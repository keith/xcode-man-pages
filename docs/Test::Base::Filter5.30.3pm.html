<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>Test::Base::Filter(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Test::Base::Filter(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Test::Base::Filter(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
Test::Base::Filter - Default Filter Class for Test::Base
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<span class="Li"></span>
<pre>
      package MyTestSuite;
      use Test::Base -Base;

      ... reusable testing code ...

      package MyTestSuite::Filter;
      use Test::Base::Filter -Base;

      sub my_filter1 {
          ...
      }
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
Filters are the key to writing effective data driven tests with Test::Base.
  Test::Base::Filter is a class containing a large default set of generic
  filters. You can easily subclass it to add/override functionality.
</section>
<section class="Sh">
<h1 class="Sh" id="FILTERS"><a class="permalink" href="#FILTERS">FILTERS</a></h1>
This is a list of the default stock filters (in alphabetic order):
<dl class="Bl-tag">
  <dt>&quot;append&quot;</dt>
  <dd>list =&gt; list
    <p class="Pp">Append a string to each element of a list.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    --- numbers lines chomp append=-#\n join
    one
    two
    three
    </pre>
  </dd>
  <dt>&quot;array&quot;</dt>
  <dd>list =&gt; scalar
    <p class="Pp">Turn a list of values into an anonymous array reference.</p>
  </dd>
  <dt>&quot;base64_decode&quot;</dt>
  <dd>scalar =&gt; scalar
    <p class="Pp">Decode base64 data. Useful for binary tests.</p>
  </dd>
  <dt>&quot;base64_encode&quot;</dt>
  <dd>scalar =&gt; scalar
    <p class="Pp">Encode base64 data. Useful for binary tests.</p>
  </dd>
  <dt>&quot;chomp&quot;</dt>
  <dd>list =&gt; list
    <p class="Pp">Remove the final newline from each string value in a list.</p>
  </dd>
  <dt>&quot;chop&quot;</dt>
  <dd></dd>
</dl>
<p class="Pp">list =&gt; list</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    Remove the final char from each string value in a list.
</pre>
<dl class="Bl-tag">
  <dt>&quot;dumper&quot;</dt>
  <dd>scalar =&gt; list
    <p class="Pp">Take a data structure (presumably from another filter like
        eval) and use Data::Dumper to dump it in a canonical fashion.</p>
  </dd>
  <dt>&quot;escape&quot;</dt>
  <dd>scalar =&gt; scalar
    <p class="Pp">Unescape all backslash escaped chars.</p>
  </dd>
  <dt>&quot;eval&quot;</dt>
  <dd>scalar =&gt; list
    <p class="Pp">Run Perl's <span class="Li">&quot;eval&quot;</span> command
        against the data and use the returned value as the data.</p>
  </dd>
  <dt>&quot;eval_all&quot;</dt>
  <dd>scalar =&gt; list
    <p class="Pp">Run Perl's <span class="Li">&quot;eval&quot;</span> command
        against the data and return a list of 4 values:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    1) The return value
    2) The error in $@
    3) Captured STDOUT
    4) Captured STDERR
    </pre>
  </dd>
  <dt>&quot;eval_stderr&quot;</dt>
  <dd>scalar =&gt; scalar
    <p class="Pp">Run Perl's <span class="Li">&quot;eval&quot;</span> command
        against the data and return the captured STDERR.</p>
  </dd>
  <dt>&quot;eval_stdout&quot;</dt>
  <dd>scalar =&gt; scalar
    <p class="Pp">Run Perl's <span class="Li">&quot;eval&quot;</span> command
        against the data and return the captured STDOUT.</p>
  </dd>
  <dt>&quot;exec_perl_stdout&quot;</dt>
  <dd>list =&gt; scalar
    <p class="Pp">Input Perl code is written to a temp file and run. STDOUT is
        captured and returned.</p>
  </dd>
  <dt>&quot;flatten&quot;</dt>
  <dd>scalar =&gt; list
    <p class="Pp">Takes a hash or array ref and flattens it to a list.</p>
  </dd>
  <dt>&quot;get_url&quot;</dt>
  <dd>scalar =&gt; scalar
    <p class="Pp">The text is chomped and considered to be a url. Then
        LWP::Simple::get is used to fetch the contents of the url.</p>
  </dd>
  <dt>&quot;hash&quot;</dt>
  <dd>list =&gt; scalar
    <p class="Pp">Turn a list of key/value pairs into an anonymous hash
        reference.</p>
  </dd>
  <dt>&quot;head[=number]&quot;</dt>
  <dd>list =&gt; list
    <p class="Pp">Takes a list and returns a number of the elements from the
        front of it. The default number is one.</p>
  </dd>
  <dt>&quot;join&quot;</dt>
  <dd>list =&gt; scalar
    <p class="Pp">Join a list of strings into a scalar.</p>
  </dd>
  <dt>&quot;Join&quot;</dt>
  <dd>Join the list of strings inside a list of array refs and return the
      strings in place of the array refs.</dd>
  <dt>&quot;lines&quot;</dt>
  <dd>scalar =&gt; list
    <p class="Pp">Break the data into an anonymous array of lines. Each line
        (except possibly the last one if the
        <span class="Li">&quot;chomp&quot;</span> filter came first) will have a
        newline at the end.</p>
  </dd>
  <dt>&quot;norm&quot;</dt>
  <dd>scalar =&gt; scalar
    <p class="Pp">Normalize the data. Change non-Unix line endings to Unix line
        endings.</p>
  </dd>
  <dt>&quot;prepend=string&quot;</dt>
  <dd>list =&gt; list
    <p class="Pp">Prepend a string onto each of a list of strings.</p>
  </dd>
  <dt>&quot;read_file&quot;</dt>
  <dd>scalar =&gt; scalar
    <p class="Pp">Read the file named by the current content and return the
        file's content.</p>
  </dd>
  <dt>&quot;regexp[=xism]&quot;</dt>
  <dd>scalar =&gt; scalar
    <p class="Pp">The <span class="Li">&quot;regexp&quot;</span> filter will
        turn your data section into a regular expression object. You can pass in
        extra flags after an equals sign.</p>
    <p class="Pp">If the text contains more than one line and no flags are
        specified, then the 'xism' flags are assumed.</p>
  </dd>
  <dt>&quot;reverse&quot;</dt>
  <dd>list =&gt; list
    <p class="Pp">Reverse the elements of a list.</p>
  </dd>
  <dt>&quot;Reverse&quot;</dt>
  <dd>list =&gt; list
    <p class="Pp">Reverse the list of strings inside a list of array refs.</p>
  </dd>
  <dt>&quot;slice=x[,y]&quot;</dt>
  <dd>list =&gt; list
    <p class="Pp">Returns the element number x through element number y of a
        list.</p>
  </dd>
  <dt>&quot;sort&quot;</dt>
  <dd>list =&gt; list
    <p class="Pp">Sorts the elements of a list in character sort order.</p>
  </dd>
  <dt>&quot;Sort&quot;</dt>
  <dd>list =&gt; list
    <p class="Pp">Sort the list of strings inside a list of array refs.</p>
  </dd>
  <dt>&quot;split[=string|pattern]&quot;</dt>
  <dd>scalar =&gt; list
    <p class="Pp">Split a string in into a list. Takes a optional string or
        regexp as a parameter. Defaults to <i>s+</i>. Same as Perl
        <span class="Li">&quot;split&quot;</span>.</p>
  </dd>
  <dt>&quot;Split[=string|pattern]&quot;</dt>
  <dd>list =&gt; list
    <p class="Pp">Split each of a list of strings and turn them into array
      refs.</p>
  </dd>
  <dt>&quot;strict&quot;</dt>
  <dd>scalar =&gt; scalar
    <p class="Pp">Prepend the string:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    use strict;
    use warnings;
    </pre>
    <p class="Pp">to the block's text.</p>
  </dd>
  <dt>&quot;tail[=number]&quot;</dt>
  <dd>list =&gt; list
    <p class="Pp">Return a number of elements from the end of a list. The
        default number is one.</p>
  </dd>
  <dt>&quot;trim&quot;</dt>
  <dd>list =&gt; list
    <p class="Pp">Remove extra blank lines from the beginning and end of the
        data. This allows you to visually separate your test data with blank
        lines.</p>
  </dd>
  <dt>&quot;unchomp&quot;</dt>
  <dd>list =&gt; list
    <p class="Pp">Add a newline to each string value in a list.</p>
  </dd>
  <dt>&quot;write_file[=filename]&quot;</dt>
  <dd>scalar =&gt; scalar
    <p class="Pp">Write the content of the section to the named file. Return the
        filename.</p>
  </dd>
  <dt>&quot;yaml&quot;</dt>
  <dd>scalar =&gt; list
    <p class="Pp">Apply the YAML::Load function to the data block and use the
        resultant structure. Requires YAML.pm.</p>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
Ingy d&#x00F6;t Net &lt;ingy@cpan.org&gt;
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT"><a class="permalink" href="#COPYRIGHT">COPYRIGHT</a></h1>
Copyright 2005-2018. Ingy d&#x00F6;t Net. All rights reserved.
<p class="Pp">This program is free software; you can redistribute it and/or
    modify it under the same terms as Perl itself.</p>
<p class="Pp">See &lt;http://www.perl.com/perl/misc/Artistic.html&gt;</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2018-04-19</td>
    <td class="foot-os">perl v5.30.2</td>
  </tr>
</table>
</body>
</html>
