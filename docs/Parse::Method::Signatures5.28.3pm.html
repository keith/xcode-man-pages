<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.10 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>Parse::Method::Signatures(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Parse::Method::Signatures(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Parse::Method::Signatures(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
Parse::Method::Signatures - Perl6 like method signature parser
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
Inspired by Perl6::Signature but streamlined to just support the subset deemed
  useful for TryCatch and MooseX::Method::Signatures.
</section>
<section class="Sh">
<h1 class="Sh" id="TODO"><a class="permalink" href="#TODO">TODO</a></h1>
<ul class="Bl-bullet">
  <li>Document the parameter return types.</li>
  <li>Probably lots of other things</li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="METHODS"><a class="permalink" href="#METHODS">METHODS</a></h1>
There are only two public methods to this module, both of which should be called
  as class methods. Both methods accept either a single (non-ref) scalar as the
  value for the &quot;input&quot; attribute, or normal new style arguments (hash
  or hash-ref).
<section class="Ss">
<h2 class="Ss" id="signature"><a class="permalink" href="#signature">signature</a></h2>
<span class="Li"></span>
<pre>
 my $sig = Parse::Method::Signatures-&gt;signature( '(Str $foo)' )
</pre>
<p class="Pp">Attempts to parse the (bracketed) method signature. Returns a
    value or croaks on error.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="param"><a class="permalink" href="#param">param</a></h2>
<span class="Li"></span>
<pre>
  my $param = Parse::Method::Signatures-&gt;param( 'Str $foo where { length($_) &lt; 10 }')
</pre>
<p class="Pp">Attempts to parse the specification for a single parameter.
    Returns value or croaks on error.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="ATTRIBUTES"><a class="permalink" href="#ATTRIBUTES">ATTRIBUTES</a></h1>
All the attributes on this class are read-only.
<section class="Ss">
<h2 class="Ss" id="input"><a class="permalink" href="#input">input</a></h2>
<b>Type:</b> Str
<p class="Pp">The string to parse.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="offset"><a class="permalink" href="#offset">offset</a></h2>
<b>Type:</b> Int
<p class="Pp">Offset into &quot;input&quot; at which to start parsing. Useful
    for using with Devel::Declare linestring</p>
</section>
<section class="Ss">
<h2 class="Ss" id="signature_class"><a class="permalink" href="#signature_class">signature_class</a></h2>
<b>Default:</b> Parse::Method::Signatures::Sig
<p class="Pp"><b>Type:</b> Str (loaded on demand class name)</p>
</section>
<section class="Ss">
<h2 class="Ss" id="param_class"><a class="permalink" href="#param_class">param_class</a></h2>
<b>Default:</b> Parse::Method::Signatures::Param
<p class="Pp"><b>Type:</b> Str (loaded on demand class name)</p>
</section>
<section class="Ss">
<h2 class="Ss" id="type_constraint_class"><a class="permalink" href="#type_constraint_class">type_constraint_class</a></h2>
<b>Default:</b> Parse::Method::Signatures::TypeConstraint
<p class="Pp"><b>Type:</b> Str (loaded on demand class name)</p>
<p class="Pp">Class that is used to turn the parsed type constraint into an
    actual Moose::Meta::TypeConstraint object.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="from_namespace"><a class="permalink" href="#from_namespace">from_namespace</a></h2>
<b>Type:</b> ClassName
<p class="Pp">Let this module know which package it is parsing signatures form.
    This is entirely optional, and the only effect is has is on parsing type
    constraints.</p>
<p class="Pp">If this attribute is set it is passed to
    &quot;type_constraint_class&quot; which can use it to introspect the package
    (commonly for MooseX::Types exported types). See
    &quot;find_registered_constraint&quot; in
    Parse::Method::Signature::TypeConstraints for more details.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="type_constraint_callback"><a class="permalink" href="#type_constraint_callback">type_constraint_callback</a></h2>
<b>Type:</b> CodeRef
<p class="Pp">Passed to the constructor of &quot;type_constraint_class&quot;.
    Default implementation of this callback asks Moose for a type constrain
    matching the name passed in. If you have more complex requirements, such as
    parsing types created by MooseX::Types then you will want a callback similar
    to this:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
 # my $target_package defined elsewhere.
 my $tc_cb = sub {
   my ($pms_tc, $name) = @_;
   my $code = $target_package-&gt;can($name);
   $code ? eval { $code-&gt;() } 
         : $pms_tc-&gt;find_registered_constraint($name);
 }
</pre>
<p class="Pp">Note that the above example is better provided by providing the
    &quot;from_namespace&quot; attribute.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="CAVEATS"><a class="permalink" href="#CAVEATS">CAVEATS</a></h1>
Like Perl6::Signature, the parsing of certain constructs is currently only a
  'best effort' - specifically default values and where code blocks might not
  successfully for certain complex cases. Patches/Failing tests welcome.
<p class="Pp">Additionally, default value specifications are not evaluated which
    means that no such lexical or similar errors will not be produced by this
    module. Constant folding will also not be performed.</p>
<p class="Pp">There are certain constructs that are simply too much hassle to
    avoid when the work around is simple. Currently the only cases that are
    known to parse wrong are when using anonymous variables (i.e. just sigils)
    in unpacked arrays. Take the following example:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
 method foo (ArrayRef [$, $], $some_value_we_care_about) {
</pre>
<p class="Pp">In this case the <span class="Li">$]</span> is treated as one of
    perl's magic variables (specifically, the patch level of the Perl
    interpreter) rather than a <span class="Li">&quot;$&quot;</span> followed by
    a <span class="Li">&quot;]&quot;</span> as was almost certainly intended.
    The work around for this is simple: introduce a space between the
    characters:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
 method foo (ArrayRef [ $, $ ], $some_value_we_care_about) {
</pre>
<p class="Pp">The same applies</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
Ash Berlin &lt;ash@cpan.org&gt;.
<p class="Pp">Thanks to Florian Ragwitz &lt;rafl@debian.org&gt;.</p>
<p class="Pp">Many thanks to Piers Cawley to showing me the way to refactor my
    spaghetti code into something more manageable.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
Devel::Declare which is used by most modules that use this (currently by all
  modules known to the author.)
<p class="Pp">&lt;http://github.com/ashb/trycatch/tree&gt;.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="LICENSE"><a class="permalink" href="#LICENSE">LICENSE</a></h1>
Licensed under the same terms as Perl itself.
<p class="Pp">This distribution copyright 2008-2009, Ash Berlin
    &lt;ash@cpan.org&gt;</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2017-04-09</td>
    <td class="foot-os">perl v5.28.2</td>
  </tr>
</table>
</body>
</html>
