<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>Moose::Manual::BestPractices(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Moose::Manual::BestPractices(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Moose::Manual::BestPractices(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
Moose::Manual::BestPractices - Get the most out of Moose
</section>
<section class="Sh">
<h1 class="Sh" id="VERSION"><a class="permalink" href="#VERSION">VERSION</a></h1>
version 2.1202
</section>
<section class="Sh">
<h1 class="Sh" id="RECOMMENDATIONS"><a class="permalink" href="#RECOMMENDATIONS">RECOMMENDATIONS</a></h1>
Moose has a lot of features, and there's definitely more than one way to do it.
  However, we think that picking a subset of these features and using them
  consistently makes everyone's life easier.
<p class="Pp">Of course, as with any list of &quot;best practices&quot;, these
    are really just opinions. Feel free to ignore us.</p>
<section class="Ss">
<h2 class="Ss" id="_namespace::autoclean__and_immutabilize"><a class="permalink" href="#_namespace::autoclean__and_immutabilize">&quot;namespace::autoclean&quot;
  and immutabilize</a></h2>
We recommend that you remove the Moose sugar and end your Moose class
  definitions by making your class immutable.
<p class="Pp"><span class="Li"></span></p>
<pre>
  package Person;

  use Moose;
  use namespace::autoclean;

  # extends, roles, attributes, etc.

  # methods

  __PACKAGE__-&gt;meta-&gt;make_immutable;

  1;
</pre>
<p class="Pp">The <span class="Li">&quot;use namespace::autoclean&quot;</span>
    bit is simply good code hygiene, as it removes imported symbols from your
    class's namespace at the end of your package's compile cycle, including
    Moose keywords. Once the class has been built, these keywords are not
    needed. (This is preferred to placing <span class="Li">&quot;no
    Moose&quot;</span> at the end of your package).</p>
<p class="Pp">The <span class="Li">&quot;make_immutable&quot;</span> call allows
    Moose to speed up a lot of things, most notably object construction. The
    trade-off is that you can no longer change the class definition.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Never_override__new_"><a class="permalink" href="#Never_override__new_">Never
  override &quot;new&quot;</a></h2>
Overriding <span class="Li">&quot;new&quot;</span> is a very bad practice.
  Instead, you should use a <span class="Li">&quot;BUILD&quot;</span> or
  <span class="Li">&quot;BUILDARGS&quot;</span> methods to do the same thing.
  When you override <span class="Li">&quot;new&quot;</span>, Moose can no longer
  inline a constructor when your class is immutabilized.
<p class="Pp">There are two good reasons to override
    <span class="Li">&quot;new&quot;</span>. One, you are writing a MooseX
    extension that provides its own Moose::Object subclass <i>and</i> a subclass
    of Moose::Meta::Method::Constructor to inline the constructor. Two, you are
    subclassing a non-Moose parent.</p>
<p class="Pp">If you know how to do that, you know when to ignore this best
    practice ;)</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Always_call_the_original/parent__BUILDARGS_"><a class="permalink" href="#Always_call_the_original/parent__BUILDARGS_">Always
  call the original/parent &quot;BUILDARGS&quot;</a></h2>
If you <span class="Li">&quot;override&quot;</span> the
  <span class="Li">&quot;BUILDARGS&quot;</span> method in your class, make sure
  to play nice and call <span class="Li">&quot;super()&quot;</span> to handle
  cases you're not checking for explicitly.
<p class="Pp">The default <span class="Li">&quot;BUILDARGS&quot;</span> method
    in Moose::Object handles both a list and hashref of named parameters
    correctly, and also checks for a <i>non-hashref</i> single argument.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Provide_defaults_whenever_possible,_otherwise_use__required_"><a class="permalink" href="#Provide_defaults_whenever_possible,_otherwise_use__required_">Provide
  defaults whenever possible, otherwise use &quot;required&quot;</a></h2>
When your class provides defaults, this makes constructing new objects simpler.
  If you cannot provide a default, consider making the attribute
  <span class="Li">&quot;required&quot;</span>.
<p class="Pp">If you don't do either, an attribute can simply be left unset,
    increasing the complexity of your object, because it has more possible
    states that you or the user of your class must account for.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Use__builder__instead_of__default__most_of_the_time"><a class="permalink" href="#Use__builder__instead_of__default__most_of_the_time">Use
  &quot;builder&quot; instead of &quot;default&quot; most of the time</a></h2>
Builders can be inherited, they have explicit names, and they're just plain
  cleaner.
<p class="Pp">However, <i>do</i> use a default when the default is a
    non-reference, <i>or</i> when the default is simply an empty reference of
    some sort.</p>
<p class="Pp">Also, keep your builder methods private.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Be__lazy_"><a class="permalink" href="#Be__lazy_">Be
  &quot;lazy&quot;</a></h2>
Lazy is good, and often solves initialization ordering problems. It's also good
  for deferring work that may never have to be done. Make your attributes
  <span class="Li">&quot;lazy&quot;</span> unless they're
  <span class="Li">&quot;required&quot;</span> or have trivial defaults.
</section>
<section class="Ss">
<h2 class="Ss" id="Consider_keeping_clearers_and_predicates_private"><a class="permalink" href="#Consider_keeping_clearers_and_predicates_private">Consider
  keeping clearers and predicates private</a></h2>
Does everyone <i>really</i> need to be able to clear an attribute? Probably not.
  Don't expose this functionality outside your class by default.
<p class="Pp">Predicates are less problematic, but there's no reason to make
    your public API bigger than it has to be.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Avoid__lazy_build_"><a class="permalink" href="#Avoid__lazy_build_">Avoid
  &quot;lazy_build&quot;</a></h2>
As described above, you rarely actually need a clearer or a predicate.
  <span class="Li">&quot;lazy_build&quot;</span> adds both to your public API,
  which exposes you to use cases that you must now test for. It's much better to
  avoid adding them until you really need them - use explicit
  <span class="Li">&quot;lazy&quot;</span> and
  <span class="Li">&quot;builder&quot;</span> options instead.
</section>
<section class="Ss">
<h2 class="Ss" id="Default_to_read-only,_and_consider_keeping_writers_private"><a class="permalink" href="#Default_to_read-only,_and_consider_keeping_writers_private">Default
  to read-only, and consider keeping writers private</a></h2>
Making attributes mutable just means more complexity to account for in your
  program. The alternative to mutable state is to encourage users of your class
  to simply make new objects as needed.
<p class="Pp">If you <i>must</i> make an attribute read-write, consider making
    the writer a separate private method. Narrower APIs are easy to maintain,
    and mutable state is trouble.</p>
<p class="Pp">In order to declare such attributes, provide a private
    <span class="Li">&quot;writer&quot;</span> parameter:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    has pizza =&gt; (
        is     =&gt; 'ro',
        isa    =&gt; 'Pizza',
        writer =&gt; '_pizza',
    );
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Think_twice_before_changing_an_attribute's_type_in_a_subclass"><a class="permalink" href="#Think_twice_before_changing_an_attribute's_type_in_a_subclass">Think
  twice before changing an attribute's type in a subclass</a></h2>
Down this path lies great confusion. If the attribute is an object itself, at
  least make sure that it has the same interface as the type of object in the
  parent class.
</section>
<section class="Ss">
<h2 class="Ss" id="Don't_use_the__initializer__feature"><a class="permalink" href="#Don't_use_the__initializer__feature">Don't
  use the &quot;initializer&quot; feature</a></h2>
Don't know what we're talking about? That's fine.
</section>
<section class="Ss">
<h2 class="Ss" id="Use_Moose::Meta::Attribute::Native_traits_instead_of__auto_deref_"><a class="permalink" href="#Use_Moose::Meta::Attribute::Native_traits_instead_of__auto_deref_">Use
  Moose::Meta::Attribute::Native traits instead of
  &quot;auto_deref&quot;</a></h2>
The <span class="Li">&quot;auto_deref&quot;</span> feature is a bit troublesome.
  Directly exposing a complex attribute is ugly. Instead, consider using
  Moose::Meta::Attribute::Native traits to define an API that only exposes the
  necessary pieces of functionality.
</section>
<section class="Ss">
<h2 class="Ss" id="Always_call__inner__in_the_most_specific_subclass"><a class="permalink" href="#Always_call__inner__in_the_most_specific_subclass">Always
  call &quot;inner&quot; in the most specific subclass</a></h2>
When using <span class="Li">&quot;augment&quot;</span> and
  <span class="Li">&quot;inner&quot;</span>, we recommend that you call
  <span class="Li">&quot;inner&quot;</span> in the most specific subclass of
  your hierarchy. This makes it possible to subclass further and extend the
  hierarchy without changing the parents.
</section>
<section class="Ss">
<h2 class="Ss" id="Namespace_your_types"><a class="permalink" href="#Namespace_your_types">Namespace
  your types</a></h2>
Use some sort of namespacing convention for type names. We recommend something
  like &quot;MyApp::Type::Foo&quot;. We also recommend considering
  MooseX::Types.
</section>
<section class="Ss">
<h2 class="Ss" id="Do_not_coerce_Moose_built-ins_directly"><a class="permalink" href="#Do_not_coerce_Moose_built-ins_directly">Do
  not coerce Moose built-ins directly</a></h2>
If you define a coercion for a Moose built-in like
  <span class="Li">&quot;ArrayRef&quot;</span>, this will affect every
  application in the Perl interpreter that uses this type.
<p class="Pp"><span class="Li"></span></p>
<pre>
    # very naughty!
    coerce 'ArrayRef'
        =&gt; from Str
        =&gt; via { [ split /,/ ] };
</pre>
<p class="Pp">Instead, create a subtype and coerce that:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    subtype 'My::ArrayRef' =&gt; as 'ArrayRef';

    coerce 'My::ArrayRef'
        =&gt; from 'Str'
        =&gt; via { [ split /,/ ] };
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Do_not_coerce_class_names_directly"><a class="permalink" href="#Do_not_coerce_class_names_directly">Do
  not coerce class names directly</a></h2>
Just as with Moose built-in types, a class type is global for the entire
  interpreter. If you add a coercion for that class name, it can have magical
  side effects elsewhere:
<p class="Pp"><span class="Li"></span></p>
<pre>
    # also very naughty!
    coerce 'HTTP::Headers'
        =&gt; from 'HashRef'
        =&gt; via { HTTP::Headers-&gt;new( %{$_} ) };
</pre>
<p class="Pp">Instead, we can create an &quot;empty&quot; subtype for the
    coercion:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    subtype 'My::HTTP::Headers' =&gt; as class_type('HTTP::Headers');

    coerce 'My::HTTP::Headers'
        =&gt; from 'HashRef'
        =&gt; via { HTTP::Headers-&gt;new( %{$_} ) };
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Use_coercion_instead_of_unions"><a class="permalink" href="#Use_coercion_instead_of_unions">Use
  coercion instead of unions</a></h2>
Consider using a type coercion instead of a type union. This was covered in
  Moose::Manual::Types.
</section>
<section class="Ss">
<h2 class="Ss" id="Define_all_your_types_in_one_module"><a class="permalink" href="#Define_all_your_types_in_one_module">Define
  all your types in one module</a></h2>
Define all your types and coercions in one module. This was also covered in
  Moose::Manual::Types.
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="BENEFITS_OF_BEST_PRACTICES"><a class="permalink" href="#BENEFITS_OF_BEST_PRACTICES">BENEFITS
  OF BEST PRACTICES</a></h1>
Following these practices has a number of benefits.
<p class="Pp">It helps ensure that your code will play nice with others, making
    it more reusable and easier to extend.</p>
<p class="Pp">Following an accepted set of idioms will make maintenance easier,
    especially when someone else has to maintain your code. It will also make it
    easier to get support from other Moose users, since your code will be easier
    to digest quickly.</p>
<p class="Pp">Some of these practices are designed to help Moose do the right
    thing, especially when it comes to immutabilization. This means your code
    will be faster when immutabilized.</p>
<p class="Pp">Many of these practices also help get the most out of meta
    programming. If you used an overridden
    <span class="Li">&quot;new&quot;</span> to do type coercion by hand, rather
    than defining a real coercion, there is no introspectable metadata. This
    sort of thing is particularly problematic for MooseX extensions which rely
    on introspection to do the right thing.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHORS"><a class="permalink" href="#AUTHORS">AUTHORS</a></h1>
<ul class="Bl-bullet">
  <li>Stevan Little &lt;stevan.little@iinteractive.com&gt;</li>
  <li>Dave Rolsky &lt;autarch@urth.org&gt;</li>
  <li>Jesse Luehrs &lt;doy@tozt.net&gt;</li>
  <li>Shawn M Moore &lt;code@sartak.org&gt;</li>
  <li>XXXX XXX'XX (Yuval Kogman) &lt;nothingmuch@woobling.org&gt;</li>
  <li>Karen Etheridge &lt;ether@cpan.org&gt;</li>
  <li>Florian Ragwitz &lt;rafl@debian.org&gt;</li>
  <li>Hans Dieter Pearcey &lt;hdp@weftsoar.net&gt;</li>
  <li>Chris Prather &lt;chris@prather.org&gt;</li>
  <li>Matt S Trout &lt;mst@shadowcat.co.uk&gt;</li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT_AND_LICENSE"><a class="permalink" href="#COPYRIGHT_AND_LICENSE">COPYRIGHT
  AND LICENSE</a></h1>
This software is copyright (c) 2006 by Infinity Interactive, Inc..
<p class="Pp">This is free software; you can redistribute it and/or modify it
    under the same terms as the Perl 5 programming language system itself.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2014-01-19</td>
    <td class="foot-os">perl v5.18.2</td>
  </tr>
</table>
</body>
</html>
