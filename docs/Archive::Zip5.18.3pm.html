<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>Archive::Zip(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Archive::Zip(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Archive::Zip(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
Archive::Zip - Provide an interface to ZIP archive files.
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<span class="Li"></span>
<pre>
   # Create a Zip file
   use Archive::Zip qw( :ERROR_CODES :CONSTANTS );
   my $zip = Archive::Zip-&gt;new();

   # Add a directory
   my $dir_member = $zip-&gt;addDirectory( 'dirname/' );

   # Add a file from a string with compression
   my $string_member = $zip-&gt;addString( 'This is a test', 'stringMember.txt' );
   $string_member-&gt;desiredCompressionMethod( COMPRESSION_DEFLATED );

   # Add a file from disk
   my $file_member = $zip-&gt;addFile( 'xyz.pl', 'AnotherName.pl' );

   # Save the Zip file
   unless ( $zip-&gt;writeToFileNamed('someZip.zip') == AZ_OK ) {
       die 'write error';
   }

   # Read a Zip file
   my $somezip = Archive::Zip-&gt;new();
   unless ( $somezip-&gt;read( 'someZip.zip' ) == AZ_OK ) {
       die 'read error';
   }

   # Change the compression type for a file in the Zip
   my $member = $somezip-&gt;memberNamed( 'stringMember.txt' );
   $member-&gt;desiredCompressionMethod( COMPRESSION_STORED );
   unless ( $zip-&gt;writeToFileNamed( 'someOtherZip.zip' ) == AZ_OK ) {
       die 'write error';
   }
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
The Archive::Zip module allows a Perl program to create, manipulate, read, and
  write Zip archive files.
<p class="Pp">Zip archives can be created, or you can read from existing zip
    files.</p>
<p class="Pp">Once created, they can be written to files, streams, or strings.
    Members can be added, removed, extracted, replaced, rearranged, and
    enumerated. They can also be renamed or have their dates, comments, or other
    attributes queried or modified. Their data can be compressed or uncompressed
    as needed.</p>
<p class="Pp">Members can be created from members in existing Zip files, or from
    existing directories, files, or strings.</p>
<p class="Pp">This module uses the Compress::Raw::Zlib library to read and write
    the compressed streams inside the files.</p>
<p class="Pp">One can use Archive::Zip::MemberRead to read the zip file archive
    members as if they were files.</p>
<section class="Ss">
<h2 class="Ss" id="File_Naming"><a class="permalink" href="#File_Naming">File
  Naming</a></h2>
Regardless of what your local file system uses for file naming, names in a Zip
  file are in Unix format (<i>forward</i> slashes (/) separating directory
  names, etc.).
<p class="Pp"><span class="Li">&quot;Archive::Zip&quot;</span> tries to be
    consistent with file naming conventions, and will translate back and forth
    between native and Zip file names.</p>
<p class="Pp">However, it can't guess which format names are in. So two rules
    control what kind of file name you must pass various routines:</p>
<dl class="Bl-tag">
  <dt>Names of files are in local format.</dt>
  <dd><span class="Li">&quot;File::Spec&quot;</span> and
      <span class="Li">&quot;File::Basename&quot;</span> are used for various
      file operations. When you're referring to a file on your system, use its
      file naming conventions.</dd>
  <dt>Names of archive members are in Unix format.</dt>
  <dd>This applies to every method that refers to an archive member, or provides
      a name for new archive members. The
      <span class="Li">&quot;extract()&quot;</span> methods that can take one or
      two names will convert from local to zip names if you call them with a
      single name.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Archive::Zip_Object_Model"><a class="permalink" href="#Archive::Zip_Object_Model">Archive::Zip
  Object Model</a></h2>
<i>Overview</i>
<p class="Pp">Archive::Zip::Archive objects are what you ordinarily deal with.
    These maintain the structure of a zip file, without necessarily holding
    data. When a zip is read from a disk file, the (possibly compressed) data
    still lives in the file, not in memory. Archive members hold information
    about the individual members, but not (usually) the actual member data. When
    the zip is written to a (different) file, the member data is compressed or
    copied as needed. It is possible to make archive members whose data is held
    in a string in memory, but this is not done when a zip file is read.
    Directory members don't have any data.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Inheritance"><a class="permalink" href="#Inheritance">Inheritance</a></h2>
<span class="Li"></span>
<pre>
  Exporter
   Archive::Zip                            Common base class, has defs.
       Archive::Zip::Archive               A Zip archive.
       Archive::Zip::Member                Abstract superclass for all members.
           Archive::Zip::StringMember      Member made from a string
           Archive::Zip::FileMember        Member made from an external file
               Archive::Zip::ZipFileMember Member that lives in a zip file
               Archive::Zip::NewFileMember Member whose data is in a file
           Archive::Zip::DirectoryMember   Member that is a directory
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="EXPORTS"><a class="permalink" href="#EXPORTS">EXPORTS</a></h1>
<dl class="Bl-tag">
  <dt>:CONSTANTS</dt>
  <dd>Exports the following constants:
    <p class="Pp">FA_MSDOS FA_UNIX GPBF_ENCRYPTED_MASK
        GPBF_DEFLATING_COMPRESSION_MASK GPBF_HAS_DATA_DESCRIPTOR_MASK
        COMPRESSION_STORED COMPRESSION_DEFLATED IFA_TEXT_FILE_MASK IFA_TEXT_FILE
        IFA_BINARY_FILE COMPRESSION_LEVEL_NONE COMPRESSION_LEVEL_DEFAULT
        COMPRESSION_LEVEL_FASTEST COMPRESSION_LEVEL_BEST_COMPRESSION</p>
  </dd>
  <dt>:MISC_CONSTANTS</dt>
  <dd>Exports the following constants (only necessary for extending the module):
    <p class="Pp">FA_AMIGA FA_VAX_VMS FA_VM_CMS FA_ATARI_ST FA_OS2_HPFS
        FA_MACINTOSH FA_Z_SYSTEM FA_CPM FA_WINDOWS_NTFS
        GPBF_IMPLODING_8K_SLIDING_DICTIONARY_MASK
        GPBF_IMPLODING_3_SHANNON_FANO_TREES_MASK
        GPBF_IS_COMPRESSED_PATCHED_DATA_MASK COMPRESSION_SHRUNK
        DEFLATING_COMPRESSION_NORMAL DEFLATING_COMPRESSION_MAXIMUM
        DEFLATING_COMPRESSION_FAST DEFLATING_COMPRESSION_SUPER_FAST
        COMPRESSION_REDUCED_1 COMPRESSION_REDUCED_2 COMPRESSION_REDUCED_3
        COMPRESSION_REDUCED_4 COMPRESSION_IMPLODED COMPRESSION_TOKENIZED
        COMPRESSION_DEFLATED_ENHANCED
        COMPRESSION_PKWARE_DATA_COMPRESSION_LIBRARY_IMPLODED</p>
  </dd>
  <dt>:ERROR_CODES</dt>
  <dd>Explained below. Returned from most methods.
    <p class="Pp">AZ_OK AZ_STREAM_END AZ_ERROR AZ_FORMAT_ERROR AZ_IO_ERROR</p>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="ERROR_CODES"><a class="permalink" href="#ERROR_CODES">ERROR
  CODES</a></h1>
Many of the methods in Archive::Zip return error codes. These are implemented as
  inline subroutines, using the <span class="Li">&quot;use constant&quot;</span>
  pragma. They can be imported into your namespace using the
  <span class="Li">&quot;:ERROR_CODES&quot;</span> tag:
<p class="Pp"><span class="Li"></span></p>
<pre>
  use Archive::Zip qw( :ERROR_CODES );

  ...

  unless ( $zip-&gt;read( 'myfile.zip' ) == AZ_OK ) {
      die &quot;whoops!&quot;;
  }
</pre>
<dl class="Bl-tag">
  <dt>AZ_OK <i>s0</i>(0)</dt>
  <dd>Everything is fine.</dd>
  <dt>AZ_STREAM_END <i>s0</i>(1)</dt>
  <dd>The read stream (or central directory) ended normally.</dd>
  <dt>AZ_ERROR <i>s0</i>(2)</dt>
  <dd>There was some generic kind of error.</dd>
  <dt>AZ_FORMAT_ERROR <i>s0</i>(3)</dt>
  <dd>There is a format error in a ZIP file being read.</dd>
  <dt>AZ_IO_ERROR <i>s0</i>(4)</dt>
  <dd>There was an IO error.</dd>
</dl>
<section class="Ss">
<h2 class="Ss" id="Compression"><a class="permalink" href="#Compression">Compression</a></h2>
Archive::Zip allows each member of a ZIP file to be compressed (using the
  Deflate algorithm) or uncompressed.
<p class="Pp">Other compression algorithms that some versions of ZIP have been
    able to produce are not supported. Each member has two compression methods:
    the one it's stored as (this is always COMPRESSION_STORED for string and
    external file members), and the one you desire for the member in the zip
    file.</p>
<p class="Pp">These can be different, of course, so you can make a zip member
    that is not compressed out of one that is, and vice versa.</p>
<p class="Pp">You can inquire about the current compression and set the desired
    compression method:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  my $member = $zip-&gt;memberNamed( 'xyz.txt' );
  $member-&gt;compressionMethod();    # return current compression

  # set to read uncompressed
  $member-&gt;desiredCompressionMethod( COMPRESSION_STORED );

  # set to read compressed
  $member-&gt;desiredCompressionMethod( COMPRESSION_DEFLATED );
</pre>
<p class="Pp">There are two different compression methods:</p>
<dl class="Bl-tag">
  <dt>COMPRESSION_STORED</dt>
  <dd>File is stored (no compression)</dd>
  <dt>COMPRESSION_DEFLATED</dt>
  <dd>File is Deflated</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Compression_Levels"><a class="permalink" href="#Compression_Levels">Compression
  Levels</a></h2>
If a member's desiredCompressionMethod is COMPRESSION_DEFLATED, you can choose
  different compression levels. This choice may affect the speed of compression
  and decompression, as well as the size of the compressed member data.
<p class="Pp"><span class="Li"></span></p>
<pre>
  $member-&gt;desiredCompressionLevel( 9 );
</pre>
<p class="Pp">The levels given can be:</p>
<ul class="Bl-bullet">
  <li>0 or COMPRESSION_LEVEL_NONE
    <p class="Pp">This is the same as saying</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  $member-&gt;desiredCompressionMethod( COMPRESSION_STORED );
    </pre>
  </li>
  <li>1 .. 9
    <p class="Pp">1 gives the best speed and worst compression, and 9 gives the
        best compression and worst speed.</p>
  </li>
  <li>COMPRESSION_LEVEL_FASTEST
    <p class="Pp">This is a synonym for level 1.</p>
  </li>
  <li>COMPRESSION_LEVEL_BEST_COMPRESSION
    <p class="Pp">This is a synonym for level 9.</p>
  </li>
  <li>COMPRESSION_LEVEL_DEFAULT
    <p class="Pp">This gives a good compromise between speed and compression,
        and is currently equivalent to 6 (this is in the zlib code). This is the
        level that will be used if not specified.</p>
  </li>
</ul>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="Archive::Zip_Methods"><a class="permalink" href="#Archive::Zip_Methods">Archive::Zip
  Methods</a></h1>
The Archive::Zip class (and its invisible subclass Archive::Zip::Archive)
  implement generic zip file functionality. Creating a new Archive::Zip object
  actually makes an Archive::Zip::Archive object, but you don't have to worry
  about this unless you're subclassing.
<section class="Ss">
<h2 class="Ss" id="Constructor"><a class="permalink" href="#Constructor">Constructor</a></h2>
<dl class="Bl-tag">
  <dt>new( [$fileName] )</dt>
  <dd></dd>
  <dt>new( { filename =&gt; $fileName } )</dt>
  <dd>Make a new, empty zip archive.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    my $zip = Archive::Zip-&gt;new();
    </pre>
    <p class="Pp">If an additional argument is passed, <i>new()</i> will call
        <i>read()</i> to read the contents of an archive:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    my $zip = Archive::Zip-&gt;new( 'xyz.zip' );
    </pre>
    <p class="Pp">If a filename argument is passed and the read fails for any
        reason, new will return undef. For this reason, it may be better to call
        read separately.</p>
  </dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Zip_Archive_Utility_Methods"><a class="permalink" href="#Zip_Archive_Utility_Methods">Zip
  Archive Utility Methods</a></h2>
These Archive::Zip methods may be called as functions or as object methods. Do
  not call them as class methods:
<p class="Pp"><span class="Li"></span></p>
<pre>
    $zip = Archive::Zip-&gt;new();
    $crc = Archive::Zip::computeCRC32( 'ghijkl' );    # OK
    $crc = $zip-&gt;computeCRC32( 'ghijkl' );            # also OK
    $crc = Archive::Zip-&gt;computeCRC32( 'ghijkl' );    # NOT OK
</pre>
<dl class="Bl-tag">
  <dt>Archive::Zip::computeCRC32( $string [, $crc] )</dt>
  <dd></dd>
  <dt>Archive::Zip::computeCRC32( { string =&gt; $string [, checksum =&gt; $crc
    ] } )</dt>
  <dd>This is a utility function that uses the Compress::Raw::Zlib CRC routine
      to compute a CRC-32. You can get the CRC of a string:
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    $crc = Archive::Zip::computeCRC32( $string );
    </pre>
    <p class="Pp">Or you can compute the running CRC:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    $crc = 0;
    $crc = Archive::Zip::computeCRC32( 'abcdef', $crc );
    $crc = Archive::Zip::computeCRC32( 'ghijkl', $crc );
    </pre>
  </dd>
  <dt>Archive::Zip::setChunkSize( $number )</dt>
  <dd></dd>
  <dt>Archive::Zip::setChunkSize( { chunkSize =&gt; $number } )</dt>
  <dd>Report or change chunk size used for reading and writing. This can make
      big differences in dealing with large files. Currently, this defaults to
      32K. This also changes the chunk size used for Compress::Raw::Zlib. You
      must call <i>setChunkSize()</i> before reading or writing. This is not
      exportable, so you must call it like:
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    Archive::Zip::setChunkSize( 4096 );
    </pre>
    <p class="Pp">or as a method on a zip (though this is a global setting).
        Returns old chunk size.</p>
  </dd>
  <dt><i>Archive::Zip::chunkSize()</i></dt>
  <dd>Returns the current chunk size:
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    my $chunkSize = Archive::Zip::chunkSize();
    </pre>
  </dd>
  <dt>Archive::Zip::setErrorHandler( \&amp;subroutine )</dt>
  <dd></dd>
  <dt>Archive::Zip::setErrorHandler( { subroutine =&gt; \&amp;subroutine }
    )</dt>
  <dd>Change the subroutine called with error strings. This defaults to
      \&amp;Carp::carp, but you may want to change it to get the error strings.
      This is not exportable, so you must call it like:
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    Archive::Zip::setErrorHandler( \&amp;myErrorHandler );
    </pre>
    <p class="Pp">If myErrorHandler is undef, resets handler to default. Returns
        old error handler. Note that if you call Carp::carp or a similar routine
        or if you're chaining to the default error handler from your error
        handler, you may want to increment the number of caller levels that are
        skipped (do not just set it to a number):</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    $Carp::CarpLevel++;
    </pre>
  </dd>
  <dt>Archive::Zip::tempFile( [ $tmpdir ] )</dt>
  <dd></dd>
  <dt>Archive::Zip::tempFile( { tempDir =&gt; $tmpdir } )</dt>
  <dd>Create a uniquely named temp file. It will be returned open for
      read/write. If <span class="Li">$tmpdir</span> is given, it is used as the
      name of a directory to create the file in. If not given, creates the file
      using <span class="Li">&quot;File::Spec::tmpdir()&quot;</span>. Generally,
      you can override this choice using the
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    $ENV{TMPDIR}
    </pre>
    <p class="Pp">environment variable. But see the File::Spec documentation for
        your system. Note that on many systems, if you're running in taint mode,
        then you must make sure that <span class="Li">$ENV{TMPDIR}</span> is
        untainted for it to be used. Will <i>NOT</i> create
        <span class="Li">$tmpdir</span> if it does not exist (this is a change
        from prior versions!). Returns file handle and name:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    my ($fh, $name) = Archive::Zip::tempFile();
    my ($fh, $name) = Archive::Zip::tempFile('myTempDir');
    my $fh = Archive::Zip::tempFile();  # if you don't need the name
    </pre>
  </dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Zip_Archive_Accessors"><a class="permalink" href="#Zip_Archive_Accessors">Zip
  Archive Accessors</a></h2>
<dl class="Bl-tag">
  <dt><i>members()</i></dt>
  <dd>Return a copy of the members array
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    my @members = $zip-&gt;members();
    </pre>
  </dd>
  <dt><i>numberOfMembers()</i></dt>
  <dd>Return the number of members I have</dd>
  <dt><i>memberNames()</i></dt>
  <dd>Return a list of the (internal) file names of the zip members</dd>
  <dt>memberNamed( $string )</dt>
  <dd></dd>
  <dt>memberNamed( { zipName =&gt; $string } )</dt>
  <dd>Return ref to member whose filename equals given filename or undef.
      <span class="Li">$string</span> must be in Zip (Unix) filename
    format.</dd>
  <dt>membersMatching( $regex )</dt>
  <dd></dd>
  <dt>membersMatching( { regex =&gt; $regex } )</dt>
  <dd>Return array of members whose filenames match given regular expression in
      list context. Returns number of matching members in scalar context.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    my @textFileMembers = $zip-&gt;membersMatching( '.*\.txt' );
    # or
    my $numberOfTextFiles = $zip-&gt;membersMatching( '.*\.txt' );
    </pre>
  </dd>
  <dt><i>diskNumber()</i></dt>
  <dd>Return the disk that I start on. Not used for writing zips, but might be
      interesting if you read a zip in. This should be 0, as Archive::Zip does
      not handle multi-volume archives.</dd>
  <dt><i>diskNumberWithStartOfCentralDirectory()</i></dt>
  <dd>Return the disk number that holds the beginning of the central directory.
      Not used for writing zips, but might be interesting if you read a zip in.
      This should be 0, as Archive::Zip does not handle multi-volume
    archives.</dd>
  <dt><i>numberOfCentralDirectoriesOnThisDisk()</i></dt>
  <dd>Return the number of CD structures in the zipfile last read in. Not used
      for writing zips, but might be interesting if you read a zip in.</dd>
  <dt><i>numberOfCentralDirectories()</i></dt>
  <dd>Return the number of CD structures in the zipfile last read in. Not used
      for writing zips, but might be interesting if you read a zip in.</dd>
  <dt><i>centralDirectorySize()</i></dt>
  <dd>Returns central directory size, as read from an external zip file. Not
      used for writing zips, but might be interesting if you read a zip in.</dd>
  <dt><i>centralDirectoryOffsetWRTStartingDiskNumber()</i></dt>
  <dd>Returns the offset into the zip file where the CD begins. Not used for
      writing zips, but might be interesting if you read a zip in.</dd>
  <dt>zipfileComment( [ $string ] )</dt>
  <dd></dd>
  <dt>zipfileComment( [ { comment =&gt; $string } ] )</dt>
  <dd>Get or set the zipfile comment. Returns the old comment.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    print $zip-&gt;zipfileComment();
    $zip-&gt;zipfileComment( 'New Comment' );
    </pre>
  </dd>
  <dt><i>eocdOffset()</i></dt>
  <dd>Returns the (unexpected) number of bytes between where the EOCD was found
      and where it expected to be. This is normally 0, but would be positive if
      something (a virus, perhaps) had added bytes somewhere before the EOCD.
      Not used for writing zips, but might be interesting if you read a zip in.
      Here is an example of how you can diagnose this:
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  my $zip = Archive::Zip-&gt;new('somefile.zip');
  if ($zip-&gt;eocdOffset())
  {
    warn &quot;A virus has added &quot;, $zip-&gt;eocdOffset, &quot; bytes of garbage\n&quot;;
  }
    </pre>
    <p class="Pp">The <span class="Li">&quot;eocdOffset()&quot;</span> is used
        to adjust the starting position of member headers, if necessary.</p>
  </dd>
  <dt><i>fileName()</i></dt>
  <dd>Returns the name of the file last read from. If nothing has been read yet,
      returns an empty string; if read from a file handle, returns the handle in
      string form.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Zip_Archive_Member_Operations"><a class="permalink" href="#Zip_Archive_Member_Operations">Zip
  Archive Member Operations</a></h2>
Various operations on a zip file modify members. When a member is passed as an
  argument, you can either use a reference to the member itself, or the name of
  a member. Of course, using the name requires that names be unique within a zip
  (this is not enforced).
<dl class="Bl-tag">
  <dt>removeMember( $memberOrName )</dt>
  <dd></dd>
  <dt>removeMember( { memberOrZipName =&gt; $memberOrName } )</dt>
  <dd>Remove and return the given member, or match its name and remove it.
      Returns undef if member or name does not exist in this Zip. No-op if
      member does not belong to this zip.</dd>
  <dt>replaceMember( $memberOrName, $newMember )</dt>
  <dd></dd>
  <dt>replaceMember( { memberOrZipName =&gt; $memberOrName, newMember =&gt;
    $newMember } )</dt>
  <dd>Remove and return the given member, or match its name and remove it.
      Replace with new member. Returns undef if member or name does not exist in
      this Zip, or if <span class="Li">$newMember</span> is undefined.
    <p class="Pp">It is an (undiagnosed) error to provide a
        <span class="Li">$newMember</span> that is a member of the zip being
        modified.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    my $member1 = $zip-&gt;removeMember( 'xyz' );
    my $member2 = $zip-&gt;replaceMember( 'abc', $member1 );
    # now, $member2 (named 'abc') is not in $zip,
    # and $member1 (named 'xyz') is, having taken $member2's place.
    </pre>
  </dd>
  <dt>extractMember( $memberOrName [, $extractedName ] )</dt>
  <dd></dd>
  <dt>extractMember( { memberOrZipName =&gt; $memberOrName [, name =&gt;
    $extractedName ] } )</dt>
  <dd>Extract the given member, or match its name and extract it. Returns undef
      if member does not exist in this Zip. If optional second arg is given, use
      it as the name of the extracted member. Otherwise, the internal filename
      of the member is used as the name of the extracted file or directory. If
      you pass <span class="Li">$extractedName</span>, it should be in the local
      file system's format. All necessary directories will be created. Returns
      <span class="Li">&quot;AZ_OK&quot;</span> on success.</dd>
  <dt>extractMemberWithoutPaths( $memberOrName [, $extractedName ] )</dt>
  <dd></dd>
  <dt>extractMemberWithoutPaths( { memberOrZipName =&gt; $memberOrName [, name
    =&gt; $extractedName ] } )</dt>
  <dd>Extract the given member, or match its name and extract it. Does not use
      path information (extracts into the current directory). Returns undef if
      member does not exist in this Zip. If optional second arg is given, use it
      as the name of the extracted member (its paths will be deleted too).
      Otherwise, the internal filename of the member (minus paths) is used as
      the name of the extracted file or directory. Returns
      <span class="Li">&quot;AZ_OK&quot;</span> on success.</dd>
  <dt>addMember( $member )</dt>
  <dd></dd>
  <dt>addMember( { member =&gt; $member } )</dt>
  <dd>Append a member (possibly from another zip file) to the zip file. Returns
      the new member. Generally, you will use <i>addFile()</i>,
      <i>addDirectory()</i>, <i>addFileOrDirectory()</i>, <i>addString()</i>, or
      <i>read()</i> to add members.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    # Move member named 'abc' to end of zip:
    my $member = $zip-&gt;removeMember( 'abc' );
    $zip-&gt;addMember( $member );
    </pre>
  </dd>
  <dt>updateMember( $memberOrName, $fileName )</dt>
  <dd></dd>
  <dt>updateMember( { memberOrZipName =&gt; $memberOrName, name =&gt; $fileName
    } )</dt>
  <dd>Update a single member from the file or directory named
      <span class="Li">$fileName</span>. Returns the (possibly added or updated)
      member, if any; <span class="Li">&quot;undef&quot;</span> on errors. The
      comparison is based on <span class="Li">&quot;lastModTime()&quot;</span>
      and (in the case of a non-directory) the size of the file.</dd>
  <dt>addFile( $fileName [, $newName, $compressionLevel ] )</dt>
  <dd></dd>
  <dt>addFile( { filename =&gt; $fileName [, zipName =&gt; $newName,
    compressionLevel =&gt; $compressionLevel } ] )</dt>
  <dd>Append a member whose data comes from an external file, returning the
      member or undef. The member will have its file name set to the name of the
      external file, and its desiredCompressionMethod set to
      COMPRESSION_DEFLATED. The file attributes and last modification time will
      be set from the file. If the name given does not represent a readable
      plain file or symbolic link, undef will be returned.
      <span class="Li">$fileName</span> must be in the format required for the
      local file system. The optional <span class="Li">$newName</span> argument
      sets the internal file name to something different than the given
      <span class="Li">$fileName</span>. <span class="Li">$newName</span>, if
      given, must be in Zip name format (i.e. Unix). The text mode bit will be
      set if the contents appears to be text (as returned by the
      <span class="Li">&quot;-T&quot;</span> perl operator).
    <p class="Pp"><i>NOTE</i> that you should not (generally) use absolute path
        names in zip member names, as this will cause problems with some zip
        tools as well as introduce a security hole and make the zip harder to
        use.</p>
  </dd>
  <dt>addDirectory( $directoryName [, $fileName ] )</dt>
  <dd></dd>
  <dt>addDirectory( { directoryName =&gt; $directoryName [, zipName =&gt;
    $fileName ] } )</dt>
  <dd>Append a member created from the given directory name. The directory name
      does not have to name an existing directory. If the named directory
      exists, the file modification time and permissions are set from the
      existing directory, otherwise they are set to now and permissive default
      permissions. <span class="Li">$directoryName</span> must be in local file
      system format. The optional second argument sets the name of the archive
      member (which defaults to <span class="Li">$directoryName</span>). If
      given, it must be in Zip (Unix) format. Returns the new member.</dd>
  <dt>addFileOrDirectory( $name [, $newName, $compressionLevel ] )</dt>
  <dd></dd>
  <dt>addFileOrDirectory( { name =&gt; $name [, zipName =&gt; $newName,
    compressionLevel =&gt; $compressionLevel ] } )</dt>
  <dd>Append a member from the file or directory named
      <span class="Li">$name</span>. If <span class="Li">$newName</span> is
      given, use it for the name of the new member. Will add or remove trailing
      slashes from <span class="Li">$newName</span> as needed.
      <span class="Li">$name</span> must be in local file system format. The
      optional second argument sets the name of the archive member (which
      defaults to <span class="Li">$name</span>). If given, it must be in Zip
      (Unix) format.</dd>
  <dt>addString( $stringOrStringRef, $name, [$compressionLevel] )</dt>
  <dd></dd>
  <dt>addString( { string =&gt; $stringOrStringRef [, zipName =&gt; $name,
    compressionLevel =&gt; $compressionLevel ] } )</dt>
  <dd>Append a member created from the given string or string reference. The
      name is given by the second argument. Returns the new member. The last
      modification time will be set to now, and the file attributes will be set
      to permissive defaults.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    my $member = $zip-&gt;addString( 'This is a test', 'test.txt' );
    </pre>
  </dd>
  <dt>contents( $memberOrMemberName [, $newContents ] )</dt>
  <dd></dd>
  <dt>contents( { memberOrZipName =&gt; $memberOrMemberName [, contents =&gt;
    $newContents ] } )</dt>
  <dd>Returns the uncompressed data for a particular member, or undef.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    print &quot;xyz.txt contains &quot; . $zip-&gt;contents( 'xyz.txt' );
    </pre>
    <p class="Pp">Also can change the contents of a member:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    $zip-&gt;contents( 'xyz.txt', 'This is the new contents' );
    </pre>
    <p class="Pp">If called expecting an array as the return value, it will
        include the status as the second value in the array.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    ($content, $status) = $zip-&gt;contents( 'xyz.txt');
    </pre>
  </dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Zip_Archive_I/O_operations"><a class="permalink" href="#Zip_Archive_I/O_operations">Zip
  Archive I/O operations</a></h2>
A Zip archive can be written to a file or file handle, or read from one.
<dl class="Bl-tag">
  <dt>writeToFileNamed( $fileName )</dt>
  <dd></dd>
  <dt>writeToFileNamed( { fileName =&gt; $fileName } )</dt>
  <dd>Write a zip archive to named file. Returns
      <span class="Li">&quot;AZ_OK&quot;</span> on success.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    my $status = $zip-&gt;writeToFileNamed( 'xx.zip' );
    die &quot;error somewhere&quot; if $status != AZ_OK;
    </pre>
    <p class="Pp">Note that if you use the same name as an existing zip file
        that you read in, you will clobber ZipFileMembers. So instead, write to
        a different file name, then delete the original. If you use the
        <span class="Li">&quot;overwrite()&quot;</span> or
        <span class="Li">&quot;overwriteAs()&quot;</span> methods, you can
        re-write the original zip in this way. <span class="Li">$fileName</span>
        should be a valid file name on your system.</p>
  </dd>
  <dt>writeToFileHandle( $fileHandle [, $seekable] )</dt>
  <dd>Write a zip archive to a file handle. Return AZ_OK on success. The
      optional second arg tells whether or not to try to seek backwards to
      re-write headers. If not provided, it is set if the Perl
      <span class="Li">&quot;-f&quot;</span> test returns true. This could fail
      on some operating systems, though.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    my $fh = IO::File-&gt;new( 'someFile.zip', 'w' );
    unless ( $zip-&gt;writeToFileHandle( $fh ) == AZ_OK ) {
        # error handling
    }
    </pre>
    <p class="Pp">If you pass a file handle that is not seekable (like if you're
        writing to a pipe or a socket), pass a false second argument:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    my $fh = IO::File-&gt;new( '| cat &gt; somefile.zip', 'w' );
    $zip-&gt;writeToFileHandle( $fh, 0 );   # fh is not seekable
    </pre>
    <p class="Pp">If this method fails during the write of a member, that member
        and all following it will return false from
        <span class="Li">&quot;wasWritten()&quot;</span>. See
        <i>writeCentralDirectory()</i> for a way to deal with this. If you want,
        you can write data to the file handle before passing it to
        <i>writeToFileHandle()</i>; this could be used (for instance) for making
        self-extracting archives. However, this only works reliably when writing
        to a real file (as opposed to STDOUT or some other possible
      non-file).</p>
    <p class="Pp">See examples/selfex.pl for how to write a self-extracting
        archive.</p>
  </dd>
  <dt>writeCentralDirectory( $fileHandle [, $offset ] )</dt>
  <dd></dd>
  <dt>writeCentralDirectory( { fileHandle =&gt; $fileHandle [, offset =&gt;
    $offset ] } )</dt>
  <dd>Writes the central directory structure to the given file handle.
    <p class="Pp">Returns AZ_OK on success. If given an
        <span class="Li">$offset</span>, will seek to that point before writing.
        This can be used for recovery in cases where writeToFileHandle or
        writeToFileNamed returns an IO error because of running out of space on
        the destination file.</p>
    <p class="Pp">You can truncate the zip by seeking backwards and then writing
        the directory:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    my $fh = IO::File-&gt;new( 'someFile.zip', 'w' );
        my $retval = $zip-&gt;writeToFileHandle( $fh );
    if ( $retval == AZ_IO_ERROR ) {
        my @unwritten = grep { not $_-&gt;wasWritten() } $zip-&gt;members();
        if (@unwritten) {
            $zip-&gt;removeMember( $member ) foreach my $member ( @unwritten );
            $zip-&gt;writeCentralDirectory( $fh,
            $unwritten[0]-&gt;writeLocalHeaderRelativeOffset());
        }
    }
    </pre>
  </dd>
  <dt>overwriteAs( $newName )</dt>
  <dd></dd>
  <dt>overwriteAs( { filename =&gt; $newName } )</dt>
  <dd>Write the zip to the specified file, as safely as possible. This is done
      by first writing to a temp file, then renaming the original if it exists,
      then renaming the temp file, then deleting the renamed original if it
      exists. Returns AZ_OK if successful.</dd>
  <dt><i>overwrite()</i></dt>
  <dd>Write back to the original zip file. See <i>overwriteAs()</i> above. If
      the zip was not ever read from a file, this generates an error.</dd>
  <dt>read( $fileName )</dt>
  <dd></dd>
  <dt>read( { filename =&gt; $fileName } )</dt>
  <dd>Read zipfile headers from a zip file, appending new members. Returns
      <span class="Li">&quot;AZ_OK&quot;</span> or error code.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    my $zipFile = Archive::Zip-&gt;new();
    my $status = $zipFile-&gt;read( '/some/FileName.zip' );
    </pre>
  </dd>
  <dt>readFromFileHandle( $fileHandle, $filename )</dt>
  <dd></dd>
  <dt>readFromFileHandle( { fileHandle =&gt; $fileHandle, filename =&gt;
    $filename } )</dt>
  <dd>Read zipfile headers from an already-opened file handle, appending new
      members. Does not close the file handle. Returns
      <span class="Li">&quot;AZ_OK&quot;</span> or error code. Note that this
      requires a seekable file handle; reading from a stream is not yet
      supported, but using in-memory data is.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    my $fh = IO::File-&gt;new( '/some/FileName.zip', 'r' );
    my $zip1 = Archive::Zip-&gt;new();
    my $status = $zip1-&gt;readFromFileHandle( $fh );
    my $zip2 = Archive::Zip-&gt;new();
    $status = $zip2-&gt;readFromFileHandle( $fh );
    </pre>
    <p class="Pp">Read zip using in-memory data (recursable):</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    open my $fh, &quot;&lt;&quot;, &quot;archive.zip&quot; or die $!;
    my $zip_data = do { local $.; &lt;$fh&gt; };
    my $zip = Archive::Zip-&gt;new;
    open my $dh, &quot;+&lt;&quot;, \$zip_data;
    $zip-&gt;readFromFileHandle ($dh);
    </pre>
  </dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Zip_Archive_Tree_operations"><a class="permalink" href="#Zip_Archive_Tree_operations">Zip
  Archive Tree operations</a></h2>
These used to be in Archive::Zip::Tree but got moved into Archive::Zip. They
  enable operation on an entire tree of members or files. A usage example:
<p class="Pp"><span class="Li"></span></p>
<pre>
  use Archive::Zip;
  my $zip = Archive::Zip-&gt;new();

  # add all readable files and directories below . as xyz/*
  $zip-&gt;addTree( '.', 'xyz' );

  # add all readable plain files below /abc as def/*
  $zip-&gt;addTree( '/abc', 'def', sub { -f &amp;&amp; -r } );

  # add all .c files below /tmp as stuff/*
  $zip-&gt;addTreeMatching( '/tmp', 'stuff', '\.c$' );

  # add all .o files below /tmp as stuff/* if they aren't writable
  $zip-&gt;addTreeMatching( '/tmp', 'stuff', '\.o$', sub { ! -w } );

  # add all .so files below /tmp that are smaller than 200 bytes as stuff/*
  $zip-&gt;addTreeMatching( '/tmp', 'stuff', '\.o$', sub { -s &lt; 200 } );

  # and write them into a file
  $zip-&gt;writeToFileNamed('xxx.zip');

  # now extract the same files into /tmpx
  $zip-&gt;extractTree( 'stuff', '/tmpx' );
</pre>
<dl class="Bl-tag">
  <dt>$zip-&gt;addTree( $root, $dest [, $pred, $compressionLevel ] ) -- Add tree
    of files to a zip</dt>
  <dd></dd>
  <dt>$zip-&gt;addTree( { root =&gt; $root, zipName =&gt; $dest [, select =&gt;
    $pred, compressionLevel =&gt; $compressionLevel ] )</dt>
  <dd><span class="Li">$root</span> is the root of the tree of files and
      directories to be added. It is a valid directory name on your system.
      <span class="Li">$dest</span> is the name for the root in the zip file
      (undef or blank means to use relative pathnames). It is a valid ZIP
      directory name (that is, it uses forward slashes (/) for separating
      directory components). <span class="Li">$pred</span> is an optional
      subroutine reference to select files: it is passed the name of the
      prospective file or directory using <span class="Li">$_</span>, and if it
      returns true, the file or directory will be included. The default is to
      add all readable files and directories. For instance, using
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  my $pred = sub { /\.txt/ };
  $zip-&gt;addTree( '.', '', $pred );
    </pre>
    <p class="Pp">will add all the .txt files in and below the current
        directory, using relative names, and making the names identical in the
        zipfile:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  original name           zip member name
  ./xyz                   xyz
  ./a/                    a/
  ./a/b                   a/b
    </pre>
    <p class="Pp">To translate absolute to relative pathnames, just pass them
        in: <span class="Li">$zip</span>-&gt;addTree( '/c/d', 'a' );</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  original name           zip member name
  /c/d/xyz                a/xyz
  /c/d/a/                 a/a/
  /c/d/a/b                a/a/b
    </pre>
    <p class="Pp">Returns AZ_OK on success. Note that this will not follow
        symbolic links to directories. Note also that this does not check for
        the validity of filenames.</p>
    <p class="Pp">Note that you generally <i>don't</i> want to make zip archive
        member names absolute.</p>
  </dd>
  <dt>$zip-&gt;addTreeMatching( $root, $dest, $pattern [, $pred,
    $compressionLevel ] )</dt>
  <dd></dd>
  <dt>$zip-&gt;addTreeMatching( { root =&gt; $root, zipName =&gt; $dest, pattern
    =&gt; $pattern [, select =&gt; $pred, compressionLevel =&gt;
    $compressionLevel ] } )</dt>
  <dd><span class="Li">$root</span> is the root of the tree of files and
      directories to be added <span class="Li">$dest</span> is the name for the
      root in the zip file (undef means to use relative pathnames)
      <span class="Li">$pattern</span> is a (non-anchored) regular expression
      for filenames to match <span class="Li">$pred</span> is an optional
      subroutine reference to select files: it is passed the name of the
      prospective file or directory in <span class="Li">$_</span>, and if it
      returns true, the file or directory will be included. The default is to
      add all readable files and directories. To add all files in and below the
      current directory whose names end in
      <span class="Li">&quot;.pl&quot;</span>, and make them extract into a
      subdirectory named <span class="Li">&quot;xyz&quot;</span>, do this:
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  $zip-&gt;addTreeMatching( '.', 'xyz', '\.pl$' )
    </pre>
    <p class="Pp">To add all <i>writable</i> files in and below the directory
        named <span class="Li">&quot;/abc&quot;</span> whose names end in
        <span class="Li">&quot;.pl&quot;</span>, and make them extract into a
        subdirectory named <span class="Li">&quot;xyz&quot;</span>, do this:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  $zip-&gt;addTreeMatching( '/abc', 'xyz', '\.pl$', sub { -w } )
    </pre>
    <p class="Pp">Returns AZ_OK on success. Note that this will not follow
        symbolic links to directories.</p>
  </dd>
  <dt>$zip-&gt;updateTree( $root [, $dest , $pred , $mirror, $compressionLevel ]
    );</dt>
  <dd></dd>
  <dt>$zip-&gt;updateTree( { root =&gt; $root [, zipName =&gt; $dest, select
    =&gt; $pred, mirror =&gt; $mirror, compressionLevel =&gt; $compressionLevel
    ] } );</dt>
  <dd>Update a zip file from a directory tree.
    <p class="Pp"><span class="Li">&quot;updateTree()&quot;</span> takes the
        same arguments as <span class="Li">&quot;addTree()&quot;</span>, but
        first checks to see whether the file or directory already exists in the
        zip file, and whether it has been changed.</p>
    <p class="Pp">If the fourth argument <span class="Li">$mirror</span> is
        true, then delete all my members if corresponding files were not
      found.</p>
    <p class="Pp">Returns an error code or AZ_OK if all is well.</p>
  </dd>
  <dt>$zip-&gt;extractTree( [ $root, $dest, $volume } ] )</dt>
  <dd></dd>
  <dt>$zip-&gt;extractTree( [ { root =&gt; $root, zipName =&gt; $dest, volume
    =&gt; $volume } ] )</dt>
  <dd>If you don't give any arguments at all, will extract all the files in the
      zip with their original names.
    <p class="Pp">If you supply one argument for <span class="Li">$root</span>,
        <span class="Li">&quot;extractTree&quot;</span> will extract all the
        members whose names start with <span class="Li">$root</span> into the
        current directory, stripping off <span class="Li">$root</span> first.
        <span class="Li">$root</span> is in Zip (Unix) format. For instance,</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  $zip-&gt;extractTree( 'a' );
    </pre>
    <p class="Pp">when applied to a zip containing the files: a/x a/b/c ax/d/e
        d/e will extract:</p>
    <p class="Pp">a/x as ./x</p>
    <p class="Pp">a/b/c as ./b/c</p>
    <p class="Pp">If you give two arguments,
        <span class="Li">&quot;extractTree&quot;</span> extracts all the members
        whose names start with <span class="Li">$root</span>. It will translate
        <span class="Li">$root</span> into <span class="Li">$dest</span> to
        construct the destination file name. <span class="Li">$root</span> and
        <span class="Li">$dest</span> are in Zip (Unix) format. For
      instance,</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
   $zip-&gt;extractTree( 'a', 'd/e' );
    </pre>
    <p class="Pp">when applied to a zip containing the files: a/x a/b/c ax/d/e
        d/e will extract:</p>
    <p class="Pp">a/x to d/e/x</p>
    <p class="Pp">a/b/c to d/e/b/c and ignore ax/d/e and d/e</p>
    <p class="Pp">If you give three arguments,
        <span class="Li">&quot;extractTree&quot;</span> extracts all the members
        whose names start with <span class="Li">$root</span>. It will translate
        <span class="Li">$root</span> into <span class="Li">$dest</span> to
        construct the destination file name, and then it will convert to local
        file system format, using <span class="Li">$volume</span> as the name of
        the destination volume.</p>
    <p class="Pp"><span class="Li">$root</span> and
        <span class="Li">$dest</span> are in Zip (Unix) format.</p>
    <p class="Pp"><span class="Li">$volume</span> is in local file system
        format.</p>
    <p class="Pp">For instance, under Windows,</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
   $zip-&gt;extractTree( 'a', 'd/e', 'f:' );
    </pre>
    <p class="Pp">when applied to a zip containing the files: a/x a/b/c ax/d/e
        d/e will extract:</p>
    <p class="Pp">a/x to f:d/e/x</p>
    <p class="Pp">a/b/c to f:d/e/b/c and ignore ax/d/e and d/e</p>
    <p class="Pp">If you want absolute paths (the prior example used paths
        relative to the current directory on the destination volume, you can
        specify these in <span class="Li">$dest</span>:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
   $zip-&gt;extractTree( 'a', '/d/e', 'f:' );
    </pre>
    <p class="Pp">when applied to a zip containing the files: a/x a/b/c ax/d/e
        d/e will extract:</p>
    <p class="Pp">a/x to f:\d\e\x</p>
    <p class="Pp">a/b/c to f:\d\e\b\c and ignore ax/d/e and d/e</p>
    <p class="Pp">Returns an error code or AZ_OK if everything worked OK.</p>
  </dd>
</dl>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="Archive::Zip_Global_Variables"><a class="permalink" href="#Archive::Zip_Global_Variables">Archive::Zip
  Global Variables</a></h1>
<dl class="Bl-tag">
  <dt>$Archive::Zip::UNICODE</dt>
  <dd>This variable governs how Unicode file and directory names are added to or
      extracted from an archive. If set, file and directory names are considered
      to be UTF-8 encoded. This is <i>EXPERIMENTAL AND BUGGY (there are some
      edge cases</i> <i>on Win32)</i>. Please report problems.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    {
        local $Archive::Zip::UNICODE = 1;
        $zip-&gt;addFile('Deja vu.txt');
    }
    </pre>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="MEMBER_OPERATIONS"><a class="permalink" href="#MEMBER_OPERATIONS">MEMBER
  OPERATIONS</a></h1>
<section class="Ss">
<h2 class="Ss" id="Member_Class_Methods"><a class="permalink" href="#Member_Class_Methods">Member
  Class Methods</a></h2>
Several constructors allow you to construct members without adding them to a zip
  archive. These work the same as the <i>addFile()</i>, <i>addDirectory()</i>,
  and <i>addString()</i> zip instance methods described above, but they don't
  add the new members to a zip.
<dl class="Bl-tag">
  <dt>Archive::Zip::Member-&gt;newFromString( $stringOrStringRef [, $fileName ]
    )</dt>
  <dd></dd>
  <dt>Archive::Zip::Member-&gt;newFromString( { string =&gt; $stringOrStringRef
    [, zipName =&gt; $fileName ] )</dt>
  <dd>Construct a new member from the given string. Returns undef on error.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    my $member = Archive::Zip::Member-&gt;newFromString( 'This is a test',
    </pre>
  </dd>
  <dt>newFromFile( $fileName [, $zipName ] )</dt>
  <dd></dd>
  <dt>newFromFile( { filename =&gt; $fileName [, zipName =&gt; $zipName ] }
    )</dt>
  <dd>Construct a new member from the given file. Returns undef on error.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    my $member = Archive::Zip::Member-&gt;newFromFile( 'xyz.txt' );
    </pre>
  </dd>
  <dt>newDirectoryNamed( $directoryName [, $zipname ] )</dt>
  <dd></dd>
  <dt>newDirectoryNamed( { directoryName =&gt; $directoryName [, zipName =&gt;
    $zipname ] } )</dt>
  <dd>Construct a new member from the given directory.
      <span class="Li">$directoryName</span> must be a valid name on your file
      system; it does not have to exist.
    <p class="Pp">If given, <span class="Li">$zipname</span> will be the name of
        the zip member; it must be a valid Zip (Unix) name. If not given, it
        will be converted from <span class="Li">$directoryName</span>.</p>
    <p class="Pp">Returns undef on error.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    my $member = Archive::Zip::Member-&gt;newDirectoryNamed( 'CVS/' );
    </pre>
  </dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Member_Simple_accessors"><a class="permalink" href="#Member_Simple_accessors">Member
  Simple accessors</a></h2>
These methods get (and/or set) member attribute values.
<dl class="Bl-tag">
  <dt><i>versionMadeBy()</i></dt>
  <dd>Gets the field from the member header.</dd>
  <dt>fileAttributeFormat( [ $format ] )</dt>
  <dd></dd>
  <dt>fileAttributeFormat( [ { format =&gt; $format ] } )</dt>
  <dd>Gets or sets the field from the member header. These are
      <span class="Li">&quot;FA_*&quot;</span> values.</dd>
  <dt><i>versionNeededToExtract()</i></dt>
  <dd>Gets the field from the member header.</dd>
  <dt><i>bitFlag()</i></dt>
  <dd>Gets the general purpose bit field from the member header. This is where
      the <span class="Li">&quot;GPBF_*&quot;</span> bits live.</dd>
  <dt><i>compressionMethod()</i></dt>
  <dd>Returns the member compression method. This is the method that is
      currently being used to compress the member data. This will be
      COMPRESSION_STORED for added string or file members, or any of the
      <span class="Li">&quot;COMPRESSION_*&quot;</span> values for members from
      a zip file. However, this module can only handle members whose data is in
      COMPRESSION_STORED or COMPRESSION_DEFLATED format.</dd>
  <dt>desiredCompressionMethod( [ $method ] )</dt>
  <dd></dd>
  <dt>desiredCompressionMethod( [ { compressionMethod =&gt; $method } ] )</dt>
  <dd>Get or set the member's
      <span class="Li">&quot;desiredCompressionMethod&quot;</span>. This is the
      compression method that will be used when the member is written. Returns
      prior desiredCompressionMethod. Only COMPRESSION_DEFLATED or
      COMPRESSION_STORED are valid arguments. Changing to COMPRESSION_STORED
      will change the member desiredCompressionLevel to 0; changing to
      COMPRESSION_DEFLATED will change the member desiredCompressionLevel to
      COMPRESSION_LEVEL_DEFAULT.</dd>
  <dt>desiredCompressionLevel( [ $level ] )</dt>
  <dd></dd>
  <dt>desiredCompressionLevel( [ { compressionLevel =&gt; $level } ] )</dt>
  <dd>Get or set the member's desiredCompressionLevel This is the method that
      will be used to write. Returns prior desiredCompressionLevel. Valid
      arguments are 0 through 9, COMPRESSION_LEVEL_NONE,
      COMPRESSION_LEVEL_DEFAULT, COMPRESSION_LEVEL_BEST_COMPRESSION, and
      COMPRESSION_LEVEL_FASTEST. 0 or COMPRESSION_LEVEL_NONE will change the
      desiredCompressionMethod to COMPRESSION_STORED. All other arguments will
      change the desiredCompressionMethod to COMPRESSION_DEFLATED.</dd>
  <dt><i>externalFileName()</i></dt>
  <dd>Return the member's external file name, if any, or undef.</dd>
  <dt><i>fileName()</i></dt>
  <dd>Get or set the member's internal filename. Returns the (possibly new)
      filename. Names will have backslashes converted to forward slashes, and
      will have multiple consecutive slashes converted to single ones.</dd>
  <dt><i>lastModFileDateTime()</i></dt>
  <dd>Return the member's last modification date/time stamp in MS-DOS
    format.</dd>
  <dt><i>lastModTime()</i></dt>
  <dd>Return the member's last modification date/time stamp, converted to unix
      localtime format.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    print &quot;Mod Time: &quot; . scalar( localtime( $member-&gt;lastModTime() ) );
    </pre>
  </dd>
  <dt><i>setLastModFileDateTimeFromUnix()</i></dt>
  <dd>Set the member's lastModFileDateTime from the given unix time.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    $member-&gt;setLastModFileDateTimeFromUnix( time() );
    </pre>
  </dd>
  <dt><i>internalFileAttributes()</i></dt>
  <dd>Return the internal file attributes field from the zip header. This is
      only set for members read from a zip file.</dd>
  <dt><i>externalFileAttributes()</i></dt>
  <dd>Return member attributes as read from the ZIP file. Note that these are
      NOT UNIX!</dd>
  <dt>unixFileAttributes( [ $newAttributes ] )</dt>
  <dd></dd>
  <dt>unixFileAttributes( [ { attributes =&gt; $newAttributes } ] )</dt>
  <dd>Get or set the member's file attributes using UNIX file attributes.
      Returns old attributes.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    my $oldAttribs = $member-&gt;unixFileAttributes( 0666 );
    </pre>
    <p class="Pp">Note that the return value has more than just the file
        permissions, so you will have to mask off the lowest bits for
        comparisons.</p>
  </dd>
  <dt>localExtraField( [ $newField ] )</dt>
  <dd></dd>
  <dt>localExtraField( [ { field =&gt; $newField } ] )</dt>
  <dd>Gets or sets the extra field that was read from the local header. This is
      not set for a member from a zip file until after the member has been
      written out. The extra field must be in the proper format.</dd>
  <dt>cdExtraField( [ $newField ] )</dt>
  <dd></dd>
  <dt>cdExtraField( [ { field =&gt; $newField } ] )</dt>
  <dd>Gets or sets the extra field that was read from the central directory
      header. The extra field must be in the proper format.</dd>
  <dt><i>extraFields()</i></dt>
  <dd>Return both local and CD extra fields, concatenated.</dd>
  <dt>fileComment( [ $newComment ] )</dt>
  <dd></dd>
  <dt>fileComment( [ { comment =&gt; $newComment } ] )</dt>
  <dd>Get or set the member's file comment.</dd>
  <dt><i>hasDataDescriptor()</i></dt>
  <dd>Get or set the data descriptor flag. If this is set, the local header will
      not necessarily have the correct data sizes. Instead, a small structure
      will be stored at the end of the member data with these values. This
      should be transparent in normal operation.</dd>
  <dt><i>crc32()</i></dt>
  <dd>Return the CRC-32 value for this member. This will not be set for members
      that were constructed from strings or external files until after the
      member has been written.</dd>
  <dt><i>crc32String()</i></dt>
  <dd>Return the CRC-32 value for this member as an 8 character printable hex
      string. This will not be set for members that were constructed from
      strings or external files until after the member has been written.</dd>
  <dt><i>compressedSize()</i></dt>
  <dd>Return the compressed size for this member. This will not be set for
      members that were constructed from strings or external files until after
      the member has been written.</dd>
  <dt><i>uncompressedSize()</i></dt>
  <dd>Return the uncompressed size for this member.</dd>
  <dt>password( [ $password ] )</dt>
  <dd>Returns the password for this member to be used on decryption. If
      <span class="Li">$password</span> is given, it will set the password for
      the decryption.</dd>
  <dt><i>isEncrypted()</i></dt>
  <dd>Return true if this member is encrypted. The Archive::Zip module does not
      currently support creation of encrypted members. Decryption works more or
      less like this:
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  my $zip = Archive::Zip-&gt;new;
  $zip-&gt;read (&quot;encrypted.zip&quot;);
  for my $m (map { $zip-&gt;memberNamed ($_) } $zip-&gt;memberNames) {
      $m-&gt;password (&quot;secret&quot;);
      $m-&gt;contents;  # is &quot;&quot; when password was wrong
    </pre>
    <p class="Pp">That shows that the password has to be set per member, and not
        per archive. This might change in the future.</p>
  </dd>
  <dt>isTextFile( [ $flag ] )</dt>
  <dd></dd>
  <dt>isTextFile( [ { flag =&gt; $flag } ] )</dt>
  <dd>Returns true if I am a text file. Also can set the status if given an
      argument (then returns old state). Note that this module does not
      currently do anything with this flag upon extraction or storage. That is,
      bytes are stored in native format whether or not they came from a text
      file.</dd>
  <dt><i>isBinaryFile()</i></dt>
  <dd>Returns true if I am a binary file. Also can set the status if given an
      argument (then returns old state). Note that this module does not
      currently do anything with this flag upon extraction or storage. That is,
      bytes are stored in native format whether or not they came from a text
      file.</dd>
  <dt>extractToFileNamed( $fileName )</dt>
  <dd></dd>
  <dt>extractToFileNamed( { name =&gt; $fileName } )</dt>
  <dd>Extract me to a file with the given name. The file will be created with
      default modes. Directories will be created as needed. The
      <span class="Li">$fileName</span> argument should be a valid file name on
      your file system. Returns AZ_OK on success.</dd>
  <dt><i>isDirectory()</i></dt>
  <dd>Returns true if I am a directory.</dd>
  <dt><i>writeLocalHeaderRelativeOffset()</i></dt>
  <dd>Returns the file offset in bytes the last time I was written.</dd>
  <dt><i>wasWritten()</i></dt>
  <dd>Returns true if I was successfully written. Reset at the beginning of a
      write attempt.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Low-level_member_data_reading"><a class="permalink" href="#Low-level_member_data_reading">Low-level
  member data reading</a></h2>
It is possible to use lower-level routines to access member data streams, rather
  than the extract* methods and <i>contents()</i>. For instance, here is how to
  print the uncompressed contents of a member in chunks using these methods:
<p class="Pp"><span class="Li"></span></p>
<pre>
    my ( $member, $status, $bufferRef );
    $member = $zip-&gt;memberNamed( 'xyz.txt' );
    $member-&gt;desiredCompressionMethod( COMPRESSION_STORED );
    $status = $member-&gt;rewindData();
    die &quot;error $status&quot; unless $status == AZ_OK;
    while ( ! $member-&gt;readIsDone() )
    {
    ( $bufferRef, $status ) = $member-&gt;readChunk();
    die &quot;error $status&quot;
                if $status != AZ_OK &amp;&amp; $status != AZ_STREAM_END;
    # do something with $bufferRef:
    print $$bufferRef;
    }
    $member-&gt;endRead();
</pre>
<dl class="Bl-tag">
  <dt>readChunk( [ $chunkSize ] )</dt>
  <dd></dd>
  <dt>readChunk( [ { chunkSize =&gt; $chunkSize } ] )</dt>
  <dd>This reads the next chunk of given size from the member's data stream and
      compresses or uncompresses it as necessary, returning a reference to the
      bytes read and a status. If size argument is not given, defaults to global
      set by Archive::Zip::setChunkSize. Status is AZ_OK on success until the
      last chunk, where it returns AZ_STREAM_END. Returns
      <span class="Li">&quot;(</span> <span class="Li">\$bytes,
      $status)&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    my ( $outRef, $status ) = $self-&gt;readChunk();
    print $$outRef if $status != AZ_OK &amp;&amp; $status != AZ_STREAM_END;
    </pre>
  </dd>
  <dt><i>rewindData()</i></dt>
  <dd>Rewind data and set up for reading data streams or writing zip files. Can
      take options for <span class="Li">&quot;inflateInit()&quot;</span> or
      <span class="Li">&quot;deflateInit()&quot;</span>, but this is not likely
      to be necessary. Subclass overrides should call this method. Returns
      <span class="Li">&quot;AZ_OK&quot;</span> on success.</dd>
  <dt><i>endRead()</i></dt>
  <dd>Reset the read variables and free the inflater or deflater. Must be called
      to close files, etc. Returns AZ_OK on success.</dd>
  <dt><i>readIsDone()</i></dt>
  <dd>Return true if the read has run out of data or encountered an error.</dd>
  <dt><i>contents()</i></dt>
  <dd>Return the entire uncompressed member data or undef in scalar context.
      When called in array context, returns <span class="Li">&quot;(
      $string,</span> <span class="Li">$status )&quot;</span>; status will be
      AZ_OK on success:
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    my $string = $member-&gt;contents();
    # or
    my ( $string, $status ) = $member-&gt;contents();
    die &quot;error $status&quot; unless $status == AZ_OK;
    </pre>
    <p class="Pp">Can also be used to set the contents of a member (this may
        change the class of the member):</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    $member-&gt;contents( &quot;this is my new contents&quot; );
    </pre>
  </dd>
  <dt>extractToFileHandle( $fh )</dt>
  <dd></dd>
  <dt>extractToFileHandle( { fileHandle =&gt; $fh } )</dt>
  <dd>Extract (and uncompress, if necessary) the member's contents to the given
      file handle. Return AZ_OK on success.</dd>
</dl>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="Archive::Zip::FileMember_methods"><a class="permalink" href="#Archive::Zip::FileMember_methods">Archive::Zip::FileMember
  methods</a></h1>
The Archive::Zip::FileMember class extends Archive::Zip::Member. It is the base
  class for both ZipFileMember and NewFileMember classes. This class adds an
  <span class="Li">&quot;externalFileName&quot;</span> and an
  <span class="Li">&quot;fh&quot;</span> member to keep track of the external
  file.
<dl class="Bl-tag">
  <dt><i>externalFileName()</i></dt>
  <dd>Return the member's external filename.</dd>
  <dt><i>fh()</i></dt>
  <dd>Return the member's read file handle. Automatically opens file if
      necessary.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="Archive::Zip::ZipFileMember_methods"><a class="permalink" href="#Archive::Zip::ZipFileMember_methods">Archive::Zip::ZipFileMember
  methods</a></h1>
The Archive::Zip::ZipFileMember class represents members that have been read
  from external zip files.
<dl class="Bl-tag">
  <dt><i>diskNumberStart()</i></dt>
  <dd>Returns the disk number that the member's local header resides in. Should
      be 0.</dd>
  <dt><i>localHeaderRelativeOffset()</i></dt>
  <dd>Returns the offset into the zip file where the member's local header
    is.</dd>
  <dt><i>dataOffset()</i></dt>
  <dd>Returns the offset from the beginning of the zip file to the member's
      data.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="REQUIRED_MODULES"><a class="permalink" href="#REQUIRED_MODULES">REQUIRED
  MODULES</a></h1>
Archive::Zip requires several other modules:
<p class="Pp">Carp</p>
<p class="Pp">Compress::Raw::Zlib</p>
<p class="Pp">Cwd</p>
<p class="Pp">File::Basename</p>
<p class="Pp">File::Copy</p>
<p class="Pp">File::Find</p>
<p class="Pp">File::Path</p>
<p class="Pp">File::Spec</p>
<p class="Pp">IO::File</p>
<p class="Pp">IO::Seekable</p>
<p class="Pp">Time::Local</p>
</section>
<section class="Sh">
<h1 class="Sh" id="BUGS_AND_CAVEATS"><a class="permalink" href="#BUGS_AND_CAVEATS">BUGS
  AND CAVEATS</a></h1>
<section class="Ss">
<h2 class="Ss" id="When_not_to_use_Archive::Zip"><a class="permalink" href="#When_not_to_use_Archive::Zip">When
  not to use Archive::Zip</a></h2>
If you are just going to be extracting zips (and/or other archives) you are
  recommended to look at using Archive::Extract instead, as it is much easier to
  use and factors out archive-specific functionality.
</section>
<section class="Ss">
<h2 class="Ss" id="Try_to_avoid_IO::Scalar"><a class="permalink" href="#Try_to_avoid_IO::Scalar">Try
  to avoid IO::Scalar</a></h2>
One of the most common ways to use Archive::Zip is to generate Zip files
  in-memory. Most people use IO::Scalar for this purpose.
<p class="Pp">Unfortunately, as of 1.11 this module no longer works with
    IO::Scalar as it incorrectly implements seeking.</p>
<p class="Pp">Anybody using IO::Scalar should consider porting to IO::String,
    which is smaller, lighter, and is implemented to be perfectly compatible
    with regular seekable filehandles.</p>
<p class="Pp">Support for IO::Scalar most likely will <b>not</b> be restored in
    the future, as IO::Scalar itself cannot change the way it is implemented due
    to back-compatibility issues.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Wrong_password_for_encrypted_members"><a class="permalink" href="#Wrong_password_for_encrypted_members">Wrong
  password for encrypted members</a></h2>
When an encrypted member is read using the wrong password, you currently have to
  re-read the entire archive to try again with the correct password.
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="TO_DO"><a class="permalink" href="#TO_DO">TO DO</a></h1>
* auto-choosing storing vs compression
<p class="Pp">* extra field hooks (see notes.txt)</p>
<p class="Pp">* check for duplicates on addition/renaming?</p>
<p class="Pp">* Text file extraction (line end translation)</p>
<p class="Pp">* Reading zip files from non-seekable inputs
   (Perhaps by proxying through IO::String?)</p>
<p class="Pp">* separate unused constants into separate module</p>
<p class="Pp">* cookbook style docs</p>
<p class="Pp">* Handle tainted paths correctly</p>
<p class="Pp">* Work on better compatibility with other IO:: modules</p>
<p class="Pp">* Support encryption</p>
<p class="Pp">* More user-friendly decryption</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SUPPORT"><a class="permalink" href="#SUPPORT">SUPPORT</a></h1>
Bugs should be reported via the CPAN bug tracker
<p class="Pp">&lt;http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Archive-Zip&gt;</p>
<p class="Pp">For other issues contact the maintainer</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
Currently maintained by Fred Moyer &lt;fred@redhotpenguin.com&gt;
<p class="Pp">Previously maintained by Adam Kennedy &lt;adamk@cpan.org&gt;</p>
<p class="Pp">Previously maintained by Steve Peters
    &lt;steve@fisharerojo.org&gt;.</p>
<p class="Pp">File attributes code by Maurice Aubrey
    &lt;maurice@lovelyfilth.com&gt;.</p>
<p class="Pp">Originally by Ned Konz &lt;nedkonz@cpan.org&gt;.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT"><a class="permalink" href="#COPYRIGHT">COPYRIGHT</a></h1>
Some parts copyright 2006 - 2012 Adam Kennedy.
<p class="Pp">Some parts copyright 2005 Steve Peters.</p>
<p class="Pp">Original work copyright 2000 - 2004 Ned Konz.</p>
<p class="Pp">This program is free software; you can redistribute it and/or
    modify it under the same terms as Perl itself.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
Look at Archive::Zip::MemberRead which is a wrapper that allows one to read Zip
  archive members as if they were files.
<p class="Pp">Compress::Raw::Zlib, Archive::Tar, Archive::Extract</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2014-01-08</td>
    <td class="foot-os">perl v5.18.4</td>
  </tr>
</table>
</body>
</html>
