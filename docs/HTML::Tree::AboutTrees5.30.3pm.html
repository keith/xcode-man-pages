<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>HTML::Tree::AboutTrees(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">HTML::Tree::AboutTrees(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">HTML::Tree::AboutTrees(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
HTML::Tree::AboutTrees -- article on tree-shaped data structures in Perl
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<span class="Li"></span>
<pre>
  # This an article, not a module.
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
The following article by Sean M. Burke first appeared in <i>The Perl</i>
  <i>Journal</i> #18 and is copyright 2000 The Perl Journal. It appears courtesy
  of Jon Orwant and The Perl Journal. This document may be distributed under the
  same terms as Perl itself.
</section>
<section class="Sh">
<h1 class="Sh" id="Trees"><a class="permalink" href="#Trees">Trees</a></h1>
-- Sean M. Burke
<p class="Pp"></p>
<div class="Bd-indent">&quot;AaaAAAaauugh! Watch out for that tree!&quot;
 -- <i>George of the Jungle theme</i></div>
<p class="Pp">Perl's facility with references, combined with its automatic
    management of memory allocation, makes it straightforward to write programs
    that store data in structures of arbitrary form and complexity.</p>
<p class="Pp">But I've noticed that many programmers, especially those who
    started out with more restrictive languages, seem at home with complex but
    uniform data structures -- N-dimensional arrays, or more struct-like things
    like hashes-of-arrays(-of-hashes(-of-hashes), etc.) -- but they're often
    uneasy with building more freeform, less tabular structures, like
    tree-shaped data structures.</p>
<p class="Pp">But trees are easy to build and manage in Perl, as I'll
    demonstrate by showing off how the HTML::Element class manages elements in
    an HTML document tree, and by walking you through a from-scratch
    implementation of game trees. But first we need to nail down what we mean by
    a &quot;tree&quot;.</p>
<section class="Ss">
<h2 class="Ss" id="Socratic_Dialogues:__What_is_a_Tree?_"><a class="permalink" href="#Socratic_Dialogues:__What_is_a_Tree?_">Socratic
  Dialogues: &quot;What is a Tree?&quot;</a></h2>
My first brush with tree-shaped structures was in linguistics classes, where
  tree diagrams are used to describe the syntax underlying natural language
  sentences. After learning my way around <i>those</i> trees, I started to
  wonder -- are what I'm used to calling &quot;trees&quot; the same as what
  programmers call &quot;trees&quot;? So I asked lots of helpful and patient
  programmers how they would define a tree. Many replied with a answer in jargon
  that they could not really explain (understandable, since explaining things,
  especially defining things, is harder than people think):
<p class="Pp"></p>
<div class="Bd-indent">-- So what <i>is</i> a &quot;tree&quot;, a tree-shaped
  data structure?
<p class="Pp">-- A tree is a special case of an acyclic directed graph!</p>
<p class="Pp">-- What's a &quot;graph&quot;?</p>
<p class="Pp">-- Um... lines... and... you draw it... with... arcs! nodes!
  um...</p>
</div>
<p class="Pp">The most helpful were folks who couldn't explain directly, but
    with whom I could get into a rather Socratic dialog (where <i>I</i> asked
    the half-dim half-earnest questions), often with much doodling of
    illustrations...</p>
<p class="Pp">Question: so what's a tree?</p>
<p class="Pp">Answer: A tree is a collection of nodes that are linked together
    in a, well, tree-like way! Like this <i>[drawing on a napkin]:</i></p>
<p class="Pp"><span class="Li"></span></p>
<pre>
     A
    / \
   B   C
     / | \
    D  E  F
</pre>
<p class="Pp">Q: So what do these letters represent?</p>
<p class="Pp">A: Each is a different node, a bunch of data. Maybe C is a bunch
    of data that stores a number, maybe a hash table, maybe nothing at all
    besides the fact that it links to D, E, and F (which are other nodes).</p>
<p class="Pp">Q: So what're the lines between the nodes?</p>
<p class="Pp">A: Links. Also called &quot;arcs&quot;. They just symbolize the
    fact that each node holds a list of nodes it links to.</p>
<p class="Pp">Q: So what if I draw nodes and links, like this...</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
     B -- E
    / \  / \
   A   C    
    \ /
     E
</pre>
<p class="Pp">Is that still a tree?</p>
<p class="Pp">A: No, not at all. There's a lot of un-treelike things about that.
    First off, E has a link coming off of it going into nowhere. You can't have
    a link to nothing -- you can only link to another node. Second off, I don't
    know what that sideways link between B and E means...</p>
<p class="Pp">Q: Okay, let's work our way up from something simpler. Is this a
    tree...?</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    A
</pre>
<p class="Pp">A: Yes, I suppose. It's a tree of just one node.</p>
<p class="Pp">Q: And how about...</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
   A
   
   B
</pre>
<p class="Pp">A: No, you can't just have nodes floating there, unattached.</p>
<p class="Pp">Q: Okay, I'll link A and B. How's this?</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
   A
   |
   B
</pre>
<p class="Pp">A: Yup, that's a tree. There's a node A, and a node B, and they're
    linked.</p>
<p class="Pp">Q: How is that tree any different from this one...?</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
   B
   |
   A
</pre>
<p class="Pp">A: Well, in both cases A and B are linked. But it's in a different
    direction.</p>
<p class="Pp">Q: Direction? What does the direction mean?</p>
<p class="Pp">A: Well, it depends what the tree represents. If it represents a
    categorization, like this:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
          citrus
       /    |    \
   orange  lemon  kumquat ...
</pre>
<p class="Pp">then you mean to say that oranges, lemons, kumquats, etc., are a
    kind of citrus. But if you drew it upside down, you'd be saying, falsely,
    that citrus is a kind of kumquat, a kind of lemon, and a kind of orange. If
    the tree represented cause-and-effect (or at least what situations could
    follow others), or represented what's a part of what, you wouldn't want to
    get those backwards, either. So with the nodes you draw together on paper,
    one has to be over the other, so you can tell which way the relationship in
    the tree works.</p>
<p class="Pp">Q: So are these two trees the same?</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
     A          A
    / \        / \
   B   C      B   \
                   C
</pre>
<p class="Pp">A: Yes, although by convention we often try to line up things in
    the same generation, like it is in the diagram on the left.</p>
<p class="Pp">Q: &quot;generation&quot;? This is a family tree?</p>
<p class="Pp">A: No, not unless it's a family tree for just yeast cells or
    something else that reproduces asexually. But for sake of having lots of
    terms to use, we just pretend that links in the tree represent the &quot;is
    a child of&quot; relationship, instead of &quot;is a kind of&quot; or
    &quot;is a part of&quot;, or &quot;could result from&quot;, or whatever the
    real relationship is. So we get to borrow a lot of kinship words for
    describing trees -- B and C are &quot;children&quot; (or
    &quot;daughters&quot;) of A; A is the &quot;parent&quot; (or
    &quot;mother&quot;) of B and C. Node C is a &quot;sibling&quot; (or
    &quot;sister&quot;) of node C; and so on, with terms like
    &quot;descendants&quot; (a node's children, children's children, etc.), and
    &quot;generation&quot; (all the nodes at the same &quot;level&quot; in the
    tree, i.e., are either all grandchildren of the top node, or all
    great-grand-children, etc.), and &quot;lineage&quot; or
    &quot;ancestors&quot; (parents, and parent's parents, etc., all the way to
    the topmost node).</p>
<p class="Pp">So then we get to express rules in terms like &quot;<b>A node
    cannot have more</b> <b>than one parent</b>&quot;, which means that this is
    not a valid tree:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    A
   / \
  B   C
   \ /
    E
</pre>
<p class="Pp">And: &quot;<b>A node can't be its own parent</b>&quot;, which
    excludes this looped-up connection:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    /\
   A  |
    \/
</pre>
<p class="Pp">Or, put more generally: &quot;<b>A node can't be its own
    ancestor</b>&quot;, which excludes the above loop, as well as the one
  here:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
      /\
     Z  |
    /   |
   A    |
  / \   |
 B   C  |
      \/
</pre>
<p class="Pp">That tree is excluded because A is a child of Z, and Z is a child
    of C, and C is a child of A, which means A is its own great-grandparent. So
    this whole network can't be a tree, because it breaks the sort of meta-rule:
    <b>once any node in the supposed tree breaks the rules for</b> <b>trees, you
    don't have a tree anymore.</b></p>
<p class="Pp">Q: Okay, now, are these two trees the same?</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
     A         A
   / | \     / | \
  B  C  D   D  C  B
</pre>
<p class="Pp">A: It depends whether you're basing your concept of trees on each
    node having a set (unordered list) of children, or an (ordered) list of
    children. It's a question of whether ordering is important for what you're
    doing. With my diagram of citrus types, ordering isn't important, so these
    tree diagrams express the same thing:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
          citrus
       /    |    \
   orange  lemon  kumquat

           citrus
       /     |    \
   kumquat  orange  lemon
</pre>
<p class="Pp">because it doesn't make sense to say that oranges are
    &quot;before&quot; or &quot;after&quot; kumquats in the whole botanical
    scheme of things. (Unless, of course, you <i>are</i> using ordering to mean
    something, like a degree of genetic similarity.)</p>
<p class="Pp">But consider a tree that's a diagram of what steps are comprised
    in an activity, to some degree of specificity:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
           make tea
         /    |     \
   pour     infuse   serve
 hot water    / \
in cup/pot  /     \
           add     let
           tea     sit
          leaves
</pre>
<p class="Pp">This means that making tea consists of putting hot water in a cup
    or put, infusing it (which itself consists of adding tea leaves and letting
    it sit), then serving it -- <i>in that order</i>. If you serve an empty dry
    pot (sipping from empty cups, etc.), let it sit, add tea leaves, and pour in
    hot water, then what you're doing is performance art, not tea
  preparation:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
        performance
            art
        /    |     \
   serve   infuse    pour
            / \       hot water
          /     \      in cup/pot
         let     add
         sit     tea
                leaves
</pre>
<p class="Pp">Except for my having renamed the root, this tree is the same as
    the making-tea tree as far as what's under what, but it differs in order,
    and what the tree means makes the order important.</p>
<p class="Pp">Q: Wait -- &quot;root&quot;? What's a root?</p>
<p class="Pp">A: Besides kinship terms like &quot;mother&quot; and
    &quot;daughter&quot;, the jargon for tree parts also has terms from
    real-life tree parts: the part that everything else grows from is called the
    root; and nodes that don't have nodes attached to them (i.e., childless
    nodes) are called &quot;leaves&quot;.</p>
<p class="Pp">Q: But you've been drawing all your trees with the root at the top
    and leaves at the bottom.</p>
<p class="Pp">A: Yes, but for some reason, that's the way everyone seems to
    think of trees. They can draw trees as above; or they can draw them sort of
    sideways with indenting representing what nodes are children of what:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  * make tea
     * pour hot water in cup/pot
     * infuse
        * add tea leaves
        * let sit
     * serve
</pre>
<p class="Pp">...but folks almost never seem to draw trees with the root at the
    bottom. So imagine it's based on spider plant in a hanging pot.
    Unfortunately, spider plants <i>aren't</i> botanically trees, they're
    plants; but &quot;spider plant diagram&quot; is rather a mouthful, so let's
    just call them trees.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Trees_Defined_Formally"><a class="permalink" href="#Trees_Defined_Formally">Trees
  Defined Formally</a></h2>
In time, I digested all these assorted facts about programmers' ideas of trees
  (which turned out to be just a more general case of linguistic ideas of trees)
  into a single rule:
<p class="Pp">* A node is an item that contains (&quot;is over&quot;, &quot;is
    parent of&quot;, etc.) zero or more other nodes.</p>
<p class="Pp">From this you can build up formal definitions for useful terms,
    like so:</p>
<p class="Pp">* A node's <b>descendants</b> are defined as all its children, and
    all their children, and so on. Or, stated recursively: a node's descendants
    are all its children, and all its children's descendants. (And if it has no
    children, it has no descendants.)</p>
<p class="Pp">* A node's <b>ancestors</b> consist of its parent, and its
    parent's parent, etc, up to the root. Or, recursively: a node's ancestors
    consist of its parent and its parent's ancestors. (If it has no parent, it
    has no ancestors.)</p>
<p class="Pp">* A <b>tree</b> is a root node and all the root's descendants.</p>
<p class="Pp">And you can add a proviso or two to clarify exactly what I impute
    to the word &quot;other&quot; in &quot;other nodes&quot;:</p>
<p class="Pp">* A node cannot contain itself, or contain any node that contains
    it, etc. Looking at it the other way: a node cannot be its own parent or
    ancestor.</p>
<p class="Pp">* A node can be root (i.e., no other node contains it) or can be
    contained by only one parent; no node can be the child of two or more
    parents.</p>
<p class="Pp">Add to this the idea that children are sometimes ordered, and
    sometimes not, and that's about all you need to know about defining what a
    tree is. From there it's a matter of using them.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Markup_Language_Trees:_HTML-Tree"><a class="permalink" href="#Markup_Language_Trees:_HTML-Tree">Markup
  Language Trees: HTML-Tree</a></h2>
While not <i>all</i> markup languages are inherently tree-like, the best-known
  family of markup languages, HTML, SGML, and XML, are about as tree-like as you
  can get. In these languages, a document consists of elements and character
  data in a tree structure where there is one root element, and elements can
  contain either other elements, or character data.
<p class="Pp"></p>
<div class="Bd-indent">Footnote: For sake of simplicity, I'm glossing over
  comments (&lt;!-- ... --&gt;), processing instructions (&lt;?xml
  version='1.0'&gt;), and declarations (&lt;!ELEMENT ...&gt;, &lt;!DOCTYPE
  ...&gt;). And I'm not bothering to distinguish entity references (&amp;lt;,
  &amp;#64;) or CDATA sections (&lt;![CDATA[ ...]]&gt;) from normal text.</div>
<p class="Pp">For example, consider this HTML document:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  &lt;html lang=&quot;en-US&quot;&gt;
    &lt;head&gt;
      &lt;title&gt;
        Blank Document!
      &lt;/title&gt;
    &lt;/head&gt;
    &lt;body bgcolor=&quot;#d010ff&quot;&gt;
      I've got
      &lt;em&gt;
        something to saaaaay
      &lt;/em&gt;
      !
    &lt;/body&gt;
  &lt;/html&gt;
</pre>
<p class="Pp">I've indented this to point out what nodes (elements or text
    items) are children of what, with each node on a line of its own.</p>
<p class="Pp">The HTML::TreeBuilder module (in the CPAN distribution HTML-Tree)
    does the work of taking HTML source and building in memory the tree that the
    document source represents.</p>
<p class="Pp"></p>
<div class="Bd-indent">Footnote: it requires the HTML::Parser module, which
  tokenizes the source -- i.e., identifies each tag, bit of text, comment,
  etc.</div>
<p class="Pp">The trees structures that it builds represent bits of text with
    normal Perl scalar string values; but elements are represented with objects
    -- that is, chunks of data that belong to a class (in this case,
    HTML::Element), a class that provides methods (routines) for accessing the
    pieces of data in each element, and otherwise doing things with elements.
    (See my article in TPJ#17 for a quick explanation of objects, the POD
    document <span class="Li">&quot;perltoot&quot;</span> for a longer
    explanation, or Damian Conway's excellent book <i>Object-Oriented Perl</i>
    for the full story.)</p>
<p class="Pp">Each HTML::Element object contains a number of pieces of data:</p>
<p class="Pp">* its element name (&quot;html&quot;, &quot;h1&quot;, etc.,
    accessed as <span class="Li">$element</span>-&gt;tag)</p>
<p class="Pp">* a list of elements (or text segments) that it contains, if any
    (accessed as <span class="Li">$element</span>-&gt;content_list or
    <span class="Li">$element</span>-&gt;content, depending on whether you want
    a list, or an arrayref)</p>
<p class="Pp">* what element, if any, contains it (accessed as
    <span class="Li">$element</span>-&gt;parent)</p>
<p class="Pp">* and any SGML attributes that the element has, such as
    <span class="Li">&quot;lang=&quot;en-US&quot;&quot;</span>,
    <span class="Li">&quot;align=&quot;center&quot;&quot;</span>, etc. (accessed
    as <span class="Li">$element</span>-&gt;attr('lang'),
    <span class="Li">$element</span>-&gt;attr('center'), etc.)</p>
<p class="Pp">So, for example, when HTML::TreeBuilder builds the tree for the
    above HTML document source, the object for the &quot;body&quot; element has
    these pieces of data:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
 * element name: &quot;body&quot;
 * nodes it contains:
    the string &quot;I've got &quot;
    the object for the &quot;em&quot; element
    the string &quot;!&quot;
 * its parent:
    the object for the &quot;html&quot; element
 * bgcolor: &quot;#d010ff&quot;
</pre>
<p class="Pp">Now, once you have this tree of objects, almost anything you'd
    want to do with it starts with searching the tree for some bit of
    information in some element.</p>
<p class="Pp">Accessing a piece of information in, say, a hash of hashes of
    hashes, is straightforward:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  $password{'sean'}{'sburke1'}{'hpux'}
</pre>
<p class="Pp">because you know that all data points in that structure are
    accessible with that syntax, but with just different keys. Now, the
    &quot;em&quot; element in the above HTML tree does happen to be accessible
    as the root's child #1's child #1:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  $root-&gt;content-&gt;[1]-&gt;content-&gt;[1]
</pre>
<p class="Pp">But with trees, you typically don't know the exact location (via
    indexes) of the data you're looking for. Instead, finding what you want will
    typically involve searching through the tree, seeing if every node is the
    kind you want. Searching the whole tree is simple enough -- look at a given
    node, and if it's not what you want, look at its children, and so on.
    HTML-Tree provides several methods that do this for you, such as
    <span class="Li">&quot;find_by_tag_name&quot;</span>, which returns the
    elements (or the first element, if called in scalar context) under a given
    node (typically the root) whose tag name is whatever you specify.</p>
<p class="Pp">For example, that &quot;em&quot; node can be found as:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  my $that_em = $root-&gt;find_by_tag_name('em');
</pre>
<p class="Pp">or as:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  @ems = $root-&gt;find_by_tag_name('em');
   # will only have one element for this particular tree
</pre>
<p class="Pp">Now, given an HTML document of whatever structure and complexity,
    if you wanted to do something like change every</p>
<p class="Pp"></p>
<div class="Bd-indent">&lt;em&gt;<i>stuff</i>&lt;/em&gt;</div>
<p class="Pp">to</p>
<p class="Pp"></p>
<div class="Bd-indent">&lt;em class=&quot;funky&quot;&gt;
  <b>&lt;b&gt;[-&lt;/b&gt;</b> <i>stuff</i> <b>&lt;b&gt;-]&lt;/b&gt;</b>
  &lt;/em&gt;</div>
<p class="Pp">the first step is to frame this operation in terms of what you're
    doing to the tree. You're changing this:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
      em
       |
      ...
</pre>
<p class="Pp">to this:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
      em
    /  |  \  
   b  ...   b
   |        |
  &quot;[-&quot;     &quot;-]&quot;
</pre>
<p class="Pp">In other words, you're finding all elements whose tag name is
    &quot;em&quot;, setting its class attribute to &quot;funky&quot;, and adding
    one child to the start of its content list -- a new &quot;b&quot; element
    whose content is the text string &quot;[-&quot; -- and one to the end of its
    content list -- a new &quot;b&quot; element whose content is the text string
    &quot;-]&quot;.</p>
<p class="Pp">Once you've got it in these terms, it's just a matter of running
    to the HTML::Element documentation, and coding this up with calls to the
    appropriate methods, like so:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  use HTML::Element 1.53;
  use HTML::TreeBuilder 2.96;
  # Build the tree by parsing the document
  my $root = HTML::TreeBuilder-&gt;new;
  $root-&gt;parse_file('whatever.html'); # source file
  
  # Now make new nodes where needed
  foreach my $em ($root-&gt;find_by_tag_name('em')) {
    $em-&gt;attr('class', 'funky'); # Set that attribute
    
    # Make the two new B nodes
    my $new1 = HTML::Element-&gt;new('b');
    my $new2 = HTML::Element-&gt;new('b');
    # Give them content (they have none at first)
    $new1-&gt;push_content('[-');
    $new2-&gt;push_content('-]');
    
    # And put 'em in place!
    $em-&gt;unshift_content($new1);
    $em-&gt;push_content($new2);
  }
  print
   &quot;&lt;!-- Looky see what I did! --&gt;\n&quot;,
   $root-&gt;as_HTML(), &quot;\n&quot;;
</pre>
<p class="Pp">The class HTML::Element provides just about every method I can
    image you needing, for manipulating trees made of HTML::Element objects.
    (And what it doesn't directly provide, it will give you the components to
    build it with.)</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Building_Your_Own_Trees"><a class="permalink" href="#Building_Your_Own_Trees">Building
  Your Own Trees</a></h2>
Theoretically, any tree is pretty much like any other tree, so you could use
  HTML::Element for anything you'd ever want to do with tree-arranged objects.
  However, as its name implies, HTML::Element is basically <i>for</i> HTML
  elements; it has lots of features that make sense only for HTML elements (like
  the idea that every element must have a tag-name). And it lacks some features
  that might be useful for general applications -- such as any sort of checking
  to make sure that you're not trying to arrange objects in a non-treelike way.
  For a general-purpose tree class that does have such features, you can use
  Tree::DAG_Node, also available from CPAN.
<p class="Pp">However, if your task is simple enough, you might find it overkill
    to bother using Tree::DAG_Node. And, in any case, I find that the best way
    to learn how something works is to implement it (or something like it, but
    simpler) yourself. So I'll here discuss how you'd implement a tree
    structure, <i>without</i> using any of the existing classes for tree
  nodes.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Implementation:_Game_Trees_for_Alak"><a class="permalink" href="#Implementation:_Game_Trees_for_Alak">Implementation:
  Game Trees for Alak</a></h2>
Suppose that the task at hand is to write a program that can play against a
  human opponent at a strategic board game (as opposed to a board game where
  there's an element of chance). For most such games, a &quot;game tree&quot; is
  an essential part of the program (as I will argue, below), and this will be
  our test case for implementing a tree structure from scratch.
<p class="Pp">For sake of simplicity, our game is not chess or backgammon, but
    instead a much simpler game called Alak. Alak was invented by the
    mathematician A. K. Dewdney, and described in his 1984 book
    <i>Planiverse</i>. The rules of Alak are simple:</p>
<p class="Pp"></p>
<div class="Bd-indent">Footnote: Actually, I'm describing only my interpretation
  of the rules Dewdney describes in <i>Planiverse</i>. Many other
  interpretations are possible.</div>
<p class="Pp">* Alak is a two-player game played on a one-dimensional board with
    eleven slots on it. Each slot can hold at most one piece at a time. There's
    two kinds of pieces, which I represent here as &quot;x&quot; and
    &quot;o&quot; -- x's belong to one player (called X), o's to the other
    (called O).</p>
<p class="Pp">* The initial configuration of the board is:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
   xxxx___oooo
</pre>
<p class="Pp">For sake of the article, the slots are numbered from 1 (on the
    left) to 11 (on the right), and X always has the first move.</p>
<p class="Pp">* The players take turns moving. At each turn, each player can
    move only one piece, once. (This unlike checkers, where you move one piece
    per move but get to keep moving it if you jump an your opponent's piece.) A
    player cannot pass up on his turn. A player can move any one of his pieces
    to the next unoccupied slot to its right or left, which may involve jumping
    over occupied slots. A player cannot move a piece off the side of the
  board.</p>
<p class="Pp">* If a move creates a pattern where the opponent's pieces are
    surrounded, on both sides, by two pieces of the mover's color (with no
    intervening unoccupied blank slot), then those surrounded pieces are removed
    from the board.</p>
<p class="Pp">* The goal of the game is to remove all of your opponent's pieces,
    at which point the game ends. Removing all-but-one ends the game as well,
    since the opponent can't surround you with one piece, and so will always
    lose within a few moves anyway.</p>
<p class="Pp">Consider, then, this rather short game where X starts:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  xxxx___oooo
    ^         Move 1: X moves from 3 (shown with caret) to 5
               (Note that any of X's pieces could move, but
               that the only place they could move to is 5.)
  xx_xx__oooo
          ^   Move 2: O moves from 9 to 7.
  xx_xx_oo_oo
     ^        Move 3: X moves from 4 to 6.
  xx__xxoo_oo
           ^  Move 4: O (stupidly) moves from 10 to 9.
  xx__xxooo_o
      ^       Move 5: X moves from 5 to 10, making the board
              &quot;xx___xoooxo&quot;.  The three o's that X just
              surrounded are removed. 
  xx___x___xo
              O has only one piece, so has lost.
</pre>
<p class="Pp">Now, move 4 could have gone quite the other way:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  xx__xxoo_oo
              Move 4: O moves from 8 to 4, making the board 
              &quot;xx_oxxo__oo&quot;.  The surrounded x's are removed.
  xx_o__o__oo
  ^           Move 5: X moves from 1 to 2.
  _xxo__o__oo
        ^     Move 6: O moves from 7 to 6.
  _xxo_o___oo
   ^          Move 7: X moves from 2 to 5, removing the o at 4.
  __x_xo___oo
              ...and so on.
</pre>
<p class="Pp">To teach a computer program to play Alak (as player X, say), it
    needs to be able to look at the configuration of the board, figure out what
    moves it can make, and weigh the benefit or costs, immediate or eventual, of
    those moves.</p>
<p class="Pp">So consider the board from just before move 3, and figure all the
    possible moves X could make. X has pieces in slots 1, 2, 4, and 5. The
    leftmost two x's (at 1 and 2) are up against the end of the board, so they
    can move only right. The other two x's (at 4 and 5) can move either right or
    left:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  Starting board: xx_xx_oo_oo
   moving 1 to 3 gives _xxxx_oo_oo
   moving 2 to 3 gives x_xxx_oo_oo
   moving 4 to 3 gives xxx_x_oo_oo
   moving 5 to 3 gives xxxx__oo_oo
   moving 4 to 6 gives xx__xxoo_oo
   moving 5 to 6 gives xx_x_xoo_oo
</pre>
<p class="Pp">For the computer to decide which of these is the best move to
    make, it needs to quantify the benefit of these moves as a number -- call
    that the &quot;payoff&quot;. The payoff of a move can be figured as just the
    number of x pieces removed by the most recent move, minus the number of o
    pieces removed by the most recent move. (It so happens that the rules of the
    game mean that no move can delete both o's and x's, but the formula still
    applies.) Since none of these moves removed any pieces, all these moves have
    the same immediate payoff: 0.</p>
<p class="Pp">Now, we could race ahead and write an Alak-playing program that
    could use the immediate payoff to decide which is the best move to make. And
    when there's more than one best move (as here, where all the moves are
    equally good), it could choose randomly between the good alternatives. This
    strategy is simple to implement; but it makes for a very dumb program.
    Consider what O's response to each of the potential moves (above) could be.
    Nothing immediately suggests itself for the first four possibilities (X
    having moved something to position 3), but either of the last two
    (illustrated below) are pretty perilous, because in either case O has the
    obvious option (which he would be foolish to pass up) of removing x's from
    the board:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
   xx_xx_oo_oo
      ^        X moves 4 to 6.
   xx__xxoo_oo
          ^    O moves 8 to 4, giving &quot;xx_oxxo__oo&quot;.  The two
               surrounded x's are removed.
   xx_o__o__oo
</pre>
<p class="Pp">or</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
   xx_xx_oo_oo
       ^       X moves 5 to 6.
   xx_x_xoo_oo
          ^    O moves 8 to 5, giving &quot;xx_xoxo__oo&quot;.  The one
               surrounded x is removed.
   xx_xo_o__oo
</pre>
<p class="Pp">Both contingencies are quite bad for X -- but this is not captured
    by the fact that they start out with X thinking his move will be harmless,
    having a payoff of zero.</p>
<p class="Pp">So what's needed is for X to think <i>more</i> than one step ahead
    -- to consider not merely what it can do in this move, and what the payoff
    is, but to consider what O might do in response, and the payoff of those
    potential moves, and so on with X's possible responses to those cases could
    be. All these possibilities form a game tree -- a tree where each node is a
    board, and its children are successors of that node -- i.e., the boards that
    could result from every move possible, given the parent's board.</p>
<p class="Pp">But how to represent the tree, and how to represent the nodes?</p>
<p class="Pp">Well, consider that a node holds several pieces of data:</p>
<p class="Pp">1) the configuration of the board, which, being nice and simple
    and one-dimensional, can be stored as just a string, like
    &quot;xx_xx_oo_oo&quot;.</p>
<p class="Pp">2) whose turn it is, X or O. (Or: who moved last, from which we
    can figure whose turn it is).</p>
<p class="Pp">3) the successors (child nodes).</p>
<p class="Pp">4) the immediate payoff of having moved to this board position
    from its predecessor (parent node).</p>
<p class="Pp">5) and what move gets us from our predecessor node to here.
    (Granted, knowing the board configuration before and after the move, it's
    easy to figure out the move; but it's easier still to store it as one is
    figuring out a node's successors.)</p>
<p class="Pp">6) whatever else we might want to add later.</p>
<p class="Pp">These could be stored equally well in an array or in a hash, but
    it's my experience that hashes are best for cases where you have more than
    just two or three bits of data, or especially when you might need to add new
    bits of data. Moreover, hash key names are mnemonic --
    <span class="Li">$node</span>-&gt;{'last_move_payoff'} is plain as day,
    whereas it's not so easy having to remember with an array that
    <span class="Li">$node</span>-&gt;[3] is where you decided to keep the
    payoff.</p>
<p class="Pp"></p>
<div class="Bd-indent">Footnote: Of course, there are ways around that problem:
  just swear you'll never use a real numeric index to access data in the array,
  and instead use constants with mnemonic names:
<p class="Pp"><span class="Li"></span></p>
<pre>
  use strict;
  use constant idx_PAYOFF =&gt; 3;
  ...
  $n-&gt;[idx_PAYOFF]
</pre>
<p class="Pp">Or use a pseudohash. But I prefer to keep it simple, and use a
    hash.</p>
<p class="Pp">These are, incidentally, the same arguments that people weigh when
    trying to decide whether their object-oriented modules should be based on
    blessed hashes, blessed arrays, or what. Essentially the only difference
    here is that we're not blessing our nodes or talking in terms of classes and
    methods.</p>
<p class="Pp">[end footnote]</p>
</div>
<p class="Pp">So, we might as well represent nodes like so:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  $node = { # hashref
     'board'          =&gt; ...board string, e.g., &quot;xx_x_xoo_oo&quot;
     
     'last_move_payoff' =&gt; ...payoff of the move
                            that got us here.
                            
     'last_move_from' =&gt;  ...the start...
     'last_move_to'   =&gt;  ...and end point of the move
                              that got us here.  E.g., 5 and 6,
                              representing a move from 5 to 6.

     'whose_turn'     =&gt; ...whose move it then becomes.
                           just an 'x' or 'o'.
                              
     'successors' =&gt; ...the successors
  };
</pre>
<p class="Pp">Note that we could have a field called something like
    'last_move_who' to denote who last moved, but since turns in Alak always
    alternate (and no-one can pass), storing whose move it is now <i>and</i> who
    last moved is redundant -- if X last moved, it's O turn now, and vice versa.
    I chose to have a 'whose_turn' field instead of a 'last_move_who', but it
    doesn't really matter. Either way, we'll end up inferring one from the other
    at several points in the program.</p>
<p class="Pp">When we want to store the successors of a node, should we use an
    array or a hash? On the one hand, the successors to
    <span class="Li">$node</span> aren't essentially ordered, so there's no
    reason to use an array per se; on the other hand, if we used a hash, with
    successor nodes as values, we don't have anything particularly meaningful to
    use as keys. (And we can't use the successors themselves as keys, since the
    nodes are referred to by hash references, and you can't use a reference as a
    hash key.) Given no particularly compelling reason to do otherwise, I choose
    to just use an array to store all a node's successors, although the order is
    never actually used for anything:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  $node = {
    ...
    'successors' =&gt; [ ...nodes... ],
    ...
  };
</pre>
<p class="Pp">In any case, now that we've settled on what should be in a node,
    let's make a little sample tree out of a few nodes and see what we can do
    with it:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  # Board just before move 3 in above game
  my $n0 = {
    'board' =&gt; 'xx_xx_oo_oo',
    'last_move_payoff' =&gt; 0,
    'last_move_from' =&gt;  9,
    'last_move_to'   =&gt;  7,
    'whose_turn' =&gt; 'x',
    'successors' =&gt; [],
  };

  # And, for now, just two of the successors:
  
  # X moves 4 to 6, giving xx__xxoo_oo
  my $n1 = {
    'board' =&gt; 'xx__xxoo_oo',
    'last_move_payoff' =&gt; 0,
    'last_move_from' =&gt;  4,
    'last_move_to'   =&gt;  6,
    'whose_turn' =&gt; 'o',
    'successors' =&gt; [],
  };

  # or X moves 5 to 6, giving xx_x_xoo_oo
  my $n2 = {
    'board' =&gt; 'xx_x_xoo_oo',
    'last_move_payoff' =&gt; 0,
    'last_move_from' =&gt;  5,
    'last_move_to'   =&gt;  6,
    'whose_turn' =&gt; 'o',
    'successors' =&gt; [],
  };

  # Now connect them...
  push @{$n0-&gt;{'successors'}}, $n1, $n2;
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Digression:_Links_to_Parents"><a class="permalink" href="#Digression:_Links_to_Parents">Digression:
  Links to Parents</a></h2>
In comparing what we store in an Alak game tree node to what HTML::Element
  stores in HTML element nodes, you'll note one big difference: every
  HTML::Element node contains a link to its parent, whereas we don't have our
  Alak nodes keeping a link to theirs.
<p class="Pp">The reason this can be an important difference is because it can
    affect how Perl knows when you're not using pieces of memory anymore.
    Consider the tree we just built, above:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
      node 0
     /      \
  node 1    node 2
</pre>
<p class="Pp">There's two ways Perl knows you're using a piece of memory: 1)
    it's memory that belongs directly to a variable (i.e., is necessary to hold
    that variable's value, or value<i>s</i> in the case of a hash or array), or
    2) it's a piece of memory that something holds a reference to. In the above
    code, Perl knows that the hash for node 0 (for board
    &quot;xx_xx_oo_oo&quot;) is in use because something (namely, the variable
    <span class="Li">$n0</span>) holds a reference to it. Now, even if you
    followed the above code with this:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  $n1 = $n2 = 'whatever';
</pre>
<p class="Pp">to make your variables <span class="Li">$n1</span> and
    <span class="Li">$n2</span> stop holding references to the hashes for the
    two successors of node 0, Perl would still know that those hashes are still
    in use, because node 0's successors array holds a reference to those hashes.
    And Perl knows that node 0 is still in use because something still holds a
    reference to it. Now, if you added:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  my $root = $n0;
</pre>
<p class="Pp">This would change nothing -- there's just be <i>two</i> things
    holding a reference to the node 0 hash, which in turn holds a reference to
    the node 1 and node 2 hashes. And if you then added:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  $n0 = 'stuff';
</pre>
<p class="Pp">still nothing would change, because something
    (<span class="Li">$root</span>) still holds a reference to the node 0 hash.
    But once <i>nothing</i> holds a reference to the node 0 hash, Perl will know
    it can destroy that hash (and reclaim the memory for later use, say), and
    once it does that, nothing will hold a reference to the node 1 or the node 2
    hashes, and those will be destroyed too.</p>
<p class="Pp">But consider if the node 1 and node 2 hashes each had an attribute
    &quot;parent&quot; (or &quot;predecessor&quot;) that held a reference to
    node 0. If your program stopped holding a reference to the node 0 hash, Perl
    could <i>not</i> then say that <i>nothing</i> holds a reference to node 0 --
    because node 1 and node 2 still do. So, the memory for nodes 0, 1, and 2
    would never get reclaimed (until your program ended, at which point Perl
    destroys <i>everything</i>). If your program grew and discarded lots of
    nodes in the game tree, but didn't let Perl know it could reclaim their
    memory, your program could grow to use immense amounts of memory -- never a
    nice thing to have happen. There's three ways around this:</p>
<p class="Pp">1) When you're finished with a node, delete the reference each of
    its children have to it (in this case, deleting
    <span class="Li">$n1</span>-&gt;{'parent'}, say). When you're finished with
    a whole tree, just go through the whole tree erasing links that children
    have to their children.</p>
<p class="Pp">2) Reconsider whether you really need to have each node hold a
    reference to its parent. Just not having those links will avoid the whole
    problem.</p>
<p class="Pp">3) use the WeakRef module with Perl 5.6 or later. This allows you
    to &quot;weaken&quot; some references (like the references that node 1 and 2
    could hold to their parent) so that they don't count when Perl goes asking
    whether anything holds a reference to a given piece of memory. This
    wonderful new module eliminates the headaches that can often crop up with
    either of the two previous methods.</p>
<p class="Pp">It so happens that our Alak program is simple enough that we don't
    need for our nodes to have links to their parents, so the second solution is
    fine. But in a more advanced program, the first or third solutions might be
    unavoidable.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Recursively_Printing_the_Tree"><a class="permalink" href="#Recursively_Printing_the_Tree">Recursively
  Printing the Tree</a></h2>
I don't like working blind -- if I have any kind of a complex data structure in
  memory for a program I'm working on, the first thing I do is write something
  that can dump that structure to the screen so I can make sure that what I
  <i>think</i> is in memory really <i>is</i> what's in memory. Now, I could just
  use the &quot;x&quot; pretty-printer command in Perl's interactive debugger,
  or I could have the program use the
  <span class="Li">&quot;Data::Dumper&quot;</span> module. But in this case, I
  think the output from those is rather too verbose. Once we have trees with
  dozens of nodes in them, we'll really want a dump of the tree to be as concise
  as possible, hopefully just one line per node. What I'd like is something that
  can print <span class="Li">$n0</span> and its successors (see above) as
  something like:
<p class="Pp"><span class="Li"></span></p>
<pre>
  xx_xx_oo_oo  (O moved 9 to 7, 0 payoff)
    xx__xxoo_oo  (X moved 4 to 6, 0 payoff)
    xx_x_xoo_oo  (X moved 5 to 6, 0 payoff)
</pre>
<p class="Pp">A subroutine to print a line for a given node, and then do that
    again for each successor, would look something like:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  sub dump_tree {
    my $n = $_[0]; # &quot;n&quot; is for node
    print
      ...something expressing $n'n content...
    foreach my $s (@{$n-&gt;{'successors'}}) {
      # &quot;s for successor
      dump($s);
    }
  }
</pre>
<p class="Pp">And we could just start that out with a call to
    <span class="Li">&quot;dump_tree($n0)&quot;</span>.</p>
<p class="Pp">Since this routine...</p>
<p class="Pp"></p>
<div class="Bd-indent">Footnote: I first wrote this routine starting out with
  &quot;sub dump {&quot;. But when I tried actually calling
  <span class="Li">&quot;dump($n0)&quot;</span>, Perl would dump core! Imagine
  my shock when I discovered that this is absolutely to be expected -- Perl
  provides a built-in function called <span class="Li">&quot;dump&quot;</span>,
  the purpose of which is to, yes, make Perl dump core. Calling our routine
  &quot;dump_tree&quot; instead of &quot;dump&quot; neatly avoids that
  problem.</div>
<p class="Pp">...does its work (dumping the subtree at and under the given node)
    by calling itself, it's <b>recursive</b>. However, there's a special term
    for this kind of recursion across a tree: traversal. To <b>traverse</b> a
    tree means to do something to a node, and to traverse its children. There's
    two prototypical ways to do this, depending on what happens when:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  traversing X in pre-order:
    * do something to X
    * then traverse X's children

  traversing X in post-order:
    * traverse X's children
    * then do something to X
</pre>
<p class="Pp">Dumping the tree to the screen the way we want it happens to be a
    matter of pre-order traversal, since the thing we do (print a description of
    the node) happens before we recurse into the successors.</p>
<p class="Pp">When we try writing the <span class="Li">&quot;print&quot;</span>
    statement for our above <span class="Li">&quot;dump_tree&quot;</span>, we
    can get something like:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  sub dump_tree {
    my $n = $_[0];

    # &quot;xx_xx_oo_oo  (O moved 9 to 7, 0 payoff)&quot;
    print
      $n-&gt;{'board'}, &quot;  (&quot;,
      ($n-&gt;{'whose_turn'} eq 'o' ? 'X' : 'O'),
      # Infer who last moved from whose turn it is now.
      &quot; moved &quot;, $n-&gt;{'last_move_from'},
      &quot; to &quot;,    $n-&gt;{'last_move_to'},
      &quot;, &quot;,      $n-&gt;{'last_move_payoff'},
      &quot; payoff)\n&quot;,
    ;

    foreach my $s (@{$n-&gt;{'successors'}}) {
      dump_tree($s);
    }
  }
</pre>
<p class="Pp">If we run this on <span class="Li">$n0</span> from above, we get
    this:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  xx_xx_oo_oo  (O moved 9 to 7, 0 payoff)
  xx__xxoo_oo  (X moved 4 to 6, 0 payoff)
  xx_x_xoo_oo  (X moved 5 to 6, 0 payoff)
</pre>
<p class="Pp">Each line on its own is fine, but we forget to allow for
    indenting, and without that we can't tell what's a child of what. (Imagine
    if the first successor had successors of its own -- you wouldn't be able to
    tell if it were a child, or a sibling.) To get indenting, we'll need to have
    the instances of the <span class="Li">&quot;dump_tree&quot;</span> routine
    know how far down in the tree they're being called, by passing a depth
    parameter between them:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  sub dump_tree {
    my $n = $_[0];
    my $depth = $_[1];
    $depth = 0 unless defined $depth;
    print
      &quot;  &quot; x $depth,
      ...stuff...
    foreach my $s (@{$n-&gt;{'successors'}}) {
      dump_tree($s, $depth + 1);
    }
  }
</pre>
<p class="Pp">When we call <span class="Li">&quot;dump_tree($n0)&quot;</span>,
    <span class="Li">$depth</span> (from <span class="Li">$_[1]</span>) is
    undefined, so gets set to 0, which translates into an indenting of no
    spaces. But when <span class="Li">&quot;dump_tree&quot;</span> invokes
    itself on <span class="Li">$n0</span>'s children, those instances see
    <span class="Li">$depth</span> + 1 as their <span class="Li">$_[1]</span>,
    giving appropriate indenting.</p>
<p class="Pp"></p>
<div class="Bd-indent">Footnote: Passing values around between different
  invocations of a recursive routine, as shown, is a decent way to share the
  data. Another way to share the data is by keeping it in a global variable,
  like <span class="Li">$Depth</span>, initially set to 0. Each time
  <span class="Li">&quot;dump_tree&quot;</span> is about to recurse, it must
  <span class="Li">&quot;++$Depth&quot;</span>, and when it's back, it must
  <span class="Li">&quot;--$Depth&quot;</span>.
<p class="Pp">Or, if the reader is familiar with closures, consider this
    approach:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  sub dump_tree {
    # A wrapper around calls to a recursive closure:
    my $start_node = $_[0];
    my $depth = 0;
     # to be shared across calls to $recursor.
    my $recursor;
    $recursor = sub {
      my $n = $_[0];
      print &quot;  &quot; x $depth,
        ...stuff...
      ++$depth;
      foreach my $s (@{$n-&gt;{'successors'}}) {
        $recursor-&gt;($s);
      }
      --$depth;
    }
    $recursor-&gt;($start_node); # start recursing
    undef $recursor;
  }
</pre>
<p class="Pp">The reader with an advanced understanding of Perl's
    reference-count-based garbage collection is invited to consider why it is
    currently necessary to undef <span class="Li">$recursor</span> (or otherwise
    change its value) after all recursion is done.</p>
<p class="Pp">The reader whose mind is perverse in other ways is invited to
    consider how (or when!) passing a depth parameter around is unnecessary
    because of information that Perl's <span class="Li">caller(N)</span>
    function reports!</p>
<p class="Pp">[end footnote]</p>
</div>
</section>
<section class="Ss">
<h2 class="Ss" id="Growing_the_Tree"><a class="permalink" href="#Growing_the_Tree">Growing
  the Tree</a></h2>
Our <span class="Li">&quot;dump_tree&quot;</span> routine works fine for the
  sample tree we've got, so now we should get the program working on making its
  own trees, starting from a given board.
<p class="Pp">In <span class="Li">&quot;Games::Alak&quot;</span> (the
    CPAN-released version of Alak that uses essentially the same code that we're
    currently discussing the tree-related parts of), there is a routine called
    <span class="Li">&quot;figure_successors&quot;</span> that, given one
    childless node, will figure out all its possible successors. That is, it
    looks at the current board, looks at every piece belonging to the player
    whose turn it is, and considers the effect of moving each piece every
    possible way -- notably, it figures out the immediate payoff, and if that
    move would end the game, it notes that by setting an &quot;endgame&quot;
    entry in that node's hash. (That way, we know that that's a node that
    <i>can't</i> have successors.)</p>
<p class="Pp">In the code for <span class="Li">&quot;Games::Alak&quot;</span>,
    <span class="Li">&quot;figure_successors&quot;</span> does all these things,
    in a rather straightforward way. I won't walk you through the details of the
    <span class="Li">&quot;figure_successors&quot;</span> code I've written,
    since the code has nothing much to do with trees, and is all just
    implementation of the Alak rules for what can move where, with what result.
    Especially interested readers can puzzle over that part of code in the
    source listing in the archive from CPAN, but others can just assume that it
    works as described above.</p>
<p class="Pp">But consider that
    <span class="Li">&quot;figure_successors&quot;</span>, regardless of its
    inner workings, does not grow the <i>tree</i>; it only makes one set of
    successors for one node at a time. It has to be up to a different routine to
    call <span class="Li">&quot;figure_successors&quot;</span>, and to keep
    applying it as needed, in order to make a nice big tree that our
    game-playing program can base its decisions on.</p>
<p class="Pp">Now, we could do this by just starting from one node, applying
    <span class="Li">&quot;figure_successors&quot;</span> to it, then applying
    <span class="Li">&quot;figure_successors&quot;</span> on all the resulting
    children, and so on:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  sub grow {  # Just a first attempt at this!
    my $n = $_[0];
    figure_successors($n);
     unless
      @{$n-&gt;{'successors'}}
        # already has successors.
      or $n-&gt;{'endgame'}
        # can't have successors.
    }
    foreach my $s (@{$n-&gt;{'successors'}}) {
      grow($s); # recurse
    }
  }
</pre>
<p class="Pp">If you have a game tree for tic-tac-toe, and you grow it without
    limitation (as above), you will soon enough have a fully &quot;solved&quot;
    tree, where every node that <i>can</i> have successors <i>does</i>, and all
    the leaves of the tree are <i>all</i> the possible endgames (where, in each
    case, the board is filled). But a game of Alak is different from
    tic-tac-toe, because it can, in theory, go on forever. For example, the
    following sequence of moves is quite possible:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  xxxx___oooo
  xxx_x__oooo
  xxx_x_o_ooo
  xxxx__o_ooo (x moved back)
  xxxx___oooo (o moved back)
  ...repeat forever...
</pre>
<p class="Pp">So if you tried using our above attempt at a
    <span class="Li">&quot;grow&quot;</span> routine, Perl would happily start
    trying to construct an infinitely deep tree, containing an infinite number
    of nodes, consuming an infinite amount of memory, and requiring an infinite
    amount of time. As the old saying goes: &quot;You can't have everything --
    where would you put it?&quot; So we have to place limits on how much we'll
    grow the tree.</p>
<p class="Pp">There's more than one way to do this:</p>
<p class="Pp">1. We could grow the tree until we hit some limit on the number of
    nodes we'll allow in the tree.</p>
<p class="Pp">2. We could grow the tree until we hit some limit on the amount of
    time we're willing to spend.</p>
<p class="Pp">3. Or we could grow the tree until it is fully fleshed out to a
    certain depth.</p>
<p class="Pp">Since we already know to track depth (as we did in writing
    <span class="Li">&quot;dump_tree&quot;</span>), we'll do it that way, the
    third way. The implementation for that third approach is also pretty
    straightforward:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  $Max_depth = 3;
  sub grow {
    my $n = $_[0];
    my $depth = $_[1] || 0;
    figure_successors($n)
     unless
      $depth &gt;= $Max_depth
      or @{$n-&gt;{'successors'}}
      or $n-&gt;{'endgame'}
    }
    foreach my $s (@{$n-&gt;{'successors'}}) {
      grow($s, $depth + 1);
    }
    # If we're at $Max_depth, then figure_successors
    #  didn't get called, so there's no successors
    #  to recurse under -- that's what stops recursion.
  }
</pre>
<p class="Pp">If we start from a single node (whether it's a node for the
    starting board &quot;xxxx___oooo&quot;, or for whatever board the computer
    is faced with), set <span class="Li">$Max_depth</span> to 4, and apply
    <span class="Li">&quot;grow&quot;</span> to it, it will grow the tree to
    include several hundred nodes.</p>
<p class="Pp"></p>
<div class="Bd-indent">Footnote: If at each move there are four pieces that can
  move, and they can each move right or left, the &quot;branching factor&quot;
  of the tree is eight, giving a tree with 1 (depth 0) + 8 (depth 1) + 8 ** 2 +
  8 ** 3 + 8 ** 4 = 4681 nodes in it. But, in practice, not all pieces can move
  in both directions (none of the x pieces in &quot;xxxx___oooo&quot; can move
  left, for example), and there may be fewer than four pieces, if some were
  lost. For example, there are 801 nodes in a tree of depth four starting from
  &quot;xxxx___oooo&quot;, suggesting an average branching factor of about five
  (801 ** (1/4) is about 5.3), not eight.</div>
<p class="Pp">What we need to derive from that tree is the information about
    what are the best moves for X. The simplest way to consider the payoff of
    different successors is to just average them -- but what we average isn't
    always their immediate payoffs (because that'd leave us using only one
    generation of information), but the average payoff of <i>their</i>
    successors, if any. We can formalize this as:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  To figure a node's average payoff:
    If the node has successors:
      Figure each successor's average payoff.
      My average payoff is the average of theirs.
    Otherwise:
      My average payoff is my immediate payoff.
</pre>
<p class="Pp">Since this involves recursing into the successors <i>before</i>
    doing anything with the current node, this will traverse the tree <i>in
    post-order</i>.</p>
<p class="Pp">We could work that up as a routine of its own, and apply that to
    the tree after we've applied <span class="Li">&quot;grow&quot;</span> to it.
    But since we'd never grow the tree without also figuring the average
    benefit, we might as well make that figuring part of the
    <span class="Li">&quot;grow&quot;</span> routine itself:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  $Max_depth = 3;
  sub grow {
    my $n = $_[0];
    my $depth = $_[1] || 0;
    figure_successors($n);
     unless
      $depth &gt;= $Max_depth
      or @{$n-&gt;{'successors'}}
      or $n-&gt;{'endgame'}
    }

    if(@{$n-&gt;{'successors'}}) {
      my $a_payoff_sum = 0;
      foreach my $s (@{$n-&gt;{'successors'}}) {
        grow($s, $depth + 1);  # RECURSE
        $a_payoff_sum += $s-&gt;{'average_payoff'};
      }
      $n-&gt;{'average_payoff'}
       = $a_payoff_sum / @{$n-&gt;{'successors'}};
    } else {
      $n-&gt;{'average_payoff'}
       = $n-&gt;{'last_move_payoff'};
    }
  }
</pre>
<p class="Pp">So, by time <span class="Li">&quot;grow&quot;</span> has applied
    to a node (wherever in the tree it is), it will have figured successors if
    possible (which, in turn, sets
    <span class="Li">&quot;last_move_payoff&quot;</span> for each node it
    creates), and will have set
    <span class="Li">&quot;average_benefit&quot;</span>.</p>
<p class="Pp">Beyond this, all that's needed is to start the board out with a
    root note of &quot;xxxx___oooo&quot;, and have the computer (X) take turns
    with the user (O) until someone wins. Whenever it's O's turn,
    <span class="Li">&quot;Games::Alak&quot;</span> presents a prompt to the
    user, letting him know the state of the current board, and asking what move
    he selects. When it's X's turn, the computer grows the game tree as
    necessary (using just the <span class="Li">&quot;grow&quot;</span> routine
    from above), then selects the move with the highest average payoff (or one
    of the highest, in case of a tie).</p>
<p class="Pp">In either case, &quot;selecting&quot; a move means just setting
    that move's node as the new root of the program's game tree. Its sibling
    nodes and their descendants (the boards that <i>didn't</i> get selected) and
    its parent node will be erased from memory, since they will no longer be in
    use (as Perl can tell by the fact that nothing holds references to them
    anymore).</p>
<p class="Pp">The interface code in
    <span class="Li">&quot;Games::Alak&quot;</span> (the code that prompts the
    user for his move) actually supports quite a few options besides just moving
    -- including dumping the game tree to a specified depth (using a slightly
    fancier version of <span class="Li">&quot;dump_tree&quot;</span>, above),
    resetting the game, changing <span class="Li">$Max_depth</span> in the
    middle of the game, and quitting the game. Like
    <span class="Li">&quot;figure_successors&quot;</span>, it's a bit too long
    to print here, but interested users are welcome to peruse (and freely
    modify) the code, as well as to enjoy just playing the game.</p>
<p class="Pp">Now, in practice, there's more to game trees than this: for games
    with a larger branching factor than Alak has (which is most!), game trees of
    depth four or larger would contain too many nodes to be manageable, most of
    those nodes being strategically quite uninteresting for either player;
    dealing with game trees specifically is therefore a matter of recognizing
    uninteresting contingencies and not bothering to grow the tree under
  them.</p>
<p class="Pp"></p>
<div class="Bd-indent">Footnote: For example, to choose a straightforward case:
  if O has a choice between moves that put him in immediate danger of X winning
  and moves that don't, then O won't ever choose the dangerous moves (and if he
  does, the computer will know enough to end the game), so there's no point in
  growing the tree any further beneath those nodes.</div>
<p class="Pp">But this sample implementation should illustrate the basics of how
    to build and manipulate a simple tree structure in memory. And once you've
    understood the basics of tree storage here, you should be ready to better
    understand the complexities and peculiarities of other systems for creating,
    accessing, and changing trees, including Tree::DAG_Node, HTML::Element,
    XML::DOM, or related formalisms like XPath and XSL.</p>
<p class="Pp"><b>[end body of article]</b></p>
</section>
<section class="Ss">
<h2 class="Ss" id="_Author_Credit_"><a class="permalink" href="#_Author_Credit_">[Author
  Credit]</a></h2>
Sean M. Burke (<span class="Li">&quot;sburke@cpan.org&quot;</span>) is a
  tree-dwelling hominid.
</section>
<section class="Ss">
<h2 class="Ss" id="References"><a class="permalink" href="#References">References</a></h2>
Dewdney, A[lexander] K[eewatin]. 1984. <i>Planiverse: Computer Contact</i>
  <i>with a Two-Dimensional World.</i> Poseidon Press, New York.
<p class="Pp">Knuth, Donald Ervin. 1997. <i>Art of Computer Programming, Volume
    1,</i> <i>Third Edition: Fundamental Algorithms</i>. Addison-Wesley,
    Reading, MA.</p>
<p class="Pp">Wirth, Niklaus. 1976. <i>Algorithms + Data Structures =
    Programs</i> Prentice-Hall, Englewood Cliffs, NJ.</p>
<p class="Pp">Worth, Stan and Allman Sheldon. Circa 1967. <i>George of the
    Jungle</i> theme. [music by Jay Ward.]</p>
<p class="Pp">Wirth's classic, currently and lamentably out of print, has a good
    section on trees. I find it clearer than Knuth's (if not quite as
    encyclopedic), probably because Wirth's example code is in a
    block-structured high-level language (basically Pascal), instead of in
    assembler (MIX). I believe the book was re-issued in the 1980s under the
    titles <i>Algorithms and Data Structures</i> and, in a German edition,
    <i>Algorithmen und Datenstrukturen</i>. Cheap copies of these editions
    should be available through used book services such as
    <span class="Li">&quot;abebooks.com&quot;</span>.</p>
<p class="Pp">Worth's classic, however, is available on the soundtrack to the
    1997 <i>George of the Jungle</i> movie, as performed by The Presidents of
    the United States of America.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="BACK"><a class="permalink" href="#BACK">BACK</a></h1>
Return to the HTML::Tree docs.
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2020-10-19</td>
    <td class="foot-os">perl v5.30.2</td>
  </tr>
</table>
</body>
</html>
