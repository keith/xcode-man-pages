<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    .Nd, .Bf, .Op { display: inline; }
    .Pa, .Ad { font-style: italic; }
    .Ms { font-weight: bold; }
    .Bl-diag > dt { font-weight: bold; }
    code.Nm, .Fl, .Cm, .Ic, code.In, .Fd, .Fn, .Cd { font-weight: bold;
      font-family: inherit; }
  </style>
  <title>PERLAPI(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">PERLAPI(1)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">PERLAPI(1)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">perlapi - autogenerated documentation for the perl public API</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">This file contains most of the documentation of the perl public
    API, as generated by <i>embed.pl</i>. Specifically, it is a listing of
    functions, macros, flags, and variables that may be used by extension
    writers. Besides perlintern and <i>config.h</i>, some items are listed here
    as being actually documented in another pod.</p>
<p class="Pp">At the end is a list of functions which have yet to be documented.
    Patches welcome! The interfaces of these are subject to change without
    notice.</p>
<p class="Pp">Some of the functions documented here are consolidated so that a
    single entry serves for multiple functions which all do basically the same
    thing, but have some slight differences. For example, one form might process
    magic, while another doesn't. The name of each variation is listed at the
    top of the single entry. But if all have the same signature (arguments and
    return type) except for their names, only the usage for the base form is
    shown. If any one of the forms has a different signature (such as returning
    <span class="Li">&quot;const&quot;</span> or not) every function's signature
    is explicitly displayed.</p>
<p class="Pp">Anything not listed here or in the other mentioned pods is not
    part of the public API, and should not be used by extension writers at all.
    For these reasons, blindly using functions listed in <i>proto.h</i> is to be
    avoided when writing extensions.</p>
<p class="Pp">In Perl, unlike C, a string of characters may generally contain
    embedded <span class="Li">&quot;NUL&quot;</span> characters. Sometimes in
    the documentation a Perl string is referred to as a &quot;buffer&quot; to
    distinguish it from a C string, but sometimes they are both just referred to
    as strings.</p>
<p class="Pp">Note that all Perl API global variables must be referenced with
    the <span class="Li">&quot;PL_&quot;</span> prefix. Again, those not listed
    here are not to be used by extension writers, and can be changed or removed
    without notice; same with macros. Some macros are provided for compatibility
    with the older, unadorned names, but this support may be disabled in a
    future release.</p>
<p class="Pp">Perl was originally written to handle US-ASCII only (that is
    characters whose ordinal numbers are in the range 0 - 127). And
    documentation and comments may still use the term ASCII, when sometimes in
    fact the entire range from 0 - 255 is meant.</p>
<p class="Pp">The non-ASCII characters below 256 can have various meanings,
    depending on various things. (See, most notably, perllocale.) But usually
    the whole range can be referred to as ISO-8859-1. Often, the term
    &quot;Latin-1&quot; (or &quot;Latin1&quot;) is used as an equivalent for
    ISO-8859-1. But some people treat &quot;Latin1&quot; as referring just to
    the characters in the range 128 through 255, or sometimes from 160 through
    255. This documentation uses &quot;Latin1&quot; and &quot;Latin-1&quot; to
    refer to all 256 characters.</p>
<p class="Pp">Note that Perl can be compiled and run under either ASCII or
    EBCDIC (See perlebcdic). Most of the documentation (and even comments in the
    code) ignore the EBCDIC possibility. For almost all purposes the differences
    are transparent. As an example, under EBCDIC, instead of UTF-8, UTF-EBCDIC
    is used to encode Unicode strings, and so whenever this documentation refers
    to <span class="Li">&quot;utf8&quot;</span> (and variants of that name,
    including in function names), it also (essentially transparently) means
    <span class="Li">&quot;UTF-EBCDIC&quot;</span>. But the ordinals of
    characters differ between ASCII, EBCDIC, and the UTF- encodings, and a
    string encoded in UTF-EBCDIC may occupy a different number of bytes than in
    UTF-8.</p>
<p class="Pp">The organization of this document is tentative and subject to
    change. Suggestions and patches welcome perl5-porters@perl.org
    &lt;mailto:perl5-porters@perl.org&gt;.</p>
<p class="Pp">The sections in this document currently are</p>
<dl class="Bl-tag">
  <dt>&quot;AV Handling&quot;</dt>
  <dd></dd>
  <dt>&quot;Callback Functions&quot;</dt>
  <dd></dd>
  <dt>&quot;Casting&quot;</dt>
  <dd></dd>
  <dt>&quot;Character case changing&quot;</dt>
  <dd></dd>
  <dt>&quot;Character classification&quot;</dt>
  <dd></dd>
  <dt>&quot;Compiler and Preprocessor information&quot;</dt>
  <dd></dd>
  <dt>&quot;Compiler directives&quot;</dt>
  <dd></dd>
  <dt>&quot;Compile-time scope hooks&quot;</dt>
  <dd></dd>
  <dt>&quot;Concurrency&quot;</dt>
  <dd></dd>
  <dt>&quot;COP Hint Hashes&quot;</dt>
  <dd></dd>
  <dt>&quot;Custom Operators&quot;</dt>
  <dd></dd>
  <dt>&quot;CV Handling&quot;</dt>
  <dd></dd>
  <dt>&quot;Debugging&quot;</dt>
  <dd></dd>
  <dt>&quot;Display functions&quot;</dt>
  <dd></dd>
  <dt>&quot;Embedding and Interpreter Cloning&quot;</dt>
  <dd></dd>
  <dt>&quot;Errno&quot;</dt>
  <dd></dd>
  <dt>&quot;Exception Handling (simple) Macros&quot;</dt>
  <dd></dd>
  <dt>&quot;Filesystem configuration values&quot;</dt>
  <dd></dd>
  <dt>&quot;Floating point configuration values&quot;</dt>
  <dd></dd>
  <dt>&quot;Formats&quot;</dt>
  <dd></dd>
  <dt>&quot;General Configuration&quot;</dt>
  <dd></dd>
  <dt>&quot;Global Variables&quot;</dt>
  <dd></dd>
  <dt>&quot;GV Handling&quot;</dt>
  <dd></dd>
  <dt>&quot;Hook manipulation&quot;</dt>
  <dd></dd>
  <dt>&quot;HV Handling&quot;</dt>
  <dd></dd>
  <dt>&quot;Input/Output&quot;</dt>
  <dd></dd>
  <dt>&quot;Integer configuration values&quot;</dt>
  <dd></dd>
  <dt>&quot;Lexer interface&quot;</dt>
  <dd></dd>
  <dt>&quot;Locales&quot;</dt>
  <dd></dd>
  <dt>&quot;Magic&quot;</dt>
  <dd></dd>
  <dt>&quot;Memory Management&quot;</dt>
  <dd></dd>
  <dt>&quot;MRO&quot;</dt>
  <dd></dd>
  <dt>&quot;Multicall Functions&quot;</dt>
  <dd></dd>
  <dt>&quot;Numeric Functions&quot;</dt>
  <dd></dd>
  <dt>&quot;Optree construction&quot;</dt>
  <dd></dd>
  <dt>&quot;Optree Manipulation Functions&quot;</dt>
  <dd></dd>
  <dt>&quot;Pack and Unpack&quot;</dt>
  <dd></dd>
  <dt>&quot;Pad Data Structures&quot;</dt>
  <dd></dd>
  <dt>&quot;Password and Group access&quot;</dt>
  <dd></dd>
  <dt>&quot;Paths to system commands&quot;</dt>
  <dd></dd>
  <dt>&quot;Prototype information&quot;</dt>
  <dd></dd>
  <dt>&quot;REGEXP Functions&quot;</dt>
  <dd></dd>
  <dt>&quot;Signals&quot;</dt>
  <dd></dd>
  <dt>&quot;Site configuration&quot;</dt>
  <dd></dd>
  <dt>&quot;Sockets configuration values&quot;</dt>
  <dd></dd>
  <dt>&quot;Source Filters&quot;</dt>
  <dd></dd>
  <dt>&quot;Stack Manipulation Macros&quot;</dt>
  <dd></dd>
  <dt>&quot;String Handling&quot;</dt>
  <dd></dd>
  <dt>&quot;SV Flags&quot;</dt>
  <dd></dd>
  <dt>&quot;SV Handling&quot;</dt>
  <dd></dd>
  <dt>&quot;Time&quot;</dt>
  <dd></dd>
  <dt>&quot;Typedef names&quot;</dt>
  <dd></dd>
  <dt>&quot;Unicode Support&quot;</dt>
  <dd></dd>
  <dt>&quot;Utility Functions&quot;</dt>
  <dd></dd>
  <dt>&quot;Versioning&quot;</dt>
  <dd></dd>
  <dt>&quot;Warning and Dieing&quot;</dt>
  <dd></dd>
  <dt>&quot;XS&quot;</dt>
  <dd></dd>
  <dt>&quot;Undocumented elements&quot;</dt>
  <dd></dd>
</dl>
<p class="Pp">The listing below is alphabetical, case insensitive.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AV_Handling"><a class="permalink" href="#AV_Handling">AV
  Handling</a></h1>
<dl class="Bl-tag">
  <dt>&quot;AV&quot;</dt>
  <dd>Described in perlguts.</dd>
  <dt>&quot;AvARRAY&quot;</dt>
  <dd>Returns a pointer to the AV's internal SV* array.
    <p class="Pp">This is useful for doing pointer arithmetic on the array. If
        all you need is to look up an array element, then prefer
        <span class="Li">&quot;av_fetch&quot;</span>.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> SV**  AvARRAY(AV* av)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;av_clear&quot;</dt>
  <dd>Frees all the elements of an array, leaving it empty. The XS equivalent of
      <span class="Li">&quot;@array = ()&quot;</span>. See also
      &quot;av_undef&quot;.
    <p class="Pp">Note that it is possible that the actions of a destructor
        called directly or indirectly by freeing an element of the array could
        cause the reference count of the array itself to be reduced (e.g. by
        deleting an entry in the symbol table). So it is a possibility that the
        AV could have been freed (or even reallocated) on return from the call
        unless you hold a reference to it.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  av_clear(AV *av)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;av_count&quot;</dt>
  <dd>Returns the number of elements in the array
      <span class="Li">&quot;av&quot;</span>. This is the true length of the
      array, including any undefined elements. It is always the same as
      <span class="Li">&quot;av_top_index(av)&#x00A0;+&#x00A0;1&quot;</span>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> Size_t  av_count(AV *av)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;av_create_and_push&quot;</dt>
  <dd>NOTE: <span class="Li">&quot;av_create_and_push&quot;</span> is
      <b>experimental</b> and may change or be removed without notice.
    <p class="Pp">Push an SV onto the end of the array, creating the array if
        necessary. A small internal helper function to remove a commonly
        duplicated idiom.</p>
    <p class="Pp">NOTE: <span class="Li">&quot;av_create_and_push&quot;</span>
        must be explicitly called as
        <span class="Li">&quot;Perl_av_create_and_push&quot;</span> with an
        <span class="Li">&quot;aTHX_&quot;</span> parameter.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  Perl_av_create_and_push(pTHX_ AV **const avp,
                               SV *const val)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;av_create_and_unshift_one&quot;</dt>
  <dd>NOTE: <span class="Li">&quot;av_create_and_unshift_one&quot;</span> is
      <b>experimental</b> and may change or be removed without notice.
    <p class="Pp">Unshifts an SV onto the beginning of the array, creating the
        array if necessary. A small internal helper function to remove a
        commonly duplicated idiom.</p>
    <p class="Pp">NOTE:
        <span class="Li">&quot;av_create_and_unshift_one&quot;</span> must be
        explicitly called as
        <span class="Li">&quot;Perl_av_create_and_unshift_one&quot;</span> with
        an <span class="Li">&quot;aTHX_&quot;</span> parameter.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> SV**  Perl_av_create_and_unshift_one(pTHX_ AV **const avp,
                                      SV *const val)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;av_delete&quot;</dt>
  <dd>Deletes the element indexed by <span class="Li">&quot;key&quot;</span>
      from the array, makes the element mortal, and returns it. If
      <span class="Li">&quot;flags&quot;</span> equals
      <span class="Li">&quot;G_DISCARD&quot;</span>, the element is freed and
      NULL is returned. NULL is also returned if
      <span class="Li">&quot;key&quot;</span> is out of range.
    <p class="Pp">Perl equivalent:
        <span class="Li">&quot;splice(@myarray,&#x00A0;$key,&#x00A0;1,&#x00A0;undef)&quot;</span>
        (with the <span class="Li">&quot;splice&quot;</span> in void context if
        <span class="Li">&quot;G_DISCARD&quot;</span> is present).</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> SV*  av_delete(AV *av, SSize_t key, I32 flags)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;av_exists&quot;</dt>
  <dd>Returns true if the element indexed by
      <span class="Li">&quot;key&quot;</span> has been initialized.
    <p class="Pp">This relies on the fact that uninitialized array elements are
        set to <span class="Li">&quot;NULL&quot;</span>.</p>
    <p class="Pp">Perl equivalent:
        <span class="Li">&quot;exists($myarray[$key])&quot;</span>.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> bool  av_exists(AV *av, SSize_t key)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;av_extend&quot;</dt>
  <dd>Pre-extend an array so that it is capable of storing values at indexes
      <span class="Li">&quot;0..key&quot;</span>. Thus
      <span class="Li">&quot;av_extend(av,99)&quot;</span> guarantees that the
      array can store 100 elements, i.e. that
      <span class="Li">&quot;av_store(av, 0, sv)&quot;</span> through
      <span class="Li">&quot;av_store(av, 99, sv)&quot;</span> on a plain array
      will work without any further memory allocation.
    <p class="Pp">If the av argument is a tied array then will call the
        <span class="Li">&quot;EXTEND&quot;</span> tied array method with an
        argument of <span class="Li">&quot;(key+1)&quot;</span>.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  av_extend(AV *av, SSize_t key)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;av_fetch&quot;</dt>
  <dd>Returns the SV at the specified index in the array. The
      <span class="Li">&quot;key&quot;</span> is the index. If lval is true, you
      are guaranteed to get a real SV back (in case it wasn't real before),
      which you can then modify. Check that the return value is non-null before
      dereferencing it to a <span class="Li">&quot;SV*&quot;</span>.
    <p class="Pp">See &quot;Understanding the Magic of Tied Hashes and
        Arrays&quot; in perlguts for more information on how to use this
        function on tied arrays.</p>
    <p class="Pp">The rough perl equivalent is
        <span class="Li">$myarray[$key]</span>.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> SV**  av_fetch(AV *av, SSize_t key, I32 lval)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;AvFILL&quot;</dt>
  <dd>Same as <span class="Li">&quot;av_top_index&quot;</span> or
      <span class="Li">&quot;av_tindex&quot;</span>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> SSize_t  AvFILL(AV* av)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;av_fill&quot;</dt>
  <dd>Set the highest index in the array to the given number, equivalent to
      Perl's <span class="Li">&quot;$#array&#x00A0;=&#x00A0;$fill;&quot;</span>.
    <p class="Pp">The number of elements in the array will be
        <span class="Li">&quot;fill&#x00A0;+&#x00A0;1&quot;</span> after
        <span class="Li">&quot;av_fill()&quot;</span> returns. If the array was
        previously shorter, then the additional elements appended are set to
        NULL. If the array was longer, then the excess elements are freed.
        <span class="Li">&quot;av_fill(av,&#x00A0;-1)&quot;</span> is the same
        as <span class="Li">&quot;av_clear(av)&quot;</span>.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  av_fill(AV *av, SSize_t fill)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;av_len&quot;</dt>
  <dd>Same as &quot;av_top_index&quot;. Note that, unlike what the name implies,
      it returns the maximum index in the array. This is unlike
      &quot;sv_len&quot;, which returns what you would expect.
    <p class="Pp"><b>To get the true number of elements in the array, instead
        use </b><span class="Li"><b>&quot;av_count&quot;</b></span><b></b>.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> SSize_t  av_len(AV *av)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;av_make&quot;</dt>
  <dd>Creates a new AV and populates it with a list of SVs. The SVs are copied
      into the array, so they may be freed after the call to
      <span class="Li">&quot;av_make&quot;</span>. The new AV will have a
      reference count of 1.
    <p class="Pp">Perl equivalent: <span class="Li">&quot;my @new_array =
        ($scalar1, $scalar2, $scalar3...);&quot;</span></p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> AV*  av_make(SSize_t size, SV **strp)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;av_pop&quot;</dt>
  <dd>Removes one SV from the end of the array, reducing its size by one and
      returning the SV (transferring control of one reference count) to the
      caller. Returns <span class="Li">&amp;PL_sv_undef</span> if the array is
      empty.
    <p class="Pp">Perl equivalent:
        <span class="Li">&quot;pop(@myarray);&quot;</span></p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> SV*  av_pop(AV *av)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;av_push&quot;</dt>
  <dd>Pushes an SV (transferring control of one reference count) onto the end of
      the array. The array will grow automatically to accommodate the addition.
    <p class="Pp">Perl equivalent: <span class="Li">&quot;push @myarray,
        $val;&quot;</span>.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  av_push(AV *av, SV *val)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;av_shift&quot;</dt>
  <dd>Removes one SV from the start of the array, reducing its size by one and
      returning the SV (transferring control of one reference count) to the
      caller. Returns <span class="Li">&amp;PL_sv_undef</span> if the array is
      empty.
    <p class="Pp">Perl equivalent:
        <span class="Li">&quot;shift(@myarray);&quot;</span></p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> SV*  av_shift(AV *av)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;av_store&quot;</dt>
  <dd>Stores an SV in an array. The array index is specified as
      <span class="Li">&quot;key&quot;</span>. The return value will be
      <span class="Li">&quot;NULL&quot;</span> if the operation failed or if the
      value did not need to be actually stored within the array (as in the case
      of tied arrays). Otherwise, it can be dereferenced to get the
      <span class="Li">&quot;SV*&quot;</span> that was stored there (=
      <span class="Li">&quot;val&quot;</span>)).
    <p class="Pp">Note that the caller is responsible for suitably incrementing
        the reference count of <span class="Li">&quot;val&quot;</span> before
        the call, and decrementing it if the function returned
        <span class="Li">&quot;NULL&quot;</span>.</p>
    <p class="Pp">Approximate Perl equivalent:
        <span class="Li">&quot;splice(@myarray, $key, 1, $val)&quot;</span>.</p>
    <p class="Pp">See &quot;Understanding the Magic of Tied Hashes and
        Arrays&quot; in perlguts for more information on how to use this
        function on tied arrays.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> SV**  av_store(AV *av, SSize_t key, SV *val)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;av_tindex&quot;</dt>
  <dd></dd>
  <dt>&quot;av_top_index&quot;</dt>
  <dd>These behave identically. If the array
      <span class="Li">&quot;av&quot;</span> is empty, these return -1;
      otherwise they return the maximum value of the indices of all the array
      elements which are currently defined in
      <span class="Li">&quot;av&quot;</span>.
    <p class="Pp">They process 'get' magic.</p>
    <p class="Pp">The Perl equivalent for these is
      <span class="Li">$#av</span>.</p>
    <p class="Pp">Use <span class="Li">&quot;av_count&quot;</span> to get the
        number of elements in an array.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> SSize_t  av_tindex(AV *av)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;av_undef&quot;</dt>
  <dd>Undefines the array. The XS equivalent of
      <span class="Li">&quot;undef(@array)&quot;</span>.
    <p class="Pp">As well as freeing all the elements of the array (like
        <span class="Li">&quot;av_clear()&quot;</span>), this also frees the
        memory used by the av to store its list of scalars.</p>
    <p class="Pp">See &quot;av_clear&quot; for a note about the array possibly
        being invalid on return.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  av_undef(AV *av)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;av_unshift&quot;</dt>
  <dd>Unshift the given number of <span class="Li">&quot;undef&quot;</span>
      values onto the beginning of the array. The array will grow automatically
      to accommodate the addition.
    <p class="Pp">Perl equivalent:
        <span class="Li">&quot;unshift&#x00A0;@myarray,&#x00A0;((undef)&#x00A0;x&#x00A0;$num);&quot;</span></p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  av_unshift(AV *av, SSize_t num)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;get_av&quot;</dt>
  <dd>Returns the AV of the specified Perl global or package array with the
      given name (so it won't work on lexical variables).
      <span class="Li">&quot;flags&quot;</span> are passed to
      <span class="Li">&quot;gv_fetchpv&quot;</span>. If
      <span class="Li">&quot;GV_ADD&quot;</span> is set and the Perl variable
      does not exist then it will be created. If
      <span class="Li">&quot;flags&quot;</span> is zero and the variable does
      not exist then NULL is returned.
    <p class="Pp">Perl equivalent:
        <span class="Li">&quot;@{&quot;$name&quot;}&quot;</span>.</p>
    <p class="Pp">NOTE: the <span class="Li">&quot;perl_get_av()&quot;</span>
        form is <b>deprecated</b>.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> AV*  get_av(const char *name, I32 flags)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;newAV&quot;</dt>
  <dd>Creates a new AV. The reference count is set to 1.
    <p class="Pp">Perl equivalent: <span class="Li">&quot;my
        @array;&quot;</span>.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> AV*  newAV()
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;Nullav&quot;</dt>
  <dd><span class="Li">&quot;</span><span class="Li"><b>DEPRECATED!</b></span><span class="Li">&quot;</span>
      It is planned to remove <span class="Li">&quot;Nullav&quot;</span> from a
      future release of Perl. Do not use it for new code; remove it from
      existing code.
    <p class="Pp">Null AV pointer.</p>
    <p class="Pp">(deprecated - use <span class="Li">&quot;(AV
        *)NULL&quot;</span> instead)</p>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="Callback_Functions"><a class="permalink" href="#Callback_Functions">Callback
  Functions</a></h1>
<dl class="Bl-tag">
  <dt>&quot;call_argv&quot;</dt>
  <dd>Performs a callback to the specified named and package-scoped Perl
      subroutine with <span class="Li">&quot;argv&quot;</span> (a
      <span class="Li">&quot;NULL&quot;</span>-terminated array of strings) as
      arguments. See perlcall.
    <p class="Pp">Approximate Perl equivalent:
        <span class="Li">&quot;&amp;{&quot;$sub_name&quot;}(@$argv)&quot;</span>.</p>
    <p class="Pp">NOTE: the <span class="Li">&quot;perl_call_argv()&quot;</span>
        form is <b>deprecated</b>.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> I32  call_argv(const char* sub_name, I32 flags, char** argv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;call_method&quot;</dt>
  <dd>Performs a callback to the specified Perl method. The blessed object must
      be on the stack. See perlcall.
    <p class="Pp">NOTE: the
        <span class="Li">&quot;perl_call_method()&quot;</span> form is
        <b>deprecated</b>.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> I32  call_method(const char* methname, I32 flags)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;call_pv&quot;</dt>
  <dd>Performs a callback to the specified Perl sub. See perlcall.
    <p class="Pp">NOTE: the <span class="Li">&quot;perl_call_pv()&quot;</span>
        form is <b>deprecated</b>.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> I32  call_pv(const char* sub_name, I32 flags)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;call_sv&quot;</dt>
  <dd>Performs a callback to the Perl sub specified by the SV.
    <p class="Pp">If neither the <span class="Li">&quot;G_METHOD&quot;</span>
        nor <span class="Li">&quot;G_METHOD_NAMED&quot;</span> flag is supplied,
        the SV may be any of a CV, a GV, a reference to a CV, a reference to a
        GV or <span class="Li">&quot;SvPV(sv)&quot;</span> will be used as the
        name of the sub to call.</p>
    <p class="Pp">If the <span class="Li">&quot;G_METHOD&quot;</span> flag is
        supplied, the SV may be a reference to a CV or
        <span class="Li">&quot;SvPV(sv)&quot;</span> will be used as the name of
        the method to call.</p>
    <p class="Pp">If the <span class="Li">&quot;G_METHOD_NAMED&quot;</span> flag
        is supplied, <span class="Li">&quot;SvPV(sv)&quot;</span> will be used
        as the name of the method to call.</p>
    <p class="Pp">Some other values are treated specially for internal use and
        should not be depended on.</p>
    <p class="Pp">See perlcall.</p>
    <p class="Pp">NOTE: the <span class="Li">&quot;perl_call_sv()&quot;</span>
        form is <b>deprecated</b>.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> I32  call_sv(SV* sv, volatile I32 flags)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;ENTER&quot;</dt>
  <dd>Opening bracket on a callback. See
      <span class="Li">&quot;LEAVE&quot;</span> and perlcall.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre>   ENTER;
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;ENTER_with_name&quot;</dt>
  <dd>Same as <span class="Li">&quot;ENTER&quot;</span>, but when debugging is
      enabled it also associates the given literal string with the new
    scope.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre>   ENTER_with_name(&quot;name&quot;);
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;eval_pv&quot;</dt>
  <dd>Tells Perl to <span class="Li">&quot;eval&quot;</span> the given string in
      scalar context and return an SV* result.
    <p class="Pp">NOTE: the <span class="Li">&quot;perl_eval_pv()&quot;</span>
        form is <b>deprecated</b>.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> SV*  eval_pv(const char* p, I32 croak_on_error)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;eval_sv&quot;</dt>
  <dd>Tells Perl to <span class="Li">&quot;eval&quot;</span> the string in the
      SV. It supports the same flags as
      <span class="Li">&quot;call_sv&quot;</span>, with the obvious exception of
      <span class="Li">&quot;G_EVAL&quot;</span>. See perlcall.
    <p class="Pp">The <span class="Li">&quot;G_RETHROW&quot;</span> flag can be
        used if you only need <b>eval_sv()</b> to execute code specified by a
        string, but not catch any errors.</p>
    <p class="Pp">NOTE: the <span class="Li">&quot;perl_eval_sv()&quot;</span>
        form is <b>deprecated</b>.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> I32  eval_sv(SV* sv, I32 flags)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;FREETMPS&quot;</dt>
  <dd>Closing bracket for temporaries on a callback. See
      <span class="Li">&quot;SAVETMPS&quot;</span> and perlcall.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre>   FREETMPS;
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;G_ARRAY&quot;</dt>
  <dd>Described in perlcall.</dd>
  <dt>&quot;G_DISCARD&quot;</dt>
  <dd>Described in perlcall.</dd>
  <dt>&quot;G_EVAL&quot;</dt>
  <dd>Described in perlcall.</dd>
  <dt>&quot;GIMME&quot;</dt>
  <dd><span class="Li">&quot;</span><span class="Li"><b>DEPRECATED!</b></span><span class="Li">&quot;</span>
      It is planned to remove <span class="Li">&quot;GIMME&quot;</span> from a
      future release of Perl. Do not use it for new code; remove it from
      existing code.
    <p class="Pp">A backward-compatible version of
        <span class="Li">&quot;GIMME_V&quot;</span> which can only return
        <span class="Li">&quot;G_SCALAR&quot;</span> or
        <span class="Li">&quot;G_ARRAY&quot;</span>; in a void context, it
        returns <span class="Li">&quot;G_SCALAR&quot;</span>. Deprecated. Use
        <span class="Li">&quot;GIMME_V&quot;</span> instead.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> U32  GIMME
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;GIMME_V&quot;</dt>
  <dd>The XSUB-writer's equivalent to Perl's
      <span class="Li">&quot;wantarray&quot;</span>. Returns
      <span class="Li">&quot;G_VOID&quot;</span>,
      <span class="Li">&quot;G_SCALAR&quot;</span> or
      <span class="Li">&quot;G_ARRAY&quot;</span> for void, scalar or list
      context, respectively. See perlcall for a usage example.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> U32  GIMME_V
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;G_KEEPERR&quot;</dt>
  <dd>Described in perlcall.</dd>
  <dt>&quot;G_NOARGS&quot;</dt>
  <dd>Described in perlcall.</dd>
  <dt>&quot;G_SCALAR&quot;</dt>
  <dd>Described in perlcall.</dd>
  <dt>&quot;G_VOID&quot;</dt>
  <dd>Described in perlcall.</dd>
  <dt>&quot;LEAVE&quot;</dt>
  <dd>Closing bracket on a callback. See
      <span class="Li">&quot;ENTER&quot;</span> and perlcall.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre>   LEAVE;
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;LEAVE_with_name&quot;</dt>
  <dd>Same as <span class="Li">&quot;LEAVE&quot;</span>, but when debugging is
      enabled it first checks that the scope has the given name.
      <span class="Li">&quot;name&quot;</span> must be a literal string.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre>   LEAVE_with_name(&quot;name&quot;);
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;PL_errgv&quot;</dt>
  <dd>Described in perlcall.</dd>
  <dt>&quot;SAVETMPS&quot;</dt>
  <dd>Opening bracket for temporaries on a callback. See
      <span class="Li">&quot;FREETMPS&quot;</span> and perlcall.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre>   SAVETMPS;
</pre>
</div>
<div class="Bd-indent"></div>
</section>
<section class="Sh">
<h1 class="Sh" id="Casting"><a class="permalink" href="#Casting">Casting</a></h1>
<dl class="Bl-tag">
  <dt>&quot;cBOOL&quot;</dt>
  <dd>Cast-to-bool. A simple
      <span class="Li">&quot;(bool)&#x00A0;</span><span class="Li"><i>expr</i></span><span class="Li">&quot;</span>
      cast may not do the right thing: if
      <span class="Li">&quot;bool&quot;</span> is defined as
      <span class="Li">&quot;char&quot;</span>, for example, then the cast from
      <span class="Li">&quot;int&quot;</span> is implementation-defined.
    <p class="Pp"><span class="Li">&quot;(bool)!!(cbool)&quot;</span> in a
        ternary triggers a bug in xlc on AIX</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> bool  cBOOL(bool expr)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;I_32&quot;</dt>
  <dd>Cast an NV to I32 while avoiding undefined C behavior</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> I32  I_32(NV what)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;INT2PTR&quot;</dt>
  <dd>Described in perlguts.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> type  INT2PTR(type, int value)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;I_V&quot;</dt>
  <dd>Cast an NV to IV while avoiding undefined C behavior</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> IV  I_V(NV what)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;Perl_cpeep_t&quot;</dt>
  <dd>Described in perlguts.</dd>
  <dt>&quot;PTR2IV&quot;</dt>
  <dd>Described in perlguts.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> IV  PTR2IV(void * ptr)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;PTR2nat&quot;</dt>
  <dd>Described in perlguts.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> IV  PTR2nat(void *)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;PTR2NV&quot;</dt>
  <dd>Described in perlguts.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> NV  PTR2NV(void * ptr)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;PTR2ul&quot;</dt>
  <dd>Described in perlguts.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> unsigned long  PTR2ul(void *)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;PTR2UV&quot;</dt>
  <dd>Described in perlguts.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> UV  PTR2UV(void * ptr)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;PTRV&quot;</dt>
  <dd>Described in perlguts.</dd>
  <dt>&quot;U_32&quot;</dt>
  <dd>Cast an NV to U32 while avoiding undefined C behavior</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> U32  U_32(NV what)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;U_V&quot;</dt>
  <dd>Cast an NV to UV while avoiding undefined C behavior</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> UV  U_V(NV what)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;XOP&quot;</dt>
  <dd>Described in perlguts.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="Character_case_changing"><a class="permalink" href="#Character_case_changing">Character
  case changing</a></h1>
<p class="Pp">Perl uses &quot;full&quot; Unicode case mappings. This means that
    converting a single character to another case may result in a sequence of
    more than one character. For example, the uppercase of
    <span class="Li">&quot;ss&quot;</span> (LATIN SMALL LETTER SHARP S) is the
    two character sequence <span class="Li">&quot;SS&quot;</span>. This presents
    some complications The lowercase of all characters in the range 0..255 is a
    single character, and thus <span class="Li">&quot;toLOWER_L1&quot;</span> is
    furnished. But, <span class="Li">&quot;toUPPER_L1&quot;</span> can't exist,
    as it couldn't return a valid result for all legal inputs. Instead
    <span class="Li">&quot;toUPPER_uvchr&quot;</span> has an API that does allow
    every possible legal result to be returned.) Likewise no other function that
    is crippled by not being able to give the correct results for the full range
    of possible inputs has been implemented here.</p>
<dl class="Bl-tag">
  <dt>&quot;toFOLD&quot;</dt>
  <dd>Converts the specified character to foldcase. If the input is anything but
      an ASCII uppercase character, that input character itself is returned.
      Variant <span class="Li">&quot;toFOLD_A&quot;</span> is equivalent. (There
      is no equivalent <span class="Li">&quot;to_FOLD_L1&quot;</span> for the
      full Latin1 range, as the full generality of &quot;toFOLD_uvchr&quot; is
      needed there.)</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> U8  toFOLD(U8 ch)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;toFOLD_utf8&quot;</dt>
  <dd></dd>
  <dt>&quot;toFOLD_utf8_safe&quot;</dt>
  <dd>Converts the first UTF-8 encoded character in the sequence starting at
      <span class="Li">&quot;p&quot;</span> and extending no further than
      <span class="Li">&quot;e&#x00A0;-&#x00A0;1&quot;</span> to its foldcase
      version, and stores that in UTF-8 in
      <span class="Li">&quot;s&quot;</span>, and its length in bytes in
      <span class="Li">&quot;lenp&quot;</span>. Note that the buffer pointed to
      by <span class="Li">&quot;s&quot;</span> needs to be at least
      <span class="Li">&quot;UTF8_MAXBYTES_CASE+1&quot;</span> bytes since the
      foldcase version may be longer than the original character.
    <p class="Pp">The first code point of the foldcased version is returned (but
        note, as explained at the top of this section, that there may be
      more).</p>
    <p class="Pp">It will not attempt to read beyond
        <span class="Li">&quot;e&#x00A0;-&#x00A0;1&quot;</span>, provided that
        the constraint
        <span class="Li">&quot;s&#x00A0;&lt;&#x00A0;e&quot;</span> is true (this
        is asserted for in <span class="Li">&quot;-DDEBUGGING&quot;</span>
        builds). If the UTF-8 for the input character is malformed in some way,
        the program may croak, or the function may return the REPLACEMENT
        CHARACTER, at the discretion of the implementation, and subject to
        change in future releases.</p>
    <p class="Pp"><span class="Li">&quot;toFOLD_utf8_safe&quot;</span> is now
        just a different spelling of plain
        <span class="Li">&quot;toFOLD_utf8&quot;</span></p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> UV  toFOLD_utf8(U8* p, U8* e, U8* s, STRLEN* lenp)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;toFOLD_uvchr&quot;</dt>
  <dd>Converts the code point <span class="Li">&quot;cp&quot;</span> to its
      foldcase version, and stores that in UTF-8 in
      <span class="Li">&quot;s&quot;</span>, and its length in bytes in
      <span class="Li">&quot;lenp&quot;</span>. The code point is interpreted as
      native if less than 256; otherwise as Unicode. Note that the buffer
      pointed to by <span class="Li">&quot;s&quot;</span> needs to be at least
      <span class="Li">&quot;UTF8_MAXBYTES_CASE+1&quot;</span> bytes since the
      foldcase version may be longer than the original character.
    <p class="Pp">The first code point of the foldcased version is returned (but
        note, as explained at the top of this section, that there may be
      more).</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> UV  toFOLD_uvchr(UV cp, U8* s, STRLEN* lenp)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;toLOWER&quot;</dt>
  <dd></dd>
  <dt>&quot;toLOWER_A&quot;</dt>
  <dd></dd>
  <dt>&quot;toLOWER_L1&quot;</dt>
  <dd></dd>
  <dt>&quot;toLOWER_LATIN1&quot;</dt>
  <dd></dd>
  <dt>&quot;toLOWER_LC&quot;</dt>
  <dd></dd>
  <dt>&quot;toLOWER_uvchr&quot;</dt>
  <dd></dd>
  <dt>&quot;toLOWER_utf8&quot;</dt>
  <dd></dd>
  <dt>&quot;toLOWER_utf8_safe&quot;</dt>
  <dd>These all return the lowercase of a character. The differences are what
      domain they operate on, and whether the input is specified as a code point
      (those forms with a <span class="Li">&quot;cp&quot;</span> parameter) or
      as a UTF-8 string (the others). In the latter case, the code point to use
      is the first one in the buffer of UTF-8 encoded code points, delineated by
      the arguments
      <span class="Li">&quot;p&#x00A0;..&#x00A0;e&#x00A0;-&#x00A0;1&quot;</span>.
    <p class="Pp"><span class="Li">&quot;toLOWER&quot;</span> and
        <span class="Li">&quot;toLOWER_A&quot;</span> are synonyms of each
        other. They return the lowercase of any uppercase ASCII-range code
        point. All other inputs are returned unchanged. Since these are macros,
        the input type may be any integral one, and the output will occupy the
        same number of bits as the input.</p>
    <p class="Pp"><span class="Li">&quot;toLOWER_L1&quot;</span> and
        <span class="Li">&quot;toLOWER_LATIN1&quot;</span> are synonyms of each
        other. They behave identically as
        <span class="Li">&quot;toLOWER&quot;</span> for ASCII-range input. But
        additionally will return the lowercase of any uppercase code point in
        the entire 0..255 range, assuming a Latin-1 encoding (or the EBCDIC
        equivalent on such platforms).</p>
    <p class="Pp"><span class="Li">&quot;toLOWER_LC&quot;</span> returns the
        lowercase of the input code point according to the rules of the current
        POSIX locale. Input code points outside the range 0..255 are returned
        unchanged.</p>
    <p class="Pp"><span class="Li">&quot;toLOWER_uvchr&quot;</span> returns the
        lowercase of any Unicode code point. The return value is identical to
        that of <span class="Li">&quot;toLOWER_L1&quot;</span> for input code
        points in the 0..255 range. The lowercase of the vast majority of
        Unicode code points is the same as the code point itself. For these, and
        for code points above the legal Unicode maximum, this returns the input
        code point unchanged. It additionally stores the UTF-8 of the result
        into the buffer beginning at <span class="Li">&quot;s&quot;</span>, and
        its length in bytes into <span class="Li">*lenp</span>. The caller must
        have made <span class="Li">&quot;s&quot;</span> large enough to contain
        at least <span class="Li">&quot;UTF8_MAXBYTES_CASE+1&quot;</span> bytes
        to avoid possible overflow.</p>
    <p class="Pp">NOTE: the lowercase of a code point may be more than one code
        point. The return value of this function is only the first of these. The
        entire lowercase is returned in <span class="Li">&quot;s&quot;</span>.
        To determine if the result is more than a single code point, you can do
        something like this:</p>
    <p class="Pp"></p>
    <pre> uc = toLOWER_uvchr(cp, s, &amp;len);
 if (len &gt; UTF8SKIP(s)) { is multiple code points }
 else { is a single code point }
    </pre>
    <p class="Pp"><span class="Li">&quot;toLOWER_utf8&quot;</span> and
        <span class="Li">&quot;toLOWER_utf8_safe&quot;</span> are synonyms of
        each other. The only difference between these and
        <span class="Li">&quot;toLOWER_uvchr&quot;</span> is that the source for
        these is encoded in UTF-8, instead of being a code point. It is passed
        as a buffer starting at <span class="Li">&quot;p&quot;</span>, with
        <span class="Li">&quot;e&quot;</span> pointing to one byte beyond its
        end. The <span class="Li">&quot;p&quot;</span> buffer may certainly
        contain more than one code point; but only the first one (up through
        <span class="Li">&quot;e&#x00A0;-&#x00A0;1&quot;</span>) is examined. If
        the UTF-8 for the input character is malformed in some way, the program
        may croak, or the function may return the REPLACEMENT CHARACTER, at the
        discretion of the implementation, and subject to change in future
        releases.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> UV  toLOWER          (UV cp)
 UV  toLOWER_A        (UV cp)
 UV  toLOWER_L1       (UV cp)
 UV  toLOWER_LATIN1   (UV cp)
 UV  toLOWER_LC       (UV cp)
 UV  toLOWER_uvchr    (UV cp, U8* s, STRLEN* lenp)
 UV  toLOWER_utf8     (U8* p, U8* e, U8* s, STRLEN* lenp)
 UV  toLOWER_utf8_safe(U8* p, U8* e, U8* s, STRLEN* lenp)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;toTITLE&quot;</dt>
  <dd>Converts the specified character to titlecase. If the input is anything
      but an ASCII lowercase character, that input character itself is returned.
      Variant <span class="Li">&quot;toTITLE_A&quot;</span> is equivalent.
      (There is no <span class="Li">&quot;toTITLE_L1&quot;</span> for the full
      Latin1 range, as the full generality of &quot;toTITLE_uvchr&quot; is
      needed there. Titlecase is not a concept used in locale handling, so there
      is no functionality for that.)</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> U8  toTITLE(U8 ch)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;toTITLE_utf8&quot;</dt>
  <dd></dd>
  <dt>&quot;toTITLE_utf8_safe&quot;</dt>
  <dd>Convert the first UTF-8 encoded character in the sequence starting at
      <span class="Li">&quot;p&quot;</span> and extending no further than
      <span class="Li">&quot;e&#x00A0;-&#x00A0;1&quot;</span> to its titlecase
      version, and stores that in UTF-8 in
      <span class="Li">&quot;s&quot;</span>, and its length in bytes in
      <span class="Li">&quot;lenp&quot;</span>. Note that the buffer pointed to
      by <span class="Li">&quot;s&quot;</span> needs to be at least
      <span class="Li">&quot;UTF8_MAXBYTES_CASE+1&quot;</span> bytes since the
      titlecase version may be longer than the original character.
    <p class="Pp">The first code point of the titlecased version is returned
        (but note, as explained at the top of this section, that there may be
        more).</p>
    <p class="Pp">It will not attempt to read beyond
        <span class="Li">&quot;e&#x00A0;-&#x00A0;1&quot;</span>, provided that
        the constraint
        <span class="Li">&quot;s&#x00A0;&lt;&#x00A0;e&quot;</span> is true (this
        is asserted for in <span class="Li">&quot;-DDEBUGGING&quot;</span>
        builds). If the UTF-8 for the input character is malformed in some way,
        the program may croak, or the function may return the REPLACEMENT
        CHARACTER, at the discretion of the implementation, and subject to
        change in future releases.</p>
    <p class="Pp"><span class="Li">&quot;toTITLE_utf8_safe&quot;</span> is now
        just a different spelling of plain
        <span class="Li">&quot;toTITLE_utf8&quot;</span></p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> UV  toTITLE_utf8(U8* p, U8* e, U8* s, STRLEN* lenp)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;toTITLE_uvchr&quot;</dt>
  <dd>Converts the code point <span class="Li">&quot;cp&quot;</span> to its
      titlecase version, and stores that in UTF-8 in
      <span class="Li">&quot;s&quot;</span>, and its length in bytes in
      <span class="Li">&quot;lenp&quot;</span>. The code point is interpreted as
      native if less than 256; otherwise as Unicode. Note that the buffer
      pointed to by <span class="Li">&quot;s&quot;</span> needs to be at least
      <span class="Li">&quot;UTF8_MAXBYTES_CASE+1&quot;</span> bytes since the
      titlecase version may be longer than the original character.
    <p class="Pp">The first code point of the titlecased version is returned
        (but note, as explained at the top of this section, that there may be
        more).</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> UV  toTITLE_uvchr(UV cp, U8* s, STRLEN* lenp)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;toUPPER&quot;</dt>
  <dd>Converts the specified character to uppercase. If the input is anything
      but an ASCII lowercase character, that input character itself is returned.
      Variant <span class="Li">&quot;toUPPER_A&quot;</span> is equivalent.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> U8  toUPPER(int ch)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;toUPPER_utf8&quot;</dt>
  <dd></dd>
  <dt>&quot;toUPPER_utf8_safe&quot;</dt>
  <dd>Converts the first UTF-8 encoded character in the sequence starting at
      <span class="Li">&quot;p&quot;</span> and extending no further than
      <span class="Li">&quot;e&#x00A0;-&#x00A0;1&quot;</span> to its uppercase
      version, and stores that in UTF-8 in
      <span class="Li">&quot;s&quot;</span>, and its length in bytes in
      <span class="Li">&quot;lenp&quot;</span>. Note that the buffer pointed to
      by <span class="Li">&quot;s&quot;</span> needs to be at least
      <span class="Li">&quot;UTF8_MAXBYTES_CASE+1&quot;</span> bytes since the
      uppercase version may be longer than the original character.
    <p class="Pp">The first code point of the uppercased version is returned
        (but note, as explained at the top of this section, that there may be
        more).</p>
    <p class="Pp">It will not attempt to read beyond
        <span class="Li">&quot;e&#x00A0;-&#x00A0;1&quot;</span>, provided that
        the constraint
        <span class="Li">&quot;s&#x00A0;&lt;&#x00A0;e&quot;</span> is true (this
        is asserted for in <span class="Li">&quot;-DDEBUGGING&quot;</span>
        builds). If the UTF-8 for the input character is malformed in some way,
        the program may croak, or the function may return the REPLACEMENT
        CHARACTER, at the discretion of the implementation, and subject to
        change in future releases.</p>
    <p class="Pp"><span class="Li">&quot;toUPPER_utf8_safe&quot;</span> is now
        just a different spelling of plain
        <span class="Li">&quot;toUPPER_utf8&quot;</span></p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> UV  toUPPER_utf8(U8* p, U8* e, U8* s, STRLEN* lenp)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;toUPPER_uvchr&quot;</dt>
  <dd>Converts the code point <span class="Li">&quot;cp&quot;</span> to its
      uppercase version, and stores that in UTF-8 in
      <span class="Li">&quot;s&quot;</span>, and its length in bytes in
      <span class="Li">&quot;lenp&quot;</span>. The code point is interpreted as
      native if less than 256; otherwise as Unicode. Note that the buffer
      pointed to by <span class="Li">&quot;s&quot;</span> needs to be at least
      <span class="Li">&quot;UTF8_MAXBYTES_CASE+1&quot;</span> bytes since the
      uppercase version may be longer than the original character.
    <p class="Pp">The first code point of the uppercased version is returned
        (but note, as explained at the top of this section, that there may be
        more.)</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> UV  toUPPER_uvchr(UV cp, U8* s, STRLEN* lenp)
</pre>
</div>
<div class="Bd-indent"></div>
</section>
<section class="Sh">
<h1 class="Sh" id="Character_classification"><a class="permalink" href="#Character_classification">Character
  classification</a></h1>
<p class="Pp">This section is about functions (really macros) that classify
    characters into types, such as punctuation versus alphabetic, etc. Most of
    these are analogous to regular expression character classes. (See
    &quot;POSIX Character Classes&quot; in perlrecharclass.) There are several
    variants for each class. (Not all macros have all variants; each item below
    lists the ones valid for it.) None are affected by
    <span class="Li">&quot;use bytes&quot;</span>, and only the ones with
    <span class="Li">&quot;LC&quot;</span> in the name are affected by the
    current locale.</p>
<p class="Pp">The base function, e.g.,
    <span class="Li">&quot;isALPHA()&quot;</span>, takes any signed or unsigned
    value, treating it as a code point, and returns a boolean as to whether or
    not the character represented by it is (or on non-ASCII platforms,
    corresponds to) an ASCII character in the named class based on platform,
    Unicode, and Perl rules. If the input is a number that doesn't fit in an
    octet, FALSE is returned.</p>
<p class="Pp">Variant
    <span class="Li">&quot;is</span><span class="Li"><i>FOO</i></span><span class="Li">_A&quot;</span>
    (e.g., <span class="Li">&quot;isALPHA_A()&quot;</span>) is identical to the
    base function with no suffix <span class="Li">&quot;_A&quot;</span>. This
    variant is used to emphasize by its name that only ASCII-range characters
    can return TRUE.</p>
<p class="Pp">Variant
    <span class="Li">&quot;is</span><span class="Li"><i>FOO</i></span><span class="Li">_L1&quot;</span>
    imposes the Latin-1 (or EBCDIC equivalent) character set onto the platform.
    That is, the code points that are ASCII are unaffected, since ASCII is a
    subset of Latin-1. But the non-ASCII code points are treated as if they are
    Latin-1 characters. For example,
    <span class="Li">&quot;isWORDCHAR_L1()&quot;</span> will return true when
    called with the code point 0xDF, which is a word character in both ASCII and
    EBCDIC (though it represents different characters in each). If the input is
    a number that doesn't fit in an octet, FALSE is returned. (Perl's
    documentation uses a colloquial definition of Latin-1, to include all code
    points below 256.)</p>
<p class="Pp">Variant
    <span class="Li">&quot;is</span><span class="Li"><i>FOO</i></span><span class="Li">_uvchr&quot;</span>
    is exactly like the
    <span class="Li">&quot;is</span><span class="Li"><i>FOO</i></span><span class="Li">_L1&quot;</span>
    variant, for inputs below 256, but if the code point is larger than 255,
    Unicode rules are used to determine if it is in the character class. For
    example, <span class="Li">&quot;isWORDCHAR_uvchr(0x100)&quot;</span> returns
    TRUE, since 0x100 is LATIN CAPITAL LETTER A WITH MACRON in Unicode, and is a
    word character.</p>
<p class="Pp">Variants
    <span class="Li">&quot;is</span><span class="Li"><i>FOO</i></span><span class="Li">_utf8&quot;</span>
    and
    <span class="Li">&quot;is</span><span class="Li"><i>FOO</i></span><span class="Li">_utf8_safe&quot;</span>
    are like
    <span class="Li">&quot;is</span><span class="Li"><i>FOO</i></span><span class="Li">_uvchr&quot;</span>,
    but are used for UTF-8 encoded strings. The two forms are different names
    for the same thing. Each call to one of these classifies the first character
    of the string starting at <span class="Li">&quot;p&quot;</span>. The second
    parameter, <span class="Li">&quot;e&quot;</span>, points to anywhere in the
    string beyond the first character, up to one byte past the end of the entire
    string. Although both variants are identical, the suffix
    <span class="Li">&quot;_safe&quot;</span> in one name emphasizes that it
    will not attempt to read beyond
    <span class="Li">&quot;e&#x00A0;-&#x00A0;1&quot;</span>, provided that the
    constraint <span class="Li">&quot;s&#x00A0;&lt;&#x00A0;e&quot;</span> is
    true (this is asserted for in
    <span class="Li">&quot;-DDEBUGGING&quot;</span> builds). If the UTF-8 for
    the input character is malformed in some way, the program may croak, or the
    function may return FALSE, at the discretion of the implementation, and
    subject to change in future releases.</p>
<p class="Pp">Variant
    <span class="Li">&quot;is</span><span class="Li"><i>FOO</i></span><span class="Li">_LC&quot;</span>
    is like the
    <span class="Li">&quot;is</span><span class="Li"><i>FOO</i></span><span class="Li">_A&quot;</span>
    and
    <span class="Li">&quot;is</span><span class="Li"><i>FOO</i></span><span class="Li">_L1&quot;</span>
    variants, but the result is based on the current locale, which is what
    <span class="Li">&quot;LC&quot;</span> in the name stands for. If Perl can
    determine that the current locale is a UTF-8 locale, it uses the published
    Unicode rules; otherwise, it uses the C library function that gives the
    named classification. For example,
    <span class="Li">&quot;isDIGIT_LC()&quot;</span> when not in a UTF-8 locale
    returns the result of calling <span class="Li">&quot;isdigit()&quot;</span>.
    FALSE is always returned if the input won't fit into an octet. On some
    platforms where the C library function is known to be defective, Perl
    changes its result to follow the POSIX standard's rules.</p>
<p class="Pp">Variant
    <span class="Li">&quot;is</span><span class="Li"><i>FOO</i></span><span class="Li">_LC_uvchr&quot;</span>
    acts exactly like
    <span class="Li">&quot;is</span><span class="Li"><i>FOO</i></span><span class="Li">_LC&quot;</span>
    for inputs less than 256, but for larger ones it returns the Unicode
    classification of the code point.</p>
<p class="Pp">Variants
    <span class="Li">&quot;is</span><span class="Li"><i>FOO</i></span><span class="Li">_LC_utf8&quot;</span>
    and
    <span class="Li">&quot;is</span><span class="Li"><i>FOO</i></span><span class="Li">_LC_utf8_safe&quot;</span>
    are like
    <span class="Li">&quot;is</span><span class="Li"><i>FOO</i></span><span class="Li">_LC_uvchr&quot;</span>,
    but are used for UTF-8 encoded strings. The two forms are different names
    for the same thing. Each call to one of these classifies the first character
    of the string starting at <span class="Li">&quot;p&quot;</span>. The second
    parameter, <span class="Li">&quot;e&quot;</span>, points to anywhere in the
    string beyond the first character, up to one byte past the end of the entire
    string. Although both variants are identical, the suffix
    <span class="Li">&quot;_safe&quot;</span> in one name emphasizes that it
    will not attempt to read beyond
    <span class="Li">&quot;e&#x00A0;-&#x00A0;1&quot;</span>, provided that the
    constraint <span class="Li">&quot;s&#x00A0;&lt;&#x00A0;e&quot;</span> is
    true (this is asserted for in
    <span class="Li">&quot;-DDEBUGGING&quot;</span> builds). If the UTF-8 for
    the input character is malformed in some way, the program may croak, or the
    function may return FALSE, at the discretion of the implementation, and
    subject to change in future releases.</p>
<dl class="Bl-tag">
  <dt>&quot;isALPHA&quot;</dt>
  <dd></dd>
  <dt>&quot;isALPHA_A&quot;</dt>
  <dd></dd>
  <dt>&quot;isALPHA_L1&quot;</dt>
  <dd></dd>
  <dt>&quot;isALPHA_uvchr&quot;</dt>
  <dd></dd>
  <dt>&quot;isALPHA_utf8_safe&quot;</dt>
  <dd></dd>
  <dt>&quot;isALPHA_utf8&quot;</dt>
  <dd></dd>
  <dt>&quot;isALPHA_LC&quot;</dt>
  <dd></dd>
  <dt>&quot;isALPHA_LC_uvchr&quot;</dt>
  <dd></dd>
  <dt>&quot;isALPHA_LC_utf8_safe&quot;</dt>
  <dd>Returns a boolean indicating whether the specified input is one of
      <span class="Li">&quot;[A-Za-z]&quot;</span>, analogous to
      <span class="Li">&quot;m/[[:alpha:]]/&quot;</span>. See the top of this
      section for an explanation of the variants.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> bool  isALPHA             (UV ch)
 bool  isALPHA_A           (UV ch)
 bool  isALPHA_L1          (UV ch)
 bool  isALPHA_uvchr       (UV ch)
 bool  isALPHA_utf8_safe   (U8 * s, U8 * end)
 bool  isALPHA_utf8        (U8 * s, U8 * end)
 bool  isALPHA_LC          (UV ch)
 bool  isALPHA_LC_uvchr    (UV ch)
 bool  isALPHA_LC_utf8_safe(U8 * s, U8 *end)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;isALPHANUMERIC&quot;</dt>
  <dd></dd>
  <dt>&quot;isALPHANUMERIC_A&quot;</dt>
  <dd></dd>
  <dt>&quot;isALPHANUMERIC_L1&quot;</dt>
  <dd></dd>
  <dt>&quot;isALPHANUMERIC_uvchr&quot;</dt>
  <dd></dd>
  <dt>&quot;isALPHANUMERIC_utf8_safe&quot;</dt>
  <dd></dd>
  <dt>&quot;isALPHANUMERIC_utf8&quot;</dt>
  <dd></dd>
  <dt>&quot;isALPHANUMERIC_LC&quot;</dt>
  <dd></dd>
  <dt>&quot;isALPHANUMERIC_LC_uvchr&quot;</dt>
  <dd></dd>
  <dt>&quot;isALPHANUMERIC_LC_utf8_safe&quot;</dt>
  <dd></dd>
  <dt>&quot;isALNUMC&quot;</dt>
  <dd></dd>
  <dt>&quot;isALNUMC_A&quot;</dt>
  <dd></dd>
  <dt>&quot;isALNUMC_L1&quot;</dt>
  <dd></dd>
  <dt>&quot;isALNUMC_LC&quot;</dt>
  <dd></dd>
  <dt>&quot;isALNUMC_LC_uvchr&quot;</dt>
  <dd>Returns a boolean indicating whether the specified character is one of
      <span class="Li">&quot;[A-Za-z0-9]&quot;</span>, analogous to
      <span class="Li">&quot;m/[[:alnum:]]/&quot;</span>. See the top of this
      section for an explanation of the variants.
    <p class="Pp">A (discouraged from use) synonym is
        <span class="Li">&quot;isALNUMC&quot;</span> (where the
        <span class="Li">&quot;C&quot;</span> suffix means this corresponds to
        the C language alphanumeric definition). Also there are the variants
        <span class="Li">&quot;isALNUMC_A&quot;</span>,
        <span class="Li">&quot;isALNUMC_L1&quot;</span>
        <span class="Li">&quot;isALNUMC_LC&quot;</span>, and
        <span class="Li">&quot;isALNUMC_LC_uvchr&quot;</span>.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> bool  isALPHANUMERIC             (UV ch)
 bool  isALPHANUMERIC_A           (UV ch)
 bool  isALPHANUMERIC_L1          (UV ch)
 bool  isALPHANUMERIC_uvchr       (UV ch)
 bool  isALPHANUMERIC_utf8_safe   (U8 * s, U8 * end)
 bool  isALPHANUMERIC_utf8        (U8 * s, U8 * end)
 bool  isALPHANUMERIC_LC          (UV ch)
 bool  isALPHANUMERIC_LC_uvchr    (UV ch)
 bool  isALPHANUMERIC_LC_utf8_safe(U8 * s, U8 *end)
 bool  isALNUMC                   (UV ch)
 bool  isALNUMC_A                 (UV ch)
 bool  isALNUMC_L1                (UV ch)
 bool  isALNUMC_LC                (UV ch)
 bool  isALNUMC_LC_uvchr          (UV ch)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;isASCII&quot;</dt>
  <dd></dd>
  <dt>&quot;isASCII_A&quot;</dt>
  <dd></dd>
  <dt>&quot;isASCII_L1&quot;</dt>
  <dd></dd>
  <dt>&quot;isASCII_uvchr&quot;</dt>
  <dd></dd>
  <dt>&quot;isASCII_utf8_safe&quot;</dt>
  <dd></dd>
  <dt>&quot;isASCII_utf8&quot;</dt>
  <dd></dd>
  <dt>&quot;isASCII_LC&quot;</dt>
  <dd></dd>
  <dt>&quot;isASCII_LC_uvchr&quot;</dt>
  <dd></dd>
  <dt>&quot;isASCII_LC_utf8_safe&quot;</dt>
  <dd>Returns a boolean indicating whether the specified character is one of the
      128 characters in the ASCII character set, analogous to
      <span class="Li">&quot;m/[[:ascii:]]/&quot;</span>. On non-ASCII
      platforms, it returns TRUE iff this character corresponds to an ASCII
      character. Variants <span class="Li">&quot;isASCII_A()&quot;</span> and
      <span class="Li">&quot;isASCII_L1()&quot;</span> are identical to
      <span class="Li">&quot;isASCII()&quot;</span>. See the top of this section
      for an explanation of the variants. Note, however, that some platforms do
      not have the C library routine
      <span class="Li">&quot;isascii()&quot;</span>. In these cases, the
      variants whose names contain <span class="Li">&quot;LC&quot;</span> are
      the same as the corresponding ones without.
    <p class="Pp">Also note, that because all ASCII characters are UTF-8
        invariant (meaning they have the exact same representation (always a
        single byte) whether encoded in UTF-8 or not),
        <span class="Li">&quot;isASCII&quot;</span> will give the correct
        results when called with any byte in any string encoded or not in UTF-8.
        And similarly <span class="Li">&quot;isASCII_utf8&quot;</span> and
        <span class="Li">&quot;isASCII_utf8_safe&quot;</span> will work properly
        on any string encoded or not in UTF-8.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> bool  isASCII             (UV ch)
 bool  isASCII_A           (UV ch)
 bool  isASCII_L1          (UV ch)
 bool  isASCII_uvchr       (UV ch)
 bool  isASCII_utf8_safe   (U8 * s, U8 * end)
 bool  isASCII_utf8        (U8 * s, U8 * end)
 bool  isASCII_LC          (UV ch)
 bool  isASCII_LC_uvchr    (UV ch)
 bool  isASCII_LC_utf8_safe(U8 * s, U8 *end)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;isBLANK&quot;</dt>
  <dd></dd>
  <dt>&quot;isBLANK_A&quot;</dt>
  <dd></dd>
  <dt>&quot;isBLANK_L1&quot;</dt>
  <dd></dd>
  <dt>&quot;isBLANK_uvchr&quot;</dt>
  <dd></dd>
  <dt>&quot;isBLANK_utf8_safe&quot;</dt>
  <dd></dd>
  <dt>&quot;isBLANK_utf8&quot;</dt>
  <dd></dd>
  <dt>&quot;isBLANK_LC&quot;</dt>
  <dd></dd>
  <dt>&quot;isBLANK_LC_uvchr&quot;</dt>
  <dd></dd>
  <dt>&quot;isBLANK_LC_utf8_safe&quot;</dt>
  <dd>Returns a boolean indicating whether the specified character is a
      character considered to be a blank, analogous to
      <span class="Li">&quot;m/[[:blank:]]/&quot;</span>. See the top of this
      section for an explanation of the variants. Note, however, that some
      platforms do not have the C library routine
      <span class="Li">&quot;isblank()&quot;</span>. In these cases, the
      variants whose names contain <span class="Li">&quot;LC&quot;</span> are
      the same as the corresponding ones without.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> bool  isBLANK             (UV ch)
 bool  isBLANK_A           (UV ch)
 bool  isBLANK_L1          (UV ch)
 bool  isBLANK_uvchr       (UV ch)
 bool  isBLANK_utf8_safe   (U8 * s, U8 * end)
 bool  isBLANK_utf8        (U8 * s, U8 * end)
 bool  isBLANK_LC          (UV ch)
 bool  isBLANK_LC_uvchr    (UV ch)
 bool  isBLANK_LC_utf8_safe(U8 * s, U8 *end)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;isCNTRL&quot;</dt>
  <dd></dd>
  <dt>&quot;isCNTRL_A&quot;</dt>
  <dd></dd>
  <dt>&quot;isCNTRL_L1&quot;</dt>
  <dd></dd>
  <dt>&quot;isCNTRL_uvchr&quot;</dt>
  <dd></dd>
  <dt>&quot;isCNTRL_utf8_safe&quot;</dt>
  <dd></dd>
  <dt>&quot;isCNTRL_utf8&quot;</dt>
  <dd></dd>
  <dt>&quot;isCNTRL_LC&quot;</dt>
  <dd></dd>
  <dt>&quot;isCNTRL_LC_uvchr&quot;</dt>
  <dd></dd>
  <dt>&quot;isCNTRL_LC_utf8_safe&quot;</dt>
  <dd>Returns a boolean indicating whether the specified character is a control
      character, analogous to
      <span class="Li">&quot;m/[[:cntrl:]]/&quot;</span>. See the top of this
      section for an explanation of the variants. On EBCDIC platforms, you
      almost always want to use the
      <span class="Li">&quot;isCNTRL_L1&quot;</span> variant.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> bool  isCNTRL             (UV ch)
 bool  isCNTRL_A           (UV ch)
 bool  isCNTRL_L1          (UV ch)
 bool  isCNTRL_uvchr       (UV ch)
 bool  isCNTRL_utf8_safe   (U8 * s, U8 * end)
 bool  isCNTRL_utf8        (U8 * s, U8 * end)
 bool  isCNTRL_LC          (UV ch)
 bool  isCNTRL_LC_uvchr    (UV ch)
 bool  isCNTRL_LC_utf8_safe(U8 * s, U8 *end)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;isDIGIT&quot;</dt>
  <dd></dd>
  <dt>&quot;isDIGIT_A&quot;</dt>
  <dd></dd>
  <dt>&quot;isDIGIT_L1&quot;</dt>
  <dd></dd>
  <dt>&quot;isDIGIT_uvchr&quot;</dt>
  <dd></dd>
  <dt>&quot;isDIGIT_utf8_safe&quot;</dt>
  <dd></dd>
  <dt>&quot;isDIGIT_utf8&quot;</dt>
  <dd></dd>
  <dt>&quot;isDIGIT_LC&quot;</dt>
  <dd></dd>
  <dt>&quot;isDIGIT_LC_uvchr&quot;</dt>
  <dd></dd>
  <dt>&quot;isDIGIT_LC_utf8_safe&quot;</dt>
  <dd>Returns a boolean indicating whether the specified character is a digit,
      analogous to <span class="Li">&quot;m/[[:digit:]]/&quot;</span>. Variants
      <span class="Li">&quot;isDIGIT_A&quot;</span> and
      <span class="Li">&quot;isDIGIT_L1&quot;</span> are identical to
      <span class="Li">&quot;isDIGIT&quot;</span>. See the top of this section
      for an explanation of the variants.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> bool  isDIGIT             (UV ch)
 bool  isDIGIT_A           (UV ch)
 bool  isDIGIT_L1          (UV ch)
 bool  isDIGIT_uvchr       (UV ch)
 bool  isDIGIT_utf8_safe   (U8 * s, U8 * end)
 bool  isDIGIT_utf8        (U8 * s, U8 * end)
 bool  isDIGIT_LC          (UV ch)
 bool  isDIGIT_LC_uvchr    (UV ch)
 bool  isDIGIT_LC_utf8_safe(U8 * s, U8 *end)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;isGRAPH&quot;</dt>
  <dd></dd>
  <dt>&quot;isGRAPH_A&quot;</dt>
  <dd></dd>
  <dt>&quot;isGRAPH_L1&quot;</dt>
  <dd></dd>
  <dt>&quot;isGRAPH_uvchr&quot;</dt>
  <dd></dd>
  <dt>&quot;isGRAPH_utf8_safe&quot;</dt>
  <dd></dd>
  <dt>&quot;isGRAPH_utf8&quot;</dt>
  <dd></dd>
  <dt>&quot;isGRAPH_LC&quot;</dt>
  <dd></dd>
  <dt>&quot;isGRAPH_LC_uvchr&quot;</dt>
  <dd></dd>
  <dt>&quot;isGRAPH_LC_utf8_safe&quot;</dt>
  <dd>Returns a boolean indicating whether the specified character is a graphic
      character, analogous to
      <span class="Li">&quot;m/[[:graph:]]/&quot;</span>. See the top of this
      section for an explanation of the variants.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> bool  isGRAPH             (UV ch)
 bool  isGRAPH_A           (UV ch)
 bool  isGRAPH_L1          (UV ch)
 bool  isGRAPH_uvchr       (UV ch)
 bool  isGRAPH_utf8_safe   (U8 * s, U8 * end)
 bool  isGRAPH_utf8        (U8 * s, U8 * end)
 bool  isGRAPH_LC          (UV ch)
 bool  isGRAPH_LC_uvchr    (UV ch)
 bool  isGRAPH_LC_utf8_safe(U8 * s, U8 *end)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;isIDCONT&quot;</dt>
  <dd></dd>
  <dt>&quot;isIDCONT_A&quot;</dt>
  <dd></dd>
  <dt>&quot;isIDCONT_L1&quot;</dt>
  <dd></dd>
  <dt>&quot;isIDCONT_uvchr&quot;</dt>
  <dd></dd>
  <dt>&quot;isIDCONT_utf8_safe&quot;</dt>
  <dd></dd>
  <dt>&quot;isIDCONT_utf8&quot;</dt>
  <dd></dd>
  <dt>&quot;isIDCONT_LC&quot;</dt>
  <dd></dd>
  <dt>&quot;isIDCONT_LC_uvchr&quot;</dt>
  <dd></dd>
  <dt>&quot;isIDCONT_LC_utf8_safe&quot;</dt>
  <dd>Returns a boolean indicating whether the specified character can be the
      second or succeeding character of an identifier. This is very close to,
      but not quite the same as the official Unicode property
      <span class="Li">&quot;XID_Continue&quot;</span>. The difference is that
      this returns true only if the input character also matches
      &quot;isWORDCHAR&quot;. See the top of this section for an explanation of
      the variants.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> bool  isIDCONT             (UV ch)
 bool  isIDCONT_A           (UV ch)
 bool  isIDCONT_L1          (UV ch)
 bool  isIDCONT_uvchr       (UV ch)
 bool  isIDCONT_utf8_safe   (U8 * s, U8 * end)
 bool  isIDCONT_utf8        (U8 * s, U8 * end)
 bool  isIDCONT_LC          (UV ch)
 bool  isIDCONT_LC_uvchr    (UV ch)
 bool  isIDCONT_LC_utf8_safe(U8 * s, U8 *end)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;isIDFIRST&quot;</dt>
  <dd></dd>
  <dt>&quot;isIDFIRST_A&quot;</dt>
  <dd></dd>
  <dt>&quot;isIDFIRST_L1&quot;</dt>
  <dd></dd>
  <dt>&quot;isIDFIRST_uvchr&quot;</dt>
  <dd></dd>
  <dt>&quot;isIDFIRST_utf8_safe&quot;</dt>
  <dd></dd>
  <dt>&quot;isIDFIRST_utf8&quot;</dt>
  <dd></dd>
  <dt>&quot;isIDFIRST_LC&quot;</dt>
  <dd></dd>
  <dt>&quot;isIDFIRST_LC_uvchr&quot;</dt>
  <dd></dd>
  <dt>&quot;isIDFIRST_LC_utf8_safe&quot;</dt>
  <dd>Returns a boolean indicating whether the specified character can be the
      first character of an identifier. This is very close to, but not quite the
      same as the official Unicode property
      <span class="Li">&quot;XID_Start&quot;</span>. The difference is that this
      returns true only if the input character also matches
      &quot;isWORDCHAR&quot;. See the top of this section for an explanation of
      the variants.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> bool  isIDFIRST             (UV ch)
 bool  isIDFIRST_A           (UV ch)
 bool  isIDFIRST_L1          (UV ch)
 bool  isIDFIRST_uvchr       (UV ch)
 bool  isIDFIRST_utf8_safe   (U8 * s, U8 * end)
 bool  isIDFIRST_utf8        (U8 * s, U8 * end)
 bool  isIDFIRST_LC          (UV ch)
 bool  isIDFIRST_LC_uvchr    (UV ch)
 bool  isIDFIRST_LC_utf8_safe(U8 * s, U8 *end)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;isLOWER&quot;</dt>
  <dd></dd>
  <dt>&quot;isLOWER_A&quot;</dt>
  <dd></dd>
  <dt>&quot;isLOWER_L1&quot;</dt>
  <dd></dd>
  <dt>&quot;isLOWER_uvchr&quot;</dt>
  <dd></dd>
  <dt>&quot;isLOWER_utf8_safe&quot;</dt>
  <dd></dd>
  <dt>&quot;isLOWER_utf8&quot;</dt>
  <dd></dd>
  <dt>&quot;isLOWER_LC&quot;</dt>
  <dd></dd>
  <dt>&quot;isLOWER_LC_uvchr&quot;</dt>
  <dd></dd>
  <dt>&quot;isLOWER_LC_utf8_safe&quot;</dt>
  <dd>Returns a boolean indicating whether the specified character is a
      lowercase character, analogous to
      <span class="Li">&quot;m/[[:lower:]]/&quot;</span>. See the top of this
      section for an explanation of the variants</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> bool  isLOWER             (UV ch)
 bool  isLOWER_A           (UV ch)
 bool  isLOWER_L1          (UV ch)
 bool  isLOWER_uvchr       (UV ch)
 bool  isLOWER_utf8_safe   (U8 * s, U8 * end)
 bool  isLOWER_utf8        (U8 * s, U8 * end)
 bool  isLOWER_LC          (UV ch)
 bool  isLOWER_LC_uvchr    (UV ch)
 bool  isLOWER_LC_utf8_safe(U8 * s, U8 *end)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;isOCTAL&quot;</dt>
  <dd></dd>
  <dt>&quot;isOCTAL_A&quot;</dt>
  <dd></dd>
  <dt>&quot;isOCTAL_L1&quot;</dt>
  <dd>Returns a boolean indicating whether the specified character is an octal
      digit, [0-7]. The only two variants are
      <span class="Li">&quot;isOCTAL_A&quot;</span> and
      <span class="Li">&quot;isOCTAL_L1&quot;</span>; each is identical to
      <span class="Li">&quot;isOCTAL&quot;</span>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> bool  isOCTAL(UV ch)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;isPRINT&quot;</dt>
  <dd></dd>
  <dt>&quot;isPRINT_A&quot;</dt>
  <dd></dd>
  <dt>&quot;isPRINT_L1&quot;</dt>
  <dd></dd>
  <dt>&quot;isPRINT_uvchr&quot;</dt>
  <dd></dd>
  <dt>&quot;isPRINT_utf8_safe&quot;</dt>
  <dd></dd>
  <dt>&quot;isPRINT_utf8&quot;</dt>
  <dd></dd>
  <dt>&quot;isPRINT_LC&quot;</dt>
  <dd></dd>
  <dt>&quot;isPRINT_LC_uvchr&quot;</dt>
  <dd></dd>
  <dt>&quot;isPRINT_LC_utf8_safe&quot;</dt>
  <dd>Returns a boolean indicating whether the specified character is a
      printable character, analogous to
      <span class="Li">&quot;m/[[:print:]]/&quot;</span>. See the top of this
      section for an explanation of the variants.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> bool  isPRINT             (UV ch)
 bool  isPRINT_A           (UV ch)
 bool  isPRINT_L1          (UV ch)
 bool  isPRINT_uvchr       (UV ch)
 bool  isPRINT_utf8_safe   (U8 * s, U8 * end)
 bool  isPRINT_utf8        (U8 * s, U8 * end)
 bool  isPRINT_LC          (UV ch)
 bool  isPRINT_LC_uvchr    (UV ch)
 bool  isPRINT_LC_utf8_safe(U8 * s, U8 *end)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;isPSXSPC&quot;</dt>
  <dd></dd>
  <dt>&quot;isPSXSPC_A&quot;</dt>
  <dd></dd>
  <dt>&quot;isPSXSPC_L1&quot;</dt>
  <dd></dd>
  <dt>&quot;isPSXSPC_uvchr&quot;</dt>
  <dd></dd>
  <dt>&quot;isPSXSPC_utf8_safe&quot;</dt>
  <dd></dd>
  <dt>&quot;isPSXSPC_utf8&quot;</dt>
  <dd></dd>
  <dt>&quot;isPSXSPC_LC&quot;</dt>
  <dd></dd>
  <dt>&quot;isPSXSPC_LC_uvchr&quot;</dt>
  <dd></dd>
  <dt>&quot;isPSXSPC_LC_utf8_safe&quot;</dt>
  <dd>(short for Posix Space) Starting in 5.18, this is identical in all its
      forms to the corresponding <span class="Li">&quot;isSPACE()&quot;</span>
      macros. The locale forms of this macro are identical to their
      corresponding <span class="Li">&quot;isSPACE()&quot;</span> forms in all
      Perl releases. In releases prior to 5.18, the non-locale forms differ from
      their <span class="Li">&quot;isSPACE()&quot;</span> forms only in that the
      <span class="Li">&quot;isSPACE()&quot;</span> forms don't match a Vertical
      Tab, and the <span class="Li">&quot;isPSXSPC()&quot;</span> forms do.
      Otherwise they are identical. Thus this macro is analogous to what
      <span class="Li">&quot;m/[[:space:]]/&quot;</span> matches in a regular
      expression. See the top of this section for an explanation of the
      variants.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> bool  isPSXSPC             (UV ch)
 bool  isPSXSPC_A           (UV ch)
 bool  isPSXSPC_L1          (UV ch)
 bool  isPSXSPC_uvchr       (UV ch)
 bool  isPSXSPC_utf8_safe   (U8 * s, U8 * end)
 bool  isPSXSPC_utf8        (U8 * s, U8 * end)
 bool  isPSXSPC_LC          (UV ch)
 bool  isPSXSPC_LC_uvchr    (UV ch)
 bool  isPSXSPC_LC_utf8_safe(U8 * s, U8 *end)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;isPUNCT&quot;</dt>
  <dd></dd>
  <dt>&quot;isPUNCT_A&quot;</dt>
  <dd></dd>
  <dt>&quot;isPUNCT_L1&quot;</dt>
  <dd></dd>
  <dt>&quot;isPUNCT_uvchr&quot;</dt>
  <dd></dd>
  <dt>&quot;isPUNCT_utf8_safe&quot;</dt>
  <dd></dd>
  <dt>&quot;isPUNCT_utf8&quot;</dt>
  <dd></dd>
  <dt>&quot;isPUNCT_LC&quot;</dt>
  <dd></dd>
  <dt>&quot;isPUNCT_LC_uvchr&quot;</dt>
  <dd></dd>
  <dt>&quot;isPUNCT_LC_utf8_safe&quot;</dt>
  <dd>Returns a boolean indicating whether the specified character is a
      punctuation character, analogous to
      <span class="Li">&quot;m/[[:punct:]]/&quot;</span>. Note that the
      definition of what is punctuation isn't as straightforward as one might
      desire. See &quot;POSIX Character Classes&quot; in perlrecharclass for
      details. See the top of this section for an explanation of the
    variants.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> bool  isPUNCT             (UV ch)
 bool  isPUNCT_A           (UV ch)
 bool  isPUNCT_L1          (UV ch)
 bool  isPUNCT_uvchr       (UV ch)
 bool  isPUNCT_utf8_safe   (U8 * s, U8 * end)
 bool  isPUNCT_utf8        (U8 * s, U8 * end)
 bool  isPUNCT_LC          (UV ch)
 bool  isPUNCT_LC_uvchr    (UV ch)
 bool  isPUNCT_LC_utf8_safe(U8 * s, U8 *end)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;isSPACE&quot;</dt>
  <dd></dd>
  <dt>&quot;isSPACE_A&quot;</dt>
  <dd></dd>
  <dt>&quot;isSPACE_L1&quot;</dt>
  <dd></dd>
  <dt>&quot;isSPACE_uvchr&quot;</dt>
  <dd></dd>
  <dt>&quot;isSPACE_utf8_safe&quot;</dt>
  <dd></dd>
  <dt>&quot;isSPACE_utf8&quot;</dt>
  <dd></dd>
  <dt>&quot;isSPACE_LC&quot;</dt>
  <dd></dd>
  <dt>&quot;isSPACE_LC_uvchr&quot;</dt>
  <dd></dd>
  <dt>&quot;isSPACE_LC_utf8_safe&quot;</dt>
  <dd>Returns a boolean indicating whether the specified character is a
      whitespace character. This is analogous to what
      <span class="Li">&quot;m/\s/&quot;</span> matches in a regular expression.
      Starting in Perl 5.18 this also matches what
      <span class="Li">&quot;m/[[:space:]]/&quot;</span> does. Prior to 5.18,
      only the locale forms of this macro (the ones with
      <span class="Li">&quot;LC&quot;</span> in their names) matched precisely
      what <span class="Li">&quot;m/[[:space:]]/&quot;</span> does. In those
      releases, the only difference, in the non-locale variants, was that
      <span class="Li">&quot;isSPACE()&quot;</span> did not match a vertical
      tab. (See &quot;isPSXSPC&quot; for a macro that matches a vertical tab in
      all releases.) See the top of this section for an explanation of the
      variants.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> bool  isSPACE             (UV ch)
 bool  isSPACE_A           (UV ch)
 bool  isSPACE_L1          (UV ch)
 bool  isSPACE_uvchr       (UV ch)
 bool  isSPACE_utf8_safe   (U8 * s, U8 * end)
 bool  isSPACE_utf8        (U8 * s, U8 * end)
 bool  isSPACE_LC          (UV ch)
 bool  isSPACE_LC_uvchr    (UV ch)
 bool  isSPACE_LC_utf8_safe(U8 * s, U8 *end)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;isUPPER&quot;</dt>
  <dd></dd>
  <dt>&quot;isUPPER_A&quot;</dt>
  <dd></dd>
  <dt>&quot;isUPPER_L1&quot;</dt>
  <dd></dd>
  <dt>&quot;isUPPER_uvchr&quot;</dt>
  <dd></dd>
  <dt>&quot;isUPPER_utf8_safe&quot;</dt>
  <dd></dd>
  <dt>&quot;isUPPER_utf8&quot;</dt>
  <dd></dd>
  <dt>&quot;isUPPER_LC&quot;</dt>
  <dd></dd>
  <dt>&quot;isUPPER_LC_uvchr&quot;</dt>
  <dd></dd>
  <dt>&quot;isUPPER_LC_utf8_safe&quot;</dt>
  <dd>Returns a boolean indicating whether the specified character is an
      uppercase character, analogous to
      <span class="Li">&quot;m/[[:upper:]]/&quot;</span>. See the top of this
      section for an explanation of the variants.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> bool  isUPPER             (UV ch)
 bool  isUPPER_A           (UV ch)
 bool  isUPPER_L1          (UV ch)
 bool  isUPPER_uvchr       (UV ch)
 bool  isUPPER_utf8_safe   (U8 * s, U8 * end)
 bool  isUPPER_utf8        (U8 * s, U8 * end)
 bool  isUPPER_LC          (UV ch)
 bool  isUPPER_LC_uvchr    (UV ch)
 bool  isUPPER_LC_utf8_safe(U8 * s, U8 *end)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;isWORDCHAR&quot;</dt>
  <dd></dd>
  <dt>&quot;isWORDCHAR_A&quot;</dt>
  <dd></dd>
  <dt>&quot;isWORDCHAR_L1&quot;</dt>
  <dd></dd>
  <dt>&quot;isWORDCHAR_uvchr&quot;</dt>
  <dd></dd>
  <dt>&quot;isWORDCHAR_utf8_safe&quot;</dt>
  <dd></dd>
  <dt>&quot;isWORDCHAR_utf8&quot;</dt>
  <dd></dd>
  <dt>&quot;isWORDCHAR_LC&quot;</dt>
  <dd></dd>
  <dt>&quot;isWORDCHAR_LC_uvchr&quot;</dt>
  <dd></dd>
  <dt>&quot;isWORDCHAR_LC_utf8_safe&quot;</dt>
  <dd></dd>
  <dt>&quot;isALNUM&quot;</dt>
  <dd></dd>
  <dt>&quot;isALNUM_A&quot;</dt>
  <dd></dd>
  <dt>&quot;isALNUM_LC&quot;</dt>
  <dd></dd>
  <dt>&quot;isALNUM_LC_uvchr&quot;</dt>
  <dd>Returns a boolean indicating whether the specified character is a
      character that is a word character, analogous to what
      <span class="Li">&quot;m/\w/&quot;</span> and
      <span class="Li">&quot;m/[[:word:]]/&quot;</span> match in a regular
      expression. A word character is an alphabetic character, a decimal digit,
      a connecting punctuation character (such as an underscore), or a
      &quot;mark&quot; character that attaches to one of those (like some sort
      of accent). <span class="Li">&quot;isALNUM()&quot;</span> is a synonym
      provided for backward compatibility, even though a word character includes
      more than the standard C language meaning of alphanumeric. See the top of
      this section for an explanation of the variants.
      <span class="Li">&quot;isWORDCHAR_A&quot;</span>,
      <span class="Li">&quot;isWORDCHAR_L1&quot;</span>,
      <span class="Li">&quot;isWORDCHAR_uvchr&quot;</span>,
      <span class="Li">&quot;isWORDCHAR_LC&quot;</span>,
      <span class="Li">&quot;isWORDCHAR_LC_uvchr&quot;</span>,
      <span class="Li">&quot;isWORDCHAR_LC_utf8&quot;</span>, and
      <span class="Li">&quot;isWORDCHAR_LC_utf8_safe&quot;</span> are also as
      described there, but additionally include the platform's native
      underscore.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> bool  isWORDCHAR             (UV ch)
 bool  isWORDCHAR_A           (UV ch)
 bool  isWORDCHAR_L1          (UV ch)
 bool  isWORDCHAR_uvchr       (UV ch)
 bool  isWORDCHAR_utf8_safe   (U8 * s, U8 * end)
 bool  isWORDCHAR_utf8        (U8 * s, U8 * end)
 bool  isWORDCHAR_LC          (UV ch)
 bool  isWORDCHAR_LC_uvchr    (UV ch)
 bool  isWORDCHAR_LC_utf8_safe(U8 * s, U8 *end)
 bool  isALNUM                (UV ch)
 bool  isALNUM_A              (UV ch)
 bool  isALNUM_LC             (UV ch)
 bool  isALNUM_LC_uvchr       (UV ch)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;isXDIGIT&quot;</dt>
  <dd></dd>
  <dt>&quot;isXDIGIT_A&quot;</dt>
  <dd></dd>
  <dt>&quot;isXDIGIT_L1&quot;</dt>
  <dd></dd>
  <dt>&quot;isXDIGIT_uvchr&quot;</dt>
  <dd></dd>
  <dt>&quot;isXDIGIT_utf8_safe&quot;</dt>
  <dd></dd>
  <dt>&quot;isXDIGIT_utf8&quot;</dt>
  <dd></dd>
  <dt>&quot;isXDIGIT_LC&quot;</dt>
  <dd></dd>
  <dt>&quot;isXDIGIT_LC_uvchr&quot;</dt>
  <dd></dd>
  <dt>&quot;isXDIGIT_LC_utf8_safe&quot;</dt>
  <dd>Returns a boolean indicating whether the specified character is a
      hexadecimal digit. In the ASCII range these are
      <span class="Li">&quot;[0-9A-Fa-f]&quot;</span>. Variants
      <span class="Li">&quot;isXDIGIT_A()&quot;</span> and
      <span class="Li">&quot;isXDIGIT_L1()&quot;</span> are identical to
      <span class="Li">&quot;isXDIGIT()&quot;</span>. See the top of this
      section for an explanation of the variants.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> bool  isXDIGIT             (UV ch)
 bool  isXDIGIT_A           (UV ch)
 bool  isXDIGIT_L1          (UV ch)
 bool  isXDIGIT_uvchr       (UV ch)
 bool  isXDIGIT_utf8_safe   (U8 * s, U8 * end)
 bool  isXDIGIT_utf8        (U8 * s, U8 * end)
 bool  isXDIGIT_LC          (UV ch)
 bool  isXDIGIT_LC_uvchr    (UV ch)
 bool  isXDIGIT_LC_utf8_safe(U8 * s, U8 *end)
</pre>
</div>
<div class="Bd-indent"></div>
</section>
<section class="Sh">
<h1 class="Sh" id="Compiler_and_Preprocessor_information"><a class="permalink" href="#Compiler_and_Preprocessor_information">Compiler
  and Preprocessor information</a></h1>
<dl class="Bl-tag">
  <dt>&quot;CPPLAST&quot;</dt>
  <dd>This symbol is intended to be used along with
      <span class="Li">&quot;CPPRUN&quot;</span> in the same manner symbol
      <span class="Li">&quot;CPPMINUS&quot;</span> is used with
      <span class="Li">&quot;CPPSTDIN&quot;</span>. It contains either
      &quot;-&quot; or &quot;&quot;.</dd>
  <dt>&quot;CPPMINUS&quot;</dt>
  <dd>This symbol contains the second part of the string which will invoke the C
      preprocessor on the standard input and produce to standard output. This
      symbol will have the value &quot;-&quot; if
      <span class="Li">&quot;CPPSTDIN&quot;</span> needs a minus to specify
      standard input, otherwise the value is &quot;&quot;.</dd>
  <dt>&quot;CPPRUN&quot;</dt>
  <dd>This symbol contains the string which will invoke a C preprocessor on the
      standard input and produce to standard output. It needs to end with
      <span class="Li">&quot;CPPLAST&quot;</span>, after all other preprocessor
      flags have been specified. The main difference with
      <span class="Li">&quot;CPPSTDIN&quot;</span> is that this program will
      never be a pointer to a shell wrapper, i.e. it will be empty if no
      preprocessor is available directly to the user. Note that it may well be
      different from the preprocessor used to compile the C program.</dd>
  <dt>&quot;CPPSTDIN&quot;</dt>
  <dd>This symbol contains the first part of the string which will invoke the C
      preprocessor on the standard input and produce to standard output. Typical
      value of &quot;cc -E&quot; or &quot;<i>/lib/cpp</i>&quot;, but it can also
      call a wrapper. See <span class="Li">&quot;CPPRUN&quot;</span>.</dd>
  <dt>&quot;HASATTRIBUTE_ALWAYS_INLINE&quot;</dt>
  <dd>Can we handle <span class="Li">&quot;GCC&quot;</span> attribute for
      functions that should always be inlined.</dd>
  <dt>&quot;HASATTRIBUTE_DEPRECATED&quot;</dt>
  <dd>Can we handle <span class="Li">&quot;GCC&quot;</span> attribute for
      marking deprecated <span class="Li">&quot;APIs&quot;</span></dd>
  <dt>&quot;HASATTRIBUTE_FORMAT&quot;</dt>
  <dd>Can we handle <span class="Li">&quot;GCC&quot;</span> attribute for
      checking printf-style formats</dd>
  <dt>&quot;HASATTRIBUTE_NONNULL&quot;</dt>
  <dd>Can we handle <span class="Li">&quot;GCC&quot;</span> attribute for
      nonnull function parms.</dd>
  <dt>&quot;HASATTRIBUTE_NORETURN&quot;</dt>
  <dd>Can we handle <span class="Li">&quot;GCC&quot;</span> attribute for
      functions that do not return</dd>
  <dt>&quot;HASATTRIBUTE_PURE&quot;</dt>
  <dd>Can we handle <span class="Li">&quot;GCC&quot;</span> attribute for pure
      functions</dd>
  <dt>&quot;HASATTRIBUTE_UNUSED&quot;</dt>
  <dd>Can we handle <span class="Li">&quot;GCC&quot;</span> attribute for unused
      variables and arguments</dd>
  <dt>&quot;HASATTRIBUTE_WARN_UNUSED_RESULT&quot;</dt>
  <dd>Can we handle <span class="Li">&quot;GCC&quot;</span> attribute for
      warning on unused results</dd>
  <dt>&quot;HAS_BUILTIN_ADD_OVERFLOW&quot;</dt>
  <dd>This symbol, if defined, indicates that the compiler supports
      <span class="Li">&quot;__builtin_add_overflow&quot;</span> for adding
      integers with overflow checks.</dd>
  <dt>&quot;HAS_BUILTIN_CHOOSE_EXPR&quot;</dt>
  <dd>Can we handle <span class="Li">&quot;GCC&quot;</span> builtin for
      compile-time ternary-like expressions</dd>
  <dt>&quot;HAS_BUILTIN_EXPECT&quot;</dt>
  <dd>Can we handle <span class="Li">&quot;GCC&quot;</span> builtin for telling
      that certain values are more likely</dd>
  <dt>&quot;HAS_BUILTIN_MUL_OVERFLOW&quot;</dt>
  <dd>This symbol, if defined, indicates that the compiler supports
      <span class="Li">&quot;__builtin_mul_overflow&quot;</span> for multiplying
      integers with overflow checks.</dd>
  <dt>&quot;HAS_BUILTIN_SUB_OVERFLOW&quot;</dt>
  <dd>This symbol, if defined, indicates that the compiler supports
      <span class="Li">&quot;__builtin_sub_overflow&quot;</span> for subtracting
      integers with overflow checks.</dd>
  <dt>&quot;HAS_C99_VARIADIC_MACROS&quot;</dt>
  <dd>If defined, the compiler supports C99 variadic macros.</dd>
  <dt>&quot;HAS_STATIC_INLINE&quot;</dt>
  <dd>This symbol, if defined, indicates that the C compiler supports C99-style
      static inline. That is, the function can't be called from another
      translation unit.</dd>
  <dt>&quot;MEM_ALIGNBYTES&quot;</dt>
  <dd>This symbol contains the number of bytes required to align a double, or a
      long double when applicable. Usual values are 2, 4 and 8. The default is
      eight, for safety. For cross-compiling or multiarch support, Configure
      will set a minimum of 8.</dd>
  <dt>&quot;PERL_STATIC_INLINE&quot;</dt>
  <dd>This symbol gives the best-guess incantation to use for static inline
      functions. If <span class="Li">&quot;HAS_STATIC_INLINE&quot;</span> is
      defined, this will give C99-style inline. If
      <span class="Li">&quot;HAS_STATIC_INLINE&quot;</span> is not defined, this
      will give a plain 'static'. It will always be defined to something that
      gives static linkage. Possibilities include
    <p class="Pp"></p>
    <pre> static inline       (c99)
 static __inline__   (gcc -ansi)
 static __inline     (MSVC)
 static _inline      (older MSVC)
 static              (c89 compilers)
    </pre>
  </dd>
  <dt>&quot;U32_ALIGNMENT_REQUIRED&quot;</dt>
  <dd>This symbol, if defined, indicates that you must access character data
      through U32-aligned pointers.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="Compiler_directives"><a class="permalink" href="#Compiler_directives">Compiler
  directives</a></h1>
<dl class="Bl-tag">
  <dt>&quot;ASSUME&quot;</dt>
  <dd><span class="Li">&quot;ASSUME&quot;</span> is like
      <span class="Li">&quot;assert()&quot;</span>, but it has a benefit in a
      release build. It is a hint to a compiler about a statement of fact in a
      function call free expression, which allows the compiler to generate
      better machine code. In a debug build, <span class="Li">ASSUME(x)</span>
      is a synonym for <span class="Li">assert(x)</span>.
      <span class="Li">ASSUME(0)</span> means the control path is unreachable.
      In a for loop, <span class="Li">&quot;ASSUME&quot;</span> can be used to
      hint that a loop will run at least X times.
      <span class="Li">&quot;ASSUME&quot;</span> is based off MSVC's
      <span class="Li">&quot;__assume&quot;</span> intrinsic function, see its
      documents for more details.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre>   ASSUME(bool expr)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;dNOOP&quot;</dt>
  <dd>Declare nothing; typically used as a placeholder to replace something that
      used to declare something. Works on compilers that require declarations
      before any code.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre>   dNOOP;
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;END_EXTERN_C&quot;</dt>
  <dd>When not compiling using C++, expands to nothing. Otherwise ends a section
      of code already begun by a
      <span class="Li">&quot;START_EXTERN_C&quot;</span>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre>   END_EXTERN_C
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;EXTERN_C&quot;</dt>
  <dd>When not compiling using C++, expands to nothing. Otherwise is used in a
      declaration of a function to indicate the function should have external C
      linkage. This is required for things to work for just about all functions
      with external linkage compiled into perl. Often, you can use
      <span class="Li">&quot;START_EXTERN_C&quot;</span> ...
      <span class="Li">&quot;END_EXTERN_C&quot;</span> blocks surrounding all
      your code that you need to have this linkage.
    <p class="Pp">Example usage:</p>
    <p class="Pp"></p>
    <pre> EXTERN_C int flock(int fd, int op);
    </pre>
  </dd>
  <dt>&quot;LIKELY&quot;</dt>
  <dd>Returns the input unchanged, but at the same time it gives a branch
      prediction hint to the compiler that this condition is likely to be
    true.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre>   LIKELY(bool expr)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;NOOP&quot;</dt>
  <dd>Do nothing; typically used as a placeholder to replace something that used
      to do something.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre>   NOOP;
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;PERL_UNUSED_ARG&quot;</dt>
  <dd>This is used to suppress compiler warnings that a parameter to a function
      is not used. This situation can arise, for example, when a parameter is
      needed under some configuration conditions, but not others, so that C
      preprocessor conditional compilation causes it be used just some
    times.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre>   PERL_UNUSED_ARG(void x);
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;PERL_UNUSED_CONTEXT&quot;</dt>
  <dd>This is used to suppress compiler warnings that the thread context
      parameter to a function is not used. This situation can arise, for
      example, when a C preprocessor conditional compilation causes it be used
      just some times.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre>   PERL_UNUSED_CONTEXT;
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;PERL_UNUSED_DECL&quot;</dt>
  <dd>Tells the compiler that the parameter in the function prototype just
      before it is not necessarily expected to be used in the function. Not that
      many compilers understand this, so this should only be used in cases where
      <span class="Li">&quot;PERL_UNUSED_ARG&quot;</span> can't conveniently be
      used.
    <p class="Pp">Example usage:</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> Signal_t
 Perl_perly_sighandler(int sig, Siginfo_t *sip PERL_UNUSED_DECL,
                       void *uap PERL_UNUSED_DECL, bool safe)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;PERL_UNUSED_RESULT&quot;</dt>
  <dd>This macro indicates to discard the return value of the function call
      inside it, <i>e.g.</i>,
    <p class="Pp"></p>
    <pre> PERL_UNUSED_RESULT(foo(a, b))
    </pre>
    <p class="Pp">The main reason for this is that the combination of
        <span class="Li">&quot;gcc -Wunused-result&quot;</span> (part of
        <span class="Li">&quot;-Wall&quot;</span>) and the
        <span class="Li">&quot;__attribute__((warn_unused_result))&quot;</span>
        cannot be silenced with casting to
        <span class="Li">&quot;void&quot;</span>. This causes trouble when the
        system header files use the attribute.</p>
    <p class="Pp">Use <span class="Li">&quot;PERL_UNUSED_RESULT&quot;</span>
        sparingly, though, since usually the warning is there for a good reason:
        you might lose success/failure information, or leak resources, or
        changes in resources.</p>
    <p class="Pp">But sometimes you just want to ignore the return value,
        <i>e.g.</i>, on codepaths soon ending up in abort, or in &quot;best
        effort&quot; attempts, or in situations where there is no good way to
        handle failures.</p>
    <p class="Pp">Sometimes
        <span class="Li">&quot;PERL_UNUSED_RESULT&quot;</span> might not be the
        most natural way: another possibility is that you can capture the return
        value and use <span class="Li">&quot;PERL_UNUSED_VAR&quot;</span> on
        that.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre>   PERL_UNUSED_RESULT(void x)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;PERL_UNUSED_VAR&quot;</dt>
  <dd>This is used to suppress compiler warnings that the variable <i>x</i> is
      not used. This situation can arise, for example, when a C preprocessor
      conditional compilation causes it be used just some times.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre>   PERL_UNUSED_VAR(void x);
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;PERL_USE_GCC_BRACE_GROUPS&quot;</dt>
  <dd>This C pre-processor value, if defined, indicates that it is permissible
      to use the GCC brace groups extension. This extension, of the form
    <p class="Pp"></p>
    <pre> ({ statement ... })
    </pre>
    <p class="Pp">turns the block consisting of <i>statements ...</i> into an
        expression with a value, unlike plain C language blocks. This can
        present optimization possibilities, <b>BUT</b> you generally need to
        specify an alternative in case this ability doesn't exist or has
        otherwise been forbidden.</p>
    <p class="Pp">Example usage:</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> #ifdef PERL_USE_GCC_BRACE_GROUPS
   ...
 #else
   ...
 #endif
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;START_EXTERN_C&quot;</dt>
  <dd>When not compiling using C++, expands to nothing. Otherwise begins a
      section of code in which every function will effectively have
      <span class="Li">&quot;EXTERN_C&quot;</span> applied to it, that is to
      have external C linkage. The section is ended by a
      <span class="Li">&quot;END_EXTERN_C&quot;</span>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre>   START_EXTERN_C
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;STATIC&quot;</dt>
  <dd>Described in perlguts.</dd>
  <dt>&quot;STMT_START&quot;</dt>
  <dd></dd>
  <dt>&quot;STMT_END&quot;</dt>
  <dd>This allows a series of statements in a macro to be used as a single
      statement, as in
    <p class="Pp"></p>
    <pre> if (x) STMT_START { ... } STMT_END else ...
    </pre>
    <p class="Pp">Note that you can't return a value out of them, which limits
        their utility. But see
        <span class="Li">&quot;PERL_USE_GCC_BRACE_GROUPS&quot;</span>.</p>
  </dd>
  <dt>&quot;UNLIKELY&quot;</dt>
  <dd>Returns the input unchanged, but at the same time it gives a branch
      prediction hint to the compiler that this condition is likely to be
    false.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre>   UNLIKELY(bool expr)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;__ASSERT_&quot;</dt>
  <dd>This is a helper macro to avoid preprocessor issues, replaced by nothing
      unless under DEBUGGING, where it expands to an assert of its argument,
      followed by a comma (hence the comma operator). If we just used a straight
      <b>assert()</b>, we would get a comma with nothing before it when not
      DEBUGGING.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre>   __ASSERT_(bool expr)
</pre>
</div>
<div class="Bd-indent"></div>
</section>
<section class="Sh">
<h1 class="Sh" id="Compile-time_scope_hooks"><a class="permalink" href="#Compile-time_scope_hooks">Compile-time
  scope hooks</a></h1>
<dl class="Bl-tag">
  <dt>&quot;BhkDISABLE&quot;</dt>
  <dd>NOTE: <span class="Li">&quot;BhkDISABLE&quot;</span> is
      <b>experimental</b> and may change or be removed without notice.
    <p class="Pp">Temporarily disable an entry in this BHK structure, by
        clearing the appropriate flag. <span class="Li">&quot;which&quot;</span>
        is a preprocessor token indicating which entry to disable.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  BhkDISABLE(BHK *hk, which)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;BhkENABLE&quot;</dt>
  <dd>NOTE: <span class="Li">&quot;BhkENABLE&quot;</span> is <b>experimental</b>
      and may change or be removed without notice.
    <p class="Pp">Re-enable an entry in this BHK structure, by setting the
        appropriate flag. <span class="Li">&quot;which&quot;</span> is a
        preprocessor token indicating which entry to enable. This will assert
        (under -DDEBUGGING) if the entry doesn't contain a valid pointer.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  BhkENABLE(BHK *hk, which)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;BhkENTRY_set&quot;</dt>
  <dd>NOTE: <span class="Li">&quot;BhkENTRY_set&quot;</span> is
      <b>experimental</b> and may change or be removed without notice.
    <p class="Pp">Set an entry in the BHK structure, and set the flags to
        indicate it is valid. <span class="Li">&quot;which&quot;</span> is a
        preprocessing token indicating which entry to set. The type of
        <span class="Li">&quot;ptr&quot;</span> depends on the entry.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  BhkENTRY_set(BHK *hk, which, void *ptr)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;blockhook_register&quot;</dt>
  <dd>NOTE: <span class="Li">&quot;blockhook_register&quot;</span> is
      <b>experimental</b> and may change or be removed without notice.
    <p class="Pp">Register a set of hooks to be called when the Perl lexical
        scope changes at compile time. See &quot;Compile-time scope hooks&quot;
        in perlguts.</p>
    <p class="Pp">NOTE: <span class="Li">&quot;blockhook_register&quot;</span>
        must be explicitly called as
        <span class="Li">&quot;Perl_blockhook_register&quot;</span> with an
        <span class="Li">&quot;aTHX_&quot;</span> parameter.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  Perl_blockhook_register(pTHX_ BHK *hk)
</pre>
</div>
<div class="Bd-indent"></div>
</section>
<section class="Sh">
<h1 class="Sh" id="Concurrency"><a class="permalink" href="#Concurrency">Concurrency</a></h1>
<dl class="Bl-tag">
  <dt>&quot;aTHX&quot;</dt>
  <dd>Described in perlguts.</dd>
  <dt>&quot;aTHX_&quot;</dt>
  <dd>Described in perlguts.</dd>
  <dt>&quot;CPERLscope&quot;</dt>
  <dd><span class="Li">&quot;</span><span class="Li"><b>DEPRECATED!</b></span><span class="Li">&quot;</span>
      It is planned to remove <span class="Li">&quot;CPERLscope&quot;</span>
      from a future release of Perl. Do not use it for new code; remove it from
      existing code.
    <p class="Pp">Now a no-op.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  CPERLscope(void x)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;dTHR&quot;</dt>
  <dd>Described in perlguts.</dd>
  <dt>&quot;dTHX&quot;</dt>
  <dd>Described in perlguts.</dd>
  <dt>&quot;dTHXa&quot;</dt>
  <dd>On threaded perls, set <span class="Li">&quot;pTHX&quot;</span> to
      <span class="Li">&quot;a&quot;</span>; on unthreaded perls, do
    nothing</dd>
  <dt>&quot;dTHXoa&quot;</dt>
  <dd>Now a synonym for <span class="Li">&quot;dTHXa&quot;</span>.</dd>
  <dt>&quot;dVAR&quot;</dt>
  <dd>This is now a synonym for dNOOP: declare nothing</dd>
  <dt>&quot;GETENV_PRESERVES_OTHER_THREAD&quot;</dt>
  <dd>This symbol, if defined, indicates that the getenv system call doesn't zap
      the static buffer of <span class="Li">&quot;getenv()&quot;</span> in a
      different thread. The typical <span class="Li">&quot;getenv()&quot;</span>
      implementation will return a pointer to the proper position in **environ.
      But some may instead copy them to a static buffer in
      <span class="Li">&quot;getenv()&quot;</span>. If there is a per-thread
      instance of that buffer, or the return points to **environ, then a
      many-reader/1-writer mutex will work; otherwise an exclusive locking mutex
      is required to prevent races.</dd>
  <dt>&quot;HAS_PTHREAD_ATFORK&quot;</dt>
  <dd>This symbol, if defined, indicates that the
      <span class="Li">&quot;pthread_atfork&quot;</span> routine is available to
      setup fork handlers.</dd>
  <dt>&quot;HAS_PTHREAD_ATTR_SETSCOPE&quot;</dt>
  <dd>This symbol, if defined, indicates that the
      <span class="Li">&quot;pthread_attr_setscope&quot;</span> system call is
      available to set the contention scope attribute of a thread attribute
      object.</dd>
  <dt>&quot;HAS_PTHREAD_YIELD&quot;</dt>
  <dd>This symbol, if defined, indicates that the
      <span class="Li">&quot;pthread_yield&quot;</span> routine is available to
      yield the execution of the current thread.
      <span class="Li">&quot;sched_yield&quot;</span> is preferable to
      <span class="Li">&quot;pthread_yield&quot;</span>.</dd>
  <dt>&quot;HAS_SCHED_YIELD&quot;</dt>
  <dd>This symbol, if defined, indicates that the
      <span class="Li">&quot;sched_yield&quot;</span> routine is available to
      yield the execution of the current thread.
      <span class="Li">&quot;sched_yield&quot;</span> is preferable to
      <span class="Li">&quot;pthread_yield&quot;</span>.</dd>
  <dt>&quot;I_MACH_CTHREADS&quot;</dt>
  <dd>This symbol, if defined, indicates to the C program that it should include
      <i>mach/cthreads.h</i>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> #ifdef I_MACH_CTHREADS
     #include &lt;mach_cthreads.h&gt;
 #endif
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;I_PTHREAD&quot;</dt>
  <dd>This symbol, if defined, indicates to the C program that it should include
      <i>pthread.h</i>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> #ifdef I_PTHREAD
     #include &lt;pthread.h&gt;
 #endif
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;MULTIPLICITY&quot;</dt>
  <dd>This symbol, if defined, indicates that Perl should be built to use
      multiplicity.</dd>
  <dt>&quot;OLD_PTHREADS_API&quot;</dt>
  <dd>This symbol, if defined, indicates that Perl should be built to use the
      old draft <span class="Li">&quot;POSIX&quot;</span> threads
      <span class="Li">&quot;API&quot;</span>.</dd>
  <dt>&quot;OLD_PTHREAD_CREATE_JOINABLE&quot;</dt>
  <dd>This symbol, if defined, indicates how to create pthread in joinable (aka
      undetached) state. <span class="Li">&quot;NOTE&quot;</span>: not defined
      if <i>pthread.h</i> already has defined
      <span class="Li">&quot;PTHREAD_CREATE_JOINABLE&quot;</span> (the new
      version of the constant). If defined, known values are
      <span class="Li">&quot;PTHREAD_CREATE_UNDETACHED&quot;</span> and
      <span class="Li">&quot;__UNDETACHED&quot;</span>.</dd>
  <dt>&quot;pTHX&quot;</dt>
  <dd>Described in perlguts.</dd>
  <dt>&quot;pTHX_&quot;</dt>
  <dd>Described in perlguts.</dd>
  <dt>&quot;SCHED_YIELD&quot;</dt>
  <dd>This symbol defines the way to yield the execution of the current thread.
      Known ways are <span class="Li">&quot;sched_yield&quot;</span>,
      <span class="Li">&quot;pthread_yield&quot;</span>, and
      <span class="Li">&quot;pthread_yield&quot;</span> with
      <span class="Li">&quot;NULL&quot;</span>.</dd>
  <dt>&quot;SVf&quot;</dt>
  <dd>Described in perlguts.</dd>
  <dt>&quot;SVfARG&quot;</dt>
  <dd>Described in perlguts.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre>   SVfARG(SV *sv)
</pre>
</div>
<div class="Bd-indent"></div>
</section>
<section class="Sh">
<h1 class="Sh" id="COP_Hint_Hashes"><a class="permalink" href="#COP_Hint_Hashes">COP
  Hint Hashes</a></h1>
<dl class="Bl-tag">
  <dt>&quot;cop_fetch_label&quot;</dt>
  <dd>NOTE: <span class="Li">&quot;cop_fetch_label&quot;</span> is
      <b>experimental</b> and may change or be removed without notice.
    <p class="Pp">Returns the label attached to a cop, and stores its length in
        bytes into <span class="Li">*len</span>. Upon return,
        <span class="Li">*flags</span> will be set to either
        <span class="Li">&quot;SVf_UTF8&quot;</span> or 0.</p>
    <p class="Pp">Alternatively, use the macro
        <span class="Li">&quot;CopLABEL_len_flags&quot;</span>; or if you don't
        need to know if the label is UTF-8 or not, the macro
        <span class="Li">&quot;CopLABEL_len&quot;</span>; or if you additionally
        dont need to know the length,
        <span class="Li">&quot;CopLABEL&quot;</span>.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> const char *  cop_fetch_label(COP *const cop, STRLEN *len,
                               U32 *flags)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;CopFILE&quot;</dt>
  <dd>Returns the name of the file associated with the
      <span class="Li">&quot;COP&quot;</span>
      <span class="Li">&quot;c&quot;</span></dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> const char *  CopFILE(const COP * c)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;CopFILEAV&quot;</dt>
  <dd>Returns the AV associated with the <span class="Li">&quot;COP&quot;</span>
      <span class="Li">&quot;c&quot;</span></dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> AV *  CopFILEAV(const COP * c)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;CopFILEGV&quot;</dt>
  <dd>Returns the GV associated with the <span class="Li">&quot;COP&quot;</span>
      <span class="Li">&quot;c&quot;</span></dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> GV *  CopFILEGV(const COP * c)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;CopFILEGV_set&quot;</dt>
  <dd>Available only on unthreaded perls. Makes
      <span class="Li">&quot;pv&quot;</span> the name of the file associated
      with the <span class="Li">&quot;COP&quot;</span>
      <span class="Li">&quot;c&quot;</span></dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  CopFILEGV_set(COP * c, GV * gv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;CopFILE_set&quot;</dt>
  <dd>Makes <span class="Li">&quot;pv&quot;</span> the name of the file
      associated with the <span class="Li">&quot;COP&quot;</span>
      <span class="Li">&quot;c&quot;</span></dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  CopFILE_set(COP * c, const char * pv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;CopFILESV&quot;</dt>
  <dd>Returns the SV associated with the <span class="Li">&quot;COP&quot;</span>
      <span class="Li">&quot;c&quot;</span></dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> SV *  CopFILESV(const COP * c)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;cophh_2hv&quot;</dt>
  <dd>NOTE: <span class="Li">&quot;cophh_2hv&quot;</span> is <b>experimental</b>
      and may change or be removed without notice.
    <p class="Pp">Generates and returns a standard Perl hash representing the
        full set of key/value pairs in the cop hints hash
        <span class="Li">&quot;cophh&quot;</span>.
        <span class="Li">&quot;flags&quot;</span> is currently unused and must
        be zero.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> HV *  cophh_2hv(const COPHH *cophh, U32 flags)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;cophh_copy&quot;</dt>
  <dd>NOTE: <span class="Li">&quot;cophh_copy&quot;</span> is
      <b>experimental</b> and may change or be removed without notice.
    <p class="Pp">Make and return a complete copy of the cop hints hash
        <span class="Li">&quot;cophh&quot;</span>.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> COPHH *  cophh_copy(COPHH *cophh)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;cophh_delete_pv&quot;</dt>
  <dd>NOTE: <span class="Li">&quot;cophh_delete_pv&quot;</span> is
      <b>experimental</b> and may change or be removed without notice.
    <p class="Pp">Like &quot;cophh_delete_pvn&quot;, but takes a nul-terminated
        string instead of a string/length pair.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> COPHH *  cophh_delete_pv(COPHH *cophh, char *key, U32 hash,
                          U32 flags)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;cophh_delete_pvn&quot;</dt>
  <dd>NOTE: <span class="Li">&quot;cophh_delete_pvn&quot;</span> is
      <b>experimental</b> and may change or be removed without notice.
    <p class="Pp">Delete a key and its associated value from the cop hints hash
        <span class="Li">&quot;cophh&quot;</span>, and returns the modified
        hash. The returned hash pointer is in general not the same as the hash
        pointer that was passed in. The input hash is consumed by the function,
        and the pointer to it must not be subsequently used. Use
        &quot;cophh_copy&quot; if you need both hashes.</p>
    <p class="Pp">The key is specified by
        <span class="Li">&quot;keypv&quot;</span> and
        <span class="Li">&quot;keylen&quot;</span>. If
        <span class="Li">&quot;flags&quot;</span> has the
        <span class="Li">&quot;COPHH_KEY_UTF8&quot;</span> bit set, the key
        octets are interpreted as UTF-8, otherwise they are interpreted as
        Latin-1. <span class="Li">&quot;hash&quot;</span> is a precomputed hash
        of the key string, or zero if it has not been precomputed.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> COPHH *  cophh_delete_pvn(COPHH *cophh, const char *keypv,
                           STRLEN keylen, U32 hash, U32 flags)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;cophh_delete_pvs&quot;</dt>
  <dd>NOTE: <span class="Li">&quot;cophh_delete_pvs&quot;</span> is
      <b>experimental</b> and may change or be removed without notice.
    <p class="Pp">Like &quot;cophh_delete_pvn&quot;, but takes a literal string
        instead of a string/length pair, and no precomputed hash.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> COPHH *  cophh_delete_pvs(COPHH *cophh, &quot;key&quot;, U32 flags)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;cophh_delete_sv&quot;</dt>
  <dd>NOTE: <span class="Li">&quot;cophh_delete_sv&quot;</span> is
      <b>experimental</b> and may change or be removed without notice.
    <p class="Pp">Like &quot;cophh_delete_pvn&quot;, but takes a Perl scalar
        instead of a string/length pair.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> COPHH *  cophh_delete_sv(COPHH *cophh, SV *key, U32 hash,
                          U32 flags)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;cophh_exists_pv&quot;</dt>
  <dd>NOTE: <span class="Li">&quot;cophh_exists_pv&quot;</span> is
      <b>experimental</b> and may change or be removed without notice.
    <p class="Pp">Like &quot;cophh_exists_pvn&quot;, but takes a nul-terminated
        string instead of a string/length pair.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> bool  cophh_exists_pv(const COPHH *cophh, const char *key,
                       U32 hash, U32 flags)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;cophh_exists_pvn&quot;</dt>
  <dd>NOTE: <span class="Li">&quot;cophh_exists_pvn&quot;</span> is
      <b>experimental</b> and may change or be removed without notice.
    <p class="Pp">Look up the entry in the cop hints hash
        <span class="Li">&quot;cophh&quot;</span> with the key specified by
        <span class="Li">&quot;keypv&quot;</span> and
        <span class="Li">&quot;keylen&quot;</span>. If
        <span class="Li">&quot;flags&quot;</span> has the
        <span class="Li">&quot;COPHH_KEY_UTF8&quot;</span> bit set, the key
        octets are interpreted as UTF-8, otherwise they are interpreted as
        Latin-1. <span class="Li">&quot;hash&quot;</span> is a precomputed hash
        of the key string, or zero if it has not been precomputed. Returns true
        if a value exists, and false otherwise.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> bool  cophh_exists_pvn(const COPHH *cophh, const char *keypv,
                        STRLEN keylen, U32 hash, U32 flags)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;cophh_exists_pvs&quot;</dt>
  <dd>NOTE: <span class="Li">&quot;cophh_exists_pvs&quot;</span> is
      <b>experimental</b> and may change or be removed without notice.
    <p class="Pp">Like &quot;cophh_exists_pvn&quot;, but takes a literal string
        instead of a string/length pair, and no precomputed hash.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> bool  cophh_exists_pvs(const COPHH *cophh, &quot;key&quot;, U32 flags)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;cophh_exists_sv&quot;</dt>
  <dd>NOTE: <span class="Li">&quot;cophh_exists_sv&quot;</span> is
      <b>experimental</b> and may change or be removed without notice.
    <p class="Pp">Like &quot;cophh_exists_pvn&quot;, but takes a Perl scalar
        instead of a string/length pair.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> bool  cophh_exists_sv(const COPHH *cophh, SV *key, U32 hash,
                       U32 flags)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;cophh_fetch_pv&quot;</dt>
  <dd>NOTE: <span class="Li">&quot;cophh_fetch_pv&quot;</span> is
      <b>experimental</b> and may change or be removed without notice.
    <p class="Pp">Like &quot;cophh_fetch_pvn&quot;, but takes a nul-terminated
        string instead of a string/length pair.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> SV *  cophh_fetch_pv(const COPHH *cophh, const char *key,
                      U32 hash, U32 flags)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;cophh_fetch_pvn&quot;</dt>
  <dd>NOTE: <span class="Li">&quot;cophh_fetch_pvn&quot;</span> is
      <b>experimental</b> and may change or be removed without notice.
    <p class="Pp">Look up the entry in the cop hints hash
        <span class="Li">&quot;cophh&quot;</span> with the key specified by
        <span class="Li">&quot;keypv&quot;</span> and
        <span class="Li">&quot;keylen&quot;</span>. If
        <span class="Li">&quot;flags&quot;</span> has the
        <span class="Li">&quot;COPHH_KEY_UTF8&quot;</span> bit set, the key
        octets are interpreted as UTF-8, otherwise they are interpreted as
        Latin-1. <span class="Li">&quot;hash&quot;</span> is a precomputed hash
        of the key string, or zero if it has not been precomputed. Returns a
        mortal scalar copy of the value associated with the key, or
        <span class="Li">&amp;PL_sv_placeholder</span> if there is no value
        associated with the key.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> SV *  cophh_fetch_pvn(const COPHH *cophh, const char *keypv,
                       STRLEN keylen, U32 hash, U32 flags)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;cophh_fetch_pvs&quot;</dt>
  <dd>NOTE: <span class="Li">&quot;cophh_fetch_pvs&quot;</span> is
      <b>experimental</b> and may change or be removed without notice.
    <p class="Pp">Like &quot;cophh_fetch_pvn&quot;, but takes a literal string
        instead of a string/length pair, and no precomputed hash.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> SV *  cophh_fetch_pvs(const COPHH *cophh, &quot;key&quot;, U32 flags)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;cophh_fetch_sv&quot;</dt>
  <dd>NOTE: <span class="Li">&quot;cophh_fetch_sv&quot;</span> is
      <b>experimental</b> and may change or be removed without notice.
    <p class="Pp">Like &quot;cophh_fetch_pvn&quot;, but takes a Perl scalar
        instead of a string/length pair.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> SV *  cophh_fetch_sv(const COPHH *cophh, SV *key, U32 hash,
                      U32 flags)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;cophh_free&quot;</dt>
  <dd>NOTE: <span class="Li">&quot;cophh_free&quot;</span> is
      <b>experimental</b> and may change or be removed without notice.
    <p class="Pp">Discard the cop hints hash
        <span class="Li">&quot;cophh&quot;</span>, freeing all resources
        associated with it.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  cophh_free(COPHH *cophh)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;cophh_new_empty&quot;</dt>
  <dd>NOTE: <span class="Li">&quot;cophh_new_empty&quot;</span> is
      <b>experimental</b> and may change or be removed without notice.
    <p class="Pp">Generate and return a fresh cop hints hash containing no
        entries.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> COPHH *  cophh_new_empty()
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;cophh_store_pv&quot;</dt>
  <dd>NOTE: <span class="Li">&quot;cophh_store_pv&quot;</span> is
      <b>experimental</b> and may change or be removed without notice.
    <p class="Pp">Like &quot;cophh_store_pvn&quot;, but takes a nul-terminated
        string instead of a string/length pair.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> COPHH *  cophh_store_pv(COPHH *cophh, const char *key, U32 hash,
                         SV *value, U32 flags)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;cophh_store_pvn&quot;</dt>
  <dd>NOTE: <span class="Li">&quot;cophh_store_pvn&quot;</span> is
      <b>experimental</b> and may change or be removed without notice.
    <p class="Pp">Stores a value, associated with a key, in the cop hints hash
        <span class="Li">&quot;cophh&quot;</span>, and returns the modified
        hash. The returned hash pointer is in general not the same as the hash
        pointer that was passed in. The input hash is consumed by the function,
        and the pointer to it must not be subsequently used. Use
        &quot;cophh_copy&quot; if you need both hashes.</p>
    <p class="Pp">The key is specified by
        <span class="Li">&quot;keypv&quot;</span> and
        <span class="Li">&quot;keylen&quot;</span>. If
        <span class="Li">&quot;flags&quot;</span> has the
        <span class="Li">&quot;COPHH_KEY_UTF8&quot;</span> bit set, the key
        octets are interpreted as UTF-8, otherwise they are interpreted as
        Latin-1. <span class="Li">&quot;hash&quot;</span> is a precomputed hash
        of the key string, or zero if it has not been precomputed.</p>
    <p class="Pp"><span class="Li">&quot;value&quot;</span> is the scalar value
        to store for this key. <span class="Li">&quot;value&quot;</span> is
        copied by this function, which thus does not take ownership of any
        reference to it, and later changes to the scalar will not be reflected
        in the value visible in the cop hints hash. Complex types of scalar will
        not be stored with referential integrity, but will be coerced to
        strings.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> COPHH *  cophh_store_pvn(COPHH *cophh, const char *keypv,
                          STRLEN keylen, U32 hash, SV *value,
                          U32 flags)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;cophh_store_pvs&quot;</dt>
  <dd>NOTE: <span class="Li">&quot;cophh_store_pvs&quot;</span> is
      <b>experimental</b> and may change or be removed without notice.
    <p class="Pp">Like &quot;cophh_store_pvn&quot;, but takes a literal string
        instead of a string/length pair, and no precomputed hash.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> COPHH *  cophh_store_pvs(COPHH *cophh, &quot;key&quot;, SV *value,
                          U32 flags)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;cophh_store_sv&quot;</dt>
  <dd>NOTE: <span class="Li">&quot;cophh_store_sv&quot;</span> is
      <b>experimental</b> and may change or be removed without notice.
    <p class="Pp">Like &quot;cophh_store_pvn&quot;, but takes a Perl scalar
        instead of a string/length pair.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> COPHH *  cophh_store_sv(COPHH *cophh, SV *key, U32 hash,
                         SV *value, U32 flags)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;cop_hints_2hv&quot;</dt>
  <dd>Generates and returns a standard Perl hash representing the full set of
      hint entries in the cop <span class="Li">&quot;cop&quot;</span>.
      <span class="Li">&quot;flags&quot;</span> is currently unused and must be
      zero.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> HV *  cop_hints_2hv(const COP *cop, U32 flags)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;cop_hints_exists_pv&quot;</dt>
  <dd>Like &quot;cop_hints_exists_pvn&quot;, but takes a nul-terminated string
      instead of a string/length pair.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> bool  cop_hints_exists_pv(const COP *cop, const char *key,
                           U32 hash, U32 flags)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;cop_hints_exists_pvn&quot;</dt>
  <dd>Look up the hint entry in the cop <span class="Li">&quot;cop&quot;</span>
      with the key specified by <span class="Li">&quot;keypv&quot;</span> and
      <span class="Li">&quot;keylen&quot;</span>. If
      <span class="Li">&quot;flags&quot;</span> has the
      <span class="Li">&quot;COPHH_KEY_UTF8&quot;</span> bit set, the key octets
      are interpreted as UTF-8, otherwise they are interpreted as Latin-1.
      <span class="Li">&quot;hash&quot;</span> is a precomputed hash of the key
      string, or zero if it has not been precomputed. Returns true if a value
      exists, and false otherwise.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> bool  cop_hints_exists_pvn(const COP *cop, const char *keypv,
                            STRLEN keylen, U32 hash, U32 flags)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;cop_hints_exists_pvs&quot;</dt>
  <dd>Like &quot;cop_hints_exists_pvn&quot;, but takes a literal string instead
      of a string/length pair, and no precomputed hash.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> bool  cop_hints_exists_pvs(const COP *cop, &quot;key&quot;, U32 flags)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;cop_hints_exists_sv&quot;</dt>
  <dd>Like &quot;cop_hints_exists_pvn&quot;, but takes a Perl scalar instead of
      a string/length pair.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> bool  cop_hints_exists_sv(const COP *cop, SV *key, U32 hash,
                           U32 flags)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;cop_hints_fetch_pv&quot;</dt>
  <dd>Like &quot;cop_hints_fetch_pvn&quot;, but takes a nul-terminated string
      instead of a string/length pair.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> SV *  cop_hints_fetch_pv(const COP *cop, const char *key,
                          U32 hash, U32 flags)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;cop_hints_fetch_pvn&quot;</dt>
  <dd>Look up the hint entry in the cop <span class="Li">&quot;cop&quot;</span>
      with the key specified by <span class="Li">&quot;keypv&quot;</span> and
      <span class="Li">&quot;keylen&quot;</span>. If
      <span class="Li">&quot;flags&quot;</span> has the
      <span class="Li">&quot;COPHH_KEY_UTF8&quot;</span> bit set, the key octets
      are interpreted as UTF-8, otherwise they are interpreted as Latin-1.
      <span class="Li">&quot;hash&quot;</span> is a precomputed hash of the key
      string, or zero if it has not been precomputed. Returns a mortal scalar
      copy of the value associated with the key, or
      <span class="Li">&amp;PL_sv_placeholder</span> if there is no value
      associated with the key.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> SV *  cop_hints_fetch_pvn(const COP *cop, const char *keypv,
                           STRLEN keylen, U32 hash, U32 flags)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;cop_hints_fetch_pvs&quot;</dt>
  <dd>Like &quot;cop_hints_fetch_pvn&quot;, but takes a literal string instead
      of a string/length pair, and no precomputed hash.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> SV *  cop_hints_fetch_pvs(const COP *cop, &quot;key&quot;, U32 flags)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;cop_hints_fetch_sv&quot;</dt>
  <dd>Like &quot;cop_hints_fetch_pvn&quot;, but takes a Perl scalar instead of a
      string/length pair.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> SV *  cop_hints_fetch_sv(const COP *cop, SV *key, U32 hash,
                          U32 flags)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;CopLABEL&quot;</dt>
  <dd>Returns the label attached to a cop.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> const char *  CopLABEL(COP *const cop)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;CopLABEL_len&quot;</dt>
  <dd>Returns the label attached to a cop, and stores its length in bytes into
      <span class="Li">*len</span>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> const char *  CopLABEL_len(COP *const cop, STRLEN *len)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;CopLABEL_len_flags&quot;</dt>
  <dd>Returns the label attached to a cop, and stores its length in bytes into
      <span class="Li">*len</span>. Upon return, <span class="Li">*flags</span>
      will be set to either <span class="Li">&quot;SVf_UTF8&quot;</span> or
    0.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> const char *  CopLABEL_len_flags(COP *const cop, STRLEN *len,
                                  U32 *flags)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;CopLINE&quot;</dt>
  <dd>Returns the line number in the source code associated with the
      <span class="Li">&quot;COP&quot;</span>
      <span class="Li">&quot;c&quot;</span></dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> STRLEN  CopLINE(const COP * c)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;CopSTASH&quot;</dt>
  <dd>Returns the stash associated with
    <span class="Li">&quot;c&quot;</span>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> HV *  CopSTASH(const COP * c)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;CopSTASH_eq&quot;</dt>
  <dd>Returns a boolean as to whether or not
      <span class="Li">&quot;hv&quot;</span> is the stash associated with
      <span class="Li">&quot;c&quot;</span>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> bool  CopSTASH_eq(const COP * c, const HV * hv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;CopSTASHPV&quot;</dt>
  <dd>Returns the package name of the stash associated with
      <span class="Li">&quot;c&quot;</span>, or
      <span class="Li">&quot;NULL&quot;</span> if no associated stash</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> char *  CopSTASHPV(const COP * c)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;CopSTASHPV_set&quot;</dt>
  <dd>Set the package name of the stash associated with
      <span class="Li">&quot;c&quot;</span>, to the NUL-terminated C string
      <span class="Li">&quot;p&quot;</span>, creating the package if
    necessary.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  CopSTASHPV_set(COP * c, const char * pv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;CopSTASH_set&quot;</dt>
  <dd>Set the stash associated with <span class="Li">&quot;c&quot;</span> to
      <span class="Li">&quot;hv&quot;</span>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> bool  CopSTASH_set(COP * c, HV * hv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;cop_store_label&quot;</dt>
  <dd>NOTE: <span class="Li">&quot;cop_store_label&quot;</span> is
      <b>experimental</b> and may change or be removed without notice.
    <p class="Pp">Save a label into a
        <span class="Li">&quot;cop_hints_hash&quot;</span>. You need to set
        flags to <span class="Li">&quot;SVf_UTF8&quot;</span> for a UTF-8 label.
        Any other flag is ignored.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  cop_store_label(COP *const cop, const char *label,
                       STRLEN len, U32 flags)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;PERL_SI&quot;</dt>
  <dd>Use this typedef to declare variables that are to hold
      <span class="Li">&quot;struct stackinfo&quot;</span>.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="Custom_Operators"><a class="permalink" href="#Custom_Operators">Custom
  Operators</a></h1>
<dl class="Bl-tag">
  <dt>&quot;custom_op_desc&quot;</dt>
  <dd><span class="Li">&quot;</span><span class="Li"><b>DEPRECATED!</b></span><span class="Li">&quot;</span>
      It is planned to remove <span class="Li">&quot;custom_op_desc&quot;</span>
      from a future release of Perl. Do not use it for new code; remove it from
      existing code.
    <p class="Pp">Return the description of a given custom op. This was once
        used by the <span class="Li">&quot;OP_DESC&quot;</span> macro, but is no
        longer: it has only been kept for compatibility, and should not be
      used.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> const char *  custom_op_desc(const OP *o)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;custom_op_name&quot;</dt>
  <dd><span class="Li">&quot;</span><span class="Li"><b>DEPRECATED!</b></span><span class="Li">&quot;</span>
      It is planned to remove <span class="Li">&quot;custom_op_name&quot;</span>
      from a future release of Perl. Do not use it for new code; remove it from
      existing code.
    <p class="Pp">Return the name for a given custom op. This was once used by
        the <span class="Li">&quot;OP_NAME&quot;</span> macro, but is no longer:
        it has only been kept for compatibility, and should not be used.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> const char *  custom_op_name(const OP *o)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;custom_op_register&quot;</dt>
  <dd>Register a custom op. See &quot;Custom Operators&quot; in perlguts.
    <p class="Pp">NOTE: <span class="Li">&quot;custom_op_register&quot;</span>
        must be explicitly called as
        <span class="Li">&quot;Perl_custom_op_register&quot;</span> with an
        <span class="Li">&quot;aTHX_&quot;</span> parameter.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  Perl_custom_op_register(pTHX_ Perl_ppaddr_t ppaddr,
                               const XOP *xop)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;Perl_custom_op_xop&quot;</dt>
  <dd>Return the XOP structure for a given custom op. This macro should be
      considered internal to <span class="Li">&quot;OP_NAME&quot;</span> and the
      other access macros: use them instead. This macro does call a function.
      Prior to 5.19.6, this was implemented as a function.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> const XOP *  Perl_custom_op_xop(pTHX_ const OP *o)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;XopDISABLE&quot;</dt>
  <dd>Temporarily disable a member of the XOP, by clearing the appropriate
    flag.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  XopDISABLE(XOP *xop, which)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;XopENABLE&quot;</dt>
  <dd>Reenable a member of the XOP which has been disabled.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  XopENABLE(XOP *xop, which)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;XopENTRY&quot;</dt>
  <dd>Return a member of the XOP structure.
      <span class="Li">&quot;which&quot;</span> is a cpp token indicating which
      entry to return. If the member is not set this will return a default
      value. The return type depends on
      <span class="Li">&quot;which&quot;</span>. This macro evaluates its
      arguments more than once. If you are using
      <span class="Li">&quot;Perl_custom_op_xop&quot;</span> to retrieve a
      <span class="Li">&quot;XOP *&quot;</span> from a <span class="Li">&quot;OP
      *&quot;</span>, use the more efficient &quot;XopENTRYCUSTOM&quot;
    instead.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre>   XopENTRY(XOP *xop, which)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;XopENTRYCUSTOM&quot;</dt>
  <dd>Exactly like
      <span class="Li">&quot;XopENTRY(XopENTRY(Perl_custom_op_xop(aTHX_ o),
      which)&quot;</span> but more efficient. The
      <span class="Li">&quot;which&quot;</span> parameter is identical to
      &quot;XopENTRY&quot;.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre>   XopENTRYCUSTOM(const OP *o, which)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;XopENTRY_set&quot;</dt>
  <dd>Set a member of the XOP structure.
      <span class="Li">&quot;which&quot;</span> is a cpp token indicating which
      entry to set. See &quot;Custom Operators&quot; in perlguts for details
      about the available members and how they are used. This macro evaluates
      its argument more than once.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  XopENTRY_set(XOP *xop, which, value)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;XopFLAGS&quot;</dt>
  <dd>Return the XOP's flags.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> U32  XopFLAGS(XOP *xop)
</pre>
</div>
<div class="Bd-indent"></div>
</section>
<section class="Sh">
<h1 class="Sh" id="CV_Handling"><a class="permalink" href="#CV_Handling">CV
  Handling</a></h1>
<p class="Pp">This section documents functions to manipulate CVs which are
    code-values, meaning subroutines. For more information, see perlguts.</p>
<dl class="Bl-tag">
  <dt>&quot;caller_cx&quot;</dt>
  <dd>The XSUB-writer's equivalent of <b>caller()</b>. The returned
      <span class="Li">&quot;PERL_CONTEXT&quot;</span> structure can be
      interrogated to find all the information returned to Perl by
      <span class="Li">&quot;caller&quot;</span>. Note that XSUBs don't get a
      stack frame, so <span class="Li">&quot;caller_cx(0, NULL)&quot;</span>
      will return information for the immediately-surrounding Perl code.
    <p class="Pp">This function skips over the automatic calls to
        <span class="Li">&amp;DB::sub</span> made on the behalf of the debugger.
        If the stack frame requested was a sub called by
        <span class="Li">&quot;DB::sub&quot;</span>, the return value will be
        the frame for the call to <span class="Li">&quot;DB::sub&quot;</span>,
        since that has the correct line number/etc. for the call site. If
        <i>dbcxp</i> is non-<span class="Li">&quot;NULL&quot;</span>, it will be
        set to a pointer to the frame for the sub call itself.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> const PERL_CONTEXT *  caller_cx(I32 level,
                                 const PERL_CONTEXT **dbcxp)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;CvGV&quot;</dt>
  <dd>Returns the GV associated with the CV
      <span class="Li">&quot;sv&quot;</span>, reifying it if necessary.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> GV *  CvGV(CV *sv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;CvSTASH&quot;</dt>
  <dd>Returns the stash of the CV. A stash is the symbol table hash, containing
      the package-scoped variables in the package where the subroutine was
      defined. For more information, see perlguts.
    <p class="Pp">This also has a special use with XS AUTOLOAD subs. See
        &quot;Autoloading with XSUBs&quot; in perlguts.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> HV*  CvSTASH(CV* cv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;find_runcv&quot;</dt>
  <dd>Locate the CV corresponding to the currently executing sub or eval. If
      <span class="Li">&quot;db_seqp&quot;</span> is non_null, skip CVs that are
      in the DB package and populate <span class="Li">*db_seqp</span> with the
      cop sequence number at the point that the DB:: code was entered. (This
      allows debuggers to eval in the scope of the breakpoint rather than in the
      scope of the debugger itself.)</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> CV*  find_runcv(U32 *db_seqp)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;get_cv&quot;</dt>
  <dd></dd>
  <dt>&quot;get_cvs&quot;</dt>
  <dd></dd>
  <dt>&quot;get_cvn_flags&quot;</dt>
  <dd>These return the CV of the specified Perl subroutine.
      <span class="Li">&quot;flags&quot;</span> are passed to
      <span class="Li">&quot;gv_fetchpvn_flags&quot;</span>. If
      <span class="Li">&quot;GV_ADD&quot;</span> is set and the Perl subroutine
      does not exist then it will be declared (which has the same effect as
      saying <span class="Li">&quot;sub name;&quot;</span>). If
      <span class="Li">&quot;GV_ADD&quot;</span> is not set and the subroutine
      does not exist, then NULL is returned.
    <p class="Pp">The forms differ only in how the subroutine is specified..
        With <span class="Li">&quot;get_cvs&quot;</span>, the name is a literal
        C string, enclosed in double quotes. With
        <span class="Li">&quot;get_cv&quot;</span>, the name is given by the
        <span class="Li">&quot;name&quot;</span> parameter, which must be a
        NUL-terminated C string. With
        <span class="Li">&quot;get_cvn_flags&quot;</span>, the name is also
        given by the <span class="Li">&quot;name&quot;</span> parameter, but it
        is a Perl string (possibly containing embedded NUL bytes), and its
        length in bytes is contained in the
        <span class="Li">&quot;len&quot;</span> parameter.</p>
    <p class="Pp">NOTE: the <span class="Li">&quot;perl_get_cv()&quot;</span>
        form is <b>deprecated</b>.</p>
    <p class="Pp">NOTE: the <span class="Li">&quot;perl_get_cvs()&quot;</span>
        form is <b>deprecated</b>.</p>
    <p class="Pp">NOTE: the
        <span class="Li">&quot;perl_get_cvn_flags()&quot;</span> form is
        <b>deprecated</b>.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> CV*   get_cv       (const char* name, I32 flags)
 CV *  get_cvs      (&quot;string&quot;, I32 flags)
 CV*   get_cvn_flags(const char* name, STRLEN len, I32 flags)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;Nullcv&quot;</dt>
  <dd><span class="Li">&quot;</span><span class="Li"><b>DEPRECATED!</b></span><span class="Li">&quot;</span>
      It is planned to remove <span class="Li">&quot;Nullcv&quot;</span> from a
      future release of Perl. Do not use it for new code; remove it from
      existing code.
    <p class="Pp">Null CV pointer.</p>
    <p class="Pp">(deprecated - use <span class="Li">&quot;(CV
        *)NULL&quot;</span> instead)</p>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="Debugging"><a class="permalink" href="#Debugging">Debugging</a></h1>
<dl class="Bl-tag">
  <dt>&quot;dump_all&quot;</dt>
  <dd>Dumps the entire optree of the current program starting at
      <span class="Li">&quot;PL_main_root&quot;</span> to
      <span class="Li">&quot;STDERR&quot;</span>. Also dumps the optrees for all
      visible subroutines in
    <span class="Li">&quot;PL_defstash&quot;</span>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  dump_all()
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;dump_c_backtrace&quot;</dt>
  <dd>Dumps the C backtrace to the given <span class="Li">&quot;fp&quot;</span>.
    <p class="Pp">Returns true if a backtrace could be retrieved, false if
      not.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> bool  dump_c_backtrace(PerlIO* fp, int max_depth, int skip)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;dump_packsubs&quot;</dt>
  <dd>Dumps the optrees for all visible subroutines in
      <span class="Li">&quot;stash&quot;</span>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  dump_packsubs(const HV* stash)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;get_c_backtrace_dump&quot;</dt>
  <dd>Returns a SV containing a dump of
      <span class="Li">&quot;depth&quot;</span> frames of the call stack,
      skipping the <span class="Li">&quot;skip&quot;</span> innermost ones.
      <span class="Li">&quot;depth&quot;</span> of 20 is usually enough.
    <p class="Pp">The appended output looks like:</p>
    <p class="Pp"></p>
    <pre> ...
 1   10e004812:0082   Perl_croak   util.c:1716    /usr/bin/perl
 2   10df8d6d2:1d72   perl_parse   perl.c:3975    /usr/bin/perl
 ...
    </pre>
    <p class="Pp">The fields are tab-separated. The first column is the depth
        (zero being the innermost non-skipped frame). In the hex:offset, the hex
        is where the program counter was in
        <span class="Li">&quot;S_parse_body&quot;</span>, and the :offset (might
        be missing) tells how much inside the
        <span class="Li">&quot;S_parse_body&quot;</span> the program counter
        was.</p>
    <p class="Pp">The <span class="Li">&quot;util.c:1716&quot;</span> is the
        source code file and line number.</p>
    <p class="Pp">The <i>/usr/bin/perl</i> is obvious (hopefully).</p>
    <p class="Pp">Unknowns are <span class="Li">&quot;-&quot;</span>. Unknowns
        can happen unfortunately quite easily: if the platform doesn't support
        retrieving the information; if the binary is missing the debug
        information; if the optimizer has transformed the code by for example
        inlining.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> SV*  get_c_backtrace_dump(int max_depth, int skip)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;HAS_BACKTRACE&quot;</dt>
  <dd>This symbol, if defined, indicates that the
      <span class="Li">&quot;backtrace()&quot;</span> routine is available to
      get a stack trace. The <i>execinfo.h</i> header must be included to use
      this routine.</dd>
  <dt>&quot;op_class&quot;</dt>
  <dd>Given an op, determine what type of struct it has been allocated as.
      Returns one of the OPclass enums, such as OPclass_LISTOP.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> OPclass  op_class(const OP *o)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;op_dump&quot;</dt>
  <dd>Dumps the optree starting at OP <span class="Li">&quot;o&quot;</span> to
      <span class="Li">&quot;STDERR&quot;</span>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  op_dump(const OP *o)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;sv_dump&quot;</dt>
  <dd>Dumps the contents of an SV to the
      <span class="Li">&quot;STDERR&quot;</span> filehandle.
    <p class="Pp">For an example of its output, see Devel::Peek.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  sv_dump(SV* sv)
</pre>
</div>
<div class="Bd-indent"></div>
</section>
<section class="Sh">
<h1 class="Sh" id="Display_functions"><a class="permalink" href="#Display_functions">Display
  functions</a></h1>
<dl class="Bl-tag">
  <dt>&quot;form&quot;</dt>
  <dd></dd>
  <dt>&quot;form_nocontext&quot;</dt>
  <dd>These take a sprintf-style format pattern and conventional (non-SV)
      arguments and return the formatted string.
    <p class="Pp"></p>
    <pre>    (char *) Perl_form(pTHX_ const char* pat, ...)
    </pre>
    <p class="Pp">can be used any place a string (char *) is required:</p>
    <p class="Pp"></p>
    <pre>    char * s = Perl_form(&quot;%d.%d&quot;,major,minor);
    </pre>
    <p class="Pp">They use a single (per-thread) private buffer so if you want
        to format several strings you must explicitly copy the earlier strings
        away (and free the copies when you are done).</p>
    <p class="Pp">The two forms differ only in that
        <span class="Li">&quot;form_nocontext&quot;</span> does not take a
        thread context (<span class="Li">&quot;aTHX&quot;</span>) parameter, so
        is used in situations where the caller doesn't already have the thread
        context.</p>
    <p class="Pp">NOTE: <span class="Li">&quot;form&quot;</span> must be
        explicitly called as <span class="Li">&quot;Perl_form&quot;</span> with
        an <span class="Li">&quot;aTHX_&quot;</span> parameter.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> char*  Perl_form     (pTHX_ const char* pat, ...)
 char*  form_nocontext(const char* pat, ...)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;mess&quot;</dt>
  <dd></dd>
  <dt>&quot;mess_nocontext&quot;</dt>
  <dd>These take a sprintf-style format pattern and argument list, which are
      used to generate a string message. If the message does not end with a
      newline, then it will be extended with some indication of the current
      location in the code, as described for
      <span class="Li">&quot;mess_sv&quot;</span>.
    <p class="Pp">Normally, the resulting message is returned in a new mortal
        SV. But during global destruction a single SV may be shared between uses
        of this function.</p>
    <p class="Pp">The two forms differ only in that
        <span class="Li">&quot;mess_nocontext&quot;</span> does not take a
        thread context (<span class="Li">&quot;aTHX&quot;</span>) parameter, so
        is used in situations where the caller doesn't already have the thread
        context.</p>
    <p class="Pp">NOTE: <span class="Li">&quot;mess&quot;</span> must be
        explicitly called as <span class="Li">&quot;Perl_mess&quot;</span> with
        an <span class="Li">&quot;aTHX_&quot;</span> parameter.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> SV*  Perl_mess     (pTHX_ const char* pat, ...)
 SV*  mess_nocontext(const char* pat, ...)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;mess_sv&quot;</dt>
  <dd>Expands a message, intended for the user, to include an indication of the
      current location in the code, if the message does not already appear to be
      complete.
    <p class="Pp"><span class="Li">&quot;basemsg&quot;</span> is the initial
        message or object. If it is a reference, it will be used as-is and will
        be the result of this function. Otherwise it is used as a string, and if
        it already ends with a newline, it is taken to be complete, and the
        result of this function will be the same string. If the message does not
        end with a newline, then a segment such as
        <span class="Li">&quot;at</span> <span class="Li">foo.pl line
        37&quot;</span> will be appended, and possibly other clauses indicating
        the current state of execution. The resulting message will end with a
        dot and a newline.</p>
    <p class="Pp">Normally, the resulting message is returned in a new mortal
        SV. During global destruction a single SV may be shared between uses of
        this function. If <span class="Li">&quot;consume&quot;</span> is true,
        then the function is permitted (but not required) to modify and return
        <span class="Li">&quot;basemsg&quot;</span> instead of allocating a new
        SV.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> SV*  mess_sv(SV* basemsg, bool consume)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;pv_display&quot;</dt>
  <dd>Similar to
    <p class="Pp"></p>
    <pre>  pv_escape(dsv,pv,cur,pvlim,PERL_PV_ESCAPE_QUOTE);
    </pre>
    <p class="Pp">except that an additional &quot;\0&quot; will be appended to
        the string when len &gt; cur and pv[cur] is &quot;\0&quot;.</p>
    <p class="Pp">Note that the final string may be up to 7 chars longer than
        pvlim.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> char*  pv_display(SV *dsv, const char *pv, STRLEN cur, STRLEN len,
                   STRLEN pvlim)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;pv_escape&quot;</dt>
  <dd>Escapes at most the first <span class="Li">&quot;count&quot;</span> chars
      of <span class="Li">&quot;pv&quot;</span> and puts the results into
      <span class="Li">&quot;dsv&quot;</span> such that the size of the escaped
      string will not exceed <span class="Li">&quot;max&quot;</span> chars and
      will not contain any incomplete escape sequences. The number of bytes
      escaped will be returned in the <span class="Li">&quot;STRLEN
      *escaped&quot;</span> parameter if it is not null. When the
      <span class="Li">&quot;dsv&quot;</span> parameter is null no escaping
      actually occurs, but the number of bytes that would be escaped were it not
      null will be calculated.
    <p class="Pp">If flags contains
        <span class="Li">&quot;PERL_PV_ESCAPE_QUOTE&quot;</span> then any double
        quotes in the string will also be escaped.</p>
    <p class="Pp">Normally the SV will be cleared before the escaped string is
        prepared, but when
        <span class="Li">&quot;PERL_PV_ESCAPE_NOCLEAR&quot;</span> is set this
        will not occur.</p>
    <p class="Pp">If <span class="Li">&quot;PERL_PV_ESCAPE_UNI&quot;</span> is
        set then the input string is treated as UTF-8 if
        <span class="Li">&quot;PERL_PV_ESCAPE_UNI_DETECT&quot;</span> is set
        then the input string is scanned using
        <span class="Li">&quot;is_utf8_string()&quot;</span> to determine if it
        is UTF-8.</p>
    <p class="Pp">If <span class="Li">&quot;PERL_PV_ESCAPE_ALL&quot;</span> is
        set then all input chars will be output using
        <span class="Li">&quot;\x01F1&quot;</span> style escapes, otherwise if
        <span class="Li">&quot;PERL_PV_ESCAPE_NONASCII&quot;</span> is set, only
        non-ASCII chars will be escaped using this style; otherwise, only chars
        above 255 will be so escaped; other non printable chars will use octal
        or common escaped patterns like <span class="Li">&quot;\n&quot;</span>.
        Otherwise, if
        <span class="Li">&quot;PERL_PV_ESCAPE_NOBACKSLASH&quot;</span> then all
        chars below 255 will be treated as printable and will be output as
        literals.</p>
    <p class="Pp">If
        <span class="Li">&quot;PERL_PV_ESCAPE_FIRSTCHAR&quot;</span> is set then
        only the first char of the string will be escaped, regardless of max. If
        the output is to be in hex, then it will be returned as a plain hex
        sequence. Thus the output will either be a single char, an octal escape
        sequence, a special escape like <span class="Li">&quot;\n&quot;</span>
        or a hex value.</p>
    <p class="Pp">If <span class="Li">&quot;PERL_PV_ESCAPE_RE&quot;</span> is
        set then the escape char used will be a
        <span class="Li">&quot;%&quot;</span> and not a
        <span class="Li">&quot;\\&quot;</span>. This is because regexes very
        often contain backslashed sequences, whereas
        <span class="Li">&quot;%&quot;</span> is not a particularly common
        character in patterns.</p>
    <p class="Pp">Returns a pointer to the escaped text as held by
        <span class="Li">&quot;dsv&quot;</span>.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> char*  pv_escape(SV *dsv, char const * const str,
                  const STRLEN count, const STRLEN max,
                  STRLEN * const escaped, const U32 flags)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;pv_pretty&quot;</dt>
  <dd>Converts a string into something presentable, handling escaping via
      <span class="Li">&quot;pv_escape()&quot;</span> and supporting quoting and
      ellipses.
    <p class="Pp">If the
        <span class="Li">&quot;PERL_PV_PRETTY_QUOTE&quot;</span> flag is set
        then the result will be double quoted with any double quotes in the
        string escaped. Otherwise if the
        <span class="Li">&quot;PERL_PV_PRETTY_LTGT&quot;</span> flag is set then
        the result be wrapped in angle brackets.</p>
    <p class="Pp">If the
        <span class="Li">&quot;PERL_PV_PRETTY_ELLIPSES&quot;</span> flag is set
        and not all characters in string were output then an ellipsis
        <span class="Li">&quot;...&quot;</span> will be appended to the string.
        Note that this happens AFTER it has been quoted.</p>
    <p class="Pp">If <span class="Li">&quot;start_color&quot;</span> is non-null
        then it will be inserted after the opening quote (if there is one) but
        before the escaped text. If
        <span class="Li">&quot;end_color&quot;</span> is non-null then it will
        be inserted after the escaped text but before any quotes or
      ellipses.</p>
    <p class="Pp">Returns a pointer to the prettified text as held by
        <span class="Li">&quot;dsv&quot;</span>.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> char*  pv_pretty(SV *dsv, char const * const str,
                  const STRLEN count, const STRLEN max,
                  char const * const start_color,
                  char const * const end_color, const U32 flags)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;vform&quot;</dt>
  <dd>Like <span class="Li">&quot;form&quot;</span> but but the arguments are an
      encapsulated argument list.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> char*  vform(const char* pat, va_list* args)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;vmess&quot;</dt>
  <dd><span class="Li">&quot;pat&quot;</span> and
      <span class="Li">&quot;args&quot;</span> are a sprintf-style format
      pattern and encapsulated argument list, respectively. These are used to
      generate a string message. If the message does not end with a newline,
      then it will be extended with some indication of the current location in
      the code, as described for &quot;mess_sv&quot;.
    <p class="Pp">Normally, the resulting message is returned in a new mortal
        SV. During global destruction a single SV may be shared between uses of
        this function.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> SV*  vmess(const char* pat, va_list* args)
</pre>
</div>
<div class="Bd-indent"></div>
</section>
<section class="Sh">
<h1 class="Sh" id="Embedding_and_Interpreter_Cloning"><a class="permalink" href="#Embedding_and_Interpreter_Cloning">Embedding
  and Interpreter Cloning</a></h1>
<dl class="Bl-tag">
  <dt>&quot;cv_clone&quot;</dt>
  <dd>Clone a CV, making a lexical closure.
      <span class="Li">&quot;proto&quot;</span> supplies the prototype of the
      function: its code, pad structure, and other attributes. The prototype is
      combined with a capture of outer lexicals to which the code refers, which
      are taken from the currently-executing instance of the immediately
      surrounding code.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> CV*  cv_clone(CV* proto)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;cv_name&quot;</dt>
  <dd>Returns an SV containing the name of the CV, mainly for use in error
      reporting. The CV may actually be a GV instead, in which case the returned
      SV holds the GV's name. Anything other than a GV or CV is treated as a
      string already holding the sub name, but this could change in the future.
    <p class="Pp">An SV may be passed as a second argument. If so, the name will
        be assigned to it and it will be returned. Otherwise the returned SV
        will be a new mortal.</p>
    <p class="Pp">If <span class="Li">&quot;flags&quot;</span> has the
        <span class="Li">&quot;CV_NAME_NOTQUAL&quot;</span> bit set, then the
        package name will not be included. If the first argument is neither a CV
        nor a GV, this flag is ignored (subject to change).</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> SV *  cv_name(CV *cv, SV *sv, U32 flags)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;cv_undef&quot;</dt>
  <dd>Clear out all the active components of a CV. This can happen either by an
      explicit <span class="Li">&quot;undef &amp;foo&quot;</span>, or by the
      reference count going to zero. In the former case, we keep the
      <span class="Li">&quot;CvOUTSIDE&quot;</span> pointer, so that any
      anonymous children can still follow the full lexical scope chain.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  cv_undef(CV* cv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;find_rundefsv&quot;</dt>
  <dd>Returns the global variable <span class="Li">$_</span>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> SV*  find_rundefsv()
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;find_rundefsvoffset&quot;</dt>
  <dd><span class="Li">&quot;</span><span class="Li"><b>DEPRECATED!</b></span><span class="Li">&quot;</span>
      It is planned to remove
      <span class="Li">&quot;find_rundefsvoffset&quot;</span> from a future
      release of Perl. Do not use it for new code; remove it from existing code.
    <p class="Pp">Until the lexical <span class="Li">$_</span> feature was
        removed, this function would find the position of the lexical
        <span class="Li">$_</span> in the pad of the currently-executing
        function and return the offset in the current pad, or
        <span class="Li">&quot;NOT_IN_PAD&quot;</span>.</p>
    <p class="Pp">Now it always returns
        <span class="Li">&quot;NOT_IN_PAD&quot;</span>.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> PADOFFSET  find_rundefsvoffset()
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;intro_my&quot;</dt>
  <dd>&quot;Introduce&quot; <span class="Li">&quot;my&quot;</span> variables to
      visible status. This is called during parsing at the end of each statement
      to make lexical variables visible to subsequent statements.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> U32  intro_my()
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;load_module&quot;</dt>
  <dd>Loads the module whose name is pointed to by the string part of
      <span class="Li">&quot;name&quot;</span>. Note that the actual module
      name, not its filename, should be given. Eg, &quot;Foo::Bar&quot; instead
      of &quot;Foo/Bar.pm&quot;. ver, if specified and not NULL, provides
      version semantics similar to <span class="Li">&quot;use Foo::Bar
      VERSION&quot;</span>. The optional trailing arguments can be used to
      specify arguments to the module's
      <span class="Li">&quot;import()&quot;</span> method, similar to
      <span class="Li">&quot;use Foo::Bar VERSION LIST&quot;</span>; their
      precise handling depends on the flags. The flags argument is a
      bitwise-ORed collection of any of
      <span class="Li">&quot;PERL_LOADMOD_DENY&quot;</span>,
      <span class="Li">&quot;PERL_LOADMOD_NOIMPORT&quot;</span>, or
      <span class="Li">&quot;PERL_LOADMOD_IMPORT_OPS&quot;</span> (or 0 for no
      flags).
    <p class="Pp">If <span class="Li">&quot;PERL_LOADMOD_NOIMPORT&quot;</span>
        is set, the module is loaded as if with an empty import list, as in
        <span class="Li">&quot;use Foo::Bar ()&quot;</span>; this is the only
        circumstance in which the trailing optional arguments may be omitted
        entirely. Otherwise, if
        <span class="Li">&quot;PERL_LOADMOD_IMPORT_OPS&quot;</span> is set, the
        trailing arguments must consist of exactly one
        <span class="Li">&quot;OP*&quot;</span>, containing the op tree that
        produces the relevant import arguments. Otherwise, the trailing
        arguments must all be <span class="Li">&quot;SV*&quot;</span> values
        that will be used as import arguments; and the list must be terminated
        with <span class="Li">&quot;(SV*)</span>
        <span class="Li">NULL&quot;</span>. If neither
        <span class="Li">&quot;PERL_LOADMOD_NOIMPORT&quot;</span> nor
        <span class="Li">&quot;PERL_LOADMOD_IMPORT_OPS&quot;</span> is set, the
        trailing <span class="Li">&quot;NULL&quot;</span> pointer is needed even
        if no import arguments are desired. The reference count for each
        specified <span class="Li">&quot;SV*&quot;</span> argument is
        decremented. In addition, the <span class="Li">&quot;name&quot;</span>
        argument is modified.</p>
    <p class="Pp">If <span class="Li">&quot;PERL_LOADMOD_DENY&quot;</span> is
        set, the module is loaded as if with
        <span class="Li">&quot;no&quot;</span> rather than
        <span class="Li">&quot;use&quot;</span>.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  load_module(U32 flags, SV* name, SV* ver, ...)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;load_module_nocontext&quot;</dt>
  <dd>Like <span class="Li">&quot;load_module&quot;</span> but does not take a
      thread context (<span class="Li">&quot;aTHX&quot;</span>) parameter, so is
      used in situations where the caller doesn't already have the thread
      context.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  load_module_nocontext(U32 flags, SV* name, SV* ver, ...)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;my_exit&quot;</dt>
  <dd>A wrapper for the C library <b>exit</b>(3), honoring what
      &quot;PL_exit_flags&quot; in perlapi say to do.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  my_exit(U32 status)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;newPADNAMELIST&quot;</dt>
  <dd>NOTE: <span class="Li">&quot;newPADNAMELIST&quot;</span> is
      <b>experimental</b> and may change or be removed without notice.
    <p class="Pp">Creates a new pad name list.
        <span class="Li">&quot;max&quot;</span> is the highest index for which
        space is allocated.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> PADNAMELIST *  newPADNAMELIST(size_t max)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;newPADNAMEouter&quot;</dt>
  <dd>NOTE: <span class="Li">&quot;newPADNAMEouter&quot;</span> is
      <b>experimental</b> and may change or be removed without notice.
    <p class="Pp">Constructs and returns a new pad name. Only use this function
        for names that refer to outer lexicals. (See also
        &quot;newPADNAMEpvn&quot;.) <span class="Li">&quot;outer&quot;</span> is
        the outer pad name that this one mirrors. The returned pad name has the
        <span class="Li">&quot;PADNAMEt_OUTER&quot;</span> flag already set.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> PADNAME *  newPADNAMEouter(PADNAME *outer)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;newPADNAMEpvn&quot;</dt>
  <dd>NOTE: <span class="Li">&quot;newPADNAMEpvn&quot;</span> is
      <b>experimental</b> and may change or be removed without notice.
    <p class="Pp">Constructs and returns a new pad name.
        <span class="Li">&quot;s&quot;</span> must be a UTF-8 string. Do not use
        this for pad names that point to outer lexicals. See
        <span class="Li">&quot;newPADNAMEouter&quot;</span>.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> PADNAME *  newPADNAMEpvn(const char *s, STRLEN len)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;nothreadhook&quot;</dt>
  <dd>Stub that provides thread hook for perl_destruct when there are no
      threads.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> int  nothreadhook()
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;pad_add_anon&quot;</dt>
  <dd>Allocates a place in the currently-compiling pad (via
      &quot;pad_alloc&quot;) for an anonymous function that is lexically scoped
      inside the currently-compiling function. The function
      <span class="Li">&quot;func&quot;</span> is linked into the pad, and its
      <span class="Li">&quot;CvOUTSIDE&quot;</span> link to the outer scope is
      weakened to avoid a reference loop.
    <p class="Pp">One reference count is stolen, so you may need to do
        <span class="Li">&quot;SvREFCNT_inc(func)&quot;</span>.</p>
    <p class="Pp"><span class="Li">&quot;optype&quot;</span> should be an opcode
        indicating the type of operation that the pad entry is to support. This
        doesn't affect operational semantics, but is used for debugging.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> PADOFFSET  pad_add_anon(CV* func, I32 optype)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;pad_add_name_pv&quot;</dt>
  <dd>Exactly like &quot;pad_add_name_pvn&quot;, but takes a nul-terminated
      string instead of a string/length pair.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> PADOFFSET  pad_add_name_pv(const char *name, const U32 flags,
                            HV *typestash, HV *ourstash)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;pad_add_name_pvn&quot;</dt>
  <dd>Allocates a place in the currently-compiling pad for a named lexical
      variable. Stores the name and other metadata in the name part of the pad,
      and makes preparations to manage the variable's lexical scoping. Returns
      the offset of the allocated pad slot.
    <p class="Pp"><span class="Li">&quot;namepv&quot;</span>/<span class="Li">&quot;namelen&quot;</span>
        specify the variable's name, including leading sigil. If
        <span class="Li">&quot;typestash&quot;</span> is non-null, the name is
        for a typed lexical, and this identifies the type. If
        <span class="Li">&quot;ourstash&quot;</span> is non-null, it's a lexical
        reference to a package variable, and this identifies the package. The
        following flags can be OR'ed together:</p>
    <p class="Pp"></p>
    <pre> padadd_OUR          redundantly specifies if it's a package var
 padadd_STATE        variable will retain value persistently
 padadd_NO_DUP_CHECK skip check for lexical shadowing
    </pre>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> PADOFFSET  pad_add_name_pvn(const char *namepv, STRLEN namelen,
                             U32 flags, HV *typestash,
                             HV *ourstash)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;pad_add_name_sv&quot;</dt>
  <dd>Exactly like &quot;pad_add_name_pvn&quot;, but takes the name string in
      the form of an SV instead of a string/length pair.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> PADOFFSET  pad_add_name_sv(SV *name, U32 flags, HV *typestash,
                            HV *ourstash)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;pad_alloc&quot;</dt>
  <dd>NOTE: <span class="Li">&quot;pad_alloc&quot;</span> is <b>experimental</b>
      and may change or be removed without notice.
    <p class="Pp">Allocates a place in the currently-compiling pad, returning
        the offset of the allocated pad slot. No name is initially attached to
        the pad slot. <span class="Li">&quot;tmptype&quot;</span> is a set of
        flags indicating the kind of pad entry required, which will be set in
        the value SV for the allocated pad entry:</p>
    <p class="Pp"></p>
    <pre>    SVs_PADMY    named lexical variable (&quot;my&quot;, &quot;our&quot;, &quot;state&quot;)
    SVs_PADTMP   unnamed temporary store
    SVf_READONLY constant shared between recursion levels
    </pre>
    <p class="Pp"><span class="Li">&quot;SVf_READONLY&quot;</span> has been
        supported here only since perl 5.20. To work with earlier versions as
        well, use <span class="Li">&quot;SVf_READONLY|SVs_PADTMP&quot;</span>.
        <span class="Li">&quot;SVf_READONLY&quot;</span> does not cause the SV
        in the pad slot to be marked read-only, but simply tells
        <span class="Li">&quot;pad_alloc&quot;</span> that it <i>will</i> be
        made read-only (by the caller), or at least should be treated as
      such.</p>
    <p class="Pp"><span class="Li">&quot;optype&quot;</span> should be an opcode
        indicating the type of operation that the pad entry is to support. This
        doesn't affect operational semantics, but is used for debugging.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> PADOFFSET  pad_alloc(I32 optype, U32 tmptype)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;pad_findmy_pv&quot;</dt>
  <dd>Exactly like &quot;pad_findmy_pvn&quot;, but takes a nul-terminated string
      instead of a string/length pair.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> PADOFFSET  pad_findmy_pv(const char* name, U32 flags)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;pad_findmy_pvn&quot;</dt>
  <dd>Given the name of a lexical variable, find its position in the
      currently-compiling pad.
      <span class="Li">&quot;namepv&quot;</span>/<span class="Li">&quot;namelen&quot;</span>
      specify the variable's name, including leading sigil.
      <span class="Li">&quot;flags&quot;</span> is reserved and must be zero. If
      it is not in the current pad but appears in the pad of any lexically
      enclosing scope, then a pseudo-entry for it is added in the current pad.
      Returns the offset in the current pad, or
      <span class="Li">&quot;NOT_IN_PAD&quot;</span> if no such lexical is in
      scope.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> PADOFFSET  pad_findmy_pvn(const char* namepv, STRLEN namelen,
                           U32 flags)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;pad_findmy_sv&quot;</dt>
  <dd>Exactly like &quot;pad_findmy_pvn&quot;, but takes the name string in the
      form of an SV instead of a string/length pair.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> PADOFFSET  pad_findmy_sv(SV* name, U32 flags)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;padnamelist_fetch&quot;</dt>
  <dd>NOTE: <span class="Li">&quot;padnamelist_fetch&quot;</span> is
      <b>experimental</b> and may change or be removed without notice.
    <p class="Pp">Fetches the pad name from the given index.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> PADNAME *  padnamelist_fetch(PADNAMELIST *pnl, SSize_t key)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;padnamelist_store&quot;</dt>
  <dd>NOTE: <span class="Li">&quot;padnamelist_store&quot;</span> is
      <b>experimental</b> and may change or be removed without notice.
    <p class="Pp">Stores the pad name (which may be null) at the given index,
        freeing any existing pad name in that slot.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> PADNAME **  padnamelist_store(PADNAMELIST *pnl, SSize_t key,
                               PADNAME *val)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;pad_tidy&quot;</dt>
  <dd>NOTE: <span class="Li">&quot;pad_tidy&quot;</span> is <b>experimental</b>
      and may change or be removed without notice.
    <p class="Pp">Tidy up a pad at the end of compilation of the code to which
        it belongs. Jobs performed here are: remove most stuff from the pads of
        anonsub prototypes; give it a <span class="Li">@_</span>; mark
        temporaries as such. <span class="Li">&quot;type&quot;</span> indicates
        the kind of subroutine:</p>
    <p class="Pp"></p>
    <pre>    padtidy_SUB        ordinary subroutine
    padtidy_SUBCLONE   prototype for lexical closure
    padtidy_FORMAT     format
    </pre>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  pad_tidy(padtidy_type type)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;perl_alloc&quot;</dt>
  <dd>Allocates a new Perl interpreter. See perlembed.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> PerlInterpreter*  perl_alloc()
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;PERL_ASYNC_CHECK&quot;</dt>
  <dd>Described in perlinterp.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  PERL_ASYNC_CHECK()
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;perl_clone&quot;</dt>
  <dd>Create and return a new interpreter by cloning the current one.
    <p class="Pp"><span class="Li">&quot;perl_clone&quot;</span> takes these
        flags as parameters:</p>
    <p class="Pp"><span class="Li">&quot;CLONEf_COPY_STACKS&quot;</span> - is
        used to, well, copy the stacks also, without it we only clone the data
        and zero the stacks, with it we copy the stacks and the new perl
        interpreter is ready to run at the exact same point as the previous one.
        The pseudo-fork code uses
        <span class="Li">&quot;COPY_STACKS&quot;</span> while the
        threads-&gt;create doesn't.</p>
    <p class="Pp"><span class="Li">&quot;CLONEf_KEEP_PTR_TABLE&quot;</span> -
        <span class="Li">&quot;perl_clone&quot;</span> keeps a ptr_table with
        the pointer of the old variable as a key and the new variable as a
        value, this allows it to check if something has been cloned and not
        clone it again, but rather just use the value and increase the refcount.
        If <span class="Li">&quot;KEEP_PTR_TABLE&quot;</span> is not set then
        <span class="Li">&quot;perl_clone&quot;</span> will kill the ptr_table
        using the function
        <span class="Li">&quot;ptr_table_free(PL_ptr_table);&#x00A0;PL_ptr_table&#x00A0;=&#x00A0;NULL;&quot;</span>.
        A reason to keep it around is if you want to dup some of your own
        variables which are outside the graph that perl scans.</p>
    <p class="Pp"><span class="Li">&quot;CLONEf_CLONE_HOST&quot;</span> - This
        is a win32 thing, it is ignored on unix, it tells perl's win32host code
        (which is c++) to clone itself, this is needed on win32 if you want to
        run two threads at the same time, if you just want to do some stuff in a
        separate perl interpreter and then throw it away and return to the
        original one, you don't need to do anything.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> PerlInterpreter*  perl_clone(PerlInterpreter *proto_perl,
                              UV flags)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;perl_construct&quot;</dt>
  <dd>Initializes a new Perl interpreter. See perlembed.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  perl_construct(PerlInterpreter *my_perl)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;perl_destruct&quot;</dt>
  <dd>Shuts down a Perl interpreter. See perlembed for a tutorial.
    <p class="Pp"><span class="Li">&quot;my_perl&quot;</span> points to the Perl
        interpreter. It must have been previously created through the use of
        &quot;perl_alloc&quot; and &quot;perl_construct&quot;. It may have been
        initialised through &quot;perl_parse&quot;, and may have been used
        through &quot;perl_run&quot; and other means. This function should be
        called for any Perl interpreter that has been constructed with
        &quot;perl_construct&quot;, even if subsequent operations on it failed,
        for example if &quot;perl_parse&quot; returned a non-zero value.</p>
    <p class="Pp">If the interpreter's
        <span class="Li">&quot;PL_exit_flags&quot;</span> word has the
        <span class="Li">&quot;PERL_EXIT_DESTRUCT_END&quot;</span> flag set,
        then this function will execute code in
        <span class="Li">&quot;END&quot;</span> blocks before performing the
        rest of destruction. If it is desired to make any use of the interpreter
        between &quot;perl_parse&quot; and &quot;perl_destruct&quot; other than
        just calling &quot;perl_run&quot;, then this flag should be set early
        on. This matters if &quot;perl_run&quot; will not be called, or if
        anything else will be done in addition to calling
      &quot;perl_run&quot;.</p>
    <p class="Pp">Returns a value be a suitable value to pass to the C library
        function <span class="Li">&quot;exit&quot;</span> (or to return from
        <span class="Li">&quot;main&quot;</span>), to serve as an exit code
        indicating the nature of the way the interpreter terminated. This takes
        into account any failure of &quot;perl_parse&quot; and any early exit
        from &quot;perl_run&quot;. The exit code is of the type required by the
        host operating system, so because of differing exit code conventions it
        is not portable to interpret specific numeric values as having specific
        meanings.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> int  perl_destruct(PerlInterpreter *my_perl)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;perl_free&quot;</dt>
  <dd>Releases a Perl interpreter. See perlembed.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  perl_free(PerlInterpreter *my_perl)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;perl_parse&quot;</dt>
  <dd>Tells a Perl interpreter to parse a Perl script. This performs most of the
      initialisation of a Perl interpreter. See perlembed for a tutorial.
    <p class="Pp"><span class="Li">&quot;my_perl&quot;</span> points to the Perl
        interpreter that is to parse the script. It must have been previously
        created through the use of &quot;perl_alloc&quot; and
        &quot;perl_construct&quot;. <span class="Li">&quot;xsinit&quot;</span>
        points to a callback function that will be called to set up the ability
        for this Perl interpreter to load XS extensions, or may be null to
        perform no such setup.</p>
    <p class="Pp"><span class="Li">&quot;argc&quot;</span> and
        <span class="Li">&quot;argv&quot;</span> supply a set of command-line
        arguments to the Perl interpreter, as would normally be passed to the
        <span class="Li">&quot;main&quot;</span> function of a C program.
        <span class="Li">&quot;argv[argc]&quot;</span> must be null. These
        arguments are where the script to parse is specified, either by naming a
        script file or by providing a script in a
        <span class="Li">&quot;-e&quot;</span> option. If
        <span class="Li">$0</span> will be written to in the Perl interpreter,
        then the argument strings must be in writable memory, and so mustn't
        just be string constants.</p>
    <p class="Pp"><span class="Li">&quot;env&quot;</span> specifies a set of
        environment variables that will be used by this Perl interpreter. If
        non-null, it must point to a null-terminated array of environment
        strings. If null, the Perl interpreter will use the environment supplied
        by the <span class="Li">&quot;environ&quot;</span> global variable.</p>
    <p class="Pp">This function initialises the interpreter, and parses and
        compiles the script specified by the command-line arguments. This
        includes executing code in <span class="Li">&quot;BEGIN&quot;</span>,
        <span class="Li">&quot;UNITCHECK&quot;</span>, and
        <span class="Li">&quot;CHECK&quot;</span> blocks. It does not execute
        <span class="Li">&quot;INIT&quot;</span> blocks or the main program.</p>
    <p class="Pp">Returns an integer of slightly tricky interpretation. The
        correct use of the return value is as a truth value indicating whether
        there was a failure in initialisation. If zero is returned, this
        indicates that initialisation was successful, and it is safe to proceed
        to call &quot;perl_run&quot; and make other use of it. If a non-zero
        value is returned, this indicates some problem that means the
        interpreter wants to terminate. The interpreter should not be just
        abandoned upon such failure; the caller should proceed to shut the
        interpreter down cleanly with &quot;perl_destruct&quot; and free it with
        &quot;perl_free&quot;.</p>
    <p class="Pp">For historical reasons, the non-zero return value also
        attempts to be a suitable value to pass to the C library function
        <span class="Li">&quot;exit&quot;</span> (or to return from
        <span class="Li">&quot;main&quot;</span>), to serve as an exit code
        indicating the nature of the way initialisation terminated. However,
        this isn't portable, due to differing exit code conventions. A
        historical bug is preserved for the time being: if the Perl built-in
        <span class="Li">&quot;exit&quot;</span> is called during this
        function's execution, with a type of exit entailing a zero exit code
        under the host operating system's conventions, then this function
        returns zero rather than a non-zero value. This bug, [perl #2754], leads
        to <span class="Li">&quot;perl_run&quot;</span> being called (and
        therefore <span class="Li">&quot;INIT&quot;</span> blocks and the main
        program running) despite a call to
        <span class="Li">&quot;exit&quot;</span>. It has been preserved because
        a popular module-installing module has come to rely on it and needs time
        to be fixed. This issue is [perl #132577], and the original bug is due
        to be fixed in Perl 5.30.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> int  perl_parse(PerlInterpreter *my_perl, XSINIT_t xsinit,
                 int argc, char** argv, char** env)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;perl_run&quot;</dt>
  <dd>Tells a Perl interpreter to run its main program. See perlembed for a
      tutorial.
    <p class="Pp"><span class="Li">&quot;my_perl&quot;</span> points to the Perl
        interpreter. It must have been previously created through the use of
        &quot;perl_alloc&quot; and &quot;perl_construct&quot;, and initialised
        through &quot;perl_parse&quot;. This function should not be called if
        &quot;perl_parse&quot; returned a non-zero value, indicating a failure
        in initialisation or compilation.</p>
    <p class="Pp">This function executes code in
        <span class="Li">&quot;INIT&quot;</span> blocks, and then executes the
        main program. The code to be executed is that established by the prior
        call to &quot;perl_parse&quot;. If the interpreter's
        <span class="Li">&quot;PL_exit_flags&quot;</span> word does not have the
        <span class="Li">&quot;PERL_EXIT_DESTRUCT_END&quot;</span> flag set,
        then this function will also execute code in
        <span class="Li">&quot;END&quot;</span> blocks. If it is desired to make
        any further use of the interpreter after calling this function, then
        <span class="Li">&quot;END&quot;</span> blocks should be postponed to
        &quot;perl_destruct&quot; time by setting that flag.</p>
    <p class="Pp">Returns an integer of slightly tricky interpretation. The
        correct use of the return value is as a truth value indicating whether
        the program terminated non-locally. If zero is returned, this indicates
        that the program ran to completion, and it is safe to make other use of
        the interpreter (provided that the
        <span class="Li">&quot;PERL_EXIT_DESTRUCT_END&quot;</span> flag was set
        as described above). If a non-zero value is returned, this indicates
        that the interpreter wants to terminate early. The interpreter should
        not be just abandoned because of this desire to terminate; the caller
        should proceed to shut the interpreter down cleanly with
        &quot;perl_destruct&quot; and free it with &quot;perl_free&quot;.</p>
    <p class="Pp">For historical reasons, the non-zero return value also
        attempts to be a suitable value to pass to the C library function
        <span class="Li">&quot;exit&quot;</span> (or to return from
        <span class="Li">&quot;main&quot;</span>), to serve as an exit code
        indicating the nature of the way the program terminated. However, this
        isn't portable, due to differing exit code conventions. An attempt is
        made to return an exit code of the type required by the host operating
        system, but because it is constrained to be non-zero, it is not
        necessarily possible to indicate every type of exit. It is only reliable
        on Unix, where a zero exit code can be augmented with a set bit that
        will be ignored. In any case, this function is not the correct place to
        acquire an exit code: one should get that from
        &quot;perl_destruct&quot;.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> int  perl_run(PerlInterpreter *my_perl)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;PERL_SYS_INIT&quot;</dt>
  <dd>Provides system-specific tune up of the C runtime environment necessary to
      run Perl interpreters. This should be called only once, before creating
      any Perl interpreters.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  PERL_SYS_INIT(int *argc, char*** argv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;PERL_SYS_INIT3&quot;</dt>
  <dd>Provides system-specific tune up of the C runtime environment necessary to
      run Perl interpreters. This should be called only once, before creating
      any Perl interpreters.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  PERL_SYS_INIT3(int *argc, char*** argv, char*** env)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;PERL_SYS_TERM&quot;</dt>
  <dd>Provides system-specific clean up of the C runtime environment after
      running Perl interpreters. This should be called only once, after freeing
      any remaining Perl interpreters.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  PERL_SYS_TERM()
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;PL_exit_flags&quot;</dt>
  <dd>Contains flags controlling perl's behaviour on <b>exit()</b>:</dd>
</dl>
<div class="Bd-indent">
<ul class="Bl-bullet">
  <li><span class="Li">&quot;PERL_EXIT_DESTRUCT_END&quot;</span>
    <p class="Pp">If set, END blocks are executed when the interpreter is
        destroyed. This is normally set by perl itself after the interpreter is
        constructed.</p>
  </li>
  <li><span class="Li">&quot;PERL_EXIT_ABORT&quot;</span>
    <p class="Pp">Call <span class="Li">&quot;abort()&quot;</span> on exit. This
        is used internally by perl itself to abort if exit is called while
        processing exit.</p>
  </li>
  <li><span class="Li">&quot;PERL_EXIT_WARN&quot;</span>
    <p class="Pp">Warn on exit.</p>
  </li>
  <li><span class="Li">&quot;PERL_EXIT_EXPECTED&quot;</span>
    <p class="Pp">Set by the &quot;exit&quot; in perlfunc operator.</p>
  </li>
</ul>
</div>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> U8  PL_exit_flags
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;PL_perl_destruct_level&quot;</dt>
  <dd>This value may be set when embedding for full cleanup.
    <p class="Pp">Possible values:</p>
  </dd>
</dl>
<div class="Bd-indent">
<ul class="Bl-bullet">
  <li>0 - none</li>
  <li>1 - full</li>
  <li>2 or greater - full with checks.</li>
</ul>
</div>
<div class="Bd-indent">
<p class="Pp">If <span class="Li">$ENV{PERL_DESTRUCT_LEVEL}</span> is set to an
    integer greater than the value of
    <span class="Li">&quot;PL_perl_destruct_level&quot;</span> its value is used
    instead.</p>
<p class="Pp">On threaded perls, each thread has an independent copy of this
    variable; each initialized at creation time with the current value of the
    creating thread's copy.</p>
<p class="Pp"></p>
<pre> signed char  PL_perl_destruct_level
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;require_pv&quot;</dt>
  <dd>Tells Perl to <span class="Li">&quot;require&quot;</span> the file named
      by the string argument. It is analogous to the Perl code
      <span class="Li">&quot;eval &quot;require '$file'&quot;&quot;</span>. It's
      even implemented that way; consider using load_module instead.
    <p class="Pp">NOTE: the
        <span class="Li">&quot;perl_require_pv()&quot;</span> form is
        <b>deprecated</b>.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  require_pv(const char* pv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;UVf&quot;</dt>
  <dd><span class="Li">&quot;</span><span class="Li"><b>DEPRECATED!</b></span><span class="Li">&quot;</span>
      It is planned to remove <span class="Li">&quot;UVf&quot;</span> from a
      future release of Perl. Do not use it for new code; remove it from
      existing code.
    <p class="Pp">Obsolete form of <span class="Li">&quot;UVuf&quot;</span>,
        which you should convert to instead use</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> const char *  UVf
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;vload_module&quot;</dt>
  <dd>Like <span class="Li">&quot;load_module&quot;</span> but the arguments are
      an encapsulated argument list.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  vload_module(U32 flags, SV* name, SV* ver, va_list* args)
</pre>
</div>
<div class="Bd-indent"></div>
</section>
<section class="Sh">
<h1 class="Sh" id="Errno"><a class="permalink" href="#Errno">Errno</a></h1>
<dl class="Bl-tag">
  <dt>&quot;sv_string_from_errnum&quot;</dt>
  <dd>Generates the message string describing an OS error and returns it as an
      SV. <span class="Li">&quot;errnum&quot;</span> must be a value that
      <span class="Li">&quot;errno&quot;</span> could take, identifying the type
      of error.
    <p class="Pp">If <span class="Li">&quot;tgtsv&quot;</span> is non-null then
        the string will be written into that SV (overwriting existing content)
        and it will be returned. If <span class="Li">&quot;tgtsv&quot;</span> is
        a null pointer then the string will be written into a new mortal SV
        which will be returned.</p>
    <p class="Pp">The message will be taken from whatever locale would be used
        by <span class="Li">$!</span>, and will be encoded in the SV in whatever
        manner would be used by <span class="Li">$!</span>. The details of this
        process are subject to future change. Currently, the message is taken
        from the C locale by default (usually producing an English message), and
        from the currently selected locale when in the scope of the
        <span class="Li">&quot;use locale&quot;</span> pragma. A heuristic
        attempt is made to decode the message from the locale's character
        encoding, but it will only be decoded as either UTF-8 or ISO-8859-1. It
        is always correctly decoded in a UTF-8 locale, usually in an ISO-8859-1
        locale, and never in any other locale.</p>
    <p class="Pp">The SV is always returned containing an actual string, and
        with no other OK bits set. Unlike <span class="Li">$!</span>, a message
        is even yielded for <span class="Li">&quot;errnum&quot;</span> zero
        (meaning success), and if no useful message is available then a useless
        string (currently empty) is returned.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> SV*  sv_string_from_errnum(int errnum, SV* tgtsv)
</pre>
</div>
<div class="Bd-indent"></div>
</section>
<section class="Sh">
<h1 class="Sh" id="Exception_Handling_(simple)_Macros"><a class="permalink" href="#Exception_Handling_(simple)_Macros">Exception
  Handling (simple) Macros</a></h1>
<dl class="Bl-tag">
  <dt>&quot;dXCPT&quot;</dt>
  <dd>Set up necessary local variables for exception handling. See
      &quot;Exception Handling&quot; in perlguts.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre>   dXCPT;
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;JMPENV_JUMP&quot;</dt>
  <dd>Described in perlinterp.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  JMPENV_JUMP(int v)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;JMPENV_PUSH&quot;</dt>
  <dd>Described in perlinterp.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  JMPENV_PUSH(int v)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;PL_restartop&quot;</dt>
  <dd>Described in perlinterp.</dd>
  <dt>&quot;XCPT_CATCH&quot;</dt>
  <dd>Introduces a catch block. See &quot;Exception Handling&quot; in
    perlguts.</dd>
  <dt>&quot;XCPT_RETHROW&quot;</dt>
  <dd>Rethrows a previously caught exception. See &quot;Exception Handling&quot;
      in perlguts.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre>   XCPT_RETHROW;
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;XCPT_TRY_END&quot;</dt>
  <dd>Ends a try block. See &quot;Exception Handling&quot; in perlguts.</dd>
  <dt>&quot;XCPT_TRY_START&quot;</dt>
  <dd>Starts a try block. See &quot;Exception Handling&quot; in perlguts.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="Filesystem_configuration_values"><a class="permalink" href="#Filesystem_configuration_values">Filesystem
  configuration values</a></h1>
<p class="Pp">Also see &quot;List of capability HAS_foo symbols&quot;.</p>
<dl class="Bl-tag">
  <dt>&quot;DIRNAMLEN&quot;</dt>
  <dd>This symbol, if defined, indicates to the C program that the length of
      directory entry names is provided by a
      <span class="Li">&quot;d_namlen&quot;</span> field. Otherwise you need to
      do <span class="Li">&quot;strlen()&quot;</span> on the
      <span class="Li">&quot;d_name&quot;</span> field.</dd>
  <dt>&quot;DOSUID&quot;</dt>
  <dd>This symbol, if defined, indicates that the C program should check the
      script that it is executing for setuid/setgid bits, and attempt to emulate
      setuid/setgid on systems that have disabled setuid #! scripts because the
      kernel can't do it securely. It is up to the package designer to make sure
      that this emulation is done securely. Among other things, it should do an
      fstat on the script it just opened to make sure it really is a
      setuid/setgid script, it should make sure the arguments passed correspond
      exactly to the argument on the #! line, and it should not trust any
      subprocesses to which it must pass the filename rather than the file
      descriptor of the script to be executed.</dd>
  <dt>&quot;EOF_NONBLOCK&quot;</dt>
  <dd>This symbol, if defined, indicates to the C program that a
      <span class="Li">&quot;read()&quot;</span> on a non-blocking file
      descriptor will return 0 on <span class="Li">&quot;EOF&quot;</span>, and
      not the value held in <span class="Li">&quot;RD_NODATA&quot;</span> (-1
      usually, in that case!).</dd>
  <dt>&quot;FCNTL_CAN_LOCK&quot;</dt>
  <dd>This symbol, if defined, indicates that
      <span class="Li">&quot;fcntl()&quot;</span> can be used for file locking.
      Normally on Unix systems this is defined. It may be undefined on
      <span class="Li">&quot;VMS&quot;</span>.</dd>
  <dt>&quot;FFLUSH_ALL&quot;</dt>
  <dd>This symbol, if defined, tells that to flush all pending stdio output one
      must loop through all the stdio file handles stored in an array and fflush
      them. Note that if <span class="Li">&quot;fflushNULL&quot;</span> is
      defined, fflushall will not even be probed for and will be left
    undefined.</dd>
  <dt>&quot;FFLUSH_NULL&quot;</dt>
  <dd>This symbol, if defined, tells that
      <span class="Li">&quot;fflush(NULL)&quot;</span> correctly flushes all
      pending stdio output without side effects. In particular, on some
      platforms calling <span class="Li">&quot;fflush(NULL)&quot;</span> *still*
      corrupts <span class="Li">&quot;STDIN&quot;</span> if it is a pipe.</dd>
  <dt>&quot;FILE_base&quot;</dt>
  <dd>This macro is used to access the <span class="Li">&quot;_base&quot;</span>
      field (or equivalent) of the <span class="Li">&quot;FILE&quot;</span>
      structure pointed to by its argument. This macro will always be defined if
      <span class="Li">&quot;USE_STDIO_BASE&quot;</span> is defined.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void *  FILE_base(FILE * f)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;FILE_bufsiz&quot;</dt>
  <dd>This macro is used to determine the number of bytes in the I/O buffer
      pointed to by <span class="Li">&quot;_base&quot;</span> field (or
      equivalent) of the <span class="Li">&quot;FILE&quot;</span> structure
      pointed to its argument. This macro will always be defined if
      <span class="Li">&quot;USE_STDIO_BASE&quot;</span> is defined.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> Size_t  FILE_bufsiz(FILE *f)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;FILE_cnt&quot;</dt>
  <dd>This macro is used to access the <span class="Li">&quot;_cnt&quot;</span>
      field (or equivalent) of the <span class="Li">&quot;FILE&quot;</span>
      structure pointed to by its argument. This macro will always be defined if
      <span class="Li">&quot;USE_STDIO_PTR&quot;</span> is defined.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> Size_t  FILE_cnt(FILE * f)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;FILE_ptr&quot;</dt>
  <dd>This macro is used to access the <span class="Li">&quot;_ptr&quot;</span>
      field (or equivalent) of the <span class="Li">&quot;FILE&quot;</span>
      structure pointed to by its argument. This macro will always be defined if
      <span class="Li">&quot;USE_STDIO_PTR&quot;</span> is defined.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void *  FILE_ptr(FILE * f)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;FLEXFILENAMES&quot;</dt>
  <dd>This symbol, if defined, indicates that the system supports filenames
      longer than 14 characters.</dd>
  <dt>&quot;HAS_DIR_DD_FD&quot;</dt>
  <dd>This symbol, if defined, indicates that the the
      <span class="Li">&quot;DIR&quot;</span>* dirstream structure contains a
      member variable named <span class="Li">&quot;dd_fd&quot;</span>.</dd>
  <dt>&quot;HAS_DUP2&quot;</dt>
  <dd>This symbol, if defined, indicates that the
      <span class="Li">&quot;dup2&quot;</span> routine is available to duplicate
      file descriptors.</dd>
  <dt>&quot;HAS_DUP3&quot;</dt>
  <dd>This symbol, if defined, indicates that the
      <span class="Li">&quot;dup3&quot;</span> routine is available to duplicate
      file descriptors.</dd>
  <dt>&quot;HAS_FAST_STDIO&quot;</dt>
  <dd>This symbol, if defined, indicates that the &quot;fast stdio&quot; is
      available to manipulate the stdio buffers directly.</dd>
  <dt>&quot;HAS_FCHDIR&quot;</dt>
  <dd>This symbol, if defined, indicates that the
      <span class="Li">&quot;fchdir&quot;</span> routine is available to change
      directory using a file descriptor.</dd>
  <dt>&quot;HAS_FCNTL&quot;</dt>
  <dd>This symbol, if defined, indicates to the C program that the
      <span class="Li">&quot;fcntl()&quot;</span> function exists.</dd>
  <dt>&quot;HAS_FDCLOSE&quot;</dt>
  <dd>This symbol, if defined, indicates that the
      <span class="Li">&quot;fdclose&quot;</span> routine is available to free a
      <span class="Li">&quot;FILE&quot;</span> structure without closing the
      underlying file descriptor. This function appeared in
      <span class="Li">&quot;FreeBSD&quot;</span> 10.2.</dd>
  <dt>&quot;HAS_FPATHCONF&quot;</dt>
  <dd>This symbol, if defined, indicates that
      <span class="Li">&quot;pathconf()&quot;</span> is available to determine
      file-system related limits and options associated with a given open file
      descriptor.</dd>
  <dt>&quot;HAS_FPOS64_T&quot;</dt>
  <dd>This symbol will be defined if the C compiler supports
      <span class="Li">&quot;fpos64_t&quot;</span>.</dd>
  <dt>&quot;HAS_FSTATFS&quot;</dt>
  <dd>This symbol, if defined, indicates that the
      <span class="Li">&quot;fstatfs&quot;</span> routine is available to stat
      filesystems by file descriptors.</dd>
  <dt>&quot;HAS_FSTATVFS&quot;</dt>
  <dd>This symbol, if defined, indicates that the
      <span class="Li">&quot;fstatvfs&quot;</span> routine is available to stat
      filesystems by file descriptors.</dd>
  <dt>&quot;HAS_GETFSSTAT&quot;</dt>
  <dd>This symbol, if defined, indicates that the
      <span class="Li">&quot;getfsstat&quot;</span> routine is available to stat
      filesystems in bulk.</dd>
  <dt>&quot;HAS_GETMNT&quot;</dt>
  <dd>This symbol, if defined, indicates that the
      <span class="Li">&quot;getmnt&quot;</span> routine is available to get
      filesystem mount info by filename.</dd>
  <dt>&quot;HAS_GETMNTENT&quot;</dt>
  <dd>This symbol, if defined, indicates that the
      <span class="Li">&quot;getmntent&quot;</span> routine is available to
      iterate through mounted file systems to get their info.</dd>
  <dt>&quot;HAS_HASMNTOPT&quot;</dt>
  <dd>This symbol, if defined, indicates that the
      <span class="Li">&quot;hasmntopt&quot;</span> routine is available to
      query the mount options of file systems.</dd>
  <dt>&quot;HAS_LSEEK_PROTO&quot;</dt>
  <dd>This symbol, if defined, indicates that the system provides a prototype
      for the <span class="Li">&quot;lseek()&quot;</span> function. Otherwise,
      it is up to the program to supply one. A good guess is
    <p class="Pp"></p>
    <pre> extern off_t lseek(int, off_t, int);
    </pre>
  </dd>
  <dt>&quot;HAS_MKDIR&quot;</dt>
  <dd>This symbol, if defined, indicates that the
      <span class="Li">&quot;mkdir&quot;</span> routine is available to create
      directories. Otherwise you should fork off a new process to exec
      <i>/bin/mkdir</i>.</dd>
  <dt>&quot;HAS_OFF64_T&quot;</dt>
  <dd>This symbol will be defined if the C compiler supports
      <span class="Li">&quot;off64_t&quot;</span>.</dd>
  <dt>&quot;HAS_OPEN3&quot;</dt>
  <dd>This manifest constant lets the C program know that the three argument
      form of <span class="Li">open(2)</span> is available.</dd>
  <dt>&quot;HAS_OPENAT&quot;</dt>
  <dd>This symbol is defined if the <span class="Li">&quot;openat()&quot;</span>
      routine is available.</dd>
  <dt>&quot;HAS_POLL&quot;</dt>
  <dd>This symbol, if defined, indicates that the
      <span class="Li">&quot;poll&quot;</span> routine is available to
      <span class="Li">&quot;poll&quot;</span> active file descriptors. Please
      check <span class="Li">&quot;I_POLL&quot;</span> and
      <span class="Li">&quot;I_SYS_POLL&quot;</span> to know which header should
      be included as well.</dd>
  <dt>&quot;HAS_READDIR&quot;</dt>
  <dd>This symbol, if defined, indicates that the
      <span class="Li">&quot;readdir&quot;</span> routine is available to read
      directory entries. You may have to include <i>dirent.h</i>. See
      <span class="Li">&quot;I_DIRENT&quot;</span>.</dd>
  <dt>&quot;HAS_READDIR64_R&quot;</dt>
  <dd>This symbol, if defined, indicates that the
      <span class="Li">&quot;readdir64_r&quot;</span> routine is available to
      readdir64 re-entrantly.</dd>
  <dt>&quot;HAS_REWINDDIR&quot;</dt>
  <dd>This symbol, if defined, indicates that the
      <span class="Li">&quot;rewinddir&quot;</span> routine is available. You
      may have to include <i>dirent.h</i>. See
      <span class="Li">&quot;I_DIRENT&quot;</span>.</dd>
  <dt>&quot;HAS_RMDIR&quot;</dt>
  <dd>This symbol, if defined, indicates that the
      <span class="Li">&quot;rmdir&quot;</span> routine is available to remove
      directories. Otherwise you should fork off a new process to exec
      <i>/bin/rmdir</i>.</dd>
  <dt>&quot;HAS_SEEKDIR&quot;</dt>
  <dd>This symbol, if defined, indicates that the
      <span class="Li">&quot;seekdir&quot;</span> routine is available. You may
      have to include <i>dirent.h</i>. See
      <span class="Li">&quot;I_DIRENT&quot;</span>.</dd>
  <dt>&quot;HAS_SELECT&quot;</dt>
  <dd>This symbol, if defined, indicates that the
      <span class="Li">&quot;select&quot;</span> routine is available to
      <span class="Li">&quot;select&quot;</span> active file descriptors. If the
      timeout field is used, <i>sys/time.h</i> may need to be included.</dd>
  <dt>&quot;HAS_SETVBUF&quot;</dt>
  <dd>This symbol, if defined, indicates that the
      <span class="Li">&quot;setvbuf&quot;</span> routine is available to change
      buffering on an open stdio stream. to a line-buffered mode.</dd>
  <dt>&quot;HAS_STDIO_STREAM_ARRAY&quot;</dt>
  <dd>This symbol, if defined, tells that there is an array holding the stdio
      streams.</dd>
  <dt>&quot;HAS_STRUCT_FS_DATA&quot;</dt>
  <dd>This symbol, if defined, indicates that the <span class="Li">&quot;struct
      fs_data&quot;</span> to do <span class="Li">&quot;statfs()&quot;</span> is
      supported.</dd>
  <dt>&quot;HAS_STRUCT_STATFS&quot;</dt>
  <dd>This symbol, if defined, indicates that the <span class="Li">&quot;struct
      statfs&quot;</span> to do <span class="Li">&quot;statfs()&quot;</span> is
      supported.</dd>
  <dt>&quot;HAS_STRUCT_STATFS_F_FLAGS&quot;</dt>
  <dd>This symbol, if defined, indicates that the <span class="Li">&quot;struct
      statfs&quot;</span> does have the
      <span class="Li">&quot;f_flags&quot;</span> member containing the mount
      flags of the filesystem containing the file. This kind of
      <span class="Li">&quot;struct statfs&quot;</span> is coming from
      <i>sys/mount.h</i> (<span class="Li">&quot;BSD&quot;</span> 4.3), not from
      <i>sys/statfs.h</i> (<span class="Li">&quot;SYSV&quot;</span>). Older
      <span class="Li">&quot;BSDs&quot;</span> (like Ultrix) do not have
      <span class="Li">&quot;statfs()&quot;</span> and
      <span class="Li">&quot;struct statfs&quot;</span>, they have
      <span class="Li">&quot;ustat()&quot;</span> and
      <span class="Li">&quot;getmnt()&quot;</span> with
      <span class="Li">&quot;struct ustat&quot;</span> and
      <span class="Li">&quot;struct fs_data&quot;</span>.</dd>
  <dt>&quot;HAS_TELLDIR&quot;</dt>
  <dd>This symbol, if defined, indicates that the
      <span class="Li">&quot;telldir&quot;</span> routine is available. You may
      have to include <i>dirent.h</i>. See
      <span class="Li">&quot;I_DIRENT&quot;</span>.</dd>
  <dt>&quot;HAS_USTAT&quot;</dt>
  <dd>This symbol, if defined, indicates that the
      <span class="Li">&quot;ustat&quot;</span> system call is available to
      query file system statistics by
    <span class="Li">&quot;dev_t&quot;</span>.</dd>
  <dt>&quot;I_FCNTL&quot;</dt>
  <dd>This manifest constant tells the C program to include <i>fcntl.h</i>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> #ifdef I_FCNTL
     #include &lt;fcntl.h&gt;
 #endif
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;I_SYS_DIR&quot;</dt>
  <dd>This symbol, if defined, indicates to the C program that it should include
      <i>sys/dir.h</i>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> #ifdef I_SYS_DIR
     #include &lt;sys_dir.h&gt;
 #endif
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;I_SYS_FILE&quot;</dt>
  <dd>This symbol, if defined, indicates to the C program that it should include
      <i>sys/file.h</i> to get definition of
      <span class="Li">&quot;R_OK&quot;</span> and friends.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> #ifdef I_SYS_FILE
     #include &lt;sys_file.h&gt;
 #endif
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;I_SYS_NDIR&quot;</dt>
  <dd>This symbol, if defined, indicates to the C program that it should include
      <i>sys/ndir.h</i>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> #ifdef I_SYS_NDIR
     #include &lt;sys_ndir.h&gt;
 #endif
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;I_SYS_STATFS&quot;</dt>
  <dd>This symbol, if defined, indicates that <i>sys/statfs.h</i> exists.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> #ifdef I_SYS_STATFS
     #include &lt;sys_statfs.h&gt;
 #endif
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;LSEEKSIZE&quot;</dt>
  <dd>This symbol holds the number of bytes used by the
      <span class="Li">&quot;Off_t&quot;</span>.</dd>
  <dt>&quot;NO_NETWORK_LIBRARY_PERL_FILE&quot;</dt>
  <dd>If this file path exists, the vendor libs (which are the
      <i>/Network/Library/Perl</i> paths) are not added to
      @<span class="Li">&quot;INC&quot;</span>.</dd>
  <dt>&quot;RD_NODATA&quot;</dt>
  <dd>This symbol holds the return code from
      <span class="Li">&quot;read()&quot;</span> when no data is present on the
      non-blocking file descriptor. Be careful! If
      <span class="Li">&quot;EOF_NONBLOCK&quot;</span> is not defined, then you
      can't distinguish between no data and
      <span class="Li">&quot;EOF&quot;</span> by issuing a
      <span class="Li">&quot;read()&quot;</span>. You'll have to find another
      way to tell for sure!</dd>
  <dt>&quot;READDIR64_R_PROTO&quot;</dt>
  <dd>This symbol encodes the prototype of
      <span class="Li">&quot;readdir64_r&quot;</span>. It is zero if
      <span class="Li">&quot;d_readdir64_r&quot;</span> is undef, and one of the
      <span class="Li">&quot;REENTRANT_PROTO_T_ABC&quot;</span> macros of
      <i>reentr.h</i> if <span class="Li">&quot;d_readdir64_r&quot;</span> is
      defined.</dd>
  <dt>&quot;STDCHAR&quot;</dt>
  <dd>This symbol is defined to be the type of char used in <i>stdio.h</i>. It
      has the values &quot;unsigned char&quot; or &quot;char&quot;.</dd>
  <dt>&quot;STDIO_CNT_LVALUE&quot;</dt>
  <dd>This symbol is defined if the <span class="Li">&quot;FILE_cnt&quot;</span>
      macro can be used as an lvalue.</dd>
  <dt>&quot;STDIO_PTR_LVALUE&quot;</dt>
  <dd>This symbol is defined if the <span class="Li">&quot;FILE_ptr&quot;</span>
      macro can be used as an lvalue.</dd>
  <dt>&quot;STDIO_PTR_LVAL_NOCHANGE_CNT&quot;</dt>
  <dd>This symbol is defined if using the
      <span class="Li">&quot;FILE_ptr&quot;</span> macro as an lvalue to
      increase the pointer by n leaves
      <span class="Li">&quot;File_cnt(fp)&quot;</span> unchanged.</dd>
  <dt>&quot;STDIO_PTR_LVAL_SETS_CNT&quot;</dt>
  <dd>This symbol is defined if using the
      <span class="Li">&quot;FILE_ptr&quot;</span> macro as an lvalue to
      increase the pointer by n has the side effect of decreasing the value of
      <span class="Li">&quot;File_cnt(fp)&quot;</span> by n.</dd>
  <dt>&quot;STDIO_STREAM_ARRAY&quot;</dt>
  <dd>This symbol tells the name of the array holding the stdio streams. Usual
      values include <span class="Li">&quot;_iob&quot;</span>,
      <span class="Li">&quot;__iob&quot;</span>, and
      <span class="Li">&quot;__sF&quot;</span>.</dd>
  <dt>&quot;ST_INO_SIGN&quot;</dt>
  <dd>This symbol holds the signedness of <span class="Li">&quot;struct
      stat&quot;</span>'s <span class="Li">&quot;st_ino&quot;</span>. 1 for
      unsigned, -1 for signed.</dd>
  <dt>&quot;ST_INO_SIZE&quot;</dt>
  <dd>This variable contains the size of <span class="Li">&quot;struct
      stat&quot;</span>'s <span class="Li">&quot;st_ino&quot;</span> in
    bytes.</dd>
  <dt>&quot;VAL_EAGAIN&quot;</dt>
  <dd>This symbol holds the errno error code set by
      <span class="Li">&quot;read()&quot;</span> when no data was present on the
      non-blocking file descriptor.</dd>
  <dt>&quot;VAL_O_NONBLOCK&quot;</dt>
  <dd>This symbol is to be used during
      <span class="Li">&quot;open()&quot;</span> or
      <span class="Li">&quot;fcntl(F_SETFL)&quot;</span> to turn on non-blocking
      I/O for the file descriptor. Note that there is no way back, i.e. you
      cannot turn it blocking again this way. If you wish to alternatively
      switch between blocking and non-blocking, use the
      <span class="Li">&quot;ioctl(FIOSNBIO)&quot;</span> call instead, but that
      is not supported by all devices.</dd>
  <dt>&quot;VOID_CLOSEDIR&quot;</dt>
  <dd>This symbol, if defined, indicates that the
      <span class="Li">&quot;closedir()&quot;</span> routine does not return a
      value.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="Floating_point_configuration_values"><a class="permalink" href="#Floating_point_configuration_values">Floating
  point configuration values</a></h1>
<p class="Pp">Also &quot;List of capability HAS_foo symbols&quot; lists
    capabilities that arent in this section. For example
    <span class="Li">&quot;HAS_ASINH&quot;</span>, for the hyperbolic sine
    function.</p>
<dl class="Bl-tag">
  <dt>&quot;CASTFLAGS&quot;</dt>
  <dd>This symbol contains flags that say what difficulties the compiler has
      casting odd floating values to unsigned long:
    <p class="Pp"></p>
    <pre> 0 = ok
 1 = couldn't cast &lt; 0
 2 = couldn't cast &gt;= 0x80000000
 4 = couldn't cast in argument expression list
    </pre>
  </dd>
  <dt>&quot;CASTNEGFLOAT&quot;</dt>
  <dd>This symbol is defined if the C compiler can cast negative numbers to
      unsigned longs, ints and shorts.</dd>
  <dt>&quot;DOUBLE_HAS_INF&quot;</dt>
  <dd>This symbol, if defined, indicates that the double has the infinity.</dd>
  <dt>&quot;DOUBLE_HAS_NAN&quot;</dt>
  <dd>This symbol, if defined, indicates that the double has the
    not-a-number.</dd>
  <dt>&quot;DOUBLE_HAS_NEGATIVE_ZERO&quot;</dt>
  <dd>This symbol, if defined, indicates that the double has the
      <span class="Li">&quot;negative_zero&quot;</span>.</dd>
  <dt>&quot;DOUBLE_HAS_SUBNORMALS&quot;</dt>
  <dd>This symbol, if defined, indicates that the double has the subnormals
      (denormals).</dd>
  <dt>&quot;DOUBLEINFBYTES&quot;</dt>
  <dd>This symbol, if defined, is a comma-separated list of hexadecimal bytes
      for the double precision infinity.</dd>
  <dt>&quot;DOUBLEKIND&quot;</dt>
  <dd><span class="Li">&quot;DOUBLEKIND&quot;</span> will be one of
      <span class="Li">&quot;DOUBLE_IS_IEEE_754_32_BIT_LITTLE_ENDIAN&quot;</span>
      <span class="Li">&quot;DOUBLE_IS_IEEE_754_32_BIT_BIG_ENDIAN&quot;</span>
      <span class="Li">&quot;DOUBLE_IS_IEEE_754_64_BIT_LITTLE_ENDIAN&quot;</span>
      <span class="Li">&quot;DOUBLE_IS_IEEE_754_64_BIT_BIG_ENDIAN&quot;</span>
      <span class="Li">&quot;DOUBLE_IS_IEEE_754_128_BIT_LITTLE_ENDIAN&quot;</span>
      <span class="Li">&quot;DOUBLE_IS_IEEE_754_128_BIT_BIG_ENDIAN&quot;</span>
      <span class="Li">&quot;DOUBLE_IS_IEEE_754_64_BIT_MIXED_ENDIAN_LE_BE&quot;</span>
      <span class="Li">&quot;DOUBLE_IS_IEEE_754_64_BIT_MIXED_ENDIAN_BE_LE&quot;</span>
      <span class="Li">&quot;DOUBLE_IS_VAX_F_FLOAT&quot;</span>
      <span class="Li">&quot;DOUBLE_IS_VAX_D_FLOAT&quot;</span>
      <span class="Li">&quot;DOUBLE_IS_VAX_G_FLOAT&quot;</span>
      <span class="Li">&quot;DOUBLE_IS_IBM_SINGLE_32_BIT&quot;</span>
      <span class="Li">&quot;DOUBLE_IS_IBM_DOUBLE_64_BIT&quot;</span>
      <span class="Li">&quot;DOUBLE_IS_CRAY_SINGLE_64_BIT&quot;</span>
      <span class="Li">&quot;DOUBLE_IS_UNKNOWN_FORMAT&quot;</span></dd>
  <dt>&quot;DOUBLEMANTBITS&quot;</dt>
  <dd>This symbol, if defined, tells how many mantissa bits there are in double
      precision floating point format. Note that this is usually
      <span class="Li">&quot;DBL_MANT_DIG&quot;</span> minus one, since with the
      standard <span class="Li">&quot;IEEE&quot;</span> 754 formats
      <span class="Li">&quot;DBL_MANT_DIG&quot;</span> includes the implicit
      bit, which doesn't really exist.</dd>
  <dt>&quot;DOUBLENANBYTES&quot;</dt>
  <dd>This symbol, if defined, is a comma-separated list of hexadecimal bytes
      (0xHH) for the double precision not-a-number.</dd>
  <dt>&quot;DOUBLESIZE&quot;</dt>
  <dd>This symbol contains the size of a double, so that the C preprocessor can
      make decisions based on it.</dd>
  <dt>&quot;DOUBLE_STYLE_CRAY&quot;</dt>
  <dd>This symbol, if defined, indicates that the double is the 64-bit
      <span class="Li">&quot;CRAY&quot;</span> mainframe format.</dd>
  <dt>&quot;DOUBLE_STYLE_IBM&quot;</dt>
  <dd>This symbol, if defined, indicates that the double is the 64-bit
      <span class="Li">&quot;IBM&quot;</span> mainframe format.</dd>
  <dt>&quot;DOUBLE_STYLE_IEEE&quot;</dt>
  <dd>This symbol, if defined, indicates that the double is the 64-bit
      <span class="Li">&quot;IEEE&quot;</span> 754.</dd>
  <dt>&quot;DOUBLE_STYLE_VAX&quot;</dt>
  <dd>This symbol, if defined, indicates that the double is the 64-bit
      <span class="Li">&quot;VAX&quot;</span> format D or G.</dd>
  <dt>&quot;HAS_ATOLF&quot;</dt>
  <dd>This symbol, if defined, indicates that the
      <span class="Li">&quot;atolf&quot;</span> routine is available to convert
      strings into long doubles.</dd>
  <dt>&quot;HAS_CLASS&quot;</dt>
  <dd>This symbol, if defined, indicates that the
      <span class="Li">&quot;class&quot;</span> routine is available to classify
      doubles. Available for example in <span class="Li">&quot;AIX&quot;</span>.
      The returned values are defined in <i>float.h</i> and are:
    <p class="Pp"></p>
    <pre> FP_PLUS_NORM    Positive normalized, nonzero
 FP_MINUS_NORM   Negative normalized, nonzero
 FP_PLUS_DENORM  Positive denormalized, nonzero
 FP_MINUS_DENORM Negative denormalized, nonzero
 FP_PLUS_ZERO    +0.0
 FP_MINUS_ZERO   -0.0
 FP_PLUS_INF     +INF
 FP_MINUS_INF    -INF
 FP_NANS         Signaling Not a Number (NaNS)
 FP_NANQ         Quiet Not a Number (NaNQ)
    </pre>
  </dd>
  <dt>&quot;HAS_FINITE&quot;</dt>
  <dd>This symbol, if defined, indicates that the
      <span class="Li">&quot;finite&quot;</span> routine is available to check
      whether a double is <span class="Li">&quot;finite&quot;</span>
      (non-infinity non-NaN).</dd>
  <dt>&quot;HAS_FINITEL&quot;</dt>
  <dd>This symbol, if defined, indicates that the
      <span class="Li">&quot;finitel&quot;</span> routine is available to check
      whether a long double is finite (non-infinity non-NaN).</dd>
  <dt>&quot;HAS_FPCLASS&quot;</dt>
  <dd>This symbol, if defined, indicates that the
      <span class="Li">&quot;fpclass&quot;</span> routine is available to
      classify doubles. Available for example in
      Solaris/<span class="Li">&quot;SVR4&quot;</span>. The returned values are
      defined in <i>ieeefp.h</i> and are:
    <p class="Pp"></p>
    <pre> FP_SNAN         signaling NaN
 FP_QNAN         quiet NaN
 FP_NINF         negative infinity
 FP_PINF         positive infinity
 FP_NDENORM      negative denormalized non-zero
 FP_PDENORM      positive denormalized non-zero
 FP_NZERO        negative zero
 FP_PZERO        positive zero
 FP_NNORM        negative normalized non-zero
 FP_PNORM        positive normalized non-zero
    </pre>
  </dd>
  <dt>&quot;HAS_FPCLASSIFY&quot;</dt>
  <dd>This symbol, if defined, indicates that the
      <span class="Li">&quot;fpclassify&quot;</span> routine is available to
      classify doubles. Available for example in HP-UX. The returned values are
      defined in <i>math.h</i> and are
    <p class="Pp"></p>
    <pre> FP_NORMAL     Normalized
 FP_ZERO       Zero
 FP_INFINITE   Infinity
 FP_SUBNORMAL  Denormalized
 FP_NAN        NaN
    </pre>
  </dd>
  <dt>&quot;HAS_FPCLASSL&quot;</dt>
  <dd>This symbol, if defined, indicates that the
      <span class="Li">&quot;fpclassl&quot;</span> routine is available to
      classify long doubles. Available for example in
      <span class="Li">&quot;IRIX&quot;</span>. The returned values are defined
      in <i>ieeefp.h</i> and are:
    <p class="Pp"></p>
    <pre> FP_SNAN         signaling NaN
 FP_QNAN         quiet NaN
 FP_NINF         negative infinity
 FP_PINF         positive infinity
 FP_NDENORM      negative denormalized non-zero
 FP_PDENORM      positive denormalized non-zero
 FP_NZERO        negative zero
 FP_PZERO        positive zero
 FP_NNORM        negative normalized non-zero
 FP_PNORM        positive normalized non-zero
    </pre>
  </dd>
  <dt>&quot;HAS_FPGETROUND&quot;</dt>
  <dd>This symbol, if defined, indicates that the
      <span class="Li">&quot;fpgetround&quot;</span> routine is available to get
      the floating point rounding mode.</dd>
  <dt>&quot;HAS_FP_CLASS&quot;</dt>
  <dd>This symbol, if defined, indicates that the
      <span class="Li">&quot;fp_class&quot;</span> routine is available to
      classify doubles. Available for example in Digital
      <span class="Li">&quot;UNIX&quot;</span>. The returned values are defined
      in <i>math.h</i> and are:
    <p class="Pp"></p>
    <pre> FP_SNAN           Signaling NaN (Not-a-Number)
 FP_QNAN           Quiet NaN (Not-a-Number)
 FP_POS_INF        +infinity
 FP_NEG_INF        -infinity
 FP_POS_NORM       Positive normalized
 FP_NEG_NORM       Negative normalized
 FP_POS_DENORM     Positive denormalized
 FP_NEG_DENORM     Negative denormalized
 FP_POS_ZERO       +0.0 (positive zero)
 FP_NEG_ZERO       -0.0 (negative zero)
    </pre>
  </dd>
  <dt>&quot;HAS_FP_CLASSIFY&quot;</dt>
  <dd>This symbol, if defined, indicates that the
      <span class="Li">&quot;fp_classify&quot;</span> routine is available to
      classify doubles. The values are defined in <i>math.h</i>
    <p class="Pp"></p>
    <pre> FP_NORMAL     Normalized
 FP_ZERO       Zero
 FP_INFINITE   Infinity
 FP_SUBNORMAL  Denormalized
 FP_NAN        NaN
    </pre>
  </dd>
  <dt>&quot;HAS_FP_CLASSL&quot;</dt>
  <dd>This symbol, if defined, indicates that the
      <span class="Li">&quot;fp_classl&quot;</span> routine is available to
      classify long doubles. Available for example in Digital
      <span class="Li">&quot;UNIX&quot;</span>. See for possible values
      <span class="Li">&quot;HAS_FP_CLASS&quot;</span>.</dd>
  <dt>&quot;HAS_FREXPL&quot;</dt>
  <dd>This symbol, if defined, indicates that the
      <span class="Li">&quot;frexpl&quot;</span> routine is available to break a
      long double floating-point number into a normalized fraction and an
      integral power of 2.</dd>
  <dt>&quot;HAS_ILOGB&quot;</dt>
  <dd>This symbol, if defined, indicates that the
      <span class="Li">&quot;ilogb&quot;</span> routine is available to get
      integer exponent of a floating-point value.</dd>
  <dt>&quot;HAS_ISFINITE&quot;</dt>
  <dd>This symbol, if defined, indicates that the
      <span class="Li">&quot;isfinite&quot;</span> routine is available to check
      whether a double is finite (non-infinity non-NaN).</dd>
  <dt>&quot;HAS_ISFINITEL&quot;</dt>
  <dd>This symbol, if defined, indicates that the
      <span class="Li">&quot;isfinitel&quot;</span> routine is available to
      check whether a long double is finite. (non-infinity non-NaN).</dd>
  <dt>&quot;HAS_ISINF&quot;</dt>
  <dd>This symbol, if defined, indicates that the
      <span class="Li">&quot;isinf&quot;</span> routine is available to check
      whether a double is an infinity.</dd>
  <dt>&quot;HAS_ISINFL&quot;</dt>
  <dd>This symbol, if defined, indicates that the
      <span class="Li">&quot;isinfl&quot;</span> routine is available to check
      whether a long double is an infinity.</dd>
  <dt>&quot;HAS_ISNAN&quot;</dt>
  <dd>This symbol, if defined, indicates that the
      <span class="Li">&quot;isnan&quot;</span> routine is available to check
      whether a double is a NaN.</dd>
  <dt>&quot;HAS_ISNANL&quot;</dt>
  <dd>This symbol, if defined, indicates that the
      <span class="Li">&quot;isnanl&quot;</span> routine is available to check
      whether a long double is a NaN.</dd>
  <dt>&quot;HAS_ISNORMAL&quot;</dt>
  <dd>This symbol, if defined, indicates that the
      <span class="Li">&quot;isnormal&quot;</span> routine is available to check
      whether a double is normal (non-zero normalized).</dd>
  <dt>&quot;HAS_J0&quot;</dt>
  <dd>This symbol, if defined, indicates to the C program that the
      <span class="Li">&quot;j0()&quot;</span> function is available for Bessel
      functions of the first kind of the order zero, for doubles.</dd>
  <dt>&quot;HAS_J0L&quot;</dt>
  <dd>This symbol, if defined, indicates to the C program that the
      <span class="Li">&quot;j0l()&quot;</span> function is available for Bessel
      functions of the first kind of the order zero, for long doubles.</dd>
  <dt>&quot;HAS_LDBL_DIG&quot;</dt>
  <dd>This symbol, if defined, indicates that this system's <i>float.h</i> or
      <i>limits.h</i> defines the symbol
      <span class="Li">&quot;LDBL_DIG&quot;</span>, which is the number of
      significant digits in a long double precision number. Unlike for
      <span class="Li">&quot;DBL_DIG&quot;</span>, there's no good guess for
      <span class="Li">&quot;LDBL_DIG&quot;</span> if it is undefined.</dd>
  <dt>&quot;HAS_LDEXPL&quot;</dt>
  <dd>This symbol, if defined, indicates that the
      <span class="Li">&quot;ldexpl&quot;</span> routine is available to shift a
      long double floating-point number by an integral power of 2.</dd>
  <dt>&quot;HAS_LLRINT&quot;</dt>
  <dd>This symbol, if defined, indicates that the
      <span class="Li">&quot;llrint&quot;</span> routine is available to return
      the long long value closest to a double (according to the current rounding
      mode).</dd>
  <dt>&quot;HAS_LLRINTL&quot;</dt>
  <dd>This symbol, if defined, indicates that the
      <span class="Li">&quot;llrintl&quot;</span> routine is available to return
      the long long value closest to a long double (according to the current
      rounding mode).</dd>
  <dt>&quot;HAS_LLROUNDL&quot;</dt>
  <dd>This symbol, if defined, indicates that the
      <span class="Li">&quot;llroundl&quot;</span> routine is available to
      return the nearest long long value away from zero of the long double
      argument value.</dd>
  <dt>&quot;HAS_LONG_DOUBLE&quot;</dt>
  <dd>This symbol will be defined if the C compiler supports long doubles.</dd>
  <dt>&quot;HAS_LRINT&quot;</dt>
  <dd>This symbol, if defined, indicates that the
      <span class="Li">&quot;lrint&quot;</span> routine is available to return
      the integral value closest to a double (according to the current rounding
      mode).</dd>
  <dt>&quot;HAS_LRINTL&quot;</dt>
  <dd>This symbol, if defined, indicates that the
      <span class="Li">&quot;lrintl&quot;</span> routine is available to return
      the integral value closest to a long double (according to the current
      rounding mode).</dd>
  <dt>&quot;HAS_LROUNDL&quot;</dt>
  <dd>This symbol, if defined, indicates that the
      <span class="Li">&quot;lroundl&quot;</span> routine is available to return
      the nearest integral value away from zero of the long double argument
      value.</dd>
  <dt>&quot;HAS_MODFL&quot;</dt>
  <dd>This symbol, if defined, indicates that the
      <span class="Li">&quot;modfl&quot;</span> routine is available to split a
      long double x into a fractional part f and an integer part i such that |f|
      &lt; 1.0 and (f + i) = x.</dd>
  <dt>&quot;HAS_NAN&quot;</dt>
  <dd>This symbol, if defined, indicates that the
      <span class="Li">&quot;nan&quot;</span> routine is available to generate
      NaN.</dd>
  <dt>&quot;HAS_NEXTTOWARD&quot;</dt>
  <dd>This symbol, if defined, indicates that the
      <span class="Li">&quot;nexttoward&quot;</span> routine is available to
      return the next machine representable long double from x in direction
    y.</dd>
  <dt>&quot;HAS_REMAINDER&quot;</dt>
  <dd>This symbol, if defined, indicates that the
      <span class="Li">&quot;remainder&quot;</span> routine is available to
      return the floating-point
    <span class="Li">&quot;remainder&quot;</span>.</dd>
  <dt>&quot;HAS_SCALBN&quot;</dt>
  <dd>This symbol, if defined, indicates that the
      <span class="Li">&quot;scalbn&quot;</span> routine is available to
      multiply floating-point number by integral power of radix.</dd>
  <dt>&quot;HAS_SIGNBIT&quot;</dt>
  <dd>This symbol, if defined, indicates that the
      <span class="Li">&quot;signbit&quot;</span> routine is available to check
      if the given number has the sign bit set. This should include correct
      testing of -0.0. This will only be set if the
      <span class="Li">&quot;signbit()&quot;</span> routine is safe to use with
      the NV type used internally in perl. Users should call
      <span class="Li">&quot;Perl_signbit()&quot;</span>, which will be #defined
      to the system's <span class="Li">&quot;signbit()&quot;</span> function or
      macro if this symbol is defined.</dd>
  <dt>&quot;HAS_SQRTL&quot;</dt>
  <dd>This symbol, if defined, indicates that the
      <span class="Li">&quot;sqrtl&quot;</span> routine is available to do long
      double square roots.</dd>
  <dt>&quot;HAS_STRTOD_L&quot;</dt>
  <dd>This symbol, if defined, indicates that the
      <span class="Li">&quot;strtod_l&quot;</span> routine is available to
      convert strings to long doubles.</dd>
  <dt>&quot;HAS_STRTOLD&quot;</dt>
  <dd>This symbol, if defined, indicates that the
      <span class="Li">&quot;strtold&quot;</span> routine is available to
      convert strings to long doubles.</dd>
  <dt>&quot;HAS_STRTOLD_L&quot;</dt>
  <dd>This symbol, if defined, indicates that the
      <span class="Li">&quot;strtold_l&quot;</span> routine is available to
      convert strings to long doubles.</dd>
  <dt>&quot;HAS_TRUNC&quot;</dt>
  <dd>This symbol, if defined, indicates that the
      <span class="Li">&quot;trunc&quot;</span> routine is available to round
      doubles towards zero.</dd>
  <dt>&quot;HAS_UNORDERED&quot;</dt>
  <dd>This symbol, if defined, indicates that the
      <span class="Li">&quot;unordered&quot;</span> routine is available to
      check whether two doubles are
      <span class="Li">&quot;unordered&quot;</span> (effectively: whether either
      of them is NaN)</dd>
  <dt>&quot;I_FENV&quot;</dt>
  <dd>This symbol, if defined, indicates to the C program that it should include
      <i>fenv.h</i> to get the floating point environment definitions.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> #ifdef I_FENV
     #include &lt;fenv.h&gt;
 #endif
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;I_QUADMATH&quot;</dt>
  <dd>This symbol, if defined, indicates that <i>quadmath.h</i> exists and
      should be included.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> #ifdef I_QUADMATH
     #include &lt;quadmath.h&gt;
 #endif
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;LONGDBLINFBYTES&quot;</dt>
  <dd>This symbol, if defined, is a comma-separated list of hexadecimal bytes
      for the long double precision infinity.</dd>
  <dt>&quot;LONGDBLMANTBITS&quot;</dt>
  <dd>This symbol, if defined, tells how many mantissa bits there are in long
      double precision floating point format. Note that this can be
      <span class="Li">&quot;LDBL_MANT_DIG&quot;</span> minus one, since
      <span class="Li">&quot;LDBL_MANT_DIG&quot;</span> can include the
      <span class="Li">&quot;IEEE&quot;</span> 754 implicit bit. The common
      x86-style 80-bit long double does not have an implicit bit.</dd>
  <dt>&quot;LONGDBLNANBYTES&quot;</dt>
  <dd>This symbol, if defined, is a comma-separated list of hexadecimal bytes
      (0xHH) for the long double precision not-a-number.</dd>
  <dt>&quot;LONG_DOUBLEKIND&quot;</dt>
  <dd><span class="Li">&quot;LONG_DOUBLEKIND&quot;</span> will be one of
      <span class="Li">&quot;LONG_DOUBLE_IS_DOUBLE&quot;</span>
      <span class="Li">&quot;LONG_DOUBLE_IS_IEEE_754_128_BIT_LITTLE_ENDIAN&quot;</span>
      <span class="Li">&quot;LONG_DOUBLE_IS_IEEE_754_128_BIT_BIG_ENDIAN&quot;</span>
      <span class="Li">&quot;LONG_DOUBLE_IS_X86_80_BIT_LITTLE_ENDIAN&quot;</span>
      <span class="Li">&quot;LONG_DOUBLE_IS_X86_80_BIT_BIG_ENDIAN&quot;</span>
      <span class="Li">&quot;LONG_DOUBLE_IS_DOUBLEDOUBLE_128_BIT_LE_LE&quot;</span>
      <span class="Li">&quot;LONG_DOUBLE_IS_DOUBLEDOUBLE_128_BIT_BE_BE&quot;</span>
      <span class="Li">&quot;LONG_DOUBLE_IS_DOUBLEDOUBLE_128_BIT_LE_BE&quot;</span>
      <span class="Li">&quot;LONG_DOUBLE_IS_DOUBLEDOUBLE_128_BIT_BE_LE&quot;</span>
      <span class="Li">&quot;LONG_DOUBLE_IS_DOUBLEDOUBLE_128_BIT_LITTLE_ENDIAN&quot;</span>
      <span class="Li">&quot;LONG_DOUBLE_IS_DOUBLEDOUBLE_128_BIT_BIG_ENDIAN&quot;</span>
      <span class="Li">&quot;LONG_DOUBLE_IS_VAX_H_FLOAT&quot;</span>
      <span class="Li">&quot;LONG_DOUBLE_IS_UNKNOWN_FORMAT&quot;</span> It is
      only defined if the system supports long doubles.</dd>
  <dt>&quot;LONG_DOUBLESIZE&quot;</dt>
  <dd>This symbol contains the size of a long double, so that the C preprocessor
      can make decisions based on it. It is only defined if the system supports
      long doubles. Note that this is <span class="Li">&quot;sizeof(long
      double)&quot;</span>, which may include unused bytes.</dd>
  <dt>&quot;LONG_DOUBLE_STYLE_IEEE&quot;</dt>
  <dd>This symbol, if defined, indicates that the long double is any of the
      <span class="Li">&quot;IEEE&quot;</span> 754 style long doubles:
      <span class="Li">&quot;LONG_DOUBLE_STYLE_IEEE_STD&quot;</span>,
      <span class="Li">&quot;LONG_DOUBLE_STYLE_IEEE_EXTENDED&quot;</span>,
      <span class="Li">&quot;LONG_DOUBLE_STYLE_IEEE_DOUBLEDOUBLE&quot;</span>.</dd>
  <dt>&quot;LONG_DOUBLE_STYLE_IEEE_DOUBLEDOUBLE&quot;</dt>
  <dd>This symbol, if defined, indicates that the long double is the 128-bit
      double-double.</dd>
  <dt>&quot;LONG_DOUBLE_STYLE_IEEE_EXTENDED&quot;</dt>
  <dd>This symbol, if defined, indicates that the long double is the 80-bit
      <span class="Li">&quot;IEEE&quot;</span> 754. Note that despite the
      'extended' this is less than the 'std', since this is an extension of the
      double precision.</dd>
  <dt>&quot;LONG_DOUBLE_STYLE_IEEE_STD&quot;</dt>
  <dd>This symbol, if defined, indicates that the long double is the 128-bit
      <span class="Li">&quot;IEEE&quot;</span> 754.</dd>
  <dt>&quot;LONG_DOUBLE_STYLE_VAX&quot;</dt>
  <dd>This symbol, if defined, indicates that the long double is the 128-bit
      <span class="Li">&quot;VAX&quot;</span> format H.</dd>
  <dt>&quot;NVMANTBITS&quot;</dt>
  <dd>This symbol, if defined, tells how many mantissa bits (not including
      implicit bit) there are in a Perl NV. This depends on which floating point
      type was chosen.</dd>
  <dt>&quot;NV_OVERFLOWS_INTEGERS_AT&quot;</dt>
  <dd>This symbol gives the largest integer value that NVs can hold. This value
      + 1.0 cannot be stored accurately. It is expressed as constant floating
      point expression to reduce the chance of decimal/binary conversion issues.
      If it can not be determined, the value 0 is given.</dd>
  <dt>&quot;NV_PRESERVES_UV&quot;</dt>
  <dd>This symbol, if defined, indicates that a variable of type
      <span class="Li">&quot;NVTYPE&quot;</span> can preserve all the bits of a
      variable of type <span class="Li">&quot;UVTYPE&quot;</span>.</dd>
  <dt>&quot;NV_PRESERVES_UV_BITS&quot;</dt>
  <dd>This symbol contains the number of bits a variable of type
      <span class="Li">&quot;NVTYPE&quot;</span> can preserve of a variable of
      type <span class="Li">&quot;UVTYPE&quot;</span>.</dd>
  <dt>&quot;NVSIZE&quot;</dt>
  <dd>This symbol contains the <span class="Li">&quot;sizeof(NV)&quot;</span>.
      Note that some floating point formats have unused bytes. The most notable
      example is the x86* 80-bit extended precision which comes in byte sizes of
      12 and 16 (for 32 and 64 bit platforms, respectively), but which only uses
      10 bytes. Perl compiled with
      <span class="Li">&quot;-Duselongdouble&quot;</span> on x86* is like
    this.</dd>
  <dt>&quot;NVTYPE&quot;</dt>
  <dd>This symbol defines the C type used for Perl's NV.</dd>
  <dt>&quot;NV_ZERO_IS_ALLBITS_ZERO&quot;</dt>
  <dd>This symbol, if defined, indicates that a variable of type
      <span class="Li">&quot;NVTYPE&quot;</span> stores 0.0 in memory as all
      bits zero.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="Formats"><a class="permalink" href="#Formats">Formats</a></h1>
<p class="Pp">These are used for formatting the corresponding type For example,
    instead of saying</p>
<p class="Pp"></p>
<pre> Perl_newSVpvf(pTHX_ &quot;Create an SV with a %d in it\n&quot;, iv);
</pre>
<p class="Pp">use</p>
<p class="Pp"></p>
<pre> Perl_newSVpvf(pTHX_ &quot;Create an SV with a &quot; IVdf &quot; in it\n&quot;, iv);
</pre>
<p class="Pp">This keeps you from having to know if, say an IV, needs to be
    printed as <span class="Li">%d</span>, <span class="Li">%ld</span>, or
    something else.</p>
<dl class="Bl-tag">
  <dt>&quot;IVdf&quot;</dt>
  <dd>This symbol defines the format string used for printing a Perl IV as a
      signed decimal integer.</dd>
  <dt>&quot;NVef&quot;</dt>
  <dd>This symbol defines the format string used for printing a Perl NV using
      <span class="Li">%e</span>-ish floating point format.</dd>
  <dt>&quot;NVff&quot;</dt>
  <dd>This symbol defines the format string used for printing a Perl NV using
      <span class="Li">%f</span>-ish floating point format.</dd>
  <dt>&quot;NVgf&quot;</dt>
  <dd>This symbol defines the format string used for printing a Perl NV using
      <span class="Li">%g</span>-ish floating point format.</dd>
  <dt>&quot;PERL_PRIeldbl&quot;</dt>
  <dd>This symbol, if defined, contains the string used by stdio to format long
      doubles (format 'e') for output.</dd>
  <dt>&quot;PERL_PRIfldbl&quot;</dt>
  <dd>This symbol, if defined, contains the string used by stdio to format long
      doubles (format 'f') for output.</dd>
  <dt>&quot;PERL_PRIgldbl&quot;</dt>
  <dd>This symbol, if defined, contains the string used by stdio to format long
      doubles (format 'g') for output.</dd>
  <dt>&quot;PERL_SCNfldbl&quot;</dt>
  <dd>This symbol, if defined, contains the string used by stdio to format long
      doubles (format 'f') for input.</dd>
  <dt>&quot;PRINTF_FORMAT_NULL_OK&quot;</dt>
  <dd>Allows <span class="Li">&quot;__printf__&quot;</span> format to be null
      when checking printf-style</dd>
  <dt>&quot;UTF8f&quot;</dt>
  <dd>Described in perlguts.</dd>
  <dt>&quot;UTF8fARG&quot;</dt>
  <dd>Described in perlguts.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre>   UTF8fARG(bool is_utf8, Size_t byte_len, char *str)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;UVof&quot;</dt>
  <dd>This symbol defines the format string used for printing a Perl UV as an
      unsigned octal integer.</dd>
  <dt>&quot;UVuf&quot;</dt>
  <dd>This symbol defines the format string used for printing a Perl UV as an
      unsigned decimal integer.</dd>
  <dt>&quot;UVXf&quot;</dt>
  <dd>This symbol defines the format string used for printing a Perl UV as an
      unsigned hexadecimal integer in uppercase
      <span class="Li">&quot;ABCDEF&quot;</span>.</dd>
  <dt>&quot;UVxf&quot;</dt>
  <dd>This symbol defines the format string used for printing a Perl UV as an
      unsigned hexadecimal integer in lowercase abcdef.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="General_Configuration"><a class="permalink" href="#General_Configuration">General
  Configuration</a></h1>
<p class="Pp">This section contains configuration information not otherwise
    found in the more specialized sections of this document. At the end is a
    list of <span class="Li">&quot;#defines&quot;</span> whose name should be
    enough to tell you what they do, and a list of #defines which tell you if
    you need to <span class="Li">&quot;#include&quot;</span> files to get the
    corresponding functionality.</p>
<dl class="Bl-tag">
  <dt>&quot;BYTEORDER&quot;</dt>
  <dd>This symbol holds the hexadecimal constant defined in byteorder, in a UV,
      i.e. 0x1234 or 0x4321 or 0x12345678, etc... If the compiler supports
      cross-compiling or multiple-architecture binaries, use compiler-defined
      macros to determine the byte order.</dd>
  <dt>&quot;CHARBITS&quot;</dt>
  <dd>This symbol contains the size of a char, so that the C preprocessor can
      make decisions based on it.</dd>
  <dt>&quot;DB_VERSION_MAJOR_CFG&quot;</dt>
  <dd>This symbol, if defined, defines the major version number of Berkeley DB
      found in the <i>db.h</i> header when Perl was configured.</dd>
  <dt>&quot;DB_VERSION_MINOR_CFG&quot;</dt>
  <dd>This symbol, if defined, defines the minor version number of Berkeley DB
      found in the <i>db.h</i> header when Perl was configured. For DB version 1
      this is always 0.</dd>
  <dt>&quot;DB_VERSION_PATCH_CFG&quot;</dt>
  <dd>This symbol, if defined, defines the patch version number of Berkeley DB
      found in the <i>db.h</i> header when Perl was configured. For DB version 1
      this is always 0.</dd>
  <dt>&quot;DEFAULT_INC_EXCLUDES_DOT&quot;</dt>
  <dd>This symbol, if defined, removes the legacy default behavior of including
      '.' at the end of @<span class="Li">&quot;INC&quot;</span>.</dd>
  <dt>&quot;DLSYM_NEEDS_UNDERSCORE&quot;</dt>
  <dd>This symbol, if defined, indicates that we need to prepend an underscore
      to the symbol name before calling
      <span class="Li">&quot;dlsym()&quot;</span>. This only makes sense if you
      *have* dlsym, which we will presume is the case if you're using
      <i>dl_dlopen.xs</i>.</dd>
  <dt>&quot;EBCDIC&quot;</dt>
  <dd>This symbol, if defined, indicates that this system uses
      <span class="Li">&quot;EBCDIC&quot;</span> encoding.</dd>
  <dt>&quot;HAS_CSH&quot;</dt>
  <dd>This symbol, if defined, indicates that the C-shell exists.</dd>
  <dt>&quot;HAS_GETHOSTNAME&quot;</dt>
  <dd>This symbol, if defined, indicates that the C program may use the
      <span class="Li">&quot;gethostname()&quot;</span> routine to derive the
      host name. See also <span class="Li">&quot;HAS_UNAME&quot;</span> and
      <span class="Li">&quot;PHOSTNAME&quot;</span>.</dd>
  <dt>&quot;HAS_GNULIBC&quot;</dt>
  <dd>This symbol, if defined, indicates to the C program that the
      <span class="Li">&quot;GNU&quot;</span> C library is being used. A better
      check is to use the <span class="Li">&quot;__GLIBC__&quot;</span> and
      <span class="Li">&quot;__GLIBC_MINOR__&quot;</span> symbols supplied with
      glibc.</dd>
  <dt>&quot;HAS_LGAMMA&quot;</dt>
  <dd>This symbol, if defined, indicates that the
      <span class="Li">&quot;lgamma&quot;</span> routine is available to do the
      log gamma function. See also
      <span class="Li">&quot;HAS_TGAMMA&quot;</span> and
      <span class="Li">&quot;HAS_LGAMMA_R&quot;</span>.</dd>
  <dt>&quot;HAS_LGAMMA_R&quot;</dt>
  <dd>This symbol, if defined, indicates that the
      <span class="Li">&quot;lgamma_r&quot;</span> routine is available to do
      the log gamma function without using the global signgam variable.</dd>
  <dt>&quot;HAS_PRCTL_SET_NAME&quot;</dt>
  <dd>This symbol, if defined, indicates that the prctl routine is available to
      set process title and supports
      <span class="Li">&quot;PR_SET_NAME&quot;</span>.</dd>
  <dt>&quot;HAS_PROCSELFEXE&quot;</dt>
  <dd>This symbol is defined if
      <span class="Li">&quot;PROCSELFEXE_PATH&quot;</span> is a symlink to the
      absolute pathname of the executing program.</dd>
  <dt>&quot;HAS_PSEUDOFORK&quot;</dt>
  <dd>This symbol, if defined, indicates that an emulation of the fork routine
      is available.</dd>
  <dt>&quot;HAS_REGCOMP&quot;</dt>
  <dd>This symbol, if defined, indicates that the
      <span class="Li">&quot;regcomp()&quot;</span> routine is available to do
      some regular pattern matching (usually on
      <span class="Li">&quot;POSIX&quot;</span>.2 conforming systems).</dd>
  <dt>&quot;HAS_SETPGID&quot;</dt>
  <dd>This symbol, if defined, indicates that the
      <span class="Li">&quot;setpgid(pid, gpid)&quot;</span> routine is
      available to set process group ID.</dd>
  <dt>&quot;HAS_SIGSETJMP&quot;</dt>
  <dd>This variable indicates to the C program that the
      <span class="Li">&quot;sigsetjmp()&quot;</span> routine is available to
      save the calling process's registers and stack environment for later use
      by <span class="Li">&quot;siglongjmp()&quot;</span>, and to optionally
      save the process's signal mask. See
      <span class="Li">&quot;Sigjmp_buf&quot;</span>,
      <span class="Li">&quot;Sigsetjmp&quot;</span>, and
      <span class="Li">&quot;Siglongjmp&quot;</span>.</dd>
  <dt>&quot;HAS_STRUCT_CMSGHDR&quot;</dt>
  <dd>This symbol, if defined, indicates that the <span class="Li">&quot;struct
      cmsghdr&quot;</span> is supported.</dd>
  <dt>&quot;HAS_STRUCT_MSGHDR&quot;</dt>
  <dd>This symbol, if defined, indicates that the <span class="Li">&quot;struct
      msghdr&quot;</span> is supported.</dd>
  <dt>&quot;HAS_TGAMMA&quot;</dt>
  <dd>This symbol, if defined, indicates that the
      <span class="Li">&quot;tgamma&quot;</span> routine is available to do the
      gamma function. See also
    <span class="Li">&quot;HAS_LGAMMA&quot;</span>.</dd>
  <dt>&quot;HAS_UNAME&quot;</dt>
  <dd>This symbol, if defined, indicates that the C program may use the
      <span class="Li">&quot;uname()&quot;</span> routine to derive the host
      name. See also <span class="Li">&quot;HAS_GETHOSTNAME&quot;</span> and
      <span class="Li">&quot;PHOSTNAME&quot;</span>.</dd>
  <dt>&quot;HAS_UNION_SEMUN&quot;</dt>
  <dd>This symbol, if defined, indicates that the <span class="Li">&quot;union
      semun&quot;</span> is defined by including <i>sys/sem.h</i>. If not, the
      user code probably needs to define it as:
    <p class="Pp"></p>
    <pre> union semun {
 int val;
 struct semid_ds *buf;
 unsigned short *array;
 }
    </pre>
  </dd>
  <dt>&quot;I_DIRENT&quot;</dt>
  <dd>This symbol, if defined, indicates to the C program that it should include
      <i>dirent.h</i>. Using this symbol also triggers the definition of the
      <span class="Li">&quot;Direntry_t&quot;</span> define which ends up being
      '<span class="Li">&quot;struct dirent&quot;</span>' or
      '<span class="Li">&quot;struct direct&quot;</span>' depending on the
      availability of <i>dirent.h</i>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> #ifdef I_DIRENT
     #include &lt;dirent.h&gt;
 #endif
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;I_POLL&quot;</dt>
  <dd>This symbol, if defined, indicates that <i>poll.h</i> exists and should be
      included. (see also <span class="Li">&quot;HAS_POLL&quot;</span>)</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> #ifdef I_POLL
     #include &lt;poll.h&gt;
 #endif
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;I_SYS_RESOURCE&quot;</dt>
  <dd>This symbol, if defined, indicates to the C program that it should include
      <i>sys/resource.h</i>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> #ifdef I_SYS_RESOURCE
     #include &lt;sys_resource.h&gt;
 #endif
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;LIBM_LIB_VERSION&quot;</dt>
  <dd>This symbol, if defined, indicates that libm exports
      <span class="Li">&quot;_LIB_VERSION&quot;</span> and that <i>math.h</i>
      defines the enum to manipulate it.</dd>
  <dt>&quot;NEED_VA_COPY&quot;</dt>
  <dd>This symbol, if defined, indicates that the system stores the variable
      argument list datatype, <span class="Li">&quot;va_list&quot;</span>, in a
      format that cannot be copied by simple assignment, so that some other
      means must be used when copying is required. As such systems vary in their
      provision (or non-provision) of copying mechanisms, <i>handy.h</i> defines
      a platform- independent macro, <span class="Li">&quot;Perl_va_copy(src,
      dst)&quot;</span>, to do the job.</dd>
  <dt>&quot;OSNAME&quot;</dt>
  <dd>This symbol contains the name of the operating system, as determined by
      Configure. You shouldn't rely on it too much; the specific feature tests
      from Configure are generally more reliable.</dd>
  <dt>&quot;OSVERS&quot;</dt>
  <dd>This symbol contains the version of the operating system, as determined by
      Configure. You shouldn't rely on it too much; the specific feature tests
      from Configure are generally more reliable.</dd>
  <dt>&quot;PHOSTNAME&quot;</dt>
  <dd>This symbol, if defined, indicates the command to feed to the
      <span class="Li">&quot;popen()&quot;</span> routine to derive the host
      name. See also <span class="Li">&quot;HAS_GETHOSTNAME&quot;</span> and
      <span class="Li">&quot;HAS_UNAME&quot;</span>. Note that the command uses
      a fully qualified path, so that it is safe even if used by a process with
      super-user privileges.</dd>
  <dt>&quot;PROCSELFEXE_PATH&quot;</dt>
  <dd>If <span class="Li">&quot;HAS_PROCSELFEXE&quot;</span> is defined this
      symbol is the filename of the symbolic link pointing to the absolute
      pathname of the executing program.</dd>
  <dt>&quot;PTRSIZE&quot;</dt>
  <dd>This symbol contains the size of a pointer, so that the C preprocessor can
      make decisions based on it. It will be <span class="Li">&quot;sizeof(void
      *)&quot;</span> if the compiler supports (void *); otherwise it will be
      <span class="Li">&quot;sizeof(char *)&quot;</span>.</dd>
  <dt>&quot;RANDBITS&quot;</dt>
  <dd>This symbol indicates how many bits are produced by the function used to
      generate normalized random numbers. Values include 15, 16, 31, and
    48.</dd>
  <dt>&quot;SELECT_MIN_BITS&quot;</dt>
  <dd>This symbol holds the minimum number of bits operated by select. That is,
      if you do <span class="Li">&quot;select(n, ...)&quot;</span>, how many
      bits at least will be cleared in the masks if some activity is detected.
      Usually this is either n or
      32*<span class="Li">&quot;ceil(n/32)&quot;</span>, especially many
      little-endians do the latter. This is only useful if you have
      <span class="Li">&quot;select()&quot;</span>, naturally.</dd>
  <dt>&quot;SETUID_SCRIPTS_ARE_SECURE_NOW&quot;</dt>
  <dd>This symbol, if defined, indicates that the bug that prevents setuid
      scripts from being secure is not present in this kernel.</dd>
  <dt>&quot;UPDATESLIB&quot;</dt>
  <dd>This is the path to the Updates directory (which comes before the system
      perl directory in @<span class="Li">&quot;INC&quot;</span>.</dd>
</dl>
<section class="Ss">
<h2 class="Ss" id="List_of_capability__HAS_"><a class="permalink" href="#List_of_capability__HAS_">List
  of capability &quot;HAS_<span class="Li"><i>foo</i></span>&quot;
  symbols</a></h2>
<p class="Pp">This is a list of those symbols that dont appear elsewhere in ths
    document that indicate if the current platform has a certain capability.
    Their names all begin with <span class="Li">&quot;HAS_&quot;</span>. Only
    those symbols whose capability is directly derived from the name are listed
    here. All others have their meaning expanded out elsewhere in this document.
    This (relatively) compact list is because we think that the expansion would
    add little or no value and take up a lot of space (because there are so
    many). If you think certain ones should be expanded, send email to
    perl5-porters@perl.org &lt;mailto:perl5-porters@perl.org&gt;.</p>
<p class="Pp">Each symbol here will be
    <span class="Li">&quot;#define&quot;</span>d if and only if the platform has
    the capability. If you need more detail, see the corresponding entry in
    <i>config.h</i>. For convenience, the list is split so that the ones that
    indicate there is a reentrant version of a capability are listed
  separately</p>
<p class="Pp"><span class="Li">&quot;HAS_ACCEPT4&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_ACCESS&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_ACCESSX&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_ACOSH&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_AINTL&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_ALARM&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_ASINH&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_ATANH&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_ATOLL&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_CBRT&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_CHOWN&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_CHROOT&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_CHSIZE&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_CLEARENV&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_COPYSIGN&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_COPYSIGNL&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_CRYPT&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_CTERMID&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_CUSERID&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_DIRFD&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_DLADDR&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_DLERROR&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_EACCESS&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_ENDHOSTENT&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_ENDNETENT&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_ENDPROTOENT&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_ENDSERVENT&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_ERF&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_ERFC&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_EXP2&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_EXPM1&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_FCHMOD&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_FCHMODAT&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_FCHOWN&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_FDIM&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_FD_SET&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_FEGETROUND&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_FGETPOS&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_FLOCK&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_FMA&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_FMAX&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_FMIN&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_FORK&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_FSEEKO&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_FSETPOS&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_FSYNC&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_FTELLO&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_GAI_STRERROR&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_GETADDRINFO&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_GETCWD&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_GETESPWNAM&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_GETGROUPS&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_GETHOSTBYADDR&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_GETHOSTBYNAME&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_GETHOSTENT&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_GETLOGIN&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_GETNAMEINFO&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_GETNETBYADDR&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_GETNETBYNAME&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_GETNETENT&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_GETPAGESIZE&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_GETPGID&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_GETPGRP&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_GETPGRP2&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_GETPPID&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_GETPRIORITY&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_GETPROTOBYNAME&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_GETPROTOBYNUMBER&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_GETPROTOENT&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_GETPRPWNAM&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_GETSERVBYNAME&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_GETSERVBYPORT&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_GETSERVENT&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_GETSPNAM&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_HTONL&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_HTONS&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_HYPOT&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_ILOGBL&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_INETNTOP&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_INETPTON&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_INET_ATON&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_IPV6_MREQ&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_IPV6_MREQ_SOURCE&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_IP_MREQ&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_IP_MREQ_SOURCE&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_ISASCII&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_ISBLANK&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_ISLESS&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_KILLPG&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_LCHOWN&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_LINK&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_LINKAT&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_LLROUND&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_LOCKF&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_LOG1P&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_LOG2&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_LOGB&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_LROUND&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_LSTAT&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_MADVISE&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_MBLEN&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_MBRLEN&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_MBRTOWC&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_MBSTOWCS&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_MBTOWC&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_MEMMEM&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_MEMRCHR&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_MKDTEMP&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_MKFIFO&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_MKOSTEMP&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_MKSTEMP&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_MKSTEMPS&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_MMAP&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_MPROTECT&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_MSG&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_MSYNC&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_MUNMAP&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_NEARBYINT&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_NEXTAFTER&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_NICE&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_NTOHL&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_NTOHS&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_PATHCONF&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_PAUSE&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_PHOSTNAME&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_PIPE&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_PIPE2&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_PRCTL&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_PTRDIFF_T&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_READLINK&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_READV&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_RECVMSG&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_REMQUO&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_RENAME&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_RENAMEAT&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_RINT&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_ROUND&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_SCALBNL&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_SEM&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_SENDMSG&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_SETEGID&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_SETEUID&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_SETGROUPS&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_SETHOSTENT&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_SETLINEBUF&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_SETNETENT&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_SETPGRP&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_SETPGRP2&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_SETPRIORITY&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_SETPROCTITLE&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_SETPROTOENT&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_SETREGID&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_SETRESGID&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_SETRESUID&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_SETREUID&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_SETRGID&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_SETRUID&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_SETSERVENT&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_SETSID&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_SHM&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_SIGACTION&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_SIGPROCMASK&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_SIN6_SCOPE_ID&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_SNPRINTF&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_STAT&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_STRCOLL&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_STRERROR_L&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_STRLCAT&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_STRLCPY&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_STRNLEN&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_STRTOD&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_STRTOL&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_STRTOLL&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_STRTOQ&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_STRTOUL&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_STRTOULL&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_STRTOUQ&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_STRXFRM&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_SYMLINK&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_SYSCALL&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_SYSCONF&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_SYSTEM&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_SYS_ERRLIST&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_TCGETPGRP&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_TCSETPGRP&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_TOWLOWER&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_TOWUPPER&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_TRUNCATE&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_TRUNCL&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_UALARM&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_UMASK&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_UNLINKAT&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_UNSETENV&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_VFORK&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_VSNPRINTF&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_WAIT4&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_WAITPID&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_WCRTOMB&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_WCSCMP&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_WCSTOMBS&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_WCSXFRM&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_WCTOMB&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_WRITEV&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS__FWALK&quot;</span></p>
<p class="Pp">And, the reentrant capabilities:</p>
<p class="Pp"><span class="Li">&quot;HAS_CRYPT_R&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_CTERMID_R&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_DRAND48_R&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_ENDHOSTENT_R&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_ENDNETENT_R&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_ENDPROTOENT_R&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_ENDSERVENT_R&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_GETGRGID_R&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_GETGRNAM_R&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_GETHOSTBYADDR_R&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_GETHOSTBYNAME_R&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_GETHOSTENT_R&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_GETLOGIN_R&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_GETNETBYADDR_R&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_GETNETBYNAME_R&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_GETNETENT_R&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_GETPROTOBYNAME_R&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_GETPROTOBYNUMBER_R&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_GETPROTOENT_R&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_GETPWNAM_R&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_GETPWUID_R&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_GETSERVBYNAME_R&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_GETSERVBYPORT_R&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_GETSERVENT_R&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_GETSPNAM_R&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_RANDOM_R&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_READDIR_R&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_SETHOSTENT_R&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_SETNETENT_R&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_SETPROTOENT_R&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_SETSERVENT_R&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_SRAND48_R&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_SRANDOM_R&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_STRERROR_R&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_TMPNAM_R&quot;</span>,&#x00A0;
    <span class="Li">&quot;HAS_TTYNAME_R&quot;</span></p>
<p class="Pp">Example usage:</p>
<p class="Pp"></p>
<pre> #ifdef HAS_STRNLEN
   use strnlen()
 #else
   use an alternative implementation
 #endif
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="List_of___include__needed_symbols"><a class="permalink" href="#List_of___include__needed_symbols">List
  of &quot;#include&quot; needed symbols</a></h2>
<p class="Pp">This list contains symbols that indicate if certain
    <span class="Li">&quot;#include&quot;</span> files are present on the
    platform. If your code accesses the functionality that one of these is for,
    you will need to <span class="Li">&quot;#include&quot;</span> it if the
    symbol on this list is <span class="Li">&quot;#define&quot;</span>d. For
    more detail, see the corresponding entry in <i>config.h</i>.</p>
<p class="Pp"><span class="Li">&quot;I_ARPA_INET&quot;</span>,&#x00A0;
    <span class="Li">&quot;I_BFD&quot;</span>,&#x00A0;
    <span class="Li">&quot;I_CRYPT&quot;</span>,&#x00A0;
    <span class="Li">&quot;I_DBM&quot;</span>,&#x00A0;
    <span class="Li">&quot;I_DLFCN&quot;</span>,&#x00A0;
    <span class="Li">&quot;I_EXECINFO&quot;</span>,&#x00A0;
    <span class="Li">&quot;I_FP&quot;</span>,&#x00A0;
    <span class="Li">&quot;I_FP_CLASS&quot;</span>,&#x00A0;
    <span class="Li">&quot;I_GDBM&quot;</span>,&#x00A0;
    <span class="Li">&quot;I_GDBMNDBM&quot;</span>,&#x00A0;
    <span class="Li">&quot;I_GDBM_NDBM&quot;</span>,&#x00A0;
    <span class="Li">&quot;I_GRP&quot;</span>,&#x00A0;
    <span class="Li">&quot;I_IEEEFP&quot;</span>,&#x00A0;
    <span class="Li">&quot;I_INTTYPES&quot;</span>,&#x00A0;
    <span class="Li">&quot;I_LIBUTIL&quot;</span>,&#x00A0;
    <span class="Li">&quot;I_MNTENT&quot;</span>,&#x00A0;
    <span class="Li">&quot;I_NDBM&quot;</span>,&#x00A0;
    <span class="Li">&quot;I_NETDB&quot;</span>,&#x00A0;
    <span class="Li">&quot;I_NETINET_IN&quot;</span>,&#x00A0;
    <span class="Li">&quot;I_NETINET_TCP&quot;</span>,&#x00A0;
    <span class="Li">&quot;I_NET_ERRNO&quot;</span>,&#x00A0;
    <span class="Li">&quot;I_PROT&quot;</span>,&#x00A0;
    <span class="Li">&quot;I_PWD&quot;</span>,&#x00A0;
    <span class="Li">&quot;I_RPCSVC_DBM&quot;</span>,&#x00A0;
    <span class="Li">&quot;I_SGTTY&quot;</span>,&#x00A0;
    <span class="Li">&quot;I_SHADOW&quot;</span>,&#x00A0;
    <span class="Li">&quot;I_STDBOOL&quot;</span>,&#x00A0;
    <span class="Li">&quot;I_STDINT&quot;</span>,&#x00A0;
    <span class="Li">&quot;I_SUNMATH&quot;</span>,&#x00A0;
    <span class="Li">&quot;I_SYSLOG&quot;</span>,&#x00A0;
    <span class="Li">&quot;I_SYSMODE&quot;</span>,&#x00A0;
    <span class="Li">&quot;I_SYSUIO&quot;</span>,&#x00A0;
    <span class="Li">&quot;I_SYSUTSNAME&quot;</span>,&#x00A0;
    <span class="Li">&quot;I_SYS_ACCESS&quot;</span>,&#x00A0;
    <span class="Li">&quot;I_SYS_IOCTL&quot;</span>,&#x00A0;
    <span class="Li">&quot;I_SYS_MOUNT&quot;</span>,&#x00A0;
    <span class="Li">&quot;I_SYS_PARAM&quot;</span>,&#x00A0;
    <span class="Li">&quot;I_SYS_POLL&quot;</span>,&#x00A0;
    <span class="Li">&quot;I_SYS_SECURITY&quot;</span>,&#x00A0;
    <span class="Li">&quot;I_SYS_SELECT&quot;</span>,&#x00A0;
    <span class="Li">&quot;I_SYS_STAT&quot;</span>,&#x00A0;
    <span class="Li">&quot;I_SYS_STATVFS&quot;</span>,&#x00A0;
    <span class="Li">&quot;I_SYS_TIME&quot;</span>,&#x00A0;
    <span class="Li">&quot;I_SYS_TIMES&quot;</span>,&#x00A0;
    <span class="Li">&quot;I_SYS_TIME_KERNEL&quot;</span>,&#x00A0;
    <span class="Li">&quot;I_SYS_TYPES&quot;</span>,&#x00A0;
    <span class="Li">&quot;I_SYS_UN&quot;</span>,&#x00A0;
    <span class="Li">&quot;I_SYS_VFS&quot;</span>,&#x00A0;
    <span class="Li">&quot;I_SYS_WAIT&quot;</span>,&#x00A0;
    <span class="Li">&quot;I_TERMIO&quot;</span>,&#x00A0;
    <span class="Li">&quot;I_TERMIOS&quot;</span>,&#x00A0;
    <span class="Li">&quot;I_UNISTD&quot;</span>,&#x00A0;
    <span class="Li">&quot;I_USTAT&quot;</span>,&#x00A0;
    <span class="Li">&quot;I_VFORK&quot;</span>,&#x00A0;
    <span class="Li">&quot;I_WCHAR&quot;</span>,&#x00A0;
    <span class="Li">&quot;I_WCTYPE&quot;</span></p>
<p class="Pp">Example usage:</p>
<p class="Pp"></p>
<pre> #ifdef I_WCHAR
   #include &lt;wchar.h&gt;
 #endif
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="Global_Variables"><a class="permalink" href="#Global_Variables">Global
  Variables</a></h1>
<p class="Pp">These variables are global to an entire process. They are shared
    between all interpreters and all threads in a process. Any variables not
    documented here may be changed or removed without notice, so don't use them!
    If you feel you really do need to use an unlisted variable, first send email
    to perl5-porters@perl.org &lt;mailto:perl5-porters@perl.org&gt;. It may be
    that someone there will point out a way to accomplish what you need without
    using an internal variable. But if not, you should get a go-ahead to
    document and then use the variable.</p>
<dl class="Bl-tag">
  <dt>&quot;PL_check&quot;</dt>
  <dd>Array, indexed by opcode, of functions that will be called for the
      &quot;check&quot; phase of optree building during compilation of Perl
      code. For most (but not all) types of op, once the op has been initially
      built and populated with child ops it will be filtered through the check
      function referenced by the appropriate element of this array. The new op
      is passed in as the sole argument to the check function, and the check
      function returns the completed op. The check function may (as the name
      suggests) check the op for validity and signal errors. It may also
      initialise or modify parts of the ops, or perform more radical surgery
      such as adding or removing child ops, or even throw the op away and return
      a different op in its place.
    <p class="Pp">This array of function pointers is a convenient place to hook
        into the compilation process. An XS module can put its own custom check
        function in place of any of the standard ones, to influence the
        compilation of a particular type of op. However, a custom check function
        must never fully replace a standard check function (or even a custom
        check function from another module). A module modifying checking must
        instead <b>wrap</b> the preexisting check function. A custom check
        function must be selective about when to apply its custom behaviour. In
        the usual case where it decides not to do anything special with an op,
        it must chain the preexisting op function. Check functions are thus
        linked in a chain, with the core's base checker at the end.</p>
    <p class="Pp">For thread safety, modules should not write directly to this
        array. Instead, use the function &quot;wrap_op_checker&quot;.</p>
  </dd>
  <dt>&quot;PL_keyword_plugin&quot;</dt>
  <dd>NOTE: <span class="Li">&quot;PL_keyword_plugin&quot;</span> is
      <b>experimental</b> and may change or be removed without notice.
    <p class="Pp">Function pointer, pointing at a function used to handle
        extended keywords. The function should be declared as</p>
    <p class="Pp"></p>
    <pre>        int keyword_plugin_function(pTHX_
                char *keyword_ptr, STRLEN keyword_len,
                OP **op_ptr)
    </pre>
    <p class="Pp">The function is called from the tokeniser, whenever a possible
        keyword is seen. <span class="Li">&quot;keyword_ptr&quot;</span> points
        at the word in the parser's input buffer, and
        <span class="Li">&quot;keyword_len&quot;</span> gives its length; it is
        not null-terminated. The function is expected to examine the word, and
        possibly other state such as %^H, to decide whether it wants to handle
        it as an extended keyword. If it does not, the function should return
        <span class="Li">&quot;KEYWORD_PLUGIN_DECLINE&quot;</span>, and the
        normal parser process will continue.</p>
    <p class="Pp">If the function wants to handle the keyword, it first must
        parse anything following the keyword that is part of the syntax
        introduced by the keyword. See &quot;Lexer interface&quot; for
      details.</p>
    <p class="Pp">When a keyword is being handled, the plugin function must
        build a tree of <span class="Li">&quot;OP&quot;</span> structures,
        representing the code that was parsed. The root of the tree must be
        stored in <span class="Li">*op_ptr</span>. The function then returns a
        constant indicating the syntactic role of the construct that it has
        parsed: <span class="Li">&quot;KEYWORD_PLUGIN_STMT&quot;</span> if it is
        a complete statement, or
        <span class="Li">&quot;KEYWORD_PLUGIN_EXPR&quot;</span> if it is an
        expression. Note that a statement construct cannot be used inside an
        expression (except via <span class="Li">&quot;do BLOCK&quot;</span> and
        similar), and an expression is not a complete statement (it requires at
        least a terminating semicolon).</p>
    <p class="Pp">When a keyword is handled, the plugin function may also have
        (compile-time) side effects. It may modify
        <span class="Li">&quot;%^H&quot;</span>, define functions, and so on.
        Typically, if side effects are the main purpose of a handler, it does
        not wish to generate any ops to be included in the normal compilation.
        In this case it is still required to supply an op tree, but it suffices
        to generate a single null op.</p>
    <p class="Pp">That's how the <span class="Li">*PL_keyword_plugin</span>
        function needs to behave overall. Conventionally, however, one does not
        completely replace the existing handler function. Instead, take a copy
        of <span class="Li">&quot;PL_keyword_plugin&quot;</span> before
        assigning your own function pointer to it. Your handler function should
        look for keywords that it is interested in and handle those. Where it is
        not interested, it should call the saved plugin function, passing on the
        arguments it received. Thus
        <span class="Li">&quot;PL_keyword_plugin&quot;</span> actually points at
        a chain of handler functions, all of which have an opportunity to handle
        keywords, and only the last function in the chain (built into the Perl
        core) will normally return
        <span class="Li">&quot;KEYWORD_PLUGIN_DECLINE&quot;</span>.</p>
    <p class="Pp">For thread safety, modules should not set this variable
        directly. Instead, use the function &quot;wrap_keyword_plugin&quot;.</p>
  </dd>
  <dt>&quot;PL_phase&quot;</dt>
  <dd>A value that indicates the current Perl interpreter's phase. Possible
      values include <span class="Li">&quot;PERL_PHASE_CONSTRUCT&quot;</span>,
      <span class="Li">&quot;PERL_PHASE_START&quot;</span>,
      <span class="Li">&quot;PERL_PHASE_CHECK&quot;</span>,
      <span class="Li">&quot;PERL_PHASE_INIT&quot;</span>,
      <span class="Li">&quot;PERL_PHASE_RUN&quot;</span>,
      <span class="Li">&quot;PERL_PHASE_END&quot;</span>, and
      <span class="Li">&quot;PERL_PHASE_DESTRUCT&quot;</span>.
    <p class="Pp">For example, the following determines whether the interpreter
        is in global destruction:</p>
    <p class="Pp"></p>
    <pre>    if (PL_phase == PERL_PHASE_DESTRUCT) {
        // we are in global destruction
    }
    </pre>
    <p class="Pp"><span class="Li">&quot;PL_phase&quot;</span> was introduced in
        Perl 5.14; in prior perls you can use
        <span class="Li">&quot;PL_dirty&quot;</span> (boolean) to determine
        whether the interpreter is in global destruction. (Use of
        <span class="Li">&quot;PL_dirty&quot;</span> is discouraged since
      5.14.)</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> enum perl_phase  PL_phase
</pre>
</div>
<div class="Bd-indent"></div>
</section>
<section class="Sh">
<h1 class="Sh" id="GV_Handling"><a class="permalink" href="#GV_Handling">GV
  Handling</a></h1>
<p class="Pp">A GV is a structure which corresponds to to a Perl typeglob, ie
    *foo. It is a structure that holds a pointer to a scalar, an array, a hash
    etc, corresponding to <span class="Li">$foo</span>,
    <span class="Li">@foo</span>, <span class="Li">%foo</span>.</p>
<p class="Pp">GVs are usually found as values in stashes (symbol table hashes)
    where Perl stores its global variables.</p>
<dl class="Bl-tag">
  <dt>&quot;gv_autoload4&quot;</dt>
  <dd>Equivalent to <span class="Li">&quot;gv_autoload_pvn&quot;</span>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> GV*  gv_autoload4(HV* stash, const char* name, STRLEN len,
                   I32 method)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;GvAV&quot;</dt>
  <dd>Return the AV from the GV.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> AV*  GvAV(GV* gv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;gv_const_sv&quot;</dt>
  <dd>If <span class="Li">&quot;gv&quot;</span> is a typeglob whose subroutine
      entry is a constant sub eligible for inlining, or
      <span class="Li">&quot;gv&quot;</span> is a placeholder reference that
      would be promoted to such a typeglob, then returns the value returned by
      the sub. Otherwise, returns <span class="Li">&quot;NULL&quot;</span>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> SV*  gv_const_sv(GV* gv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;GvCV&quot;</dt>
  <dd>Return the CV from the GV.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> CV*  GvCV(GV* gv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;gv_fetchfile&quot;</dt>
  <dd></dd>
  <dt>&quot;gv_fetchfile_flags&quot;</dt>
  <dd>These return the debugger glob for the file (compiled by Perl) whose name
      is given by the <span class="Li">&quot;name&quot;</span> parameter.
    <p class="Pp">There are currently exactly two differences between these
        functions.</p>
    <p class="Pp">The <span class="Li">&quot;name&quot;</span> parameter to
        <span class="Li">&quot;gv_fetchfile&quot;</span> is a C string, meaning
        it is <span class="Li">&quot;NUL&quot;</span>-terminated; whereas the
        <span class="Li">&quot;name&quot;</span> parameter to
        <span class="Li">&quot;gv_fetchfile_flags&quot;</span> is a Perl string,
        whose length (in bytes) is passed in via the
        <span class="Li">&quot;namelen&quot;</span> parameter This means the
        name may contain embedded <span class="Li">&quot;NUL&quot;</span>
        characters. <span class="Li">&quot;namelen&quot;</span> doesn't exist in
        plain <span class="Li">&quot;gv_fetchfile&quot;</span>).</p>
    <p class="Pp">The other difference is that
        <span class="Li">&quot;gv_fetchfile_flags&quot;</span> has an extra
        <span class="Li">&quot;flags&quot;</span> parameter, which is currently
        completely ignored, but allows for possible future extensions.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> GV*  gv_fetchfile      (const char* name)
 GV*  gv_fetchfile_flags(const char *const name, const STRLEN len,
                         const U32 flags)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;gv_fetchmeth&quot;</dt>
  <dd>Like &quot;gv_fetchmeth_pvn&quot;, but lacks a flags parameter.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> GV*  gv_fetchmeth(HV* stash, const char* name, STRLEN len,
                   I32 level)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;gv_fetchmethod&quot;</dt>
  <dd>See &quot;gv_fetchmethod_autoload&quot;.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> GV*  gv_fetchmethod(HV* stash, const char* name)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;gv_fetchmethod_autoload&quot;</dt>
  <dd>Returns the glob which contains the subroutine to call to invoke the
      method on the <span class="Li">&quot;stash&quot;</span>. In fact in the
      presence of autoloading this may be the glob for &quot;AUTOLOAD&quot;. In
      this case the corresponding variable <span class="Li">$AUTOLOAD</span> is
      already setup.
    <p class="Pp">The third parameter of
        <span class="Li">&quot;gv_fetchmethod_autoload&quot;</span> determines
        whether AUTOLOAD lookup is performed if the given method is not present:
        non-zero means yes, look for AUTOLOAD; zero means no, don't look for
        AUTOLOAD. Calling <span class="Li">&quot;gv_fetchmethod&quot;</span> is
        equivalent to calling
        <span class="Li">&quot;gv_fetchmethod_autoload&quot;</span> with a
        non-zero <span class="Li">&quot;autoload&quot;</span> parameter.</p>
    <p class="Pp">These functions grant
        <span class="Li">&quot;SUPER&quot;</span> token as a prefix of the
        method name. Note that if you want to keep the returned glob for a long
        time, you need to check for it being &quot;AUTOLOAD&quot;, since at the
        later time the call may load a different subroutine due to
        <span class="Li">$AUTOLOAD</span> changing its value. Use the glob
        created as a side effect to do this.</p>
    <p class="Pp">These functions have the same side-effects as
        <span class="Li">&quot;gv_fetchmeth&quot;</span> with
        <span class="Li">&quot;level==0&quot;</span>. The warning against
        passing the GV returned by
        <span class="Li">&quot;gv_fetchmeth&quot;</span> to
        <span class="Li">&quot;call_sv&quot;</span> applies equally to these
        functions.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> GV*  gv_fetchmethod_autoload(HV* stash, const char* name,
                              I32 autoload)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;gv_fetchmeth_autoload&quot;</dt>
  <dd>This is the old form of &quot;gv_fetchmeth_pvn_autoload&quot;, which has
      no flags parameter.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> GV*  gv_fetchmeth_autoload(HV* stash, const char* name,
                            STRLEN len, I32 level)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;gv_fetchmeth_pv&quot;</dt>
  <dd>Exactly like &quot;gv_fetchmeth_pvn&quot;, but takes a nul-terminated
      string instead of a string/length pair.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> GV*  gv_fetchmeth_pv(HV* stash, const char* name, I32 level,
                      U32 flags)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;gv_fetchmeth_pvn&quot;</dt>
  <dd>Returns the glob with the given <span class="Li">&quot;name&quot;</span>
      and a defined subroutine or <span class="Li">&quot;NULL&quot;</span>. The
      glob lives in the given <span class="Li">&quot;stash&quot;</span>, or in
      the stashes accessible via <span class="Li">@ISA</span> and
      <span class="Li">&quot;UNIVERSAL::&quot;</span>.
    <p class="Pp">The argument <span class="Li">&quot;level&quot;</span> should
        be either 0 or -1. If <span class="Li">&quot;level==0&quot;</span>, as a
        side-effect creates a glob with the given
        <span class="Li">&quot;name&quot;</span> in the given
        <span class="Li">&quot;stash&quot;</span> which in the case of success
        contains an alias for the subroutine, and sets up caching info for this
        glob.</p>
    <p class="Pp">The only significant values for
        <span class="Li">&quot;flags&quot;</span> are
        <span class="Li">&quot;GV_SUPER&quot;</span>,
        <span class="Li">&quot;GV_NOUNIVERSAL&quot;</span>, and
        <span class="Li">&quot;SVf_UTF8&quot;</span>.</p>
    <p class="Pp"><span class="Li">&quot;GV_SUPER&quot;</span> indicates that we
        want to look up the method in the superclasses of the
        <span class="Li">&quot;stash&quot;</span>.</p>
    <p class="Pp"><span class="Li">&quot;GV_NOUNIVERSAL&quot;</span> indicates
        that we do not want to look up the method in the stash accessible by
        <span class="Li">&quot;UNIVERSAL::&quot;</span>.</p>
    <p class="Pp">The GV returned from
        <span class="Li">&quot;gv_fetchmeth&quot;</span> may be a method cache
        entry, which is not visible to Perl code. So when calling
        <span class="Li">&quot;call_sv&quot;</span>, you should not use the GV
        directly; instead, you should use the method's CV, which can be obtained
        from the GV with the <span class="Li">&quot;GvCV&quot;</span> macro.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> GV*  gv_fetchmeth_pvn(HV* stash, const char* name, STRLEN len,
                       I32 level, U32 flags)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;gv_fetchmeth_pvn_autoload&quot;</dt>
  <dd>Same as <span class="Li">&quot;gv_fetchmeth_pvn()&quot;</span>, but looks
      for autoloaded subroutines too. Returns a glob for the subroutine.
    <p class="Pp">For an autoloaded subroutine without a GV, will create a GV
        even if <span class="Li">&quot;level &lt; 0&quot;</span>. For an
        autoloaded subroutine without a stub,
        <span class="Li">&quot;GvCV()&quot;</span> of the result may be
      zero.</p>
    <p class="Pp">Currently, the only significant value for
        <span class="Li">&quot;flags&quot;</span> is
        <span class="Li">&quot;SVf_UTF8&quot;</span>.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> GV*  gv_fetchmeth_pvn_autoload(HV* stash, const char* name,
                                STRLEN len, I32 level, U32 flags)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;gv_fetchmeth_pv_autoload&quot;</dt>
  <dd>Exactly like &quot;gv_fetchmeth_pvn_autoload&quot;, but takes a
      nul-terminated string instead of a string/length pair.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> GV*  gv_fetchmeth_pv_autoload(HV* stash, const char* name,
                               I32 level, U32 flags)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;gv_fetchmeth_sv&quot;</dt>
  <dd>Exactly like &quot;gv_fetchmeth_pvn&quot;, but takes the name string in
      the form of an SV instead of a string/length pair.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> GV*  gv_fetchmeth_sv(HV* stash, SV* namesv, I32 level, U32 flags)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;gv_fetchmeth_sv_autoload&quot;</dt>
  <dd>Exactly like &quot;gv_fetchmeth_pvn_autoload&quot;, but takes the name
      string in the form of an SV instead of a string/length pair.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> GV*  gv_fetchmeth_sv_autoload(HV* stash, SV* namesv, I32 level,
                               U32 flags)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;gv_fetchpv&quot;</dt>
  <dd></dd>
  <dt>&quot;gv_fetchpvn&quot;</dt>
  <dd></dd>
  <dt>&quot;gv_fetchpvn_flags&quot;</dt>
  <dd></dd>
  <dt>&quot;gv_fetchpvs&quot;</dt>
  <dd></dd>
  <dt>&quot;gv_fetchsv&quot;</dt>
  <dd></dd>
  <dt>&quot;gv_fetchsv_nomg&quot;</dt>
  <dd>These all return the GV of type
      <span class="Li">&quot;sv_type&quot;</span> whose name is given by the
      inputs, or NULL if no GV of that name and type could be found. See
      &quot;Stashes and Globs&quot; in perlguts.
    <p class="Pp">The only differences are how the input name is specified, and
        if 'get' magic is normally used in getting that name.</p>
    <p class="Pp">Don't be fooled by the fact that only one form has
        <span class="Li">&quot;flags&quot;</span> in its name. They all have a
        <span class="Li">&quot;flags&quot;</span> parameter in fact, and all the
        flag bits have the same meanings for all</p>
    <p class="Pp">If any of the flags
        <span class="Li">&quot;GV_ADD&quot;</span>,
        <span class="Li">&quot;GV_ADDMG&quot;</span>,
        <span class="Li">&quot;GV_ADDWARN&quot;</span>,
        <span class="Li">&quot;GV_ADDMULTI&quot;</span>, or
        <span class="Li">&quot;GV_NOINIT&quot;</span> is set, a GV is created if
        none already exists for the input name and type. However,
        <span class="Li">&quot;GV_ADDMG&quot;</span> will only do the creation
        for magical GV's. For all of these flags except
        <span class="Li">&quot;GV_NOINIT&quot;</span>,
        <span class="Li">&quot;gv_init_pvn&quot;</span> is called after the
        addition. <span class="Li">&quot;GV_ADDWARN&quot;</span> is used when
        the caller expects that adding won't be necessary because the symbol
        should already exist; but if not, add it anyway, with a warning that it
        was unexpectedly absent. The
        <span class="Li">&quot;GV_ADDMULTI&quot;</span> flag means to pretend
        that the GV has been seen before (<i>i.e.</i>, suppress &quot;Used
        once&quot; warnings).</p>
    <p class="Pp">The flag <span class="Li">&quot;GV_NOADD_NOINIT&quot;</span>
        causes <span class="Li">&quot;gv_init_pvn&quot;</span> not be to called
        if the GV existed but isn't PVGV.</p>
    <p class="Pp">If the <span class="Li">&quot;SVf_UTF8&quot;</span> bit is
        set, the name is treated as being encoded in UTF-8; otherwise the name
        won't be considered to be UTF-8 in the
        <span class="Li">&quot;pv&quot;</span>-named forms, and the UTF-8ness of
        the underlying SVs will be used in the
        <span class="Li">&quot;sv&quot;</span> forms.</p>
    <p class="Pp">If the flag <span class="Li">&quot;GV_NOTQUAL&quot;</span> is
        set, the caller warrants that the input name is a plain symbol name, not
        qualified with a package, otherwise the name is checked for being a
        qualified one.</p>
    <p class="Pp">In <span class="Li">&quot;gv_fetchpv&quot;</span>,
        <span class="Li">&quot;nambeg&quot;</span> is a C string, NUL-terminated
        with no intermediate NULs.</p>
    <p class="Pp">In <span class="Li">&quot;gv_fetchpvs&quot;</span>,
        <span class="Li">&quot;name&quot;</span> is a literal C string, hence is
        enclosed in double quotes.</p>
    <p class="Pp"><span class="Li">&quot;gv_fetchpvn&quot;</span> and
        <span class="Li">&quot;gv_fetchpvn_flags&quot;</span> are identical. In
        these, &lt;nambeg&gt; is a Perl string whose byte length is given by
        <span class="Li">&quot;full_len&quot;</span>, and may contain embedded
        NULs.</p>
    <p class="Pp">In <span class="Li">&quot;gv_fetchsv&quot;</span> and
        <span class="Li">&quot;gv_fetchsv_nomg&quot;</span>, the name is
        extracted from the PV of the input
        <span class="Li">&quot;name&quot;</span> SV. The only difference between
        these two forms is that 'get' magic is normally done on
        <span class="Li">&quot;name&quot;</span> in
        <span class="Li">&quot;gv_fetchsv&quot;</span>, and always skipped with
        <span class="Li">&quot;gv_fetchsv_nomg&quot;</span>. Including
        <span class="Li">&quot;GV_NO_SVGMAGIC&quot;</span> in the
        <span class="Li">&quot;flags&quot;</span> parameter to
        <span class="Li">&quot;gv_fetchsv&quot;</span> makes it behave
        identically to <span class="Li">&quot;gv_fetchsv_nomg&quot;</span>.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> GV*   gv_fetchpv       (const char *nambeg, I32 flags,
                         const svtype sv_type)
 GV *  gv_fetchpvn      (const char * nambeg, STRLEN full_len,
                         I32 flags, const svtype sv_type)
 GV*   gv_fetchpvn_flags(const char* name, STRLEN len, I32 flags,
                         const svtype sv_type)
 GV *  gv_fetchpvs      (&quot;name&quot;, I32 flags, const svtype sv_type)
 GV*   gv_fetchsv       (SV *name, I32 flags, const svtype sv_type)
 GV *  gv_fetchsv_nomg  (SV *name, I32 flags, const svtype sv_type)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;GvHV&quot;</dt>
  <dd>Return the HV from the GV.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> HV*  GvHV(GV* gv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;gv_init&quot;</dt>
  <dd>The old form of <span class="Li">&quot;gv_init_pvn()&quot;</span>. It does
      not work with UTF-8 strings, as it has no flags parameter. If the
      <span class="Li">&quot;multi&quot;</span> parameter is set, the
      <span class="Li">&quot;GV_ADDMULTI&quot;</span> flag will be passed to
      <span class="Li">&quot;gv_init_pvn()&quot;</span>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  gv_init(GV* gv, HV* stash, const char* name, STRLEN len,
               int multi)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;gv_init_pv&quot;</dt>
  <dd>Same as <span class="Li">&quot;gv_init_pvn()&quot;</span>, but takes a
      nul-terminated string for the name instead of separate char * and length
      parameters.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  gv_init_pv(GV* gv, HV* stash, const char* name, U32 flags)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;gv_init_pvn&quot;</dt>
  <dd>Converts a scalar into a typeglob. This is an incoercible typeglob;
      assigning a reference to it will assign to one of its slots, instead of
      overwriting it as happens with typeglobs created by
      <span class="Li">&quot;SvSetSV&quot;</span>. Converting any scalar that is
      <span class="Li">&quot;SvOK()&quot;</span> may produce unpredictable
      results and is reserved for perl's internal use.
    <p class="Pp"><span class="Li">&quot;gv&quot;</span> is the scalar to be
        converted.</p>
    <p class="Pp"><span class="Li">&quot;stash&quot;</span> is the parent
        stash/package, if any.</p>
    <p class="Pp"><span class="Li">&quot;name&quot;</span> and
        <span class="Li">&quot;len&quot;</span> give the name. The name must be
        unqualified; that is, it must not include the package name. If
        <span class="Li">&quot;gv&quot;</span> is a stash element, it is the
        caller's responsibility to ensure that the name passed to this function
        matches the name of the element. If it does not match, perl's internal
        bookkeeping will get out of sync.</p>
    <p class="Pp"><span class="Li">&quot;flags&quot;</span> can be set to
        <span class="Li">&quot;SVf_UTF8&quot;</span> if
        <span class="Li">&quot;name&quot;</span> is a UTF-8 string, or the
        return value of SvUTF8(sv). It can also take the
        <span class="Li">&quot;GV_ADDMULTI&quot;</span> flag, which means to
        pretend that the GV has been seen before (i.e., suppress &quot;Used
        once&quot; warnings).</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  gv_init_pvn(GV* gv, HV* stash, const char* name, STRLEN len,
                   U32 flags)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;gv_init_sv&quot;</dt>
  <dd>Same as <span class="Li">&quot;gv_init_pvn()&quot;</span>, but takes an SV
      * for the name instead of separate char * and length parameters.
      <span class="Li">&quot;flags&quot;</span> is currently unused.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  gv_init_sv(GV* gv, HV* stash, SV* namesv, U32 flags)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;gv_stashpv&quot;</dt>
  <dd>Returns a pointer to the stash for a specified package. Uses
      <span class="Li">&quot;strlen&quot;</span> to determine the length of
      <span class="Li">&quot;name&quot;</span>, then calls
      <span class="Li">&quot;gv_stashpvn()&quot;</span>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> HV*  gv_stashpv(const char* name, I32 flags)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;gv_stashpvn&quot;</dt>
  <dd>Returns a pointer to the stash for a specified package. The
      <span class="Li">&quot;namelen&quot;</span> parameter indicates the length
      of the <span class="Li">&quot;name&quot;</span>, in bytes.
      <span class="Li">&quot;flags&quot;</span> is passed to
      <span class="Li">&quot;gv_fetchpvn_flags()&quot;</span>, so if set to
      <span class="Li">&quot;GV_ADD&quot;</span> then the package will be
      created if it does not already exist. If the package does not exist and
      <span class="Li">&quot;flags&quot;</span> is 0 (or any other setting that
      does not create packages) then <span class="Li">&quot;NULL&quot;</span> is
      returned.
    <p class="Pp">Flags may be one of:</p>
    <p class="Pp"></p>
    <pre> GV_ADD           Create and initialize the package if doesn't
                  already exist
 GV_NOADD_NOINIT  Don't create the package,
 GV_ADDMG         GV_ADD iff the GV is magical
 GV_NOINIT        GV_ADD, but don't initialize
 GV_NOEXPAND      Don't expand SvOK() entries to PVGV
 SVf_UTF8         The name is in UTF-8
    </pre>
    <p class="Pp">The most important of which are probably
        <span class="Li">&quot;GV_ADD&quot;</span> and
        <span class="Li">&quot;SVf_UTF8&quot;</span>.</p>
    <p class="Pp">Note, use of <span class="Li">&quot;gv_stashsv&quot;</span>
        instead of <span class="Li">&quot;gv_stashpvn&quot;</span> where
        possible is strongly recommended for performance reasons.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> HV*  gv_stashpvn(const char* name, U32 namelen, I32 flags)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;gv_stashpvs&quot;</dt>
  <dd>Like <span class="Li">&quot;gv_stashpvn&quot;</span>, but takes a literal
      string instead of a string/length pair.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> HV*  gv_stashpvs(&quot;name&quot;, I32 create)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;gv_stashsv&quot;</dt>
  <dd>Returns a pointer to the stash for a specified package. See
      <span class="Li">&quot;gv_stashpvn&quot;</span>.
    <p class="Pp">Note this interface is strongly preferred over
        <span class="Li">&quot;gv_stashpvn&quot;</span> for performance
      reasons.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> HV*  gv_stashsv(SV* sv, I32 flags)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;GvSV&quot;</dt>
  <dd>Return the SV from the GV.
    <p class="Pp">Prior to Perl v5.9.3, this would add a scalar if none existed.
        Nowadays, use <span class="Li">&quot;GvSVn&quot;</span> for that, or
        compile perl with
        <span class="Li">&quot;-DPERL_CREATE_GVSV&quot;</span>. See
        perl5100delta.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> SV*  GvSV(GV* gv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;GvSVn&quot;</dt>
  <dd>Like <span class="Li">&quot;GvSV&quot;</span>, but creates an empty scalar
      if none already exists.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> SV*  GvSVn(GV* gv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;save_gp&quot;</dt>
  <dd>Saves the current GP of gv on the save stack to be restored on scope exit.
    <p class="Pp">If empty is true, replace the GP with a new GP.</p>
    <p class="Pp">If empty is false, mark gv with GVf_INTRO so the next
        reference assigned is localized, which is how <span class="Li">&quot;
        local *foo = $someref; &quot;</span> works.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  save_gp(GV* gv, I32 empty)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;setdefout&quot;</dt>
  <dd>Sets <span class="Li">&quot;PL_defoutgv&quot;</span>, the default file
      handle for output, to the passed in typeglob. As
      <span class="Li">&quot;PL_defoutgv&quot;</span> &quot;owns&quot; a
      reference on its typeglob, the reference count of the passed in typeglob
      is increased by one, and the reference count of the typeglob that
      <span class="Li">&quot;PL_defoutgv&quot;</span> points to is decreased by
      one.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  setdefout(GV* gv)
</pre>
</div>
<div class="Bd-indent"></div>
</section>
<section class="Sh">
<h1 class="Sh" id="Hook_manipulation"><a class="permalink" href="#Hook_manipulation">Hook
  manipulation</a></h1>
<p class="Pp">These functions provide convenient and thread-safe means of
    manipulating hook variables.</p>
<dl class="Bl-tag">
  <dt>&quot;wrap_op_checker&quot;</dt>
  <dd>Puts a C function into the chain of check functions for a specified op
      type. This is the preferred way to manipulate the &quot;PL_check&quot;
      array. <span class="Li">&quot;opcode&quot;</span> specifies which type of
      op is to be affected. <span class="Li">&quot;new_checker&quot;</span> is a
      pointer to the C function that is to be added to that opcode's check
      chain, and <span class="Li">&quot;old_checker_p&quot;</span> points to the
      storage location where a pointer to the next function in the chain will be
      stored. The value of <span class="Li">&quot;new_checker&quot;</span> is
      written into the &quot;PL_check&quot; array, while the value previously
      stored there is written to <span class="Li">*old_checker_p</span>.
    <p class="Pp">&quot;PL_check&quot; is global to an entire process, and a
        module wishing to hook op checking may find itself invoked more than
        once per process, typically in different threads. To handle that
        situation, this function is idempotent. The location
        <span class="Li">*old_checker_p</span> must initially (once per process)
        contain a null pointer. A C variable of static duration (declared at
        file scope, typically also marked
        <span class="Li">&quot;static&quot;</span> to give it internal linkage)
        will be implicitly initialised appropriately, if it does not have an
        explicit initialiser. This function will only actually modify the check
        chain if it finds <span class="Li">*old_checker_p</span> to be null.
        This function is also thread safe on the small scale. It uses
        appropriate locking to avoid race conditions in accessing
        &quot;PL_check&quot;.</p>
    <p class="Pp">When this function is called, the function referenced by
        <span class="Li">&quot;new_checker&quot;</span> must be ready to be
        called, except for <span class="Li">*old_checker_p</span> being
        unfilled. In a threading situation,
        <span class="Li">&quot;new_checker&quot;</span> may be called
        immediately, even before this function has returned.
        <span class="Li">*old_checker_p</span> will always be appropriately set
        before <span class="Li">&quot;new_checker&quot;</span> is called. If
        <span class="Li">&quot;new_checker&quot;</span> decides not to do
        anything special with an op that it is given (which is the usual case
        for most uses of op check hooking), it must chain the check function
        referenced by <span class="Li">*old_checker_p</span>.</p>
    <p class="Pp">Taken all together, XS code to hook an op checker should
        typically look something like this:</p>
    <p class="Pp"></p>
    <pre>    static Perl_check_t nxck_frob;
    static OP *myck_frob(pTHX_ OP *op) {
        ...
        op = nxck_frob(aTHX_ op);
        ...
        return op;
    }
    BOOT:
        wrap_op_checker(OP_FROB, myck_frob, &amp;nxck_frob);
    </pre>
    <p class="Pp">If you want to influence compilation of calls to a specific
        subroutine, then use &quot;cv_set_call_checker_flags&quot; rather than
        hooking checking of all <span class="Li">&quot;entersub&quot;</span>
        ops.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  wrap_op_checker(Optype opcode, Perl_check_t new_checker,
                       Perl_check_t *old_checker_p)
</pre>
</div>
<div class="Bd-indent"></div>
</section>
<section class="Sh">
<h1 class="Sh" id="HV_Handling"><a class="permalink" href="#HV_Handling">HV
  Handling</a></h1>
<p class="Pp">A HV structure represents a Perl hash. It consists mainly of an
    array of pointers, each of which points to a linked list of HE structures.
    The array is indexed by the hash function of the key, so each linked list
    represents all the hash entries with the same hash value. Each HE contains a
    pointer to the actual value, plus a pointer to a HEK structure which holds
    the key and hash value.</p>
<dl class="Bl-tag">
  <dt>&quot;get_hv&quot;</dt>
  <dd>Returns the HV of the specified Perl hash.
      <span class="Li">&quot;flags&quot;</span> are passed to
      <span class="Li">&quot;gv_fetchpv&quot;</span>. If
      <span class="Li">&quot;GV_ADD&quot;</span> is set and the Perl variable
      does not exist then it will be created. If
      <span class="Li">&quot;flags&quot;</span> is zero and the variable does
      not exist then <span class="Li">&quot;NULL&quot;</span> is returned.
    <p class="Pp">NOTE: the <span class="Li">&quot;perl_get_hv()&quot;</span>
        form is <b>deprecated</b>.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> HV*  get_hv(const char *name, I32 flags)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;HEf_SVKEY&quot;</dt>
  <dd>This flag, used in the length slot of hash entries and magic structures,
      specifies the structure contains an
      <span class="Li">&quot;SV*&quot;</span> pointer where a
      <span class="Li">&quot;char*&quot;</span> pointer is to be expected. (For
      information only--not to be used).</dd>
  <dt>&quot;HeHASH&quot;</dt>
  <dd>Returns the computed hash stored in the hash entry.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> U32  HeHASH(HE* he)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;HeKEY&quot;</dt>
  <dd>Returns the actual pointer stored in the key slot of the hash entry. The
      pointer may be either <span class="Li">&quot;char*&quot;</span> or
      <span class="Li">&quot;SV*&quot;</span>, depending on the value of
      <span class="Li">&quot;HeKLEN()&quot;</span>. Can be assigned to. The
      <span class="Li">&quot;HePV()&quot;</span> or
      <span class="Li">&quot;HeSVKEY()&quot;</span> macros are usually
      preferable for finding the value of a key.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void*  HeKEY(HE* he)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;HeKLEN&quot;</dt>
  <dd>If this is negative, and amounts to
      <span class="Li">&quot;HEf_SVKEY&quot;</span>, it indicates the entry
      holds an <span class="Li">&quot;SV*&quot;</span> key. Otherwise, holds the
      actual length of the key. Can be assigned to. The
      <span class="Li">&quot;HePV()&quot;</span> macro is usually preferable for
      finding key lengths.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> STRLEN  HeKLEN(HE* he)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;HePV&quot;</dt>
  <dd>Returns the key slot of the hash entry as a
      <span class="Li">&quot;char*&quot;</span> value, doing any necessary
      dereferencing of possibly <span class="Li">&quot;SV*&quot;</span> keys.
      The length of the string is placed in
      <span class="Li">&quot;len&quot;</span> (this is a macro, so do <i>not</i>
      use <span class="Li">&amp;len</span>). If you do not care about what the
      length of the key is, you may use the global variable
      <span class="Li">&quot;PL_na&quot;</span>, though this is rather less
      efficient than using a local variable. Remember though, that hash keys in
      perl are free to contain embedded nulls, so using
      <span class="Li">&quot;strlen()&quot;</span> or similar is not a good way
      to find the length of hash keys. This is very similar to the
      <span class="Li">&quot;SvPV()&quot;</span> macro described elsewhere in
      this document. See also <span class="Li">&quot;HeUTF8&quot;</span>.
    <p class="Pp">If you are using <span class="Li">&quot;HePV&quot;</span> to
        get values to pass to <span class="Li">&quot;newSVpvn()&quot;</span> to
        create a new SV, you should consider using
        <span class="Li">&quot;newSVhek(HeKEY_hek(he))&quot;</span> as it is
        more efficient.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> char*  HePV(HE* he, STRLEN len)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;HeSVKEY&quot;</dt>
  <dd>Returns the key as an <span class="Li">&quot;SV*&quot;</span>, or
      <span class="Li">&quot;NULL&quot;</span> if the hash entry does not
      contain an <span class="Li">&quot;SV*&quot;</span> key.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> SV*  HeSVKEY(HE* he)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;HeSVKEY_force&quot;</dt>
  <dd>Returns the key as an <span class="Li">&quot;SV*&quot;</span>. Will create
      and return a temporary mortal <span class="Li">&quot;SV*&quot;</span> if
      the hash entry contains only a <span class="Li">&quot;char*&quot;</span>
      key.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> SV*  HeSVKEY_force(HE* he)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;HeSVKEY_set&quot;</dt>
  <dd>Sets the key to a given <span class="Li">&quot;SV*&quot;</span>, taking
      care to set the appropriate flags to indicate the presence of an
      <span class="Li">&quot;SV*&quot;</span> key, and returns the same
      <span class="Li">&quot;SV*&quot;</span>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> SV*  HeSVKEY_set(HE* he, SV* sv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;HeUTF8&quot;</dt>
  <dd>Returns whether the <span class="Li">&quot;char *&quot;</span> value
      returned by <span class="Li">&quot;HePV&quot;</span> is encoded in UTF-8,
      doing any necessary dereferencing of possibly
      <span class="Li">&quot;SV*&quot;</span> keys. The value returned will be 0
      or non-0, not necessarily 1 (or even a value with any low bits set), so
      <b>do not</b> blindly assign this to a
      <span class="Li">&quot;bool&quot;</span> variable, as
      <span class="Li">&quot;bool&quot;</span> may be a typedef for
      <span class="Li">&quot;char&quot;</span>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> U32  HeUTF8(HE* he)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;HeVAL&quot;</dt>
  <dd>Returns the value slot (type <span class="Li">&quot;SV*&quot;</span>)
      stored in the hash entry. Can be assigned to.
    <p class="Pp"></p>
    <pre>  SV *foo= HeVAL(hv);
  HeVAL(hv)= sv;
    </pre>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> SV*  HeVAL(HE* he)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;HV&quot;</dt>
  <dd>Described in perlguts.</dd>
  <dt>&quot;hv_assert&quot;</dt>
  <dd>Check that a hash is in an internally consistent state.
    <p class="Pp">NOTE: <span class="Li">&quot;hv_assert&quot;</span> must be
        explicitly called as <span class="Li">&quot;Perl_hv_assert&quot;</span>
        with an <span class="Li">&quot;aTHX_&quot;</span> parameter.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  Perl_hv_assert(pTHX_ HV *hv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;hv_bucket_ratio&quot;</dt>
  <dd>NOTE: <span class="Li">&quot;hv_bucket_ratio&quot;</span> is
      <b>experimental</b> and may change or be removed without notice.
    <p class="Pp">If the hash is tied dispatches through to the SCALAR tied
        method, otherwise if the hash contains no keys returns 0, otherwise
        returns a mortal sv containing a string specifying the number of used
        buckets, followed by a slash, followed by the number of available
        buckets.</p>
    <p class="Pp">This function is expensive, it must scan all of the buckets to
        determine which are used, and the count is NOT cached. In a large hash
        this could be a lot of buckets.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> SV*  hv_bucket_ratio(HV *hv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;hv_clear&quot;</dt>
  <dd>Frees all the elements of a hash, leaving it empty. The XS equivalent of
      <span class="Li">&quot;%hash = ()&quot;</span>. See also
      &quot;hv_undef&quot;.
    <p class="Pp">See &quot;av_clear&quot; for a note about the hash possibly
        being invalid on return.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  hv_clear(HV *hv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;hv_clear_placeholders&quot;</dt>
  <dd>Clears any placeholders from a hash. If a restricted hash has any of its
      keys marked as readonly and the key is subsequently deleted, the key is
      not actually deleted but is marked by assigning it a value of
      <span class="Li">&amp;PL_sv_placeholder</span>. This tags it so it will be
      ignored by future operations such as iterating over the hash, but will
      still allow the hash to have a value reassigned to the key at some future
      point. This function clears any such placeholder keys from the hash. See
      <span class="Li">&quot;Hash::Util::lock_keys()&quot;</span> for an example
      of its use.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  hv_clear_placeholders(HV *hv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;hv_copy_hints_hv&quot;</dt>
  <dd>A specialised version of &quot;newHVhv&quot; for copying
      <span class="Li">&quot;%^H&quot;</span>.
      <span class="Li">&quot;ohv&quot;</span> must be a pointer to a hash (which
      may have <span class="Li">&quot;%^H&quot;</span> magic, but should be
      generally non-magical), or <span class="Li">&quot;NULL&quot;</span>
      (interpreted as an empty hash). The content of
      <span class="Li">&quot;ohv&quot;</span> is copied to a new hash, which has
      the <span class="Li">&quot;%^H&quot;</span>-specific magic added to it. A
      pointer to the new hash is returned.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> HV *  hv_copy_hints_hv(HV *const ohv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;hv_delete&quot;</dt>
  <dd>Deletes a key/value pair in the hash. The value's SV is removed from the
      hash, made mortal, and returned to the caller. The absolute value of
      <span class="Li">&quot;klen&quot;</span> is the length of the key. If
      <span class="Li">&quot;klen&quot;</span> is negative the key is assumed to
      be in UTF-8-encoded Unicode. The <span class="Li">&quot;flags&quot;</span>
      value will normally be zero; if set to
      <span class="Li">&quot;G_DISCARD&quot;</span> then
      <span class="Li">&quot;NULL&quot;</span> will be returned.
      <span class="Li">&quot;NULL&quot;</span> will also be returned if the key
      is not found.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> SV*  hv_delete(HV *hv, const char *key, I32 klen, I32 flags)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;hv_delete_ent&quot;</dt>
  <dd>Deletes a key/value pair in the hash. The value SV is removed from the
      hash, made mortal, and returned to the caller. The
      <span class="Li">&quot;flags&quot;</span> value will normally be zero; if
      set to <span class="Li">&quot;G_DISCARD&quot;</span> then
      <span class="Li">&quot;NULL&quot;</span> will be returned.
      <span class="Li">&quot;NULL&quot;</span> will also be returned if the key
      is not found. <span class="Li">&quot;hash&quot;</span> can be a valid
      precomputed hash value, or 0 to ask for it to be computed.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> SV*  hv_delete_ent(HV *hv, SV *keysv, I32 flags, U32 hash)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;HvENAME&quot;</dt>
  <dd>Returns the effective name of a stash, or NULL if there is none. The
      effective name represents a location in the symbol table where this stash
      resides. It is updated automatically when packages are aliased or deleted.
      A stash that is no longer in the symbol table has no effective name. This
      name is preferable to <span class="Li">&quot;HvNAME&quot;</span> for use
      in MRO linearisations and isa caches.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> char*  HvENAME(HV* stash)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;HvENAMELEN&quot;</dt>
  <dd>Returns the length of the stash's effective name.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> STRLEN  HvENAMELEN(HV *stash)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;HvENAMEUTF8&quot;</dt>
  <dd>Returns true if the effective name is in UTF-8 encoding.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> unsigned char  HvENAMEUTF8(HV *stash)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;hv_exists&quot;</dt>
  <dd>Returns a boolean indicating whether the specified hash key exists. The
      absolute value of <span class="Li">&quot;klen&quot;</span> is the length
      of the key. If <span class="Li">&quot;klen&quot;</span> is negative the
      key is assumed to be in UTF-8-encoded Unicode.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> bool  hv_exists(HV *hv, const char *key, I32 klen)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;hv_exists_ent&quot;</dt>
  <dd>Returns a boolean indicating whether the specified hash key exists.
      <span class="Li">&quot;hash&quot;</span> can be a valid precomputed hash
      value, or 0 to ask for it to be computed.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> bool  hv_exists_ent(HV *hv, SV *keysv, U32 hash)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;hv_fetch&quot;</dt>
  <dd>Returns the SV which corresponds to the specified key in the hash. The
      absolute value of <span class="Li">&quot;klen&quot;</span> is the length
      of the key. If <span class="Li">&quot;klen&quot;</span> is negative the
      key is assumed to be in UTF-8-encoded Unicode. If
      <span class="Li">&quot;lval&quot;</span> is set then the fetch will be
      part of a store. This means that if there is no value in the hash
      associated with the given key, then one is created and a pointer to it is
      returned. The <span class="Li">&quot;SV*&quot;</span> it points to can be
      assigned to. But always check that the return value is non-null before
      dereferencing it to an <span class="Li">&quot;SV*&quot;</span>.
    <p class="Pp">See &quot;Understanding the Magic of Tied Hashes and
        Arrays&quot; in perlguts for more information on how to use this
        function on tied hashes.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> SV**  hv_fetch(HV *hv, const char *key, I32 klen, I32 lval)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;hv_fetchs&quot;</dt>
  <dd>Like <span class="Li">&quot;hv_fetch&quot;</span>, but takes a literal
      string instead of a string/length pair.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> SV**  hv_fetchs(HV* tb, &quot;key&quot;, I32 lval)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;hv_fetch_ent&quot;</dt>
  <dd>Returns the hash entry which corresponds to the specified key in the hash.
      <span class="Li">&quot;hash&quot;</span> must be a valid precomputed hash
      number for the given <span class="Li">&quot;key&quot;</span>, or 0 if you
      want the function to compute it. IF
      <span class="Li">&quot;lval&quot;</span> is set then the fetch will be
      part of a store. Make sure the return value is non-null before accessing
      it. The return value when <span class="Li">&quot;hv&quot;</span> is a tied
      hash is a pointer to a static location, so be sure to make a copy of the
      structure if you need to store it somewhere.
    <p class="Pp">See &quot;Understanding the Magic of Tied Hashes and
        Arrays&quot; in perlguts for more information on how to use this
        function on tied hashes.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> HE*  hv_fetch_ent(HV *hv, SV *keysv, I32 lval, U32 hash)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;HvFILL&quot;</dt>
  <dd>See &quot;hv_fill&quot;.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> STRLEN  HvFILL(HV *const hv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;hv_fill&quot;</dt>
  <dd>Returns the number of hash buckets that happen to be in use.
    <p class="Pp">This function is wrapped by the macro
        <span class="Li">&quot;HvFILL&quot;</span>.</p>
    <p class="Pp">As of perl 5.25 this function is used only for debugging
        purposes, and the number of used hash buckets is not in any way cached,
        thus this function can be costly to execute as it must iterate over all
        the buckets in the hash.</p>
    <p class="Pp">NOTE: <span class="Li">&quot;hv_fill&quot;</span> must be
        explicitly called as <span class="Li">&quot;Perl_hv_fill&quot;</span>
        with an <span class="Li">&quot;aTHX_&quot;</span> parameter.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> STRLEN  Perl_hv_fill(pTHX_ HV *const hv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;hv_iterinit&quot;</dt>
  <dd>Prepares a starting point to traverse a hash table. Returns the number of
      keys in the hash, including placeholders (i.e. the same as
      <span class="Li">&quot;HvTOTALKEYS(hv)&quot;</span>). The return value is
      currently only meaningful for hashes without tie magic.
    <p class="Pp">NOTE: Before version 5.004_65,
        <span class="Li">&quot;hv_iterinit&quot;</span> used to return the
        number of hash buckets that happen to be in use. If you still need that
        esoteric value, you can get it through the macro
        <span class="Li">&quot;HvFILL(hv)&quot;</span>.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> I32  hv_iterinit(HV *hv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;hv_iterkey&quot;</dt>
  <dd>Returns the key from the current position of the hash iterator. See
      <span class="Li">&quot;hv_iterinit&quot;</span>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> char*  hv_iterkey(HE* entry, I32* retlen)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;hv_iterkeysv&quot;</dt>
  <dd>Returns the key as an <span class="Li">&quot;SV*&quot;</span> from the
      current position of the hash iterator. The return value will always be a
      mortal copy of the key. Also see
      <span class="Li">&quot;hv_iterinit&quot;</span>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> SV*  hv_iterkeysv(HE* entry)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;hv_iternext&quot;</dt>
  <dd>Returns entries from a hash iterator. See
      <span class="Li">&quot;hv_iterinit&quot;</span>.
    <p class="Pp">You may call <span class="Li">&quot;hv_delete&quot;</span> or
        <span class="Li">&quot;hv_delete_ent&quot;</span> on the hash entry that
        the iterator currently points to, without losing your place or
        invalidating your iterator. Note that in this case the current entry is
        deleted from the hash with your iterator holding the last reference to
        it. Your iterator is flagged to free the entry on the next call to
        <span class="Li">&quot;hv_iternext&quot;</span>, so you must not discard
        your iterator immediately else the entry will leak - call
        <span class="Li">&quot;hv_iternext&quot;</span> to trigger the resource
        deallocation.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> HE*  hv_iternext(HV *hv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;hv_iternextsv&quot;</dt>
  <dd>Performs an <span class="Li">&quot;hv_iternext&quot;</span>,
      <span class="Li">&quot;hv_iterkey&quot;</span>, and
      <span class="Li">&quot;hv_iterval&quot;</span> in one operation.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> SV*  hv_iternextsv(HV *hv, char **key, I32 *retlen)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;hv_iternext_flags&quot;</dt>
  <dd>NOTE: <span class="Li">&quot;hv_iternext_flags&quot;</span> is
      <b>experimental</b> and may change or be removed without notice.
    <p class="Pp">Returns entries from a hash iterator. See
        <span class="Li">&quot;hv_iterinit&quot;</span> and
        <span class="Li">&quot;hv_iternext&quot;</span>. The
        <span class="Li">&quot;flags&quot;</span> value will normally be zero;
        if <span class="Li">&quot;HV_ITERNEXT_WANTPLACEHOLDERS&quot;</span> is
        set the placeholders keys (for restricted hashes) will be returned in
        addition to normal keys. By default placeholders are automatically
        skipped over. Currently a placeholder is implemented with a value that
        is <span class="Li">&amp;PL_sv_placeholder</span>. Note that the
        implementation of placeholders and restricted hashes may change, and the
        implementation currently is insufficiently abstracted for any change to
        be tidy.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> HE*  hv_iternext_flags(HV *hv, I32 flags)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;hv_iterval&quot;</dt>
  <dd>Returns the value from the current position of the hash iterator. See
      <span class="Li">&quot;hv_iterkey&quot;</span>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> SV*  hv_iterval(HV *hv, HE *entry)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;hv_magic&quot;</dt>
  <dd>Adds magic to a hash. See
    <span class="Li">&quot;sv_magic&quot;</span>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  hv_magic(HV *hv, GV *gv, int how)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;HvNAME&quot;</dt>
  <dd>Returns the package name of a stash, or
      <span class="Li">&quot;NULL&quot;</span> if
      <span class="Li">&quot;stash&quot;</span> isn't a stash. See
      <span class="Li">&quot;SvSTASH&quot;</span>,
      <span class="Li">&quot;CvSTASH&quot;</span>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> char*  HvNAME(HV* stash)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;HvNAMELEN&quot;</dt>
  <dd>Returns the length of the stash's name.
    <p class="Pp">Disfavored forms of HvNAME and HvNAMELEN; suppress mention of
        them</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> STRLEN  HvNAMELEN(HV *stash)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;HvNAMEUTF8&quot;</dt>
  <dd>Returns true if the name is in UTF-8 encoding.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> unsigned char  HvNAMEUTF8(HV *stash)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;hv_scalar&quot;</dt>
  <dd>Evaluates the hash in scalar context and returns the result.
    <p class="Pp">When the hash is tied dispatches through to the SCALAR method,
        otherwise returns a mortal SV containing the number of keys in the
      hash.</p>
    <p class="Pp">Note, prior to 5.25 this function returned what is now
        returned by the <b>hv_bucket_ratio()</b> function.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> SV*  hv_scalar(HV *hv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;hv_store&quot;</dt>
  <dd>Stores an SV in a hash. The hash key is specified as
      <span class="Li">&quot;key&quot;</span> and the absolute value of
      <span class="Li">&quot;klen&quot;</span> is the length of the key. If
      <span class="Li">&quot;klen&quot;</span> is negative the key is assumed to
      be in UTF-8-encoded Unicode. The <span class="Li">&quot;hash&quot;</span>
      parameter is the precomputed hash value; if it is zero then Perl will
      compute it.
    <p class="Pp">The return value will be
        <span class="Li">&quot;NULL&quot;</span> if the operation failed or if
        the value did not need to be actually stored within the hash (as in the
        case of tied hashes). Otherwise it can be dereferenced to get the
        original <span class="Li">&quot;SV*&quot;</span>. Note that the caller
        is responsible for suitably incrementing the reference count of
        <span class="Li">&quot;val&quot;</span> before the call, and
        decrementing it if the function returned
        <span class="Li">&quot;NULL&quot;</span>. Effectively a successful
        <span class="Li">&quot;hv_store&quot;</span> takes ownership of one
        reference to <span class="Li">&quot;val&quot;</span>. This is usually
        what you want; a newly created SV has a reference count of one, so if
        all your code does is create SVs then store them in a hash,
        <span class="Li">&quot;hv_store&quot;</span> will own the only reference
        to the new SV, and your code doesn't need to do anything further to tidy
        up. <span class="Li">&quot;hv_store&quot;</span> is not implemented as a
        call to <span class="Li">&quot;hv_store_ent&quot;</span>, and does not
        create a temporary SV for the key, so if your key data is not already in
        SV form then use <span class="Li">&quot;hv_store&quot;</span> in
        preference to <span class="Li">&quot;hv_store_ent&quot;</span>.</p>
    <p class="Pp">See &quot;Understanding the Magic of Tied Hashes and
        Arrays&quot; in perlguts for more information on how to use this
        function on tied hashes.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> SV**  hv_store(HV *hv, const char *key, I32 klen, SV *val,
                U32 hash)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;hv_stores&quot;</dt>
  <dd>Like <span class="Li">&quot;hv_store&quot;</span>, but takes a literal
      string instead of a string/length pair and omits the hash parameter.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> SV**  hv_stores(HV* tb, &quot;key&quot;, SV* val)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;hv_store_ent&quot;</dt>
  <dd>Stores <span class="Li">&quot;val&quot;</span> in a hash. The hash key is
      specified as <span class="Li">&quot;key&quot;</span>. The
      <span class="Li">&quot;hash&quot;</span> parameter is the precomputed hash
      value; if it is zero then Perl will compute it. The return value is the
      new hash entry so created. It will be
      <span class="Li">&quot;NULL&quot;</span> if the operation failed or if the
      value did not need to be actually stored within the hash (as in the case
      of tied hashes). Otherwise the contents of the return value can be
      accessed using the <span class="Li">&quot;He?&quot;</span> macros
      described here. Note that the caller is responsible for suitably
      incrementing the reference count of
      <span class="Li">&quot;val&quot;</span> before the call, and decrementing
      it if the function returned NULL. Effectively a successful
      <span class="Li">&quot;hv_store_ent&quot;</span> takes ownership of one
      reference to <span class="Li">&quot;val&quot;</span>. This is usually what
      you want; a newly created SV has a reference count of one, so if all your
      code does is create SVs then store them in a hash,
      <span class="Li">&quot;hv_store&quot;</span> will own the only reference
      to the new SV, and your code doesn't need to do anything further to tidy
      up. Note that <span class="Li">&quot;hv_store_ent&quot;</span> only reads
      the <span class="Li">&quot;key&quot;</span>; unlike
      <span class="Li">&quot;val&quot;</span> it does not take ownership of it,
      so maintaining the correct reference count on
      <span class="Li">&quot;key&quot;</span> is entirely the caller's
      responsibility. The reason it does not take ownership, is that
      <span class="Li">&quot;key&quot;</span> is not used after this function
      returns, and so can be freed immediately.
      <span class="Li">&quot;hv_store&quot;</span> is not implemented as a call
      to <span class="Li">&quot;hv_store_ent&quot;</span>, and does not create a
      temporary SV for the key, so if your key data is not already in SV form
      then use <span class="Li">&quot;hv_store&quot;</span> in preference to
      <span class="Li">&quot;hv_store_ent&quot;</span>.
    <p class="Pp">See &quot;Understanding the Magic of Tied Hashes and
        Arrays&quot; in perlguts for more information on how to use this
        function on tied hashes.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> HE*  hv_store_ent(HV *hv, SV *key, SV *val, U32 hash)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;hv_undef&quot;</dt>
  <dd>Undefines the hash. The XS equivalent of
      <span class="Li">&quot;undef(%hash)&quot;</span>.
    <p class="Pp">As well as freeing all the elements of the hash (like
        <span class="Li">&quot;hv_clear()&quot;</span>), this also frees any
        auxiliary data and storage associated with the hash.</p>
    <p class="Pp">See &quot;av_clear&quot; for a note about the hash possibly
        being invalid on return.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  hv_undef(HV *hv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;MGVTBL&quot;</dt>
  <dd>Described in perlguts.</dd>
  <dt>&quot;newHV&quot;</dt>
  <dd>Creates a new HV. The reference count is set to 1.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> HV*  newHV()
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;Nullhv&quot;</dt>
  <dd><span class="Li">&quot;</span><span class="Li"><b>DEPRECATED!</b></span><span class="Li">&quot;</span>
      It is planned to remove <span class="Li">&quot;Nullhv&quot;</span> from a
      future release of Perl. Do not use it for new code; remove it from
      existing code.
    <p class="Pp">Null HV pointer.</p>
    <p class="Pp">(deprecated - use <span class="Li">&quot;(HV
        *)NULL&quot;</span> instead)</p>
  </dd>
  <dt>&quot;PERL_HASH&quot;</dt>
  <dd>Described in perlguts.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  PERL_HASH(U32 hash, char *key, STRLEN klen)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;PERL_MAGIC_arylen&quot;</dt>
  <dd></dd>
  <dt>&quot;PERL_MAGIC_arylen_p&quot;</dt>
  <dd></dd>
  <dt>&quot;PERL_MAGIC_backref&quot;</dt>
  <dd></dd>
  <dt>&quot;PERL_MAGIC_bm&quot;</dt>
  <dd></dd>
  <dt>&quot;PERL_MAGIC_checkcall&quot;</dt>
  <dd></dd>
  <dt>&quot;PERL_MAGIC_collxfrm&quot;</dt>
  <dd></dd>
  <dt>&quot;PERL_MAGIC_dbfile&quot;</dt>
  <dd></dd>
  <dt>&quot;PERL_MAGIC_dbline&quot;</dt>
  <dd></dd>
  <dt>&quot;PERL_MAGIC_debugvar&quot;</dt>
  <dd></dd>
  <dt>&quot;PERL_MAGIC_defelem&quot;</dt>
  <dd></dd>
  <dt>&quot;PERL_MAGIC_env&quot;</dt>
  <dd></dd>
  <dt>&quot;PERL_MAGIC_envelem&quot;</dt>
  <dd></dd>
  <dt>&quot;PERL_MAGIC_ext&quot;</dt>
  <dd></dd>
  <dt>&quot;PERL_MAGIC_fm&quot;</dt>
  <dd></dd>
  <dt>&quot;PERL_MAGIC_hints&quot;</dt>
  <dd></dd>
  <dt>&quot;PERL_MAGIC_hintselem&quot;</dt>
  <dd></dd>
  <dt>&quot;PERL_MAGIC_isa&quot;</dt>
  <dd></dd>
  <dt>&quot;PERL_MAGIC_isaelem&quot;</dt>
  <dd></dd>
  <dt>&quot;PERL_MAGIC_lvref&quot;</dt>
  <dd></dd>
  <dt>&quot;PERL_MAGIC_nkeys&quot;</dt>
  <dd></dd>
  <dt>&quot;PERL_MAGIC_nonelem&quot;</dt>
  <dd></dd>
  <dt>&quot;PERL_MAGIC_overload_table&quot;</dt>
  <dd></dd>
  <dt>&quot;PERL_MAGIC_pos&quot;</dt>
  <dd></dd>
  <dt>&quot;PERL_MAGIC_qr&quot;</dt>
  <dd></dd>
  <dt>&quot;PERL_MAGIC_regdata&quot;</dt>
  <dd></dd>
  <dt>&quot;PERL_MAGIC_regdatum&quot;</dt>
  <dd></dd>
  <dt>&quot;PERL_MAGIC_regex_global&quot;</dt>
  <dd></dd>
  <dt>&quot;PERL_MAGIC_rhash&quot;</dt>
  <dd></dd>
  <dt>&quot;PERL_MAGIC_shared&quot;</dt>
  <dd></dd>
  <dt>&quot;PERL_MAGIC_shared_scalar&quot;</dt>
  <dd></dd>
  <dt>&quot;PERL_MAGIC_sig&quot;</dt>
  <dd></dd>
  <dt>&quot;PERL_MAGIC_sigelem&quot;</dt>
  <dd></dd>
  <dt>&quot;PERL_MAGIC_substr&quot;</dt>
  <dd></dd>
  <dt>&quot;PERL_MAGIC_sv&quot;</dt>
  <dd></dd>
  <dt>&quot;PERL_MAGIC_symtab&quot;</dt>
  <dd></dd>
  <dt>&quot;PERL_MAGIC_taint&quot;</dt>
  <dd></dd>
  <dt>&quot;PERL_MAGIC_tied&quot;</dt>
  <dd></dd>
  <dt>&quot;PERL_MAGIC_tiedelem&quot;</dt>
  <dd></dd>
  <dt>&quot;PERL_MAGIC_tiedscalar&quot;</dt>
  <dd></dd>
  <dt>&quot;PERL_MAGIC_utf8&quot;</dt>
  <dd></dd>
  <dt>&quot;PERL_MAGIC_uvar&quot;</dt>
  <dd></dd>
  <dt>&quot;PERL_MAGIC_uvar_elem&quot;</dt>
  <dd></dd>
  <dt>&quot;PERL_MAGIC_vec&quot;</dt>
  <dd></dd>
  <dt>&quot;PERL_MAGIC_vstring&quot;</dt>
  <dd>Described in perlguts.</dd>
  <dt>&quot;PL_modglobal&quot;</dt>
  <dd><span class="Li">&quot;PL_modglobal&quot;</span> is a general purpose,
      interpreter global HV for use by extensions that need to keep information
      on a per-interpreter basis. In a pinch, it can also be used as a symbol
      table for extensions to share data among each other. It is a good idea to
      use keys prefixed by the package name of the extension that owns the data.
    <p class="Pp">On threaded perls, each thread has an independent copy of this
        variable; each initialized at creation time with the current value of
        the creating thread's copy.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> HV*  PL_modglobal
</pre>
</div>
<div class="Bd-indent"></div>
</section>
<section class="Sh">
<h1 class="Sh" id="Input/Output"><a class="permalink" href="#Input/Output">Input/Output</a></h1>
<dl class="Bl-tag">
  <dt>&quot;PerlIO_apply_layers&quot;</dt>
  <dd>Described in perlapio.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> int  PerlIO_apply_layers(PerlIO *f, const char *mode,
                          const char *layers)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;PerlIO_binmode&quot;</dt>
  <dd>Described in perlapio.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> int  PerlIO_binmode(PerlIO *f, int ptype, int imode,
                     const char *layers)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;PerlIO_canset_cnt&quot;</dt>
  <dd>Described in perlapio.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> int  PerlIO_canset_cnt(PerlIO *f)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;PerlIO_clearerr&quot;</dt>
  <dd>Described in perlapio.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  PerlIO_clearerr(PerlIO *f)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;PerlIO_close&quot;</dt>
  <dd>Described in perlapio.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> int  PerlIO_close(PerlIO *f)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;PerlIO_debug&quot;</dt>
  <dd>Described in perlapio.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  PerlIO_debug(const char *fmt, ...)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;PerlIO_eof&quot;</dt>
  <dd>Described in perlapio.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> int  PerlIO_eof(PerlIO *f)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;PerlIO_error&quot;</dt>
  <dd>Described in perlapio.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> int  PerlIO_error(PerlIO *f)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;PerlIO_exportFILE&quot;</dt>
  <dd>Described in perlapio.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> FILE  *  PerlIO_exportFILE(PerlIO *f, const char *mode)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;PerlIO_fast_gets&quot;</dt>
  <dd>Described in perlapio.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> int  PerlIO_fast_gets(PerlIO *f)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;PerlIO_fdopen&quot;</dt>
  <dd>Described in perlapio.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> PerlIO*  PerlIO_fdopen(int fd, const char *mode)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;PerlIO_fileno&quot;</dt>
  <dd>Described in perlapio.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> int  PerlIO_fileno(PerlIO *f)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;PerlIO_findFILE&quot;</dt>
  <dd>Described in perlapio.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> FILE  *  PerlIO_findFILE(PerlIO *f)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;PerlIO_flush&quot;</dt>
  <dd>Described in perlapio.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> int  PerlIO_flush(PerlIO *f)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;PERLIO_F_APPEND&quot;</dt>
  <dd></dd>
  <dt>&quot;PERLIO_F_CANREAD&quot;</dt>
  <dd></dd>
  <dt>&quot;PERLIO_F_CANWRITE&quot;</dt>
  <dd></dd>
  <dt>&quot;PERLIO_F_CRLF&quot;</dt>
  <dd></dd>
  <dt>&quot;PERLIO_F_EOF&quot;</dt>
  <dd></dd>
  <dt>&quot;PERLIO_F_ERROR&quot;</dt>
  <dd></dd>
  <dt>&quot;PERLIO_F_FASTGETS&quot;</dt>
  <dd></dd>
  <dt>&quot;PERLIO_F_LINEBUF&quot;</dt>
  <dd></dd>
  <dt>&quot;PERLIO_F_OPEN&quot;</dt>
  <dd></dd>
  <dt>&quot;PERLIO_F_RDBUF&quot;</dt>
  <dd></dd>
  <dt>&quot;PERLIO_F_TEMP&quot;</dt>
  <dd></dd>
  <dt>&quot;PERLIO_F_TRUNCATE&quot;</dt>
  <dd></dd>
  <dt>&quot;PERLIO_F_UNBUF&quot;</dt>
  <dd></dd>
  <dt>&quot;PERLIO_F_UTF8&quot;</dt>
  <dd></dd>
  <dt>&quot;PERLIO_F_WRBUF&quot;</dt>
  <dd>Described in perliol.</dd>
  <dt>&quot;PerlIO_getc&quot;</dt>
  <dd>Described in perlapio.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> int  PerlIO_getc(PerlIO *d)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;PerlIO_getpos&quot;</dt>
  <dd>Described in perlapio.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> int  PerlIO_getpos(PerlIO *f, SV *save)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;PerlIO_get_base&quot;</dt>
  <dd>Described in perlapio.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> STDCHAR *  PerlIO_get_base(PerlIO *f)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;PerlIO_get_bufsiz&quot;</dt>
  <dd>Described in perlapio.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> SSize_t  PerlIO_get_bufsiz(PerlIO *f)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;PerlIO_get_cnt&quot;</dt>
  <dd>Described in perlapio.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> SSize_t  PerlIO_get_cnt(PerlIO *f)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;PerlIO_get_ptr&quot;</dt>
  <dd>Described in perlapio.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> STDCHAR *  PerlIO_get_ptr(PerlIO *f)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;PerlIO_has_base&quot;</dt>
  <dd>Described in perlapio.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> int  PerlIO_has_base(PerlIO *f)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;PerlIO_has_cntptr&quot;</dt>
  <dd>Described in perlapio.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> int  PerlIO_has_cntptr(PerlIO *f)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;PerlIO_importFILE&quot;</dt>
  <dd>Described in perlapio.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> PerlIO*  PerlIO_importFILE(FILE *stdio, const char *mode)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;PERLIO_K_BUFFERED&quot;</dt>
  <dd></dd>
  <dt>&quot;PERLIO_K_CANCRLF&quot;</dt>
  <dd></dd>
  <dt>&quot;PERLIO_K_FASTGETS&quot;</dt>
  <dd></dd>
  <dt>&quot;PERLIO_K_MULTIARG&quot;</dt>
  <dd></dd>
  <dt>&quot;PERLIO_K_RAW&quot;</dt>
  <dd>Described in perliol.</dd>
  <dt>&quot;PerlIO_open&quot;</dt>
  <dd>Described in perlapio.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> PerlIO*  PerlIO_open(const char *path, const char *mode)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;PerlIO_printf&quot;</dt>
  <dd>Described in perlapio.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> int  PerlIO_printf(PerlIO *f, const char *fmt, ...)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;PerlIO_putc&quot;</dt>
  <dd>Described in perlapio.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> int  PerlIO_putc(PerlIO *f, int ch)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;PerlIO_puts&quot;</dt>
  <dd>Described in perlapio.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> int  PerlIO_puts(PerlIO *f, const char *string)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;PerlIO_read&quot;</dt>
  <dd>Described in perlapio.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> SSize_t  PerlIO_read(PerlIO *f, void *vbuf, Size_t count)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;PerlIO_releaseFILE&quot;</dt>
  <dd>Described in perlapio.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  PerlIO_releaseFILE(PerlIO *f, FILE *stdio)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;PerlIO_reopen&quot;</dt>
  <dd>Described in perlapio.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> PerlIO *  PerlIO_reopen(const char *path, const char *mode,
                         PerlIO *old)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;PerlIO_rewind&quot;</dt>
  <dd>Described in perlapio.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  PerlIO_rewind(PerlIO *f)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;PerlIO_seek&quot;</dt>
  <dd>Described in perlapio.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> int  PerlIO_seek(PerlIO *f, Off_t offset, int whence)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;PerlIO_setlinebuf&quot;</dt>
  <dd>Described in perlapio.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  PerlIO_setlinebuf(PerlIO *f)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;PerlIO_setpos&quot;</dt>
  <dd>Described in perlapio.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> int  PerlIO_setpos(PerlIO *f, SV *saved)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;PerlIO_set_cnt&quot;</dt>
  <dd>Described in perlapio.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  PerlIO_set_cnt(PerlIO *f, SSize_t cnt)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;PerlIO_set_ptrcnt&quot;</dt>
  <dd>Described in perlapio.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  PerlIO_set_ptrcnt(PerlIO *f, STDCHAR *ptr, SSize_t cnt)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;PerlIO_stderr&quot;</dt>
  <dd>Described in perlapio.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> PerlIO *  PerlIO_stderr()
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;PerlIO_stdin&quot;</dt>
  <dd>Described in perlapio.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> PerlIO *  PerlIO_stdin()
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;PerlIO_stdout&quot;</dt>
  <dd>Described in perlapio.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> PerlIO *  PerlIO_stdout()
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;PerlIO_stdoutf&quot;</dt>
  <dd>Described in perlapio.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> int  PerlIO_stdoutf(const char *fmt, ...)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;PerlIO_tell&quot;</dt>
  <dd>Described in perlapio.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> Off_t  PerlIO_tell(PerlIO *f)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;PerlIO_ungetc&quot;</dt>
  <dd>Described in perlapio.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> int  PerlIO_ungetc(PerlIO *f, int ch)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;PerlIO_vprintf&quot;</dt>
  <dd>Described in perlapio.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> int  PerlIO_vprintf(PerlIO *f, const char *fmt, va_list args)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;PerlIO_write&quot;</dt>
  <dd>Described in perlapio.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> SSize_t  PerlIO_write(PerlIO *f, const void *vbuf, Size_t count)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;PL_maxsysfd&quot;</dt>
  <dd>Described in perliol.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="Integer_configuration_values"><a class="permalink" href="#Integer_configuration_values">Integer
  configuration values</a></h1>
<dl class="Bl-tag">
  <dt>&quot;CASTI32&quot;</dt>
  <dd>This symbol is defined if the C compiler can cast negative or large
      floating point numbers to 32-bit ints.</dd>
  <dt>&quot;HAS_INT64_T&quot;</dt>
  <dd>This symbol will defined if the C compiler supports
      <span class="Li">&quot;int64_t&quot;</span>. Usually the <i>inttypes.h</i>
      needs to be included, but sometimes <i>sys/types.h</i> is enough.</dd>
  <dt>&quot;HAS_LONG_LONG&quot;</dt>
  <dd>This symbol will be defined if the C compiler supports long long.</dd>
  <dt>&quot;HAS_QUAD&quot;</dt>
  <dd>This symbol, if defined, tells that there's a 64-bit integer type,
      <span class="Li">&quot;Quad_t&quot;</span>, and its unsigned counterpart,
      <span class="Li">&quot;Uquad_t&quot;</span>.
      <span class="Li">&quot;QUADKIND&quot;</span> will be one of
      <span class="Li">&quot;QUAD_IS_INT&quot;</span>,
      <span class="Li">&quot;QUAD_IS_LONG&quot;</span>,
      <span class="Li">&quot;QUAD_IS_LONG_LONG&quot;</span>,
      <span class="Li">&quot;QUAD_IS_INT64_T&quot;</span>, or
      <span class="Li">&quot;QUAD_IS___INT64&quot;</span>.</dd>
  <dt>&quot;HE&quot;</dt>
  <dd>Described in perlguts.</dd>
  <dt>&quot;I8&quot;</dt>
  <dd></dd>
  <dt>&quot;I16&quot;</dt>
  <dd></dd>
  <dt>&quot;I32&quot;</dt>
  <dd></dd>
  <dt>&quot;I64&quot;</dt>
  <dd></dd>
  <dt>&quot;IV&quot;</dt>
  <dd>Described in perlguts.</dd>
  <dt>&quot;I32SIZE&quot;</dt>
  <dd>This symbol contains the
    <span class="Li">&quot;sizeof(I32)&quot;</span>.</dd>
  <dt>&quot;I32TYPE&quot;</dt>
  <dd>This symbol defines the C type used for Perl's I32.</dd>
  <dt>&quot;I64SIZE&quot;</dt>
  <dd>This symbol contains the
    <span class="Li">&quot;sizeof(I64)&quot;</span>.</dd>
  <dt>&quot;I64TYPE&quot;</dt>
  <dd>This symbol defines the C type used for Perl's I64.</dd>
  <dt>&quot;I16SIZE&quot;</dt>
  <dd>This symbol contains the
    <span class="Li">&quot;sizeof(I16)&quot;</span>.</dd>
  <dt>&quot;I16TYPE&quot;</dt>
  <dd>This symbol defines the C type used for Perl's I16.</dd>
  <dt>&quot;INT16_C&quot;</dt>
  <dd></dd>
  <dt>&quot;INT32_C&quot;</dt>
  <dd></dd>
  <dt>&quot;INT64_C&quot;</dt>
  <dd>Returns a token the C compiler recognizes for the constant
      <span class="Li">&quot;number&quot;</span> of the corresponding integer
      type on the machine.
    <p class="Pp">If the machine does not have a 64-bit type,
        <span class="Li">&quot;INT64_C&quot;</span> is undefined. Use
        <span class="Li">&quot;INTMAX_C&quot;</span> to get the largest type
        available on the platform.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> I16  INT16_C(number)
 I32  INT32_C(number)
 I64  INT64_C(number)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;INTMAX_C&quot;</dt>
  <dd>Returns a token the C compiler recognizes for the constant
      <span class="Li">&quot;number&quot;</span> of the widest integer type on
      the machine. For example, if the machine has
      <span class="Li">&quot;long</span> <span class="Li">long&quot;</span>s,
      <span class="Li">&quot;INTMAX_C(-1)&quot;</span> would yield
    <p class="Pp"></p>
    <pre> -1LL
    </pre>
    <p class="Pp">See also, for example,
        <span class="Li">&quot;INT32_C&quot;</span>.</p>
    <p class="Pp">Use &quot;IV&quot; to declare variables of the maximum usable
        size on this platform.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre>   INTMAX_C(number)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;INTSIZE&quot;</dt>
  <dd>This symbol contains the value of
      <span class="Li">&quot;sizeof(int)&quot;</span> so that the C preprocessor
      can make decisions based on it.</dd>
  <dt>&quot;I8SIZE&quot;</dt>
  <dd>This symbol contains the
    <span class="Li">&quot;sizeof(I8)&quot;</span>.</dd>
  <dt>&quot;I8TYPE&quot;</dt>
  <dd>This symbol defines the C type used for Perl's I8.</dd>
  <dt>&quot;IV_MAX&quot;</dt>
  <dd>The largest signed integer that fits in an IV on this platform.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> IV  IV_MAX
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;IV_MIN&quot;</dt>
  <dd>The negative signed integer furthest away from 0 that fits in an IV on
      this platform.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> IV  IV_MIN
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;IVSIZE&quot;</dt>
  <dd>This symbol contains the
    <span class="Li">&quot;sizeof(IV)&quot;</span>.</dd>
  <dt>&quot;IVTYPE&quot;</dt>
  <dd>This symbol defines the C type used for Perl's IV.</dd>
  <dt>&quot;line_t&quot;</dt>
  <dd>The typedef to use to declare variables that are to hold line
    numbers.</dd>
  <dt>&quot;LONGLONGSIZE&quot;</dt>
  <dd>This symbol contains the size of a long long, so that the C preprocessor
      can make decisions based on it. It is only defined if the system supports
      long long.</dd>
  <dt>&quot;LONGSIZE&quot;</dt>
  <dd>This symbol contains the value of
      <span class="Li">&quot;sizeof(long)&quot;</span> so that the C
      preprocessor can make decisions based on it.</dd>
  <dt>&quot;memzero&quot;</dt>
  <dd>Set the <span class="Li">&quot;l&quot;</span> bytes starting at
      <span class="Li">*d</span> to all zeroes.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  memzero(void * d, Size_t l)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;NV&quot;</dt>
  <dd>Described in perlguts.</dd>
  <dt>&quot;PERL_INT_FAST8_T&quot;</dt>
  <dd></dd>
  <dt>&quot;PERL_INT_FAST16_T&quot;</dt>
  <dd></dd>
  <dt>&quot;PERL_UINT_FAST8_T&quot;</dt>
  <dd></dd>
  <dt>&quot;PERL_UINT_FAST16_T&quot;</dt>
  <dd>These are equivalent to the correspondingly-named C99 typedefs on
      platforms that have those; they evaluate to
      <span class="Li">&quot;int&quot;</span> and
      <span class="Li">&quot;unsigned int&quot;</span> on platforms that don't,
      so that you can portably take advantage of this C99 feature.</dd>
  <dt>&quot;PERL_INT_MAX&quot;</dt>
  <dd></dd>
  <dt>&quot;PERL_INT_MIN&quot;</dt>
  <dd></dd>
  <dt>&quot;PERL_LONG_MAX&quot;</dt>
  <dd></dd>
  <dt>&quot;PERL_LONG_MIN&quot;</dt>
  <dd></dd>
  <dt>&quot;PERL_SHORT_MAX&quot;</dt>
  <dd></dd>
  <dt>&quot;PERL_SHORT_MIN&quot;</dt>
  <dd></dd>
  <dt>&quot;PERL_UCHAR_MAX&quot;</dt>
  <dd></dd>
  <dt>&quot;PERL_UCHAR_MIN&quot;</dt>
  <dd></dd>
  <dt>&quot;PERL_UINT_MAX&quot;</dt>
  <dd></dd>
  <dt>&quot;PERL_UINT_MIN&quot;</dt>
  <dd></dd>
  <dt>&quot;PERL_ULONG_MAX&quot;</dt>
  <dd></dd>
  <dt>&quot;PERL_ULONG_MIN&quot;</dt>
  <dd></dd>
  <dt>&quot;PERL_USHORT_MAX&quot;</dt>
  <dd></dd>
  <dt>&quot;PERL_USHORT_MIN&quot;</dt>
  <dd></dd>
  <dt>&quot;PERL_QUAD_MAX&quot;</dt>
  <dd></dd>
  <dt>&quot;PERL_QUAD_MIN&quot;</dt>
  <dd></dd>
  <dt>&quot;PERL_UQUAD_MAX&quot;</dt>
  <dd></dd>
  <dt>&quot;PERL_UQUAD_MIN&quot;</dt>
  <dd>These give the largest and smallest number representable in the current
      platform in variables of the corresponding types.
    <p class="Pp">For signed types, the smallest representable number is the
        most negative number, the one furthest away from zero.</p>
    <p class="Pp">For C99 and later compilers, these correspond to things like
        <span class="Li">&quot;INT_MAX&quot;</span>, which are available to the
        C code. But these constants, furnished by Perl, allow code compiled on
        earlier compilers to portably have access to the same constants.</p>
  </dd>
  <dt>&quot;SHORTSIZE&quot;</dt>
  <dd>This symbol contains the value of
      <span class="Li">&quot;sizeof(short)&quot;</span> so that the C
      preprocessor can make decisions based on it.</dd>
  <dt>&quot;STRLEN&quot;</dt>
  <dd>Described in perlguts.</dd>
  <dt>&quot;U8&quot;</dt>
  <dd></dd>
  <dt>&quot;U16&quot;</dt>
  <dd></dd>
  <dt>&quot;U32&quot;</dt>
  <dd></dd>
  <dt>&quot;U64&quot;</dt>
  <dd></dd>
  <dt>&quot;UV&quot;</dt>
  <dd>Described in perlguts.</dd>
  <dt>&quot;U32SIZE&quot;</dt>
  <dd>This symbol contains the
    <span class="Li">&quot;sizeof(U32)&quot;</span>.</dd>
  <dt>&quot;U32TYPE&quot;</dt>
  <dd>This symbol defines the C type used for Perl's U32.</dd>
  <dt>&quot;U64SIZE&quot;</dt>
  <dd>This symbol contains the
    <span class="Li">&quot;sizeof(U64)&quot;</span>.</dd>
  <dt>&quot;U64TYPE&quot;</dt>
  <dd>This symbol defines the C type used for Perl's U64.</dd>
  <dt>&quot;U16SIZE&quot;</dt>
  <dd>This symbol contains the
    <span class="Li">&quot;sizeof(U16)&quot;</span>.</dd>
  <dt>&quot;U16TYPE&quot;</dt>
  <dd>This symbol defines the C type used for Perl's U16.</dd>
  <dt>&quot;UINT16_C&quot;</dt>
  <dd></dd>
  <dt>&quot;UINT32_C&quot;</dt>
  <dd></dd>
  <dt>&quot;UINT64_C&quot;</dt>
  <dd>Returns a token the C compiler recognizes for the constant
      <span class="Li">&quot;number&quot;</span> of the corresponding unsigned
      integer type on the machine.
    <p class="Pp">If the machine does not have a 64-bit type,
        <span class="Li">&quot;UINT64_C&quot;</span> is undefined. Use
        <span class="Li">&quot;UINTMAX_C&quot;</span> to get the largest type
        available on the platform.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> U16  UINT16_C(number)
 U32  UINT32_C(number)
 U64  UINT64_C(number)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;UINTMAX_C&quot;</dt>
  <dd>Returns a token the C compiler recognizes for the constant
      <span class="Li">&quot;number&quot;</span> of the widest unsigned integer
      type on the machine. For example, if the machine has
      <span class="Li">&quot;long&quot;</span>s,
      <span class="Li">UINTMAX_C(1)</span> would yield
    <p class="Pp"></p>
    <pre> 1UL
    </pre>
    <p class="Pp">See also, for example,
        <span class="Li">&quot;UINT32_C&quot;</span>.</p>
    <p class="Pp">Use &quot;UV&quot; to declare variables of the maximum usable
        size on this platform.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre>   UINTMAX_C(number)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;U8SIZE&quot;</dt>
  <dd>This symbol contains the
    <span class="Li">&quot;sizeof(U8)&quot;</span>.</dd>
  <dt>&quot;U8TYPE&quot;</dt>
  <dd>This symbol defines the C type used for Perl's U8.</dd>
  <dt>&quot;UV_MAX&quot;</dt>
  <dd>The largest unsigned integer that fits in a UV on this platform.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> UV  UV_MAX
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;UV_MIN&quot;</dt>
  <dd>The smallest unsigned integer that fits in a UV on this platform. It
      should equal zero.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> UV  UV_MIN
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;UVSIZE&quot;</dt>
  <dd>This symbol contains the
    <span class="Li">&quot;sizeof(UV)&quot;</span>.</dd>
  <dt>&quot;UVTYPE&quot;</dt>
  <dd>This symbol defines the C type used for Perl's UV.</dd>
  <dt>&quot;WIDEST_UTYPE&quot;</dt>
  <dd>Yields the widest unsigned integer type on the platform, currently either
      <span class="Li">&quot;U32&quot;</span> or
      <span class="Li">&quot;U64&quot;</span>. This can be used in declarations
      such as
    <p class="Pp"></p>
    <pre> WIDEST_UTYPE my_uv;
    </pre>
    <p class="Pp">or casts</p>
    <p class="Pp"></p>
    <pre> my_uv = (WIDEST_UTYPE) val;
    </pre>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="Lexer_interface"><a class="permalink" href="#Lexer_interface">Lexer
  interface</a></h1>
<p class="Pp">This is the lower layer of the Perl parser, managing characters
    and tokens.</p>
<dl class="Bl-tag">
  <dt>&quot;lex_bufutf8&quot;</dt>
  <dd>NOTE: <span class="Li">&quot;lex_bufutf8&quot;</span> is
      <b>experimental</b> and may change or be removed without notice.
    <p class="Pp">Indicates whether the octets in the lexer buffer
        (&quot;PL_parser-&gt;linestr&quot;) should be interpreted as the UTF-8
        encoding of Unicode characters. If not, they should be interpreted as
        Latin-1 characters. This is analogous to the
        <span class="Li">&quot;SvUTF8&quot;</span> flag for scalars.</p>
    <p class="Pp">In UTF-8 mode, it is not guaranteed that the lexer buffer
        actually contains valid UTF-8. Lexing code must be robust in the face of
        invalid encoding.</p>
    <p class="Pp">The actual <span class="Li">&quot;SvUTF8&quot;</span> flag of
        the &quot;PL_parser-&gt;linestr&quot; scalar is significant, but not the
        whole story regarding the input character encoding. Normally, when a
        file is being read, the scalar contains octets and its
        <span class="Li">&quot;SvUTF8&quot;</span> flag is off, but the octets
        should be interpreted as UTF-8 if the <span class="Li">&quot;use
        utf8&quot;</span> pragma is in effect. During a string eval, however,
        the scalar may have the <span class="Li">&quot;SvUTF8&quot;</span> flag
        on, and in this case its octets should be interpreted as UTF-8 unless
        the <span class="Li">&quot;use bytes&quot;</span> pragma is in effect.
        This logic may change in the future; use this function instead of
        implementing the logic yourself.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> bool  lex_bufutf8()
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;lex_discard_to&quot;</dt>
  <dd>NOTE: <span class="Li">&quot;lex_discard_to&quot;</span> is
      <b>experimental</b> and may change or be removed without notice.
    <p class="Pp">Discards the first part of the
        &quot;PL_parser-&gt;linestr&quot; buffer, up to
        <span class="Li">&quot;ptr&quot;</span>. The remaining content of the
        buffer will be moved, and all pointers into the buffer updated
        appropriately. <span class="Li">&quot;ptr&quot;</span> must not be later
        in the buffer than the position of &quot;PL_parser-&gt;bufptr&quot;: it
        is not permitted to discard text that has yet to be lexed.</p>
    <p class="Pp">Normally it is not necessarily to do this directly, because it
        suffices to use the implicit discarding behaviour of
        &quot;lex_next_chunk&quot; and things based on it. However, if a token
        stretches across multiple lines, and the lexing code has kept multiple
        lines of text in the buffer for that purpose, then after completion of
        the token it would be wise to explicitly discard the now-unneeded
        earlier lines, to avoid future multi-line tokens growing the buffer
        without bound.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  lex_discard_to(char* ptr)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;lex_grow_linestr&quot;</dt>
  <dd>NOTE: <span class="Li">&quot;lex_grow_linestr&quot;</span> is
      <b>experimental</b> and may change or be removed without notice.
    <p class="Pp">Reallocates the lexer buffer
        (&quot;PL_parser-&gt;linestr&quot;) to accommodate at least
        <span class="Li">&quot;len&quot;</span> octets (including terminating
        <span class="Li">&quot;NUL&quot;</span>). Returns a pointer to the
        reallocated buffer. This is necessary before making any direct
        modification of the buffer that would increase its length.
        &quot;lex_stuff_pvn&quot; provides a more convenient way to insert text
        into the buffer.</p>
    <p class="Pp">Do not use <span class="Li">&quot;SvGROW&quot;</span> or
        <span class="Li">&quot;sv_grow&quot;</span> directly on
        <span class="Li">&quot;PL_parser-&gt;linestr&quot;</span>; this function
        updates all of the lexer's variables that point directly into the
        buffer.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> char*  lex_grow_linestr(STRLEN len)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;lex_next_chunk&quot;</dt>
  <dd>NOTE: <span class="Li">&quot;lex_next_chunk&quot;</span> is
      <b>experimental</b> and may change or be removed without notice.
    <p class="Pp">Reads in the next chunk of text to be lexed, appending it to
        &quot;PL_parser-&gt;linestr&quot;. This should be called when lexing
        code has looked to the end of the current chunk and wants to know more.
        It is usual, but not necessary, for lexing to have consumed the entirety
        of the current chunk at this time.</p>
    <p class="Pp">If &quot;PL_parser-&gt;bufptr&quot; is pointing to the very
        end of the current chunk (i.e., the current chunk has been entirely
        consumed), normally the current chunk will be discarded at the same time
        that the new chunk is read in. If
        <span class="Li">&quot;flags&quot;</span> has the
        <span class="Li">&quot;LEX_KEEP_PREVIOUS&quot;</span> bit set, the
        current chunk will not be discarded. If the current chunk has not been
        entirely consumed, then it will not be discarded regardless of the
      flag.</p>
    <p class="Pp">Returns true if some new text was added to the buffer, or
        false if the buffer has reached the end of the input text.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> bool  lex_next_chunk(U32 flags)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;lex_peek_unichar&quot;</dt>
  <dd>NOTE: <span class="Li">&quot;lex_peek_unichar&quot;</span> is
      <b>experimental</b> and may change or be removed without notice.
    <p class="Pp">Looks ahead one (Unicode) character in the text currently
        being lexed. Returns the codepoint (unsigned integer value) of the next
        character, or -1 if lexing has reached the end of the input text. To
        consume the peeked character, use &quot;lex_read_unichar&quot;.</p>
    <p class="Pp">If the next character is in (or extends into) the next chunk
        of input text, the next chunk will be read in. Normally the current
        chunk will be discarded at the same time, but if
        <span class="Li">&quot;flags&quot;</span> has the
        <span class="Li">&quot;LEX_KEEP_PREVIOUS&quot;</span> bit set, then the
        current chunk will not be discarded.</p>
    <p class="Pp">If the input is being interpreted as UTF-8 and a UTF-8
        encoding error is encountered, an exception is generated.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> I32  lex_peek_unichar(U32 flags)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;lex_read_space&quot;</dt>
  <dd>NOTE: <span class="Li">&quot;lex_read_space&quot;</span> is
      <b>experimental</b> and may change or be removed without notice.
    <p class="Pp">Reads optional spaces, in Perl style, in the text currently
        being lexed. The spaces may include ordinary whitespace characters and
        Perl-style comments. <span class="Li">&quot;#line&quot;</span>
        directives are processed if encountered.
        &quot;PL_parser-&gt;bufptr&quot; is moved past the spaces, so that it
        points at a non-space character (or the end of the input text).</p>
    <p class="Pp">If spaces extend into the next chunk of input text, the next
        chunk will be read in. Normally the current chunk will be discarded at
        the same time, but if <span class="Li">&quot;flags&quot;</span> has the
        <span class="Li">&quot;LEX_KEEP_PREVIOUS&quot;</span> bit set, then the
        current chunk will not be discarded.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  lex_read_space(U32 flags)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;lex_read_to&quot;</dt>
  <dd>NOTE: <span class="Li">&quot;lex_read_to&quot;</span> is
      <b>experimental</b> and may change or be removed without notice.
    <p class="Pp">Consume text in the lexer buffer, from
        &quot;PL_parser-&gt;bufptr&quot; up to
        <span class="Li">&quot;ptr&quot;</span>. This advances
        &quot;PL_parser-&gt;bufptr&quot; to match
        <span class="Li">&quot;ptr&quot;</span>, performing the correct
        bookkeeping whenever a newline character is passed. This is the normal
        way to consume lexed text.</p>
    <p class="Pp">Interpretation of the buffer's octets can be abstracted out by
        using the slightly higher-level functions &quot;lex_peek_unichar&quot;
        and &quot;lex_read_unichar&quot;.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  lex_read_to(char* ptr)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;lex_read_unichar&quot;</dt>
  <dd>NOTE: <span class="Li">&quot;lex_read_unichar&quot;</span> is
      <b>experimental</b> and may change or be removed without notice.
    <p class="Pp">Reads the next (Unicode) character in the text currently being
        lexed. Returns the codepoint (unsigned integer value) of the character
        read, and moves &quot;PL_parser-&gt;bufptr&quot; past the character, or
        returns -1 if lexing has reached the end of the input text. To
        non-destructively examine the next character, use
        &quot;lex_peek_unichar&quot; instead.</p>
    <p class="Pp">If the next character is in (or extends into) the next chunk
        of input text, the next chunk will be read in. Normally the current
        chunk will be discarded at the same time, but if
        <span class="Li">&quot;flags&quot;</span> has the
        <span class="Li">&quot;LEX_KEEP_PREVIOUS&quot;</span> bit set, then the
        current chunk will not be discarded.</p>
    <p class="Pp">If the input is being interpreted as UTF-8 and a UTF-8
        encoding error is encountered, an exception is generated.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> I32  lex_read_unichar(U32 flags)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;lex_start&quot;</dt>
  <dd>NOTE: <span class="Li">&quot;lex_start&quot;</span> is <b>experimental</b>
      and may change or be removed without notice.
    <p class="Pp">Creates and initialises a new lexer/parser state object,
        supplying a context in which to lex and parse from a new source of Perl
        code. A pointer to the new state object is placed in
        &quot;PL_parser&quot;. An entry is made on the save stack so that upon
        unwinding, the new state object will be destroyed and the former value
        of &quot;PL_parser&quot; will be restored. Nothing else need be done to
        clean up the parsing context.</p>
    <p class="Pp">The code to be parsed comes from
        <span class="Li">&quot;line&quot;</span> and
        <span class="Li">&quot;rsfp&quot;</span>.
        <span class="Li">&quot;line&quot;</span>, if non-null, provides a string
        (in SV form) containing code to be parsed. A copy of the string is made,
        so subsequent modification of <span class="Li">&quot;line&quot;</span>
        does not affect parsing. <span class="Li">&quot;rsfp&quot;</span>, if
        non-null, provides an input stream from which code will be read to be
        parsed. If both are non-null, the code in
        <span class="Li">&quot;line&quot;</span> comes first and must consist of
        complete lines of input, and <span class="Li">&quot;rsfp&quot;</span>
        supplies the remainder of the source.</p>
    <p class="Pp">The <span class="Li">&quot;flags&quot;</span> parameter is
        reserved for future use. Currently it is only used by perl internally,
        so extensions should always pass zero.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  lex_start(SV* line, PerlIO *rsfp, U32 flags)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;lex_stuff_pv&quot;</dt>
  <dd>NOTE: <span class="Li">&quot;lex_stuff_pv&quot;</span> is
      <b>experimental</b> and may change or be removed without notice.
    <p class="Pp">Insert characters into the lexer buffer
        (&quot;PL_parser-&gt;linestr&quot;), immediately after the current
        lexing point (&quot;PL_parser-&gt;bufptr&quot;), reallocating the buffer
        if necessary. This means that lexing code that runs later will see the
        characters as if they had appeared in the input. It is not recommended
        to do this as part of normal parsing, and most uses of this facility run
        the risk of the inserted characters being interpreted in an unintended
        manner.</p>
    <p class="Pp">The string to be inserted is represented by octets starting at
        <span class="Li">&quot;pv&quot;</span> and continuing to the first nul.
        These octets are interpreted as either UTF-8 or Latin-1, according to
        whether the <span class="Li">&quot;LEX_STUFF_UTF8&quot;</span> flag is
        set in <span class="Li">&quot;flags&quot;</span>. The characters are
        recoded for the lexer buffer, according to how the buffer is currently
        being interpreted (&quot;lex_bufutf8&quot;). If it is not convenient to
        nul-terminate a string to be inserted, the &quot;lex_stuff_pvn&quot;
        function is more appropriate.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  lex_stuff_pv(const char* pv, U32 flags)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;lex_stuff_pvn&quot;</dt>
  <dd>NOTE: <span class="Li">&quot;lex_stuff_pvn&quot;</span> is
      <b>experimental</b> and may change or be removed without notice.
    <p class="Pp">Insert characters into the lexer buffer
        (&quot;PL_parser-&gt;linestr&quot;), immediately after the current
        lexing point (&quot;PL_parser-&gt;bufptr&quot;), reallocating the buffer
        if necessary. This means that lexing code that runs later will see the
        characters as if they had appeared in the input. It is not recommended
        to do this as part of normal parsing, and most uses of this facility run
        the risk of the inserted characters being interpreted in an unintended
        manner.</p>
    <p class="Pp">The string to be inserted is represented by
        <span class="Li">&quot;len&quot;</span> octets starting at
        <span class="Li">&quot;pv&quot;</span>. These octets are interpreted as
        either UTF-8 or Latin-1, according to whether the
        <span class="Li">&quot;LEX_STUFF_UTF8&quot;</span> flag is set in
        <span class="Li">&quot;flags&quot;</span>. The characters are recoded
        for the lexer buffer, according to how the buffer is currently being
        interpreted (&quot;lex_bufutf8&quot;). If a string to be inserted is
        available as a Perl scalar, the &quot;lex_stuff_sv&quot; function is
        more convenient.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  lex_stuff_pvn(const char* pv, STRLEN len, U32 flags)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;lex_stuff_pvs&quot;</dt>
  <dd>NOTE: <span class="Li">&quot;lex_stuff_pvs&quot;</span> is
      <b>experimental</b> and may change or be removed without notice.
    <p class="Pp">Like &quot;lex_stuff_pvn&quot;, but takes a literal string
        instead of a string/length pair.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  lex_stuff_pvs(&quot;pv&quot;, U32 flags)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;lex_stuff_sv&quot;</dt>
  <dd>NOTE: <span class="Li">&quot;lex_stuff_sv&quot;</span> is
      <b>experimental</b> and may change or be removed without notice.
    <p class="Pp">Insert characters into the lexer buffer
        (&quot;PL_parser-&gt;linestr&quot;), immediately after the current
        lexing point (&quot;PL_parser-&gt;bufptr&quot;), reallocating the buffer
        if necessary. This means that lexing code that runs later will see the
        characters as if they had appeared in the input. It is not recommended
        to do this as part of normal parsing, and most uses of this facility run
        the risk of the inserted characters being interpreted in an unintended
        manner.</p>
    <p class="Pp">The string to be inserted is the string value of
        <span class="Li">&quot;sv&quot;</span>. The characters are recoded for
        the lexer buffer, according to how the buffer is currently being
        interpreted (&quot;lex_bufutf8&quot;). If a string to be inserted is not
        already a Perl scalar, the &quot;lex_stuff_pvn&quot; function avoids the
        need to construct a scalar.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  lex_stuff_sv(SV* sv, U32 flags)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;lex_unstuff&quot;</dt>
  <dd>NOTE: <span class="Li">&quot;lex_unstuff&quot;</span> is
      <b>experimental</b> and may change or be removed without notice.
    <p class="Pp">Discards text about to be lexed, from
        &quot;PL_parser-&gt;bufptr&quot; up to
        <span class="Li">&quot;ptr&quot;</span>. Text following
        <span class="Li">&quot;ptr&quot;</span> will be moved, and the buffer
        shortened. This hides the discarded text from any lexing code that runs
        later, as if the text had never appeared.</p>
    <p class="Pp">This is not the normal way to consume lexed text. For that,
        use &quot;lex_read_to&quot;.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  lex_unstuff(char* ptr)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;parse_arithexpr&quot;</dt>
  <dd>NOTE: <span class="Li">&quot;parse_arithexpr&quot;</span> is
      <b>experimental</b> and may change or be removed without notice.
    <p class="Pp">Parse a Perl arithmetic expression. This may contain operators
        of precedence down to the bit shift operators. The expression must be
        followed (and thus terminated) either by a comparison or
        lower-precedence operator or by something that would normally terminate
        an expression such as semicolon. If
        <span class="Li">&quot;flags&quot;</span> has the
        <span class="Li">&quot;PARSE_OPTIONAL&quot;</span> bit set, then the
        expression is optional, otherwise it is mandatory. It is up to the
        caller to ensure that the dynamic parser state (&quot;PL_parser&quot; et
        al) is correctly set to reflect the source of the code to be parsed and
        the lexical context for the expression.</p>
    <p class="Pp">The op tree representing the expression is returned. If an
        optional expression is absent, a null pointer is returned, otherwise the
        pointer will be non-null.</p>
    <p class="Pp">If an error occurs in parsing or compilation, in most cases a
        valid op tree is returned anyway. The error is reflected in the parser
        state, normally resulting in a single exception at the top level of
        parsing which covers all the compilation errors that occurred. Some
        compilation errors, however, will throw an exception immediately.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> OP*  parse_arithexpr(U32 flags)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;parse_barestmt&quot;</dt>
  <dd>NOTE: <span class="Li">&quot;parse_barestmt&quot;</span> is
      <b>experimental</b> and may change or be removed without notice.
    <p class="Pp">Parse a single unadorned Perl statement. This may be a normal
        imperative statement or a declaration that has compile-time effect. It
        does not include any label or other affixture. It is up to the caller to
        ensure that the dynamic parser state (&quot;PL_parser&quot; et al) is
        correctly set to reflect the source of the code to be parsed and the
        lexical context for the statement.</p>
    <p class="Pp">The op tree representing the statement is returned. This may
        be a null pointer if the statement is null, for example if it was
        actually a subroutine definition (which has compile-time side effects).
        If not null, it will be ops directly implementing the statement,
        suitable to pass to &quot;newSTATEOP&quot;. It will not normally include
        a <span class="Li">&quot;nextstate&quot;</span> or equivalent op (except
        for those embedded in a scope contained entirely within the
      statement).</p>
    <p class="Pp">If an error occurs in parsing or compilation, in most cases a
        valid op tree (most likely null) is returned anyway. The error is
        reflected in the parser state, normally resulting in a single exception
        at the top level of parsing which covers all the compilation errors that
        occurred. Some compilation errors, however, will throw an exception
        immediately.</p>
    <p class="Pp">The <span class="Li">&quot;flags&quot;</span> parameter is
        reserved for future use, and must always be zero.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> OP*  parse_barestmt(U32 flags)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;parse_block&quot;</dt>
  <dd>NOTE: <span class="Li">&quot;parse_block&quot;</span> is
      <b>experimental</b> and may change or be removed without notice.
    <p class="Pp">Parse a single complete Perl code block. This consists of an
        opening brace, a sequence of statements, and a closing brace. The block
        constitutes a lexical scope, so <span class="Li">&quot;my&quot;</span>
        variables and various compile-time effects can be contained within it.
        It is up to the caller to ensure that the dynamic parser state
        (&quot;PL_parser&quot; et al) is correctly set to reflect the source of
        the code to be parsed and the lexical context for the statement.</p>
    <p class="Pp">The op tree representing the code block is returned. This is
        always a real op, never a null pointer. It will normally be a
        <span class="Li">&quot;lineseq&quot;</span> list, including
        <span class="Li">&quot;nextstate&quot;</span> or equivalent ops. No ops
        to construct any kind of runtime scope are included by virtue of it
        being a block.</p>
    <p class="Pp">If an error occurs in parsing or compilation, in most cases a
        valid op tree (most likely null) is returned anyway. The error is
        reflected in the parser state, normally resulting in a single exception
        at the top level of parsing which covers all the compilation errors that
        occurred. Some compilation errors, however, will throw an exception
        immediately.</p>
    <p class="Pp">The <span class="Li">&quot;flags&quot;</span> parameter is
        reserved for future use, and must always be zero.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> OP*  parse_block(U32 flags)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;parse_fullexpr&quot;</dt>
  <dd>NOTE: <span class="Li">&quot;parse_fullexpr&quot;</span> is
      <b>experimental</b> and may change or be removed without notice.
    <p class="Pp">Parse a single complete Perl expression. This allows the full
        expression grammar, including the lowest-precedence operators such as
        <span class="Li">&quot;or&quot;</span>. The expression must be followed
        (and thus terminated) by a token that an expression would normally be
        terminated by: end-of-file, closing bracketing punctuation, semicolon,
        or one of the keywords that signals a postfix expression-statement
        modifier. If <span class="Li">&quot;flags&quot;</span> has the
        <span class="Li">&quot;PARSE_OPTIONAL&quot;</span> bit set, then the
        expression is optional, otherwise it is mandatory. It is up to the
        caller to ensure that the dynamic parser state (&quot;PL_parser&quot; et
        al) is correctly set to reflect the source of the code to be parsed and
        the lexical context for the expression.</p>
    <p class="Pp">The op tree representing the expression is returned. If an
        optional expression is absent, a null pointer is returned, otherwise the
        pointer will be non-null.</p>
    <p class="Pp">If an error occurs in parsing or compilation, in most cases a
        valid op tree is returned anyway. The error is reflected in the parser
        state, normally resulting in a single exception at the top level of
        parsing which covers all the compilation errors that occurred. Some
        compilation errors, however, will throw an exception immediately.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> OP*  parse_fullexpr(U32 flags)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;parse_fullstmt&quot;</dt>
  <dd>NOTE: <span class="Li">&quot;parse_fullstmt&quot;</span> is
      <b>experimental</b> and may change or be removed without notice.
    <p class="Pp">Parse a single complete Perl statement. This may be a normal
        imperative statement or a declaration that has compile-time effect, and
        may include optional labels. It is up to the caller to ensure that the
        dynamic parser state (&quot;PL_parser&quot; et al) is correctly set to
        reflect the source of the code to be parsed and the lexical context for
        the statement.</p>
    <p class="Pp">The op tree representing the statement is returned. This may
        be a null pointer if the statement is null, for example if it was
        actually a subroutine definition (which has compile-time side effects).
        If not null, it will be the result of a &quot;newSTATEOP&quot; call,
        normally including a <span class="Li">&quot;nextstate&quot;</span> or
        equivalent op.</p>
    <p class="Pp">If an error occurs in parsing or compilation, in most cases a
        valid op tree (most likely null) is returned anyway. The error is
        reflected in the parser state, normally resulting in a single exception
        at the top level of parsing which covers all the compilation errors that
        occurred. Some compilation errors, however, will throw an exception
        immediately.</p>
    <p class="Pp">The <span class="Li">&quot;flags&quot;</span> parameter is
        reserved for future use, and must always be zero.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> OP*  parse_fullstmt(U32 flags)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;parse_label&quot;</dt>
  <dd>NOTE: <span class="Li">&quot;parse_label&quot;</span> is
      <b>experimental</b> and may change or be removed without notice.
    <p class="Pp">Parse a single label, possibly optional, of the type that may
        prefix a Perl statement. It is up to the caller to ensure that the
        dynamic parser state (&quot;PL_parser&quot; et al) is correctly set to
        reflect the source of the code to be parsed. If
        <span class="Li">&quot;flags&quot;</span> has the
        <span class="Li">&quot;PARSE_OPTIONAL&quot;</span> bit set, then the
        label is optional, otherwise it is mandatory.</p>
    <p class="Pp">The name of the label is returned in the form of a fresh
        scalar. If an optional label is absent, a null pointer is returned.</p>
    <p class="Pp">If an error occurs in parsing, which can only occur if the
        label is mandatory, a valid label is returned anyway. The error is
        reflected in the parser state, normally resulting in a single exception
        at the top level of parsing which covers all the compilation errors that
        occurred.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> SV*  parse_label(U32 flags)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;parse_listexpr&quot;</dt>
  <dd>NOTE: <span class="Li">&quot;parse_listexpr&quot;</span> is
      <b>experimental</b> and may change or be removed without notice.
    <p class="Pp">Parse a Perl list expression. This may contain operators of
        precedence down to the comma operator. The expression must be followed
        (and thus terminated) either by a low-precedence logic operator such as
        <span class="Li">&quot;or&quot;</span> or by something that would
        normally terminate an expression such as semicolon. If
        <span class="Li">&quot;flags&quot;</span> has the
        <span class="Li">&quot;PARSE_OPTIONAL&quot;</span> bit set, then the
        expression is optional, otherwise it is mandatory. It is up to the
        caller to ensure that the dynamic parser state (&quot;PL_parser&quot; et
        al) is correctly set to reflect the source of the code to be parsed and
        the lexical context for the expression.</p>
    <p class="Pp">The op tree representing the expression is returned. If an
        optional expression is absent, a null pointer is returned, otherwise the
        pointer will be non-null.</p>
    <p class="Pp">If an error occurs in parsing or compilation, in most cases a
        valid op tree is returned anyway. The error is reflected in the parser
        state, normally resulting in a single exception at the top level of
        parsing which covers all the compilation errors that occurred. Some
        compilation errors, however, will throw an exception immediately.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> OP*  parse_listexpr(U32 flags)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;parse_stmtseq&quot;</dt>
  <dd>NOTE: <span class="Li">&quot;parse_stmtseq&quot;</span> is
      <b>experimental</b> and may change or be removed without notice.
    <p class="Pp">Parse a sequence of zero or more Perl statements. These may be
        normal imperative statements, including optional labels, or declarations
        that have compile-time effect, or any mixture thereof. The statement
        sequence ends when a closing brace or end-of-file is encountered in a
        place where a new statement could have validly started. It is up to the
        caller to ensure that the dynamic parser state (&quot;PL_parser&quot; et
        al) is correctly set to reflect the source of the code to be parsed and
        the lexical context for the statements.</p>
    <p class="Pp">The op tree representing the statement sequence is returned.
        This may be a null pointer if the statements were all null, for example
        if there were no statements or if there were only subroutine definitions
        (which have compile-time side effects). If not null, it will be a
        <span class="Li">&quot;lineseq&quot;</span> list, normally including
        <span class="Li">&quot;nextstate&quot;</span> or equivalent ops.</p>
    <p class="Pp">If an error occurs in parsing or compilation, in most cases a
        valid op tree is returned anyway. The error is reflected in the parser
        state, normally resulting in a single exception at the top level of
        parsing which covers all the compilation errors that occurred. Some
        compilation errors, however, will throw an exception immediately.</p>
    <p class="Pp">The <span class="Li">&quot;flags&quot;</span> parameter is
        reserved for future use, and must always be zero.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> OP*  parse_stmtseq(U32 flags)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;parse_subsignature&quot;</dt>
  <dd>NOTE: <span class="Li">&quot;parse_subsignature&quot;</span> is
      <b>experimental</b> and may change or be removed without notice.
    <p class="Pp">Parse a subroutine signature declaration. This is the contents
        of the parentheses following a named or anonymous subroutine declaration
        when the <span class="Li">&quot;signatures&quot;</span> feature is
        enabled. Note that this function neither expects nor consumes the
        opening and closing parentheses around the signature; it is the caller's
        job to handle these.</p>
    <p class="Pp">This function must only be called during parsing of a
        subroutine; after &quot;start_subparse&quot; has been called. It might
        allocate lexical variables on the pad for the current subroutine.</p>
    <p class="Pp">The op tree to unpack the arguments from the stack at runtime
        is returned. This op tree should appear at the beginning of the compiled
        function. The caller may wish to use &quot;op_append_list&quot; to build
        their function body after it, or splice it together with the body before
        calling &quot;newATTRSUB&quot;.</p>
    <p class="Pp">The <span class="Li">&quot;flags&quot;</span> parameter is
        reserved for future use, and must always be zero.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> OP*  parse_subsignature(U32 flags)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;parse_termexpr&quot;</dt>
  <dd>NOTE: <span class="Li">&quot;parse_termexpr&quot;</span> is
      <b>experimental</b> and may change or be removed without notice.
    <p class="Pp">Parse a Perl term expression. This may contain operators of
        precedence down to the assignment operators. The expression must be
        followed (and thus terminated) either by a comma or lower-precedence
        operator or by something that would normally terminate an expression
        such as semicolon. If <span class="Li">&quot;flags&quot;</span> has the
        <span class="Li">&quot;PARSE_OPTIONAL&quot;</span> bit set, then the
        expression is optional, otherwise it is mandatory. It is up to the
        caller to ensure that the dynamic parser state (&quot;PL_parser&quot; et
        al) is correctly set to reflect the source of the code to be parsed and
        the lexical context for the expression.</p>
    <p class="Pp">The op tree representing the expression is returned. If an
        optional expression is absent, a null pointer is returned, otherwise the
        pointer will be non-null.</p>
    <p class="Pp">If an error occurs in parsing or compilation, in most cases a
        valid op tree is returned anyway. The error is reflected in the parser
        state, normally resulting in a single exception at the top level of
        parsing which covers all the compilation errors that occurred. Some
        compilation errors, however, will throw an exception immediately.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> OP*  parse_termexpr(U32 flags)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;PL_parser&quot;</dt>
  <dd>Pointer to a structure encapsulating the state of the parsing operation
      currently in progress. The pointer can be locally changed to perform a
      nested parse without interfering with the state of an outer parse.
      Individual members of <span class="Li">&quot;PL_parser&quot;</span> have
      their own documentation.</dd>
  <dt>&quot;PL_parser-&gt;bufend&quot;</dt>
  <dd>NOTE: <span class="Li">&quot;PL_parser-&gt;bufend&quot;</span> is
      <b>experimental</b> and may change or be removed without notice.
    <p class="Pp">Direct pointer to the end of the chunk of text currently being
        lexed, the end of the lexer buffer. This is equal to
        <span class="Li">&quot;SvPVX(PL_parser-&gt;linestr)</span>
        <span class="Li">+ SvCUR(PL_parser-&gt;linestr)&quot;</span>. A
        <span class="Li">&quot;NUL&quot;</span> character (zero octet) is always
        located at the end of the buffer, and does not count as part of the
        buffer's contents.</p>
  </dd>
  <dt>&quot;PL_parser-&gt;bufptr&quot;</dt>
  <dd>NOTE: <span class="Li">&quot;PL_parser-&gt;bufptr&quot;</span> is
      <b>experimental</b> and may change or be removed without notice.
    <p class="Pp">Points to the current position of lexing inside the lexer
        buffer. Characters around this point may be freely examined, within the
        range delimited by
        <span class="Li">&quot;SvPVX(&quot;PL_parser-&gt;linestr&quot;)&quot;</span>
        and &quot;PL_parser-&gt;bufend&quot;. The octets of the buffer may be
        intended to be interpreted as either UTF-8 or Latin-1, as indicated by
        &quot;lex_bufutf8&quot;.</p>
    <p class="Pp">Lexing code (whether in the Perl core or not) moves this
        pointer past the characters that it consumes. It is also expected to
        perform some bookkeeping whenever a newline character is consumed. This
        movement can be more conveniently performed by the function
        &quot;lex_read_to&quot;, which handles newlines appropriately.</p>
    <p class="Pp">Interpretation of the buffer's octets can be abstracted out by
        using the slightly higher-level functions &quot;lex_peek_unichar&quot;
        and &quot;lex_read_unichar&quot;.</p>
  </dd>
  <dt>&quot;PL_parser-&gt;linestart&quot;</dt>
  <dd>NOTE: <span class="Li">&quot;PL_parser-&gt;linestart&quot;</span> is
      <b>experimental</b> and may change or be removed without notice.
    <p class="Pp">Points to the start of the current line inside the lexer
        buffer. This is useful for indicating at which column an error occurred,
        and not much else. This must be updated by any lexing code that consumes
        a newline; the function &quot;lex_read_to&quot; handles this detail.</p>
  </dd>
  <dt>&quot;PL_parser-&gt;linestr&quot;</dt>
  <dd>NOTE: <span class="Li">&quot;PL_parser-&gt;linestr&quot;</span> is
      <b>experimental</b> and may change or be removed without notice.
    <p class="Pp">Buffer scalar containing the chunk currently under
        consideration of the text currently being lexed. This is always a plain
        string scalar (for which <span class="Li">&quot;SvPOK&quot;</span> is
        true). It is not intended to be used as a scalar by normal scalar means;
        instead refer to the buffer directly by the pointer variables described
        below.</p>
    <p class="Pp">The lexer maintains various
        <span class="Li">&quot;char*&quot;</span> pointers to things in the
        <span class="Li">&quot;PL_parser-&gt;linestr&quot;</span> buffer. If
        <span class="Li">&quot;PL_parser-&gt;linestr&quot;</span> is ever
        reallocated, all of these pointers must be updated. Don't attempt to do
        this manually, but rather use &quot;lex_grow_linestr&quot; if you need
        to reallocate the buffer.</p>
    <p class="Pp">The content of the text chunk in the buffer is commonly
        exactly one complete line of input, up to and including a newline
        terminator, but there are situations where it is otherwise. The octets
        of the buffer may be intended to be interpreted as either UTF-8 or
        Latin-1. The function &quot;lex_bufutf8&quot; tells you which. Do not
        use the <span class="Li">&quot;SvUTF8&quot;</span> flag on this scalar,
        which may disagree with it.</p>
    <p class="Pp">For direct examination of the buffer, the variable
        &quot;PL_parser-&gt;bufend&quot; points to the end of the buffer. The
        current lexing position is pointed to by
        &quot;PL_parser-&gt;bufptr&quot;. Direct use of these pointers is
        usually preferable to examination of the scalar through normal scalar
        means.</p>
  </dd>
  <dt>&quot;wrap_keyword_plugin&quot;</dt>
  <dd>NOTE: <span class="Li">&quot;wrap_keyword_plugin&quot;</span> is
      <b>experimental</b> and may change or be removed without notice.
    <p class="Pp">Puts a C function into the chain of keyword plugins. This is
        the preferred way to manipulate the &quot;PL_keyword_plugin&quot;
        variable. <span class="Li">&quot;new_plugin&quot;</span> is a pointer to
        the C function that is to be added to the keyword plugin chain, and
        <span class="Li">&quot;old_plugin_p&quot;</span> points to the storage
        location where a pointer to the next function in the chain will be
        stored. The value of <span class="Li">&quot;new_plugin&quot;</span> is
        written into the &quot;PL_keyword_plugin&quot; variable, while the value
        previously stored there is written to
        <span class="Li">*old_plugin_p</span>.</p>
    <p class="Pp">&quot;PL_keyword_plugin&quot; is global to an entire process,
        and a module wishing to hook keyword parsing may find itself invoked
        more than once per process, typically in different threads. To handle
        that situation, this function is idempotent. The location
        <span class="Li">*old_plugin_p</span> must initially (once per process)
        contain a null pointer. A C variable of static duration (declared at
        file scope, typically also marked
        <span class="Li">&quot;static&quot;</span> to give it internal linkage)
        will be implicitly initialised appropriately, if it does not have an
        explicit initialiser. This function will only actually modify the plugin
        chain if it finds <span class="Li">*old_plugin_p</span> to be null. This
        function is also thread safe on the small scale. It uses appropriate
        locking to avoid race conditions in accessing
        &quot;PL_keyword_plugin&quot;.</p>
    <p class="Pp">When this function is called, the function referenced by
        <span class="Li">&quot;new_plugin&quot;</span> must be ready to be
        called, except for <span class="Li">*old_plugin_p</span> being unfilled.
        In a threading situation, <span class="Li">&quot;new_plugin&quot;</span>
        may be called immediately, even before this function has returned.
        <span class="Li">*old_plugin_p</span> will always be appropriately set
        before <span class="Li">&quot;new_plugin&quot;</span> is called. If
        <span class="Li">&quot;new_plugin&quot;</span> decides not to do
        anything special with the identifier that it is given (which is the
        usual case for most calls to a keyword plugin), it must chain the plugin
        function referenced by <span class="Li">*old_plugin_p</span>.</p>
    <p class="Pp">Taken all together, XS code to install a keyword plugin should
        typically look something like this:</p>
    <p class="Pp"></p>
    <pre>    static Perl_keyword_plugin_t next_keyword_plugin;
    static OP *my_keyword_plugin(pTHX_
        char *keyword_ptr, STRLEN keyword_len, OP **op_ptr)
    {
        if (memEQs(keyword_ptr, keyword_len,
                   &quot;my_new_keyword&quot;)) {
            ...
        } else {
            return next_keyword_plugin(aTHX_
                keyword_ptr, keyword_len, op_ptr);
        }
    }
    BOOT:
        wrap_keyword_plugin(my_keyword_plugin,
                            &amp;next_keyword_plugin);
    </pre>
    <p class="Pp">Direct access to &quot;PL_keyword_plugin&quot; should be
        avoided.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  wrap_keyword_plugin(Perl_keyword_plugin_t new_plugin,
                           Perl_keyword_plugin_t *old_plugin_p)
</pre>
</div>
<div class="Bd-indent"></div>
</section>
<section class="Sh">
<h1 class="Sh" id="Locales"><a class="permalink" href="#Locales">Locales</a></h1>
<dl class="Bl-tag">
  <dt>&quot;DECLARATION_FOR_LC_NUMERIC_MANIPULATION&quot;</dt>
  <dd>This macro should be used as a statement. It declares a private variable
      (whose name begins with an underscore) that is needed by the other macros
      in this section. Failing to include this correctly should lead to a syntax
      error. For compatibility with C89 C compilers it should be placed in a
      block before any executable statements.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  DECLARATION_FOR_LC_NUMERIC_MANIPULATION
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;foldEQ_locale&quot;</dt>
  <dd>Returns true if the leading <span class="Li">&quot;len&quot;</span> bytes
      of the strings <span class="Li">&quot;s1&quot;</span> and
      <span class="Li">&quot;s2&quot;</span> are the same case-insensitively in
      the current locale; false otherwise.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> I32  foldEQ_locale(const char* a, const char* b, I32 len)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;HAS_DUPLOCALE&quot;</dt>
  <dd>This symbol, if defined, indicates that the
      <span class="Li">&quot;duplocale&quot;</span> routine is available to
      duplicate a locale object.</dd>
  <dt>&quot;HAS_FREELOCALE&quot;</dt>
  <dd>This symbol, if defined, indicates that the
      <span class="Li">&quot;freelocale&quot;</span> routine is available to
      deallocates the resources associated with a locale object.</dd>
  <dt>&quot;HAS_LC_MONETARY_2008&quot;</dt>
  <dd>This symbol, if defined, indicates that the localeconv routine is
      available and has the additional members added in
      <span class="Li">&quot;POSIX&quot;</span> 1003.1-2008.</dd>
  <dt>&quot;HAS_LOCALECONV&quot;</dt>
  <dd>This symbol, if defined, indicates that the
      <span class="Li">&quot;localeconv&quot;</span> routine is available for
      numeric and monetary formatting conventions.</dd>
  <dt>&quot;HAS_LOCALECONV_L&quot;</dt>
  <dd>This symbol, if defined, indicates that the
      <span class="Li">&quot;localeconv_l&quot;</span> routine is available to
      query certain information about a locale.</dd>
  <dt>&quot;HAS_NEWLOCALE&quot;</dt>
  <dd>This symbol, if defined, indicates that the
      <span class="Li">&quot;newlocale&quot;</span> routine is available to
      return a new locale object or modify an existing locale object.</dd>
  <dt>&quot;HAS_NL_LANGINFO&quot;</dt>
  <dd>This symbol, if defined, indicates that the
      <span class="Li">&quot;nl_langinfo&quot;</span> routine is available to
      return local data. You will also need <i>langinfo.h</i> and therefore
      <span class="Li">&quot;I_LANGINFO&quot;</span>.</dd>
  <dt>&quot;HAS_QUERYLOCALE&quot;</dt>
  <dd>This symbol, if defined, indicates that the
      <span class="Li">&quot;querylocale&quot;</span> routine is available to
      return the name of the locale for a category mask.</dd>
  <dt>&quot;HAS_SETLOCALE&quot;</dt>
  <dd>This symbol, if defined, indicates that the
      <span class="Li">&quot;setlocale&quot;</span> routine is available to
      handle locale-specific ctype implementations.</dd>
  <dt>&quot;HAS_SETLOCALE_R&quot;</dt>
  <dd>This symbol, if defined, indicates that the
      <span class="Li">&quot;setlocale_r&quot;</span> routine is available to
      setlocale re-entrantly.</dd>
  <dt>&quot;HAS_THREAD_SAFE_NL_LANGINFO_L&quot;</dt>
  <dd>This symbol, when defined, indicates presence of the
      <span class="Li">&quot;nl_langinfo_l()&quot;</span> function, and that it
      is thread-safe.</dd>
  <dt>&quot;HAS_USELOCALE&quot;</dt>
  <dd>This symbol, if defined, indicates that the
      <span class="Li">&quot;uselocale&quot;</span> routine is available to set
      the current locale for the calling thread.</dd>
  <dt>&quot;I_LANGINFO&quot;</dt>
  <dd>This symbol, if defined, indicates that <i>langinfo.h</i> exists and
      should be included.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> #ifdef I_LANGINFO
     #include &lt;langinfo.h&gt;
 #endif
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;I_LOCALE&quot;</dt>
  <dd>This symbol, if defined, indicates to the C program that it should include
      <i>locale.h</i>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> #ifdef I_LOCALE
     #include &lt;locale.h&gt;
 #endif
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;IN_LOCALE&quot;</dt>
  <dd>Evaluates to TRUE if the plain locale pragma without a parameter
      (<span class="Li">&quot;use&#x00A0;locale&quot;</span>) is in effect.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> bool  IN_LOCALE
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;IN_LOCALE_COMPILETIME&quot;</dt>
  <dd>Evaluates to TRUE if, when compiling a perl program (including an
      <span class="Li">&quot;eval&quot;</span>) if the plain locale pragma
      without a parameter
      (<span class="Li">&quot;use&#x00A0;locale&quot;</span>) is in effect.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> bool  IN_LOCALE_COMPILETIME
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;IN_LOCALE_RUNTIME&quot;</dt>
  <dd>Evaluates to TRUE if, when executing a perl program (including an
      <span class="Li">&quot;eval&quot;</span>) if the plain locale pragma
      without a parameter
      (<span class="Li">&quot;use&#x00A0;locale&quot;</span>) is in effect.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> bool  IN_LOCALE_RUNTIME
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;I_XLOCALE&quot;</dt>
  <dd>This symbol, if defined, indicates to the C program that it should include
      <i>xlocale.h</i> to get <span class="Li">&quot;uselocale()&quot;</span>
      and its friends.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> #ifdef I_XLOCALE
     #include &lt;xlocale.h&gt;
 #endif
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;Perl_langinfo&quot;</dt>
  <dd>This is an (almost) drop-in replacement for the system
      <span class="Li">nl_langinfo(3)</span>, taking the same
      <span class="Li">&quot;item&quot;</span> parameter values, and returning
      the same information. But it is more thread-safe than regular
      <span class="Li">&quot;nl_langinfo()&quot;</span>, and hides the quirks of
      Perl's locale handling from your code, and can be used on systems that
      lack a native <span class="Li">&quot;nl_langinfo&quot;</span>.
    <p class="Pp">Expanding on these:</p>
  </dd>
</dl>
<div class="Bd-indent">
<ul class="Bl-bullet">
  <li>The reason it isn't quite a drop-in replacement is actually an advantage.
      The only difference is that it returns
      <span class="Li">&quot;const&#x00A0;char&#x00A0;*&quot;</span>, whereas
      plain <span class="Li">&quot;nl_langinfo()&quot;</span> returns
      <span class="Li">&quot;char&#x00A0;*&quot;</span>, but you are (only by
      documentation) forbidden to write into the buffer. By declaring this
      <span class="Li">&quot;const&quot;</span>, the compiler enforces this
      restriction, so if it is violated, you know at compilation time, rather
      than getting segfaults at runtime.</li>
  <li>It delivers the correct results for the
      <span class="Li">&quot;RADIXCHAR&quot;</span> and
      <span class="Li">&quot;THOUSEP&quot;</span> items, without you having to
      write extra code. The reason for the extra code would be because these are
      from the <span class="Li">&quot;LC_NUMERIC&quot;</span> locale category,
      which is normally kept set by Perl so that the radix is a dot, and the
      separator is the empty string, no matter what the underlying locale is
      supposed to be, and so to get the expected results, you have to
      temporarily toggle into the underlying locale, and later toggle back. (You
      could use plain <span class="Li">&quot;nl_langinfo&quot;</span> and
      <span class="Li">&quot;STORE_LC_NUMERIC_FORCE_TO_UNDERLYING&quot;</span>
      for this but then you wouldn't get the other advantages of
      <span class="Li">&quot;Perl_langinfo()&quot;</span>; not keeping
      <span class="Li">&quot;LC_NUMERIC&quot;</span> in the C (or equivalent)
      locale would break a lot of CPAN, which is expecting the radix (decimal
      point) character to be a dot.)</li>
  <li>The system function it replaces can have its static return buffer trashed,
      not only by a subsequent call to that function, but by a
      <span class="Li">&quot;freelocale&quot;</span>,
      <span class="Li">&quot;setlocale&quot;</span>, or other locale change. The
      returned buffer of this function is not changed until the next call to it,
      so the buffer is never in a trashed state.</li>
  <li>Its return buffer is per-thread, so it also is never overwritten by a call
      to this function from another thread; unlike the function it
    replaces.</li>
  <li>But most importantly, it works on systems that don't have
      <span class="Li">&quot;nl_langinfo&quot;</span>, such as Windows, hence
      makes your code more portable. Of the fifty-some possible items specified
      by the POSIX 2008 standard,
      &lt;http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/langinfo.h.html&gt;,
      only one is completely unimplemented, though on non-Windows platforms,
      another significant one is also not implemented). It uses various
      techniques to recover the other items, including calling
      <span class="Li">localeconv(3)</span>, and
      <span class="Li">strftime(3)</span>, both of which are specified in C89,
      so should be always be available. Later
      <span class="Li">&quot;strftime()&quot;</span> versions have additional
      capabilities; <span class="Li">&quot;&quot;</span> is returned for those
      not available on your system.
    <p class="Pp">It is important to note that when called with an item that is
        recovered by using <span class="Li">&quot;localeconv&quot;</span>, the
        buffer from any previous explicit call to
        <span class="Li">&quot;localeconv&quot;</span> will be overwritten. This
        means you must save that buffer's contents if you need to access them
        after a call to this function. (But note that you might not want to be
        using <span class="Li">&quot;localeconv()&quot;</span> directly anyway,
        because of issues like the ones listed in the second item of this list
        (above) for <span class="Li">&quot;RADIXCHAR&quot;</span> and
        <span class="Li">&quot;THOUSEP&quot;</span>. You can use the methods
        given in perlcall to call &quot;localeconv&quot; in POSIX and avoid all
        the issues, but then you have a hash to unpack).</p>
    <p class="Pp">The details for those items which may deviate from what this
        emulation returns and what a native
        <span class="Li">&quot;nl_langinfo()&quot;</span> would return are
        specified in I18N::Langinfo.</p>
  </li>
</ul>
</div>
<div class="Bd-indent">
<p class="Pp">When using <span class="Li">&quot;Perl_langinfo&quot;</span> on
    systems that don't have a native
    <span class="Li">&quot;nl_langinfo()&quot;</span>, you must</p>
<p class="Pp"></p>
<pre> #include &quot;perl_langinfo.h&quot;
</pre>
<p class="Pp">before the <span class="Li">&quot;perl.h&quot;</span>
    <span class="Li">&quot;#include&quot;</span>. You can replace your
    <span class="Li">&quot;langinfo.h&quot;</span>
    <span class="Li">&quot;#include&quot;</span> with this one. (Doing it this
    way keeps out the symbols that plain
    <span class="Li">&quot;langinfo.h&quot;</span> would try to import into the
    namespace for code that doesn't need it.)</p>
<p class="Pp">The original impetus for
    <span class="Li">&quot;Perl_langinfo()&quot;</span> was so that code that
    needs to find out the current currency symbol, floating point radix
    character, or digit grouping separator can use, on all systems, the simpler
    and more thread-friendly <span class="Li">&quot;nl_langinfo&quot;</span> API
    instead of <span class="Li">localeconv(3)</span> which is a pain to make
    thread-friendly. For other fields returned by
    <span class="Li">&quot;localeconv&quot;</span>, it is better to use the
    methods given in perlcall to call
    <span class="Li">&quot;POSIX::localeconv()&quot;</span>, which is
    thread-friendly.</p>
<p class="Pp"></p>
<pre> const char*  Perl_langinfo(const nl_item item)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;Perl_setlocale&quot;</dt>
  <dd>This is an (almost) drop-in replacement for the system
      <span class="Li">setlocale(3)</span>, taking the same parameters, and
      returning the same information, except that it returns the correct
      underlying <span class="Li">&quot;LC_NUMERIC&quot;</span> locale. Regular
      <span class="Li">&quot;setlocale&quot;</span> will instead return
      <span class="Li">&quot;C&quot;</span> if the underlying locale has a
      non-dot decimal point character, or a non-empty thousands separator for
      displaying floating point numbers. This is because perl keeps that locale
      category such that it has a dot and empty separator, changing the locale
      briefly during the operations where the underlying one is required.
      <span class="Li">&quot;Perl_setlocale&quot;</span> knows about this, and
      compensates; regular <span class="Li">&quot;setlocale&quot;</span>
      doesn't.
    <p class="Pp">Another reason it isn't completely a drop-in replacement is
        that it is declared to return
        <span class="Li">&quot;const&#x00A0;char&#x00A0;*&quot;</span>, whereas
        the system setlocale omits the <span class="Li">&quot;const&quot;</span>
        (presumably because its API was specified long ago, and can't be
        updated; it is illegal to change the information
        <span class="Li">&quot;setlocale&quot;</span> returns; doing so leads to
        segfaults.)</p>
    <p class="Pp">Finally, <span class="Li">&quot;Perl_setlocale&quot;</span>
        works under all circumstances, whereas plain
        <span class="Li">&quot;setlocale&quot;</span> can be completely
        ineffective on some platforms under some configurations.</p>
    <p class="Pp"><span class="Li">&quot;Perl_setlocale&quot;</span> should not
        be used to change the locale except on systems where the predefined
        variable <span class="Li">&quot;${^SAFE_LOCALES}&quot;</span> is 1. On
        some such systems, the system
        <span class="Li">&quot;setlocale()&quot;</span> is ineffective,
        returning the wrong information, and failing to actually change the
        locale. <span class="Li">&quot;Perl_setlocale&quot;</span>, however
        works properly in all circumstances.</p>
    <p class="Pp">The return points to a per-thread static buffer, which is
        overwritten the next time
        <span class="Li">&quot;Perl_setlocale&quot;</span> is called from the
        same thread.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> const char*  Perl_setlocale(const int category,
                             const char* locale)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;RESTORE_LC_NUMERIC&quot;</dt>
  <dd>This is used in conjunction with one of the macros
      &quot;STORE_LC_NUMERIC_SET_TO_NEEDED&quot; and
      &quot;STORE_LC_NUMERIC_FORCE_TO_UNDERLYING&quot; to properly restore the
      <span class="Li">&quot;LC_NUMERIC&quot;</span> state.
    <p class="Pp">A call to &quot;DECLARATION_FOR_LC_NUMERIC_MANIPULATION&quot;
        must have been made to declare at compile time a private variable used
        by this macro and the two <span class="Li">&quot;STORE&quot;</span>
        ones. This macro should be called as a single statement, not an
        expression, but with an empty argument list, like this:</p>
    <p class="Pp"></p>
    <pre> {
    DECLARATION_FOR_LC_NUMERIC_MANIPULATION;
     ...
    RESTORE_LC_NUMERIC();
     ...
 }
    </pre>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  RESTORE_LC_NUMERIC()
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;SETLOCALE_ACCEPTS_ANY_LOCALE_NAME&quot;</dt>
  <dd>This symbol, if defined, indicates that the setlocale routine is available
      and it accepts any input locale name as valid.</dd>
  <dt>&quot;STORE_LC_NUMERIC_FORCE_TO_UNDERLYING&quot;</dt>
  <dd>This is used by XS code that is
      <span class="Li">&quot;LC_NUMERIC&quot;</span> locale-aware to force the
      locale for category <span class="Li">&quot;LC_NUMERIC&quot;</span> to be
      what perl thinks is the current underlying locale. (The perl interpreter
      could be wrong about what the underlying locale actually is if some C or
      XS code has called the C library function <b>setlocale</b>(3) behind its
      back; calling &quot;sync_locale&quot; before calling this macro will
      update perl's records.)
    <p class="Pp">A call to &quot;DECLARATION_FOR_LC_NUMERIC_MANIPULATION&quot;
        must have been made to declare at compile time a private variable used
        by this macro. This macro should be called as a single statement, not an
        expression, but with an empty argument list, like this:</p>
    <p class="Pp"></p>
    <pre> {
    DECLARATION_FOR_LC_NUMERIC_MANIPULATION;
     ...
    STORE_LC_NUMERIC_FORCE_TO_UNDERLYING();
     ...
    RESTORE_LC_NUMERIC();
     ...
 }
    </pre>
    <p class="Pp">The private variable is used to save the current locale state,
        so that the requisite matching call to &quot;RESTORE_LC_NUMERIC&quot;
        can restore it.</p>
    <p class="Pp">On threaded perls not operating with thread-safe
        functionality, this macro uses a mutex to force a critical section.
        Therefore the matching RESTORE should be close by, and guaranteed to be
        called.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  STORE_LC_NUMERIC_FORCE_TO_UNDERLYING()
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;STORE_LC_NUMERIC_SET_TO_NEEDED&quot;</dt>
  <dd>This is used to help wrap XS or C code that is
      <span class="Li">&quot;LC_NUMERIC&quot;</span> locale-aware. This locale
      category is generally kept set to a locale where the decimal radix
      character is a dot, and the separator between groups of digits is empty.
      This is because most XS code that reads floating point numbers is
      expecting them to have this syntax.
    <p class="Pp">This macro makes sure the current
        <span class="Li">&quot;LC_NUMERIC&quot;</span> state is set properly, to
        be aware of locale if the call to the XS or C code from the Perl program
        is from within the scope of a
        <span class="Li">&quot;use&#x00A0;locale&quot;</span>; or to ignore
        locale if the call is instead from outside such scope.</p>
    <p class="Pp">This macro is the start of wrapping the C or XS code; the wrap
        ending is done by calling the &quot;RESTORE_LC_NUMERIC&quot; macro after
        the operation. Otherwise the state can be changed that will adversely
        affect other XS code.</p>
    <p class="Pp">A call to &quot;DECLARATION_FOR_LC_NUMERIC_MANIPULATION&quot;
        must have been made to declare at compile time a private variable used
        by this macro. This macro should be called as a single statement, not an
        expression, but with an empty argument list, like this:</p>
    <p class="Pp"></p>
    <pre> {
    DECLARATION_FOR_LC_NUMERIC_MANIPULATION;
     ...
    STORE_LC_NUMERIC_SET_TO_NEEDED();
     ...
    RESTORE_LC_NUMERIC();
     ...
 }
    </pre>
    <p class="Pp">On threaded perls not operating with thread-safe
        functionality, this macro uses a mutex to force a critical section.
        Therefore the matching RESTORE should be close by, and guaranteed to be
        called; see &quot;WITH_LC_NUMERIC_SET_TO_NEEDED&quot; for a more
        contained way to ensure that.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  STORE_LC_NUMERIC_SET_TO_NEEDED()
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;STORE_LC_NUMERIC_SET_TO_NEEDED_IN&quot;</dt>
  <dd>Same as &quot;STORE_LC_NUMERIC_SET_TO_NEEDED&quot; with in_lc_numeric
      provided as the precalculated value of
      <span class="Li">&quot;IN_LC(LC_NUMERIC)&quot;</span>. It is the caller's
      responsibility to ensure that the status of
      <span class="Li">&quot;PL_compiling&quot;</span> and
      <span class="Li">&quot;PL_hints&quot;</span> cannot have changed since the
      precalculation.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  STORE_LC_NUMERIC_SET_TO_NEEDED_IN(bool in_lc_numeric)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;switch_to_global_locale&quot;</dt>
  <dd>On systems without locale support, or on typical single-threaded builds,
      or on platforms that do not support per-thread locale operations, this
      function does nothing. On such systems that do have locale support, only a
      locale global to the whole program is available.
    <p class="Pp">On multi-threaded builds on systems that do have per-thread
        locale operations, this function converts the thread it is running in to
        use the global locale. This is for code that has not yet or cannot be
        updated to handle multi-threaded locale operation. As long as only a
        single thread is so-converted, everything works fine, as all the other
        threads continue to ignore the global one, so only this thread looks at
        it.</p>
    <p class="Pp">However, on Windows systems this isn't quite true prior to
        Visual Studio 15, at which point Microsoft fixed a bug. A race can occur
        if you use the following operations on earlier Windows platforms:</p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="POSIX::localeconv"><a class="permalink" href="#POSIX::localeconv">POSIX::localeconv</a></dt>
  <dd></dd>
  <dt id="I18N::Langinfo,"><a class="permalink" href="#I18N::Langinfo,">I18N::Langinfo,
    items &quot;CRNCYSTR&quot; and &quot;THOUSEP&quot;</a></dt>
  <dd></dd>
  <dt>&quot;Perl_langinfo&quot; in perlapi, items &quot;CRNCYSTR&quot; and
    &quot;THOUSEP&quot;</dt>
  <dd></dd>
</dl>
</div>
<div class="Bd-indent">
<p class="Pp">The first item is not fixable (except by upgrading to a later
    Visual Studio release), but it would be possible to work around the latter
    two items by using the Windows API functions
    <span class="Li">&quot;GetNumberFormat&quot;</span> and
    <span class="Li">&quot;GetCurrencyFormat&quot;</span>; patches welcome.</p>
<p class="Pp">Without this function call, threads that use the
    <span class="Li">setlocale(3)</span> system function will not work properly,
    as all the locale-sensitive functions will look at the per-thread locale,
    and <span class="Li">&quot;setlocale&quot;</span> will have no effect on
    this thread.</p>
<p class="Pp">Perl code should convert to either call
    <span class="Li">&quot;Perl_setlocale&quot;</span> (which is a drop-in for
    the system <span class="Li">&quot;setlocale&quot;</span>) or use the methods
    given in perlcall to call
    <span class="Li">&quot;POSIX::setlocale&quot;</span>. Either one will
    transparently properly handle all cases of single- vs multi-thread, POSIX
    2008-supported or not.</p>
<p class="Pp">Non-Perl libraries, such as
    <span class="Li">&quot;gtk&quot;</span>, that call the system
    <span class="Li">&quot;setlocale&quot;</span> can continue to work if this
    function is called before transferring control to the library.</p>
<p class="Pp">Upon return from the code that needs to use the global locale,
    <span class="Li">&quot;sync_locale()&quot;</span> should be called to
    restore the safe multi-thread operation.</p>
<p class="Pp"></p>
<pre> void  switch_to_global_locale()
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;sync_locale&quot;</dt>
  <dd><span class="Li">&quot;Perl_setlocale&quot;</span> can be used at any time
      to query or change the locale (though changing the locale is antisocial
      and dangerous on multi-threaded systems that don't have multi-thread safe
      locale operations. (See &quot;Multi-threaded operation&quot; in
      perllocale). Using the system <span class="Li">setlocale(3)</span> should
      be avoided. Nevertheless, certain non-Perl libraries called from XS, such
      as <span class="Li">&quot;Gtk&quot;</span> do so, and this can't be
      changed. When the locale is changed by XS code that didn't use
      <span class="Li">&quot;Perl_setlocale&quot;</span>, Perl needs to be told
      that the locale has changed. Use this function to do so, before returning
      to Perl.
    <p class="Pp">The return value is a boolean: TRUE if the global locale at
        the time of call was in effect; and FALSE if a per-thread locale was in
        effect. This can be used by the caller that needs to restore things
        as-they-were to decide whether or not to call
        <span class="Li">&quot;Perl_switch_to_global_locale&quot;</span>.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> bool  sync_locale()
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;WITH_LC_NUMERIC_SET_TO_NEEDED&quot;</dt>
  <dd>This macro invokes the supplied statement or block within the context of a
      &quot;STORE_LC_NUMERIC_SET_TO_NEEDED&quot; ..
      &quot;RESTORE_LC_NUMERIC&quot; pair if required, so eg:
    <p class="Pp"></p>
    <pre>  WITH_LC_NUMERIC_SET_TO_NEEDED(
    SNPRINTF_G(fv, ebuf, sizeof(ebuf), precis)
  );
    </pre>
    <p class="Pp">is equivalent to:</p>
    <p class="Pp"></p>
    <pre>  {
#ifdef USE_LOCALE_NUMERIC
    DECLARATION_FOR_LC_NUMERIC_MANIPULATION;
    STORE_LC_NUMERIC_SET_TO_NEEDED();
#endif
    SNPRINTF_G(fv, ebuf, sizeof(ebuf), precis);
#ifdef USE_LOCALE_NUMERIC
    RESTORE_LC_NUMERIC();
#endif
  }
    </pre>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  WITH_LC_NUMERIC_SET_TO_NEEDED(block)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;WITH_LC_NUMERIC_SET_TO_NEEDED_IN&quot;</dt>
  <dd>Same as &quot;WITH_LC_NUMERIC_SET_TO_NEEDED&quot; with in_lc_numeric
      provided as the precalculated value of
      <span class="Li">&quot;IN_LC(LC_NUMERIC)&quot;</span>. It is the caller's
      responsibility to ensure that the status of
      <span class="Li">&quot;PL_compiling&quot;</span> and
      <span class="Li">&quot;PL_hints&quot;</span> cannot have changed since the
      precalculation.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  WITH_LC_NUMERIC_SET_TO_NEEDED_IN(bool in_lc_numeric, block)
</pre>
</div>
<div class="Bd-indent"></div>
</section>
<section class="Sh">
<h1 class="Sh" id="Magic"><a class="permalink" href="#Magic">Magic</a></h1>
<p class="Pp">&quot;Magic&quot; is special data attached to SV structures in
    order to give them &quot;magical&quot; properties. When any Perl code tries
    to read from, or assign to, an SV marked as magical, it calls the 'get' or
    'set' function associated with that SV's magic. A get is called prior to
    reading an SV, in order to give it a chance to update its internal value
    (get on $. writes the line number of the last read filehandle into the SV's
    IV slot), while set is called after an SV has been written to, in order to
    allow it to make use of its changed value (set on $/ copies the SV's new
    value to the PL_rs global variable).</p>
<p class="Pp">Magic is implemented as a linked list of MAGIC structures attached
    to the SV. Each MAGIC struct holds the type of the magic, a pointer to an
    array of functions that implement the <b>get()</b>, <b>set()</b>,
    <b>length()</b> etc functions, plus space for some flags and pointers. For
    example, a tied variable has a MAGIC structure that contains a pointer to
    the object associated with the tie.</p>
<dl class="Bl-tag">
  <dt>&quot;mg_clear&quot;</dt>
  <dd>Clear something magical that the SV represents. See
      <span class="Li">&quot;sv_magic&quot;</span>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> int  mg_clear(SV* sv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;mg_copy&quot;</dt>
  <dd>Copies the magic from one SV to another. See
      <span class="Li">&quot;sv_magic&quot;</span>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> int  mg_copy(SV *sv, SV *nsv, const char *key, I32 klen)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;mg_find&quot;</dt>
  <dd>Finds the magic pointer for <span class="Li">&quot;type&quot;</span>
      matching the SV. See <span class="Li">&quot;sv_magic&quot;</span>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> MAGIC*  mg_find(const SV* sv, int type)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;mg_findext&quot;</dt>
  <dd>Finds the magic pointer of <span class="Li">&quot;type&quot;</span> with
      the given <span class="Li">&quot;vtbl&quot;</span> for the
      <span class="Li">&quot;SV&quot;</span>. See
      <span class="Li">&quot;sv_magicext&quot;</span>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> MAGIC*  mg_findext(const SV* sv, int type, const MGVTBL *vtbl)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;mg_free&quot;</dt>
  <dd>Free any magic storage used by the SV. See
      <span class="Li">&quot;sv_magic&quot;</span>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> int  mg_free(SV* sv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;mg_freeext&quot;</dt>
  <dd>Remove any magic of type <span class="Li">&quot;how&quot;</span> using
      virtual table <span class="Li">&quot;vtbl&quot;</span> from the SV
      <span class="Li">&quot;sv&quot;</span>. See &quot;sv_magic&quot;.
    <p class="Pp"><span class="Li">&quot;mg_freeext(sv, how, NULL)&quot;</span>
        is equivalent to <span class="Li">&quot;mg_free_type(sv,
        how)&quot;</span>.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  mg_freeext(SV* sv, int how, const MGVTBL *vtbl)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;mg_free_type&quot;</dt>
  <dd>Remove any magic of type <span class="Li">&quot;how&quot;</span> from the
      SV <span class="Li">&quot;sv&quot;</span>. See &quot;sv_magic&quot;.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  mg_free_type(SV* sv, int how)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;mg_get&quot;</dt>
  <dd>Do magic before a value is retrieved from the SV. The type of SV must be
      &gt;= <span class="Li">&quot;SVt_PVMG&quot;</span>. See
      <span class="Li">&quot;sv_magic&quot;</span>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> int  mg_get(SV* sv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;mg_length&quot;</dt>
  <dd><span class="Li">&quot;</span><span class="Li"><b>DEPRECATED!</b></span><span class="Li">&quot;</span>
      It is planned to remove <span class="Li">&quot;mg_length&quot;</span> from
      a future release of Perl. Do not use it for new code; remove it from
      existing code.
    <p class="Pp">Reports on the SV's length in bytes, calling length magic if
        available, but does not set the UTF8 flag on
        <span class="Li">&quot;sv&quot;</span>. It will fall back to 'get' magic
        if there is no 'length' magic, but with no indication as to whether it
        called 'get' magic. It assumes <span class="Li">&quot;sv&quot;</span> is
        a <span class="Li">&quot;PVMG&quot;</span> or higher. Use
        <span class="Li">&quot;sv_len()&quot;</span> instead.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> U32  mg_length(SV* sv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;mg_magical&quot;</dt>
  <dd>Turns on the magical status of an SV. See
      <span class="Li">&quot;sv_magic&quot;</span>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  mg_magical(SV* sv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;mg_set&quot;</dt>
  <dd>Do magic after a value is assigned to the SV. See
      <span class="Li">&quot;sv_magic&quot;</span>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> int  mg_set(SV* sv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;SvTIED_obj&quot;</dt>
  <dd>Described in perlinterp.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre>   SvTIED_obj(SV *sv, MAGIC *mg)
</pre>
</div>
<div class="Bd-indent"></div>
</section>
<section class="Sh">
<h1 class="Sh" id="Memory_Management"><a class="permalink" href="#Memory_Management">Memory
  Management</a></h1>
<dl class="Bl-tag">
  <dt>&quot;HASATTRIBUTE_MALLOC&quot;</dt>
  <dd>Can we handle <span class="Li">&quot;GCC&quot;</span> attribute for
      malloc-style functions.</dd>
  <dt>&quot;HAS_MALLOC_GOOD_SIZE&quot;</dt>
  <dd>This symbol, if defined, indicates that the
      <span class="Li">&quot;malloc_good_size&quot;</span> routine is available
      for use.</dd>
  <dt>&quot;HAS_MALLOC_SIZE&quot;</dt>
  <dd>This symbol, if defined, indicates that the
      <span class="Li">&quot;malloc_size&quot;</span> routine is available for
      use.</dd>
  <dt>&quot;I_MALLOCMALLOC&quot;</dt>
  <dd>This symbol, if defined, indicates to the C program that it should include
      <i>malloc/malloc.h</i>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> #ifdef I_MALLOCMALLOC
     #include &lt;mallocmalloc.h&gt;
 #endif
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;MYMALLOC&quot;</dt>
  <dd>This symbol, if defined, indicates that we're using our own malloc.</dd>
  <dt>&quot;Newx&quot;</dt>
  <dd>The XSUB-writer's interface to the C
      <span class="Li">&quot;malloc&quot;</span> function.
    <p class="Pp">Memory obtained by this should <b>ONLY</b> be freed with
        &quot;Safefree&quot;.</p>
    <p class="Pp">In 5.9.3, <b>Newx()</b> and friends replace the older
        <b>New()</b> API, and drops the first parameter, <i>x</i>, a debug aid
        which allowed callers to identify themselves. This aid has been
        superseded by a new build option, PERL_MEM_LOG (see
        &quot;PERL_MEM_LOG&quot; in perlhacktips). The older API is still there
        for use in XS modules supporting older perls.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  Newx(void* ptr, int nitems, type)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;Newxc&quot;</dt>
  <dd>The XSUB-writer's interface to the C
      <span class="Li">&quot;malloc&quot;</span> function, with cast. See also
      <span class="Li">&quot;Newx&quot;</span>.
    <p class="Pp">Memory obtained by this should <b>ONLY</b> be freed with
        &quot;Safefree&quot;.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  Newxc(void* ptr, int nitems, type, cast)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;Newxz&quot;</dt>
  <dd>The XSUB-writer's interface to the C
      <span class="Li">&quot;malloc&quot;</span> function. The allocated memory
      is zeroed with <span class="Li">&quot;memzero&quot;</span>. See also
      <span class="Li">&quot;Newx&quot;</span>.
    <p class="Pp">Memory obtained by this should <b>ONLY</b> be freed with
        &quot;Safefree&quot;.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  Newxz(void* ptr, int nitems, type)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;PERL_MALLOC_WRAP&quot;</dt>
  <dd>This symbol, if defined, indicates that we'd like malloc wrap checks.</dd>
  <dt>&quot;Renew&quot;</dt>
  <dd>The XSUB-writer's interface to the C
      <span class="Li">&quot;realloc&quot;</span> function.
    <p class="Pp">Memory obtained by this should <b>ONLY</b> be freed with
        &quot;Safefree&quot;.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  Renew(void* ptr, int nitems, type)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;Renewc&quot;</dt>
  <dd>The XSUB-writer's interface to the C
      <span class="Li">&quot;realloc&quot;</span> function, with cast.
    <p class="Pp">Memory obtained by this should <b>ONLY</b> be freed with
        &quot;Safefree&quot;.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  Renewc(void* ptr, int nitems, type, cast)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;Safefree&quot;</dt>
  <dd>The XSUB-writer's interface to the C
      <span class="Li">&quot;free&quot;</span> function.
    <p class="Pp">This should <b>ONLY</b> be used on memory obtained using
        &quot;Newx&quot; and friends.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  Safefree(void* ptr)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;safesyscalloc&quot;</dt>
  <dd>Safe version of system's <b>calloc()</b></dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> Malloc_t  safesyscalloc(MEM_SIZE elements, MEM_SIZE size)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;safesysfree&quot;</dt>
  <dd>Safe version of system's <b>free()</b></dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> Free_t  safesysfree(Malloc_t where)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;safesysmalloc&quot;</dt>
  <dd>Paranoid version of system's <b>malloc()</b></dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> Malloc_t  safesysmalloc(MEM_SIZE nbytes)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;safesysrealloc&quot;</dt>
  <dd>Paranoid version of system's <b>realloc()</b></dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> Malloc_t  safesysrealloc(Malloc_t where, MEM_SIZE nbytes)
</pre>
</div>
<div class="Bd-indent"></div>
</section>
<section class="Sh">
<h1 class="Sh" id="MRO"><a class="permalink" href="#MRO">MRO</a></h1>
<p class="Pp">These functions are related to the method resolution order of perl
    classes Also see perlmroapi.</p>
<dl class="Bl-tag">
  <dt>&quot;HvMROMETA&quot;</dt>
  <dd>Described in perlmroapi.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> struct mro_meta *  HvMROMETA(HV *hv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;mro_get_linear_isa&quot;</dt>
  <dd>Returns the mro linearisation for the given stash. By default, this will
      be whatever <span class="Li">&quot;mro_get_linear_isa_dfs&quot;</span>
      returns unless some other MRO is in effect for the stash. The return value
      is a read-only AV*.
    <p class="Pp">You are responsible for
        <span class="Li">&quot;SvREFCNT_inc()&quot;</span> on the return value
        if you plan to store it anywhere semi-permanently (otherwise it might be
        deleted out from under you the next time the cache is invalidated).</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> AV*  mro_get_linear_isa(HV* stash)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;MRO_GET_PRIVATE_DATA&quot;</dt>
  <dd>Described in perlmroapi.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> SV*  MRO_GET_PRIVATE_DATA(struct mro_meta *const smeta,
                           const struct mro_alg *const which)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;mro_method_changed_in&quot;</dt>
  <dd>Invalidates method caching on any child classes of the given stash, so
      that they might notice the changes in this one.
    <p class="Pp">Ideally, all instances of
        <span class="Li">&quot;PL_sub_generation++&quot;</span> in perl source
        outside of <i>mro.c</i> should be replaced by calls to this.</p>
    <p class="Pp">Perl automatically handles most of the common ways a method
        might be redefined. However, there are a few ways you could change a
        method in a stash without the cache code noticing, in which case you
        need to call this method afterwards:</p>
    <p class="Pp">1) Directly manipulating the stash HV entries from XS
      code.</p>
    <p class="Pp">2) Assigning a reference to a readonly scalar constant into a
        stash entry in order to create a constant subroutine (like
        <i>constant.pm</i> does).</p>
    <p class="Pp">This same method is available from pure perl via,
        <span class="Li">&quot;mro::method_changed_in(classname)&quot;</span>.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  mro_method_changed_in(HV* stash)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;mro_register&quot;</dt>
  <dd>Registers a custom mro plugin. See perlmroapi for details on this and
      other mro functions.
    <p class="Pp">NOTE: <span class="Li">&quot;mro_register&quot;</span> must be
        explicitly called as
        <span class="Li">&quot;Perl_mro_register&quot;</span> with an
        <span class="Li">&quot;aTHX_&quot;</span> parameter.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  Perl_mro_register(pTHX_ const struct mro_alg *mro)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;mro_set_private_data&quot;</dt>
  <dd>Described in perlmroapi.
    <p class="Pp">NOTE: <span class="Li">&quot;mro_set_private_data&quot;</span>
        must be explicitly called as
        <span class="Li">&quot;Perl_mro_set_private_data&quot;</span> with an
        <span class="Li">&quot;aTHX_&quot;</span> parameter.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> SV*  Perl_mro_set_private_data(pTHX_
                                struct mro_meta *const smeta,
                                const struct mro_alg *const which,
                                SV *const data)
</pre>
</div>
<div class="Bd-indent"></div>
</section>
<section class="Sh">
<h1 class="Sh" id="Multicall_Functions"><a class="permalink" href="#Multicall_Functions">Multicall
  Functions</a></h1>
<dl class="Bl-tag">
  <dt>&quot;dMULTICALL&quot;</dt>
  <dd>Declare local variables for a multicall. See &quot;LIGHTWEIGHT
      CALLBACKS&quot; in perlcall.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre>   dMULTICALL;
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;MULTICALL&quot;</dt>
  <dd>Make a lightweight callback. See &quot;LIGHTWEIGHT CALLBACKS&quot; in
      perlcall.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre>   MULTICALL;
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;POP_MULTICALL&quot;</dt>
  <dd>Closing bracket for a lightweight callback. See &quot;LIGHTWEIGHT
      CALLBACKS&quot; in perlcall.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre>   POP_MULTICALL;
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;PUSH_MULTICALL&quot;</dt>
  <dd>Opening bracket for a lightweight callback. See &quot;LIGHTWEIGHT
      CALLBACKS&quot; in perlcall.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre>   PUSH_MULTICALL(CV* the_cv);
</pre>
</div>
<div class="Bd-indent"></div>
</section>
<section class="Sh">
<h1 class="Sh" id="Numeric_Functions"><a class="permalink" href="#Numeric_Functions">Numeric
  Functions</a></h1>
<dl class="Bl-tag">
  <dt>&quot;Drand01&quot;</dt>
  <dd>This macro is to be used to generate uniformly distributed random numbers
      over the range [0., 1.[. You may have to supply an 'extern double
      <span class="Li">&quot;drand48()&quot;</span>;' in your program since
      SunOS 4.1.3 doesn't provide you with anything relevant in its headers. See
      <span class="Li">&quot;HAS_DRAND48_PROTO&quot;</span>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> double  Drand01()
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;Gconvert&quot;</dt>
  <dd>This preprocessor macro is defined to convert a floating point number to a
      string without a trailing decimal point. This emulates the behavior of
      <span class="Li">&quot;sprintf(&quot;%g&quot;)&quot;</span>, but is
      sometimes much more efficient. If
      <span class="Li">&quot;gconvert()&quot;</span> is not available, but
      <span class="Li">&quot;gcvt()&quot;</span> drops the trailing decimal
      point, then <span class="Li">&quot;gcvt()&quot;</span> is used. If all
      else fails, a macro using
      <span class="Li">&quot;sprintf(&quot;%g&quot;)&quot;</span> is used.
      Arguments for the Gconvert macro are: value, number of digits, whether
      trailing zeros should be retained, and the output buffer. The usual values
      are:
    <p class="Pp"></p>
    <pre> d_Gconvert='gconvert((x),(n),(t),(b))'
 d_Gconvert='gcvt((x),(n),(b))'
 d_Gconvert='sprintf((b),&quot;%.*g&quot;,(n),(x))'
    </pre>
    <p class="Pp">The last two assume trailing zeros should not be kept.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> char *  Gconvert(double x, Size_t n, bool t, char * b)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;grok_bin&quot;</dt>
  <dd>converts a string representing a binary number to numeric form.
    <p class="Pp">On entry <span class="Li">&quot;start&quot;</span> and
        <span class="Li">*len_p</span> give the string to scan,
        <span class="Li">*flags</span> gives conversion flags, and
        <span class="Li">&quot;result&quot;</span> should be
        <span class="Li">&quot;NULL&quot;</span> or a pointer to an NV. The scan
        stops at the end of the string, or at just before the first invalid
        character. Unless
        <span class="Li">&quot;PERL_SCAN_SILENT_ILLDIGIT&quot;</span> is set in
        <span class="Li">*flags</span>, encountering an invalid character
        (except NUL) will also trigger a warning. On return
        <span class="Li">*len_p</span> is set to the length of the scanned
        string, and <span class="Li">*flags</span> gives output flags.</p>
    <p class="Pp">If the value is &lt;=
        <span class="Li">&quot;UV_MAX&quot;</span> it is returned as a UV, the
        output flags are clear, and nothing is written to
        <span class="Li">*result</span>. If the value is &gt;
        <span class="Li">&quot;UV_MAX&quot;</span>,
        <span class="Li">&quot;grok_bin&quot;</span> returns
        <span class="Li">&quot;UV_MAX&quot;</span>, sets
        <span class="Li">&quot;PERL_SCAN_GREATER_THAN_UV_MAX&quot;</span> in the
        output flags, and writes an approximation of the correct value into
        <span class="Li">*result</span> (which is an NV; or the approximation is
        discarded if <span class="Li">&quot;result&quot;</span> is NULL).</p>
    <p class="Pp">The binary number may optionally be prefixed with
        <span class="Li">&quot;0b&quot;</span> or
        <span class="Li">&quot;b&quot;</span> unless
        <span class="Li">&quot;PERL_SCAN_DISALLOW_PREFIX&quot;</span> is set in
        <span class="Li">*flags</span> on entry.</p>
    <p class="Pp">If
        <span class="Li">&quot;PERL_SCAN_ALLOW_UNDERSCORES&quot;</span> is set
        in <span class="Li">*flags</span> then any or all pairs of digits may be
        separated from each other by a single underscore; also a single leading
        underscore is accepted.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> UV  grok_bin(const char* start, STRLEN* len_p, I32* flags,
              NV *result)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;grok_hex&quot;</dt>
  <dd>converts a string representing a hex number to numeric form.
    <p class="Pp">On entry <span class="Li">&quot;start&quot;</span> and
        <span class="Li">*len_p</span> give the string to scan,
        <span class="Li">*flags</span> gives conversion flags, and
        <span class="Li">&quot;result&quot;</span> should be
        <span class="Li">&quot;NULL&quot;</span> or a pointer to an NV. The scan
        stops at the end of the string, or at just before the first invalid
        character. Unless
        <span class="Li">&quot;PERL_SCAN_SILENT_ILLDIGIT&quot;</span> is set in
        <span class="Li">*flags</span>, encountering an invalid character
        (except NUL) will also trigger a warning. On return
        <span class="Li">*len_p</span> is set to the length of the scanned
        string, and <span class="Li">*flags</span> gives output flags.</p>
    <p class="Pp">If the value is &lt;=
        <span class="Li">&quot;UV_MAX&quot;</span> it is returned as a UV, the
        output flags are clear, and nothing is written to
        <span class="Li">*result</span>. If the value is &gt;
        <span class="Li">&quot;UV_MAX&quot;</span>,
        <span class="Li">&quot;grok_hex&quot;</span> returns
        <span class="Li">&quot;UV_MAX&quot;</span>, sets
        <span class="Li">&quot;PERL_SCAN_GREATER_THAN_UV_MAX&quot;</span> in the
        output flags, and writes an approximation of the correct value into
        <span class="Li">*result</span> (which is an NV; or the approximation is
        discarded if <span class="Li">&quot;result&quot;</span> is NULL).</p>
    <p class="Pp">The hex number may optionally be prefixed with
        <span class="Li">&quot;0x&quot;</span> or
        <span class="Li">&quot;x&quot;</span> unless
        <span class="Li">&quot;PERL_SCAN_DISALLOW_PREFIX&quot;</span> is set in
        <span class="Li">*flags</span> on entry.</p>
    <p class="Pp">If
        <span class="Li">&quot;PERL_SCAN_ALLOW_UNDERSCORES&quot;</span> is set
        in <span class="Li">*flags</span> then any or all pairs of digits may be
        separated from each other by a single underscore; also a single leading
        underscore is accepted.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> UV  grok_hex(const char* start, STRLEN* len_p, I32* flags,
              NV *result)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;grok_infnan&quot;</dt>
  <dd>Helper for <span class="Li">&quot;grok_number()&quot;</span>, accepts
      various ways of spelling &quot;infinity&quot; or &quot;not a number&quot;,
      and returns one of the following flag combinations:
    <p class="Pp"></p>
    <pre>  IS_NUMBER_INFINITY
  IS_NUMBER_NAN
  IS_NUMBER_INFINITY | IS_NUMBER_NEG
  IS_NUMBER_NAN | IS_NUMBER_NEG
  0
    </pre>
    <p class="Pp">possibly |-ed with
        <span class="Li">&quot;IS_NUMBER_TRAILING&quot;</span>.</p>
    <p class="Pp">If an infinity or a not-a-number is recognized,
        <span class="Li">*sp</span> will point to one byte past the end of the
        recognized string. If the recognition fails, zero is returned, and
        <span class="Li">*sp</span> will not move.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> int  grok_infnan(const char** sp, const char *send)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;grok_number&quot;</dt>
  <dd>Identical to <span class="Li">&quot;grok_number_flags()&quot;</span> with
      <span class="Li">&quot;flags&quot;</span> set to zero.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> int  grok_number(const char *pv, STRLEN len, UV *valuep)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;grok_number_flags&quot;</dt>
  <dd>Recognise (or not) a number. The type of the number is returned (0 if
      unrecognised), otherwise it is a bit-ORed combination of
      <span class="Li">&quot;IS_NUMBER_IN_UV&quot;</span>,
      <span class="Li">&quot;IS_NUMBER_GREATER_THAN_UV_MAX&quot;</span>,
      <span class="Li">&quot;IS_NUMBER_NOT_INT&quot;</span>,
      <span class="Li">&quot;IS_NUMBER_NEG&quot;</span>,
      <span class="Li">&quot;IS_NUMBER_INFINITY&quot;</span>,
      <span class="Li">&quot;IS_NUMBER_NAN&quot;</span> (defined in perl.h).
    <p class="Pp">If the value of the number can fit in a UV, it is returned in
        <span class="Li">*valuep</span>.
        <span class="Li">&quot;IS_NUMBER_IN_UV&quot;</span> will be set to
        indicate that <span class="Li">*valuep</span> is valid,
        <span class="Li">&quot;IS_NUMBER_IN_UV&quot;</span> will never be set
        unless <span class="Li">*valuep</span> is valid, but
        <span class="Li">*valuep</span> may have been assigned to during
        processing even though
        <span class="Li">&quot;IS_NUMBER_IN_UV&quot;</span> is not set on
        return. If <span class="Li">&quot;valuep&quot;</span> is
        <span class="Li">&quot;NULL&quot;</span>,
        <span class="Li">&quot;IS_NUMBER_IN_UV&quot;</span> will be set for the
        same cases as when <span class="Li">&quot;valuep&quot;</span> is
        non-<span class="Li">&quot;NULL&quot;</span>, but no actual assignment
        (or SEGV) will occur.</p>
    <p class="Pp"><span class="Li">&quot;IS_NUMBER_NOT_INT&quot;</span> will be
        set with <span class="Li">&quot;IS_NUMBER_IN_UV&quot;</span> if trailing
        decimals were seen (in which case <span class="Li">*valuep</span> gives
        the true value truncated to an integer), and
        <span class="Li">&quot;IS_NUMBER_NEG&quot;</span> if the number is
        negative (in which case <span class="Li">*valuep</span> holds the
        absolute value). <span class="Li">&quot;IS_NUMBER_IN_UV&quot;</span> is
        not set if <span class="Li">&quot;e&quot;</span> notation was used or
        the number is larger than a UV.</p>
    <p class="Pp"><span class="Li">&quot;flags&quot;</span> allows only
        <span class="Li">&quot;PERL_SCAN_TRAILING&quot;</span>, which allows for
        trailing non-numeric text on an otherwise successful <i>grok</i>,
        setting <span class="Li">&quot;IS_NUMBER_TRAILING&quot;</span> on the
        result.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> int  grok_number_flags(const char *pv, STRLEN len, UV *valuep,
                        U32 flags)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;GROK_NUMERIC_RADIX&quot;</dt>
  <dd>A synonym for &quot;grok_numeric_radix&quot;</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> bool  GROK_NUMERIC_RADIX(NN const char **sp, NN const char *send)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;grok_numeric_radix&quot;</dt>
  <dd>Scan and skip for a numeric decimal separator (radix).</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> bool  grok_numeric_radix(const char **sp, const char *send)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;grok_oct&quot;</dt>
  <dd>converts a string representing an octal number to numeric form.
    <p class="Pp">On entry <span class="Li">&quot;start&quot;</span> and
        <span class="Li">*len_p</span> give the string to scan,
        <span class="Li">*flags</span> gives conversion flags, and
        <span class="Li">&quot;result&quot;</span> should be
        <span class="Li">&quot;NULL&quot;</span> or a pointer to an NV. The scan
        stops at the end of the string, or at just before the first invalid
        character. Unless
        <span class="Li">&quot;PERL_SCAN_SILENT_ILLDIGIT&quot;</span> is set in
        <span class="Li">*flags</span>, encountering an invalid character
        (except NUL) will also trigger a warning. On return
        <span class="Li">*len_p</span> is set to the length of the scanned
        string, and <span class="Li">*flags</span> gives output flags.</p>
    <p class="Pp">If the value is &lt;=
        <span class="Li">&quot;UV_MAX&quot;</span> it is returned as a UV, the
        output flags are clear, and nothing is written to
        <span class="Li">*result</span>. If the value is &gt;
        <span class="Li">&quot;UV_MAX&quot;</span>,
        <span class="Li">&quot;grok_oct&quot;</span> returns
        <span class="Li">&quot;UV_MAX&quot;</span>, sets
        <span class="Li">&quot;PERL_SCAN_GREATER_THAN_UV_MAX&quot;</span> in the
        output flags, and writes an approximation of the correct value into
        <span class="Li">*result</span> (which is an NV; or the approximation is
        discarded if <span class="Li">&quot;result&quot;</span> is NULL).</p>
    <p class="Pp">If
        <span class="Li">&quot;PERL_SCAN_ALLOW_UNDERSCORES&quot;</span> is set
        in <span class="Li">*flags</span> then any or all pairs of digits may be
        separated from each other by a single underscore; also a single leading
        underscore is accepted.</p>
    <p class="Pp">The
        <span class="Li">&quot;PERL_SCAN_DISALLOW_PREFIX&quot;</span> flag is
        always treated as being set for this function.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> UV  grok_oct(const char* start, STRLEN* len_p, I32* flags,
              NV *result)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;isinfnan&quot;</dt>
  <dd><span class="Li">&quot;Perl_isinfnan()&quot;</span> is a utility function
      that returns true if the NV argument is either an infinity or a
      <span class="Li">&quot;NaN&quot;</span>, false otherwise. To test in more
      detail, use <span class="Li">&quot;Perl_isinf()&quot;</span> and
      <span class="Li">&quot;Perl_isnan()&quot;</span>.
    <p class="Pp">This is also the logical inverse of
      <b>Perl_isfinite()</b>.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> bool  isinfnan(NV nv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;my_atof&quot;</dt>
  <dd><span class="Li">&quot;atof&quot;</span>(3), but properly works with Perl
      locale handling, accepting a dot radix character always, but also the
      current locale's radix character if and only if called from within the
      lexical scope of a Perl <span class="Li">&quot;use locale&quot;</span>
      statement.
    <p class="Pp">N.B. <span class="Li">&quot;s&quot;</span> must be NUL
        terminated.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> NV  my_atof(const char *s)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;my_strtod&quot;</dt>
  <dd>This function is equivalent to the libc <b>strtod()</b> function, and is
      available even on platforms that lack plain <b>strtod()</b>. Its return
      value is the best available precision depending on platform capabilities
      and <i>Configure</i> options.
    <p class="Pp">It properly handles the locale radix character, meaning it
        expects a dot except when called from within the scope of
        <span class="Li">&quot;use&#x00A0;locale&quot;</span>, in which case the
        radix character should be that specified by the current locale.</p>
    <p class="Pp">The synonym <b>Strtod()</b> may be used instead.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> NV  my_strtod(const char * const s, char ** e)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;PERL_ABS&quot;</dt>
  <dd>Typeless <span class="Li">&quot;abs&quot;</span> or
      <span class="Li">&quot;fabs&quot;</span>, <i>etc</i>. (The usage below
      indicates it is for integers, but it works for any type.) Use instead of
      these, since the C library ones force their argument to be what it is
      expecting, potentially leading to disaster. But also beware that this
      evaluates its argument twice, so no
      <span class="Li">&quot;x++&quot;</span>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> int  PERL_ABS(int x)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;Perl_acos&quot;</dt>
  <dd></dd>
  <dt>&quot;Perl_asin&quot;</dt>
  <dd></dd>
  <dt>&quot;Perl_atan&quot;</dt>
  <dd></dd>
  <dt>&quot;Perl_atan2&quot;</dt>
  <dd></dd>
  <dt>&quot;Perl_ceil&quot;</dt>
  <dd></dd>
  <dt>&quot;Perl_cos&quot;</dt>
  <dd></dd>
  <dt>&quot;Perl_cosh&quot;</dt>
  <dd></dd>
  <dt>&quot;Perl_exp&quot;</dt>
  <dd></dd>
  <dt>&quot;Perl_floor&quot;</dt>
  <dd></dd>
  <dt>&quot;Perl_fmod&quot;</dt>
  <dd></dd>
  <dt>&quot;Perl_frexp&quot;</dt>
  <dd></dd>
  <dt>&quot;Perl_isfinite&quot;</dt>
  <dd></dd>
  <dt>&quot;Perl_isinf&quot;</dt>
  <dd></dd>
  <dt>&quot;Perl_isnan&quot;</dt>
  <dd></dd>
  <dt>&quot;Perl_ldexp&quot;</dt>
  <dd></dd>
  <dt>&quot;Perl_log&quot;</dt>
  <dd></dd>
  <dt>&quot;Perl_log10&quot;</dt>
  <dd></dd>
  <dt>&quot;Perl_modf&quot;</dt>
  <dd></dd>
  <dt>&quot;Perl_pow&quot;</dt>
  <dd></dd>
  <dt>&quot;Perl_sin&quot;</dt>
  <dd></dd>
  <dt>&quot;Perl_sinh&quot;</dt>
  <dd></dd>
  <dt>&quot;Perl_sqrt&quot;</dt>
  <dd></dd>
  <dt>&quot;Perl_tan&quot;</dt>
  <dd></dd>
  <dt>&quot;Perl_tanh&quot;</dt>
  <dd>These perform the corresponding mathematical operation on the operand(s),
      using the libc function designed for the task that has just enough
      precision for an NV on this platform. If no such function with sufficient
      precision exists, the highest precision one available is used.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> NV  Perl_acos    (NV x)
 NV  Perl_asin    (NV x)
 NV  Perl_atan    (NV x)
 NV  Perl_atan2   (NV x, NV y)
 NV  Perl_ceil    (NV x)
 NV  Perl_cos     (NV x)
 NV  Perl_cosh    (NV x)
 NV  Perl_exp     (NV x)
 NV  Perl_floor   (NV x)
 NV  Perl_fmod    (NV x, NV y)
 NV  Perl_frexp   (NV x, int *exp)
 IV  Perl_isfinite(NV x)
 IV  Perl_isinf   (NV x)
 IV  Perl_isnan   (NV x)
 NV  Perl_ldexp   (NV x, int exp)
 NV  Perl_log     (NV x)
 NV  Perl_log10   (NV x)
 NV  Perl_modf    (NV x, NV *iptr)
 NV  Perl_pow     (NV x, NV y)
 NV  Perl_sin     (NV x)
 NV  Perl_sinh    (NV x)
 NV  Perl_sqrt    (NV x)
 NV  Perl_tan     (NV x)
 NV  Perl_tanh    (NV x)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;Perl_signbit&quot;</dt>
  <dd>NOTE: <span class="Li">&quot;Perl_signbit&quot;</span> is
      <b>experimental</b> and may change or be removed without notice.
    <p class="Pp">Return a non-zero integer if the sign bit on an NV is set, and
        0 if it is not.</p>
    <p class="Pp">If <i>Configure</i> detects this system has a
        <span class="Li">&quot;signbit()&quot;</span> that will work with our
        NVs, then we just use it via the
        <span class="Li">&quot;#define&quot;</span> in <i>perl.h</i>. Otherwise,
        fall back on this implementation. The main use of this function is
        catching <span class="Li">&quot;-0.0&quot;</span>.</p>
    <p class="Pp"><span class="Li">&quot;Configure&quot;</span> notes: This
        function is called <span class="Li">'Perl_signbit'</span> instead of a
        plain <span class="Li">'signbit'</span> because it is easy to imagine a
        system having a <span class="Li">&quot;signbit()&quot;</span> function
        or macro that doesn't happen to work with our particular choice of NVs.
        We shouldn't just re-<span class="Li">&quot;#define&quot;</span>
        <span class="Li">&quot;signbit&quot;</span> as
        <span class="Li">&quot;Perl_signbit&quot;</span> and expect the standard
        system headers to be happy. Also, this is a no-context function (no
        <span class="Li">&quot;pTHX_&quot;</span>) because
        <span class="Li">&quot;Perl_signbit()&quot;</span> is usually
        re-<span class="Li">&quot;#defined&quot;</span> in <i>perl.h</i> as a
        simple macro call to the system's
        <span class="Li">&quot;signbit()&quot;</span>. Users should just always
        call <span class="Li">&quot;Perl_signbit()&quot;</span>.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> int  Perl_signbit(NV f)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;PL_hexdigit&quot;</dt>
  <dd>This array, indexed by an integer, converts that value into the character
      that represents it. For example, if the input is 8, the return will be a
      string whose first character is '8'. What is actually returned is a
      pointer into a string. All you are interested in is the first character of
      that string. To get uppercase letters (for the values 10..15), add 16 to
      the index. Hence, <span class="Li">&quot;PL_hexdigit[11]&quot;</span> is
      <span class="Li">'b'</span>, and
      <span class="Li">&quot;PL_hexdigit[11+16]&quot;</span> is
      <span class="Li">'B'</span>. Adding 16 to an index whose representation is
      '0'..'9' yields the same as not adding 16. Indices outside the range 0..31
      result in (bad) undedefined behavior.</dd>
  <dt>&quot;READ_XDIGIT&quot;</dt>
  <dd>Returns the value of an ASCII-range hex digit and advances the string
      pointer. Behaviour is only well defined when isXDIGIT(*str) is true.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> U8  READ_XDIGIT(char str*)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;scan_bin&quot;</dt>
  <dd>For backwards compatibility. Use
      <span class="Li">&quot;grok_bin&quot;</span> instead.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> NV  scan_bin(const char* start, STRLEN len, STRLEN* retlen)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;scan_hex&quot;</dt>
  <dd>For backwards compatibility. Use
      <span class="Li">&quot;grok_hex&quot;</span> instead.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> NV  scan_hex(const char* start, STRLEN len, STRLEN* retlen)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;scan_oct&quot;</dt>
  <dd>For backwards compatibility. Use
      <span class="Li">&quot;grok_oct&quot;</span> instead.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> NV  scan_oct(const char* start, STRLEN len, STRLEN* retlen)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;seedDrand01&quot;</dt>
  <dd>This symbol defines the macro to be used in seeding the random number
      generator (see <span class="Li">&quot;Drand01&quot;</span>).</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  seedDrand01(Rand_seed_t x)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;Strtod&quot;</dt>
  <dd>This is a synonym for &quot;my_strtod&quot;.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> NV  Strtod(NN const char * const s, NULLOK char ** e)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;Strtol&quot;</dt>
  <dd>Platform and configuration independent
      <span class="Li">&quot;strtol&quot;</span>. This expands to the
      appropriate <span class="Li">&quot;strotol&quot;</span>-like function
      based on the platform and <i>Configure</i> options&gt;. For example it
      could expand to <span class="Li">&quot;strtoll&quot;</span> or
      <span class="Li">&quot;strtoq&quot;</span> instead of
      <span class="Li">&quot;strtol&quot;</span>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> NV  Strtol(NN const char * const s, NULLOK char ** e, int base)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;Strtoul&quot;</dt>
  <dd>Platform and configuration independent
      <span class="Li">&quot;strtoul&quot;</span>. This expands to the
      appropriate <span class="Li">&quot;strotoul&quot;</span>-like function
      based on the platform and <i>Configure</i> options&gt;. For example it
      could expand to <span class="Li">&quot;strtoull&quot;</span> or
      <span class="Li">&quot;strtouq&quot;</span> instead of
      <span class="Li">&quot;strtoul&quot;</span>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> NV  Strtoul(NN const char * const s, NULLOK char ** e, int base)
</pre>
</div>
<div class="Bd-indent"></div>
</section>
<section class="Sh">
<h1 class="Sh" id="Optree_construction"><a class="permalink" href="#Optree_construction">Optree
  construction</a></h1>
<dl class="Bl-tag">
  <dt>&quot;newASSIGNOP&quot;</dt>
  <dd>Constructs, checks, and returns an assignment op.
      <span class="Li">&quot;left&quot;</span> and
      <span class="Li">&quot;right&quot;</span> supply the parameters of the
      assignment; they are consumed by this function and become part of the
      constructed op tree.
    <p class="Pp">If <span class="Li">&quot;optype&quot;</span> is
        <span class="Li">&quot;OP_ANDASSIGN&quot;</span>,
        <span class="Li">&quot;OP_ORASSIGN&quot;</span>, or
        <span class="Li">&quot;OP_DORASSIGN&quot;</span>, then a suitable
        conditional optree is constructed. If
        <span class="Li">&quot;optype&quot;</span> is the opcode of a binary
        operator, such as <span class="Li">&quot;OP_BIT_OR&quot;</span>, then an
        op is constructed that performs the binary operation and assigns the
        result to the left argument. Either way, if
        <span class="Li">&quot;optype&quot;</span> is non-zero then
        <span class="Li">&quot;flags&quot;</span> has no effect.</p>
    <p class="Pp">If <span class="Li">&quot;optype&quot;</span> is zero, then a
        plain scalar or list assignment is constructed. Which type of assignment
        it is is automatically determined.
        <span class="Li">&quot;flags&quot;</span> gives the eight bits of
        <span class="Li">&quot;op_flags&quot;</span>, except that
        <span class="Li">&quot;OPf_KIDS&quot;</span> will be set automatically,
        and, shifted up eight bits, the eight bits of
        <span class="Li">&quot;op_private&quot;</span>, except that the bit with
        value 1 or 2 is automatically set as required.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> OP*  newASSIGNOP(I32 flags, OP* left, I32 optype, OP* right)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;newBINOP&quot;</dt>
  <dd>Constructs, checks, and returns an op of any binary type.
      <span class="Li">&quot;type&quot;</span> is the opcode.
      <span class="Li">&quot;flags&quot;</span> gives the eight bits of
      <span class="Li">&quot;op_flags&quot;</span>, except that
      <span class="Li">&quot;OPf_KIDS&quot;</span> will be set automatically,
      and, shifted up eight bits, the eight bits of
      <span class="Li">&quot;op_private&quot;</span>, except that the bit with
      value 1 or 2 is automatically set as required.
      <span class="Li">&quot;first&quot;</span> and
      <span class="Li">&quot;last&quot;</span> supply up to two ops to be the
      direct children of the binary op; they are consumed by this function and
      become part of the constructed op tree.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> OP*  newBINOP(I32 type, I32 flags, OP* first, OP* last)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;newCONDOP&quot;</dt>
  <dd>Constructs, checks, and returns a conditional-expression
      (<span class="Li">&quot;cond_expr&quot;</span>) op.
      <span class="Li">&quot;flags&quot;</span> gives the eight bits of
      <span class="Li">&quot;op_flags&quot;</span>, except that
      <span class="Li">&quot;OPf_KIDS&quot;</span> will be set automatically,
      and, shifted up eight bits, the eight bits of
      <span class="Li">&quot;op_private&quot;</span>, except that the bit with
      value 1 is automatically set. <span class="Li">&quot;first&quot;</span>
      supplies the expression selecting between the two branches, and
      <span class="Li">&quot;trueop&quot;</span> and
      <span class="Li">&quot;falseop&quot;</span> supply the branches; they are
      consumed by this function and become part of the constructed op tree.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> OP*  newCONDOP(I32 flags, OP* first, OP* trueop, OP* falseop)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;newDEFSVOP&quot;</dt>
  <dd>Constructs and returns an op to access <span class="Li">$_</span>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> OP*  newDEFSVOP()
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;newFOROP&quot;</dt>
  <dd>Constructs, checks, and returns an op tree expressing a
      <span class="Li">&quot;foreach&quot;</span> loop (iteration through a list
      of values). This is a heavyweight loop, with structure that allows exiting
      the loop by <span class="Li">&quot;last&quot;</span> and suchlike.
    <p class="Pp"><span class="Li">&quot;sv&quot;</span> optionally supplies the
        variable that will be aliased to each item in turn; if null, it defaults
        to <span class="Li">$_</span>. <span class="Li">&quot;expr&quot;</span>
        supplies the list of values to iterate over.
        <span class="Li">&quot;block&quot;</span> supplies the main body of the
        loop, and <span class="Li">&quot;cont&quot;</span> optionally supplies a
        <span class="Li">&quot;continue&quot;</span> block that operates as a
        second half of the body. All of these optree inputs are consumed by this
        function and become part of the constructed op tree.</p>
    <p class="Pp"><span class="Li">&quot;flags&quot;</span> gives the eight bits
        of <span class="Li">&quot;op_flags&quot;</span> for the
        <span class="Li">&quot;leaveloop&quot;</span> op and, shifted up eight
        bits, the eight bits of <span class="Li">&quot;op_private&quot;</span>
        for the <span class="Li">&quot;leaveloop&quot;</span> op, except that
        (in both cases) some bits will be set automatically.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> OP*  newFOROP(I32 flags, OP* sv, OP* expr, OP* block, OP* cont)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;newGIVENOP&quot;</dt>
  <dd>Constructs, checks, and returns an op tree expressing a
      <span class="Li">&quot;given&quot;</span> block.
      <span class="Li">&quot;cond&quot;</span> supplies the expression to whose
      value <span class="Li">$_</span> will be locally aliased, and
      <span class="Li">&quot;block&quot;</span> supplies the body of the
      <span class="Li">&quot;given&quot;</span> construct; they are consumed by
      this function and become part of the constructed op tree.
      <span class="Li">&quot;defsv_off&quot;</span> must be zero (it used to
      identity the pad slot of lexical <span class="Li">$_</span>).</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> OP*  newGIVENOP(OP* cond, OP* block, PADOFFSET defsv_off)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;newGVOP&quot;</dt>
  <dd>Constructs, checks, and returns an op of any type that involves an
      embedded reference to a GV. <span class="Li">&quot;type&quot;</span> is
      the opcode. <span class="Li">&quot;flags&quot;</span> gives the eight bits
      of <span class="Li">&quot;op_flags&quot;</span>.
      <span class="Li">&quot;gv&quot;</span> identifies the GV that the op
      should reference; calling this function does not transfer ownership of any
      reference to it.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> OP*  newGVOP(I32 type, I32 flags, GV* gv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;newLISTOP&quot;</dt>
  <dd>Constructs, checks, and returns an op of any list type.
      <span class="Li">&quot;type&quot;</span> is the opcode.
      <span class="Li">&quot;flags&quot;</span> gives the eight bits of
      <span class="Li">&quot;op_flags&quot;</span>, except that
      <span class="Li">&quot;OPf_KIDS&quot;</span> will be set automatically if
      required. <span class="Li">&quot;first&quot;</span> and
      <span class="Li">&quot;last&quot;</span> supply up to two ops to be direct
      children of the list op; they are consumed by this function and become
      part of the constructed op tree.
    <p class="Pp">For most list operators, the check function expects all the
        kid ops to be present already, so calling
        <span class="Li">&quot;newLISTOP(OP_JOIN, ...)&quot;</span> (e.g.) is
        not appropriate. What you want to do in that case is create an op of
        type <span class="Li">&quot;OP_LIST&quot;</span>, append more children
        to it, and then call &quot;op_convert_list&quot;. See
        &quot;op_convert_list&quot; for more information.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> OP*  newLISTOP(I32 type, I32 flags, OP* first, OP* last)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;newLOGOP&quot;</dt>
  <dd>Constructs, checks, and returns a logical (flow control) op.
      <span class="Li">&quot;type&quot;</span> is the opcode.
      <span class="Li">&quot;flags&quot;</span> gives the eight bits of
      <span class="Li">&quot;op_flags&quot;</span>, except that
      <span class="Li">&quot;OPf_KIDS&quot;</span> will be set automatically,
      and, shifted up eight bits, the eight bits of
      <span class="Li">&quot;op_private&quot;</span>, except that the bit with
      value 1 is automatically set. <span class="Li">&quot;first&quot;</span>
      supplies the expression controlling the flow, and
      <span class="Li">&quot;other&quot;</span> supplies the side (alternate)
      chain of ops; they are consumed by this function and become part of the
      constructed op tree.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> OP*  newLOGOP(I32 optype, I32 flags, OP *first, OP *other)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;newLOOPEX&quot;</dt>
  <dd>Constructs, checks, and returns a loop-exiting op (such as
      <span class="Li">&quot;goto&quot;</span> or
      <span class="Li">&quot;last&quot;</span>).
      <span class="Li">&quot;type&quot;</span> is the opcode.
      <span class="Li">&quot;label&quot;</span> supplies the parameter
      determining the target of the op; it is consumed by this function and
      becomes part of the constructed op tree.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> OP*  newLOOPEX(I32 type, OP* label)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;newLOOPOP&quot;</dt>
  <dd>Constructs, checks, and returns an op tree expressing a loop. This is only
      a loop in the control flow through the op tree; it does not have the
      heavyweight loop structure that allows exiting the loop by
      <span class="Li">&quot;last&quot;</span> and suchlike.
      <span class="Li">&quot;flags&quot;</span> gives the eight bits of
      <span class="Li">&quot;op_flags&quot;</span> for the top-level op, except
      that some bits will be set automatically as required.
      <span class="Li">&quot;expr&quot;</span> supplies the expression
      controlling loop iteration, and <span class="Li">&quot;block&quot;</span>
      supplies the body of the loop; they are consumed by this function and
      become part of the constructed op tree.
      <span class="Li">&quot;debuggable&quot;</span> is currently unused and
      should always be 1.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> OP*  newLOOPOP(I32 flags, I32 debuggable, OP* expr, OP* block)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;newMETHOP&quot;</dt>
  <dd>Constructs, checks, and returns an op of method type with a method name
      evaluated at runtime. <span class="Li">&quot;type&quot;</span> is the
      opcode. <span class="Li">&quot;flags&quot;</span> gives the eight bits of
      <span class="Li">&quot;op_flags&quot;</span>, except that
      <span class="Li">&quot;OPf_KIDS&quot;</span> will be set automatically,
      and, shifted up eight bits, the eight bits of
      <span class="Li">&quot;op_private&quot;</span>, except that the bit with
      value 1 is automatically set.
      <span class="Li">&quot;dynamic_meth&quot;</span> supplies an op which
      evaluates method name; it is consumed by this function and become part of
      the constructed op tree. Supported optypes:
      <span class="Li">&quot;OP_METHOD&quot;</span>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> OP*  newMETHOP(I32 type, I32 flags, OP* dynamic_meth)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;newMETHOP_named&quot;</dt>
  <dd>Constructs, checks, and returns an op of method type with a constant
      method name. <span class="Li">&quot;type&quot;</span> is the opcode.
      <span class="Li">&quot;flags&quot;</span> gives the eight bits of
      <span class="Li">&quot;op_flags&quot;</span>, and, shifted up eight bits,
      the eight bits of <span class="Li">&quot;op_private&quot;</span>.
      <span class="Li">&quot;const_meth&quot;</span> supplies a constant method
      name; it must be a shared COW string. Supported optypes:
      <span class="Li">&quot;OP_METHOD_NAMED&quot;</span>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> OP*  newMETHOP_named(I32 type, I32 flags, SV* const_meth)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;newNULLLIST&quot;</dt>
  <dd>Constructs, checks, and returns a new
      <span class="Li">&quot;stub&quot;</span> op, which represents an empty
      list expression.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> OP*  newNULLLIST()
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;newOP&quot;</dt>
  <dd>Constructs, checks, and returns an op of any base type (any type that has
      no extra fields). <span class="Li">&quot;type&quot;</span> is the opcode.
      <span class="Li">&quot;flags&quot;</span> gives the eight bits of
      <span class="Li">&quot;op_flags&quot;</span>, and, shifted up eight bits,
      the eight bits of <span class="Li">&quot;op_private&quot;</span>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> OP*  newOP(I32 optype, I32 flags)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;newPADOP&quot;</dt>
  <dd>Constructs, checks, and returns an op of any type that involves a
      reference to a pad element. <span class="Li">&quot;type&quot;</span> is
      the opcode. <span class="Li">&quot;flags&quot;</span> gives the eight bits
      of <span class="Li">&quot;op_flags&quot;</span>. A pad slot is
      automatically allocated, and is populated with
      <span class="Li">&quot;sv&quot;</span>; this function takes ownership of
      one reference to it.
    <p class="Pp">This function only exists if Perl has been compiled to use
        ithreads.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> OP*  newPADOP(I32 type, I32 flags, SV* sv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;newPMOP&quot;</dt>
  <dd>Constructs, checks, and returns an op of any pattern matching type.
      <span class="Li">&quot;type&quot;</span> is the opcode.
      <span class="Li">&quot;flags&quot;</span> gives the eight bits of
      <span class="Li">&quot;op_flags&quot;</span> and, shifted up eight bits,
      the eight bits of <span class="Li">&quot;op_private&quot;</span>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> OP*  newPMOP(I32 type, I32 flags)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;newPVOP&quot;</dt>
  <dd>Constructs, checks, and returns an op of any type that involves an
      embedded C-level pointer (PV). <span class="Li">&quot;type&quot;</span> is
      the opcode. <span class="Li">&quot;flags&quot;</span> gives the eight bits
      of <span class="Li">&quot;op_flags&quot;</span>.
      <span class="Li">&quot;pv&quot;</span> supplies the C-level pointer.
      Depending on the op type, the memory referenced by
      <span class="Li">&quot;pv&quot;</span> may be freed when the op is
      destroyed. If the op is of a freeing type,
      <span class="Li">&quot;pv&quot;</span> must have been allocated using
      <span class="Li">&quot;PerlMemShared_malloc&quot;</span>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> OP*  newPVOP(I32 type, I32 flags, char* pv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;newRANGE&quot;</dt>
  <dd>Constructs and returns a <span class="Li">&quot;range&quot;</span> op,
      with subordinate <span class="Li">&quot;flip&quot;</span> and
      <span class="Li">&quot;flop&quot;</span> ops.
      <span class="Li">&quot;flags&quot;</span> gives the eight bits of
      <span class="Li">&quot;op_flags&quot;</span> for the
      <span class="Li">&quot;flip&quot;</span> op and, shifted up eight bits,
      the eight bits of <span class="Li">&quot;op_private&quot;</span> for both
      the <span class="Li">&quot;flip&quot;</span> and
      <span class="Li">&quot;range&quot;</span> ops, except that the bit with
      value 1 is automatically set. <span class="Li">&quot;left&quot;</span> and
      <span class="Li">&quot;right&quot;</span> supply the expressions
      controlling the endpoints of the range; they are consumed by this function
      and become part of the constructed op tree.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> OP*  newRANGE(I32 flags, OP* left, OP* right)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;newSLICEOP&quot;</dt>
  <dd>Constructs, checks, and returns an
      <span class="Li">&quot;lslice&quot;</span> (list slice) op.
      <span class="Li">&quot;flags&quot;</span> gives the eight bits of
      <span class="Li">&quot;op_flags&quot;</span>, except that
      <span class="Li">&quot;OPf_KIDS&quot;</span> will be set automatically,
      and, shifted up eight bits, the eight bits of
      <span class="Li">&quot;op_private&quot;</span>, except that the bit with
      value 1 or 2 is automatically set as required.
      <span class="Li">&quot;listval&quot;</span> and
      <span class="Li">&quot;subscript&quot;</span> supply the parameters of the
      slice; they are consumed by this function and become part of the
      constructed op tree.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> OP*  newSLICEOP(I32 flags, OP* subscript, OP* listop)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;newSTATEOP&quot;</dt>
  <dd>Constructs a state op (COP). The state op is normally a
      <span class="Li">&quot;nextstate&quot;</span> op, but will be a
      <span class="Li">&quot;dbstate&quot;</span> op if debugging is enabled for
      currently-compiled code. The state op is populated from
      <span class="Li">&quot;PL_curcop&quot;</span> (or
      <span class="Li">&quot;PL_compiling&quot;</span>). If
      <span class="Li">&quot;label&quot;</span> is non-null, it supplies the
      name of a label to attach to the state op; this function takes ownership
      of the memory pointed at by <span class="Li">&quot;label&quot;</span>, and
      will free it. <span class="Li">&quot;flags&quot;</span> gives the eight
      bits of <span class="Li">&quot;op_flags&quot;</span> for the state op.
    <p class="Pp">If <span class="Li">&quot;o&quot;</span> is null, the state op
        is returned. Otherwise the state op is combined with
        <span class="Li">&quot;o&quot;</span> into a
        <span class="Li">&quot;lineseq&quot;</span> list op, which is returned.
        <span class="Li">&quot;o&quot;</span> is consumed by this function and
        becomes part of the returned op tree.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> OP*  newSTATEOP(I32 flags, char* label, OP* o)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;newSVOP&quot;</dt>
  <dd>Constructs, checks, and returns an op of any type that involves an
      embedded SV. <span class="Li">&quot;type&quot;</span> is the opcode.
      <span class="Li">&quot;flags&quot;</span> gives the eight bits of
      <span class="Li">&quot;op_flags&quot;</span>.
      <span class="Li">&quot;sv&quot;</span> gives the SV to embed in the op;
      this function takes ownership of one reference to it.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> OP*  newSVOP(I32 type, I32 flags, SV* sv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;newTRYCATCHOP&quot;</dt>
  <dd>NOTE: <span class="Li">&quot;newTRYCATCHOP&quot;</span> is
      <b>experimental</b> and may change or be removed without notice.
    <p class="Pp">Constructs and returns a conditional execution statement that
        implements the
        <span class="Li">&quot;try&quot;</span>/<span class="Li">&quot;catch&quot;</span>
        semantics. First the op tree in
        <span class="Li">&quot;tryblock&quot;</span> is executed, inside a
        context that traps exceptions. If an exception occurs then the optree in
        <span class="Li">&quot;catchblock&quot;</span> is executed, with the
        trapped exception set into the lexical variable given by
        <span class="Li">&quot;catchvar&quot;</span> (which must be an op of
        type <span class="Li">&quot;OP_PADSV&quot;</span>). All the optrees are
        consumed by this function and become part of the returned op tree.</p>
    <p class="Pp">The <span class="Li">&quot;flags&quot;</span> argument is
        currently ignored.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> OP*  newTRYCATCHOP(I32 flags, OP* tryblock, OP *catchvar,
                    OP* catchblock)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;newUNOP&quot;</dt>
  <dd>Constructs, checks, and returns an op of any unary type.
      <span class="Li">&quot;type&quot;</span> is the opcode.
      <span class="Li">&quot;flags&quot;</span> gives the eight bits of
      <span class="Li">&quot;op_flags&quot;</span>, except that
      <span class="Li">&quot;OPf_KIDS&quot;</span> will be set automatically if
      required, and, shifted up eight bits, the eight bits of
      <span class="Li">&quot;op_private&quot;</span>, except that the bit with
      value 1 is automatically set. <span class="Li">&quot;first&quot;</span>
      supplies an optional op to be the direct child of the unary op; it is
      consumed by this function and become part of the constructed op tree.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> OP*  newUNOP(I32 type, I32 flags, OP* first)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;newUNOP_AUX&quot;</dt>
  <dd>Similar to <span class="Li">&quot;newUNOP&quot;</span>, but creates an
      <span class="Li">&quot;UNOP_AUX&quot;</span> struct instead, with
      <span class="Li">&quot;op_aux&quot;</span> initialised to
      <span class="Li">&quot;aux&quot;</span></dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> OP*  newUNOP_AUX(I32 type, I32 flags, OP* first,
                  UNOP_AUX_item *aux)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;newWHENOP&quot;</dt>
  <dd>Constructs, checks, and returns an op tree expressing a
      <span class="Li">&quot;when&quot;</span> block.
      <span class="Li">&quot;cond&quot;</span> supplies the test expression, and
      <span class="Li">&quot;block&quot;</span> supplies the block that will be
      executed if the test evaluates to true; they are consumed by this function
      and become part of the constructed op tree.
      <span class="Li">&quot;cond&quot;</span> will be interpreted DWIMically,
      often as a comparison against <span class="Li">$_</span>, and may be null
      to generate a <span class="Li">&quot;default&quot;</span> block.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> OP*  newWHENOP(OP* cond, OP* block)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;newWHILEOP&quot;</dt>
  <dd>Constructs, checks, and returns an op tree expressing a
      <span class="Li">&quot;while&quot;</span> loop. This is a heavyweight
      loop, with structure that allows exiting the loop by
      <span class="Li">&quot;last&quot;</span> and suchlike.
    <p class="Pp"><span class="Li">&quot;loop&quot;</span> is an optional
        preconstructed <span class="Li">&quot;enterloop&quot;</span> op to use
        in the loop; if it is null then a suitable op will be constructed
        automatically. <span class="Li">&quot;expr&quot;</span> supplies the
        loop's controlling expression. <span class="Li">&quot;block&quot;</span>
        supplies the main body of the loop, and
        <span class="Li">&quot;cont&quot;</span> optionally supplies a
        <span class="Li">&quot;continue&quot;</span> block that operates as a
        second half of the body. All of these optree inputs are consumed by this
        function and become part of the constructed op tree.</p>
    <p class="Pp"><span class="Li">&quot;flags&quot;</span> gives the eight bits
        of <span class="Li">&quot;op_flags&quot;</span> for the
        <span class="Li">&quot;leaveloop&quot;</span> op and, shifted up eight
        bits, the eight bits of <span class="Li">&quot;op_private&quot;</span>
        for the <span class="Li">&quot;leaveloop&quot;</span> op, except that
        (in both cases) some bits will be set automatically.
        <span class="Li">&quot;debuggable&quot;</span> is currently unused and
        should always be 1. <span class="Li">&quot;has_my&quot;</span> can be
        supplied as true to force the loop body to be enclosed in its own
      scope.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> OP*  newWHILEOP(I32 flags, I32 debuggable, LOOP* loop, OP* expr,
                 OP* block, OP* cont, I32 has_my)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;PL_opfreehook&quot;</dt>
  <dd>When non-<span class="Li">&quot;NULL&quot;</span>, the function pointed by
      this variable will be called each time an OP is freed with the
      corresponding OP as the argument. This allows extensions to free any extra
      attribute they have locally attached to an OP. It is also assured to first
      fire for the parent OP and then for its kids.
    <p class="Pp">When you replace this variable, it is considered a good
        practice to store the possibly previously installed hook and that you
        recall it inside your own.</p>
    <p class="Pp">On threaded perls, each thread has an independent copy of this
        variable; each initialized at creation time with the current value of
        the creating thread's copy.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> Perl_ophook_t  PL_opfreehook
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;PL_peepp&quot;</dt>
  <dd>Pointer to the per-subroutine peephole optimiser. This is a function that
      gets called at the end of compilation of a Perl subroutine (or
      equivalently independent piece of Perl code) to perform fixups of some ops
      and to perform small-scale optimisations. The function is called once for
      each subroutine that is compiled, and is passed, as sole parameter, a
      pointer to the op that is the entry point to the subroutine. It modifies
      the op tree in place.
    <p class="Pp">The peephole optimiser should never be completely replaced.
        Rather, add code to it by wrapping the existing optimiser. The basic way
        to do this can be seen in &quot;Compile pass 3: peephole
        optimization&quot; in perlguts. If the new code wishes to operate on ops
        throughout the subroutine's structure, rather than just at the top
        level, it is likely to be more convenient to wrap the
        &quot;PL_rpeepp&quot; hook.</p>
    <p class="Pp">On threaded perls, each thread has an independent copy of this
        variable; each initialized at creation time with the current value of
        the creating thread's copy.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> peep_t  PL_peepp
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;PL_rpeepp&quot;</dt>
  <dd>Pointer to the recursive peephole optimiser. This is a function that gets
      called at the end of compilation of a Perl subroutine (or equivalently
      independent piece of Perl code) to perform fixups of some ops and to
      perform small-scale optimisations. The function is called once for each
      chain of ops linked through their
      <span class="Li">&quot;op_next&quot;</span> fields; it is recursively
      called to handle each side chain. It is passed, as sole parameter, a
      pointer to the op that is at the head of the chain. It modifies the op
      tree in place.
    <p class="Pp">The peephole optimiser should never be completely replaced.
        Rather, add code to it by wrapping the existing optimiser. The basic way
        to do this can be seen in &quot;Compile pass 3: peephole
        optimization&quot; in perlguts. If the new code wishes to operate only
        on ops at a subroutine's top level, rather than throughout the
        structure, it is likely to be more convenient to wrap the
        &quot;PL_peepp&quot; hook.</p>
    <p class="Pp">On threaded perls, each thread has an independent copy of this
        variable; each initialized at creation time with the current value of
        the creating thread's copy.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> peep_t  PL_rpeepp
</pre>
</div>
<div class="Bd-indent"></div>
</section>
<section class="Sh">
<h1 class="Sh" id="Optree_Manipulation_Functions"><a class="permalink" href="#Optree_Manipulation_Functions">Optree
  Manipulation Functions</a></h1>
<dl class="Bl-tag">
  <dt>&quot;alloccopstash&quot;</dt>
  <dd>NOTE: <span class="Li">&quot;alloccopstash&quot;</span> is
      <b>experimental</b> and may change or be removed without notice.
    <p class="Pp">Available only under threaded builds, this function allocates
        an entry in <span class="Li">&quot;PL_stashpad&quot;</span> for the
        stash passed to it.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> PADOFFSET  alloccopstash(HV *hv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;block_end&quot;</dt>
  <dd>Handles compile-time scope exit. <span class="Li">&quot;floor&quot;</span>
      is the savestack index returned by
      <span class="Li">&quot;block_start&quot;</span>, and
      <span class="Li">&quot;seq&quot;</span> is the body of the block. Returns
      the block, possibly modified.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> OP*  block_end(I32 floor, OP* seq)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;block_start&quot;</dt>
  <dd>Handles compile-time scope entry. Arranges for hints to be restored on
      block exit and also handles pad sequence numbers to make lexical variables
      scope right. Returns a savestack index for use with
      <span class="Li">&quot;block_end&quot;</span>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> int  block_start(int full)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;ck_entersub_args_list&quot;</dt>
  <dd>Performs the default fixup of the arguments part of an
      <span class="Li">&quot;entersub&quot;</span> op tree. This consists of
      applying list context to each of the argument ops. This is the standard
      treatment used on a call marked with
      <span class="Li">&quot;&amp;&quot;</span>, or a method call, or a call
      through a subroutine reference, or any other call where the callee can't
      be identified at compile time, or a call where the callee has no
      prototype.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> OP*  ck_entersub_args_list(OP *entersubop)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;ck_entersub_args_proto&quot;</dt>
  <dd>Performs the fixup of the arguments part of an
      <span class="Li">&quot;entersub&quot;</span> op tree based on a subroutine
      prototype. This makes various modifications to the argument ops, from
      applying context up to inserting
      <span class="Li">&quot;refgen&quot;</span> ops, and checking the number
      and syntactic types of arguments, as directed by the prototype. This is
      the standard treatment used on a subroutine call, not marked with
      <span class="Li">&quot;&amp;&quot;</span>, where the callee can be
      identified at compile time and has a prototype.
    <p class="Pp"><span class="Li">&quot;protosv&quot;</span> supplies the
        subroutine prototype to be applied to the call. It may be a normal
        defined scalar, of which the string value will be used. Alternatively,
        for convenience, it may be a subroutine object (a
        <span class="Li">&quot;CV*&quot;</span> that has been cast to
        <span class="Li">&quot;SV*&quot;</span>) which has a prototype. The
        prototype supplied, in whichever form, does not need to match the actual
        callee referenced by the op tree.</p>
    <p class="Pp">If the argument ops disagree with the prototype, for example
        by having an unacceptable number of arguments, a valid op tree is
        returned anyway. The error is reflected in the parser state, normally
        resulting in a single exception at the top level of parsing which covers
        all the compilation errors that occurred. In the error message, the
        callee is referred to by the name defined by the
        <span class="Li">&quot;namegv&quot;</span> parameter.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> OP*  ck_entersub_args_proto(OP *entersubop, GV *namegv,
                             SV *protosv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;ck_entersub_args_proto_or_list&quot;</dt>
  <dd>Performs the fixup of the arguments part of an
      <span class="Li">&quot;entersub&quot;</span> op tree either based on a
      subroutine prototype or using default list-context processing. This is the
      standard treatment used on a subroutine call, not marked with
      <span class="Li">&quot;&amp;&quot;</span>, where the callee can be
      identified at compile time.
    <p class="Pp"><span class="Li">&quot;protosv&quot;</span> supplies the
        subroutine prototype to be applied to the call, or indicates that there
        is no prototype. It may be a normal scalar, in which case if it is
        defined then the string value will be used as a prototype, and if it is
        undefined then there is no prototype. Alternatively, for convenience, it
        may be a subroutine object (a <span class="Li">&quot;CV*&quot;</span>
        that has been cast to <span class="Li">&quot;SV*&quot;</span>), of which
        the prototype will be used if it has one. The prototype (or lack
        thereof) supplied, in whichever form, does not need to match the actual
        callee referenced by the op tree.</p>
    <p class="Pp">If the argument ops disagree with the prototype, for example
        by having an unacceptable number of arguments, a valid op tree is
        returned anyway. The error is reflected in the parser state, normally
        resulting in a single exception at the top level of parsing which covers
        all the compilation errors that occurred. In the error message, the
        callee is referred to by the name defined by the
        <span class="Li">&quot;namegv&quot;</span> parameter.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> OP*  ck_entersub_args_proto_or_list(OP *entersubop, GV *namegv,
                                     SV *protosv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;cv_const_sv&quot;</dt>
  <dd>If <span class="Li">&quot;cv&quot;</span> is a constant sub eligible for
      inlining, returns the constant value returned by the sub. Otherwise,
      returns <span class="Li">&quot;NULL&quot;</span>.
    <p class="Pp">Constant subs can be created with
        <span class="Li">&quot;newCONSTSUB&quot;</span> or as described in
        &quot;Constant Functions&quot; in perlsub.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> SV*  cv_const_sv(const CV *const cv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;cv_get_call_checker&quot;</dt>
  <dd>The original form of &quot;cv_get_call_checker_flags&quot;, which does not
      return checker flags. When using a checker function returned by this
      function, it is only safe to call it with a genuine GV as its
      <span class="Li">&quot;namegv&quot;</span> argument.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  cv_get_call_checker(CV *cv, Perl_call_checker *ckfun_p,
                           SV **ckobj_p)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;cv_get_call_checker_flags&quot;</dt>
  <dd>Retrieves the function that will be used to fix up a call to
      <span class="Li">&quot;cv&quot;</span>. Specifically, the function is
      applied to an <span class="Li">&quot;entersub&quot;</span> op tree for a
      subroutine call, not marked with
      <span class="Li">&quot;&amp;&quot;</span>, where the callee can be
      identified at compile time as <span class="Li">&quot;cv&quot;</span>.
    <p class="Pp">The C-level function pointer is returned in
        <span class="Li">*ckfun_p</span>, an SV argument for it is returned in
        <span class="Li">*ckobj_p</span>, and control flags are returned in
        <span class="Li">*ckflags_p</span>. The function is intended to be
        called in this manner:</p>
    <p class="Pp"></p>
    <pre> entersubop = (*ckfun_p)(aTHX_ entersubop, namegv, (*ckobj_p));
    </pre>
    <p class="Pp">In this call, <span class="Li">&quot;entersubop&quot;</span>
        is a pointer to the <span class="Li">&quot;entersub&quot;</span> op,
        which may be replaced by the check function, and
        <span class="Li">&quot;namegv&quot;</span> supplies the name that should
        be used by the check function to refer to the callee of the
        <span class="Li">&quot;entersub&quot;</span> op if it needs to emit any
        diagnostics. It is permitted to apply the check function in non-standard
        situations, such as to a call to a different subroutine or to a method
        call.</p>
    <p class="Pp"><span class="Li">&quot;namegv&quot;</span> may not actually be
        a GV. If the <span class="Li">&quot;CALL_CHECKER_REQUIRE_GV&quot;</span>
        bit is clear in <span class="Li">*ckflags_p</span>, it is permitted to
        pass a CV or other SV instead, anything that can be used as the first
        argument to &quot;cv_name&quot;. If the
        <span class="Li">&quot;CALL_CHECKER_REQUIRE_GV&quot;</span> bit is set
        in <span class="Li">*ckflags_p</span> then the check function requires
        <span class="Li">&quot;namegv&quot;</span> to be a genuine GV.</p>
    <p class="Pp">By default, the check function is
        Perl_ck_entersub_args_proto_or_list, the SV parameter is
        <span class="Li">&quot;cv&quot;</span> itself, and the
        <span class="Li">&quot;CALL_CHECKER_REQUIRE_GV&quot;</span> flag is
        clear. This implements standard prototype processing. It can be changed,
        for a particular subroutine, by
      &quot;cv_set_call_checker_flags&quot;.</p>
    <p class="Pp">If the
        <span class="Li">&quot;CALL_CHECKER_REQUIRE_GV&quot;</span> bit is set
        in <span class="Li">&quot;gflags&quot;</span> then it indicates that the
        caller only knows about the genuine GV version of
        <span class="Li">&quot;namegv&quot;</span>, and accordingly the
        corresponding bit will always be set in
        <span class="Li">*ckflags_p</span>, regardless of the check function's
        recorded requirements. If the
        <span class="Li">&quot;CALL_CHECKER_REQUIRE_GV&quot;</span> bit is clear
        in <span class="Li">&quot;gflags&quot;</span> then it indicates the
        caller knows about the possibility of passing something other than a GV
        as <span class="Li">&quot;namegv&quot;</span>, and accordingly the
        corresponding bit may be either set or clear in
        <span class="Li">*ckflags_p</span>, indicating the check function's
        recorded requirements.</p>
    <p class="Pp"><span class="Li">&quot;gflags&quot;</span> is a bitset passed
        into <span class="Li">&quot;cv_get_call_checker_flags&quot;</span>, in
        which only the
        <span class="Li">&quot;CALL_CHECKER_REQUIRE_GV&quot;</span> bit
        currently has a defined meaning (for which see above). All other bits
        should be clear.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  cv_get_call_checker_flags(CV *cv, U32 gflags,
                                 Perl_call_checker *ckfun_p,
                                 SV **ckobj_p, U32 *ckflags_p)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;cv_set_call_checker&quot;</dt>
  <dd>The original form of &quot;cv_set_call_checker_flags&quot;, which passes
      it the <span class="Li">&quot;CALL_CHECKER_REQUIRE_GV&quot;</span> flag
      for backward-compatibility. The effect of that flag setting is that the
      check function is guaranteed to get a genuine GV as its
      <span class="Li">&quot;namegv&quot;</span> argument.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  cv_set_call_checker(CV *cv, Perl_call_checker ckfun,
                           SV *ckobj)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;cv_set_call_checker_flags&quot;</dt>
  <dd>Sets the function that will be used to fix up a call to
      <span class="Li">&quot;cv&quot;</span>. Specifically, the function is
      applied to an <span class="Li">&quot;entersub&quot;</span> op tree for a
      subroutine call, not marked with
      <span class="Li">&quot;&amp;&quot;</span>, where the callee can be
      identified at compile time as <span class="Li">&quot;cv&quot;</span>.
    <p class="Pp">The C-level function pointer is supplied in
        <span class="Li">&quot;ckfun&quot;</span>, an SV argument for it is
        supplied in <span class="Li">&quot;ckobj&quot;</span>, and control flags
        are supplied in <span class="Li">&quot;ckflags&quot;</span>. The
        function should be defined like this:</p>
    <p class="Pp"></p>
    <pre>    STATIC OP * ckfun(pTHX_ OP *op, GV *namegv, SV *ckobj)
    </pre>
    <p class="Pp">It is intended to be called in this manner:</p>
    <p class="Pp"></p>
    <pre>    entersubop = ckfun(aTHX_ entersubop, namegv, ckobj);
    </pre>
    <p class="Pp">In this call, <span class="Li">&quot;entersubop&quot;</span>
        is a pointer to the <span class="Li">&quot;entersub&quot;</span> op,
        which may be replaced by the check function, and
        <span class="Li">&quot;namegv&quot;</span> supplies the name that should
        be used by the check function to refer to the callee of the
        <span class="Li">&quot;entersub&quot;</span> op if it needs to emit any
        diagnostics. It is permitted to apply the check function in non-standard
        situations, such as to a call to a different subroutine or to a method
        call.</p>
    <p class="Pp"><span class="Li">&quot;namegv&quot;</span> may not actually be
        a GV. For efficiency, perl may pass a CV or other SV instead. Whatever
        is passed can be used as the first argument to &quot;cv_name&quot;. You
        can force perl to pass a GV by including
        <span class="Li">&quot;CALL_CHECKER_REQUIRE_GV&quot;</span> in the
        <span class="Li">&quot;ckflags&quot;</span>.</p>
    <p class="Pp"><span class="Li">&quot;ckflags&quot;</span> is a bitset, in
        which only the
        <span class="Li">&quot;CALL_CHECKER_REQUIRE_GV&quot;</span> bit
        currently has a defined meaning (for which see above). All other bits
        should be clear.</p>
    <p class="Pp">The current setting for a particular CV can be retrieved by
        &quot;cv_get_call_checker_flags&quot;.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  cv_set_call_checker_flags(CV *cv, Perl_call_checker ckfun,
                                 SV *ckobj, U32 ckflags)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;LINKLIST&quot;</dt>
  <dd>Given the root of an optree, link the tree in execution order using the
      <span class="Li">&quot;op_next&quot;</span> pointers and return the first
      op executed. If this has already been done, it will not be redone, and
      <span class="Li">&quot;o-&gt;op_next&quot;</span> will be returned. If
      <span class="Li">&quot;o-&gt;op_next&quot;</span> is not already set,
      <span class="Li">&quot;o&quot;</span> should be at least an
      <span class="Li">&quot;UNOP&quot;</span>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> OP*  LINKLIST(OP *o)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;newATTRSUB&quot;</dt>
  <dd>Construct a Perl subroutine, also performing some surrounding jobs.
    <p class="Pp">This is the same as
        &quot;<span class="Li">&quot;newATTRSUB_x&quot;</span>&quot; in
        perlintern with its <span class="Li">&quot;o_is_gv&quot;</span>
        parameter set to FALSE. This means that if
        <span class="Li">&quot;o&quot;</span> is null, the new sub will be
        anonymous; otherwise the name will be derived from
        <span class="Li">&quot;o&quot;</span> in the way described (as with all
        other details) in
        &quot;<span class="Li">&quot;newATTRSUB_x&quot;</span>&quot; in
        perlintern.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> CV*  newATTRSUB(I32 floor, OP *o, OP *proto, OP *attrs, OP *block)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;newCONSTSUB&quot;</dt>
  <dd>Behaves like &quot;newCONSTSUB_flags&quot;, except that
      <span class="Li">&quot;name&quot;</span> is nul-terminated rather than of
      counted length, and no flags are set. (This means that
      <span class="Li">&quot;name&quot;</span> is always interpreted as
      Latin-1.)</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> CV*  newCONSTSUB(HV* stash, const char* name, SV* sv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;newCONSTSUB_flags&quot;</dt>
  <dd>Construct a constant subroutine, also performing some surrounding jobs. A
      scalar constant-valued subroutine is eligible for inlining at
      compile-time, and in Perl code can be created by
      <span class="Li">&quot;sub&#x00A0;FOO&#x00A0;()&#x00A0;{&#x00A0;123&#x00A0;}&quot;</span>.
      Other kinds of constant subroutine have other treatment.
    <p class="Pp">The subroutine will have an empty prototype and will ignore
        any arguments when called. Its constant behaviour is determined by
        <span class="Li">&quot;sv&quot;</span>. If
        <span class="Li">&quot;sv&quot;</span> is null, the subroutine will
        yield an empty list. If <span class="Li">&quot;sv&quot;</span> points to
        a scalar, the subroutine will always yield that scalar. If
        <span class="Li">&quot;sv&quot;</span> points to an array, the
        subroutine will always yield a list of the elements of that array in
        list context, or the number of elements in the array in scalar context.
        This function takes ownership of one counted reference to the scalar or
        array, and will arrange for the object to live as long as the subroutine
        does. If <span class="Li">&quot;sv&quot;</span> points to a scalar then
        the inlining assumes that the value of the scalar will never change, so
        the caller must ensure that the scalar is not subsequently written to.
        If <span class="Li">&quot;sv&quot;</span> points to an array then no
        such assumption is made, so it is ostensibly safe to mutate the array or
        its elements, but whether this is really supported has not been
        determined.</p>
    <p class="Pp">The subroutine will have
        <span class="Li">&quot;CvFILE&quot;</span> set according to
        <span class="Li">&quot;PL_curcop&quot;</span>. Other aspects of the
        subroutine will be left in their default state. The caller is free to
        mutate the subroutine beyond its initial state after this function has
        returned.</p>
    <p class="Pp">If <span class="Li">&quot;name&quot;</span> is null then the
        subroutine will be anonymous, with its
        <span class="Li">&quot;CvGV&quot;</span> referring to an
        <span class="Li">&quot;__ANON__&quot;</span> glob. If
        <span class="Li">&quot;name&quot;</span> is non-null then the subroutine
        will be named accordingly, referenced by the appropriate glob.
        <span class="Li">&quot;name&quot;</span> is a string of length
        <span class="Li">&quot;len&quot;</span> bytes giving a sigilless symbol
        name, in UTF-8 if <span class="Li">&quot;flags&quot;</span> has the
        <span class="Li">&quot;SVf_UTF8&quot;</span> bit set and in Latin-1
        otherwise. The name may be either qualified or unqualified. If the name
        is unqualified then it defaults to being in the stash specified by
        <span class="Li">&quot;stash&quot;</span> if that is non-null, or to
        <span class="Li">&quot;PL_curstash&quot;</span> if
        <span class="Li">&quot;stash&quot;</span> is null. The symbol is always
        added to the stash if necessary, with
        <span class="Li">&quot;GV_ADDMULTI&quot;</span> semantics.</p>
    <p class="Pp"><span class="Li">&quot;flags&quot;</span> should not have bits
        set other than <span class="Li">&quot;SVf_UTF8&quot;</span>.</p>
    <p class="Pp">If there is already a subroutine of the specified name, then
        the new sub will replace the existing one in the glob. A warning may be
        generated about the redefinition.</p>
    <p class="Pp">If the subroutine has one of a few special names, such as
        <span class="Li">&quot;BEGIN&quot;</span> or
        <span class="Li">&quot;END&quot;</span>, then it will be claimed by the
        appropriate queue for automatic running of phase-related subroutines. In
        this case the relevant glob will be left not containing any subroutine,
        even if it did contain one before. Execution of the subroutine will
        likely be a no-op, unless <span class="Li">&quot;sv&quot;</span> was a
        tied array or the caller modified the subroutine in some interesting way
        before it was executed. In the case of
        <span class="Li">&quot;BEGIN&quot;</span>, the treatment is buggy: the
        sub will be executed when only half built, and may be deleted
        prematurely, possibly causing a crash.</p>
    <p class="Pp">The function returns a pointer to the constructed subroutine.
        If the sub is anonymous then ownership of one counted reference to the
        subroutine is transferred to the caller. If the sub is named then the
        caller does not get ownership of a reference. In most such cases, where
        the sub has a non-phase name, the sub will be alive at the point it is
        returned by virtue of being contained in the glob that names it. A
        phase-named subroutine will usually be alive by virtue of the reference
        owned by the phase's automatic run queue. A
        <span class="Li">&quot;BEGIN&quot;</span> subroutine may have been
        destroyed already by the time this function returns, but currently bugs
        occur in that case before the caller gets control. It is the caller's
        responsibility to ensure that it knows which of these situations
        applies.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> CV*  newCONSTSUB_flags(HV* stash, const char* name, STRLEN len,
                        U32 flags, SV* sv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;newSUB&quot;</dt>
  <dd>Like <span class="Li">&quot;newATTRSUB&quot;</span>, but without
      attributes.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> CV*  newSUB(I32 floor, OP* o, OP* proto, OP* block)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;newXS&quot;</dt>
  <dd>Used by <span class="Li">&quot;xsubpp&quot;</span> to hook up XSUBs as
      Perl subs. <span class="Li">&quot;filename&quot;</span> needs to be static
      storage, as it is used directly as <b>CvFILE()</b>, without a copy being
      made.</dd>
  <dt>&quot;op_append_elem&quot;</dt>
  <dd>Append an item to the list of ops contained directly within a list-type
      op, returning the lengthened list.
      <span class="Li">&quot;first&quot;</span> is the list-type op, and
      <span class="Li">&quot;last&quot;</span> is the op to append to the list.
      <span class="Li">&quot;optype&quot;</span> specifies the intended opcode
      for the list. If <span class="Li">&quot;first&quot;</span> is not already
      a list of the right type, it will be upgraded into one. If either
      <span class="Li">&quot;first&quot;</span> or
      <span class="Li">&quot;last&quot;</span> is null, the other is returned
      unchanged.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> OP*  op_append_elem(I32 optype, OP* first, OP* last)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;op_append_list&quot;</dt>
  <dd>Concatenate the lists of ops contained directly within two list-type ops,
      returning the combined list. <span class="Li">&quot;first&quot;</span> and
      <span class="Li">&quot;last&quot;</span> are the list-type ops to
      concatenate. <span class="Li">&quot;optype&quot;</span> specifies the
      intended opcode for the list. If either
      <span class="Li">&quot;first&quot;</span> or
      <span class="Li">&quot;last&quot;</span> is not already a list of the
      right type, it will be upgraded into one. If either
      <span class="Li">&quot;first&quot;</span> or
      <span class="Li">&quot;last&quot;</span> is null, the other is returned
      unchanged.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> OP*  op_append_list(I32 optype, OP* first, OP* last)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;OP_CLASS&quot;</dt>
  <dd>Return the class of the provided OP: that is, which of the *OP structures
      it uses. For core ops this currently gets the information out of
      <span class="Li">&quot;PL_opargs&quot;</span>, which does not always
      accurately reflect the type used; in v5.26 onwards, see also the function
      <span class="Li">&quot;op_class&quot;</span> which can do a better job of
      determining the used type.
    <p class="Pp">For custom ops the type is returned from the registration, and
        it is up to the registree to ensure it is accurate. The value returned
        will be one of the <span class="Li">&quot;OA_&quot;</span>* constants
        from <i>op.h</i>.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> U32  OP_CLASS(OP *o)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;op_contextualize&quot;</dt>
  <dd>Applies a syntactic context to an op tree representing an expression.
      <span class="Li">&quot;o&quot;</span> is the op tree, and
      <span class="Li">&quot;context&quot;</span> must be
      <span class="Li">&quot;G_SCALAR&quot;</span>,
      <span class="Li">&quot;G_ARRAY&quot;</span>, or
      <span class="Li">&quot;G_VOID&quot;</span> to specify the context to
      apply. The modified op tree is returned.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> OP*  op_contextualize(OP* o, I32 context)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;op_convert_list&quot;</dt>
  <dd>Converts <span class="Li">&quot;o&quot;</span> into a list op if it is not
      one already, and then converts it into the specified
      <span class="Li">&quot;type&quot;</span>, calling its check function,
      allocating a target if it needs one, and folding constants.
    <p class="Pp">A list-type op is usually constructed one kid at a time via
        <span class="Li">&quot;newLISTOP&quot;</span>,
        <span class="Li">&quot;op_prepend_elem&quot;</span> and
        <span class="Li">&quot;op_append_elem&quot;</span>. Then finally it is
        passed to <span class="Li">&quot;op_convert_list&quot;</span> to make it
        the right type.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> OP*  op_convert_list(I32 optype, I32 flags, OP* o)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;OP_DESC&quot;</dt>
  <dd>Return a short description of the provided OP.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> const char *  OP_DESC(OP *o)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;op_free&quot;</dt>
  <dd>Free an op and its children. Only use this when an op is no longer linked
      to from any optree.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  op_free(OP* arg)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;OpHAS_SIBLING&quot;</dt>
  <dd>Returns true if <span class="Li">&quot;o&quot;</span> has a sibling</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> bool  OpHAS_SIBLING(OP *o)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;OpLASTSIB_set&quot;</dt>
  <dd>Marks <span class="Li">&quot;o&quot;</span> as having no further siblings
      and marks o as having the specified parent. See also
      <span class="Li">&quot;OpMORESIB_set&quot;</span> and
      <span class="Li">&quot;OpMAYBESIB_set&quot;</span>. For a higher-level
      interface, see <span class="Li">&quot;op_sibling_splice&quot;</span>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  OpLASTSIB_set(OP *o, OP *parent)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;op_linklist&quot;</dt>
  <dd>This function is the implementation of the &quot;LINKLIST&quot; macro. It
      should not be called directly.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> OP*  op_linklist(OP *o)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;op_lvalue&quot;</dt>
  <dd>NOTE: <span class="Li">&quot;op_lvalue&quot;</span> is <b>experimental</b>
      and may change or be removed without notice.
    <p class="Pp">Propagate lvalue (&quot;modifiable&quot;) context to an op and
        its children. <span class="Li">&quot;type&quot;</span> represents the
        context type, roughly based on the type of op that would do the
        modifying, although <span class="Li">&quot;local()&quot;</span> is
        represented by <span class="Li">&quot;OP_NULL&quot;</span>, because it
        has no op type of its own (it is signalled by a flag on the lvalue
      op).</p>
    <p class="Pp">This function detects things that can't be modified, such as
        <span class="Li">&quot;$x+1&quot;</span>, and generates errors for them.
        For example, <span class="Li">&quot;$x+1 = 2&quot;</span> would cause it
        to be called with an op of type
        <span class="Li">&quot;OP_ADD&quot;</span> and a
        <span class="Li">&quot;type&quot;</span> argument of
        <span class="Li">&quot;OP_SASSIGN&quot;</span>.</p>
    <p class="Pp">It also flags things that need to behave specially in an
        lvalue context, such as <span class="Li">&quot;$$x = 5&quot;</span>
        which might have to vivify a reference in
      <span class="Li">$x</span>.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> OP*  op_lvalue(OP* o, I32 type)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;OpMAYBESIB_set&quot;</dt>
  <dd>Conditionally does <span class="Li">&quot;OpMORESIB_set&quot;</span> or
      <span class="Li">&quot;OpLASTSIB_set&quot;</span> depending on whether
      <span class="Li">&quot;sib&quot;</span> is non-null. For a higher-level
      interface, see <span class="Li">&quot;op_sibling_splice&quot;</span>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  OpMAYBESIB_set(OP *o, OP *sib, OP *parent)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;OpMORESIB_set&quot;</dt>
  <dd>Sets the sibling of <span class="Li">&quot;o&quot;</span> to the non-zero
      value <span class="Li">&quot;sib&quot;</span>. See also
      <span class="Li">&quot;OpLASTSIB_set&quot;</span> and
      <span class="Li">&quot;OpMAYBESIB_set&quot;</span>. For a higher-level
      interface, see <span class="Li">&quot;op_sibling_splice&quot;</span>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  OpMORESIB_set(OP *o, OP *sib)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;OP_NAME&quot;</dt>
  <dd>Return the name of the provided OP. For core ops this looks up the name
      from the op_type; for custom ops from the op_ppaddr.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> const char *  OP_NAME(OP *o)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;op_null&quot;</dt>
  <dd>Neutralizes an op when it is no longer needed, but is still linked to from
      other ops.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  op_null(OP* o)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;op_parent&quot;</dt>
  <dd>Returns the parent OP of <span class="Li">&quot;o&quot;</span>, if it has
      a parent. Returns <span class="Li">&quot;NULL&quot;</span> otherwise.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> OP*  op_parent(OP *o)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;op_prepend_elem&quot;</dt>
  <dd>Prepend an item to the list of ops contained directly within a list-type
      op, returning the lengthened list.
      <span class="Li">&quot;first&quot;</span> is the op to prepend to the
      list, and <span class="Li">&quot;last&quot;</span> is the list-type op.
      <span class="Li">&quot;optype&quot;</span> specifies the intended opcode
      for the list. If <span class="Li">&quot;last&quot;</span> is not already a
      list of the right type, it will be upgraded into one. If either
      <span class="Li">&quot;first&quot;</span> or
      <span class="Li">&quot;last&quot;</span> is null, the other is returned
      unchanged.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> OP*  op_prepend_elem(I32 optype, OP* first, OP* last)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;op_scope&quot;</dt>
  <dd>NOTE: <span class="Li">&quot;op_scope&quot;</span> is <b>experimental</b>
      and may change or be removed without notice.
    <p class="Pp">Wraps up an op tree with some additional ops so that at
        runtime a dynamic scope will be created. The original ops run in the new
        dynamic scope, and then, provided that they exit normally, the scope
        will be unwound. The additional ops used to create and unwind the
        dynamic scope will normally be an
        <span class="Li">&quot;enter&quot;</span>/<span class="Li">&quot;leave&quot;</span>
        pair, but a <span class="Li">&quot;scope&quot;</span> op may be used
        instead if the ops are simple enough to not need the full dynamic scope
        structure.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> OP*  op_scope(OP* o)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;OpSIBLING&quot;</dt>
  <dd>Returns the sibling of <span class="Li">&quot;o&quot;</span>, or
      <span class="Li">&quot;NULL&quot;</span> if there is no sibling</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> OP*  OpSIBLING(OP *o)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;op_sibling_splice&quot;</dt>
  <dd>A general function for editing the structure of an existing chain of
      op_sibling nodes. By analogy with the perl-level
      <span class="Li">&quot;splice()&quot;</span> function, allows you to
      delete zero or more sequential nodes, replacing them with zero or more
      different nodes. Performs the necessary op_first/op_last housekeeping on
      the parent node and op_sibling manipulation on the children. The last
      deleted node will be marked as the last node by updating the
      op_sibling/op_sibparent or op_moresib field as appropriate.
    <p class="Pp">Note that op_next is not manipulated, and nodes are not freed;
        that is the responsibility of the caller. It also won't create a new
        list op for an empty list etc; use higher-level functions like
        <b>op_append_elem()</b> for that.</p>
    <p class="Pp"><span class="Li">&quot;parent&quot;</span> is the parent node
        of the sibling chain. It may passed as
        <span class="Li">&quot;NULL&quot;</span> if the splicing doesn't affect
        the first or last op in the chain.</p>
    <p class="Pp"><span class="Li">&quot;start&quot;</span> is the node
        preceding the first node to be spliced. Node(s) following it will be
        deleted, and ops will be inserted after it. If it is
        <span class="Li">&quot;NULL&quot;</span>, the first node onwards is
        deleted, and nodes are inserted at the beginning.</p>
    <p class="Pp"><span class="Li">&quot;del_count&quot;</span> is the number of
        nodes to delete. If zero, no nodes are deleted. If -1 or greater than or
        equal to the number of remaining kids, all remaining kids are
      deleted.</p>
    <p class="Pp"><span class="Li">&quot;insert&quot;</span> is the first of a
        chain of nodes to be inserted in place of the nodes. If
        <span class="Li">&quot;NULL&quot;</span>, no nodes are inserted.</p>
    <p class="Pp">The head of the chain of deleted ops is returned, or
        <span class="Li">&quot;NULL&quot;</span> if no ops were deleted.</p>
    <p class="Pp">For example:</p>
    <p class="Pp"></p>
    <pre>    action                    before      after         returns
    ------                    -----       -----         -------
                              P           P
    splice(P, A, 2, X-Y-Z)    |           |             B-C
                              A-B-C-D     A-X-Y-Z-D
                              P           P
    splice(P, NULL, 1, X-Y)   |           |             A
                              A-B-C-D     X-Y-B-C-D
                              P           P
    splice(P, NULL, 3, NULL)  |           |             A-B-C
                              A-B-C-D     D
                              P           P
    splice(P, B, 0, X-Y)      |           |             NULL
                              A-B-C-D     A-B-X-Y-C-D
    </pre>
    <p class="Pp">For lower-level direct manipulation of
        <span class="Li">&quot;op_sibparent&quot;</span> and
        <span class="Li">&quot;op_moresib&quot;</span>, see
        <span class="Li">&quot;OpMORESIB_set&quot;</span>,
        <span class="Li">&quot;OpLASTSIB_set&quot;</span>,
        <span class="Li">&quot;OpMAYBESIB_set&quot;</span>.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> OP*  op_sibling_splice(OP *parent, OP *start, int del_count,
                        OP* insert)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;OP_TYPE_IS&quot;</dt>
  <dd>Returns true if the given OP is not a
      <span class="Li">&quot;NULL&quot;</span> pointer and if it is of the given
      type.
    <p class="Pp">The negation of this macro,
        <span class="Li">&quot;OP_TYPE_ISNT&quot;</span> is also available as
        well as <span class="Li">&quot;OP_TYPE_IS_NN&quot;</span> and
        <span class="Li">&quot;OP_TYPE_ISNT_NN&quot;</span> which elide the NULL
        pointer check.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> bool  OP_TYPE_IS(OP *o, Optype type)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;OP_TYPE_IS_OR_WAS&quot;</dt>
  <dd>Returns true if the given OP is not a NULL pointer and if it is of the
      given type or used to be before being replaced by an OP of type OP_NULL.
    <p class="Pp">The negation of this macro,
        <span class="Li">&quot;OP_TYPE_ISNT_AND_WASNT&quot;</span> is also
        available as well as
        <span class="Li">&quot;OP_TYPE_IS_OR_WAS_NN&quot;</span> and
        <span class="Li">&quot;OP_TYPE_ISNT_AND_WASNT_NN&quot;</span> which
        elide the <span class="Li">&quot;NULL&quot;</span> pointer check.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> bool  OP_TYPE_IS_OR_WAS(OP *o, Optype type)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;rv2cv_op_cv&quot;</dt>
  <dd>Examines an op, which is expected to identify a subroutine at runtime, and
      attempts to determine at compile time which subroutine it identifies. This
      is normally used during Perl compilation to determine whether a prototype
      can be applied to a function call.
      <span class="Li">&quot;cvop&quot;</span> is the op being considered,
      normally an <span class="Li">&quot;rv2cv&quot;</span> op. A pointer to the
      identified subroutine is returned, if it could be determined statically,
      and a null pointer is returned if it was not possible to determine
      statically.
    <p class="Pp">Currently, the subroutine can be identified statically if the
        RV that the <span class="Li">&quot;rv2cv&quot;</span> is to operate on
        is provided by a suitable <span class="Li">&quot;gv&quot;</span> or
        <span class="Li">&quot;const&quot;</span> op. A
        <span class="Li">&quot;gv&quot;</span> op is suitable if the GV's CV
        slot is populated. A <span class="Li">&quot;const&quot;</span> op is
        suitable if the constant value must be an RV pointing to a CV. Details
        of this process may change in future versions of Perl. If the
        <span class="Li">&quot;rv2cv&quot;</span> op has the
        <span class="Li">&quot;OPpENTERSUB_AMPER&quot;</span> flag set then no
        attempt is made to identify the subroutine statically: this flag is used
        to suppress compile-time magic on a subroutine call, forcing it to use
        default runtime behaviour.</p>
    <p class="Pp">If <span class="Li">&quot;flags&quot;</span> has the bit
        <span class="Li">&quot;RV2CVOPCV_MARK_EARLY&quot;</span> set, then the
        handling of a GV reference is modified. If a GV was examined and its CV
        slot was found to be empty, then the
        <span class="Li">&quot;gv&quot;</span> op has the
        <span class="Li">&quot;OPpEARLY_CV&quot;</span> flag set. If the op is
        not optimised away, and the CV slot is later populated with a subroutine
        having a prototype, that flag eventually triggers the warning
        &quot;called too early to check prototype&quot;.</p>
    <p class="Pp">If <span class="Li">&quot;flags&quot;</span> has the bit
        <span class="Li">&quot;RV2CVOPCV_RETURN_NAME_GV&quot;</span> set, then
        instead of returning a pointer to the subroutine it returns a pointer to
        the GV giving the most appropriate name for the subroutine in this
        context. Normally this is just the
        <span class="Li">&quot;CvGV&quot;</span> of the subroutine, but for an
        anonymous (<span class="Li">&quot;CvANON&quot;</span>) subroutine that
        is referenced through a GV it will be the referencing GV. The resulting
        <span class="Li">&quot;GV*&quot;</span> is cast to
        <span class="Li">&quot;CV*&quot;</span> to be returned. A null pointer
        is returned as usual if there is no statically-determinable
      subroutine.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> CV*  rv2cv_op_cv(OP *cvop, U32 flags)
</pre>
</div>
<div class="Bd-indent"></div>
</section>
<section class="Sh">
<h1 class="Sh" id="Pack_and_Unpack"><a class="permalink" href="#Pack_and_Unpack">Pack
  and Unpack</a></h1>
<dl class="Bl-tag">
  <dt>&quot;pack_cat&quot;</dt>
  <dd><span class="Li">&quot;</span><span class="Li"><b>DEPRECATED!</b></span><span class="Li">&quot;</span>
      It is planned to remove <span class="Li">&quot;pack_cat&quot;</span> from
      a future release of Perl. Do not use it for new code; remove it from
      existing code.
    <p class="Pp">The engine implementing
        <span class="Li">&quot;pack()&quot;</span> Perl function. Note:
        parameters <span class="Li">&quot;next_in_list&quot;</span> and
        <span class="Li">&quot;flags&quot;</span> are not used. This call should
        not be used; use <span class="Li">&quot;packlist&quot;</span>
      instead.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  pack_cat(SV *cat, const char *pat, const char *patend,
                SV **beglist, SV **endlist, SV ***next_in_list,
                U32 flags)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;packlist&quot;</dt>
  <dd>The engine implementing <span class="Li">&quot;pack()&quot;</span> Perl
      function.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  packlist(SV *cat, const char *pat, const char *patend,
                SV **beglist, SV **endlist)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;unpack_str&quot;</dt>
  <dd><span class="Li">&quot;</span><span class="Li"><b>DEPRECATED!</b></span><span class="Li">&quot;</span>
      It is planned to remove <span class="Li">&quot;unpack_str&quot;</span>
      from a future release of Perl. Do not use it for new code; remove it from
      existing code.
    <p class="Pp">The engine implementing
        <span class="Li">&quot;unpack()&quot;</span> Perl function. Note:
        parameters <span class="Li">&quot;strbeg&quot;</span>,
        <span class="Li">&quot;new_s&quot;</span> and
        <span class="Li">&quot;ocnt&quot;</span> are not used. This call should
        not be used, use <span class="Li">&quot;unpackstring&quot;</span>
        instead.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> SSize_t  unpack_str(const char *pat, const char *patend,
                     const char *s, const char *strbeg,
                     const char *strend, char **new_s, I32 ocnt,
                     U32 flags)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;unpackstring&quot;</dt>
  <dd>The engine implementing the <span class="Li">&quot;unpack()&quot;</span>
      Perl function.
    <p class="Pp">Using the template
        <span class="Li">&quot;pat..patend&quot;</span>, this function unpacks
        the string <span class="Li">&quot;s..strend&quot;</span> into a number
        of mortal SVs, which it pushes onto the perl argument
        (<span class="Li">@_</span>) stack (so you will need to issue a
        <span class="Li">&quot;PUTBACK&quot;</span> before and
        <span class="Li">&quot;SPAGAIN&quot;</span> after the call to this
        function). It returns the number of pushed elements.</p>
    <p class="Pp">The <span class="Li">&quot;strend&quot;</span> and
        <span class="Li">&quot;patend&quot;</span> pointers should point to the
        byte following the last character of each string.</p>
    <p class="Pp">Although this function returns its values on the perl argument
        stack, it doesn't take any parameters from that stack (and thus in
        particular there's no need to do a
        <span class="Li">&quot;PUSHMARK&quot;</span> before calling it, unlike
        &quot;call_pv&quot; for example).</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> SSize_t  unpackstring(const char *pat, const char *patend,
                       const char *s, const char *strend,
                       U32 flags)
</pre>
</div>
<div class="Bd-indent"></div>
</section>
<section class="Sh">
<h1 class="Sh" id="Pad_Data_Structures"><a class="permalink" href="#Pad_Data_Structures">Pad
  Data Structures</a></h1>
<dl class="Bl-tag">
  <dt>&quot;CvPADLIST&quot;</dt>
  <dd>NOTE: <span class="Li">&quot;CvPADLIST&quot;</span> is <b>experimental</b>
      and may change or be removed without notice.
    <p class="Pp">CV's can have CvPADLIST(cv) set to point to a PADLIST. This is
        the CV's scratchpad, which stores lexical variables and opcode temporary
        and per-thread values.</p>
    <p class="Pp">For these purposes &quot;formats&quot; are a kind-of CV;
        eval&quot;&quot;s are too (except they're not callable at will and are
        always thrown away after the eval&quot;&quot; is done executing).
        Require'd files are simply evals without any outer lexical scope.</p>
    <p class="Pp">XSUBs do not have a
        <span class="Li">&quot;CvPADLIST&quot;</span>.
        <span class="Li">&quot;dXSTARG&quot;</span> fetches values from
        <span class="Li">&quot;PL_curpad&quot;</span>, but that is really the
        callers pad (a slot of which is allocated by every entersub). Do not get
        or set <span class="Li">&quot;CvPADLIST&quot;</span> if a CV is an XSUB
        (as determined by <span class="Li">&quot;CvISXSUB()&quot;</span>),
        <span class="Li">&quot;CvPADLIST&quot;</span> slot is reused for a
        different internal purpose in XSUBs.</p>
    <p class="Pp">The PADLIST has a C array where pads are stored.</p>
    <p class="Pp">The 0th entry of the PADLIST is a PADNAMELIST which represents
        the &quot;names&quot; or rather the &quot;static type information&quot;
        for lexicals. The individual elements of a PADNAMELIST are PADNAMEs.
        Future refactorings might stop the PADNAMELIST from being stored in the
        PADLIST's array, so don't rely on it. See &quot;PadlistNAMES&quot;.</p>
    <p class="Pp">The CvDEPTH'th entry of a PADLIST is a PAD (an AV) which is
        the stack frame at that depth of recursion into the CV. The 0th slot of
        a frame AV is an AV which is <span class="Li">@_</span>. Other entries
        are storage for variables and op targets.</p>
    <p class="Pp">Iterating over the PADNAMELIST iterates over all possible pad
        items. Pad slots for targets
        (<span class="Li">&quot;SVs_PADTMP&quot;</span>) and GVs end up having
        &amp;PL_padname_undef &quot;names&quot;, while slots for constants have
        <span class="Li">&amp;PL_padname_const</span> &quot;names&quot; (see
        <span class="Li">&quot;pad_alloc&quot;</span>). That
        <span class="Li">&amp;PL_padname_undef</span> and
        <span class="Li">&amp;PL_padname_const</span> are used is an
        implementation detail subject to change. To test for them, use
        <span class="Li">&quot;!PadnamePV(name)&quot;</span> and
        <span class="Li">&quot;PadnamePV(name)&#x00A0;&amp;&amp;&#x00A0;!PadnameLEN(name)&quot;</span>,
        respectively.</p>
    <p class="Pp">Only
        <span class="Li">&quot;my&quot;</span>/<span class="Li">&quot;our&quot;</span>
        variable slots get valid names. The rest are op targets/GVs/constants
        which are statically allocated or resolved at compile time. These don't
        have names by which they can be looked up from Perl code at run time
        through eval&quot;&quot; the way
        <span class="Li">&quot;my&quot;</span>/<span class="Li">&quot;our&quot;</span>
        variables can be. Since they can't be looked up by &quot;name&quot; but
        only by their index allocated at compile time (which is usually in
        <span class="Li">&quot;PL_op-&gt;op_targ&quot;</span>), wasting a name
        SV for them doesn't make sense.</p>
    <p class="Pp">The pad names in the PADNAMELIST have their PV holding the
        name of the variable. The
        <span class="Li">&quot;COP_SEQ_RANGE_LOW&quot;</span> and
        <span class="Li">&quot;_HIGH&quot;</span> fields form a range
        (low+1..high inclusive) of cop_seq numbers for which the name is valid.
        During compilation, these fields may hold the special value
        PERL_PADSEQ_INTRO to indicate various stages:</p>
    <p class="Pp"></p>
    <pre> COP_SEQ_RANGE_LOW        _HIGH
 -----------------        -----
 PERL_PADSEQ_INTRO            0   variable not yet introduced:
                                  { my ($x
 valid-seq#   PERL_PADSEQ_INTRO   variable in scope:
                                  { my ($x);
 valid-seq#          valid-seq#   compilation of scope complete:
                                  { my ($x); .... }
    </pre>
    <p class="Pp">When a lexical var hasn't yet been introduced, it already
        exists from the perspective of duplicate declarations, but not for
        variable lookups, e.g.</p>
    <p class="Pp"></p>
    <pre>    my ($x, $x); # '&quot;my&quot; variable $x masks earlier declaration'
    my $x = $x;  # equal to my $x = $::x;
    </pre>
    <p class="Pp">For typed lexicals
        <span class="Li">&quot;PadnameTYPE&quot;</span> points at the type
        stash. For <span class="Li">&quot;our&quot;</span> lexicals,
        <span class="Li">&quot;PadnameOURSTASH&quot;</span> points at the stash
        of the associated global (so that duplicate
        <span class="Li">&quot;our&quot;</span> declarations in the same package
        can be detected). <span class="Li">&quot;PadnameGEN&quot;</span> is
        sometimes used to store the generation number during compilation.</p>
    <p class="Pp">If <span class="Li">&quot;PadnameOUTER&quot;</span> is set on
        the pad name, then that slot in the frame AV is a REFCNT'ed reference to
        a lexical from &quot;outside&quot;. Such entries are sometimes referred
        to as 'fake'. In this case, the name does not use 'low' and 'high' to
        store a cop_seq range, since it is in scope throughout. Instead 'high'
        stores some flags containing info about the real lexical (is it declared
        in an anon, and is it capable of being instantiated multiple times?),
        and for fake ANONs, 'low' contains the index within the parent's pad
        where the lexical's value is stored, to make cloning quicker.</p>
    <p class="Pp">If the 'name' is <span class="Li">&quot;&amp;&quot;</span> the
        corresponding entry in the PAD is a CV representing a possible
      closure.</p>
    <p class="Pp">Note that formats are treated as anon subs, and are cloned
        each time write is called (if necessary).</p>
    <p class="Pp">The flag <span class="Li">&quot;SVs_PADSTALE&quot;</span> is
        cleared on lexicals each time the
        <span class="Li">&quot;my()&quot;</span> is executed, and set on scope
        exit. This allows the <span class="Li">&quot;Variable $x is not
        available&quot;</span> warning to be generated in evals, such as</p>
    <p class="Pp"></p>
    <pre>    { my $x = 1; sub f { eval '$x'} } f();
    </pre>
    <p class="Pp">For state vars,
        <span class="Li">&quot;SVs_PADSTALE&quot;</span> is overloaded to mean
        'not yet initialised', but this internal state is stored in a separate
        pad entry.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> PADLIST *  CvPADLIST(CV *cv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;pad_add_name_pvs&quot;</dt>
  <dd>Exactly like &quot;pad_add_name_pvn&quot;, but takes a literal string
      instead of a string/length pair.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> PADOFFSET  pad_add_name_pvs(&quot;name&quot;, U32 flags, HV *typestash,
                             HV *ourstash)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;PadARRAY&quot;</dt>
  <dd>NOTE: <span class="Li">&quot;PadARRAY&quot;</span> is <b>experimental</b>
      and may change or be removed without notice.
    <p class="Pp">The C array of pad entries.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> SV **  PadARRAY(PAD * pad)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;pad_findmy_pvs&quot;</dt>
  <dd>Exactly like &quot;pad_findmy_pvn&quot;, but takes a literal string
      instead of a string/length pair.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> PADOFFSET  pad_findmy_pvs(&quot;name&quot;, U32 flags)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;PadlistARRAY&quot;</dt>
  <dd>NOTE: <span class="Li">&quot;PadlistARRAY&quot;</span> is
      <b>experimental</b> and may change or be removed without notice.
    <p class="Pp">The C array of a padlist, containing the pads. Only subscript
        it with numbers &gt;= 1, as the 0th entry is not guaranteed to remain
        usable.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> PAD **  PadlistARRAY(PADLIST * padlist)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;PadlistMAX&quot;</dt>
  <dd>NOTE: <span class="Li">&quot;PadlistMAX&quot;</span> is
      <b>experimental</b> and may change or be removed without notice.
    <p class="Pp">The index of the last allocated space in the padlist. Note
        that the last pad may be in an earlier slot. Any entries following it
        will be <span class="Li">&quot;NULL&quot;</span> in that case.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> SSize_t  PadlistMAX(PADLIST * padlist)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;PadlistNAMES&quot;</dt>
  <dd>NOTE: <span class="Li">&quot;PadlistNAMES&quot;</span> is
      <b>experimental</b> and may change or be removed without notice.
    <p class="Pp">The names associated with pad entries.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> PADNAMELIST *  PadlistNAMES(PADLIST * padlist)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;PadlistNAMESARRAY&quot;</dt>
  <dd>NOTE: <span class="Li">&quot;PadlistNAMESARRAY&quot;</span> is
      <b>experimental</b> and may change or be removed without notice.
    <p class="Pp">The C array of pad names.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> PADNAME **  PadlistNAMESARRAY(PADLIST * padlist)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;PadlistNAMESMAX&quot;</dt>
  <dd>NOTE: <span class="Li">&quot;PadlistNAMESMAX&quot;</span> is
      <b>experimental</b> and may change or be removed without notice.
    <p class="Pp">The index of the last pad name.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> SSize_t  PadlistNAMESMAX(PADLIST * padlist)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;PadlistREFCNT&quot;</dt>
  <dd>NOTE: <span class="Li">&quot;PadlistREFCNT&quot;</span> is
      <b>experimental</b> and may change or be removed without notice.
    <p class="Pp">The reference count of the padlist. Currently this is always
        1.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> U32  PadlistREFCNT(PADLIST * padlist)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;PadMAX&quot;</dt>
  <dd>NOTE: <span class="Li">&quot;PadMAX&quot;</span> is <b>experimental</b>
      and may change or be removed without notice.
    <p class="Pp">The index of the last pad entry.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> SSize_t  PadMAX(PAD * pad)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;PadnameLEN&quot;</dt>
  <dd>NOTE: <span class="Li">&quot;PadnameLEN&quot;</span> is
      <b>experimental</b> and may change or be removed without notice.
    <p class="Pp">The length of the name.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> STRLEN  PadnameLEN(PADNAME * pn)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;PadnamelistARRAY&quot;</dt>
  <dd>NOTE: <span class="Li">&quot;PadnamelistARRAY&quot;</span> is
      <b>experimental</b> and may change or be removed without notice.
    <p class="Pp">The C array of pad names.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> PADNAME **  PadnamelistARRAY(PADNAMELIST * pnl)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;PadnamelistMAX&quot;</dt>
  <dd>NOTE: <span class="Li">&quot;PadnamelistMAX&quot;</span> is
      <b>experimental</b> and may change or be removed without notice.
    <p class="Pp">The index of the last pad name.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> SSize_t  PadnamelistMAX(PADNAMELIST * pnl)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;PadnamelistREFCNT&quot;</dt>
  <dd>NOTE: <span class="Li">&quot;PadnamelistREFCNT&quot;</span> is
      <b>experimental</b> and may change or be removed without notice.
    <p class="Pp">The reference count of the pad name list.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> SSize_t  PadnamelistREFCNT(PADNAMELIST * pnl)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;PadnamelistREFCNT_dec&quot;</dt>
  <dd>NOTE: <span class="Li">&quot;PadnamelistREFCNT_dec&quot;</span> is
      <b>experimental</b> and may change or be removed without notice.
    <p class="Pp">Lowers the reference count of the pad name list.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  PadnamelistREFCNT_dec(PADNAMELIST * pnl)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;PadnamePV&quot;</dt>
  <dd>NOTE: <span class="Li">&quot;PadnamePV&quot;</span> is <b>experimental</b>
      and may change or be removed without notice.
    <p class="Pp">The name stored in the pad name struct. This returns
        <span class="Li">&quot;NULL&quot;</span> for a target slot.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> char *  PadnamePV(PADNAME * pn)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;PadnameREFCNT&quot;</dt>
  <dd>NOTE: <span class="Li">&quot;PadnameREFCNT&quot;</span> is
      <b>experimental</b> and may change or be removed without notice.
    <p class="Pp">The reference count of the pad name.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> SSize_t  PadnameREFCNT(PADNAME * pn)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;PadnameREFCNT_dec&quot;</dt>
  <dd>NOTE: <span class="Li">&quot;PadnameREFCNT_dec&quot;</span> is
      <b>experimental</b> and may change or be removed without notice.
    <p class="Pp">Lowers the reference count of the pad name.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  PadnameREFCNT_dec(PADNAME * pn)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;PadnameSV&quot;</dt>
  <dd>NOTE: <span class="Li">&quot;PadnameSV&quot;</span> is <b>experimental</b>
      and may change or be removed without notice.
    <p class="Pp">Returns the pad name as a mortal SV.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> SV *  PadnameSV(PADNAME * pn)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;PadnameUTF8&quot;</dt>
  <dd>NOTE: <span class="Li">&quot;PadnameUTF8&quot;</span> is
      <b>experimental</b> and may change or be removed without notice.
    <p class="Pp">Whether PadnamePV is in UTF-8. Currently, this is always
      true.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> bool  PadnameUTF8(PADNAME * pn)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;pad_new&quot;</dt>
  <dd>Create a new padlist, updating the global variables for the
      currently-compiling padlist to point to the new padlist. The following
      flags can be OR'ed together:
    <p class="Pp"></p>
    <pre>    padnew_CLONE        this pad is for a cloned CV
    padnew_SAVE         save old globals on the save stack
    padnew_SAVESUB      also save extra stuff for start of sub
    </pre>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> PADLIST*  pad_new(int flags)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;PL_comppad&quot;</dt>
  <dd>NOTE: <span class="Li">&quot;PL_comppad&quot;</span> is
      <b>experimental</b> and may change or be removed without notice.
    <p class="Pp">During compilation, this points to the array containing the
        values part of the pad for the currently-compiling code. (At runtime a
        CV may have many such value arrays; at compile time just one is
        constructed.) At runtime, this points to the array containing the
        currently-relevant values for the pad for the currently-executing
      code.</p>
  </dd>
  <dt>&quot;PL_comppad_name&quot;</dt>
  <dd>NOTE: <span class="Li">&quot;PL_comppad_name&quot;</span> is
      <b>experimental</b> and may change or be removed without notice.
    <p class="Pp">During compilation, this points to the array containing the
        names part of the pad for the currently-compiling code.</p>
  </dd>
  <dt>&quot;PL_curpad&quot;</dt>
  <dd>NOTE: <span class="Li">&quot;PL_curpad&quot;</span> is <b>experimental</b>
      and may change or be removed without notice.
    <p class="Pp">Points directly to the body of the &quot;PL_comppad&quot;
        array. (I.e., this is
        <span class="Li">&quot;PadARRAY(PL_comppad)&quot;</span>.)</p>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="Password_and_Group_access"><a class="permalink" href="#Password_and_Group_access">Password
  and Group access</a></h1>
<dl class="Bl-tag">
  <dt>&quot;GRPASSWD&quot;</dt>
  <dd>This symbol, if defined, indicates to the C program that
      <span class="Li">&quot;struct group&quot;</span> in <i>grp.h</i> contains
      <span class="Li">&quot;gr_passwd&quot;</span>.</dd>
  <dt>&quot;HAS_ENDGRENT&quot;</dt>
  <dd>This symbol, if defined, indicates that the getgrent routine is available
      for finalizing sequential access of the group database.</dd>
  <dt>&quot;HAS_ENDGRENT_R&quot;</dt>
  <dd>This symbol, if defined, indicates that the
      <span class="Li">&quot;endgrent_r&quot;</span> routine is available to
      endgrent re-entrantly.</dd>
  <dt>&quot;HAS_ENDPWENT&quot;</dt>
  <dd>This symbol, if defined, indicates that the getgrent routine is available
      for finalizing sequential access of the passwd database.</dd>
  <dt>&quot;HAS_ENDPWENT_R&quot;</dt>
  <dd>This symbol, if defined, indicates that the
      <span class="Li">&quot;endpwent_r&quot;</span> routine is available to
      endpwent re-entrantly.</dd>
  <dt>&quot;HAS_GETGRENT&quot;</dt>
  <dd>This symbol, if defined, indicates that the
      <span class="Li">&quot;getgrent&quot;</span> routine is available for
      sequential access of the group database.</dd>
  <dt>&quot;HAS_GETGRENT_R&quot;</dt>
  <dd>This symbol, if defined, indicates that the
      <span class="Li">&quot;getgrent_r&quot;</span> routine is available to
      getgrent re-entrantly.</dd>
  <dt>&quot;HAS_GETPWENT&quot;</dt>
  <dd>This symbol, if defined, indicates that the
      <span class="Li">&quot;getpwent&quot;</span> routine is available for
      sequential access of the passwd database. If this is not available, the
      older <span class="Li">&quot;getpw()&quot;</span> function may be
      available.</dd>
  <dt>&quot;HAS_GETPWENT_R&quot;</dt>
  <dd>This symbol, if defined, indicates that the
      <span class="Li">&quot;getpwent_r&quot;</span> routine is available to
      getpwent re-entrantly.</dd>
  <dt>&quot;HAS_SETGRENT&quot;</dt>
  <dd>This symbol, if defined, indicates that the
      <span class="Li">&quot;setgrent&quot;</span> routine is available for
      initializing sequential access of the group database.</dd>
  <dt>&quot;HAS_SETGRENT_R&quot;</dt>
  <dd>This symbol, if defined, indicates that the
      <span class="Li">&quot;setgrent_r&quot;</span> routine is available to
      setgrent re-entrantly.</dd>
  <dt>&quot;HAS_SETPWENT&quot;</dt>
  <dd>This symbol, if defined, indicates that the
      <span class="Li">&quot;setpwent&quot;</span> routine is available for
      initializing sequential access of the passwd database.</dd>
  <dt>&quot;HAS_SETPWENT_R&quot;</dt>
  <dd>This symbol, if defined, indicates that the
      <span class="Li">&quot;setpwent_r&quot;</span> routine is available to
      setpwent re-entrantly.</dd>
  <dt>&quot;PWAGE&quot;</dt>
  <dd>This symbol, if defined, indicates to the C program that
      <span class="Li">&quot;struct passwd&quot;</span> contains
      <span class="Li">&quot;pw_age&quot;</span>.</dd>
  <dt>&quot;PWCHANGE&quot;</dt>
  <dd>This symbol, if defined, indicates to the C program that
      <span class="Li">&quot;struct passwd&quot;</span> contains
      <span class="Li">&quot;pw_change&quot;</span>.</dd>
  <dt>&quot;PWCLASS&quot;</dt>
  <dd>This symbol, if defined, indicates to the C program that
      <span class="Li">&quot;struct passwd&quot;</span> contains
      <span class="Li">&quot;pw_class&quot;</span>.</dd>
  <dt>&quot;PWCOMMENT&quot;</dt>
  <dd>This symbol, if defined, indicates to the C program that
      <span class="Li">&quot;struct passwd&quot;</span> contains
      <span class="Li">&quot;pw_comment&quot;</span>.</dd>
  <dt>&quot;PWEXPIRE&quot;</dt>
  <dd>This symbol, if defined, indicates to the C program that
      <span class="Li">&quot;struct passwd&quot;</span> contains
      <span class="Li">&quot;pw_expire&quot;</span>.</dd>
  <dt>&quot;PWGECOS&quot;</dt>
  <dd>This symbol, if defined, indicates to the C program that
      <span class="Li">&quot;struct passwd&quot;</span> contains
      <span class="Li">&quot;pw_gecos&quot;</span>.</dd>
  <dt>&quot;PWPASSWD&quot;</dt>
  <dd>This symbol, if defined, indicates to the C program that
      <span class="Li">&quot;struct passwd&quot;</span> contains
      <span class="Li">&quot;pw_passwd&quot;</span>.</dd>
  <dt>&quot;PWQUOTA&quot;</dt>
  <dd>This symbol, if defined, indicates to the C program that
      <span class="Li">&quot;struct passwd&quot;</span> contains
      <span class="Li">&quot;pw_quota&quot;</span>.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="Paths_to_system_commands"><a class="permalink" href="#Paths_to_system_commands">Paths
  to system commands</a></h1>
<dl class="Bl-tag">
  <dt>&quot;CSH&quot;</dt>
  <dd>This symbol, if defined, contains the full pathname of csh.</dd>
  <dt>&quot;LOC_SED&quot;</dt>
  <dd>This symbol holds the complete pathname to the sed program.</dd>
  <dt>&quot;SH_PATH&quot;</dt>
  <dd>This symbol contains the full pathname to the shell used on this on this
      system to execute Bourne shell scripts. Usually, this will be
      <i>/bin/sh</i>, though it's possible that some systems will have
      <i>/bin/ksh</i>, <i>/bin/pdksh</i>, <i>/bin/ash</i>, <i>/bin/bash</i>, or
      even something such as D:<i>/bin/sh.exe</i>.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="Prototype_information"><a class="permalink" href="#Prototype_information">Prototype
  information</a></h1>
<dl class="Bl-tag">
  <dt>&quot;CRYPT_R_PROTO&quot;</dt>
  <dd>This symbol encodes the prototype of
      <span class="Li">&quot;crypt_r&quot;</span>. It is zero if
      <span class="Li">&quot;d_crypt_r&quot;</span> is undef, and one of the
      <span class="Li">&quot;REENTRANT_PROTO_T_ABC&quot;</span> macros of
      <i>reentr.h</i> if <span class="Li">&quot;d_crypt_r&quot;</span> is
      defined.</dd>
  <dt>&quot;CTERMID_R_PROTO&quot;</dt>
  <dd>This symbol encodes the prototype of
      <span class="Li">&quot;ctermid_r&quot;</span>. It is zero if
      <span class="Li">&quot;d_ctermid_r&quot;</span> is undef, and one of the
      <span class="Li">&quot;REENTRANT_PROTO_T_ABC&quot;</span> macros of
      <i>reentr.h</i> if <span class="Li">&quot;d_ctermid_r&quot;</span> is
      defined.</dd>
  <dt>&quot;DRAND48_R_PROTO&quot;</dt>
  <dd>This symbol encodes the prototype of
      <span class="Li">&quot;drand48_r&quot;</span>. It is zero if
      <span class="Li">&quot;d_drand48_r&quot;</span> is undef, and one of the
      <span class="Li">&quot;REENTRANT_PROTO_T_ABC&quot;</span> macros of
      <i>reentr.h</i> if <span class="Li">&quot;d_drand48_r&quot;</span> is
      defined.</dd>
  <dt>&quot;ENDGRENT_R_PROTO&quot;</dt>
  <dd>This symbol encodes the prototype of
      <span class="Li">&quot;endgrent_r&quot;</span>. It is zero if
      <span class="Li">&quot;d_endgrent_r&quot;</span> is undef, and one of the
      <span class="Li">&quot;REENTRANT_PROTO_T_ABC&quot;</span> macros of
      <i>reentr.h</i> if <span class="Li">&quot;d_endgrent_r&quot;</span> is
      defined.</dd>
  <dt>&quot;ENDHOSTENT_R_PROTO&quot;</dt>
  <dd>This symbol encodes the prototype of
      <span class="Li">&quot;endhostent_r&quot;</span>. It is zero if
      <span class="Li">&quot;d_endhostent_r&quot;</span> is undef, and one of
      the <span class="Li">&quot;REENTRANT_PROTO_T_ABC&quot;</span> macros of
      <i>reentr.h</i> if <span class="Li">&quot;d_endhostent_r&quot;</span> is
      defined.</dd>
  <dt>&quot;ENDNETENT_R_PROTO&quot;</dt>
  <dd>This symbol encodes the prototype of
      <span class="Li">&quot;endnetent_r&quot;</span>. It is zero if
      <span class="Li">&quot;d_endnetent_r&quot;</span> is undef, and one of the
      <span class="Li">&quot;REENTRANT_PROTO_T_ABC&quot;</span> macros of
      <i>reentr.h</i> if <span class="Li">&quot;d_endnetent_r&quot;</span> is
      defined.</dd>
  <dt>&quot;ENDPROTOENT_R_PROTO&quot;</dt>
  <dd>This symbol encodes the prototype of
      <span class="Li">&quot;endprotoent_r&quot;</span>. It is zero if
      <span class="Li">&quot;d_endprotoent_r&quot;</span> is undef, and one of
      the <span class="Li">&quot;REENTRANT_PROTO_T_ABC&quot;</span> macros of
      <i>reentr.h</i> if <span class="Li">&quot;d_endprotoent_r&quot;</span> is
      defined.</dd>
  <dt>&quot;ENDPWENT_R_PROTO&quot;</dt>
  <dd>This symbol encodes the prototype of
      <span class="Li">&quot;endpwent_r&quot;</span>. It is zero if
      <span class="Li">&quot;d_endpwent_r&quot;</span> is undef, and one of the
      <span class="Li">&quot;REENTRANT_PROTO_T_ABC&quot;</span> macros of
      <i>reentr.h</i> if <span class="Li">&quot;d_endpwent_r&quot;</span> is
      defined.</dd>
  <dt>&quot;ENDSERVENT_R_PROTO&quot;</dt>
  <dd>This symbol encodes the prototype of
      <span class="Li">&quot;endservent_r&quot;</span>. It is zero if
      <span class="Li">&quot;d_endservent_r&quot;</span> is undef, and one of
      the <span class="Li">&quot;REENTRANT_PROTO_T_ABC&quot;</span> macros of
      <i>reentr.h</i> if <span class="Li">&quot;d_endservent_r&quot;</span> is
      defined.</dd>
  <dt>&quot;GDBMNDBM_H_USES_PROTOTYPES&quot;</dt>
  <dd>This symbol, if defined, indicates that <i>gdbm/ndbm.h</i> uses real
      <span class="Li">&quot;ANSI&quot;</span> C prototypes instead of K&amp;R
      style function declarations without any parameter information. While
      <span class="Li">&quot;ANSI&quot;</span> C prototypes are supported in
      C++, K&amp;R style function declarations will yield errors.</dd>
  <dt>&quot;GDBM_NDBM_H_USES_PROTOTYPES&quot;</dt>
  <dd>This symbol, if defined, indicates that &lt;gdbm-<i>ndbm.h</i>&gt; uses
      real <span class="Li">&quot;ANSI&quot;</span> C prototypes instead of
      K&amp;R style function declarations without any parameter information.
      While <span class="Li">&quot;ANSI&quot;</span> C prototypes are supported
      in C++, K&amp;R style function declarations will yield errors.</dd>
  <dt>&quot;GETGRENT_R_PROTO&quot;</dt>
  <dd>This symbol encodes the prototype of
      <span class="Li">&quot;getgrent_r&quot;</span>. It is zero if
      <span class="Li">&quot;d_getgrent_r&quot;</span> is undef, and one of the
      <span class="Li">&quot;REENTRANT_PROTO_T_ABC&quot;</span> macros of
      <i>reentr.h</i> if <span class="Li">&quot;d_getgrent_r&quot;</span> is
      defined.</dd>
  <dt>&quot;GETGRGID_R_PROTO&quot;</dt>
  <dd>This symbol encodes the prototype of
      <span class="Li">&quot;getgrgid_r&quot;</span>. It is zero if
      <span class="Li">&quot;d_getgrgid_r&quot;</span> is undef, and one of the
      <span class="Li">&quot;REENTRANT_PROTO_T_ABC&quot;</span> macros of
      <i>reentr.h</i> if <span class="Li">&quot;d_getgrgid_r&quot;</span> is
      defined.</dd>
  <dt>&quot;GETGRNAM_R_PROTO&quot;</dt>
  <dd>This symbol encodes the prototype of
      <span class="Li">&quot;getgrnam_r&quot;</span>. It is zero if
      <span class="Li">&quot;d_getgrnam_r&quot;</span> is undef, and one of the
      <span class="Li">&quot;REENTRANT_PROTO_T_ABC&quot;</span> macros of
      <i>reentr.h</i> if <span class="Li">&quot;d_getgrnam_r&quot;</span> is
      defined.</dd>
  <dt>&quot;GETHOSTBYADDR_R_PROTO&quot;</dt>
  <dd>This symbol encodes the prototype of
      <span class="Li">&quot;gethostbyaddr_r&quot;</span>. It is zero if
      <span class="Li">&quot;d_gethostbyaddr_r&quot;</span> is undef, and one of
      the <span class="Li">&quot;REENTRANT_PROTO_T_ABC&quot;</span> macros of
      <i>reentr.h</i> if <span class="Li">&quot;d_gethostbyaddr_r&quot;</span>
      is defined.</dd>
  <dt>&quot;GETHOSTBYNAME_R_PROTO&quot;</dt>
  <dd>This symbol encodes the prototype of
      <span class="Li">&quot;gethostbyname_r&quot;</span>. It is zero if
      <span class="Li">&quot;d_gethostbyname_r&quot;</span> is undef, and one of
      the <span class="Li">&quot;REENTRANT_PROTO_T_ABC&quot;</span> macros of
      <i>reentr.h</i> if <span class="Li">&quot;d_gethostbyname_r&quot;</span>
      is defined.</dd>
  <dt>&quot;GETHOSTENT_R_PROTO&quot;</dt>
  <dd>This symbol encodes the prototype of
      <span class="Li">&quot;gethostent_r&quot;</span>. It is zero if
      <span class="Li">&quot;d_gethostent_r&quot;</span> is undef, and one of
      the <span class="Li">&quot;REENTRANT_PROTO_T_ABC&quot;</span> macros of
      <i>reentr.h</i> if <span class="Li">&quot;d_gethostent_r&quot;</span> is
      defined.</dd>
  <dt>&quot;GETLOGIN_R_PROTO&quot;</dt>
  <dd>This symbol encodes the prototype of
      <span class="Li">&quot;getlogin_r&quot;</span>. It is zero if
      <span class="Li">&quot;d_getlogin_r&quot;</span> is undef, and one of the
      <span class="Li">&quot;REENTRANT_PROTO_T_ABC&quot;</span> macros of
      <i>reentr.h</i> if <span class="Li">&quot;d_getlogin_r&quot;</span> is
      defined.</dd>
  <dt>&quot;GETNETBYADDR_R_PROTO&quot;</dt>
  <dd>This symbol encodes the prototype of
      <span class="Li">&quot;getnetbyaddr_r&quot;</span>. It is zero if
      <span class="Li">&quot;d_getnetbyaddr_r&quot;</span> is undef, and one of
      the <span class="Li">&quot;REENTRANT_PROTO_T_ABC&quot;</span> macros of
      <i>reentr.h</i> if <span class="Li">&quot;d_getnetbyaddr_r&quot;</span> is
      defined.</dd>
  <dt>&quot;GETNETBYNAME_R_PROTO&quot;</dt>
  <dd>This symbol encodes the prototype of
      <span class="Li">&quot;getnetbyname_r&quot;</span>. It is zero if
      <span class="Li">&quot;d_getnetbyname_r&quot;</span> is undef, and one of
      the <span class="Li">&quot;REENTRANT_PROTO_T_ABC&quot;</span> macros of
      <i>reentr.h</i> if <span class="Li">&quot;d_getnetbyname_r&quot;</span> is
      defined.</dd>
  <dt>&quot;GETNETENT_R_PROTO&quot;</dt>
  <dd>This symbol encodes the prototype of
      <span class="Li">&quot;getnetent_r&quot;</span>. It is zero if
      <span class="Li">&quot;d_getnetent_r&quot;</span> is undef, and one of the
      <span class="Li">&quot;REENTRANT_PROTO_T_ABC&quot;</span> macros of
      <i>reentr.h</i> if <span class="Li">&quot;d_getnetent_r&quot;</span> is
      defined.</dd>
  <dt>&quot;GETPROTOBYNAME_R_PROTO&quot;</dt>
  <dd>This symbol encodes the prototype of
      <span class="Li">&quot;getprotobyname_r&quot;</span>. It is zero if
      <span class="Li">&quot;d_getprotobyname_r&quot;</span> is undef, and one
      of the <span class="Li">&quot;REENTRANT_PROTO_T_ABC&quot;</span> macros of
      <i>reentr.h</i> if <span class="Li">&quot;d_getprotobyname_r&quot;</span>
      is defined.</dd>
  <dt>&quot;GETPROTOBYNUMBER_R_PROTO&quot;</dt>
  <dd>This symbol encodes the prototype of
      <span class="Li">&quot;getprotobynumber_r&quot;</span>. It is zero if
      <span class="Li">&quot;d_getprotobynumber_r&quot;</span> is undef, and one
      of the <span class="Li">&quot;REENTRANT_PROTO_T_ABC&quot;</span> macros of
      <i>reentr.h</i> if
      <span class="Li">&quot;d_getprotobynumber_r&quot;</span> is defined.</dd>
  <dt>&quot;GETPROTOENT_R_PROTO&quot;</dt>
  <dd>This symbol encodes the prototype of
      <span class="Li">&quot;getprotoent_r&quot;</span>. It is zero if
      <span class="Li">&quot;d_getprotoent_r&quot;</span> is undef, and one of
      the <span class="Li">&quot;REENTRANT_PROTO_T_ABC&quot;</span> macros of
      <i>reentr.h</i> if <span class="Li">&quot;d_getprotoent_r&quot;</span> is
      defined.</dd>
  <dt>&quot;GETPWENT_R_PROTO&quot;</dt>
  <dd>This symbol encodes the prototype of
      <span class="Li">&quot;getpwent_r&quot;</span>. It is zero if
      <span class="Li">&quot;d_getpwent_r&quot;</span> is undef, and one of the
      <span class="Li">&quot;REENTRANT_PROTO_T_ABC&quot;</span> macros of
      <i>reentr.h</i> if <span class="Li">&quot;d_getpwent_r&quot;</span> is
      defined.</dd>
  <dt>&quot;GETPWNAM_R_PROTO&quot;</dt>
  <dd>This symbol encodes the prototype of
      <span class="Li">&quot;getpwnam_r&quot;</span>. It is zero if
      <span class="Li">&quot;d_getpwnam_r&quot;</span> is undef, and one of the
      <span class="Li">&quot;REENTRANT_PROTO_T_ABC&quot;</span> macros of
      <i>reentr.h</i> if <span class="Li">&quot;d_getpwnam_r&quot;</span> is
      defined.</dd>
  <dt>&quot;GETPWUID_R_PROTO&quot;</dt>
  <dd>This symbol encodes the prototype of
      <span class="Li">&quot;getpwuid_r&quot;</span>. It is zero if
      <span class="Li">&quot;d_getpwuid_r&quot;</span> is undef, and one of the
      <span class="Li">&quot;REENTRANT_PROTO_T_ABC&quot;</span> macros of
      <i>reentr.h</i> if <span class="Li">&quot;d_getpwuid_r&quot;</span> is
      defined.</dd>
  <dt>&quot;GETSERVBYNAME_R_PROTO&quot;</dt>
  <dd>This symbol encodes the prototype of
      <span class="Li">&quot;getservbyname_r&quot;</span>. It is zero if
      <span class="Li">&quot;d_getservbyname_r&quot;</span> is undef, and one of
      the <span class="Li">&quot;REENTRANT_PROTO_T_ABC&quot;</span> macros of
      <i>reentr.h</i> if <span class="Li">&quot;d_getservbyname_r&quot;</span>
      is defined.</dd>
  <dt>&quot;GETSERVBYPORT_R_PROTO&quot;</dt>
  <dd>This symbol encodes the prototype of
      <span class="Li">&quot;getservbyport_r&quot;</span>. It is zero if
      <span class="Li">&quot;d_getservbyport_r&quot;</span> is undef, and one of
      the <span class="Li">&quot;REENTRANT_PROTO_T_ABC&quot;</span> macros of
      <i>reentr.h</i> if <span class="Li">&quot;d_getservbyport_r&quot;</span>
      is defined.</dd>
  <dt>&quot;GETSERVENT_R_PROTO&quot;</dt>
  <dd>This symbol encodes the prototype of
      <span class="Li">&quot;getservent_r&quot;</span>. It is zero if
      <span class="Li">&quot;d_getservent_r&quot;</span> is undef, and one of
      the <span class="Li">&quot;REENTRANT_PROTO_T_ABC&quot;</span> macros of
      <i>reentr.h</i> if <span class="Li">&quot;d_getservent_r&quot;</span> is
      defined.</dd>
  <dt>&quot;GETSPNAM_R_PROTO&quot;</dt>
  <dd>This symbol encodes the prototype of
      <span class="Li">&quot;getspnam_r&quot;</span>. It is zero if
      <span class="Li">&quot;d_getspnam_r&quot;</span> is undef, and one of the
      <span class="Li">&quot;REENTRANT_PROTO_T_ABC&quot;</span> macros of
      <i>reentr.h</i> if <span class="Li">&quot;d_getspnam_r&quot;</span> is
      defined.</dd>
  <dt>&quot;HAS_DBMINIT_PROTO&quot;</dt>
  <dd>This symbol, if defined, indicates that the system provides a prototype
      for the <span class="Li">&quot;dbminit()&quot;</span> function. Otherwise,
      it is up to the program to supply one. A good guess is
    <p class="Pp"></p>
    <pre> extern int dbminit(char *);
    </pre>
  </dd>
  <dt>&quot;HAS_DRAND48_PROTO&quot;</dt>
  <dd>This symbol, if defined, indicates that the system provides a prototype
      for the <span class="Li">&quot;drand48()&quot;</span> function. Otherwise,
      it is up to the program to supply one. A good guess is
    <p class="Pp"></p>
    <pre> extern double drand48(void);
    </pre>
  </dd>
  <dt>&quot;HAS_FLOCK_PROTO&quot;</dt>
  <dd>This symbol, if defined, indicates that the system provides a prototype
      for the <span class="Li">&quot;flock()&quot;</span> function. Otherwise,
      it is up to the program to supply one. A good guess is
    <p class="Pp"></p>
    <pre> extern int flock(int, int);
    </pre>
  </dd>
  <dt>&quot;HAS_GETHOST_PROTOS&quot;</dt>
  <dd>This symbol, if defined, indicates that <i>netdb.h</i> includes prototypes
      for <span class="Li">&quot;gethostent()&quot;</span>,
      <span class="Li">&quot;gethostbyname()&quot;</span>, and
      <span class="Li">&quot;gethostbyaddr()&quot;</span>. Otherwise, it is up
      to the program to guess them. See netdbtype.U (part of metaconfig) for
      probing for various <span class="Li">&quot;Netdb_xxx_t&quot;</span>
    types.</dd>
  <dt>&quot;HAS_GETNET_PROTOS&quot;</dt>
  <dd>This symbol, if defined, indicates that <i>netdb.h</i> includes prototypes
      for <span class="Li">&quot;getnetent()&quot;</span>,
      <span class="Li">&quot;getnetbyname()&quot;</span>, and
      <span class="Li">&quot;getnetbyaddr()&quot;</span>. Otherwise, it is up to
      the program to guess them. See netdbtype.U (part of metaconfig) for
      probing for various <span class="Li">&quot;Netdb_xxx_t&quot;</span>
    types.</dd>
  <dt>&quot;HAS_GETPROTO_PROTOS&quot;</dt>
  <dd>This symbol, if defined, indicates that <i>netdb.h</i> includes prototypes
      for <span class="Li">&quot;getprotoent()&quot;</span>,
      <span class="Li">&quot;getprotobyname()&quot;</span>, and
      <span class="Li">&quot;getprotobyaddr()&quot;</span>. Otherwise, it is up
      to the program to guess them. See netdbtype.U (part of metaconfig) for
      probing for various <span class="Li">&quot;Netdb_xxx_t&quot;</span>
    types.</dd>
  <dt>&quot;HAS_GETSERV_PROTOS&quot;</dt>
  <dd>This symbol, if defined, indicates that <i>netdb.h</i> includes prototypes
      for <span class="Li">&quot;getservent()&quot;</span>,
      <span class="Li">&quot;getservbyname()&quot;</span>, and
      <span class="Li">&quot;getservbyaddr()&quot;</span>. Otherwise, it is up
      to the program to guess them. See netdbtype.U (part of metaconfig) for
      probing for various <span class="Li">&quot;Netdb_xxx_t&quot;</span>
    types.</dd>
  <dt>&quot;HAS_MODFL_PROTO&quot;</dt>
  <dd>This symbol, if defined, indicates that the system provides a prototype
      for the <span class="Li">&quot;modfl()&quot;</span> function. Otherwise,
      it is up to the program to supply one.</dd>
  <dt>&quot;HAS_SBRK_PROTO&quot;</dt>
  <dd>This symbol, if defined, indicates that the system provides a prototype
      for the <span class="Li">&quot;sbrk()&quot;</span> function. Otherwise, it
      is up to the program to supply one. Good guesses are
    <p class="Pp"></p>
    <pre> extern void* sbrk(int);
 extern void* sbrk(size_t);
    </pre>
  </dd>
  <dt>&quot;HAS_SETRESGID_PROTO&quot;</dt>
  <dd>This symbol, if defined, indicates that the system provides a prototype
      for the <span class="Li">&quot;setresgid()&quot;</span> function.
      Otherwise, it is up to the program to supply one. Good guesses are
    <p class="Pp"></p>
    <pre> extern int setresgid(uid_t ruid, uid_t euid, uid_t suid);
    </pre>
  </dd>
  <dt>&quot;HAS_SETRESUID_PROTO&quot;</dt>
  <dd>This symbol, if defined, indicates that the system provides a prototype
      for the <span class="Li">&quot;setresuid()&quot;</span> function.
      Otherwise, it is up to the program to supply one. Good guesses are
    <p class="Pp"></p>
    <pre> extern int setresuid(uid_t ruid, uid_t euid, uid_t suid);
    </pre>
  </dd>
  <dt>&quot;HAS_SHMAT_PROTOTYPE&quot;</dt>
  <dd>This symbol, if defined, indicates that the <i>sys/shm.h</i> includes a
      prototype for <span class="Li">&quot;shmat()&quot;</span>. Otherwise, it
      is up to the program to guess one.
      <span class="Li">&quot;Shmat_t&quot;</span>
      <span class="Li">&quot;shmat(int, Shmat_t, int)&quot;</span> is a good
      guess, but not always right so it should be emitted by the program only
      when <span class="Li">&quot;HAS_SHMAT_PROTOTYPE&quot;</span> is not
      defined to avoid conflicting defs.</dd>
  <dt>&quot;HAS_SOCKATMARK_PROTO&quot;</dt>
  <dd>This symbol, if defined, indicates that the system provides a prototype
      for the <span class="Li">&quot;sockatmark()&quot;</span> function.
      Otherwise, it is up to the program to supply one. A good guess is
    <p class="Pp"></p>
    <pre> extern int sockatmark(int);
    </pre>
  </dd>
  <dt>&quot;HAS_SYSCALL_PROTO&quot;</dt>
  <dd>This symbol, if defined, indicates that the system provides a prototype
      for the <span class="Li">&quot;syscall()&quot;</span> function. Otherwise,
      it is up to the program to supply one. Good guesses are
    <p class="Pp"></p>
    <pre> extern int syscall(int,  ...);
 extern int syscall(long, ...);
    </pre>
  </dd>
  <dt>&quot;HAS_TELLDIR_PROTO&quot;</dt>
  <dd>This symbol, if defined, indicates that the system provides a prototype
      for the <span class="Li">&quot;telldir()&quot;</span> function. Otherwise,
      it is up to the program to supply one. A good guess is
    <p class="Pp"></p>
    <pre> extern long telldir(DIR*);
    </pre>
  </dd>
  <dt>&quot;NDBM_H_USES_PROTOTYPES&quot;</dt>
  <dd>This symbol, if defined, indicates that <i>ndbm.h</i> uses real
      <span class="Li">&quot;ANSI&quot;</span> C prototypes instead of K&amp;R
      style function declarations without any parameter information. While
      <span class="Li">&quot;ANSI&quot;</span> C prototypes are supported in
      C++, K&amp;R style function declarations will yield errors.</dd>
  <dt>&quot;RANDOM_R_PROTO&quot;</dt>
  <dd>This symbol encodes the prototype of
      <span class="Li">&quot;random_r&quot;</span>. It is zero if
      <span class="Li">&quot;d_random_r&quot;</span> is undef, and one of the
      <span class="Li">&quot;REENTRANT_PROTO_T_ABC&quot;</span> macros of
      <i>reentr.h</i> if <span class="Li">&quot;d_random_r&quot;</span> is
      defined.</dd>
  <dt>&quot;READDIR_R_PROTO&quot;</dt>
  <dd>This symbol encodes the prototype of
      <span class="Li">&quot;readdir_r&quot;</span>. It is zero if
      <span class="Li">&quot;d_readdir_r&quot;</span> is undef, and one of the
      <span class="Li">&quot;REENTRANT_PROTO_T_ABC&quot;</span> macros of
      <i>reentr.h</i> if <span class="Li">&quot;d_readdir_r&quot;</span> is
      defined.</dd>
  <dt>&quot;SETGRENT_R_PROTO&quot;</dt>
  <dd>This symbol encodes the prototype of
      <span class="Li">&quot;setgrent_r&quot;</span>. It is zero if
      <span class="Li">&quot;d_setgrent_r&quot;</span> is undef, and one of the
      <span class="Li">&quot;REENTRANT_PROTO_T_ABC&quot;</span> macros of
      <i>reentr.h</i> if <span class="Li">&quot;d_setgrent_r&quot;</span> is
      defined.</dd>
  <dt>&quot;SETHOSTENT_R_PROTO&quot;</dt>
  <dd>This symbol encodes the prototype of
      <span class="Li">&quot;sethostent_r&quot;</span>. It is zero if
      <span class="Li">&quot;d_sethostent_r&quot;</span> is undef, and one of
      the <span class="Li">&quot;REENTRANT_PROTO_T_ABC&quot;</span> macros of
      <i>reentr.h</i> if <span class="Li">&quot;d_sethostent_r&quot;</span> is
      defined.</dd>
  <dt>&quot;SETLOCALE_R_PROTO&quot;</dt>
  <dd>This symbol encodes the prototype of
      <span class="Li">&quot;setlocale_r&quot;</span>. It is zero if
      <span class="Li">&quot;d_setlocale_r&quot;</span> is undef, and one of the
      <span class="Li">&quot;REENTRANT_PROTO_T_ABC&quot;</span> macros of
      <i>reentr.h</i> if <span class="Li">&quot;d_setlocale_r&quot;</span> is
      defined.</dd>
  <dt>&quot;SETNETENT_R_PROTO&quot;</dt>
  <dd>This symbol encodes the prototype of
      <span class="Li">&quot;setnetent_r&quot;</span>. It is zero if
      <span class="Li">&quot;d_setnetent_r&quot;</span> is undef, and one of the
      <span class="Li">&quot;REENTRANT_PROTO_T_ABC&quot;</span> macros of
      <i>reentr.h</i> if <span class="Li">&quot;d_setnetent_r&quot;</span> is
      defined.</dd>
  <dt>&quot;SETPROTOENT_R_PROTO&quot;</dt>
  <dd>This symbol encodes the prototype of
      <span class="Li">&quot;setprotoent_r&quot;</span>. It is zero if
      <span class="Li">&quot;d_setprotoent_r&quot;</span> is undef, and one of
      the <span class="Li">&quot;REENTRANT_PROTO_T_ABC&quot;</span> macros of
      <i>reentr.h</i> if <span class="Li">&quot;d_setprotoent_r&quot;</span> is
      defined.</dd>
  <dt>&quot;SETPWENT_R_PROTO&quot;</dt>
  <dd>This symbol encodes the prototype of
      <span class="Li">&quot;setpwent_r&quot;</span>. It is zero if
      <span class="Li">&quot;d_setpwent_r&quot;</span> is undef, and one of the
      <span class="Li">&quot;REENTRANT_PROTO_T_ABC&quot;</span> macros of
      <i>reentr.h</i> if <span class="Li">&quot;d_setpwent_r&quot;</span> is
      defined.</dd>
  <dt>&quot;SETSERVENT_R_PROTO&quot;</dt>
  <dd>This symbol encodes the prototype of
      <span class="Li">&quot;setservent_r&quot;</span>. It is zero if
      <span class="Li">&quot;d_setservent_r&quot;</span> is undef, and one of
      the <span class="Li">&quot;REENTRANT_PROTO_T_ABC&quot;</span> macros of
      <i>reentr.h</i> if <span class="Li">&quot;d_setservent_r&quot;</span> is
      defined.</dd>
  <dt>&quot;SRAND48_R_PROTO&quot;</dt>
  <dd>This symbol encodes the prototype of
      <span class="Li">&quot;srand48_r&quot;</span>. It is zero if
      <span class="Li">&quot;d_srand48_r&quot;</span> is undef, and one of the
      <span class="Li">&quot;REENTRANT_PROTO_T_ABC&quot;</span> macros of
      <i>reentr.h</i> if <span class="Li">&quot;d_srand48_r&quot;</span> is
      defined.</dd>
  <dt>&quot;SRANDOM_R_PROTO&quot;</dt>
  <dd>This symbol encodes the prototype of
      <span class="Li">&quot;srandom_r&quot;</span>. It is zero if
      <span class="Li">&quot;d_srandom_r&quot;</span> is undef, and one of the
      <span class="Li">&quot;REENTRANT_PROTO_T_ABC&quot;</span> macros of
      <i>reentr.h</i> if <span class="Li">&quot;d_srandom_r&quot;</span> is
      defined.</dd>
  <dt>&quot;STRERROR_R_PROTO&quot;</dt>
  <dd>This symbol encodes the prototype of
      <span class="Li">&quot;strerror_r&quot;</span>. It is zero if
      <span class="Li">&quot;d_strerror_r&quot;</span> is undef, and one of the
      <span class="Li">&quot;REENTRANT_PROTO_T_ABC&quot;</span> macros of
      <i>reentr.h</i> if <span class="Li">&quot;d_strerror_r&quot;</span> is
      defined.</dd>
  <dt>&quot;TMPNAM_R_PROTO&quot;</dt>
  <dd>This symbol encodes the prototype of
      <span class="Li">&quot;tmpnam_r&quot;</span>. It is zero if
      <span class="Li">&quot;d_tmpnam_r&quot;</span> is undef, and one of the
      <span class="Li">&quot;REENTRANT_PROTO_T_ABC&quot;</span> macros of
      <i>reentr.h</i> if <span class="Li">&quot;d_tmpnam_r&quot;</span> is
      defined.</dd>
  <dt>&quot;TTYNAME_R_PROTO&quot;</dt>
  <dd>This symbol encodes the prototype of
      <span class="Li">&quot;ttyname_r&quot;</span>. It is zero if
      <span class="Li">&quot;d_ttyname_r&quot;</span> is undef, and one of the
      <span class="Li">&quot;REENTRANT_PROTO_T_ABC&quot;</span> macros of
      <i>reentr.h</i> if <span class="Li">&quot;d_ttyname_r&quot;</span> is
      defined.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="REGEXP_Functions"><a class="permalink" href="#REGEXP_Functions">REGEXP
  Functions</a></h1>
<dl class="Bl-tag">
  <dt>&quot;pregcomp&quot;</dt>
  <dd>Described in perlreguts.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> REGEXP*  pregcomp(SV * const pattern, const U32 flags)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;pregexec&quot;</dt>
  <dd>Described in perlreguts.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> I32  pregexec(REGEXP * const prog, char* stringarg, char* strend,
               char* strbeg, SSize_t minend, SV* screamer,
               U32 nosave)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;re_dup_guts&quot;</dt>
  <dd>Duplicate a regexp.
    <p class="Pp">This routine is expected to clone a given regexp structure. It
        is only compiled under USE_ITHREADS.</p>
    <p class="Pp">After all of the core data stored in struct regexp is
        duplicated the <span class="Li">&quot;regexp_engine.dupe&quot;</span>
        method is used to copy any private data stored in the *pprivate pointer.
        This allows extensions to handle any duplication they need to do.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  re_dup_guts(const REGEXP *sstr, REGEXP *dstr,
                   CLONE_PARAMS* param)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;regmatch_info&quot;</dt>
  <dd>Some basic information about the current match that is created by
      Perl_regexec_flags and then passed to <b>regtry()</b>, <b>regmatch()</b>
      etc. It is allocated as a local var on the stack, so nothing should be
      stored in it that needs preserving or clearing up on <b>croak()</b>. For
      that, see the aux_info and aux_info_eval members of the regmatch_state
      union.</dd>
  <dt>&quot;SvRX&quot;</dt>
  <dd>Convenience macro to get the REGEXP from a SV. This is approximately
      equivalent to the following snippet:
    <p class="Pp"></p>
    <pre>    if (SvMAGICAL(sv))
        mg_get(sv);
    if (SvROK(sv))
        sv = MUTABLE_SV(SvRV(sv));
    if (SvTYPE(sv) == SVt_REGEXP)
        return (REGEXP*) sv;
    </pre>
    <p class="Pp"><span class="Li">&quot;NULL&quot;</span> will be returned if a
        REGEXP* is not found.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> REGEXP *  SvRX(SV *sv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;SvRXOK&quot;</dt>
  <dd>Returns a boolean indicating whether the SV (or the one it references) is
      a REGEXP.
    <p class="Pp">If you want to do something with the REGEXP* later use SvRX
        instead and check for NULL.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> bool  SvRXOK(SV* sv)
</pre>
</div>
<div class="Bd-indent"></div>
</section>
<section class="Sh">
<h1 class="Sh" id="Signals"><a class="permalink" href="#Signals">Signals</a></h1>
<dl class="Bl-tag">
  <dt>&quot;HAS_SIGINFO_SI_ADDR&quot;</dt>
  <dd>This symbol, if defined, indicates that
      <span class="Li">&quot;siginfo_t&quot;</span> has the
      <span class="Li">&quot;si_addr&quot;</span> member</dd>
  <dt>&quot;HAS_SIGINFO_SI_BAND&quot;</dt>
  <dd>This symbol, if defined, indicates that
      <span class="Li">&quot;siginfo_t&quot;</span> has the
      <span class="Li">&quot;si_band&quot;</span> member</dd>
  <dt>&quot;HAS_SIGINFO_SI_ERRNO&quot;</dt>
  <dd>This symbol, if defined, indicates that
      <span class="Li">&quot;siginfo_t&quot;</span> has the
      <span class="Li">&quot;si_errno&quot;</span> member</dd>
  <dt>&quot;HAS_SIGINFO_SI_PID&quot;</dt>
  <dd>This symbol, if defined, indicates that
      <span class="Li">&quot;siginfo_t&quot;</span> has the
      <span class="Li">&quot;si_pid&quot;</span> member</dd>
  <dt>&quot;HAS_SIGINFO_SI_STATUS&quot;</dt>
  <dd>This symbol, if defined, indicates that
      <span class="Li">&quot;siginfo_t&quot;</span> has the
      <span class="Li">&quot;si_status&quot;</span> member</dd>
  <dt>&quot;HAS_SIGINFO_SI_UID&quot;</dt>
  <dd>This symbol, if defined, indicates that
      <span class="Li">&quot;siginfo_t&quot;</span> has the
      <span class="Li">&quot;si_uid&quot;</span> member</dd>
  <dt>&quot;HAS_SIGINFO_SI_VALUE&quot;</dt>
  <dd>This symbol, if defined, indicates that
      <span class="Li">&quot;siginfo_t&quot;</span> has the
      <span class="Li">&quot;si_value&quot;</span> member</dd>
  <dt>&quot;PERL_SIGNALS_UNSAFE_FLAG&quot;</dt>
  <dd>If this bit in <span class="Li">&quot;PL_signals&quot;</span> is set, the
      system is uing the pre-Perl 5.8 unsafe signals. See
      &quot;PERL_SIGNALS&quot; in perlrun and &quot;Deferred Signals (Safe
      Signals)&quot; in perlipc.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> U32  PERL_SIGNALS_UNSAFE_FLAG
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;rsignal&quot;</dt>
  <dd>A wrapper for the C library <b>signal</b>(2). Don't use the latter, as the
      Perl version knows things that interact with the rest of the perl
      interpreter.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> Sighandler_t  rsignal(int i, Sighandler_t t)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;Sigjmp_buf&quot;</dt>
  <dd>This is the buffer type to be used with Sigsetjmp and Siglongjmp.</dd>
  <dt>&quot;Siglongjmp&quot;</dt>
  <dd>This macro is used in the same way as
      <span class="Li">&quot;siglongjmp()&quot;</span>, but will invoke
      traditional <span class="Li">&quot;longjmp()&quot;</span> if siglongjmp
      isn't available. See
    <span class="Li">&quot;HAS_SIGSETJMP&quot;</span>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  Siglongjmp(jmp_buf env, int val)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;SIG_NAME&quot;</dt>
  <dd>This symbol contains a list of signal names in order of signal number.
      This is intended to be used as a static array initialization, like this:
    <p class="Pp"></p>
    <pre> char *sig_name[] = { SIG_NAME };
    </pre>
    <p class="Pp">The signals in the list are separated with commas, and each
        signal is surrounded by double quotes. There is no leading
        <span class="Li">&quot;SIG&quot;</span> in the signal name, i.e.
        <span class="Li">&quot;SIGQUIT&quot;</span> is known as
        &quot;<span class="Li">&quot;QUIT&quot;</span>&quot;. Gaps in the signal
        numbers (up to <span class="Li">&quot;NSIG&quot;</span>) are filled in
        with <span class="Li">&quot;NUMnn&quot;</span>, etc., where nn is the
        actual signal number (e.g. <span class="Li">&quot;NUM37&quot;</span>).
        The signal number for <span class="Li">&quot;sig_name[i]&quot;</span> is
        stored in <span class="Li">&quot;sig_num[i]&quot;</span>. The last
        element is 0 to terminate the list with a
        <span class="Li">&quot;NULL&quot;</span>. This corresponds to the 0 at
        the end of the <span class="Li">&quot;sig_name_init&quot;</span> list.
        Note that this variable is initialized from the
        <span class="Li">&quot;sig_name_init&quot;</span>, not from
        <span class="Li">&quot;sig_name&quot;</span> (which is unused).</p>
  </dd>
  <dt>&quot;SIG_NUM&quot;</dt>
  <dd>This symbol contains a list of signal numbers, in the same order as the
      <span class="Li">&quot;SIG_NAME&quot;</span> list. It is suitable for
      static array initialization, as in:
    <p class="Pp"></p>
    <pre> int sig_num[] = { SIG_NUM };
    </pre>
    <p class="Pp">The signals in the list are separated with commas, and the
        indices within that list and the
        <span class="Li">&quot;SIG_NAME&quot;</span> list match, so it's easy to
        compute the signal name from a number or vice versa at the price of a
        small dynamic linear lookup. Duplicates are allowed, but are moved to
        the end of the list. The signal number corresponding to
        <span class="Li">&quot;sig_name[i]&quot;</span> is
        <span class="Li">&quot;sig_number[i]&quot;</span>. if (i &lt;
        <span class="Li">&quot;NSIG&quot;</span>) then
        <span class="Li">&quot;sig_number[i]&quot;</span> == i. The last element
        is 0, corresponding to the 0 at the end of the
        <span class="Li">&quot;sig_name_init&quot;</span> list. Note that this
        variable is initialized from the
        <span class="Li">&quot;sig_num_init&quot;</span>, not from
        <span class="Li">&quot;sig_num&quot;</span> (which is unused).</p>
  </dd>
  <dt>&quot;Sigsetjmp&quot;</dt>
  <dd>This macro is used in the same way as
      <span class="Li">&quot;sigsetjmp()&quot;</span>, but will invoke
      traditional <span class="Li">&quot;setjmp()&quot;</span> if sigsetjmp
      isn't available. See
    <span class="Li">&quot;HAS_SIGSETJMP&quot;</span>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> int  Sigsetjmp(jmp_buf env, int savesigs)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;SIG_SIZE&quot;</dt>
  <dd>This variable contains the number of elements of the
      <span class="Li">&quot;SIG_NAME&quot;</span> and
      <span class="Li">&quot;SIG_NUM&quot;</span> arrays, excluding the final
      <span class="Li">&quot;NULL&quot;</span> entry.</dd>
  <dt>&quot;whichsig&quot;</dt>
  <dd></dd>
  <dt>&quot;whichsig_pv&quot;</dt>
  <dd></dd>
  <dt>&quot;whichsig_pvn&quot;</dt>
  <dd></dd>
  <dt>&quot;whichsig_sv&quot;</dt>
  <dd>These all convert a signal name into its corresponding signal number;
      returning -1 if no corresponding number was found.
    <p class="Pp">They differ only in the source of the signal name:</p>
    <p class="Pp"><span class="Li">&quot;whichsig_pv&quot;</span> takes the name
        from the <span class="Li">&quot;NUL&quot;</span>-terminated string
        starting at <span class="Li">&quot;sig&quot;</span>.</p>
    <p class="Pp"><span class="Li">&quot;whichsig&quot;</span> is merely a
        different spelling, a synonym, of
        <span class="Li">&quot;whichsig_pv&quot;</span>.</p>
    <p class="Pp"><span class="Li">&quot;whichsig_pvn&quot;</span> takes the
        name from the string starting at
        <span class="Li">&quot;sig&quot;</span>, with length
        <span class="Li">&quot;len&quot;</span> bytes.</p>
    <p class="Pp"><span class="Li">&quot;whichsig_sv&quot;</span> takes the name
        from the PV stored in the SV
      <span class="Li">&quot;sigsv&quot;</span>.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> I32  whichsig    (const char* sig)
 I32  whichsig_pv (const char* sig)
 I32  whichsig_pvn(const char* sig, STRLEN len)
 I32  whichsig_sv (SV* sigsv)
</pre>
</div>
<div class="Bd-indent"></div>
</section>
<section class="Sh">
<h1 class="Sh" id="Site_configuration"><a class="permalink" href="#Site_configuration">Site
  configuration</a></h1>
<p class="Pp">These variables give details as to where various libraries,
    installation destinations, <i>etc.</i>, go, as well as what various
    installation options were selected</p>
<dl class="Bl-tag">
  <dt>&quot;ARCHLIB&quot;</dt>
  <dd>This variable, if defined, holds the name of the directory in which the
      user wants to put architecture-dependent public library files for perl5.
      It is most often a local directory such as <i>/usr/local/lib</i>. Programs
      using this variable must be prepared to deal with filename expansion. If
      <span class="Li">&quot;ARCHLIB&quot;</span> is the same as
      <span class="Li">&quot;PRIVLIB&quot;</span>, it is not defined, since
      presumably the program already searches
      <span class="Li">&quot;PRIVLIB&quot;</span>.</dd>
  <dt>&quot;ARCHLIB_EXP&quot;</dt>
  <dd>This symbol contains the ~name expanded version of
      <span class="Li">&quot;ARCHLIB&quot;</span>, to be used in programs that
      are not prepared to deal with ~ expansion at run-time.</dd>
  <dt>&quot;ARCHNAME&quot;</dt>
  <dd>This symbol holds a string representing the architecture name. It may be
      used to construct an architecture-dependant pathname where library files
      may be held under a private library, for instance.</dd>
  <dt>&quot;BIN&quot;</dt>
  <dd>This symbol holds the path of the bin directory where the package will be
      installed. Program must be prepared to deal with ~name substitution.</dd>
  <dt>&quot;BIN_EXP&quot;</dt>
  <dd>This symbol is the filename expanded version of the
      <span class="Li">&quot;BIN&quot;</span> symbol, for programs that do not
      want to deal with that at run-time.</dd>
  <dt>&quot;INSTALL_USR_BIN_PERL&quot;</dt>
  <dd>This symbol, if defined, indicates that Perl is to be installed also as
      <i>/usr/bin/perl</i>.</dd>
  <dt>&quot;MULTIARCH&quot;</dt>
  <dd>This symbol, if defined, signifies that the build process will produce
      some binary files that are going to be used in a cross-platform
      environment. This is the case for example with the NeXT &quot;fat&quot;
      binaries that contain executables for several
      <span class="Li">&quot;CPUs&quot;</span>.</dd>
  <dt>&quot;PERL_APPENDTOPATH&quot;</dt>
  <dd>If defined, this is the path to a file containing colon-separated paths to
      append to @<span class="Li">&quot;INC&quot;</span>.</dd>
  <dt>&quot;PERL_INC_VERSION_LIST&quot;</dt>
  <dd>This variable specifies the list of subdirectories in over which
      <i>perl.c</i>:<span class="Li">&quot;incpush()&quot;</span> and
      <i>lib/lib.pm</i> will automatically search when adding directories to
      @<span class="Li">&quot;INC&quot;</span>, in a format suitable for a C
      initialization string. See the
      <span class="Li">&quot;inc_version_list&quot;</span> entry in
      Porting/Glossary for more details.</dd>
  <dt>&quot;PERL_OTHERLIBDIRS&quot;</dt>
  <dd>This variable contains a colon-separated set of paths for the perl binary
      to search for additional library files or modules. These directories will
      be tacked to the end of @<span class="Li">&quot;INC&quot;</span>. Perl
      will automatically search below each path for version- and
      architecture-specific directories. See
      <span class="Li">&quot;PERL_INC_VERSION_LIST&quot;</span> for more
      details.</dd>
  <dt>&quot;PERL_PREPENDTOPATH&quot;</dt>
  <dd>If defined, this is the path to a file containing colon-separated paths to
      prepend to @<span class="Li">&quot;INC&quot;</span>.</dd>
  <dt>&quot;PERL_RELOCATABLE_INC&quot;</dt>
  <dd>This symbol, if defined, indicates that we'd like to relocate entries in
      @<span class="Li">&quot;INC&quot;</span> at run time based on the location
      of the perl binary.</dd>
  <dt>&quot;PERL_TARGETARCH&quot;</dt>
  <dd>This symbol, if defined, indicates the target architecture Perl has been
      cross-compiled to. Undefined if not a cross-compile.</dd>
  <dt>&quot;PERL_USE_DEVEL&quot;</dt>
  <dd>This symbol, if defined, indicates that Perl was configured with
      <span class="Li">&quot;-Dusedevel&quot;</span>, to enable development
      features. This should not be done for production builds.</dd>
  <dt>&quot;PERL_VENDORARCH&quot;</dt>
  <dd>If defined, this symbol contains the name of a private library. The
      library is private in the sense that it needn't be in anyone's execution
      path, but it should be accessible by the world. It may have a ~ on the
      front. The standard distribution will put nothing in this directory.
      Vendors who distribute perl may wish to place their own
      architecture-dependent modules and extensions in this directory with
    <p class="Pp"></p>
    <pre> MakeMaker Makefile.PL INSTALLDIRS=vendor
    </pre>
    <p class="Pp">or equivalent. See <span class="Li">&quot;INSTALL&quot;</span>
        for details.</p>
  </dd>
  <dt>&quot;PERL_VENDORARCH_EXP&quot;</dt>
  <dd>This symbol contains the ~name expanded version of
      <span class="Li">&quot;PERL_VENDORARCH&quot;</span>, to be used in
      programs that are not prepared to deal with ~ expansion at run-time.</dd>
  <dt>&quot;PERL_VENDORLIB_EXP&quot;</dt>
  <dd>This symbol contains the ~name expanded version of
      <span class="Li">&quot;VENDORLIB&quot;</span>, to be used in programs that
      are not prepared to deal with ~ expansion at run-time.</dd>
  <dt>&quot;PERL_VENDORLIB_STEM&quot;</dt>
  <dd>This define is <span class="Li">&quot;PERL_VENDORLIB_EXP&quot;</span> with
      any trailing version-specific component removed. The elements in
      <span class="Li">&quot;inc_version_list&quot;</span>
      (<span class="Li">&quot;inc_version_list&quot;</span>.U (part of
      metaconfig)) can be tacked onto this variable to generate a list of
      directories to search.</dd>
  <dt>&quot;PRIVLIB&quot;</dt>
  <dd>This symbol contains the name of the private library for this package. The
      library is private in the sense that it needn't be in anyone's execution
      path, but it should be accessible by the world. The program should be
      prepared to do ~ expansion.</dd>
  <dt>&quot;PRIVLIB_EXP&quot;</dt>
  <dd>This symbol contains the ~name expanded version of
      <span class="Li">&quot;PRIVLIB&quot;</span>, to be used in programs that
      are not prepared to deal with ~ expansion at run-time.</dd>
  <dt>&quot;SITEARCH&quot;</dt>
  <dd>This symbol contains the name of the private library for this package. The
      library is private in the sense that it needn't be in anyone's execution
      path, but it should be accessible by the world. The program should be
      prepared to do ~ expansion. The standard distribution will put nothing in
      this directory. After perl has been installed, users may install their own
      local architecture-dependent modules in this directory with
    <p class="Pp"></p>
    <pre> MakeMaker Makefile.PL
    </pre>
    <p class="Pp">or equivalent. See <span class="Li">&quot;INSTALL&quot;</span>
        for details.</p>
  </dd>
  <dt>&quot;SITEARCH_EXP&quot;</dt>
  <dd>This symbol contains the ~name expanded version of
      <span class="Li">&quot;SITEARCH&quot;</span>, to be used in programs that
      are not prepared to deal with ~ expansion at run-time.</dd>
  <dt>&quot;SITELIB&quot;</dt>
  <dd>This symbol contains the name of the private library for this package. The
      library is private in the sense that it needn't be in anyone's execution
      path, but it should be accessible by the world. The program should be
      prepared to do ~ expansion. The standard distribution will put nothing in
      this directory. After perl has been installed, users may install their own
      local architecture-independent modules in this directory with
    <p class="Pp"></p>
    <pre> MakeMaker Makefile.PL
    </pre>
    <p class="Pp">or equivalent. See <span class="Li">&quot;INSTALL&quot;</span>
        for details.</p>
  </dd>
  <dt>&quot;SITELIB_EXP&quot;</dt>
  <dd>This symbol contains the ~name expanded version of
      <span class="Li">&quot;SITELIB&quot;</span>, to be used in programs that
      are not prepared to deal with ~ expansion at run-time.</dd>
  <dt>&quot;SITELIB_STEM&quot;</dt>
  <dd>This define is <span class="Li">&quot;SITELIB_EXP&quot;</span> with any
      trailing version-specific component removed. The elements in
      <span class="Li">&quot;inc_version_list&quot;</span>
      (<span class="Li">&quot;inc_version_list&quot;</span>.U (part of
      metaconfig)) can be tacked onto this variable to generate a list of
      directories to search.</dd>
  <dt>&quot;STARTPERL&quot;</dt>
  <dd>This variable contains the string to put in front of a perl script to make
      sure (one hopes) that it runs with perl and not some shell.</dd>
  <dt>&quot;USE_64_BIT_ALL&quot;</dt>
  <dd>This symbol, if defined, indicates that 64-bit integers should be used
      when available. If not defined, the native integers will be used (be they
      32 or 64 bits). The maximal possible 64-bitness is employed: LP64 or
      <span class="Li">&quot;ILP64&quot;</span>, meaning that you will be able
      to use more than 2 gigabytes of memory. This mode is even more binary
      incompatible than <span class="Li">&quot;USE_64_BIT_INT&quot;</span>. You
      may not be able to run the resulting executable in a 32-bit
      <span class="Li">&quot;CPU&quot;</span> at all or you may need at least to
      reboot your OS to 64-bit mode.</dd>
  <dt>&quot;USE_64_BIT_INT&quot;</dt>
  <dd>This symbol, if defined, indicates that 64-bit integers should be used
      when available. If not defined, the native integers will be employed (be
      they 32 or 64 bits). The minimal possible 64-bitness is used, just enough
      to get 64-bit integers into Perl. This may mean using for example
      &quot;long longs&quot;, while your memory may still be limited to 2
      gigabytes.</dd>
  <dt>&quot;USE_BSD_GETPGRP&quot;</dt>
  <dd>This symbol, if defined, indicates that getpgrp needs one arguments
      whereas <span class="Li">&quot;USG&quot;</span> one needs none.</dd>
  <dt>&quot;USE_BSD_SETPGRP&quot;</dt>
  <dd>This symbol, if defined, indicates that setpgrp needs two arguments
      whereas <span class="Li">&quot;USG&quot;</span> one needs none. See also
      <span class="Li">&quot;HAS_SETPGID&quot;</span> for a
      <span class="Li">&quot;POSIX&quot;</span> interface.</dd>
  <dt>&quot;USE_CPLUSPLUS&quot;</dt>
  <dd>This symbol, if defined, indicates that a C++ compiler was used to
      compiled Perl and will be used to compile extensions.</dd>
  <dt>&quot;USE_CROSS_COMPILE&quot;</dt>
  <dd>This symbol, if defined, indicates that Perl is being cross-compiled.</dd>
  <dt>&quot;USE_C_BACKTRACE&quot;</dt>
  <dd>This symbol, if defined, indicates that Perl should be built with support
      for backtrace.</dd>
  <dt>&quot;USE_DTRACE&quot;</dt>
  <dd>This symbol, if defined, indicates that Perl should be built with support
      for DTrace.</dd>
  <dt>&quot;USE_DYNAMIC_LOADING&quot;</dt>
  <dd>This symbol, if defined, indicates that dynamic loading of some sort is
      available.</dd>
  <dt>&quot;USE_FAST_STDIO&quot;</dt>
  <dd>This symbol, if defined, indicates that Perl should be built to use 'fast
      stdio'. Defaults to define in Perls 5.8 and earlier, to undef later.</dd>
  <dt>&quot;USE_ITHREADS&quot;</dt>
  <dd>This symbol, if defined, indicates that Perl should be built to use the
      interpreter-based threading implementation.</dd>
  <dt>&quot;USE_KERN_PROC_PATHNAME&quot;</dt>
  <dd>This symbol, if defined, indicates that we can use sysctl with
      <span class="Li">&quot;KERN_PROC_PATHNAME&quot;</span> to get a full path
      for the executable, and hence convert $^X to an absolute path.</dd>
  <dt>&quot;USE_LARGE_FILES&quot;</dt>
  <dd>This symbol, if defined, indicates that large file support should be used
      when available.</dd>
  <dt>&quot;USE_LONG_DOUBLE&quot;</dt>
  <dd>This symbol, if defined, indicates that long doubles should be used when
      available.</dd>
  <dt>&quot;USE_MORE_BITS&quot;</dt>
  <dd>This symbol, if defined, indicates that 64-bit interfaces and long doubles
      should be used when available.</dd>
  <dt>&quot;USE_NSGETEXECUTABLEPATH&quot;</dt>
  <dd>This symbol, if defined, indicates that we can use
      <span class="Li">&quot;_NSGetExecutablePath&quot;</span> and realpath to
      get a full path for the executable, and hence convert $^X to an absolute
      path.</dd>
  <dt>&quot;USE_PERLIO&quot;</dt>
  <dd>This symbol, if defined, indicates that the PerlIO abstraction should be
      used throughout. If not defined, stdio should be used in a fully backward
      compatible manner.</dd>
  <dt>&quot;USE_QUADMATH&quot;</dt>
  <dd>This symbol, if defined, indicates that the quadmath library should be
      used when available.</dd>
  <dt>&quot;USE_REENTRANT_API&quot;</dt>
  <dd>This symbol, if defined, indicates that Perl should try to use the various
      <span class="Li">&quot;_r&quot;</span> versions of library functions. This
      is extremely experimental.</dd>
  <dt>&quot;USE_SEMCTL_SEMID_DS&quot;</dt>
  <dd>This symbol, if defined, indicates that <span class="Li">&quot;struct
      semid_ds&quot;</span> * is used for semctl
      <span class="Li">&quot;IPC_STAT&quot;</span>.</dd>
  <dt>&quot;USE_SEMCTL_SEMUN&quot;</dt>
  <dd>This symbol, if defined, indicates that <span class="Li">&quot;union
      semun&quot;</span> is used for semctl
      <span class="Li">&quot;IPC_STAT&quot;</span>.</dd>
  <dt>&quot;USE_SITECUSTOMIZE&quot;</dt>
  <dd>This symbol, if defined, indicates that sitecustomize should be used.</dd>
  <dt>&quot;USE_SOCKS&quot;</dt>
  <dd>This symbol, if defined, indicates that Perl should be built to use
    socks.</dd>
  <dt>&quot;USE_STAT_BLOCKS&quot;</dt>
  <dd>This symbol is defined if this system has a stat structure declaring
      <span class="Li">&quot;st_blksize&quot;</span> and
      <span class="Li">&quot;st_blocks&quot;</span>.</dd>
  <dt>&quot;USE_STDIO_BASE&quot;</dt>
  <dd>This symbol is defined if the <span class="Li">&quot;_base&quot;</span>
      field (or similar) of the stdio <span class="Li">&quot;FILE&quot;</span>
      structure can be used to access the stdio buffer for a file handle. If
      this is defined, then the
      <span class="Li">&quot;FILE_base(fp)&quot;</span> macro will also be
      defined and should be used to access this field. Also, the
      <span class="Li">&quot;FILE_bufsiz(fp)&quot;</span> macro will be defined
      and should be used to determine the number of bytes in the buffer.
      <span class="Li">&quot;USE_STDIO_BASE&quot;</span> will never be defined
      unless <span class="Li">&quot;USE_STDIO_PTR&quot;</span> is.</dd>
  <dt>&quot;USE_STDIO_PTR&quot;</dt>
  <dd>This symbol is defined if the <span class="Li">&quot;_ptr&quot;</span> and
      <span class="Li">&quot;_cnt&quot;</span> fields (or similar) of the stdio
      <span class="Li">&quot;FILE&quot;</span> structure can be used to access
      the stdio buffer for a file handle. If this is defined, then the
      <span class="Li">&quot;FILE_ptr(fp)&quot;</span> and
      <span class="Li">&quot;FILE_cnt(fp)&quot;</span> macros will also be
      defined and should be used to access these fields.</dd>
  <dt>&quot;USE_STRICT_BY_DEFAULT&quot;</dt>
  <dd>This symbol, if defined, enables additional defaults. At this time it only
      enables implicit strict by default.</dd>
  <dt>&quot;USE_THREADS&quot;</dt>
  <dd>This symbol, if defined, indicates that Perl should be built to use
      threads. At present, it is a synonym for and
      <span class="Li">&quot;USE_ITHREADS&quot;</span>, but eventually the
      source ought to be changed to use this to mean
      <span class="Li">&quot;_any_&quot;</span> threading implementation.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="Sockets_configuration_values"><a class="permalink" href="#Sockets_configuration_values">Sockets
  configuration values</a></h1>
<dl class="Bl-tag">
  <dt>&quot;HAS_SOCKADDR_IN6&quot;</dt>
  <dd>This symbol, if defined, indicates the availability of
      <span class="Li">&quot;struct sockaddr_in6&quot;</span>;</dd>
  <dt>&quot;HAS_SOCKADDR_SA_LEN&quot;</dt>
  <dd>This symbol, if defined, indicates that the <span class="Li">&quot;struct
      sockaddr&quot;</span> structure has a member called
      <span class="Li">&quot;sa_len&quot;</span>, indicating the length of the
      structure.</dd>
  <dt>&quot;HAS_SOCKADDR_STORAGE&quot;</dt>
  <dd>This symbol, if defined, indicates the availability of
      <span class="Li">&quot;struct sockaddr_storage&quot;</span>;</dd>
  <dt>&quot;HAS_SOCKATMARK&quot;</dt>
  <dd>This symbol, if defined, indicates that the
      <span class="Li">&quot;sockatmark&quot;</span> routine is available to
      test whether a socket is at the out-of-band mark.</dd>
  <dt>&quot;HAS_SOCKET&quot;</dt>
  <dd>This symbol, if defined, indicates that the
      <span class="Li">&quot;BSD&quot;</span>
      <span class="Li">&quot;socket&quot;</span> interface is supported.</dd>
  <dt>&quot;HAS_SOCKETPAIR&quot;</dt>
  <dd>This symbol, if defined, indicates that the
      <span class="Li">&quot;BSD&quot;</span>
      <span class="Li">&quot;socketpair()&quot;</span> call is supported.</dd>
  <dt>&quot;HAS_SOCKS5_INIT&quot;</dt>
  <dd>This symbol, if defined, indicates that the
      <span class="Li">&quot;socks5_init&quot;</span> routine is available to
      initialize <span class="Li">&quot;SOCKS&quot;</span> 5.</dd>
  <dt>&quot;I_SOCKS&quot;</dt>
  <dd>This symbol, if defined, indicates that <i>socks.h</i> exists and should
      be included.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> #ifdef I_SOCKS
     #include &lt;socks.h&gt;
 #endif
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;I_SYS_SOCKIO&quot;</dt>
  <dd>This symbol, if defined, indicates the <i>sys/sockio.h</i> should be
      included to get socket ioctl options, like
      <span class="Li">&quot;SIOCATMARK&quot;</span>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> #ifdef I_SYS_SOCKIO
     #include &lt;sys_sockio.h&gt;
 #endif
</pre>
</div>
<div class="Bd-indent"></div>
</section>
<section class="Sh">
<h1 class="Sh" id="Source_Filters"><a class="permalink" href="#Source_Filters">Source
  Filters</a></h1>
<dl class="Bl-tag">
  <dt>&quot;filter_add&quot;</dt>
  <dd>Described in perlfilter.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> SV*  filter_add(filter_t funcp, SV* datasv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;filter_read&quot;</dt>
  <dd>Described in perlfilter.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> I32  filter_read(int idx, SV *buf_sv, int maxlen)
</pre>
</div>
<div class="Bd-indent"></div>
</section>
<section class="Sh">
<h1 class="Sh" id="Stack_Manipulation_Macros"><a class="permalink" href="#Stack_Manipulation_Macros">Stack
  Manipulation Macros</a></h1>
<dl class="Bl-tag">
  <dt>&quot;BHK&quot;</dt>
  <dd>Described in perlguts.</dd>
  <dt>&quot;BINOP&quot;</dt>
  <dd>Described in perlguts.</dd>
  <dt>&quot;DESTRUCTORFUNC_NOCONTEXT_t&quot;</dt>
  <dd>Described in perlguts.</dd>
  <dt>&quot;DESTRUCTORFUNC_t&quot;</dt>
  <dd>Described in perlguts.</dd>
  <dt>&quot;dMARK&quot;</dt>
  <dd>Declare a stack marker variable, <span class="Li">&quot;mark&quot;</span>,
      for the XSUB. See <span class="Li">&quot;MARK&quot;</span> and
      <span class="Li">&quot;dORIGMARK&quot;</span>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre>   dMARK;
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;dORIGMARK&quot;</dt>
  <dd>Saves the original stack mark for the XSUB. See
      <span class="Li">&quot;ORIGMARK&quot;</span>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre>   dORIGMARK;
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;dSP&quot;</dt>
  <dd>Declares a local copy of perl's stack pointer for the XSUB, available via
      the <span class="Li">&quot;SP&quot;</span> macro. See
      <span class="Li">&quot;SP&quot;</span>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre>   dSP;
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;dTARGET&quot;</dt>
  <dd>Declare that this function uses
    <span class="Li">&quot;TARG&quot;</span></dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre>   dTARGET;
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;EXTEND&quot;</dt>
  <dd>Used to extend the argument stack for an XSUB's return values. Once used,
      guarantees that there is room for at least
      <span class="Li">&quot;nitems&quot;</span> to be pushed onto the
    stack.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  EXTEND(SP, SSize_t nitems)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;LISTOP&quot;</dt>
  <dd>Described in perlguts.</dd>
  <dt>&quot;LOGOP&quot;</dt>
  <dd>Described in perlguts.</dd>
  <dt>&quot;LOOP&quot;</dt>
  <dd>Described in perlguts.</dd>
  <dt>&quot;MARK&quot;</dt>
  <dd>Stack marker variable for the XSUB. See
      <span class="Li">&quot;dMARK&quot;</span>.</dd>
  <dt>&quot;mPUSHi&quot;</dt>
  <dd>Push an integer onto the stack. The stack must have room for this element.
      Does not use <span class="Li">&quot;TARG&quot;</span>. See also
      <span class="Li">&quot;PUSHi&quot;</span>,
      <span class="Li">&quot;mXPUSHi&quot;</span> and
      <span class="Li">&quot;XPUSHi&quot;</span>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  mPUSHi(IV iv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;mPUSHn&quot;</dt>
  <dd>Push a double onto the stack. The stack must have room for this element.
      Does not use <span class="Li">&quot;TARG&quot;</span>. See also
      <span class="Li">&quot;PUSHn&quot;</span>,
      <span class="Li">&quot;mXPUSHn&quot;</span> and
      <span class="Li">&quot;XPUSHn&quot;</span>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  mPUSHn(NV nv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;mPUSHp&quot;</dt>
  <dd>Push a string onto the stack. The stack must have room for this element.
      The <span class="Li">&quot;len&quot;</span> indicates the length of the
      string. Does not use <span class="Li">&quot;TARG&quot;</span>. See also
      <span class="Li">&quot;PUSHp&quot;</span>,
      <span class="Li">&quot;mXPUSHp&quot;</span> and
      <span class="Li">&quot;XPUSHp&quot;</span>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  mPUSHp(char* str, STRLEN len)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;mPUSHs&quot;</dt>
  <dd>Push an SV onto the stack and mortalizes the SV. The stack must have room
      for this element. Does not use <span class="Li">&quot;TARG&quot;</span>.
      See also <span class="Li">&quot;PUSHs&quot;</span> and
      <span class="Li">&quot;mXPUSHs&quot;</span>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  mPUSHs(SV* sv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;mPUSHu&quot;</dt>
  <dd>Push an unsigned integer onto the stack. The stack must have room for this
      element. Does not use <span class="Li">&quot;TARG&quot;</span>. See also
      <span class="Li">&quot;PUSHu&quot;</span>,
      <span class="Li">&quot;mXPUSHu&quot;</span> and
      <span class="Li">&quot;XPUSHu&quot;</span>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  mPUSHu(UV uv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;mXPUSHi&quot;</dt>
  <dd>Push an integer onto the stack, extending the stack if necessary. Does not
      use <span class="Li">&quot;TARG&quot;</span>. See also
      <span class="Li">&quot;XPUSHi&quot;</span>,
      <span class="Li">&quot;mPUSHi&quot;</span> and
      <span class="Li">&quot;PUSHi&quot;</span>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  mXPUSHi(IV iv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;mXPUSHn&quot;</dt>
  <dd>Push a double onto the stack, extending the stack if necessary. Does not
      use <span class="Li">&quot;TARG&quot;</span>. See also
      <span class="Li">&quot;XPUSHn&quot;</span>,
      <span class="Li">&quot;mPUSHn&quot;</span> and
      <span class="Li">&quot;PUSHn&quot;</span>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  mXPUSHn(NV nv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;mXPUSHp&quot;</dt>
  <dd>Push a string onto the stack, extending the stack if necessary. The
      <span class="Li">&quot;len&quot;</span> indicates the length of the
      string. Does not use <span class="Li">&quot;TARG&quot;</span>. See also
      <span class="Li">&quot;XPUSHp&quot;</span>,
      <span class="Li">&quot;mPUSHp&quot;</span> and
      <span class="Li">&quot;PUSHp&quot;</span>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  mXPUSHp(char* str, STRLEN len)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;mXPUSHs&quot;</dt>
  <dd>Push an SV onto the stack, extending the stack if necessary and mortalizes
      the SV. Does not use <span class="Li">&quot;TARG&quot;</span>. See also
      <span class="Li">&quot;XPUSHs&quot;</span> and
      <span class="Li">&quot;mPUSHs&quot;</span>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  mXPUSHs(SV* sv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;mXPUSHu&quot;</dt>
  <dd>Push an unsigned integer onto the stack, extending the stack if necessary.
      Does not use <span class="Li">&quot;TARG&quot;</span>. See also
      <span class="Li">&quot;XPUSHu&quot;</span>,
      <span class="Li">&quot;mPUSHu&quot;</span> and
      <span class="Li">&quot;PUSHu&quot;</span>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  mXPUSHu(UV uv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;newXSproto&quot;</dt>
  <dd>Used by <span class="Li">&quot;xsubpp&quot;</span> to hook up XSUBs as
      Perl subs. Adds Perl prototypes to the subs.</dd>
  <dt>&quot;OP&quot;</dt>
  <dd>Described in perlguts.</dd>
  <dt>&quot;ORIGMARK&quot;</dt>
  <dd>The original stack mark for the XSUB. See
      <span class="Li">&quot;dORIGMARK&quot;</span>.</dd>
  <dt>&quot;peep_t&quot;</dt>
  <dd>Described in perlguts.</dd>
  <dt>&quot;PL_runops&quot;</dt>
  <dd>Described in perlguts.</dd>
  <dt>&quot;PMOP&quot;</dt>
  <dd>Described in perlguts.</dd>
  <dt>&quot;POPi&quot;</dt>
  <dd>Pops an integer off the stack.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> IV  POPi
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;POPl&quot;</dt>
  <dd>Pops a long off the stack.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> long  POPl
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;POPn&quot;</dt>
  <dd>Pops a double off the stack.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> NV  POPn
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;POPp&quot;</dt>
  <dd>Pops a string off the stack.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> char*  POPp
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;POPpbytex&quot;</dt>
  <dd>Pops a string off the stack which must consist of bytes i.e. characters
      &lt; 256.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> char*  POPpbytex
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;POPpx&quot;</dt>
  <dd>Pops a string off the stack. Identical to POPp. There are two names for
      historical reasons.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> char*  POPpx
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;POPs&quot;</dt>
  <dd>Pops an SV off the stack.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> SV*  POPs
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;POPu&quot;</dt>
  <dd>Pops an unsigned integer off the stack.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> UV  POPu
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;POPul&quot;</dt>
  <dd>Pops an unsigned long off the stack.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> long  POPul
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;PUSHi&quot;</dt>
  <dd>Push an integer onto the stack. The stack must have room for this element.
      Handles 'set' magic. Uses <span class="Li">&quot;TARG&quot;</span>, so
      <span class="Li">&quot;dTARGET&quot;</span> or
      <span class="Li">&quot;dXSTARG&quot;</span> should be called to declare
      it. Do not call multiple <span class="Li">&quot;TARG&quot;</span>-oriented
      macros to return lists from XSUB's - see
      <span class="Li">&quot;mPUSHi&quot;</span> instead. See also
      <span class="Li">&quot;XPUSHi&quot;</span> and
      <span class="Li">&quot;mXPUSHi&quot;</span>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  PUSHi(IV iv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;PUSHMARK&quot;</dt>
  <dd>Opening bracket for arguments on a callback. See
      <span class="Li">&quot;PUTBACK&quot;</span> and perlcall.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  PUSHMARK(SP)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;PUSHmortal&quot;</dt>
  <dd>Push a new mortal SV onto the stack. The stack must have room for this
      element. Does not use <span class="Li">&quot;TARG&quot;</span>. See also
      <span class="Li">&quot;PUSHs&quot;</span>,
      <span class="Li">&quot;XPUSHmortal&quot;</span> and
      <span class="Li">&quot;XPUSHs&quot;</span>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  PUSHmortal
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;PUSHn&quot;</dt>
  <dd>Push a double onto the stack. The stack must have room for this element.
      Handles 'set' magic. Uses <span class="Li">&quot;TARG&quot;</span>, so
      <span class="Li">&quot;dTARGET&quot;</span> or
      <span class="Li">&quot;dXSTARG&quot;</span> should be called to declare
      it. Do not call multiple <span class="Li">&quot;TARG&quot;</span>-oriented
      macros to return lists from XSUB's - see
      <span class="Li">&quot;mPUSHn&quot;</span> instead. See also
      <span class="Li">&quot;XPUSHn&quot;</span> and
      <span class="Li">&quot;mXPUSHn&quot;</span>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  PUSHn(NV nv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;PUSHp&quot;</dt>
  <dd>Push a string onto the stack. The stack must have room for this element.
      The <span class="Li">&quot;len&quot;</span> indicates the length of the
      string. Handles 'set' magic. Uses
      <span class="Li">&quot;TARG&quot;</span>, so
      <span class="Li">&quot;dTARGET&quot;</span> or
      <span class="Li">&quot;dXSTARG&quot;</span> should be called to declare
      it. Do not call multiple <span class="Li">&quot;TARG&quot;</span>-oriented
      macros to return lists from XSUB's - see
      <span class="Li">&quot;mPUSHp&quot;</span> instead. See also
      <span class="Li">&quot;XPUSHp&quot;</span> and
      <span class="Li">&quot;mXPUSHp&quot;</span>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  PUSHp(char* str, STRLEN len)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;PUSHs&quot;</dt>
  <dd>Push an SV onto the stack. The stack must have room for this element. Does
      not handle 'set' magic. Does not use
      <span class="Li">&quot;TARG&quot;</span>. See also
      <span class="Li">&quot;PUSHmortal&quot;</span>,
      <span class="Li">&quot;XPUSHs&quot;</span>, and
      <span class="Li">&quot;XPUSHmortal&quot;</span>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  PUSHs(SV* sv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;PUSHu&quot;</dt>
  <dd>Push an unsigned integer onto the stack. The stack must have room for this
      element. Handles 'set' magic. Uses
      <span class="Li">&quot;TARG&quot;</span>, so
      <span class="Li">&quot;dTARGET&quot;</span> or
      <span class="Li">&quot;dXSTARG&quot;</span> should be called to declare
      it. Do not call multiple <span class="Li">&quot;TARG&quot;</span>-oriented
      macros to return lists from XSUB's - see
      <span class="Li">&quot;mPUSHu&quot;</span> instead. See also
      <span class="Li">&quot;XPUSHu&quot;</span> and
      <span class="Li">&quot;mXPUSHu&quot;</span>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  PUSHu(UV uv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;PUTBACK&quot;</dt>
  <dd>Closing bracket for XSUB arguments. This is usually handled by
      <span class="Li">&quot;xsubpp&quot;</span>. See
      <span class="Li">&quot;PUSHMARK&quot;</span> and perlcall for other
    uses.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre>   PUTBACK;
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;save_aptr&quot;</dt>
  <dd>Described in perlguts.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  save_aptr(AV** aptr)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;save_ary&quot;</dt>
  <dd>Described in perlguts.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> AV*  save_ary(GV* gv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;SAVEBOOL&quot;</dt>
  <dd>Described in perlguts.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre>   SAVEBOOL(bool i)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;SAVEDELETE&quot;</dt>
  <dd>Described in perlguts.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre>   SAVEDELETE(HV * hv, char * key, I32 length)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;SAVEDESTRUCTOR&quot;</dt>
  <dd>Described in perlguts.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre>   SAVEDESTRUCTOR(DESTRUCTORFUNC_NOCONTEXT_t f, void *p)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;SAVEDESTRUCTOR_X&quot;</dt>
  <dd>Described in perlguts.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre>   SAVEDESTRUCTOR_X(DESTRUCTORFUNC_t f, void *p)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;SAVEFREEOP&quot;</dt>
  <dd>Described in perlguts.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre>   SAVEFREEOP(OP *op)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;SAVEFREEPV&quot;</dt>
  <dd>Described in perlguts.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre>   SAVEFREEPV(void * p)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;SAVEFREESV&quot;</dt>
  <dd>Described in perlguts.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre>   SAVEFREESV(SV* sv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;save_hash&quot;</dt>
  <dd>Described in perlguts.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> HV*  save_hash(GV* gv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;save_hptr&quot;</dt>
  <dd>Described in perlguts.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  save_hptr(HV** hptr)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;SAVEI8&quot;</dt>
  <dd>Described in perlguts.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre>   SAVEI8(I8 i)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;SAVEI32&quot;</dt>
  <dd>Described in perlguts.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre>   SAVEI32(I32 i)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;SAVEI16&quot;</dt>
  <dd>Described in perlguts.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre>   SAVEI16(I16 i)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;SAVEINT&quot;</dt>
  <dd>Described in perlguts.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre>   SAVEINT(int i)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;save_item&quot;</dt>
  <dd>Described in perlguts.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  save_item(SV* item)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;SAVEIV&quot;</dt>
  <dd>Described in perlguts.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre>   SAVEIV(IV i)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;save_list&quot;</dt>
  <dd><span class="Li">&quot;</span><span class="Li"><b>DEPRECATED!</b></span><span class="Li">&quot;</span>
      It is planned to remove <span class="Li">&quot;save_list&quot;</span> from
      a future release of Perl. Do not use it for new code; remove it from
      existing code.
    <p class="Pp">Described in perlguts.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  save_list(SV** sarg, I32 maxsarg)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;SAVELONG&quot;</dt>
  <dd>Described in perlguts.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre>   SAVELONG(long i)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;SAVEMORTALIZESV&quot;</dt>
  <dd>Described in perlguts.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre>   SAVEMORTALIZESV(SV* sv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;SAVEPPTR&quot;</dt>
  <dd>Described in perlguts.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre>   SAVEPPTR(char * p)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;save_scalar&quot;</dt>
  <dd>Described in perlguts.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> SV*  save_scalar(GV* gv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;SAVESPTR&quot;</dt>
  <dd>Described in perlguts.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre>   SAVESPTR(SV * s)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;SAVESTACK_POS&quot;</dt>
  <dd>Described in perlguts.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre>   SAVESTACK_POS()
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;save_svref&quot;</dt>
  <dd>Described in perlguts.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> SV*  save_svref(SV** sptr)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;SP&quot;</dt>
  <dd>Stack pointer. This is usually handled by
      <span class="Li">&quot;xsubpp&quot;</span>. See
      <span class="Li">&quot;dSP&quot;</span> and
      <span class="Li">&quot;SPAGAIN&quot;</span>.</dd>
  <dt>&quot;SPAGAIN&quot;</dt>
  <dd>Refetch the stack pointer. Used after a callback. See perlcall.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre>   SPAGAIN;
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;TARG&quot;</dt>
  <dd><span class="Li">&quot;TARG&quot;</span> is short for &quot;target&quot;.
      It is an entry in the pad that an OPs
      <span class="Li">&quot;op_targ&quot;</span> refers to. It is scratchpad
      space, often used as a return value for the OP, but some use it for other
      purposes.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre>   TARG;
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;UNOP&quot;</dt>
  <dd>Described in perlguts.</dd>
  <dt>&quot;XPUSHi&quot;</dt>
  <dd>Push an integer onto the stack, extending the stack if necessary. Handles
      'set' magic. Uses <span class="Li">&quot;TARG&quot;</span>, so
      <span class="Li">&quot;dTARGET&quot;</span> or
      <span class="Li">&quot;dXSTARG&quot;</span> should be called to declare
      it. Do not call multiple <span class="Li">&quot;TARG&quot;</span>-oriented
      macros to return lists from XSUB's - see
      <span class="Li">&quot;mXPUSHi&quot;</span> instead. See also
      <span class="Li">&quot;PUSHi&quot;</span> and
      <span class="Li">&quot;mPUSHi&quot;</span>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  XPUSHi(IV iv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;XPUSHmortal&quot;</dt>
  <dd>Push a new mortal SV onto the stack, extending the stack if necessary.
      Does not use <span class="Li">&quot;TARG&quot;</span>. See also
      <span class="Li">&quot;XPUSHs&quot;</span>,
      <span class="Li">&quot;PUSHmortal&quot;</span> and
      <span class="Li">&quot;PUSHs&quot;</span>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  XPUSHmortal
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;XPUSHn&quot;</dt>
  <dd>Push a double onto the stack, extending the stack if necessary. Handles
      'set' magic. Uses <span class="Li">&quot;TARG&quot;</span>, so
      <span class="Li">&quot;dTARGET&quot;</span> or
      <span class="Li">&quot;dXSTARG&quot;</span> should be called to declare
      it. Do not call multiple <span class="Li">&quot;TARG&quot;</span>-oriented
      macros to return lists from XSUB's - see
      <span class="Li">&quot;mXPUSHn&quot;</span> instead. See also
      <span class="Li">&quot;PUSHn&quot;</span> and
      <span class="Li">&quot;mPUSHn&quot;</span>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  XPUSHn(NV nv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;XPUSHp&quot;</dt>
  <dd>Push a string onto the stack, extending the stack if necessary. The
      <span class="Li">&quot;len&quot;</span> indicates the length of the
      string. Handles 'set' magic. Uses
      <span class="Li">&quot;TARG&quot;</span>, so
      <span class="Li">&quot;dTARGET&quot;</span> or
      <span class="Li">&quot;dXSTARG&quot;</span> should be called to declare
      it. Do not call multiple <span class="Li">&quot;TARG&quot;</span>-oriented
      macros to return lists from XSUB's - see
      <span class="Li">&quot;mXPUSHp&quot;</span> instead. See also
      <span class="Li">&quot;PUSHp&quot;</span> and
      <span class="Li">&quot;mPUSHp&quot;</span>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  XPUSHp(char* str, STRLEN len)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;XPUSHs&quot;</dt>
  <dd>Push an SV onto the stack, extending the stack if necessary. Does not
      handle 'set' magic. Does not use <span class="Li">&quot;TARG&quot;</span>.
      See also <span class="Li">&quot;XPUSHmortal&quot;</span>,
      <span class="Li">&quot;PUSHs&quot;</span> and
      <span class="Li">&quot;PUSHmortal&quot;</span>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  XPUSHs(SV* sv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;XPUSHu&quot;</dt>
  <dd>Push an unsigned integer onto the stack, extending the stack if necessary.
      Handles 'set' magic. Uses <span class="Li">&quot;TARG&quot;</span>, so
      <span class="Li">&quot;dTARGET&quot;</span> or
      <span class="Li">&quot;dXSTARG&quot;</span> should be called to declare
      it. Do not call multiple <span class="Li">&quot;TARG&quot;</span>-oriented
      macros to return lists from XSUB's - see
      <span class="Li">&quot;mXPUSHu&quot;</span> instead. See also
      <span class="Li">&quot;PUSHu&quot;</span> and
      <span class="Li">&quot;mPUSHu&quot;</span>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  XPUSHu(UV uv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;XS_APIVERSION_BOOTCHECK&quot;</dt>
  <dd>Macro to verify that the perl api version an XS module has been compiled
      against matches the api version of the perl interpreter it's being loaded
      into.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre>   XS_APIVERSION_BOOTCHECK;
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;XSRETURN&quot;</dt>
  <dd>Return from XSUB, indicating number of items on the stack. This is usually
      handled by <span class="Li">&quot;xsubpp&quot;</span>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  XSRETURN(int nitems)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;XSRETURN_EMPTY&quot;</dt>
  <dd>Return an empty list from an XSUB immediately.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre>   XSRETURN_EMPTY;
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;XSRETURN_IV&quot;</dt>
  <dd>Return an integer from an XSUB immediately. Uses
      <span class="Li">&quot;XST_mIV&quot;</span>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  XSRETURN_IV(IV iv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;XSRETURN_NO&quot;</dt>
  <dd>Return <span class="Li">&amp;PL_sv_no</span> from an XSUB immediately.
      Uses <span class="Li">&quot;XST_mNO&quot;</span>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre>   XSRETURN_NO;
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;XSRETURN_NV&quot;</dt>
  <dd>Return a double from an XSUB immediately. Uses
      <span class="Li">&quot;XST_mNV&quot;</span>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  XSRETURN_NV(NV nv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;XSRETURN_PV&quot;</dt>
  <dd>Return a copy of a string from an XSUB immediately. Uses
      <span class="Li">&quot;XST_mPV&quot;</span>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  XSRETURN_PV(char* str)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;XSRETURN_UNDEF&quot;</dt>
  <dd>Return <span class="Li">&amp;PL_sv_undef</span> from an XSUB immediately.
      Uses <span class="Li">&quot;XST_mUNDEF&quot;</span>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre>   XSRETURN_UNDEF;
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;XSRETURN_UV&quot;</dt>
  <dd>Return an integer from an XSUB immediately. Uses
      <span class="Li">&quot;XST_mUV&quot;</span>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  XSRETURN_UV(IV uv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;XSRETURN_YES&quot;</dt>
  <dd>Return <span class="Li">&amp;PL_sv_yes</span> from an XSUB immediately.
      Uses <span class="Li">&quot;XST_mYES&quot;</span>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre>   XSRETURN_YES;
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;XST_mIV&quot;</dt>
  <dd>Place an integer into the specified position
      <span class="Li">&quot;pos&quot;</span> on the stack. The value is stored
      in a new mortal SV.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  XST_mIV(int pos, IV iv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;XST_mNO&quot;</dt>
  <dd>Place <span class="Li">&amp;PL_sv_no</span> into the specified position
      <span class="Li">&quot;pos&quot;</span> on the stack.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  XST_mNO(int pos)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;XST_mNV&quot;</dt>
  <dd>Place a double into the specified position
      <span class="Li">&quot;pos&quot;</span> on the stack. The value is stored
      in a new mortal SV.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  XST_mNV(int pos, NV nv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;XST_mPV&quot;</dt>
  <dd>Place a copy of a string into the specified position
      <span class="Li">&quot;pos&quot;</span> on the stack. The value is stored
      in a new mortal SV.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  XST_mPV(int pos, char* str)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;XST_mUNDEF&quot;</dt>
  <dd>Place <span class="Li">&amp;PL_sv_undef</span> into the specified position
      <span class="Li">&quot;pos&quot;</span> on the stack.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  XST_mUNDEF(int pos)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;XST_mUV&quot;</dt>
  <dd>Place an unsigned integer into the specified position
      <span class="Li">&quot;pos&quot;</span> on the stack. The value is stored
      in a new mortal SV.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  XST_mUV(int pos, UV uv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;XST_mYES&quot;</dt>
  <dd>Place <span class="Li">&amp;PL_sv_yes</span> into the specified position
      <span class="Li">&quot;pos&quot;</span> on the stack.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  XST_mYES(int pos)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;XS_VERSION&quot;</dt>
  <dd>The version identifier for an XS module. This is usually handled
      automatically by <span class="Li">&quot;ExtUtils::MakeMaker&quot;</span>.
      See <span class="Li">&quot;XS_VERSION_BOOTCHECK&quot;</span>.</dd>
  <dt>&quot;XS_VERSION_BOOTCHECK&quot;</dt>
  <dd>Macro to verify that a PM module's <span class="Li">$VERSION</span>
      variable matches the XS module's
      <span class="Li">&quot;XS_VERSION&quot;</span> variable. This is usually
      handled automatically by <span class="Li">&quot;xsubpp&quot;</span>. See
      &quot;The VERSIONCHECK: Keyword&quot; in perlxs.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre>   XS_VERSION_BOOTCHECK;
</pre>
</div>
<div class="Bd-indent"></div>
</section>
<section class="Sh">
<h1 class="Sh" id="String_Handling"><a class="permalink" href="#String_Handling">String
  Handling</a></h1>
<p class="Pp">See also <span class="Li">&quot;Unicode Support&quot;</span>.</p>
<dl class="Bl-tag">
  <dt>&quot;CAT2&quot;</dt>
  <dd>This macro concatenates 2 tokens together.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> token  CAT2(token x, token y)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;Copy&quot;</dt>
  <dd>The XSUB-writer's interface to the C
      <span class="Li">&quot;memcpy&quot;</span> function. The
      <span class="Li">&quot;src&quot;</span> is the source,
      <span class="Li">&quot;dest&quot;</span> is the destination,
      <span class="Li">&quot;nitems&quot;</span> is the number of items, and
      <span class="Li">&quot;type&quot;</span> is the type. May fail on
      overlapping copies. See also
    <span class="Li">&quot;Move&quot;</span>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  Copy(void* src, void* dest, int nitems, type)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;CopyD&quot;</dt>
  <dd>Like <span class="Li">&quot;Copy&quot;</span> but returns
      <span class="Li">&quot;dest&quot;</span>. Useful for encouraging compilers
      to tail-call optimise.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void *  CopyD(void* src, void* dest, int nitems, type)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;delimcpy&quot;</dt>
  <dd>Copy a source buffer to a destination buffer, stopping at (but not
      including) the first occurrence in the source of an unescaped (defined
      below) delimiter byte, <span class="Li">&quot;delim&quot;</span>. The
      source is the bytes between
      <span class="Li">&quot;from&quot;</span>&#x00A0;and&#x00A0;<span class="Li">&quot;from_end&quot;</span>&#x00A0;-&#x00A0;1.
      Similarly, the dest is <span class="Li">&quot;to&quot;</span> up to
      <span class="Li">&quot;to_end&quot;</span>.
    <p class="Pp">The number of bytes copied is written to
        <span class="Li">*retlen</span>.</p>
    <p class="Pp">Returns the position of the first uncopied
        <span class="Li">&quot;delim&quot;</span> in the
        <span class="Li">&quot;from&quot;</span> buffer, but if there is no such
        occurrence before <span class="Li">&quot;from_end&quot;</span>, then
        <span class="Li">&quot;from_end&quot;</span> is returned, and the entire
        buffer
        <span class="Li">&quot;from&quot;</span>&#x00A0;..&#x00A0;<span class="Li">&quot;from_end&quot;</span>&#x00A0;-&#x00A0;1
        is copied.</p>
    <p class="Pp">If there is room in the destination available after the copy,
        an extra terminating safety <span class="Li">&quot;NUL&quot;</span> byte
        is appended (not included in the returned length).</p>
    <p class="Pp">The error case is if the destination buffer is not large
        enough to accommodate everything that should be copied. In this
        situation, a value larger than
        <span class="Li">&quot;to_end&quot;</span>&#x00A0;-&#x00A0;<span class="Li">&quot;to&quot;</span>
        is written to <span class="Li">*retlen</span>, and as much of the source
        as fits will be written to the destination. Not having room for the
        safety <span class="Li">&quot;NUL&quot;</span> is not considered an
        error.</p>
    <p class="Pp">In the following examples, let
        <span class="Li">&quot;x&quot;</span> be the delimiter, and
        <span class="Li">0</span> represent a
        <span class="Li">&quot;NUL&quot;</span> byte (<b>NOT</b> the digit
        <span class="Li">0</span>). Then we would have</p>
    <p class="Pp"></p>
    <pre>  Source     Destination
 abcxdef        abc0
    </pre>
    <p class="Pp">provided the destination buffer is at least 4 bytes long.</p>
    <p class="Pp">An escaped delimiter is one which is immediately preceded by a
        single backslash. Escaped delimiters are copied, and the copy continues
        past the delimiter; the backslash is not copied:</p>
    <p class="Pp"></p>
    <pre>  Source       Destination
 abc\xdef       abcxdef0
    </pre>
    <p class="Pp">(provided the destination buffer is at least 8 bytes
      long).</p>
    <p class="Pp">It's actually somewhat more complicated than that. A sequence
        of any odd number of backslashes escapes the following delimiter, and
        the copy continues with exactly one of the backslashes stripped.</p>
    <p class="Pp"></p>
    <pre>     Source         Destination
     abc\xdef          abcxdef0
   abc\\\xdef        abc\\xdef0
 abc\\\\\xdef      abc\\\\xdef0
    </pre>
    <p class="Pp">(as always, if the destination is large enough)</p>
    <p class="Pp">An even number of preceding backslashes does not escape the
        delimiter, so that the copy stops just before it, and includes all the
        backslashes (no stripping; zero is considered even):</p>
    <p class="Pp"></p>
    <pre>      Source         Destination
      abcxdef          abc0
    abc\\xdef          abc\\0
  abc\\\\xdef          abc\\\\0
    </pre>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> char*  delimcpy(char* to, const char* to_end, const char* from,
                 const char* from_end, const int delim,
                 I32* retlen)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;fbm_compile&quot;</dt>
  <dd>Analyzes the string in order to make fast searches on it using
      <span class="Li">&quot;fbm_instr()&quot;</span> -- the Boyer-Moore
      algorithm.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  fbm_compile(SV* sv, U32 flags)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;fbm_instr&quot;</dt>
  <dd>Returns the location of the SV in the string delimited by
      <span class="Li">&quot;big&quot;</span> and
      <span class="Li">&quot;bigend&quot;</span>
      (<span class="Li">&quot;bigend&quot;</span>) is the char following the
      last char). It returns <span class="Li">&quot;NULL&quot;</span> if the
      string can't be found. The <span class="Li">&quot;sv&quot;</span> does not
      have to be <span class="Li">&quot;fbm_compiled&quot;</span>, but the
      search will not be as fast then.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> char*  fbm_instr(unsigned char* big, unsigned char* bigend,
                  SV* littlestr, U32 flags)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;foldEQ&quot;</dt>
  <dd>Returns true if the leading <span class="Li">&quot;len&quot;</span> bytes
      of the strings <span class="Li">&quot;s1&quot;</span> and
      <span class="Li">&quot;s2&quot;</span> are the same case-insensitively;
      false otherwise. Uppercase and lowercase ASCII range bytes match
      themselves and their opposite case counterparts. Non-cased and non-ASCII
      range bytes match only themselves.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> I32  foldEQ(const char* a, const char* b, I32 len)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;ibcmp&quot;</dt>
  <dd>This is a synonym for
      <span class="Li">&quot;(!&#x00A0;foldEQ())&quot;</span></dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> I32  ibcmp(const char* a, const char* b, I32 len)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;ibcmp_locale&quot;</dt>
  <dd>This is a synonym for
      <span class="Li">&quot;(!&#x00A0;foldEQ_locale())&quot;</span></dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> I32  ibcmp_locale(const char* a, const char* b, I32 len)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;ibcmp_utf8&quot;</dt>
  <dd>This is a synonym for
      <span class="Li">&quot;(!&#x00A0;foldEQ_utf8())&quot;</span></dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> I32  ibcmp_utf8(const char *s1, char **pe1, UV l1, bool u1,
                 const char *s2, char **pe2, UV l2, bool u2)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;instr&quot;</dt>
  <dd>Same as <b>strstr</b>(3), which finds and returns a pointer to the first
      occurrence of the NUL-terminated substring
      <span class="Li">&quot;little&quot;</span> in the NUL-terminated string
      <span class="Li">&quot;big&quot;</span>, returning NULL if not found. The
      terminating NUL bytes are not compared.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> char*  instr(const char* big, const char* little)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;memCHRs&quot;</dt>
  <dd>Returns the position of the first occurence of the byte
      <span class="Li">&quot;c&quot;</span> in the literal string
      <span class="Li">&quot;list&quot;</span>, or NULL if
      <span class="Li">&quot;c&quot;</span> doesn't appear in
      <span class="Li">&quot;list&quot;</span>. All bytes are treated as
      unsigned char. Thus this macro can be used to determine if
      <span class="Li">&quot;c&quot;</span> is in a set of particular
      characters. Unlike <b>strchr</b>(3), it works even if
      <span class="Li">&quot;c&quot;</span> is
      <span class="Li">&quot;NUL&quot;</span> (and the set doesn't include
      <span class="Li">&quot;NUL&quot;</span>).</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> bool  memCHRs(&quot;list&quot;, char c)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;memEQ&quot;</dt>
  <dd>Test two buffers (which may contain embedded
      <span class="Li">&quot;NUL&quot;</span> characters, to see if they are
      equal. The <span class="Li">&quot;len&quot;</span> parameter indicates the
      number of bytes to compare. Returns true or false. It is undefined
      behavior if either of the buffers doesn't contain at least
      <span class="Li">&quot;len&quot;</span> bytes.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> bool  memEQ(char* s1, char* s2, STRLEN len)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;memEQs&quot;</dt>
  <dd>Like &quot;memEQ&quot;, but the second string is a literal enclosed in
      double quotes, <span class="Li">&quot;l1&quot;</span> gives the number of
      bytes in <span class="Li">&quot;s1&quot;</span>. Returns true or
    false.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> bool  memEQs(char* s1, STRLEN l1, &quot;s2&quot;)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;memNE&quot;</dt>
  <dd>Test two buffers (which may contain embedded
      <span class="Li">&quot;NUL&quot;</span> characters, to see if they are not
      equal. The <span class="Li">&quot;len&quot;</span> parameter indicates the
      number of bytes to compare. Returns true or false. It is undefined
      behavior if either of the buffers doesn't contain at least
      <span class="Li">&quot;len&quot;</span> bytes.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> bool  memNE(char* s1, char* s2, STRLEN len)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;memNEs&quot;</dt>
  <dd>Like &quot;memNE&quot;, but the second string is a literal enclosed in
      double quotes, <span class="Li">&quot;l1&quot;</span> gives the number of
      bytes in <span class="Li">&quot;s1&quot;</span>. Returns true or
    false.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> bool  memNEs(char* s1, STRLEN l1, &quot;s2&quot;)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;Move&quot;</dt>
  <dd>The XSUB-writer's interface to the C
      <span class="Li">&quot;memmove&quot;</span> function. The
      <span class="Li">&quot;src&quot;</span> is the source,
      <span class="Li">&quot;dest&quot;</span> is the destination,
      <span class="Li">&quot;nitems&quot;</span> is the number of items, and
      <span class="Li">&quot;type&quot;</span> is the type. Can do overlapping
      moves. See also <span class="Li">&quot;Copy&quot;</span>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  Move(void* src, void* dest, int nitems, type)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;MoveD&quot;</dt>
  <dd>Like <span class="Li">&quot;Move&quot;</span> but returns
      <span class="Li">&quot;dest&quot;</span>. Useful for encouraging compilers
      to tail-call optimise.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void *  MoveD(void* src, void* dest, int nitems, type)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;my_snprintf&quot;</dt>
  <dd>The C library <span class="Li">&quot;snprintf&quot;</span> functionality,
      if available and standards-compliant (uses
      <span class="Li">&quot;vsnprintf&quot;</span>, actually). However, if the
      <span class="Li">&quot;vsnprintf&quot;</span> is not available, will
      unfortunately use the unsafe <span class="Li">&quot;vsprintf&quot;</span>
      which can overrun the buffer (there is an overrun check, but that may be
      too late). Consider using <span class="Li">&quot;sv_vcatpvf&quot;</span>
      instead, or getting <span class="Li">&quot;vsnprintf&quot;</span>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> int  my_snprintf(char *buffer, const Size_t len,
                  const char *format, ...)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;my_sprintf&quot;</dt>
  <dd><span class="Li">&quot;</span><span class="Li"><b>DEPRECATED!</b></span><span class="Li">&quot;</span>
      It is planned to remove <span class="Li">&quot;my_sprintf&quot;</span>
      from a future release of Perl. Do not use it for new code; remove it from
      existing code.
    <p class="Pp">Do NOT use this due to the possibility of overflowing
        <span class="Li">&quot;buffer&quot;</span>. Instead use
        <b>my_snprintf()</b></p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> int  my_sprintf(NN char *buffer, NN const char *pat, ...)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;my_strlcat&quot;</dt>
  <dd>The C library <span class="Li">&quot;strlcat&quot;</span> if available, or
      a Perl implementation of it. This operates on C
      <span class="Li">&quot;NUL&quot;</span>-terminated strings.
    <p class="Pp"><span class="Li">&quot;my_strlcat()&quot;</span> appends
        string <span class="Li">&quot;src&quot;</span> to the end of
        <span class="Li">&quot;dst&quot;</span>. It will append at most
        <span class="Li">&quot;size&#x00A0;-&#x00A0;strlen(dst)&#x00A0;-&#x00A0;1&quot;</span>
        characters. It will then
        <span class="Li">&quot;NUL&quot;</span>-terminate, unless
        <span class="Li">&quot;size&quot;</span> is 0 or the original
        <span class="Li">&quot;dst&quot;</span> string was longer than
        <span class="Li">&quot;size&quot;</span> (in practice this should not
        happen as it means that either <span class="Li">&quot;size&quot;</span>
        is incorrect or that <span class="Li">&quot;dst&quot;</span> is not a
        proper <span class="Li">&quot;NUL&quot;</span>-terminated string).</p>
    <p class="Pp">Note that <span class="Li">&quot;size&quot;</span> is the full
        size of the destination buffer and the result is guaranteed to be
        <span class="Li">&quot;NUL&quot;</span>-terminated if there is room.
        Note that room for the <span class="Li">&quot;NUL&quot;</span> should be
        included in <span class="Li">&quot;size&quot;</span>.</p>
    <p class="Pp">The return value is the total length that
        <span class="Li">&quot;dst&quot;</span> would have if
        <span class="Li">&quot;size&quot;</span> is sufficiently large. Thus it
        is the initial length of <span class="Li">&quot;dst&quot;</span> plus
        the length of <span class="Li">&quot;src&quot;</span>. If
        <span class="Li">&quot;size&quot;</span> is smaller than the return, the
        excess was not appended.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> Size_t  my_strlcat(char *dst, const char *src, Size_t size)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;my_strlcpy&quot;</dt>
  <dd>The C library <span class="Li">&quot;strlcpy&quot;</span> if available, or
      a Perl implementation of it. This operates on C
      <span class="Li">&quot;NUL&quot;</span>-terminated strings.
    <p class="Pp"><span class="Li">&quot;my_strlcpy()&quot;</span> copies up to
        <span class="Li">&quot;size&#x00A0;-&#x00A0;1&quot;</span> characters
        from the string <span class="Li">&quot;src&quot;</span> to
        <span class="Li">&quot;dst&quot;</span>,
        <span class="Li">&quot;NUL&quot;</span>-terminating the result if
        <span class="Li">&quot;size&quot;</span> is not 0.</p>
    <p class="Pp">The return value is the total length
        <span class="Li">&quot;src&quot;</span> would be if the copy completely
        succeeded. If it is larger than
        <span class="Li">&quot;size&quot;</span>, the excess was not copied.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> Size_t  my_strlcpy(char *dst, const char *src, Size_t size)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;my_strnlen&quot;</dt>
  <dd>The C library <span class="Li">&quot;strnlen&quot;</span> if available, or
      a Perl implementation of it.
    <p class="Pp"><span class="Li">&quot;my_strnlen()&quot;</span> computes the
        length of the string, up to <span class="Li">&quot;maxlen&quot;</span>
        characters. It will never attempt to address more than
        <span class="Li">&quot;maxlen&quot;</span> characters, making it
        suitable for use with strings that are not guaranteed to be
        NUL-terminated.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> Size_t  my_strnlen(const char *str, Size_t maxlen)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;my_vsnprintf&quot;</dt>
  <dd>The C library <span class="Li">&quot;vsnprintf&quot;</span> if available
      and standards-compliant. However, if the
      <span class="Li">&quot;vsnprintf&quot;</span> is not available, will
      unfortunately use the unsafe <span class="Li">&quot;vsprintf&quot;</span>
      which can overrun the buffer (there is an overrun check, but that may be
      too late). Consider using <span class="Li">&quot;sv_vcatpvf&quot;</span>
      instead, or getting <span class="Li">&quot;vsnprintf&quot;</span>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> int  my_vsnprintf(char *buffer, const Size_t len,
                   const char *format, va_list ap)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;ninstr&quot;</dt>
  <dd>Find the first (leftmost) occurrence of a sequence of bytes within another
      sequence. This is the Perl version of
      <span class="Li">&quot;strstr()&quot;</span>, extended to handle arbitrary
      sequences, potentially containing embedded
      <span class="Li">&quot;NUL&quot;</span> characters
      (<span class="Li">&quot;NUL&quot;</span> is what the initial
      <span class="Li">&quot;n&quot;</span> in the function name stands for;
      some systems have an equivalent,
      <span class="Li">&quot;memmem()&quot;</span>, but with a somewhat
      different API).
    <p class="Pp">Another way of thinking about this function is finding a
        needle in a haystack. <span class="Li">&quot;big&quot;</span> points to
        the first byte in the haystack.
        <span class="Li">&quot;big_end&quot;</span> points to one byte beyond
        the final byte in the haystack.
        <span class="Li">&quot;little&quot;</span> points to the first byte in
        the needle. <span class="Li">&quot;little_end&quot;</span> points to one
        byte beyond the final byte in the needle. All the parameters must be
        non-<span class="Li">&quot;NULL&quot;</span>.</p>
    <p class="Pp">The function returns <span class="Li">&quot;NULL&quot;</span>
        if there is no occurrence of <span class="Li">&quot;little&quot;</span>
        within <span class="Li">&quot;big&quot;</span>. If
        <span class="Li">&quot;little&quot;</span> is the empty string,
        <span class="Li">&quot;big&quot;</span> is returned.</p>
    <p class="Pp">Because this function operates at the byte level, and because
        of the inherent characteristics of UTF-8 (or UTF-EBCDIC), it will work
        properly if both the needle and the haystack are strings with the same
        UTF-8ness, but not if the UTF-8ness differs.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> char*  ninstr(const char* big, const char* bigend,
               const char* little, const char* lend)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;Nullch&quot;</dt>
  <dd>Null character pointer. (No longer available when
      <span class="Li">&quot;PERL_CORE&quot;</span> is defined.)</dd>
  <dt>&quot;rninstr&quot;</dt>
  <dd>Like <span class="Li">&quot;ninstr&quot;</span>, but instead finds the
      final (rightmost) occurrence of a sequence of bytes within another
      sequence, returning <span class="Li">&quot;NULL&quot;</span> if there is
      no such occurrence.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> char*  rninstr(const char* big, const char* bigend,
                const char* little, const char* lend)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;savepv&quot;</dt>
  <dd>Perl's version of <span class="Li">&quot;strdup()&quot;</span>. Returns a
      pointer to a newly allocated string which is a duplicate of
      <span class="Li">&quot;pv&quot;</span>. The size of the string is
      determined by <span class="Li">&quot;strlen()&quot;</span>, which means it
      may not contain embedded <span class="Li">&quot;NUL&quot;</span>
      characters and must have a trailing
      <span class="Li">&quot;NUL&quot;</span>. To prevent memory leaks, the
      memory allocated for the new string needs to be freed when no longer
      needed. This can be done with the
      <span class="Li">&quot;Safefree&quot;</span> function, or
      <span class="Li">&quot;SAVEFREEPV&quot;</span>.
    <p class="Pp">On some platforms, Windows for example, all allocated memory
        owned by a thread is deallocated when that thread ends. So if you need
        that not to happen, you need to use the shared memory functions, such as
        <span class="Li">&quot;savesharedpv&quot;</span>.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> char*  savepv(const char* pv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;savepvn&quot;</dt>
  <dd>Perl's version of what <span class="Li">&quot;strndup()&quot;</span> would
      be if it existed. Returns a pointer to a newly allocated string which is a
      duplicate of the first <span class="Li">&quot;len&quot;</span> bytes from
      <span class="Li">&quot;pv&quot;</span>, plus a trailing
      <span class="Li">&quot;NUL&quot;</span> byte. The memory allocated for the
      new string can be freed with the
      <span class="Li">&quot;Safefree()&quot;</span> function.
    <p class="Pp">On some platforms, Windows for example, all allocated memory
        owned by a thread is deallocated when that thread ends. So if you need
        that not to happen, you need to use the shared memory functions, such as
        <span class="Li">&quot;savesharedpvn&quot;</span>.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> char*  savepvn(const char* pv, Size_t len)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;savepvs&quot;</dt>
  <dd>Like <span class="Li">&quot;savepvn&quot;</span>, but takes a literal
      string instead of a string/length pair.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> char*  savepvs(&quot;literal string&quot;)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;savesharedpv&quot;</dt>
  <dd>A version of <span class="Li">&quot;savepv()&quot;</span> which allocates
      the duplicate string in memory which is shared between threads.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> char*  savesharedpv(const char* pv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;savesharedpvn&quot;</dt>
  <dd>A version of <span class="Li">&quot;savepvn()&quot;</span> which allocates
      the duplicate string in memory which is shared between threads. (With the
      specific difference that a <span class="Li">&quot;NULL&quot;</span>
      pointer is not acceptable)</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> char*  savesharedpvn(const char *const pv, const STRLEN len)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;savesharedpvs&quot;</dt>
  <dd>A version of <span class="Li">&quot;savepvs()&quot;</span> which allocates
      the duplicate string in memory which is shared between threads.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> char*  savesharedpvs(&quot;literal string&quot;)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;savesharedsvpv&quot;</dt>
  <dd>A version of <span class="Li">&quot;savesharedpv()&quot;</span> which
      allocates the duplicate string in memory which is shared between
    threads.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> char*  savesharedsvpv(SV *sv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;savesvpv&quot;</dt>
  <dd>A version of
      <span class="Li">&quot;savepv()&quot;</span>/<span class="Li">&quot;savepvn()&quot;</span>
      which gets the string to duplicate from the passed in SV using
      <span class="Li">&quot;SvPV()&quot;</span>
    <p class="Pp">On some platforms, Windows for example, all allocated memory
        owned by a thread is deallocated when that thread ends. So if you need
        that not to happen, you need to use the shared memory functions, such as
        <span class="Li">&quot;savesharedsvpv&quot;</span>.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> char*  savesvpv(SV* sv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;strEQ&quot;</dt>
  <dd>Test two <span class="Li">&quot;NUL&quot;</span>-terminated strings to see
      if they are equal. Returns true or false.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> bool  strEQ(char* s1, char* s2)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;strGE&quot;</dt>
  <dd>Test two <span class="Li">&quot;NUL&quot;</span>-terminated strings to see
      if the first, <span class="Li">&quot;s1&quot;</span>, is greater than or
      equal to the second, <span class="Li">&quot;s2&quot;</span>. Returns true
      or false.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> bool  strGE(char* s1, char* s2)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;strGT&quot;</dt>
  <dd>Test two <span class="Li">&quot;NUL&quot;</span>-terminated strings to see
      if the first, <span class="Li">&quot;s1&quot;</span>, is greater than the
      second, <span class="Li">&quot;s2&quot;</span>. Returns true or
    false.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> bool  strGT(char* s1, char* s2)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;STRINGIFY&quot;</dt>
  <dd>This macro surrounds its token with double quotes.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> string  STRINGIFY(token x)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;strLE&quot;</dt>
  <dd>Test two <span class="Li">&quot;NUL&quot;</span>-terminated strings to see
      if the first, <span class="Li">&quot;s1&quot;</span>, is less than or
      equal to the second, <span class="Li">&quot;s2&quot;</span>. Returns true
      or false.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> bool  strLE(char* s1, char* s2)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;strLT&quot;</dt>
  <dd>Test two <span class="Li">&quot;NUL&quot;</span>-terminated strings to see
      if the first, <span class="Li">&quot;s1&quot;</span>, is less than the
      second, <span class="Li">&quot;s2&quot;</span>. Returns true or
    false.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> bool  strLT(char* s1, char* s2)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;strNE&quot;</dt>
  <dd>Test two <span class="Li">&quot;NUL&quot;</span>-terminated strings to see
      if they are different. Returns true or false.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> bool  strNE(char* s1, char* s2)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;strnEQ&quot;</dt>
  <dd>Test two <span class="Li">&quot;NUL&quot;</span>-terminated strings to see
      if they are equal. The <span class="Li">&quot;len&quot;</span> parameter
      indicates the number of bytes to compare. Returns true or false. (A
      wrapper for <span class="Li">&quot;strncmp&quot;</span>).</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> bool  strnEQ(char* s1, char* s2, STRLEN len)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;strnNE&quot;</dt>
  <dd>Test two <span class="Li">&quot;NUL&quot;</span>-terminated strings to see
      if they are different. The <span class="Li">&quot;len&quot;</span>
      parameter indicates the number of bytes to compare. Returns true or false.
      (A wrapper for <span class="Li">&quot;strncmp&quot;</span>).</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> bool  strnNE(char* s1, char* s2, STRLEN len)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;STR_WITH_LEN&quot;</dt>
  <dd>Returns two comma separated tokens of the input literal string, and its
      length. This is convenience macro which helps out in some API calls. Note
      that it can't be used as an argument to macros or functions that under
      some configurations might be macros, which means that it requires the full
      Perl_xxx(aTHX_ ...) form for any API calls where it's used.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> pair  STR_WITH_LEN(&quot;literal string&quot;)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;Zero&quot;</dt>
  <dd>The XSUB-writer's interface to the C
      <span class="Li">&quot;memzero&quot;</span> function. The
      <span class="Li">&quot;dest&quot;</span> is the destination,
      <span class="Li">&quot;nitems&quot;</span> is the number of items, and
      <span class="Li">&quot;type&quot;</span> is the type.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  Zero(void* dest, int nitems, type)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;ZeroD&quot;</dt>
  <dd>Like <span class="Li">&quot;Zero&quot;</span> but returns dest. Useful for
      encouraging compilers to tail-call optimise.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void *  ZeroD(void* dest, int nitems, type)
</pre>
</div>
<div class="Bd-indent"></div>
</section>
<section class="Sh">
<h1 class="Sh" id="SV_Flags"><a class="permalink" href="#SV_Flags">SV
  Flags</a></h1>
<dl class="Bl-tag">
  <dt>&quot;SVt_IV&quot;</dt>
  <dd>Type flag for scalars. See &quot;svtype&quot;.</dd>
  <dt>&quot;SVt_NULL&quot;</dt>
  <dd>Type flag for scalars. See &quot;svtype&quot;.</dd>
  <dt>&quot;SVt_NV&quot;</dt>
  <dd>Type flag for scalars. See &quot;svtype&quot;.</dd>
  <dt>&quot;SVt_PV&quot;</dt>
  <dd>Type flag for scalars. See &quot;svtype&quot;.</dd>
  <dt>&quot;SVt_PVAV&quot;</dt>
  <dd>Type flag for arrays. See &quot;svtype&quot;.</dd>
  <dt>&quot;SVt_PVCV&quot;</dt>
  <dd>Type flag for subroutines. See &quot;svtype&quot;.</dd>
  <dt>&quot;SVt_PVFM&quot;</dt>
  <dd>Type flag for formats. See &quot;svtype&quot;.</dd>
  <dt>&quot;SVt_PVGV&quot;</dt>
  <dd>Type flag for typeglobs. See &quot;svtype&quot;.</dd>
  <dt>&quot;SVt_PVHV&quot;</dt>
  <dd>Type flag for hashes. See &quot;svtype&quot;.</dd>
  <dt>&quot;SVt_PVIO&quot;</dt>
  <dd>Type flag for I/O objects. See &quot;svtype&quot;.</dd>
  <dt>&quot;SVt_PVIV&quot;</dt>
  <dd>Type flag for scalars. See &quot;svtype&quot;.</dd>
  <dt>&quot;SVt_PVLV&quot;</dt>
  <dd>Type flag for scalars. See &quot;svtype&quot;.</dd>
  <dt>&quot;SVt_PVMG&quot;</dt>
  <dd>Type flag for scalars. See &quot;svtype&quot;.</dd>
  <dt>&quot;SVt_PVNV&quot;</dt>
  <dd>Type flag for scalars. See &quot;svtype&quot;.</dd>
  <dt>&quot;SVt_REGEXP&quot;</dt>
  <dd>Type flag for regular expressions. See &quot;svtype&quot;.</dd>
  <dt>&quot;svtype&quot;</dt>
  <dd>An enum of flags for Perl types. These are found in the file <i>sv.h</i>
      in the <span class="Li">&quot;svtype&quot;</span> enum. Test these flags
      with the <span class="Li">&quot;SvTYPE&quot;</span> macro.
    <p class="Pp">The types are:</p>
    <p class="Pp"></p>
    <pre>    SVt_NULL
    SVt_IV
    SVt_NV
    SVt_RV
    SVt_PV
    SVt_PVIV
    SVt_PVNV
    SVt_PVMG
    SVt_INVLIST
    SVt_REGEXP
    SVt_PVGV
    SVt_PVLV
    SVt_PVAV
    SVt_PVHV
    SVt_PVCV
    SVt_PVFM
    SVt_PVIO
    </pre>
    <p class="Pp">These are most easily explained from the bottom up.</p>
    <p class="Pp"><span class="Li">&quot;SVt_PVIO&quot;</span> is for I/O
        objects, <span class="Li">&quot;SVt_PVFM&quot;</span> for formats,
        <span class="Li">&quot;SVt_PVCV&quot;</span> for subroutines,
        <span class="Li">&quot;SVt_PVHV&quot;</span> for hashes and
        <span class="Li">&quot;SVt_PVAV&quot;</span> for arrays.</p>
    <p class="Pp">All the others are scalar types, that is, things that can be
        bound to a <span class="Li">&quot;$&quot;</span> variable. For these,
        the internal types are mostly orthogonal to types in the Perl
      language.</p>
    <p class="Pp">Hence, checking <span class="Li">&quot;SvTYPE(sv) &lt;
        SVt_PVAV&quot;</span> is the best way to see whether something is a
        scalar.</p>
    <p class="Pp"><span class="Li">&quot;SVt_PVGV&quot;</span> represents a
        typeglob. If <span class="Li">&quot;!SvFAKE(sv)&quot;</span>, then it is
        a real, incoercible typeglob. If
        <span class="Li">&quot;SvFAKE(sv)&quot;</span>, then it is a scalar to
        which a typeglob has been assigned. Assigning to it again will stop it
        from being a typeglob. <span class="Li">&quot;SVt_PVLV&quot;</span>
        represents a scalar that delegates to another scalar behind the scenes.
        It is used, e.g., for the return value of
        <span class="Li">&quot;substr&quot;</span> and for tied hash and array
        elements. It can hold any scalar value, including a typeglob.
        <span class="Li">&quot;SVt_REGEXP&quot;</span> is for regular
        expressions. <span class="Li">&quot;SVt_INVLIST&quot;</span> is for Perl
        core internal use only.</p>
    <p class="Pp"><span class="Li">&quot;SVt_PVMG&quot;</span> represents a
        &quot;normal&quot; scalar (not a typeglob, regular expression, or
        delegate). Since most scalars do not need all the internal fields of a
        PVMG, we save memory by allocating smaller structs when possible. All
        the other types are just simpler forms of
        <span class="Li">&quot;SVt_PVMG&quot;</span>, with fewer internal
        fields. <span class="Li">&quot;SVt_NULL&quot;</span> can only hold
        undef. <span class="Li">&quot;SVt_IV&quot;</span> can hold undef, an
        integer, or a reference. (<span class="Li">&quot;SVt_RV&quot;</span> is
        an alias for <span class="Li">&quot;SVt_IV&quot;</span>, which exists
        for backward compatibility.) <span class="Li">&quot;SVt_NV&quot;</span>
        can hold any of those or a double.
        <span class="Li">&quot;SVt_PV&quot;</span> can only hold
        <span class="Li">&quot;undef&quot;</span> or a string.
        <span class="Li">&quot;SVt_PVIV&quot;</span> is a superset of
        <span class="Li">&quot;SVt_PV&quot;</span> and
        <span class="Li">&quot;SVt_IV&quot;</span>.
        <span class="Li">&quot;SVt_PVNV&quot;</span> is similar.
        <span class="Li">&quot;SVt_PVMG&quot;</span> can hold anything
        <span class="Li">&quot;SVt_PVNV&quot;</span> can hold, but it can, but
        does not have to, be blessed or magical.</p>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="SV_Handling"><a class="permalink" href="#SV_Handling">SV
  Handling</a></h1>
<p class="Pp">An SV (or AV, HV, etc.) is allocated in two parts: the head
    (struct sv, av, hv...) contains type and reference count information, and
    for many types, a pointer to the body (struct xrv, xpv, xpviv...), which
    contains fields specific to each type. Some types store all they need in the
    head, so don't have a body.</p>
<p class="Pp">In all but the most memory-paranoid configurations (ex: PURIFY),
    heads and bodies are allocated out of arenas, which by default are
    approximately 4K chunks of memory parcelled up into N heads or bodies.
    Sv-bodies are allocated by their sv-type, guaranteeing size consistency
    needed to allocate safely from arrays.</p>
<p class="Pp">For SV-heads, the first slot in each arena is reserved, and holds
    a link to the next arena, some flags, and a note of the number of slots.
    Snaked through each arena chain is a linked list of free items; when this
    becomes empty, an extra arena is allocated and divided up into N items which
    are threaded into the free list.</p>
<p class="Pp">SV-bodies are similar, but they use arena-sets by default, which
    separate the link and info from the arena itself, and reclaim the 1st slot
    in the arena. SV-bodies are further described later.</p>
<p class="Pp">The following global variables are associated with arenas:</p>
<p class="Pp"></p>
<pre> PL_sv_arenaroot     pointer to list of SV arenas
 PL_sv_root          pointer to list of free SV structures
 PL_body_arenas      head of linked-list of body arenas
 PL_body_roots[]     array of pointers to list of free bodies of svtype
                     arrays are indexed by the svtype needed
</pre>
<p class="Pp">A few special SV heads are not allocated from an arena, but are
    instead directly created in the interpreter structure, eg PL_sv_undef. The
    size of arenas can be changed from the default by setting PERL_ARENA_SIZE
    appropriately at compile time.</p>
<p class="Pp">The SV arena serves the secondary purpose of allowing still-live
    SVs to be located and destroyed during final cleanup.</p>
<p class="Pp">At the lowest level, the macros <b>new_SV()</b> and
    <b>del_SV()</b> grab and free an SV head. (If debugging with -DD,
    <b>del_SV()</b> calls the function <b>S_del_sv()</b> to return the SV to the
    free list with error checking.) <b>new_SV()</b> calls <b>more_sv()</b> /
    <b>sv_add_arena()</b> to add an extra arena if the free list is empty. SVs
    in the free list have their SvTYPE field set to all ones.</p>
<p class="Pp">At the time of very final cleanup, <b>sv_free_arenas()</b> is
    called from <b>perl_destruct()</b> to physically free all the arenas
    allocated since the start of the interpreter.</p>
<p class="Pp">The internal function <b>visit()</b> scans the SV arenas list, and
    calls a specified function for each SV it finds which is still live,
    <i>i.e.</i> which has an SvTYPE other than all 1's, and a non-zero SvREFCNT.
    <b>visit()</b> is used by the following functions (specified as [function
    that calls <b>visit()</b>] / [function called by <b>visit()</b> for each
    SV]):</p>
<p class="Pp"></p>
<pre>    sv_report_used() / do_report_used()
                        dump all remaining SVs (debugging aid)
    sv_clean_objs() / do_clean_objs(),do_clean_named_objs(),
                      do_clean_named_io_objs(),do_curse()
                        Attempt to free all objects pointed to by RVs,
                        try to do the same for all objects indir-
                        ectly referenced by typeglobs too, and
                        then do a final sweep, cursing any
                        objects that remain.  Called once from
                        perl_destruct(), prior to calling sv_clean_all()
                        below.
    sv_clean_all() / do_clean_all()
                        SvREFCNT_dec(sv) each remaining SV, possibly
                        triggering an sv_free(). It also sets the
                        SVf_BREAK flag on the SV to indicate that the
                        refcnt has been artificially lowered, and thus
                        stopping sv_free() from giving spurious warnings
                        about SVs which unexpectedly have a refcnt
                        of zero.  called repeatedly from perl_destruct()
                        until there are no SVs left.
</pre>
<section class="Ss">
<h2 class="Ss" id="Arena_allocator_"><a class="permalink" href="#Arena_allocator_">Arena
  allocator API Summary</a></h2>
<p class="Pp">Private API to rest of sv.c</p>
<p class="Pp"></p>
<pre>    new_SV(),  del_SV(),
    new_XPVNV(), del_XPVGV(),
    etc
</pre>
<p class="Pp">Public API:</p>
<p class="Pp"></p>
<pre>    sv_report_used(), sv_clean_objs(), sv_clean_all(), sv_free_arenas()
</pre>
<dl class="Bl-tag">
  <dt>&quot;boolSV&quot;</dt>
  <dd>Returns a true SV if <span class="Li">&quot;b&quot;</span> is a true
      value, or a false SV if <span class="Li">&quot;b&quot;</span> is 0.
    <p class="Pp">See also <span class="Li">&quot;PL_sv_yes&quot;</span> and
        <span class="Li">&quot;PL_sv_no&quot;</span>.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> SV *  boolSV(bool b)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;croak_xs_usage&quot;</dt>
  <dd>A specialised variant of <span class="Li">&quot;croak()&quot;</span> for
      emitting the usage message for xsubs
    <p class="Pp"></p>
    <pre>    croak_xs_usage(cv, &quot;eee_yow&quot;);
    </pre>
    <p class="Pp">works out the package name and subroutine name from
        <span class="Li">&quot;cv&quot;</span>, and then calls
        <span class="Li">&quot;croak()&quot;</span>. Hence if
        <span class="Li">&quot;cv&quot;</span> is
        <span class="Li">&amp;ouch::awk</span>, it would call
        <span class="Li">&quot;croak&quot;</span> as:</p>
    <p class="Pp"></p>
    <pre> Perl_croak(aTHX_ &quot;Usage: %&quot; SVf &quot;::%&quot; SVf &quot;(%s)&quot;, &quot;ouch&quot; &quot;awk&quot;,
                                                     &quot;eee_yow&quot;);
    </pre>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  croak_xs_usage(const CV *const cv, const char *const params)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;DEFSV&quot;</dt>
  <dd>Returns the SV associated with <span class="Li">$_</span></dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> SV *  DEFSV
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;DEFSV_set&quot;</dt>
  <dd>Associate <span class="Li">&quot;sv&quot;</span> with
      <span class="Li">$_</span></dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  DEFSV_set(SV * sv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;get_sv&quot;</dt>
  <dd>Returns the SV of the specified Perl scalar.
      <span class="Li">&quot;flags&quot;</span> are passed to
      <span class="Li">&quot;gv_fetchpv&quot;</span>. If
      <span class="Li">&quot;GV_ADD&quot;</span> is set and the Perl variable
      does not exist then it will be created. If
      <span class="Li">&quot;flags&quot;</span> is zero and the variable does
      not exist then NULL is returned.
    <p class="Pp">NOTE: the <span class="Li">&quot;perl_get_sv()&quot;</span>
        form is <b>deprecated</b>.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> SV*  get_sv(const char *name, I32 flags)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;isGV_with_GP&quot;</dt>
  <dd>Returns a boolean as to whether or not
      <span class="Li">&quot;sv&quot;</span> is a GV with a pointer to a GP
      (glob pointer).</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> bool  isGV_with_GP(SV * sv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;looks_like_number&quot;</dt>
  <dd>Test if the content of an SV looks like a number (or is a number).
      <span class="Li">&quot;Inf&quot;</span> and
      <span class="Li">&quot;Infinity&quot;</span> are treated as numbers (so
      will not issue a non-numeric warning), even if your
      <span class="Li">&quot;atof()&quot;</span> doesn't grok them. Get-magic is
      ignored.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> I32  looks_like_number(SV *const sv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;MUTABLE_PTR&quot;</dt>
  <dd></dd>
  <dt>&quot;MUTABLE_AV&quot;</dt>
  <dd></dd>
  <dt>&quot;MUTABLE_CV&quot;</dt>
  <dd></dd>
  <dt>&quot;MUTABLE_GV&quot;</dt>
  <dd></dd>
  <dt>&quot;MUTABLE_HV&quot;</dt>
  <dd></dd>
  <dt>&quot;MUTABLE_IO&quot;</dt>
  <dd></dd>
  <dt>&quot;MUTABLE_SV&quot;</dt>
  <dd>The
      <span class="Li">&quot;MUTABLE_</span><span class="Li"><i>*</i></span><span class="Li">&quot;</span>()
      macros cast pointers to the types shown, in such a way (compiler
      permitting) that casting away const-ness will give a warning; e.g.:
    <p class="Pp"></p>
    <pre> const SV *sv = ...;
 AV *av1 = (AV*)sv;        &lt;== BAD:  the const has been silently
                                     cast away
 AV *av2 = MUTABLE_AV(sv); &lt;== GOOD: it may warn
    </pre>
    <p class="Pp"><span class="Li">&quot;MUTABLE_PTR&quot;</span> is the base
        macro used to derive new casts. The other already-built-in ones return
        pointers to what their names indicate.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void *  MUTABLE_PTR(void * p)
 AV *    MUTABLE_AV (AV * p)
 CV *    MUTABLE_CV (CV * p)
 GV *    MUTABLE_GV (GV * p)
 HV *    MUTABLE_HV (HV * p)
 IO *    MUTABLE_IO (IO * p)
 SV *    MUTABLE_SV (SV * p)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;newRV&quot;</dt>
  <dd></dd>
  <dt>&quot;newRV_inc&quot;</dt>
  <dd>These are identical. They create an RV wrapper for an SV. The reference
      count for the original SV is incremented.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> SV*  newRV(SV *const sv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;newRV_noinc&quot;</dt>
  <dd>Creates an RV wrapper for an SV. The reference count for the original SV
      is <b>not</b> incremented.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> SV*  newRV_noinc(SV *const tmpRef)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;newSV&quot;</dt>
  <dd>Creates a new SV. A non-zero <span class="Li">&quot;len&quot;</span>
      parameter indicates the number of bytes of preallocated string space the
      SV should have. An extra byte for a trailing
      <span class="Li">&quot;NUL&quot;</span> is also reserved.
      (<span class="Li">&quot;SvPOK&quot;</span> is not set for the SV even if
      string space is allocated.) The reference count for the new SV is set to
      1.
    <p class="Pp">In 5.9.3, <span class="Li">&quot;newSV()&quot;</span> replaces
        the older <span class="Li">&quot;NEWSV()&quot;</span> API, and drops the
        first parameter, <i>x</i>, a debug aid which allowed callers to identify
        themselves. This aid has been superseded by a new build option,
        <span class="Li">&quot;PERL_MEM_LOG&quot;</span> (see
        &quot;PERL_MEM_LOG&quot; in perlhacktips). The older API is still there
        for use in XS modules supporting older perls.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> SV*  newSV(const STRLEN len)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;newSVhek&quot;</dt>
  <dd>Creates a new SV from the hash key structure. It will generate scalars
      that point to the shared string table where possible. Returns a new
      (undefined) SV if <span class="Li">&quot;hek&quot;</span> is NULL.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> SV*  newSVhek(const HEK *const hek)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;newSViv&quot;</dt>
  <dd>Creates a new SV and copies an integer into it. The reference count for
      the SV is set to 1.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> SV*  newSViv(const IV i)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;newSVnv&quot;</dt>
  <dd>Creates a new SV and copies a floating point value into it. The reference
      count for the SV is set to 1.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> SV*  newSVnv(const NV n)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;newSVpadname&quot;</dt>
  <dd>NOTE: <span class="Li">&quot;newSVpadname&quot;</span> is
      <b>experimental</b> and may change or be removed without notice.
    <p class="Pp">Creates a new SV containing the pad name.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> SV*  newSVpadname(PADNAME *pn)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;newSVpv&quot;</dt>
  <dd>Creates a new SV and copies a string (which may contain
      <span class="Li">&quot;NUL&quot;</span>
      (<span class="Li">&quot;\0&quot;</span>) characters) into it. The
      reference count for the SV is set to 1. If
      <span class="Li">&quot;len&quot;</span> is zero, Perl will compute the
      length using <span class="Li">&quot;strlen()&quot;</span>, (which means if
      you use this option, that <span class="Li">&quot;s&quot;</span> can't have
      embedded <span class="Li">&quot;NUL&quot;</span> characters and has to
      have a terminating <span class="Li">&quot;NUL&quot;</span> byte).
    <p class="Pp">This function can cause reliability issues if you are likely
        to pass in empty strings that are not null terminated, because it will
        run strlen on the string and potentially run past valid memory.</p>
    <p class="Pp">Using &quot;newSVpvn&quot; is a safer alternative for non
        <span class="Li">&quot;NUL&quot;</span> terminated strings. For string
        literals use &quot;newSVpvs&quot; instead. This function will work fine
        for <span class="Li">&quot;NUL&quot;</span> terminated strings, but if
        you want to avoid the if statement on whether to call
        <span class="Li">&quot;strlen&quot;</span> use
        <span class="Li">&quot;newSVpvn&quot;</span> instead (calling
        <span class="Li">&quot;strlen&quot;</span> yourself).</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> SV*  newSVpv(const char *const s, const STRLEN len)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;newSVpvf&quot;</dt>
  <dd>Creates a new SV and initializes it with the string formatted like
      <span class="Li">&quot;sv_catpvf&quot;</span>.
    <p class="Pp">NOTE: <span class="Li">&quot;newSVpvf&quot;</span> must be
        explicitly called as <span class="Li">&quot;Perl_newSVpvf&quot;</span>
        with an <span class="Li">&quot;aTHX_&quot;</span> parameter.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> SV*  Perl_newSVpvf(pTHX_ const char *const pat, ...)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;newSVpvf_nocontext&quot;</dt>
  <dd>Like <span class="Li">&quot;newSVpvf&quot;</span> but does not take a
      thread context (<span class="Li">&quot;aTHX&quot;</span>) parameter, so is
      used in situations where the caller doesn't already have the thread
      context.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> SV*  newSVpvf_nocontext(const char *const pat, ...)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;newSVpvn&quot;</dt>
  <dd>Creates a new SV and copies a string into it, which may contain
      <span class="Li">&quot;NUL&quot;</span> characters
      (<span class="Li">&quot;\0&quot;</span>) and other binary data. The
      reference count for the SV is set to 1. Note that if
      <span class="Li">&quot;len&quot;</span> is zero, Perl will create a zero
      length (Perl) string. You are responsible for ensuring that the source
      buffer is at least <span class="Li">&quot;len&quot;</span> bytes long. If
      the <span class="Li">&quot;buffer&quot;</span> argument is NULL the new SV
      will be undefined.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> SV*  newSVpvn(const char *const buffer, const STRLEN len)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;newSVpvn_flags&quot;</dt>
  <dd>Creates a new SV and copies a string (which may contain
      <span class="Li">&quot;NUL&quot;</span>
      (<span class="Li">&quot;\0&quot;</span>) characters) into it. The
      reference count for the SV is set to 1. Note that if
      <span class="Li">&quot;len&quot;</span> is zero, Perl will create a zero
      length string. You are responsible for ensuring that the source string is
      at least <span class="Li">&quot;len&quot;</span> bytes long. If the
      <span class="Li">&quot;s&quot;</span> argument is NULL the new SV will be
      undefined. Currently the only flag bits accepted are
      <span class="Li">&quot;SVf_UTF8&quot;</span> and
      <span class="Li">&quot;SVs_TEMP&quot;</span>. If
      <span class="Li">&quot;SVs_TEMP&quot;</span> is set, then
      <span class="Li">&quot;sv_2mortal()&quot;</span> is called on the result
      before returning. If <span class="Li">&quot;SVf_UTF8&quot;</span> is set,
      <span class="Li">&quot;s&quot;</span> is considered to be in UTF-8 and the
      <span class="Li">&quot;SVf_UTF8&quot;</span> flag will be set on the new
      SV. <span class="Li">&quot;newSVpvn_utf8()&quot;</span> is a convenience
      wrapper for this function, defined as
    <p class="Pp"></p>
    <pre>    #define newSVpvn_utf8(s, len, u)                    \
        newSVpvn_flags((s), (len), (u) ? SVf_UTF8 : 0)
    </pre>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> SV*  newSVpvn_flags(const char *const s, const STRLEN len,
                     const U32 flags)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;newSVpvn_share&quot;</dt>
  <dd>Creates a new SV with its <span class="Li">&quot;SvPVX_const&quot;</span>
      pointing to a shared string in the string table. If the string does not
      already exist in the table, it is created first. Turns on the
      <span class="Li">&quot;SvIsCOW&quot;</span> flag (or
      <span class="Li">&quot;READONLY&quot;</span> and
      <span class="Li">&quot;FAKE&quot;</span> in 5.16 and earlier). If the
      <span class="Li">&quot;hash&quot;</span> parameter is non-zero, that value
      is used; otherwise the hash is computed. The string's hash can later be
      retrieved from the SV with the
      <span class="Li">&quot;SvSHARED_HASH&quot;</span> macro. The idea here is
      that as the string table is used for shared hash keys these strings will
      have <span class="Li">&quot;SvPVX_const == HeKEY&quot;</span> and hash
      lookup will avoid string compare.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> SV*  newSVpvn_share(const char* s, I32 len, U32 hash)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;newSVpvn_utf8&quot;</dt>
  <dd>Creates a new SV and copies a string (which may contain
      <span class="Li">&quot;NUL&quot;</span>
      (<span class="Li">&quot;\0&quot;</span>) characters) into it. If
      <span class="Li">&quot;utf8&quot;</span> is true, calls
      <span class="Li">&quot;SvUTF8_on&quot;</span> on the new SV. Implemented
      as a wrapper around
    <span class="Li">&quot;newSVpvn_flags&quot;</span>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> SV*  newSVpvn_utf8(const char* s, STRLEN len, U32 utf8)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;newSVpvs&quot;</dt>
  <dd>Like <span class="Li">&quot;newSVpvn&quot;</span>, but takes a literal
      string instead of a string/length pair.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> SV*  newSVpvs(&quot;literal string&quot;)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;newSVpvs_flags&quot;</dt>
  <dd>Like <span class="Li">&quot;newSVpvn_flags&quot;</span>, but takes a
      literal string instead of a string/length pair.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> SV*  newSVpvs_flags(&quot;literal string&quot;, U32 flags)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;newSVpv_share&quot;</dt>
  <dd>Like <span class="Li">&quot;newSVpvn_share&quot;</span>, but takes a
      <span class="Li">&quot;NUL&quot;</span>-terminated string instead of a
      string/length pair.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> SV*  newSVpv_share(const char* s, U32 hash)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;newSVpvs_share&quot;</dt>
  <dd>Like <span class="Li">&quot;newSVpvn_share&quot;</span>, but takes a
      literal string instead of a string/length pair and omits the hash
      parameter.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> SV*  newSVpvs_share(&quot;literal string&quot;)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;newSVrv&quot;</dt>
  <dd>Creates a new SV for the existing RV,
      <span class="Li">&quot;rv&quot;</span>, to point to. If
      <span class="Li">&quot;rv&quot;</span> is not an RV then it will be
      upgraded to one. If <span class="Li">&quot;classname&quot;</span> is
      non-null then the new SV will be blessed in the specified package. The new
      SV is returned and its reference count is 1. The reference count 1 is
      owned by <span class="Li">&quot;rv&quot;</span>. See also
      <b>newRV_inc()</b> and <b>newRV_noinc()</b> for creating a new RV
      properly.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> SV*  newSVrv(SV *const rv, const char *const classname)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;newSVsv&quot;</dt>
  <dd></dd>
  <dt>&quot;newSVsv_nomg&quot;</dt>
  <dd></dd>
  <dt>&quot;newSVsv_flags&quot;</dt>
  <dd>These create a new SV which is an exact duplicate of the original SV
      (using <span class="Li">&quot;sv_setsv&quot;</span>.)
    <p class="Pp">They differ only in that
        <span class="Li">&quot;newSVsv&quot;</span> performs 'get' magic;
        <span class="Li">&quot;newSVsv_nomg&quot;</span> skips any magic; and
        <span class="Li">&quot;newSVsv_flags&quot;</span> allows you to
        explicitly set a <span class="Li">&quot;flags&quot;</span>
      parameter.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> SV*  newSVsv      (SV *const old)
 SV*  newSVsv_nomg (SV *const old)
 SV*  newSVsv_flags(SV *const old, I32 flags)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;newSV_type&quot;</dt>
  <dd>Creates a new SV, of the type specified. The reference count for the new
      SV is set to 1.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> SV*  newSV_type(const svtype type)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;newSVuv&quot;</dt>
  <dd>Creates a new SV and copies an unsigned integer into it. The reference
      count for the SV is set to 1.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> SV*  newSVuv(const UV u)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;Nullsv&quot;</dt>
  <dd>Null SV pointer. (No longer available when
      <span class="Li">&quot;PERL_CORE&quot;</span> is defined.)</dd>
  <dt>&quot;PL_na&quot;</dt>
  <dd>A convenience variable which is typically used with
      <span class="Li">&quot;SvPV&quot;</span> when one doesn't care about the
      length of the string. It is usually more efficient to either declare a
      local variable and use that instead or to use the
      <span class="Li">&quot;SvPV_nolen&quot;</span> macro.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> STRLEN  PL_na
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;PL_sv_no&quot;</dt>
  <dd>This is the <span class="Li">&quot;false&quot;</span> SV. It is readonly.
      See <span class="Li">&quot;PL_sv_yes&quot;</span>. Always refer to this as
      <span class="Li">&amp;PL_sv_no</span>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> SV  PL_sv_no
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;PL_sv_undef&quot;</dt>
  <dd>This is the <span class="Li">&quot;undef&quot;</span> SV. It is readonly.
      Always refer to this as <span class="Li">&amp;PL_sv_undef</span>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> SV  PL_sv_undef
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;PL_sv_yes&quot;</dt>
  <dd>This is the <span class="Li">&quot;true&quot;</span> SV. It is readonly.
      See <span class="Li">&quot;PL_sv_no&quot;</span>. Always refer to this as
      <span class="Li">&amp;PL_sv_yes</span>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> SV  PL_sv_yes
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;PL_sv_zero&quot;</dt>
  <dd>This readonly SV has a zero numeric value and a
      <span class="Li">&quot;0&quot;</span> string value. It's similar to
      <span class="Li">&quot;PL_sv_no&quot;</span> except for its string value.
      Can be used as a cheap alternative to <span class="Li">mXPUSHi(0)</span>
      for example. Always refer to this as
      <span class="Li">&amp;PL_sv_zero</span>. Introduced in 5.28.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> SV  PL_sv_zero
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;SAVE_DEFSV&quot;</dt>
  <dd>Localize <span class="Li">$_</span>. See &quot;Localizing changes&quot; in
      perlguts.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  SAVE_DEFSV
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;sortsv&quot;</dt>
  <dd>In-place sort an array of SV pointers with the given comparison routine.
    <p class="Pp">Currently this always uses mergesort. See
        <span class="Li">&quot;sortsv_flags&quot;</span> for a more flexible
        routine.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  sortsv(SV** array, size_t num_elts, SVCOMPARE_t cmp)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;sortsv_flags&quot;</dt>
  <dd>In-place sort an array of SV pointers with the given comparison routine,
      with various SORTf_* flag options.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  sortsv_flags(SV** array, size_t num_elts, SVCOMPARE_t cmp,
                    U32 flags)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;SV&quot;</dt>
  <dd>Described in perlguts.</dd>
  <dt>&quot;sv_2cv&quot;</dt>
  <dd>Using various gambits, try to get a CV from an SV; in addition, try if
      possible to set <span class="Li">*st</span> and
      <span class="Li">*gvp</span> to the stash and GV associated with it. The
      flags in <span class="Li">&quot;lref&quot;</span> are passed to
      <span class="Li">&quot;gv_fetchsv&quot;</span>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> CV*  sv_2cv(SV* sv, HV **const st, GV **const gvp, const I32 lref)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;sv_2io&quot;</dt>
  <dd>Using various gambits, try to get an IO from an SV: the IO slot if its a
      GV; or the recursive result if we're an RV; or the IO slot of the symbol
      named after the PV if we're a string.
    <p class="Pp">'Get' magic is ignored on the
        <span class="Li">&quot;sv&quot;</span> passed in, but will be called on
        <span class="Li">&quot;SvRV(sv)&quot;</span> if
        <span class="Li">&quot;sv&quot;</span> is an RV.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> IO*  sv_2io(SV *const sv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;sv_2iv_flags&quot;</dt>
  <dd>Return the integer value of an SV, doing any necessary string conversion.
      If <span class="Li">&quot;flags&quot;</span> has the
      <span class="Li">&quot;SV_GMAGIC&quot;</span> bit set, does an
      <span class="Li">&quot;mg_get()&quot;</span> first. Normally used via the
      <span class="Li">&quot;SvIV(sv)&quot;</span> and
      <span class="Li">&quot;SvIVx(sv)&quot;</span> macros.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> IV  sv_2iv_flags(SV *const sv, const I32 flags)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;sv_2mortal&quot;</dt>
  <dd>Marks an existing SV as mortal. The SV will be destroyed &quot;soon&quot;,
      either by an explicit call to
      <span class="Li">&quot;FREETMPS&quot;</span>, or by an implicit call at
      places such as statement boundaries.
      <span class="Li">&quot;SvTEMP()&quot;</span> is turned on which means that
      the SV's string buffer can be &quot;stolen&quot; if this SV is copied. See
      also <span class="Li">&quot;sv_newmortal&quot;</span> and
      <span class="Li">&quot;sv_mortalcopy&quot;</span>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> SV*  sv_2mortal(SV *const sv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;sv_2nv_flags&quot;</dt>
  <dd>Return the num value of an SV, doing any necessary string or integer
      conversion. If <span class="Li">&quot;flags&quot;</span> has the
      <span class="Li">&quot;SV_GMAGIC&quot;</span> bit set, does an
      <span class="Li">&quot;mg_get()&quot;</span> first. Normally used via the
      <span class="Li">&quot;SvNV(sv)&quot;</span> and
      <span class="Li">&quot;SvNVx(sv)&quot;</span> macros.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> NV  sv_2nv_flags(SV *const sv, const I32 flags)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;sv_2pvbyte&quot;</dt>
  <dd>Returns a pointer to the byte-encoded representation of the SV, and set
      <span class="Li">*lp</span> to its length. If the SV is marked as being
      encoded as UTF-8, it will downgrade it to a byte string as a side-effect,
      if possible. If the SV cannot be downgraded, this croaks.
    <p class="Pp">Processes 'get' magic.</p>
    <p class="Pp">Usually accessed via the
        <span class="Li">&quot;SvPVbyte&quot;</span> macro.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> char*  sv_2pvbyte(SV *sv, STRLEN *const lp)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;sv_2pvutf8&quot;</dt>
  <dd>Return a pointer to the UTF-8-encoded representation of the SV, and set
      <span class="Li">*lp</span> to its length. May cause the SV to be upgraded
      to UTF-8 as a side-effect.
    <p class="Pp">Usually accessed via the
        <span class="Li">&quot;SvPVutf8&quot;</span> macro.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> char*  sv_2pvutf8(SV *sv, STRLEN *const lp)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;sv_2uv_flags&quot;</dt>
  <dd>Return the unsigned integer value of an SV, doing any necessary string
      conversion. If <span class="Li">&quot;flags&quot;</span> has the
      <span class="Li">&quot;SV_GMAGIC&quot;</span> bit set, does an
      <span class="Li">&quot;mg_get()&quot;</span> first. Normally used via the
      <span class="Li">&quot;SvUV(sv)&quot;</span> and
      <span class="Li">&quot;SvUVx(sv)&quot;</span> macros.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> UV  sv_2uv_flags(SV *const sv, const I32 flags)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;sv_backoff&quot;</dt>
  <dd>Remove any string offset. You should normally use the
      <span class="Li">&quot;SvOOK_off&quot;</span> macro wrapper instead.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  sv_backoff(SV *const sv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;sv_bless&quot;</dt>
  <dd>Blesses an SV into a specified package. The SV must be an RV. The package
      must be designated by its stash (see
      <span class="Li">&quot;gv_stashpv&quot;</span>). The reference count of
      the SV is unaffected.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> SV*  sv_bless(SV *const sv, HV *const stash)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;sv_catpv&quot;</dt>
  <dd></dd>
  <dt>&quot;sv_catpv_flags&quot;</dt>
  <dd></dd>
  <dt>&quot;sv_catpv_mg&quot;</dt>
  <dd></dd>
  <dt>&quot;sv_catpv_nomg&quot;</dt>
  <dd>These concatenate the <span class="Li">&quot;NUL&quot;</span>-terminated
      string <span class="Li">&quot;sstr&quot;</span> onto the end of the string
      which is in the SV. If the SV has the UTF-8 status set, then the bytes
      appended should be valid UTF-8.
    <p class="Pp">They differ only in how they handle magic:</p>
    <p class="Pp"><span class="Li">&quot;sv_catpv_mg&quot;</span> performs both
        'get' and 'set' magic.</p>
    <p class="Pp"><span class="Li">&quot;sv_catpv&quot;</span> performs only
        'get' magic.</p>
    <p class="Pp"><span class="Li">&quot;sv_catpv_nomg&quot;</span> skips all
        magic.</p>
    <p class="Pp"><span class="Li">&quot;sv_catpv_flags&quot;</span> has an
        extra <span class="Li">&quot;flags&quot;</span> parameter which allows
        you to specify any combination of magic handling (using
        <span class="Li">&quot;SV_GMAGIC&quot;</span> and/or
        <span class="Li">&quot;SV_SMAGIC&quot;</span>), and to also override the
        UTF-8 handling. By supplying the
        <span class="Li">&quot;SV_CATUTF8&quot;</span> flag, the appended string
        is forced to be interpreted as UTF-8; by supplying instead the
        <span class="Li">&quot;SV_CATBYTES&quot;</span> flag, it will be
        interpreted as just bytes. Either the SV or the string appended will be
        upgraded to UTF-8 if necessary.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  sv_catpv      (SV *const dsv, const char* sstr)
 void  sv_catpv_flags(SV *dsv, const char *sstr, const I32 flags)
 void  sv_catpv_mg   (SV *const dsv, const char *const sstr)
 void  sv_catpv_nomg (SV *const dsv, const char* sstr)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;sv_catpvf&quot;</dt>
  <dd></dd>
  <dt>&quot;sv_catpvf_nocontext&quot;</dt>
  <dd></dd>
  <dt>&quot;sv_catpvf_mg&quot;</dt>
  <dd></dd>
  <dt>&quot;sv_catpvf_mg_nocontext&quot;</dt>
  <dd>These process their arguments like
      <span class="Li">&quot;sprintf&quot;</span>, and append the formatted
      output to an SV. As with <span class="Li">&quot;sv_vcatpvfn&quot;</span>,
      argument reordering is not supporte when called with a non-null C-style
      variable argument list.
    <p class="Pp">If the appended data contains &quot;wide&quot; characters
        (including, but not limited to, SVs with a UTF-8 PV formatted with
        <span class="Li">%s</span>, and characters &gt;255 formatted with
        <span class="Li">%c</span>), the original SV might get upgraded to
        UTF-8.</p>
    <p class="Pp">If the original SV was UTF-8, the pattern should be valid
        UTF-8; if the original SV was bytes, the pattern should be too.</p>
    <p class="Pp">All perform 'get' magic, but only
        <span class="Li">&quot;sv_catpvf_mg&quot;</span> and
        <span class="Li">&quot;sv_catpvf_mg_nocontext&quot;</span> perform 'set'
        magic.</p>
    <p class="Pp"><span class="Li">&quot;sv_catpvf_nocontext&quot;</span> and
        <span class="Li">&quot;sv_catpvf_mg_nocontext&quot;</span> do not take a
        thread context (<span class="Li">&quot;aTHX&quot;</span>) parameter, so
        are used in situations where the caller doesn't already have the thread
        context.</p>
    <p class="Pp">NOTE: <span class="Li">&quot;sv_catpvf&quot;</span> must be
        explicitly called as <span class="Li">&quot;Perl_sv_catpvf&quot;</span>
        with an <span class="Li">&quot;aTHX_&quot;</span> parameter.</p>
    <p class="Pp">NOTE: <span class="Li">&quot;sv_catpvf_mg&quot;</span> must be
        explicitly called as
        <span class="Li">&quot;Perl_sv_catpvf_mg&quot;</span> with an
        <span class="Li">&quot;aTHX_&quot;</span> parameter.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  Perl_sv_catpvf        (pTHX_ SV *const sv,
                              const char *const pat, ...)
 void  sv_catpvf_nocontext   (SV *const sv, const char *const pat,
                              ...)
 void  Perl_sv_catpvf_mg     (pTHX_ SV *const sv,
                              const char *const pat, ...)
 void  sv_catpvf_mg_nocontext(SV *const sv, const char *const pat,
                              ...)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;sv_catpvn&quot;</dt>
  <dd></dd>
  <dt>&quot;sv_catpvn_flags&quot;</dt>
  <dd></dd>
  <dt>&quot;sv_catpvn_mg&quot;</dt>
  <dd></dd>
  <dt>&quot;sv_catpvn_nomg&quot;</dt>
  <dd>These concatenate the <span class="Li">&quot;len&quot;</span> bytes of the
      string beginning at <span class="Li">&quot;ptr&quot;</span> onto the end
      of the string which is in <span class="Li">&quot;dsv&quot;</span>. The
      caller must make sure <span class="Li">&quot;ptr&quot;</span> contains at
      least <span class="Li">&quot;len&quot;</span> bytes.
    <p class="Pp">For all but
        <span class="Li">&quot;sv_catpvn_flags&quot;</span>, the string appended
        is assumed to be valid UTF-8 if the SV has the UTF-8 status set, and a
        string of bytes otherwise.</p>
    <p class="Pp">They differ in that:</p>
    <p class="Pp"><span class="Li">&quot;sv_catpvn_mg&quot;</span> performs both
        'get' and 'set' magic on <span class="Li">&quot;dsv&quot;</span>.</p>
    <p class="Pp"><span class="Li">&quot;sv_catpvn&quot;</span> performs only
        'get' magic.</p>
    <p class="Pp"><span class="Li">&quot;sv_catpvn_nomg&quot;</span> skips all
        magic.</p>
    <p class="Pp"><span class="Li">&quot;sv_catpvn_flags&quot;</span> has an
        extra <span class="Li">&quot;flags&quot;</span> parameter which allows
        you to specify any combination of magic handling (using
        <span class="Li">&quot;SV_GMAGIC&quot;</span> and/or
        <span class="Li">&quot;SV_SMAGIC&quot;</span>) and to also override the
        UTF-8 handling. By supplying the
        <span class="Li">&quot;SV_CATBYTES&quot;</span> flag, the appended
        string is interpreted as plain bytes; by supplying instead the
        <span class="Li">&quot;SV_CATUTF8&quot;</span> flag, it will be
        interpreted as UTF-8, and the <span class="Li">&quot;dsv&quot;</span>
        will be upgraded to UTF-8 if necessary.</p>
    <p class="Pp"><span class="Li">&quot;sv_catpvn&quot;</span>,
        <span class="Li">&quot;sv_catpvn_mg&quot;</span>, and
        <span class="Li">&quot;sv_catpvn_nomg&quot;</span> are implemented in
        terms of <span class="Li">&quot;sv_catpvn_flags&quot;</span>.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  sv_catpvn      (SV *dsv, const char *sstr, STRLEN len)
 void  sv_catpvn_flags(SV *const dsv, const char *sstr,
                       const STRLEN len, const I32 flags)
 void  sv_catpvn_mg   (SV *dsv, const char *sstr, STRLEN len)
 void  sv_catpvn_nomg (SV *dsv, const char *sstr, STRLEN len)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;sv_catpvs&quot;</dt>
  <dd>Like <span class="Li">&quot;sv_catpvn&quot;</span>, but takes a literal
      string instead of a string/length pair.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  sv_catpvs(SV* sv, &quot;literal string&quot;)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;sv_catpvs_flags&quot;</dt>
  <dd>Like <span class="Li">&quot;sv_catpvn_flags&quot;</span>, but takes a
      literal string instead of a string/length pair.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  sv_catpvs_flags(SV* sv, &quot;literal string&quot;, I32 flags)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;sv_catpvs_mg&quot;</dt>
  <dd>Like <span class="Li">&quot;sv_catpvn_mg&quot;</span>, but takes a literal
      string instead of a string/length pair.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  sv_catpvs_mg(SV* sv, &quot;literal string&quot;)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;sv_catpvs_nomg&quot;</dt>
  <dd>Like <span class="Li">&quot;sv_catpvn_nomg&quot;</span>, but takes a
      literal string instead of a string/length pair.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  sv_catpvs_nomg(SV* sv, &quot;literal string&quot;)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;sv_catsv&quot;</dt>
  <dd></dd>
  <dt>&quot;sv_catsv_flags&quot;</dt>
  <dd></dd>
  <dt>&quot;sv_catsv_mg&quot;</dt>
  <dd></dd>
  <dt>&quot;sv_catsv_nomg&quot;</dt>
  <dd>These concatenate the string from SV
      <span class="Li">&quot;sstr&quot;</span> onto the end of the string in SV
      <span class="Li">&quot;dsv&quot;</span>. If
      <span class="Li">&quot;sstr&quot;</span> is null, these are no-ops;
      otherwise only <span class="Li">&quot;dsv&quot;</span> is modified.
    <p class="Pp">They differ only in what magic they perform:</p>
    <p class="Pp"><span class="Li">&quot;sv_catsv_mg&quot;</span> performs 'get'
        magic on both SVs before the copy, and 'set' magic on
        <span class="Li">&quot;dsv&quot;</span> afterwards.</p>
    <p class="Pp"><span class="Li">&quot;sv_catsv&quot;</span> performs just
        'get' magic, on both SVs.</p>
    <p class="Pp"><span class="Li">&quot;sv_catsv_nomg&quot;</span> skips all
        magic.</p>
    <p class="Pp"><span class="Li">&quot;sv_catsv_flags&quot;</span> has an
        extra <span class="Li">&quot;flags&quot;</span> parameter which allows
        you to use <span class="Li">&quot;SV_GMAGIC&quot;</span> and/or
        <span class="Li">&quot;SV_SMAGIC&quot;</span> to specify any combination
        of magic handling (although either both or neither SV will have 'get'
        magic applied to it.)</p>
    <p class="Pp"><span class="Li">&quot;sv_catsv&quot;</span>,
        <span class="Li">&quot;sv_catsv_mg&quot;</span>, and
        <span class="Li">&quot;sv_catsv_nomg&quot;</span> are implemented in
        terms of <span class="Li">&quot;sv_catsv_flags&quot;</span>.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  sv_catsv      (SV *dsv, SV *sstr)
 void  sv_catsv_flags(SV *const dsv, SV *const sstr,
                      const I32 flags)
 void  sv_catsv_mg   (SV *dsv, SV *sstr)
 void  sv_catsv_nomg (SV *dsv, SV *sstr)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;sv_chop&quot;</dt>
  <dd>Efficient removal of characters from the beginning of the string buffer.
      <span class="Li">&quot;SvPOK(sv)&quot;</span>, or at least
      <span class="Li">&quot;SvPOKp(sv)&quot;</span>, must be true and
      <span class="Li">&quot;ptr&quot;</span> must be a pointer to somewhere
      inside the string buffer. <span class="Li">&quot;ptr&quot;</span> becomes
      the first character of the adjusted string. Uses the
      <span class="Li">&quot;OOK&quot;</span> hack. On return, only
      <span class="Li">&quot;SvPOK(sv)&quot;</span> and
      <span class="Li">&quot;SvPOKp(sv)&quot;</span> among the
      <span class="Li">&quot;OK&quot;</span> flags will be true.
    <p class="Pp">Beware: after this function returns,
        <span class="Li">&quot;ptr&quot;</span> and SvPVX_const(sv) may no
        longer refer to the same chunk of data.</p>
    <p class="Pp">The unfortunate similarity of this function's name to that of
        Perl's <span class="Li">&quot;chop&quot;</span> operator is strictly
        coincidental. This function works from the left;
        <span class="Li">&quot;chop&quot;</span> works from the right.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  sv_chop(SV *const sv, const char *const ptr)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;sv_clear&quot;</dt>
  <dd>Clear an SV: call any destructors, free up any memory used by the body,
      and free the body itself. The SV's head is <i>not</i> freed, although its
      type is set to all 1's so that it won't inadvertently be assumed to be
      live during global destruction etc. This function should only be called
      when <span class="Li">&quot;REFCNT&quot;</span> is zero. Most of the time
      you'll want to call <span class="Li">&quot;sv_free()&quot;</span> (or its
      macro wrapper <span class="Li">&quot;SvREFCNT_dec&quot;</span>)
    instead.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  sv_clear(SV *const orig_sv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;sv_cmp&quot;</dt>
  <dd>Compares the strings in two SVs. Returns -1, 0, or 1 indicating whether
      the string in <span class="Li">&quot;sv1&quot;</span> is less than, equal
      to, or greater than the string in <span class="Li">&quot;sv2&quot;</span>.
      Is UTF-8 and <span class="Li">'use&#x00A0;bytes'</span> aware, handles get
      magic, and will coerce its args to strings if necessary. See also
      <span class="Li">&quot;sv_cmp_locale&quot;</span>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> I32  sv_cmp(SV *const sv1, SV *const sv2)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;sv_cmp_flags&quot;</dt>
  <dd>Compares the strings in two SVs. Returns -1, 0, or 1 indicating whether
      the string in <span class="Li">&quot;sv1&quot;</span> is less than, equal
      to, or greater than the string in <span class="Li">&quot;sv2&quot;</span>.
      Is UTF-8 and <span class="Li">'use&#x00A0;bytes'</span> aware and will
      coerce its args to strings if necessary. If the flags has the
      <span class="Li">&quot;SV_GMAGIC&quot;</span> bit set, it handles get
      magic. See also
    <span class="Li">&quot;sv_cmp_locale_flags&quot;</span>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> I32  sv_cmp_flags(SV *const sv1, SV *const sv2, const U32 flags)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;sv_cmp_locale&quot;</dt>
  <dd>Compares the strings in two SVs in a locale-aware manner. Is UTF-8 and
      <span class="Li">'use&#x00A0;bytes'</span> aware, handles get magic, and
      will coerce its args to strings if necessary. See also
      <span class="Li">&quot;sv_cmp&quot;</span>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> I32  sv_cmp_locale(SV *const sv1, SV *const sv2)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;sv_cmp_locale_flags&quot;</dt>
  <dd>Compares the strings in two SVs in a locale-aware manner. Is UTF-8 and
      <span class="Li">'use&#x00A0;bytes'</span> aware and will coerce its args
      to strings if necessary. If the flags contain
      <span class="Li">&quot;SV_GMAGIC&quot;</span>, it handles get magic. See
      also <span class="Li">&quot;sv_cmp_flags&quot;</span>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> I32  sv_cmp_locale_flags(SV *const sv1, SV *const sv2,
                          const U32 flags)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;sv_collxfrm&quot;</dt>
  <dd>This calls <span class="Li">&quot;sv_collxfrm_flags&quot;</span> with the
      SV_GMAGIC flag. See
    <span class="Li">&quot;sv_collxfrm_flags&quot;</span>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> char*  sv_collxfrm(SV *const sv, STRLEN *const nxp)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;sv_collxfrm_flags&quot;</dt>
  <dd>Add Collate Transform magic to an SV if it doesn't already have it. If the
      flags contain <span class="Li">&quot;SV_GMAGIC&quot;</span>, it handles
      get-magic.
    <p class="Pp">Any scalar variable may carry
        <span class="Li">&quot;PERL_MAGIC_collxfrm&quot;</span> magic that
        contains the scalar data of the variable, but transformed to such a
        format that a normal memory comparison can be used to compare the data
        according to the locale settings.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> char*  sv_collxfrm_flags(SV *const sv, STRLEN *const nxp,
                          I32 const flags)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;sv_copypv&quot;</dt>
  <dd></dd>
  <dt>&quot;sv_copypv_nomg&quot;</dt>
  <dd></dd>
  <dt>&quot;sv_copypv_flags&quot;</dt>
  <dd>These copy a stringified representation of the source SV into the
      destination SV. They automatically perform coercion of numeric values into
      strings. Guaranteed to preserve the
      <span class="Li">&quot;UTF8&quot;</span> flag even from overloaded
      objects. Similar in nature to
      <span class="Li">&quot;sv_2pv[_flags]&quot;</span> but they operate
      directly on an SV instead of just the string. Mostly they use
      &quot;<span class="Li">&quot;sv_2pv_flags&quot;</span>&quot; in perlintern
      to do the work, except when that would lose the UTF-8'ness of the PV.
    <p class="Pp">The three forms differ only in whether or not they perform
        'get magic' on <span class="Li">&quot;sv&quot;</span>.
        <span class="Li">&quot;sv_copypv_nomg&quot;</span> skips 'get magic';
        <span class="Li">&quot;sv_copypv&quot;</span> performs it; and
        <span class="Li">&quot;sv_copypv_flags&quot;</span> either performs it
        (if the <span class="Li">&quot;SV_GMAGIC&quot;</span> bit is set in
        <span class="Li">&quot;flags&quot;</span>) or doesn't (if that bit is
        cleared).</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  sv_copypv      (SV *const dsv, SV *const ssv)
 void  sv_copypv_nomg (SV *const dsv, SV *const ssv)
 void  sv_copypv_flags(SV *const dsv, SV *const ssv,
                       const I32 flags)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;SvCUR&quot;</dt>
  <dd>Returns the length, in bytes, of the PV inside the SV. Note that this may
      not match Perl's <span class="Li">&quot;length&quot;</span>; for that, use
      <span class="Li">&quot;sv_len_utf8(sv)&quot;</span>. See
      <span class="Li">&quot;SvLEN&quot;</span> also.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> STRLEN  SvCUR(SV* sv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;SvCUR_set&quot;</dt>
  <dd>Sets the current length, in bytes, of the C string which is in the SV. See
      <span class="Li">&quot;SvCUR&quot;</span> and
      <span class="Li">&quot;SvIV_set&quot;</span>&gt;.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  SvCUR_set(SV* sv, STRLEN len)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;sv_dec&quot;</dt>
  <dd></dd>
  <dt>&quot;sv_dec_nomg&quot;</dt>
  <dd>These auto-decrement the value in the SV, doing string to numeric
      conversion if necessary. They both handle operator overloading.
    <p class="Pp">They differ only in that:</p>
    <p class="Pp"><span class="Li">&quot;sv_dec&quot;</span> handles 'get'
        magic; <span class="Li">&quot;sv_dec_nomg&quot;</span> skips 'get'
        magic.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  sv_dec(SV *const sv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;sv_derived_from&quot;</dt>
  <dd>Exactly like &quot;sv_derived_from_pv&quot;, but doesn't take a
      <span class="Li">&quot;flags&quot;</span> parameter.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> bool  sv_derived_from(SV* sv, const char *const name)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;sv_derived_from_pv&quot;</dt>
  <dd>Exactly like &quot;sv_derived_from_pvn&quot;, but takes a nul-terminated
      string instead of a string/length pair.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> bool  sv_derived_from_pv(SV* sv, const char *const name,
                          U32 flags)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;sv_derived_from_pvn&quot;</dt>
  <dd>Returns a boolean indicating whether the SV is derived from the specified
      class <i>at the C level</i>. To check derivation at the Perl level, call
      <span class="Li">&quot;isa()&quot;</span> as a normal Perl method.
    <p class="Pp">Currently, the only significant value for
        <span class="Li">&quot;flags&quot;</span> is SVf_UTF8.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> bool  sv_derived_from_pvn(SV* sv, const char *const name,
                           const STRLEN len, U32 flags)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;sv_derived_from_sv&quot;</dt>
  <dd>Exactly like &quot;sv_derived_from_pvn&quot;, but takes the name string in
      the form of an SV instead of a string/length pair. This is the advised
      form.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> bool  sv_derived_from_sv(SV* sv, SV *namesv, U32 flags)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;sv_does&quot;</dt>
  <dd>Like &quot;sv_does_pv&quot;, but doesn't take a
      <span class="Li">&quot;flags&quot;</span> parameter.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> bool  sv_does(SV* sv, const char *const name)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;sv_does_pv&quot;</dt>
  <dd>Like &quot;sv_does_sv&quot;, but takes a nul-terminated string instead of
      an SV.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> bool  sv_does_pv(SV* sv, const char *const name, U32 flags)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;sv_does_pvn&quot;</dt>
  <dd>Like &quot;sv_does_sv&quot;, but takes a string/length pair instead of an
      SV.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> bool  sv_does_pvn(SV* sv, const char *const name,
                   const STRLEN len, U32 flags)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;sv_does_sv&quot;</dt>
  <dd>Returns a boolean indicating whether the SV performs a specific, named
      role. The SV can be a Perl object or the name of a Perl class.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> bool  sv_does_sv(SV* sv, SV* namesv, U32 flags)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;SvEND&quot;</dt>
  <dd>Returns a pointer to the spot just after the last character in the string
      which is in the SV, where there is usually a trailing
      <span class="Li">&quot;NUL&quot;</span> character (even though Perl
      scalars do not strictly require it). See
      <span class="Li">&quot;SvCUR&quot;</span>. Access the character as
      <span class="Li">&quot;*(SvEND(sv))&quot;</span>.
    <p class="Pp">Warning: If <span class="Li">&quot;SvCUR&quot;</span> is equal
        to <span class="Li">&quot;SvLEN&quot;</span>, then
        <span class="Li">&quot;SvEND&quot;</span> points to unallocated
      memory.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> char*  SvEND(SV* sv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;sv_eq&quot;</dt>
  <dd>Returns a boolean indicating whether the strings in the two SVs are
      identical. Is UTF-8 and <span class="Li">'use&#x00A0;bytes'</span> aware,
      handles get magic, and will coerce its args to strings if necessary.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> I32  sv_eq(SV* sv1, SV* sv2)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;sv_eq_flags&quot;</dt>
  <dd>Returns a boolean indicating whether the strings in the two SVs are
      identical. Is UTF-8 and <span class="Li">'use&#x00A0;bytes'</span> aware
      and coerces its args to strings if necessary. If the flags has the
      <span class="Li">&quot;SV_GMAGIC&quot;</span> bit set, it handles
      get-magic, too.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> I32  sv_eq_flags(SV* sv1, SV* sv2, const U32 flags)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;sv_force_normal&quot;</dt>
  <dd>Undo various types of fakery on an SV: if the PV is a shared string, make
      a private copy; if we're a ref, stop refing; if we're a glob, downgrade to
      an <span class="Li">&quot;xpvmg&quot;</span>. See also
      <span class="Li">&quot;sv_force_normal_flags&quot;</span>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  sv_force_normal(SV *sv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;sv_force_normal_flags&quot;</dt>
  <dd>Undo various types of fakery on an SV, where fakery means &quot;more
      than&quot; a string: if the PV is a shared string, make a private copy; if
      we're a ref, stop refing; if we're a glob, downgrade to an
      <span class="Li">&quot;xpvmg&quot;</span>; if we're a copy-on-write
      scalar, this is the on-write time when we do the copy, and is also used
      locally; if this is a vstring, drop the vstring magic. If
      <span class="Li">&quot;SV_COW_DROP_PV&quot;</span> is set then a
      copy-on-write scalar drops its PV buffer (if any) and becomes
      <span class="Li">&quot;SvPOK_off&quot;</span> rather than making a copy.
      (Used where this scalar is about to be set to some other value.) In
      addition, the <span class="Li">&quot;flags&quot;</span> parameter gets
      passed to <span class="Li">&quot;sv_unref_flags()&quot;</span> when
      unreffing. <span class="Li">&quot;sv_force_normal&quot;</span> calls this
      function with flags set to 0.
    <p class="Pp">This function is expected to be used to signal to perl that
        this SV is about to be written to, and any extra book-keeping needs to
        be taken care of. Hence, it croaks on read-only values.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  sv_force_normal_flags(SV *const sv, const U32 flags)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;sv_free&quot;</dt>
  <dd>Decrement an SV's reference count, and if it drops to zero, call
      <span class="Li">&quot;sv_clear&quot;</span> to invoke destructors and
      free up any memory used by the body; finally, deallocating the SV's head
      itself. Normally called via a wrapper macro
      <span class="Li">&quot;SvREFCNT_dec&quot;</span>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  sv_free(SV *const sv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;SvGAMAGIC&quot;</dt>
  <dd>Returns true if the SV has get magic or overloading. If either is true
      then the scalar is active data, and has the potential to return a new
      value every time it is accessed. Hence you must be careful to only read it
      once per user logical operation and work with that returned value. If
      neither is true then the scalar's value cannot change unless written
    to.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> U32  SvGAMAGIC(SV* sv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;SvGETMAGIC&quot;</dt>
  <dd>Invokes <span class="Li">&quot;mg_get&quot;</span> on an SV if it has
      'get' magic. For example, this will call
      <span class="Li">&quot;FETCH&quot;</span> on a tied variable. This macro
      evaluates its argument more than once.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  SvGETMAGIC(SV* sv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;sv_gets&quot;</dt>
  <dd>Get a line from the filehandle and store it into the SV, optionally
      appending to the currently-stored string. If
      <span class="Li">&quot;append&quot;</span> is not 0, the line is appended
      to the SV instead of overwriting it.
      <span class="Li">&quot;append&quot;</span> should be set to the byte
      offset that the appended string should start at in the SV (typically,
      <span class="Li">&quot;SvCUR(sv)&quot;</span> is a suitable choice).</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> char*  sv_gets(SV *const sv, PerlIO *const fp, I32 append)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;sv_get_backrefs&quot;</dt>
  <dd>NOTE: <span class="Li">&quot;sv_get_backrefs&quot;</span> is
      <b>experimental</b> and may change or be removed without notice.
    <p class="Pp">If <span class="Li">&quot;sv&quot;</span> is the target of a
        weak reference then it returns the back references structure associated
        with the sv; otherwise return
      <span class="Li">&quot;NULL&quot;</span>.</p>
    <p class="Pp">When returning a non-null result the type of the return is
        relevant. If it is an AV then the elements of the AV are the weak
        reference RVs which point at this item. If it is any other type then the
        item itself is the weak reference.</p>
    <p class="Pp">See also
        <span class="Li">&quot;Perl_sv_add_backref()&quot;</span>,
        <span class="Li">&quot;Perl_sv_del_backref()&quot;</span>,
        <span class="Li">&quot;Perl_sv_kill_backrefs()&quot;</span></p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> SV*  sv_get_backrefs(SV *const sv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;SvGROW&quot;</dt>
  <dd>Expands the character buffer in the SV so that it has room for the
      indicated number of bytes (remember to reserve space for an extra trailing
      <span class="Li">&quot;NUL&quot;</span> character). Calls
      <span class="Li">&quot;sv_grow&quot;</span> to perform the expansion if
      necessary. Returns a pointer to the character buffer. SV must be of type
      &gt;= <span class="Li">&quot;SVt_PV&quot;</span>. One alternative is to
      call <span class="Li">&quot;sv_grow&quot;</span> if you are not sure of
      the type of SV.
    <p class="Pp">You might mistakenly think that
        <span class="Li">&quot;len&quot;</span> is the number of bytes to add to
        the existing size, but instead it is the total size
        <span class="Li">&quot;sv&quot;</span> should be.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> char *  SvGROW(SV* sv, STRLEN len)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;sv_inc&quot;</dt>
  <dd></dd>
  <dt>&quot;sv_inc_nomg&quot;</dt>
  <dd>These auto-increment the value in the SV, doing string to numeric
      conversion if necessary. They both handle operator overloading.
    <p class="Pp">They differ only in that
        <span class="Li">&quot;sv_inc&quot;</span> performs 'get' magic;
        <span class="Li">&quot;sv_inc_nomg&quot;</span> skips any magic.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  sv_inc(SV *const sv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;sv_insert&quot;</dt>
  <dd>Inserts and/or replaces a string at the specified offset/length within the
      SV. Similar to the Perl <span class="Li">&quot;substr()&quot;</span>
      function, with <span class="Li">&quot;littlelen&quot;</span> bytes
      starting at <span class="Li">&quot;little&quot;</span> replacing
      <span class="Li">&quot;len&quot;</span> bytes of the string in
      <span class="Li">&quot;bigstr&quot;</span> starting at
      <span class="Li">&quot;offset&quot;</span>. Handles get magic.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  sv_insert(SV *const bigstr, const STRLEN offset,
                 const STRLEN len, const char *const little,
                 const STRLEN littlelen)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;sv_insert_flags&quot;</dt>
  <dd>Same as <span class="Li">&quot;sv_insert&quot;</span>, but the extra
      <span class="Li">&quot;flags&quot;</span> are passed to the
      <span class="Li">&quot;SvPV_force_flags&quot;</span> that applies to
      <span class="Li">&quot;bigstr&quot;</span>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  sv_insert_flags(SV *const bigstr, const STRLEN offset,
                       const STRLEN len, const char *little,
                       const STRLEN littlelen, const U32 flags)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;SvIOK&quot;</dt>
  <dd>Returns a U32 value indicating whether the SV contains an integer.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> U32  SvIOK(SV* sv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;SvIOK_notUV&quot;</dt>
  <dd>Returns a boolean indicating whether the SV contains a signed
    integer.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> bool  SvIOK_notUV(SV* sv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;SvIOK_off&quot;</dt>
  <dd>Unsets the IV status of an SV.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  SvIOK_off(SV* sv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;SvIOK_on&quot;</dt>
  <dd>Tells an SV that it is an integer.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  SvIOK_on(SV* sv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;SvIOK_only&quot;</dt>
  <dd>Tells an SV that it is an integer and disables all other
      <span class="Li">&quot;OK&quot;</span> bits.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  SvIOK_only(SV* sv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;SvIOK_only_UV&quot;</dt>
  <dd>Tells an SV that it is an unsigned integer and disables all other
      <span class="Li">&quot;OK&quot;</span> bits.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  SvIOK_only_UV(SV* sv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;SvIOKp&quot;</dt>
  <dd>Returns a U32 value indicating whether the SV contains an integer. Checks
      the <b>private</b> setting. Use <span class="Li">&quot;SvIOK&quot;</span>
      instead.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> U32  SvIOKp(SV* sv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;SvIOK_UV&quot;</dt>
  <dd>Returns a boolean indicating whether the SV contains an integer that must
      be interpreted as unsigned. A non-negative integer whose value is within
      the range of both an IV and a UV may be flagged as either
      <span class="Li">&quot;SvUOK&quot;</span> or
      <span class="Li">&quot;SvIOK&quot;</span>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> bool  SvIOK_UV(SV* sv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;sv_isa&quot;</dt>
  <dd>Returns a boolean indicating whether the SV is blessed into the specified
      class.
    <p class="Pp">This does not check for subtypes or method overloading. Use
        <span class="Li">&quot;sv_isa_sv&quot;</span> to verify an inheritance
        relationship in the same way as the
        <span class="Li">&quot;isa&quot;</span> operator by respecting any
        <span class="Li">&quot;isa()&quot;</span> method overloading; or
        <span class="Li">&quot;sv_derived_from_sv&quot;</span> to test directly
        on the actual object type.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> int  sv_isa(SV* sv, const char *const name)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;sv_isa_sv&quot;</dt>
  <dd>NOTE: <span class="Li">&quot;sv_isa_sv&quot;</span> is <b>experimental</b>
      and may change or be removed without notice.
    <p class="Pp">Returns a boolean indicating whether the SV is an object
        reference and is derived from the specified class, respecting any
        <span class="Li">&quot;isa()&quot;</span> method overloading it may
        have. Returns false if <span class="Li">&quot;sv&quot;</span> is not a
        reference to an object, or is not derived from the specified class.</p>
    <p class="Pp">This is the function used to implement the behaviour of the
        <span class="Li">&quot;isa&quot;</span> operator.</p>
    <p class="Pp">Does not invoke magic on
        <span class="Li">&quot;sv&quot;</span>.</p>
    <p class="Pp">Not to be confused with the older
        <span class="Li">&quot;sv_isa&quot;</span> function, which does not use
        an overloaded <span class="Li">&quot;isa()&quot;</span> method, nor will
        check subclassing.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> bool  sv_isa_sv(SV* sv, SV* namesv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;SvIsCOW&quot;</dt>
  <dd>Returns a U32 value indicating whether the SV is Copy-On-Write (either
      shared hash key scalars, or full Copy On Write scalars if 5.9.0 is
      configured for COW).</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> U32  SvIsCOW(SV* sv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;SvIsCOW_shared_hash&quot;</dt>
  <dd>Returns a boolean indicating whether the SV is Copy-On-Write shared hash
      key scalar.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> bool  SvIsCOW_shared_hash(SV* sv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;sv_isobject&quot;</dt>
  <dd>Returns a boolean indicating whether the SV is an RV pointing to a blessed
      object. If the SV is not an RV, or if the object is not blessed, then this
      will return false.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> int  sv_isobject(SV* sv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;SvIV&quot;</dt>
  <dd></dd>
  <dt>&quot;SvIVx&quot;</dt>
  <dd></dd>
  <dt>&quot;SvIV_nomg&quot;</dt>
  <dd>These coerce the given SV to IV and return it. The returned value in many
      circumstances will get stored in <span class="Li">&quot;sv&quot;</span>'s
      IV slot, but not in all cases. (Use
      <span class="Li">&quot;sv_setiv&quot;</span> to make sure it does).
    <p class="Pp"><span class="Li">&quot;SvIVx&quot;</span> is different from
        the others in that it is guaranteed to evaluate
        <span class="Li">&quot;sv&quot;</span> exactly once; the others may
        evaluate it multiple times. Only use this form if
        <span class="Li">&quot;sv&quot;</span> is an expression with side
        effects, otherwise use the more efficient
        <span class="Li">&quot;SvIV&quot;</span>.</p>
    <p class="Pp"><span class="Li">&quot;SvIV_nomg&quot;</span> is the same as
        <span class="Li">&quot;SvIV&quot;</span>, but does not perform 'get'
        magic.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> IV  SvIV(SV* sv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;SvIV_set&quot;</dt>
  <dd>Set the value of the IV pointer in sv to val. It is possible to perform
      the same function of this macro with an lvalue assignment to
      <span class="Li">&quot;SvIVX&quot;</span>. With future Perls, however, it
      will be more efficient to use <span class="Li">&quot;SvIV_set&quot;</span>
      instead of the lvalue assignment to
      <span class="Li">&quot;SvIVX&quot;</span>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  SvIV_set(SV* sv, IV val)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;SvIVX&quot;</dt>
  <dd>Returns the raw value in the SV's IV slot, without checks or conversions.
      Only use when you are sure <span class="Li">&quot;SvIOK&quot;</span> is
      true. See also <span class="Li">&quot;SvIV&quot;</span>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> IV  SvIVX(SV* sv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;SvLEN&quot;</dt>
  <dd>Returns the size of the string buffer in the SV, not including any part
      attributable to <span class="Li">&quot;SvOOK&quot;</span>. See
      <span class="Li">&quot;SvCUR&quot;</span>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> STRLEN  SvLEN(SV* sv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;sv_len&quot;</dt>
  <dd>Returns the length of the string in the SV. Handles magic and type
      coercion and sets the UTF8 flag appropriately. See also
      <span class="Li">&quot;SvCUR&quot;</span>, which gives raw access to the
      <span class="Li">&quot;xpv_cur&quot;</span> slot.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> STRLEN  sv_len(SV *const sv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;SvLEN_set&quot;</dt>
  <dd>Set the size of the string buffer for the SV. See
      <span class="Li">&quot;SvLEN&quot;</span>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  SvLEN_set(SV* sv, STRLEN len)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;sv_len_utf8&quot;</dt>
  <dd>Returns the number of characters in the string in an SV, counting wide
      UTF-8 bytes as a single character. Handles magic and type coercion.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> STRLEN  sv_len_utf8(SV *const sv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;SvLOCK&quot;</dt>
  <dd>Arranges for a mutual exclusion lock to be obtained on
      <span class="Li">&quot;sv&quot;</span> if a suitable module has been
      loaded.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  SvLOCK(SV* sv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;sv_magic&quot;</dt>
  <dd>Adds magic to an SV. First upgrades <span class="Li">&quot;sv&quot;</span>
      to type <span class="Li">&quot;SVt_PVMG&quot;</span> if necessary, then
      adds a new magic item of type <span class="Li">&quot;how&quot;</span> to
      the head of the magic list.
    <p class="Pp">See <span class="Li">&quot;sv_magicext&quot;</span> (which
        <span class="Li">&quot;sv_magic&quot;</span> now calls) for a
        description of the handling of the
        <span class="Li">&quot;name&quot;</span> and
        <span class="Li">&quot;namlen&quot;</span> arguments.</p>
    <p class="Pp">You need to use
        <span class="Li">&quot;sv_magicext&quot;</span> to add magic to
        <span class="Li">&quot;SvREADONLY&quot;</span> SVs and also to add more
        than one instance of the same
      <span class="Li">&quot;how&quot;</span>.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  sv_magic(SV *const sv, SV *const obj, const int how,
                const char *const name, const I32 namlen)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;sv_magicext&quot;</dt>
  <dd>Adds magic to an SV, upgrading it if necessary. Applies the supplied
      <span class="Li">&quot;vtable&quot;</span> and returns a pointer to the
      magic added.
    <p class="Pp">Note that <span class="Li">&quot;sv_magicext&quot;</span> will
        allow things that <span class="Li">&quot;sv_magic&quot;</span> will not.
        In particular, you can add magic to
        <span class="Li">&quot;SvREADONLY&quot;</span> SVs, and add more than
        one instance of the same <span class="Li">&quot;how&quot;</span>.</p>
    <p class="Pp">If <span class="Li">&quot;namlen&quot;</span> is greater than
        zero then a <span class="Li">&quot;savepvn&quot;</span> <i>copy</i> of
        <span class="Li">&quot;name&quot;</span> is stored, if
        <span class="Li">&quot;namlen&quot;</span> is zero then
        <span class="Li">&quot;name&quot;</span> is stored as-is and - as
        another special case - if <span class="Li">&quot;(name &amp;&amp; namlen
        == HEf_SVKEY)&quot;</span> then <span class="Li">&quot;name&quot;</span>
        is assumed to contain an SV* and is stored as-is with its
        <span class="Li">&quot;REFCNT&quot;</span> incremented.</p>
    <p class="Pp">(This is now used as a subroutine by
        <span class="Li">&quot;sv_magic&quot;</span>.)</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> MAGIC *  sv_magicext(SV *const sv, SV *const obj, const int how,
                      const MGVTBL *const vtbl,
                      const char *const name, const I32 namlen)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;SvMAGIC_set&quot;</dt>
  <dd>Set the value of the MAGIC pointer in
      <span class="Li">&quot;sv&quot;</span> to val. See
      <span class="Li">&quot;SvIV_set&quot;</span>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  SvMAGIC_set(SV* sv, MAGIC* val)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;sv_mortalcopy&quot;</dt>
  <dd>Creates a new SV which is a copy of the original SV (using
      <span class="Li">&quot;sv_setsv&quot;</span>). The new SV is marked as
      mortal. It will be destroyed &quot;soon&quot;, either by an explicit call
      to <span class="Li">&quot;FREETMPS&quot;</span>, or by an implicit call at
      places such as statement boundaries. See also
      <span class="Li">&quot;sv_newmortal&quot;</span> and
      <span class="Li">&quot;sv_2mortal&quot;</span>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> SV*  sv_mortalcopy(SV *const oldsv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;sv_mortalcopy_flags&quot;</dt>
  <dd>Like <span class="Li">&quot;sv_mortalcopy&quot;</span>, but the extra
      <span class="Li">&quot;flags&quot;</span> are passed to the
      <span class="Li">&quot;sv_setsv_flags&quot;</span>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> SV*  sv_mortalcopy_flags(SV *const oldsv, U32 flags)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;sv_newmortal&quot;</dt>
  <dd>Creates a new null SV which is mortal. The reference count of the SV is
      set to 1. It will be destroyed &quot;soon&quot;, either by an explicit
      call to <span class="Li">&quot;FREETMPS&quot;</span>, or by an implicit
      call at places such as statement boundaries. See also
      <span class="Li">&quot;sv_mortalcopy&quot;</span> and
      <span class="Li">&quot;sv_2mortal&quot;</span>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> SV*  sv_newmortal()
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;SvNIOK&quot;</dt>
  <dd>Returns a U32 value indicating whether the SV contains a number, integer
      or double.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> U32  SvNIOK(SV* sv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;SvNIOK_off&quot;</dt>
  <dd>Unsets the NV/IV status of an SV.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  SvNIOK_off(SV* sv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;SvNIOKp&quot;</dt>
  <dd>Returns a U32 value indicating whether the SV contains a number, integer
      or double. Checks the <b>private</b> setting. Use
      <span class="Li">&quot;SvNIOK&quot;</span> instead.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> U32  SvNIOKp(SV* sv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;SvNOK&quot;</dt>
  <dd>Returns a U32 value indicating whether the SV contains a double.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> U32  SvNOK(SV* sv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;SvNOK_off&quot;</dt>
  <dd>Unsets the NV status of an SV.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  SvNOK_off(SV* sv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;SvNOK_on&quot;</dt>
  <dd>Tells an SV that it is a double.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  SvNOK_on(SV* sv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;SvNOK_only&quot;</dt>
  <dd>Tells an SV that it is a double and disables all other OK bits.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  SvNOK_only(SV* sv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;SvNOKp&quot;</dt>
  <dd>Returns a U32 value indicating whether the SV contains a double. Checks
      the <b>private</b> setting. Use <span class="Li">&quot;SvNOK&quot;</span>
      instead.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> U32  SvNOKp(SV* sv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;sv_nolocking&quot;</dt>
  <dd><span class="Li">&quot;</span><span class="Li"><b>DEPRECATED!</b></span><span class="Li">&quot;</span>
      It is planned to remove <span class="Li">&quot;sv_nolocking&quot;</span>
      from a future release of Perl. Do not use it for new code; remove it from
      existing code.
    <p class="Pp">Dummy routine which &quot;locks&quot; an SV when there is no
        locking module present. Exists to avoid test for a
        <span class="Li">&quot;NULL&quot;</span> function pointer and because it
        could potentially warn under some level of strict-ness.</p>
    <p class="Pp">&quot;Superseded&quot; by
        <span class="Li">&quot;sv_nosharing()&quot;</span>.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  sv_nolocking(SV *sv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;sv_nounlocking&quot;</dt>
  <dd><span class="Li">&quot;</span><span class="Li"><b>DEPRECATED!</b></span><span class="Li">&quot;</span>
      It is planned to remove <span class="Li">&quot;sv_nounlocking&quot;</span>
      from a future release of Perl. Do not use it for new code; remove it from
      existing code.
    <p class="Pp">Dummy routine which &quot;unlocks&quot; an SV when there is no
        locking module present. Exists to avoid test for a
        <span class="Li">&quot;NULL&quot;</span> function pointer and because it
        could potentially warn under some level of strict-ness.</p>
    <p class="Pp">&quot;Superseded&quot; by
        <span class="Li">&quot;sv_nosharing()&quot;</span>.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  sv_nounlocking(SV *sv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;SvNV&quot;</dt>
  <dd></dd>
  <dt>&quot;SvNVx&quot;</dt>
  <dd></dd>
  <dt>&quot;SvNV_nomg&quot;</dt>
  <dd>These coerce the given SV to NV and return it. The returned value in many
      circumstances will get stored in <span class="Li">&quot;sv&quot;</span>'s
      NV slot, but not in all cases. (Use
      <span class="Li">&quot;sv_setnv&quot;</span> to make sure it does).
    <p class="Pp"><span class="Li">&quot;SvNVx&quot;</span> is different from
        the others in that it is guaranteed to evaluate
        <span class="Li">&quot;sv&quot;</span> exactly once; the others may
        evaluate it multiple times. Only use this form if
        <span class="Li">&quot;sv&quot;</span> is an expression with side
        effects, otherwise use the more efficient
        <span class="Li">&quot;SvNV&quot;</span>.</p>
    <p class="Pp"><span class="Li">&quot;SvNV_nomg&quot;</span> is the same as
        <span class="Li">&quot;SvNV&quot;</span>, but does not perform 'get'
        magic.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> NV  SvNV(SV* sv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;SvNV_set&quot;</dt>
  <dd>Set the value of the NV pointer in <span class="Li">&quot;sv&quot;</span>
      to val. See <span class="Li">&quot;SvIV_set&quot;</span>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  SvNV_set(SV* sv, NV val)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;SvNVX&quot;</dt>
  <dd>Returns the raw value in the SV's NV slot, without checks or conversions.
      Only use when you are sure <span class="Li">&quot;SvNOK&quot;</span> is
      true. See also <span class="Li">&quot;SvNV&quot;</span>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> NV  SvNVX(SV* sv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;SvOK&quot;</dt>
  <dd>Returns a U32 value indicating whether the value is defined. This is only
      meaningful for scalars.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> U32  SvOK(SV* sv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;SvOOK&quot;</dt>
  <dd>Returns a U32 indicating whether the pointer to the string buffer is
      offset. This hack is used internally to speed up removal of characters
      from the beginning of a <span class="Li">&quot;SvPV&quot;</span>. When
      <span class="Li">&quot;SvOOK&quot;</span> is true, then the start of the
      allocated string buffer is actually
      <span class="Li">&quot;SvOOK_offset()&quot;</span> bytes before
      <span class="Li">&quot;SvPVX&quot;</span>. This offset used to be stored
      in <span class="Li">&quot;SvIVX&quot;</span>, but is now stored within the
      spare part of the buffer.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> U32  SvOOK(SV* sv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;SvOOK_off&quot;</dt>
  <dd>Remove any string offset.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  SvOOK_off(SV * sv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;SvOOK_offset&quot;</dt>
  <dd>Reads into <span class="Li">&quot;len&quot;</span> the offset from
      <span class="Li">&quot;SvPVX&quot;</span> back to the true start of the
      allocated buffer, which will be non-zero if
      <span class="Li">&quot;sv_chop&quot;</span> has been used to efficiently
      remove characters from start of the buffer. Implemented as a macro, which
      takes the address of <span class="Li">&quot;len&quot;</span>, which must
      be of type <span class="Li">&quot;STRLEN&quot;</span>. Evaluates
      <span class="Li">&quot;sv&quot;</span> more than once. Sets
      <span class="Li">&quot;len&quot;</span> to 0 if
      <span class="Li">&quot;SvOOK(sv)&quot;</span> is false.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  SvOOK_offset(SV*sv, STRLEN len)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;SvPOK&quot;</dt>
  <dd>Returns a U32 value indicating whether the SV contains a character
    string.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> U32  SvPOK(SV* sv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;SvPOK_off&quot;</dt>
  <dd>Unsets the PV status of an SV.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  SvPOK_off(SV* sv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;SvPOK_on&quot;</dt>
  <dd>Tells an SV that it is a string.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  SvPOK_on(SV* sv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;SvPOK_only&quot;</dt>
  <dd>Tells an SV that it is a string and disables all other
      <span class="Li">&quot;OK&quot;</span> bits. Will also turn off the UTF-8
      status.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  SvPOK_only(SV* sv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;SvPOK_only_UTF8&quot;</dt>
  <dd>Tells an SV that it is a string and disables all other
      <span class="Li">&quot;OK&quot;</span> bits, and leaves the UTF-8 status
      as it was.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  SvPOK_only_UTF8(SV* sv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;SvPOKp&quot;</dt>
  <dd>Returns a U32 value indicating whether the SV contains a character string.
      Checks the <b>private</b> setting. Use
      <span class="Li">&quot;SvPOK&quot;</span> instead.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> U32  SvPOKp(SV* sv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;sv_pos_b2u&quot;</dt>
  <dd>Converts the value pointed to by
      <span class="Li">&quot;offsetp&quot;</span> from a count of bytes from the
      start of the string, to a count of the equivalent number of UTF-8 chars.
      Handles magic and type coercion.
    <p class="Pp">Use <span class="Li">&quot;sv_pos_b2u_flags&quot;</span> in
        preference, which correctly handles strings longer than 2Gb.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  sv_pos_b2u(SV *const sv, I32 *const offsetp)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;sv_pos_b2u_flags&quot;</dt>
  <dd>Converts <span class="Li">&quot;offset&quot;</span> from a count of bytes
      from the start of the string, to a count of the equivalent number of UTF-8
      chars. Handles type coercion. <span class="Li">&quot;flags&quot;</span> is
      passed to <span class="Li">&quot;SvPV_flags&quot;</span>, and usually
      should be <span class="Li">&quot;SV_GMAGIC|SV_CONST_RETURN&quot;</span> to
      handle magic.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> STRLEN  sv_pos_b2u_flags(SV *const sv, STRLEN const offset,
                          U32 flags)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;sv_pos_u2b&quot;</dt>
  <dd>Converts the value pointed to by
      <span class="Li">&quot;offsetp&quot;</span> from a count of UTF-8 chars
      from the start of the string, to a count of the equivalent number of
      bytes; if <span class="Li">&quot;lenp&quot;</span> is non-zero, it does
      the same to <span class="Li">&quot;lenp&quot;</span>, but this time
      starting from the offset, rather than from the start of the string.
      Handles magic and type coercion.
    <p class="Pp">Use <span class="Li">&quot;sv_pos_u2b_flags&quot;</span> in
        preference, which correctly handles strings longer than 2Gb.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  sv_pos_u2b(SV *const sv, I32 *const offsetp,
                  I32 *const lenp)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;sv_pos_u2b_flags&quot;</dt>
  <dd>Converts the offset from a count of UTF-8 chars from the start of the
      string, to a count of the equivalent number of bytes; if
      <span class="Li">&quot;lenp&quot;</span> is non-zero, it does the same to
      <span class="Li">&quot;lenp&quot;</span>, but this time starting from
      <span class="Li">&quot;offset&quot;</span>, rather than from the start of
      the string. Handles type coercion.
      <span class="Li">&quot;flags&quot;</span> is passed to
      <span class="Li">&quot;SvPV_flags&quot;</span>, and usually should be
      <span class="Li">&quot;SV_GMAGIC|SV_CONST_RETURN&quot;</span> to handle
      magic.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> STRLEN  sv_pos_u2b_flags(SV *const sv, STRLEN uoffset,
                          STRLEN *const lenp, U32 flags)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;SvPV&quot;</dt>
  <dd></dd>
  <dt>&quot;SvPVx&quot;</dt>
  <dd></dd>
  <dt>&quot;SvPV_nomg&quot;</dt>
  <dd></dd>
  <dt>&quot;SvPV_nolen&quot;</dt>
  <dd></dd>
  <dt>&quot;SvPVx_nolen&quot;</dt>
  <dd></dd>
  <dt>&quot;SvPV_nomg_nolen&quot;</dt>
  <dd></dd>
  <dt>&quot;SvPV_mutable&quot;</dt>
  <dd></dd>
  <dt>&quot;SvPV_const&quot;</dt>
  <dd></dd>
  <dt>&quot;SvPVx_const&quot;</dt>
  <dd></dd>
  <dt>&quot;SvPV_nolen_const&quot;</dt>
  <dd></dd>
  <dt>&quot;SvPVx_nolen_const&quot;</dt>
  <dd></dd>
  <dt>&quot;SvPV_nomg_const&quot;</dt>
  <dd></dd>
  <dt>&quot;SvPV_nomg_const_nolen&quot;</dt>
  <dd></dd>
  <dt>&quot;SvPV_flags&quot;</dt>
  <dd></dd>
  <dt>&quot;SvPV_flags_const&quot;</dt>
  <dd></dd>
  <dt>&quot;SvPV_flags_mutable&quot;</dt>
  <dd></dd>
  <dt>&quot;SvPVbyte&quot;</dt>
  <dd></dd>
  <dt>&quot;SvPVbyte_nomg&quot;</dt>
  <dd></dd>
  <dt>&quot;SvPVbyte_nolen&quot;</dt>
  <dd></dd>
  <dt>&quot;SvPVbytex_nolen&quot;</dt>
  <dd></dd>
  <dt>&quot;SvPVbytex&quot;</dt>
  <dd></dd>
  <dt>&quot;SvPVbyte_or_null&quot;</dt>
  <dd></dd>
  <dt>&quot;SvPVbyte_or_null_nomg&quot;</dt>
  <dd></dd>
  <dt>&quot;SvPVutf8&quot;</dt>
  <dd></dd>
  <dt>&quot;SvPVutf8x&quot;</dt>
  <dd></dd>
  <dt>&quot;SvPVutf8_nomg&quot;</dt>
  <dd></dd>
  <dt>&quot;SvPVutf8_nolen&quot;</dt>
  <dd></dd>
  <dt>&quot;SvPVutf8_or_null&quot;</dt>
  <dd></dd>
  <dt>&quot;SvPVutf8_or_null_nomg&quot;</dt>
  <dd>All these return a pointer to the string in
      <span class="Li">&quot;sv&quot;</span>, or a stringified form of
      <span class="Li">&quot;sv&quot;</span> if it does not contain a string.
      The SV may cache the stringified version becoming
      <span class="Li">&quot;SvPOK&quot;</span>.
    <p class="Pp">This is a very basic and common operation, so there are lots
        of slightly different versions of it.</p>
    <p class="Pp">Note that there is no guarantee that the return value of
        <span class="Li">&quot;SvPV(sv)&quot;</span>, for example, is equal to
        <span class="Li">&quot;SvPVX(sv)&quot;</span>, or that
        <span class="Li">&quot;SvPVX(sv)&quot;</span> contains valid data, or
        that successive calls to <span class="Li">&quot;SvPV(sv)&quot;</span>
        (or another of these forms) will return the same pointer value each
        time. This is due to the way that things like overloading and
        Copy-On-Write are handled. In these cases, the return value may point to
        a temporary buffer or similar. If you absolutely need the
        <span class="Li">&quot;SvPVX&quot;</span> field to be valid (for
        example, if you intend to write to it), then see
        <span class="Li">&quot;SvPV_force&quot;</span>.</p>
    <p class="Pp">The differences between the forms are:</p>
    <p class="Pp">The forms with neither
        <span class="Li">&quot;byte&quot;</span> nor
        <span class="Li">&quot;utf8&quot;</span> in their names (e.g.,
        <span class="Li">&quot;SvPV&quot;</span> or
        <span class="Li">&quot;SvPV_nolen&quot;</span>) can expose the SV's
        internal string buffer. If that buffer consists entirely of bytes 0-255
        and includes any bytes above 127, then you <b>MUST</b> consult
        <span class="Li">&quot;SvUTF8&quot;</span> to determine the actual code
        points the string is meant to contain. Generally speaking, it is
        probably safer to prefer <span class="Li">&quot;SvPVbyte&quot;</span>,
        <span class="Li">&quot;SvPVutf8&quot;</span>, and the like. See
        &quot;How do I pass a Perl string to a C library?&quot; in perlguts for
        more details.</p>
    <p class="Pp">The forms with <span class="Li">&quot;flags&quot;</span> in
        their names allow you to use the
        <span class="Li">&quot;flags&quot;</span> parameter to specify to
        process 'get' magic (by setting the
        <span class="Li">&quot;SV_GMAGIC&quot;</span> flag) or to skip 'get'
        magic (by clearing it). The other forms process 'get' magic, except for
        the ones with <span class="Li">&quot;nomg&quot;</span> in their names,
        which skip 'get' magic.</p>
    <p class="Pp">The forms that take a <span class="Li">&quot;len&quot;</span>
        parameter will set that variable to the byte length of the resultant
        string (these are macros, so don't use
        <span class="Li">&amp;len</span>).</p>
    <p class="Pp">The forms with <span class="Li">&quot;nolen&quot;</span> in
        their names indicate they don't have a
        <span class="Li">&quot;len&quot;</span> parameter. They should be used
        only when it is known that the PV is a C string, terminated by a NUL
        byte, and without intermediate NUL characters; or when you don't care
        about its length.</p>
    <p class="Pp">The forms with <span class="Li">&quot;const&quot;</span> in
        their names return
        <span class="Li">&quot;const&#x00A0;char&#x00A0;*&quot;</span> so that
        the compiler will hopefully complain if you were to try to modify the
        contents of the string (unless you cast away const yourself).</p>
    <p class="Pp">The other forms return a mutable pointer so that the string is
        modifiable by the caller; this is emphasized for the ones with
        <span class="Li">&quot;mutable&quot;</span> in their names.</p>
    <p class="Pp">The forms whose name ends in
        <span class="Li">&quot;x&quot;</span> are the same as the corresponding
        form without the <span class="Li">&quot;x&quot;</span>, but the
        <span class="Li">&quot;x&quot;</span> form is guaranteed to evaluate
        <span class="Li">&quot;sv&quot;</span> exactly once, with a slight loss
        of efficiency. Use this if <span class="Li">&quot;sv&quot;</span> is an
        expression with side effects.</p>
    <p class="Pp"><span class="Li">&quot;SvPVutf8&quot;</span> is like
        <span class="Li">&quot;SvPV&quot;</span>, but converts
        <span class="Li">&quot;sv&quot;</span> to UTF-8 first if not already
        UTF-8. Similiarly, the other forms with
        <span class="Li">&quot;utf8&quot;</span> in their names correspond to
        their respective forms without.</p>
    <p class="Pp"><span class="Li">&quot;SvPVutf8_or_null&quot;</span> and
        <span class="Li">&quot;SvPVutf8_or_null_nomg&quot;</span> don't have
        corresponding non-<span class="Li">&quot;utf8&quot;</span> forms.
        Instead they are like <span class="Li">&quot;SvPVutf8_nomg&quot;</span>,
        but when <span class="Li">&quot;sv&quot;</span> is undef, they return
        <span class="Li">&quot;NULL&quot;</span>.</p>
    <p class="Pp"><span class="Li">&quot;SvPVbyte&quot;</span> is like
        <span class="Li">&quot;SvPV&quot;</span>, but converts
        <span class="Li">&quot;sv&quot;</span> to byte representation first if
        currently encoded as UTF-8. If <span class="Li">&quot;sv&quot;</span>
        cannot be downgraded from UTF-8, it croaks. Similiarly, the other forms
        with <span class="Li">&quot;byte&quot;</span> in their names correspond
        to their respective forms without.</p>
    <p class="Pp"><span class="Li">&quot;SvPVbyte_or_null&quot;</span> doesn't
        have a corresponding non-<span class="Li">&quot;byte&quot;</span> form.
        Instead it is like <span class="Li">&quot;SvPVbyte&quot;</span>, but
        when <span class="Li">&quot;sv&quot;</span> is undef, it returns
        <span class="Li">&quot;NULL&quot;</span>.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> char*         SvPV                 (SV* sv, STRLEN len)
 char*         SvPVx                (SV* sv, STRLEN len)
 char*         SvPV_nomg            (SV* sv, STRLEN len)
 char*         SvPV_nolen           (SV* sv)
 char*         SvPVx_nolen          (SV* sv)
 char*         SvPV_nomg_nolen      (SV* sv)
 char*         SvPV_mutable         (SV* sv, STRLEN len)
 const char*   SvPV_const           (SV* sv, STRLEN len)
 const char*   SvPVx_const          (SV* sv, STRLEN len)
 const char*   SvPV_nolen_const     (SV* sv)
 const char*   SvPVx_nolen_const    (SV* sv)
 const char*   SvPV_nomg_const      (SV* sv, STRLEN len)
 const char*   SvPV_nomg_const_nolen(SV* sv)
 char *        SvPV_flags           (SV * sv, STRLEN len,
                                     U32 flags)
 const char *  SvPV_flags_const     (SV * sv, STRLEN len,
                                     U32 flags)
 char *        SvPV_flags_mutable   (SV * sv, STRLEN len,
                                     U32 flags)
 char*         SvPVbyte             (SV* sv, STRLEN len)
 char*         SvPVbyte_nomg        (SV* sv, STRLEN len)
 char*         SvPVbyte_nolen       (SV* sv)
 char*         SvPVbytex_nolen      (SV* sv)
 char*         SvPVbytex            (SV* sv, STRLEN len)
 char*         SvPVbyte_or_null     (SV* sv, STRLEN len)
 char*         SvPVbyte_or_null_nomg(SV* sv, STRLEN len)
 char*         SvPVutf8             (SV* sv, STRLEN len)
 char*         SvPVutf8x            (SV* sv, STRLEN len)
 char*         SvPVutf8_nomg        (SV* sv, STRLEN len)
 char*         SvPVutf8_nolen       (SV* sv)
 char*         SvPVutf8_or_null     (SV* sv, STRLEN len)
 char*         SvPVutf8_or_null_nomg(SV* sv, STRLEN len)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;SvPVbyte&quot;</dt>
  <dd>Like <span class="Li">&quot;SvPV&quot;</span>, but converts
      <span class="Li">&quot;sv&quot;</span> to byte representation first if
      necessary. If the SV cannot be downgraded from UTF-8, this croaks.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> char*  SvPVbyte(SV* sv, STRLEN len)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;SvPVbyte_force&quot;</dt>
  <dd>Like <span class="Li">&quot;SvPV_force&quot;</span>, but converts
      <span class="Li">&quot;sv&quot;</span> to byte representation first if
      necessary. If the SV cannot be downgraded from UTF-8, this croaks.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> char*  SvPVbyte_force(SV* sv, STRLEN len)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;SvPVbyte_nolen&quot;</dt>
  <dd>Like <span class="Li">&quot;SvPV_nolen&quot;</span>, but converts
      <span class="Li">&quot;sv&quot;</span> to byte representation first if
      necessary. If the SV cannot be downgraded from UTF-8, this croaks.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> char*  SvPVbyte_nolen(SV* sv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;SvPVbyte_nomg&quot;</dt>
  <dd>Like <span class="Li">&quot;SvPVbyte&quot;</span>, but does not process
      get magic.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> char*  SvPVbyte_nomg(SV* sv, STRLEN len)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;SvPVbyte_or_null&quot;</dt>
  <dd>Like <span class="Li">&quot;SvPVbyte&quot;</span>, but when
      <span class="Li">&quot;sv&quot;</span> is undef, returns
      <span class="Li">&quot;NULL&quot;</span>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> char*  SvPVbyte_or_null(SV* sv, STRLEN len)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;SvPVbyte_or_null_nomg&quot;</dt>
  <dd>Like <span class="Li">&quot;SvPVbyte_or_null&quot;</span>, but does not
      process get magic.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> char*  SvPVbyte_or_null_nomg(SV* sv, STRLEN len)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;SvPVCLEAR&quot;</dt>
  <dd>Ensures that sv is a SVt_PV and that its SvCUR is 0, and that it is
      properly null terminated. Equivalent to sv_setpvs(&quot;&quot;), but more
      efficient.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> char *  SvPVCLEAR(SV* sv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;SvPV_force&quot;</dt>
  <dd></dd>
  <dt>&quot;SvPV_force_nolen&quot;</dt>
  <dd></dd>
  <dt>&quot;SvPVx_force&quot;</dt>
  <dd></dd>
  <dt>&quot;SvPV_force_nomg&quot;</dt>
  <dd></dd>
  <dt>&quot;SvPV_force_nomg_nolen&quot;</dt>
  <dd></dd>
  <dt>&quot;SvPV_force_mutable&quot;</dt>
  <dd></dd>
  <dt>&quot;SvPV_force_flags&quot;</dt>
  <dd></dd>
  <dt>&quot;SvPV_force_flags_nolen&quot;</dt>
  <dd></dd>
  <dt>&quot;SvPV_force_flags_mutable&quot;</dt>
  <dd></dd>
  <dt>&quot;SvPVbyte_force&quot;</dt>
  <dd></dd>
  <dt>&quot;SvPVbytex_force&quot;</dt>
  <dd></dd>
  <dt>&quot;SvPVutf8_force&quot;</dt>
  <dd></dd>
  <dt>&quot;SvPVutf8x_force&quot;</dt>
  <dd>These are like <span class="Li">&quot;SvPV&quot;</span>, returning the
      string in the SV, but will force the SV into containing a string
      (<span class="Li">&quot;SvPOK&quot;</span>), and only a string
      (<span class="Li">&quot;SvPOK_only&quot;</span>), by hook or by crook. You
      need to use one of these <span class="Li">&quot;force&quot;</span>
      routines if you are going to update the
      <span class="Li">&quot;SvPVX&quot;</span> directly.
    <p class="Pp">Note that coercing an arbitrary scalar into a plain PV will
        potentially strip useful data from it. For example if the SV was
        <span class="Li">&quot;SvROK&quot;</span>, then the referent will have
        its reference count decremented, and the SV itself may be converted to
        an <span class="Li">&quot;SvPOK&quot;</span> scalar with a string buffer
        containing a value such as
        <span class="Li">&quot;ARRAY(0x1234)&quot;</span>.</p>
    <p class="Pp">The differences between the forms are:</p>
    <p class="Pp">The forms with <span class="Li">&quot;flags&quot;</span> in
        their names allow you to use the
        <span class="Li">&quot;flags&quot;</span> parameter to specify to
        perform 'get' magic (by setting the
        <span class="Li">&quot;SV_GMAGIC&quot;</span> flag) or to skip 'get'
        magic (by clearing it). The other forms do perform 'get' magic, except
        for the ones with <span class="Li">&quot;nomg&quot;</span> in their
        names, which skip 'get' magic.</p>
    <p class="Pp">The forms that take a <span class="Li">&quot;len&quot;</span>
        parameter will set that variable to the byte length of the resultant
        string (these are macros, so don't use
        <span class="Li">&amp;len</span>).</p>
    <p class="Pp">The forms with <span class="Li">&quot;nolen&quot;</span> in
        their names indicate they don't have a
        <span class="Li">&quot;len&quot;</span> parameter. They should be used
        only when it is known that the PV is a C string, terminated by a NUL
        byte, and without intermediate NUL characters; or when you don't care
        about its length.</p>
    <p class="Pp">The forms with <span class="Li">&quot;mutable&quot;</span> in
        their names are effectively the same as those without, but the name
        emphasizes that the string is modifiable by the caller, which it is in
        all the forms.</p>
    <p class="Pp"><span class="Li">&quot;SvPVutf8_force&quot;</span> is like
        <span class="Li">&quot;SvPV_force&quot;</span>, but converts
        <span class="Li">&quot;sv&quot;</span> to UTF-8 first if not already
        UTF-8.</p>
    <p class="Pp"><span class="Li">&quot;SvPVutf8x_force&quot;</span> is like
        <span class="Li">&quot;SvPVutf8_force&quot;</span>, but guarantees to
        evaluate <span class="Li">&quot;sv&quot;</span> only once; use the more
        efficient <span class="Li">&quot;SvPVutf8_force&quot;</span>
      otherwise.</p>
    <p class="Pp"><span class="Li">&quot;SvPVbyte_force&quot;</span> is like
        <span class="Li">&quot;SvPV_force&quot;</span>, but converts
        <span class="Li">&quot;sv&quot;</span> to byte representation first if
        currently encoded as UTF-8. If the SV cannot be downgraded from UTF-8,
        this croaks.</p>
    <p class="Pp"><span class="Li">&quot;SvPVbytex_force&quot;</span> is like
        <span class="Li">&quot;SvPVbyte_force&quot;</span>, but guarantees to
        evaluate <span class="Li">&quot;sv&quot;</span> only once; use the more
        efficient <span class="Li">&quot;SvPVbyte_force&quot;</span>
      otherwise.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> char*  SvPV_force              (SV* sv, STRLEN len)
 char*  SvPV_force_nolen        (SV* sv)
 char*  SvPVx_force             (SV* sv, STRLEN len)
 char*  SvPV_force_nomg         (SV* sv, STRLEN len)
 char*  SvPV_force_nomg_nolen   (SV * sv)
 char*  SvPV_force_mutable      (SV * sv, STRLEN len)
 char*  SvPV_force_flags        (SV * sv, STRLEN len, U32 flags)
 char*  SvPV_force_flags_nolen  (SV * sv, U32 flags)
 char*  SvPV_force_flags_mutable(SV * sv, STRLEN len, U32 flags)
 char*  SvPVbyte_force          (SV* sv, STRLEN len)
 char*  SvPVbytex_force         (SV* sv, STRLEN len)
 char*  SvPVutf8_force          (SV* sv, STRLEN len)
 char*  SvPVutf8x_force         (SV* sv, STRLEN len)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;SvPV_free&quot;</dt>
  <dd>Frees the PV buffer in <span class="Li">&quot;sv&quot;</span>, leaving
      things in a precarious state, so should only be used as part of a larger
      operation</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  SvPV_free(SV * sv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;sv_pvn_force_flags&quot;</dt>
  <dd>Get a sensible string out of the SV somehow. If
      <span class="Li">&quot;flags&quot;</span> has the
      <span class="Li">&quot;SV_GMAGIC&quot;</span> bit set, will
      <span class="Li">&quot;mg_get&quot;</span> on
      <span class="Li">&quot;sv&quot;</span> if appropriate, else not.
      <span class="Li">&quot;sv_pvn_force&quot;</span> and
      <span class="Li">&quot;sv_pvn_force_nomg&quot;</span> are implemented in
      terms of this function. You normally want to use the various wrapper
      macros instead: see <span class="Li">&quot;SvPV_force&quot;</span> and
      <span class="Li">&quot;SvPV_force_nomg&quot;</span>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> char*  sv_pvn_force_flags(SV *const sv, STRLEN *const lp,
                           const U32 flags)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;SvPV_renew&quot;</dt>
  <dd>Low level micro optimization of
      <span class="Li">&quot;SvGROW&quot;</span>. It is generally better to use
      <span class="Li">&quot;SvGROW&quot;</span> instead. This is because
      <span class="Li">&quot;SvPV_renew&quot;</span> ignores potential issues
      that <span class="Li">&quot;SvGROW&quot;</span> handles.
      <span class="Li">&quot;sv&quot;</span> needs to have a real
      <span class="Li">&quot;PV&quot;</span> that is unencombered by things like
      COW. Using <span class="Li">&quot;SV_CHECK_THINKFIRST&quot;</span> or
      <span class="Li">&quot;SV_CHECK_THINKFIRST_COW_DROP&quot;</span> before
      calling this should clean it up, but why not just use
      <span class="Li">&quot;SvGROW&quot;</span> if you're not sure about the
      provenance?</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  SvPV_renew(SV* sv, STRLEN len)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;SvPV_set&quot;</dt>
  <dd>This is probably not what you want to use, you probably wanted
      &quot;sv_usepvn_flags&quot; or &quot;sv_setpvn&quot; or
      &quot;sv_setpvs&quot;.
    <p class="Pp">Set the value of the PV pointer in
        <span class="Li">&quot;sv&quot;</span> to the Perl allocated
        <span class="Li">&quot;NUL&quot;</span>-terminated string
        <span class="Li">&quot;val&quot;</span>. See also
        <span class="Li">&quot;SvIV_set&quot;</span>.</p>
    <p class="Pp">Remember to free the previous PV buffer. There are many things
        to check. Beware that the existing pointer may be involved in
        copy-on-write or other mischief, so do
        <span class="Li">&quot;SvOOK_off(sv)&quot;</span> and use
        <span class="Li">&quot;sv_force_normal&quot;</span> or
        <span class="Li">&quot;SvPV_force&quot;</span> (or check the
        <span class="Li">&quot;SvIsCOW&quot;</span> flag) first to make sure
        this modification is safe. Then finally, if it is not a COW, call
        <span class="Li">&quot;SvPV_free&quot;</span> to free the previous PV
        buffer.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  SvPV_set(SV* sv, char* val)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;SvPVutf8&quot;</dt>
  <dd>Like <span class="Li">&quot;SvPV&quot;</span>, but converts
      <span class="Li">&quot;sv&quot;</span> to UTF-8 first if necessary.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> char*  SvPVutf8(SV* sv, STRLEN len)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;SvPVutf8_force&quot;</dt>
  <dd>Like <span class="Li">&quot;SvPV_force&quot;</span>, but converts
      <span class="Li">&quot;sv&quot;</span> to UTF-8 first if necessary.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> char*  SvPVutf8_force(SV* sv, STRLEN len)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;SvPVutf8_nolen&quot;</dt>
  <dd>Like <span class="Li">&quot;SvPV_nolen&quot;</span>, but converts
      <span class="Li">&quot;sv&quot;</span> to UTF-8 first if necessary.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> char*  SvPVutf8_nolen(SV* sv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;SvPVutf8_nomg&quot;</dt>
  <dd>Like <span class="Li">&quot;SvPVutf8&quot;</span>, but does not process
      get magic.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> char*  SvPVutf8_nomg(SV* sv, STRLEN len)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;SvPVutf8_or_null&quot;</dt>
  <dd>Like <span class="Li">&quot;SvPVutf8&quot;</span>, but when
      <span class="Li">&quot;sv&quot;</span> is undef, returns
      <span class="Li">&quot;NULL&quot;</span>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> char*  SvPVutf8_or_null(SV* sv, STRLEN len)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;SvPVutf8_or_null_nomg&quot;</dt>
  <dd>Like <span class="Li">&quot;SvPVutf8_or_null&quot;</span>, but does not
      process get magic.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> char*  SvPVutf8_or_null_nomg(SV* sv, STRLEN len)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;SvPVX&quot;</dt>
  <dd></dd>
  <dt>&quot;SvPVXx&quot;</dt>
  <dd></dd>
  <dt>&quot;SvPVX_const&quot;</dt>
  <dd></dd>
  <dt>&quot;SvPVX_mutable&quot;</dt>
  <dd>These return a pointer to the physical string in the SV. The SV must
      contain a string. Prior to 5.9.3 it is not safe to execute these unless
      the SV's type &gt;= <span class="Li">&quot;SVt_PV&quot;</span>.
    <p class="Pp">These are also used to store the name of an autoloaded
        subroutine in an XS AUTOLOAD routine. See &quot;Autoloading with
        XSUBs&quot; in perlguts.</p>
    <p class="Pp"><span class="Li">&quot;SvPVXx&quot;</span> is identical to
        <span class="Li">&quot;SvPVX&quot;</span>.</p>
    <p class="Pp"><span class="Li">&quot;SvPVX_mutable&quot;</span> is merely a
        synonym for <span class="Li">&quot;SvPVX&quot;</span>, but its name
        emphasizes that the string is modifiable by the caller.</p>
    <p class="Pp"><span class="Li">&quot;SvPVX_const&quot;</span> differs in
        that the return value has been cast so that the compiler will complain
        if you were to try to modify the contents of the string, (unless you
        cast away const yourself).</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> char*        SvPVX        (SV* sv)
 char*        SvPVXx       (SV* sv)
 const char*  SvPVX_const  (SV* sv)
 char*        SvPVX_mutable(SV* sv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;SvREADONLY&quot;</dt>
  <dd>Returns true if the argument is readonly, otherwise returns false. Exposed
      to perl code via <b>Internals::SvREADONLY()</b>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> U32  SvREADONLY(SV* sv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;SvREADONLY_off&quot;</dt>
  <dd>Mark an object as not-readonly. Exactly what this mean depends on the
      object type. Exposed to perl code via <b>Internals::SvREADONLY()</b>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> U32  SvREADONLY_off(SV* sv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;SvREADONLY_on&quot;</dt>
  <dd>Mark an object as readonly. Exactly what this means depends on the object
      type. Exposed to perl code via <b>Internals::SvREADONLY()</b>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> U32  SvREADONLY_on(SV* sv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;sv_ref&quot;</dt>
  <dd>Returns a SV describing what the SV passed in is a reference to.
    <p class="Pp">dst can be a SV to be set to the description or NULL, in which
        case a mortal SV is returned.</p>
    <p class="Pp">If ob is true and the SV is blessed, the description is the
        class name, otherwise it is the type of the SV, &quot;SCALAR&quot;,
        &quot;ARRAY&quot; etc.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> SV*  sv_ref(SV *dst, const SV *const sv, const int ob)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;SvREFCNT&quot;</dt>
  <dd>Returns the value of the object's reference count. Exposed to perl code
      via <b>Internals::SvREFCNT()</b>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> U32  SvREFCNT(SV* sv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;SvREFCNT_dec&quot;</dt>
  <dd></dd>
  <dt>&quot;SvREFCNT_dec_NN&quot;</dt>
  <dd>These decrement the reference count of the given SV.
    <p class="Pp"><span class="Li">&quot;SvREFCNT_dec_NN&quot;</span> may only
        be used when <span class="Li">&quot;sv&quot;</span> is known to not be
        <span class="Li">&quot;NULL&quot;</span>.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  SvREFCNT_dec(SV *sv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;SvREFCNT_inc&quot;</dt>
  <dd></dd>
  <dt>&quot;SvREFCNT_inc_NN&quot;</dt>
  <dd></dd>
  <dt>&quot;SvREFCNT_inc_void&quot;</dt>
  <dd></dd>
  <dt>&quot;SvREFCNT_inc_void_NN&quot;</dt>
  <dd></dd>
  <dt>&quot;SvREFCNT_inc_simple&quot;</dt>
  <dd></dd>
  <dt>&quot;SvREFCNT_inc_simple_NN&quot;</dt>
  <dd></dd>
  <dt>&quot;SvREFCNT_inc_simple_void&quot;</dt>
  <dd></dd>
  <dt>&quot;SvREFCNT_inc_simple_void_NN&quot;</dt>
  <dd>These all increment the reference count of the given SV. The ones without
      <span class="Li">&quot;void&quot;</span> in their names return the SV.
    <p class="Pp"><span class="Li">&quot;SvREFCNT_inc&quot;</span> is the base
        operation; the rest are optimizations if various input constraints are
        known to be true; hence, all can be replaced with
        <span class="Li">&quot;SvREFCNT_inc&quot;</span>.</p>
    <p class="Pp"><span class="Li">&quot;SvREFCNT_inc_NN&quot;</span> can only
        be used if you know <span class="Li">&quot;sv&quot;</span> is not
        <span class="Li">&quot;NULL&quot;</span>. Since we don't have to check
        the NULLness, it's faster and smaller.</p>
    <p class="Pp"><span class="Li">&quot;SvREFCNT_inc_void&quot;</span> can only
        be used if you don't need the return value. The macro doesn't need to
        return a meaningful value.</p>
    <p class="Pp"><span class="Li">&quot;SvREFCNT_inc_void_NN&quot;</span> can
        only be used if you both don't need the return value, and you know that
        <span class="Li">&quot;sv&quot;</span> is not
        <span class="Li">&quot;NULL&quot;</span>. The macro doesn't need to
        return a meaningful value, or check for NULLness, so it's smaller and
        faster.</p>
    <p class="Pp"><span class="Li">&quot;SvREFCNT_inc_simple&quot;</span> can
        only be used with expressions without side effects. Since we don't have
        to store a temporary value, it's faster.</p>
    <p class="Pp"><span class="Li">&quot;SvREFCNT_inc_simple_NN&quot;</span> can
        only be used with expressions without side effects and you know
        <span class="Li">&quot;sv&quot;</span> is not
        <span class="Li">&quot;NULL&quot;</span>. Since we don't have to store a
        temporary value, nor check for NULLness, it's faster and smaller.</p>
    <p class="Pp"><span class="Li">&quot;SvREFCNT_inc_simple_void&quot;</span>
        can only be used with expressions without side effects and you don't
        need the return value.</p>
    <p class="Pp"><span class="Li">&quot;SvREFCNT_inc_simple_void_NN&quot;</span>
        can only be used with expressions without side effects, you don't need
        the return value, and you know <span class="Li">&quot;sv&quot;</span> is
        not <span class="Li">&quot;NULL&quot;</span>.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> SV *  SvREFCNT_inc               (SV *sv)
 SV *  SvREFCNT_inc_NN            (SV *sv)
 void  SvREFCNT_inc_void          (SV *sv)
 void  SvREFCNT_inc_void_NN       (SV* sv)
 SV*   SvREFCNT_inc_simple        (SV* sv)
 SV*   SvREFCNT_inc_simple_NN     (SV* sv)
 void  SvREFCNT_inc_simple_void   (SV* sv)
 void  SvREFCNT_inc_simple_void_NN(SV* sv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;sv_reftype&quot;</dt>
  <dd>Returns a string describing what the SV is a reference to.
    <p class="Pp">If ob is true and the SV is blessed, the string is the class
        name, otherwise it is the type of the SV, &quot;SCALAR&quot;,
        &quot;ARRAY&quot; etc.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> const char*  sv_reftype(const SV *const sv, const int ob)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;sv_replace&quot;</dt>
  <dd>Make the first argument a copy of the second, then delete the original.
      The target SV physically takes over ownership of the body of the source SV
      and inherits its flags; however, the target keeps any magic it owns, and
      any magic in the source is discarded. Note that this is a rather
      specialist SV copying operation; most of the time you'll want to use
      <span class="Li">&quot;sv_setsv&quot;</span> or one of its many macro
      front-ends.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  sv_replace(SV *const sv, SV *const nsv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;sv_report_used&quot;</dt>
  <dd>Dump the contents of all SVs not yet freed (debugging aid).</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  sv_report_used()
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;sv_reset&quot;</dt>
  <dd>Underlying implementation for the
      <span class="Li">&quot;reset&quot;</span> Perl function. Note that the
      perl-level function is vaguely deprecated.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  sv_reset(const char* s, HV *const stash)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;SvROK&quot;</dt>
  <dd>Tests if the SV is an RV.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> U32  SvROK(SV* sv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;SvROK_off&quot;</dt>
  <dd>Unsets the RV status of an SV.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  SvROK_off(SV* sv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;SvROK_on&quot;</dt>
  <dd>Tells an SV that it is an RV.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  SvROK_on(SV* sv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;SvRV&quot;</dt>
  <dd>Dereferences an RV to return the SV.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> SV*  SvRV(SV* sv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;SvRV_set&quot;</dt>
  <dd>Set the value of the RV pointer in <span class="Li">&quot;sv&quot;</span>
      to val. See <span class="Li">&quot;SvIV_set&quot;</span>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  SvRV_set(SV* sv, SV* val)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;sv_rvunweaken&quot;</dt>
  <dd>Unweaken a reference: Clear the
      <span class="Li">&quot;SvWEAKREF&quot;</span> flag on this RV; remove the
      backreference to this RV from the array of backreferences associated with
      the target SV, increment the refcount of the target. Silently ignores
      <span class="Li">&quot;undef&quot;</span> and warns on non-weak
      references.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> SV*  sv_rvunweaken(SV *const sv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;sv_rvweaken&quot;</dt>
  <dd>Weaken a reference: set the <span class="Li">&quot;SvWEAKREF&quot;</span>
      flag on this RV; give the referred-to SV
      <span class="Li">&quot;PERL_MAGIC_backref&quot;</span> magic if it hasn't
      already; and push a back-reference to this RV onto the array of
      backreferences associated with that magic. If the RV is magical, set magic
      will be called after the RV is cleared. Silently ignores
      <span class="Li">&quot;undef&quot;</span> and warns on already-weak
      references.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> SV*  sv_rvweaken(SV *const sv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;sv_setiv&quot;</dt>
  <dd></dd>
  <dt>&quot;sv_setiv_mg&quot;</dt>
  <dd>These copy an integer into the given SV, upgrading first if necessary.
    <p class="Pp">They differ only in that
        <span class="Li">&quot;sv_setiv_mg&quot;</span> handles 'set' magic;
        <span class="Li">&quot;sv_setiv&quot;</span> does not.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  sv_setiv   (SV *const sv, const IV num)
 void  sv_setiv_mg(SV *const sv, const IV i)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;SvSETMAGIC&quot;</dt>
  <dd>Invokes <span class="Li">&quot;mg_set&quot;</span> on an SV if it has
      'set' magic. This is necessary after modifying a scalar, in case it is a
      magical variable like <span class="Li">$|</span> or a tied variable (it
      calls <span class="Li">&quot;STORE&quot;</span>). This macro evaluates its
      argument more than once.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  SvSETMAGIC(SV* sv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;sv_setnv&quot;</dt>
  <dd></dd>
  <dt>&quot;sv_setnv_mg&quot;</dt>
  <dd>These copy a double into the given SV, upgrading first if necessary.
    <p class="Pp">They differ only in that
        <span class="Li">&quot;sv_setnv_mg&quot;</span> handles 'set' magic;
        <span class="Li">&quot;sv_setnv&quot;</span> does not.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  sv_setnv(SV *const sv, const NV num)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;sv_setpv&quot;</dt>
  <dd></dd>
  <dt>&quot;sv_setpv_mg&quot;</dt>
  <dd>These copy a string into an SV. The string must be terminated with a
      <span class="Li">&quot;NUL&quot;</span> character, and not contain embeded
      <span class="Li">&quot;NUL&quot;</span>'s.
    <p class="Pp">They differ only in that:</p>
    <p class="Pp"><span class="Li">&quot;sv_setpv&quot;</span> does not handle
        'set' magic; <span class="Li">&quot;sv_setpv_mg&quot;</span> does.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  sv_setpv(SV *const sv, const char *const ptr)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;sv_setpvf&quot;</dt>
  <dd></dd>
  <dt>&quot;sv_setpvf_nocontext&quot;</dt>
  <dd></dd>
  <dt>&quot;sv_setpvf_mg&quot;</dt>
  <dd></dd>
  <dt>&quot;sv_setpvf_mg_nocontext&quot;</dt>
  <dd>These work like <span class="Li">&quot;sv_catpvf&quot;</span> but copy the
      text into the SV instead of appending it.
    <p class="Pp">The differences between these are:</p>
    <p class="Pp"><span class="Li">&quot;sv_setpvf&quot;</span> and
        <span class="Li">&quot;sv_setpvf_nocontext&quot;</span> do not handle
        'set' magic; <span class="Li">&quot;sv_setpvf_mg&quot;</span> and
        <span class="Li">&quot;sv_setpvf_mg_nocontext&quot;</span> do.</p>
    <p class="Pp"><span class="Li">&quot;sv_setpvf_nocontext&quot;</span> and
        <span class="Li">&quot;sv_setpvf_mg_nocontext&quot;</span> do not take a
        thread context (<span class="Li">&quot;aTHX&quot;</span>) parameter, so
        are used in situations where the caller doesn't already have the thread
        context.</p>
    <p class="Pp">NOTE: <span class="Li">&quot;sv_setpvf&quot;</span> must be
        explicitly called as <span class="Li">&quot;Perl_sv_setpvf&quot;</span>
        with an <span class="Li">&quot;aTHX_&quot;</span> parameter.</p>
    <p class="Pp">NOTE: <span class="Li">&quot;sv_setpvf_mg&quot;</span> must be
        explicitly called as
        <span class="Li">&quot;Perl_sv_setpvf_mg&quot;</span> with an
        <span class="Li">&quot;aTHX_&quot;</span> parameter.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  Perl_sv_setpvf        (pTHX_ SV *const sv,
                              const char *const pat, ...)
 void  sv_setpvf_nocontext   (SV *const sv, const char *const pat,
                              ...)
 void  Perl_sv_setpvf_mg     (pTHX_ SV *const sv,
                              const char *const pat, ...)
 void  sv_setpvf_mg_nocontext(SV *const sv, const char *const pat,
                              ...)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;sv_setpviv&quot;</dt>
  <dd></dd>
  <dt>&quot;sv_setpviv_mg&quot;</dt>
  <dd><span class="Li">&quot;</span><span class="Li"><b>DEPRECATED!</b></span><span class="Li">&quot;</span>
      It is planned to remove <span class="Li">&quot;sv_setpviv&quot;</span>
      from a future release of Perl. Do not use it for new code; remove it from
      existing code.
    <p class="Pp"><span class="Li">&quot;</span><span class="Li"><b>DEPRECATED!</b></span><span class="Li">&quot;</span>
        It is planned to remove
        <span class="Li">&quot;sv_setpviv_mg&quot;</span> from a future release
        of Perl. Do not use it for new code; remove it from existing code.</p>
    <p class="Pp">These copy an integer into the given SV, also updating its
        string value.</p>
    <p class="Pp">They differ only in that
        <span class="Li">&quot;sv_setpviv_mg&quot;</span> performs 'set' magic;
        <span class="Li">&quot;sv_setpviv&quot;</span> skips any magic.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  sv_setpviv   (SV *const sv, const IV num)
 void  sv_setpviv_mg(SV *const sv, const IV iv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;sv_setpvn&quot;</dt>
  <dd></dd>
  <dt>&quot;sv_setpvn_mg&quot;</dt>
  <dd>These copy a string (possibly containing embedded
      <span class="Li">&quot;NUL&quot;</span> characters) into an SV. The
      <span class="Li">&quot;len&quot;</span> parameter indicates the number of
      bytes to be copied. If the <span class="Li">&quot;ptr&quot;</span>
      argument is NULL the SV will become undefined.
    <p class="Pp">The UTF-8 flag is not changed by these functions. A
        terminating NUL byte is guaranteed.</p>
    <p class="Pp">They differ only in that:</p>
    <p class="Pp"><span class="Li">&quot;sv_setpvn&quot;</span> does not handle
        'set' magic; <span class="Li">&quot;sv_setpvn_mg&quot;</span> does.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  sv_setpvn(SV *const sv, const char *const ptr,
                 const STRLEN len)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;sv_setpvs&quot;</dt>
  <dd>Like <span class="Li">&quot;sv_setpvn&quot;</span>, but takes a literal
      string instead of a string/length pair.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  sv_setpvs(SV* sv, &quot;literal string&quot;)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;sv_setpvs_mg&quot;</dt>
  <dd>Like <span class="Li">&quot;sv_setpvn_mg&quot;</span>, but takes a literal
      string instead of a string/length pair.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  sv_setpvs_mg(SV* sv, &quot;literal string&quot;)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;sv_setpv_bufsize&quot;</dt>
  <dd>Sets the SV to be a string of cur bytes length, with at least len bytes
      available. Ensures that there is a null byte at SvEND. Returns a char *
      pointer to the SvPV buffer.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> char  *  sv_setpv_bufsize(SV *const sv, const STRLEN cur,
                           const STRLEN len)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;sv_setref_iv&quot;</dt>
  <dd>Copies an integer into a new SV, optionally blessing the SV. The
      <span class="Li">&quot;rv&quot;</span> argument will be upgraded to an RV.
      That RV will be modified to point to the new SV. The
      <span class="Li">&quot;classname&quot;</span> argument indicates the
      package for the blessing. Set
      <span class="Li">&quot;classname&quot;</span> to
      <span class="Li">&quot;NULL&quot;</span> to avoid the blessing. The new SV
      will have a reference count of 1, and the RV will be returned.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> SV*  sv_setref_iv(SV *const rv, const char *const classname,
                   const IV iv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;sv_setref_nv&quot;</dt>
  <dd>Copies a double into a new SV, optionally blessing the SV. The
      <span class="Li">&quot;rv&quot;</span> argument will be upgraded to an RV.
      That RV will be modified to point to the new SV. The
      <span class="Li">&quot;classname&quot;</span> argument indicates the
      package for the blessing. Set
      <span class="Li">&quot;classname&quot;</span> to
      <span class="Li">&quot;NULL&quot;</span> to avoid the blessing. The new SV
      will have a reference count of 1, and the RV will be returned.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> SV*  sv_setref_nv(SV *const rv, const char *const classname,
                   const NV nv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;sv_setref_pv&quot;</dt>
  <dd>Copies a pointer into a new SV, optionally blessing the SV. The
      <span class="Li">&quot;rv&quot;</span> argument will be upgraded to an RV.
      That RV will be modified to point to the new SV. If the
      <span class="Li">&quot;pv&quot;</span> argument is
      <span class="Li">&quot;NULL&quot;</span>, then
      <span class="Li">&quot;PL_sv_undef&quot;</span> will be placed into the
      SV. The <span class="Li">&quot;classname&quot;</span> argument indicates
      the package for the blessing. Set
      <span class="Li">&quot;classname&quot;</span> to
      <span class="Li">&quot;NULL&quot;</span> to avoid the blessing. The new SV
      will have a reference count of 1, and the RV will be returned.
    <p class="Pp">Do not use with other Perl types such as HV, AV, SV, CV,
        because those objects will become corrupted by the pointer copy
      process.</p>
    <p class="Pp">Note that <span class="Li">&quot;sv_setref_pvn&quot;</span>
        copies the string while this copies the pointer.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> SV*  sv_setref_pv(SV *const rv, const char *const classname,
                   void *const pv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;sv_setref_pvn&quot;</dt>
  <dd>Copies a string into a new SV, optionally blessing the SV. The length of
      the string must be specified with <span class="Li">&quot;n&quot;</span>.
      The <span class="Li">&quot;rv&quot;</span> argument will be upgraded to an
      RV. That RV will be modified to point to the new SV. The
      <span class="Li">&quot;classname&quot;</span> argument indicates the
      package for the blessing. Set
      <span class="Li">&quot;classname&quot;</span> to
      <span class="Li">&quot;NULL&quot;</span> to avoid the blessing. The new SV
      will have a reference count of 1, and the RV will be returned.
    <p class="Pp">Note that <span class="Li">&quot;sv_setref_pv&quot;</span>
        copies the pointer while this copies the string.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> SV*  sv_setref_pvn(SV *const rv, const char *const classname,
                    const char *const pv, const STRLEN n)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;sv_setref_pvs&quot;</dt>
  <dd>Like <span class="Li">&quot;sv_setref_pvn&quot;</span>, but takes a
      literal string instead of a string/length pair.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> SV *  sv_setref_pvs(SV *const rv, const char *const classname,
                     &quot;literal string&quot;)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;sv_setref_uv&quot;</dt>
  <dd>Copies an unsigned integer into a new SV, optionally blessing the SV. The
      <span class="Li">&quot;rv&quot;</span> argument will be upgraded to an RV.
      That RV will be modified to point to the new SV. The
      <span class="Li">&quot;classname&quot;</span> argument indicates the
      package for the blessing. Set
      <span class="Li">&quot;classname&quot;</span> to
      <span class="Li">&quot;NULL&quot;</span> to avoid the blessing. The new SV
      will have a reference count of 1, and the RV will be returned.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> SV*  sv_setref_uv(SV *const rv, const char *const classname,
                   const UV uv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;SvSetSV&quot;</dt>
  <dd></dd>
  <dt>&quot;SvSetMagicSV&quot;</dt>
  <dd></dd>
  <dt>&quot;SvSetSV_nosteal&quot;</dt>
  <dd></dd>
  <dt>&quot;SvSetMagicSV_nosteal&quot;</dt>
  <dd>if <span class="Li">&quot;dsv&quot;</span> is the same as
      <span class="Li">&quot;ssv&quot;</span>, these do nothing. Otherwise they
      all call some form of <span class="Li">&quot;sv_setsv&quot;</span>. They
      may evaluate their arguments more than once.
    <p class="Pp">The only differences are:</p>
    <p class="Pp"><span class="Li">&quot;SvSetMagicSV&quot;</span> and
        <span class="Li">&quot;SvSetMagicSV_nosteal&quot;</span> perform any
        required 'set' magic afterwards on the destination SV;
        <span class="Li">&quot;SvSetSV&quot;</span> and
        <span class="Li">&quot;SvSetSV_nosteal&quot;</span> do not.</p>
    <p class="Pp"><span class="Li">&quot;SvSetSV_nosteal&quot;</span>
        <span class="Li">&quot;SvSetMagicSV_nosteal&quot;</span> call a
        non-destructive version of
      <span class="Li">&quot;sv_setsv&quot;</span>.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  SvSetSV(SV* dsv, SV* ssv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;sv_setsv&quot;</dt>
  <dd></dd>
  <dt>&quot;sv_setsv_flags&quot;</dt>
  <dd></dd>
  <dt>&quot;sv_setsv_mg&quot;</dt>
  <dd></dd>
  <dt>&quot;sv_setsv_nomg&quot;</dt>
  <dd>These copy the contents of the source SV
      <span class="Li">&quot;ssv&quot;</span> into the destination SV
      <span class="Li">&quot;dsv&quot;</span>.
      <span class="Li">&quot;ssv&quot;</span> may be destroyed if it is mortal,
      so don't use these functions if the source SV needs to be reused. Loosely
      speaking, they perform a copy-by-value, obliterating any previous content
      of the destination.
    <p class="Pp">They differ only in that:</p>
    <p class="Pp"><span class="Li">&quot;sv_setsv&quot;</span> calls 'get' magic
        on <span class="Li">&quot;ssv&quot;</span>, but skips 'set' magic on
        <span class="Li">&quot;dsv&quot;</span>.</p>
    <p class="Pp"><span class="Li">&quot;sv_setsv_mg&quot;</span> calls both
        'get' magic on <span class="Li">&quot;ssv&quot;</span> and 'set' magic
        on <span class="Li">&quot;dsv&quot;</span>.</p>
    <p class="Pp"><span class="Li">&quot;sv_setsv_nomg&quot;</span> skips all
        magic.</p>
    <p class="Pp"><span class="Li">&quot;sv_setsv_flags&quot;</span> has a
        <span class="Li">&quot;flags&quot;</span> parameter which you can use to
        specify any combination of magic handling, and also you can specify
        <span class="Li">&quot;SV_NOSTEAL&quot;</span> so that the buffers of
        temps will not be stolen.</p>
    <p class="Pp">You probably want to instead use one of the assortment of
        wrappers, such as <span class="Li">&quot;SvSetSV&quot;</span>,
        <span class="Li">&quot;SvSetSV_nosteal&quot;</span>,
        <span class="Li">&quot;SvSetMagicSV&quot;</span> and
        <span class="Li">&quot;SvSetMagicSV_nosteal&quot;</span>.</p>
    <p class="Pp"><span class="Li">&quot;sv_setsv_flags&quot;</span> is the
        primary function for copying scalars, and most other copy-ish functions
        and macros use it underneath.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  sv_setsv      (SV *dsv, SV *ssv)
 void  sv_setsv_flags(SV *dsv, SV *ssv, const I32 flags)
 void  sv_setsv_mg   (SV *const dsv, SV *const ssv)
 void  sv_setsv_nomg (SV *dsv, SV *ssv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;sv_setuv&quot;</dt>
  <dd></dd>
  <dt>&quot;sv_setuv_mg&quot;</dt>
  <dd>These copy an unsigned integer into the given SV, upgrading first if
      necessary.
    <p class="Pp">They differ only in that
        <span class="Li">&quot;sv_setuv_mg&quot;</span> handles 'set' magic;
        <span class="Li">&quot;sv_setuv&quot;</span> does not.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  sv_setuv   (SV *const sv, const UV num)
 void  sv_setuv_mg(SV *const sv, const UV u)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;sv_set_undef&quot;</dt>
  <dd>Equivalent to <span class="Li">&quot;sv_setsv(sv,
      &amp;PL_sv_undef)&quot;</span>, but more efficient. Doesn't handle set
      magic.
    <p class="Pp">The perl equivalent is <span class="Li">&quot;$sv =
        undef;&quot;</span>. Note that it doesn't free any string buffer, unlike
        <span class="Li">&quot;undef $sv&quot;</span>.</p>
    <p class="Pp">Introduced in perl 5.25.12.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  sv_set_undef(SV *sv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;SvSHARE&quot;</dt>
  <dd>Arranges for <span class="Li">&quot;sv&quot;</span> to be shared between
      threads if a suitable module has been loaded.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  SvSHARE(SV* sv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;SvSHARED_HASH&quot;</dt>
  <dd>Returns the hash for <span class="Li">&quot;sv&quot;</span> created by
      <span class="Li">&quot;newSVpvn_share&quot;</span>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> struct hek*  SvSHARED_HASH(SV * sv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;SvSTASH&quot;</dt>
  <dd>Returns the stash of the SV.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> HV*  SvSTASH(SV* sv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;SvSTASH_set&quot;</dt>
  <dd>Set the value of the STASH pointer in
      <span class="Li">&quot;sv&quot;</span> to val. See
      <span class="Li">&quot;SvIV_set&quot;</span>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  SvSTASH_set(SV* sv, HV* val)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;SvTAINT&quot;</dt>
  <dd>Taints an SV if tainting is enabled, and if some input to the current
      expression is tainted--usually a variable, but possibly also implicit
      inputs such as locale settings.
      <span class="Li">&quot;SvTAINT&quot;</span> propagates that taintedness to
      the outputs of an expression in a pessimistic fashion; i.e., without
      paying attention to precisely which outputs are influenced by which
      inputs.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  SvTAINT(SV* sv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;SvTAINTED&quot;</dt>
  <dd>Checks to see if an SV is tainted. Returns TRUE if it is, FALSE if
    not.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> bool  SvTAINTED(SV* sv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;SvTAINTED_off&quot;</dt>
  <dd>Untaints an SV. Be <i>very</i> careful with this routine, as it
      short-circuits some of Perl's fundamental security features. XS module
      authors should not use this function unless they fully understand all the
      implications of unconditionally untainting the value. Untainting should be
      done in the standard perl fashion, via a carefully crafted regexp, rather
      than directly untainting variables.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  SvTAINTED_off(SV* sv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;SvTAINTED_on&quot;</dt>
  <dd>Marks an SV as tainted if tainting is enabled.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  SvTAINTED_on(SV* sv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;SvTRUE&quot;</dt>
  <dd></dd>
  <dt>&quot;SvTRUEx&quot;</dt>
  <dd></dd>
  <dt>&quot;SvTRUE_nomg&quot;</dt>
  <dd></dd>
  <dt>&quot;SvTRUE_NN&quot;</dt>
  <dd></dd>
  <dt>&quot;SvTRUE_nomg_NN&quot;</dt>
  <dd>These return a boolean indicating whether Perl would evaluate the SV as
      true or false. See <span class="Li">&quot;SvOK&quot;</span> for a
      defined/undefined test.
    <p class="Pp">As of Perl 5.32, all are guaranteed to evaluate
        <span class="Li">&quot;sv&quot;</span> only once. Prior to that release,
        only <span class="Li">&quot;SvTRUEx&quot;</span> guaranteed single
        evaluation; now <span class="Li">&quot;SvTRUEx&quot;</span> is identical
        to <span class="Li">&quot;SvTRUE&quot;</span>.</p>
    <p class="Pp"><span class="Li">&quot;SvTRUE_nomg&quot;</span> and
        <span class="Li">&quot;TRUE_nomg_NN&quot;</span> do not perform 'get'
        magic; the others do unless the scalar is already
        <span class="Li">&quot;SvPOK&quot;</span>,
        <span class="Li">&quot;SvIOK&quot;</span>, or
        <span class="Li">&quot;SvNOK&quot;</span> (the public, not the private
        flags).</p>
    <p class="Pp"><span class="Li">&quot;SvTRUE_NN&quot;</span> is like
        <span class="Li">&quot;SvTRUE&quot;</span>, but
        <span class="Li">&quot;sv&quot;</span> is assumed to be non-null (NN).
        If there is a possibility that it is NULL, use plain
        <span class="Li">&quot;SvTRUE&quot;</span>.</p>
    <p class="Pp"><span class="Li">&quot;SvTRUE_nomg_NN&quot;</span> is like
        <span class="Li">&quot;SvTRUE_nomg&quot;</span>, but
        <span class="Li">&quot;sv&quot;</span> is assumed to be non-null (NN).
        If there is a possibility that it is NULL, use plain
        <span class="Li">&quot;SvTRUE_nomg&quot;</span>.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> bool  SvTRUE(SV *sv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;SvTYPE&quot;</dt>
  <dd>Returns the type of the SV. See
      <span class="Li">&quot;svtype&quot;</span>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> svtype  SvTYPE(SV* sv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;SvUNLOCK&quot;</dt>
  <dd>Releases a mutual exclusion lock on <span class="Li">&quot;sv&quot;</span>
      if a suitable module has been loaded.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  SvUNLOCK(SV* sv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;sv_unmagic&quot;</dt>
  <dd>Removes all magic of type <span class="Li">&quot;type&quot;</span> from an
      SV.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> int  sv_unmagic(SV *const sv, const int type)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;sv_unmagicext&quot;</dt>
  <dd>Removes all magic of type <span class="Li">&quot;type&quot;</span> with
      the specified <span class="Li">&quot;vtbl&quot;</span> from an SV.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> int  sv_unmagicext(SV *const sv, const int type, MGVTBL *vtbl)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;sv_unref&quot;</dt>
  <dd>Unsets the RV status of the SV, and decrements the reference count of
      whatever was being referenced by the RV. This can almost be thought of as
      a reversal of <span class="Li">&quot;newSVrv&quot;</span>. This is
      <span class="Li">&quot;sv_unref_flags&quot;</span> with the
      <span class="Li">&quot;flag&quot;</span> being zero. See
      <span class="Li">&quot;SvROK_off&quot;</span>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  sv_unref(SV* sv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;sv_unref_flags&quot;</dt>
  <dd>Unsets the RV status of the SV, and decrements the reference count of
      whatever was being referenced by the RV. This can almost be thought of as
      a reversal of <span class="Li">&quot;newSVrv&quot;</span>. The
      <span class="Li">&quot;cflags&quot;</span> argument can contain
      <span class="Li">&quot;SV_IMMEDIATE_UNREF&quot;</span> to force the
      reference count to be decremented (otherwise the decrementing is
      conditional on the reference count being different from one or the
      reference being a readonly SV). See
      <span class="Li">&quot;SvROK_off&quot;</span>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  sv_unref_flags(SV *const ref, const U32 flags)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;SvUOK&quot;</dt>
  <dd>Returns a boolean indicating whether the SV contains an integer that must
      be interpreted as unsigned. A non-negative integer whose value is within
      the range of both an IV and a UV may be flagged as either
      <span class="Li">&quot;SvUOK&quot;</span> or
      <span class="Li">&quot;SvIOK&quot;</span>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> bool  SvUOK(SV* sv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;SvUPGRADE&quot;</dt>
  <dd>Used to upgrade an SV to a more complex form. Uses
      <span class="Li">&quot;sv_upgrade&quot;</span> to perform the upgrade if
      necessary. See <span class="Li">&quot;svtype&quot;</span>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  SvUPGRADE(SV* sv, svtype type)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;sv_upgrade&quot;</dt>
  <dd>Upgrade an SV to a more complex form. Generally adds a new body type to
      the SV, then copies across as much information as possible from the old
      body. It croaks if the SV is already in a more complex form than
      requested. You generally want to use the
      <span class="Li">&quot;SvUPGRADE&quot;</span> macro wrapper, which checks
      the type before calling <span class="Li">&quot;sv_upgrade&quot;</span>,
      and hence does not croak. See also
      <span class="Li">&quot;svtype&quot;</span>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  sv_upgrade(SV *const sv, svtype new_type)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;sv_usepvn&quot;</dt>
  <dd>Tells an SV to use <span class="Li">&quot;ptr&quot;</span> to find its
      string value. Implemented by calling
      <span class="Li">&quot;sv_usepvn_flags&quot;</span> with
      <span class="Li">&quot;flags&quot;</span> of 0, hence does not handle
      'set' magic. See <span class="Li">&quot;sv_usepvn_flags&quot;</span>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  sv_usepvn(SV* sv, char* ptr, STRLEN len)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;sv_usepvn_flags&quot;</dt>
  <dd>Tells an SV to use <span class="Li">&quot;ptr&quot;</span> to find its
      string value. Normally the string is stored inside the SV, but sv_usepvn
      allows the SV to use an outside string.
      <span class="Li">&quot;ptr&quot;</span> should point to memory that was
      allocated by <span class="Li">&quot;Newx&quot;</span>. It must be the
      start of a <span class="Li">&quot;Newx&quot;</span>-ed block of memory,
      and not a pointer to the middle of it (beware of
      <span class="Li">&quot;OOK&quot;</span> and copy-on-write), and not be
      from a non-<span class="Li">&quot;Newx&quot;</span> memory allocator like
      <span class="Li">&quot;malloc&quot;</span>. The string length,
      <span class="Li">&quot;len&quot;</span>, must be supplied. By default this
      function will <span class="Li">&quot;Renew&quot;</span> (i.e. realloc,
      move) the memory pointed to by <span class="Li">&quot;ptr&quot;</span>, so
      that pointer should not be freed or used by the programmer after giving it
      to <span class="Li">&quot;sv_usepvn&quot;</span>, and neither should any
      pointers from &quot;behind&quot; that pointer (e.g. ptr + 1) be used.
    <p class="Pp">If
        <span class="Li">&quot;flags&#x00A0;&amp;&#x00A0;SV_SMAGIC&quot;</span>
        is true, will call <span class="Li">&quot;SvSETMAGIC&quot;</span>. If
        <span class="Li">&quot;flags&#x00A0;&amp;&#x00A0;SV_HAS_TRAILING_NUL&quot;</span>
        is true, then <span class="Li">&quot;ptr[len]&quot;</span> must be
        <span class="Li">&quot;NUL&quot;</span>, and the realloc will be skipped
        (i.e. the buffer is actually at least 1 byte longer than
        <span class="Li">&quot;len&quot;</span>, and already meets the
        requirements for storing in
      <span class="Li">&quot;SvPVX&quot;</span>).</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  sv_usepvn_flags(SV *const sv, char* ptr, const STRLEN len,
                       const U32 flags)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;sv_usepvn_mg&quot;</dt>
  <dd>Like <span class="Li">&quot;sv_usepvn&quot;</span>, but also handles 'set'
      magic.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  sv_usepvn_mg(SV *sv, char *ptr, STRLEN len)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;SvUTF8&quot;</dt>
  <dd>Returns a U32 value indicating the UTF-8 status of an SV. If things are
      set-up properly, this indicates whether or not the SV contains UTF-8
      encoded data. You should use this <i>after</i> a call to
      <span class="Li">&quot;SvPV&quot;</span> or one of its variants, in case
      any call to string overloading updates the internal flag.
    <p class="Pp">If you want to take into account the bytes pragma, use
        <span class="Li">&quot;DO_UTF8&quot;</span> instead.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> U32  SvUTF8(SV* sv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;sv_utf8_decode&quot;</dt>
  <dd>If the PV of the SV is an octet sequence in Perl's extended UTF-8 and
      contains a multiple-byte character, the
      <span class="Li">&quot;SvUTF8&quot;</span> flag is turned on so that it
      looks like a character. If the PV contains only single-byte characters,
      the <span class="Li">&quot;SvUTF8&quot;</span> flag stays off. Scans PV
      for validity and returns FALSE if the PV is invalid UTF-8.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> bool  sv_utf8_decode(SV *const sv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;sv_utf8_downgrade&quot;</dt>
  <dd></dd>
  <dt>&quot;sv_utf8_downgrade_flags&quot;</dt>
  <dd></dd>
  <dt>&quot;sv_utf8_downgrade_nomg&quot;</dt>
  <dd>These attempt to convert the PV of an SV from characters to bytes. If the
      PV contains a character that cannot fit in a byte, this conversion will
      fail; in this case, <span class="Li">&quot;FALSE&quot;</span> is returned
      if <span class="Li">&quot;fail_ok&quot;</span> is true; otherwise they
      croak.
    <p class="Pp">They are not a general purpose Unicode to byte encoding
        interface: use the <span class="Li">&quot;Encode&quot;</span> extension
        for that.</p>
    <p class="Pp">They differ only in that:</p>
    <p class="Pp"><span class="Li">&quot;sv_utf8_downgrade&quot;</span>
        processes 'get' magic on <span class="Li">&quot;sv&quot;</span>.</p>
    <p class="Pp"><span class="Li">&quot;sv_utf8_downgrade_nomg&quot;</span>
        does not.</p>
    <p class="Pp"><span class="Li">&quot;sv_utf8_downgrade_flags&quot;</span>
        has an additional <span class="Li">&quot;flags&quot;</span> parameter in
        which you can specify <span class="Li">&quot;SV_GMAGIC&quot;</span> to
        process 'get' magic, or leave it cleared to not proccess 'get'
      magic.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> bool  sv_utf8_downgrade      (SV *const sv, const bool fail_ok)
 bool  sv_utf8_downgrade_flags(SV *const sv, const bool fail_ok,
                               const U32 flags)
 bool  sv_utf8_downgrade_nomg (SV *const sv, const bool fail_ok)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;sv_utf8_encode&quot;</dt>
  <dd>Converts the PV of an SV to UTF-8, but then turns the
      <span class="Li">&quot;SvUTF8&quot;</span> flag off so that it looks like
      octets again.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  sv_utf8_encode(SV *const sv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;sv_utf8_upgrade&quot;</dt>
  <dd></dd>
  <dt>&quot;sv_utf8_upgrade_nomg&quot;</dt>
  <dd></dd>
  <dt>&quot;sv_utf8_upgrade_flags&quot;</dt>
  <dd></dd>
  <dt>&quot;sv_utf8_upgrade_flags_grow&quot;</dt>
  <dd>These convert the PV of an SV to its UTF-8-encoded form. The SV is forced
      to string form if it is not already. They always set the
      <span class="Li">&quot;SvUTF8&quot;</span> flag to avoid future validity
      checks even if the whole string is the same in UTF-8 as not. They return
      the number of bytes in the converted string
    <p class="Pp">The forms differ in just two ways. The main difference is
        whether or not they perform 'get magic' on
        <span class="Li">&quot;sv&quot;</span>.
        <span class="Li">&quot;sv_utf8_upgrade_nomg&quot;</span> skips 'get
        magic'; <span class="Li">&quot;sv_utf8_upgrade&quot;</span> performs it;
        and <span class="Li">&quot;sv_utf8_upgrade_flags&quot;</span> and
        <span class="Li">&quot;sv_utf8_upgrade_flags_grow&quot;</span> either
        perform it (if the <span class="Li">&quot;SV_GMAGIC&quot;</span> bit is
        set in <span class="Li">&quot;flags&quot;</span>) or don't (if that bit
        is cleared).</p>
    <p class="Pp">The other difference is that
        <span class="Li">&quot;sv_utf8_upgrade_flags_grow&quot;</span> has an
        additional parameter, <span class="Li">&quot;extra&quot;</span>, which
        allows the caller to specify an amount of space to be reserved as spare
        beyond what is needed for the actual conversion. This is used when the
        caller knows it will soon be needing yet more space, and it is more
        efficient to request space from the system in a single call. This form
        is otherwise identical to
        <span class="Li">&quot;sv_utf8_upgrade_flags&quot;</span>.</p>
    <p class="Pp">These are not a general purpose byte encoding to Unicode
        interface: use the Encode extension for that.</p>
    <p class="Pp">The <span class="Li">&quot;SV_FORCE_UTF8_UPGRADE&quot;</span>
        flag is now ignored.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> STRLEN  sv_utf8_upgrade           (SV *sv)
 STRLEN  sv_utf8_upgrade_nomg      (SV *sv)
 STRLEN  sv_utf8_upgrade_flags     (SV *const sv, const I32 flags)
 STRLEN  sv_utf8_upgrade_flags_grow(SV *const sv, const I32 flags,
                                    STRLEN extra)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;SvUTF8_off&quot;</dt>
  <dd>Unsets the UTF-8 status of an SV (the data is not changed, just the flag).
      Do not use frivolously.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  SvUTF8_off(SV *sv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;SvUTF8_on&quot;</dt>
  <dd>Turn on the UTF-8 status of an SV (the data is not changed, just the
      flag). Do not use frivolously.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  SvUTF8_on(SV *sv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;SvUV&quot;</dt>
  <dd></dd>
  <dt>&quot;SvUVx&quot;</dt>
  <dd></dd>
  <dt>&quot;SvUV_nomg&quot;</dt>
  <dd>These coerce the given SV to UV and return it. The returned value in many
      circumstances will get stored in <span class="Li">&quot;sv&quot;</span>'s
      UV slot, but not in all cases. (Use
      <span class="Li">&quot;sv_setuv&quot;</span> to make sure it does).
    <p class="Pp"><span class="Li">&quot;SvUVx&quot;</span> is different from
        the others in that it is guaranteed to evaluate
        <span class="Li">&quot;sv&quot;</span> exactly once; the others may
        evaluate it multiple times. Only use this form if
        <span class="Li">&quot;sv&quot;</span> is an expression with side
        effects, otherwise use the more efficient
        <span class="Li">&quot;SvUV&quot;</span>.</p>
    <p class="Pp"><span class="Li">&quot;SvUV_nomg&quot;</span> is the same as
        <span class="Li">&quot;SvUV&quot;</span>, but does not perform 'get'
        magic.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> UV  SvUV(SV* sv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;SvUV_set&quot;</dt>
  <dd>Set the value of the UV pointer in <span class="Li">&quot;sv&quot;</span>
      to val. See <span class="Li">&quot;SvIV_set&quot;</span>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  SvUV_set(SV* sv, UV val)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;SvUVX&quot;</dt>
  <dd>Returns the raw value in the SV's UV slot, without checks or conversions.
      Only use when you are sure <span class="Li">&quot;SvIOK&quot;</span> is
      true. See also <span class="Li">&quot;SvUV&quot;</span>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> UV  SvUVX(SV* sv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;SvUVXx&quot;</dt>
  <dd><span class="Li">&quot;</span><span class="Li"><b>DEPRECATED!</b></span><span class="Li">&quot;</span>
      It is planned to remove <span class="Li">&quot;SvUVXx&quot;</span> from a
      future release of Perl. Do not use it for new code; remove it from
      existing code.
    <p class="Pp">This is an unnecessary synonym for &quot;SvUVX&quot;</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> UV  SvUVXx(SV* sv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;sv_vcatpvf&quot;</dt>
  <dd></dd>
  <dt>&quot;sv_vcatpvf_mg&quot;</dt>
  <dd>These process their arguments like
      <span class="Li">&quot;sv_vcatpvfn&quot;</span> called with a non-null
      C-style variable argument list, and append the formatted output to
      <span class="Li">&quot;sv&quot;</span>.
    <p class="Pp">They differ only in that
        <span class="Li">&quot;sv_vcatpvf_mg&quot;</span> performs 'set' magic;
        <span class="Li">&quot;sv_vcatpvf&quot;</span> skips 'set' magic.</p>
    <p class="Pp">Both perform 'get' magic.</p>
    <p class="Pp">They are usually accessed via their frontends
        <span class="Li">&quot;sv_catpvf&quot;</span> and
        <span class="Li">&quot;sv_catpvf_mg&quot;</span>.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  sv_vcatpvf(SV *const sv, const char *const pat,
                  va_list *const args)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;sv_vcatpvfn&quot;</dt>
  <dd></dd>
  <dt>&quot;sv_vcatpvfn_flags&quot;</dt>
  <dd>These process their arguments like <span class="Li">vsprintf(3)</span> and
      append the formatted output to an SV. They use an array of SVs if the
      C-style variable argument list is missing
      (<span class="Li">&quot;NULL&quot;</span>). Argument reordering (using
      format specifiers like <span class="Li">&quot;%2$d&quot;</span> or
      <span class="Li">&quot;%*2$d&quot;</span>) is supported only when using an
      array of SVs; using a C-style <span class="Li">&quot;va_list&quot;</span>
      argument list with a format string that uses argument reordering will
      yield an exception.
    <p class="Pp">When running with taint checks enabled, they indicate via
        <span class="Li">&quot;maybe_tainted&quot;</span> if results are
        untrustworthy (often due to the use of locales).</p>
    <p class="Pp">They assume that <span class="Li">&quot;pat&quot;</span> has
        the same utf8-ness as <span class="Li">&quot;sv&quot;</span>. It's the
        caller's responsibility to ensure that this is so.</p>
    <p class="Pp">They differ in that
        <span class="Li">&quot;sv_vcatpvfn_flags&quot;</span> has a
        <span class="Li">&quot;flags&quot;</span> parameter in which you can set
        or clear the <span class="Li">&quot;SV_GMAGIC&quot;</span> and/or
        SV_SMAGIC flags, to specify which magic to handle or not handle; whereas
        plain <span class="Li">&quot;sv_vcatpvfn&quot;</span> always specifies
        both 'get' and 'set' magic.</p>
    <p class="Pp">They are usually used via one of the frontends
        <span class="Li">&quot;sv_vcatpvf&quot;</span> and
        <span class="Li">&quot;sv_vcatpvf_mg&quot;</span>.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  sv_vcatpvfn      (SV *const sv, const char *const pat,
                         const STRLEN patlen, va_list *const args,
                         SV **const svargs, const Size_t sv_count,
                         bool *const maybe_tainted)
 void  sv_vcatpvfn_flags(SV *const sv, const char *const pat,
                         const STRLEN patlen, va_list *const args,
                         SV **const svargs, const Size_t sv_count,
                         bool *const maybe_tainted,
                         const U32 flags)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;SvVOK&quot;</dt>
  <dd>Returns a boolean indicating whether the SV contains a v-string.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> bool  SvVOK(SV* sv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;sv_vsetpvf&quot;</dt>
  <dd></dd>
  <dt>&quot;sv_vsetpvf_mg&quot;</dt>
  <dd>These work like <span class="Li">&quot;sv_vcatpvf&quot;</span> but copy
      the text into the SV instead of appending it.
    <p class="Pp">They differ only in that
        <span class="Li">&quot;sv_vsetpvf_mg&quot;</span> performs 'set' magic;
        <span class="Li">&quot;sv_vsetpvf&quot;</span> skips all magic.</p>
    <p class="Pp">They are usually used via their frontends,
        <span class="Li">&quot;sv_setpvf&quot;</span> and
        <span class="Li">&quot;sv_setpvf_mg&quot;</span>.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  sv_vsetpvf(SV *const sv, const char *const pat,
                  va_list *const args)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;sv_vsetpvfn&quot;</dt>
  <dd>Works like <span class="Li">&quot;sv_vcatpvfn&quot;</span> but copies the
      text into the SV instead of appending it.
    <p class="Pp">Usually used via one of its frontends
        <span class="Li">&quot;sv_vsetpvf&quot;</span> and
        <span class="Li">&quot;sv_vsetpvf_mg&quot;</span>.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  sv_vsetpvfn(SV *const sv, const char *const pat,
                   const STRLEN patlen, va_list *const args,
                   SV **const svargs, const Size_t sv_count,
                   bool *const maybe_tainted)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;SvVSTRING_mg&quot;</dt>
  <dd>Returns the vstring magic, or NULL if none</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> MAGIC*  SvVSTRING_mg(SV * sv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;vnewSVpvf&quot;</dt>
  <dd>Like <span class="Li">&quot;newSVpvf&quot;</span> but but the arguments
      are an encapsulated argument list.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> SV*  vnewSVpvf(const char *const pat, va_list *const args)
</pre>
</div>
<div class="Bd-indent"></div>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="Time"><a class="permalink" href="#Time">Time</a></h1>
<dl class="Bl-tag">
  <dt>&quot;ASCTIME_R_PROTO&quot;</dt>
  <dd>This symbol encodes the prototype of
      <span class="Li">&quot;asctime_r&quot;</span>. It is zero if
      <span class="Li">&quot;d_asctime_r&quot;</span> is undef, and one of the
      <span class="Li">&quot;REENTRANT_PROTO_T_ABC&quot;</span> macros of
      <i>reentr.h</i> if <span class="Li">&quot;d_asctime_r&quot;</span> is
      defined.</dd>
  <dt>&quot;CTIME_R_PROTO&quot;</dt>
  <dd>This symbol encodes the prototype of
      <span class="Li">&quot;ctime_r&quot;</span>. It is zero if
      <span class="Li">&quot;d_ctime_r&quot;</span> is undef, and one of the
      <span class="Li">&quot;REENTRANT_PROTO_T_ABC&quot;</span> macros of
      <i>reentr.h</i> if <span class="Li">&quot;d_ctime_r&quot;</span> is
      defined.</dd>
  <dt>&quot;GMTIME_MAX&quot;</dt>
  <dd>This symbol contains the maximum value for the
      <span class="Li">&quot;time_t&quot;</span> offset that the system function
      gmtime () accepts, and defaults to 0</dd>
  <dt>&quot;GMTIME_MIN&quot;</dt>
  <dd>This symbol contains the minimum value for the
      <span class="Li">&quot;time_t&quot;</span> offset that the system function
      gmtime () accepts, and defaults to 0</dd>
  <dt>&quot;GMTIME_R_PROTO&quot;</dt>
  <dd>This symbol encodes the prototype of
      <span class="Li">&quot;gmtime_r&quot;</span>. It is zero if
      <span class="Li">&quot;d_gmtime_r&quot;</span> is undef, and one of the
      <span class="Li">&quot;REENTRANT_PROTO_T_ABC&quot;</span> macros of
      <i>reentr.h</i> if <span class="Li">&quot;d_gmtime_r&quot;</span> is
      defined.</dd>
  <dt>&quot;HAS_ASCTIME64&quot;</dt>
  <dd>This symbol, if defined, indicates that the
      <span class="Li">&quot;asctime64&quot;</span> () routine is available to
      do the 64bit variant of asctime ()</dd>
  <dt>&quot;HAS_ASCTIME_R&quot;</dt>
  <dd>This symbol, if defined, indicates that the
      <span class="Li">&quot;asctime_r&quot;</span> routine is available to
      asctime re-entrantly.</dd>
  <dt>&quot;HAS_CTIME64&quot;</dt>
  <dd>This symbol, if defined, indicates that the
      <span class="Li">&quot;ctime64&quot;</span> () routine is available to do
      the 64bit variant of ctime ()</dd>
  <dt>&quot;HAS_CTIME_R&quot;</dt>
  <dd>This symbol, if defined, indicates that the
      <span class="Li">&quot;ctime_r&quot;</span> routine is available to ctime
      re-entrantly.</dd>
  <dt>&quot;HAS_DIFFTIME&quot;</dt>
  <dd>This symbol, if defined, indicates that the
      <span class="Li">&quot;difftime&quot;</span> routine is available.</dd>
  <dt>&quot;HAS_DIFFTIME64&quot;</dt>
  <dd>This symbol, if defined, indicates that the
      <span class="Li">&quot;difftime64&quot;</span> () routine is available to
      do the 64bit variant of difftime ()</dd>
  <dt>&quot;HAS_FUTIMES&quot;</dt>
  <dd>This symbol, if defined, indicates that the
      <span class="Li">&quot;futimes&quot;</span> routine is available to change
      file descriptor time stamps with <span class="Li">&quot;struct
      timevals&quot;</span>.</dd>
  <dt>&quot;HAS_GETITIMER&quot;</dt>
  <dd>This symbol, if defined, indicates that the
      <span class="Li">&quot;getitimer&quot;</span> routine is available to
      return interval timers.</dd>
  <dt>&quot;HAS_GETTIMEOFDAY&quot;</dt>
  <dd>This symbol, if defined, indicates that the
      <span class="Li">&quot;gettimeofday()&quot;</span> system call is
      available for a sub-second accuracy clock. Usually, the file
      <i>sys/resource.h</i> needs to be included (see
      <span class="Li">&quot;I_SYS_RESOURCE&quot;</span>). The type
      &quot;Timeval&quot; should be used to refer to
      &quot;<span class="Li">&quot;struct timeval&quot;</span>&quot;.</dd>
  <dt>&quot;HAS_GMTIME64&quot;</dt>
  <dd>This symbol, if defined, indicates that the
      <span class="Li">&quot;gmtime64&quot;</span> () routine is available to do
      the 64bit variant of gmtime ()</dd>
  <dt>&quot;HAS_GMTIME_R&quot;</dt>
  <dd>This symbol, if defined, indicates that the
      <span class="Li">&quot;gmtime_r&quot;</span> routine is available to
      gmtime re-entrantly.</dd>
  <dt>&quot;HAS_LOCALTIME64&quot;</dt>
  <dd>This symbol, if defined, indicates that the
      <span class="Li">&quot;localtime64&quot;</span> () routine is available to
      do the 64bit variant of localtime ()</dd>
  <dt>&quot;HAS_LOCALTIME_R&quot;</dt>
  <dd>This symbol, if defined, indicates that the
      <span class="Li">&quot;localtime_r&quot;</span> routine is available to
      localtime re-entrantly.</dd>
  <dt>&quot;HAS_MKTIME&quot;</dt>
  <dd>This symbol, if defined, indicates that the
      <span class="Li">&quot;mktime&quot;</span> routine is available.</dd>
  <dt>&quot;HAS_MKTIME64&quot;</dt>
  <dd>This symbol, if defined, indicates that the
      <span class="Li">&quot;mktime64&quot;</span> () routine is available to do
      the 64bit variant of mktime ()</dd>
  <dt>&quot;HAS_NANOSLEEP&quot;</dt>
  <dd>This symbol, if defined, indicates that the
      <span class="Li">&quot;nanosleep&quot;</span> system call is available to
      sleep with 1E-9 sec accuracy.</dd>
  <dt>&quot;HAS_SETITIMER&quot;</dt>
  <dd>This symbol, if defined, indicates that the
      <span class="Li">&quot;setitimer&quot;</span> routine is available to set
      interval timers.</dd>
  <dt>&quot;HAS_STRFTIME&quot;</dt>
  <dd>This symbol, if defined, indicates that the
      <span class="Li">&quot;strftime&quot;</span> routine is available to do
      time formatting.</dd>
  <dt>&quot;HAS_TIME&quot;</dt>
  <dd>This symbol, if defined, indicates that the
      <span class="Li">&quot;time()&quot;</span> routine exists.</dd>
  <dt>&quot;HAS_TIMEGM&quot;</dt>
  <dd>This symbol, if defined, indicates that the
      <span class="Li">&quot;timegm&quot;</span> routine is available to do the
      opposite of gmtime ()</dd>
  <dt>&quot;HAS_TIMES&quot;</dt>
  <dd>This symbol, if defined, indicates that the
      <span class="Li">&quot;times()&quot;</span> routine exists. Note that this
      became obsolete on some systems
      (<span class="Li">&quot;SUNOS&quot;</span>), which now use
      <span class="Li">&quot;getrusage()&quot;</span>. It may be necessary to
      include <i>sys/times.h</i>.</dd>
  <dt>&quot;HAS_TM_TM_GMTOFF&quot;</dt>
  <dd>This symbol, if defined, indicates to the C program that the
      <span class="Li">&quot;struct tm&quot;</span> has a
      <span class="Li">&quot;tm_gmtoff&quot;</span> field.</dd>
  <dt>&quot;HAS_TM_TM_ZONE&quot;</dt>
  <dd>This symbol, if defined, indicates to the C program that the
      <span class="Li">&quot;struct tm&quot;</span> has a
      <span class="Li">&quot;tm_zone&quot;</span> field.</dd>
  <dt>&quot;HAS_TZNAME&quot;</dt>
  <dd>This symbol, if defined, indicates that the
      <span class="Li">&quot;tzname[]&quot;</span> array is available to access
      timezone names.</dd>
  <dt>&quot;HAS_USLEEP&quot;</dt>
  <dd>This symbol, if defined, indicates that the
      <span class="Li">&quot;usleep&quot;</span> routine is available to let the
      process sleep on a sub-second accuracy.</dd>
  <dt>&quot;HAS_USLEEP_PROTO&quot;</dt>
  <dd>This symbol, if defined, indicates that the system provides a prototype
      for the <span class="Li">&quot;usleep()&quot;</span> function. Otherwise,
      it is up to the program to supply one. A good guess is
    <p class="Pp"></p>
    <pre> extern int usleep(useconds_t);
    </pre>
  </dd>
  <dt>&quot;I_TIME&quot;</dt>
  <dd>This symbol is always defined, and indicates to the C program that it
      should include <i>time.h</i>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> #ifdef I_TIME
     #include &lt;time.h&gt;
 #endif
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;I_UTIME&quot;</dt>
  <dd>This symbol, if defined, indicates to the C program that it should include
      <i>utime.h</i>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> #ifdef I_UTIME
     #include &lt;utime.h&gt;
 #endif
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;LOCALTIME_MAX&quot;</dt>
  <dd>This symbol contains the maximum value for the
      <span class="Li">&quot;time_t&quot;</span> offset that the system function
      localtime () accepts, and defaults to 0</dd>
  <dt>&quot;LOCALTIME_MIN&quot;</dt>
  <dd>This symbol contains the minimum value for the
      <span class="Li">&quot;time_t&quot;</span> offset that the system function
      localtime () accepts, and defaults to 0</dd>
  <dt>&quot;LOCALTIME_R_NEEDS_TZSET&quot;</dt>
  <dd>Many libc's <span class="Li">&quot;localtime_r&quot;</span>
      implementations do not call tzset, making them differ from
      <span class="Li">&quot;localtime()&quot;</span>, and making timezone
      changes using $<span class="Li">&quot;ENV&quot;</span>{TZ} without
      explicitly calling tzset impossible. This symbol makes us call tzset
      before <span class="Li">&quot;localtime_r&quot;</span></dd>
  <dt>&quot;LOCALTIME_R_PROTO&quot;</dt>
  <dd>This symbol encodes the prototype of
      <span class="Li">&quot;localtime_r&quot;</span>. It is zero if
      <span class="Li">&quot;d_localtime_r&quot;</span> is undef, and one of the
      <span class="Li">&quot;REENTRANT_PROTO_T_ABC&quot;</span> macros of
      <i>reentr.h</i> if <span class="Li">&quot;d_localtime_r&quot;</span> is
      defined.</dd>
  <dt>&quot;L_R_TZSET&quot;</dt>
  <dd>If <span class="Li">&quot;localtime_r()&quot;</span> needs tzset, it is
      defined in this define</dd>
  <dt>&quot;mini_mktime&quot;</dt>
  <dd>normalise <span class="Li">&quot;struct&#x00A0;tm&quot;</span> values
      without the <b>localtime()</b> semantics (and overhead) of
      <b>mktime()</b>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  mini_mktime(struct tm *ptm)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;my_strftime&quot;</dt>
  <dd><b>strftime()</b>, but with a different API so that the return value is a
      pointer to the formatted result (which MUST be arranged to be FREED BY THE
      CALLER). This allows this function to increase the buffer size as needed,
      so that the caller doesn't have to worry about that.
    <p class="Pp">Note that yday and wday effectively are ignored by this
        function, as <b>mini_mktime()</b> overwrites them</p>
    <p class="Pp">Also note that this is always executed in the underlying
        locale of the program, giving localized results.</p>
    <p class="Pp">NOTE: <span class="Li">&quot;my_strftime&quot;</span> must be
        explicitly called as
        <span class="Li">&quot;Perl_my_strftime&quot;</span> with an
        <span class="Li">&quot;aTHX_&quot;</span> parameter.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> char *  Perl_my_strftime(pTHX_ const char *fmt, int sec, int min,
                          int hour, int mday, int mon, int year,
                          int wday, int yday, int isdst)
</pre>
</div>
<div class="Bd-indent"></div>
</section>
<section class="Sh">
<h1 class="Sh" id="Typedef_names"><a class="permalink" href="#Typedef_names">Typedef
  names</a></h1>
<dl class="Bl-tag">
  <dt>&quot;DB_Hash_t&quot;</dt>
  <dd>This symbol contains the type of the prefix structure element in the
      <i>db.h</i> header file. In older versions of DB, it was int, while in
      newer ones it is <span class="Li">&quot;size_t&quot;</span>.</dd>
  <dt>&quot;DB_Prefix_t&quot;</dt>
  <dd>This symbol contains the type of the prefix structure element in the
      <i>db.h</i> header file. In older versions of DB, it was int, while in
      newer ones it is <span class="Li">&quot;u_int32_t&quot;</span>.</dd>
  <dt>&quot;Direntry_t&quot;</dt>
  <dd>This symbol is set to '<span class="Li">&quot;struct direct&quot;</span>'
      or '<span class="Li">&quot;struct dirent&quot;</span>' depending on
      whether dirent is available or not. You should use this pseudo type to
      portably declare your directory entries.</dd>
  <dt>&quot;Fpos_t&quot;</dt>
  <dd>This symbol holds the type used to declare file positions in libc. It can
      be <span class="Li">&quot;fpos_t&quot;</span>, long, uint, etc... It may
      be necessary to include <i>sys/types.h</i> to get any typedef'ed
      information.</dd>
  <dt>&quot;Free_t&quot;</dt>
  <dd>This variable contains the return type of
      <span class="Li">&quot;free()&quot;</span>. It is usually void, but
      occasionally int.</dd>
  <dt>&quot;Gid_t&quot;</dt>
  <dd>This symbol holds the return type of
      <span class="Li">&quot;getgid()&quot;</span> and the type of argument to
      <span class="Li">&quot;setrgid()&quot;</span> and related functions.
      Typically, it is the type of group ids in the kernel. It can be int,
      ushort, <span class="Li">&quot;gid_t&quot;</span>, etc... It may be
      necessary to include <i>sys/types.h</i> to get any typedef'ed
    information.</dd>
  <dt>&quot;Gid_t_f&quot;</dt>
  <dd>This symbol defines the format string used for printing a
      <span class="Li">&quot;Gid_t&quot;</span>.</dd>
  <dt>&quot;Gid_t_sign&quot;</dt>
  <dd>This symbol holds the signedness of a
      <span class="Li">&quot;Gid_t&quot;</span>. 1 for unsigned, -1 for
    signed.</dd>
  <dt>&quot;Gid_t_size&quot;</dt>
  <dd>This symbol holds the size of a <span class="Li">&quot;Gid_t&quot;</span>
      in bytes.</dd>
  <dt>&quot;Groups_t&quot;</dt>
  <dd>This symbol holds the type used for the second argument to
      <span class="Li">&quot;getgroups()&quot;</span> and
      <span class="Li">&quot;setgroups()&quot;</span>. Usually, this is the same
      as gidtype (<span class="Li">&quot;gid_t&quot;</span>) , but sometimes it
      isn't. It can be int, ushort, <span class="Li">&quot;gid_t&quot;</span>,
      etc... It may be necessary to include <i>sys/types.h</i> to get any
      typedef'ed information. This is only required if you have
      <span class="Li">&quot;getgroups()&quot;</span> or
      <span class="Li">&quot;setgroups()&quot;</span>..</dd>
  <dt>&quot;Malloc_t&quot;</dt>
  <dd>This symbol is the type of pointer returned by malloc and realloc.</dd>
  <dt>&quot;Mmap_t&quot;</dt>
  <dd>This symbol holds the return type of the
      <span class="Li">&quot;mmap()&quot;</span> system call (and simultaneously
      the type of the first argument). Usually set to 'void *' or
      '<span class="Li">&quot;caddr_t&quot;</span>'.</dd>
  <dt>&quot;Mode_t&quot;</dt>
  <dd>This symbol holds the type used to declare file modes for systems calls.
      It is usually <span class="Li">&quot;mode_t&quot;</span>, but may be int
      or unsigned short. It may be necessary to include <i>sys/types.h</i> to
      get any typedef'ed information.</dd>
  <dt>&quot;Netdb_hlen_t&quot;</dt>
  <dd>This symbol holds the type used for the 2nd argument to
      <span class="Li">&quot;gethostbyaddr()&quot;</span>.</dd>
  <dt>&quot;Netdb_host_t&quot;</dt>
  <dd>This symbol holds the type used for the 1st argument to
      <span class="Li">&quot;gethostbyaddr()&quot;</span>.</dd>
  <dt>&quot;Netdb_name_t&quot;</dt>
  <dd>This symbol holds the type used for the argument to
      <span class="Li">&quot;gethostbyname()&quot;</span>.</dd>
  <dt>&quot;Netdb_net_t&quot;</dt>
  <dd>This symbol holds the type used for the 1st argument to
      <span class="Li">&quot;getnetbyaddr()&quot;</span>.</dd>
  <dt>&quot;Off_t&quot;</dt>
  <dd>This symbol holds the type used to declare offsets in the kernel. It can
      be int, long, <span class="Li">&quot;off_t&quot;</span>, etc... It may be
      necessary to include <i>sys/types.h</i> to get any typedef'ed
    information.</dd>
  <dt>&quot;Off_t_size&quot;</dt>
  <dd>This symbol holds the number of bytes used by the
      <span class="Li">&quot;Off_t&quot;</span>.</dd>
  <dt>&quot;Pid_t&quot;</dt>
  <dd>This symbol holds the type used to declare process ids in the kernel. It
      can be int, uint, <span class="Li">&quot;pid_t&quot;</span>, etc... It may
      be necessary to include <i>sys/types.h</i> to get any typedef'ed
      information.</dd>
  <dt>&quot;Rand_seed_t&quot;</dt>
  <dd>This symbol defines the type of the argument of the random seed
    function.</dd>
  <dt>&quot;Select_fd_set_t&quot;</dt>
  <dd>This symbol holds the type used for the 2nd, 3rd, and 4th arguments to
      select. Usually, this is '<span class="Li">&quot;fd_set&quot;</span> *',
      if <span class="Li">&quot;HAS_FD_SET&quot;</span> is defined, and 'int *'
      otherwise. This is only useful if you have
      <span class="Li">&quot;select()&quot;</span>, of course.</dd>
  <dt>&quot;Shmat_t&quot;</dt>
  <dd>This symbol holds the return type of the
      <span class="Li">&quot;shmat()&quot;</span> system call. Usually set to
      'void *' or 'char *'.</dd>
  <dt>&quot;Signal_t&quot;</dt>
  <dd>This symbol's value is either &quot;void&quot; or &quot;int&quot;,
      corresponding to the appropriate return type of a signal handler. Thus,
      you can declare a signal handler using
      &quot;<span class="Li">&quot;Signal_t&quot;</span> (*handler)()&quot;, and
      define the handler using
      &quot;<span class="Li">&quot;Signal_t&quot;</span>
      <span class="Li">&quot;handler(sig)&quot;</span>&quot;.</dd>
  <dt>&quot;Size_t&quot;</dt>
  <dd>This symbol holds the type used to declare length parameters for string
      functions. It is usually <span class="Li">&quot;size_t&quot;</span>, but
      may be unsigned long, int, etc. It may be necessary to include
      <i>sys/types.h</i> to get any typedef'ed information.</dd>
  <dt>&quot;Size_t_size&quot;</dt>
  <dd>This symbol holds the size of a <span class="Li">&quot;Size_t&quot;</span>
      in bytes.</dd>
  <dt>&quot;Sock_size_t&quot;</dt>
  <dd>This symbol holds the type used for the size argument of various socket
      calls (just the base type, not the pointer-to).</dd>
  <dt>&quot;SSize_t&quot;</dt>
  <dd>This symbol holds the type used by functions that return a count of bytes
      or an error condition. It must be a signed type. It is usually
      <span class="Li">&quot;ssize_t&quot;</span>, but may be long or int, etc.
      It may be necessary to include <i>sys/types.h</i> or <i>unistd.h</i> to
      get any typedef'ed information. We will pick a type such that
      <span class="Li">&quot;sizeof(SSize_t)&quot;</span> ==
      <span class="Li">&quot;sizeof(Size_t)&quot;</span>.</dd>
  <dt>&quot;Time_t&quot;</dt>
  <dd>This symbol holds the type returned by
      <span class="Li">&quot;time()&quot;</span>. It can be long, or
      <span class="Li">&quot;time_t&quot;</span> on
      <span class="Li">&quot;BSD&quot;</span> sites (in which case
      <i>sys/types.h</i> should be included).</dd>
  <dt>&quot;Uid_t&quot;</dt>
  <dd>This symbol holds the type used to declare user ids in the kernel. It can
      be int, ushort, <span class="Li">&quot;uid_t&quot;</span>, etc... It may
      be necessary to include <i>sys/types.h</i> to get any typedef'ed
      information.</dd>
  <dt>&quot;Uid_t_f&quot;</dt>
  <dd>This symbol defines the format string used for printing a
      <span class="Li">&quot;Uid_t&quot;</span>.</dd>
  <dt>&quot;Uid_t_sign&quot;</dt>
  <dd>This symbol holds the signedness of a
      <span class="Li">&quot;Uid_t&quot;</span>. 1 for unsigned, -1 for
    signed.</dd>
  <dt>&quot;Uid_t_size&quot;</dt>
  <dd>This symbol holds the size of a <span class="Li">&quot;Uid_t&quot;</span>
      in bytes.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="Unicode_Support"><a class="permalink" href="#Unicode_Support">Unicode
  Support</a></h1>
<p class="Pp">&quot;Unicode Support&quot; in perlguts has an introduction to
    this API.</p>
<p class="Pp">See also <span class="Li">&quot;Character
    classification&quot;</span>, <span class="Li">&quot;Character case
    changing&quot;</span>, and <span class="Li">&quot;String
    Handling&quot;</span>. Various functions outside this section also work
    specially with Unicode. Search for the string &quot;utf8&quot; in this
    document.</p>
<dl class="Bl-tag">
  <dt>&quot;BOM_UTF8&quot;</dt>
  <dd>This is a macro that evaluates to a string constant of the UTF-8 bytes
      that define the Unicode BYTE ORDER MARK (U+FEFF) for the platform that
      perl is compiled on. This allows code to use a mnemonic for this character
      that works on both ASCII and EBCDIC platforms.
      <span class="Li">&quot;sizeof(BOM_UTF8)&#x00A0;-&#x00A0;1&quot;</span> can
      be used to get its length in bytes.</dd>
  <dt>&quot;bytes_cmp_utf8&quot;</dt>
  <dd>Compares the sequence of characters (stored as octets) in
      <span class="Li">&quot;b&quot;</span>,
      <span class="Li">&quot;blen&quot;</span> with the sequence of characters
      (stored as UTF-8) in <span class="Li">&quot;u&quot;</span>,
      <span class="Li">&quot;ulen&quot;</span>. Returns 0 if they are equal, -1
      or -2 if the first string is less than the second string, +1 or +2 if the
      first string is greater than the second string.
    <p class="Pp">-1 or +1 is returned if the shorter string was identical to
        the start of the longer string. -2 or +2 is returned if there was a
        difference between characters within the strings.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> int  bytes_cmp_utf8(const U8 *b, STRLEN blen, const U8 *u,
                     STRLEN ulen)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;bytes_from_utf8&quot;</dt>
  <dd>NOTE: <span class="Li">&quot;bytes_from_utf8&quot;</span> is
      <b>experimental</b> and may change or be removed without notice.
    <p class="Pp">Converts a potentially UTF-8 encoded string
        <span class="Li">&quot;s&quot;</span> of length
        <span class="Li">*lenp</span> into native byte encoding. On input, the
        boolean <span class="Li">*is_utf8p</span> gives whether or not
        <span class="Li">&quot;s&quot;</span> is actually encoded in UTF-8.</p>
    <p class="Pp">Unlike &quot;utf8_to_bytes&quot; but like
        &quot;bytes_to_utf8&quot;, this is non-destructive of the input
      string.</p>
    <p class="Pp">Do nothing if <span class="Li">*is_utf8p</span> is 0, or if
        there are code points in the string not expressible in native byte
        encoding. In these cases, <span class="Li">*is_utf8p</span> and
        <span class="Li">*lenp</span> are unchanged, and the return value is the
        original <span class="Li">&quot;s&quot;</span>.</p>
    <p class="Pp">Otherwise, <span class="Li">*is_utf8p</span> is set to 0, and
        the return value is a pointer to a newly created string containing a
        downgraded copy of <span class="Li">&quot;s&quot;</span>, and whose
        length is returned in <span class="Li">*lenp</span>, updated. The new
        string is <span class="Li">&quot;NUL&quot;</span>-terminated. The caller
        is responsible for arranging for the memory used by this string to get
        freed.</p>
    <p class="Pp">Upon successful return, the number of variants in the string
        can be computed by having saved the value of
        <span class="Li">*lenp</span> before the call, and subtracting the
        after-call value of <span class="Li">*lenp</span> from it.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> U8*  bytes_from_utf8(const U8 *s, STRLEN *lenp, bool *is_utf8p)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;bytes_to_utf8&quot;</dt>
  <dd>NOTE: <span class="Li">&quot;bytes_to_utf8&quot;</span> is
      <b>experimental</b> and may change or be removed without notice.
    <p class="Pp">Converts a string <span class="Li">&quot;s&quot;</span> of
        length <span class="Li">*lenp</span> bytes from the native encoding into
        UTF-8. Returns a pointer to the newly-created string, and sets
        <span class="Li">*lenp</span> to reflect the new length in bytes. The
        caller is responsible for arranging for the memory used by this string
        to get freed.</p>
    <p class="Pp">Upon successful return, the number of variants in the string
        can be computed by having saved the value of
        <span class="Li">*lenp</span> before the call, and subtracting it from
        the after-call value of <span class="Li">*lenp</span>.</p>
    <p class="Pp">A <span class="Li">&quot;NUL&quot;</span> character will be
        written after the end of the string.</p>
    <p class="Pp">If you want to convert to UTF-8 from encodings other than the
        native (Latin1 or EBCDIC), see &quot;sv_recode_to_utf8&quot;().</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> U8*  bytes_to_utf8(const U8 *s, STRLEN *lenp)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;DO_UTF8&quot;</dt>
  <dd>Returns a bool giving whether or not the PV in
      <span class="Li">&quot;sv&quot;</span> is to be treated as being encoded
      in UTF-8.
    <p class="Pp">You should use this <i>after</i> a call to
        <span class="Li">&quot;SvPV()&quot;</span> or one of its variants, in
        case any call to string overloading updates the internal UTF-8 encoding
        flag.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> bool  DO_UTF8(SV* sv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;foldEQ_utf8&quot;</dt>
  <dd>Returns true if the leading portions of the strings
      <span class="Li">&quot;s1&quot;</span> and
      <span class="Li">&quot;s2&quot;</span> (either or both of which may be in
      UTF-8) are the same case-insensitively; false otherwise. How far into the
      strings to compare is determined by other input parameters.
    <p class="Pp">If <span class="Li">&quot;u1&quot;</span> is true, the string
        <span class="Li">&quot;s1&quot;</span> is assumed to be in UTF-8-encoded
        Unicode; otherwise it is assumed to be in native 8-bit encoding.
        Correspondingly for <span class="Li">&quot;u2&quot;</span> with respect
        to <span class="Li">&quot;s2&quot;</span>.</p>
    <p class="Pp">If the byte length <span class="Li">&quot;l1&quot;</span> is
        non-zero, it says how far into <span class="Li">&quot;s1&quot;</span> to
        check for fold equality. In other words,
        <span class="Li">&quot;s1&quot;</span>+<span class="Li">&quot;l1&quot;</span>
        will be used as a goal to reach. The scan will not be considered to be a
        match unless the goal is reached, and scanning won't continue past that
        goal. Correspondingly for <span class="Li">&quot;l2&quot;</span> with
        respect to <span class="Li">&quot;s2&quot;</span>.</p>
    <p class="Pp">If <span class="Li">&quot;pe1&quot;</span> is
        non-<span class="Li">&quot;NULL&quot;</span> and the pointer it points
        to is not <span class="Li">&quot;NULL&quot;</span>, that pointer is
        considered an end pointer to the position 1 byte past the maximum point
        in <span class="Li">&quot;s1&quot;</span> beyond which scanning will not
        continue under any circumstances. (This routine assumes that UTF-8
        encoded input strings are not malformed; malformed input can cause it to
        read past <span class="Li">&quot;pe1&quot;</span>). This means that if
        both <span class="Li">&quot;l1&quot;</span> and
        <span class="Li">&quot;pe1&quot;</span> are specified, and
        <span class="Li">&quot;pe1&quot;</span> is less than
        <span class="Li">&quot;s1&quot;</span>+<span class="Li">&quot;l1&quot;</span>,
        the match will never be successful because it can never get as far as
        its goal (and in fact is asserted against). Correspondingly for
        <span class="Li">&quot;pe2&quot;</span> with respect to
        <span class="Li">&quot;s2&quot;</span>.</p>
    <p class="Pp">At least one of <span class="Li">&quot;s1&quot;</span> and
        <span class="Li">&quot;s2&quot;</span> must have a goal (at least one of
        <span class="Li">&quot;l1&quot;</span> and
        <span class="Li">&quot;l2&quot;</span> must be non-zero), and if both
        do, both have to be reached for a successful match. Also, if the fold of
        a character is multiple characters, all of them must be matched (see
        tr21 reference below for 'folding').</p>
    <p class="Pp">Upon a successful match, if
        <span class="Li">&quot;pe1&quot;</span> is
        non-<span class="Li">&quot;NULL&quot;</span>, it will be set to point to
        the beginning of the <i>next</i> character of
        <span class="Li">&quot;s1&quot;</span> beyond what was matched.
        Correspondingly for <span class="Li">&quot;pe2&quot;</span> and
        <span class="Li">&quot;s2&quot;</span>.</p>
    <p class="Pp">For case-insensitiveness, the &quot;casefolding&quot; of
        Unicode is used instead of upper/lowercasing both the characters, see
        &lt;https://www.unicode.org/unicode/reports/tr21/&gt; (Case
      Mappings).</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> I32  foldEQ_utf8(const char *s1, char **pe1, UV l1, bool u1,
                  const char *s2, char **pe2, UV l2, bool u2)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;is_ascii_string&quot;</dt>
  <dd>This is a misleadingly-named synonym for
      &quot;is_utf8_invariant_string&quot;. On ASCII-ish platforms, the name
      isn't misleading: the ASCII-range characters are exactly the UTF-8
      invariants. But EBCDIC machines have more invariants than just the ASCII
      characters, so
      <span class="Li">&quot;is_utf8_invariant_string&quot;</span> is
    preferred.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> bool  is_ascii_string(const U8* const s, STRLEN len)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;is_c9strict_utf8_string&quot;</dt>
  <dd>Returns TRUE if the first <span class="Li">&quot;len&quot;</span> bytes of
      string <span class="Li">&quot;s&quot;</span> form a valid UTF-8-encoded
      string that conforms to Unicode Corrigendum #9
      &lt;http://www.unicode.org/versions/corrigendum9.html&gt;; otherwise it
      returns FALSE. If <span class="Li">&quot;len&quot;</span> is 0, it will be
      calculated using <span class="Li">strlen(s)</span> (which means if you use
      this option, that <span class="Li">&quot;s&quot;</span> can't have
      embedded <span class="Li">&quot;NUL&quot;</span> characters and has to
      have a terminating <span class="Li">&quot;NUL&quot;</span> byte). Note
      that all characters being ASCII constitute 'a valid UTF-8 string'.
    <p class="Pp">This function returns FALSE for strings containing any code
        points above the Unicode max of 0x10FFFF or surrogate code points, but
        accepts non-character code points per Corrigendum #9
        &lt;http://www.unicode.org/versions/corrigendum9.html&gt;.</p>
    <p class="Pp">See also
        <span class="Li">&quot;is_utf8_invariant_string&quot;</span>,
        <span class="Li">&quot;is_utf8_invariant_string_loc&quot;</span>,
        <span class="Li">&quot;is_utf8_string&quot;</span>,
        <span class="Li">&quot;is_utf8_string_flags&quot;</span>,
        <span class="Li">&quot;is_utf8_string_loc&quot;</span>,
        <span class="Li">&quot;is_utf8_string_loc_flags&quot;</span>,
        <span class="Li">&quot;is_utf8_string_loclen&quot;</span>,
        <span class="Li">&quot;is_utf8_string_loclen_flags&quot;</span>,
        <span class="Li">&quot;is_utf8_fixed_width_buf_flags&quot;</span>,
        <span class="Li">&quot;is_utf8_fixed_width_buf_loc_flags&quot;</span>,
        <span class="Li">&quot;is_utf8_fixed_width_buf_loclen_flags&quot;</span>,
        <span class="Li">&quot;is_strict_utf8_string&quot;</span>,
        <span class="Li">&quot;is_strict_utf8_string_loc&quot;</span>,
        <span class="Li">&quot;is_strict_utf8_string_loclen&quot;</span>,
        <span class="Li">&quot;is_c9strict_utf8_string_loc&quot;</span>, and
        <span class="Li">&quot;is_c9strict_utf8_string_loclen&quot;</span>.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> bool  is_c9strict_utf8_string(const U8 *s, STRLEN len)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;is_c9strict_utf8_string_loc&quot;</dt>
  <dd>Like <span class="Li">&quot;is_c9strict_utf8_string&quot;</span> but
      stores the location of the failure (in the case of &quot;utf8ness
      failure&quot;) or the location
      <span class="Li">&quot;s&quot;</span>+<span class="Li">&quot;len&quot;</span>
      (in the case of &quot;utf8ness success&quot;) in the
      <span class="Li">&quot;ep&quot;</span> pointer.
    <p class="Pp">See also
        <span class="Li">&quot;is_c9strict_utf8_string_loclen&quot;</span>.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> bool  is_c9strict_utf8_string_loc(const U8 *s, STRLEN len,
                                   const U8 **ep)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;is_c9strict_utf8_string_loclen&quot;</dt>
  <dd>Like <span class="Li">&quot;is_c9strict_utf8_string&quot;</span> but
      stores the location of the failure (in the case of &quot;utf8ness
      failure&quot;) or the location
      <span class="Li">&quot;s&quot;</span>+<span class="Li">&quot;len&quot;</span>
      (in the case of &quot;utf8ness success&quot;) in the
      <span class="Li">&quot;ep&quot;</span> pointer, and the number of UTF-8
      encoded characters in the <span class="Li">&quot;el&quot;</span> pointer.
    <p class="Pp">See also
        <span class="Li">&quot;is_c9strict_utf8_string_loc&quot;</span>.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> bool  is_c9strict_utf8_string_loclen(const U8 *s, STRLEN len,
                                      const U8 **ep, STRLEN *el)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;isC9_STRICT_UTF8_CHAR&quot;</dt>
  <dd>Evaluates to non-zero if the first few bytes of the string starting at
      <span class="Li">&quot;s&quot;</span> and looking no further than
      <span class="Li">&quot;e&#x00A0;-&#x00A0;1&quot;</span> are well-formed
      UTF-8 that represents some Unicode non-surrogate code point; otherwise it
      evaluates to 0. If non-zero, the value gives how many bytes starting at
      <span class="Li">&quot;s&quot;</span> comprise the code point's
      representation. Any bytes remaining before
      <span class="Li">&quot;e&quot;</span>, but beyond the ones needed to form
      the first code point in <span class="Li">&quot;s&quot;</span>, are not
      examined.
    <p class="Pp">The largest acceptable code point is the Unicode maximum
        0x10FFFF. This differs from
        <span class="Li">&quot;isSTRICT_UTF8_CHAR&quot;</span> only in that it
        accepts non-character code points. This corresponds to Unicode
        Corrigendum #9
        &lt;http://www.unicode.org/versions/corrigendum9.html&gt;. which said
        that non-character code points are merely discouraged rather than
        completely forbidden in open interchange. See &quot;Noncharacter code
        points&quot; in perlunicode.</p>
    <p class="Pp">Use <span class="Li">&quot;isUTF8_CHAR&quot;</span> to check
        for Perl's extended UTF-8; and
        <span class="Li">&quot;isUTF8_CHAR_flags&quot;</span> for a more
        customized definition.</p>
    <p class="Pp">Use
        <span class="Li">&quot;is_c9strict_utf8_string&quot;</span>,
        <span class="Li">&quot;is_c9strict_utf8_string_loc&quot;</span>, and
        <span class="Li">&quot;is_c9strict_utf8_string_loclen&quot;</span> to
        check entire strings.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> Size_t  isC9_STRICT_UTF8_CHAR(const U8 * const s0,
                               const U8 * const e)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;is_invariant_string&quot;</dt>
  <dd>This is a somewhat misleadingly-named synonym for
      &quot;is_utf8_invariant_string&quot;.
      <span class="Li">&quot;is_utf8_invariant_string&quot;</span> is preferred,
      as it indicates under what conditions the string is invariant.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> bool  is_invariant_string(const U8* const s, STRLEN len)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;isSTRICT_UTF8_CHAR&quot;</dt>
  <dd>Evaluates to non-zero if the first few bytes of the string starting at
      <span class="Li">&quot;s&quot;</span> and looking no further than
      <span class="Li">&quot;e&#x00A0;-&#x00A0;1&quot;</span> are well-formed
      UTF-8 that represents some Unicode code point completely acceptable for
      open interchange between all applications; otherwise it evaluates to 0. If
      non-zero, the value gives how many bytes starting at
      <span class="Li">&quot;s&quot;</span> comprise the code point's
      representation. Any bytes remaining before
      <span class="Li">&quot;e&quot;</span>, but beyond the ones needed to form
      the first code point in <span class="Li">&quot;s&quot;</span>, are not
      examined.
    <p class="Pp">The largest acceptable code point is the Unicode maximum
        0x10FFFF, and must not be a surrogate nor a non-character code point.
        Thus this excludes any code point from Perl's extended UTF-8.</p>
    <p class="Pp">This is used to efficiently decide if the next few bytes in
        <span class="Li">&quot;s&quot;</span> is legal Unicode-acceptable UTF-8
        for a single character.</p>
    <p class="Pp">Use <span class="Li">&quot;isC9_STRICT_UTF8_CHAR&quot;</span>
        to use the Unicode Corrigendum #9
        &lt;http://www.unicode.org/versions/corrigendum9.html&gt; definition of
        allowable code points; <span class="Li">&quot;isUTF8_CHAR&quot;</span>
        to check for Perl's extended UTF-8; and
        <span class="Li">&quot;isUTF8_CHAR_flags&quot;</span> for a more
        customized definition.</p>
    <p class="Pp">Use <span class="Li">&quot;is_strict_utf8_string&quot;</span>,
        <span class="Li">&quot;is_strict_utf8_string_loc&quot;</span>, and
        <span class="Li">&quot;is_strict_utf8_string_loclen&quot;</span> to
        check entire strings.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> Size_t  isSTRICT_UTF8_CHAR(const U8 * const s0,
                            const U8 * const e)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;is_strict_utf8_string&quot;</dt>
  <dd>Returns TRUE if the first <span class="Li">&quot;len&quot;</span> bytes of
      string <span class="Li">&quot;s&quot;</span> form a valid UTF-8-encoded
      string that is fully interchangeable by any application using Unicode
      rules; otherwise it returns FALSE. If
      <span class="Li">&quot;len&quot;</span> is 0, it will be calculated using
      <span class="Li">strlen(s)</span> (which means if you use this option,
      that <span class="Li">&quot;s&quot;</span> can't have embedded
      <span class="Li">&quot;NUL&quot;</span> characters and has to have a
      terminating <span class="Li">&quot;NUL&quot;</span> byte). Note that all
      characters being ASCII constitute 'a valid UTF-8 string'.
    <p class="Pp">This function returns FALSE for strings containing any code
        points above the Unicode max of 0x10FFFF, surrogate code points, or
        non-character code points.</p>
    <p class="Pp">See also
        <span class="Li">&quot;is_utf8_invariant_string&quot;</span>,
        <span class="Li">&quot;is_utf8_invariant_string_loc&quot;</span>,
        <span class="Li">&quot;is_utf8_string&quot;</span>,
        <span class="Li">&quot;is_utf8_string_flags&quot;</span>,
        <span class="Li">&quot;is_utf8_string_loc&quot;</span>,
        <span class="Li">&quot;is_utf8_string_loc_flags&quot;</span>,
        <span class="Li">&quot;is_utf8_string_loclen&quot;</span>,
        <span class="Li">&quot;is_utf8_string_loclen_flags&quot;</span>,
        <span class="Li">&quot;is_utf8_fixed_width_buf_flags&quot;</span>,
        <span class="Li">&quot;is_utf8_fixed_width_buf_loc_flags&quot;</span>,
        <span class="Li">&quot;is_utf8_fixed_width_buf_loclen_flags&quot;</span>,
        <span class="Li">&quot;is_strict_utf8_string_loc&quot;</span>,
        <span class="Li">&quot;is_strict_utf8_string_loclen&quot;</span>,
        <span class="Li">&quot;is_c9strict_utf8_string&quot;</span>,
        <span class="Li">&quot;is_c9strict_utf8_string_loc&quot;</span>, and
        <span class="Li">&quot;is_c9strict_utf8_string_loclen&quot;</span>.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> bool  is_strict_utf8_string(const U8 *s, STRLEN len)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;is_strict_utf8_string_loc&quot;</dt>
  <dd>Like <span class="Li">&quot;is_strict_utf8_string&quot;</span> but stores
      the location of the failure (in the case of &quot;utf8ness failure&quot;)
      or the location
      <span class="Li">&quot;s&quot;</span>+<span class="Li">&quot;len&quot;</span>
      (in the case of &quot;utf8ness success&quot;) in the
      <span class="Li">&quot;ep&quot;</span> pointer.
    <p class="Pp">See also
        <span class="Li">&quot;is_strict_utf8_string_loclen&quot;</span>.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> bool  is_strict_utf8_string_loc(const U8 *s, STRLEN len,
                                 const U8 **ep)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;is_strict_utf8_string_loclen&quot;</dt>
  <dd>Like <span class="Li">&quot;is_strict_utf8_string&quot;</span> but stores
      the location of the failure (in the case of &quot;utf8ness failure&quot;)
      or the location
      <span class="Li">&quot;s&quot;</span>+<span class="Li">&quot;len&quot;</span>
      (in the case of &quot;utf8ness success&quot;) in the
      <span class="Li">&quot;ep&quot;</span> pointer, and the number of UTF-8
      encoded characters in the <span class="Li">&quot;el&quot;</span> pointer.
    <p class="Pp">See also
        <span class="Li">&quot;is_strict_utf8_string_loc&quot;</span>.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> bool  is_strict_utf8_string_loclen(const U8 *s, STRLEN len,
                                    const U8 **ep, STRLEN *el)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;is_utf8_char&quot;</dt>
  <dd><span class="Li">&quot;</span><span class="Li"><b>DEPRECATED!</b></span><span class="Li">&quot;</span>
      It is planned to remove <span class="Li">&quot;is_utf8_char&quot;</span>
      from a future release of Perl. Do not use it for new code; remove it from
      existing code.
    <p class="Pp">Tests if some arbitrary number of bytes begins in a valid
        UTF-8 character. Note that an INVARIANT (i.e. ASCII on non-EBCDIC
        machines) character is a valid UTF-8 character. The actual number of
        bytes in the UTF-8 character will be returned if it is valid, otherwise
        0.</p>
    <p class="Pp">This function is deprecated due to the possibility that
        malformed input could cause reading beyond the end of the input buffer.
        Use &quot;isUTF8_CHAR&quot; instead.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> STRLEN  is_utf8_char(const U8 *s)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;is_utf8_char_buf&quot;</dt>
  <dd>This is identical to the macro &quot;isUTF8_CHAR&quot; in perlapi.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> STRLEN  is_utf8_char_buf(const U8 *buf, const U8 *buf_end)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;is_utf8_fixed_width_buf_flags&quot;</dt>
  <dd>Returns TRUE if the fixed-width buffer starting at
      <span class="Li">&quot;s&quot;</span> with length
      <span class="Li">&quot;len&quot;</span> is entirely valid UTF-8, subject
      to the restrictions given by <span class="Li">&quot;flags&quot;</span>;
      otherwise it returns FALSE.
    <p class="Pp">If <span class="Li">&quot;flags&quot;</span> is 0, any
        well-formed UTF-8, as extended by Perl, is accepted without restriction.
        If the final few bytes of the buffer do not form a complete code point,
        this will return TRUE anyway, provided that
        <span class="Li">&quot;is_utf8_valid_partial_char_flags&quot;</span>
        returns TRUE for them.</p>
    <p class="Pp">If <span class="Li">&quot;flags&quot;</span> in non-zero, it
        can be any combination of the
        <span class="Li">&quot;UTF8_DISALLOW_</span><span class="Li"><i>foo</i></span><span class="Li">&quot;</span>
        flags accepted by <span class="Li">&quot;utf8n_to_uvchr&quot;</span>,
        and with the same meanings.</p>
    <p class="Pp">This function differs from
        <span class="Li">&quot;is_utf8_string_flags&quot;</span> only in that
        the latter returns FALSE if the final few bytes of the string don't form
        a complete code point.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> bool  is_utf8_fixed_width_buf_flags(const U8 * const s,
                                     STRLEN len, const U32 flags)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;is_utf8_fixed_width_buf_loclen_flags&quot;</dt>
  <dd>Like <span class="Li">&quot;is_utf8_fixed_width_buf_loc_flags&quot;</span>
      but stores the number of complete, valid characters found in the
      <span class="Li">&quot;el&quot;</span> pointer.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> bool  is_utf8_fixed_width_buf_loclen_flags(const U8 * const s,
                                            STRLEN len,
                                            const U8 **ep,
                                            STRLEN *el,
                                            const U32 flags)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;is_utf8_fixed_width_buf_loc_flags&quot;</dt>
  <dd>Like <span class="Li">&quot;is_utf8_fixed_width_buf_flags&quot;</span> but
      stores the location of the failure in the
      <span class="Li">&quot;ep&quot;</span> pointer. If the function returns
      TRUE, <span class="Li">*ep</span> will point to the beginning of any
      partial character at the end of the buffer; if there is no partial
      character <span class="Li">*ep</span> will contain
      <span class="Li">&quot;s&quot;</span>+<span class="Li">&quot;len&quot;</span>.
    <p class="Pp">See also
        <span class="Li">&quot;is_utf8_fixed_width_buf_loclen_flags&quot;</span>.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> bool  is_utf8_fixed_width_buf_loc_flags(const U8 * const s,
                                         STRLEN len, const U8 **ep,
                                         const U32 flags)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;is_utf8_invariant_string&quot;</dt>
  <dd>Returns TRUE if the first <span class="Li">&quot;len&quot;</span> bytes of
      the string <span class="Li">&quot;s&quot;</span> are the same regardless
      of the UTF-8 encoding of the string (or UTF-EBCDIC encoding on EBCDIC
      machines); otherwise it returns FALSE. That is, it returns TRUE if they
      are UTF-8 invariant. On ASCII-ish machines, all the ASCII characters and
      only the ASCII characters fit this definition. On EBCDIC machines, the
      ASCII-range characters are invariant, but so also are the C1 controls.
    <p class="Pp">If <span class="Li">&quot;len&quot;</span> is 0, it will be
        calculated using <span class="Li">strlen(s)</span>, (which means if you
        use this option, that <span class="Li">&quot;s&quot;</span> can't have
        embedded <span class="Li">&quot;NUL&quot;</span> characters and has to
        have a terminating <span class="Li">&quot;NUL&quot;</span> byte).</p>
    <p class="Pp">See also <span class="Li">&quot;is_utf8_string&quot;</span>,
        <span class="Li">&quot;is_utf8_string_flags&quot;</span>,
        <span class="Li">&quot;is_utf8_string_loc&quot;</span>,
        <span class="Li">&quot;is_utf8_string_loc_flags&quot;</span>,
        <span class="Li">&quot;is_utf8_string_loclen&quot;</span>,
        <span class="Li">&quot;is_utf8_string_loclen_flags&quot;</span>,
        <span class="Li">&quot;is_utf8_fixed_width_buf_flags&quot;</span>,
        <span class="Li">&quot;is_utf8_fixed_width_buf_loc_flags&quot;</span>,
        <span class="Li">&quot;is_utf8_fixed_width_buf_loclen_flags&quot;</span>,
        <span class="Li">&quot;is_strict_utf8_string&quot;</span>,
        <span class="Li">&quot;is_strict_utf8_string_loc&quot;</span>,
        <span class="Li">&quot;is_strict_utf8_string_loclen&quot;</span>,
        <span class="Li">&quot;is_c9strict_utf8_string&quot;</span>,
        <span class="Li">&quot;is_c9strict_utf8_string_loc&quot;</span>, and
        <span class="Li">&quot;is_c9strict_utf8_string_loclen&quot;</span>.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> bool  is_utf8_invariant_string(const U8* const s, STRLEN len)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;is_utf8_invariant_string_loc&quot;</dt>
  <dd>Like <span class="Li">&quot;is_utf8_invariant_string&quot;</span> but upon
      failure, stores the location of the first UTF-8 variant character in the
      <span class="Li">&quot;ep&quot;</span> pointer; if all characters are
      UTF-8 invariant, this function does not change the contents of
      <span class="Li">*ep</span>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> bool  is_utf8_invariant_string_loc(const U8* const s, STRLEN len,
                                    const U8 ** ep)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;is_utf8_string&quot;</dt>
  <dd>Returns TRUE if the first <span class="Li">&quot;len&quot;</span> bytes of
      string <span class="Li">&quot;s&quot;</span> form a valid
      Perl-extended-UTF-8 string; returns FALSE otherwise. If
      <span class="Li">&quot;len&quot;</span> is 0, it will be calculated using
      <span class="Li">strlen(s)</span> (which means if you use this option,
      that <span class="Li">&quot;s&quot;</span> can't have embedded
      <span class="Li">&quot;NUL&quot;</span> characters and has to have a
      terminating <span class="Li">&quot;NUL&quot;</span> byte). Note that all
      characters being ASCII constitute 'a valid UTF-8 string'.
    <p class="Pp">This function considers Perl's extended UTF-8 to be valid.
        That means that code points above Unicode, surrogates, and non-character
        code points are considered valid by this function. Use
        <span class="Li">&quot;is_strict_utf8_string&quot;</span>,
        <span class="Li">&quot;is_c9strict_utf8_string&quot;</span>, or
        <span class="Li">&quot;is_utf8_string_flags&quot;</span> to restrict
        what code points are considered valid.</p>
    <p class="Pp">See also
        <span class="Li">&quot;is_utf8_invariant_string&quot;</span>,
        <span class="Li">&quot;is_utf8_invariant_string_loc&quot;</span>,
        <span class="Li">&quot;is_utf8_string_loc&quot;</span>,
        <span class="Li">&quot;is_utf8_string_loclen&quot;</span>,
        <span class="Li">&quot;is_utf8_fixed_width_buf_flags&quot;</span>,
        <span class="Li">&quot;is_utf8_fixed_width_buf_loc_flags&quot;</span>,
        <span class="Li">&quot;is_utf8_fixed_width_buf_loclen_flags&quot;</span>,</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> bool  is_utf8_string(const U8 *s, STRLEN len)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;is_utf8_string_flags&quot;</dt>
  <dd>Returns TRUE if the first <span class="Li">&quot;len&quot;</span> bytes of
      string <span class="Li">&quot;s&quot;</span> form a valid UTF-8 string,
      subject to the restrictions imposed by
      <span class="Li">&quot;flags&quot;</span>; returns FALSE otherwise. If
      <span class="Li">&quot;len&quot;</span> is 0, it will be calculated using
      <span class="Li">strlen(s)</span> (which means if you use this option,
      that <span class="Li">&quot;s&quot;</span> can't have embedded
      <span class="Li">&quot;NUL&quot;</span> characters and has to have a
      terminating <span class="Li">&quot;NUL&quot;</span> byte). Note that all
      characters being ASCII constitute 'a valid UTF-8 string'.
    <p class="Pp">If <span class="Li">&quot;flags&quot;</span> is 0, this gives
        the same results as <span class="Li">&quot;is_utf8_string&quot;</span>;
        if <span class="Li">&quot;flags&quot;</span> is
        <span class="Li">&quot;UTF8_DISALLOW_ILLEGAL_INTERCHANGE&quot;</span>,
        this gives the same results as
        <span class="Li">&quot;is_strict_utf8_string&quot;</span>; and if
        <span class="Li">&quot;flags&quot;</span> is
        <span class="Li">&quot;UTF8_DISALLOW_ILLEGAL_C9_INTERCHANGE&quot;</span>,
        this gives the same results as
        <span class="Li">&quot;is_c9strict_utf8_string&quot;</span>. Otherwise
        <span class="Li">&quot;flags&quot;</span> may be any combination of the
        <span class="Li">&quot;UTF8_DISALLOW_</span><span class="Li"><i>foo</i></span><span class="Li">&quot;</span>
        flags understood by <span class="Li">&quot;utf8n_to_uvchr&quot;</span>,
        with the same meanings.</p>
    <p class="Pp">See also
        <span class="Li">&quot;is_utf8_invariant_string&quot;</span>,
        <span class="Li">&quot;is_utf8_invariant_string_loc&quot;</span>,
        <span class="Li">&quot;is_utf8_string&quot;</span>,
        <span class="Li">&quot;is_utf8_string_loc&quot;</span>,
        <span class="Li">&quot;is_utf8_string_loc_flags&quot;</span>,
        <span class="Li">&quot;is_utf8_string_loclen&quot;</span>,
        <span class="Li">&quot;is_utf8_string_loclen_flags&quot;</span>,
        <span class="Li">&quot;is_utf8_fixed_width_buf_flags&quot;</span>,
        <span class="Li">&quot;is_utf8_fixed_width_buf_loc_flags&quot;</span>,
        <span class="Li">&quot;is_utf8_fixed_width_buf_loclen_flags&quot;</span>,
        <span class="Li">&quot;is_strict_utf8_string&quot;</span>,
        <span class="Li">&quot;is_strict_utf8_string_loc&quot;</span>,
        <span class="Li">&quot;is_strict_utf8_string_loclen&quot;</span>,
        <span class="Li">&quot;is_c9strict_utf8_string&quot;</span>,
        <span class="Li">&quot;is_c9strict_utf8_string_loc&quot;</span>, and
        <span class="Li">&quot;is_c9strict_utf8_string_loclen&quot;</span>.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> bool  is_utf8_string_flags(const U8 *s, STRLEN len,
                            const U32 flags)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;is_utf8_string_loc&quot;</dt>
  <dd>Like <span class="Li">&quot;is_utf8_string&quot;</span> but stores the
      location of the failure (in the case of &quot;utf8ness failure&quot;) or
      the location
      <span class="Li">&quot;s&quot;</span>+<span class="Li">&quot;len&quot;</span>
      (in the case of &quot;utf8ness success&quot;) in the
      <span class="Li">&quot;ep&quot;</span> pointer.
    <p class="Pp">See also
        <span class="Li">&quot;is_utf8_string_loclen&quot;</span>.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> bool  is_utf8_string_loc(const U8 *s, const STRLEN len,
                          const U8 **ep)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;is_utf8_string_loclen&quot;</dt>
  <dd>Like <span class="Li">&quot;is_utf8_string&quot;</span> but stores the
      location of the failure (in the case of &quot;utf8ness failure&quot;) or
      the location
      <span class="Li">&quot;s&quot;</span>+<span class="Li">&quot;len&quot;</span>
      (in the case of &quot;utf8ness success&quot;) in the
      <span class="Li">&quot;ep&quot;</span> pointer, and the number of UTF-8
      encoded characters in the <span class="Li">&quot;el&quot;</span> pointer.
    <p class="Pp">See also
        <span class="Li">&quot;is_utf8_string_loc&quot;</span>.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> bool  is_utf8_string_loclen(const U8 *s, STRLEN len,
                             const U8 **ep, STRLEN *el)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;is_utf8_string_loclen_flags&quot;</dt>
  <dd>Like <span class="Li">&quot;is_utf8_string_flags&quot;</span> but stores
      the location of the failure (in the case of &quot;utf8ness failure&quot;)
      or the location
      <span class="Li">&quot;s&quot;</span>+<span class="Li">&quot;len&quot;</span>
      (in the case of &quot;utf8ness success&quot;) in the
      <span class="Li">&quot;ep&quot;</span> pointer, and the number of UTF-8
      encoded characters in the <span class="Li">&quot;el&quot;</span> pointer.
    <p class="Pp">See also
        <span class="Li">&quot;is_utf8_string_loc_flags&quot;</span>.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> bool  is_utf8_string_loclen_flags(const U8 *s, STRLEN len,
                                   const U8 **ep, STRLEN *el,
                                   const U32 flags)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;is_utf8_string_loc_flags&quot;</dt>
  <dd>Like <span class="Li">&quot;is_utf8_string_flags&quot;</span> but stores
      the location of the failure (in the case of &quot;utf8ness failure&quot;)
      or the location
      <span class="Li">&quot;s&quot;</span>+<span class="Li">&quot;len&quot;</span>
      (in the case of &quot;utf8ness success&quot;) in the
      <span class="Li">&quot;ep&quot;</span> pointer.
    <p class="Pp">See also
        <span class="Li">&quot;is_utf8_string_loclen_flags&quot;</span>.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> bool  is_utf8_string_loc_flags(const U8 *s, STRLEN len,
                                const U8 **ep, const U32 flags)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;is_utf8_valid_partial_char&quot;</dt>
  <dd>Returns 0 if the sequence of bytes starting at
      <span class="Li">&quot;s&quot;</span> and looking no further than
      <span class="Li">&quot;e&#x00A0;-&#x00A0;1&quot;</span> is the UTF-8
      encoding, as extended by Perl, for one or more code points. Otherwise, it
      returns 1 if there exists at least one non-empty sequence of bytes that
      when appended to sequence <span class="Li">&quot;s&quot;</span>, starting
      at position <span class="Li">&quot;e&quot;</span> causes the entire
      sequence to be the well-formed UTF-8 of some code point; otherwise returns
      0.
    <p class="Pp">In other words this returns TRUE if
        <span class="Li">&quot;s&quot;</span> points to a partial UTF-8-encoded
        code point.</p>
    <p class="Pp">This is useful when a fixed-length buffer is being tested for
        being well-formed UTF-8, but the final few bytes in it don't comprise a
        full character; that is, it is split somewhere in the middle of the
        final code point's UTF-8 representation. (Presumably when the buffer is
        refreshed with the next chunk of data, the new first bytes will complete
        the partial code point.) This function is used to verify that the final
        bytes in the current buffer are in fact the legal beginning of some code
        point, so that if they aren't, the failure can be signalled without
        having to wait for the next read.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> bool  is_utf8_valid_partial_char(const U8 * const s,
                                  const U8 * const e)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;is_utf8_valid_partial_char_flags&quot;</dt>
  <dd>Like <span class="Li">&quot;is_utf8_valid_partial_char&quot;</span>, it
      returns a boolean giving whether or not the input is a valid UTF-8 encoded
      partial character, but it takes an extra parameter,
      <span class="Li">&quot;flags&quot;</span>, which can further restrict
      which code points are considered valid.
    <p class="Pp">If <span class="Li">&quot;flags&quot;</span> is 0, this
        behaves identically to
        <span class="Li">&quot;is_utf8_valid_partial_char&quot;</span>.
        Otherwise <span class="Li">&quot;flags&quot;</span> can be any
        combination of the
        <span class="Li">&quot;UTF8_DISALLOW_</span><span class="Li"><i>foo</i></span><span class="Li">&quot;</span>
        flags accepted by <span class="Li">&quot;utf8n_to_uvchr&quot;</span>. If
        there is any sequence of bytes that can complete the input partial
        character in such a way that a non-prohibited character is formed, the
        function returns TRUE; otherwise FALSE. Non character code points cannot
        be determined based on partial character input. But many of the other
        possible excluded types can be determined from just the first one or two
        bytes.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> bool  is_utf8_valid_partial_char_flags(const U8 * const s,
                                        const U8 * const e,
                                        const U32 flags)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;isUTF8_CHAR&quot;</dt>
  <dd>Evaluates to non-zero if the first few bytes of the string starting at
      <span class="Li">&quot;s&quot;</span> and looking no further than
      <span class="Li">&quot;e&#x00A0;-&#x00A0;1&quot;</span> are well-formed
      UTF-8, as extended by Perl, that represents some code point; otherwise it
      evaluates to 0. If non-zero, the value gives how many bytes starting at
      <span class="Li">&quot;s&quot;</span> comprise the code point's
      representation. Any bytes remaining before
      <span class="Li">&quot;e&quot;</span>, but beyond the ones needed to form
      the first code point in <span class="Li">&quot;s&quot;</span>, are not
      examined.
    <p class="Pp">The code point can be any that will fit in an IV on this
        machine, using Perl's extension to official UTF-8 to represent those
        higher than the Unicode maximum of 0x10FFFF. That means that this macro
        is used to efficiently decide if the next few bytes in
        <span class="Li">&quot;s&quot;</span> is legal UTF-8 for a single
        character.</p>
    <p class="Pp">Use <span class="Li">&quot;isSTRICT_UTF8_CHAR&quot;</span> to
        restrict the acceptable code points to those defined by Unicode to be
        fully interchangeable across applications;
        <span class="Li">&quot;isC9_STRICT_UTF8_CHAR&quot;</span> to use the
        Unicode Corrigendum #9
        &lt;http://www.unicode.org/versions/corrigendum9.html&gt; definition of
        allowable code points; and
        <span class="Li">&quot;isUTF8_CHAR_flags&quot;</span> for a more
        customized definition.</p>
    <p class="Pp">Use <span class="Li">&quot;is_utf8_string&quot;</span>,
        <span class="Li">&quot;is_utf8_string_loc&quot;</span>, and
        <span class="Li">&quot;is_utf8_string_loclen&quot;</span> to check
        entire strings.</p>
    <p class="Pp">Note also that a UTF-8 &quot;invariant&quot; character (i.e.
        ASCII on non-EBCDIC machines) is a valid UTF-8 character.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> Size_t  isUTF8_CHAR(const U8 * const s0, const U8 * const e)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;isUTF8_CHAR_flags&quot;</dt>
  <dd>Evaluates to non-zero if the first few bytes of the string starting at
      <span class="Li">&quot;s&quot;</span> and looking no further than
      <span class="Li">&quot;e&#x00A0;-&#x00A0;1&quot;</span> are well-formed
      UTF-8, as extended by Perl, that represents some code point, subject to
      the restrictions given by <span class="Li">&quot;flags&quot;</span>;
      otherwise it evaluates to 0. If non-zero, the value gives how many bytes
      starting at <span class="Li">&quot;s&quot;</span> comprise the code
      point's representation. Any bytes remaining before
      <span class="Li">&quot;e&quot;</span>, but beyond the ones needed to form
      the first code point in <span class="Li">&quot;s&quot;</span>, are not
      examined.
    <p class="Pp">If <span class="Li">&quot;flags&quot;</span> is 0, this gives
        the same results as <span class="Li">&quot;isUTF8_CHAR&quot;</span>; if
        <span class="Li">&quot;flags&quot;</span> is
        <span class="Li">&quot;UTF8_DISALLOW_ILLEGAL_INTERCHANGE&quot;</span>,
        this gives the same results as
        <span class="Li">&quot;isSTRICT_UTF8_CHAR&quot;</span>; and if
        <span class="Li">&quot;flags&quot;</span> is
        <span class="Li">&quot;UTF8_DISALLOW_ILLEGAL_C9_INTERCHANGE&quot;</span>,
        this gives the same results as
        <span class="Li">&quot;isC9_STRICT_UTF8_CHAR&quot;</span>. Otherwise
        <span class="Li">&quot;flags&quot;</span> may be any combination of the
        <span class="Li">&quot;UTF8_DISALLOW_</span><span class="Li"><i>foo</i></span><span class="Li">&quot;</span>
        flags understood by <span class="Li">&quot;utf8n_to_uvchr&quot;</span>,
        with the same meanings.</p>
    <p class="Pp">The three alternative macros are for the most commonly needed
        validations; they are likely to run somewhat faster than this more
        general one, as they can be inlined into your code.</p>
    <p class="Pp">Use &quot;is_utf8_string_flags&quot;,
        &quot;is_utf8_string_loc_flags&quot;, and
        &quot;is_utf8_string_loclen_flags&quot; to check entire strings.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> STRLEN  isUTF8_CHAR_flags(const U8 *s, const U8 *e,
                           const U32 flags)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;LATIN1_TO_NATIVE&quot;</dt>
  <dd>Returns the native equivalent of the input Latin-1 code point (including
      ASCII and control characters) given by
      <span class="Li">&quot;ch&quot;</span>. Thus,
      <span class="Li">&quot;LATIN1_TO_NATIVE(66)&quot;</span> on EBCDIC
      platforms returns 194. These each represent the character
      <span class="Li">&quot;B&quot;</span> on their respective platforms. On
      ASCII platforms no conversion is needed, so this macro expands to just its
      input, adding no time nor space requirements to the implementation.
    <p class="Pp">For conversion of code points potentially larger than will fit
        in a character, use &quot;UNI_TO_NATIVE&quot;.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> U8  LATIN1_TO_NATIVE(U8 ch)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;NATIVE_TO_LATIN1&quot;</dt>
  <dd>Returns the Latin-1 (including ASCII and control characters) equivalent of
      the input native code point given by
      <span class="Li">&quot;ch&quot;</span>. Thus,
      <span class="Li">&quot;NATIVE_TO_LATIN1(193)&quot;</span> on EBCDIC
      platforms returns 65. These each represent the character
      <span class="Li">&quot;A&quot;</span> on their respective platforms. On
      ASCII platforms no conversion is needed, so this macro expands to just its
      input, adding no time nor space requirements to the implementation.
    <p class="Pp">For conversion of code points potentially larger than will fit
        in a character, use &quot;NATIVE_TO_UNI&quot;.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> U8  NATIVE_TO_LATIN1(U8 ch)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;NATIVE_TO_UNI&quot;</dt>
  <dd>Returns the Unicode equivalent of the input native code point given by
      <span class="Li">&quot;ch&quot;</span>. Thus,
      <span class="Li">&quot;NATIVE_TO_UNI(195)&quot;</span> on EBCDIC platforms
      returns 67. These each represent the character
      <span class="Li">&quot;C&quot;</span> on their respective platforms. On
      ASCII platforms no conversion is needed, so this macro expands to just its
      input, adding no time nor space requirements to the implementation.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> UV  NATIVE_TO_UNI(UV ch)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;pad_compname_type&quot;</dt>
  <dd><span class="Li">&quot;</span><span class="Li"><b>DEPRECATED!</b></span><span class="Li">&quot;</span>
      It is planned to remove
      <span class="Li">&quot;pad_compname_type&quot;</span> from a future
      release of Perl. Do not use it for new code; remove it from existing code.
    <p class="Pp">Looks up the type of the lexical variable at position
        <span class="Li">&quot;po&quot;</span> in the currently-compiling pad.
        If the variable is typed, the stash of the class to which it is typed is
        returned. If not, <span class="Li">&quot;NULL&quot;</span> is
      returned.</p>
    <p class="Pp">Use
        &quot;<span class="Li">&quot;PAD_COMPNAME_TYPE&quot;</span>&quot; in
        perlintern instead.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> HV*  pad_compname_type(const PADOFFSET po)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;pv_uni_display&quot;</dt>
  <dd>Build to the scalar <span class="Li">&quot;dsv&quot;</span> a displayable
      version of the UTF-8 encoded string
      <span class="Li">&quot;spv&quot;</span>, length
      <span class="Li">&quot;len&quot;</span>, the displayable version being at
      most <span class="Li">&quot;pvlim&quot;</span> bytes long (if longer, the
      rest is truncated and <span class="Li">&quot;...&quot;</span> will be
      appended).
    <p class="Pp">The <span class="Li">&quot;flags&quot;</span> argument can
        have <span class="Li">&quot;UNI_DISPLAY_ISPRINT&quot;</span> set to
        display <span class="Li">&quot;isPRINT()&quot;</span>able characters as
        themselves, <span class="Li">&quot;UNI_DISPLAY_BACKSLASH&quot;</span> to
        display the <span class="Li">&quot;\\[nrfta\\]&quot;</span> as the
        backslashed versions (like <span class="Li">&quot;\n&quot;</span>)
        (<span class="Li">&quot;UNI_DISPLAY_BACKSLASH&quot;</span> is preferred
        over <span class="Li">&quot;UNI_DISPLAY_ISPRINT&quot;</span> for
        <span class="Li">&quot;\\&quot;</span>).
        <span class="Li">&quot;UNI_DISPLAY_QQ&quot;</span> (and its alias
        <span class="Li">&quot;UNI_DISPLAY_REGEX&quot;</span>) have both
        <span class="Li">&quot;UNI_DISPLAY_BACKSLASH&quot;</span> and
        <span class="Li">&quot;UNI_DISPLAY_ISPRINT&quot;</span> turned on.</p>
    <p class="Pp">Additionally, there is now
        <span class="Li">&quot;UNI_DISPLAY_BACKSPACE&quot;</span> which allows
        <span class="Li">&quot;\b&quot;</span> for a backspace, but only when
        <span class="Li">&quot;UNI_DISPLAY_BACKSLASH&quot;</span> also is
      set.</p>
    <p class="Pp">The pointer to the PV of the
        <span class="Li">&quot;dsv&quot;</span> is returned.</p>
    <p class="Pp">See also &quot;sv_uni_display&quot;.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> char*  pv_uni_display(SV *dsv, const U8 *spv, STRLEN len,
                       STRLEN pvlim, UV flags)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;REPLACEMENT_CHARACTER_UTF8&quot;</dt>
  <dd>This is a macro that evaluates to a string constant of the UTF-8 bytes
      that define the Unicode REPLACEMENT CHARACTER (U+FFFD) for the platform
      that perl is compiled on. This allows code to use a mnemonic for this
      character that works on both ASCII and EBCDIC platforms.
      <span class="Li">&quot;sizeof(REPLACEMENT_CHARACTER_UTF8)&#x00A0;-&#x00A0;1&quot;</span>
      can be used to get its length in bytes.</dd>
  <dt>&quot;sv_cat_decode&quot;</dt>
  <dd><span class="Li">&quot;encoding&quot;</span> is assumed to be an
      <span class="Li">&quot;Encode&quot;</span> object, the PV of
      <span class="Li">&quot;ssv&quot;</span> is assumed to be octets in that
      encoding and decoding the input starts from the position which
      <span class="Li">&quot;(PV&#x00A0;+&#x00A0;*offset)&quot;</span> pointed
      to. <span class="Li">&quot;dsv&quot;</span> will be concatenated with the
      decoded UTF-8 string from <span class="Li">&quot;ssv&quot;</span>.
      Decoding will terminate when the string
      <span class="Li">&quot;tstr&quot;</span> appears in decoding output or the
      input ends on the PV of <span class="Li">&quot;ssv&quot;</span>. The value
      which <span class="Li">&quot;offset&quot;</span> points will be modified
      to the last input position on <span class="Li">&quot;ssv&quot;</span>.
    <p class="Pp">Returns TRUE if the terminator was found, else returns
      FALSE.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> bool  sv_cat_decode(SV* dsv, SV *encoding, SV *ssv, int *offset,
                     char* tstr, int tlen)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;sv_recode_to_utf8&quot;</dt>
  <dd><span class="Li">&quot;encoding&quot;</span> is assumed to be an
      <span class="Li">&quot;Encode&quot;</span> object, on entry the PV of
      <span class="Li">&quot;sv&quot;</span> is assumed to be octets in that
      encoding, and <span class="Li">&quot;sv&quot;</span> will be converted
      into Unicode (and UTF-8).
    <p class="Pp">If <span class="Li">&quot;sv&quot;</span> already is UTF-8 (or
        if it is not <span class="Li">&quot;POK&quot;</span>), or if
        <span class="Li">&quot;encoding&quot;</span> is not a reference, nothing
        is done to <span class="Li">&quot;sv&quot;</span>. If
        <span class="Li">&quot;encoding&quot;</span> is not an
        <span class="Li">&quot;Encode::XS&quot;</span> Encoding object, bad
        things will happen. (See <i>cpan/Encode/encoding.pm</i> and Encode.)</p>
    <p class="Pp">The PV of <span class="Li">&quot;sv&quot;</span> is
      returned.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> char*  sv_recode_to_utf8(SV* sv, SV *encoding)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;sv_uni_display&quot;</dt>
  <dd>Build to the scalar <span class="Li">&quot;dsv&quot;</span> a displayable
      version of the scalar <span class="Li">&quot;sv&quot;</span>, the
      displayable version being at most
      <span class="Li">&quot;pvlim&quot;</span> bytes long (if longer, the rest
      is truncated and &quot;...&quot; will be appended).
    <p class="Pp">The <span class="Li">&quot;flags&quot;</span> argument is as
        in &quot;pv_uni_display&quot;().</p>
    <p class="Pp">The pointer to the PV of the
        <span class="Li">&quot;dsv&quot;</span> is returned.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> char*  sv_uni_display(SV *dsv, SV *ssv, STRLEN pvlim, UV flags)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;UNICODE_REPLACEMENT&quot;</dt>
  <dd>Evaluates to 0xFFFD, the code point of the Unicode REPLACEMENT
    CHARACTER</dd>
  <dt>&quot;UNI_TO_NATIVE&quot;</dt>
  <dd>Returns the native equivalent of the input Unicode code point given by
      <span class="Li">&quot;ch&quot;</span>. Thus,
      <span class="Li">&quot;UNI_TO_NATIVE(68)&quot;</span> on EBCDIC platforms
      returns 196. These each represent the character
      <span class="Li">&quot;D&quot;</span> on their respective platforms. On
      ASCII platforms no conversion is needed, so this macro expands to just its
      input, adding no time nor space requirements to the implementation.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> UV  UNI_TO_NATIVE(UV ch)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;utf8n_to_uvchr&quot;</dt>
  <dd>THIS FUNCTION SHOULD BE USED IN ONLY VERY SPECIALIZED CIRCUMSTANCES. Most
      code should use &quot;utf8_to_uvchr_buf&quot;() rather than call this
      directly.
    <p class="Pp">Bottom level UTF-8 decode routine. Returns the native code
        point value of the first character in the string
        <span class="Li">&quot;s&quot;</span>, which is assumed to be in UTF-8
        (or UTF-EBCDIC) encoding, and no longer than
        <span class="Li">&quot;curlen&quot;</span> bytes;
        <span class="Li">*retlen</span> (if
        <span class="Li">&quot;retlen&quot;</span> isn't NULL) will be set to
        the length, in bytes, of that character.</p>
    <p class="Pp">The value of <span class="Li">&quot;flags&quot;</span>
        determines the behavior when <span class="Li">&quot;s&quot;</span> does
        not point to a well-formed UTF-8 character. If
        <span class="Li">&quot;flags&quot;</span> is 0, encountering a
        malformation causes zero to be returned and
        <span class="Li">*retlen</span> is set so that
        (<span class="Li">&quot;s&quot;</span>&#x00A0;+&#x00A0;<span class="Li">*retlen</span>)
        is the next possible position in <span class="Li">&quot;s&quot;</span>
        that could begin a non-malformed character. Also, if UTF-8 warnings
        haven't been lexically disabled, a warning is raised. Some UTF-8 input
        sequences may contain multiple malformations. This function tries to
        find every possible one in each call, so multiple warnings can be raised
        for the same sequence.</p>
    <p class="Pp">Various ALLOW flags can be set in
        <span class="Li">&quot;flags&quot;</span> to allow (and not warn on)
        individual types of malformations, such as the sequence being overlong
        (that is, when there is a shorter sequence that can express the same
        code point; overlong sequences are expressly forbidden in the UTF-8
        standard due to potential security issues). Another malformation example
        is the first byte of a character not being a legal first byte. See
        <i>utf8.h</i> for the list of such flags. Even if allowed, this function
        generally returns the Unicode REPLACEMENT CHARACTER when it encounters a
        malformation. There are flags in <i>utf8.h</i> to override this behavior
        for the overlong malformations, but don't do that except for very
        specialized purposes.</p>
    <p class="Pp">The <span class="Li">&quot;UTF8_CHECK_ONLY&quot;</span> flag
        overrides the behavior when a non-allowed (by other flags) malformation
        is found. If this flag is set, the routine assumes that the caller will
        raise a warning, and this function will silently just set
        <span class="Li">&quot;retlen&quot;</span> to
        <span class="Li">&quot;-1&quot;</span> (cast to
        <span class="Li">&quot;STRLEN&quot;</span>) and return zero.</p>
    <p class="Pp">Note that this API requires disambiguation between successful
        decoding a <span class="Li">&quot;NUL&quot;</span> character, and an
        error return (unless the
        <span class="Li">&quot;UTF8_CHECK_ONLY&quot;</span> flag is set), as in
        both cases, 0 is returned, and, depending on the malformation,
        <span class="Li">&quot;retlen&quot;</span> may be set to 1. To
        disambiguate, upon a zero return, see if the first byte of
        <span class="Li">&quot;s&quot;</span> is 0 as well. If so, the input was
        a <span class="Li">&quot;NUL&quot;</span>; if not, the input had an
        error. Or you can use
        <span class="Li">&quot;utf8n_to_uvchr_error&quot;</span>.</p>
    <p class="Pp">Certain code points are considered problematic. These are
        Unicode surrogates, Unicode non-characters, and code points above the
        Unicode maximum of 0x10FFFF. By default these are considered regular
        code points, but certain situations warrant special handling for them,
        which can be specified using the
        <span class="Li">&quot;flags&quot;</span> parameter. If
        <span class="Li">&quot;flags&quot;</span> contains
        <span class="Li">&quot;UTF8_DISALLOW_ILLEGAL_INTERCHANGE&quot;</span>,
        all three classes are treated as malformations and handled as such. The
        flags <span class="Li">&quot;UTF8_DISALLOW_SURROGATE&quot;</span>,
        <span class="Li">&quot;UTF8_DISALLOW_NONCHAR&quot;</span>, and
        <span class="Li">&quot;UTF8_DISALLOW_SUPER&quot;</span> (meaning above
        the legal Unicode maximum) can be set to disallow these categories
        individually.
        <span class="Li">&quot;UTF8_DISALLOW_ILLEGAL_INTERCHANGE&quot;</span>
        restricts the allowed inputs to the strict UTF-8 traditionally defined
        by Unicode. Use
        <span class="Li">&quot;UTF8_DISALLOW_ILLEGAL_C9_INTERCHANGE&quot;</span>
        to use the strictness definition given by Unicode Corrigendum #9
        &lt;https://www.unicode.org/versions/corrigendum9.html&gt;. The
        difference between traditional strictness and C9 strictness is that the
        latter does not forbid non-character code points. (They are still
        discouraged, however.) For more discussion see &quot;Noncharacter code
        points&quot; in perlunicode.</p>
    <p class="Pp">The flags
        <span class="Li">&quot;UTF8_WARN_ILLEGAL_INTERCHANGE&quot;</span>,
        <span class="Li">&quot;UTF8_WARN_ILLEGAL_C9_INTERCHANGE&quot;</span>,
        <span class="Li">&quot;UTF8_WARN_SURROGATE&quot;</span>,
        <span class="Li">&quot;UTF8_WARN_NONCHAR&quot;</span>, and
        <span class="Li">&quot;UTF8_WARN_SUPER&quot;</span> will cause warning
        messages to be raised for their respective categories, but otherwise the
        code points are considered valid (not malformations). To get a category
        to both be treated as a malformation and raise a warning, specify both
        the WARN and DISALLOW flags. (But note that warnings are not raised if
        lexically disabled nor if
        <span class="Li">&quot;UTF8_CHECK_ONLY&quot;</span> is also
      specified.)</p>
    <p class="Pp">Extremely high code points were never specified in any
        standard, and require an extension to UTF-8 to express, which Perl does.
        It is likely that programs written in something other than Perl would
        not be able to read files that contain these; nor would Perl understand
        files written by something that uses a different extension. For these
        reasons, there is a separate set of flags that can warn and/or disallow
        these extremely high code points, even if other above-Unicode ones are
        accepted. They are the
        <span class="Li">&quot;UTF8_WARN_PERL_EXTENDED&quot;</span> and
        <span class="Li">&quot;UTF8_DISALLOW_PERL_EXTENDED&quot;</span> flags.
        For more information see
        <span class="Li">&quot;UTF8_GOT_PERL_EXTENDED&quot;</span>. Of course
        <span class="Li">&quot;UTF8_DISALLOW_SUPER&quot;</span> will treat all
        above-Unicode code points, including these, as malformations. (Note that
        the Unicode standard considers anything above 0x10FFFF to be illegal,
        but there are standards predating it that allow up to 0x7FFF_FFFF (2**31
        -1))</p>
    <p class="Pp">A somewhat misleadingly named synonym for
        <span class="Li">&quot;UTF8_WARN_PERL_EXTENDED&quot;</span> is retained
        for backward compatibility:
        <span class="Li">&quot;UTF8_WARN_ABOVE_31_BIT&quot;</span>. Similarly,
        <span class="Li">&quot;UTF8_DISALLOW_ABOVE_31_BIT&quot;</span> is usable
        instead of the more accurately named
        <span class="Li">&quot;UTF8_DISALLOW_PERL_EXTENDED&quot;</span>. The
        names are misleading because these flags can apply to code points that
        actually do fit in 31 bits. This happens on EBCDIC platforms, and
        sometimes when the overlong malformation is also present. The new names
        accurately describe the situation in all cases.</p>
    <p class="Pp">All other code points corresponding to Unicode characters,
        including private use and those yet to be assigned, are never considered
        malformed and never warn.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> UV  utf8n_to_uvchr(const U8 *s, STRLEN curlen, STRLEN *retlen,
                    const U32 flags)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;utf8n_to_uvchr_error&quot;</dt>
  <dd>THIS FUNCTION SHOULD BE USED IN ONLY VERY SPECIALIZED CIRCUMSTANCES. Most
      code should use &quot;utf8_to_uvchr_buf&quot;() rather than call this
      directly.
    <p class="Pp">This function is for code that needs to know what the precise
        malformation(s) are when an error is found. If you also need to know the
        generated warning messages, use &quot;utf8n_to_uvchr_msgs&quot;()
        instead.</p>
    <p class="Pp">It is like <span class="Li">&quot;utf8n_to_uvchr&quot;</span>
        but it takes an extra parameter placed after all the others,
        <span class="Li">&quot;errors&quot;</span>. If this parameter is 0, this
        function behaves identically to
        <span class="Li">&quot;utf8n_to_uvchr&quot;</span>. Otherwise,
        <span class="Li">&quot;errors&quot;</span> should be a pointer to a
        <span class="Li">&quot;U32&quot;</span> variable, which this function
        sets to indicate any errors found. Upon return, if
        <span class="Li">*errors</span> is 0, there were no errors found.
        Otherwise, <span class="Li">*errors</span> is the bit-wise
        <span class="Li">&quot;OR&quot;</span> of the bits described in the list
        below. Some of these bits will be set if a malformation is found, even
        if the input <span class="Li">&quot;flags&quot;</span> parameter
        indicates that the given malformation is allowed; those exceptions are
        noted:</p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>&quot;UTF8_GOT_PERL_EXTENDED&quot;</dt>
  <dd>The input sequence is not standard UTF-8, but a Perl extension. This bit
      is set only if the input <span class="Li">&quot;flags&quot;</span>
      parameter contains either the
      <span class="Li">&quot;UTF8_DISALLOW_PERL_EXTENDED&quot;</span> or the
      <span class="Li">&quot;UTF8_WARN_PERL_EXTENDED&quot;</span> flags.
    <p class="Pp">Code points above 0x7FFF_FFFF (2**31 - 1) were never specified
        in any standard, and so some extension must be used to express them.
        Perl uses a natural extension to UTF-8 to represent the ones up to
        2**36-1, and invented a further extension to represent even higher ones,
        so that any code point that fits in a 64-bit word can be represented.
        Text using these extensions is not likely to be portable to non-Perl
        code. We lump both of these extensions together and refer to them as
        Perl extended UTF-8. There exist other extensions that people have
        invented, incompatible with Perl's.</p>
    <p class="Pp">On EBCDIC platforms starting in Perl v5.24, the Perl extension
        for representing extremely high code points kicks in at 0x3FFF_FFFF
        (2**30 -1), which is lower than on ASCII. Prior to that, code points
        2**31 and higher were simply unrepresentable, and a different,
        incompatible method was used to represent code points between 2**30 and
        2**31 - 1.</p>
    <p class="Pp">On both platforms, ASCII and EBCDIC,
        <span class="Li">&quot;UTF8_GOT_PERL_EXTENDED&quot;</span> is set if
        Perl extended UTF-8 is used.</p>
    <p class="Pp">In earlier Perls, this bit was named
        <span class="Li">&quot;UTF8_GOT_ABOVE_31_BIT&quot;</span>, which you
        still may use for backward compatibility. That name is misleading, as
        this flag may be set when the code point actually does fit in 31 bits.
        This happens on EBCDIC platforms, and sometimes when the overlong
        malformation is also present. The new name accurately describes the
        situation in all cases.</p>
  </dd>
  <dt>&quot;UTF8_GOT_CONTINUATION&quot;</dt>
  <dd>The input sequence was malformed in that the first byte was a UTF-8
      continuation byte.</dd>
  <dt>&quot;UTF8_GOT_EMPTY&quot;</dt>
  <dd>The input <span class="Li">&quot;curlen&quot;</span> parameter was 0.</dd>
  <dt>&quot;UTF8_GOT_LONG&quot;</dt>
  <dd>The input sequence was malformed in that there is some other sequence that
      evaluates to the same code point, but that sequence is shorter than this
      one.
    <p class="Pp">Until Unicode 3.1, it was legal for programs to accept this
        malformation, but it was discovered that this created security
      issues.</p>
  </dd>
  <dt>&quot;UTF8_GOT_NONCHAR&quot;</dt>
  <dd>The code point represented by the input UTF-8 sequence is for a Unicode
      non-character code point. This bit is set only if the input
      <span class="Li">&quot;flags&quot;</span> parameter contains either the
      <span class="Li">&quot;UTF8_DISALLOW_NONCHAR&quot;</span> or the
      <span class="Li">&quot;UTF8_WARN_NONCHAR&quot;</span> flags.</dd>
  <dt>&quot;UTF8_GOT_NON_CONTINUATION&quot;</dt>
  <dd>The input sequence was malformed in that a non-continuation type byte was
      found in a position where only a continuation type one should be. See also
      <span class="Li">&quot;UTF8_GOT_SHORT&quot;</span>.</dd>
  <dt>&quot;UTF8_GOT_OVERFLOW&quot;</dt>
  <dd>The input sequence was malformed in that it is for a code point that is
      not representable in the number of bits available in an IV on the current
      platform.</dd>
  <dt>&quot;UTF8_GOT_SHORT&quot;</dt>
  <dd>The input sequence was malformed in that
      <span class="Li">&quot;curlen&quot;</span> is smaller than required for a
      complete sequence. In other words, the input is for a partial character
      sequence.
    <p class="Pp"><span class="Li">&quot;UTF8_GOT_SHORT&quot;</span> and
        <span class="Li">&quot;UTF8_GOT_NON_CONTINUATION&quot;</span> both
        indicate a too short sequence. The difference is that
        <span class="Li">&quot;UTF8_GOT_NON_CONTINUATION&quot;</span> indicates
        always that there is an error, while
        <span class="Li">&quot;UTF8_GOT_SHORT&quot;</span> means that an
        incomplete sequence was looked at. If no other flags are present, it
        means that the sequence was valid as far as it went. Depending on the
        application, this could mean one of three things:</p>
  </dd>
</dl>
<div class="Bd-indent">
<ul class="Bl-bullet">
  <li>The <span class="Li">&quot;curlen&quot;</span> length parameter passed in
      was too small, and the function was prevented from examining all the
      necessary bytes.</li>
  <li>The buffer being looked at is based on reading data, and the data received
      so far stopped in the middle of a character, so that the next read will
      read the remainder of this character. (It is up to the caller to deal with
      the split bytes somehow.)</li>
  <li>This is a real error, and the partial sequence is all we're going to
    get.</li>
</ul>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;UTF8_GOT_SUPER&quot;</dt>
  <dd>The input sequence was malformed in that it is for a non-Unicode code
      point; that is, one above the legal Unicode maximum. This bit is set only
      if the input <span class="Li">&quot;flags&quot;</span> parameter contains
      either the <span class="Li">&quot;UTF8_DISALLOW_SUPER&quot;</span> or the
      <span class="Li">&quot;UTF8_WARN_SUPER&quot;</span> flags.</dd>
  <dt>&quot;UTF8_GOT_SURROGATE&quot;</dt>
  <dd>The input sequence was malformed in that it is for a -Unicode UTF-16
      surrogate code point. This bit is set only if the input
      <span class="Li">&quot;flags&quot;</span> parameter contains either the
      <span class="Li">&quot;UTF8_DISALLOW_SURROGATE&quot;</span> or the
      <span class="Li">&quot;UTF8_WARN_SURROGATE&quot;</span> flags.</dd>
</dl>
</div>
<div class="Bd-indent">
<p class="Pp">To do your own error handling, call this function with the
    <span class="Li">&quot;UTF8_CHECK_ONLY&quot;</span> flag to suppress any
    warnings, and then examine the <span class="Li">*errors</span> return.</p>
<p class="Pp"></p>
<pre> UV  utf8n_to_uvchr_error(const U8 *s, STRLEN curlen,
                          STRLEN *retlen, const U32 flags,
                          U32 * errors)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;utf8n_to_uvchr_msgs&quot;</dt>
  <dd>THIS FUNCTION SHOULD BE USED IN ONLY VERY SPECIALIZED CIRCUMSTANCES. Most
      code should use &quot;utf8_to_uvchr_buf&quot;() rather than call this
      directly.
    <p class="Pp">This function is for code that needs to know what the precise
        malformation(s) are when an error is found, and wants the corresponding
        warning and/or error messages to be returned to the caller rather than
        be displayed. All messages that would have been displayed if all lexical
        warnings are enabled will be returned.</p>
    <p class="Pp">It is just like
        <span class="Li">&quot;utf8n_to_uvchr_error&quot;</span> but it takes an
        extra parameter placed after all the others,
        <span class="Li">&quot;msgs&quot;</span>. If this parameter is 0, this
        function behaves identically to
        <span class="Li">&quot;utf8n_to_uvchr_error&quot;</span>. Otherwise,
        <span class="Li">&quot;msgs&quot;</span> should be a pointer to an
        <span class="Li">&quot;AV *&quot;</span> variable, in which this
        function creates a new AV to contain any appropriate messages. The
        elements of the array are ordered so that the first message that would
        have been displayed is in the 0th element, and so on. Each element is a
        hash with three key-value pairs, as follows:</p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>&quot;text&quot;</dt>
  <dd>The text of the message as a
    <span class="Li">&quot;SVpv&quot;</span>.</dd>
  <dt>&quot;warn_categories&quot;</dt>
  <dd>The warning category (or categories) packed into a
      <span class="Li">&quot;SVuv&quot;</span>.</dd>
  <dt>&quot;flag&quot;</dt>
  <dd>A single flag bit associated with this message, in a
      <span class="Li">&quot;SVuv&quot;</span>. The bit corresponds to some bit
      in the <span class="Li">*errors</span> return value, such as
      <span class="Li">&quot;UTF8_GOT_LONG&quot;</span>.</dd>
</dl>
</div>
<div class="Bd-indent">
<p class="Pp">It's important to note that specifying this parameter as non-null
    will cause any warnings this function would otherwise generate to be
    suppressed, and instead be placed in <span class="Li">*msgs</span>. The
    caller can check the lexical warnings state (or not) when choosing what to
    do with the returned messages.</p>
<p class="Pp">If the flag <span class="Li">&quot;UTF8_CHECK_ONLY&quot;</span> is
    passed, no warnings are generated, and hence no AV is created.</p>
<p class="Pp">The caller, of course, is responsible for freeing any returned
  AV.</p>
<p class="Pp"></p>
<pre> UV  utf8n_to_uvchr_msgs(const U8 *s, STRLEN curlen,
                         STRLEN *retlen, const U32 flags,
                         U32 * errors, AV ** msgs)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;UTF8SKIP&quot;</dt>
  <dd>returns the number of bytes a non-malformed UTF-8 encoded character whose
      first (perhaps only) byte is pointed to by
      <span class="Li">&quot;s&quot;</span>.
    <p class="Pp">If there is a possibility of malformed input, use instead:</p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>&quot;UTF8_SAFE_SKIP&quot; if you know the maximum ending pointer in the
    buffer pointed to by &quot;s&quot;; or</dt>
  <dd></dd>
  <dt>&quot;UTF8_CHK_SKIP&quot; if you don't know it.</dt>
  <dd></dd>
</dl>
</div>
<div class="Bd-indent">
<p class="Pp">It is better to restructure your code so the end pointer is passed
    down so that you know what it actually is at the point of this call, but if
    that isn't possible, <span class="Li">&quot;UTF8_CHK_SKIP&quot;</span> can
    minimize the chance of accessing beyond the end of the input buffer.</p>
<p class="Pp"></p>
<pre> STRLEN  UTF8SKIP(char* s)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;UTF8_CHK_SKIP&quot;</dt>
  <dd>This is a safer version of <span class="Li">&quot;UTF8SKIP&quot;</span>,
      but still not as safe as
      <span class="Li">&quot;UTF8_SAFE_SKIP&quot;</span>. This version doesn't
      blindly assume that the input string pointed to by
      <span class="Li">&quot;s&quot;</span> is well-formed, but verifies that
      there isn't a NUL terminating character before the expected end of the
      next character in <span class="Li">&quot;s&quot;</span>. The length
      <span class="Li">&quot;UTF8_CHK_SKIP&quot;</span> returns stops just
      before any such NUL.
    <p class="Pp">Perl tends to add NULs, as an insurance policy, after the end
        of strings in SV's, so it is likely that using this macro will prevent
        inadvertent reading beyond the end of the input buffer, even if it is
        malformed UTF-8.</p>
    <p class="Pp">This macro is intended to be used by XS modules where the
        inputs could be malformed, and it isn't feasible to restructure to use
        the safer <span class="Li">&quot;UTF8_SAFE_SKIP&quot;</span>, for
        example when interfacing with a C library.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> STRLEN  UTF8_CHK_SKIP(char* s)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;utf8_distance&quot;</dt>
  <dd>Returns the number of UTF-8 characters between the UTF-8 pointers
      <span class="Li">&quot;a&quot;</span> and
      <span class="Li">&quot;b&quot;</span>.
    <p class="Pp">WARNING: use only if you *know* that the pointers point inside
        the same UTF-8 buffer.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> IV  utf8_distance(const U8 *a, const U8 *b)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;utf8_hop&quot;</dt>
  <dd>Return the UTF-8 pointer <span class="Li">&quot;s&quot;</span> displaced
      by <span class="Li">&quot;off&quot;</span> characters, either forward or
      backward.
    <p class="Pp">WARNING: do not use the following unless you *know*
        <span class="Li">&quot;off&quot;</span> is within the UTF-8 data pointed
        to by <span class="Li">&quot;s&quot;</span> *and* that on entry
        <span class="Li">&quot;s&quot;</span> is aligned on the first byte of
        character or just after the last byte of a character.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> U8*  utf8_hop(const U8 *s, SSize_t off)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;utf8_hop_back&quot;</dt>
  <dd>Return the UTF-8 pointer <span class="Li">&quot;s&quot;</span> displaced
      by up to <span class="Li">&quot;off&quot;</span> characters, backward.
    <p class="Pp"><span class="Li">&quot;off&quot;</span> must be
      non-positive.</p>
    <p class="Pp"><span class="Li">&quot;s&quot;</span> must be after or equal
        to <span class="Li">&quot;start&quot;</span>.</p>
    <p class="Pp">When moving backward it will not move before
        <span class="Li">&quot;start&quot;</span>.</p>
    <p class="Pp">Will not exceed this limit even if the string is not valid
        &quot;UTF-8&quot;.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> U8*  utf8_hop_back(const U8 *s, SSize_t off, const U8 *start)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;utf8_hop_forward&quot;</dt>
  <dd>Return the UTF-8 pointer <span class="Li">&quot;s&quot;</span> displaced
      by up to <span class="Li">&quot;off&quot;</span> characters, forward.
    <p class="Pp"><span class="Li">&quot;off&quot;</span> must be
      non-negative.</p>
    <p class="Pp"><span class="Li">&quot;s&quot;</span> must be before or equal
        to <span class="Li">&quot;end&quot;</span>.</p>
    <p class="Pp">When moving forward it will not move beyond
        <span class="Li">&quot;end&quot;</span>.</p>
    <p class="Pp">Will not exceed this limit even if the string is not valid
        &quot;UTF-8&quot;.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> U8*  utf8_hop_forward(const U8 *s, SSize_t off, const U8 *end)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;utf8_hop_safe&quot;</dt>
  <dd>Return the UTF-8 pointer <span class="Li">&quot;s&quot;</span> displaced
      by up to <span class="Li">&quot;off&quot;</span> characters, either
      forward or backward.
    <p class="Pp">When moving backward it will not move before
        <span class="Li">&quot;start&quot;</span>.</p>
    <p class="Pp">When moving forward it will not move beyond
        <span class="Li">&quot;end&quot;</span>.</p>
    <p class="Pp">Will not exceed those limits even if the string is not valid
        &quot;UTF-8&quot;.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> U8*  utf8_hop_safe(const U8 *s, SSize_t off, const U8 *start,
                    const U8 *end)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;UTF8_IS_INVARIANT&quot;</dt>
  <dd>Evaluates to 1 if the byte <span class="Li">&quot;c&quot;</span>
      represents the same character when encoded in UTF-8 as when not; otherwise
      evaluates to 0. UTF-8 invariant characters can be copied as-is when
      converting to/from UTF-8, saving time.
    <p class="Pp">In spite of the name, this macro gives the correct result if
        the input string from which <span class="Li">&quot;c&quot;</span> comes
        is not encoded in UTF-8.</p>
    <p class="Pp">See <span class="Li">&quot;UVCHR_IS_INVARIANT&quot;</span> for
        checking if a UV is invariant.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> bool  UTF8_IS_INVARIANT(char c)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;UTF8_IS_NONCHAR&quot;</dt>
  <dd>Evaluates to non-zero if the first few bytes of the string starting at
      <span class="Li">&quot;s&quot;</span> and looking no further than
      <span class="Li">&quot;e&#x00A0;-&#x00A0;1&quot;</span> are well-formed
      UTF-8 that represents one of the Unicode non-character code points;
      otherwise it evaluates to 0. If non-zero, the value gives how many bytes
      starting at <span class="Li">&quot;s&quot;</span> comprise the code
      point's representation.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> bool  UTF8_IS_NONCHAR(const U8 *s, const U8 *e)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;UTF8_IS_SUPER&quot;</dt>
  <dd>Recall that Perl recognizes an extension to UTF-8 that can encode code
      points larger than the ones defined by Unicode, which are 0..0x10FFFF.
    <p class="Pp">This macro evaluates to non-zero if the first few bytes of the
        string starting at <span class="Li">&quot;s&quot;</span> and looking no
        further than <span class="Li">&quot;e&#x00A0;-&#x00A0;1&quot;</span> are
        from this UTF-8 extension; otherwise it evaluates to 0. If non-zero, the
        value gives how many bytes starting at
        <span class="Li">&quot;s&quot;</span> comprise the code point's
        representation.</p>
    <p class="Pp">0 is returned if the bytes are not well-formed extended UTF-8,
        or if they represent a code point that cannot fit in a UV on the current
        platform. Hence this macro can give different results when run on a
        64-bit word machine than on one with a 32-bit word size.</p>
    <p class="Pp">Note that it is illegal to have code points that are larger
        than what can fit in an IV on the current machine.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> bool  UTF8_IS_SUPER(const U8 *s, const U8 *e)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;UTF8_IS_SURROGATE&quot;</dt>
  <dd>Evaluates to non-zero if the first few bytes of the string starting at
      <span class="Li">&quot;s&quot;</span> and looking no further than
      <span class="Li">&quot;e&#x00A0;-&#x00A0;1&quot;</span> are well-formed
      UTF-8 that represents one of the Unicode surrogate code points; otherwise
      it evaluates to 0. If non-zero, the value gives how many bytes starting at
      <span class="Li">&quot;s&quot;</span> comprise the code point's
      representation.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> bool  UTF8_IS_SURROGATE(const U8 *s, const U8 *e)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;utf8_length&quot;</dt>
  <dd>Returns the number of characters in the sequence of UTF-8-encoded bytes
      starting at <span class="Li">&quot;s&quot;</span> and ending at the byte
      just before <span class="Li">&quot;e&quot;</span>. If &lt;s&gt; and
      &lt;e&gt; point to the same place, it returns 0 with no warning raised.
    <p class="Pp">If <span class="Li">&quot;e &lt; s&quot;</span> or if the scan
        would end up past <span class="Li">&quot;e&quot;</span>, it raises a
        UTF8 warning and returns the number of valid characters.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> STRLEN  utf8_length(const U8* s, const U8 *e)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;UTF8_MAXBYTES&quot;</dt>
  <dd>The maximum width of a single UTF-8 encoded character, in bytes.
    <p class="Pp">NOTE: Strictly speaking Perl's UTF-8 should not be called
        UTF-8 since UTF-8 is an encoding of Unicode, and Unicode's upper limit,
        0x10FFFF, can be expressed with 4 bytes. However, Perl thinks of UTF-8
        as a way to encode non-negative integers in a binary format, even those
        above Unicode.</p>
  </dd>
  <dt>&quot;UTF8_MAXBYTES_CASE&quot;</dt>
  <dd>The maximum number of UTF-8 bytes a single Unicode character can
      uppercase/lowercase/titlecase/fold into.</dd>
  <dt>&quot;UTF8_SAFE_SKIP&quot;</dt>
  <dd>returns 0 if <span class="Li">&quot;s&#x00A0;&gt;=&#x00A0;e&quot;</span>;
      otherwise returns the number of bytes in the UTF-8 encoded character whose
      first byte is pointed to by <span class="Li">&quot;s&quot;</span>. But it
      never returns beyond <span class="Li">&quot;e&quot;</span>. On DEBUGGING
      builds, it asserts that
      <span class="Li">&quot;s&#x00A0;&lt;=&#x00A0;e&quot;</span>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> STRLEN  UTF8_SAFE_SKIP(char* s, char* e)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;UTF8_SKIP&quot;</dt>
  <dd>This is a synonym for <span class="Li">&quot;UTF8SKIP&quot;</span></dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> STRLEN  UTF8_SKIP(char* s)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;utf8_to_bytes&quot;</dt>
  <dd>NOTE: <span class="Li">&quot;utf8_to_bytes&quot;</span> is
      <b>experimental</b> and may change or be removed without notice.
    <p class="Pp">Converts a string <span class="Li">&quot;s&quot;</span> of
        length <span class="Li">*lenp</span> from UTF-8 into native byte
        encoding. Unlike &quot;bytes_to_utf8&quot;, this over-writes the
        original string, and updates <span class="Li">*lenp</span> to contain
        the new length. Returns zero on failure (leaving
        <span class="Li">&quot;s&quot;</span> unchanged) setting
        <span class="Li">*lenp</span> to -1.</p>
    <p class="Pp">Upon successful return, the number of variants in the string
        can be computed by having saved the value of
        <span class="Li">*lenp</span> before the call, and subtracting the
        after-call value of <span class="Li">*lenp</span> from it.</p>
    <p class="Pp">If you need a copy of the string, see
        &quot;bytes_from_utf8&quot;.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> U8*  utf8_to_bytes(U8 *s, STRLEN *lenp)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;utf8_to_uvchr&quot;</dt>
  <dd><span class="Li">&quot;</span><span class="Li"><b>DEPRECATED!</b></span><span class="Li">&quot;</span>
      It is planned to remove <span class="Li">&quot;utf8_to_uvchr&quot;</span>
      from a future release of Perl. Do not use it for new code; remove it from
      existing code.
    <p class="Pp">Returns the native code point of the first character in the
        string <span class="Li">&quot;s&quot;</span> which is assumed to be in
        UTF-8 encoding; <span class="Li">&quot;retlen&quot;</span> will be set
        to the length, in bytes, of that character.</p>
    <p class="Pp">Some, but not all, UTF-8 malformations are detected, and in
        fact, some malformed input could cause reading beyond the end of the
        input buffer, which is why this function is deprecated. Use
        &quot;utf8_to_uvchr_buf&quot; instead.</p>
    <p class="Pp">If <span class="Li">&quot;s&quot;</span> points to one of the
        detected malformations, and UTF8 warnings are enabled, zero is returned
        and <span class="Li">*retlen</span> is set (if
        <span class="Li">&quot;retlen&quot;</span> isn't
        <span class="Li">&quot;NULL&quot;</span>) to -1. If those warnings are
        off, the computed value if well-defined (or the Unicode REPLACEMENT
        CHARACTER, if not) is silently returned, and
        <span class="Li">*retlen</span> is set (if
        <span class="Li">&quot;retlen&quot;</span> isn't NULL) so that
        (<span class="Li">&quot;s&quot;</span>&#x00A0;+&#x00A0;<span class="Li">*retlen</span>)
        is the next possible position in <span class="Li">&quot;s&quot;</span>
        that could begin a non-malformed character. See
        &quot;utf8n_to_uvchr&quot; for details on when the REPLACEMENT CHARACTER
        is returned.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> UV  utf8_to_uvchr(const U8 *s, STRLEN *retlen)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;utf8_to_uvchr_buf&quot;</dt>
  <dd>Returns the native code point of the first character in the string
      <span class="Li">&quot;s&quot;</span> which is assumed to be in UTF-8
      encoding; <span class="Li">&quot;send&quot;</span> points to 1 beyond the
      end of <span class="Li">&quot;s&quot;</span>.
      <span class="Li">*retlen</span> will be set to the length, in bytes, of
      that character.
    <p class="Pp">If <span class="Li">&quot;s&quot;</span> does not point to a
        well-formed UTF-8 character and UTF8 warnings are enabled, zero is
        returned and <span class="Li">*retlen</span> is set (if
        <span class="Li">&quot;retlen&quot;</span> isn't
        <span class="Li">&quot;NULL&quot;</span>) to -1. If those warnings are
        off, the computed value, if well-defined (or the Unicode REPLACEMENT
        CHARACTER if not), is silently returned, and
        <span class="Li">*retlen</span> is set (if
        <span class="Li">&quot;retlen&quot;</span> isn't
        <span class="Li">&quot;NULL&quot;</span>) so that
        (<span class="Li">&quot;s&quot;</span>&#x00A0;+&#x00A0;<span class="Li">*retlen</span>)
        is the next possible position in <span class="Li">&quot;s&quot;</span>
        that could begin a non-malformed character. See
        &quot;utf8n_to_uvchr&quot; for details on when the REPLACEMENT CHARACTER
        is returned.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> UV  utf8_to_uvchr_buf(const U8 *s, const U8 *send, STRLEN *retlen)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;UVCHR_IS_INVARIANT&quot;</dt>
  <dd>Evaluates to 1 if the representation of code point
      <span class="Li">&quot;cp&quot;</span> is the same whether or not it is
      encoded in UTF-8; otherwise evaluates to 0. UTF-8 invariant characters can
      be copied as-is when converting to/from UTF-8, saving time.
      <span class="Li">&quot;cp&quot;</span> is Unicode if above 255; otherwise
      is platform-native.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> bool  UVCHR_IS_INVARIANT(UV cp)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;UVCHR_SKIP&quot;</dt>
  <dd>returns the number of bytes required to represent the code point
      <span class="Li">&quot;cp&quot;</span> when encoded as UTF-8.
      <span class="Li">&quot;cp&quot;</span> is a native (ASCII or EBCDIC) code
      point if less than 255; a Unicode code point otherwise.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> STRLEN  UVCHR_SKIP(UV cp)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;uvchr_to_utf8&quot;</dt>
  <dd>Adds the UTF-8 representation of the native code point
      <span class="Li">&quot;uv&quot;</span> to the end of the string
      <span class="Li">&quot;d&quot;</span>;
      <span class="Li">&quot;d&quot;</span> should have at least
      <span class="Li">&quot;UVCHR_SKIP(uv)+1&quot;</span> (up to
      <span class="Li">&quot;UTF8_MAXBYTES+1&quot;</span>) free bytes available.
      The return value is the pointer to the byte after the end of the new
      character. In other words,
    <p class="Pp"></p>
    <pre>    d = uvchr_to_utf8(d, uv);
    </pre>
    <p class="Pp">is the recommended wide native character-aware way of
      saying</p>
    <p class="Pp"></p>
    <pre>    *(d++) = uv;
    </pre>
    <p class="Pp">This function accepts any code point from
        0..<span class="Li">&quot;IV_MAX&quot;</span> as input.
        <span class="Li">&quot;IV_MAX&quot;</span> is typically 0x7FFF_FFFF in a
        32-bit word.</p>
    <p class="Pp">It is possible to forbid or warn on non-Unicode code points,
        or those that may be problematic by using
        &quot;uvchr_to_utf8_flags&quot;.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> U8*  uvchr_to_utf8(U8 *d, UV uv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;uvchr_to_utf8_flags&quot;</dt>
  <dd>Adds the UTF-8 representation of the native code point
      <span class="Li">&quot;uv&quot;</span> to the end of the string
      <span class="Li">&quot;d&quot;</span>;
      <span class="Li">&quot;d&quot;</span> should have at least
      <span class="Li">&quot;UVCHR_SKIP(uv)+1&quot;</span> (up to
      <span class="Li">&quot;UTF8_MAXBYTES+1&quot;</span>) free bytes available.
      The return value is the pointer to the byte after the end of the new
      character. In other words,
    <p class="Pp"></p>
    <pre>    d = uvchr_to_utf8_flags(d, uv, flags);
    </pre>
    <p class="Pp">or, in most cases,</p>
    <p class="Pp"></p>
    <pre>    d = uvchr_to_utf8_flags(d, uv, 0);
    </pre>
    <p class="Pp">This is the Unicode-aware way of saying</p>
    <p class="Pp"></p>
    <pre>    *(d++) = uv;
    </pre>
    <p class="Pp">If <span class="Li">&quot;flags&quot;</span> is 0, this
        function accepts any code point from
        0..<span class="Li">&quot;IV_MAX&quot;</span> as input.
        <span class="Li">&quot;IV_MAX&quot;</span> is typically 0x7FFF_FFFF in a
        32-bit word.</p>
    <p class="Pp">Specifying <span class="Li">&quot;flags&quot;</span> can
        further restrict what is allowed and not warned on, as follows:</p>
    <p class="Pp">If <span class="Li">&quot;uv&quot;</span> is a Unicode
        surrogate code point and
        <span class="Li">&quot;UNICODE_WARN_SURROGATE&quot;</span> is set, the
        function will raise a warning, provided UTF8 warnings are enabled. If
        instead <span class="Li">&quot;UNICODE_DISALLOW_SURROGATE&quot;</span>
        is set, the function will fail and return NULL. If both flags are set,
        the function will both warn and return NULL.</p>
    <p class="Pp">Similarly, the
        <span class="Li">&quot;UNICODE_WARN_NONCHAR&quot;</span> and
        <span class="Li">&quot;UNICODE_DISALLOW_NONCHAR&quot;</span> flags
        affect how the function handles a Unicode non-character.</p>
    <p class="Pp">And likewise, the
        <span class="Li">&quot;UNICODE_WARN_SUPER&quot;</span> and
        <span class="Li">&quot;UNICODE_DISALLOW_SUPER&quot;</span> flags affect
        the handling of code points that are above the Unicode maximum of
        0x10FFFF. Languages other than Perl may not be able to accept files that
        contain these.</p>
    <p class="Pp">The flag
        <span class="Li">&quot;UNICODE_WARN_ILLEGAL_INTERCHANGE&quot;</span>
        selects all three of the above WARN flags; and
        <span class="Li">&quot;UNICODE_DISALLOW_ILLEGAL_INTERCHANGE&quot;</span>
        selects all three DISALLOW flags.
        <span class="Li">&quot;UNICODE_DISALLOW_ILLEGAL_INTERCHANGE&quot;</span>
        restricts the allowed inputs to the strict UTF-8 traditionally defined
        by Unicode. Similarly,
        <span class="Li">&quot;UNICODE_WARN_ILLEGAL_C9_INTERCHANGE&quot;</span>
        and
        <span class="Li">&quot;UNICODE_DISALLOW_ILLEGAL_C9_INTERCHANGE&quot;</span>
        are shortcuts to select the above-Unicode and surrogate flags, but not
        the non-character ones, as defined in Unicode Corrigendum #9
        &lt;https://www.unicode.org/versions/corrigendum9.html&gt;. See
        &quot;Noncharacter code points&quot; in perlunicode.</p>
    <p class="Pp">Extremely high code points were never specified in any
        standard, and require an extension to UTF-8 to express, which Perl does.
        It is likely that programs written in something other than Perl would
        not be able to read files that contain these; nor would Perl understand
        files written by something that uses a different extension. For these
        reasons, there is a separate set of flags that can warn and/or disallow
        these extremely high code points, even if other above-Unicode ones are
        accepted. They are the
        <span class="Li">&quot;UNICODE_WARN_PERL_EXTENDED&quot;</span> and
        <span class="Li">&quot;UNICODE_DISALLOW_PERL_EXTENDED&quot;</span>
        flags. For more information see
        <span class="Li">&quot;UTF8_GOT_PERL_EXTENDED&quot;</span>. Of course
        <span class="Li">&quot;UNICODE_DISALLOW_SUPER&quot;</span> will treat
        all above-Unicode code points, including these, as malformations. (Note
        that the Unicode standard considers anything above 0x10FFFF to be
        illegal, but there are standards predating it that allow up to
        0x7FFF_FFFF (2**31 -1))</p>
    <p class="Pp">A somewhat misleadingly named synonym for
        <span class="Li">&quot;UNICODE_WARN_PERL_EXTENDED&quot;</span> is
        retained for backward compatibility:
        <span class="Li">&quot;UNICODE_WARN_ABOVE_31_BIT&quot;</span>.
        Similarly,
        <span class="Li">&quot;UNICODE_DISALLOW_ABOVE_31_BIT&quot;</span> is
        usable instead of the more accurately named
        <span class="Li">&quot;UNICODE_DISALLOW_PERL_EXTENDED&quot;</span>. The
        names are misleading because on EBCDIC platforms,these flags can apply
        to code points that actually do fit in 31 bits. The new names accurately
        describe the situation in all cases.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> U8*  uvchr_to_utf8_flags(U8 *d, UV uv, UV flags)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;uvchr_to_utf8_flags_msgs&quot;</dt>
  <dd>THIS FUNCTION SHOULD BE USED IN ONLY VERY SPECIALIZED CIRCUMSTANCES.
    <p class="Pp">Most code should use
        <span class="Li">&quot;&quot;uvchr_to_utf8_flags&quot;()&quot;</span>
        rather than call this directly.</p>
    <p class="Pp">This function is for code that wants any warning and/or error
        messages to be returned to the caller rather than be displayed. All
        messages that would have been displayed if all lexical warnings are
        enabled will be returned.</p>
    <p class="Pp">It is just like
        <span class="Li">&quot;uvchr_to_utf8_flags&quot;</span> but it takes an
        extra parameter placed after all the others,
        <span class="Li">&quot;msgs&quot;</span>. If this parameter is 0, this
        function behaves identically to
        <span class="Li">&quot;uvchr_to_utf8_flags&quot;</span>. Otherwise,
        <span class="Li">&quot;msgs&quot;</span> should be a pointer to an
        <span class="Li">&quot;HV *&quot;</span> variable, in which this
        function creates a new HV to contain any appropriate messages. The hash
        has three key-value pairs, as follows:</p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>&quot;text&quot;</dt>
  <dd>The text of the message as a
    <span class="Li">&quot;SVpv&quot;</span>.</dd>
  <dt>&quot;warn_categories&quot;</dt>
  <dd>The warning category (or categories) packed into a
      <span class="Li">&quot;SVuv&quot;</span>.</dd>
  <dt>&quot;flag&quot;</dt>
  <dd>A single flag bit associated with this message, in a
      <span class="Li">&quot;SVuv&quot;</span>. The bit corresponds to some bit
      in the <span class="Li">*errors</span> return value, such as
      <span class="Li">&quot;UNICODE_GOT_SURROGATE&quot;</span>.</dd>
</dl>
</div>
<div class="Bd-indent">
<p class="Pp">It's important to note that specifying this parameter as non-null
    will cause any warnings this function would otherwise generate to be
    suppressed, and instead be placed in <span class="Li">*msgs</span>. The
    caller can check the lexical warnings state (or not) when choosing what to
    do with the returned messages.</p>
<p class="Pp">The caller, of course, is responsible for freeing any returned
  HV.</p>
<p class="Pp"></p>
<pre> U8*  uvchr_to_utf8_flags_msgs(U8 *d, UV uv, UV flags, HV ** msgs)
</pre>
</div>
<div class="Bd-indent"></div>
</section>
<section class="Sh">
<h1 class="Sh" id="Utility_Functions"><a class="permalink" href="#Utility_Functions">Utility
  Functions</a></h1>
<dl class="Bl-tag">
  <dt>&quot;C_ARRAY_END&quot;</dt>
  <dd>Returns a pointer to one element past the final element of the input C
      array.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void *  C_ARRAY_END(void *a)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;C_ARRAY_LENGTH&quot;</dt>
  <dd>Returns the number of elements in the input C array (so you want your
      zero-based indices to be less than but not equal to).</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> STRLEN  C_ARRAY_LENGTH(void *a)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;getcwd_sv&quot;</dt>
  <dd>Fill <span class="Li">&quot;sv&quot;</span> with current working
    directory</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> int  getcwd_sv(SV* sv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;IN_PERL_COMPILETIME&quot;</dt>
  <dd>Returns 1 if this macro is being called during the compilation phase of
      the program; otherwise 0;</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> bool  IN_PERL_COMPILETIME
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;IN_PERL_RUNTIME&quot;</dt>
  <dd>Returns 1 if this macro is being called during the execution phase of the
      program; otherwise 0;</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> bool  IN_PERL_RUNTIME
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;IS_SAFE_SYSCALL&quot;</dt>
  <dd>Same as &quot;is_safe_syscall&quot;.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> bool  IS_SAFE_SYSCALL(NN const char *pv, STRLEN len,
                       NN const char *what, NN const char *op_name)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;is_safe_syscall&quot;</dt>
  <dd>Test that the given <span class="Li">&quot;pv&quot;</span> (with length
      <span class="Li">&quot;len&quot;</span>) doesn't contain any internal
      <span class="Li">&quot;NUL&quot;</span> characters. If it does, set
      <span class="Li">&quot;errno&quot;</span> to
      <span class="Li">&quot;ENOENT&quot;</span>, optionally warn using the
      <span class="Li">&quot;syscalls&quot;</span> category, and return FALSE.
    <p class="Pp">Return TRUE if the name is safe.</p>
    <p class="Pp"><span class="Li">&quot;what&quot;</span> and
        <span class="Li">&quot;op_name&quot;</span> are used in any warning.</p>
    <p class="Pp">Used by the
        <span class="Li">&quot;IS_SAFE_SYSCALL()&quot;</span> macro.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> bool  is_safe_syscall(const char *pv, STRLEN len,
                       const char *what, const char *op_name)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;my_setenv&quot;</dt>
  <dd>A wrapper for the C library <b>setenv</b>(3). Don't use the latter, as the
      perl version has desirable safeguards</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  my_setenv(const char* nam, const char* val)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;Poison&quot;</dt>
  <dd>PoisonWith(0xEF) for catching access to freed memory.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  Poison(void* dest, int nitems, type)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;PoisonFree&quot;</dt>
  <dd>PoisonWith(0xEF) for catching access to freed memory.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  PoisonFree(void* dest, int nitems, type)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;PoisonNew&quot;</dt>
  <dd>PoisonWith(0xAB) for catching access to allocated but uninitialized
      memory.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  PoisonNew(void* dest, int nitems, type)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;PoisonWith&quot;</dt>
  <dd>Fill up memory with a byte pattern (a byte repeated over and over again)
      that hopefully catches attempts to access uninitialized memory.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  PoisonWith(void* dest, int nitems, type, U8 byte)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;StructCopy&quot;</dt>
  <dd>This is an architecture-independent macro to copy one structure to
      another.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  StructCopy(type *src, type *dest, type)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;sv_destroyable&quot;</dt>
  <dd>Dummy routine which reports that object can be destroyed when there is no
      sharing module present. It ignores its single SV argument, and returns
      'true'. Exists to avoid test for a
      <span class="Li">&quot;NULL&quot;</span> function pointer and because it
      could potentially warn under some level of strict-ness.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> bool  sv_destroyable(SV *sv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;sv_nosharing&quot;</dt>
  <dd>Dummy routine which &quot;shares&quot; an SV when there is no sharing
      module present. Or &quot;locks&quot; it. Or &quot;unlocks&quot; it. In
      other words, ignores its single SV argument. Exists to avoid test for a
      <span class="Li">&quot;NULL&quot;</span> function pointer and because it
      could potentially warn under some level of strict-ness.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  sv_nosharing(SV *sv)
</pre>
</div>
<div class="Bd-indent"></div>
</section>
<section class="Sh">
<h1 class="Sh" id="Versioning"><a class="permalink" href="#Versioning">Versioning</a></h1>
<dl class="Bl-tag">
  <dt>&quot;new_version&quot;</dt>
  <dd>Returns a new version object based on the passed in SV:
    <p class="Pp"></p>
    <pre>    SV *sv = new_version(SV *ver);
    </pre>
    <p class="Pp">Does not alter the passed in ver SV. See
        &quot;upg_version&quot; if you want to upgrade the SV.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> SV*  new_version(SV *ver)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;PERL_REVISION&quot;</dt>
  <dd><span class="Li">&quot;</span><span class="Li"><b>DEPRECATED!</b></span><span class="Li">&quot;</span>
      It is planned to remove <span class="Li">&quot;PERL_REVISION&quot;</span>
      from a future release of Perl. Do not use it for new code; remove it from
      existing code.
    <p class="Pp">The major number component of the perl interpreter currently
        being compiled or executing. This has been <span class="Li">5</span>
        from 1993 into 2020.</p>
    <p class="Pp">Instead use one of the version comparison macros. See
        <span class="Li">&quot;PERL_VERSION_EQ&quot;</span>.</p>
  </dd>
  <dt>&quot;PERL_SUBVERSION&quot;</dt>
  <dd><span class="Li">&quot;</span><span class="Li"><b>DEPRECATED!</b></span><span class="Li">&quot;</span>
      It is planned to remove
      <span class="Li">&quot;PERL_SUBVERSION&quot;</span> from a future release
      of Perl. Do not use it for new code; remove it from existing code.
    <p class="Pp">The micro number component of the perl interpreter currently
        being compiled or executing. In stable releases this gives the dot
        release number for maintenance updates. In development releases this
        gives a tag for a snapshot of the status at various points in the
        development cycle.</p>
    <p class="Pp">Instead use one of the version comparison macros. See
        <span class="Li">&quot;PERL_VERSION_EQ&quot;</span>.</p>
  </dd>
  <dt>&quot;PERL_VERSION&quot;</dt>
  <dd><span class="Li">&quot;</span><span class="Li"><b>DEPRECATED!</b></span><span class="Li">&quot;</span>
      It is planned to remove <span class="Li">&quot;PERL_VERSION&quot;</span>
      from a future release of Perl. Do not use it for new code; remove it from
      existing code.
    <p class="Pp">The minor number component of the perl interpreter currently
        being compiled or executing. Between 1993 into 2020, this has ranged
        from 0 to 33.</p>
    <p class="Pp">Instead use one of the version comparison macros. See
        <span class="Li">&quot;PERL_VERSION_EQ&quot;</span>.</p>
  </dd>
  <dt>&quot;PERL_VERSION_EQ&quot;</dt>
  <dd></dd>
  <dt>&quot;PERL_VERSION_NE&quot;</dt>
  <dd></dd>
  <dt>&quot;PERL_VERSION_LT&quot;</dt>
  <dd></dd>
  <dt>&quot;PERL_VERSION_LE&quot;</dt>
  <dd></dd>
  <dt>&quot;PERL_VERSION_GT&quot;</dt>
  <dd></dd>
  <dt>&quot;PERL_VERSION_GE&quot;</dt>
  <dd>Returns whether or not the perl currently being compiled has the specified
      relationship to the perl given by the parameters. For example,
    <p class="Pp"></p>
    <pre> #if PERL_VERSION_GT(5,24,2)
   code that will only be compiled on perls after v5.24.2
 #else
   fallback code
 #endif
    </pre>
    <p class="Pp">Note that this is usable in making compile-time decisions</p>
    <p class="Pp">You may use the special value '*' for the final number to mean
        ALL possible values for it. Thus,</p>
    <p class="Pp"></p>
    <pre> #if PERL_VERSION_EQ(5,31,'*')
    </pre>
    <p class="Pp">means all perls in the 5.31 series. And</p>
    <p class="Pp"></p>
    <pre> #if PERL_VERSION_NE(5,24,'*')
    </pre>
    <p class="Pp">means all perls EXCEPT 5.24 ones. And</p>
    <p class="Pp"></p>
    <pre> #if PERL_VERSION_LE(5,9,'*')
    </pre>
    <p class="Pp">is effectively</p>
    <p class="Pp"></p>
    <pre> #if PERL_VERSION_LT(5,10,0)
    </pre>
    <p class="Pp">This means you don't have to think so much when converting
        from the existing deprecated
        <span class="Li">&quot;PERL_VERSION&quot;</span> to using this
      macro:</p>
    <p class="Pp"></p>
    <pre> #if PERL_VERSION &lt;= 9
    </pre>
    <p class="Pp">becomes</p>
    <p class="Pp"></p>
    <pre> #if PERL_VERSION_LE(5,9,'*')
    </pre>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> bool  PERL_VERSION_EQ(const U8 major, const U8 minor,
                       const U8 patch)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;prescan_version&quot;</dt>
  <dd>Validate that a given string can be parsed as a version object, but
      doesn't actually perform the parsing. Can use either strict or lax
      validation rules. Can optionally set a number of hint variables to save
      the parsing code some time when tokenizing.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> const char*  prescan_version(const char *s, bool strict,
                              const char** errstr, bool *sqv,
                              int *ssaw_decimal, int *swidth,
                              bool *salpha)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;scan_version&quot;</dt>
  <dd>Returns a pointer to the next character after the parsed version string,
      as well as upgrading the passed in SV to an RV.
    <p class="Pp">Function must be called with an already existing SV like</p>
    <p class="Pp"></p>
    <pre>    sv = newSV(0);
    s = scan_version(s, SV *sv, bool qv);
    </pre>
    <p class="Pp">Performs some preprocessing to the string to ensure that it
        has the correct characteristics of a version. Flags the object if it
        contains an underscore (which denotes this is an alpha version). The
        boolean qv denotes that the version should be interpreted as if it had
        multiple decimals, even if it doesn't.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> const char*  scan_version(const char *s, SV *rv, bool qv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;upg_version&quot;</dt>
  <dd>In-place upgrade of the supplied SV to a version object.
    <p class="Pp"></p>
    <pre>    SV *sv = upg_version(SV *sv, bool qv);
    </pre>
    <p class="Pp">Returns a pointer to the upgraded SV. Set the boolean qv if
        you want to force this SV to be interpreted as an &quot;extended&quot;
        version.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> SV*  upg_version(SV *ver, bool qv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;vcmp&quot;</dt>
  <dd>Version object aware cmp. Both operands must already have been converted
      into version objects.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> int  vcmp(SV *lhv, SV *rhv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;vnormal&quot;</dt>
  <dd>Accepts a version object and returns the normalized string representation.
      Call like:
    <p class="Pp"></p>
    <pre>    sv = vnormal(rv);
    </pre>
    <p class="Pp">NOTE: you can pass either the object directly or the SV
        contained within the RV.</p>
    <p class="Pp">The SV returned has a refcount of 1.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> SV*  vnormal(SV *vs)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;vnumify&quot;</dt>
  <dd>Accepts a version object and returns the normalized floating point
      representation. Call like:
    <p class="Pp"></p>
    <pre>    sv = vnumify(rv);
    </pre>
    <p class="Pp">NOTE: you can pass either the object directly or the SV
        contained within the RV.</p>
    <p class="Pp">The SV returned has a refcount of 1.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> SV*  vnumify(SV *vs)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;vstringify&quot;</dt>
  <dd>In order to maintain maximum compatibility with earlier versions of Perl,
      this function will return either the floating point notation or the
      multiple dotted notation, depending on whether the original version
      contained 1 or more dots, respectively.
    <p class="Pp">The SV returned has a refcount of 1.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> SV*  vstringify(SV *vs)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;vverify&quot;</dt>
  <dd>Validates that the SV contains valid internal structure for a version
      object. It may be passed either the version object (RV) or the hash itself
      (HV). If the structure is valid, it returns the HV. If the structure is
      invalid, it returns NULL.
    <p class="Pp"></p>
    <pre>    SV *hv = vverify(sv);
    </pre>
    <p class="Pp">Note that it only confirms the bare minimum structure (so as
        not to get confused by derived classes which may contain additional hash
        entries):</p>
  </dd>
</dl>
<div class="Bd-indent">
<ul class="Bl-bullet">
  <li>The SV is an HV or a reference to an HV</li>
  <li>The hash contains a &quot;version&quot; key</li>
  <li>The &quot;version&quot; key has a reference to an AV as its value</li>
</ul>
</div>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> SV*  vverify(SV *vs)
</pre>
</div>
<div class="Bd-indent"></div>
</section>
<section class="Sh">
<h1 class="Sh" id="Warning_and_Dieing"><a class="permalink" href="#Warning_and_Dieing">Warning
  and Dieing</a></h1>
<p class="Pp">In all these calls, the <span class="Li">&quot;U32
    w</span><span class="Li"><i>n</i></span><span class="Li">&quot;</span>
    parameters are warning category constants. You can see the ones currently
    available in &quot;Category Hierarchy&quot; in warnings, just capitalize all
    letters in the names and prefix them by
    <span class="Li">&quot;WARN_&quot;</span>. So, for example, the category
    <span class="Li">&quot;void&quot;</span> used in a perl program becomes
    <span class="Li">&quot;WARN_VOID&quot;</span> when used in XS code and
    passed to one of the calls below.</p>
<dl class="Bl-tag">
  <dt>&quot;ckWARN&quot;</dt>
  <dd></dd>
  <dt>&quot;ckWARN2&quot;</dt>
  <dd></dd>
  <dt>&quot;ckWARN3&quot;</dt>
  <dd></dd>
  <dt>&quot;ckWARN4&quot;</dt>
  <dd>These return a boolean as to whether or not warnings are enabled for any
      of the warning category(ies) parameters:
      <span class="Li">&quot;w&quot;</span>,
      <span class="Li">&quot;w1&quot;</span>, ....
    <p class="Pp">Should any of the categories by default be enabled even if not
        within the scope of
        <span class="Li">&quot;use&#x00A0;warnings&quot;</span>, instead use the
        <span class="Li">&quot;ckWARN_d&quot;</span> macros.</p>
    <p class="Pp">The categories must be completely independent, one may not be
        subclassed from the other.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> bool  ckWARN (U32 w)
 bool  ckWARN2(U32 w1, U32 w2)
 bool  ckWARN3(U32 w1, U32 w2, U32 w3)
 bool  ckWARN4(U32 w1, U32 w2, U32 w3, U32 w4)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;ckWARN_d&quot;</dt>
  <dd></dd>
  <dt>&quot;ckWARN2_d&quot;</dt>
  <dd></dd>
  <dt>&quot;ckWARN3_d&quot;</dt>
  <dd></dd>
  <dt>&quot;ckWARN4_d&quot;</dt>
  <dd>Like <span class="Li">&quot;ckWARN&quot;</span>, but for use if and only
      if the warning category(ies) is by default enabled even if not within the
      scope of <span class="Li">&quot;use&#x00A0;warnings&quot;</span>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> bool  ckWARN_d (U32 w)
 bool  ckWARN2_d(U32 w1, U32 w2)
 bool  ckWARN3_d(U32 w1, U32 w2, U32 w3)
 bool  ckWARN4_d(U32 w1, U32 w2, U32 w3, U32 w4)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;ck_warner&quot;</dt>
  <dd></dd>
  <dt>&quot;ck_warner_d&quot;</dt>
  <dd>If none of the warning categories given by
      <span class="Li">&quot;err&quot;</span> are enabled, do nothing; otherwise
      call <span class="Li">&quot;warner&quot;</span> or
      <span class="Li">&quot;warner_nocontext&quot;</span> with the passed-in
      parameters;.
    <p class="Pp"><span class="Li">&quot;err&quot;</span> must be one of the
        <span class="Li">&quot;packWARN&quot;</span>,
        <span class="Li">&quot;packWARN2&quot;</span>,
        <span class="Li">&quot;packWARN3&quot;</span>,
        <span class="Li">&quot;packWARN4&quot;</span> macros populated with the
        appropriate number of warning categories.</p>
    <p class="Pp">The two forms differ only in that
        <span class="Li">&quot;ck_warner_d&quot;</span> should be used if
        warnings for any of the categories are by default enabled.</p>
    <p class="Pp">NOTE: <span class="Li">&quot;ck_warner&quot;</span> must be
        explicitly called as <span class="Li">&quot;Perl_ck_warner&quot;</span>
        with an <span class="Li">&quot;aTHX_&quot;</span> parameter.</p>
    <p class="Pp">NOTE: <span class="Li">&quot;ck_warner_d&quot;</span> must be
        explicitly called as
        <span class="Li">&quot;Perl_ck_warner_d&quot;</span> with an
        <span class="Li">&quot;aTHX_&quot;</span> parameter.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  Perl_ck_warner(pTHX_ U32 err, const char* pat, ...)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;CLEAR_ERRSV&quot;</dt>
  <dd>Clear the contents of <span class="Li">$@</span>, setting it to the empty
      string.
    <p class="Pp">This replaces any read-only SV with a fresh SV and removes any
        magic.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  CLEAR_ERRSV()
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;croak&quot;</dt>
  <dd></dd>
  <dt>&quot;croak_nocontext&quot;</dt>
  <dd>These are XS interfaces to Perl's <span class="Li">&quot;die&quot;</span>
      function.
    <p class="Pp">They take a sprintf-style format pattern and argument list,
        which are used to generate a string message. If the message does not end
        with a newline, then it will be extended with some indication of the
        current location in the code, as described for
        <span class="Li">&quot;mess_sv&quot;</span>.</p>
    <p class="Pp">The error message will be used as an exception, by default
        returning control to the nearest enclosing
        <span class="Li">&quot;eval&quot;</span>, but subject to modification by
        a <span class="Li">$SIG{__DIE__}</span> handler. In any case, these
        croak functions never return normally.</p>
    <p class="Pp">For historical reasons, if
        <span class="Li">&quot;pat&quot;</span> is null then the contents of
        <span class="Li">&quot;ERRSV&quot;</span> (<span class="Li">$@</span>)
        will be used as an error message or object instead of building an error
        message from arguments. If you want to throw a non-string object, or
        build an error message in an SV yourself, it is preferable to use the
        <span class="Li">&quot;croak_sv&quot;</span> function, which does not
        involve clobbering <span class="Li">&quot;ERRSV&quot;</span>.</p>
    <p class="Pp">The two forms differ only in that
        <span class="Li">&quot;croak_nocontext&quot;</span> does not take a
        thread context (<span class="Li">&quot;aTHX&quot;</span>) parameter. It
        is usually preferred as it takes up fewer bytes of code than plain
        <span class="Li">&quot;Perl_croak&quot;</span>, and time is rarely a
        critical resource when you are about to throw an exception.</p>
    <p class="Pp">NOTE: <span class="Li">&quot;croak&quot;</span> must be
        explicitly called as <span class="Li">&quot;Perl_croak&quot;</span> with
        an <span class="Li">&quot;aTHX_&quot;</span> parameter.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  Perl_croak     (pTHX_ const char* pat, ...)
 void  croak_nocontext(const char* pat, ...)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;croak_no_modify&quot;</dt>
  <dd>This encapsulates a common reason for dying, generating terser object code
      than using the generic <span class="Li">&quot;Perl_croak&quot;</span>. It
      is exactly equivalent to <span class="Li">&quot;Perl_croak(aTHX_
      &quot;%s&quot;, PL_no_modify)&quot;</span> (which expands to something
      like &quot;Modification of a read-only value attempted&quot;).
    <p class="Pp">Less code used on exception code paths reduces CPU cache
        pressure.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  croak_no_modify()
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;croak_sv&quot;</dt>
  <dd>This is an XS interface to Perl's <span class="Li">&quot;die&quot;</span>
      function.
    <p class="Pp"><span class="Li">&quot;baseex&quot;</span> is the error
        message or object. If it is a reference, it will be used as-is.
        Otherwise it is used as a string, and if it does not end with a newline
        then it will be extended with some indication of the current location in
        the code, as described for &quot;mess_sv&quot;.</p>
    <p class="Pp">The error message or object will be used as an exception, by
        default returning control to the nearest enclosing
        <span class="Li">&quot;eval&quot;</span>, but subject to modification by
        a <span class="Li">$SIG{__DIE__}</span> handler. In any case, the
        <span class="Li">&quot;croak_sv&quot;</span> function never returns
        normally.</p>
    <p class="Pp">To die with a simple string message, the &quot;croak&quot;
        function may be more convenient.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  croak_sv(SV *baseex)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;die&quot;</dt>
  <dd>Behaves the same as &quot;croak&quot;, except for the return type. It
      should be used only where the <span class="Li">&quot;OP *&quot;</span>
      return type is required. The function never actually returns.
    <p class="Pp">NOTE: <span class="Li">&quot;die&quot;</span> must be
        explicitly called as <span class="Li">&quot;Perl_die&quot;</span> with
        an <span class="Li">&quot;aTHX_&quot;</span> parameter.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> OP*  Perl_die(pTHX_ const char* pat, ...)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;die_sv&quot;</dt>
  <dd></dd>
  <dt>&quot;die_nocontext&quot;</dt>
  <dd>These ehave the same as &quot;croak_sv&quot;, except for the return type.
      It should be used only where the <span class="Li">&quot;OP *&quot;</span>
      return type is required. The functions never actually return.
    <p class="Pp">The two forms differ only in that
        <span class="Li">&quot;die_nocontext&quot;</span> does not take a thread
        context (<span class="Li">&quot;aTHX&quot;</span>) parameter, so is used
        in situations where the caller doesn't already have the thread
      context.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> OP*  die_sv       (SV *baseex)
 OP*  die_nocontext(const char* pat, ...)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;ERRSV&quot;</dt>
  <dd>Returns the SV for <span class="Li">$@</span>, creating it if needed.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> SV *  ERRSV
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;packWARN&quot;</dt>
  <dd></dd>
  <dt>&quot;packWARN2&quot;</dt>
  <dd></dd>
  <dt>&quot;packWARN3&quot;</dt>
  <dd></dd>
  <dt>&quot;packWARN4&quot;</dt>
  <dd>These macros are used to pack warning categories into a single U32 to pass
      to macros and functions that take a warning category parameter. The number
      of categories to pack is given by the name, with a corresponding number of
      category parameters passed.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> U32  packWARN (U32 w1)
 U32  packWARN2(U32 w1, U32 w2)
 U32  packWARN3(U32 w1, U32 w2, U32 w3)
 U32  packWARN4(U32 w1, U32 w2, U32 w3, U32 w4)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;PL_curcop&quot;</dt>
  <dd>The currently active COP (control op) roughly representing the current
      statement in the source.
    <p class="Pp">On threaded perls, each thread has an independent copy of this
        variable; each initialized at creation time with the current value of
        the creating thread's copy.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> COP*  PL_curcop
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;PL_curstash&quot;</dt>
  <dd>The stash for the package code will be compiled into.
    <p class="Pp">On threaded perls, each thread has an independent copy of this
        variable; each initialized at creation time with the current value of
        the creating thread's copy.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> HV*  PL_curstash
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;PL_defgv&quot;</dt>
  <dd>The GV representing <span class="Li">*_</span>. Useful for access to
      <span class="Li">$_</span>.
    <p class="Pp">On threaded perls, each thread has an independent copy of this
        variable; each initialized at creation time with the current value of
        the creating thread's copy.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> GV *  PL_defgv
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;SANE_ERRSV&quot;</dt>
  <dd>Clean up ERRSV so we can safely set it.
    <p class="Pp">This replaces any read-only SV with a fresh writable copy and
        removes any magic.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  SANE_ERRSV()
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;vcroak&quot;</dt>
  <dd>This is an XS interface to Perl's <span class="Li">&quot;die&quot;</span>
      function.
    <p class="Pp"><span class="Li">&quot;pat&quot;</span> and
        <span class="Li">&quot;args&quot;</span> are a sprintf-style format
        pattern and encapsulated argument list. These are used to generate a
        string message. If the message does not end with a newline, then it will
        be extended with some indication of the current location in the code, as
        described for &quot;mess_sv&quot;.</p>
    <p class="Pp">The error message will be used as an exception, by default
        returning control to the nearest enclosing
        <span class="Li">&quot;eval&quot;</span>, but subject to modification by
        a <span class="Li">$SIG{__DIE__}</span> handler. In any case, the
        <span class="Li">&quot;croak&quot;</span> function never returns
        normally.</p>
    <p class="Pp">For historical reasons, if
        <span class="Li">&quot;pat&quot;</span> is null then the contents of
        <span class="Li">&quot;ERRSV&quot;</span> (<span class="Li">$@</span>)
        will be used as an error message or object instead of building an error
        message from arguments. If you want to throw a non-string object, or
        build an error message in an SV yourself, it is preferable to use the
        &quot;croak_sv&quot; function, which does not involve clobbering
        <span class="Li">&quot;ERRSV&quot;</span>.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  vcroak(const char* pat, va_list* args)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;vwarn&quot;</dt>
  <dd>This is an XS interface to Perl's <span class="Li">&quot;warn&quot;</span>
      function.
    <p class="Pp">This is like <span class="Li">&quot;warn&quot;</span>, but
        <span class="Li">&quot;args&quot;</span> are an encapsulated argument
        list.</p>
    <p class="Pp">Unlike with &quot;vcroak&quot;,
        <span class="Li">&quot;pat&quot;</span> is not permitted to be null.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  vwarn(const char* pat, va_list* args)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;vwarner&quot;</dt>
  <dd>This is like <span class="Li">&quot;warner&quot;</span>, but
      <span class="Li">&quot;args&quot;</span> are an encapsulated argument
      list.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  vwarner(U32 err, const char* pat, va_list* args)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;warn&quot;</dt>
  <dd></dd>
  <dt>&quot;warn_nocontext&quot;</dt>
  <dd>These are XS interfaces to Perl's <span class="Li">&quot;warn&quot;</span>
      function.
    <p class="Pp">They take a sprintf-style format pattern and argument list,
        which are used to generate a string message. If the message does not end
        with a newline, then it will be extended with some indication of the
        current location in the code, as described for
        <span class="Li">&quot;mess_sv&quot;</span>.</p>
    <p class="Pp">The error message or object will by default be written to
        standard error, but this is subject to modification by a
        <span class="Li">$SIG{__WARN__}</span> handler.</p>
    <p class="Pp">Unlike with <span class="Li">&quot;croak&quot;</span>,
        <span class="Li">&quot;pat&quot;</span> is not permitted to be null.</p>
    <p class="Pp">The two forms differ only in that
        <span class="Li">&quot;warn_nocontext&quot;</span> does not take a
        thread context (<span class="Li">&quot;aTHX&quot;</span>) parameter, so
        is used in situations where the caller doesn't already have the thread
        context.</p>
    <p class="Pp">NOTE: <span class="Li">&quot;warn&quot;</span> must be
        explicitly called as <span class="Li">&quot;Perl_warn&quot;</span> with
        an <span class="Li">&quot;aTHX_&quot;</span> parameter.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  Perl_warn     (pTHX_ const char* pat, ...)
 void  warn_nocontext(const char* pat, ...)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;warner&quot;</dt>
  <dd></dd>
  <dt>&quot;warner_nocontext&quot;</dt>
  <dd>These output a warning of the specified category (or categories) given by
      <span class="Li">&quot;err&quot;</span>, using the sprintf-style format
      pattern <span class="Li">&quot;pat&quot;</span>, and argument list.
    <p class="Pp"><span class="Li">&quot;err&quot;</span> must be one of the
        <span class="Li">&quot;packWARN&quot;</span>,
        <span class="Li">&quot;packWARN2&quot;</span>,
        <span class="Li">&quot;packWARN3&quot;</span>,
        <span class="Li">&quot;packWARN4&quot;</span> macros populated with the
        appropriate number of warning categories. If any of the warning
        categories they specify is fatal, a fatal exception is thrown.</p>
    <p class="Pp">In any event a message is generated by the pattern and
        arguments. If the message does not end with a newline, then it will be
        extended with some indication of the current location in the code, as
        described for &quot;mess_sv&quot;.</p>
    <p class="Pp">The error message or object will by default be written to
        standard error, but this is subject to modification by a
        <span class="Li">$SIG{__WARN__}</span> handler.</p>
    <p class="Pp"><span class="Li">&quot;pat&quot;</span> is not permitted to be
        null.</p>
    <p class="Pp">The two forms differ only in that
        <span class="Li">&quot;warner_nocontext&quot;</span> does not take a
        thread context (<span class="Li">&quot;aTHX&quot;</span>) parameter, so
        is used in situations where the caller doesn't already have the thread
        context.</p>
    <p class="Pp">These functions differ from the similarly named
        <span class="Li">&quot;warn&quot;</span> functions, in that the latter
        are for XS code to unconditionally display a warning, whereas these are
        for code that may be compiling a perl program, and does extra checking
        to see if the warning should be fatal.</p>
    <p class="Pp">NOTE: <span class="Li">&quot;warner&quot;</span> must be
        explicitly called as <span class="Li">&quot;Perl_warner&quot;</span>
        with an <span class="Li">&quot;aTHX_&quot;</span> parameter.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  Perl_warner     (pTHX_ U32 err, const char* pat, ...)
 void  warner_nocontext(U32 err, const char* pat, ...)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;warn_sv&quot;</dt>
  <dd>This is an XS interface to Perl's <span class="Li">&quot;warn&quot;</span>
      function.
    <p class="Pp"><span class="Li">&quot;baseex&quot;</span> is the error
        message or object. If it is a reference, it will be used as-is.
        Otherwise it is used as a string, and if it does not end with a newline
        then it will be extended with some indication of the current location in
        the code, as described for &quot;mess_sv&quot;.</p>
    <p class="Pp">The error message or object will by default be written to
        standard error, but this is subject to modification by a
        <span class="Li">$SIG{__WARN__}</span> handler.</p>
    <p class="Pp">To warn with a simple string message, the &quot;warn&quot;
        function may be more convenient.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  warn_sv(SV *baseex)
</pre>
</div>
<div class="Bd-indent"></div>
</section>
<section class="Sh">
<h1 class="Sh" id="XS"><a class="permalink" href="#XS">XS</a></h1>
<p class="Pp"><i>xsubpp</i> compiles XS code into C. See &quot;xsubpp&quot; in
    perlutil.</p>
<dl class="Bl-tag">
  <dt>&quot;ax&quot;</dt>
  <dd>Variable which is setup by <span class="Li">&quot;xsubpp&quot;</span> to
      indicate the stack base offset, used by the
      <span class="Li">&quot;ST&quot;</span>,
      <span class="Li">&quot;XSprePUSH&quot;</span> and
      <span class="Li">&quot;XSRETURN&quot;</span> macros. The
      <span class="Li">&quot;dMARK&quot;</span> macro must be called prior to
      setup the <span class="Li">&quot;MARK&quot;</span> variable.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> I32  ax
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;CLASS&quot;</dt>
  <dd>Variable which is setup by <span class="Li">&quot;xsubpp&quot;</span> to
      indicate the class name for a C++ XS constructor. This is always a
      <span class="Li">&quot;char*&quot;</span>. See
      <span class="Li">&quot;THIS&quot;</span>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> char*  CLASS
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;dAX&quot;</dt>
  <dd>Sets up the <span class="Li">&quot;ax&quot;</span> variable. This is
      usually handled automatically by
      <span class="Li">&quot;xsubpp&quot;</span> by calling
      <span class="Li">&quot;dXSARGS&quot;</span>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre>   dAX;
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;dAXMARK&quot;</dt>
  <dd>Sets up the <span class="Li">&quot;ax&quot;</span> variable and stack
      marker variable <span class="Li">&quot;mark&quot;</span>. This is usually
      handled automatically by <span class="Li">&quot;xsubpp&quot;</span> by
      calling <span class="Li">&quot;dXSARGS&quot;</span>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre>   dAXMARK;
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;dITEMS&quot;</dt>
  <dd>Sets up the <span class="Li">&quot;items&quot;</span> variable. This is
      usually handled automatically by
      <span class="Li">&quot;xsubpp&quot;</span> by calling
      <span class="Li">&quot;dXSARGS&quot;</span>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre>   dITEMS;
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;dMY_CXT_SV&quot;</dt>
  <dd>Now a placeholder that declares nothing</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre>   dMY_CXT_SV;
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;dUNDERBAR&quot;</dt>
  <dd>Sets up any variable needed by the
      <span class="Li">&quot;UNDERBAR&quot;</span> macro. It used to define
      <span class="Li">&quot;padoff_du&quot;</span>, but it is currently a noop.
      However, it is strongly advised to still use it for ensuring past and
      future compatibility.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre>   dUNDERBAR;
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;dXSARGS&quot;</dt>
  <dd>Sets up stack and mark pointers for an XSUB, calling
      <span class="Li">&quot;dSP&quot;</span> and
      <span class="Li">&quot;dMARK&quot;</span>. Sets up the
      <span class="Li">&quot;ax&quot;</span> and
      <span class="Li">&quot;items&quot;</span> variables by calling
      <span class="Li">&quot;dAX&quot;</span> and
      <span class="Li">&quot;dITEMS&quot;</span>. This is usually handled
      automatically by <span class="Li">&quot;xsubpp&quot;</span>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre>   dXSARGS;
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;dXSI32&quot;</dt>
  <dd>Sets up the <span class="Li">&quot;ix&quot;</span> variable for an XSUB
      which has aliases. This is usually handled automatically by
      <span class="Li">&quot;xsubpp&quot;</span>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre>   dXSI32;
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;items&quot;</dt>
  <dd>Variable which is setup by <span class="Li">&quot;xsubpp&quot;</span> to
      indicate the number of items on the stack. See &quot;Variable-length
      Parameter Lists&quot; in perlxs.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> I32  items
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;ix&quot;</dt>
  <dd>Variable which is setup by <span class="Li">&quot;xsubpp&quot;</span> to
      indicate which of an XSUB's aliases was used to invoke it. See &quot;The
      ALIAS: Keyword&quot; in perlxs.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> I32  ix
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;RETVAL&quot;</dt>
  <dd>Variable which is setup by <span class="Li">&quot;xsubpp&quot;</span> to
      hold the return value for an XSUB. This is always the proper type for the
      XSUB. See &quot;The RETVAL Variable&quot; in perlxs.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> type  RETVAL
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;ST&quot;</dt>
  <dd>Used to access elements on the XSUB's stack.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> SV*  ST(int ix)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;THIS&quot;</dt>
  <dd>Variable which is setup by <span class="Li">&quot;xsubpp&quot;</span> to
      designate the object in a C++ XSUB. This is always the proper type for the
      C++ object. See <span class="Li">&quot;CLASS&quot;</span> and &quot;Using
      XS With C++&quot; in perlxs.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> type  THIS
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;UNDERBAR&quot;</dt>
  <dd>The SV* corresponding to the <span class="Li">$_</span> variable. Works
      even if there is a lexical <span class="Li">$_</span> in scope.</dd>
  <dt>&quot;XS&quot;</dt>
  <dd>Macro to declare an XSUB and its C parameter list. This is handled by
      <span class="Li">&quot;xsubpp&quot;</span>. It is the same as using the
      more explicit <span class="Li">&quot;XS_EXTERNAL&quot;</span> macro; the
      latter is preferred.</dd>
  <dt>&quot;XS_EXTERNAL&quot;</dt>
  <dd>Macro to declare an XSUB and its C parameter list explicitly exporting the
      symbols.</dd>
  <dt>&quot;XS_INTERNAL&quot;</dt>
  <dd>Macro to declare an XSUB and its C parameter list without exporting the
      symbols. This is handled by <span class="Li">&quot;xsubpp&quot;</span> and
      generally preferable over exporting the XSUB symbols unnecessarily.</dd>
  <dt>&quot;XSPROTO&quot;</dt>
  <dd>Macro used by <span class="Li">&quot;XS_INTERNAL&quot;</span> and
      <span class="Li">&quot;XS_EXTERNAL&quot;</span> to declare a function
      prototype. You probably shouldn't be using this directly yourself.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="Undocumented_elements"><a class="permalink" href="#Undocumented_elements">Undocumented
  elements</a></h1>
<p class="Pp">The following functions have been flagged as part of the public
    API, but are currently undocumented. Use them at your own risk, as the
    interfaces are subject to change. Functions that are not listed in this
    document are not intended for public use, and should NOT be used under any
    circumstances.</p>
<p class="Pp">If you feel you need to use one of these functions, first send
    email to perl5-porters@perl.org &lt;mailto:perl5-porters@perl.org&gt;. It
    may be that there is a good reason for the function not being documented,
    and it should be removed from this list; or it may just be that no one has
    gotten around to documenting it. In the latter case, you will be asked to
    submit a patch to document the function. Once your patch is accepted, it
    will indicate that the interface is stable (unless it is explicitly marked
    otherwise) and usable by you.</p>
<p class="Pp"></p>
<p class="Pp"></p>
<pre> amagic_call        gv_name_set            PerlIO_fill
 amagic_deref_call  gv_SVadd               PerlIO_unread
 any_dup            he_dup                 pmop_dump
 atfork_lock        hek_dup                pop_scope
 atfork_unlock      hv_delayfree_ent       pregfree
 block_gimme        hv_eiter_p             ptr_table_fetch
 call_atexit        hv_eiter_set           ptr_table_free
 call_list          hv_free_ent            ptr_table_new
 clear_defarray     hv_ksplit              ptr_table_split
 clone_params_del   hv_name_set            ptr_table_store
 clone_params_new   hv_placeholders_get    push_scope
 CvDEPTH            hv_placeholders_set    re_compile
 deb                hv_rand_set            regdump
 deb_nocontext      hv_riter_p             repeatcpy
 debop              hv_riter_set           rsignal_state
 debprofdump        init_stacks            rvpv_dup
 debstack           init_tm                save_adelete
 debstackptrs       is_lvalue_sub          save_aelem
 dirp_dup           leave_scope            save_aelem_flags
 do_aspawn          magic_dump             save_alloc
 do_close           markstack_grow         save_generic_pvref
 do_join            mfree                  save_generic_svref
 do_open            mg_dup                 save_hdelete
 do_openn           mg_size                save_helem
 doref              mro_get_from_name      save_helem_flags
 do_spawn           mro_set_mro            save_hints
 do_spawn_nowait    my_chsize              save_op
 do_sprintf         my_cxt_init            save_padsv_and_mortalize
 dounwind           my_dirfd               save_pushi32ptr
 dowantarray        my_failure_exit        save_pushptr
 dump_eval          my_fflush_all          save_pushptrptr
 dump_form          my_fork                save_set_svflags
 dump_mstats        my_pclose              save_shared_pvref
 dump_sub           my_popen               savestack_grow
 filter_del         my_popen_list          savestack_grow_cnt
 fp_dup             my_socketpair          save_vptr
 get_context        newANONATTRSUB         scan_vstring
 get_mstats         newANONHASH            seed
 get_op_descs       newANONLIST            set_context
 get_op_names       newANONSUB             share_hek
 get_ppaddr         newAVREF               si_dup
 get_vtbl           newCVREF               ss_dup
 gp_dup             newFORM                start_subparse
 gp_free            newGVgen               sv_2pvbyte_flags
 gp_ref             newGVgen_flags         sv_2pvutf8_flags
 gv_add_by_type     newGVREF               SvAMAGIC_off
 Gv_AMupdate        newHVhv                SvAMAGIC_on
 gv_autoload_pv     newHVREF               sv_dup
 gv_autoload_pvn    newIO                  sv_dup_inc
 gv_autoload_sv     newMYSUB               sv_peek
 gv_AVadd           newPROG                sys_intern_clear
 gv_dump            new_stackinfo          sys_intern_dup
 gv_efullname3      newSVREF               sys_intern_init
 gv_efullname4      op_refcnt_lock         taint_env
 gv_fullname3       op_refcnt_unlock       taint_proper
 gv_fullname4       parser_dup             unsharepvn
 gv_handler         perl_alloc_using       vdeb
 gv_HVadd           perl_clone_using       
 gv_IOadd           PerlIO_context_layers
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHORS"><a class="permalink" href="#AUTHORS">AUTHORS</a></h1>
<p class="Pp">Until May 1997, this document was maintained by Jeff Okamoto
    &lt;okamoto@corp.hp.com&gt;. It is now maintained as part of Perl
  itself.</p>
<p class="Pp">With lots of help and suggestions from Dean Roehrich, Malcolm
    Beattie, Andreas Koenig, Paul Hudson, Ilya Zakharevich, Paul Marquess, Neil
    Bowers, Matthew Green, Tim Bunce, Spider Boardman, Ulrich Pfeifer, Stephen
    McCamant, and Gurusamy Sarathy.</p>
<p class="Pp">API Listing originally by Dean Roehrich
  &lt;roehrich@cray.com&gt;.</p>
<p class="Pp">Updated to be autogenerated from comments in the source by
    Benjamin Stuhl.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp"><i>config.h</i>, perlapio, perlcall, perlclib, perlfilter,
    perlguts, perlintern, perlinterp, perliol, perlmroapi, perlreguts,
  perlxs</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2024-01-10</td>
    <td class="foot-os">perl v5.34.1</td>
  </tr>
</table>
</body>
</html>
