<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    .Nd, .Bf, .Op { display: inline; }
    .Pa, .Ad { font-style: italic; }
    .Ms { font-weight: bold; }
    .Bl-diag > dt { font-weight: bold; }
    code.Nm, .Fl, .Cm, .Ic, code.In, .Fd, .Fn, .Cd { font-weight: bold;
      font-family: inherit; }
  </style>
  <title>Util(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Util(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Util(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">NetAddr::IP::Util -- IPv4/6 and 128 bit number utilities</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>  use NetAddr::IP::Util qw(
        inet_aton
        inet_ntoa
        ipv6_aton
        ipv6_ntoa
        ipv6_n2x
        ipv6_n2d
        inet_any2n
        hasbits
        isIPv4
        isNewIPv4
        isAnyIPv4
        inet_n2dx
        inet_n2ad
        inet_pton
        inet_ntop
        inet_4map6
        ipv4to6
        mask4to6
        ipanyto6
        maskanyto6
        ipv6to4
        packzeros
        shiftleft
        addconst
        add128
        sub128
        notcontiguous
        bin2bcd
        bcd2bin
        mode
        AF_INET
        AF_INET6
        naip_gethostbyname
  );
  use NetAddr::IP::Util qw(:all :inet :ipv4 :ipv6 :math)
  :inet   =&gt;    inet_aton, inet_ntoa, ipv6_aton
                ipv6_ntoa, ipv6_n2x, ipv6_n2d, 
                inet_any2n, inet_n2dx, inet_n2ad, 
                inet_pton, inet_ntop, inet_4map6, 
                ipv4to6, mask4to6, ipanyto6, packzeros
                maskanyto6, ipv6to4, naip_gethostbyname
  :ipv4   =&gt;    inet_aton, inet_ntoa
  :ipv6   =&gt;    ipv6_aton, ipv6_ntoa, ipv6_n2x, 
                ipv6_n2d, inet_any2n, inet_n2dx, 
                inet_n2ad, inet_pton, inet_ntop,
                inet_4map6, ipv4to6, mask4to6,
                ipanyto6, maskanyto6, ipv6to4,
                packzeros, naip_gethostbyname
  :math   =&gt;    hasbits, isIPv4, isNewIPv4, isAnyIPv4,
                addconst, add128, sub128, notcontiguous,
                bin2bcd, bcd2bin, shiftleft
  $dotquad = inet_ntoa($netaddr);
  $netaddr = inet_aton($dotquad);
  $ipv6naddr = ipv6_aton($ipv6_text);
  $ipv6_text = ipvt_ntoa($ipv6naddr);
  $hex_text = ipv6_n2x($ipv6naddr);
  $dec_text = ipv6_n2d($ipv6naddr);
  $hex_text = packzeros($hex_text);
  $ipv6naddr = inet_any2n($dotquad or $ipv6_text);
  $ipv6naddr = inet_4map6($netaddr or $ipv6naddr);
  $rv = hasbits($bits128);
  $rv = isIPv4($bits128);
  $rv = isNewIPv4($bits128);
  $rv = isAnyIPv4($bits128);
  $dotquad or $hex_text = inet_n2dx($ipv6naddr);
  $dotquad or $dec_text = inet_n2ad($ipv6naddr);
  $netaddr = inet_pton($AF_family,$hex_text);
  $hex_text = inet_ntop($AF_family,$netaddr);
  $ipv6naddr = ipv4to6($netaddr);
  $ipv6naddr = mask4to6($netaddr);
  $ipv6naddr = ipanyto6($netaddr);
  $ipv6naddr = maskanyto6($netaddr);
  $netaddr = ipv6to4($pv6naddr);
  $bitsX2 = shiftleft($bits128,$n);
  $carry = addconst($ipv6naddr,$signed_32con);
  ($carry,$ipv6naddr)=addconst($ipv6naddr,$signed_32con);
  $carry = add128($ipv6naddr1,$ipv6naddr2);
  ($carry,$ipv6naddr)=add128($ipv6naddr1,$ipv6naddr2);
  $carry = sub128($ipv6naddr1,$ipv6naddr2);
  ($carry,$ipv6naddr)=sub128($ipv6naddr1,$ipv6naddr2);
  ($spurious,$cidr) = notcontiguous($mask128);
  $bcdtext = bin2bcd($bits128);
  $bits128 = bcd2bin($bcdtxt);
  $modetext = mode;
  ($name,$aliases,$addrtype,$length,@addrs)=naip_gethostbyname(NAME);
  $trueif = havegethostbyname2();
  NetAddr::IP::Util::lower();
  NetAddr::IP::Util::upper();
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="INSTALLATION"><a class="permalink" href="#INSTALLATION">INSTALLATION</a></h1>
<p class="Pp">Un-tar the distribution in an appropriate directory and type:</p>
<p class="Pp"></p>
<pre>        perl Makefile.PL
        make
        make test
        make install
</pre>
<p class="Pp"><b>NetAddr::IP::Util</b> installs by default with its primary
    functions compiled using Perl's XS extensions to build a 'C' library. If you
    do not have a 'C' complier available or would like the slower Pure Perl
    version for some other reason, then type:</p>
<p class="Pp"></p>
<pre>        perl Makefile.PL -noxs
        make
        make test
        make install
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp"><b>NetAddr::IP::Util</b> provides a suite of tools for
    manipulating and converting IPv4 and IPv6 addresses into 128 bit string
    context and back to text. The strings can be manipulated with Perl's logical
    operators:</p>
<p class="Pp"></p>
<pre>        and     &amp;
        or      |
        xor     ^
                ~       compliment
</pre>
<p class="Pp">in the same manner as 'vec' strings.</p>
<p class="Pp">The IPv6 functions support all rfc1884 formats.</p>
<p class="Pp"></p>
<pre>  i.e.  x:x:x:x:x:x:x:x:x
        x:x:x:x:x:x:x:d.d.d.d
        ::x:x:x
        ::x:d.d.d.d
  and so on...
</pre>
<ul class="Bl-bullet">
  <li><span class="Li">$dotquad</span> = inet_ntoa($netaddr);
    <p class="Pp">Convert a packed IPv4 network address to a dot-quad IP
        address.</p>
    <p class="Pp"></p>
    <pre>  input:        packed network address
  returns:      IP address i.e. 10.4.12.123
    </pre>
  </li>
  <li><span class="Li">$netaddr</span> = inet_aton($dotquad);
    <p class="Pp">Convert a dot-quad IP address into an IPv4 packed network
        address.</p>
    <p class="Pp"></p>
    <pre>  input:        IP address i.e. 192.5.16.32
  returns:      packed network address
    </pre>
  </li>
  <li><span class="Li">$ipv6addr</span> = ipv6_aton($ipv6_text);
    <p class="Pp">Takes an IPv6 address of the form described in rfc1884 and
        returns a 128 bit binary RDATA string.</p>
    <p class="Pp"></p>
    <pre>  input:        ipv6 text
  returns:      128 bit RDATA string
    </pre>
  </li>
  <li><span class="Li">$ipv6_text</span> = ipv6_ntoa($ipv6naddr);
    <p class="Pp">Convert a 128 bit binary IPv6 address to compressed rfc 1884
        text representation.</p>
    <p class="Pp"></p>
    <pre>  input:        128 bit RDATA string
  returns:      ipv6 text
    </pre>
  </li>
  <li><span class="Li">$hex_text</span> = ipv6_n2x($ipv6addr);
    <p class="Pp">Takes an IPv6 RDATA string and returns an 8 segment IPv6 hex
        address</p>
    <p class="Pp"></p>
    <pre>  input:        128 bit RDATA string
  returns:      x:x:x:x:x:x:x:x
    </pre>
  </li>
  <li><span class="Li">$dec_text</span> = ipv6_n2d($ipv6addr);
    <p class="Pp">Takes an IPv6 RDATA string and returns a mixed hex - decimal
        IPv6 address with the 6 uppermost chunks in hex and the lower 32 bits in
        dot-quad representation.</p>
    <p class="Pp"></p>
    <pre>  input:        128 bit RDATA string
  returns:      x:x:x:x:x:x:d.d.d.d
    </pre>
  </li>
  <li><span class="Li">$ipv6naddr</span> = inet_any2n($dotquad or
      <span class="Li">$ipv6_text</span>);
    <p class="Pp">This function converts a text IPv4 or IPv6 address in text
        format in any standard notation into a 128 bit IPv6 string address. It
        prefixes any dot-quad address (if found) with '::' and passes it to
        <b>ipv6_aton</b>.</p>
    <p class="Pp"></p>
    <pre>  input:        dot-quad or rfc1844 address
  returns:      128 bit IPv6 string
    </pre>
  </li>
  <li><span class="Li">$rv</span> = hasbits($bits128);
    <p class="Pp">This function returns true if there are one's present in the
        128 bit string and false if all the bits are zero.</p>
    <p class="Pp"></p>
    <pre>  i.e.  if (hasbits($bits128)) {
          &amp;do_something;
        }
  or    if (hasbits($bits128 &amp; $mask128) {
          &amp;do_something;
        }
    </pre>
    <p class="Pp">This allows the implementation of logical functions of the
        form of:</p>
    <p class="Pp"></p>
    <pre>        if ($bits128 &amp; $mask128) {
            ...
  input:        128 bit IPv6 string
  returns:      true if any bits are present
    </pre>
  </li>
  <li><span class="Li">$ipv6naddr</span> = inet_4map6($netaddr or
      <span class="Li">$ipv6naddr</span>
    <p class="Pp">This function returns an ipV6 network address with the first
        80 bits set to zero and the next 16 bits set to one, while the last 32
        bits are filled with the ipV4 address.</p>
    <p class="Pp"></p>
    <pre>  input:        ipV4 netaddr
            or  ipV6 netaddr
  returns:      ipV6 netaddr
  returns: undef on error
    </pre>
    <p class="Pp">An ipV6 network address must be in one of the two compatible
        ipV4 mapped address spaces. i.e.</p>
    <p class="Pp"></p>
    <pre>        ::ffff::d.d.d.d    or    ::d.d.d.d
    </pre>
  </li>
  <li><span class="Li">$rv</span> = isIPv4($bits128);
    <p class="Pp">This function returns true if there are no on bits present in
        the IPv6 portion of the 128 bit string and false otherwise.</p>
    <p class="Pp"></p>
    <pre>  i.e.  the address must be of the form - ::d.d.d.d
    </pre>
    <p class="Pp">Note: this is an old and deprecated ipV4 compatible ipV6
        address</p>
  </li>
  <li><span class="Li">$rv</span> = isNewIPv4($bits128);
    <p class="Pp">This function return true if the IPv6 128 bit string is of the
        form</p>
    <p class="Pp"></p>
    <pre>        ::ffff::d.d.d.d
    </pre>
  </li>
  <li><span class="Li">$rv</span> = isAnyIPv4($bits128);
    <p class="Pp">This function return true if the IPv6 bit string is of the
        form</p>
    <p class="Pp"></p>
    <pre>        ::d.d.d.d       or      ::ffff::d.d.d.d
    </pre>
  </li>
  <li><span class="Li">$dotquad</span> or <span class="Li">$hex_text</span> =
      inet_n2dx($ipv6naddr);
    <p class="Pp">This function <b>does the right thing</b> and returns the text
        for either a dot-quad IPv4 or a hex notation IPv6 address.</p>
    <p class="Pp"></p>
    <pre>  input:        128 bit IPv6 string
  returns:      ddd.ddd.ddd.ddd
            or  x:x:x:x:x:x:x:x
    </pre>
  </li>
  <li><span class="Li">$dotquad</span> or <span class="Li">$dec_text</span> =
      inet_n2ad($ipv6naddr);
    <p class="Pp">This function <b>does the right thing</b> and returns the text
        for either a dot-quad IPv4 or a hex::decimal notation IPv6 address.</p>
    <p class="Pp"></p>
    <pre>  input:        128 bit IPv6 string
  returns:      ddd.ddd.ddd.ddd
            or  x:x:x:x:x:x:ddd.ddd.ddd.dd
    </pre>
  </li>
  <li><span class="Li">$netaddr</span> = inet_pton($AF_family,$hex_text);
    <p class="Pp">This function takes an IP address in IPv4 or IPv6 text format
        and converts it into binary format. The type of IP address conversion is
        controlled by the FAMILY argument.</p>
  </li>
  <li><span class="Li">$hex_text</span> = inet_ntop($AF_family,$netaddr);
    <p class="Pp">This function takes and IP address in binary format and
        converts it into text format. The type of IP address conversion is
        controlled by the FAMILY argument.</p>
    <p class="Pp">NOTE: inet_ntop ALWAYS returns lowercase characters.</p>
  </li>
  <li><span class="Li">$hex_text</span> = packzeros($hex_text);
    <p class="Pp">This function optimizes and rfc 1884 IPv6 hex address to
        reduce the number of long strings of zero bits as specified in rfc 1884,
        2.2 (2) by substituting <b>::</b> for the first occurence of the longest
        string of zeros in the address.</p>
  </li>
  <li><span class="Li">$ipv6naddr</span> = ipv4to6($netaddr);
    <p class="Pp">Convert an ipv4 network address into an IPv6 network
      address.</p>
    <p class="Pp"></p>
    <pre>  input:        32 bit network address
  returns:      128 bit network address
    </pre>
  </li>
  <li><span class="Li">$ipv6naddr</span> = mask4to6($netaddr);
    <p class="Pp">Convert an ipv4 network address/mask into an ipv6 network
        mask.</p>
    <p class="Pp"></p>
    <pre>  input:        32 bit network/mask address
  returns:      128 bit network/mask address
    </pre>
    <p class="Pp">NOTE: returns the high 96 bits as one's</p>
  </li>
  <li><span class="Li">$ipv6naddr</span> = ipanyto6($netaddr);
    <p class="Pp">Similar to ipv4to6 except that this function takes either an
        IPv4 or IPv6 input and always returns a 128 bit IPv6 network
      address.</p>
    <p class="Pp"></p>
    <pre>  input:        32 or 128 bit network address
  returns:      128 bit network address
    </pre>
  </li>
  <li><span class="Li">$ipv6naddr</span> = maskanyto6($netaddr);
    <p class="Pp">Similar to mask4to6 except that this function takes either an
        IPv4 or IPv6 netmask and always returns a 128 bit IPv6 netmask.</p>
    <p class="Pp"></p>
    <pre>  input:        32 or 128 bit network mask
  returns:      128 bit network mask
    </pre>
  </li>
  <li><span class="Li">$netaddr</span> = ipv6to4($pv6naddr);
    <p class="Pp">Truncate the upper 96 bits of a 128 bit address and return the
        lower 32 bits. Returns an IPv4 address as returned by inet_aton.</p>
    <p class="Pp"></p>
    <pre>  input:        128 bit network address
  returns:      32 bit inet_aton network address
    </pre>
  </li>
  <li><span class="Li">$bitsXn</span> = shiftleft($bits128,$n);
    <p class="Pp"></p>
    <pre>  input:        128 bit string variable,
                number of shifts [optional]
  returns:      bits X n shifts
  NOTE: a single shift is performed
        if $n is not specified
    </pre>
  </li>
  <li>addconst($ipv6naddr,$signed_32con);
    <p class="Pp">Add a signed constant to a 128 bit string variable.</p>
    <p class="Pp"></p>
    <pre>  input:        128 bit IPv6 string,
                signed 32 bit integer
  returns:  scalar      carry
            array       (carry, result)
    </pre>
  </li>
  <li>add128($ipv6naddr1,$ipv6naddr2);
    <p class="Pp">Add two 128 bit string variables.</p>
    <p class="Pp"></p>
    <pre>  input:        128 bit string var1,
                128 bit string var2
  returns:  scalar      carry
            array       (carry, result)
    </pre>
  </li>
  <li>sub128($ipv6naddr1,$ipv6naddr2);
    <p class="Pp">Subtract two 128 bit string variables.</p>
    <p class="Pp"></p>
    <pre>  input:        128 bit string var1,
                128 bit string var2
  returns:  scalar      carry
            array       (carry, result)
    </pre>
    <p class="Pp">Note: The carry from this operation is the result of adding
        the one's complement of ARG2 +1 to the ARG1. It is logically <b>NOT
        borrow</b>.</p>
    <p class="Pp"></p>
    <pre>        i.e.    if ARG1 &gt;= ARG2 then carry = 1
        or      if ARG1  &lt; ARG2 then carry = 0
    </pre>
  </li>
  <li>($spurious,$cidr) = notcontiguous($mask128);
    <p class="Pp">This function counts the bit positions remaining in the mask
        when the rightmost '0's are removed.</p>
    <p class="Pp"></p>
    <pre>        input:  128 bit netmask
        returns true if there are spurious
                    zero bits remaining in the
                    mask, false if the mask is
                    contiguous one's,
                128 bit cidr number
    </pre>
  </li>
  <li><span class="Li">$bcdtext</span> = bin2bcd($bits128);
    <p class="Pp">Convert a 128 bit binary string into binary coded decimal text
        digits.</p>
    <p class="Pp"></p>
    <pre>  input:        128 bit string variable
  returns:      string of bcd text digits
    </pre>
  </li>
  <li><span class="Li">$bits128</span> = bcd2bin($bcdtxt);
    <p class="Pp">Convert a bcd text string to 128 bit string variable</p>
    <p class="Pp"></p>
    <pre>  input:        string of bcd text digits
  returns:      128 bit string variable
    </pre>
  </li>
  <li><span class="Li">$modetext</span> = mode;
    <p class="Pp">Returns the operating mode of this module.</p>
    <p class="Pp"></p>
    <pre>        input:          none
        returns:        &quot;Pure Perl&quot;
                   or   &quot;CC XS&quot;
    </pre>
  </li>
  <li>($name,$aliases,$addrtype,$length,@addrs)=naip_gethostbyname(NAME);
    <p class="Pp">Replacement for Perl's gethostbyname if Socket6 is
      available</p>
    <p class="Pp">In ARRAY context, returns a list of five elements, the
        hostname or NAME, a space separated list of C_NAMES, AF family, length
        of the address structure, and an array of one or more netaddr's</p>
    <p class="Pp">In SCALAR context, returns the first netaddr.</p>
    <p class="Pp">This function ALWAYS returns an IPv6 address, even on IPv4
        only systems. IPv4 addresses are mapped into IPv6 space in the form:</p>
    <p class="Pp"></p>
    <pre>        ::FFFF:FFFF:d.d.d.d
    </pre>
    <p class="Pp">This is NOT the expected result from Perl's gethostbyname2. It
        is instead equivalent to:</p>
    <p class="Pp"></p>
    <pre>  On an IPv4 only system:
    $ipv6naddr = ipv4to6 scalar ( gethostbyname( name ));
  On a system with Socket6 and a working gethostbyname2:
    $ipv6naddr = gethostbyname2( name, AF_INET6 );
  and if that fails, the IPv4 conversion above.
    </pre>
    <p class="Pp">For a gethostbyname2 emulator that behave like Socket6, see:
        Net::DNS::Dig</p>
  </li>
  <li><span class="Li">$trueif</span> = <b>havegethostbyname2()</b>;
    <p class="Pp">This function returns TRUE if Socket6 has a functioning
        <b>gethostbyname2</b>, otherwise it returns FALSE. See the comments
        above about the behavior of <b>naip_gethostbyname</b>.</p>
  </li>
  <li><b>NetAddr::IP::Util::lower()</b>;
    <p class="Pp">Return IPv6 strings in lowercase.</p>
  </li>
  <li><b>NetAddr::IP::Util::upper()</b>;
    <p class="Pp">Return IPv6 strings in uppercase. This is the default.</p>
  </li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="EXAMPLES"><a class="permalink" href="#EXAMPLES">EXAMPLES</a></h1>
<pre>  # convert any textual IP address into a 128 bit vector
  #
  sub text2vec {
    my($anyIP,$anyMask) = @_;
  # not IPv4 bit mask
    my $notiv4 = ipv6_aton('FFFF:FFFF:FFFF:FFFF:FFFF:FFFF::');
    my $vecip   = inet_any2n($anyIP);
    my $mask    = inet_any2n($anyMask);
  # extend mask bits for IPv4
    my $bits = 128;     # default
    unless (hasbits($mask &amp; $notiv4)) {
      $mask |= $notiv4;
      $bits = 32;
    }
    return ($vecip, $mask, $bits);
  }
  ... alternate implementation, a little faster
  sub text2vec {
    my($anyIP,$anyMask) = @_;
  # not IPv4 bit mask
    my $notiv4 = ipv6_aton('FFFF:FFFF:FFFF:FFFF:FFFF:FFFF::');
    my $vecip   = inet_any2n($anyIP);
    my $mask    = inet_any2n($anyMask);
  # extend mask bits for IPv4
    my $bits = 128;     # default
    if (isIPv4($mask)) {
      $mask |= $notiv4;
      $bits = 32;
    }
    return ($vecip, $mask, $bits);
  }
  ... elsewhere
    $nip = {
        addr    =&gt; $vecip,
        mask    =&gt; $mask,
        bits    =&gt; $bits,
    };
  # return network and broadcast addresses from IP and Mask
  #
  sub netbroad {
    my($nip) = shift;
    my $notmask = ~ $nip-&gt;{mask};
    my $bcast   = $nip-&gt;{addr} | $notmask;
    my $network = $nip-&gt;{addr} &amp; $nip-&gt;{mask};
    return ($network, $broadcast);
  }
  # check if address is within a network
  #
  sub within {
    my($nip,$net) = @_;
    my $addr = $nip-&gt;{addr}
    my($nw,$bc) = netbroad($net);
  # arg1 &gt;= arg2, sub128 returns true
    return (sub128($addr,$nw) &amp;&amp; sub128($bc,$addr))
        ? 1 : 0;
  }
  # truely hard way to do $ip++
  # add a constant, wrapping at netblock boundaries
  # to subtract the constant, negate it before calling
  # 'addwrap' since 'addconst' will extend the sign bits
  #
  sub addwrap {
    my($nip,$const) = @_;
    my $addr    = $nip-&gt;{addr};
    my $mask    = $nip-&gt;{mask};
    my $bits    = $nip-&gt;{bits};
    my $notmask = ~ $mask;
    my $hibits  = $addr &amp; $mask;
    $addr = addconst($addr,$const);
    my $wraponly = $addr &amp; $notmask;
    my $newip = {
        addr    =&gt; $hibits | $wraponly,
        mask    =&gt; $mask,
        bits    =&gt; $bits,
    };
    # bless $newip as appropriate
    return $newip;
  }
  # something more useful
  # increment a /24 net to the NEXT net at the boundry
  my $nextnet = 256;    # for /24
  LOOP:
  while (...continuing) {
    your code....
    ...
    my $lastip = $ip-copy();
    $ip++;
    if ($ip &lt; $lastip) {        # host part wrapped?
  # discard carry
      (undef, $ip-&gt;{addr} = addconst($ip-&gt;{addr}, $nextnet);
    }
    next LOOP;
  }
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="EXPORT_OK"><a class="permalink" href="#EXPORT_OK">EXPORT_OK</a></h1>
<pre>        inet_aton
        inet_ntoa
        ipv6_aton
        ipv6_ntoa
        ipv6_n2x
        ipv6_n2d
        inet_any2n
        hasbits
        isIPv4
        isNewIPv4
        isAnyIPv4
        inet_n2dx
        inet_n2ad
        inet_pton
        inet_ntop
        inet_4map6
        ipv4to6
        mask4to6
        ipanyto6
        maskanyto6
        ipv6to4
        packzeros
        shiftleft
        addconst
        add128
        sub128
        notcontiguous
        bin2bcd
        bcd2bin
        mode
        naip_gethostbyname
        havegethostbyname2
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">Michael Robinton &lt;michael@bizsystems.com&gt;</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT"><a class="permalink" href="#COPYRIGHT">COPYRIGHT</a></h1>
<p class="Pp">Copyright 2003 - 2014, Michael Robinton
    &lt;michael@bizsystems.com&gt;</p>
<p class="Pp">All rights reserved.</p>
<p class="Pp">This program is free software; you can redistribute it and/or
    modify it under the terms of either:</p>
<p class="Pp"></p>
<pre>  a) the GNU General Public License as published by the Free
  Software Foundation; either version 2, or (at your option) any
  later version, or
  b) the &quot;Artistic License&quot; which comes with this distribution.
</pre>
<p class="Pp">This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See either the GNU
    General Public License or the Artistic License for more details.</p>
<p class="Pp">You should have received a copy of the Artistic License with this
    distribution, in the file named &quot;Artistic&quot;. If not, I'll be glad
    to provide one.</p>
<p class="Pp">You should also have received a copy of the GNU General Public
    License along with this program in the file named &quot;Copying&quot;. If
    not, write to the</p>
<p class="Pp"></p>
<pre>        Free Software Foundation, Inc.
        51 Franklin Street, Fifth Floor
        Boston, MA 02110-1301 USA.
</pre>
<p class="Pp">or visit their web page on the internet at:</p>
<p class="Pp"></p>
<pre>        http://www.gnu.org/copyleft/gpl.html.
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR~2"><a class="permalink" href="#AUTHOR~2">AUTHOR</a></h1>
<p class="Pp">Michael Robinton &lt;michael@bizsystems.com&gt;</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp"><b>NetAddr::IP</b>(3), <b>NetAddr::IP::Lite</b>(3),
    <b>NetAddr::IP::InetBase</b>(3)</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2015-08-17</td>
    <td class="foot-os">perl v5.34.0</td>
  </tr>
</table>
</body>
</html>
