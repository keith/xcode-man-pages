<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>PERLFAQ9(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">PERLFAQ9(1)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">PERLFAQ9(1)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
perlfaq9 - Web, Email and Networking
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
This section deals with questions related to running web sites, sending and
  receiving email as well as general networking.
<section class="Ss">
<h2 class="Ss" id="Should_I_use_a_web_framework?"><a class="permalink" href="#Should_I_use_a_web_framework?">Should
  I use a web framework?</a></h2>
Yes. If you are building a web site with any level of interactivity (forms /
  users / databases), you will want to use a framework to make handling requests
  and responses easier.
<p class="Pp">If there is no interactivity then you may still want to look at
    using something like Template Toolkit
    &lt;https://metacpan.org/module/Template&gt; or
    Plack::Middleware::TemplateToolkit so maintenance of your HTML files (and
    other assets) is easier.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Which_web_framework_should_I_use?"><a class="permalink" href="#Which_web_framework_should_I_use?">Which
  web framework should I use?</a></h2>
There is no simple answer to this question. Perl frameworks can run everything
  from basic file servers and small scale intranets to massive multinational
  multilingual websites that are the core to international businesses.
<p class="Pp">Below is a list of a few frameworks with comments which might help
    you in making a decision, depending on your specific requirements. Start by
    reading the docs, then ask questions on the relevant mailing list or IRC
    channel.</p>
<dl class="Bl-tag">
  <dt>Catalyst</dt>
  <dd>Strongly object-oriented and fully-featured with a long development
      history and a large community and addon ecosystem. It is excellent for
      large and complex applications, where you have full control over the
      server.</dd>
  <dt>Dancer</dt>
  <dd>Young and free of legacy weight, providing a lightweight and easy to learn
      API. Has a growing addon ecosystem. It is best used for smaller projects
      and very easy to learn for beginners.</dd>
  <dt>Mojolicious</dt>
  <dd>Fairly young with a focus on HTML5 and real-time web technologies such as
      WebSockets.</dd>
  <dt>Web::Simple</dt>
  <dd>Currently experimental, strongly object-oriented, built for speed and
      intended as a toolkit for building micro web apps, custom frameworks or
      for tieing together existing Plack-compatible web applications with one
      central dispatcher.</dd>
</dl>
<p class="Pp">All of these interact with or use Plack which is worth
    understanding the basics of when building a website in Perl (there is a lot
    of useful Plack::Middleware
    &lt;https://metacpan.org/search?q=plack%3A%3Amiddleware&gt;).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="What_is_Plack_and__s-1PSGI_s0?"><a class="permalink" href="#What_is_Plack_and__s-1PSGI_s0?">What
  is Plack and PSGI?</a></h2>
PSGI is the Perl Web Server Gateway Interface Specification, it is a standard
  that many Perl web frameworks use, you should not need to understand it to
  build a web site, the part you might want to use is Plack.
<p class="Pp">Plack is a set of tools for using the PSGI stack. It contains
    middleware &lt;https://metacpan.org/search?q=plack%3A%3Amiddleware&gt;
    components, a reference server and utilities for Web application frameworks.
    Plack is like Ruby's Rack or Python's Paste for WSGI.</p>
<p class="Pp">You could build a web site using Plack and your own code, but for
    anything other than a very basic web site, using a web framework (that uses
    Plack) is a better option.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="How_do_I_remove__s-1HTML_s0_from_a_string?"><a class="permalink" href="#How_do_I_remove__s-1HTML_s0_from_a_string?">How
  do I remove HTML from a string?</a></h2>
Use HTML::Strip, or HTML::FormatText which not only removes HTML but also
  attempts to do a little simple formatting of the resulting plain text.
</section>
<section class="Ss">
<h2 class="Ss" id="How_do_I_extract_URLs?"><a class="permalink" href="#How_do_I_extract_URLs?">How
  do I extract URLs?</a></h2>
HTML::SimpleLinkExtor will extract URLs from HTML, it handles anchors, images,
  objects, frames, and many other tags that can contain a URL. If you need
  anything more complex, you can create your own subclass of HTML::LinkExtor or
  HTML::Parser. You might even use HTML::SimpleLinkExtor as an example for
  something specifically suited to your needs.
<p class="Pp">You can use URI::Find to extract URLs from an arbitrary text
    document.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="How_do_I_fetch_an__s-1HTML_s0_file?"><a class="permalink" href="#How_do_I_fetch_an__s-1HTML_s0_file?">How
  do I fetch an HTML file?</a></h2>
(contributed by brian d foy)
<p class="Pp">Use the libwww-perl distribution. The LWP::Simple module can fetch
    web resources and give their content back to you as a string:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    use LWP::Simple qw(get);

    my $html = get( &quot;http://www.example.com/index.html&quot; );
</pre>
<p class="Pp">It can also store the resource directly in a file:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    use LWP::Simple qw(getstore);

    getstore( &quot;http://www.example.com/index.html&quot;, &quot;foo.html&quot; );
</pre>
<p class="Pp">If you need to do something more complicated, you can use
    LWP::UserAgent module to create your own user-agent (e.g. browser) to get
    the job done. If you want to simulate an interactive web browser, you can
    use the WWW::Mechanize module.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="How_do_I_automate_an__s-1HTML_s0_form_submission?"><a class="permalink" href="#How_do_I_automate_an__s-1HTML_s0_form_submission?">How
  do I automate an HTML form submission?</a></h2>
If you are doing something complex, such as moving through many pages and forms
  or a web site, you can use WWW::Mechanize. See its documentation for all the
  details.
<p class="Pp">If you're submitting values using the GET method, create a URL and
    encode the form using the <span class="Li">&quot;query_form&quot;</span>
    method:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    use LWP::Simple;
    use URI::URL;

    my $url = url('L&lt;http://www.perl.com/cgi-bin/cpan_mod')&gt;;
    $url-&gt;query_form(module =&gt; 'DB_File', readme =&gt; 1);
    $content = get($url);
</pre>
<p class="Pp">If you're using the POST method, create your own user agent and
    encode the content appropriately.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    use HTTP::Request::Common qw(POST);
    use LWP::UserAgent;

    my $ua = LWP::UserAgent-&gt;new();
    my $req = POST 'L&lt;http://www.perl.com/cgi-bin/cpan_mod'&gt;,
                   [ module =&gt; 'DB_File', readme =&gt; 1 ];
    my $content = $ua-&gt;request($req)-&gt;as_string;
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="How_do_I_decode_or_create_those___-encodings_on_the_web?"><a class="permalink" href="#How_do_I_decode_or_create_those___-encodings_on_the_web?">How
  do I decode or create those %-encodings on the web?</a></h2>
Most of the time you should not need to do this as your web framework, or if you
  are making a request, the LWP or other module would handle it for you.
<p class="Pp">To encode a string yourself, use the URI::Escape module. The
    <span class="Li">&quot;uri_escape&quot;</span> function returns the escaped
    string:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    my $original = &quot;Colon : Hash # Percent %&quot;;

    my $escaped = uri_escape( $original );

    print &quot;$escaped\n&quot;; # 'Colon%20%3A%20Hash%20%23%20Percent%20%25'
</pre>
<p class="Pp">To decode the string, use the
    <span class="Li">&quot;uri_unescape&quot;</span> function:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    my $unescaped = uri_unescape( $escaped );

    print $unescaped; # back to original
</pre>
<p class="Pp">Remember not to encode a full URI, you need to escape each
    component separately and then join them together.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="How_do_I_redirect_to_another_page?"><a class="permalink" href="#How_do_I_redirect_to_another_page?">How
  do I redirect to another page?</a></h2>
Most Perl Web Frameworks will have a mechanism for doing this, using the
  Catalyst framework it would be:
<p class="Pp"><span class="Li"></span></p>
<pre>
    $c-&gt;res-&gt;redirect($url);
    $c-&gt;detach();
</pre>
<p class="Pp">If you are using Plack (which most frameworks do), then
    Plack::Middleware::Rewrite is worth looking at if you are migrating from
    Apache or have URL's you want to always redirect.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="How_do_I_put_a_password_on_my_web_pages?"><a class="permalink" href="#How_do_I_put_a_password_on_my_web_pages?">How
  do I put a password on my web pages?</a></h2>
See if the web framework you are using has an authentication system and if that
  fits your needs.
<p class="Pp">Alternativly look at Plack::Middleware::Auth::Basic, or one of the
    other Plack authentication &lt;https://metacpan.org/search?q=plack+auth&gt;
    options.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="How_do_I_make_sure_users_can't_enter_values_into_a_form_that_causes_my__s-1CGI_s0_script_to_do_bad_things?"><a class="permalink" href="#How_do_I_make_sure_users_can't_enter_values_into_a_form_that_causes_my__s-1CGI_s0_script_to_do_bad_things?">How
  do I make sure users can't enter values into a form that causes my CGI script
  to do bad things?</a></h2>
(contributed by brian d foy)
<p class="Pp">You can't prevent people from sending your script bad data. Even
    if you add some client-side checks, people may disable them or bypass them
    completely. For instance, someone might use a module such as LWP to submit
    to your web site. If you want to prevent data that try to use SQL injection
    or other sorts of attacks (and you should want to), you have to not trust
    any data that enter your program.</p>
<p class="Pp">The perlsec documentation has general advice about data security.
    If you are using the DBI module, use placeholder to fill in data. If you are
    running external programs with <span class="Li">&quot;system&quot;</span> or
    <span class="Li">&quot;exec&quot;</span>, use the list forms. There are many
    other precautions that you should take, too many to list here, and most of
    them fall under the category of not using any data that you don't intend to
    use. Trust no one.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="How_do_I_parse_a_mail_header?"><a class="permalink" href="#How_do_I_parse_a_mail_header?">How
  do I parse a mail header?</a></h2>
Use the Email::MIME module. It's well-tested and supports all the craziness that
  you'll see in the real world (comment-folding whitespace, encodings, comments,
  etc.).
<p class="Pp"><span class="Li"></span></p>
<pre>
  use Email::MIME;

  my $message = Email::MIME-&gt;new($rfc2822);
  my $subject = $message-&gt;header('Subject');
  my $from    = $message-&gt;header('From');
</pre>
<p class="Pp">If you've already got some other kind of email object, consider
    passing it to Email::Abstract and then using its cast method to get an
    Email::MIME object:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  my $mail_message_object = read_message();
  my $abstract = Email::Abstract-&gt;new($mail_message_object);
  my $email_mime_object = $abstract-&gt;cast('Email::MIME');
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="How_do_I_check_a_valid_mail_address?"><a class="permalink" href="#How_do_I_check_a_valid_mail_address?">How
  do I check a valid mail address?</a></h2>
(partly contributed by Aaron Sherman)
<p class="Pp">This isn't as simple a question as it sounds. There are two
  parts:</p>
<p class="Pp">a) How do I verify that an email address is correctly
  formatted?</p>
<p class="Pp">b) How do I verify that an email address targets a valid
    recipient?</p>
<p class="Pp">Without sending mail to the address and seeing whether there's a
    human on the other end to answer you, you cannot fully answer part <i>b</i>,
    but the Email::Valid module will do both part <i>a</i> and part <i>b</i> as
    far as you can in real-time.</p>
<p class="Pp">Our best advice for verifying a person's mail address is to have
    them enter their address twice, just as you normally do to change a
    password. This usually weeds out typos. If both versions match, send mail to
    that address with a personal message. If you get the message back and
    they've followed your directions, you can be reasonably assured that it's
    real.</p>
<p class="Pp">A related strategy that's less open to forgery is to give them a
    PIN (personal ID number). Record the address and PIN (best that it be a
    random one) for later processing. In the mail you send, include a link to
    your site with the PIN included. If the mail bounces, you know it's not
    valid. If they don't click on the link, either they forged the address or
    (assuming they got the message) following through wasn't important so you
    don't need to worry about it.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="How_do_I_decode_a__s-1MIME/BASE64_s0_string?"><a class="permalink" href="#How_do_I_decode_a__s-1MIME/BASE64_s0_string?">How
  do I decode a MIME/BASE64 string?</a></h2>
The MIME::Base64 package handles this as well as the MIME/QP encoding. Decoding
  base 64 becomes as simple as:
<p class="Pp"><span class="Li"></span></p>
<pre>
    use MIME::Base64;
    my $decoded = decode_base64($encoded);
</pre>
<p class="Pp">The Email::MIME module can decode base 64-encoded email message
    parts transparently so the developer doesn't need to worry about it.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="How_do_I_find_the_user's_mail_address?"><a class="permalink" href="#How_do_I_find_the_user's_mail_address?">How
  do I find the user's mail address?</a></h2>
Ask them for it. There are so many email providers available that it's unlikely
  the local system has any idea how to determine a user's email address.
<p class="Pp">The exception is for organization-specific email (e.g.
    foo@yourcompany.com) where policy can be codified in your program. In that
    case, you could look at <span class="Li">$ENV</span>{USER},
    <span class="Li">$ENV</span>{LOGNAME}, and getpwuid($&lt;) in scalar
    context, like so:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  my $user_name = getpwuid($&lt;)
</pre>
<p class="Pp">But you still cannot make assumptions about whether this is
    correct, unless your policy says it is. You really are best off asking the
    user.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="How_do_I_send_email?"><a class="permalink" href="#How_do_I_send_email?">How
  do I send email?</a></h2>
Use the Email::MIME and Email::Sender::Simple modules, like so:
<p class="Pp"><span class="Li"></span></p>
<pre>
  # first, create your message
  my $message = Email::MIME-&gt;create(
    header_str =&gt; [
      From    =&gt; 'you@example.com',
      To      =&gt; 'friend@example.com',
      Subject =&gt; 'Happy birthday!',
    ],
    attributes =&gt; {
      encoding =&gt; 'quoted-printable',
      charset  =&gt; 'utf-8',
    },
    body_str =&gt; &quot;Happy birthday to you!\n&quot;,
  );

  use Email::Sender::Simple qw(sendmail);
  sendmail($message);
</pre>
<p class="Pp">By default, Email::Sender::Simple will try `sendmail` first, if it
    exists in your <span class="Li">$PATH</span>. This generally isn't the case.
    If there's a remote mail server you use to send mail, consider investigating
    one of the Transport classes. At time of writing, the available transports
    include:</p>
<dl class="Bl-tag">
  <dt>Email::Sender::Transport::Sendmail</dt>
  <dd>This is the default. If you can use the <i>mail</i>(1) or <i>mailx</i>(1)
      program to send mail from the machine where your code runs, you should be
      able to use this.</dd>
  <dt>Email::Sender::Transport::SMTP</dt>
  <dd>This transport contacts a remote SMTP server over TCP. It optionally uses
      SSL and can authenticate to the server via SASL.</dd>
  <dt>Email::Sender::Transport::SMTP::TLS</dt>
  <dd>This is like the SMTP transport, but uses TLS security. You can
      authenticate with this module as well, using any mechanisms your server
      supports after STARTTLS.</dd>
</dl>
<p class="Pp">Telling Email::Sender::Simple to use your transport is
    straightforward.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  sendmail(
    $message,
    {
      transport =&gt; $email_sender_transport_object,
    }
  );
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="How_do_I_use__s-1MIME_s0_to_make_an_attachment_to_a_mail_message?"><a class="permalink" href="#How_do_I_use__s-1MIME_s0_to_make_an_attachment_to_a_mail_message?">How
  do I use MIME to make an attachment to a mail message?</a></h2>
Email::MIME directly supports multipart messages. Email::MIME objects themselves
  are parts and can be attached to other Email::MIME objects. Consult the
  Email::MIME documentation for more information, including all of the supported
  methods and examples of their use.
</section>
<section class="Ss">
<h2 class="Ss" id="How_do_I_read_email?"><a class="permalink" href="#How_do_I_read_email?">How
  do I read email?</a></h2>
Use the Email::Folder module, like so:
<p class="Pp"><span class="Li"></span></p>
<pre>
  use Email::Folder;

  my $folder = Email::Folder-&gt;new('/path/to/email/folder');
  while(my $message = $folder-&gt;next_message) {
    # next_message returns Email::Simple objects, but we want
    # Email::MIME objects as they're more robust
    my $mime = Email::MIME-&gt;new($message-&gt;as_string);
  }
</pre>
<p class="Pp">There are different classes in the Email::Folder namespace for
    supporting various mailbox types. Note that these modules are generally
    rather limited and only support <b>reading</b> rather than writing.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="How_do_I_find_out_my_hostname,_domainname,_or__s-1IP_s0_address?"><a class="permalink" href="#How_do_I_find_out_my_hostname,_domainname,_or__s-1IP_s0_address?">How
  do I find out my hostname, domainname, or IP address?</a></h2>
(contributed by brian d foy)
<p class="Pp">The Net::Domain module, which is part of the Standard Library
    starting in Perl 5.7.3, can get you the fully qualified domain name (FQDN),
    the host name, or the domain name.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    use Net::Domain qw(hostname hostfqdn hostdomain);

    my $host = hostfqdn();
</pre>
<p class="Pp">The Sys::Hostname module, part of the Standard Library, can also
    get the hostname:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    use Sys::Hostname;

    $host = hostname();
</pre>
<p class="Pp">The Sys::Hostname::Long module takes a different approach and
    tries harder to return the fully qualified hostname:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  use Sys::Hostname::Long 'hostname_long';

  my $hostname = hostname_long();
</pre>
<p class="Pp">To get the IP address, you can use the
    <span class="Li">&quot;gethostbyname&quot;</span> built-in function to turn
    the name into a number. To turn that number into the dotted octet form
    (a.b.c.d) that most people expect, use the
    <span class="Li">&quot;inet_ntoa&quot;</span> function from the Socket
    module, which also comes with perl.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    use Socket;

    my $address = inet_ntoa(
        scalar gethostbyname( $host || 'localhost' )
    );
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="How_do_I_fetch/put_an_(S)FTP_file?"><a class="permalink" href="#How_do_I_fetch/put_an_(S)FTP_file?">How
  do I fetch/put an (S)FTP file?</a></h2>
Net::FTP, and Net::SFTP allow you to interact with FTP and SFTP (Secure FTP)
  servers.
</section>
<section class="Ss">
<h2 class="Ss" id="How_can_I_do__s-1RPC_s0_in_Perl?"><a class="permalink" href="#How_can_I_do__s-1RPC_s0_in_Perl?">How
  can I do RPC in Perl?</a></h2>
Use one of the RPC modules( &lt;https://metacpan.org/search?q=RPC&gt; ).
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR_AND_COPYRIGHT"><a class="permalink" href="#AUTHOR_AND_COPYRIGHT">AUTHOR
  AND COPYRIGHT</a></h1>
Copyright (c) 1997-2010 Tom Christiansen, Nathan Torkington, and other authors
  as noted. All rights reserved.
<p class="Pp">This documentation is free; you can redistribute it and/or modify
    it under the same terms as Perl itself.</p>
<p class="Pp">Irrespective of its distribution, all code examples in this file
    are hereby placed into the public domain. You are permitted and encouraged
    to use this code in your own programs for fun or for profit as you see fit.
    A simple comment in the code giving credit would be courteous but is not
    required.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2014-09-30</td>
    <td class="foot-os">perl v5.18.4</td>
  </tr>
</table>
</body>
</html>
