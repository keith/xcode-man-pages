<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Copyright (c) 2006 Apple Computer, Inc.  All rights reserved.
  
   @APPLE_LICENSE_HEADER_START@
  
   The contents of this file constitute Original Code as defined in and
   are subject to the Apple Public Source License Version 1.1 (the
   "License").  You may not use this file except in compliance with the
   License.  Please obtain a copy of the License at
   http://www.apple.com/publicsource and read it before using this file.
  
   This Original Code and all software distributed under the License are
   distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
   EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
   INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
   FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
   License for the specific language governing rights and limitations
   under the License.
  
   @APPLE_LICENSE_HEADER_END@
   -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>MALLOC(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">MALLOC(3)</td>
    <td class="head-vol">Library Functions Manual</td>
    <td class="head-rtitle">MALLOC(3)</td>
  </tr>
</table>
<div class="manual-text">
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<code class="Nm">calloc</code>, <code class="Nm">free</code>,
  <code class="Nm">malloc</code>, <code class="Nm">realloc</code>,
  <code class="Nm">reallocf</code>, <code class="Nm">valloc</code>,
  <code class="Nm">aligned_alloc</code> &#x2014;
<div class="Nd">memory allocation</div>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<code class="In">#include &lt;<a class="In">stdlib.h</a>&gt;</code>
<p class="Pp"><var class="Ft">void *</var>
  <br/>
  <code class="Fn">calloc</code>(<var class="Fa">size_t count</var>,
    <var class="Fa">size_t size</var>);</p>
<p class="Pp"><var class="Ft">void</var>
  <br/>
  <code class="Fn">free</code>(<var class="Fa">void *ptr</var>);</p>
<p class="Pp"><var class="Ft">void *</var>
  <br/>
  <code class="Fn">malloc</code>(<var class="Fa">size_t size</var>);</p>
<p class="Pp"><var class="Ft">void *</var>
  <br/>
  <code class="Fn">realloc</code>(<var class="Fa">void *ptr</var>,
    <var class="Fa">size_t size</var>);</p>
<p class="Pp"><var class="Ft">void *</var>
  <br/>
  <code class="Fn">reallocf</code>(<var class="Fa">void *ptr</var>,
    <var class="Fa">size_t size</var>);</p>
<p class="Pp"><var class="Ft">void *</var>
  <br/>
  <code class="Fn">valloc</code>(<var class="Fa">size_t size</var>);</p>
<p class="Pp"><var class="Ft">void *</var>
  <br/>
  <code class="Fn">aligned_alloc</code>(<var class="Fa">size_t alignment</var>,
    <var class="Fa">size_t size</var>);</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
The <code class="Fn">malloc</code>(), <code class="Fn">calloc</code>(),
  <code class="Fn">valloc</code>(), <code class="Fn">realloc</code>(), and
  <code class="Fn">reallocf</code>() functions allocate memory. The allocated
  memory is aligned such that it can be used for any data type, including
  AltiVec- and SSE-related types. The <code class="Fn">aligned_alloc</code>()
  function allocates memory with the requested alignment. The
  <code class="Fn">free</code>() function frees allocations that were created
  via the preceding allocation functions.
<p class="Pp">The <code class="Fn">malloc</code>() function allocates
    <var class="Fa">size</var> bytes of memory and returns a pointer to the
    allocated memory.</p>
<p class="Pp">The <code class="Fn">calloc</code>() function contiguously
    allocates enough space for <var class="Fa">count</var> objects that are
    <var class="Fa">size</var> bytes of memory each and returns a pointer to the
    allocated memory. The allocated memory is filled with bytes of value
  zero.</p>
<p class="Pp">The <code class="Fn">valloc</code>() function allocates
    <var class="Fa">size</var> bytes of memory and returns a pointer to the
    allocated memory. The allocated memory is aligned on a page boundary.</p>
<p class="Pp">The <code class="Fn">aligned_alloc</code>() function allocates
    <var class="Fa">size</var> bytes of memory with an alignment specified by
    <var class="Fa">alignment</var> and returns a pointer to the allocated
    memory.</p>
<p class="Pp">The <code class="Fn">realloc</code>() function tries to change the
    size of the allocation pointed to by <var class="Fa">ptr</var> to
    <var class="Fa">size</var>, and returns <var class="Fa">ptr</var>. If there
    is not enough room to enlarge the memory allocation pointed to by
    <var class="Fa">ptr</var>, <code class="Fn">realloc</code>() creates a new
    allocation, copies as much of the old data pointed to by
    <var class="Fa">ptr</var> as will fit to the new allocation, frees the old
    allocation, and returns a pointer to the allocated memory. If
    <var class="Fa">ptr</var> is <code class="Dv">NULL</code>,
    <code class="Fn">realloc</code>() is identical to a call to
    <code class="Fn">malloc</code>() for <var class="Fa">size</var> bytes. If
    <var class="Fa">size</var> is zero and <var class="Fa">ptr</var> is not
    <code class="Dv">NULL</code>, a new, minimum sized object is allocated and
    the original object is freed. When extending a region allocated with
    calloc(3), realloc(3) does not guarantee that the additional memory is also
    zero-filled.</p>
<p class="Pp">The <code class="Fn">reallocf</code>() function is identical to
    the <code class="Fn">realloc</code>() function, except that it will free the
    passed pointer when the requested memory cannot be allocated. This is a
    <span class="Ux">FreeBSD</span> specific API designed to ease the problems
    with traditional coding styles for realloc causing memory leaks in
    libraries.</p>
<p class="Pp">The <code class="Fn">free</code>() function deallocates the memory
    allocation pointed to by <var class="Fa">ptr</var>. <var class="Fa">If</var>
    <var class="Fa">ptr</var> is a NULL pointer, no operation is performed.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="RETURN_VALUES"><a class="permalink" href="#RETURN_VALUES">RETURN
  VALUES</a></h1>
If successful, <code class="Fn">calloc</code>(),
  <code class="Fn">malloc</code>(), <code class="Fn">realloc</code>(),
  <code class="Fn">reallocf</code>(), <code class="Fn">valloc</code>(), and
  <code class="Fn">aligned_alloc</code>() functions return a pointer to
  allocated memory. If there is an error, they return a
  <code class="Dv">NULL</code> pointer and set <var class="Va">errno</var> to
  <code class="Er">ENOMEM</code>.
<p class="Pp">In addition, <code class="Fn">aligned_alloc</code>() returns a
    <code class="Dv">NULL</code> pointer and sets <var class="Va">errno</var> to
    <code class="Er">EINVAL</code> if <var class="Fa">size</var> is not an
    integral multiple of <var class="Fa">alignment</var>, or if
    <var class="Fa">alignment</var> is not a power of 2 at least as large as
    <code class="Fn">sizeof</code>(<var class="Fa">void *</var>).</p>
<p class="Pp">For <code class="Fn">realloc</code>(), the input pointer is still
    valid if reallocation failed. For <code class="Fn">reallocf</code>(), the
    input pointer will have been freed if reallocation failed.</p>
<p class="Pp">The <code class="Fn">free</code>() function does not return a
    value.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DEBUGGING_ALLOCATION_ERRORS"><a class="permalink" href="#DEBUGGING_ALLOCATION_ERRORS">DEBUGGING
  ALLOCATION ERRORS</a></h1>
A number of facilities are provided to aid in debugging allocation errors in
  applications. These facilities are primarily controlled via environment
  variables. The recognized environment variables and their meanings are
  documented below.
</section>
<section class="Sh">
<h1 class="Sh" id="ENVIRONMENT"><a class="permalink" href="#ENVIRONMENT">ENVIRONMENT</a></h1>
The following environment variables change the behavior of the
  allocation-related functions.
<dl class="Bl-tag">
  <dt><a class="permalink" href="#MallocDebugReport"><code class="Ev" id="MallocDebugReport">MallocDebugReport</code></a></dt>
  <dd>If set, specifies where messages are written. Set to &quot;stderr&quot; to
      write messages to the standard error stream, &quot;none&quot; to discard
      all messages and &quot;crash&quot; to write messages to standard error
      only for a condition that is about to cause a crash. When not set, message
      are written to the standard error stream if it appears to be a terminal
      (that is, if isatty(STDERR_FILENO) returns a non-zero value) and are
      otherwise discarded.</dd>
  <dt><a class="permalink" href="#MallocGuardEdges"><code class="Ev" id="MallocGuardEdges">MallocGuardEdges</code></a></dt>
  <dd>If set, add a guard page before and after each large block.</dd>
  <dt><a class="permalink" href="#MallocDoNotProtectPrelude"><code class="Ev" id="MallocDoNotProtectPrelude">MallocDoNotProtectPrelude</code></a></dt>
  <dd>If set, do not add a guard page before large blocks, even if the
      <code class="Ev">MallocGuardEdges</code> environment variable is set.</dd>
  <dt><a class="permalink" href="#MallocDoNotProtectPostlude"><code class="Ev" id="MallocDoNotProtectPostlude">MallocDoNotProtectPostlude</code></a></dt>
  <dd>If set, do not add a guard page after large blocks, even if the
      <code class="Ev">MallocGuardEdges</code> environment variable is set.</dd>
  <dt><a class="permalink" href="#MallocStackLogging"><code class="Ev" id="MallocStackLogging">MallocStackLogging</code></a></dt>
  <dd>The default behavior if this is set is to record all allocation and
      deallocation events to an on-disk log, along with stacks, so that tools
      like <a class="Xr">leaks(1)</a> and <a class="Xr">malloc_history(1)</a>
      can be used.
    <p class="Pp">Set to &quot;vm&quot; to record only allocation of virtual
        memory regions allocated by system calls and mach traps, such as by
        <a class="Xr">mmap(1)</a></p>
    <p class="Pp">Set to &quot;malloc&quot; to record only allocations via
        <a class="Xr">malloc(3)</a> and related interfaces, not virtual memory
        regions.</p>
    <p class="Pp">Set to &quot;lite&quot; to record current allocations only,
        not history. These are recorded by in-memory data structures, instead of
        an on-disk log.</p>
  </dd>
  <dt><a class="permalink" href="#MallocStackLoggingNoCompact"><code class="Ev" id="MallocStackLoggingNoCompact">MallocStackLoggingNoCompact</code></a></dt>
  <dd>If set, record all stacks in a manner that is compatible with the
      <code class="Nm">malloc_history</code> program.</dd>
  <dt><a class="permalink" href="#MallocStackLoggingDirectory"><code class="Ev" id="MallocStackLoggingDirectory">MallocStackLoggingDirectory</code></a></dt>
  <dd>If set, records stack logs to the directory specified instead of saving
      them to the default location (/tmp).</dd>
  <dt><a class="permalink" href="#MallocScribble"><code class="Ev" id="MallocScribble">MallocScribble</code></a></dt>
  <dd>If set, fill memory that has been allocated with 0xaa bytes. This
      increases the likelihood that a program making assumptions about the
      contents of freshly allocated memory will fail. Also if set, fill memory
      that has been deallocated with 0x55 bytes. This increases the likelihood
      that a program will fail due to accessing memory that is no longer
      allocated. Note that due to the way in which freed memory is managed
      internally, the 0x55 pattern may not appear in some parts of a deallocated
      memory block.</dd>
  <dt><a class="permalink" href="#MallocCheckHeapStart__s_"><code class="Ev" id="MallocCheckHeapStart__s_">MallocCheckHeapStart
    &lt;s&gt;</code></a></dt>
  <dd>If set, specifies the number of allocations
      <var class="Fa">&lt;s&gt;</var> to wait before begining periodic heap
      checks every <var class="Fa">&lt;n&gt;</var> as specified by
      <code class="Ev">MallocCheckHeapEach</code>. If
      <code class="Ev">MallocCheckHeapStart</code> is set but
      <code class="Ev">MallocCheckHeapEach</code> is not specified, the default
      check repetition is 1000.</dd>
  <dt><a class="permalink" href="#MallocCheckHeapEach__n_"><code class="Ev" id="MallocCheckHeapEach__n_">MallocCheckHeapEach
    &lt;n&gt;</code></a></dt>
  <dd>If set, run a consistency check on the heap every
      <var class="Fa">&lt;n&gt;</var> operations.
      <code class="Ev">MallocCheckHeapEach</code> is only meaningful if
      <code class="Ev">MallocCheckHeapStart</code> is also set.</dd>
  <dt><a class="permalink" href="#MallocCheckHeapSleep__t_"><code class="Ev" id="MallocCheckHeapSleep__t_">MallocCheckHeapSleep
    &lt;t&gt;</code></a></dt>
  <dd>Sets the number of seconds to sleep (waiting for a debugger to attach)
      when <code class="Ev">MallocCheckHeapStart</code> is set and a heap
      corruption is detected. The default is 100 seconds. Setting this to zero
      means not to sleep at all. Setting this to a negative number means to
      sleep (for the positive number of seconds) only the very first time a heap
      corruption is detected.</dd>
  <dt><a class="permalink" href="#MallocCheckHeapAbort__b_"><code class="Ev" id="MallocCheckHeapAbort__b_">MallocCheckHeapAbort
    &lt;b&gt;</code></a></dt>
  <dd>When <code class="Ev">MallocCheckHeapStart</code> is set and this is set
      to a non-zero value, causes <a class="Xr">abort(3)</a> to be called if a
      heap corruption is detected, instead of any sleeping.</dd>
  <dt><a class="permalink" href="#MallocErrorAbort"><code class="Ev" id="MallocErrorAbort">MallocErrorAbort</code></a></dt>
  <dd>If set, causes <a class="Xr">abort(3)</a> to be called if an error was
      encountered in <a class="Xr">malloc(3)</a> or <a class="Xr">free(3)</a> ,
      such as a calling <a class="Xr">free(3)</a> on a pointer previously
    freed.</dd>
  <dt><a class="permalink" href="#MallocCorruptionAbort"><code class="Ev" id="MallocCorruptionAbort">MallocCorruptionAbort</code></a></dt>
  <dd>Similar to <code class="Ev">MallocErrorAbort</code> but will not abort in
      out of memory conditions, making it more useful to catch only those errors
      which will cause memory corruption. MallocCorruptionAbort is always set on
      64-bit processes.</dd>
  <dt><a class="permalink" href="#MallocHelp"><code class="Ev" id="MallocHelp">MallocHelp</code></a></dt>
  <dd>If set, print a list of environment variables that are paid heed to by the
      allocation-related functions, along with short descriptions. The list
      should correspond to this documentation.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="DIAGNOSTIC_MESSAGES"><a class="permalink" href="#DIAGNOSTIC_MESSAGES">DIAGNOSTIC
  MESSAGES</a></h1>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<a class="Xr">leaks(1)</a>, <a class="Xr">malloc_history(1)</a>,
  <a class="Xr">abort(3)</a>, <a class="Xr">malloc_size(3)</a>,
  <a class="Xr">malloc_zone_malloc(3)</a>, <a class="Xr">posix_memalign(3)</a>,
  <a class="Xr">libgmalloc(3)</a>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">August 13, 2008</td>
    <td class="foot-os">Mac OS X 11.0</td>
  </tr>
</table>
</body>
</html>
