<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>Parse::Eyapp::YATW(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Parse::Eyapp::YATW(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Parse::Eyapp::YATW(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
Parse::Eyapp::YATW - Tree transformation objects
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<span class="Li"></span>
<pre>
  #!/usr/bin/perl -w
  use strict;
  use Rule6;
  use Parse::Eyapp::YATW;

  my %BinaryOperation = (PLUS=&gt;'+', MINUS =&gt; '-', TIMES=&gt;'*', DIV =&gt; '/');

  sub set_terminfo {
    no warnings;
    *TERMINAL::info = sub { $_[0]{attr} };
  }
  sub is_foldable {
    my ($op, $left, $right);
    return 0 unless defined($op = $BinaryOperation{ref($_[0])});
    return 0 unless ($left = $_[0]-&gt;child(0), $left-&gt;isa('NUM'));
    return 0 unless ($right = $_[0]-&gt;child(1), $right-&gt;isa('NUM'));

    my $leftnum = $left-&gt;child(0)-&gt;{attr};
    my $rightnum = $right-&gt;child(0)-&gt;{attr};
    $left-&gt;child(0)-&gt;{attr} = eval &quot;$leftnum $op $rightnum&quot;;
    $_[0] = $left;
  }

  my $parser = new Rule6();
  my $input = &quot;2*3&quot;;
  my $t = $parser-&gt;Run(\$input);
  &amp;set_terminfo;
  print &quot;\n***** Before ******\n&quot;;
  print $t-&gt;str;
  my $p = Parse::Eyapp::YATW-&gt;new(PATTERN =&gt; \&amp;is_foldable);
  $p-&gt;s($t);
  print &quot;\n***** After ******\n&quot;;
  print $t-&gt;str.&quot;\n&quot;;
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="INTRODUCTION"><a class="permalink" href="#INTRODUCTION">INTRODUCTION</a></h1>
<span class="Li">&quot;Parse::Eyapp:YATW&quot;</span> objects implement tree
  transformations. They have two attributes
  <span class="Li">&quot;PATTERN&quot;</span> and
  <span class="Li">&quot;NAME&quot;</span>.
  <span class="Li">&quot;PATTERN&quot;</span> is a reference to the code
  implementing the transformation. <span class="Li">&quot;NAME&quot;</span> is
  the name of the transformation.
<p class="Pp">Though usually you build a transformation by means of Treeregexp
    programs you can directly invoke the method
    <span class="Li">&quot;new&quot;</span> to build a tree transformation. A
    transformation object can be built from a function that conforms to the YATW
    tree transformation call protocol</p>
<p class="Pp">For a subroutine <span class="Li">&quot;pattern_sub&quot;</span>
    to work as a YATW tree transformation - as subroutine
    <span class="Li">&quot;is_foldable&quot;</span> in the SYNOPSIS section -
    has to conform to the following call description:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  pattern_sub(
      $_[0],  # Node being visited
      $_[1],  # Father of this node
      $index, # Index of this node in @Father-&gt;children
      $self,  # The YATW pattern object
  );
</pre>
<p class="Pp">The <span class="Li">&quot;pattern_sub&quot;</span> must return
    TRUE if matched and FALSE otherwise.</p>
<p class="Pp">The function <span class="Li">&quot;is_foldable&quot;</span> in
    the SYNOPSIS section (file
    <span class="Li">&quot;examples/YATW/foldrule6.pl&quot;</span>) holds the
    properties to be a YATW tree transformation</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
     1    sub is_foldable {
     2      my ($op, $left, $right);
     3  
     4      return 0 unless defined($op = $BinaryOperation{ref($_[0])});
     5      return 0 unless ($left = $_[0]-&gt;child(0), $left-&gt;isa('NUM'));
     6      return 0 unless ($right = $_[0]-&gt;child(1), $right-&gt;isa('NUM'));
     7  
     8      my $leftnum = $left-&gt;child(0)-&gt;{attr};
     9      my $rightnum = $right-&gt;child(0)-&gt;{attr};
    10      $left-&gt;child(0)-&gt;{attr} = eval &quot;$leftnum $op $rightnum&quot;;
    11      $_[0] = $left;
    12    }
</pre>
<p class="Pp">First, checks that the current node is one of
    <span class="Li">&quot;PLUS&quot;</span>,
    <span class="Li">&quot;MINUS&quot;</span>,
    <span class="Li">&quot;TIMES&quot;</span> or
    <span class="Li">&quot;DIV&quot;</span> (line 4). Then checks that both
    children are <span class="Li">&quot;NUM&quot;</span>bers (lines 5 and 6). In
    such case proceeds to modify its left child with the result of operating
    both children (line 10). The matching tree is finally substituted by its
    left child (line 11).</p>
<p class="Pp">This is the output of the program in the SYNOPSIS section:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  pl@nereida:~/LEyapp/examples$ eyapp Rule6.yp; foldrule6.pl

  ***** Before ******
  TIMES(NUM(TERMINAL[2]),NUM(TERMINAL[3]))
  ***** After ******
  NUM(TERMINAL[6])
</pre>
<p class="Pp">Follows the grammar description file in
    <span class="Li">&quot;Rule6.yp&quot;</span>:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  pl@nereida:~/LEyapp/examples$ cat -n Rule6.yp
     1  %{
     2  use Data::Dumper;
     3  %}
     4  %right  '='
     5  %left   '-' '+'
     6  %left   '*' '/'
     7  %left   NEG
     8  %tree
     9
    10  %%
    11  line: exp  { $_[1] }
    12  ;
    13
    14  exp:      %name NUM
    15              NUM
    16          | %name VAR
    17            VAR
    18          | %name ASSIGN
    19            VAR '=' exp
    20          | %name PLUS
    21            exp '+' exp
    22          | %name MINUS
    23            exp '-' exp
    24          | %name TIMES
    25            exp '*' exp
    26          | %name DIV
    27            exp '/' exp
    28          | %name UMINUS
    29            '-' exp %prec NEG
    30          |   '(' exp ')'  { $_[2] } /* Let us simplify a bit the tree */
    31  ;
    32
    33  %%
    34
    35  use Tail2;
</pre>
<p class="Pp">The module <span class="Li">&quot;Tail2&quot;</span> in file
    <span class="Li">&quot;examples/Tail2.pm&quot;</span> implements the lexical
    analyzer plus the <span class="Li">&quot;error&quot;</span> and
    <span class="Li">&quot;run&quot;</span> methods.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="Parse::Eyapp:YATW__Methods"><a class="permalink" href="#Parse::Eyapp:YATW__Methods">Parse::Eyapp:YATW
  Methods</a></h1>
<span class="Li">&quot;Parse::Eyapp:YATW&quot;</span> objects represent tree
  transformations. They carry the information of what nodes match and how to
  modify them.
<section class="Ss">
<h2 class="Ss" id="Parse::Eyapp::YATW_-_new"><a class="permalink" href="#Parse::Eyapp::YATW_-_new">Parse::Eyapp::YATW-&gt;new</a></h2>
Builds a treeregexp transformation object. Though usually you build a
  transformation by means of Treeregexp programs you can directly invoke the
  method to build a tree transformation. A transformation object can be built
  from a function that conforms to the YATW tree transformation call protocol
  (see the section &quot;The YATW Tree Transformation Call Protocol&quot;).
  Follows an example (file
  <span class="Li">&quot;examples/12ts_simplify_with_s.pl&quot;</span>):
<p class="Pp"><span class="Li"></span></p>
<pre>
 nereida:~/src/perl/YappWithDefaultAction/examples&gt; \
        sed -ne '68,$p' 12ts_simplify_with_s.pl | cat -n
  1  sub is_code {
  2    my $self = shift; # tree
  3
  4    # After the shift $_[0] is the father, $_[1] the index
  5    if ((ref($self) eq 'CODE')) {
  6      splice(@{$_[0]-&gt;{children}}, $_[1], 1);
  7      return 1;
  8    }
  9    return 0;
 10  }
 11
 12  Parse::Eyapp-&gt;new_grammar(
 13    input=&gt;$translationscheme,
 14    classname=&gt;'Calc',
 15    firstline =&gt;7,
 16  );
 17  my $parser = Calc-&gt;new();                # Create the parser
 18
 19  $parser-&gt;YYData-&gt;{INPUT} = &quot;2*-3\n&quot;;  print &quot;2*-3\n&quot;; # Set the input
 20  my $t = $parser-&gt;Run;                    # Parse it
 21  print $t-&gt;str.&quot;\n&quot;;
 22  my $p = Parse::Eyapp::YATW-&gt;new(PATTERN =&gt; \&amp;is_code);
 23  $p-&gt;s($t);
 24  { no warnings; # make attr info available only for this display
 25    local *TERMINAL::info = sub { $_[0]{attr} };
 26    print $t-&gt;str.&quot;\n&quot;;
 27  }
</pre>
<p class="Pp">After the <span class="Li">&quot;Parse::Eyapp::YATW&quot;</span>
    object <span class="Li">$p</span> is built at line 22 the call to method
    <span class="Li">&quot;$p-&gt;s($t)&quot;</span> applies the transformation
    <span class="Li">&quot;is_code&quot;</span> using a bottom-up traversing of
    the tree <span class="Li">$t</span>. The achieved effect is the elimination
    of <span class="Li">&quot;CODE&quot;</span> references in the translation
    scheme tree. When executed the former code produces:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
 nereida:~/src/perl/YappWithDefaultAction/examples&gt; 12ts_simplify_with_s.pl
 2*-3
 EXP(TIMES(NUM(TERMINAL,CODE),TERMINAL,UMINUS(TERMINAL,NUM(TERMINAL,CODE),CODE),CODE),CODE)
 EXP(TIMES(NUM(TERMINAL[2]),TERMINAL[*],UMINUS(TERMINAL[-],NUM(TERMINAL[3]))))
</pre>
<p class="Pp">The file <span class="Li">&quot;foldrule6.pl&quot;</span> in the
    <span class="Li">&quot;examples/&quot;</span> distribution directory gives
    you another example:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
 nereida:~/src/perl/YappWithDefaultAction/examples&gt; cat -n foldrule6.pl
   1  #!/usr/bin/perl -w
   2  use strict;
   3  use Rule6;
   4  use Parse::Eyapp::YATW;
   5
   6  my %BinaryOperation = (PLUS=&gt;'+', MINUS =&gt; '-', TIMES=&gt;'*', DIV =&gt; '/');
   7
   8  sub set_terminfo {
   9    no warnings;
  10    *TERMINAL::info = sub { $_[0]{attr} };
  11  }
  12  sub is_foldable {
  13    my ($op, $left, $right);
  14    return 0 unless defined($op = $BinaryOperation{ref($_[0])});
  15    return 0 unless ($left = $_[0]-&gt;child(0), $left-&gt;isa('NUM'));
  16    return 0 unless ($right = $_[0]-&gt;child(1), $right-&gt;isa('NUM'));
  17
  18    my $leftnum = $left-&gt;child(0)-&gt;{attr};
  19    my $rightnum = $right-&gt;child(0)-&gt;{attr};
  20    $left-&gt;child(0)-&gt;{attr} = eval &quot;$leftnum $op $rightnum&quot;;
  21    $_[0] = $left;
  22  }
  23
  24  my $parser = new Rule6();
  25  $parser-&gt;YYData-&gt;{INPUT} = &quot;2*3&quot;;
  26  my $t = $parser-&gt;Run;
  27  &amp;set_terminfo;
  28  print &quot;\n***** Before ******\n&quot;;
  29  print $t-&gt;str;
  30  my $p = Parse::Eyapp::YATW-&gt;new(PATTERN =&gt; \&amp;is_foldable);
  31  $p-&gt;s($t);
  32  print &quot;\n***** After ******\n&quot;;
  33  print $t-&gt;str.&quot;\n&quot;;
</pre>
<p class="Pp">when executed produces:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
 nereida:~/src/perl/YappWithDefaultAction/examples&gt; foldrule6.pl

 ***** Before ******
 TIMES(NUM(TERMINAL[2]),NUM(TERMINAL[3]))
 ***** After ******
 NUM(TERMINAL[6])
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="The__s-1YATW_s0_Tree_Transformation_Call_Protocol"><a class="permalink" href="#The__s-1YATW_s0_Tree_Transformation_Call_Protocol">The
  YATW Tree Transformation Call Protocol</a></h2>
For a subroutine <span class="Li">&quot;pattern_sub&quot;</span> to work as a
  YATW tree transformation - as subroutines
  <span class="Li">&quot;is_foldable&quot;</span> and
  <span class="Li">&quot;is_code&quot;</span> above - has to conform to the
  following call description:
<p class="Pp"><span class="Li"></span></p>
<pre>
  pattern_sub(
      $_[0],  # Node being visited
      $_[1],  # Father of this node
      $index, # Index of this node in @Father-&gt;children
      $self,  # The YATW pattern object
  );
</pre>
<p class="Pp">The <span class="Li">&quot;pattern_sub&quot;</span> must return
    TRUE if matched and FALSE otherwise.</p>
<p class="Pp">The protocol may change in the near future. Avoid using other
    information than the fact that the first argument is the node being
  visited.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Parse::Eyapp::YATW_-_buildpatterns"><a class="permalink" href="#Parse::Eyapp::YATW_-_buildpatterns">Parse::Eyapp::YATW-&gt;buildpatterns</a></h2>
Works as <span class="Li">&quot;Parse::Eyapp-&gt;new&quot;</span> but receives
  an array of subs conforming to the YATW Tree Transformation Call Protocol.
<p class="Pp"><span class="Li"></span></p>
<pre>
  our @all = Parse::Eyapp::YATW-&gt;buildpatt(\&amp;delete_code, \&amp;delete_tokens);
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="$yatw_-_delete"><a class="permalink" href="#$yatw_-_delete">$yatw-&gt;delete</a></h2>
The root of the tree that is currently matched by the YATW transformation
  <span class="Li">$yatw</span> will be deleted from the tree as soon as is
  safe. That usually means when the processing of their siblings is finished.
  The following example (taken from file
  <span class="Li">&quot;examples/13ts_simplify_with_delete.pl&quot;</span> in
  the Parse::Eyapp distribution) illustrates how to eliminate CODE and syntactic
  terminals from the syntax tree:
<p class="Pp"><span class="Li"></span></p>
<pre>
 pl@nereida:~/src/perl/YappWithDefaultAction/examples$ \
        sed -ne '62,$p' 13ts_simplify_with_delete.pl | cat -n
  1  sub not_useful {
  2    my $self = shift; # node
  3    my $pat = $_[2];  # get the YATW object
  4
  5    (ref($self) eq 'CODE') or ((ref($self) eq 'TERMINAL') and ($self-&gt;{token} eq $self-&gt;{attr}))
  6      or do { return 0 };
  7    $pat-&gt;delete();
  8    return 1;
  9  }
 10
 11  Parse::Eyapp-&gt;new_grammar(
 12    input=&gt;$translationscheme,
 13    classname=&gt;'Calc',
 14    firstline =&gt;7,
 15  );
 16  my $parser = Calc-&gt;new();                # Create the parser
 17
 18  $parser-&gt;YYData-&gt;{INPUT} = &quot;2*3\n&quot;; print $parser-&gt;YYData-&gt;{INPUT};
 19  my $t = $parser-&gt;Run;                    # Parse it
 20  print $t-&gt;str.&quot;\n&quot;;                      # Show the tree
 21  my $p = Parse::Eyapp::YATW-&gt;new(PATTERN =&gt; \&amp;not_useful); 
 22  $p-&gt;s($t);                               # Delete nodes
 23  print $t-&gt;str.&quot;\n&quot;;                      # Show the tree
</pre>
<p class="Pp">when executed we get the following output:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
 pl@nereida:~/src/perl/YappWithDefaultAction/examples$ 13ts_simplify_with_delete.pl
 2*3
 EXP(TIMES(NUM(TERMINAL[2],CODE),TERMINAL[*],NUM(TERMINAL[3],CODE),CODE))
 EXP(TIMES(NUM(TERMINAL[2]),NUM(TERMINAL[3])))
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="$yatw_-_unshift"><a class="permalink" href="#$yatw_-_unshift">$yatw-&gt;unshift</a></h2>
The call <span class="Li">&quot;$yatw-&gt;unshift($b)&quot;</span> safely
  unshifts (inserts at the beginning) the node <span class="Li">$b</span> in the
  list of its siblings of the node that matched (i.e in the list of siblings of
  <span class="Li">$_[0]</span>). The following example shows a YATW
  transformation <span class="Li">&quot;insert_child&quot;</span> that
  illustrates the use of <span class="Li">&quot;unshift&quot;</span> (file
  <span class="Li">&quot;examples/26delete_with_trreereg.pl&quot;</span>):
<p class="Pp"><span class="Li"></span></p>
<pre>
 pl@nereida:~/src/perl/YappWithDefaultAction/examples$ \
         sed -ne '70,$p' 26delete_with_trreereg.pl | cat -n
  1  my $transform = Parse::Eyapp::Treeregexp-&gt;new( STRING =&gt; q{
  2
  3      delete_code : CODE =&gt; { $delete_code-&gt;delete() }
  4
  5      {
  6        sub not_semantic {
  7          my $self = shift;
  8          return  1 if ((ref($self) eq 'TERMINAL') and ($self-&gt;{token} eq $self-&gt;{attr}));
  9          return 0;
 10        }
 11      }
 12
 13      delete_tokens : TERMINAL and { not_semantic($TERMINAL) } =&gt; {
 14        $delete_tokens-&gt;delete();
 15      }
 16
 17      insert_child : TIMES(NUM(TERMINAL), NUM(TERMINAL)) =&gt; {
 18        my $b = Parse::Eyapp::Node-&gt;new( 'UMINUS(TERMINAL)',
 19          sub { $_[1]-&gt;{attr} = '4.5' }); # The new node will be a sibling of TIMES
 20
 21        $insert_child-&gt;unshift($b); 
 22      }
 23    },
 24  )-&gt;generate();
 25
 26  Parse::Eyapp-&gt;new_grammar(
 27    input=&gt;$translationscheme,
 28    classname=&gt;'Calc',
 29    firstline =&gt;7,
 30  );
 31  my $parser = Calc-&gt;new();                # Create the parser
 32
 33  $parser-&gt;YYData-&gt;{INPUT} = &quot;2*3\n&quot;; print $parser-&gt;YYData-&gt;{INPUT}; # Set the input
 34  my $t = $parser-&gt;Run;                # Parse it
 35  print $t-&gt;str.&quot;\n&quot;;                        # Show the tree
 36  # Get the AST
 37  our ($delete_tokens, $delete_code);
 38  $t-&gt;s($delete_tokens, $delete_code);
 39  print $t-&gt;str.&quot;\n&quot;;                        # Show the tree
 40  our $insert_child;
 41  $insert_child-&gt;s($t);
 42  print $t-&gt;str.&quot;\n&quot;;                        # Show the tree
</pre>
<p class="Pp">When is executed the program produces the following output:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
 pl@nereida:~/src/perl/YappWithDefaultAction/examples$ 26delete_with_trreereg.pl
 2*3
 EXP(TIMES(NUM(TERMINAL[2],CODE),TERMINAL[*],NUM(TERMINAL[3],CODE),CODE))
 EXP(TIMES(NUM(TERMINAL[2]),NUM(TERMINAL[3])))
 EXP(UMINUS(TERMINAL[4.5]),TIMES(NUM(TERMINAL[2]),NUM(TERMINAL[3])))
</pre>
<p class="Pp">Don't try to take advantage that the transformation sub receives
    in <span class="Li">$_[1]</span> a reference to the father (see the section
    &quot;The YATW Tree Transformation Call Protocol&quot;) and do something
    like:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  unshift $_[1]-&gt;{children}, $b
</pre>
<p class="Pp">it is unsafe.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="$yatw_-_insert_before"><a class="permalink" href="#$yatw_-_insert_before">$yatw-&gt;insert_before</a></h2>
A call to <span class="Li">&quot;$yatw-&gt;insert_before($node)&quot;</span>
  safely inserts <span class="Li">$node</span> in the list of siblings of
  <span class="Li">$_[0]</span> just before <span class="Li">$_[0]</span> (i.e.
  the node that matched with <span class="Li">$yatw</span>). The following
  example (see file
  <span class="Li">&quot;examples/YATW/moveinvariantoutofloopcomplexformula.pl&quot;</span>)
  illustrates its use:
<p class="Pp"><span class="Li"></span></p>
<pre>
  my $p = Parse::Eyapp::Treeregexp-&gt;new( STRING =&gt; q{
    moveinvariant: WHILE(VAR($b), BLOCK(@a, ASSIGN($x, $e), @c)) 
         and { is_invariant($ASSIGN, $WHILE) } =&gt; {
           my $assign = $ASSIGN;
           $BLOCK-&gt;delete($ASSIGN);
           $moveinvariant-&gt;insert_before($assign);
         }
    },
  );
</pre>
<p class="Pp">Here the <span class="Li">&quot;ASSIGN($x, $e)&quot;</span>
    subtree - if is loop invariant - will be moved to the list of siblings of
    <span class="Li">$WHILE</span> just before the
    <span class="Li">$WHILE</span>. Thus a program like</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  &quot;a =1000; c = 1; while (a) { c = c*a; b = 5; a = a-1 }\n&quot;
</pre>
<p class="Pp">is transformed in s.t. like:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  &quot;a =1000; c = 1; b = 5; while (a) { c = c*a; a = a-1 }\n&quot;
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="TREE_MATCHING_AND_TREE_SUBSTITUTION"><a class="permalink" href="#TREE_MATCHING_AND_TREE_SUBSTITUTION">TREE
  MATCHING AND TREE SUBSTITUTION</a></h1>
See the documentation in Parse::Eyapp::treematchingtut
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<ul class="Bl-bullet">
  <li>The project home is at &lt;http://code.google.com/p/parse-eyapp/&gt;. Use
      a subversion client to anonymously check out the latest project source
      code:
    <p class="Pp"><span class="Li"></span></p>
    <pre>
   svn checkout http://parse-eyapp.googlecode.com/svn/trunk/ parse-eyapp-read-only
    </pre>
  </li>
  <li>The tutorial <i>Parsing Strings and Trees with</i>
      <span class="Li">&quot;Parse::Eyapp&quot;</span> (An Introduction to
      Compiler Construction in seven pages) in
      &lt;http://nereida.deioc.ull.es/~pl/eyapsimple/&gt;</li>
  <li>Parse::Eyapp, Parse::Eyapp::eyapplanguageref, Parse::Eyapp::debuggingtut,
      Parse::Eyapp::defaultactionsintro, Parse::Eyapp::translationschemestut,
      Parse::Eyapp::Driver, Parse::Eyapp::Node, Parse::Eyapp::YATW,
      Parse::Eyapp::Treeregexp, Parse::Eyapp::Scope, Parse::Eyapp::Base,
      Parse::Eyapp::datagenerationtut</li>
  <li>The pdf file in
      &lt;http://nereida.deioc.ull.es/~pl/perlexamples/languageintro.pdf&gt;</li>
  <li>The pdf file in
      &lt;http://nereida.deioc.ull.es/~pl/perlexamples/debuggingtut.pdf&gt;</li>
  <li>The pdf file in
      &lt;http://nereida.deioc.ull.es/~pl/perlexamples/eyapplanguageref.pdf&gt;</li>
  <li>The pdf file in
      &lt;http://nereida.deioc.ull.es/~pl/perlexamples/Treeregexp.pdf&gt;</li>
  <li>The pdf file in
      &lt;http://nereida.deioc.ull.es/~pl/perlexamples/Node.pdf&gt;</li>
  <li>The pdf file in
      &lt;http://nereida.deioc.ull.es/~pl/perlexamples/YATW.pdf&gt;</li>
  <li>The pdf file in
      &lt;http://nereida.deioc.ull.es/~pl/perlexamples/Eyapp.pdf&gt;</li>
  <li>The pdf file in
      &lt;http://nereida.deioc.ull.es/~pl/perlexamples/Base.pdf&gt;</li>
  <li>The pdf file in
      &lt;http://nereida.deioc.ull.es/~pl/perlexamples/translationschemestut.pdf&gt;</li>
  <li>The pdf file in
      &lt;http://nereida.deioc.ull.es/~pl/perlexamples/treematchingtut.pdf&gt;</li>
  <li>perldoc eyapp,</li>
  <li>perldoc treereg,</li>
  <li>perldoc vgg,</li>
  <li>The Syntax Highlight file for vim at
      &lt;http://www.vim.org/scripts/script.php?script_id=2453&gt; and
      &lt;http://nereida.deioc.ull.es/~vim/&gt;</li>
  <li><i>Analisis Lexico y Sintactico</i>, (Notes for a course in compiler
      construction) by Casiano Rodriguez-Leon. Available at
      &lt;http://nereida.deioc.ull.es/~pl/perlexamples/&gt; Is the more complete
      and reliable source for Parse::Eyapp. However is in Spanish.</li>
  <li>Parse::Yapp,</li>
  <li>Man pages of <i>yacc</i>(1) and <i>bison</i>(1),
      &lt;http://www.delorie.com/gnu/docs/bison/bison.html&gt;</li>
  <li>Language::AttributeGrammar</li>
  <li>Parse::RecDescent.</li>
  <li>HOP::Parser</li>
  <li>HOP::Lexer</li>
  <li>ocamlyacc tutorial at
      &lt;http://plus.kaist.ac.kr/~shoh/ocaml/ocamllex-ocamlyacc/ocamlyacc-tutorial/ocamlyacc-tutorial.html&gt;</li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="REFERENCES"><a class="permalink" href="#REFERENCES">REFERENCES</a></h1>
<ul class="Bl-bullet">
  <li>The classic Dragon's book <i>Compilers: Principles, Techniques, and
      Tools</i> by Alfred V. Aho, Ravi Sethi and Jeffrey D. Ullman
      (Addison-Wesley 1986)</li>
  <li><i>CS2121: The Implementation and Power of Programming Languages</i> (See
      &lt;http://www.cs.man.ac.uk/~pjj&gt;,
      &lt;http://www.cs.man.ac.uk/~pjj/complang/g2lr.html&gt; and
      &lt;http://www.cs.man.ac.uk/~pjj/cs2121/ho/ho.html&gt;) by Pete Jinks</li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="CONTRIBUTORS"><a class="permalink" href="#CONTRIBUTORS">CONTRIBUTORS</a></h1>
<ul class="Bl-bullet">
  <li>Hal Finkel &lt;http://www.halssoftware.com/&gt;</li>
  <li>G. Williams &lt;http://kasei.us/&gt;</li>
  <li>Thomas L. Shinnick &lt;http://search.cpan.org/~tshinnic/&gt;</li>
  <li>Frank Leray</li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
Casiano Rodriguez-Leon (casiano@ull.es)
</section>
<section class="Sh">
<h1 class="Sh" id="ACKNOWLEDGMENTS"><a class="permalink" href="#ACKNOWLEDGMENTS">ACKNOWLEDGMENTS</a></h1>
This work has been supported by CEE (FEDER) and the Spanish Ministry of
  <i>Educacion y Ciencia</i> through <i>Plan Nacional I+D+I</i> number
  TIN2005-08818-C04-04 (ULL::OPLINK project &lt;http://www.oplink.ull.es/&gt;).
  Support from Gobierno de Canarias was through GC02210601 (<i>Grupos
  Consolidados</i>). The University of La Laguna has also supported my work in
  many ways and for many years.
<p class="Pp">A large percentage of code is verbatim taken from Parse::Yapp
    1.05. The author of Parse::Yapp is Francois Desarmenien.</p>
<p class="Pp">I wish to thank Francois Desarmenien for his Parse::Yapp module,
    to my students at La Laguna and to the Perl Community. Thanks to the people
    who have contributed to improve the module (see &quot;CONTRIBUTORS&quot; in
    Parse::Eyapp). Thanks to Larry Wall for giving us Perl. Special thanks to
    Juana.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="LICENCE_AND_COPYRIGHT"><a class="permalink" href="#LICENCE_AND_COPYRIGHT">LICENCE
  AND COPYRIGHT</a></h1>
Copyright (c) 2006-2008 Casiano Rodriguez-Leon (casiano@ull.es). All rights
  reserved.
<p class="Pp">Parse::Yapp copyright is of Francois Desarmenien, all rights
    reserved. 1998-2001</p>
<p class="Pp">These modules are free software; you can redistribute it and/or
    modify it under the same terms as Perl itself. See perlartistic.</p>
<p class="Pp">This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. </p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2012-03-23</td>
    <td class="foot-os">perl v5.18.2</td>
  </tr>
</table>
</body>
</html>
