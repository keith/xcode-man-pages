<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>PERLXS(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">PERLXS(1)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">PERLXS(1)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
perlxs - XS language reference manual
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<section class="Ss">
<h2 class="Ss" id="Introduction"><a class="permalink" href="#Introduction">Introduction</a></h2>
XS is an interface description file format used to create an extension interface
  between Perl and C code (or a C library) which one wishes to use with Perl.
  The XS interface is combined with the library to create a new library which
  can then be either dynamically loaded or statically linked into perl. The XS
  interface description is written in the XS language and is the core component
  of the Perl extension interface.
<p class="Pp">Before writing XS, read the &quot;CAVEATS&quot; section below.</p>
<p class="Pp">An <b>XSUB</b> forms the basic unit of the XS interface. After
    compilation by the <b>xsubpp</b> compiler, each XSUB amounts to a C function
    definition which will provide the glue between Perl calling conventions and
    C calling conventions.</p>
<p class="Pp">The glue code pulls the arguments from the Perl stack, converts
    these Perl values to the formats expected by a C function, call this C
    function, transfers the return values of the C function back to Perl. Return
    values here may be a conventional C return value or any C function arguments
    that may serve as output parameters. These return values may be passed back
    to Perl either by putting them on the Perl stack, or by modifying the
    arguments supplied from the Perl side.</p>
<p class="Pp">The above is a somewhat simplified view of what really happens.
    Since Perl allows more flexible calling conventions than C, XSUBs may do
    much more in practice, such as checking input parameters for validity,
    throwing exceptions (or returning undef/empty list) if the return value from
    the C function indicates failure, calling different C functions based on
    numbers and types of the arguments, providing an object-oriented interface,
    etc.</p>
<p class="Pp">Of course, one could write such glue code directly in C. However,
    this would be a tedious task, especially if one needs to write glue for
    multiple C functions, and/or one is not familiar enough with the Perl stack
    discipline and other such arcana. XS comes to the rescue here: instead of
    writing this glue C code in long-hand, one can write a more concise
    short-hand <i>description</i> of what should be done by the glue, and let
    the XS compiler <b>xsubpp</b> handle the rest.</p>
<p class="Pp">The XS language allows one to describe the mapping between how the
    C routine is used, and how the corresponding Perl routine is used. It also
    allows creation of Perl routines which are directly translated to C code and
    which are not related to a pre-existing C function. In cases when the C
    interface coincides with the Perl interface, the XSUB declaration is almost
    identical to a declaration of a C function (in K&amp;R style). In such
    circumstances, there is another tool called
    <span class="Li">&quot;h2xs&quot;</span> that is able to translate an entire
    C header file into a corresponding XS file that will provide glue to the
    functions/macros described in the header file.</p>
<p class="Pp">The XS compiler is called <b>xsubpp</b>. This compiler creates the
    constructs necessary to let an XSUB manipulate Perl values, and creates the
    glue necessary to let Perl call the XSUB. The compiler uses <b>typemaps</b>
    to determine how to map C function parameters and output values to Perl
    values and back. The default typemap (which comes with Perl) handles many
    common C types. A supplementary typemap may also be needed to handle any
    special structures and types for the library being linked. For more
    information on typemaps, see perlxstypemap.</p>
<p class="Pp">A file in XS format starts with a C language section which goes
    until the first <span class="Li">&quot;MODULE =&quot;</span> directive.
    Other XS directives and XSUB definitions may follow this line. The
    &quot;language&quot; used in this part of the file is usually referred to as
    the XS language. <b>xsubpp</b> recognizes and skips POD (see perlpod) in
    both the C and XS language sections, which allows the XS file to contain
    embedded documentation.</p>
<p class="Pp">See perlxstut for a tutorial on the whole extension creation
    process.</p>
<p class="Pp">Note: For some extensions, Dave Beazley's SWIG system may provide
    a significantly more convenient mechanism for creating the extension glue
    code. See &lt;http://www.swig.org/&gt; for more information.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="On_The_Road"><a class="permalink" href="#On_The_Road">On The
  Road</a></h2>
Many of the examples which follow will concentrate on creating an interface
  between Perl and the ONC+ RPC bind library functions. The
  <b>rpcb_gettime()</b> function is used to demonstrate many features of the XS
  language. This function has two parameters; the first is an input parameter
  and the second is an output parameter. The function also returns a status
  value.
<p class="Pp"><span class="Li"></span></p>
<pre>
        bool_t rpcb_gettime(const char *host, time_t *timep);
</pre>
<p class="Pp">From C this function will be called with the following
  statements.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
     #include &lt;rpc/rpc.h&gt;
     bool_t status;
     time_t timep;
     status = rpcb_gettime( &quot;localhost&quot;, &amp;timep );
</pre>
<p class="Pp">If an XSUB is created to offer a direct translation between this
    function and Perl, then this XSUB will be used from Perl with the following
    code. The <span class="Li">$status</span> and <span class="Li">$timep</span>
    variables will contain the output of the function.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
     use RPC;
     $status = rpcb_gettime( &quot;localhost&quot;, $timep );
</pre>
<p class="Pp">The following XS file shows an XS subroutine, or XSUB, which
    demonstrates one possible interface to the <b>rpcb_gettime()</b> function.
    This XSUB represents a direct translation between C and Perl and so
    preserves the interface even from Perl. This XSUB will be invoked from Perl
    with the usage shown above. Note that the first three #include statements,
    for <span class="Li">&quot;EXTERN.h&quot;</span>,
    <span class="Li">&quot;perl.h&quot;</span>, and
    <span class="Li">&quot;XSUB.h&quot;</span>, will always be present at the
    beginning of an XS file. This approach and others will be expanded later in
    this document. A #define for
    <span class="Li">&quot;PERL_NO_GET_CONTEXT&quot;</span> should be present to
    fetch the interpreter context more efficiently, see perlguts for
  details.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
     #define PERL_NO_GET_CONTEXT
     #include &quot;EXTERN.h&quot;
     #include &quot;perl.h&quot;
     #include &quot;XSUB.h&quot;
     #include &lt;rpc/rpc.h&gt;

     MODULE = RPC  PACKAGE = RPC

     bool_t
     rpcb_gettime(host,timep)
          char *host
          time_t &amp;timep
        OUTPUT:
          timep
</pre>
<p class="Pp">Any extension to Perl, including those containing XSUBs, should
    have a Perl module to serve as the bootstrap which pulls the extension into
    Perl. This module will export the extension's functions and variables to the
    Perl program and will cause the extension's XSUBs to be linked into Perl.
    The following module will be used for most of the examples in this document
    and should be used from Perl with the
    <span class="Li">&quot;use&quot;</span> command as shown earlier. Perl
    modules are explained in more detail later in this document.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
     package RPC;

     require Exporter;
     require DynaLoader;
     @ISA = qw(Exporter DynaLoader);
     @EXPORT = qw( rpcb_gettime );

     bootstrap RPC;
     1;
</pre>
<p class="Pp">Throughout this document a variety of interfaces to the
    <b>rpcb_gettime()</b> XSUB will be explored. The XSUBs will take their
    parameters in different orders or will take different numbers of parameters.
    In each case the XSUB is an abstraction between Perl and the real C
    <b>rpcb_gettime()</b> function, and the XSUB must always ensure that the
    real <b>rpcb_gettime()</b> function is called with the correct parameters.
    This abstraction will allow the programmer to create a more Perl-like
    interface to the C function.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="The_Anatomy_of_an__s-1XSUB_s0"><a class="permalink" href="#The_Anatomy_of_an__s-1XSUB_s0">The
  Anatomy of an XSUB</a></h2>
The simplest XSUBs consist of 3 parts: a description of the return value, the
  name of the XSUB routine and the names of its arguments, and a description of
  types or formats of the arguments.
<p class="Pp">The following XSUB allows a Perl program to access a C library
    function called <b>sin()</b>. The XSUB will imitate the C function which
    takes a single argument and returns a single value.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
     double
     sin(x)
       double x
</pre>
<p class="Pp">Optionally, one can merge the description of types and the list of
    argument names, rewriting this as</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
     double
     sin(double x)
</pre>
<p class="Pp">This makes this XSUB look similar to an ANSI C declaration. An
    optional semicolon is allowed after the argument list, as in</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
     double
     sin(double x);
</pre>
<p class="Pp">Parameters with C pointer types can have different semantic: C
    functions with similar declarations</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
     bool string_looks_as_a_number(char *s);
     bool make_char_uppercase(char *c);
</pre>
<p class="Pp">are used in absolutely incompatible manner. Parameters to these
    functions could be described <b>xsubpp</b> like this:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
     char *  s
     char    &amp;c
</pre>
<p class="Pp">Both these XS declarations correspond to the
    <span class="Li">&quot;char*&quot;</span> C type, but they have different
    semantics, see &quot;The &amp; Unary Operator&quot;.</p>
<p class="Pp">It is convenient to think that the indirection operator
    <span class="Li">&quot;*&quot;</span> should be considered as a part of the
    type and the address operator <span class="Li">&quot;&amp;&quot;</span>
    should be considered part of the variable. See perlxstypemap for more info
    about handling qualifiers and unary operators in C types.</p>
<p class="Pp">The function name and the return type must be placed on separate
    lines and should be flush left-adjusted.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  INCORRECT                        CORRECT

  double sin(x)                    double
    double x                       sin(x)
                                     double x
</pre>
<p class="Pp">The rest of the function description may be indented or
    left-adjusted. The following example shows a function with its body
    left-adjusted. Most examples in this document will indent the body for
    better readability.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  CORRECT

  double
  sin(x)
  double x
</pre>
<p class="Pp">More complicated XSUBs may contain many other sections. Each
    section of an XSUB starts with the corresponding keyword, such as INIT: or
    CLEANUP:. However, the first two lines of an XSUB always contain the same
    data: descriptions of the return type and the names of the function and its
    parameters. Whatever immediately follows these is considered to be an INPUT:
    section unless explicitly marked with another keyword. (See &quot;The INPUT:
    Keyword&quot;.)</p>
<p class="Pp">An XSUB section continues until another section-start keyword is
    found.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="The_Argument_Stack"><a class="permalink" href="#The_Argument_Stack">The
  Argument Stack</a></h2>
The Perl argument stack is used to store the values which are sent as parameters
  to the XSUB and to store the XSUB's return value(s). In reality all Perl
  functions (including non-XSUB ones) keep their values on this stack all the
  same time, each limited to its own range of positions on the stack. In this
  document the first position on that stack which belongs to the active function
  will be referred to as position 0 for that function.
<p class="Pp">XSUBs refer to their stack arguments with the macro <b>ST(x)</b>,
    where <i>x</i> refers to a position in this XSUB's part of the stack.
    Position 0 for that function would be known to the XSUB as <b>ST</b>(0). The
    XSUB's incoming parameters and outgoing return values always begin at
    <b>ST</b>(0). For many simple cases the <b>xsubpp</b> compiler will generate
    the code necessary to handle the argument stack by embedding code fragments
    found in the typemaps. In more complex cases the programmer must supply the
    code.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="The__s-1RETVAL_s0_Variable"><a class="permalink" href="#The__s-1RETVAL_s0_Variable">The
  RETVAL Variable</a></h2>
The RETVAL variable is a special C variable that is declared automatically for
  you. The C type of RETVAL matches the return type of the C library function.
  The <b>xsubpp</b> compiler will declare this variable in each XSUB with
  non-<span class="Li">&quot;void&quot;</span> return type. By default the
  generated C function will use RETVAL to hold the return value of the C library
  function being called. In simple cases the value of RETVAL will be placed in
  <b>ST</b>(0) of the argument stack where it can be received by Perl as the
  return value of the XSUB.
<p class="Pp">If the XSUB has a return type of
    <span class="Li">&quot;void&quot;</span> then the compiler will not declare
    a RETVAL variable for that function. When using a PPCODE: section no
    manipulation of the RETVAL variable is required, the section may use direct
    stack manipulation to place output values on the stack.</p>
<p class="Pp">If PPCODE: directive is not used,
    <span class="Li">&quot;void&quot;</span> return value should be used only
    for subroutines which do not return a value, <i>even if</i> CODE: directive
    is used which sets <b>ST</b>(0) explicitly.</p>
<p class="Pp">Older versions of this document recommended to use
    <span class="Li">&quot;void&quot;</span> return value in such cases. It was
    discovered that this could lead to segfaults in cases when XSUB was
    <i>truly</i> <span class="Li">&quot;void&quot;</span>. This practice is now
    deprecated, and may be not supported at some future version. Use the return
    value <span class="Li">&quot;SV *&quot;</span> in such cases. (Currently
    <span class="Li">&quot;xsubpp&quot;</span> contains some heuristic code
    which tries to disambiguate between &quot;truly-void&quot; and
    &quot;old-practice-declared-as-void&quot; functions. Hence your code is at
    mercy of this heuristics unless you use <span class="Li">&quot;SV
    *&quot;</span> as return value.)</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Returning_SVs,_AVs_and_HVs_through__s-1RETVAL_s0"><a class="permalink" href="#Returning_SVs,_AVs_and_HVs_through__s-1RETVAL_s0">Returning
  SVs, AVs and HVs through RETVAL</a></h2>
When you're using RETVAL to return an <span class="Li">&quot;SV *&quot;</span>,
  there's some magic going on behind the scenes that should be mentioned. When
  you're manipulating the argument stack using the ST(x) macro, for example, you
  usually have to pay special attention to reference counts. (For more about
  reference counts, see perlguts.) To make your life easier, the typemap file
  automatically makes <span class="Li">&quot;RETVAL&quot;</span> mortal when
  you're returning an <span class="Li">&quot;SV *&quot;</span>. Thus, the
  following two XSUBs are more or less equivalent:
<p class="Pp"><span class="Li"></span></p>
<pre>
  void
  alpha()
      PPCODE:
          ST(0) = newSVpv(&quot;Hello World&quot;,0);
          sv_2mortal(ST(0));
          XSRETURN(1);

  SV *
  beta()
      CODE:
          RETVAL = newSVpv(&quot;Hello World&quot;,0);
      OUTPUT:
          RETVAL
</pre>
<p class="Pp">This is quite useful as it usually improves readability. While
    this works fine for an <span class="Li">&quot;SV *&quot;</span>, it's
    unfortunately not as easy to have <span class="Li">&quot;AV *&quot;</span>
    or <span class="Li">&quot;HV *&quot;</span> as a return value. You
    <i>should</i> be able to write:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  AV *
  array()
      CODE:
          RETVAL = newAV();
          /* do something with RETVAL */
      OUTPUT:
          RETVAL
</pre>
<p class="Pp">But due to an unfixable bug (fixing it would break lots of
    existing CPAN modules) in the typemap file, the reference count of the
    <span class="Li">&quot;AV *&quot;</span> is not properly decremented. Thus,
    the above XSUB would leak memory whenever it is being called. The same
    problem exists for <span class="Li">&quot;HV *&quot;</span>,
    <span class="Li">&quot;CV *&quot;</span>, and
    <span class="Li">&quot;SVREF&quot;</span> (which indicates a scalar
    reference, not a general <span class="Li">&quot;SV *&quot;</span>). In XS
    code on perls starting with perl 5.16, you can override the typemaps for any
    of these types with a version that has proper handling of refcounts. In your
    <span class="Li">&quot;TYPEMAP&quot;</span> section, do</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  AV*   T_AVREF_REFCOUNT_FIXED
</pre>
<p class="Pp">to get the repaired variant. For backward compatibility with older
    versions of perl, you can instead decrement the reference count manually
    when you're returning one of the aforementioned types using
    <span class="Li">&quot;sv_2mortal&quot;</span>:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  AV *
  array()
      CODE:
          RETVAL = newAV();
          sv_2mortal((SV*)RETVAL);
          /* do something with RETVAL */
      OUTPUT:
          RETVAL
</pre>
<p class="Pp">Remember that you don't have to do this for an
    <span class="Li">&quot;SV *&quot;</span>. The reference documentation for
    all core typemaps can be found in perlxstypemap.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="The__s-1MODULE_s0_Keyword"><a class="permalink" href="#The__s-1MODULE_s0_Keyword">The
  MODULE Keyword</a></h2>
The MODULE keyword is used to start the XS code and to specify the package of
  the functions which are being defined. All text preceding the first MODULE
  keyword is considered C code and is passed through to the output with POD
  stripped, but otherwise untouched. Every XS module will have a bootstrap
  function which is used to hook the XSUBs into Perl. The package name of this
  bootstrap function will match the value of the last MODULE statement in the XS
  source files. The value of MODULE should always remain constant within the
  same XS file, though this is not required.
<p class="Pp">The following example will start the XS code and will place all
    functions in a package named RPC.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
     MODULE = RPC
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="The__s-1PACKAGE_s0_Keyword"><a class="permalink" href="#The__s-1PACKAGE_s0_Keyword">The
  PACKAGE Keyword</a></h2>
When functions within an XS source file must be separated into packages the
  PACKAGE keyword should be used. This keyword is used with the MODULE keyword
  and must follow immediately after it when used.
<p class="Pp"><span class="Li"></span></p>
<pre>
     MODULE = RPC  PACKAGE = RPC

     [ XS code in package RPC ]

     MODULE = RPC  PACKAGE = RPCB

     [ XS code in package RPCB ]

     MODULE = RPC  PACKAGE = RPC

     [ XS code in package RPC ]
</pre>
<p class="Pp">The same package name can be used more than once, allowing for
    non-contiguous code. This is useful if you have a stronger ordering
    principle than package names.</p>
<p class="Pp">Although this keyword is optional and in some cases provides
    redundant information it should always be used. This keyword will ensure
    that the XSUBs appear in the desired package.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="The__s-1PREFIX_s0_Keyword"><a class="permalink" href="#The__s-1PREFIX_s0_Keyword">The
  PREFIX Keyword</a></h2>
The PREFIX keyword designates prefixes which should be removed from the Perl
  function names. If the C function is
  <span class="Li">&quot;rpcb_gettime()&quot;</span> and the PREFIX value is
  <span class="Li">&quot;rpcb_&quot;</span> then Perl will see this function as
  <span class="Li">&quot;gettime()&quot;</span>.
<p class="Pp">This keyword should follow the PACKAGE keyword when used. If
    PACKAGE is not used then PREFIX should follow the MODULE keyword.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
     MODULE = RPC  PREFIX = rpc_

     MODULE = RPC  PACKAGE = RPCB  PREFIX = rpcb_
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="The__s-1OUTPUT:_s0_Keyword"><a class="permalink" href="#The__s-1OUTPUT:_s0_Keyword">The
  OUTPUT: Keyword</a></h2>
The OUTPUT: keyword indicates that certain function parameters should be updated
  (new values made visible to Perl) when the XSUB terminates or that certain
  values should be returned to the calling Perl function. For simple functions
  which have no CODE: or PPCODE: section, such as the <b>sin()</b> function
  above, the RETVAL variable is automatically designated as an output value. For
  more complex functions the <b>xsubpp</b> compiler will need help to determine
  which variables are output variables.
<p class="Pp">This keyword will normally be used to complement the CODE:
    keyword. The RETVAL variable is not recognized as an output variable when
    the CODE: keyword is present. The OUTPUT: keyword is used in this situation
    to tell the compiler that RETVAL really is an output variable.</p>
<p class="Pp">The OUTPUT: keyword can also be used to indicate that function
    parameters are output variables. This may be necessary when a parameter has
    been modified within the function and the programmer would like the update
    to be seen by Perl.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
     bool_t
     rpcb_gettime(host,timep)
          char *host
          time_t &amp;timep
        OUTPUT:
          timep
</pre>
<p class="Pp">The OUTPUT: keyword will also allow an output parameter to be
    mapped to a matching piece of code rather than to a typemap.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
     bool_t
     rpcb_gettime(host,timep)
          char *host
          time_t &amp;timep
        OUTPUT:
          timep sv_setnv(ST(1), (double)timep);
</pre>
<p class="Pp"><b>xsubpp</b> emits an automatic
    <span class="Li">&quot;SvSETMAGIC()&quot;</span> for all parameters in the
    OUTPUT section of the XSUB, except RETVAL. This is the usually desired
    behavior, as it takes care of properly invoking 'set' magic on output
    parameters (needed for hash or array element parameters that must be created
    if they didn't exist). If for some reason, this behavior is not desired, the
    OUTPUT section may contain a <span class="Li">&quot;SETMAGIC:
    DISABLE&quot;</span> line to disable it for the remainder of the parameters
    in the OUTPUT section. Likewise, <span class="Li">&quot;SETMAGIC:
    ENABLE&quot;</span> can be used to reenable it for the remainder of the
    OUTPUT section. See perlguts for more details about 'set' magic.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="The__s-1NO_OUTPUT_s0_Keyword"><a class="permalink" href="#The__s-1NO_OUTPUT_s0_Keyword">The
  NO_OUTPUT Keyword</a></h2>
The NO_OUTPUT can be placed as the first token of the XSUB. This keyword
  indicates that while the C subroutine we provide an interface to has a
  non-<span class="Li">&quot;void&quot;</span> return type, the return value of
  this C subroutine should not be returned from the generated Perl subroutine.
<p class="Pp">With this keyword present &quot;The RETVAL Variable&quot; is
    created, and in the generated call to the subroutine this variable is
    assigned to, but the value of this variable is not going to be used in the
    auto-generated code.</p>
<p class="Pp">This keyword makes sense only if
    <span class="Li">&quot;RETVAL&quot;</span> is going to be accessed by the
    user-supplied code. It is especially useful to make a function interface
    more Perl-like, especially when the C return value is just an error
    condition indicator. For example,</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  NO_OUTPUT int
  delete_file(char *name)
    POSTCALL:
      if (RETVAL != 0)
          croak(&quot;Error %d while deleting file '%s'&quot;, RETVAL, name);
</pre>
<p class="Pp">Here the generated XS function returns nothing on success, and
    will <b>die()</b> with a meaningful error message on error.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="The__s-1CODE:_s0_Keyword"><a class="permalink" href="#The__s-1CODE:_s0_Keyword">The
  CODE: Keyword</a></h2>
This keyword is used in more complicated XSUBs which require special handling
  for the C function. The RETVAL variable is still declared, but it will not be
  returned unless it is specified in the OUTPUT: section.
<p class="Pp">The following XSUB is for a C function which requires special
    handling of its parameters. The Perl usage is given first.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
     $status = rpcb_gettime( &quot;localhost&quot;, $timep );
</pre>
<p class="Pp">The XSUB follows.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
     bool_t
     rpcb_gettime(host,timep)
          char *host
          time_t timep
        CODE:
               RETVAL = rpcb_gettime( host, &amp;timep );
        OUTPUT:
          timep
          RETVAL
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="The__s-1INIT:_s0_Keyword"><a class="permalink" href="#The__s-1INIT:_s0_Keyword">The
  INIT: Keyword</a></h2>
The INIT: keyword allows initialization to be inserted into the XSUB before the
  compiler generates the call to the C function. Unlike the CODE: keyword above,
  this keyword does not affect the way the compiler handles RETVAL.
<p class="Pp"><span class="Li"></span></p>
<pre>
    bool_t
    rpcb_gettime(host,timep)
          char *host
          time_t &amp;timep
        INIT:
          printf(&quot;# Host is %s\n&quot;, host );
        OUTPUT:
          timep
</pre>
<p class="Pp">Another use for the INIT: section is to check for preconditions
    before making a call to the C function:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    long long
    lldiv(a,b)
        long long a
        long long b
      INIT:
        if (a == 0 &amp;&amp; b == 0)
            XSRETURN_UNDEF;
        if (b == 0)
            croak(&quot;lldiv: cannot divide by 0&quot;);
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="The__s-1NO_INIT_s0_Keyword"><a class="permalink" href="#The__s-1NO_INIT_s0_Keyword">The
  NO_INIT Keyword</a></h2>
The NO_INIT keyword is used to indicate that a function parameter is being used
  only as an output value. The <b>xsubpp</b> compiler will normally generate
  code to read the values of all function parameters from the argument stack and
  assign them to C variables upon entry to the function. NO_INIT will tell the
  compiler that some parameters will be used for output rather than for input
  and that they will be handled before the function terminates.
<p class="Pp">The following example shows a variation of the
    <b>rpcb_gettime()</b> function. This function uses the timep variable only
    as an output variable and does not care about its initial contents.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
     bool_t
     rpcb_gettime(host,timep)
          char *host
          time_t &amp;timep = NO_INIT
        OUTPUT:
          timep
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="The__s-1TYPEMAP:_s0_Keyword"><a class="permalink" href="#The__s-1TYPEMAP:_s0_Keyword">The
  TYPEMAP: Keyword</a></h2>
Starting with Perl 5.16, you can embed typemaps into your XS code instead of or
  in addition to typemaps in a separate file. Multiple such embedded typemaps
  will be processed in order of appearance in the XS code and like local typemap
  files take precedence over the default typemap, the embedded typemaps may
  overwrite previous definitions of TYPEMAP, INPUT, and OUTPUT stanzas. The
  syntax for embedded typemaps is
<p class="Pp"><span class="Li"></span></p>
<pre>
      TYPEMAP: &lt;&lt;HERE
      ... your typemap code here ...
      HERE
</pre>
<p class="Pp">where the <span class="Li">&quot;TYPEMAP&quot;</span> keyword must
    appear in the first column of a new line.</p>
<p class="Pp">Refer to perlxstypemap for details on writing typemaps.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Initializing_Function_Parameters"><a class="permalink" href="#Initializing_Function_Parameters">Initializing
  Function Parameters</a></h2>
C function parameters are normally initialized with their values from the
  argument stack (which in turn contains the parameters that were passed to the
  XSUB from Perl). The typemaps contain the code segments which are used to
  translate the Perl values to the C parameters. The programmer, however, is
  allowed to override the typemaps and supply alternate (or additional)
  initialization code. Initialization code starts with the first
  <span class="Li">&quot;=&quot;</span>, <span class="Li">&quot;;&quot;</span>
  or <span class="Li">&quot;+&quot;</span> on a line in the INPUT: section. The
  only exception happens if this <span class="Li">&quot;;&quot;</span>
  terminates the line, then this <span class="Li">&quot;;&quot;</span> is
  quietly ignored.
<p class="Pp">The following code demonstrates how to supply initialization code
    for function parameters. The initialization code is eval'ed within double
    quotes by the compiler before it is added to the output so anything which
    should be interpreted literally [mainly
    <span class="Li">&quot;$&quot;</span>,
    <span class="Li">&quot;@&quot;</span>, or
    <span class="Li">&quot;\\&quot;</span>] must be protected with backslashes.
    The variables <span class="Li">$var</span>, <span class="Li">$arg</span>,
    and <span class="Li">$type</span> can be used as in typemaps.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
     bool_t
     rpcb_gettime(host,timep)
          char *host = (char *)SvPV_nolen($arg);
          time_t &amp;timep = 0;
        OUTPUT:
          timep
</pre>
<p class="Pp">This should not be used to supply default values for parameters.
    One would normally use this when a function parameter must be processed by
    another library function before it can be used. Default parameters are
    covered in the next section.</p>
<p class="Pp">If the initialization begins with
    <span class="Li">&quot;=&quot;</span>, then it is output in the declaration
    for the input variable, replacing the initialization supplied by the
    typemap. If the initialization begins with
    <span class="Li">&quot;;&quot;</span> or
    <span class="Li">&quot;+&quot;</span>, then it is performed after all of the
    input variables have been declared. In the
    <span class="Li">&quot;;&quot;</span> case the initialization normally
    supplied by the typemap is not performed. For the
    <span class="Li">&quot;+&quot;</span> case, the declaration for the variable
    will include the initialization from the typemap. A global variable,
    <span class="Li">%v</span>, is available for the truly rare case where
    information from one initialization is needed in another initialization.</p>
<p class="Pp">Here's a truly obscure example:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
     bool_t
     rpcb_gettime(host,timep)
          time_t &amp;timep; /* \$v{timep}=@{[$v{timep}=$arg]} */
          char *host + SvOK($v{timep}) ? SvPV_nolen($arg) : NULL;
        OUTPUT:
          timep
</pre>
<p class="Pp">The construct
    <span class="Li">&quot;\$v{timep}=@{[$v{timep}=$arg]}&quot;</span> used in
    the above example has a two-fold purpose: first, when this line is processed
    by <b>xsubpp</b>, the Perl snippet
    <span class="Li">&quot;$v{timep}=$arg&quot;</span> is evaluated. Second, the
    text of the evaluated snippet is output into the generated C file (inside a
    C comment)! During the processing of <span class="Li">&quot;char
    *host&quot;</span> line, <span class="Li">$arg</span> will evaluate to
    <span class="Li">ST(0)</span>, and <span class="Li">$v{timep}</span> will
    evaluate to <span class="Li">ST(1)</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Default_Parameter_Values"><a class="permalink" href="#Default_Parameter_Values">Default
  Parameter Values</a></h2>
Default values for XSUB arguments can be specified by placing an assignment
  statement in the parameter list. The default value may be a number, a string
  or the special string <span class="Li">&quot;NO_INIT&quot;</span>. Defaults
  should always be used on the right-most parameters only.
<p class="Pp">To allow the XSUB for <b>rpcb_gettime()</b> to have a default host
    value the parameters to the XSUB could be rearranged. The XSUB will then
    call the real <b>rpcb_gettime()</b> function with the parameters in the
    correct order. This XSUB can be called from Perl with either of the
    following statements:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
     $status = rpcb_gettime( $timep, $host );

     $status = rpcb_gettime( $timep );
</pre>
<p class="Pp">The XSUB will look like the code which follows. A CODE: block is
    used to call the real <b>rpcb_gettime()</b> function with the parameters in
    the correct order for that function.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
     bool_t
     rpcb_gettime(timep,host=&quot;localhost&quot;)
          char *host
          time_t timep = NO_INIT
        CODE:
               RETVAL = rpcb_gettime( host, &amp;timep );
        OUTPUT:
          timep
          RETVAL
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="The__s-1PREINIT:_s0_Keyword"><a class="permalink" href="#The__s-1PREINIT:_s0_Keyword">The
  PREINIT: Keyword</a></h2>
The PREINIT: keyword allows extra variables to be declared immediately before or
  after the declarations of the parameters from the INPUT: section are emitted.
<p class="Pp">If a variable is declared inside a CODE: section it will follow
    any typemap code that is emitted for the input parameters. This may result
    in the declaration ending up after C code, which is C syntax error. Similar
    errors may happen with an explicit
    <span class="Li">&quot;;&quot;</span>-type or
    <span class="Li">&quot;+&quot;</span>-type initialization of parameters is
    used (see &quot;Initializing Function Parameters&quot;). Declaring these
    variables in an INIT: section will not help.</p>
<p class="Pp">In such cases, to force an additional variable to be declared
    together with declarations of other variables, place the declaration into a
    PREINIT: section. The PREINIT: keyword may be used one or more times within
    an XSUB.</p>
<p class="Pp">The following examples are equivalent, but if the code is using
    complex typemaps then the first example is safer.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
     bool_t
     rpcb_gettime(timep)
          time_t timep = NO_INIT
        PREINIT:
          char *host = &quot;localhost&quot;;
        CODE:
          RETVAL = rpcb_gettime( host, &amp;timep );
        OUTPUT:
          timep
          RETVAL
</pre>
<p class="Pp">For this particular case an INIT: keyword would generate the same
    C code as the PREINIT: keyword. Another correct, but error-prone
  example:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
     bool_t
     rpcb_gettime(timep)
          time_t timep = NO_INIT
        CODE:
          char *host = &quot;localhost&quot;;
          RETVAL = rpcb_gettime( host, &amp;timep );
        OUTPUT:
          timep
          RETVAL
</pre>
<p class="Pp">Another way to declare <span class="Li">&quot;host&quot;</span> is
    to use a C block in the CODE: section:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
     bool_t
     rpcb_gettime(timep)
          time_t timep = NO_INIT
        CODE:
          {
            char *host = &quot;localhost&quot;;
            RETVAL = rpcb_gettime( host, &amp;timep );
          }
        OUTPUT:
          timep
          RETVAL
</pre>
<p class="Pp">The ability to put additional declarations before the typemap
    entries are processed is very handy in the cases when typemap conversions
    manipulate some global state:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    MyObject
    mutate(o)
        PREINIT:
            MyState st = global_state;
        INPUT:
            MyObject o;
        CLEANUP:
            reset_to(global_state, st);
</pre>
<p class="Pp">Here we suppose that conversion to
    <span class="Li">&quot;MyObject&quot;</span> in the INPUT: section and from
    MyObject when processing RETVAL will modify a global variable
    <span class="Li">&quot;global_state&quot;</span>. After these conversions
    are performed, we restore the old value of
    <span class="Li">&quot;global_state&quot;</span> (to avoid memory leaks, for
    example).</p>
<p class="Pp">There is another way to trade clarity for compactness: INPUT
    sections allow declaration of C variables which do not appear in the
    parameter list of a subroutine. Thus the above code for <b>mutate()</b> can
    be rewritten as</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    MyObject
    mutate(o)
          MyState st = global_state;
          MyObject o;
        CLEANUP:
          reset_to(global_state, st);
</pre>
<p class="Pp">and the code for <b>rpcb_gettime()</b> can be rewritten as</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
     bool_t
     rpcb_gettime(timep)
          time_t timep = NO_INIT
          char *host = &quot;localhost&quot;;
        C_ARGS:
          host, &amp;timep
        OUTPUT:
          timep
          RETVAL
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="The__s-1SCOPE:_s0_Keyword"><a class="permalink" href="#The__s-1SCOPE:_s0_Keyword">The
  SCOPE: Keyword</a></h2>
The SCOPE: keyword allows scoping to be enabled for a particular XSUB. If
  enabled, the XSUB will invoke ENTER and LEAVE automatically.
<p class="Pp">To support potentially complex type mappings, if a typemap entry
    used by an XSUB contains a comment like
    <span class="Li">&quot;/*scope*/&quot;</span> then scoping will be
    automatically enabled for that XSUB.</p>
<p class="Pp">To enable scoping:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    SCOPE: ENABLE
</pre>
<p class="Pp">To disable scoping:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    SCOPE: DISABLE
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="The__s-1INPUT:_s0_Keyword"><a class="permalink" href="#The__s-1INPUT:_s0_Keyword">The
  INPUT: Keyword</a></h2>
The XSUB's parameters are usually evaluated immediately after entering the XSUB.
  The INPUT: keyword can be used to force those parameters to be evaluated a
  little later. The INPUT: keyword can be used multiple times within an XSUB and
  can be used to list one or more input variables. This keyword is used with the
  PREINIT: keyword.
<p class="Pp">The following example shows how the input parameter
    <span class="Li">&quot;timep&quot;</span> can be evaluated late, after a
    PREINIT.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    bool_t
    rpcb_gettime(host,timep)
          char *host
        PREINIT:
          time_t tt;
        INPUT:
          time_t timep
        CODE:
               RETVAL = rpcb_gettime( host, &amp;tt );
               timep = tt;
        OUTPUT:
          timep
          RETVAL
</pre>
<p class="Pp">The next example shows each input parameter evaluated late.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    bool_t
    rpcb_gettime(host,timep)
        PREINIT:
          time_t tt;
        INPUT:
          char *host
        PREINIT:
          char *h;
        INPUT:
          time_t timep
        CODE:
               h = host;
               RETVAL = rpcb_gettime( h, &amp;tt );
               timep = tt;
        OUTPUT:
          timep
          RETVAL
</pre>
<p class="Pp">Since INPUT sections allow declaration of C variables which do not
    appear in the parameter list of a subroutine, this may be shortened to:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    bool_t
    rpcb_gettime(host,timep)
          time_t tt;
          char *host;
          char *h = host;
          time_t timep;
        CODE:
          RETVAL = rpcb_gettime( h, &amp;tt );
          timep = tt;
        OUTPUT:
          timep
          RETVAL
</pre>
<p class="Pp">(We used our knowledge that input conversion for
    <span class="Li">&quot;char *&quot;</span> is a &quot;simple&quot; one, thus
    <span class="Li">&quot;host&quot;</span> is initialized on the declaration
    line, and our assignment <span class="Li">&quot;h = host&quot;</span> is not
    performed too early. Otherwise one would need to have the assignment
    <span class="Li">&quot;h = host&quot;</span> in a CODE: or INIT:
  section.)</p>
</section>
<section class="Ss">
<h2 class="Ss" id="The__s-1IN/OUTLIST/IN_OUTLIST/OUT/IN_OUT_s0_Keywords"><a class="permalink" href="#The__s-1IN/OUTLIST/IN_OUTLIST/OUT/IN_OUT_s0_Keywords">The
  IN/OUTLIST/IN_OUTLIST/OUT/IN_OUT Keywords</a></h2>
In the list of parameters for an XSUB, one can precede parameter names by the
  <span class="Li">&quot;IN&quot;</span>/<span class="Li">&quot;OUTLIST&quot;</span>/<span class="Li">&quot;IN_OUTLIST&quot;</span>/<span class="Li">&quot;OUT&quot;</span>/<span class="Li">&quot;IN_OUT&quot;</span>
  keywords. <span class="Li">&quot;IN&quot;</span> keyword is the default, the
  other keywords indicate how the Perl interface should differ from the C
  interface.
<p class="Pp">Parameters preceded by
    <span class="Li">&quot;OUTLIST&quot;</span>/<span class="Li">&quot;IN_OUTLIST&quot;</span>/<span class="Li">&quot;OUT&quot;</span>/<span class="Li">&quot;IN_OUT&quot;</span>
    keywords are considered to be used by the C subroutine <i>via</i>
    <i>pointers</i>.
    <span class="Li">&quot;OUTLIST&quot;</span>/<span class="Li">&quot;OUT&quot;</span>
    keywords indicate that the C subroutine does not inspect the memory pointed
    by this parameter, but will write through this pointer to provide additional
    return values.</p>
<p class="Pp">Parameters preceded by <span class="Li">&quot;OUTLIST&quot;</span>
    keyword do not appear in the usage signature of the generated Perl
  function.</p>
<p class="Pp">Parameters preceded by
    <span class="Li">&quot;IN_OUTLIST&quot;</span>/<span class="Li">&quot;IN_OUT&quot;</span>/<span class="Li">&quot;OUT&quot;</span>
    <i>do</i> appear as parameters to the Perl function. With the exception of
    <span class="Li">&quot;OUT&quot;</span>-parameters, these parameters are
    converted to the corresponding C type, then pointers to these data are given
    as arguments to the C function. It is expected that the C function will
    write through these pointers.</p>
<p class="Pp">The return list of the generated Perl function consists of the C
    return value from the function (unless the XSUB is of
    <span class="Li">&quot;void&quot;</span> return type or
    <span class="Li">&quot;The NO_OUTPUT Keyword&quot;</span> was used) followed
    by all the <span class="Li">&quot;OUTLIST&quot;</span> and
    <span class="Li">&quot;IN_OUTLIST&quot;</span> parameters (in the order of
    appearance). On the return from the XSUB the
    <span class="Li">&quot;IN_OUT&quot;</span>/<span class="Li">&quot;OUT&quot;</span>
    Perl parameter will be modified to have the values written by the C
    function.</p>
<p class="Pp">For example, an XSUB</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  void
  day_month(OUTLIST day, IN unix_time, OUTLIST month)
    int day
    int unix_time
    int month
</pre>
<p class="Pp">should be used from Perl as</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  my ($day, $month) = day_month(time);
</pre>
<p class="Pp">The C signature of the corresponding function should be</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  void day_month(int *day, int unix_time, int *month);
</pre>
<p class="Pp">The
    <span class="Li">&quot;IN&quot;</span>/<span class="Li">&quot;OUTLIST&quot;</span>/<span class="Li">&quot;IN_OUTLIST&quot;</span>/<span class="Li">&quot;IN_OUT&quot;</span>/<span class="Li">&quot;OUT&quot;</span>
    keywords can be mixed with ANSI-style declarations, as in</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  void
  day_month(OUTLIST int day, int unix_time, OUTLIST int month)
</pre>
<p class="Pp">(here the optional <span class="Li">&quot;IN&quot;</span> keyword
    is omitted).</p>
<p class="Pp">The <span class="Li">&quot;IN_OUT&quot;</span> parameters are
    identical with parameters introduced with &quot;The &amp; Unary
    Operator&quot; and put into the <span class="Li">&quot;OUTPUT:&quot;</span>
    section (see &quot;The OUTPUT: Keyword&quot;). The
    <span class="Li">&quot;IN_OUTLIST&quot;</span> parameters are very similar,
    the only difference being that the value C function writes through the
    pointer would not modify the Perl parameter, but is put in the output
  list.</p>
<p class="Pp">The
    <span class="Li">&quot;OUTLIST&quot;</span>/<span class="Li">&quot;OUT&quot;</span>
    parameter differ from
    <span class="Li">&quot;IN_OUTLIST&quot;</span>/<span class="Li">&quot;IN_OUT&quot;</span>
    parameters only by the initial value of the Perl parameter not being read
    (and not being given to the C function - which gets some garbage instead).
    For example, the same C function as above can be interfaced with as</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  void day_month(OUT int day, int unix_time, OUT int month);
</pre>
<p class="Pp">or</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  void
  day_month(day, unix_time, month)
      int &amp;day = NO_INIT
      int  unix_time
      int &amp;month = NO_INIT
    OUTPUT:
      day
      month
</pre>
<p class="Pp">However, the generated Perl function is called in very C-ish
    style:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  my ($day, $month);
  day_month($day, time, $month);
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="The__length(NAME)__Keyword"><a class="permalink" href="#The__length(NAME)__Keyword">The
  &quot;length(NAME)&quot; Keyword</a></h2>
If one of the input arguments to the C function is the length of a string
  argument <span class="Li">&quot;NAME&quot;</span>, one can substitute the name
  of the length-argument by <span class="Li">&quot;length(NAME)&quot;</span> in
  the XSUB declaration. This argument must be omitted when the generated Perl
  function is called. E.g.,
<p class="Pp"><span class="Li"></span></p>
<pre>
  void
  dump_chars(char *s, short l)
  {
    short n = 0;
    while (n &lt; l) {
        printf(&quot;s[%d] = \&quot;\\%#03o\&quot;\n&quot;, n, (int)s[n]);
        n++;
    }
  }

  MODULE = x            PACKAGE = x

  void dump_chars(char *s, short length(s))
</pre>
<p class="Pp">should be called as
    <span class="Li">&quot;dump_chars($string)&quot;</span>.</p>
<p class="Pp">This directive is supported with ANSI-type function declarations
    only.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Variable-length_Parameter_Lists"><a class="permalink" href="#Variable-length_Parameter_Lists">Variable-length
  Parameter Lists</a></h2>
XSUBs can have variable-length parameter lists by specifying an ellipsis
  <span class="Li">&quot;(...)&quot;</span> in the parameter list. This use of
  the ellipsis is similar to that found in ANSI C. The programmer is able to
  determine the number of arguments passed to the XSUB by examining the
  <span class="Li">&quot;items&quot;</span> variable which the <b>xsubpp</b>
  compiler supplies for all XSUBs. By using this mechanism one can create an
  XSUB which accepts a list of parameters of unknown length.
<p class="Pp">The <i>host</i> parameter for the <b>rpcb_gettime()</b> XSUB can
    be optional so the ellipsis can be used to indicate that the XSUB will take
    a variable number of parameters. Perl should be able to call this XSUB with
    either of the following statements.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
     $status = rpcb_gettime( $timep, $host );

     $status = rpcb_gettime( $timep );
</pre>
<p class="Pp">The XS code, with ellipsis, follows.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
     bool_t
     rpcb_gettime(timep, ...)
          time_t timep = NO_INIT
        PREINIT:
          char *host = &quot;localhost&quot;;
        CODE:
          if( items &gt; 1 )
               host = (char *)SvPV_nolen(ST(1));
          RETVAL = rpcb_gettime( host, &amp;timep );
        OUTPUT:
          timep
          RETVAL
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="The_C_ARGS:_Keyword"><a class="permalink" href="#The_C_ARGS:_Keyword">The
  C_ARGS: Keyword</a></h2>
The C_ARGS: keyword allows creating of XSUBS which have different calling
  sequence from Perl than from C, without a need to write CODE: or PPCODE:
  section. The contents of the C_ARGS: paragraph is put as the argument to the
  called C function without any change.
<p class="Pp">For example, suppose that a C function is declared as</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    symbolic nth_derivative(int n, symbolic function, int flags);
</pre>
<p class="Pp">and that the default flags are kept in a global C variable
    <span class="Li">&quot;default_flags&quot;</span>. Suppose that you want to
    create an interface which is called as</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    $second_deriv = $function-&gt;nth_derivative(2);
</pre>
<p class="Pp">To do this, declare the XSUB as</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    symbolic
    nth_derivative(function, n)
        symbolic        function
        int             n
      C_ARGS:
        n, function, default_flags
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="The__s-1PPCODE:_s0_Keyword"><a class="permalink" href="#The__s-1PPCODE:_s0_Keyword">The
  PPCODE: Keyword</a></h2>
The PPCODE: keyword is an alternate form of the CODE: keyword and is used to
  tell the <b>xsubpp</b> compiler that the programmer is supplying the code to
  control the argument stack for the XSUBs return values. Occasionally one will
  want an XSUB to return a list of values rather than a single value. In these
  cases one must use PPCODE: and then explicitly push the list of values on the
  stack. The PPCODE: and CODE: keywords should not be used together within the
  same XSUB.
<p class="Pp">The actual difference between PPCODE: and CODE: sections is in the
    initialization of <span class="Li">&quot;SP&quot;</span> macro (which stands
    for the <i>current</i> Perl stack pointer), and in the handling of data on
    the stack when returning from an XSUB. In CODE: sections SP preserves the
    value which was on entry to the XSUB: SP is on the function pointer (which
    follows the last parameter). In PPCODE: sections SP is moved backward to the
    beginning of the parameter list, which allows
    <span class="Li">&quot;PUSH*()&quot;</span> macros to place output values in
    the place Perl expects them to be when the XSUB returns back to Perl.</p>
<p class="Pp">The generated trailer for a CODE: section ensures that the number
    of return values Perl will see is either 0 or 1 (depending on the
    <span class="Li">&quot;void&quot;</span>ness of the return value of the C
    function, and heuristics mentioned in &quot;The RETVAL Variable&quot;). The
    trailer generated for a PPCODE: section is based on the number of return
    values and on the number of times <span class="Li">&quot;SP&quot;</span> was
    updated by <span class="Li">&quot;[X]PUSH*()&quot;</span> macros.</p>
<p class="Pp">Note that macros <span class="Li">ST(i)</span>,
    <span class="Li">&quot;XST_m*()&quot;</span> and
    <span class="Li">&quot;XSRETURN*()&quot;</span> work equally well in CODE:
    sections and PPCODE: sections.</p>
<p class="Pp">The following XSUB will call the C <b>rpcb_gettime()</b> function
    and will return its two output values, timep and status, to Perl as a single
    list.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
     void
     rpcb_gettime(host)
          char *host
        PREINIT:
          time_t  timep;
          bool_t  status;
        PPCODE:
          status = rpcb_gettime( host, &amp;timep );
          EXTEND(SP, 2);
          PUSHs(sv_2mortal(newSViv(status)));
          PUSHs(sv_2mortal(newSViv(timep)));
</pre>
<p class="Pp">Notice that the programmer must supply the C code necessary to
    have the real <b>rpcb_gettime()</b> function called and to have the return
    values properly placed on the argument stack.</p>
<p class="Pp">The <span class="Li">&quot;void&quot;</span> return type for this
    function tells the <b>xsubpp</b> compiler that the RETVAL variable is not
    needed or used and that it should not be created. In most scenarios the void
    return type should be used with the PPCODE: directive.</p>
<p class="Pp">The <b>EXTEND()</b> macro is used to make room on the argument
    stack for 2 return values. The PPCODE: directive causes the <b>xsubpp</b>
    compiler to create a stack pointer available as
    <span class="Li">&quot;SP&quot;</span>, and it is this pointer which is
    being used in the <b>EXTEND()</b> macro. The values are then pushed onto the
    stack with the <b>PUSHs()</b> macro.</p>
<p class="Pp">Now the <b>rpcb_gettime()</b> function can be used from Perl with
    the following statement.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
     ($status, $timep) = rpcb_gettime(&quot;localhost&quot;);
</pre>
<p class="Pp">When handling output parameters with a PPCODE section, be sure to
    handle 'set' magic properly. See perlguts for details about 'set' magic.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Returning_Undef_And_Empty_Lists"><a class="permalink" href="#Returning_Undef_And_Empty_Lists">Returning
  Undef And Empty Lists</a></h2>
Occasionally the programmer will want to return simply
  <span class="Li">&quot;undef&quot;</span> or an empty list if a function fails
  rather than a separate status value. The <b>rpcb_gettime()</b> function offers
  just this situation. If the function succeeds we would like to have it return
  the time and if it fails we would like to have undef returned. In the
  following Perl code the value of <span class="Li">$timep</span> will either be
  undef or it will be a valid time.
<p class="Pp"><span class="Li"></span></p>
<pre>
     $timep = rpcb_gettime( &quot;localhost&quot; );
</pre>
<p class="Pp">The following XSUB uses the <span class="Li">&quot;SV
    *&quot;</span> return type as a mnemonic only, and uses a CODE: block to
    indicate to the compiler that the programmer has supplied all the necessary
    code. The <b>sv_newmortal()</b> call will initialize the return value to
    undef, making that the default return value.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
     SV *
     rpcb_gettime(host)
          char *  host
        PREINIT:
          time_t  timep;
          bool_t x;
        CODE:
          ST(0) = sv_newmortal();
          if( rpcb_gettime( host, &amp;timep ) )
               sv_setnv( ST(0), (double)timep);
</pre>
<p class="Pp">The next example demonstrates how one would place an explicit
    undef in the return value, should the need arise.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
     SV *
     rpcb_gettime(host)
          char *  host
        PREINIT:
          time_t  timep;
          bool_t x;
        CODE:
          if( rpcb_gettime( host, &amp;timep ) ){
               ST(0) = sv_newmortal();
               sv_setnv( ST(0), (double)timep);
          }
          else{
               ST(0) = &amp;PL_sv_undef;
          }
</pre>
<p class="Pp">To return an empty list one must use a PPCODE: block and then not
    push return values on the stack.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
     void
     rpcb_gettime(host)
          char *host
        PREINIT:
          time_t  timep;
        PPCODE:
          if( rpcb_gettime( host, &amp;timep ) )
               PUSHs(sv_2mortal(newSViv(timep)));
          else{
              /* Nothing pushed on stack, so an empty
               * list is implicitly returned. */
          }
</pre>
<p class="Pp">Some people may be inclined to include an explicit
    <span class="Li">&quot;return&quot;</span> in the above XSUB, rather than
    letting control fall through to the end. In those situations
    <span class="Li">&quot;XSRETURN_EMPTY&quot;</span> should be used, instead.
    This will ensure that the XSUB stack is properly adjusted. Consult perlapi
    for other <span class="Li">&quot;XSRETURN&quot;</span> macros.</p>
<p class="Pp">Since <span class="Li">&quot;XSRETURN_*&quot;</span> macros can be
    used with CODE blocks as well, one can rewrite this example as:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
     int
     rpcb_gettime(host)
          char *host
        PREINIT:
          time_t  timep;
        CODE:
          RETVAL = rpcb_gettime( host, &amp;timep );
          if (RETVAL == 0)
                XSRETURN_UNDEF;
        OUTPUT:
          RETVAL
</pre>
<p class="Pp">In fact, one can put this check into a POSTCALL: section as well.
    Together with PREINIT: simplifications, this leads to:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
     int
     rpcb_gettime(host)
          char *host
          time_t  timep;
        POSTCALL:
          if (RETVAL == 0)
                XSRETURN_UNDEF;
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="The__s-1REQUIRE:_s0_Keyword"><a class="permalink" href="#The__s-1REQUIRE:_s0_Keyword">The
  REQUIRE: Keyword</a></h2>
The REQUIRE: keyword is used to indicate the minimum version of the
  <b>xsubpp</b> compiler needed to compile the XS module. An XS module which
  contains the following statement will compile with only <b>xsubpp</b> version
  1.922 or greater:
<p class="Pp"><span class="Li"></span></p>
<pre>
        REQUIRE: 1.922
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="The__s-1CLEANUP:_s0_Keyword"><a class="permalink" href="#The__s-1CLEANUP:_s0_Keyword">The
  CLEANUP: Keyword</a></h2>
This keyword can be used when an XSUB requires special cleanup procedures before
  it terminates. When the CLEANUP: keyword is used it must follow any CODE:, or
  OUTPUT: blocks which are present in the XSUB. The code specified for the
  cleanup block will be added as the last statements in the XSUB.
</section>
<section class="Ss">
<h2 class="Ss" id="The__s-1POSTCALL:_s0_Keyword"><a class="permalink" href="#The__s-1POSTCALL:_s0_Keyword">The
  POSTCALL: Keyword</a></h2>
This keyword can be used when an XSUB requires special procedures executed after
  the C subroutine call is performed. When the POSTCALL: keyword is used it must
  precede OUTPUT: and CLEANUP: blocks which are present in the XSUB.
<p class="Pp">See examples in &quot;The NO_OUTPUT Keyword&quot; and
    &quot;Returning Undef And Empty Lists&quot;.</p>
<p class="Pp">The POSTCALL: block does not make a lot of sense when the C
    subroutine call is supplied by user by providing either CODE: or PPCODE:
    section.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="The__s-1BOOT:_s0_Keyword"><a class="permalink" href="#The__s-1BOOT:_s0_Keyword">The
  BOOT: Keyword</a></h2>
The BOOT: keyword is used to add code to the extension's bootstrap function. The
  bootstrap function is generated by the <b>xsubpp</b> compiler and normally
  holds the statements necessary to register any XSUBs with Perl. With the BOOT:
  keyword the programmer can tell the compiler to add extra statements to the
  bootstrap function.
<p class="Pp">This keyword may be used any time after the first MODULE keyword
    and should appear on a line by itself. The first blank line after the
    keyword will terminate the code block.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
     BOOT:
     # The following message will be printed when the
     # bootstrap function executes.
     printf(&quot;Hello from the bootstrap!\n&quot;);
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="The__s-1VERSIONCHECK:_s0_Keyword"><a class="permalink" href="#The__s-1VERSIONCHECK:_s0_Keyword">The
  VERSIONCHECK: Keyword</a></h2>
The VERSIONCHECK: keyword corresponds to <b>xsubpp</b>'s
  <span class="Li">&quot;-versioncheck&quot;</span> and
  <span class="Li">&quot;-noversioncheck&quot;</span> options. This keyword
  overrides the command line options. Version checking is enabled by default.
  When version checking is enabled the XS module will attempt to verify that its
  version matches the version of the PM module.
<p class="Pp">To enable version checking:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    VERSIONCHECK: ENABLE
</pre>
<p class="Pp">To disable version checking:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    VERSIONCHECK: DISABLE
</pre>
<p class="Pp">Note that if the version of the PM module is an NV (a floating
    point number), it will be stringified with a possible loss of precision
    (currently chopping to nine decimal places) so that it may not match the
    version of the XS module anymore. Quoting the
    <span class="Li">$VERSION</span> declaration to make it a string is
    recommended if long version numbers are used.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="The__s-1PROTOTYPES:_s0_Keyword"><a class="permalink" href="#The__s-1PROTOTYPES:_s0_Keyword">The
  PROTOTYPES: Keyword</a></h2>
The PROTOTYPES: keyword corresponds to <b>xsubpp</b>'s
  <span class="Li">&quot;-prototypes&quot;</span> and
  <span class="Li">&quot;-noprototypes&quot;</span> options. This keyword
  overrides the command line options. Prototypes are disabled by default. When
  prototypes are enabled, XSUBs will be given Perl prototypes. This keyword may
  be used multiple times in an XS module to enable and disable prototypes for
  different parts of the module. Note that <b>xsubpp</b> will nag you if you
  don't explicitly enable or disable prototypes, with:
<p class="Pp"><span class="Li"></span></p>
<pre>
    Please specify prototyping behavior for Foo.xs (see perlxs manual)
</pre>
<p class="Pp">To enable prototypes:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    PROTOTYPES: ENABLE
</pre>
<p class="Pp">To disable prototypes:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    PROTOTYPES: DISABLE
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="The__s-1PROTOTYPE:_s0_Keyword"><a class="permalink" href="#The__s-1PROTOTYPE:_s0_Keyword">The
  PROTOTYPE: Keyword</a></h2>
This keyword is similar to the PROTOTYPES: keyword above but can be used to
  force <b>xsubpp</b> to use a specific prototype for the XSUB. This keyword
  overrides all other prototype options and keywords but affects only the
  current XSUB. Consult &quot;Prototypes&quot; in perlsub for information about
  Perl prototypes.
<p class="Pp"><span class="Li"></span></p>
<pre>
    bool_t
    rpcb_gettime(timep, ...)
          time_t timep = NO_INIT
        PROTOTYPE: $;$
        PREINIT:
          char *host = &quot;localhost&quot;;
        CODE:
                  if( items &gt; 1 )
                       host = (char *)SvPV_nolen(ST(1));
                  RETVAL = rpcb_gettime( host, &amp;timep );
        OUTPUT:
          timep
          RETVAL
</pre>
<p class="Pp">If the prototypes are enabled, you can disable it locally for a
    given XSUB as in the following example:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    void
    rpcb_gettime_noproto()
        PROTOTYPE: DISABLE
    ...
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="The__s-1ALIAS:_s0_Keyword"><a class="permalink" href="#The__s-1ALIAS:_s0_Keyword">The
  ALIAS: Keyword</a></h2>
The ALIAS: keyword allows an XSUB to have two or more unique Perl names and to
  know which of those names was used when it was invoked. The Perl names may be
  fully-qualified with package names. Each alias is given an index. The compiler
  will setup a variable called <span class="Li">&quot;ix&quot;</span> which
  contain the index of the alias which was used. When the XSUB is called with
  its declared name <span class="Li">&quot;ix&quot;</span> will be 0.
<p class="Pp">The following example will create aliases
    <span class="Li">&quot;FOO::gettime()&quot;</span> and
    <span class="Li">&quot;BAR::getit()&quot;</span> for this function.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    bool_t
    rpcb_gettime(host,timep)
          char *host
          time_t &amp;timep
        ALIAS:
            FOO::gettime = 1
            BAR::getit = 2
        INIT:
          printf(&quot;# ix = %d\n&quot;, ix );
        OUTPUT:
          timep
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="The__s-1OVERLOAD:_s0_Keyword"><a class="permalink" href="#The__s-1OVERLOAD:_s0_Keyword">The
  OVERLOAD: Keyword</a></h2>
Instead of writing an overloaded interface using pure Perl, you can also use the
  OVERLOAD keyword to define additional Perl names for your functions (like the
  ALIAS: keyword above). However, the overloaded functions must be defined in
  such a way as to accept the number of parameters supplied by perl's overload
  system. For most overload methods, it will be three parameters; for the
  <span class="Li">&quot;nomethod&quot;</span> function it will be four.
  However, the bitwise operators <span class="Li">&quot;&amp;&quot;</span>,
  <span class="Li">&quot;|&quot;</span>, <span class="Li">&quot;^&quot;</span>,
  and <span class="Li">&quot;~&quot;</span> may be called with three <i>or</i>
  five arguments (see overload).
<p class="Pp">If any function has the OVERLOAD: keyword, several additional
    lines will be defined in the c file generated by xsubpp in order to register
    with the overload magic.</p>
<p class="Pp">Since blessed objects are actually stored as RV's, it is useful to
    use the typemap features to preprocess parameters and extract the actual SV
    stored within the blessed RV. See the sample for T_PTROBJ_SPECIAL below.</p>
<p class="Pp">To use the OVERLOAD: keyword, create an XS function which takes
    three input parameters (or use the C-style '...' definition) like this:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    SV *
    cmp (lobj, robj, swap)
    My_Module_obj    lobj
    My_Module_obj    robj
    IV               swap
    OVERLOAD: cmp &lt;=&gt;
    { /* function defined here */}
</pre>
<p class="Pp">In this case, the function will overload both of the three way
    comparison operators. For all overload operations using non-alpha
    characters, you must type the parameter without quoting, separating multiple
    overloads with whitespace. Note that &quot;&quot; (the stringify overload)
    should be entered as \&quot;\&quot; (i.e. escaped).</p>
<p class="Pp">Since, as mentioned above, bitwise operators may take extra
    arguments, you may want to use something like <span class="Li">&quot;(lobj,
    robj, swap, ...)&quot;</span> (with literal
    <span class="Li">&quot;...&quot;</span>) as your parameter list.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="The__s-1FALLBACK:_s0_Keyword"><a class="permalink" href="#The__s-1FALLBACK:_s0_Keyword">The
  FALLBACK: Keyword</a></h2>
In addition to the OVERLOAD keyword, if you need to control how Perl
  autogenerates missing overloaded operators, you can set the FALLBACK keyword
  in the module header section, like this:
<p class="Pp"><span class="Li"></span></p>
<pre>
    MODULE = RPC  PACKAGE = RPC

    FALLBACK: TRUE
    ...
</pre>
<p class="Pp">where FALLBACK can take any of the three values TRUE, FALSE, or
    UNDEF. If you do not set any FALLBACK value when using OVERLOAD, it defaults
    to UNDEF. FALLBACK is not used except when one or more functions using
    OVERLOAD have been defined. Please see &quot;fallback&quot; in overload for
    more details.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="The__s-1INTERFACE:_s0_Keyword"><a class="permalink" href="#The__s-1INTERFACE:_s0_Keyword">The
  INTERFACE: Keyword</a></h2>
This keyword declares the current XSUB as a keeper of the given calling
  signature. If some text follows this keyword, it is considered as a list of
  functions which have this signature, and should be attached to the current
  XSUB.
<p class="Pp">For example, if you have 4 C functions <b>multiply()</b>,
    <b>divide()</b>, <b>add()</b>, <b>subtract()</b> all having the
  signature:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    symbolic f(symbolic, symbolic);
</pre>
<p class="Pp">you can make them all to use the same XSUB using this:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    symbolic
    interface_s_ss(arg1, arg2)
        symbolic        arg1
        symbolic        arg2
    INTERFACE:
        multiply divide
        add subtract
</pre>
<p class="Pp">(This is the complete XSUB code for 4 Perl functions!) Four
    generated Perl function share names with corresponding C functions.</p>
<p class="Pp">The advantage of this approach comparing to ALIAS: keyword is that
    there is no need to code a switch statement, each Perl function (which
    shares the same XSUB) knows which C function it should call. Additionally,
    one can attach an extra function <b>remainder()</b> at runtime by using</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    CV *mycv = newXSproto(&quot;Symbolic::remainder&quot;,
                          XS_Symbolic_interface_s_ss, __FILE__, &quot;$$&quot;);
    XSINTERFACE_FUNC_SET(mycv, remainder);
</pre>
<p class="Pp">say, from another XSUB. (This example supposes that there was no
    INTERFACE_MACRO: section, otherwise one needs to use something else instead
    of <span class="Li">&quot;XSINTERFACE_FUNC_SET&quot;</span>, see the next
    section.)</p>
</section>
<section class="Ss">
<h2 class="Ss" id="The__s-1INTERFACE_MACRO:_s0_Keyword"><a class="permalink" href="#The__s-1INTERFACE_MACRO:_s0_Keyword">The
  INTERFACE_MACRO: Keyword</a></h2>
This keyword allows one to define an INTERFACE using a different way to extract
  a function pointer from an XSUB. The text which follows this keyword should
  give the name of macros which would extract/set a function pointer. The
  extractor macro is given return type, <span class="Li">&quot;CV*&quot;</span>,
  and <span class="Li">&quot;XSANY.any_dptr&quot;</span> for this
  <span class="Li">&quot;CV*&quot;</span>. The setter macro is given cv, and the
  function pointer.
<p class="Pp">The default value is
    <span class="Li">&quot;XSINTERFACE_FUNC&quot;</span> and
    <span class="Li">&quot;XSINTERFACE_FUNC_SET&quot;</span>. An INTERFACE
    keyword with an empty list of functions can be omitted if INTERFACE_MACRO
    keyword is used.</p>
<p class="Pp">Suppose that in the previous example functions pointers for
    <b>multiply()</b>, <b>divide()</b>, <b>add()</b>, <b>subtract()</b> are kept
    in a global C array <span class="Li">&quot;fp[]&quot;</span> with offsets
    being <span class="Li">&quot;multiply_off&quot;</span>,
    <span class="Li">&quot;divide_off&quot;</span>,
    <span class="Li">&quot;add_off&quot;</span>,
    <span class="Li">&quot;subtract_off&quot;</span>. Then one can use</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    #define XSINTERFACE_FUNC_BYOFFSET(ret,cv,f) \
        ((XSINTERFACE_CVT_ANON(ret))fp[CvXSUBANY(cv).any_i32])
    #define XSINTERFACE_FUNC_BYOFFSET_set(cv,f) \
        CvXSUBANY(cv).any_i32 = CAT2( f, _off )
</pre>
<p class="Pp">in C section,</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    symbolic
    interface_s_ss(arg1, arg2)
        symbolic        arg1
        symbolic        arg2
      INTERFACE_MACRO:
        XSINTERFACE_FUNC_BYOFFSET
        XSINTERFACE_FUNC_BYOFFSET_set
      INTERFACE:
        multiply divide
        add subtract
</pre>
<p class="Pp">in XSUB section.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="The__s-1INCLUDE:_s0_Keyword"><a class="permalink" href="#The__s-1INCLUDE:_s0_Keyword">The
  INCLUDE: Keyword</a></h2>
This keyword can be used to pull other files into the XS module. The other files
  may have XS code. INCLUDE: can also be used to run a command to generate the
  XS code to be pulled into the module.
<p class="Pp">The file <i>Rpcb1.xsh</i> contains our
    <span class="Li">&quot;rpcb_gettime()&quot;</span> function:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    bool_t
    rpcb_gettime(host,timep)
          char *host
          time_t &amp;timep
        OUTPUT:
          timep
</pre>
<p class="Pp">The XS module can use INCLUDE: to pull that file into it.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    INCLUDE: Rpcb1.xsh
</pre>
<p class="Pp">If the parameters to the INCLUDE: keyword are followed by a pipe
    (<span class="Li">&quot;|&quot;</span>) then the compiler will interpret the
    parameters as a command. This feature is mildly deprecated in favour of the
    <span class="Li">&quot;INCLUDE_COMMAND:&quot;</span> directive, as
    documented below.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    INCLUDE: cat Rpcb1.xsh |
</pre>
<p class="Pp">Do not use this to run perl: <span class="Li">&quot;INCLUDE: perl
    |&quot;</span> will run the perl that happens to be the first in your path
    and not necessarily the same perl that is used to run
    <span class="Li">&quot;xsubpp&quot;</span>. See &quot;The INCLUDE_COMMAND:
    Keyword&quot;.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="The__s-1INCLUDE_COMMAND:_s0_Keyword"><a class="permalink" href="#The__s-1INCLUDE_COMMAND:_s0_Keyword">The
  INCLUDE_COMMAND: Keyword</a></h2>
Runs the supplied command and includes its output into the current XS document.
  <span class="Li">&quot;INCLUDE_COMMAND&quot;</span> assigns special meaning to
  the <span class="Li">$^X</span> token in that it runs the same perl
  interpreter that is running <span class="Li">&quot;xsubpp&quot;</span>:
<p class="Pp"><span class="Li"></span></p>
<pre>
    INCLUDE_COMMAND: cat Rpcb1.xsh

    INCLUDE_COMMAND: $^X -e ...
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="The__s-1CASE:_s0_Keyword"><a class="permalink" href="#The__s-1CASE:_s0_Keyword">The
  CASE: Keyword</a></h2>
The CASE: keyword allows an XSUB to have multiple distinct parts with each part
  acting as a virtual XSUB. CASE: is greedy and if it is used then all other XS
  keywords must be contained within a CASE:. This means nothing may precede the
  first CASE: in the XSUB and anything following the last CASE: is included in
  that case.
<p class="Pp">A CASE: might switch via a parameter of the XSUB, via the
    <span class="Li">&quot;ix&quot;</span> ALIAS: variable (see &quot;The ALIAS:
    Keyword&quot;), or maybe via the <span class="Li">&quot;items&quot;</span>
    variable (see &quot;Variable-length Parameter Lists&quot;). The last CASE:
    becomes the <b>default</b> case if it is not associated with a conditional.
    The following example shows CASE switched via
    <span class="Li">&quot;ix&quot;</span> with a function
    <span class="Li">&quot;rpcb_gettime()&quot;</span> having an alias
    <span class="Li">&quot;x_gettime()&quot;</span>. When the function is called
    as <span class="Li">&quot;rpcb_gettime()&quot;</span> its parameters are the
    usual <span class="Li">&quot;(char *host, time_t *timep)&quot;</span>, but
    when the function is called as
    <span class="Li">&quot;x_gettime()&quot;</span> its parameters are reversed,
    <span class="Li">&quot;(time_t *timep, char *host)&quot;</span>.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    long
    rpcb_gettime(a,b)
      CASE: ix == 1
        ALIAS:
          x_gettime = 1
        INPUT:
          # 'a' is timep, 'b' is host
          char *b
          time_t a = NO_INIT
        CODE:
               RETVAL = rpcb_gettime( b, &amp;a );
        OUTPUT:
          a
          RETVAL
      CASE:
          # 'a' is host, 'b' is timep
          char *a
          time_t &amp;b = NO_INIT
        OUTPUT:
          b
          RETVAL
</pre>
<p class="Pp">That function can be called with either of the following
    statements. Note the different argument lists.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
        $status = rpcb_gettime( $host, $timep );

        $status = x_gettime( $timep, $host );
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="The__s-1EXPORT_XSUB_SYMBOLS:_s0_Keyword"><a class="permalink" href="#The__s-1EXPORT_XSUB_SYMBOLS:_s0_Keyword">The
  EXPORT_XSUB_SYMBOLS: Keyword</a></h2>
The EXPORT_XSUB_SYMBOLS: keyword is likely something you will never need. In
  perl versions earlier than 5.16.0, this keyword does nothing. Starting with
  5.16, XSUB symbols are no longer exported by default. That is, they are
  <span class="Li">&quot;static&quot;</span> functions. If you include
<p class="Pp"><span class="Li"></span></p>
<pre>
  EXPORT_XSUB_SYMBOLS: ENABLE
</pre>
<p class="Pp">in your XS code, the XSUBs following this line will not be
    declared <span class="Li">&quot;static&quot;</span>. You can later disable
    this with</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  EXPORT_XSUB_SYMBOLS: DISABLE
</pre>
<p class="Pp">which, again, is the default that you should probably never
    change. You cannot use this keyword on versions of perl before 5.16 to make
    XSUBs <span class="Li">&quot;static&quot;</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="The_&amp;_Unary_Operator"><a class="permalink" href="#The_&amp;_Unary_Operator">The
  &amp; Unary Operator</a></h2>
The <span class="Li">&quot;&amp;&quot;</span> unary operator in the INPUT:
  section is used to tell <b>xsubpp</b> that it should convert a Perl value
  to/from C using the C type to the left of
  <span class="Li">&quot;&amp;&quot;</span>, but provide a pointer to this value
  when the C function is called.
<p class="Pp">This is useful to avoid a CODE: block for a C function which takes
    a parameter by reference. Typically, the parameter should be not a pointer
    type (an <span class="Li">&quot;int&quot;</span> or
    <span class="Li">&quot;long&quot;</span> but not an
    <span class="Li">&quot;int*&quot;</span> or
    <span class="Li">&quot;long*&quot;</span>).</p>
<p class="Pp">The following XSUB will generate incorrect C code. The
    <b>xsubpp</b> compiler will turn this into code which calls
    <span class="Li">&quot;rpcb_gettime()&quot;</span> with parameters
    <span class="Li">&quot;(char</span> <span class="Li">*host, time_t
    timep)&quot;</span>, but the real
    <span class="Li">&quot;rpcb_gettime()&quot;</span> wants the
    <span class="Li">&quot;timep&quot;</span> parameter to be of type
    <span class="Li">&quot;time_t*&quot;</span> rather than
    <span class="Li">&quot;time_t&quot;</span>.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    bool_t
    rpcb_gettime(host,timep)
          char *host
          time_t timep
        OUTPUT:
          timep
</pre>
<p class="Pp">That problem is corrected by using the
    <span class="Li">&quot;&amp;&quot;</span> operator. The <b>xsubpp</b>
    compiler will now turn this into code which calls
    <span class="Li">&quot;rpcb_gettime()&quot;</span> correctly with parameters
    <span class="Li">&quot;(char *host, time_t *timep)&quot;</span>. It does
    this by carrying the <span class="Li">&quot;&amp;&quot;</span> through, so
    the function call looks like <span class="Li">&quot;rpcb_gettime(host,
    &amp;timep)&quot;</span>.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    bool_t
    rpcb_gettime(host,timep)
          char *host
          time_t &amp;timep
        OUTPUT:
          timep
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Inserting__s-1POD,_s0_Comments_and_C_Preprocessor_Directives"><a class="permalink" href="#Inserting__s-1POD,_s0_Comments_and_C_Preprocessor_Directives">Inserting
  POD, Comments and C Preprocessor Directives</a></h2>
C preprocessor directives are allowed within BOOT:, PREINIT: INIT:, CODE:,
  PPCODE:, POSTCALL:, and CLEANUP: blocks, as well as outside the functions.
  Comments are allowed anywhere after the MODULE keyword. The compiler will pass
  the preprocessor directives through untouched and will remove the commented
  lines. POD documentation is allowed at any point, both in the C and XS
  language sections. POD must be terminated with a
  <span class="Li">&quot;=cut&quot;</span> command;
  <span class="Li">&quot;xsubpp&quot;</span> will exit with an error if it does
  not. It is very unlikely that human generated C code will be mistaken for POD,
  as most indenting styles result in whitespace in front of any line starting
  with <span class="Li">&quot;=&quot;</span>. Machine generated XS files may
  fall into this trap unless care is taken to ensure that a space breaks the
  sequence &quot;\n=&quot;.
<p class="Pp">Comments can be added to XSUBs by placing a
    <span class="Li">&quot;#&quot;</span> as the first non-whitespace of a line.
    Care should be taken to avoid making the comment look like a C preprocessor
    directive, lest it be interpreted as such. The simplest way to prevent this
    is to put whitespace in front of the
  <span class="Li">&quot;#&quot;</span>.</p>
<p class="Pp">If you use preprocessor directives to choose one of two versions
    of a function, use</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    #if ... version1
    #else /* ... version2  */
    #endif
</pre>
<p class="Pp">and not</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    #if ... version1
    #endif
    #if ... version2
    #endif
</pre>
<p class="Pp">because otherwise <b>xsubpp</b> will believe that you made a
    duplicate definition of the function. Also, put a blank line before the
    #else/#endif so it will not be seen as part of the function body.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Using__s-1XS_s0_With_C_v'-.1v'_h'-1p'_s-2+_h'-1p'+_s0_v'.1v'_h'-1p'"><a class="permalink" href="#Using__s-1XS_s0_With_C_v'-.1v'_h'-1p'_s-2+_h'-1p'+_s0_v'.1v'_h'-1p'">Using
  XS With C++</a></h2>
If an XSUB name contains <span class="Li">&quot;::&quot;</span>, it is
  considered to be a C++ method. The generated Perl function will assume that
  its first argument is an object pointer. The object pointer will be stored in
  a variable called THIS. The object should have been created by C++ with the
  <b>new()</b> function and should be blessed by Perl with the
  <b>sv_setref_pv()</b> macro. The blessing of the object by Perl can be handled
  by a typemap. An example typemap is shown at the end of this section.
<p class="Pp">If the return type of the XSUB includes
    <span class="Li">&quot;static&quot;</span>, the method is considered to be a
    static method. It will call the C++ function using the
    <b>class::method()</b> syntax. If the method is not static the function will
    be called using the THIS-&gt;<b>method()</b> syntax.</p>
<p class="Pp">The next examples will use the following C++ class.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
     class color {
          public:
          color();
          ~color();
          int blue();
          void set_blue( int );

          private:
          int c_blue;
     };
</pre>
<p class="Pp">The XSUBs for the <b>blue()</b> and <b>set_blue()</b> methods are
    defined with the class name but the parameter for the object (THIS, or
    &quot;self&quot;) is implicit and is not listed.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
     int
     color::blue()

     void
     color::set_blue( val )
          int val
</pre>
<p class="Pp">Both Perl functions will expect an object as the first parameter.
    In the generated C++ code the object is called
    <span class="Li">&quot;THIS&quot;</span>, and the method call will be
    performed on this object. So in the C++ code the <b>blue()</b> and
    <b>set_blue()</b> methods will be called as this:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
     RETVAL = THIS-&gt;blue();

     THIS-&gt;set_blue( val );
</pre>
<p class="Pp">You could also write a single get/set method using an optional
    argument:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
     int
     color::blue( val = NO_INIT )
         int val
         PROTOTYPE $;$
         CODE:
             if (items &gt; 1)
                 THIS-&gt;set_blue( val );
             RETVAL = THIS-&gt;blue();
         OUTPUT:
             RETVAL
</pre>
<p class="Pp">If the function's name is <b>DESTROY</b> then the C++
    <span class="Li">&quot;delete&quot;</span> function will be called and
    <span class="Li">&quot;THIS&quot;</span> will be given as its parameter. The
    generated C++ code for</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
     void
     color::DESTROY()
</pre>
<p class="Pp">will look like this:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
     color *THIS = ...;  // Initialized as in typemap

     delete THIS;
</pre>
<p class="Pp">If the function's name is <b>new</b> then the C++
    <span class="Li">&quot;new&quot;</span> function will be called to create a
    dynamic C++ object. The XSUB will expect the class name, which will be kept
    in a variable called <span class="Li">&quot;CLASS&quot;</span>, to be given
    as the first argument.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
     color *
     color::new()
</pre>
<p class="Pp">The generated C++ code will call
    <span class="Li">&quot;new&quot;</span>.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
     RETVAL = new color();
</pre>
<p class="Pp">The following is an example of a typemap that could be used for
    this C++ example.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    TYPEMAP
    color *  O_OBJECT

    OUTPUT
    # The Perl object is blessed into 'CLASS', which should be a
    # char* having the name of the package for the blessing.
    O_OBJECT
        sv_setref_pv( $arg, CLASS, (void*)$var );

    INPUT
    O_OBJECT
        if( sv_isobject($arg) &amp;&amp; (SvTYPE(SvRV($arg)) == SVt_PVMG) )
            $var = ($type)SvIV((SV*)SvRV( $arg ));
        else{
            warn(&quot;${Package}::$func_name() -- &quot; .
                &quot;$var is not a blessed SV reference&quot;);
            XSRETURN_UNDEF;
        }
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Interface_Strategy"><a class="permalink" href="#Interface_Strategy">Interface
  Strategy</a></h2>
When designing an interface between Perl and a C library a straight translation
  from C to XS (such as created by <span class="Li">&quot;h2xs -x&quot;</span>)
  is often sufficient. However, sometimes the interface will look very C-like
  and occasionally nonintuitive, especially when the C function modifies one of
  its parameters, or returns failure inband (as in &quot;negative return values
  mean failure&quot;). In cases where the programmer wishes to create a more
  Perl-like interface the following strategy may help to identify the more
  critical parts of the interface.
<p class="Pp">Identify the C functions with input/output or output parameters.
    The XSUBs for these functions may be able to return lists to Perl.</p>
<p class="Pp">Identify the C functions which use some inband info as an
    indication of failure. They may be candidates to return undef or an empty
    list in case of failure. If the failure may be detected without a call to
    the C function, you may want to use an INIT: section to report the failure.
    For failures detectable after the C function returns one may want to use a
    POSTCALL: section to process the failure. In more complicated cases use
    CODE: or PPCODE: sections.</p>
<p class="Pp">If many functions use the same failure indication based on the
    return value, you may want to create a special typedef to handle this
    situation. Put</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  typedef int negative_is_failure;
</pre>
<p class="Pp">near the beginning of XS file, and create an OUTPUT typemap entry
    for <span class="Li">&quot;negative_is_failure&quot;</span> which converts
    negative values to <span class="Li">&quot;undef&quot;</span>, or maybe
    <b>croak()</b>s. After this the return value of type
    <span class="Li">&quot;negative_is_failure&quot;</span> will create more
    Perl-like interface.</p>
<p class="Pp">Identify which values are used by only the C and XSUB functions
    themselves, say, when a parameter to a function should be a contents of a
    global variable. If Perl does not need to access the contents of the value
    then it may not be necessary to provide a translation for that value from C
    to Perl.</p>
<p class="Pp">Identify the pointers in the C function parameter lists and return
    values. Some pointers may be used to implement input/output or output
    parameters, they can be handled in XS with the
    <span class="Li">&quot;&amp;&quot;</span> unary operator, and, possibly,
    using the NO_INIT keyword. Some others will require handling of types like
    <span class="Li">&quot;int *&quot;</span>, and one needs to decide what a
    useful Perl translation will do in such a case. When the semantic is clear,
    it is advisable to put the translation into a typemap file.</p>
<p class="Pp">Identify the structures used by the C functions. In many cases it
    may be helpful to use the T_PTROBJ typemap for these structures so they can
    be manipulated by Perl as blessed objects. (This is handled automatically by
    <span class="Li">&quot;h2xs -x&quot;</span>.)</p>
<p class="Pp">If the same C type is used in several different contexts which
    require different translations, <span class="Li">&quot;typedef&quot;</span>
    several new types mapped to this C type, and create separate <i>typemap</i>
    entries for these new types. Use these types in declarations of return type
    and parameters to XSUBs.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Perl_Objects_And_C_Structures"><a class="permalink" href="#Perl_Objects_And_C_Structures">Perl
  Objects And C Structures</a></h2>
When dealing with C structures one should select either <b>T_PTROBJ</b> or
  <b>T_PTRREF</b> for the XS type. Both types are designed to handle pointers to
  complex objects. The T_PTRREF type will allow the Perl object to be unblessed
  while the T_PTROBJ type requires that the object be blessed. By using T_PTROBJ
  one can achieve a form of type-checking because the XSUB will attempt to
  verify that the Perl object is of the expected type.
<p class="Pp">The following XS code shows the <b>getnetconfigent()</b> function
    which is used with ONC+ TIRPC. The <b>getnetconfigent()</b> function will
    return a pointer to a C structure and has the C prototype shown below. The
    example will demonstrate how the C pointer will become a Perl reference.
    Perl will consider this reference to be a pointer to a blessed object and
    will attempt to call a destructor for the object. A destructor will be
    provided in the XS source to free the memory used by
    <b>getnetconfigent()</b>. Destructors in XS can be created by specifying an
    XSUB function whose name ends with the word <b>DESTROY</b>. XS destructors
    can be used to free memory which may have been malloc'd by another XSUB.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
     struct netconfig *getnetconfigent(const char *netid);
</pre>
<p class="Pp">A <span class="Li">&quot;typedef&quot;</span> will be created for
    <span class="Li">&quot;struct netconfig&quot;</span>. The Perl object will
    be blessed in a class matching the name of the C type, with the tag
    <span class="Li">&quot;Ptr&quot;</span> appended, and the name should not
    have embedded spaces if it will be a Perl package name. The destructor will
    be placed in a class corresponding to the class of the object and the PREFIX
    keyword will be used to trim the name to the word DESTROY as Perl will
    expect.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
     typedef struct netconfig Netconfig;

     MODULE = RPC  PACKAGE = RPC

     Netconfig *
     getnetconfigent(netid)
          char *netid

     MODULE = RPC  PACKAGE = NetconfigPtr  PREFIX = rpcb_

     void
     rpcb_DESTROY(netconf)
          Netconfig *netconf
        CODE:
          printf(&quot;Now in NetconfigPtr::DESTROY\n&quot;);
          free( netconf );
</pre>
<p class="Pp">This example requires the following typemap entry. Consult
    perlxstypemap for more information about adding new typemaps for an
    extension.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
     TYPEMAP
     Netconfig *  T_PTROBJ
</pre>
<p class="Pp">This example will be used with the following Perl statements.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
     use RPC;
     $netconf = getnetconfigent(&quot;udp&quot;);
</pre>
<p class="Pp">When Perl destroys the object referenced by
    <span class="Li">$netconf</span> it will send the object to the supplied
    XSUB DESTROY function. Perl cannot determine, and does not care, that this
    object is a C struct and not a Perl object. In this sense, there is no
    difference between the object created by the <b>getnetconfigent()</b> XSUB
    and an object created by a normal Perl subroutine.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Safely_Storing_Static_Data_in__s-1XS_s0"><a class="permalink" href="#Safely_Storing_Static_Data_in__s-1XS_s0">Safely
  Storing Static Data in XS</a></h2>
Starting with Perl 5.8, a macro framework has been defined to allow static data
  to be safely stored in XS modules that will be accessed from a multi-threaded
  Perl.
<p class="Pp">Although primarily designed for use with multi-threaded Perl, the
    macros have been designed so that they will work with non-threaded Perl as
    well.</p>
<p class="Pp">It is therefore strongly recommended that these macros be used by
    all XS modules that make use of static data.</p>
<p class="Pp">The easiest way to get a template set of macros to use is by
    specifying the <span class="Li">&quot;-g&quot;</span>
    (<span class="Li">&quot;--global&quot;</span>) option with h2xs (see
  h2xs).</p>
<p class="Pp">Below is an example module that makes use of the macros.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    #define PERL_NO_GET_CONTEXT
    #include &quot;EXTERN.h&quot;
    #include &quot;perl.h&quot;
    #include &quot;XSUB.h&quot;

    /* Global Data */

    #define MY_CXT_KEY &quot;BlindMice::_guts&quot; XS_VERSION

    typedef struct {
        int count;
        char name[3][100];
    } my_cxt_t;

    START_MY_CXT

    MODULE = BlindMice           PACKAGE = BlindMice

    BOOT:
    {
        MY_CXT_INIT;
        MY_CXT.count = 0;
        strcpy(MY_CXT.name[0], &quot;None&quot;);
        strcpy(MY_CXT.name[1], &quot;None&quot;);
        strcpy(MY_CXT.name[2], &quot;None&quot;);
    }

    int
    newMouse(char * name)
        PREINIT:
          dMY_CXT;
        CODE:
          if (MY_CXT.count &gt;= 3) {
              warn(&quot;Already have 3 blind mice&quot;);
              RETVAL = 0;
          }
          else {
              RETVAL = ++ MY_CXT.count;
              strcpy(MY_CXT.name[MY_CXT.count - 1], name);
          }
        OUTPUT:
          RETVAL

    char *
    get_mouse_name(index)
          int index
        PREINIT:
          dMY_CXT;
        CODE:
          if (index &gt; MY_CXT.count)
            croak(&quot;There are only 3 blind mice.&quot;);
          else
            RETVAL = MY_CXT.name[index - 1];
        OUTPUT:
          RETVAL

    void
    CLONE(...)
        CODE:
          MY_CXT_CLONE;
</pre>
<p class="Pp"><i>MY_CXT REFERENCE</i></p>
<dl class="Bl-tag">
  <dt>MY_CXT_KEY</dt>
  <dd>This macro is used to define a unique key to refer to the static data for
      an XS module. The suggested naming scheme, as used by h2xs, is to use a
      string that consists of the module name, the string &quot;::_guts&quot;
      and the module version number.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    #define MY_CXT_KEY &quot;MyModule::_guts&quot; XS_VERSION
    </pre>
  </dd>
  <dt>typedef my_cxt_t</dt>
  <dd>This struct typedef <i>must</i> always be called
      <span class="Li">&quot;my_cxt_t&quot;</span>. The other
      <span class="Li">&quot;CXT*&quot;</span> macros assume the existence of
      the <span class="Li">&quot;my_cxt_t&quot;</span> typedef name.
    <p class="Pp">Declare a typedef named
        <span class="Li">&quot;my_cxt_t&quot;</span> that is a structure that
        contains all the data that needs to be interpreter-local.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    typedef struct {
        int some_value;
    } my_cxt_t;
    </pre>
  </dd>
  <dt>START_MY_CXT</dt>
  <dd>Always place the START_MY_CXT macro directly after the declaration of
      <span class="Li">&quot;my_cxt_t&quot;</span>.</dd>
  <dt>MY_CXT_INIT</dt>
  <dd>The MY_CXT_INIT macro initializes storage for the
      <span class="Li">&quot;my_cxt_t&quot;</span> struct.
    <p class="Pp">It <i>must</i> be called exactly once, typically in a BOOT:
        section. If you are maintaining multiple interpreters, it should be
        called once in each interpreter instance, except for interpreters cloned
        from existing ones. (But see &quot;MY_CXT_CLONE&quot; below.)</p>
  </dd>
  <dt>dMY_CXT</dt>
  <dd>Use the dMY_CXT macro (a declaration) in all the functions that access
      MY_CXT.</dd>
  <dt>MY_CXT</dt>
  <dd>Use the MY_CXT macro to access members of the
      <span class="Li">&quot;my_cxt_t&quot;</span> struct. For example, if
      <span class="Li">&quot;my_cxt_t&quot;</span> is
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    typedef struct {
        int index;
    } my_cxt_t;
    </pre>
    <p class="Pp">then use this to access the
        <span class="Li">&quot;index&quot;</span> member</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    dMY_CXT;
    MY_CXT.index = 2;
    </pre>
  </dd>
  <dt>aMY_CXT/pMY_CXT</dt>
  <dd><span class="Li">&quot;dMY_CXT&quot;</span> may be quite expensive to
      calculate, and to avoid the overhead of invoking it in each function it is
      possible to pass the declaration onto other functions using the
      <span class="Li">&quot;aMY_CXT&quot;</span>/<span class="Li">&quot;pMY_CXT&quot;</span>
      macros, eg
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    void sub1() {
        dMY_CXT;
        MY_CXT.index = 1;
        sub2(aMY_CXT);
    }

    void sub2(pMY_CXT) {
        MY_CXT.index = 2;
    }
    </pre>
    <p class="Pp">Analogously to <span class="Li">&quot;pTHX&quot;</span>, there
        are equivalent forms for when the macro is the first or last in multiple
        arguments, where an underscore represents a comma, i.e.
        <span class="Li">&quot;_aMY_CXT&quot;</span>,
        <span class="Li">&quot;aMY_CXT_&quot;</span>,
        <span class="Li">&quot;_pMY_CXT&quot;</span> and
        <span class="Li">&quot;pMY_CXT_&quot;</span>.</p>
  </dd>
  <dt>MY_CXT_CLONE</dt>
  <dd>By default, when a new interpreter is created as a copy of an existing one
      (eg via <span class="Li">&quot;threads-&gt;create()&quot;</span>), both
      interpreters share the same physical my_cxt_t structure. Calling
      <span class="Li">&quot;MY_CXT_CLONE&quot;</span> (typically via the
      package's <span class="Li">&quot;CLONE()&quot;</span> function), causes a
      byte-for-byte copy of the structure to be taken, and any future dMY_CXT
      will cause the copy to be accessed instead.</dd>
  <dt>MY_CXT_INIT_INTERP(my_perl)</dt>
  <dd></dd>
  <dt>dMY_CXT_INTERP(my_perl)</dt>
  <dd>These are versions of the macros which take an explicit interpreter as an
      argument.</dd>
</dl>
<p class="Pp">Note that these macros will only work together within the
    <i>same</i> source file; that is, a dMY_CTX in one source file will access a
    different structure than a dMY_CTX in another source file.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Thread-aware_system_interfaces"><a class="permalink" href="#Thread-aware_system_interfaces">Thread-aware
  system interfaces</a></h2>
Starting from Perl 5.8, in C/C++ level Perl knows how to wrap system/library
  interfaces that have thread-aware versions (e.g. <b>getpwent_r()</b>) into
  frontend macros (e.g. <b>getpwent()</b>) that correctly handle the
  multithreaded interaction with the Perl interpreter. This will happen
  transparently, the only thing you need to do is to instantiate a Perl
  interpreter.
<p class="Pp">This wrapping happens always when compiling Perl core source
    (PERL_CORE is defined) or the Perl core extensions (PERL_EXT is defined).
    When compiling XS code outside of the Perl core, the wrapping does not take
    place before Perl 5.28. Starting in that release you can</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
 #define PERL_REENTRANT
</pre>
<p class="Pp">in your code to enable the wrapping. It is advisable to do so if
    you are using such functions, as intermixing the
    <span class="Li">&quot;_r&quot;</span>-forms (as Perl compiled for
    multithreaded operation will do) and the
    <span class="Li">&quot;_r&quot;</span>-less forms is neither well-defined
    (inconsistent results, data corruption, or even crashes become more likely),
    nor is it very portable. Unfortunately, not all systems have all the
    <span class="Li">&quot;_r&quot;</span> forms, but using this
    <span class="Li">&quot;#define&quot;</span> gives you whatever protection
    that Perl is aware is available on each system.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="EXAMPLES"><a class="permalink" href="#EXAMPLES">EXAMPLES</a></h1>
File <span class="Li">&quot;RPC.xs&quot;</span>: Interface to some ONC+ RPC bind
  library functions.
<p class="Pp"><span class="Li"></span></p>
<pre>
     #define PERL_NO_GET_CONTEXT
     #include &quot;EXTERN.h&quot;
     #include &quot;perl.h&quot;
     #include &quot;XSUB.h&quot;

     #include &lt;rpc/rpc.h&gt;

     typedef struct netconfig Netconfig;

     MODULE = RPC  PACKAGE = RPC

     SV *
     rpcb_gettime(host=&quot;localhost&quot;)
          char *host
        PREINIT:
          time_t  timep;
        CODE:
          ST(0) = sv_newmortal();
          if( rpcb_gettime( host, &amp;timep ) )
               sv_setnv( ST(0), (double)timep );

     Netconfig *
     getnetconfigent(netid=&quot;udp&quot;)
          char *netid

     MODULE = RPC  PACKAGE = NetconfigPtr  PREFIX = rpcb_

     void
     rpcb_DESTROY(netconf)
          Netconfig *netconf
        CODE:
          printf(&quot;NetconfigPtr::DESTROY\n&quot;);
          free( netconf );
</pre>
<p class="Pp">File <span class="Li">&quot;typemap&quot;</span>: Custom typemap
    for RPC.xs. (cf. perlxstypemap)</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
     TYPEMAP
     Netconfig *  T_PTROBJ
</pre>
<p class="Pp">File <span class="Li">&quot;RPC.pm&quot;</span>: Perl module for
    the RPC extension.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
     package RPC;

     require Exporter;
     require DynaLoader;
     @ISA = qw(Exporter DynaLoader);
     @EXPORT = qw(rpcb_gettime getnetconfigent);

     bootstrap RPC;
     1;
</pre>
<p class="Pp">File <span class="Li">&quot;rpctest.pl&quot;</span>: Perl test
    program for the RPC extension.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
     use RPC;

     $netconf = getnetconfigent();
     $a = rpcb_gettime();
     print &quot;time = $a\n&quot;;
     print &quot;netconf = $netconf\n&quot;;

     $netconf = getnetconfigent(&quot;tcp&quot;);
     $a = rpcb_gettime(&quot;poplar&quot;);
     print &quot;time = $a\n&quot;;
     print &quot;netconf = $netconf\n&quot;;
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="CAVEATS"><a class="permalink" href="#CAVEATS">CAVEATS</a></h1>
XS code has full access to system calls including C library functions. It thus
  has the capability of interfering with things that the Perl core or other
  modules have set up, such as signal handlers or file handles. It could mess
  with the memory, or any number of harmful things. Don't.
<p class="Pp">Some modules have an event loop, waiting for user-input. It is
    highly unlikely that two such modules would work adequately together in a
    single Perl application.</p>
<p class="Pp">In general, the perl interpreter views itself as the center of the
    universe as far as the Perl program goes. XS code is viewed as a help-mate,
    to accomplish things that perl doesn't do, or doesn't do fast enough, but
    always subservient to perl. The closer XS code adheres to this model, the
    less likely conflicts will occur.</p>
<p class="Pp">One area where there has been conflict is in regards to C locales.
    (See perllocale.) perl, with one exception and unless told otherwise, sets
    up the underlying locale the program is running in to the locale passed into
    it from the environment. This is an important difference from a generic C
    language program, where the underlying locale is the &quot;C&quot; locale
    unless the program changes it. As of v5.20, this underlying locale is
    completely hidden from pure Perl code outside the lexical scope of
    <span class="Li">&quot;use&#x00A0;locale&quot;</span> except for a couple of
    function calls in the POSIX module which of necessity use it. But the
    underlying locale, with that one exception is exposed to XS code, affecting
    all C library routines whose behavior is locale-dependent. Your XS code
    better not assume that the underlying locale is &quot;C&quot;. The exception
    is the <span class="Li">&quot;LC_NUMERIC&quot;</span> locale category, and
    the reason it is an exception is that experience has shown that it can be
    problematic for XS code, whereas we have not had reports of problems with
    the other locale categories. And the reason for this one category being
    problematic is that the character used as a decimal point can vary. Many
    European languages use a comma, whereas English, and hence Perl are
    expecting a dot (U+002E: FULL STOP). Many modules can handle only the radix
    character being a dot, and so perl attempts to make it so. Up through Perl
    v5.20, the attempt was merely to set
    <span class="Li">&quot;LC_NUMERIC&quot;</span> upon startup to the
    <span class="Li">&quot;C&quot;</span> locale. Any <b>setlocale()</b>
    otherwise would change it; this caused some failures. Therefore, starting in
    v5.22, perl tries to keep <span class="Li">&quot;LC_NUMERIC&quot;</span>
    always set to <span class="Li">&quot;C&quot;</span> for XS code.</p>
<p class="Pp">To summarize, here's what to expect and how to handle locales in
    XS code:</p>
<dl class="Bl-tag">
  <dt>Non-locale-aware XS code</dt>
  <dd>Keep in mind that even if you think your code is not locale-aware, it may
      call a library function that is. Hopefully the man page for such a
      function will indicate that dependency, but the documentation is
      imperfect.
    <p class="Pp">The current locale is exposed to XS code except possibly
        <span class="Li">&quot;LC_NUMERIC&quot;</span> (explained in the next
        paragraph). There have not been reports of problems with the other
        categories. Perl initializes things on start-up so that the current
        locale is the one which is indicated by the user's environment in effect
        at that time. See &quot;ENVIRONMENT&quot; in perllocale.</p>
    <p class="Pp">However, up through v5.20, Perl initialized things on start-up
        so that <span class="Li">&quot;LC_NUMERIC&quot;</span> was set to the
        &quot;C&quot; locale. But if any code anywhere changed it, it would stay
        changed. This means that your module can't count on
        <span class="Li">&quot;LC_NUMERIC&quot;</span> being something in
        particular, and you can't expect floating point numbers (including
        version strings) to have dots in them. If you don't allow for a non-dot,
        your code could break if anyone anywhere changed the locale. For this
        reason, v5.22 changed the behavior so that Perl tries to keep
        <span class="Li">&quot;LC_NUMERIC&quot;</span> in the &quot;C&quot;
        locale except around the operations internally where it should be
        something else. Misbehaving XS code will always be able to change the
        locale anyway, but the most common instance of this is checked for and
        handled.</p>
  </dd>
  <dt>Locale-aware XS code</dt>
  <dd>If the locale from the user's environment is desired, there should be no
      need for XS code to set the locale except for
      <span class="Li">&quot;LC_NUMERIC&quot;</span>, as perl has already set
      the others up. XS code should avoid changing the locale, as it can
      adversely affect other, unrelated, code and may not be thread-safe. To
      minimize problems, the macros &quot;STORE_LC_NUMERIC_SET_TO_NEEDED&quot;
      in perlapi, &quot;STORE_LC_NUMERIC_FORCE_TO_UNDERLYING&quot; in perlapi,
      and &quot;RESTORE_LC_NUMERIC&quot; in perlapi should be used to affect any
      needed change.
    <p class="Pp">But, starting with Perl v5.28, locales are thread-safe on
        platforms that support this functionality. Windows has this starting
        with Visual Studio 2005. Many other modern platforms support the
        thread-safe POSIX 2008 functions. The C
        <span class="Li">&quot;#define&quot;</span>
        <span class="Li">&quot;USE_THREAD_SAFE_LOCALE&quot;</span> will be
        defined iff this build is using these. From Perl-space, the read-only
        variable <span class="Li">&quot;${SAFE_LOCALES}&quot;</span> is 1 if
        either the build is not threaded, or if
        <span class="Li">&quot;USE_THREAD_SAFE_LOCALE&quot;</span> is defined;
        otherwise it is 0.</p>
    <p class="Pp">The way this works under-the-hood is that every thread has a
        choice of using a locale specific to it (this is the Windows and POSIX
        2008 functionality), or the global locale that is accessible to all
        threads (this is the functionality that has always been there). The
        implementations for Windows and POSIX are completely different. On
        Windows, the runtime can be set up so that the standard
        <span class="Li">setlocale(3)</span> function either only knows about
        the global locale or the locale for this thread. On POSIX,
        <span class="Li">&quot;setlocale&quot;</span> always deals with the
        global locale, and other functions have been created to handle
        per-thread locales. Perl makes this transparent to perl-space code. It
        continues to use <span class="Li">&quot;POSIX::setlocale()&quot;</span>,
        and the interpreter translates that into the per-thread functions.</p>
    <p class="Pp">All other locale-senstive functions automatically use the
        per-thread locale, if that is turned on, and failing that, the global
        locale. Thus calls to <span class="Li">&quot;setlocale&quot;</span> are
        ineffective on POSIX systems for the current thread if that thread is
        using a per-thread locale. If perl is compiled for single-thread
        operation, it does not use the per-thread functions, so
        <span class="Li">&quot;setlocale&quot;</span> does work as expected.</p>
    <p class="Pp">If you have loaded the
        <span class="Li">&quot;POSIX&quot;</span> module you can use the methods
        given in perlcall to call
        <span class="Li">&quot;POSIX::setlocale&quot;</span> to safely change or
        query the locale (on systems where it is safe to do so), or you can use
        the new 5.28 function &quot;Perl_setlocale&quot; in perlapi instead,
        which is a drop-in replacement for the system
        <span class="Li">setlocale(3)</span>, and handles single-threaded and
        multi-threaded applications transparently.</p>
    <p class="Pp">There are some locale-related library calls that still aren't
        thread-safe because they return data in a buffer global to all threads.
        In the past, these didn't matter as locales weren't thread-safe at all.
        But now you have to be aware of them in case your module is called in a
        multi-threaded application. The known ones are</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
 asctime()
 ctime()
 gcvt() [POSIX.1-2001 only (function removed in POSIX.1-2008)]
 getdate()
 wcrtomb() if its final argument is NULL
 wcsrtombs() if its final argument is NULL
 wcstombs()
 wctomb()
    </pre>
    <p class="Pp">Some of these shouldn't really be called in a Perl
        application, and for others there are thread-safe versions of these
        already implemented:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
 asctime_r()
 ctime_r()
 Perl_langinfo()
    </pre>
    <p class="Pp">The <span class="Li">&quot;_r&quot;</span> forms are
        automatically used, starting in Perl 5.28, if you compile your code,
        with</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
 #define PERL_REENTRANT
    </pre>
    <p class="Pp">See also &quot;Perl_langinfo&quot; in perlapi. You can use the
        methods given in perlcall, to get the best available locale-safe
        versions of these</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
 POSIX::localeconv()
 POSIX::wcstombs()
 POSIX::wctomb()
    </pre>
    <p class="Pp">And note, that some items returned by
        <span class="Li">&quot;Localeconv&quot;</span> are available through
        &quot;Perl_langinfo&quot; in perlapi.</p>
    <p class="Pp">The others shouldn't be used in a threaded application.</p>
    <p class="Pp">Some modules may call a non-perl library that is locale-aware.
        This is fine as long as it doesn't try to query or change the locale
        using the system <span class="Li">&quot;setlocale&quot;</span>. But if
        these do call the system <span class="Li">&quot;setlocale&quot;</span>,
        those calls may be ineffective. Instead,
        <span class="Li">&quot;Perl_setlocale&quot;</span> works in all
        circumstances. Plain setlocale is ineffective on multi-threaded POSIX
        2008 systems. It operates only on the global locale, whereas each thread
        has its own locale, paying no attention to the global one. Since
        converting these non-Perl libraries to
        <span class="Li">&quot;Perl_setlocale&quot;</span> is out of the
        question, there is a new function in v5.28
        <span class="Li">&quot;switch_to_global_locale&quot;</span> that will
        switch the thread it is called from so that any system
        <span class="Li">&quot;setlocale&quot;</span> calls will have their
        desired effect. The function
        <span class="Li">&quot;sync_locale&quot;</span> must be called before
        returning to perl.</p>
    <p class="Pp">This thread can change the locale all it wants and it won't
        affect any other thread, except any that also have been switched to the
        global locale. This means that a multi-threaded application can have a
        single thread using an alien library without a problem; but no more than
        a single thread can be so-occupied. Bad results likely will happen.</p>
    <p class="Pp">In perls without multi-thread locale support, some alien
        libraries, such as <span class="Li">&quot;Gtk&quot;</span> change
        locales. This can cause problems for the Perl core and other modules.
        For these, before control is returned to perl, starting in v5.20.1,
        calling the function <b>sync_locale()</b> from XS should be sufficient
        to avoid most of these problems. Prior to this, you need a pure Perl
        statement that does this:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
 POSIX::setlocale(LC_ALL, POSIX::setlocale(LC_ALL));
    </pre>
    <p class="Pp">or use the methods given in perlcall.</p>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="XS_VERSION"><a class="permalink" href="#XS_VERSION">XS
  VERSION</a></h1>
This document covers features supported by
  <span class="Li">&quot;ExtUtils::ParseXS&quot;</span> (also known as
  <span class="Li">&quot;xsubpp&quot;</span>) 3.13_01.
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
Originally written by Dean Roehrich &lt;<i>roehrich@cray.com</i>&gt;.
<p class="Pp">Maintained since 1996 by The Perl Porters
    &lt;<i>perlbug@perl.org</i>&gt;.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2019-10-24</td>
    <td class="foot-os">perl v5.30.2</td>
  </tr>
</table>
</body>
</html>
