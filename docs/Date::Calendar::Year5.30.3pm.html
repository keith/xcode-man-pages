<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    .Nd, .Bf, .Op { display: inline; }
    .Pa, .Ad { font-style: italic; }
    .Ms { font-weight: bold; }
    .Bl-diag > dt { font-weight: bold; }
    code.Nm, .Fl, .Cm, .Ic, code.In, .Fd, .Fn, .Cd { font-weight: bold;
      font-family: inherit; }
  </style>
  <title>Date::Calendar::Year(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Date::Calendar::Year(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Date::Calendar::Year(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Date::Calendar::Year - Implements embedded &quot;year&quot;
    objects for Date::Calendar</p>
</section>
<section class="Sh">
<h1 class="Sh" id="MOTTO"><a class="permalink" href="#MOTTO">MOTTO</a></h1>
<p class="Pp">There is more than one way to do it - this is just one of
  them!</p>
</section>
<section class="Sh">
<h1 class="Sh" id="PREFACE"><a class="permalink" href="#PREFACE">PREFACE</a></h1>
<p class="Pp">Note that Date::Calendar::Year (and Date::Calendar) can only deal
    with years lying within the range [1583..2299].</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>  use Date::Calendar::Year qw( check_year empty_period );
  use Date::Calendar::Year qw( :all ); # same as above
  check_year(YEAR|DATE); # dies if year &lt; 1583 or year &gt; 2299
  empty_period();        # warns about empty interval if $^W is set
  $index = $year-&gt;date2index(YEAR,MONTH,DAY|DATE);
  $date  = $year-&gt;index2date(INDEX);
  use Date::Calendar::Profiles qw( $Profiles );
  $year_2000_US_FL = Date::Calendar::Year-&gt;new( 2000, $Profiles-&gt;{'US-FL'} [,LANG[,WEEKEND]] );
  $year_2001_DE_NW = Date::Calendar::Year-&gt;new( 2001, $Profiles-&gt;{'DE-NW'} [,LANG[,WEEKEND]] );
  $year = Date::Calendar::Year-&gt;new( 2001, {} );
  $year-&gt;init( 2002, $Profiles-&gt;{'DE-SN'} [,LANG[,WEEKEND]] );
  $vector = $year-&gt;vec_full(); # vector of full holidays
  $vector = $year-&gt;vec_half(); # vector of half holidays
  $vector = $year-&gt;vec_work(); # NOT a vector of workdays but a workspace!
  $size   = $year-&gt;val_days(); # number of days in that year, size of vectors
  $base   = $year-&gt;val_base(); # number of days for [year,1,1] since [1,1,1]
  $number = $year-&gt;val_year(); # the year's number itself
  $number = $year-&gt;year();     # alias for val_year()
  @names    = $year-&gt;labels(YEAR,MONTH,DAY|DATE);
  @holidays = $year-&gt;labels();
  $holidays = $year-&gt;labels();
  @dates    = $year-&gt;search(PATTERN);
  $dates    = $year-&gt;search(PATTERN);
  $hashref  = $year-&gt;tags(YEAR,MONTH,DAY|DATE);
  $hashref  = $year-&gt;tags(INDEX);
  $days     = $year-&gt;delta_workdays(YEAR,MONTH1,DAY1|DATE1
                                   ,YEAR,MONTH2,DAY2|DATE2
                                   ,FLAG1,FLAG2);
  ($date,$rest,$sign) = $year-&gt;add_delta_workdays(YEAR,MONTH,DAY|DATE
                                                 ,DELTA,SIGN);
  $flag     = $year-&gt;is_full(YEAR,MONTH,DAY|DATE);
  $flag     = $year-&gt;is_half(YEAR,MONTH,DAY|DATE);
  $flag     = $year-&gt;is_work(YEAR,MONTH,DAY|DATE);
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="INTERFACE"><a class="permalink" href="#INTERFACE">INTERFACE</a></h1>
<p class="Pp">Note that whenever a year number, a date, a time or a combined
    date and time are expected as input parameters by one of the methods of this
    class, you can always pass a Date::Calc[::Object] date object or an array
    reference (of an array of appropriate length) instead!</p>
<p class="Pp">See <b>Date::Calc::Object</b>(3) for more details.</p>
<p class="Pp">So instead of calling a given method like this:</p>
<p class="Pp"></p>
<pre>  $object-&gt;method1( $year,$month,$day );
  $object-&gt;method2( $year1,$month1,$day1, $year2,$month2,$day2 );
  $object-&gt;method3( $year1, $year2, $year3 );
</pre>
<p class="Pp">You can also call it like so:</p>
<p class="Pp"></p>
<pre>  $object-&gt;method1( $date );
  $object-&gt;method1( [1964,1,3] );
  $object-&gt;method2( $year1,$month1,$day1, $date2 );
  $object-&gt;method2( $date1, $year2,$month2,$day2 );
  $object-&gt;method2( $date1, $date2 );
  $object-&gt;method2( $year1,$month1,$day1, [2001,3,17] );
  $object-&gt;method2( [1964,1,3], $year2,$month2,$day2 );
  $object-&gt;method2( [1964,1,3], [2001,3,17] );
  $object-&gt;method2( $date1, [2001,3,17] );
  $object-&gt;method2( [1964,1,3], $date2 );
  $object-&gt;method3( $year1, $date2, [2001,3,17] );
</pre>
<p class="Pp">And similarly if a time or a combined date and time are
  expected.</p>
<p class="Pp">If you substitute an expected year number by an anonymous array
    (this is the recommended way of writing date constants, for increased
    readability of your programs), it must contain three values, nevertheless
    (otherwise the use of an anonymous array would be pointless).</p>
<p class="Pp">Don't confuse year numbers and their substitutes (a date object or
    an array reference) with Date::Calendar::Year objects, which are a totally
    different thing!</p>
<p class="Pp">But incidentally <span class="Li">&quot;:-)&quot;</span>, you may
    also pass a Date::Calendar::Year object whenever a year number is expected.
    However, and perhaps against your expectations at times, only the year
    number from that object will be used, not the year object itself (the year
    object in question might be using the wrong profile!).</p>
<p class="Pp">Moreover, whenever a method of this class returns a date, it does
    so by returning a Date::Calc[::Object] date object.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="IMPLEMENTATION"><a class="permalink" href="#IMPLEMENTATION">IMPLEMENTATION</a></h1>
<p class="Pp">Each Date::Calendar::Year object consists mainly of three bit
    vectors, plus some administrative attributes, all stored in a (blessed)
    hash.</p>
<p class="Pp">All three bit vectors contain as many bits as there are days in
    the corresponding year, i.e., either 365 or 366.</p>
<p class="Pp">The first bit vector, called &quot;FULL&quot;, contains set bits
    for Saturdays, Sundays and all &quot;full&quot; legal holidays (i.e., days
    off, on which you usually do not work).</p>
<p class="Pp">The second bit vector, called &quot;HALF&quot;, contains set bits
    for all &quot;half&quot; holidays, i.e., holidays where you get only half a
    day off from work.</p>
<p class="Pp">The third and last bit vector, called &quot;WORK&quot;, is used as
    a workspace, in which various calculations are performed throughout this
    module.</p>
<p class="Pp">Its name does <b>NOT</b> come from &quot;working days&quot; (as
    you might think), but from &quot;workspace&quot;.</p>
<p class="Pp">It only so happens that it is used to calculate the working days
    sometimes, at some places in this module.</p>
<p class="Pp">But you are free to use it yourself, for whatever calculation you
    would like to carry out yourself.</p>
<p class="Pp">The two other bit vectors, &quot;FULL&quot; and &quot;HALF&quot;,
    should never be changed, unless you know <b>EXACTLY</b> what you're
  doing!</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">Functions</p>
<ul class="Bl-bullet">
  <li><span class="Li">&quot;check_year(YEAR);&quot;</span>
    <p class="Pp">This function checks that the given year lies in the permitted
        range [1583..2299]. It returns nothing in case of success, and throws an
        exception (&quot;given year out of range [1583..2299]&quot;)
      otherwise.</p>
  </li>
  <li><span class="Li">&quot;empty_period();&quot;</span>
    <p class="Pp">This function issues a warning (from the perspective of the
        caller of a Date::* module) that the given range of dates is empty
        (&quot;dates interval is empty&quot;), provided that warnings are
        enabled (i.e., &quot;<span class="Li">$^W</span>&quot; is true).</p>
    <p class="Pp">This function is currently used by the method
        &quot;<b>delta_workdays()</b>&quot; in this class, and by its equivalent
        from the Date::Calendar module.</p>
    <p class="Pp">It is called whenever the range of dates of which the
        difference in working days is to be calculated is empty. This can happen
        for instance if you specify two adjacent dates both of which are not to
        be included in the difference.</p>
  </li>
</ul>
<p class="Pp">Methods</p>
<ul class="Bl-bullet">
  <li><span class="Li">&quot;$index =
      $year-&gt;date2index(YEAR,MONTH,DAY|DATE);&quot;</span>
    <p class="Pp">This method converts a given date into the number of the day
        in that year (this is sometimes also referred to as the
        &quot;julian&quot; date), i.e., a number between 0 (for January 1st) and
        the number of days in the given year minus one, i.e., 364 or 365 (for
        December 31st).</p>
    <p class="Pp">You may need this in order to access the bit vectors returned
        by the methods &quot;<b>vec_full()</b>&quot;,
        &quot;<b>vec_half()</b>&quot; and &quot;<b>vec_work()</b>&quot;.</p>
    <p class="Pp">Note that there are shorthand methods in this module called
        &quot;<b>is_full()</b>&quot;, &quot;<b>is_half()</b>&quot; and
        &quot;<b>is_work()</b>&quot;, which serve to test individual bits of the
        three bit vectors which are a part of each Date::Calendar::Year
      object.</p>
    <p class="Pp">An exception (&quot;given year != object's year&quot;) is
        thrown if the year associated with the year object itself and the year
        from the given date do not match.</p>
    <p class="Pp">An exception (&quot;invalid date&quot;) is also thrown if the
        given arguments do not constitute a valid date, or (&quot;given year out
        of range [1583..2299]&quot;) if the given year lies outside of the
        permitted range.</p>
  </li>
  <li><span class="Li">&quot;$date = $year-&gt;index2date(INDEX);&quot;</span>
    <p class="Pp">This method converts an index (or &quot;julian date&quot;) for
        the given year back into a date.</p>
    <p class="Pp">An exception (&quot;invalid index&quot;) is thrown if the
        given index is outside of the permitted range for the given year, i.e.,
        <span class="Li">&quot;[0..364]&quot;</span> or
        <span class="Li">&quot;[0..365]&quot;</span>.</p>
    <p class="Pp">Note that this method returns a Date::Calc <b>OBJECT</b>!</p>
  </li>
  <li><span class="Li">&quot;$year_2000_US_FL = Date::Calendar::Year-&gt;new(
      2000, $Profiles-&gt;{'US-FL'} [,LANG[,WEEKEND]] );&quot;</span>
    <p class="Pp"><span class="Li">&quot;$year_2001_DE_NW =
        Date::Calendar::Year-&gt;new( 2001, $Profiles-&gt;{'DE-NW'}
        [,LANG[,WEEKEND]] );&quot;</span></p>
    <p class="Pp"><span class="Li">&quot;$year = Date::Calendar::Year-&gt;new(
        2001, {} );&quot;</span></p>
    <p class="Pp">This is the constructor method. Call it to create a new
        Date::Calendar::Year object.</p>
    <p class="Pp">The first argument must be a year number in the range
        [1583..2299].</p>
    <p class="Pp">The second argument must be the reference of a hash, which
        usually contains names of holidays and commemorative days as keys and
        strings containing the date or formula for each holiday as values.</p>
    <p class="Pp">Reading this hash and initializing the object's internal data
        is performed by an extra method, called &quot;<b>init()</b>&quot;, which
        is called internally by the constructor method, and which is described
        immediately below, after this method.</p>
    <p class="Pp">In case you want to call the &quot;<b>init()</b>&quot; method
        yourself, explicitly, after creating the object, you can pass an empty
        profile (e.g., just an empty anonymous hash) to the
        &quot;<b>new()</b>&quot; method, in order to create an empty object, and
        also to improve performance.</p>
    <p class="Pp">The third argument is optional, and must consist of the valid
        name or number of a language as provided by the <b>Date::Calc</b>(3)
        module, if given.</p>
    <p class="Pp">This argument determines which language shall be used when
        reading the profile, since the profile may contain names of months and
        weekdays in its formulas in that language.</p>
    <p class="Pp">The default is English if no value or no valid value is
        specified (and if the global default has not been changed with
        &quot;<b>Language()</b>&quot;).</p>
    <p class="Pp">After the third argument, a list of day numbers which will
        constitute the &quot;weekend&quot; can optionally be specified, where
        1=Monday, 2=Tuesday, 3=Wednesday, 4=Thursday, 5=Friday, 6=Saturday and
        7=Sunday.</p>
    <p class="Pp">If no values are given, 6 and 7 (Saturday and Sunday) are
        automatically taken as default.</p>
    <p class="Pp">If values outside of the range <span class="Li">1..7</span>
        are given, they will be ignored.</p>
    <p class="Pp">This can be used to switch off this feature and to have no
        regularly recurring holidays at all when for instance a zero is
      given.</p>
  </li>
  <li><span class="Li">&quot;$year-&gt;init( 2002, $Profiles-&gt;{'DE-SN'}
      [,LANG[,WEEKEND]] );&quot;</span>
    <p class="Pp">This method is called by the &quot;<b>new()</b>&quot;
        constructor method, internally, and has the same arguments as the
        latter.</p>
    <p class="Pp">See immediately above for a description of these
      arguments.</p>
    <p class="Pp">Note that you can also call this method explicitly yourself,
        if needed, and you can of course subclass the Date::Calendar::Year class
        and override the &quot;<b>init()</b>&quot; method with a method of your
        own.</p>
    <p class="Pp">The holiday scheme or &quot;profile&quot; (i.e., the reference
        of a hash passed as the second argument to this method) must obey the
        following semantics and syntax:</p>
    <p class="Pp">The keys are the names of the holiday or commemorative day in
        question. Keys must be unique (but see further below).</p>
    <p class="Pp">The difference between a holiday and a commemorative day is
        that you (usually) get a day off on a holiday, whereas on a purely
        commemorative day, you don't.</p>
    <p class="Pp">A commemorative day is just a date with a name, nothing
      more.</p>
    <p class="Pp">The values belonging to these keys can either be the code
        reference of a callback function (see <b>Date::Calendar::Profiles</b>(3)
        for more details and examples), or a string.</p>
    <p class="Pp">All other values cause a fatal error with program
      abortion.</p>
    <p class="Pp">The strings can specify three types of dates:</p>
    <p class="Pp"></p>
    <pre>  -  fixed dates
     (like New Year, or first of January),
  -  dates relative to Easter Sunday
     (like Ascension = Easter Sunday + 39 days), and
  -  the 1st, 2nd, 3rd, 4th or last
     of a given day of week in a given month
     (like &quot;the 4th Thursday of November&quot;, or Thanksgiving).
    </pre>
    <p class="Pp">All other types of dates must be specified via callback
        functions.</p>
    <p class="Pp">Note that the &quot;last&quot; of a given day of week is
        written as the &quot;5th&quot;, because the last is always either the
        5th or the 4th of the given day of week. So the
        &quot;<b>init()</b>&quot; module first calculates the 5th of the
        requested day of week, and if that doesn't exist, takes the 4th
      instead.</p>
    <p class="Pp">There are also two modifier characters which may prefix the
        string with the date formula, &quot;#&quot; and &quot;:&quot;.</p>
    <p class="Pp">The character &quot;#&quot; (mnemonic: it's only a comment)
        signals that the date in question is a purely commemorative day, i.e.,
        it will not enter into any date calculations, but can be queried with
        the &quot;<b>labels()</b>&quot; and &quot;<b>search()</b>&quot; methods,
        and appears when printing a calendar, for instance.</p>
    <p class="Pp">The character &quot;:&quot; (mnemonic: divided into two
        halves) specifies that the date in question is only a &quot;half&quot;
        holiday, i.e., you only get half a day off instead of a full day. Some
        companies have this sort of thing.
        <span class="Li">&quot;:-)&quot;</span></p>
    <p class="Pp">The exact syntax for the date formula strings is the following
        (by example):</p>
    <p class="Pp"></p>
    <pre> -  Fixed dates:
    &quot;Christmas&quot;  =&gt;  &quot;24.12&quot;,   # European format (day, month)
    &quot;Christmas&quot;  =&gt;  &quot;24.12.&quot;,
    &quot;Christmas&quot;  =&gt;  &quot;24Dec&quot;,
    &quot;Christmas&quot;  =&gt;  &quot;24.Dec&quot;,
    &quot;Christmas&quot;  =&gt;  &quot;24Dec.&quot;,
    &quot;Christmas&quot;  =&gt;  &quot;24.Dec.&quot;,
    &quot;Christmas&quot;  =&gt;  &quot;24-12&quot;,
    &quot;Christmas&quot;  =&gt;  &quot;24-12-&quot;,
    &quot;Christmas&quot;  =&gt;  &quot;24-Dec&quot;,
    &quot;Christmas&quot;  =&gt;  &quot;24-Dec-&quot;,
    &quot;Christmas&quot;  =&gt;  &quot;12/25&quot;,   # American format (month, day)
    &quot;Christmas&quot;  =&gt;  &quot;Dec25&quot;,
    &quot;Christmas&quot;  =&gt;  &quot;Dec/25&quot;,
 -  Dates relative to Easter Sunday:
    &quot;Ladies' Carnival&quot;  =&gt;  &quot;-52&quot;,
    &quot;Carnival Monday&quot;   =&gt;  &quot;-48&quot;,
    &quot;Mardi Gras&quot;        =&gt;  &quot;-47&quot;,
    &quot;Ash Wednesday&quot;     =&gt;  &quot;-46&quot;,
    &quot;Palm Sunday&quot;       =&gt;   &quot;-7&quot;,
    &quot;Maundy Thursday&quot;   =&gt;   &quot;-3&quot;,
    &quot;Good Friday&quot;       =&gt;   &quot;-2&quot;,
    &quot;Easter Sunday&quot;     =&gt;   &quot;+0&quot;,
    &quot;Easter Monday&quot;     =&gt;   &quot;+1&quot;,
    &quot;Ascension&quot;         =&gt;  &quot;+39&quot;,
    &quot;Whitsunday&quot;        =&gt;  &quot;+49&quot;,
    &quot;Whitmonday&quot;        =&gt;  &quot;+50&quot;,
    &quot;Corpus Christi&quot;    =&gt;  &quot;+60&quot;,
 -  The 1st, 2nd, 3rd, 4th or last day of week:
    &quot;Thanksgiving&quot;      =&gt;  &quot;4Thu11&quot;,
    &quot;Thanksgiving&quot;      =&gt;  &quot;4/Thu/Nov&quot;,
    &quot;Columbus Day&quot;      =&gt;  &quot;2/Mon/Oct&quot;,
    &quot;Columbus Day&quot;      =&gt;  &quot;2/Mon/10&quot;,
    &quot;Columbus Day&quot;      =&gt;  &quot;2/1/Oct&quot;,
    &quot;Columbus Day&quot;      =&gt;  &quot;2/1/10&quot;,
    &quot;Memorial Day&quot;      =&gt;  &quot;5/Mon/May&quot;, # LAST Monday of May
    </pre>
    <p class="Pp">Remember that each of these date formula strings may also be
        prefixed with either &quot;#&quot; or &quot;:&quot;:</p>
    <p class="Pp"></p>
    <pre>    &quot;Christmas&quot;         =&gt;  &quot;:24.12.&quot;, # only half a day off
    &quot;Valentine's Day&quot;   =&gt;  &quot;#Feb/14&quot;, # not an official holiday
    </pre>
    <p class="Pp">Note that the name of the month or day of week may have any
        length you like, it just must specify the intended month or day of week
        unambiguously. So &quot;D&quot;, &quot;De&quot;, &quot;Dec&quot;,
        &quot;Dece&quot;, &quot;Decem&quot;, &quot;Decemb&quot;,
        &quot;Decembe&quot; and &quot;December&quot; would all be valid, for
        example. Note also that case is ignored.</p>
    <p class="Pp">When specifying day and month numbers, or offsets relative to
        Easter Sunday, leading zeros are permitted (for nicely indented
        formatting, for instance) but ignored.</p>
    <p class="Pp">Leading zeros are not permitted in front of the ordinal number
        [1..5] or the number of the day of week [1..7] when specifying the nth
        day of week in a month.</p>
    <p class="Pp"><b>BEWARE</b> that if keys are not unique in the source code,
        later entries will overwrite previous ones! I.e.,</p>
    <p class="Pp"></p>
    <pre>    ...
    &quot;My special holiday&quot; =&gt; &quot;01-11&quot;,
    &quot;My special holiday&quot; =&gt; &quot;02-11&quot;,
    ...
    </pre>
    <p class="Pp">will <b>NOT</b> set two holidays of the same name, one on
        November first, the other on November second, but only one, on November
        second!</p>
    <p class="Pp">Therefore, in order to use sets of defaults and to be able to
        override some of them, you must <b>FIRST</b> include any hash containing
        the default definitions, and <b>THEN</b> write down your own definitions
        (see also the Date::Calendar::Profiles module for examples of this!),
        like this:</p>
    <p class="Pp"></p>
    <pre>    $defaults =
    {
        &quot;Holiday #1&quot; =&gt; &quot;01-01&quot;,
        &quot;Holiday #2&quot; =&gt; &quot;02-02&quot;,
        &quot;Holiday #3&quot; =&gt; &quot;03-03&quot;
    };
    $variant1 =
    {
        %$defaults,
        &quot;Holiday #2&quot; =&gt; &quot;09-02&quot;,
        &quot;Holiday #4&quot; =&gt; &quot;04-04&quot;
    };
    </pre>
    <p class="Pp">This is because of the way hashes work in Perl.</p>
    <p class="Pp">The &quot;<b>init()</b>&quot; method proceeds as follows:</p>
    <p class="Pp">First it checks whether the given year number lies in the
        range [1583..2299]. A fatal error occurs if not.</p>
    <p class="Pp">Then it determines the number of days in the requested year,
        and stores it in the given Date::Calendar::Year object.</p>
    <p class="Pp">It then calls the <b>Bit::Vector</b>(3) module to allocate
        three bit vectors with a number of bits equal to the number of days in
        the requested year, and stores the three object references (of the bit
        vectors) in the Date::Calendar::Year object.</p>
    <p class="Pp">(See also the description of the three methods
        &quot;<b>vec_full()</b>&quot;, &quot;<b>vec_half()</b>&quot; and
        &quot;<b>vec_full()</b>&quot; immediately below.)</p>
    <p class="Pp">It then sets the bits which correspond to Saturdays and
        Sundays (or optionally to the days whose numbers have been specified as
        the &quot;weekend&quot;) in the &quot;full holidays&quot; bit
      vector.</p>
    <p class="Pp">At last, it iterates over the keys of the given holiday scheme
        (of the hash referred to by the hash reference passed to the
        &quot;<b>init()</b>&quot; method as the second argument), evaluates the
        formula (or calls the given callback function), and sets the
        corresponding bit in the &quot;full&quot; or &quot;half&quot; holidays
        bit vector if the calculated date is valid.</p>
    <p class="Pp">A fatal error occurs if the date formula cannot be parsed or
        if the date returned by a formula or callback function is invalid (e.g.
        30-Feb-2001 or the like) or lies outside the given year (e.g.
        Easter+365).</p>
    <p class="Pp">Finally, the &quot;<b>init()</b>&quot; method makes sure that
        days marked as &quot;full&quot; holidays do not appear as
        &quot;half&quot; holidays as well.</p>
    <p class="Pp">Then the &quot;<b>init()</b>&quot; method returns.</p>
    <p class="Pp">Note that when deciphering the date formulas, the
        &quot;<b>init()</b>&quot; method uses the functions
        &quot;<b>Decode_Day_of_Week()</b>&quot; and
        &quot;<b>Decode_Month()</b>&quot; from the <b>Date::Calc</b>(3) module,
        which are language-dependent.</p>
    <p class="Pp">Therefore the &quot;<b>init()</b>&quot; method allows you to
        pass it an optional third argument, which must consist of the valid name
        or number of a language as provided by the <b>Date::Calc</b>(3)
      module.</p>
    <p class="Pp">For the time of scanning the given holiday scheme, the
        &quot;<b>init()</b>&quot; method will use the language that has been
        specified, or the global setting from &quot;<b>Language()</b>&quot; if
        no or an invalid language parameter is given.</p>
    <p class="Pp">The default is English if none is specified and if the global
        setting has not been modified.</p>
    <p class="Pp">This means that you can provide the names of months and days
        of week in your holiday profile in any of the languages supported by the
        <b>Date::Calc</b>(3) module, provided you give the
        &quot;<b>init()</b>&quot; method a clue (the third parameter) which
        language to expect.</p>
  </li>
  <li><span class="Li">&quot;$vector = $year-&gt;vec_full();&quot;</span>
    <p class="Pp">This method returns a reference to the bit vector in the given
        year object which contains all &quot;full&quot; holidays.</p>
    <p class="Pp"><b>BEWARE</b> that you should <b>NEVER</b> change the contents
        of this bit vector unless you know <b>EXACTLY</b> what you're doing!</p>
    <p class="Pp">You should usually only read from this bit vector, or use it
        as an operand in bit vector operations - but never as an lvalue.</p>
  </li>
  <li><span class="Li">&quot;$vector = $year-&gt;vec_half();&quot;</span>
    <p class="Pp">This method returns a reference to the bit vector in the given
        year object which contains all &quot;half&quot; holidays.</p>
    <p class="Pp"><b>BEWARE</b> that you should <b>NEVER</b> change the contents
        of this bit vector unless you know <b>EXACTLY</b> what you're doing!</p>
    <p class="Pp">You should usually only read from this bit vector, or use it
        as an operand in bit vector operations - but never as an lvalue.</p>
  </li>
  <li><span class="Li">&quot;$vector = $year-&gt;vec_work();&quot;</span>
    <p class="Pp">This method returns a reference to the &quot;workspace&quot;
        bit vector in the given year object.</p>
    <p class="Pp">Note that you cannot rely on the contents of this bit
      vector.</p>
    <p class="Pp">You have to set it up yourself before performing any
        calculations with it.</p>
    <p class="Pp">Currently the contents of this bit vector are modified by the
        two methods &quot;<b>delta_workdays()</b>&quot; and
        &quot;<b>add_delta_workdays()</b>&quot;, in ways which are hard to
        predict (depending on the calculations being performed).</p>
    <p class="Pp">The size of this bit vector can be determined through either
        &quot;<span class="Li">&quot;$days =
        $vector-&gt;Size();&quot;</span>&quot; or
        &quot;<span class="Li">&quot;$days =
        $year-&gt;val_days();&quot;</span>&quot;.</p>
  </li>
  <li><span class="Li">&quot;$size = $year-&gt;val_days();&quot;</span>
    <p class="Pp">This method returns the number of days in the given year
        object, i.e., either 365 or 366. This is also the size (number of bits)
        of the three bit vectors contained in the given year object.</p>
  </li>
  <li><span class="Li">&quot;$base = $year-&gt;val_base();&quot;</span>
    <p class="Pp">This method returns the value of the expression
        &quot;<span class="Li">&quot;Date_to_Days($year-&gt;val_year(),1,1)&quot;</span>&quot;,
        or in other words, the number of days between January 1st of the year 1
        and January 1st of the given year, plus one.</p>
    <p class="Pp">This value is used internally by the method
        &quot;<b>date2index()</b>&quot; in order to calculate the
        &quot;julian&quot; date or day of the year for a given date.</p>
    <p class="Pp">The expression above is computed only once in method
        &quot;<b>init()</b>&quot; and then stored in one of the year object's
        attributes, of which this method just returns the value.</p>
  </li>
  <li><span class="Li">&quot;$number = $year-&gt;val_year();&quot;</span>
    <p class="Pp"><span class="Li">&quot;$number =
        $year-&gt;year();&quot;</span></p>
    <p class="Pp">These two methods are identical, the latter being a shortcut
        of the former.</p>
    <p class="Pp">They return the number of the year for which a calendar has
        been stored in the given year object.</p>
    <p class="Pp">The method name &quot;<b>val_year()</b>&quot; is used here in
        order to be consistent with the other attribute accessor methods of this
        class, and the method &quot;<b>year()</b>&quot; is necessary in order to
        be able to pass Date::Calendar::Year objects as parameters instead of a
        year number in the methods of the Date::Calendar and
        Date::Calendar::Year modules.</p>
  </li>
  <li><span class="Li">&quot;@names =
      $year-&gt;labels(YEAR,MONTH,DAY|DATE);&quot;</span>
    <p class="Pp"><span class="Li">&quot;@holidays =
        $year-&gt;labels();&quot;</span></p>
    <p class="Pp"><span class="Li">&quot;$holidays =
        $year-&gt;labels();&quot;</span></p>
    <p class="Pp">If any arguments are given, they are supposed to represent a
        date. In that case, a list of all labels (= names of holidays)
        associated with that date are returned. The first item returned is
        always the name of the day of week for that date.</p>
    <p class="Pp">If no arguments are given, the list of all available labels in
        the given year is returned. This list does <b>NOT</b> include any names
        of the days of week (which would be pointless in this case).</p>
    <p class="Pp">In list context, the resulting list itself is returned. In
        scalar context, the number of items in the resulting list is
      returned.</p>
  </li>
  <li><span class="Li">&quot;@dates = $year-&gt;search(PATTERN);&quot;</span>
    <p class="Pp"><span class="Li">&quot;$dates =
        $year-&gt;search(PATTERN);&quot;</span></p>
    <p class="Pp">This method searches through all the labels of the given year
        and returns a list of date objects with all dates whose labels match the
        given pattern.</p>
    <p class="Pp">Note that this is a simple, case-insensitive substring search,
        <b>NOT</b> a full-fledged regular expression search!</p>
    <p class="Pp">The result is guaranteed to be sorted chronologically.</p>
    <p class="Pp">In scalar context, only the number of items in the resulting
        list is returned, instead of the resulting list itself (as in list
        context).</p>
  </li>
  <li><span class="Li">&quot;$hashref =
      $year-&gt;tags(YEAR,MONTH,DAY|DATE);&quot;</span>
    <p class="Pp"><span class="Li">&quot;$hashref =
        $year-&gt;tags(INDEX);&quot;</span></p>
    <p class="Pp">This method returns a hash reference for the given calendar
        and date (or index). The hash it refers to is a copy of the calendar
        profile's internal hash which contains the names for the given date as
        keys and 0, 1, 2, or 3 as their corresponding values meaning the
        following:</p>
    <p class="Pp"></p>
    <pre>    0    =&gt;    commemorative day
    1    =&gt;    &quot;half&quot; holiday
    2    =&gt;    &quot;full&quot; holiday
    3    =&gt;    both a &quot;half&quot; and a &quot;full&quot; holiday
    </pre>
    <p class="Pp">The value &quot;3&quot; should only occur if a date has been
        redefined by the underlying profile using the same key (i.e., the same
        name) but with a different type of holiday.</p>
    <p class="Pp">The index must be a number such as returned by the method
        &quot;<b>date2index()</b>&quot;; it can be used here instead of a date
        or a date object in order to speed up processing (= no need to calculate
        it internally).</p>
  </li>
  <li><span class="Li">&quot;$days = $year-&gt;delta_workdays(YEAR,MONTH1,DAY1,
      YEAR,MONTH2,DAY2, FLAG1,FLAG2);&quot;</span>
    <p class="Pp"><span class="Li">&quot;$days =
        $year-&gt;delta_workdays(DATE1,DATE2,FLAG1,FLAG2);&quot;</span></p>
    <p class="Pp">This method calculates the number of work days (i.e., the
        number of days, but excluding all holidays) between two dates.</p>
    <p class="Pp">In other words, this method is equivalent to the
        &quot;<b>Delta_Days()</b>&quot; function of the Date::Calc module,
        except that it disregards holidays in its counting.</p>
    <p class="Pp">The two flags indicate whether the start and end dates should
        be included in the counting (that is, of course, only in case they
        aren't holidays), or not.</p>
    <p class="Pp">It is common, for example, that you want to know how many work
        days are left between the current date and a given deadline.</p>
    <p class="Pp">Typically, you will want to count the current date but not the
        deadline's date. So you would specify &quot;true&quot; (&quot;1&quot;)
        for FLAG1 and &quot;false&quot; (&quot;0&quot;) for FLAG2 in order to
        achieve that.</p>
    <p class="Pp">In other words, a value of &quot;true&quot; means
        &quot;including this date&quot;, a value of &quot;false&quot; means
        &quot;excluding this date&quot;.</p>
    <p class="Pp">As with the &quot;<b>Delta_Days()</b>&quot; function from the
        Date::Calc module, the dates have to be given in chronological order to
        yield a positive result. If the dates are reversed, the result will be
        negative.</p>
    <p class="Pp">The parameter FLAG1 is associated with the first given date,
        the parameter FLAG2 with the second given date (regardless of whether
        the dates are in chronological order or not).</p>
    <p class="Pp">An exception (&quot;given year != object's year&quot;) is
        thrown if the year number of either of the two given dates does not
        match the year number associated with the given year object.</p>
    <p class="Pp">An exception (&quot;invalid date&quot;) is also raised if
        either of the two date arguments does not constitute a valid date.</p>
  </li>
  <li><span class="Li">&quot;($date,$rest,$sign) =
      $year-&gt;add_delta_workdays(YEAR,MONTH,DAY, DELTA, SIGN);&quot;</span>
    <p class="Pp"><span class="Li">&quot;($date,$rest,$sign) =
        $year-&gt;add_delta_workdays(DATE,DELTA,SIGN);&quot;</span></p>
    <p class="Pp">This method is the equivalent of the
        &quot;<b>Add_Delta_Days()</b>&quot; function from the Date::Calc module,
        except that it adds work days and skips holidays.</p>
    <p class="Pp">In other words, you can add or subtract a number of work days
        &quot;DELTA&quot; to/from a given date and get a new date as the result
        (as a Date::Calc object).</p>
    <p class="Pp">You add days (i.e., you go forward in time) with a positive
        offset &quot;DELTA&quot;, and you subtract days (i.e., you go backwards
        in time) with a negative offset.</p>
    <p class="Pp">Note that an exception (&quot;invalid date&quot;) is raised if
        the given date argument (the &quot;start&quot; date) does not constitute
        a valid date.</p>
    <p class="Pp">Beware that this method is limited to date calculations within
        a single year (in contrast to the method with the same name from the
        Date::Calendar module).</p>
    <p class="Pp">Therefore, the method does not only return a date (object),
        but also a &quot;rest&quot; and a &quot;sign&quot;.</p>
    <p class="Pp">The &quot;rest&quot; indicates how many days are still left
        from your original DELTA after going in the desired direction and
        reaching a year boundary.</p>
    <p class="Pp">The &quot;sign&quot; indicates in which direction (future or
        past) one needs to go in order to &quot;eat up&quot; the
        &quot;rest&quot; (by subtracting a day from the &quot;rest&quot; for
        each work day passed), or to adjust the resulting date (in order to skip
        any holidays directly after a year boundary), if at all.</p>
    <p class="Pp">The &quot;sign&quot; is -1 for going backwards in time, +1 for
        going forward, and 0 if the result doesn't need any more fixing (for
        instance because the result lies in the same year as the starting
      date).</p>
    <p class="Pp">The method &quot;<b>add_delta_workdays()</b>&quot; from the
        Date::Calendar module uses the &quot;rest&quot; and &quot;sign&quot;
        return values from this method in order to perform calculations which
        may cross year boundaries.</p>
    <p class="Pp">Therefore, it is not recommended to use this method here
        directly, as it is rather clumsy to use, but to use the method with the
        same name from the Date::Calendar module instead, which does the same
        but is much easier to use and moreover allows calculations which cross
        an arbitrary number of year boundaries.</p>
    <p class="Pp"><b>BEWARE</b> that this method may currently return unexpected
        (i.e., contradicting the above documentation) or plain wrong results
        when going back in time (this is a bug!).</p>
    <p class="Pp">However, it works correctly and as documented above when going
        forward in time.</p>
  </li>
  <li><span class="Li">&quot;$flag =
      $year-&gt;is_full(YEAR,MONTH,DAY|DATE);&quot;</span>
    <p class="Pp">This method returns &quot;true&quot; (&quot;1&quot;) if the
        bit corresponding to the given date is set in the bit vector
        representing &quot;full&quot; holidays, and &quot;false&quot;
        (&quot;0&quot;) otherwise.</p>
    <p class="Pp">I.e., the method returns &quot;true&quot; if the given date is
        a (full) holiday (according to the calendar profile associated with the
        given year object).</p>
  </li>
  <li><span class="Li">&quot;$flag =
      $year-&gt;is_half(YEAR,MONTH,DAY|DATE);&quot;</span>
    <p class="Pp">This method returns &quot;true&quot; (&quot;1&quot;) if the
        bit corresponding to the given date is set in the bit vector
        representing &quot;half&quot; holidays, and &quot;false&quot;
        (&quot;0&quot;) otherwise.</p>
    <p class="Pp">I.e., the method returns &quot;true&quot; if the given date is
        a half holiday (according to the calendar profile associated with the
        given year object).</p>
    <p class="Pp">Note that if a date is a &quot;full&quot; holiday, the
        &quot;half&quot; bit is never set, even if you try to do so in your
        calendar profile, on purpose or by accident.</p>
  </li>
  <li><span class="Li">&quot;$flag =
      $year-&gt;is_work(YEAR,MONTH,DAY|DATE);&quot;</span>
    <p class="Pp">This method returns &quot;true&quot; (&quot;1&quot;) if the
        bit corresponding to the given date is set in the bit vector used to
        perform all sorts of calculations, and &quot;false&quot; (&quot;0&quot;)
        otherwise.</p>
    <p class="Pp"><b>BEWARE</b> that the &quot;work&quot; in this method's name
        does <b>NOT</b> come from &quot;work days&quot;!</p>
    <p class="Pp">It comes from the fact that the corresponding bit vector can
        be used for any &quot;work&quot; that you need to do. In other words,
        it's a &quot;work space&quot;.</p>
    <p class="Pp">Therefore, this bit vector might contain about everything you
        could imagine - including a bit pattern which marks all &quot;work
        days&quot; with set bits, if it so happens!</p>
    <p class="Pp">But you better don't rely on it, unless you put the bit
        pattern there yourself in the first place.</p>
    <p class="Pp">Note that you can get a reference to this bit vector (in order
        to fill it with any bit pattern you like) using the method
        &quot;<b>vec_work()</b>&quot;, described further above in this
      document.</p>
    <p class="Pp">The number of bits in this bit vector is the same as the
        number of days in the given year
        &quot;<span class="Li">$year</span>&quot;, which you can retrieve
        through either &quot;<span class="Li">&quot;$days =
        $year-&gt;vec_work-&gt;Size();&quot;</span>&quot; or
        &quot;<span class="Li">&quot;$days =
        $year-&gt;val_days();&quot;</span>&quot;.</p>
    <p class="Pp">See also <b>Bit::Vector</b>(3) for more details.</p>
  </li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp"><b>Bit::Vector</b>(3), <b>Date::Calendar</b>(3),
    <b>Date::Calendar::Profiles</b>(3), <b>Date::Calc::Object</b>(3),
    <b>Date::Calc</b>(3), <b>Date::Calc::Util</b>(3).</p>
</section>
<section class="Sh">
<h1 class="Sh" id="KNOWN_BUGS"><a class="permalink" href="#KNOWN_BUGS">KNOWN
  BUGS</a></h1>
<p class="Pp">The method &quot;<b>add_delta_workdays()</b>&quot; is known to
    produce results which are sometimes off by one working day when a negative
    offset is used. As a workaround, try to add one working day first and then
    subtract one working day more than initially intended. See also the file
    &quot;examples/bug.pl&quot; for how to do this.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="VERSION"><a class="permalink" href="#VERSION">VERSION</a></h1>
<p class="Pp">This man page documents &quot;Date::Calendar::Year&quot; version
    6.4.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<pre>  Steffen Beyer
  mailto:STBEY@cpan.org
  http://www.engelschall.com/u/sb/download/
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT"><a class="permalink" href="#COPYRIGHT">COPYRIGHT</a></h1>
<p class="Pp">Copyright (c) 2000 - 2015 by Steffen Beyer. All rights
  reserved.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="LICENSE"><a class="permalink" href="#LICENSE">LICENSE</a></h1>
<p class="Pp">This package is free software; you can use, modify and
    redistribute it under the same terms as Perl itself, i.e., at your option,
    under the terms either of the &quot;Artistic License&quot; or the &quot;GNU
    General Public License&quot;.</p>
<p class="Pp">The C library at the core of the module &quot;Date::Calc::XS&quot;
    can, at your discretion, also be used, modified and redistributed under the
    terms of the &quot;GNU Library General Public License&quot;.</p>
<p class="Pp">Please refer to the files &quot;Artistic.txt&quot;,
    &quot;GNU_GPL.txt&quot; and &quot;GNU_LGPL.txt&quot; in the
    &quot;license&quot; subdirectory of this distribution for any details!</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DISCLAIMER"><a class="permalink" href="#DISCLAIMER">DISCLAIMER</a></h1>
<p class="Pp">This package is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</p>
<p class="Pp">See the &quot;GNU General Public License&quot; for more
  details.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2015-03-07</td>
    <td class="foot-os">perl v5.30.2</td>
  </tr>
</table>
</body>
</html>
