<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    .Nd, .Bf, .Op { display: inline; }
    .Pa, .Ad { font-style: italic; }
    .Ms { font-weight: bold; }
    .Bl-diag > dt { font-weight: bold; }
    code.Nm, .Fl, .Cm, .Ic, code.In, .Fd, .Fn, .Cd { font-weight: bold;
      font-family: inherit; }
  </style>
  <title>Pod::Simple::Subclassing(3pm)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Pod::Simple::Subclassing(3pm)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">Pod::Simple::Subclassing(3pm)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Pod::Simple::Subclassing -- write a formatter as a Pod::Simple
    subclass</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>  package Pod::SomeFormatter;
  use Pod::Simple;
  @ISA = qw(Pod::Simple);
  $VERSION = '1.01';
  use strict;
  sub _handle_element_start {
        my($parser, $element_name, $attr_hash_r) = @_;
        ...
  }
  sub _handle_element_end {
        my($parser, $element_name, $attr_hash_r) = @_;
        # NOTE: $attr_hash_r is only present when $element_name is &quot;over&quot; or &quot;begin&quot;
        # The remaining code excerpts will mostly ignore this $attr_hash_r, as it is
        # mostly useless. It is documented where &quot;over-*&quot; and &quot;begin&quot; events are
        # documented.
        ...
  }
  sub _handle_text {
        my($parser, $text) = @_;
        ...
  }
  1;
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">This document is about using Pod::Simple to write a Pod processor,
    generally a Pod formatter. If you just want to know about using an existing
    Pod formatter, instead see its documentation and see also the docs in
    Pod::Simple.</p>
<p class="Pp"><b>The zeroeth step</b> in writing a Pod formatter is to make sure
    that there isn't already a decent one in CPAN. See
    &lt;http://search.cpan.org/&gt;, and run a search on the name of the format
    you want to render to. Also consider joining the Pod People list
    &lt;http://lists.perl.org/showlist.cgi?name=pod-people&gt; and asking
    whether anyone has a formatter for that format -- maybe someone cobbled one
    together but just hasn't released it.</p>
<p class="Pp"><b>The first step</b> in writing a Pod processor is to read
    perlpodspec, which contains information on writing a Pod parser (which has
    been largely taken care of by Pod::Simple), but also a lot of requirements
    and recommendations for writing a formatter.</p>
<p class="Pp"><b>The second step</b> is to actually learn the format you're
    planning to format to -- or at least as much as you need to know to
    represent Pod, which probably isn't much.</p>
<p class="Pp"><b>The third step</b> is to pick which of Pod::Simple's interfaces
    you want to use:</p>
<dl class="Bl-tag">
  <dt id="Pod::Simple"><a class="permalink" href="#Pod::Simple">Pod::Simple</a></dt>
  <dd>The basic Pod::Simple interface that uses
      <span class="Li">&quot;_handle_element_start()&quot;</span>,
      <span class="Li">&quot;_handle_element_end()&quot;</span> and
      <span class="Li">&quot;_handle_text()&quot;</span>.</dd>
  <dt id="Pod::Simple::Methody"><a class="permalink" href="#Pod::Simple::Methody">Pod::Simple::Methody</a></dt>
  <dd>The Pod::Simple::Methody interface is event-based, similar to that of
      HTML::Parser or XML::Parser's &quot;Handlers&quot;.</dd>
  <dt id="Pod::Simple::PullParser"><a class="permalink" href="#Pod::Simple::PullParser">Pod::Simple::PullParser</a></dt>
  <dd>Pod::Simple::PullParser provides a token-stream interface, sort of like
      HTML::TokeParser's interface.</dd>
  <dt id="Pod::Simple::SimpleTree"><a class="permalink" href="#Pod::Simple::SimpleTree">Pod::Simple::SimpleTree</a></dt>
  <dd>Pod::Simple::SimpleTree provides a simple tree interface, rather like
      XML::Parser's &quot;Tree&quot; interface. Users familiar with XML handling
      will be comfortable with this interface. Users interested in outputting
      XML, should look into the modules that produce an XML representation of
      the Pod stream, notably Pod::Simple::XMLOutStream; you can feed the output
      of such a class to whatever XML parsing system you are most at home
    with.</dd>
</dl>
<p class="Pp"><b>The last step</b> is to write your code based on how the events
    (or tokens, or tree-nodes, or the XML, or however you're parsing) will map
    to constructs in the output format. Also be sure to consider how to escape
    text nodes containing arbitrary text, and what to do with text nodes that
    represent preformatted text (from verbatim sections).</p>
</section>
<section class="Sh">
<h1 class="Sh" id="Events"><a class="permalink" href="#Events">Events</a></h1>
<p class="Pp">TODO intro... mention that events are supplied for implicits, like
    for missing &gt;'s</p>
<p class="Pp">In the following section, we use XML to represent the event
    structure associated with a particular construct. That is, TODO</p>
<dl class="Bl-tag">
  <dt>&quot;$parser-&gt;_handle_element_start( <i>element_name</i>,
    <i>attr_hashref</i> )&quot;</dt>
  <dd></dd>
  <dt>&quot;$parser-&gt;_handle_element_end( <i>element_name</i> )&quot;</dt>
  <dd></dd>
  <dt>&quot;$parser-&gt;_handle_text( <i>text_string</i> )&quot;</dt>
  <dd></dd>
</dl>
<p class="Pp">TODO describe</p>
<dl class="Bl-tag">
  <dt id="events"><a class="permalink" href="#events">events with an
    element_name of Document</a></dt>
  <dd>Parsing a document produces this event structure:
    <p class="Pp"></p>
    <pre>  &lt;Document start_line=&quot;543&quot;&gt;
        ...all events...
  &lt;/Document&gt;
    </pre>
    <p class="Pp">The value of the <i>start_line</i> attribute will be the line
        number of the first Pod directive in the document.</p>
    <p class="Pp">If there is no Pod in the given document, then the event
        structure will be this:</p>
    <p class="Pp"></p>
    <pre>  &lt;Document contentless=&quot;1&quot; start_line=&quot;543&quot;&gt;
  &lt;/Document&gt;
    </pre>
    <p class="Pp">In that case, the value of the <i>start_line</i> attribute
        will not be meaningful; under current implementations, it will probably
        be the line number of the last line in the file.</p>
  </dd>
  <dt id="events~2"><a class="permalink" href="#events~2">events with an
    element_name of Para</a></dt>
  <dd>Parsing a plain (non-verbatim, non-directive, non-data) paragraph in a Pod
      document produces this event structure:
    <p class="Pp"></p>
    <pre>        &lt;Para start_line=&quot;543&quot;&gt;
          ...all events in this paragraph...
        &lt;/Para&gt;
    </pre>
    <p class="Pp">The value of the <i>start_line</i> attribute will be the line
        number of the start of the paragraph.</p>
    <p class="Pp">For example, parsing this paragraph of Pod:</p>
    <p class="Pp"></p>
    <pre>  The value of the I&lt;start_line&gt; attribute will be the
  line number of the start of the paragraph.
    </pre>
    <p class="Pp">produces this event structure:</p>
    <p class="Pp"></p>
    <pre>        &lt;Para start_line=&quot;129&quot;&gt;
          The value of the
          &lt;I&gt;
                start_line
          &lt;/I&gt;
           attribute will be the line number of the first Pod directive
          in the document.
        &lt;/Para&gt;
    </pre>
  </dd>
  <dt id="events~3"><a class="permalink" href="#events~3">events with an
    element_name of B, C, F, or I.</a></dt>
  <dd>Parsing a B&lt;...&gt; formatting code (or of course any of its
      semantically identical syntactic variants
      B&lt;&lt;&#x00A0;...&#x00A0;&gt;&gt;, or
      B&lt;&lt;&lt;&lt;&#x00A0;...&#x00A0;&gt;&gt;&gt;&gt;, etc.) produces this
      event structure:
    <p class="Pp"></p>
    <pre>          &lt;B&gt;
                ...stuff...
          &lt;/B&gt;
    </pre>
    <p class="Pp">Currently, there are no attributes conveyed.</p>
    <p class="Pp">Parsing C, F, or I codes produce the same structure, with only
        a different element name.</p>
    <p class="Pp">If your parser object has been set to accept other formatting
        codes, then they will be presented like these B/C/F/I codes -- i.e.,
        without any attributes.</p>
  </dd>
  <dt id="events~4"><a class="permalink" href="#events~4">events with an
    element_name of S</a></dt>
  <dd>Normally, parsing an S&lt;...&gt; sequence produces this event structure,
      just as if it were a B/C/F/I code:
    <p class="Pp"></p>
    <pre>          &lt;S&gt;
                ...stuff...
          &lt;/S&gt;
    </pre>
    <p class="Pp">However, Pod::Simple (and presumably all derived parsers)
        offers the <span class="Li">&quot;nbsp_for_S&quot;</span> option which,
        if enabled, will suppress all S events, and instead change all spaces in
        the content to non-breaking spaces. This is intended for formatters that
        output to a format that has no code that means the same as S&lt;...&gt;,
        but which has a code/character that means non-breaking space.</p>
  </dd>
  <dt id="events~5"><a class="permalink" href="#events~5">events with an
    element_name of X</a></dt>
  <dd>Normally, parsing an X&lt;...&gt; sequence produces this event structure,
      just as if it were a B/C/F/I code:
    <p class="Pp"></p>
    <pre>          &lt;X&gt;
                ...stuff...
          &lt;/X&gt;
    </pre>
    <p class="Pp">However, Pod::Simple (and presumably all derived parsers)
        offers the <span class="Li">&quot;nix_X_codes&quot;</span> option which,
        if enabled, will suppress all X events and ignore their content. For
        formatters/processors that don't use X events, this is presumably quite
        useful.</p>
  </dd>
  <dt id="events~6"><a class="permalink" href="#events~6">events with an
    element_name of L</a></dt>
  <dd>Because the L&lt;...&gt; is the most complex construct in the language, it
      should not surprise you that the events it generates are the most complex
      in the language. Most of complexity is hidden away in the attribute
      values, so for those of you writing a Pod formatter that produces a
      non-hypertextual format, you can just ignore the attributes and treat an L
      event structure like a formatting element that (presumably) doesn't
      actually produce a change in formatting. That is, the content of the L
      event structure (as opposed to its attributes) is always what text should
      be displayed.
    <p class="Pp">There are, at first glance, three kinds of L links: URL, man,
        and pod.</p>
    <p class="Pp">When a L&lt;<i>some_url</i>&gt; code is parsed, it produces
        this event structure:</p>
    <p class="Pp"></p>
    <pre>  &lt;L content-implicit=&quot;yes&quot; raw=&quot;that_url&quot; to=&quot;that_url&quot; type=&quot;url&quot;&gt;
        that_url
  &lt;/L&gt;
    </pre>
    <p class="Pp">The <span class="Li">&quot;type=&quot;url&quot;&quot;</span>
        attribute is always specified for this type of L code.</p>
    <p class="Pp">For example, this Pod source:</p>
    <p class="Pp"></p>
    <pre>  L&lt;http://www.perl.com/CPAN/authors/&gt;
    </pre>
    <p class="Pp">produces this event structure:</p>
    <p class="Pp"></p>
    <pre>  &lt;L content-implicit=&quot;yes&quot; raw=&quot;http://www.perl.com/CPAN/authors/&quot; to=&quot;http://www.perl.com/CPAN/authors/&quot; type=&quot;url&quot;&gt;
        http://www.perl.com/CPAN/authors/
  &lt;/L&gt;
    </pre>
    <p class="Pp">When a L&lt;<i>manpage(section)</i>&gt; code is parsed (and
        these are fairly rare and not terribly useful), it produces this event
        structure:</p>
    <p class="Pp"></p>
    <pre>  &lt;L content-implicit=&quot;yes&quot; raw=&quot;manpage(section)&quot; to=&quot;manpage(section)&quot; type=&quot;man&quot;&gt;
        manpage(section)
  &lt;/L&gt;
    </pre>
    <p class="Pp">The <span class="Li">&quot;type=&quot;man&quot;&quot;</span>
        attribute is always specified for this type of L code.</p>
    <p class="Pp">For example, this Pod source:</p>
    <p class="Pp"></p>
    <pre>  L&lt;crontab(5)&gt;
    </pre>
    <p class="Pp">produces this event structure:</p>
    <p class="Pp"></p>
    <pre>  &lt;L content-implicit=&quot;yes&quot; raw=&quot;crontab(5)&quot; to=&quot;crontab(5)&quot; type=&quot;man&quot;&gt;
        crontab(5)
  &lt;/L&gt;
    </pre>
    <p class="Pp">In the rare cases where a man page link has a section
        specified, that text appears in a <i>section</i> attribute. For example,
        this Pod source:</p>
    <p class="Pp"></p>
    <pre>  L&lt;crontab(5)/&quot;ENVIRONMENT&quot;&gt;
    </pre>
    <p class="Pp">will produce this event structure:</p>
    <p class="Pp"></p>
    <pre>  &lt;L content-implicit=&quot;yes&quot; raw=&quot;crontab(5)/&amp;quot;ENVIRONMENT&amp;quot;&quot; section=&quot;ENVIRONMENT&quot; to=&quot;crontab(5)&quot; type=&quot;man&quot;&gt;
        &quot;ENVIRONMENT&quot; in crontab(5)
  &lt;/L&gt;
    </pre>
    <p class="Pp">In the rare case where the Pod document has code like
        L&lt;<i>sometext</i>|<i>manpage(section)</i>&gt;, then the
        <i>sometext</i> will appear as the content of the element, the
        <i>manpage(section)</i> text will appear only as the value of the
        <i>to</i> attribute, and there will be no
        <span class="Li">&quot;content-implicit=&quot;yes&quot;&quot;</span>
        attribute (whose presence means that the Pod parser had to infer what
        text should appear as the link text -- as opposed to cases where that
        attribute is absent, which means that the Pod parser did <i>not</i> have
        to infer the link text, because that L code explicitly specified some
        link text.)</p>
    <p class="Pp">For example, this Pod source:</p>
    <p class="Pp"></p>
    <pre>  L&lt;hell itself!|crontab(5)&gt;
    </pre>
    <p class="Pp">will produce this event structure:</p>
    <p class="Pp"></p>
    <pre>  &lt;L raw=&quot;hell itself!|crontab(5)&quot; to=&quot;crontab(5)&quot; type=&quot;man&quot;&gt;
        hell itself!
  &lt;/L&gt;
    </pre>
    <p class="Pp">The last type of L structure is for links to/within Pod
        documents. It is the most complex because it can have a <i>to</i>
        attribute, <i>or</i> a <i>section</i> attribute, or both. The
        <span class="Li">&quot;type=&quot;pod&quot;&quot;</span> attribute is
        always specified for this type of L code.</p>
    <p class="Pp">In the most common case, the simple case of a L&lt;podpage&gt;
        code produces this event structure:</p>
    <p class="Pp"></p>
    <pre>  &lt;L content-implicit=&quot;yes&quot; raw=&quot;podpage&quot; to=&quot;podpage&quot; type=&quot;pod&quot;&gt;
        podpage
  &lt;/L&gt;
    </pre>
    <p class="Pp">For example, this Pod source:</p>
    <p class="Pp"></p>
    <pre>  L&lt;Net::Ping&gt;
    </pre>
    <p class="Pp">produces this event structure:</p>
    <p class="Pp"></p>
    <pre>  &lt;L content-implicit=&quot;yes&quot; raw=&quot;Net::Ping&quot; to=&quot;Net::Ping&quot; type=&quot;pod&quot;&gt;
        Net::Ping
  &lt;/L&gt;
    </pre>
    <p class="Pp">In cases where there is link-text explicitly specified, it is
        to be found in the content of the element (and not the attributes), just
        as with the L&lt;<i>sometext</i>|<i>manpage(section)</i>&gt; case
        discussed above. For example, this Pod source:</p>
    <p class="Pp"></p>
    <pre>  L&lt;Perl Error Messages|perldiag&gt;
    </pre>
    <p class="Pp">produces this event structure:</p>
    <p class="Pp"></p>
    <pre>  &lt;L raw=&quot;Perl Error Messages|perldiag&quot; to=&quot;perldiag&quot; type=&quot;pod&quot;&gt;
        Perl Error Messages
  &lt;/L&gt;
    </pre>
    <p class="Pp">In cases of links to a section in the current Pod document,
        there is a <i>section</i> attribute instead of a <i>to</i> attribute.
        For example, this Pod source:</p>
    <p class="Pp"></p>
    <pre>  L&lt;/&quot;Member Data&quot;&gt;
    </pre>
    <p class="Pp">produces this event structure:</p>
    <p class="Pp"></p>
    <pre>  &lt;L content-implicit=&quot;yes&quot; raw=&quot;/&amp;quot;Member Data&amp;quot;&quot; section=&quot;Member Data&quot; type=&quot;pod&quot;&gt;
        &quot;Member Data&quot;
  &lt;/L&gt;
    </pre>
    <p class="Pp">As another example, this Pod source:</p>
    <p class="Pp"></p>
    <pre>  L&lt;the various attributes|/&quot;Member Data&quot;&gt;
    </pre>
    <p class="Pp">produces this event structure:</p>
    <p class="Pp"></p>
    <pre>  &lt;L raw=&quot;the various attributes|/&amp;quot;Member Data&amp;quot;&quot; section=&quot;Member Data&quot; type=&quot;pod&quot;&gt;
        the various attributes
  &lt;/L&gt;
    </pre>
    <p class="Pp">In cases of links to a section in a different Pod document,
        there are both a <i>section</i> attribute and a to attribute. For
        example, this Pod source:</p>
    <p class="Pp"></p>
    <pre>  L&lt;perlsyn/&quot;Basic BLOCKs and Switch Statements&quot;&gt;
    </pre>
    <p class="Pp">produces this event structure:</p>
    <p class="Pp"></p>
    <pre>  &lt;L content-implicit=&quot;yes&quot; raw=&quot;perlsyn/&amp;quot;Basic BLOCKs and Switch Statements&amp;quot;&quot; section=&quot;Basic BLOCKs and Switch Statements&quot; to=&quot;perlsyn&quot; type=&quot;pod&quot;&gt;
        &quot;Basic BLOCKs and Switch Statements&quot; in perlsyn
  &lt;/L&gt;
    </pre>
    <p class="Pp">As another example, this Pod source:</p>
    <p class="Pp"></p>
    <pre>  L&lt;SWITCH statements|perlsyn/&quot;Basic BLOCKs and Switch Statements&quot;&gt;
    </pre>
    <p class="Pp">produces this event structure:</p>
    <p class="Pp"></p>
    <pre>  &lt;L raw=&quot;SWITCH statements|perlsyn/&amp;quot;Basic BLOCKs and Switch Statements&amp;quot;&quot; section=&quot;Basic BLOCKs and Switch Statements&quot; to=&quot;perlsyn&quot; type=&quot;pod&quot;&gt;
        SWITCH statements
  &lt;/L&gt;
    </pre>
    <p class="Pp">Incidentally, note that we do not distinguish between these
        syntaxes:</p>
    <p class="Pp"></p>
    <pre>  L&lt;/&quot;Member Data&quot;&gt;
  L&lt;&quot;Member Data&quot;&gt;
  L&lt;/Member Data&gt;
  L&lt;Member Data&gt;    [deprecated syntax]
    </pre>
    <p class="Pp">That is, they all produce the same event structure (for the
        most part), namely:</p>
    <p class="Pp"></p>
    <pre>  &lt;L content-implicit=&quot;yes&quot; raw=&quot;$depends_on_syntax&quot; section=&quot;Member Data&quot; type=&quot;pod&quot;&gt;
        &amp;#34;Member Data&amp;#34;
  &lt;/L&gt;
    </pre>
    <p class="Pp">The <i>raw</i> attribute depends on what the raw content of
        the <span class="Li">&quot;L&lt;&gt;&quot;</span> is, so that is why the
        event structure is the same &quot;for the most part&quot;.</p>
    <p class="Pp">If you have not guessed it yet, the <i>raw</i> attribute
        contains the raw, original, unescaped content of the
        <span class="Li">&quot;L&lt;&gt;&quot;</span> formatting code. In
        addition to the examples above, take notice of the following event
        structure produced by the following
        <span class="Li">&quot;L&lt;&gt;&quot;</span> formatting code.</p>
    <p class="Pp"></p>
    <pre>  L&lt;click B&lt;here&gt;|page/About the C&lt;-M&gt; switch&gt;
  &lt;L raw=&quot;click B&lt;here&gt;|page/About the C&lt;-M&gt; switch&quot; section=&quot;About the -M switch&quot; to=&quot;page&quot; type=&quot;pod&quot;&gt;
        click B&lt;here&gt;
  &lt;/L&gt;
    </pre>
    <p class="Pp">Specifically, notice that the formatting codes are present and
        unescaped in <i>raw</i>.</p>
    <p class="Pp">There is a known bug in the <i>raw</i> attribute where any
        surrounding whitespace is condensed into a single ' '. For example,
        given L&lt; link&gt;, <i>raw</i> will be &quot; link&quot;.</p>
  </dd>
  <dt id="events~7"><a class="permalink" href="#events~7">events with an
    element_name of E or Z</a></dt>
  <dd>While there are Pod codes E&lt;...&gt; and Z&lt;&gt;, these <i>do not</i>
      produce any E or Z events -- that is, there are no such events as E or
    Z.</dd>
  <dt id="events~8"><a class="permalink" href="#events~8">events with an
    element_name of Verbatim</a></dt>
  <dd>When a Pod verbatim paragraph (AKA &quot;codeblock&quot;) is parsed, it
      produces this event structure:
    <p class="Pp"></p>
    <pre>  &lt;Verbatim start_line=&quot;543&quot; xml:space=&quot;preserve&quot;&gt;
        ...text...
  &lt;/Verbatim&gt;
    </pre>
    <p class="Pp">The value of the <i>start_line</i> attribute will be the line
        number of the first line of this verbatim block. The <i>xml:space</i>
        attribute is always present, and always has the value
        &quot;preserve&quot;.</p>
    <p class="Pp">The text content will have tabs already expanded.</p>
  </dd>
  <dt id="events~9"><a class="permalink" href="#events~9">events with an
    element_name of head1 .. head4</a></dt>
  <dd>When a &quot;=head1 ...&quot; directive is parsed, it produces this event
      structure:
    <p class="Pp"></p>
    <pre>  &lt;head1&gt;
        ...stuff...
  &lt;/head1&gt;
    </pre>
    <p class="Pp">For example, a directive consisting of this:</p>
    <p class="Pp"></p>
    <pre>  =head1 Options to C&lt;new&gt; et al.
    </pre>
    <p class="Pp">will produce this event structure:</p>
    <p class="Pp"></p>
    <pre>  &lt;head1 start_line=&quot;543&quot;&gt;
        Options to
        &lt;C&gt;
          new
        &lt;/C&gt;
         et al.
  &lt;/head1&gt;
    </pre>
    <p class="Pp">&quot;=head2&quot; through &quot;=head4&quot; directives are
        the same, except for the element names in the event structure.</p>
  </dd>
  <dt id="events~10"><a class="permalink" href="#events~10">events with an
    element_name of encoding</a></dt>
  <dd>In the default case, the events corresponding to
      <span class="Li">&quot;=encoding&quot;</span> directives are not emitted.
      They are emitted if
      <span class="Li">&quot;keep_encoding_directive&quot;</span> is true. In
      that case they produce event structures like &quot;events with an
      element_name of head1 .. head4&quot; above.</dd>
  <dt id="events~11"><a class="permalink" href="#events~11">events with an
    element_name of over-bullet</a></dt>
  <dd>When an &quot;=over ... =back&quot; block is parsed where the items are a
      bulleted list, it will produce this event structure:
    <p class="Pp"></p>
    <pre>  &lt;over-bullet indent=&quot;4&quot; start_line=&quot;543&quot;&gt;
        &lt;item-bullet start_line=&quot;545&quot;&gt;
          ...Stuff...
        &lt;/item-bullet&gt;
        ...more item-bullets...
  &lt;/over-bullet fake-closer=&quot;1&quot;&gt;
    </pre>
    <p class="Pp">The attribute <i>fake-closer</i> is only present if it is a
        true value; it is not present if it is a false value. It is shown in the
        above example to illustrate where the attribute is (in the
        <b>closing</b> tag). It signifies that the
        <span class="Li">&quot;=over&quot;</span> did not have a matching
        <span class="Li">&quot;=back&quot;</span>, and thus Pod::Simple had to
        create a fake closer.</p>
    <p class="Pp">For example, this Pod source:</p>
    <p class="Pp"></p>
    <pre>  =over
  =item *
  Something
  =back
    </pre>
    <p class="Pp">Would produce an event structure that does <b>not</b> have the
        <i>fake-closer</i> attribute, whereas this Pod source:</p>
    <p class="Pp"></p>
    <pre>  =over
  =item *
  Gasp! An unclosed =over block!
    </pre>
    <p class="Pp">would. The rest of the over-* examples will not demonstrate
        this attribute, but they all can have it. See Pod::Checker's source for
        an example of this attribute being used.</p>
    <p class="Pp">The value of the <i>indent</i> attribute is whatever value is
        after the &quot;=over&quot; directive, as in &quot;=over 8&quot;. If no
        such value is specified in the directive, then the <i>indent</i>
        attribute has the value &quot;4&quot;.</p>
    <p class="Pp">For example, this Pod source:</p>
    <p class="Pp"></p>
    <pre>  =over
  =item *
  Stuff
  =item *
  Bar I&lt;baz&gt;!
  =back
    </pre>
    <p class="Pp">produces this event structure:</p>
    <p class="Pp"></p>
    <pre>  &lt;over-bullet indent=&quot;4&quot; start_line=&quot;10&quot;&gt;
        &lt;item-bullet start_line=&quot;12&quot;&gt;
          Stuff
        &lt;/item-bullet&gt;
        &lt;item-bullet start_line=&quot;14&quot;&gt;
          Bar &lt;I&gt;baz&lt;/I&gt;!
        &lt;/item-bullet&gt;
  &lt;/over-bullet&gt;
    </pre>
  </dd>
  <dt id="events~12"><a class="permalink" href="#events~12">events with an
    element_name of over-number</a></dt>
  <dd>When an &quot;=over ... =back&quot; block is parsed where the items are a
      numbered list, it will produce this event structure:
    <p class="Pp"></p>
    <pre>  &lt;over-number indent=&quot;4&quot; start_line=&quot;543&quot;&gt;
        &lt;item-number number=&quot;1&quot; start_line=&quot;545&quot;&gt;
          ...Stuff...
        &lt;/item-number&gt;
        ...more item-number...
  &lt;/over-bullet&gt;
    </pre>
    <p class="Pp">This is like the &quot;over-bullet&quot; event structure; but
        note that the contents are &quot;item-number&quot; instead of
        &quot;item-bullet&quot;, and note that they will have a
        &quot;number&quot; attribute, which some formatters/processors may
        ignore (since, for example, there's no need for it in HTML when
        producing an
        &quot;&lt;UL&gt;&lt;LI&gt;...&lt;/LI&gt;...&lt;/UL&gt;&quot; structure),
        but which any processor may use.</p>
    <p class="Pp">Note that the values for the <i>number</i> attributes of
        &quot;item-number&quot; elements in a given &quot;over-number&quot; area
        <i>will</i> start at 1 and go up by one each time. If the Pod source
        doesn't follow that order (even though it really should!), whatever
        numbers it has will be ignored (with the correct values being put in the
        <i>number</i> attributes), and an error message might be issued to the
        user.</p>
  </dd>
  <dt id="events~13"><a class="permalink" href="#events~13">events with an
    element_name of over-text</a></dt>
  <dd>These events are somewhat unlike the other over-* structures, as far as
      what their contents are. When an &quot;=over ... =back&quot; block is
      parsed where the items are a list of text &quot;subheadings&quot;, it will
      produce this event structure:
    <p class="Pp"></p>
    <pre>  &lt;over-text indent=&quot;4&quot; start_line=&quot;543&quot;&gt;
        &lt;item-text&gt;
          ...stuff...
        &lt;/item-text&gt;
        ...stuff (generally Para or Verbatim elements)...
        &lt;item-text&gt;
        ...more item-text and/or stuff...
  &lt;/over-text&gt;
    </pre>
    <p class="Pp">The <i>indent</i> and <i>fake-closer</i> attributes are as
        with the other over-* events.</p>
    <p class="Pp">For example, this Pod source:</p>
    <p class="Pp"></p>
    <pre>  =over
  =item Foo
  Stuff
  =item Bar I&lt;baz&gt;!
  Quux
  =back
    </pre>
    <p class="Pp">produces this event structure:</p>
    <p class="Pp"></p>
    <pre>  &lt;over-text indent=&quot;4&quot; start_line=&quot;20&quot;&gt;
        &lt;item-text start_line=&quot;22&quot;&gt;
          Foo
        &lt;/item-text&gt;
        &lt;Para start_line=&quot;24&quot;&gt;
          Stuff
        &lt;/Para&gt;
        &lt;item-text start_line=&quot;26&quot;&gt;
          Bar
                &lt;I&gt;
                  baz
                &lt;/I&gt;
          !
        &lt;/item-text&gt;
        &lt;Para start_line=&quot;28&quot;&gt;
          Quux
        &lt;/Para&gt;
  &lt;/over-text&gt;
    </pre>
  </dd>
  <dt id="events~14"><a class="permalink" href="#events~14">events with an
    element_name of over-block</a></dt>
  <dd>These events are somewhat unlike the other over-* structures, as far as
      what their contents are. When an &quot;=over ... =back&quot; block is
      parsed where there are no items, it will produce this event structure:
    <p class="Pp"></p>
    <pre>  &lt;over-block indent=&quot;4&quot; start_line=&quot;543&quot;&gt;
        ...stuff (generally Para or Verbatim elements)...
  &lt;/over-block&gt;
    </pre>
    <p class="Pp">The <i>indent</i> and <i>fake-closer</i> attributes are as
        with the other over-* events.</p>
    <p class="Pp">For example, this Pod source:</p>
    <p class="Pp"></p>
    <pre>  =over
  For cutting off our trade with all parts of the world
  For transporting us beyond seas to be tried for pretended offenses
  He is at this time transporting large armies of foreign mercenaries to
  complete the works of death, desolation and tyranny, already begun with
  circumstances of cruelty and perfidy scarcely paralleled in the most
  barbarous ages, and totally unworthy the head of a civilized nation.
  =back
    </pre>
    <p class="Pp">will produce this event structure:</p>
    <p class="Pp"></p>
    <pre>  &lt;over-block indent=&quot;4&quot; start_line=&quot;2&quot;&gt;
        &lt;Para start_line=&quot;4&quot;&gt;
          For cutting off our trade with all parts of the world
        &lt;/Para&gt;
        &lt;Para start_line=&quot;6&quot;&gt;
          For transporting us beyond seas to be tried for pretended offenses
        &lt;/Para&gt;
        &lt;Para start_line=&quot;8&quot;&gt;
          He is at this time transporting large armies of [...more text...]
        &lt;/Para&gt;
  &lt;/over-block&gt;
    </pre>
  </dd>
  <dt id="events~15"><a class="permalink" href="#events~15">events with an
    element_name of over-empty</a></dt>
  <dd><b>Note: These events are only triggered if
      </b><span class="Li"><b>&quot;parse_empty_lists()&quot;</b></span><b> is
      set to a</b> <b>true value.</b>
    <p class="Pp">These events are somewhat unlike the other over-* structures,
        as far as what their contents are. When an &quot;=over ... =back&quot;
        block is parsed where there is no content, it will produce this event
        structure:</p>
    <p class="Pp"></p>
    <pre>  &lt;over-empty indent=&quot;4&quot; start_line=&quot;543&quot;&gt;
  &lt;/over-empty&gt;
    </pre>
    <p class="Pp">The <i>indent</i> and <i>fake-closer</i> attributes are as
        with the other over-* events.</p>
    <p class="Pp">For example, this Pod source:</p>
    <p class="Pp"></p>
    <pre>  =over
  =over
  =back
  =back
    </pre>
    <p class="Pp">will produce this event structure:</p>
    <p class="Pp"></p>
    <pre>  &lt;over-block indent=&quot;4&quot; start_line=&quot;1&quot;&gt;
        &lt;over-empty indent=&quot;4&quot; start_line=&quot;3&quot;&gt;
        &lt;/over-empty&gt;
  &lt;/over-block&gt;
    </pre>
    <p class="Pp">Note that the outer <span class="Li">&quot;=over&quot;</span>
        is a block because it has no <span class="Li">&quot;=item&quot;</span>s
        but still has content: the inner
        <span class="Li">&quot;=over&quot;</span>. The inner
        <span class="Li">&quot;=over&quot;</span>, in turn, is completely empty,
        and is treated as such.</p>
  </dd>
  <dt id="events~16"><a class="permalink" href="#events~16">events with an
    element_name of item-bullet</a></dt>
  <dd>See &quot;events with an element_name of over-bullet&quot;, above.</dd>
  <dt id="events~17"><a class="permalink" href="#events~17">events with an
    element_name of item-number</a></dt>
  <dd>See &quot;events with an element_name of over-number&quot;, above.</dd>
  <dt id="events~18"><a class="permalink" href="#events~18">events with an
    element_name of item-text</a></dt>
  <dd>See &quot;events with an element_name of over-text&quot;, above.</dd>
  <dt id="events~19"><a class="permalink" href="#events~19">events with an
    element_name of for</a></dt>
  <dd>TODO...</dd>
  <dt id="events~20"><a class="permalink" href="#events~20">events with an
    element_name of Data</a></dt>
  <dd>TODO...</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="More_Pod::Simple_Methods"><a class="permalink" href="#More_Pod::Simple_Methods">More
  Pod::Simple Methods</a></h1>
<p class="Pp">Pod::Simple provides a lot of methods that aren't generally
    interesting to the end user of an existing Pod formatter, but some of which
    you might find useful in writing a Pod formatter. They are listed below. The
    first several methods (the accept_* methods) are for declaring the
    capabilities of your parser, notably what <span class="Li">&quot;=for
    </span><span class="Li"><i>targetname</i></span><span class="Li">&quot;</span>
    sections it's interested in, what extra N&lt;...&gt; codes it accepts beyond
    the ones described in the <i>perlpod</i>.</p>
<dl class="Bl-tag">
  <dt>&quot;$parser-&gt;accept_targets( <i>SOMEVALUE</i> )&quot;</dt>
  <dd>As the parser sees sections like:
    <p class="Pp"></p>
    <pre>        =for html  &lt;img src=&quot;fig1.jpg&quot;&gt;
    </pre>
    <p class="Pp">or</p>
    <p class="Pp"></p>
    <pre>        =begin html
          &lt;img src=&quot;fig1.jpg&quot;&gt;
        =end html
    </pre>
    <p class="Pp">...the parser will ignore these sections unless your subclass
        has specified that it wants to see sections targeted to &quot;html&quot;
        (or whatever the formatter name is).</p>
    <p class="Pp">If you want to process all sections, even if they're not
        targeted for you, call this before you start parsing:</p>
    <p class="Pp"></p>
    <pre>  $parser-&gt;accept_targets('*');
    </pre>
  </dd>
  <dt>&quot;$parser-&gt;accept_targets_as_text( <i>SOMEVALUE</i> )&quot;</dt>
  <dd>This is like accept_targets, except that it specifies also that the
      content of sections for this target should be treated as Pod text even if
      the target name in &quot;=for <i>targetname</i>&quot; doesn't start with a
      &quot;:&quot;.
    <p class="Pp">At time of writing, I don't think you'll need to use this.</p>
  </dd>
  <dt>&quot;$parser-&gt;accept_codes( <i>Codename</i>, <i>Codename</i>...
    )&quot;</dt>
  <dd>This tells the parser that you accept additional formatting codes, beyond
      just the standard ones (I B C L F S X, plus the two weird ones you don't
      actually see in the parse tree, Z and E). For example, to also accept
      codes &quot;N&quot;, &quot;R&quot;, and &quot;W&quot;:
    <p class="Pp"></p>
    <pre>        $parser-&gt;accept_codes( qw( N R W ) );
    </pre>
    <p class="Pp"><b>TODO: document how this interacts with =extend, and long
        element names</b></p>
  </dd>
  <dt>&quot;$parser-&gt;accept_directive_as_data( <i>directive_name</i>
    )&quot;</dt>
  <dd></dd>
  <dt>&quot;$parser-&gt;accept_directive_as_verbatim( <i>directive_name</i>
    )&quot;</dt>
  <dd></dd>
  <dt>&quot;$parser-&gt;accept_directive_as_processed( <i>directive_name</i>
    )&quot;</dt>
  <dd>In the unlikely situation that you need to tell the parser that you will
      accept additional directives (&quot;=foo&quot; things), you need to first
      set the parser to treat its content as data (i.e., not really processed at
      all), or as verbatim (mostly just expanding tabs), or as processed text
      (parsing formatting codes like B&lt;...&gt;).
    <p class="Pp">For example, to accept a new directive &quot;=method&quot;,
        you'd presumably use:</p>
    <p class="Pp"></p>
    <pre>        $parser-&gt;accept_directive_as_processed(&quot;method&quot;);
    </pre>
    <p class="Pp">so that you could have Pod lines like:</p>
    <p class="Pp"></p>
    <pre>        =method I&lt;$whatever&gt; thing B&lt;um&gt;
    </pre>
    <p class="Pp">Making up your own directives breaks compatibility with other
        Pod formatters, in a way that using &quot;=for <i>target</i> ...&quot;
        lines doesn't; however, you may find this useful if you're making a Pod
        superset format where you don't need to worry about compatibility.</p>
  </dd>
  <dt>&quot;$parser-&gt;nbsp_for_S( <i>BOOLEAN</i> );&quot;</dt>
  <dd>Setting this attribute to a true value (and by default it is false) will
      turn &quot;S&lt;...&gt;&quot; sequences into sequences of words separated
      by <span class="Li">&quot;\xA0&quot;</span> (non-breaking space)
      characters. For example, it will take this:
    <p class="Pp"></p>
    <pre>        I like S&lt;Dutch apple pie&gt;, don't you?
    </pre>
    <p class="Pp">and treat it as if it were:</p>
    <p class="Pp"></p>
    <pre>        I like DutchE&lt;nbsp&gt;appleE&lt;nbsp&gt;pie, don't you?
    </pre>
    <p class="Pp">This is handy for output formats that don't have anything
        quite like an &quot;S&lt;...&gt;&quot; code, but which do have a code
        for non-breaking space.</p>
    <p class="Pp">There is currently no method for going the other way; but I
        can probably provide one upon request.</p>
  </dd>
  <dt>&quot;$parser-&gt;version_report()&quot;</dt>
  <dd>This returns a string reporting the <span class="Li">$VERSION</span> value
      from your module (and its classname) as well as the
      <span class="Li">$VERSION</span> value of Pod::Simple. Note that
      perlpodspec requires output formats (wherever possible) to note this
      detail in a comment in the output format. For example, for some kind of
      SGML output format:
    <p class="Pp"></p>
    <pre>        print OUT &quot;&lt;!-- \n&quot;, $parser-&gt;version_report, &quot;\n --&gt;&quot;;
    </pre>
  </dd>
  <dt>&quot;$parser-&gt;pod_para_count()&quot;</dt>
  <dd>This returns the count of Pod paragraphs seen so far.</dd>
  <dt>&quot;$parser-&gt;line_count()&quot;</dt>
  <dd>This is the current line number being parsed. But you might find the
      &quot;line_number&quot; event attribute more accurate, when it is
    present.</dd>
  <dt>&quot;$parser-&gt;nix_X_codes( <i>SOMEVALUE</i> )&quot;</dt>
  <dd>This attribute, when set to a true value (and it is false by default)
      ignores any &quot;X&lt;...&gt;&quot; sequences in the document being
      parsed. Many formats don't actually use the content of these codes, so
      have no reason to process them.</dd>
  <dt>&quot;$parser-&gt;keep_encoding_directive( <i>SOMEVALUE</i> )&quot;</dt>
  <dd>This attribute, when set to a true value (it is false by default) will
      keep <span class="Li">&quot;=encoding&quot;</span> and its content in the
      event structure. Most formats don't actually need to process the content
      of an <span class="Li">&quot;=encoding&quot;</span> directive, even when
      this directive sets the encoding and the processor makes use of the
      encoding information. Indeed, it is possible to know the encoding without
      processing the directive content.</dd>
  <dt>&quot;$parser-&gt;merge_text( <i>SOMEVALUE</i> )&quot;</dt>
  <dd>This attribute, when set to a true value (and it is false by default)
      makes sure that only one event (or token, or node) will be created for any
      single contiguous sequence of text. For example, consider this somewhat
      contrived example:
    <p class="Pp"></p>
    <pre>        I just LOVE Z&lt;&gt;hotE&lt;32&gt;apple pie!
    </pre>
    <p class="Pp">When that is parsed and events are about to be called on it,
        it may actually seem to be four different text events, one right after
        another: one event for &quot;I just LOVE &quot;, one for
        &quot;hot&quot;, one for &quot; &quot;, and one for &quot;apple
        pie!&quot;. But if you have merge_text on, then you're guaranteed that
        it will be fired as one text event: &quot;I just LOVE hot apple
        pie!&quot;.</p>
  </dd>
  <dt>&quot;$parser-&gt;code_handler( <i>CODE_REF</i> )&quot;</dt>
  <dd>This specifies code that should be called when a code line is seen (i.e.,
      a line outside of the Pod). Normally this is undef, meaning that no code
      should be called. If you provide a routine, it should start out like this:
    <p class="Pp"></p>
    <pre>        sub get_code_line {  # or whatever you'll call it
          my($line, $line_number, $parser) = @_;
          ...
        }
    </pre>
    <p class="Pp">Note, however, that sometimes the Pod events aren't processed
        in exactly the same order as the code lines are -- i.e., if you have a
        file with Pod, then code, then more Pod, sometimes the code will be
        processed (via whatever you have code_handler call) before the all of
        the preceding Pod has been processed.</p>
  </dd>
  <dt>&quot;$parser-&gt;cut_handler( <i>CODE_REF</i> )&quot;</dt>
  <dd>This is just like the code_handler attribute, except that it's for
      &quot;=cut&quot; lines, not code lines. The same caveats apply.
      &quot;=cut&quot; lines are unlikely to be interesting, but this is
      included for completeness.</dd>
  <dt>&quot;$parser-&gt;pod_handler( <i>CODE_REF</i> )&quot;</dt>
  <dd>This is just like the code_handler attribute, except that it's for
      &quot;=pod&quot; lines, not code lines. The same caveats apply.
      &quot;=pod&quot; lines are unlikely to be interesting, but this is
      included for completeness.</dd>
  <dt>&quot;$parser-&gt;whiteline_handler( <i>CODE_REF</i> )&quot;</dt>
  <dd>This is just like the code_handler attribute, except that it's for lines
      that are seemingly blank but have whitespace (&quot; &quot; and/or
      &quot;\t&quot;) on them, not code lines. The same caveats apply. These
      lines are unlikely to be interesting, but this is included for
      completeness.</dd>
  <dt>&quot;$parser-&gt;whine( <i>linenumber</i>, <i>complaint string</i>
    )&quot;</dt>
  <dd>This notes a problem in the Pod, which will be reported in the &quot;Pod
      Errors&quot; section of the document and/or sent to STDERR, depending on
      the values of the attributes
      <span class="Li">&quot;no_whining&quot;</span>,
      <span class="Li">&quot;no_errata_section&quot;</span>, and
      <span class="Li">&quot;complain_stderr&quot;</span>.</dd>
  <dt>&quot;$parser-&gt;scream( <i>linenumber</i>, <i>complaint string</i>
    )&quot;</dt>
  <dd>This notes an error like <span class="Li">&quot;whine&quot;</span> does,
      except that it is not suppressible with
      <span class="Li">&quot;no_whining&quot;</span>. This should be used only
      for very serious errors.</dd>
  <dt>&quot;$parser-&gt;source_dead(1)&quot;</dt>
  <dd>This aborts parsing of the current document, by switching on the flag that
      indicates that EOF has been seen. In particularly drastic cases, you might
      want to do this. It's rather nicer than just calling
      <span class="Li">&quot;die&quot;</span>!</dd>
  <dt>&quot;$parser-&gt;hide_line_numbers( <i>SOMEVALUE</i> )&quot;</dt>
  <dd>Some subclasses that indiscriminately dump event attributes (well, except
      for ones beginning with &quot;~&quot;) can use this object attribute for
      refraining to dump the &quot;start_line&quot; attribute.</dd>
  <dt>&quot;$parser-&gt;no_whining( <i>SOMEVALUE</i> )&quot;</dt>
  <dd>This attribute, if set to true, will suppress reports of non-fatal error
      messages. The default value is false, meaning that complaints <i>are</i>
      reported. How they get reported depends on the values of the attributes
      <span class="Li">&quot;no_errata_section&quot;</span> and
      <span class="Li">&quot;complain_stderr&quot;</span>.</dd>
  <dt>&quot;$parser-&gt;no_errata_section( <i>SOMEVALUE</i> )&quot;</dt>
  <dd>This attribute, if set to true, will suppress generation of an errata
      section. The default value is false -- i.e., an errata section will be
      generated.</dd>
  <dt>&quot;$parser-&gt;complain_stderr( <i>SOMEVALUE</i> )&quot;</dt>
  <dd>This attribute, if set to true will send complaints to STDERR. The default
      value is false -- i.e., complaints do not go to STDERR.</dd>
  <dt>&quot;$parser-&gt;bare_output( <i>SOMEVALUE</i> )&quot;</dt>
  <dd>Some formatter subclasses use this as a flag for whether output should
      have prologue and epilogue code omitted. For example, setting this to true
      for an HTML formatter class should omit the
      &quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;...&lt;/title&gt;&lt;body&gt;...&quot;
      prologue and the &quot;&lt;/body&gt;&lt;/html&gt;&quot; epilogue.
    <p class="Pp">If you want to set this to true, you should probably also set
        <span class="Li">&quot;no_whining&quot;</span> or at least
        <span class="Li">&quot;no_errata_section&quot;</span> to true.</p>
  </dd>
  <dt>&quot;$parser-&gt;preserve_whitespace( <i>SOMEVALUE</i> )&quot;</dt>
  <dd>If you set this attribute to a true value, the parser will try to preserve
      whitespace in the output. This means that such formatting conventions as
      two spaces after periods will be preserved by the parser. This is
      primarily useful for output formats that treat whitespace as significant
      (such as text or *roff, but not HTML).</dd>
  <dt>&quot;$parser-&gt;parse_empty_lists( <i>SOMEVALUE</i> )&quot;</dt>
  <dd>If this attribute is set to true, the parser will not ignore empty
      <span class="Li">&quot;=over&quot;</span>/<span class="Li">&quot;=back&quot;</span>
      blocks. The type of <span class="Li">&quot;=over&quot;</span> will be
      <i>empty</i>, documented above, &quot;events with an element_name of
      over-empty&quot;.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp">Pod::Simple -- event-based Pod-parsing framework</p>
<p class="Pp">Pod::Simple::Methody -- like Pod::Simple, but each sort of event
    calls its own method (like
  <span class="Li">&quot;start_head3&quot;</span>)</p>
<p class="Pp">Pod::Simple::PullParser -- a Pod-parsing framework like
    Pod::Simple, but with a token-stream interface</p>
<p class="Pp">Pod::Simple::SimpleTree -- a Pod-parsing framework like
    Pod::Simple, but with a tree interface</p>
<p class="Pp">Pod::Simple::Checker -- a simple Pod::Simple subclass that reads
    documents, and then makes a plaintext report of any errors found in the
    document</p>
<p class="Pp">Pod::Simple::DumpAsXML -- for dumping Pod documents as tidily
    indented XML, showing each event on its own line</p>
<p class="Pp">Pod::Simple::XMLOutStream -- dumps a Pod document as XML (without
    introducing extra whitespace as Pod::Simple::DumpAsXML does).</p>
<p class="Pp">Pod::Simple::DumpAsText -- for dumping Pod documents as tidily
    indented text, showing each event on its own line</p>
<p class="Pp">Pod::Simple::LinkSection -- class for objects representing the
    values of the TODO and TODO attributes of L&lt;...&gt; elements</p>
<p class="Pp">Pod::Escapes -- the module that Pod::Simple uses for evaluating
    E&lt;...&gt; content</p>
<p class="Pp">Pod::Simple::Text -- a simple plaintext formatter for Pod</p>
<p class="Pp">Pod::Simple::TextContent -- like Pod::Simple::Text, but makes no
    effort for indent or wrap the text being formatted</p>
<p class="Pp">Pod::Simple::HTML -- a simple HTML formatter for Pod</p>
<p class="Pp">perlpod</p>
<p class="Pp">perlpodspec</p>
<p class="Pp">perldoc</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SUPPORT"><a class="permalink" href="#SUPPORT">SUPPORT</a></h1>
<p class="Pp">Questions or discussion about POD and Pod::Simple should be sent
    to the pod-people@perl.org mail list. Send an empty email to
    pod-people-subscribe@perl.org to subscribe.</p>
<p class="Pp">This module is managed in an open GitHub repository,
    &lt;https://github.com/perl-pod/pod-simple/&gt;. Feel free to fork and
    contribute, or to clone &lt;git://github.com/perl-pod/pod-simple.git&gt; and
    send patches!</p>
<p class="Pp">Patches against Pod::Simple are welcome. Please send bug reports
    to &lt;bug-pod-simple@rt.cpan.org&gt;.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT_AND_DISCLAIMERS"><a class="permalink" href="#COPYRIGHT_AND_DISCLAIMERS">COPYRIGHT
  AND DISCLAIMERS</a></h1>
<p class="Pp">Copyright (c) 2002 Sean M. Burke.</p>
<p class="Pp">This library is free software; you can redistribute it and/or
    modify it under the same terms as Perl itself.</p>
<p class="Pp">This program is distributed in the hope that it will be useful,
    but without any warranty; without even the implied warranty of
    merchantability or fitness for a particular purpose.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">Pod::Simple was created by Sean M. Burke &lt;sburke@cpan.org&gt;.
    But don't bother him, he's retired.</p>
<p class="Pp">Pod::Simple is maintained by:</p>
<ul class="Bl-bullet">
  <li>Allison Randal <span class="Li">&quot;allison@perl.org&quot;</span></li>
  <li>Hans Dieter Pearcey <span class="Li">&quot;hdp@cpan.org&quot;</span></li>
  <li>David E. Wheeler
    <span class="Li">&quot;dwheeler@cpan.org&quot;</span></li>
</ul>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2019-10-21</td>
    <td class="foot-os">perl v5.30.3</td>
  </tr>
</table>
</body>
</html>
