<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    .Nd, .Bf, .Op { display: inline; }
    .Pa, .Ad { font-style: italic; }
    .Ms { font-weight: bold; }
    .Bl-diag > dt { font-weight: bold; }
    code.Nm, .Fl, .Cm, .Ic, code.In, .Fd, .Fn, .Cd { font-weight: bold;
      font-family: inherit; }
  </style>
  <title>install::TempContent::Objects::mod_perl-2.0.12::docs::api::Apache2::Filter(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">install::TempContent::Objects::mod_perl-2.0.12::docs::api::Apache2::Filter(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">install::TempContent::Objects::mod_perl-2.0.12::docs::api::Apache2::Filter(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Apache2::Filter - Perl API for Apache 2.0 Filtering</p>
</section>
<section class="Sh">
<h1 class="Sh" id="Synopsis"><a class="permalink" href="#Synopsis">Synopsis</a></h1>
<pre>  use Apache2::Filter ();
  
  # filter attributes
  my $c = $f-&gt;c;
  my $r = $f-&gt;r;
  my $frec = $f-&gt;frec();
  my $next_f = $f-&gt;next;
  
  my $ctx = $f-&gt;ctx;
  $f-&gt;ctx($ctx);
  
  # bucket brigade filtering API
  $rc = $f-&gt;next-&gt;get_brigade($bb, $mode, $block, $readbytes);
  $rc = $f-&gt;next-&gt;pass_brigade($bb);
  $rc = $f-&gt;fflush($bb);
  
  # streaming filtering API
  while ($filter-&gt;read(my $buffer, $wanted)) {
      # transform $buffer here
      $filter-&gt;print($buffer);
  }
  if ($f-&gt;seen_eos) {
      $filter-&gt;print(&quot;filter signature&quot;);
  }
  
  # filter manipulations
  $r-&gt;add_input_filter(\&amp;callback);
  $c-&gt;add_input_filter(\&amp;callback);
  $r-&gt;add_output_filter(\&amp;callback);
  $c-&gt;add_output_filter(\&amp;callback);
  $f-&gt;remove;
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="Description"><a class="permalink" href="#Description">Description</a></h1>
<p class="Pp"><span class="Li">&quot;Apache2::Filter&quot;</span> provides Perl
    API for Apache 2.0 filtering framework.</p>
<p class="Pp">Make sure to read <span class="Li">&quot;the Filtering</span>
    <span class="Li">tutorial|docs::2.0::user::handlers::filters&quot;</span>.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="Common_Filter_API"><a class="permalink" href="#Common_Filter_API">Common
  Filter API</a></h1>
<p class="Pp">The following methods can be called from any filter handler:</p>
<section class="Ss">
<h2 class="Ss" id="_c_"><a class="permalink" href="#_c_">&quot;c&quot;</a></h2>
<p class="Pp">Get the current connection object from a connection or a request
    filter:</p>
<p class="Pp"></p>
<pre>  $c = $f-&gt;c;
</pre>
<dl class="Bl-tag">
  <dt id="obj:"><a class="permalink" href="#obj:">obj: $f (
    &quot;Apache2::Filter object&quot; )</a></dt>
  <dd></dd>
  <dt id="ret:"><a class="permalink" href="#ret:">ret: $c (
    &quot;Apache2::Connection object&quot; )</a></dt>
  <dd></dd>
  <dt id="since:"><a class="permalink" href="#since:">since: 2.0.00</a></dt>
  <dd></dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="_ctx_"><a class="permalink" href="#_ctx_">&quot;ctx&quot;</a></h2>
<p class="Pp">Get/set the filter context data.</p>
<p class="Pp"></p>
<pre>  $ctx = $f-&gt;ctx;
         $f-&gt;ctx($ctx);
</pre>
<dl class="Bl-tag">
  <dt id="obj:~2"><a class="permalink" href="#obj:~2">obj: $f (
    &quot;Apache2::Filter object&quot; )</a></dt>
  <dd></dd>
  <dt id="opt"><a class="permalink" href="#opt">opt arg2: $ctx ( SCALAR
    )</a></dt>
  <dd>next context</dd>
  <dt id="ret:~2"><a class="permalink" href="#ret:~2">ret: $ctx ( SCALAR
    )</a></dt>
  <dd>current context</dd>
  <dt id="since:~2"><a class="permalink" href="#since:~2">since: 2.0.00</a></dt>
  <dd></dd>
</dl>
<p class="Pp">A filter context is created before the filter is called for the
    first time and it's destroyed at the end of the request. The context is
    preserved between filter invocations of the same request. So if a filter
    needs to store some data between invocations it should use the filter
    context for that. The filter context is initialized with the
    <span class="Li">&quot;undef&quot;</span> value.</p>
<p class="Pp">The <span class="Li">&quot;ctx&quot;</span> method accepts a
    single SCALAR argument. Therefore if you want to store any other perl
    datastructure you should use a reference to it.</p>
<p class="Pp">For example you can store a hash reference:</p>
<p class="Pp"></p>
<pre>  $f-&gt;ctx({ foo =&gt; 'bar' });
</pre>
<p class="Pp">and then access it:</p>
<p class="Pp"></p>
<pre>  $foo = $f-&gt;ctx-&gt;{foo};
</pre>
<p class="Pp">if you access the context more than once it's more efficient to
    copy it's value before using it:</p>
<p class="Pp"></p>
<pre>  my $ctx = $f-&gt;ctx;
  $foo = $ctx-&gt;{foo};
</pre>
<p class="Pp">to avoid redundant method calls. As of this writing
    <span class="Li">$ctx</span> is not a tied variable, so if you modify it
    need to store it at the end:</p>
<p class="Pp"></p>
<pre>  $f-&gt;ctx($ctx);
</pre>
<p class="Pp">META: later we might make it a TIEd-variable interface, so it'll
    be stored automatically.</p>
<p class="Pp">Besides its primary purpose of storing context data across
    multiple filter invocations, this method is also useful when used as a flag.
    For example here is how to ensure that something happens only once during
    the filter's life:</p>
<p class="Pp"></p>
<pre>  unless ($f-&gt;ctx) {
      do_something_once();
      $f-&gt;ctx(1);
  }
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="_frec_"><a class="permalink" href="#_frec_">&quot;frec&quot;</a></h2>
<p class="Pp">Get/set the <span class="Li">&quot;Apache2::FilterRec&quot;</span>
    (filter record) object.</p>
<p class="Pp"></p>
<pre>  $frec = $f-&gt;frec();
</pre>
<dl class="Bl-tag">
  <dt id="obj:~3"><a class="permalink" href="#obj:~3">obj: $f (
    &quot;Apache2::Filter object&quot; )</a></dt>
  <dd></dd>
  <dt id="ret:~3"><a class="permalink" href="#ret:~3">ret: $frec (
    &quot;Apache2::FilterRec object&quot; )</a></dt>
  <dd></dd>
  <dt id="since:~3"><a class="permalink" href="#since:~3">since: 2.0.00</a></dt>
  <dd></dd>
</dl>
<p class="Pp">For example you can call
    <span class="Li">&quot;$frec-&gt;name&quot;</span> to get filter's name.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_next_"><a class="permalink" href="#_next_">&quot;next&quot;</a></h2>
<p class="Pp">Return the <span class="Li">&quot;Apache2::Filter&quot;</span>
    object of the next filter in chain.</p>
<p class="Pp"></p>
<pre>  $next_f = $f-&gt;next;
</pre>
<dl class="Bl-tag">
  <dt id="obj:~4"><a class="permalink" href="#obj:~4">obj: $f (
    &quot;Apache2::Filter object&quot; )</a></dt>
  <dd>The current filter object</dd>
  <dt id="ret:~4"><a class="permalink" href="#ret:~4">ret: $next_f (
    &quot;Apache2::Filter object&quot; )</a></dt>
  <dd>The next filter object in chain</dd>
  <dt id="since:~4"><a class="permalink" href="#since:~4">since: 2.0.00</a></dt>
  <dd></dd>
</dl>
<p class="Pp">Since Apache inserts several core filters at the end of each
    chain, normally this method always returns an object. However if it's not a
    mod_perl filter handler, you can call only the following methods on it:
    <span class="Li">&quot;get_brigade&quot;</span>,
    <span class="Li">&quot;pass_brigade&quot;</span>,
    <span class="Li">&quot;c&quot;</span>,
    <span class="Li">&quot;r&quot;</span>,
    <span class="Li">&quot;frec&quot;</span> and
    <span class="Li">&quot;next&quot;</span>. If you call other methods the
    behavior is undefined.</p>
<p class="Pp">The next filter can be a mod_perl one or not, it's easy to tell
    which one is that by calling
    <span class="Li">&quot;$f-&gt;frec-&gt;name&quot;</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_r_"><a class="permalink" href="#_r_">&quot;r&quot;</a></h2>
<p class="Pp">Inside an HTTP request filter retrieve the current request
  object:</p>
<p class="Pp"></p>
<pre>  $r = $f-&gt;r;
</pre>
<dl class="Bl-tag">
  <dt id="obj:~5"><a class="permalink" href="#obj:~5">obj: $f (
    &quot;Apache2::Filter object&quot; )</a></dt>
  <dd></dd>
  <dt id="ret:~5"><a class="permalink" href="#ret:~5">ret: $r (
    &quot;Apache2::RequestRec object&quot; )</a></dt>
  <dd></dd>
  <dt id="since:~5"><a class="permalink" href="#since:~5">since: 2.0.00</a></dt>
  <dd></dd>
</dl>
<p class="Pp">If a sub-request adds filters, then that sub-request object is
    associated with the filter.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_remove_"><a class="permalink" href="#_remove_">&quot;remove&quot;</a></h2>
<p class="Pp">Remove the current filter from the filter chain (for the current
    request or connection).</p>
<p class="Pp"></p>
<pre>  $f-&gt;remove;
</pre>
<dl class="Bl-tag">
  <dt id="obj:~6"><a class="permalink" href="#obj:~6">obj: $f (
    &quot;Apache2::Filter object&quot; )</a></dt>
  <dd></dd>
  <dt id="ret:~6"><a class="permalink" href="#ret:~6">ret: no return
    value</a></dt>
  <dd></dd>
  <dt id="since:~6"><a class="permalink" href="#since:~6">since: 2.0.00</a></dt>
  <dd></dd>
</dl>
<p class="Pp">Notice that you should either complete the current filter
    invocation normally (by calling
    <span class="Li">&quot;get_brigade&quot;</span> or
    <span class="Li">&quot;pass_brigade&quot;</span> depending on the filter
    kind) or if nothing was done, return
    <span class="Li">&quot;Apache2::Const::DECLINED&quot;</span> and mod_perl
    will take care of passing the current bucket brigade through unmodified to
    the next filter in chain.</p>
<p class="Pp">Note: calling <b>remove()</b> on the very top connection filter
    doesn't affect the filter chain due to a bug in Apache 2.0 (which may be
    fixed in 2.1). So don't use it with connection filters, till it gets fixed
    in Apache and then make sure to require the minimum Apache version if you
    rely on.</p>
<p class="Pp">Remember that if the connection is
    <span class="Li">&quot;$c-&gt;keepalive&quot;</span> ) and the connection
    filter is removed, it won't be added until the connection is closed. Which
    may happen after many HTTP requests. You may want to keep the filter in
    place and pass the data through unmodified, by returning
    <span class="Li">&quot;Apache2::Const::DECLINED&quot;</span>. If you need to
    reset the whole or parts of the filter context between requests, use the
    technique based on <span class="Li">&quot;$c-&gt;keepalives&quot;</span>
    counting.</p>
<p class="Pp">This method works for native Apache (non-mod_perl) filters
  too.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="Bucket_Brigade_Filter_API"><a class="permalink" href="#Bucket_Brigade_Filter_API">Bucket
  Brigade Filter API</a></h1>
<p class="Pp">The following methods can be called from any filter, directly
    manipulating bucket brigades:</p>
<section class="Ss">
<h2 class="Ss" id="_fflush_"><a class="permalink" href="#_fflush_">&quot;fflush&quot;</a></h2>
<p class="Pp">Flush a bucket brigade down the filter stack.</p>
<p class="Pp"></p>
<pre>  $rc = $f-&gt;fflush($bb);
</pre>
<dl class="Bl-tag">
  <dt id="obj:~7"><a class="permalink" href="#obj:~7">obj: $f (
    &quot;Apache2::Filter object&quot; )</a></dt>
  <dd>The current filter</dd>
  <dt id="arg1:"><a class="permalink" href="#arg1:">arg1: $bb (
    &quot;Apache2::Brigade object&quot; )</a></dt>
  <dd>The brigade to flush</dd>
  <dt id="ret:~7"><a class="permalink" href="#ret:~7">ret: $rc (
    &quot;APR::Const status constant&quot; )</a></dt>
  <dd>Refer to the <span class="Li">&quot;pass_brigade()&quot;</span>
    entry.</dd>
  <dt id="excpt:"><a class="permalink" href="#excpt:">excpt:
    &quot;APR::Error&quot;</a></dt>
  <dd>Exceptions are thrown only when this function is called in the VOID
      context. Refer to the <span class="Li">&quot;get_brigade()&quot;</span>
      entry for details.</dd>
  <dt id="since:~7"><a class="permalink" href="#since:~7">since: 2.0.00</a></dt>
  <dd></dd>
</dl>
<p class="Pp"><span class="Li">&quot;fflush&quot;</span> is a shortcut method.
    So instead of doing:</p>
<p class="Pp"></p>
<pre>  my $b = APR::Bucket::flush_create($f-&gt;c-&gt;bucket_alloc);
  $bb-&gt;insert_tail($b);
  $f-&gt;pass_brigade($bb);
</pre>
<p class="Pp">one can just write:</p>
<p class="Pp"></p>
<pre>  $f-&gt;fflush($bb);
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="_get_brigade_"><a class="permalink" href="#_get_brigade_">&quot;get_brigade&quot;</a></h2>
<p class="Pp">This is a method to use in bucket brigade input filters. It
    acquires a bucket brigade from the upstream input filter.</p>
<p class="Pp"></p>
<pre>  $rc = $next_f-&gt;get_brigade($bb, $mode, $block, $readbytes);
  $rc = $next_f-&gt;get_brigade($bb, $mode, $block);
  $rc = $next_f-&gt;get_brigade($bb, $mode)
  $rc = $next_f-&gt;get_brigade($bb);
</pre>
<dl class="Bl-tag">
  <dt id="obj:~8"><a class="permalink" href="#obj:~8">obj: $next_f (
    &quot;Apache2::Filter object&quot; )</a></dt>
  <dd>The next filter in the filter chain.
    <p class="Pp">Inside filter handlers it's usually
        <span class="Li">&quot;$f-&gt;next&quot;</span>. Inside protocol
        handlers: <span class="Li">&quot;$c-&gt;input_filters&quot;</span>.</p>
  </dd>
  <dt id="arg1:~2"><a class="permalink" href="#arg1:~2">arg1: $bb (
    &quot;APR::Brigade object&quot; )</a></dt>
  <dd>The original bucket brigade passed to
      <span class="Li">&quot;get_brigade()&quot;</span>, which must be empty.
    <p class="Pp">Inside input filter handlers it's usually the second argument
        to the filter handler.</p>
    <p class="Pp">Otherwise it should be created:</p>
    <p class="Pp"></p>
    <pre>  my $bb = APR::Brigade-&gt;new($c-&gt;pool, $c-&gt;bucket_alloc);
    </pre>
    <p class="Pp">On return it gets populated with the next bucket brigade. That
        brigade may contain nothing if there was no more data to read. The
        return status tells the outcome.</p>
  </dd>
  <dt id="opt~2"><a class="permalink" href="#opt~2">opt arg2: $mode (
    &quot;Apache2::Const :input_mode constant&quot; )</a></dt>
  <dd>The filter mode in which the data should be read.
    <p class="Pp">If inside the filter handler, you should normally pass the
        same mode that was passed to the filter handler (the third
      argument).</p>
    <p class="Pp">At the end of this section the available modes are
      presented.</p>
    <p class="Pp">If the argument <span class="Li">$mode</span> is not passed,
        <span class="Li">&quot;Apache2::Const::MODE_READBYTES&quot;</span> is
        used as a default value.</p>
  </dd>
  <dt id="opt~3"><a class="permalink" href="#opt~3">opt arg3: $block (
    &quot;APR::Const :read_type constant&quot; )</a></dt>
  <dd>You may ask the reading operation to be blocking:
      <span class="Li">&quot;APR::Const::BLOCK_READ&quot;</span>, or
      nonblocking:
      <span class="Li">&quot;APR::Const::NONBLOCK_READ&quot;</span>.
    <p class="Pp">If inside the filter handler, you should normally pass the
        same blocking mode argument that was passed to the filter handler (the
        forth argument).</p>
    <p class="Pp">If the argument <span class="Li">$block</span> is not passed,
        <span class="Li">&quot;APR::Const::BLOCK_READ&quot;</span> is used as a
        default value.</p>
  </dd>
  <dt id="opt~4"><a class="permalink" href="#opt~4">opt arg4: $readbytes (
    integer )</a></dt>
  <dd>How many bytes to read from the next filter.
    <p class="Pp">If inside the filter handler, you may want the same number of
        bytes, as the upstream filter, i.e. the argument that was passed to the
        filter handler (the fifth argument).</p>
    <p class="Pp">If the argument <span class="Li">$block</span> is not passed,
        8192 is used as a default value.</p>
  </dd>
  <dt id="ret:~8"><a class="permalink" href="#ret:~8">ret: $rc (
    &quot;APR::Const status constant&quot; )</a></dt>
  <dd>On success, <span class="Li">&quot;APR::Const::SUCCESS&quot;</span> is
      returned and <span class="Li">$bb</span> is populated (see the
      <span class="Li">$bb</span> entry).
    <p class="Pp">In case of a failure -- a failure code is returned, in which
        case normally it should be returned to the caller.</p>
    <p class="Pp">If the bottom-most filter doesn't read from the network, then
        <span class="Li">&quot;Apache2::NOBODY_READ&quot;</span> is returned
        (META: need to add this constant).</p>
    <p class="Pp">Inside protocol handlers the return code can also be
        <span class="Li">&quot;APR::Const::EOF&quot;</span>, which is success as
        well.</p>
  </dd>
  <dt id="excpt:~2"><a class="permalink" href="#excpt:~2">excpt:
    &quot;APR::Error&quot;</a></dt>
  <dd>You don't have to ask for the return value. If this function is called in
      the VOID context, e.g.:
    <p class="Pp"></p>
    <pre>  $f-&gt;next-&gt;get_brigade($bb, $mode, $block, $readbytes);
    </pre>
    <p class="Pp">mod_perl will do the error checking on your behalf, and if the
        return code is not
        <span class="Li">&quot;APR::Const::SUCCESS&quot;</span>, an
        <span class="Li">&quot;APR::Error exception&quot;</span> will be thrown.
        The only time you want to do the error checking yourself, is when return
        codes besides <span class="Li">&quot;APR::Const::SUCCESS&quot;</span>
        are considered as successful and you want to manage them by
      yourself.</p>
  </dd>
  <dt id="since:~8"><a class="permalink" href="#since:~8">since: 2.0.00</a></dt>
  <dd></dd>
</dl>
<p class="Pp">Available input filter modes (the optional second argument
    <span class="Li">$mode</span>) are:</p>
<ul class="Bl-bullet">
  <li><span class="Li">&quot;Apache2::Const::MODE_READBYTES&quot;</span>
    <p class="Pp">The filter should return at most readbytes data</p>
  </li>
  <li><span class="Li">&quot;Apache2::Const::MODE_GETLINE&quot;</span>
    <p class="Pp">The filter should return at most one line of CRLF data. (If a
        potential line is too long or no CRLF is found, the filter may return
        partial data).</p>
  </li>
  <li><span class="Li">&quot;Apache2::Const::MODE_EATCRLF&quot;</span>
    <p class="Pp">The filter should implicitly eat any CRLF pairs that it
      sees.</p>
  </li>
  <li><span class="Li">&quot;Apache2::Const::MODE_SPECULATIVE&quot;</span>
    <p class="Pp">The filter read should be treated as speculative and any
        returned data should be stored for later retrieval in another mode.</p>
  </li>
  <li><span class="Li">&quot;Apache2::Const::MODE_EXHAUSTIVE&quot;</span>
    <p class="Pp">The filter read should be exhaustive and read until it can not
        read any more. Use this mode with extreme caution.</p>
  </li>
  <li><span class="Li">&quot;Apache2::Const::MODE_INIT&quot;</span>
    <p class="Pp">The filter should initialize the connection if needed, NNTP or
        FTP over SSL for example.</p>
  </li>
</ul>
<p class="Pp">Either compile all these constants with:</p>
<p class="Pp"></p>
<pre>  use Apache2::Const -compile =&gt; qw(:input_mode);
</pre>
<p class="Pp">But it's a bit more efficient to compile only those constants that
    you need.</p>
<p class="Pp">Example:</p>
<p class="Pp">Here is a fragment of a filter handler, that receives a bucket
    brigade from the upstream filter:</p>
<p class="Pp"></p>
<pre>  use Apache2::Filter ();
  use APR::Const    -compile =&gt; qw(SUCCESS);
  use Apache2::Const -compile =&gt; qw(OK);
  sub filter {
      my ($f, $bb, $mode, $block, $readbytes) = @_;
      
      my $rc = $f-&gt;next-&gt;get_brigade($bb, $mode, $block, $readbytes);
      return $rc unless $rc == APR::Const::SUCCESS;
      
      # ... process $bb
      
      return Apache2::Const::OK;
  }
</pre>
<p class="Pp">Usually arguments <span class="Li">$mode</span>,
    <span class="Li">$block</span>, <span class="Li">$readbytes</span> are the
    same as passed to the filter itself.</p>
<p class="Pp">You can see that in case of a failure, the handler returns
    immediately with that failure code, which gets propagated to the downstream
    filter.</p>
<p class="Pp">If you decide not check the return code, you can write it as:</p>
<p class="Pp"></p>
<pre>  sub filter {
      my ($f, $bb, $mode, $block, $readbytes) = @_;
      
      $f-&gt;next-&gt;get_brigade($bb, $mode, $block, $readbytes);
      
      # ... process $bb
      
      return Apache2::Const::OK;
  }
</pre>
<p class="Pp">and the error checking will be done on your behalf.</p>
<p class="Pp">You will find many more examples in <span class="Li">&quot;the
    filter</span>
    <span class="Li">handlers|docs::2.0::user::handlers::filters&quot;</span>
    and <span class="Li">&quot;the protocol</span>
    <span class="Li">handlers|docs::2.0::user::handlers::protocols&quot;</span>
    tutorials.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_pass_brigade_"><a class="permalink" href="#_pass_brigade_">&quot;pass_brigade&quot;</a></h2>
<p class="Pp">This is a method to use in bucket brigade output filters. It
    passes the current bucket brigade to the downstream output filter.</p>
<p class="Pp"></p>
<pre>  $rc = $next_f-&gt;pass_brigade($bb);
</pre>
<dl class="Bl-tag">
  <dt id="obj:~9"><a class="permalink" href="#obj:~9">obj: $next_f (
    &quot;Apache2::Filter object&quot; )</a></dt>
  <dd>The next filter in the filter chain.
    <p class="Pp">Inside output filter handlers it's usually
        <span class="Li">&quot;$f-&gt;next&quot;</span>. Inside protocol
        handlers: <span class="Li">&quot;$c-&gt;output_filters&quot;</span>.</p>
  </dd>
  <dt id="arg1:~3"><a class="permalink" href="#arg1:~3">arg1: $bb (
    &quot;APR::Brigade object&quot; )</a></dt>
  <dd>The bucket brigade to pass.
    <p class="Pp">Inside output filter handlers it's usually the second argument
        to the filter handler (after potential manipulations).</p>
  </dd>
  <dt id="ret:~9"><a class="permalink" href="#ret:~9">ret: $rc (
    &quot;APR::Const status constant&quot; )</a></dt>
  <dd>On success, <span class="Li">&quot;APR::Const::SUCCESS&quot;</span> is
      returned.
    <p class="Pp">In case of a failure -- a failure code is returned, in which
        case normally it should be returned to the caller.</p>
    <p class="Pp">If the bottom-most filter doesn't write to the network, then
        <span class="Li">&quot;Apache2::NOBODY_WROTE&quot;</span> is returned
        (META: need to add this constant).</p>
    <p class="Pp">Also refer to the
        <span class="Li">&quot;get_brigade()&quot;</span> entry to see how to
        avoid checking the errors explicitly.</p>
  </dd>
  <dt id="excpt:~3"><a class="permalink" href="#excpt:~3">excpt:
    &quot;APR::Error&quot;</a></dt>
  <dd>Exceptions are thrown only when this function is called in the VOID
      context. Refer to the <span class="Li">&quot;get_brigade()&quot;</span>
      entry for details.</dd>
  <dt id="since:~9"><a class="permalink" href="#since:~9">since: 2.0.00</a></dt>
  <dd></dd>
</dl>
<p class="Pp">The caller relinquishes ownership of the brigade (i.e. it may get
    destroyed/overwritten/etc. by the callee).</p>
<p class="Pp">Example:</p>
<p class="Pp">Here is a fragment of a filter handler, that passes a bucket
    brigade to the downstream filter (after some potential processing of the
    buckets in the bucket brigade):</p>
<p class="Pp"></p>
<pre>  use Apache2::Filter ();
  use APR::Const    -compile =&gt; qw(SUCCESS);
  use Apache2::Const -compile =&gt; qw(OK);
  sub filter {
      my ($f, $bb) = @_;
  
      # ... process $bb
  
      my $rc = $f-&gt;next-&gt;pass_brigade($bb);
      return $rc unless $rc == APR::Const::SUCCESS;
  
      return Apache2::Const::OK;
  }
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="Streaming_Filter_API"><a class="permalink" href="#Streaming_Filter_API">Streaming
  Filter API</a></h1>
<p class="Pp">The following methods can be called from any filter, which uses
    the simplified streaming functionality:</p>
<section class="Ss">
<h2 class="Ss" id="_print_"><a class="permalink" href="#_print_">&quot;print&quot;</a></h2>
<p class="Pp">Send the contents of <span class="Li">$buffer</span> to the next
    filter in chain (via internal buffer).</p>
<p class="Pp"></p>
<pre>  $sent = $f-&gt;print($buffer);
</pre>
<dl class="Bl-tag">
  <dt id="obj:~10"><a class="permalink" href="#obj:~10">obj: $f (
    &quot;Apache2::Filter object&quot; )</a></dt>
  <dd></dd>
  <dt id="arg1:~4"><a class="permalink" href="#arg1:~4">arg1: $buffer ( string
    )</a></dt>
  <dd>The data to send.</dd>
  <dt id="ret:~10"><a class="permalink" href="#ret:~10">ret: $sent ( integer
    )</a></dt>
  <dd>How many characters were sent. There is no need to check, since all should
      go through and if something goes work an exception will be thrown.</dd>
  <dt id="excpt:~4"><a class="permalink" href="#excpt:~4">excpt:
    &quot;APR::Error&quot;</a></dt>
  <dd></dd>
  <dt id="since:~10"><a class="permalink" href="#since:~10">since:
    2.0.00</a></dt>
  <dd></dd>
</dl>
<p class="Pp">This method should be used only in streaming filters.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_read_"><a class="permalink" href="#_read_">&quot;read&quot;</a></h2>
<p class="Pp">Read data from the filter</p>
<p class="Pp"></p>
<pre>  $read = $f-&gt;read($buffer, $wanted);
</pre>
<dl class="Bl-tag">
  <dt id="obj:~11"><a class="permalink" href="#obj:~11">obj: $f (
    &quot;Apache2::Filter object&quot; )</a></dt>
  <dd></dd>
  <dt id="arg1:~5"><a class="permalink" href="#arg1:~5">arg1: $buffer ( SCALAR
    )</a></dt>
  <dd>The buffer to fill. All previous data will be lost.</dd>
  <dt id="opt~5"><a class="permalink" href="#opt~5">opt arg2: $wanted ( integer
    )</a></dt>
  <dd>How many bytes to attempt to read.
    <p class="Pp">If this optional argument is not specified -- the default 8192
        will be used.</p>
  </dd>
  <dt id="ret:~11"><a class="permalink" href="#ret:~11">ret: $read ( integer
    )</a></dt>
  <dd>How many bytes were actually read.
    <p class="Pp"><span class="Li">$buffer</span> gets populated with the string
        that is read. It will contain an empty string if there was nothing to
        read.</p>
  </dd>
  <dt id="excpt:~5"><a class="permalink" href="#excpt:~5">excpt:
    &quot;APR::Error&quot;</a></dt>
  <dd></dd>
  <dt id="since:~11"><a class="permalink" href="#since:~11">since:
    2.0.00</a></dt>
  <dd></dd>
</dl>
<p class="Pp">Reads at most <span class="Li">$wanted</span> characters into
    <span class="Li">$buffer</span>. The returned value
    <span class="Li">$read</span> tells exactly how many were read, making it
    easy to use it in a while loop:</p>
<p class="Pp"></p>
<pre>  while ($filter-&gt;read(my $buffer, $wanted)) {
      # transform $buffer here
      $filter-&gt;print($buffer);
  }
</pre>
<p class="Pp">This is a streaming filter method, which acquires a single bucket
    brigade behind the scenes and reads data from all its buckets. Therefore it
    can only read from one bucket brigade per filter invocation.</p>
<p class="Pp">If the EOS bucket is read, the
    <span class="Li">&quot;seen_eos&quot;</span> method will return a true
    value.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_seen_eos_"><a class="permalink" href="#_seen_eos_">&quot;seen_eos&quot;</a></h2>
<p class="Pp">This methods returns a true value when the EOS bucket is seen by
    the <span class="Li">&quot;read&quot;</span> method.</p>
<p class="Pp"></p>
<pre>  $ok = $f-&gt;seen_eos;
</pre>
<dl class="Bl-tag">
  <dt id="obj:~12"><a class="permalink" href="#obj:~12">obj: $f (
    &quot;Apache2::Filter object&quot; )</a></dt>
  <dd>The filter to remove</dd>
  <dt id="ret:~12"><a class="permalink" href="#ret:~12">ret: $ok ( boolean
    )</a></dt>
  <dd>a true value if EOS has been seen, otherwise a false value</dd>
  <dt id="since:~12"><a class="permalink" href="#since:~12">since:
    2.0.00</a></dt>
  <dd></dd>
</dl>
<p class="Pp">This method only works in streaming filters which exhaustively
    <span class="Li">&quot;$f-&gt;read&quot;</span> all the incoming data in a
    while loop, like so:</p>
<p class="Pp"></p>
<pre>      while ($f-&gt;read(my $buffer, $wanted)) {
          # do something with $buffer
      }
      if ($f-&gt;seen_eos) {
          # do something
      }
</pre>
<p class="Pp">The technique in this example is useful when a streaming filter
    wants to append something to the very end of data, or do something at the
    end of the last filter invocation. After the EOS bucket is read, the filter
    should expect not to be invoked again.</p>
<p class="Pp">If an input streaming filter doesn't consume all data in the
    bucket brigade (or even in several bucket brigades), it has to generate the
    EOS event by itself. So when the filter is done it has to set the EOS
  flag:</p>
<p class="Pp"></p>
<pre>  $f-&gt;seen_eos(1);
</pre>
<p class="Pp">when the filter handler returns, internally mod_perl will take
    care of creating and sending the EOS bucket to the upstream input
  filter.</p>
<p class="Pp">A similar logic may apply for output filters.</p>
<p class="Pp">In most other cases you shouldn't set this flag. When this flag is
    prematurely set (before the real EOS bucket has arrived) in the current
    filter invocation, instead of invoking the filter again, mod_perl will
    create and send the EOS bucket to the next filter, ignoring any other bucket
    brigades that may have left to consume. As mentioned earlier this special
    behavior is useful in writing special tests that test abnormal
  situations.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="Other_Filter-related_API"><a class="permalink" href="#Other_Filter-related_API">Other
  Filter-related API</a></h1>
<p class="Pp">Other methods which affect filters, but called on
    non-<span class="Li">&quot;Apache2::Filter&quot;</span> objects:</p>
<section class="Ss">
<h2 class="Ss" id="_add_input_filter_"><a class="permalink" href="#_add_input_filter_">&quot;add_input_filter&quot;</a></h2>
<p class="Pp">Add <span class="Li">&amp;callback</span> filter handler to input
    request filter chain.</p>
<p class="Pp"></p>
<pre>  $r-&gt;add_input_filter(\&amp;callback);
</pre>
<p class="Pp">Add <span class="Li">&amp;callback</span> filter handler to input
    connection filter chain.</p>
<p class="Pp"></p>
<pre>  $c-&gt;add_input_filter(\&amp;callback);
</pre>
<dl class="Bl-tag">
  <dt id="obj:~13"><a class="permalink" href="#obj:~13">obj: $c (
    &quot;Apache2::Connection object&quot; ) or $r ( &quot;Apache2::RequestRec
    object&quot; )</a></dt>
  <dd></dd>
  <dt id="arg1:~6"><a class="permalink" href="#arg1:~6">arg1: &amp;callback
    (CODE ref)</a></dt>
  <dd></dd>
  <dt id="ret:~13"><a class="permalink" href="#ret:~13">ret: no return
    value</a></dt>
  <dd></dd>
  <dt id="since:~13"><a class="permalink" href="#since:~13">since:
    2.0.00</a></dt>
  <dd></dd>
</dl>
<p class="Pp">[META: It seems that you can't add a filter when another filter is
    called. I've tried to add an output connection filter from the input
    connection filter when it was called for the first time. It didn't have any
    affect for the first request (over keepalive connection). The only way I
    succeeded to do that is from that input connection filter's filter_init
    handler. In fact it does work if there is any filter additional filter of
    the same kind configured from httpd.conf or via filter_init. It looks like
    there is a bug in httpd, where it doesn't prepare the chain of 3rd party
    filter if none were inserted before the first filter was called.]</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_add_output_filter_"><a class="permalink" href="#_add_output_filter_">&quot;add_output_filter&quot;</a></h2>
<p class="Pp">Add <span class="Li">&amp;callback</span> filter handler to output
    request filter chain.</p>
<p class="Pp"></p>
<pre>  $r-&gt;add_output_filter(\&amp;callback);
</pre>
<p class="Pp">Add <span class="Li">&amp;callback</span> filter handler to output
    connection filter chain.</p>
<p class="Pp"></p>
<pre>  $c-&gt;add_output_filter(\&amp;callback);
</pre>
<dl class="Bl-tag">
  <dt id="obj:~14"><a class="permalink" href="#obj:~14">obj: $c (
    &quot;Apache2::Connection object&quot; ) or $r ( &quot;Apache2::RequestRec
    object&quot; )</a></dt>
  <dd></dd>
  <dt id="arg1:~7"><a class="permalink" href="#arg1:~7">arg1: &amp;callback
    (CODE ref)</a></dt>
  <dd></dd>
  <dt id="ret:~14"><a class="permalink" href="#ret:~14">ret: no return
    value</a></dt>
  <dd></dd>
  <dt id="since:~14"><a class="permalink" href="#since:~14">since:
    2.0.00</a></dt>
  <dd></dd>
</dl>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="Filter_Handler_Attributes"><a class="permalink" href="#Filter_Handler_Attributes">Filter
  Handler Attributes</a></h1>
<p class="Pp">Packages using filter attributes have to subclass
    <span class="Li">&quot;Apache2::Filter&quot;</span>:</p>
<p class="Pp"></p>
<pre>  package MyApache2::FilterCool;
  use base qw(Apache2::Filter);
</pre>
<p class="Pp">Attributes are parsed during the code compilation, by the function
    <span class="Li">&quot;MODIFY_CODE_ATTRIBUTES&quot;</span>, inherited from
    the <span class="Li">&quot;Apache2::Filter&quot;</span> package.</p>
<section class="Ss">
<h2 class="Ss" id="_FilterRequestHandler_"><a class="permalink" href="#_FilterRequestHandler_">&quot;FilterRequestHandler&quot;</a></h2>
<p class="Pp">The <span class="Li">&quot;FilterRequestHandler&quot;</span>
    attribute tells mod_perl to insert the filter into an HTTP request filter
    chain.</p>
<p class="Pp">For example, to configure an output request filter handler, use
    the <span class="Li">&quot;FilterRequestHandler&quot;</span> attribute in
    the handler subroutine's declaration:</p>
<p class="Pp"></p>
<pre>  package MyApache2::FilterOutputReq;
  sub handler : FilterRequestHandler { ... }
</pre>
<p class="Pp">and add the configuration entry:</p>
<p class="Pp"></p>
<pre>  PerlOutputFilterHandler MyApache2::FilterOutputReq
</pre>
<p class="Pp">This is the default mode. So if you are writing an HTTP request
    filter, you don't have to specify this attribute.</p>
<p class="Pp">The section HTTP Request vs. Connection Filters delves into more
    details.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_FilterConnectionHandler_"><a class="permalink" href="#_FilterConnectionHandler_">&quot;FilterConnectionHandler&quot;</a></h2>
<p class="Pp">The <span class="Li">&quot;FilterConnectionHandler&quot;</span>
    attribute tells mod_perl to insert this filter into a connection filter
    chain.</p>
<p class="Pp">For example, to configure an output connection filter handler, use
    the <span class="Li">&quot;FilterConnectionHandler&quot;</span> attribute in
    the handler subroutine's declaration:</p>
<p class="Pp"></p>
<pre>  package MyApache2::FilterOutputCon;
  sub handler : FilterConnectionHandler { ... }
</pre>
<p class="Pp">and add the configuration entry:</p>
<p class="Pp"></p>
<pre>  PerlOutputFilterHandler MyApache2::FilterOutputCon
</pre>
<p class="Pp">The section HTTP Request vs. Connection Filters delves into more
    details.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_FilterInitHandler_"><a class="permalink" href="#_FilterInitHandler_">&quot;FilterInitHandler&quot;</a></h2>
<p class="Pp">The attribute
    <span class="Li">&quot;FilterInitHandler&quot;</span> marks the function
    suitable to be used as a filter initialization callback, which is called
    immediately after a filter is inserted to the filter chain and before it's
    actually called.</p>
<p class="Pp"></p>
<pre>  sub init : FilterInitHandler {
      my $f = shift;
      #...
      return Apache2::Const::OK;
  }
</pre>
<p class="Pp">In order to hook this filter callback, the real filter has to
    assign this callback using the
    <span class="Li">&quot;FilterHasInitHandler&quot;</span> which accepts a
    reference to the callback function.</p>
<p class="Pp">For further discussion and examples refer to the Filter
    Initialization Phase tutorial section.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_FilterHasInitHandler_"><a class="permalink" href="#_FilterHasInitHandler_">&quot;FilterHasInitHandler&quot;</a></h2>
<p class="Pp">If a filter wants to run an initialization callback it can
    register such using the
    <span class="Li">&quot;FilterHasInitHandler&quot;</span> attribute. Similar
    to <span class="Li">&quot;push_handlers&quot;</span> the callback reference
    is expected, rather than a callback name. The used callback function has to
    have the <span class="Li">&quot;FilterInitHandler&quot;</span> attribute.
    For example:</p>
<p class="Pp"></p>
<pre>  package MyApache2::FilterBar;
  use base qw(Apache2::Filter);
  sub init   : FilterInitHandler { ... }
  sub filter : FilterRequestHandler FilterHasInitHandler(\&amp;init) {
      my ($f, $bb) = @_;
      # ...
      return Apache2::Const::OK;
  }
</pre>
<p class="Pp">For further discussion and examples refer to the Filter
    Initialization Phase tutorial section.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="Configuration"><a class="permalink" href="#Configuration">Configuration</a></h1>
<p class="Pp">mod_perl 2.0 filters configuration is explained in the filter
    handlers tutorial.</p>
<section class="Ss">
<h2 class="Ss" id="_PerlInputFilterHandler_"><a class="permalink" href="#_PerlInputFilterHandler_">&quot;PerlInputFilterHandler&quot;</a></h2>
<p class="Pp">See
  <span class="Li">&quot;PerlInputFilterHandler&quot;</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_PerlOutputFilterHandler_"><a class="permalink" href="#_PerlOutputFilterHandler_">&quot;PerlOutputFilterHandler&quot;</a></h2>
<p class="Pp">See
  <span class="Li">&quot;PerlOutputFilterHandler&quot;</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_PerlSetInputFilter_"><a class="permalink" href="#_PerlSetInputFilter_">&quot;PerlSetInputFilter&quot;</a></h2>
<p class="Pp">See <span class="Li">&quot;PerlSetInputFilter&quot;</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_PerlSetOutputFilter_"><a class="permalink" href="#_PerlSetOutputFilter_">&quot;PerlSetOutputFilter&quot;</a></h2>
<p class="Pp">See <span class="Li">&quot;PerlSetInputFilter&quot;</span>.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="TIE_Interface"><a class="permalink" href="#TIE_Interface">TIE
  Interface</a></h1>
<p class="Pp"><span class="Li">&quot;Apache2::Filter&quot;</span> also
    implements a tied interface, so you can work with the
    <span class="Li">$f</span> object as a hash reference.</p>
<p class="Pp">The TIE interface is mostly unimplemented and might be implemented
    post 2.0 release.</p>
<section class="Ss">
<h2 class="Ss" id="_TIEHANDLE_"><a class="permalink" href="#_TIEHANDLE_">&quot;TIEHANDLE&quot;</a></h2>
<pre>  $ret = TIEHANDLE($stashsv, $sv);
</pre>
<dl class="Bl-tag">
  <dt id="obj:~15"><a class="permalink" href="#obj:~15">obj: $stashsv ( SCALAR
    )</a></dt>
  <dd></dd>
  <dt id="arg1:~8"><a class="permalink" href="#arg1:~8">arg1: $sv ( SCALAR
    )</a></dt>
  <dd></dd>
  <dt id="ret:~15"><a class="permalink" href="#ret:~15">ret: $ret ( SCALAR
    )</a></dt>
  <dd></dd>
  <dt id="since:~15"><a class="permalink" href="#since:~15">since: subject to
    change</a></dt>
  <dd></dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="_PRINT_"><a class="permalink" href="#_PRINT_">&quot;PRINT&quot;</a></h2>
<pre>  $ret = PRINT(...);
</pre>
<dl class="Bl-tag">
  <dt id="obj:~16"><a class="permalink" href="#obj:~16">obj: &quot;...&quot;
    (XXX)</a></dt>
  <dd></dd>
  <dt id="ret:~16"><a class="permalink" href="#ret:~16">ret: $ret ( integer
    )</a></dt>
  <dd></dd>
  <dt id="since:~16"><a class="permalink" href="#since:~16">since: subject to
    change</a></dt>
  <dd></dd>
</dl>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="See_Also"><a class="permalink" href="#See_Also">See
  Also</a></h1>
<p class="Pp">mod_perl 2.0 documentation.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="Copyright"><a class="permalink" href="#Copyright">Copyright</a></h1>
<p class="Pp">mod_perl 2.0 and its core modules are copyrighted under The Apache
    Software License, Version 2.0.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="Authors"><a class="permalink" href="#Authors">Authors</a></h1>
<p class="Pp">The mod_perl development team and numerous contributors.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2015-06-18</td>
    <td class="foot-os">perl v5.30.2</td>
  </tr>
</table>
</body>
</html>
