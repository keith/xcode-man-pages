<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.10 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>install::TempContent::Objects::mod_perl-2.0.9::docs::api::Apache2::Filter(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">install::TempContent::Objects::mod_perl-2.0.9::docs::api::Apache2::Filter(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">install::TempContent::Objects::mod_perl-2.0.9::docs::api::Apache2::Filter(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
Apache2::Filter - Perl API for Apache 2.0 Filtering
</section>
<section class="Sh">
<h1 class="Sh" id="Synopsis"><a class="permalink" href="#Synopsis">Synopsis</a></h1>
<span class="Li"></span>
<pre>
  use Apache2::Filter ();
  
  # filter attributes
  my $c = $f-&gt;c;
  my $r = $f-&gt;r;
  my $frec = $f-&gt;frec();
  my $next_f = $f-&gt;next;
  
  my $ctx = $f-&gt;ctx;
  $f-&gt;ctx($ctx);
  
  # bucket brigade filtering API
  $rc = $f-&gt;next-&gt;get_brigade($bb, $mode, $block, $readbytes);
  $rc = $f-&gt;next-&gt;pass_brigade($bb);
  $rc = $f-&gt;fflush($bb);
  
  # streaming filtering API
  while ($filter-&gt;read(my $buffer, $wanted)) {
      # transform $buffer here
      $filter-&gt;print($buffer);
  }
  if ($f-&gt;seen_eos) {
      $filter-&gt;print(&quot;filter signature&quot;);
  }
  
  # filter manipulations
  $r-&gt;add_input_filter(\&amp;callback);
  $c-&gt;add_input_filter(\&amp;callback);
  $r-&gt;add_output_filter(\&amp;callback);
  $c-&gt;add_output_filter(\&amp;callback);
  $f-&gt;remove;
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="Description"><a class="permalink" href="#Description">Description</a></h1>
<span class="Li">&quot;Apache2::Filter&quot;</span> provides Perl API for Apache
  2.0 filtering framework.
<p class="Pp">Make sure to read <span class="Li">&quot;the Filtering</span>
    <span class="Li">tutorial|docs::2.0::user::handlers::filters&quot;</span>.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="Common_Filter_API"><a class="permalink" href="#Common_Filter_API">Common
  Filter API</a></h1>
The following methods can be called from any filter handler:
<section class="Ss">
<h2 class="Ss" id="_c_"><a class="permalink" href="#_c_">&quot;c&quot;</a></h2>
Get the current connection object from a connection or a request filter:
<p class="Pp"><span class="Li"></span></p>
<pre>
  $c = $f-&gt;c;
</pre>
<dl class="Bl-tag">
  <dt>obj: $f ( &quot;Apache2::Filter object&quot; )</dt>
  <dd></dd>
  <dt>ret: $c ( &quot;Apache2::Connection object&quot; )</dt>
  <dd></dd>
  <dt>since: 2.0.00</dt>
  <dd></dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="_ctx_"><a class="permalink" href="#_ctx_">&quot;ctx&quot;</a></h2>
Get/set the filter context data.
<p class="Pp"><span class="Li"></span></p>
<pre>
  $ctx = $f-&gt;ctx;
         $f-&gt;ctx($ctx);
</pre>
<dl class="Bl-tag">
  <dt>obj: $f ( &quot;Apache2::Filter object&quot; )</dt>
  <dd></dd>
  <dt>opt arg2: $ctx ( SCALAR )</dt>
  <dd>next context</dd>
  <dt>ret: $ctx ( SCALAR )</dt>
  <dd>current context</dd>
  <dt>since: 2.0.00</dt>
  <dd></dd>
</dl>
<p class="Pp">A filter context is created before the filter is called for the
    first time and it's destroyed at the end of the request. The context is
    preserved between filter invocations of the same request. So if a filter
    needs to store some data between invocations it should use the filter
    context for that. The filter context is initialized with the
    <span class="Li">&quot;undef&quot;</span> value.</p>
<p class="Pp">The <span class="Li">&quot;ctx&quot;</span> method accepts a
    single SCALAR argument. Therefore if you want to store any other perl
    datastructure you should use a reference to it.</p>
<p class="Pp">For example you can store a hash reference:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  $f-&gt;ctx({ foo =&gt; 'bar' });
</pre>
<p class="Pp">and then access it:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  $foo = $f-&gt;ctx-&gt;{foo};
</pre>
<p class="Pp">if you access the context more than once it's more efficient to
    copy it's value before using it:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  my $ctx = $f-&gt;ctx;
  $foo = $ctx-&gt;{foo};
</pre>
<p class="Pp">to avoid redundant method calls. As of this writing
    <span class="Li">$ctx</span> is not a tied variable, so if you modify it
    need to store it at the end:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  $f-&gt;ctx($ctx);
</pre>
<p class="Pp">META: later we might make it a TIEd-variable interface, so it'll
    be stored automatically.</p>
<p class="Pp">Besides its primary purpose of storing context data across
    multiple filter invocations, this method is also useful when used as a flag.
    For example here is how to ensure that something happens only once during
    the filter's life:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  unless ($f-&gt;ctx) {
      do_something_once();
      $f-&gt;ctx(1);
  }
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="_frec_"><a class="permalink" href="#_frec_">&quot;frec&quot;</a></h2>
Get/set the <span class="Li">&quot;Apache2::FilterRec&quot;</span> (filter
  record) object.
<p class="Pp"><span class="Li"></span></p>
<pre>
  $frec = $f-&gt;frec();
</pre>
<dl class="Bl-tag">
  <dt>obj: $f ( &quot;Apache2::Filter object&quot; )</dt>
  <dd></dd>
  <dt>ret: $frec ( &quot;Apache2::FilterRec object&quot; )</dt>
  <dd></dd>
  <dt>since: 2.0.00</dt>
  <dd></dd>
</dl>
<p class="Pp">For example you can call
    <span class="Li">&quot;$frec-&gt;name&quot;</span> to get filter's name.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_next_"><a class="permalink" href="#_next_">&quot;next&quot;</a></h2>
Return the <span class="Li">&quot;Apache2::Filter&quot;</span> object of the
  next filter in chain.
<p class="Pp"><span class="Li"></span></p>
<pre>
  $next_f = $f-&gt;next;
</pre>
<dl class="Bl-tag">
  <dt>obj: $f ( &quot;Apache2::Filter object&quot; )</dt>
  <dd>The current filter object</dd>
  <dt>ret: $next_f ( &quot;Apache2::Filter object&quot; )</dt>
  <dd>The next filter object in chain</dd>
  <dt>since: 2.0.00</dt>
  <dd></dd>
</dl>
<p class="Pp">Since Apache inserts several core filters at the end of each
    chain, normally this method always returns an object. However if it's not a
    mod_perl filter handler, you can call only the following methods on it:
    <span class="Li">&quot;get_brigade&quot;</span>,
    <span class="Li">&quot;pass_brigade&quot;</span>,
    <span class="Li">&quot;c&quot;</span>,
    <span class="Li">&quot;r&quot;</span>,
    <span class="Li">&quot;frec&quot;</span> and
    <span class="Li">&quot;next&quot;</span>. If you call other methods the
    behavior is undefined.</p>
<p class="Pp">The next filter can be a mod_perl one or not, it's easy to tell
    which one is that by calling
    <span class="Li">&quot;$f-&gt;frec-&gt;name&quot;</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_r_"><a class="permalink" href="#_r_">&quot;r&quot;</a></h2>
Inside an HTTP request filter retrieve the current request object:
<p class="Pp"><span class="Li"></span></p>
<pre>
  $r = $f-&gt;r;
</pre>
<dl class="Bl-tag">
  <dt>obj: $f ( &quot;Apache2::Filter object&quot; )</dt>
  <dd></dd>
  <dt>ret: $r ( &quot;Apache2::RequestRec object&quot; )</dt>
  <dd></dd>
  <dt>since: 2.0.00</dt>
  <dd></dd>
</dl>
<p class="Pp">If a sub-request adds filters, then that sub-request object is
    associated with the filter.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_remove_"><a class="permalink" href="#_remove_">&quot;remove&quot;</a></h2>
Remove the current filter from the filter chain (for the current request or
  connection).
<p class="Pp"><span class="Li"></span></p>
<pre>
  $f-&gt;remove;
</pre>
<dl class="Bl-tag">
  <dt>obj: $f ( &quot;Apache2::Filter object&quot; )</dt>
  <dd></dd>
  <dt>ret: no return value</dt>
  <dd></dd>
  <dt>since: 2.0.00</dt>
  <dd></dd>
</dl>
<p class="Pp">Notice that you should either complete the current filter
    invocation normally (by calling
    <span class="Li">&quot;get_brigade&quot;</span> or
    <span class="Li">&quot;pass_brigade&quot;</span> depending on the filter
    kind) or if nothing was done, return
    <span class="Li">&quot;Apache2::Const::DECLINED&quot;</span> and mod_perl
    will take care of passing the current bucket brigade through unmodified to
    the next filter in chain.</p>
<p class="Pp">Note: calling <b>remove()</b> on the very top connection filter
    doesn't affect the filter chain due to a bug in Apache 2.0 (which may be
    fixed in 2.1). So don't use it with connection filters, till it gets fixed
    in Apache and then make sure to require the minimum Apache version if you
    rely on.</p>
<p class="Pp">Remember that if the connection is
    <span class="Li">&quot;$c-&gt;keepalive&quot;</span> ) and the connection
    filter is removed, it won't be added until the connection is closed. Which
    may happen after many HTTP requests. You may want to keep the filter in
    place and pass the data through unmodified, by returning
    <span class="Li">&quot;Apache2::Const::DECLINED&quot;</span>. If you need to
    reset the whole or parts of the filter context between requests, use the
    technique based on <span class="Li">&quot;$c-&gt;keepalives&quot;</span>
    counting.</p>
<p class="Pp">This method works for native Apache (non-mod_perl) filters
  too.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="Bucket_Brigade_Filter_API"><a class="permalink" href="#Bucket_Brigade_Filter_API">Bucket
  Brigade Filter API</a></h1>
The following methods can be called from any filter, directly manipulating
  bucket brigades:
<section class="Ss">
<h2 class="Ss" id="_fflush_"><a class="permalink" href="#_fflush_">&quot;fflush&quot;</a></h2>
Flush a bucket brigade down the filter stack.
<p class="Pp"><span class="Li"></span></p>
<pre>
  $rc = $f-&gt;fflush($bb);
</pre>
<dl class="Bl-tag">
  <dt>obj: $f ( &quot;Apache2::Filter object&quot; )</dt>
  <dd>The current filter</dd>
  <dt>arg1: $bb ( &quot;Apache2::Brigade object&quot; )</dt>
  <dd>The brigade to flush</dd>
  <dt>ret: $rc ( &quot;APR::Const status constant&quot; )</dt>
  <dd>Refer to the <span class="Li">&quot;pass_brigade()&quot;</span>
    entry.</dd>
  <dt>excpt: &quot;APR::Error&quot;</dt>
  <dd>Exceptions are thrown only when this function is called in the VOID
      context. Refer to the <span class="Li">&quot;get_brigade()&quot;</span>
      entry for details.</dd>
  <dt>since: 2.0.00</dt>
  <dd></dd>
</dl>
<p class="Pp"><span class="Li">&quot;fflush&quot;</span> is a shortcut method.
    So instead of doing:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  my $b = APR::Bucket::flush_create($f-&gt;c-&gt;bucket_alloc);
  $bb-&gt;insert_tail($b);
  $f-&gt;pass_brigade($bb);
</pre>
<p class="Pp">one can just write:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  $f-&gt;fflush($bb);
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="_get_brigade_"><a class="permalink" href="#_get_brigade_">&quot;get_brigade&quot;</a></h2>
This is a method to use in bucket brigade input filters. It acquires a bucket
  brigade from the upstream input filter.
<p class="Pp"><span class="Li"></span></p>
<pre>
  $rc = $next_f-&gt;get_brigade($bb, $mode, $block, $readbytes);
  $rc = $next_f-&gt;get_brigade($bb, $mode, $block);
  $rc = $next_f-&gt;get_brigade($bb, $mode)
  $rc = $next_f-&gt;get_brigade($bb);
</pre>
<dl class="Bl-tag">
  <dt>obj: $next_f ( &quot;Apache2::Filter object&quot; )</dt>
  <dd>The next filter in the filter chain.
    <p class="Pp">Inside filter handlers it's usually
        <span class="Li">&quot;$f-&gt;next&quot;</span>. Inside protocol
        handlers: <span class="Li">&quot;$c-&gt;input_filters&quot;</span>.</p>
  </dd>
  <dt>arg1: $bb ( &quot;APR::Brigade object&quot; )</dt>
  <dd>The original bucket brigade passed to
      <span class="Li">&quot;get_brigade()&quot;</span>, which must be empty.
    <p class="Pp">Inside input filter handlers it's usually the second argument
        to the filter handler.</p>
    <p class="Pp">Otherwise it should be created:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  my $bb = APR::Brigade-&gt;new($c-&gt;pool, $c-&gt;bucket_alloc);
    </pre>
    <p class="Pp">On return it gets populated with the next bucket brigade. That
        brigade may contain nothing if there was no more data to read. The
        return status tells the outcome.</p>
  </dd>
  <dt>opt arg2: $mode ( &quot;Apache2::Const :input_mode constant&quot; )</dt>
  <dd>The filter mode in which the data should be read.
    <p class="Pp">If inside the filter handler, you should normally pass the
        same mode that was passed to the filter handler (the third
      argument).</p>
    <p class="Pp">At the end of this section the available modes are
      presented.</p>
    <p class="Pp">If the argument <span class="Li">$mode</span> is not passed,
        <span class="Li">&quot;Apache2::Const::MODE_READBYTES&quot;</span> is
        used as a default value.</p>
  </dd>
  <dt>opt arg3: $block ( &quot;APR::Const :read_type constant&quot; )</dt>
  <dd>You may ask the reading operation to be blocking:
      <span class="Li">&quot;APR::Const::BLOCK_READ&quot;</span>, or
      nonblocking:
      <span class="Li">&quot;APR::Const::NONBLOCK_READ&quot;</span>.
    <p class="Pp">If inside the filter handler, you should normally pass the
        same blocking mode argument that was passed to the filter handler (the
        forth argument).</p>
    <p class="Pp">If the argument <span class="Li">$block</span> is not passed,
        <span class="Li">&quot;APR::Const::BLOCK_READ&quot;</span> is used as a
        default value.</p>
  </dd>
  <dt>opt arg4: $readbytes ( integer )</dt>
  <dd>How many bytes to read from the next filter.
    <p class="Pp">If inside the filter handler, you may want the same number of
        bytes, as the upstream filter, i.e. the argument that was passed to the
        filter handler (the fifth argument).</p>
    <p class="Pp">If the argument <span class="Li">$block</span> is not passed,
        8192 is used as a default value.</p>
  </dd>
  <dt>ret: $rc ( &quot;APR::Const status constant&quot; )</dt>
  <dd>On success, <span class="Li">&quot;APR::Const::SUCCESS&quot;</span> is
      returned and <span class="Li">$bb</span> is populated (see the
      <span class="Li">$bb</span> entry).
    <p class="Pp">In case of a failure -- a failure code is returned, in which
        case normally it should be returned to the caller.</p>
    <p class="Pp">If the bottom-most filter doesn't read from the network, then
        <span class="Li">&quot;Apache2::NOBODY_READ&quot;</span> is returned
        (META: need to add this constant).</p>
    <p class="Pp">Inside protocol handlers the return code can also be
        <span class="Li">&quot;APR::Const::EOF&quot;</span>, which is success as
        well.</p>
  </dd>
  <dt>excpt: &quot;APR::Error&quot;</dt>
  <dd>You don't have to ask for the return value. If this function is called in
      the VOID context, e.g.:
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  $f-&gt;next-&gt;get_brigade($bb, $mode, $block, $readbytes);
    </pre>
    <p class="Pp">mod_perl will do the error checking on your behalf, and if the
        return code is not
        <span class="Li">&quot;APR::Const::SUCCESS&quot;</span>, an
        <span class="Li">&quot;APR::Error exception&quot;</span> will be thrown.
        The only time you want to do the error checking yourself, is when return
        codes besides <span class="Li">&quot;APR::Const::SUCCESS&quot;</span>
        are considered as successful and you want to manage them by
      yourself.</p>
  </dd>
  <dt>since: 2.0.00</dt>
  <dd></dd>
</dl>
<p class="Pp">Available input filter modes (the optional second argument
    <span class="Li">$mode</span>) are:</p>
<ul class="Bl-bullet">
  <li><span class="Li">&quot;Apache2::Const::MODE_READBYTES&quot;</span>
    <p class="Pp">The filter should return at most readbytes data</p>
  </li>
  <li><span class="Li">&quot;Apache2::Const::MODE_GETLINE&quot;</span>
    <p class="Pp">The filter should return at most one line of CRLF data. (If a
        potential line is too long or no CRLF is found, the filter may return
        partial data).</p>
  </li>
  <li><span class="Li">&quot;Apache2::Const::MODE_EATCRLF&quot;</span>
    <p class="Pp">The filter should implicitly eat any CRLF pairs that it
      sees.</p>
  </li>
  <li><span class="Li">&quot;Apache2::Const::MODE_SPECULATIVE&quot;</span>
    <p class="Pp">The filter read should be treated as speculative and any
        returned data should be stored for later retrieval in another mode.</p>
  </li>
  <li><span class="Li">&quot;Apache2::Const::MODE_EXHAUSTIVE&quot;</span>
    <p class="Pp">The filter read should be exhaustive and read until it can not
        read any more. Use this mode with extreme caution.</p>
  </li>
  <li><span class="Li">&quot;Apache2::Const::MODE_INIT&quot;</span>
    <p class="Pp">The filter should initialize the connection if needed, NNTP or
        FTP over SSL for example.</p>
  </li>
</ul>
<p class="Pp">Either compile all these constants with:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  use Apache2::Const -compile =&gt; qw(:input_mode);
</pre>
<p class="Pp">But it's a bit more efficient to compile only those constants that
    you need.</p>
<p class="Pp">Example:</p>
<p class="Pp">Here is a fragment of a filter handler, that receives a bucket
    brigade from the upstream filter:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  use Apache2::Filter ();
  use APR::Const    -compile =&gt; qw(SUCCESS);
  use Apache2::Const -compile =&gt; qw(OK);
  sub filter {
      my ($f, $bb, $mode, $block, $readbytes) = @_;
      
      my $rc = $f-&gt;next-&gt;get_brigade($bb, $mode, $block, $readbytes);
      return $rc unless $rc == APR::Const::SUCCESS;
      
      # ... process $bb
      
      return Apache2::Const::OK;
  }
</pre>
<p class="Pp">Usually arguments <span class="Li">$mode</span>,
    <span class="Li">$block</span>, <span class="Li">$readbytes</span> are the
    same as passed to the filter itself.</p>
<p class="Pp">You can see that in case of a failure, the handler returns
    immediately with that failure code, which gets propagated to the downstream
    filter.</p>
<p class="Pp">If you decide not check the return code, you can write it as:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  sub filter {
      my ($f, $bb, $mode, $block, $readbytes) = @_;
      
      $f-&gt;next-&gt;get_brigade($bb, $mode, $block, $readbytes);
      
      # ... process $bb
      
      return Apache2::Const::OK;
  }
</pre>
<p class="Pp">and the error checking will be done on your behalf.</p>
<p class="Pp">You will find many more examples in <span class="Li">&quot;the
    filter</span>
    <span class="Li">handlers|docs::2.0::user::handlers::filters&quot;</span>
    and <span class="Li">&quot;the protocol</span>
    <span class="Li">handlers|docs::2.0::user::handlers::protocols&quot;</span>
    tutorials.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_pass_brigade_"><a class="permalink" href="#_pass_brigade_">&quot;pass_brigade&quot;</a></h2>
This is a method to use in bucket brigade output filters. It passes the current
  bucket brigade to the downstream output filter.
<p class="Pp"><span class="Li"></span></p>
<pre>
  $rc = $next_f-&gt;pass_brigade($bb);
</pre>
<dl class="Bl-tag">
  <dt>obj: $next_f ( &quot;Apache2::Filter object&quot; )</dt>
  <dd>The next filter in the filter chain.
    <p class="Pp">Inside output filter handlers it's usually
        <span class="Li">&quot;$f-&gt;next&quot;</span>. Inside protocol
        handlers: <span class="Li">&quot;$c-&gt;output_filters&quot;</span>.</p>
  </dd>
  <dt>arg1: $bb ( &quot;APR::Brigade object&quot; )</dt>
  <dd>The bucket brigade to pass.
    <p class="Pp">Inside output filter handlers it's usually the second argument
        to the filter handler (after potential manipulations).</p>
  </dd>
  <dt>ret: $rc ( &quot;APR::Const status constant&quot; )</dt>
  <dd>On success, <span class="Li">&quot;APR::Const::SUCCESS&quot;</span> is
      returned.
    <p class="Pp">In case of a failure -- a failure code is returned, in which
        case normally it should be returned to the caller.</p>
    <p class="Pp">If the bottom-most filter doesn't write to the network, then
        <span class="Li">&quot;Apache2::NOBODY_WROTE&quot;</span> is returned
        (META: need to add this constant).</p>
    <p class="Pp">Also refer to the
        <span class="Li">&quot;get_brigade()&quot;</span> entry to see how to
        avoid checking the errors explicitly.</p>
  </dd>
  <dt>excpt: &quot;APR::Error&quot;</dt>
  <dd>Exceptions are thrown only when this function is called in the VOID
      context. Refer to the <span class="Li">&quot;get_brigade()&quot;</span>
      entry for details.</dd>
  <dt>since: 2.0.00</dt>
  <dd></dd>
</dl>
<p class="Pp">The caller relinquishes ownership of the brigade (i.e. it may get
    destroyed/overwritten/etc. by the callee).</p>
<p class="Pp">Example:</p>
<p class="Pp">Here is a fragment of a filter handler, that passes a bucket
    brigade to the downstream filter (after some potential processing of the
    buckets in the bucket brigade):</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  use Apache2::Filter ();
  use APR::Const    -compile =&gt; qw(SUCCESS);
  use Apache2::Const -compile =&gt; qw(OK);
  sub filter {
      my ($f, $bb) = @_;
  
      # ... process $bb
  
      my $rc = $f-&gt;next-&gt;pass_brigade($bb);
      return $rc unless $rc == APR::Const::SUCCESS;
  
      return Apache2::Const::OK;
  }
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="Streaming_Filter_API"><a class="permalink" href="#Streaming_Filter_API">Streaming
  Filter API</a></h1>
The following methods can be called from any filter, which uses the simplified
  streaming functionality:
<section class="Ss">
<h2 class="Ss" id="_print_"><a class="permalink" href="#_print_">&quot;print&quot;</a></h2>
Send the contents of <span class="Li">$buffer</span> to the next filter in chain
  (via internal buffer).
<p class="Pp"><span class="Li"></span></p>
<pre>
  $sent = $f-&gt;print($buffer);
</pre>
<dl class="Bl-tag">
  <dt>obj: $f ( &quot;Apache2::Filter object&quot; )</dt>
  <dd></dd>
  <dt>arg1: $buffer ( string )</dt>
  <dd>The data to send.</dd>
  <dt>ret: $sent ( integer )</dt>
  <dd>How many characters were sent. There is no need to check, since all should
      go through and if something goes work an exception will be thrown.</dd>
  <dt>excpt: &quot;APR::Error&quot;</dt>
  <dd></dd>
  <dt>since: 2.0.00</dt>
  <dd></dd>
</dl>
<p class="Pp">This method should be used only in streaming filters.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_read_"><a class="permalink" href="#_read_">&quot;read&quot;</a></h2>
Read data from the filter
<p class="Pp"><span class="Li"></span></p>
<pre>
  $read = $f-&gt;read($buffer, $wanted);
</pre>
<dl class="Bl-tag">
  <dt>obj: $f ( &quot;Apache2::Filter object&quot; )</dt>
  <dd></dd>
  <dt>arg1: $buffer ( SCALAR )</dt>
  <dd>The buffer to fill. All previous data will be lost.</dd>
  <dt>opt arg2: $wanted ( integer )</dt>
  <dd>How many bytes to attempt to read.
    <p class="Pp">If this optional argument is not specified -- the default 8192
        will be used.</p>
  </dd>
  <dt>ret: $read ( integer )</dt>
  <dd>How many bytes were actually read.
    <p class="Pp"><span class="Li">$buffer</span> gets populated with the string
        that is read. It will contain an empty string if there was nothing to
        read.</p>
  </dd>
  <dt>excpt: &quot;APR::Error&quot;</dt>
  <dd></dd>
  <dt>since: 2.0.00</dt>
  <dd></dd>
</dl>
<p class="Pp">Reads at most <span class="Li">$wanted</span> characters into
    <span class="Li">$buffer</span>. The returned value
    <span class="Li">$read</span> tells exactly how many were read, making it
    easy to use it in a while loop:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  while ($filter-&gt;read(my $buffer, $wanted)) {
      # transform $buffer here
      $filter-&gt;print($buffer);
  }
</pre>
<p class="Pp">This is a streaming filter method, which acquires a single bucket
    brigade behind the scenes and reads data from all its buckets. Therefore it
    can only read from one bucket brigade per filter invocation.</p>
<p class="Pp">If the EOS bucket is read, the
    <span class="Li">&quot;seen_eos&quot;</span> method will return a true
    value.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_seen_eos_"><a class="permalink" href="#_seen_eos_">&quot;seen_eos&quot;</a></h2>
This methods returns a true value when the EOS bucket is seen by the
  <span class="Li">&quot;read&quot;</span> method.
<p class="Pp"><span class="Li"></span></p>
<pre>
  $ok = $f-&gt;seen_eos;
</pre>
<dl class="Bl-tag">
  <dt>obj: $f ( &quot;Apache2::Filter object&quot; )</dt>
  <dd>The filter to remove</dd>
  <dt>ret: $ok ( boolean )</dt>
  <dd>a true value if EOS has been seen, otherwise a false value</dd>
  <dt>since: 2.0.00</dt>
  <dd></dd>
</dl>
<p class="Pp">This method only works in streaming filters which exhaustively
    <span class="Li">&quot;$f-&gt;read&quot;</span> all the incoming data in a
    while loop, like so:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
      while ($f-&gt;read(my $buffer, $wanted)) {
          # do something with $buffer
      }
      if ($f-&gt;seen_eos) {
          # do something
      }
</pre>
<p class="Pp">The technique in this example is useful when a streaming filter
    wants to append something to the very end of data, or do something at the
    end of the last filter invocation. After the EOS bucket is read, the filter
    should expect not to be invoked again.</p>
<p class="Pp">If an input streaming filter doesn't consume all data in the
    bucket brigade (or even in several bucket brigades), it has to generate the
    EOS event by itself. So when the filter is done it has to set the EOS
  flag:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  $f-&gt;seen_eos(1);
</pre>
<p class="Pp">when the filter handler returns, internally mod_perl will take
    care of creating and sending the EOS bucket to the upstream input
  filter.</p>
<p class="Pp">A similar logic may apply for output filters.</p>
<p class="Pp">In most other cases you shouldn't set this flag. When this flag is
    prematurely set (before the real EOS bucket has arrived) in the current
    filter invocation, instead of invoking the filter again, mod_perl will
    create and send the EOS bucket to the next filter, ignoring any other bucket
    brigades that may have left to consume. As mentioned earlier this special
    behavior is useful in writing special tests that test abnormal
  situations.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="Other_Filter-related_API"><a class="permalink" href="#Other_Filter-related_API">Other
  Filter-related API</a></h1>
Other methods which affect filters, but called on
  non-<span class="Li">&quot;Apache2::Filter&quot;</span> objects:
<section class="Ss">
<h2 class="Ss" id="_add_input_filter_"><a class="permalink" href="#_add_input_filter_">&quot;add_input_filter&quot;</a></h2>
Add <span class="Li">&amp;callback</span> filter handler to input request filter
  chain.
<p class="Pp"><span class="Li"></span></p>
<pre>
  $r-&gt;add_input_filter(\&amp;callback);
</pre>
<p class="Pp">Add <span class="Li">&amp;callback</span> filter handler to input
    connection filter chain.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  $c-&gt;add_input_filter(\&amp;callback);
</pre>
<dl class="Bl-tag">
  <dt>obj: $c ( &quot;Apache2::Connection object&quot; ) or $r (
    &quot;Apache2::RequestRec object&quot; )</dt>
  <dd></dd>
  <dt>arg1: &amp;callback (CODE ref)</dt>
  <dd></dd>
  <dt>ret: no return value</dt>
  <dd></dd>
  <dt>since: 2.0.00</dt>
  <dd></dd>
</dl>
<p class="Pp">[META: It seems that you can't add a filter when another filter is
    called. I've tried to add an output connection filter from the input
    connection filter when it was called for the first time. It didn't have any
    affect for the first request (over keepalive connection). The only way I
    succeeded to do that is from that input connection filter's filter_init
    handler. In fact it does work if there is any filter additional filter of
    the same kind configured from httpd.conf or via filter_init. It looks like
    there is a bug in httpd, where it doesn't prepare the chain of 3rd party
    filter if none were inserted before the first filter was called.]</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_add_output_filter_"><a class="permalink" href="#_add_output_filter_">&quot;add_output_filter&quot;</a></h2>
Add <span class="Li">&amp;callback</span> filter handler to output request
  filter chain.
<p class="Pp"><span class="Li"></span></p>
<pre>
  $r-&gt;add_output_filter(\&amp;callback);
</pre>
<p class="Pp">Add <span class="Li">&amp;callback</span> filter handler to output
    connection filter chain.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  $c-&gt;add_output_filter(\&amp;callback);
</pre>
<dl class="Bl-tag">
  <dt>obj: $c ( &quot;Apache2::Connection object&quot; ) or $r (
    &quot;Apache2::RequestRec object&quot; )</dt>
  <dd></dd>
  <dt>arg1: &amp;callback (CODE ref)</dt>
  <dd></dd>
  <dt>ret: no return value</dt>
  <dd></dd>
  <dt>since: 2.0.00</dt>
  <dd></dd>
</dl>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="Filter_Handler_Attributes"><a class="permalink" href="#Filter_Handler_Attributes">Filter
  Handler Attributes</a></h1>
Packages using filter attributes have to subclass
  <span class="Li">&quot;Apache2::Filter&quot;</span>:
<p class="Pp"><span class="Li"></span></p>
<pre>
  package MyApache2::FilterCool;
  use base qw(Apache2::Filter);
</pre>
<p class="Pp">Attributes are parsed during the code compilation, by the function
    <span class="Li">&quot;MODIFY_CODE_ATTRIBUTES&quot;</span>, inherited from
    the <span class="Li">&quot;Apache2::Filter&quot;</span> package.</p>
<section class="Ss">
<h2 class="Ss" id="_FilterRequestHandler_"><a class="permalink" href="#_FilterRequestHandler_">&quot;FilterRequestHandler&quot;</a></h2>
The <span class="Li">&quot;FilterRequestHandler&quot;</span> attribute tells
  mod_perl to insert the filter into an HTTP request filter chain.
<p class="Pp">For example, to configure an output request filter handler, use
    the <span class="Li">&quot;FilterRequestHandler&quot;</span> attribute in
    the handler subroutine's declaration:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  package MyApache2::FilterOutputReq;
  sub handler : FilterRequestHandler { ... }
</pre>
<p class="Pp">and add the configuration entry:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  PerlOutputFilterHandler MyApache2::FilterOutputReq
</pre>
<p class="Pp">This is the default mode. So if you are writing an HTTP request
    filter, you don't have to specify this attribute.</p>
<p class="Pp">The section HTTP Request vs. Connection Filters delves into more
    details.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_FilterConnectionHandler_"><a class="permalink" href="#_FilterConnectionHandler_">&quot;FilterConnectionHandler&quot;</a></h2>
The <span class="Li">&quot;FilterConnectionHandler&quot;</span> attribute tells
  mod_perl to insert this filter into a connection filter chain.
<p class="Pp">For example, to configure an output connection filter handler, use
    the <span class="Li">&quot;FilterConnectionHandler&quot;</span> attribute in
    the handler subroutine's declaration:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  package MyApache2::FilterOutputCon;
  sub handler : FilterConnectionHandler { ... }
</pre>
<p class="Pp">and add the configuration entry:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  PerlOutputFilterHandler MyApache2::FilterOutputCon
</pre>
<p class="Pp">The section HTTP Request vs. Connection Filters delves into more
    details.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_FilterInitHandler_"><a class="permalink" href="#_FilterInitHandler_">&quot;FilterInitHandler&quot;</a></h2>
The attribute <span class="Li">&quot;FilterInitHandler&quot;</span> marks the
  function suitable to be used as a filter initialization callback, which is
  called immediately after a filter is inserted to the filter chain and before
  it's actually called.
<p class="Pp"><span class="Li"></span></p>
<pre>
  sub init : FilterInitHandler {
      my $f = shift;
      #...
      return Apache2::Const::OK;
  }
</pre>
<p class="Pp">In order to hook this filter callback, the real filter has to
    assign this callback using the
    <span class="Li">&quot;FilterHasInitHandler&quot;</span> which accepts a
    reference to the callback function.</p>
<p class="Pp">For further discussion and examples refer to the Filter
    Initialization Phase tutorial section.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_FilterHasInitHandler_"><a class="permalink" href="#_FilterHasInitHandler_">&quot;FilterHasInitHandler&quot;</a></h2>
If a filter wants to run an initialization callback it can register such using
  the <span class="Li">&quot;FilterHasInitHandler&quot;</span> attribute.
  Similar to <span class="Li">&quot;push_handlers&quot;</span> the callback
  reference is expected, rather than a callback name. The used callback function
  has to have the <span class="Li">&quot;FilterInitHandler&quot;</span>
  attribute. For example:
<p class="Pp"><span class="Li"></span></p>
<pre>
  package MyApache2::FilterBar;
  use base qw(Apache2::Filter);
  sub init   : FilterInitHandler { ... }
  sub filter : FilterRequestHandler FilterHasInitHandler(\&amp;init) {
      my ($f, $bb) = @_;
      # ...
      return Apache2::Const::OK;
  }
</pre>
<p class="Pp">For further discussion and examples refer to the Filter
    Initialization Phase tutorial section.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="Configuration"><a class="permalink" href="#Configuration">Configuration</a></h1>
mod_perl 2.0 filters configuration is explained in the filter handlers tutorial.
<section class="Ss">
<h2 class="Ss" id="_PerlInputFilterHandler_"><a class="permalink" href="#_PerlInputFilterHandler_">&quot;PerlInputFilterHandler&quot;</a></h2>
See <span class="Li">&quot;PerlInputFilterHandler&quot;</span>.
</section>
<section class="Ss">
<h2 class="Ss" id="_PerlOutputFilterHandler_"><a class="permalink" href="#_PerlOutputFilterHandler_">&quot;PerlOutputFilterHandler&quot;</a></h2>
See <span class="Li">&quot;PerlOutputFilterHandler&quot;</span>.
</section>
<section class="Ss">
<h2 class="Ss" id="_PerlSetInputFilter_"><a class="permalink" href="#_PerlSetInputFilter_">&quot;PerlSetInputFilter&quot;</a></h2>
See <span class="Li">&quot;PerlSetInputFilter&quot;</span>.
</section>
<section class="Ss">
<h2 class="Ss" id="_PerlSetOutputFilter_"><a class="permalink" href="#_PerlSetOutputFilter_">&quot;PerlSetOutputFilter&quot;</a></h2>
See <span class="Li">&quot;PerlSetInputFilter&quot;</span>.
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="TIE_Interface"><a class="permalink" href="#TIE_Interface">TIE
  Interface</a></h1>
<span class="Li">&quot;Apache2::Filter&quot;</span> also implements a tied
  interface, so you can work with the <span class="Li">$f</span> object as a
  hash reference.
<p class="Pp">The TIE interface is mostly unimplemented and might be implemented
    post 2.0 release.</p>
<section class="Ss">
<h2 class="Ss" id="_TIEHANDLE_"><a class="permalink" href="#_TIEHANDLE_">&quot;TIEHANDLE&quot;</a></h2>
<span class="Li"></span>
<pre>
  $ret = TIEHANDLE($stashsv, $sv);
</pre>
<dl class="Bl-tag">
  <dt>obj: $stashsv ( SCALAR )</dt>
  <dd></dd>
  <dt>arg1: $sv ( SCALAR )</dt>
  <dd></dd>
  <dt>ret: $ret ( SCALAR )</dt>
  <dd></dd>
  <dt>since: subject to change</dt>
  <dd></dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="_PRINT_"><a class="permalink" href="#_PRINT_">&quot;PRINT&quot;</a></h2>
<span class="Li"></span>
<pre>
  $ret = PRINT(...);
</pre>
<dl class="Bl-tag">
  <dt>obj: &quot;...&quot; (XXX)</dt>
  <dd></dd>
  <dt>ret: $ret ( integer )</dt>
  <dd></dd>
  <dt>since: subject to change</dt>
  <dd></dd>
</dl>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="See_Also"><a class="permalink" href="#See_Also">See
  Also</a></h1>
mod_perl 2.0 documentation.
</section>
<section class="Sh">
<h1 class="Sh" id="Copyright"><a class="permalink" href="#Copyright">Copyright</a></h1>
mod_perl 2.0 and its core modules are copyrighted under The Apache Software
  License, Version 2.0.
</section>
<section class="Sh">
<h1 class="Sh" id="Authors"><a class="permalink" href="#Authors">Authors</a></h1>
The mod_perl development team and numerous contributors.
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2015-06-18</td>
    <td class="foot-os">perl v5.28.2</td>
  </tr>
</table>
</body>
</html>
