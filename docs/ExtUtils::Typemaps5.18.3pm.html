<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>ExtUtils::Typemaps(3pm)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">ExtUtils::Typemaps(3pm)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">ExtUtils::Typemaps(3pm)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
ExtUtils::Typemaps - Read/Write/Modify Perl/XS typemap files
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<span class="Li"></span>
<pre>
  # read/create file
  my $typemap = ExtUtils::Typemaps-&gt;new(file =&gt; 'typemap');
  # alternatively create an in-memory typemap
  # $typemap = ExtUtils::Typemaps-&gt;new();
  # alternatively create an in-memory typemap by parsing a string
  # $typemap = ExtUtils::Typemaps-&gt;new(string =&gt; $sometypemap);

  # add a mapping
  $typemap-&gt;add_typemap(ctype =&gt; 'NV', xstype =&gt; 'T_NV');
  $typemap-&gt;add_inputmap(
     xstype =&gt; 'T_NV', code =&gt; '$var = ($type)SvNV($arg);'
  );
  $typemap-&gt;add_outputmap(
     xstype =&gt; 'T_NV', code =&gt; 'sv_setnv($arg, (NV)$var);'
  );
  $typemap-&gt;add_string(string =&gt; $typemapstring);
                                           # will be parsed and merged

  # remove a mapping (same for remove_typemap and remove_outputmap...)
  $typemap-&gt;remove_inputmap(xstype =&gt; 'SomeType');

  # save a typemap to a file
  $typemap-&gt;write(file =&gt; 'anotherfile.map');

  # merge the other typemap into this one
  $typemap-&gt;merge(typemap =&gt; $another_typemap);
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
This module can read, modify, create and write Perl XS typemap files. If you
  don't know what a typemap is, please confer the perlxstut and perlxs manuals.
<p class="Pp">The module is not entirely round-trip safe: For example it
    currently simply strips all comments. The order of entries in the maps is,
    however, preserved.</p>
<p class="Pp">We check for duplicate entries in the typemap, but do not check
    for missing <span class="Li">&quot;TYPEMAP&quot;</span> entries for
    <span class="Li">&quot;INPUTMAP&quot;</span> or
    <span class="Li">&quot;OUTPUTMAP&quot;</span> entries since these might be
    hidden in a different typemap.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="METHODS"><a class="permalink" href="#METHODS">METHODS</a></h1>
<section class="Ss">
<h2 class="Ss" id="new"><a class="permalink" href="#new">new</a></h2>
Returns a new typemap object. Takes an optional
  <span class="Li">&quot;file&quot;</span> parameter. If set, the given file
  will be read. If the file doesn't exist, an empty typemap is returned.
<p class="Pp">Alternatively, if the <span class="Li">&quot;string&quot;</span>
    parameter is given, the supplied string will be parsed instead of a
  file.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="file"><a class="permalink" href="#file">file</a></h2>
Get/set the file that the typemap is written to when the
  <span class="Li">&quot;write&quot;</span> method is called.
</section>
<section class="Ss">
<h2 class="Ss" id="add_typemap"><a class="permalink" href="#add_typemap">add_typemap</a></h2>
Add a <span class="Li">&quot;TYPEMAP&quot;</span> entry to the typemap.
<p class="Pp">Required named arguments: The
    <span class="Li">&quot;ctype&quot;</span> (e.g. <span class="Li">&quot;ctype
    =&gt; 'double'&quot;</span>) and the
    <span class="Li">&quot;xstype&quot;</span> (e.g.
    <span class="Li">&quot;xstype =&gt; 'T_NV'&quot;</span>).</p>
<p class="Pp">Optional named arguments: <span class="Li">&quot;replace =&gt;
    1&quot;</span> forces removal/replacement of existing
    <span class="Li">&quot;TYPEMAP&quot;</span> entries of the same
    <span class="Li">&quot;ctype&quot;</span>. <span class="Li">&quot;skip =&gt;
    1&quot;</span> triggers a <i>&quot;first come first serve&quot;</i> logic by
    which new entries that conflict with existing entries are silently
  ignored.</p>
<p class="Pp">As an alternative to the named parameters usage, you may pass in
    an <span class="Li">&quot;ExtUtils::Typemaps::Type&quot;</span> object as
    first argument, a copy of which will be added to the typemap. In that case,
    only the <span class="Li">&quot;replace&quot;</span> or
    <span class="Li">&quot;skip&quot;</span> named parameters may be used after
    the object. Example:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  $map-&gt;add_typemap($type_obj, replace =&gt; 1);
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="add_inputmap"><a class="permalink" href="#add_inputmap">add_inputmap</a></h2>
Add an <span class="Li">&quot;INPUT&quot;</span> entry to the typemap.
<p class="Pp">Required named arguments: The
    <span class="Li">&quot;xstype&quot;</span> (e.g.
    <span class="Li">&quot;xstype =&gt; 'T_NV'&quot;</span>) and the
    <span class="Li">&quot;code&quot;</span> to associate with it for input.</p>
<p class="Pp">Optional named arguments: <span class="Li">&quot;replace =&gt;
    1&quot;</span> forces removal/replacement of existing
    <span class="Li">&quot;INPUT&quot;</span> entries of the same
    <span class="Li">&quot;xstype&quot;</span>. <span class="Li">&quot;skip
    =&gt; 1&quot;</span> triggers a <i>&quot;first come first serve&quot;</i>
    logic by which new entries that conflict with existing entries are silently
    ignored.</p>
<p class="Pp">As an alternative to the named parameters usage, you may pass in
    an <span class="Li">&quot;ExtUtils::Typemaps::InputMap&quot;</span> object
    as first argument, a copy of which will be added to the typemap. In that
    case, only the <span class="Li">&quot;replace&quot;</span> or
    <span class="Li">&quot;skip&quot;</span> named parameters may be used after
    the object. Example:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  $map-&gt;add_inputmap($type_obj, replace =&gt; 1);
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="add_outputmap"><a class="permalink" href="#add_outputmap">add_outputmap</a></h2>
Add an <span class="Li">&quot;OUTPUT&quot;</span> entry to the typemap. Works
  exactly the same as <span class="Li">&quot;add_inputmap&quot;</span>.
</section>
<section class="Ss">
<h2 class="Ss" id="add_string"><a class="permalink" href="#add_string">add_string</a></h2>
Parses a string as a typemap and merge it into the typemap object.
<p class="Pp">Required named argument:
    <span class="Li">&quot;string&quot;</span> to specify the string to
  parse.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="remove_typemap"><a class="permalink" href="#remove_typemap">remove_typemap</a></h2>
Removes a <span class="Li">&quot;TYPEMAP&quot;</span> entry from the typemap.
<p class="Pp">Required named argument: <span class="Li">&quot;ctype&quot;</span>
    to specify the entry to remove from the typemap.</p>
<p class="Pp">Alternatively, you may pass a single
    <span class="Li">&quot;ExtUtils::Typemaps::Type&quot;</span> object.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="remove_inputmap"><a class="permalink" href="#remove_inputmap">remove_inputmap</a></h2>
Removes an <span class="Li">&quot;INPUT&quot;</span> entry from the typemap.
<p class="Pp">Required named argument:
    <span class="Li">&quot;xstype&quot;</span> to specify the entry to remove
    from the typemap.</p>
<p class="Pp">Alternatively, you may pass a single
    <span class="Li">&quot;ExtUtils::Typemaps::InputMap&quot;</span> object.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="remove_inputmap_2"><a class="permalink" href="#remove_inputmap_2">remove_inputmap</a></h2>
Removes an <span class="Li">&quot;OUTPUT&quot;</span> entry from the typemap.
<p class="Pp">Required named argument:
    <span class="Li">&quot;xstype&quot;</span> to specify the entry to remove
    from the typemap.</p>
<p class="Pp">Alternatively, you may pass a single
    <span class="Li">&quot;ExtUtils::Typemaps::OutputMap&quot;</span>
  object.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="get_typemap"><a class="permalink" href="#get_typemap">get_typemap</a></h2>
Fetches an entry of the TYPEMAP section of the typemap.
<p class="Pp">Mandatory named arguments: The
    <span class="Li">&quot;ctype&quot;</span> of the entry.</p>
<p class="Pp">Returns the
    <span class="Li">&quot;ExtUtils::Typemaps::Type&quot;</span> object for the
    entry if found.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="get_inputmap"><a class="permalink" href="#get_inputmap">get_inputmap</a></h2>
Fetches an entry of the INPUT section of the typemap.
<p class="Pp">Mandatory named arguments: The
    <span class="Li">&quot;xstype&quot;</span> of the entry or the
    <span class="Li">&quot;ctype&quot;</span> of the typemap that can be used to
    find the <span class="Li">&quot;xstype&quot;</span>. To wit, the following
    pieces of code are equivalent:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  my $type = $typemap-&gt;get_typemap(ctype =&gt; $ctype)
  my $input_map = $typemap-&gt;get_inputmap(xstype =&gt; $type-&gt;xstype);

  my $input_map = $typemap-&gt;get_inputmap(ctype =&gt; $ctype);
</pre>
<p class="Pp">Returns the
    <span class="Li">&quot;ExtUtils::Typemaps::InputMap&quot;</span> object for
    the entry if found.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="get_outputmap"><a class="permalink" href="#get_outputmap">get_outputmap</a></h2>
Fetches an entry of the OUTPUT section of the typemap.
<p class="Pp">Mandatory named arguments: The
    <span class="Li">&quot;xstype&quot;</span> of the entry or the
    <span class="Li">&quot;ctype&quot;</span> of the typemap that can be used to
    resolve the <span class="Li">&quot;xstype&quot;</span>. (See above for an
    example.)</p>
<p class="Pp">Returns the
    <span class="Li">&quot;ExtUtils::Typemaps::InputMap&quot;</span> object for
    the entry if found.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="write"><a class="permalink" href="#write">write</a></h2>
Write the typemap to a file. Optionally takes a
  <span class="Li">&quot;file&quot;</span> argument. If given, the typemap will
  be written to the specified file. If not, the typemap is written to the
  currently stored file name (see <span class="Li">&quot;-&gt;file&quot;</span>
  above, this defaults to the file it was read from if any).
</section>
<section class="Ss">
<h2 class="Ss" id="as_string"><a class="permalink" href="#as_string">as_string</a></h2>
Generates and returns the string form of the typemap.
</section>
<section class="Ss">
<h2 class="Ss" id="as_embedded_typemap"><a class="permalink" href="#as_embedded_typemap">as_embedded_typemap</a></h2>
Generates and returns the string form of the typemap with the appropriate prefix
  around it for verbatim inclusion into an XS file as an embedded typemap. This
  will return a string like
<p class="Pp"><span class="Li"></span></p>
<pre>
  TYPEMAP: &lt;&lt;END_OF_TYPEMAP
  ... typemap here (see as_string) ...
  END_OF_TYPEMAP
</pre>
<p class="Pp">The method takes care not to use a HERE-doc end marker that
    appears in the typemap string itself.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="merge"><a class="permalink" href="#merge">merge</a></h2>
Merges a given typemap into the object. Note that a failed merge operation
  leaves the object in an inconsistent state so clone it if necessary.
<p class="Pp">Mandatory named arguments: Either <span class="Li">&quot;typemap
    =&gt; $another_typemap_obj&quot;</span> or <span class="Li">&quot;file =&gt;
    $path_to_typemap_file&quot;</span> but not both.</p>
<p class="Pp">Optional arguments: <span class="Li">&quot;replace =&gt;
    1&quot;</span> to force replacement of existing typemap entries without
    warning or <span class="Li">&quot;skip =&gt; 1&quot;</span> to skip entries
    that exist already in the typemap.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="is_empty"><a class="permalink" href="#is_empty">is_empty</a></h2>
Returns a bool indicating whether this typemap is entirely empty.
</section>
<section class="Ss">
<h2 class="Ss" id="list_mapped_ctypes"><a class="permalink" href="#list_mapped_ctypes">list_mapped_ctypes</a></h2>
Returns a list of the C types that are mappable by this typemap object.
</section>
<section class="Ss">
<h2 class="Ss" id="_get_typemap_hash"><a class="permalink" href="#_get_typemap_hash">_get_typemap_hash</a></h2>
Returns a hash mapping the C types to the XS types:
<p class="Pp"><span class="Li"></span></p>
<pre>
  {
    'char **' =&gt; 'T_PACKEDARRAY',
    'bool_t' =&gt; 'T_IV',
    'AV *' =&gt; 'T_AVREF',
    'InputStream' =&gt; 'T_IN',
    'double' =&gt; 'T_DOUBLE',
    # ...
  }
</pre>
<p class="Pp">This is documented because it is used by
    <span class="Li">&quot;ExtUtils::ParseXS&quot;</span>, but it's not intended
    for general consumption. May be removed at any time.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_get_inputmap_hash"><a class="permalink" href="#_get_inputmap_hash">_get_inputmap_hash</a></h2>
Returns a hash mapping the XS types (identifiers) to the corresponding INPUT
  code:
<p class="Pp"><span class="Li"></span></p>
<pre>
  {
    'T_CALLBACK' =&gt; '   $var = make_perl_cb_$type($arg)
  ',
    'T_OUT' =&gt; '    $var = IoOFP(sv_2io($arg))
  ',
    'T_REF_IV_PTR' =&gt; '   if (sv_isa($arg, \\&quot;${ntype}\\&quot;)) {
    # ...
  }
</pre>
<p class="Pp">This is documented because it is used by
    <span class="Li">&quot;ExtUtils::ParseXS&quot;</span>, but it's not intended
    for general consumption. May be removed at any time.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_get_outputmap_hash"><a class="permalink" href="#_get_outputmap_hash">_get_outputmap_hash</a></h2>
Returns a hash mapping the XS types (identifiers) to the corresponding OUTPUT
  code:
<p class="Pp"><span class="Li"></span></p>
<pre>
  {
    'T_CALLBACK' =&gt; '   sv_setpvn($arg, $var.context.value().chp(),
                $var.context.value().size());
  ',
    'T_OUT' =&gt; '    {
            GV *gv = newGVgen(&quot;$Package&quot;);
            if ( do_open(gv, &quot;+&gt;&amp;&quot;, 3, FALSE, 0, 0, $var) )
                sv_setsv(
                  $arg,
                  sv_bless(newRV((SV*)gv), gv_stashpv(&quot;$Package&quot;,1))
                );
            else
                $arg = &amp;PL_sv_undef;
         }
  ',
    # ...
  }
</pre>
<p class="Pp">This is documented because it is used by
    <span class="Li">&quot;ExtUtils::ParseXS&quot;</span>, but it's not intended
    for general consumption. May be removed at any time.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_get_prototype_hash"><a class="permalink" href="#_get_prototype_hash">_get_prototype_hash</a></h2>
Returns a hash mapping the C types of the typemap to their corresponding
  prototypes.
<p class="Pp"><span class="Li"></span></p>
<pre>
  {
    'char **' =&gt; '$',
    'bool_t' =&gt; '$',
    'AV *' =&gt; '$',
    'InputStream' =&gt; '$',
    'double' =&gt; '$',
    # ...
  }
</pre>
<p class="Pp">This is documented because it is used by
    <span class="Li">&quot;ExtUtils::ParseXS&quot;</span>, but it's not intended
    for general consumption. May be removed at any time.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="CAVEATS"><a class="permalink" href="#CAVEATS">CAVEATS</a></h1>
Inherits some evil code from
  <span class="Li">&quot;ExtUtils::ParseXS&quot;</span>.
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
The parser is heavily inspired from the one in ExtUtils::ParseXS.
<p class="Pp">For details on typemaps: perlxstut, perlxs.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
Steffen Mueller <span class="Li">&quot;&lt;smueller@cpan.org&quot;</span>&gt;
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT_&amp;_LICENSE"><a class="permalink" href="#COPYRIGHT_&amp;_LICENSE">COPYRIGHT
  &amp; LICENSE</a></h1>
Copyright 2009, 2010, 2011, 2012 Steffen Mueller
<p class="Pp">This program is free software; you can redistribute it and/or
    modify it under the same terms as Perl itself.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2014-09-30</td>
    <td class="foot-os">perl v5.18.4</td>
  </tr>
</table>
</body>
</html>
