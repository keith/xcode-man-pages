<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>Module::Package(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Module::Package(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Module::Package(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
In your <span class="Li">&quot;Makefile.PL&quot;</span>:
<p class="Pp"><span class="Li"></span></p>
<pre>
    use inc::Module::Package;
</pre>
<p class="Pp">or one of these invocations:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    # These two are functionally the same as above:
    use inc::Module::Package ':basic';
    use inc::Module::Package 'Plugin:basic';

    # With Module::Package::Catalyst plugin options
    use inc::Module::Package 'Catalyst';

    # With Module::Package::Catalyst::common inline plugin class
    use inc::Module::Package 'Catalyst:common';

    # Pass options to the Module::Package::Ingy::modern constructor
    use inc::Module::Package 'Ingy:modern',
        option1 =&gt; 'value1',
        option2 =&gt; 'value2';
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
This module is a dropin replacement for Module::Install. It does everything
  Module::Install does, but just a bit better.
<p class="Pp">Actually this module is simply a wrapper around Module::Install.
    It attempts to drastically reduce what goes in a Makefile.PL, while at the
    same time, fixing many of the problems that people have had with
    Module::Install (and other module frameworks) over the years.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="PROPAGANDA"><a class="permalink" href="#PROPAGANDA">PROPAGANDA</a></h1>
Module::Install took Makefile.PL authoring from a black art to a small set of
  powerful and reusable instructions. It allowed packaging gurus to take their
  fancy tricks and make them into one liners for the rest of us.
<p class="Pp">As the number of plugins has grown over the years, using
    Module::Install has itself become a bit of a black art. It's become hard to
    know all the latest tricks, put them in the correct order, and make sure you
    always use the correct sets for your various Perl modules.</p>
<p class="Pp">Added to this is the fact that there are a few problems in
    Module::Install design and general usage that are hard to fix and deploy
    with certainty that it will work in all cases.</p>
<p class="Pp">This is where Module::Package steps in. Module::Package is the
    next logical step in Makefile.PL authoring. It allows gurus to create well
    tested sets of Module::Install directives, and lets the rest of us use
    Makefile.PLs that are one line long. For example:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    use inc::Module::Package 'Catalyst:widget';
</pre>
<p class="Pp">could be the one line Makefile.PL for a Catalyst widget (whatever
    that is) module distribution. Assuming someone creates a module called
    Module::Package::Catalyst, with an inline class called
    Module::Package::Catalyst::widget that inherited from
    Module::Package::Plugin.</p>
<p class="Pp">Module::Package is pragmatic. Even though you can do everything in
    one line, you are still able to make any Module::Install calls as usual.
    Also you can pass parameters to the Module::Package plugin.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    use inc::Module::Package 'Catalyst:widget',
        deps_list =&gt; 0,
        some_cataylst_thing =&gt; '...';

    # All Module::Install plugins still work!
    requires 'Some::Module' =&gt; 3.14;
</pre>
<p class="Pp">This allows Module::Package::Catalyst to be configurable, even on
    the properties like <span class="Li">&quot;deps_list&quot;</span> that are
    inherited from Module::Package::Plugin.</p>
<p class="Pp">The point here is that with Module::Package, module packaging just
    got a whole lot more powerful and simple. A rare combination!</p>
</section>
<section class="Sh">
<h1 class="Sh" id="FEATURES"><a class="permalink" href="#FEATURES">FEATURES</a></h1>
Module::Package has many advantages over vanilla Module::Install.
<section class="Ss">
<h2 class="Ss" id="Smaller_Makefile.PL_Files"><a class="permalink" href="#Smaller_Makefile.PL_Files">Smaller
  Makefile.PL Files</a></h2>
In the majority of cases you can reduce your Makefile.PL to a single command.
  The core Module::Package invokes the Module::Install plugins that it thinks
  you want. You can also name the Module::Package plugin that does exactly the
  plugins you want.
</section>
<section class="Ss">
<h2 class="Ss" id="Reduces_Module::Install_Bloat"><a class="permalink" href="#Reduces_Module::Install_Bloat">Reduces
  Module::Install Bloat</a></h2>
Somewhere Module::Install development went awry, and allowed modules that only
  have useful code for an author, to be bundled into a distribution. Over time,
  this has created a lot of wasted space on CPAN mirrors. Module::Package fixes
  this.
</section>
<section class="Ss">
<h2 class="Ss" id="Collaborator_Plugin_Discovery"><a class="permalink" href="#Collaborator_Plugin_Discovery">Collaborator
  Plugin Discovery</a></h2>
An increasing problem with Module::Install is that when people check out your
  module source from a repository, they don't know which Module::Install plugin
  modules you have used. That's because the Makefile.PL only requires the
  function names, not the module names that they come from.
<p class="Pp">Many people have realized this problem, and worked around it in
    various suboptimal ways. Module::Package manages this problem for you.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Feature_Grouping_and_Reuse"><a class="permalink" href="#Feature_Grouping_and_Reuse">Feature
  Grouping and Reuse</a></h2>
Module::Install has lots of plugins. Although it is possible with plain
  Module::Install, nobody seems to make plugins that group other plugins. This
  also might introduce subtle problems of using groups with other groups.
<p class="Pp">Module::Package has object oriented plugins whose main purpose is
    to create these groups. They inherit base functionality, subclass it to
    their design goals and can define options for the user to tweak how they
    will operate.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="USAGE"><a class="permalink" href="#USAGE">USAGE</a></h1>
The basic anatomy of a Makefile.PL call to Module::Package is:
<p class="Pp"><span class="Li"></span></p>
<pre>
    use inc::Module::Package 'PluginName:flavor &lt;version&gt;',
        $option1 =&gt; $value1;
</pre>
<p class="Pp">The <span class="Li">&quot;inc::Module::Package&quot;</span> part
    uses the Module::Install <span class="Li">&quot;inc&quot;</span>
    bootstrapping trick.</p>
<p class="Pp"><span class="Li">&quot;PluginName:flavor&quot;</span> (note the
    single ':') resolves to the inline class
    <span class="Li">&quot;Module::Package::PluginName::flavor&quot;</span>,
    within the module
    <span class="Li">&quot;Module::Package::PluginName&quot;</span>.
    Module::Package::PluginName::flavor must be a subclass of
    Module::Package::Plugin.</p>
<p class="Pp">An optional version can be used after the plugin name.</p>
<p class="Pp">Optional key/value pairs can follow the Plugin specification. They
    are used to pass information to the plugin. See Plugin docs for more
    details.</p>
<p class="Pp">If <span class="Li">&quot;:flavor&quot;</span> is omitted, the
    class Module::Package::PluginName is used. The idea is that you can create a
    single module with many different plugin styles.</p>
<p class="Pp">If <span class="Li">&quot;PluginName&quot;</span> is omitted, then
    <span class="Li">&quot;:flavor&quot;</span> is used against
    Module::Package::Plugin. These are a set of common plugin classes that you
    can use.</p>
<p class="Pp">If <span class="Li">&quot;PluginName:flavor&quot;</span> is
    omitted altogether, it is the same as saying 'Plugin:basic'. Note that you
    need to specify the ':basic' plugin if you want to also pass it options.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="STATUS"><a class="permalink" href="#STATUS">STATUS</a></h1>
This is still an early release. We are still shaking out the bugs. You might
  want to hold off for a bit longer before using Module::Package for important
  modules.
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2011-10-06</td>
    <td class="foot-os">perl v5.30.2</td>
  </tr>
</table>
</body>
</html>
