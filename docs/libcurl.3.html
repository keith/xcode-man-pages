<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   generated by cd2nroff 0.1 from libcurl.md
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    .Nd, .Bf, .Op { display: inline; }
    .Pa, .Ad { font-style: italic; }
    .Ms { font-weight: bold; }
    .Bl-diag > dt { font-weight: bold; }
    code.Nm, .Fl, .Cm, .Ic, code.In, .Fd, .Fn, .Cd { font-weight: bold;
      font-family: inherit; }
  </style>
  <title>libcurl(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">libcurl(3)</td>
    <td class="head-vol">Library Functions Manual</td>
    <td class="head-rtitle">libcurl(3)</td>
  </tr>
</table>
<div class="manual-text">
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">libcurl - client-side URL transfers</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">This is a short overview on how to use libcurl in your C programs.
    There are specific man pages for each function mentioned in here. See
    <i>libcurl-easy(3)</i>, <i>libcurl-multi(3)</i>, <i>libcurl-share(3)</i>,
    <i>libcurl-url(3)</i>, <i>libcurl-ws(3)</i> and <i>libcurl-tutorial(3)</i>
    for in-depth understanding on how to program with libcurl.</p>
<p class="Pp">There are many bindings available that bring libcurl access to
    your favorite language. Look elsewhere for documentation on those.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="TRANSFERS"><a class="permalink" href="#TRANSFERS">TRANSFERS</a></h1>
<p class="Pp">To transfer files, you create an &quot;easy handle&quot; using
    <i>curl_easy_init(3)</i> for a single individual transfer (in either
    direction). You then set your desired set of options in that handle with
    <i>curl_easy_setopt(3)</i>. Options you set with <i>curl_easy_setopt(3)</i>
    stick. They are then used for every repeated use of this handle until you
    either change the option, or you reset them all with
    <i>curl_easy_reset(3)</i>.</p>
<p class="Pp">To actually transfer data you have the option of using the
    &quot;easy&quot; interface, or the &quot;multi&quot; interface.</p>
<p class="Pp">The easy interface is a synchronous interface with which you call
    <i>curl_easy_perform(3)</i> and let it perform the transfer. When it is
    completed, the function returns and you can continue. More details are found
    in the <i>libcurl-easy(3)</i> man page.</p>
<p class="Pp">The multi interface on the other hand is an asynchronous
    interface, that you call and that performs only a little piece of the
    transfer on each invoke. It is perfect if you want to do things while the
    transfer is in progress, or similar. The multi interface allows you to
    select() on libcurl action, and even to easily download multiple files
    simultaneously using a single thread. See further details in the
    <i>libcurl-multi(3)</i> man page.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SUPPORT_INTERFACES"><a class="permalink" href="#SUPPORT_INTERFACES">SUPPORT
  INTERFACES</a></h1>
<p class="Pp">There is also a series of other helpful functions and interface
    families to use, including these:</p>
<dl class="Bl-tag">
  <dt id="curl_version_info()"><a class="permalink" href="#curl_version_info()">curl_version_info()</a></dt>
  <dd>gets detailed libcurl (and other used libraries) version info. See
      <i>curl_version_info(3)</i></dd>
  <dt id="curl_getdate()"><a class="permalink" href="#curl_getdate()">curl_getdate()</a></dt>
  <dd>converts a date string to time_t. See <i>curl_getdate(3)</i></dd>
  <dt id="curl_easy_getinfo()"><a class="permalink" href="#curl_easy_getinfo()">curl_easy_getinfo()</a></dt>
  <dd>get information about a performed transfer. See
      <i>curl_easy_getinfo(3)</i></dd>
  <dt id="curl_mime_addpart()"><a class="permalink" href="#curl_mime_addpart()">curl_mime_addpart()</a></dt>
  <dd>helps building an HTTP form POST. See <i>curl_mime_addpart(3)</i></dd>
  <dt id="curl_slist_append()"><a class="permalink" href="#curl_slist_append()">curl_slist_append()</a></dt>
  <dd>builds a linked list. See <i>curl_slist_append(3)</i></dd>
  <dt id="Sharing"><a class="permalink" href="#Sharing">Sharing data between
    transfers</a></dt>
  <dd>You can have multiple easy handles share certain data, even if they are
      used in different threads. This magic is setup using the share interface,
      as described in the <i>libcurl-share(3)</i> man page.</dd>
  <dt id="URL"><a class="permalink" href="#URL">URL Parsing</a></dt>
  <dd>URL parsing and manipulations. See <i>libcurl-url(3)</i></dd>
  <dt id="WebSocket"><a class="permalink" href="#WebSocket">WebSocket
    communication</a></dt>
  <dd>See <i>libcurl-ws(3)</i></dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="LINKING_WITH_LIBCURL"><a class="permalink" href="#LINKING_WITH_LIBCURL">LINKING
  WITH LIBCURL</a></h1>
<p class="Pp">On unix-like machines, there is a tool named curl-config that gets
    installed with the rest of the curl stuff when 'make install' is
  performed.</p>
<p class="Pp">curl-config is added to make it easier for applications to link
    with libcurl and developers to learn about libcurl and how to use it.</p>
<p class="Pp">Run 'curl-config --libs' to get the (additional) linker options
    you need to link with the particular version of libcurl you have installed.
    See the <i>curl-config(1)</i> man page for further details.</p>
<p class="Pp">Unix-like operating system that ship libcurl as part of their
    distributions often do not provide the curl-config tool, but simply install
    the library and headers in the common path for this purpose.</p>
<p class="Pp">Many Linux and similar systems use pkg-config to provide build and
    link options about libraries and libcurl supports that as well.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="LIBCURL_SYMBOL_NAMES"><a class="permalink" href="#LIBCURL_SYMBOL_NAMES">LIBCURL
  SYMBOL NAMES</a></h1>
<p class="Pp">All public functions in the libcurl interface are prefixed with
    'curl_' (with a lowercase c). You can find other functions in the library
    source code, but other prefixes indicate that the functions are private and
    may change without further notice in the next release.</p>
<p class="Pp">Only use documented functions and functionality!</p>
</section>
<section class="Sh">
<h1 class="Sh" id="PORTABILITY"><a class="permalink" href="#PORTABILITY">PORTABILITY</a></h1>
<p class="Pp">libcurl works <b>exactly</b> the same, on any of the platforms it
    compiles and builds on.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="THREADS"><a class="permalink" href="#THREADS">THREADS</a></h1>
<p class="Pp">libcurl is thread safe but there are a few exceptions. Refer to
    <i>libcurl-thread(3)</i> for more information.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="PERSISTENT_CONNECTIONS"><a class="permalink" href="#PERSISTENT_CONNECTIONS">PERSISTENT
  CONNECTIONS</a></h1>
<p class="Pp">Persistent connections means that libcurl can reuse the same
    connection for several transfers, if the conditions are right.</p>
<p class="Pp">libcurl always attempts to use persistent connections. Whenever
    you use <i>curl_easy_perform(3)</i> or <i>curl_multi_perform(3)</i> etc,
    libcurl attempts to use an existing connection to do the transfer, and if
    none exists it opens a new one that is subject for reuse on a possible
    following call to <i>curl_easy_perform(3)</i> or
    <i>curl_multi_perform(3)</i>.</p>
<p class="Pp">To allow libcurl to take full advantage of persistent connections,
    you should do as many of your file transfers as possible using the same
    handle.</p>
<p class="Pp">If you use the easy interface, and you call
    <i>curl_easy_cleanup(3)</i>, all the possibly open connections held by
    libcurl are closed and forgotten.</p>
<p class="Pp">When you have created a multi handle and are using the multi
    interface, the connection pool is instead kept in the multi handle so
    closing and creating new easy handles to do transfers do not affect them.
    Instead all added easy handles can take advantage of the single shared
  pool.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="GLOBAL_CONSTANTS"><a class="permalink" href="#GLOBAL_CONSTANTS">GLOBAL
  CONSTANTS</a></h1>
<p class="Pp">There are a variety of constants that libcurl uses, mainly through
    its internal use of other libraries, which are too complicated for the
    library loader to set up. Therefore, a program must call a library function
    after the program is loaded and running to finish setting up the library
    code. For example, when libcurl is built for SSL capability via the GNU TLS
    library, there is an elaborate tree inside that library that describes the
    SSL protocol.</p>
<p class="Pp"><i>curl_global_init(3)</i> is the function that you must call.
    This may allocate resources (e.g. the memory for the GNU TLS tree mentioned
    above), so the companion function <i>curl_global_cleanup(3)</i> releases
    them.</p>
<p class="Pp">If libcurl was compiled with support for multiple SSL backends,
    the function <i>curl_global_sslset(3)</i> can be called before
    <i>curl_global_init(3)</i> to select the active SSL backend.</p>
<p class="Pp">The global constant functions are thread-safe since libcurl 7.84.0
    if <i>curl_version_info(3)</i> has the CURL_VERSION_THREADSAFE feature bit
    set (most platforms). Read <i>libcurl-thread(3)</i> for thread safety
    guidelines.</p>
<p class="Pp">If the global constant functions are <i>not thread safe</i>, then
    you must not call them when any other thread in the program is running. It
    is not good enough that no other thread is using libcurl at the time,
    because these functions internally call similar functions of other
    libraries, and those functions are similarly thread-unsafe. You cannot
    generally know what these libraries are, or whether other threads are using
    them.</p>
<p class="Pp">If the global constant functions are <i>not thread safe</i>, then
    the basic rule for constructing a program that uses libcurl is this: Call
    <i>curl_global_init(3)</i>, with a <i>CURL_GLOBAL_ALL</i> argument,
    immediately after the program starts, while it is still only one thread and
    before it uses libcurl at all. Call <i>curl_global_cleanup(3)</i>
    immediately before the program exits, when the program is again only one
    thread and after its last use of libcurl.</p>
<p class="Pp">It is not actually required that the functions be called at the
    beginning and end of the program -- that is just usually the easiest way to
    do it.</p>
<p class="Pp">You can call both of these multiple times, as long as all calls
    meet these requirements and the number of calls to each is the same.</p>
<p class="Pp">The global constant situation merits special consideration when
    the code you are writing to use libcurl is not the main program, but rather
    a modular piece of a program, e.g. another library. As a module, your code
    does not know about other parts of the program -- it does not know whether
    they use libcurl or not. Its code does not necessarily run at the start and
    end of the whole program.</p>
<p class="Pp">A module like this must have global constant functions of its own,
    just like <i>curl_global_init(3)</i> and <i>curl_global_cleanup(3)</i>. The
    module thus has control at the beginning and end of the program and has a
    place to call the libcurl functions. If multiple modules in the program use
    libcurl, they all separately call the libcurl functions, and that is OK
    because only the first <i>curl_global_init(3)</i> and the last
    <i>curl_global_cleanup(3)</i> in a program change anything. (libcurl uses a
    reference count in static memory).</p>
<p class="Pp">In a C++ module, it is common to deal with the global constant
    situation by defining a special class that represents the global constant
    environment of the module. A program always has exactly one object of the
    class, in static storage. That way, the program automatically calls the
    constructor of the object as the program starts up and the destructor as it
    terminates. As the author of this libcurl-using module, you can make the
    constructor call <i>curl_global_init(3)</i> and the destructor call
    <i>curl_global_cleanup(3)</i> and satisfy libcurl's requirements without
    your user having to think about it. (Caveat: If you are initializing libcurl
    from a Windows DLL you should not initialize it from <i>DllMain</i> or a
    static initializer because Windows holds the loader lock during that time
    and it could cause a deadlock.)</p>
<p class="Pp"><i>curl_global_init(3)</i> has an argument that tells what
    particular parts of the global constant environment to set up. In order to
    successfully use any value except <i>CURL_GLOBAL_ALL</i> (which says to set
    up the whole thing), you must have specific knowledge of internal workings
    of libcurl and all other parts of the program of which it is part.</p>
<p class="Pp">A special part of the global constant environment is the identity
    of the memory allocator. <i>curl_global_init(3)</i> selects the system
    default memory allocator, but you can use <i>curl_global_init_mem(3)</i> to
    supply one of your own. However, there is no way to use
    <i>curl_global_init_mem(3)</i> in a modular program -- all modules in the
    program that might use libcurl would have to agree on one allocator.</p>
<p class="Pp">There is a failsafe in libcurl that makes it usable in simple
    situations without you having to worry about the global constant environment
    at all: <i>curl_easy_init(3)</i> sets up the environment itself if it has
    not been done yet. The resources it acquires to do so get released by the
    operating system automatically when the program exits.</p>
<p class="Pp">This failsafe feature exists mainly for backward compatibility
    because there was a time when the global functions did not exist. Because it
    is sufficient only in the simplest of programs, it is not recommended for
    any program to rely on it.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp"><b>libcurl-easy</b>(3), <b>libcurl-multi</b>(3),
    <b>libcurl-security</b>(3), <b>libcurl-thread</b>(3)</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">March 12 2024</td>
    <td class="foot-os">libcurl</td>
  </tr>
</table>
</body>
</html>
