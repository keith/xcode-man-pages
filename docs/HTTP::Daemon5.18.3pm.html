<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    .Nd, .Bf, .Op { display: inline; }
    .Pa, .Ad { font-style: italic; }
    .Ms { font-weight: bold; }
    .Bl-diag > dt { font-weight: bold; }
    code.Nm, .Fl, .Cm, .Ic, code.In, .Fd, .Fn, .Cd { font-weight: bold;
      font-family: inherit; }
  </style>
  <title>HTTP::Daemon(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">HTTP::Daemon(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">HTTP::Daemon(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">HTTP::Daemon - a simple http server class</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>  use HTTP::Daemon;
  use HTTP::Status;
  my $d = HTTP::Daemon-&gt;new || die;
  print &quot;Please contact me at: &lt;URL:&quot;, $d-&gt;url, &quot;&gt;\n&quot;;
  while (my $c = $d-&gt;accept) {
      while (my $r = $c-&gt;get_request) {
          if ($r-&gt;method eq 'GET' and $r-&gt;uri-&gt;path eq &quot;/xyzzy&quot;) {
              # remember, this is *not* recommended practice :-)
              $c-&gt;send_file_response(&quot;/etc/passwd&quot;);
          }
          else {
              $c-&gt;send_error(RC_FORBIDDEN)
          }
      }
      $c-&gt;close;
      undef($c);
  }
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">Instances of the <span class="Li">&quot;HTTP::Daemon&quot;</span>
    class are HTTP/1.1 servers that listen on a socket for incoming requests.
    The <span class="Li">&quot;HTTP::Daemon&quot;</span> is a subclass of
    <span class="Li">&quot;IO::Socket::INET&quot;</span>, so you can perform
    socket operations directly on it too.</p>
<p class="Pp">The <i>accept()</i> method will return when a connection from a
    client is available. The returned value will be an
    <span class="Li">&quot;HTTP::Daemon::ClientConn&quot;</span> object which is
    another <span class="Li">&quot;IO::Socket::INET&quot;</span> subclass.
    Calling the <i>get_request()</i> method on this object will read data from
    the client and return an <span class="Li">&quot;HTTP::Request&quot;</span>
    object. The ClientConn object also provide methods to send back various
    responses.</p>
<p class="Pp">This HTTP daemon does not <i>fork</i>(2) for you. Your
    application, i.e. the user of the
    <span class="Li">&quot;HTTP::Daemon&quot;</span> is responsible for forking
    if that is desirable. Also note that the user is responsible for generating
    responses that conform to the HTTP/1.1 protocol.</p>
<p class="Pp">The following methods of
    <span class="Li">&quot;HTTP::Daemon&quot;</span> are new (or enhanced)
    relative to the <span class="Li">&quot;IO::Socket::INET&quot;</span> base
    class:</p>
<dl class="Bl-tag">
  <dt>$d = HTTP::Daemon-&gt;new</dt>
  <dd></dd>
  <dt>$d = HTTP::Daemon-&gt;new( %opts )</dt>
  <dd>The constructor method takes the same arguments as the
      <span class="Li">&quot;IO::Socket::INET&quot;</span> constructor, but
      unlike its base class it can also be called without any arguments. The
      daemon will then set up a listen queue of 5 connections and allocate some
      random port number.
    <p class="Pp">A server that wants to bind to some specific address on the
        standard HTTP port will be constructed like this:</p>
    <p class="Pp"></p>
    <pre>  $d = HTTP::Daemon-&gt;new(
           LocalAddr =&gt; 'www.thisplace.com',
           LocalPort =&gt; 80,
       );
    </pre>
    <p class="Pp">See IO::Socket::INET for a description of other arguments that
        can be used configure the daemon during construction.</p>
  </dd>
  <dt>$c = $d-&gt;accept</dt>
  <dd></dd>
  <dt>$c = $d-&gt;accept( $pkg )</dt>
  <dd></dd>
  <dt>($c, $peer_addr) = $d-&gt;accept</dt>
  <dd>This method works the same the one provided by the base class, but it
      returns an <span class="Li">&quot;HTTP::Daemon::ClientConn&quot;</span>
      reference by default. If a package name is provided as argument, then the
      returned object will be blessed into the given class. It is probably a
      good idea to make that class a subclass of
      <span class="Li">&quot;HTTP::Daemon::ClientConn&quot;</span>.
    <p class="Pp">The accept method will return
        <span class="Li">&quot;undef&quot;</span> if timeouts have been enabled
        and no connection is made within the given time. The <i>timeout()</i>
        method is described in IO::Socket.</p>
    <p class="Pp">In list context both the client object and the peer address
        will be returned; see the description of the accept method IO::Socket
        for details.</p>
  </dd>
  <dt>$d-&gt;url</dt>
  <dd>Returns a URL string that can be used to access the server root.</dd>
  <dt>$d-&gt;product_tokens</dt>
  <dd>Returns the name that this server will use to identify itself. This is the
      string that is sent with the <span class="Li">&quot;Server&quot;</span>
      response header. The main reason to have this method is that subclasses
      can override it if they want to use another product name.
    <p class="Pp">The default is the string &quot;libwww-perl-daemon/#.##&quot;
        where &quot;#.##&quot; is replaced with the version number of this
        module.</p>
  </dd>
</dl>
<p class="Pp">The <span class="Li">&quot;HTTP::Daemon::ClientConn&quot;</span>
    is a <span class="Li">&quot;IO::Socket::INET&quot;</span> subclass.
    Instances of this class are returned by the <i>accept()</i> method of
    <span class="Li">&quot;HTTP::Daemon&quot;</span>. The following methods are
    provided:</p>
<dl class="Bl-tag">
  <dt>$c-&gt;get_request</dt>
  <dd></dd>
  <dt>$c-&gt;get_request( $headers_only )</dt>
  <dd>This method reads data from the client and turns it into an
      <span class="Li">&quot;HTTP::Request&quot;</span> object which is
      returned. It returns <span class="Li">&quot;undef&quot;</span> if reading
      fails. If it fails, then the
      <span class="Li">&quot;HTTP::Daemon::ClientConn&quot;</span> object ($c)
      should be discarded, and you should not try call this method again on it.
      The <span class="Li">$c</span>-&gt;reason method might give you some
      information about why <span class="Li">$c</span>-&gt;get_request failed.
    <p class="Pp">The <i>get_request()</i> method will normally not return until
        the whole request has been received from the client. This might not be
        what you want if the request is an upload of a large file (and with
        chunked transfer encoding HTTP can even support infinite request
        messages - uploading live audio for instance). If you pass a TRUE value
        as the <span class="Li">$headers_only</span> argument, then
        <i>get_request()</i> will return immediately after parsing the request
        headers and you are responsible for reading the rest of the request
        content. If you are going to call
        <span class="Li">$c</span>-&gt;get_request again on the same connection
        you better read the correct number of bytes.</p>
  </dd>
  <dt>$c-&gt;read_buffer</dt>
  <dd></dd>
  <dt>$c-&gt;read_buffer( $new_value )</dt>
  <dd>Bytes read by <span class="Li">$c</span>-&gt;get_request, but not used are
      placed in the <i>read</i> <i>buffer</i>. The next time
      <span class="Li">$c</span>-&gt;get_request is called it will consume the
      bytes in this buffer before reading more data from the network connection
      itself. The read buffer is invalid after
      <span class="Li">$c</span>-&gt;get_request has failed.
    <p class="Pp">If you handle the reading of the request content yourself you
        need to empty this buffer before you read more and you need to place
        unconsumed bytes here. You also need this buffer if you implement
        services like <i>101 Switching Protocols</i>.</p>
    <p class="Pp">This method always returns the old buffer content and can
        optionally replace the buffer content if you pass it an argument.</p>
  </dd>
  <dt>$c-&gt;reason</dt>
  <dd>When <span class="Li">$c</span>-&gt;get_request returns
      <span class="Li">&quot;undef&quot;</span> you can obtain a short string
      describing why it happened by calling
      <span class="Li">$c</span>-&gt;reason.</dd>
  <dt>$c-&gt;proto_ge( $proto )</dt>
  <dd>Return TRUE if the client announced a protocol with version number greater
      or equal to the given argument. The <span class="Li">$proto</span>
      argument can be a string like &quot;HTTP/1.1&quot; or just
      &quot;1.1&quot;.</dd>
  <dt>$c-&gt;antique_client</dt>
  <dd>Return TRUE if the client speaks the HTTP/0.9 protocol. No status code and
      no headers should be returned to such a client. This should be the same as
      !$c-&gt;proto_ge(&quot;HTTP/1.0&quot;).</dd>
  <dt>$c-&gt;head_request</dt>
  <dd>Return TRUE if the last request was a
      <span class="Li">&quot;HEAD&quot;</span> request. No content body must be
      generated for these requests.</dd>
  <dt>$c-&gt;force_last_request</dt>
  <dd>Make sure that <span class="Li">$c</span>-&gt;get_request will not try to
      read more requests off this connection. If you generate a response that is
      not self delimiting, then you should signal this fact by calling this
      method.
    <p class="Pp">This attribute is turned on automatically if the client
        announces protocol HTTP/1.0 or worse and does not include a
        &quot;Connection: Keep-Alive&quot; header. It is also turned on
        automatically when HTTP/1.1 or better clients send the &quot;Connection:
        close&quot; request header.</p>
  </dd>
  <dt>$c-&gt;send_status_line</dt>
  <dd></dd>
  <dt>$c-&gt;send_status_line( $code )</dt>
  <dd></dd>
  <dt>$c-&gt;send_status_line( $code, $mess )</dt>
  <dd></dd>
  <dt>$c-&gt;send_status_line( $code, $mess, $proto )</dt>
  <dd>Send the status line back to the client. If <span class="Li">$code</span>
      is omitted 200 is assumed. If <span class="Li">$mess</span> is omitted,
      then a message corresponding to <span class="Li">$code</span> is inserted.
      If <span class="Li">$proto</span> is missing the content of the
      <span class="Li">$HTTP::Daemon::PROTO</span> variable is used.</dd>
  <dt>$c-&gt;send_crlf</dt>
  <dd>Send the CRLF sequence to the client.</dd>
  <dt>$c-&gt;send_basic_header</dt>
  <dd></dd>
  <dt>$c-&gt;send_basic_header( $code )</dt>
  <dd></dd>
  <dt>$c-&gt;send_basic_header( $code, $mess )</dt>
  <dd></dd>
  <dt>$c-&gt;send_basic_header( $code, $mess, $proto )</dt>
  <dd>Send the status line and the &quot;Date:&quot; and &quot;Server:&quot;
      headers back to the client. This header is assumed to be continued and
      does not end with an empty CRLF line.
    <p class="Pp">See the description of <i>send_status_line()</i> for the
        description of the accepted arguments.</p>
  </dd>
  <dt>$c-&gt;send_header( $field, $value )</dt>
  <dd></dd>
  <dt>$c-&gt;send_header( $field1, $value1, $field2, $value2, ... )</dt>
  <dd>Send one or more header lines.</dd>
  <dt>$c-&gt;send_response( $res )</dt>
  <dd>Write a <span class="Li">&quot;HTTP::Response&quot;</span> object to the
      client as a response. We try hard to make sure that the response is self
      delimiting so that the connection can stay persistent for further
      request/response exchanges.
    <p class="Pp">The content attribute of the
        <span class="Li">&quot;HTTP::Response&quot;</span> object can be a
        normal string or a subroutine reference. If it is a subroutine, then
        whatever this callback routine returns is written back to the client as
        the response content. The routine will be called until it return an
        undefined or empty value. If the client is HTTP/1.1 aware then we will
        use chunked transfer encoding for the response.</p>
  </dd>
  <dt>$c-&gt;send_redirect( $loc )</dt>
  <dd></dd>
  <dt>$c-&gt;send_redirect( $loc, $code )</dt>
  <dd></dd>
  <dt>$c-&gt;send_redirect( $loc, $code, $entity_body )</dt>
  <dd>Send a redirect response back to the client. The location ($loc) can be an
      absolute or relative URL. The <span class="Li">$code</span> must be one
      the redirect status codes, and defaults to &quot;301 Moved
      Permanently&quot;</dd>
  <dt>$c-&gt;send_error</dt>
  <dd></dd>
  <dt>$c-&gt;send_error( $code )</dt>
  <dd></dd>
  <dt>$c-&gt;send_error( $code, $error_message )</dt>
  <dd>Send an error response back to the client. If the
      <span class="Li">$code</span> is missing a &quot;Bad Request&quot; error
      is reported. The <span class="Li">$error_message</span> is a string that
      is incorporated in the body of the HTML entity body.</dd>
  <dt>$c-&gt;send_file_response( $filename )</dt>
  <dd>Send back a response with the specified <span class="Li">$filename</span>
      as content. If the file is a directory we try to generate an HTML index of
      it.</dd>
  <dt>$c-&gt;send_file( $filename )</dt>
  <dd></dd>
  <dt>$c-&gt;send_file( $fd )</dt>
  <dd>Copy the file to the client. The file can be a string (which will be
      interpreted as a filename) or a reference to an
      <span class="Li">&quot;IO::Handle&quot;</span> or glob.</dd>
  <dt>$c-&gt;daemon</dt>
  <dd>Return a reference to the corresponding
      <span class="Li">&quot;HTTP::Daemon&quot;</span> object.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp">RFC 2616</p>
<p class="Pp">IO::Socket::INET, IO::Socket</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT"><a class="permalink" href="#COPYRIGHT">COPYRIGHT</a></h1>
<p class="Pp">Copyright 1996-2003, Gisle Aas</p>
<p class="Pp">This library is free software; you can redistribute it and/or
    modify it under the same terms as Perl itself.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2021-10-19</td>
    <td class="foot-os">perl v5.18.4</td>
  </tr>
</table>
</body>
</html>
