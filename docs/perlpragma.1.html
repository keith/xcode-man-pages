<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.10 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>PERLPRAGMA(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">PERLPRAGMA(1)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">PERLPRAGMA(1)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
perlpragma - how to write a user pragma
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
A pragma is a module which influences some aspect of the compile time or run
  time behaviour of Perl, such as <span class="Li">&quot;strict&quot;</span> or
  <span class="Li">&quot;warnings&quot;</span>. With Perl 5.10 you are no longer
  limited to the built in pragmata; you can now create user pragmata that modify
  the behaviour of user functions within a lexical scope.
</section>
<section class="Sh">
<h1 class="Sh" id="A_basic_example"><a class="permalink" href="#A_basic_example">A
  basic example</a></h1>
For example, say you need to create a class implementing overloaded mathematical
  operators, and would like to provide your own pragma that functions much like
  <span class="Li">&quot;use integer;&quot;</span> You'd like this code
<p class="Pp"><span class="Li"></span></p>
<pre>
    use MyMaths;

    my $l = MyMaths-&gt;new(1.2);
    my $r = MyMaths-&gt;new(3.4);

    print &quot;A: &quot;, $l + $r, &quot;\n&quot;;

    use myint;
    print &quot;B: &quot;, $l + $r, &quot;\n&quot;;

    {
        no myint;
        print &quot;C: &quot;, $l + $r, &quot;\n&quot;;
    }

    print &quot;D: &quot;, $l + $r, &quot;\n&quot;;

    no myint;
    print &quot;E: &quot;, $l + $r, &quot;\n&quot;;
</pre>
<p class="Pp">to give the output</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    A: 4.6
    B: 4
    C: 4.6
    D: 4
    E: 4.6
</pre>
<p class="Pp"><i>i.e.</i>, where <span class="Li">&quot;use myint;&quot;</span>
    is in effect, addition operations are forced to integer, whereas by default
    they are not, with the default behaviour being restored via
    <span class="Li">&quot;no myint;&quot;</span></p>
<p class="Pp">The minimal implementation of the package
    <span class="Li">&quot;MyMaths&quot;</span> would be something like
  this:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    package MyMaths;
    use warnings;
    use strict;
    use myint();
    use overload '+' =&gt; sub {
        my ($l, $r) = @_;
        # Pass 1 to check up one call level from here
        if (myint::in_effect(1)) {
            int($$l) + int($$r);
        } else {
            $$l + $$r;
        }
    };

    sub new {
        my ($class, $value) = @_;
        bless \$value, $class;
    }

    1;
</pre>
<p class="Pp">Note how we load the user pragma
    <span class="Li">&quot;myint&quot;</span> with an empty list
    <span class="Li">&quot;()&quot;</span> to prevent its
    <span class="Li">&quot;import&quot;</span> being called.</p>
<p class="Pp">The interaction with the Perl compilation happens inside package
    <span class="Li">&quot;myint&quot;</span>:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    package myint;

    use strict;
    use warnings;

    sub import {
        $^H{&quot;myint/in_effect&quot;} = 1;
    }

    sub unimport {
        $^H{&quot;myint/in_effect&quot;} = 0;
    }

    sub in_effect {
        my $level = shift // 0;
        my $hinthash = (caller($level))[10];
        return $hinthash-&gt;{&quot;myint/in_effect&quot;};
    }

    1;
</pre>
<p class="Pp">As pragmata are implemented as modules, like any other module,
    <span class="Li">&quot;use myint;&quot;</span> becomes</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    BEGIN {
        require myint;
        myint-&gt;import();
    }
</pre>
<p class="Pp">and <span class="Li">&quot;no myint;&quot;</span> is</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    BEGIN {
        require myint;
        myint-&gt;unimport();
    }
</pre>
<p class="Pp">Hence the <span class="Li">&quot;import&quot;</span> and
    <span class="Li">&quot;unimport&quot;</span> routines are called at
    <b>compile time</b> for the user's code.</p>
<p class="Pp">User pragmata store their state by writing to the magical hash
    <span class="Li">&quot;%^H&quot;</span>, hence these two routines manipulate
    it. The state information in <span class="Li">&quot;%^H&quot;</span> is
    stored in the optree, and can be retrieved read-only at runtime with
    <span class="Li">&quot;caller()&quot;</span>, at index 10 of the list of
    returned results. In the example pragma, retrieval is encapsulated into the
    routine <span class="Li">&quot;in_effect()&quot;</span>, which takes as
    parameter the number of call frames to go up to find the value of the pragma
    in the user's script. This uses <span class="Li">&quot;caller()&quot;</span>
    to determine the value of
    <span class="Li">$^H{&quot;myint/in_effect&quot;}</span> when each line of
    the user's script was called, and therefore provide the correct semantics in
    the subroutine implementing the overloaded addition.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="Key_naming"><a class="permalink" href="#Key_naming">Key
  naming</a></h1>
There is only a single <span class="Li">&quot;%^H&quot;</span>, but arbitrarily
  many modules that want to use its scoping semantics. To avoid stepping on each
  other's toes, they need to be sure to use different keys in the hash. It is
  therefore conventional for a module to use only keys that begin with the
  module's name (the name of its main package) and a &quot;/&quot; character.
  After this module-identifying prefix, the rest of the key is entirely up to
  the module: it may include any characters whatsoever. For example, a module
  <span class="Li">&quot;Foo::Bar&quot;</span> should use keys such as
  <span class="Li">&quot;Foo::Bar/baz&quot;</span> and
  <span class="Li">&quot;Foo::Bar/$%/_!&quot;</span>. Modules following this
  convention all play nicely with each other.
<p class="Pp">The Perl core uses a handful of keys in
    <span class="Li">&quot;%^H&quot;</span> which do not follow this convention,
    because they predate it. Keys that follow the convention won't conflict with
    the core's historical keys.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="Implementation_details"><a class="permalink" href="#Implementation_details">Implementation
  details</a></h1>
The optree is shared between threads. This means there is a possibility that the
  optree will outlive the particular thread (and therefore the interpreter
  instance) that created it, so true Perl scalars cannot be stored in the
  optree. Instead a compact form is used, which can only store values that are
  integers (signed and unsigned), strings or
  <span class="Li">&quot;undef&quot;</span> - references and floating point
  values are stringified. If you need to store multiple values or complex
  structures, you should serialise them, for example with
  <span class="Li">&quot;pack&quot;</span>. The deletion of a hash key from
  <span class="Li">&quot;%^H&quot;</span> is recorded, and as ever can be
  distinguished from the existence of a key with value
  <span class="Li">&quot;undef&quot;</span> with
  <span class="Li">&quot;exists&quot;</span>.
<p class="Pp"><b>Don't</b> attempt to store references to data structures as
    integers which are retrieved via <span class="Li">&quot;caller&quot;</span>
    and converted back, as this will not be threadsafe. Accesses would be to the
    structure without locking (which is not safe for Perl's scalars), and either
    the structure has to leak, or it has to be freed when its creating thread
    terminates, which may be before the optree referencing it is deleted, if
    other threads outlive it.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2018-03-01</td>
    <td class="foot-os">perl v5.28.2</td>
  </tr>
</table>
</body>
</html>
