<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>Term::ANSIColor(3pm)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Term::ANSIColor(3pm)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">Term::ANSIColor(3pm)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
Term::ANSIColor - Color screen output using ANSI escape sequences
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<span class="Li"></span>
<pre>
    use Term::ANSIColor;
    print color('bold blue');
    print &quot;This text is bold blue.\n&quot;;
    print color('reset');
    print &quot;This text is normal.\n&quot;;
    print colored(&quot;Yellow on magenta.&quot;, 'yellow on_magenta'), &quot;\n&quot;;
    print &quot;This text is normal.\n&quot;;
    print colored(['yellow on_magenta'], 'Yellow on magenta.', &quot;\n&quot;);
    print colored(['red on_bright_yellow'], 'Red on bright yellow.', &quot;\n&quot;);
    print colored(['bright_red on_black'], 'Bright red on black.', &quot;\n&quot;);
    print &quot;\n&quot;;

    # Map escape sequences back to color names.
    use Term::ANSIColor 1.04 qw(uncolor);
    my $names = uncolor('01;31');
    print join(q{ }, @{$names}), &quot;\n&quot;;

    # Strip all color escape sequences.
    use Term::ANSIColor 2.01 qw(colorstrip);
    print colorstrip(&quot;\e[1mThis is bold\e[0m&quot;), &quot;\n&quot;;

    # Determine whether a color is valid.
    use Term::ANSIColor 2.02 qw(colorvalid);
    my $valid = colorvalid('blue bold', 'on_magenta');
    print &quot;Color string is &quot;, $valid ? &quot;valid\n&quot; : &quot;invalid\n&quot;;

    # Create new aliases for colors.
    use Term::ANSIColor 4.00 qw(coloralias);
    coloralias('alert', 'red');
    print &quot;Alert is &quot;, coloralias('alert'), &quot;\n&quot;;
    print colored(&quot;This is in red.&quot;, 'alert'), &quot;\n&quot;;

    use Term::ANSIColor qw(:constants);
    print BOLD, BLUE, &quot;This text is in bold blue.\n&quot;, RESET;

    use Term::ANSIColor qw(:constants);
    {
        local $Term::ANSIColor::AUTORESET = 1;
        print BOLD BLUE &quot;This text is in bold blue.\n&quot;;
        print &quot;This text is normal.\n&quot;;
    }

    use Term::ANSIColor 2.00 qw(:pushpop);
    print PUSHCOLOR RED ON_GREEN &quot;This text is red on green.\n&quot;;
    print PUSHCOLOR BRIGHT_BLUE &quot;This text is bright blue on green.\n&quot;;
    print RESET BRIGHT_BLUE &quot;This text is just bright blue.\n&quot;;
    print POPCOLOR &quot;Back to red on green.\n&quot;;
    print LOCALCOLOR GREEN ON_BLUE &quot;This text is green on blue.\n&quot;;
    print &quot;This text is red on green.\n&quot;;
    {
        local $Term::ANSIColor::AUTOLOCAL = 1;
        print ON_BLUE &quot;This text is red on blue.\n&quot;;
        print &quot;This text is red on green.\n&quot;;
    }
    print POPCOLOR &quot;Back to whatever we started as.\n&quot;;
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
This module has two interfaces, one through <b>color()</b> and <b>colored()</b>
  and the other through constants. It also offers the utility functions
  <b>uncolor()</b>, <b>colorstrip()</b>, <b>colorvalid()</b>, and
  <b>coloralias()</b>, which have to be explicitly imported to be used (see
  &quot;SYNOPSIS&quot;).
<p class="Pp">See &quot;COMPATIBILITY&quot; for the versions of Term::ANSIColor
    that introduced particular features and the versions of Perl that included
    them.</p>
<section class="Ss">
<h2 class="Ss" id="Supported_Colors"><a class="permalink" href="#Supported_Colors">Supported
  Colors</a></h2>
Terminal emulators that support color divide into three types: ones that support
  only eight colors, ones that support sixteen, and ones that support 256. This
  module provides the ANSI escape codes for all of them. These colors are
  referred to as ANSI colors 0 through 7 (normal), 8 through 15 (16-color), and
  16 through 255 (256-color).
<p class="Pp">Unfortunately, interpretation of colors 0 through 7 often depends
    on whether the emulator supports eight colors or sixteen colors. Emulators
    that only support eight colors (such as the Linux console) will display
    colors 0 through 7 with normal brightness and ignore colors 8 through 15,
    treating them the same as white. Emulators that support 16 colors, such as
    gnome-terminal, normally display colors 0 through 7 as dim or darker
    versions and colors 8 through 15 as normal brightness. On such emulators,
    the &quot;normal&quot; white (color 7) usually is shown as pale grey,
    requiring bright white (15) to be used to get a real white color. Bright
    black usually is a dark grey color, although some terminals display it as
    pure black. Some sixteen-color terminal emulators also treat normal yellow
    (color 3) as orange or brown, and bright yellow (color 11) as yellow.</p>
<p class="Pp">Following the normal convention of sixteen-color emulators, this
    module provides a pair of attributes for each color. For every normal color
    (0 through 7), the corresponding bright color (8 through 15) is obtained by
    prepending the string <span class="Li">&quot;bright_&quot;</span> to the
    normal color name. For example, <span class="Li">&quot;red&quot;</span> is
    color 1 and <span class="Li">&quot;bright_red&quot;</span> is color 9. The
    same applies for background colors:
    <span class="Li">&quot;on_red&quot;</span> is the normal color and
    <span class="Li">&quot;on_bright_red&quot;</span> is the bright color.
    Capitalize these strings for the constant interface.</p>
<p class="Pp">For 256-color emulators, this module additionally provides
    <span class="Li">&quot;ansi0&quot;</span> through
    <span class="Li">&quot;ansi15&quot;</span>, which are the same as colors 0
    through 15 in sixteen-color emulators but use the 256-color escape syntax,
    <span class="Li">&quot;grey0&quot;</span> through
    <span class="Li">&quot;grey23&quot;</span> ranging from nearly black to
    nearly white, and a set of RGB colors. The RGB colors are of the form
    <span class="Li">&quot;rgb</span><i>RGB</i><span class="Li">&quot;</span>
    where <i>R</i>, <i>G</i>, and <i>B</i> are numbers from 0 to 5 giving the
    intensity of red, green, and blue. The grey and RGB colors are also
    available as <span class="Li">&quot;ansi16&quot;</span> through
    <span class="Li">&quot;ansi255&quot;</span> if you want simple names for all
    256 colors. <span class="Li">&quot;on_&quot;</span> variants of all of these
    colors are also provided. These colors may be ignored completely on
    non-256-color terminals or may be misinterpreted and produce random
    behavior. Additional attributes such as blink, italic, or bold may not work
    with the 256-color palette.</p>
<p class="Pp">There is unfortunately no way to know whether the current emulator
    supports more than eight colors, which makes the choice of colors difficult.
    The most conservative choice is to use only the regular colors, which are at
    least displayed on all emulators. However, they will appear dark in
    sixteen-color terminal emulators, including most common emulators in UNIX X
    environments. If you know the display is one of those emulators, you may
    wish to use the bright variants instead. Even better, offer the user a way
    to configure the colors for a given application to fit their terminal
    emulator.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Function_Interface"><a class="permalink" href="#Function_Interface">Function
  Interface</a></h2>
The function interface uses attribute strings to describe the colors and text
  attributes to assign to text. The recognized non-color attributes are clear,
  reset, bold, dark, faint, italic, underline, underscore, blink, reverse, and
  concealed. Clear and reset (reset to default attributes), dark and faint (dim
  and saturated), and underline and underscore are equivalent, so use whichever
  is the most intuitive to you.
<p class="Pp">Note that not all attributes are supported by all terminal types,
    and some terminals may not support any of these sequences. Dark and faint,
    italic, blink, and concealed in particular are frequently not
  implemented.</p>
<p class="Pp">The recognized normal foreground color attributes (colors 0 to 7)
    are:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  black  red  green  yellow  blue  magenta  cyan  white
</pre>
<p class="Pp">The corresponding bright foreground color attributes (colors 8 to
    15) are:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  bright_black  bright_red      bright_green  bright_yellow
  bright_blue   bright_magenta  bright_cyan   bright_white
</pre>
<p class="Pp">The recognized normal background color attributes (colors 0 to 7)
    are:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  on_black  on_red      on_green  on yellow
  on_blue   on_magenta  on_cyan   on_white
</pre>
<p class="Pp">The recognized bright background color attributes (colors 8 to 15)
    are:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  on_bright_black  on_bright_red      on_bright_green  on_bright_yellow
  on_bright_blue   on_bright_magenta  on_bright_cyan   on_bright_white
</pre>
<p class="Pp">For 256-color terminals, the recognized foreground colors are:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  ansi0 .. ansi255
  grey0 .. grey23
</pre>
<p class="Pp">plus
    <span class="Li">&quot;rgb</span><i>RGB</i><span class="Li">&quot;</span>
    for <i>R</i>, <i>G</i>, and <i>B</i> values from 0 to 5, such as
    <span class="Li">&quot;rgb000&quot;</span> or
    <span class="Li">&quot;rgb515&quot;</span>. Similarly, the recognized
    background colors are:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  on_ansi0 .. on_ansi255
  on_grey0 .. on_grey23
</pre>
<p class="Pp">plus
    <span class="Li">&quot;on_rgb</span><i>RGB</i><span class="Li">&quot;</span>
    for <i>R</i>, <i>G</i>, and <i>B</i> values from 0 to 5.</p>
<p class="Pp">For any of the above listed attributes, case is not
  significant.</p>
<p class="Pp">Attributes, once set, last until they are unset (by printing the
    attribute <span class="Li">&quot;clear&quot;</span> or
    <span class="Li">&quot;reset&quot;</span>). Be careful to do this, or
    otherwise your attribute will last after your script is done running, and
    people get very annoyed at having their prompt and typing changed to weird
    colors.</p>
<dl class="Bl-tag">
  <dt>color(ATTR[, ATTR ...])</dt>
  <dd><b>color()</b> takes any number of strings as arguments and considers them
      to be space-separated lists of attributes. It then forms and returns the
      escape sequence to set those attributes. It doesn't print it out, just
      returns it, so you'll have to print it yourself if you want to. This is so
      that you can save it as a string, pass it to something else, send it to a
      file handle, or do anything else with it that you might care to.
      <b>color()</b> throws an exception if given an invalid attribute.</dd>
  <dt>colored(STRING, ATTR[, ATTR ...])</dt>
  <dd></dd>
  <dt>colored(ATTR-REF, STRING[, STRING...])</dt>
  <dd>As an aid in resetting colors, <b>colored()</b> takes a scalar as the
      first argument and any number of attribute strings as the second argument
      and returns the scalar wrapped in escape codes so that the attributes will
      be set as requested before the string and reset to normal after the
      string. Alternately, you can pass a reference to an array as the first
      argument, and then the contents of that array will be taken as attributes
      and color codes and the remainder of the arguments as text to colorize.
    <p class="Pp">Normally, <b>colored()</b> just puts attribute codes at the
        beginning and end of the string, but if you set
        <span class="Li">$Term::ANSIColor::EACHLINE</span> to some string, that
        string will be considered the line delimiter and the attribute will be
        set at the beginning of each line of the passed string and reset at the
        end of each line. This is often desirable if the output contains
        newlines and you're using background colors, since a background color
        that persists across a newline is often interpreted by the terminal as
        providing the default background color for the next line. Programs like
        pagers can also be confused by attributes that span lines. Normally
        you'll want to set <span class="Li">$Term::ANSIColor::EACHLINE</span> to
        <span class="Li">&quot;\n&quot;</span> to use this feature.</p>
  </dd>
  <dt>uncolor(ESCAPE)</dt>
  <dd><b>uncolor()</b> performs the opposite translation as <b>color()</b>,
      turning escape sequences into a list of strings corresponding to the
      attributes being set by those sequences. <b>uncolor()</b> will never
      return <span class="Li">&quot;ansi16&quot;</span> through
      <span class="Li">&quot;ansi255&quot;</span>, instead preferring the
      <span class="Li">&quot;grey&quot;</span> and
      <span class="Li">&quot;rgb&quot;</span> names (and likewise for
      <span class="Li">&quot;on_ansi16&quot;</span> through
      <span class="Li">&quot;on_ansi255&quot;</span>).</dd>
  <dt>colorstrip(STRING[, STRING ...])</dt>
  <dd><b>colorstrip()</b> removes all color escape sequences from the provided
      strings, returning the modified strings separately in array context or
      joined together in scalar context. Its arguments are not modified.</dd>
  <dt>colorvalid(ATTR[, ATTR ...])</dt>
  <dd><b>colorvalid()</b> takes attribute strings the same as <b>color()</b> and
      returns true if all attributes are known and false otherwise.</dd>
  <dt>coloralias(ALIAS[, ATTR])</dt>
  <dd>If ATTR is specified, <b>coloralias()</b> sets up an alias of ALIAS for
      the standard color ATTR. From that point forward, ALIAS can be passed into
      <b>color()</b>, <b>colored()</b>, and <b>colorvalid()</b> and will have
      the same meaning as ATTR. One possible use of this facility is to give
      more meaningful names to the 256-color RGB colors. Only ASCII
      alphanumerics, <span class="Li">&quot;.&quot;</span>,
      <span class="Li">&quot;_&quot;</span>, and
      <span class="Li">&quot;-&quot;</span> are allowed in alias names.
    <p class="Pp">If ATTR is not specified, <b>coloralias()</b> returns the
        standard color name to which ALIAS is aliased, if any, or undef if ALIAS
        does not exist.</p>
    <p class="Pp">This is the same facility used by the ANSI_COLORS_ALIASES
        environment variable (see &quot;ENVIRONMENT&quot; below) but can be used
        at runtime, not just when the module is loaded.</p>
    <p class="Pp">Later invocations of <b>coloralias()</b> with the same ALIAS
        will override earlier aliases. There is no way to remove an alias.</p>
    <p class="Pp">Aliases have no effect on the return value of
        <b>uncolor()</b>.</p>
    <p class="Pp"><b>WARNING</b>: Aliases are global and affect all callers in
        the same process. There is no way to set an alias limited to a
        particular block of code or a particular object.</p>
  </dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Constant_Interface"><a class="permalink" href="#Constant_Interface">Constant
  Interface</a></h2>
Alternately, if you import <span class="Li">&quot;:constants&quot;</span>, you
  can use the following constants directly:
<p class="Pp"><span class="Li"></span></p>
<pre>
  CLEAR           RESET             BOLD            DARK
  FAINT           ITALIC            UNDERLINE       UNDERSCORE
  BLINK           REVERSE           CONCEALED

  BLACK           RED               GREEN           YELLOW
  BLUE            MAGENTA           CYAN            WHITE
  BRIGHT_BLACK    BRIGHT_RED        BRIGHT_GREEN    BRIGHT_YELLOW
  BRIGHT_BLUE     BRIGHT_MAGENTA    BRIGHT_CYAN     BRIGHT_WHITE

  ON_BLACK        ON_RED            ON_GREEN        ON_YELLOW
  ON_BLUE         ON_MAGENTA        ON_CYAN         ON_WHITE
  ON_BRIGHT_BLACK ON_BRIGHT_RED     ON_BRIGHT_GREEN ON_BRIGHT_YELLOW
  ON_BRIGHT_BLUE  ON_BRIGHT_MAGENTA ON_BRIGHT_CYAN  ON_BRIGHT_WHITE
</pre>
<p class="Pp">These are the same as color('attribute') and can be used if you
    prefer typing:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    print BOLD BLUE ON_WHITE &quot;Text&quot;, RESET, &quot;\n&quot;;
</pre>
<p class="Pp">to</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    print colored (&quot;Text&quot;, 'bold blue on_white'), &quot;\n&quot;;
</pre>
<p class="Pp">(Note that the newline is kept separate to avoid confusing the
    terminal as described above since a background color is being used.)</p>
<p class="Pp">If you import <span class="Li">&quot;:constants256&quot;</span>,
    you can use the following constants directly:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  ANSI0 .. ANSI255
  GREY0 .. GREY23

  RGBXYZ (for X, Y, and Z values from 0 to 5, like RGB000 or RGB515)

  ON_ANSI0 .. ON_ANSI255
  ON_GREY0 .. ON_GREY23

  ON_RGBXYZ (for X, Y, and Z values from 0 to 5)
</pre>
<p class="Pp">Note that <span class="Li">&quot;:constants256&quot;</span> does
    not include the other constants, so if you want to mix both, you need to
    include <span class="Li">&quot;:constants&quot;</span> as well. You may want
    to explicitly import at least <span class="Li">&quot;RESET&quot;</span>, as
    in:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    use Term::ANSIColor 4.00 qw(RESET :constants256);
</pre>
<p class="Pp">When using the constants, if you don't want to have to remember to
    add the <span class="Li">&quot;, RESET&quot;</span> at the end of each print
    line, you can set <span class="Li">$Term::ANSIColor::AUTORESET</span> to a
    true value. Then, the display mode will automatically be reset if there is
    no comma after the constant. In other words, with that variable set:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    print BOLD BLUE &quot;Text\n&quot;;
</pre>
<p class="Pp">will reset the display mode afterward, whereas:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    print BOLD, BLUE, &quot;Text\n&quot;;
</pre>
<p class="Pp">will not. If you are using background colors, you will probably
    want to either use <b>say()</b> (in newer versions of Perl) or print the
    newline with a separate print statement to avoid confusing the terminal.</p>
<p class="Pp">If <span class="Li">$Term::ANSIColor::AUTOLOCAL</span> is set (see
    below), it takes precedence over
    <span class="Li">$Term::ANSIColor::AUTORESET</span>, and the latter is
    ignored.</p>
<p class="Pp">The subroutine interface has the advantage over the constants
    interface in that only two subroutines are exported into your namespace,
    versus thirty-eight in the constants interface. On the flip side, the
    constants interface has the advantage of better compile time error checking,
    since misspelled names of colors or attributes in calls to <b>color()</b>
    and <b>colored()</b> won't be caught until runtime whereas misspelled names
    of constants will be caught at compile time. So, pollute your namespace with
    almost two dozen subroutines that you may not even use that often, or risk a
    silly bug by mistyping an attribute. Your choice, TMTOWTDI after all.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="The_Color_Stack"><a class="permalink" href="#The_Color_Stack">The
  Color Stack</a></h2>
You can import <span class="Li">&quot;:pushpop&quot;</span> and maintain a stack
  of colors using PUSHCOLOR, POPCOLOR, and LOCALCOLOR. PUSHCOLOR takes the
  attribute string that starts its argument and pushes it onto a stack of
  attributes. POPCOLOR removes the top of the stack and restores the previous
  attributes set by the argument of a prior PUSHCOLOR. LOCALCOLOR surrounds its
  argument in a PUSHCOLOR and POPCOLOR so that the color resets afterward.
<p class="Pp">If <span class="Li">$Term::ANSIColor::AUTOLOCAL</span> is set,
    each sequence of color constants will be implicitly preceded by LOCALCOLOR.
    In other words, the following:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    {
        local $Term::ANSIColor::AUTOLOCAL = 1;
        print BLUE &quot;Text\n&quot;;
    }
</pre>
<p class="Pp">is equivalent to:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    print LOCALCOLOR BLUE &quot;Text\n&quot;;
</pre>
<p class="Pp">If <span class="Li">$Term::ANSIColor::AUTOLOCAL</span> is set, it
    takes precedence over <span class="Li">$Term::ANSIColor::AUTORESET</span>,
    and the latter is ignored.</p>
<p class="Pp">When using PUSHCOLOR, POPCOLOR, and LOCALCOLOR, it's particularly
    important to not put commas between the constants.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    print PUSHCOLOR BLUE &quot;Text\n&quot;;
</pre>
<p class="Pp">will correctly push BLUE onto the top of the stack.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    print PUSHCOLOR, BLUE, &quot;Text\n&quot;;    # wrong!
</pre>
<p class="Pp">will not, and a subsequent pop won't restore the correct
    attributes. PUSHCOLOR pushes the attributes set by its argument, which is
    normally a string of color constants. It can't ask the terminal what the
    current attributes are.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="DIAGNOSTICS"><a class="permalink" href="#DIAGNOSTICS">DIAGNOSTICS</a></h1>
<dl class="Bl-tag">
  <dt>Bad color mapping %s</dt>
  <dd>(W) The specified color mapping from ANSI_COLORS_ALIASES is not valid and
      could not be parsed. It was ignored.</dd>
  <dt>Bad escape sequence %s</dt>
  <dd>(F) You passed an invalid ANSI escape sequence to <b>uncolor()</b>.</dd>
  <dt>Bareword &quot;%s&quot; not allowed while &quot;strict subs&quot; in
    use</dt>
  <dd>(F) You probably mistyped a constant color name such as:
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    $Foobar = FOOBAR . &quot;This line should be blue\n&quot;;
    </pre>
    <p class="Pp">or:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    @Foobar = FOOBAR, &quot;This line should be blue\n&quot;;
    </pre>
    <p class="Pp">This will only show up under use strict (another good reason
        to run under use strict).</p>
  </dd>
  <dt>Cannot alias standard color %s</dt>
  <dd>(F) The alias name passed to <b>coloralias()</b> matches a standard color
      name. Standard color names cannot be aliased.</dd>
  <dt>Cannot alias standard color %s in %s</dt>
  <dd>(W) The same, but in ANSI_COLORS_ALIASES. The color mapping was
    ignored.</dd>
  <dt>Invalid alias name %s</dt>
  <dd>(F) You passed an invalid alias name to <b>coloralias()</b>. Alias names
      must consist only of alphanumerics, <span class="Li">&quot;.&quot;</span>,
      <span class="Li">&quot;-&quot;</span>, and
      <span class="Li">&quot;_&quot;</span>.</dd>
  <dt>Invalid alias name %s in %s</dt>
  <dd>(W) You specified an invalid alias name on the left hand of the equal sign
      in a color mapping in ANSI_COLORS_ALIASES. The color mapping was
    ignored.</dd>
  <dt>Invalid attribute name %s</dt>
  <dd>(F) You passed an invalid attribute name to <b>color()</b>,
      <b>colored()</b>, or <b>coloralias()</b>.</dd>
  <dt>Invalid attribute name %s in %s</dt>
  <dd>(W) You specified an invalid attribute name on the right hand of the equal
      sign in a color mapping in ANSI_COLORS_ALIASES. The color mapping was
      ignored.</dd>
  <dt>Name &quot;%s&quot; used only once: possible typo</dt>
  <dd>(W) You probably mistyped a constant color name such as:
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    print FOOBAR &quot;This text is color FOOBAR\n&quot;;
    </pre>
    <p class="Pp">It's probably better to always use commas after constant names
        in order to force the next error.</p>
  </dd>
  <dt>No comma allowed after filehandle</dt>
  <dd>(F) You probably mistyped a constant color name such as:
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    print FOOBAR, &quot;This text is color FOOBAR\n&quot;;
    </pre>
    <p class="Pp">Generating this fatal compile error is one of the main
        advantages of using the constants interface, since you'll immediately
        know if you mistype a color name.</p>
  </dd>
  <dt>No name for escape sequence %s</dt>
  <dd>(F) The ANSI escape sequence passed to <b>uncolor()</b> contains escapes
      which aren't recognized and can't be translated to names.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="ENVIRONMENT"><a class="permalink" href="#ENVIRONMENT">ENVIRONMENT</a></h1>
<dl class="Bl-tag">
  <dt>ANSI_COLORS_ALIASES</dt>
  <dd>This environment variable allows the user to specify custom color aliases
      that will be understood by <b>color()</b>, <b>colored()</b>, and
      <b>colorvalid()</b>. None of the other functions will be affected, and no
      new color constants will be created. The custom colors are aliases for
      existing color names; no new escape sequences can be introduced. Only
      alphanumerics, <span class="Li">&quot;.&quot;</span>,
      <span class="Li">&quot;_&quot;</span>, and
      <span class="Li">&quot;-&quot;</span> are allowed in alias names.
    <p class="Pp">The format is:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    ANSI_COLORS_ALIASES='newcolor1=oldcolor1,newcolor2=oldcolor2'
    </pre>
    <p class="Pp">Whitespace is ignored.</p>
    <p class="Pp">For example the Solarized
        &lt;http://ethanschoonover.com/solarized&gt; colors can be mapped
      with:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    ANSI_COLORS_ALIASES='\
        base00=bright_yellow, on_base00=on_bright_yellow,\
        base01=bright_green,  on_base01=on_bright_green, \
        base02=black,         on_base02=on_black,        \
        base03=bright_black,  on_base03=on_bright_black, \
        base0=bright_blue,    on_base0=on_bright_blue,   \
        base1=bright_cyan,    on_base1=on_bright_cyan,   \
        base2=white,          on_base2=on_white,         \
        base3=bright_white,   on_base3=on_bright_white,  \
        orange=bright_red,    on_orange=on_bright_red,   \
        violet=bright_magenta,on_violet=on_bright_magenta'
    </pre>
    <p class="Pp">This environment variable is read and applied when the
        Term::ANSIColor module is loaded and is then subsequently ignored.
        Changes to ANSI_COLORS_ALIASES after the module is loaded will have no
        effect. See <b>coloralias()</b> for an equivalent facility that can be
        used at runtime.</p>
  </dd>
  <dt>ANSI_COLORS_DISABLED</dt>
  <dd>If this environment variable is set to a true value, all of the functions
      defined by this module (<b>color()</b>, <b>colored()</b>, and all of the
      constants not previously used in the program) will not output any escape
      sequences and instead will just return the empty string or pass through
      the original text as appropriate. This is intended to support easy use of
      scripts using this module on platforms that don't support ANSI escape
      sequences.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="COMPATIBILITY"><a class="permalink" href="#COMPATIBILITY">COMPATIBILITY</a></h1>
Term::ANSIColor was first included with Perl in Perl 5.6.0.
<p class="Pp">The <b>uncolor()</b> function and support for ANSI_COLORS_DISABLED
    were added in Term::ANSIColor 1.04, included in Perl 5.8.0.</p>
<p class="Pp">Support for dark was added in Term::ANSIColor 1.08, included in
    Perl 5.8.4.</p>
<p class="Pp">The color stack, including the
    <span class="Li">&quot;:pushpop&quot;</span> import tag, PUSHCOLOR,
    POPCOLOR, LOCALCOLOR, and the
    <span class="Li">$Term::ANSIColor::AUTOLOCAL</span> variable, was added in
    Term::ANSIColor 2.00, included in Perl 5.10.1.</p>
<p class="Pp"><b>colorstrip()</b> was added in Term::ANSIColor 2.01 and
    <b>colorvalid()</b> was added in Term::ANSIColor 2.02, both included in Perl
    5.11.0.</p>
<p class="Pp">Support for colors 8 through 15 (the
    <span class="Li">&quot;bright_&quot;</span> variants) was added in
    Term::ANSIColor 3.00, included in Perl 5.13.3.</p>
<p class="Pp">Support for italic was added in Term::ANSIColor 3.02, included in
    Perl 5.17.1.</p>
<p class="Pp">Support for colors 16 through 256 (the
    <span class="Li">&quot;ansi&quot;</span>,
    <span class="Li">&quot;rgb&quot;</span>, and
    <span class="Li">&quot;grey&quot;</span> colors), the
    <span class="Li">&quot;:constants256&quot;</span> import tag, the
    <b>coloralias()</b> function, and support for the ANSI_COLORS_ALIASES
    environment variable were added in Term::ANSIColor 4.00, included in Perl
    5.17.8.</p>
<p class="Pp"><span class="Li">$Term::ANSIColor::AUTOLOCAL</span> was changed to
    take precedence over <span class="Li">$Term::ANSIColor::AUTORESET</span>,
    rather than the other way around, in Term::ANSIColor 4.00, included in Perl
    5.17.8.</p>
<p class="Pp"><span class="Li">&quot;ansi16&quot;</span> through
    <span class="Li">&quot;ansi255&quot;</span>, as aliases for the
    <span class="Li">&quot;rgb&quot;</span> and
    <span class="Li">&quot;grey&quot;</span> colors, and the corresponding
    <span class="Li">&quot;on_ansi&quot;</span> names and
    <span class="Li">&quot;ANSI&quot;</span> and
    <span class="Li">&quot;ON_ANSI&quot;</span> constants, were added in
    Term::ANSIColor 4.06.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="RESTRICTIONS"><a class="permalink" href="#RESTRICTIONS">RESTRICTIONS</a></h1>
It would be nice if one could leave off the commas around the constants entirely
  and just say:
<p class="Pp"><span class="Li"></span></p>
<pre>
    print BOLD BLUE ON_WHITE &quot;Text\n&quot; RESET;
</pre>
<p class="Pp">but the syntax of Perl doesn't allow this. You need a comma after
    the string. (Of course, you may consider it a bug that commas between all
    the constants aren't required, in which case you may feel free to insert
    commas unless you're using
    <span class="Li">$Term::ANSIColor::AUTORESET</span> or
  PUSHCOLOR/POPCOLOR.)</p>
<p class="Pp">For easier debugging, you may prefer to always use the commas when
    not setting <span class="Li">$Term::ANSIColor::AUTORESET</span> or
    PUSHCOLOR/POPCOLOR so that you'll get a fatal compile error rather than a
    warning.</p>
<p class="Pp">It's not possible to use this module to embed formatting and color
    attributes using Perl formats. They replace the escape character with a
    space (as documented in <b>perlform</b>(1)), resulting in garbled output
    from the unrecognized attribute. Even if there were a way around that
    problem, the format doesn't know that the non-printing escape sequence is
    zero-length and would incorrectly format the output. For formatted output
    using color or other attributes, either use <b>sprintf()</b> instead or use
    <b>formline()</b> and then add the color or other attributes after
    formatting and before output.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="NOTES"><a class="permalink" href="#NOTES">NOTES</a></h1>
The codes generated by this module are standard terminal control codes,
  complying with ECMA-048 and ISO 6429 (generally referred to as &quot;ANSI
  color&quot; for the color codes). The non-color control codes (bold, dark,
  italic, underline, and reverse) are part of the earlier ANSI X3.64 standard
  for control sequences for video terminals and peripherals.
<p class="Pp">Note that not all displays are ISO 6429-compliant, or even
    X3.64-compliant (or are even attempting to be so). This module will not work
    as expected on displays that do not honor these escape sequences, such as
    cmd.exe, 4nt.exe, and command.com under either Windows NT or Windows 2000.
    They may just be ignored, or they may display as an ESC character followed
    by some apparent garbage.</p>
<p class="Pp">Jean Delvare provided the following table of different common
    terminal emulators and their support for the various attributes and others
    have helped me flesh it out:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
              clear    bold     faint   under    blink   reverse  conceal
 ------------------------------------------------------------------------
 xterm         yes      yes      no      yes      yes      yes      yes
 linux         yes      yes      yes    bold      yes      yes      no
 rxvt          yes      yes      no      yes  bold/black   yes      no
 dtterm        yes      yes      yes     yes    reverse    yes      yes
 teraterm      yes    reverse    no      yes    rev/red    yes      no
 aixterm      kinda   normal     no      yes      no       yes      yes
 PuTTY         yes     color     no      yes      no       yes      no
 Windows       yes      no       no      no       no       yes      no
 Cygwin SSH    yes      yes      no     color    color    color     yes
 Terminal.app  yes      yes      no      yes      yes      yes      yes
</pre>
<p class="Pp">Windows is Windows telnet, Cygwin SSH is the OpenSSH
    implementation under Cygwin on Windows NT, and Mac Terminal is the Terminal
    application in Mac OS X. Where the entry is other than yes or no, that
    emulator displays the given attribute as something else instead. Note that
    on an aixterm, clear doesn't reset colors; you have to explicitly set the
    colors back to what you want. More entries in this table are welcome.</p>
<p class="Pp">Support for code 3 (italic) is rare and therefore not mentioned in
    that table. It is not believed to be fully supported by any of the terminals
    listed, although it's displayed as green in the Linux console, but it is
    reportedly supported by urxvt.</p>
<p class="Pp">Note that codes 6 (rapid blink) and 9 (strike-through) are
    specified in ANSI X3.64 and ECMA-048 but are not commonly supported by most
    displays and emulators and therefore aren't supported by this module at the
    present time. ECMA-048 also specifies a large number of other attributes,
    including a sequence of attributes for font changes, Fraktur characters,
    double-underlining, framing, circling, and overlining. As none of these
    attributes are widely supported or useful, they also aren't currently
    supported by this module.</p>
<p class="Pp">Most modern X terminal emulators support 256 colors. Known to not
    support those colors are aterm, rxvt, Terminal.app, and TTY/VC.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHORS"><a class="permalink" href="#AUTHORS">AUTHORS</a></h1>
Original idea (using constants) by Zenin, reimplemented using subs by Russ
  Allbery &lt;rra@cpan.org&gt;, and then combined with the original idea by Russ
  with input from Zenin. 256-color support is based on work by Kurt Starsinic.
  Russ Allbery now maintains this module.
<p class="Pp">PUSHCOLOR, POPCOLOR, and LOCALCOLOR were contributed by
    openmethods.com voice solutions.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT_AND_LICENSE"><a class="permalink" href="#COPYRIGHT_AND_LICENSE">COPYRIGHT
  AND LICENSE</a></h1>
Copyright 1996 Zenin
<p class="Pp">Copyright 1996, 1997, 1998, 2000, 2001, 2002, 2005, 2006, 2008,
    2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016 Russ Allbery
    &lt;rra@cpan.org&gt;</p>
<p class="Pp">Copyright 2012 Kurt Starsinic &lt;kstarsinic@gmail.com&gt;</p>
<p class="Pp">This program is free software; you may redistribute it and/or
    modify it under the same terms as Perl itself.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
The CPAN module Term::ExtendedColor provides a different and more comprehensive
  interface for 256-color emulators that may be more convenient. The CPAN module
  Win32::Console::ANSI provides ANSI color (and other escape sequence) support
  in the Win32 Console environment. The CPAN module Term::Chrome provides a
  different interface using objects and operator overloading.
<p class="Pp">ECMA-048 is available on-line (at least at the time of this
    writing) at
    &lt;http://www.ecma-international.org/publications/standards/Ecma-048.htm&gt;.</p>
<p class="Pp">ISO 6429 is available from ISO for a charge; the author of this
    module does not own a copy of it. Since the source material for ISO 6429 was
    ECMA-048 and the latter is available for free, there seems little reason to
    obtain the ISO standard.</p>
<p class="Pp">The 256-color control sequences are documented at
    &lt;http://invisible-island.net/xterm/ctlseqs/ctlseqs.html&gt; (search for
    256-color).</p>
<p class="Pp">The current version of this module is always available from its
    web site at &lt;https://www.eyrie.org/~eagle/software/ansicolor/&gt;. It is
    also part of the Perl core distribution as of 5.6.0.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2019-10-24</td>
    <td class="foot-os">perl v5.30.2</td>
  </tr>
</table>
</body>
</html>
