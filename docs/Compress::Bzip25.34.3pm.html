<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    .Nd, .Bf, .Op { display: inline; }
    .Pa, .Ad { font-style: italic; }
    .Ms { font-weight: bold; }
    .Bl-diag > dt { font-weight: bold; }
    code.Nm, .Fl, .Cm, .Ic, code.In, .Fd, .Fn, .Cd { font-weight: bold;
      font-family: inherit; }
  </style>
  <title>Compress::Bzip2(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Compress::Bzip2(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Compress::Bzip2(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Compress::Bzip2 - Interface to Bzip2 compression library</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>    use Compress::Bzip2 qw(:all :constant :utilities :gzip);
    ($bz, $status) = bzdeflateInit( [PARAMS] );
    ($out, $status) = $bz-&gt;bzdeflate($buffer) ; # compress
    ($bz, $status) = bzinflateInit( [PARAMS] );
    ($out, $status) = $bz-&gt;bzinflate($buffer);  # uncompress
    ($out, $status) = $bz-&gt;bzflush() ;
    ($out, $status) = $bz-&gt;bzclose() ;
    $dest = memBzip($source);
        alias compress
    $dest = memBunzip($source);
        alias decompress
    $bz = Compress::Bzip2-&gt;new( [PARAMS] );
    $bz = bzopen($filename or filehandle, $mode);
        alternate, with $bz created by new():
    $bz-&gt;bzopen($filename or filehandle, $mode);
    $bytesread = $bz-&gt;bzread($buffer [,$size]) ;
    $bytesread = $bz-&gt;bzreadline($line);
    $byteswritten = $bz-&gt;bzwrite($buffer [,$limit]);
    $errstring = $bz-&gt;bzerror();
    $status = $bz-&gt;bzeof();
    $status = $bz-&gt;bzflush();
    $status = $bz-&gt;bzclose() ;
    $status = $bz-&gt;bzsetparams( $param =&gt; $setting );
    $bz-&gt;total_in() ;
    $bz-&gt;total_out() ;
    $verstring = $bz-&gt;bzversion();
    $Compress::Bzip2::bzerrno
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">The <i>Compress::Bzip2</i> module provides a Perl interface to the
    <b>bzip2</b> compression library (see &quot;AUTHOR&quot; for details about
    where to get <i>Bzip2</i>). A relevant subset of the functionality provided
    by <i>bzip2</i> is available in <i>Compress::Bzip2</i>.</p>
<p class="Pp">All string parameters can either be a scalar or a scalar
    reference.</p>
<p class="Pp">The module can be split into two general areas of functionality,
    namely in-memory compression/decompression and read/write access to
    <i>bzip2</i> files. Each of these areas will be discussed separately
  below.</p>
<p class="Pp"><b>NOTE</b></p>
<p class="Pp"><i>Compress::Bzip2</i> is just a simple <i>bzip2</i> binding,
    comparable to the old Compress::Zlib library. It is not well integrated into
    PerlIO, use the preferred IO::Compress::Bzip2 instead.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="FILE_READ/WRITE_INTERFACE"><a class="permalink" href="#FILE_READ/WRITE_INTERFACE">FILE
  READ/WRITE INTERFACE</a></h1>
<p class="Pp">A number of functions are supplied in <i>bzlib</i> for reading and
    writing <i>bzip2</i> files. Unfortunately, most of them are not suitable.
    So, this module provides another interface, built over top of the low level
    bzlib methods.</p>
<section class="Ss">
<h2 class="Ss"><b></b><span class="Li"><b>$bz</b></span><b> = bzopen(filename or
  filehandle, mode)</b></h2>
<p class="Pp">This function returns an object which is used to access the other
    <i>bzip2</i> methods.</p>
<p class="Pp">The <b>mode</b> parameter is used to specify both whether the file
    is opened for reading or writing, with &quot;r&quot; or &quot;w&quot;
    respectively.</p>
<p class="Pp">If a reference to an open filehandle is passed in place of the
    filename, it better be positioned to the start of a
    compression/decompression sequence.</p>
<p class="Pp">WARNING: With Perl 5.6 you cannot use a filehandle because of SEGV
    in destruction with bzclose or an implicit close.</p>
</section>
<section class="Ss">
<h2 class="Ss"><b></b><span class="Li"><b>$bz</b></span><b> =
  Compress::Bzip2-&gt;new( [PARAMS] )</b></h2>
<p class="Pp">Create a Compress::Bzip2 object. Optionally, provide
    compression/decompression parameters as a keyword =&gt; setting list. See
    <i></i><b><i>bzsetparams()</i></b><i></i> for a description of the
    parameters.</p>
</section>
<section class="Ss">
<h2 class="Ss"><b></b><span class="Li"><b>$bz</b></span><b>-&gt;bzopen(filename
  or filehandle, mode)</b></h2>
<p class="Pp">This is bzopen, but it uses an object previously created by the
    new method. Other than that, it is identical to the above bzopen.</p>
</section>
<section class="Ss">
<h2 class="Ss"><b></b><span class="Li"><b>$bytesread</b></span><b> =
  </b><span class="Li"><b>$bz</b></span><b>-&gt;bzread($buffer [,
  </b><span class="Li"><b>$size</b></span><b>]) ;</b></h2>
<p class="Pp">Reads <b></b><span class="Li"><b>$size</b></span><b></b> bytes
    from the compressed file into
    <b></b><span class="Li"><b>$buffer</b></span><b></b>. If
    <b></b><span class="Li"><b>$size</b></span><b></b> is not specified, it will
    default to 4096. If the scalar
    <b></b><span class="Li"><b>$buffer</b></span><b></b> is not large enough, it
    will be extended automatically.</p>
<p class="Pp">Returns the number of bytes actually read. On EOF it returns 0 and
    in the case of an error, -1.</p>
</section>
<section class="Ss">
<h2 class="Ss"><b></b><span class="Li"><b>$bytesread</b></span><b> =
  </b><span class="Li"><b>$bz</b></span><b>-&gt;bzreadline($line) ;</b></h2>
<p class="Pp">Reads the next line from the compressed file into
    <b></b><span class="Li"><b>$line</b></span><b></b>.</p>
<p class="Pp">Returns the number of bytes actually read. On EOF it returns 0 and
    in the case of an error, -1.</p>
<p class="Pp">It IS legal to intermix calls to <b>bzread</b> and
    <b>bzreadline</b>.</p>
<p class="Pp">At this time <b>bzreadline</b> ignores the variable
    <span class="Li">$/</span> (<span class="Li">$INPUT_RECORD_SEPARATOR</span>
    or <span class="Li">$RS</span> when
    <span class="Li">&quot;English&quot;</span> is in use). The end of a line is
    denoted by the C character <span class="Li">'\n'</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss"><b></b><span class="Li"><b>$byteswritten</b></span><b> =
  </b><span class="Li"><b>$bz</b></span><b>-&gt;bzwrite($buffer [,
  </b><span class="Li"><b>$limit</b></span><b>]) ;</b></h2>
<p class="Pp">Writes the contents of
    <b></b><span class="Li"><b>$buffer</b></span><b></b> to the compressed file.
    Returns the number of bytes actually written, or 0 on error.</p>
<p class="Pp">If <span class="Li">$limit</span> is given and non-zero, then only
    that many bytes from <span class="Li">$buffer</span> will be written.</p>
</section>
<section class="Ss">
<h2 class="Ss"><b></b><span class="Li"><b>$status</b></span><b> =
  </b><span class="Li"><b>$bz</b></span><b>-&gt;bzflush($flush) ;</b></h2>
<p class="Pp">Flushes all pending output to the compressed file. Works
    identically to the <i>zlib</i> function it interfaces to. Note that the use
    of <b>bzflush</b> can degrade compression.</p>
<p class="Pp">Returns <span class="Li">&quot;BZ_OK&quot;</span> if
    <b></b><span class="Li"><b>$flush</b></span><b></b> is
    <span class="Li">&quot;BZ_FINISH&quot;</span> and all output could be
    flushed. Otherwise the bzlib error code is returned.</p>
<p class="Pp">Refer to the <i>bzlib</i> documentation for the valid values of
    <b></b><span class="Li"><b>$flush</b></span><b></b>.</p>
</section>
<section class="Ss">
<h2 class="Ss"><b></b><span class="Li"><b>$status</b></span><b> =
  </b><span class="Li"><b>$bz</b></span><b>-&gt;bzeof() ;</b></h2>
<p class="Pp">Returns 1 if the end of file has been detected while reading the
    input file, otherwise returns 0.</p>
</section>
<section class="Ss">
<h2 class="Ss"><b></b><span class="Li"><b>$bz</b></span><b>-&gt;bzclose</b></h2>
<p class="Pp">Closes the compressed file. Any pending data is flushed to the
    file before it is closed.</p>
</section>
<section class="Ss">
<h2 class="Ss"><b></b><span class="Li"><b>$bz</b></span><b>-&gt;bzsetparams(
  [PARAMS] );</b></h2>
<p class="Pp">Change settings for the deflate stream
    <span class="Li">$bz</span>.</p>
<p class="Pp">The list of the valid options is shown below. Options not
    specified will remain unchanged.</p>
<dl class="Bl-tag">
  <dt id="verbosity"><a class="permalink" href="#verbosity"><b>-verbosity</b></a></dt>
  <dd>Defines the verbosity level. Valid values are 0 through 4,
    <p class="Pp">The default is <span class="Li">&quot;-verbosity =&gt;
        0&quot;</span>.</p>
  </dd>
  <dt id="blockSize100k"><a class="permalink" href="#blockSize100k"><b>-blockSize100k</b></a></dt>
  <dd>For bzip object opened for stream deflation or write.
    <p class="Pp">Defines the buffering factor of compression method. The
        algorithm buffers all data until the buffer is full, then it flushes all
        the data out. Use -blockSize100k to specify the size of the buffer.</p>
    <p class="Pp">Valid settings are 1 through 9, representing a blocking in
        multiples of 100k.</p>
    <p class="Pp">Note that each such block has an overhead of leading and
        trailing synchronization bytes. bzip2 recovery uses this information to
        pull useable data out of a corrupted file.</p>
    <p class="Pp">A streaming application would probably want to set the
        blocking low.</p>
  </dd>
  <dt id="workFactor"><a class="permalink" href="#workFactor"><b>-workFactor</b></a></dt>
  <dd>For bzip object opened for stream deflation or write.
    <p class="Pp">The workFactor setting tells the deflation algorithm how much
        work to invest to compensate for repetitive data.</p>
    <p class="Pp">workFactor may be a number from 0 to 250 inclusive. The
        default setting is 30.</p>
    <p class="Pp">See the bzip documentation for more information.</p>
  </dd>
  <dt id="small"><a class="permalink" href="#small"><b>-small</b></a></dt>
  <dd>For bzip object opened for stream inflation or read.
    <p class="Pp"><b>small</b> may be 0 or 1. Set
        <span class="Li">&quot;small&quot;</span> to one to use a slower, less
        memory intensive algorithm.</p>
  </dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss"><b></b><span class="Li"><b>$bz</b></span><b>-&gt;bzerror</b></h2>
<p class="Pp">Returns the <i>bzlib</i> error message or number for the last
    operation associated with <b></b><span class="Li"><b>$bz</b></span><b></b>.
    The return value will be the <i>bzlib</i> error number when used in a
    numeric context and the <i>bzlib</i> error message when used in a string
    context. The <i>bzlib</i> error number constants, shown below, are available
    for use.</p>
<p class="Pp"></p>
<pre>  BZ_CONFIG_ERROR
  BZ_DATA_ERROR
  BZ_DATA_ERROR_MAGIC
  BZ_FINISH
  BZ_FINISH_OK
  BZ_FLUSH
  BZ_FLUSH_OK
  BZ_IO_ERROR
  BZ_MAX_UNUSED
  BZ_MEM_ERROR
  BZ_OK
  BZ_OUTBUFF_FULL
  BZ_PARAM_ERROR
  BZ_RUN
  BZ_RUN_OK
  BZ_SEQUENCE_ERROR
  BZ_STREAM_END
  BZ_UNEXPECTED_EOF
</pre>
</section>
<section class="Ss">
<h2 class="Ss"><b></b><span class="Li"><b>$bz</b></span><b>-&gt;bzclearerr</b></h2>
</section>
<section class="Ss">
<h2 class="Ss"><b></b><span class="Li"><b>$bzerrno</b></span><b></b></h2>
<p class="Pp">The <b></b><span class="Li"><b>$bzerrno</b></span><b></b> scalar
    holds the error code associated with the most recent <i>bzip2</i> routine.
    Note that unlike <b></b><b>bzerror()</b><b></b>, the error is <i>not</i>
    associated with a particular file.</p>
<p class="Pp">As with <b></b><b>bzerror()</b><b></b> it returns an error number
    in numeric context and an error message in string context. Unlike
    <b></b><b>bzerror()</b><b></b> though, the error message will correspond to
    the <i>bzlib</i> message when the error is associated with <i>bzlib</i>
    itself, or the UNIX error message when it is not (i.e. <i>bzlib</i> returned
    <span class="Li">&quot;Z_ERRORNO&quot;</span>).</p>
<p class="Pp">As there is an overlap between the error numbers used by
    <i>bzlib</i> and UNIX, <b></b><span class="Li"><b>$bzerrno</b></span><b></b>
    should only be used to check for the presence of <i>an</i> error in numeric
    context. Use <b></b><b>bzerror()</b><b></b> to check for specific
    <i>bzlib</i> errors. The <i>bzcat</i> example below shows how the variable
    can be used safely.</p>
</section>
<section class="Ss">
<h2 class="Ss"><b></b><span class="Li"><b>$bz</b></span><b>-&gt;prefix</b></h2>
<p class="Pp">Returns the additional 5 byte header which is prepended to the
    bzip2 header starting with <span class="Li">&quot;BZh&quot;</span> when
    using memBzip/compress.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="Compress::Bzip2_Utilities"><a class="permalink" href="#Compress::Bzip2_Utilities">Compress::Bzip2
  Utilities</a></h1>
<p class="Pp">Options: -d -c -z -f -v -k -s -1..9</p>
<section class="Ss">
<h2 class="Ss" id="bzip2(__"><a class="permalink" href="#bzip2(__">bzip2(
  [OPTS], filename)</a></h2>
</section>
<section class="Ss">
<h2 class="Ss" id="bunzip2(filename)"><a class="permalink" href="#bunzip2(filename)">bunzip2(filename)</a></h2>
</section>
<section class="Ss">
<h2 class="Ss" id="bzcat(filenames...)"><a class="permalink" href="#bzcat(filenames...)">bzcat(filenames...)</a></h2>
</section>
<section class="Ss">
<h2 class="Ss"><b>bzlibversion()</b></h2>
</section>
<section class="Ss">
<h2 class="Ss" id="bzinflateInit(_opts..._)"><a class="permalink" href="#bzinflateInit(_opts..._)">bzinflateInit(
  opts... )</a></h2>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="Internal_Utilties"><a class="permalink" href="#Internal_Utilties">Internal
  Utilties</a></h1>
<section class="Ss">
<h2 class="Ss" id="bz_seterror(errno,_msg)_=head2_$bz"><a class="permalink" href="#bz_seterror(errno,_msg)_=head2_$bz">bz_seterror(errno,
  msg) =head2 $bz-&gt;<b>is_read()</b> =head2 $bz-&gt;<b>is_stream()</b> =head2
  $bz-&gt;<b>is_write()</b> =head2 $bz-&gt;<b>total_in()</b> =head2
  $bz-&gt;<b>total_out()</b> =head2 <b>version()</b></a></h2>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="Compress::Bzip2_1.03_COMPATIBILITY"><a class="permalink" href="#Compress::Bzip2_1.03_COMPATIBILITY">Compress::Bzip2
  1.03 COMPATIBILITY</a></h1>
<p class="Pp">While the 2.x thread forked off of 1.00, another line of
    development came to a head at 1.03. The 1.03 version worked with bzlib
    1.0.2, had improvements to the error handling, single buffer
    inflate/deflate, a streaming interface to inflate/deflate, and a cpan style
    test suite.</p>
<section class="Ss">
<h2 class="Ss"><b></b><span class="Li"><b>$dest</b></span><b> = compress(
  </b><span class="Li"><b>$string</b></span><b>, [$level] )</b></h2>
<p class="Pp">Alias to memBzip, this compresses string, using the optional
    compression level, 1 through 9, the default being 6. Returns a string
    containing the compressed data.</p>
<p class="Pp">On error <i>undef</i> is returned.</p>
</section>
<section class="Ss">
<h2 class="Ss"><b></b><span class="Li"><b>$dest</b></span><b> =
  decompress($string, [$level])</b></h2>
<p class="Pp">Alias to memBunzip, this decompresses the data in string,
    returning a string containing the decompressed data.</p>
<p class="Pp">On error <i>undef</i> is returned.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="uncompress($string,__$level_)"><a class="permalink" href="#uncompress($string,__$level_)">uncompress($string,
  [$level])</a></h2>
<p class="Pp">Another alias to memBunzip</p>
</section>
<section class="Ss">
<h2 class="Ss"><b></b><span class="Li"><b>$stream</b></span><b> = compress_init(
  [PARAMS] )</b></h2>
<p class="Pp">Alias to bzdeflateInit. In addition to the named parameters
    documented for bzdeflateInit, the following are accepted:</p>
<p class="Pp"></p>
<pre>   -level, alias to -blockSize100k
   -buffer, to set the buffer size.
</pre>
<p class="Pp">The -buffer option is ignored. The intermediate buffer size is not
    changeable.</p>
</section>
<section class="Ss">
<h2 class="Ss"><b></b><span class="Li"><b>$stream</b></span><b> =
  decompress_init( [PARAMS] )</b></h2>
<p class="Pp">Alias to bzinflateInit. See bzinflateInit for a description of the
    parameters. The option &quot;-buffer&quot; is accepted, but ignored.</p>
</section>
<section class="Ss">
<h2 class="Ss"><b></b><span class="Li"><b>$output</b></span><b> =
  </b><span class="Li"><b>$stream</b></span><b>-&gt;add(
  </b><span class="Li"><b>$string</b></span><b> )</b></h2>
<p class="Pp">Add data to be compressed/decompressed. Returns whatever output is
    available (possibly none, if it's still buffering it), or undef on
  error.</p>
</section>
<section class="Ss">
<h2 class="Ss"><b></b><span class="Li"><b>$output</b></span><b> =
  </b><span class="Li"><b>$stream</b></span><b>-&gt;finish( [$string] )</b></h2>
<p class="Pp">Finish the operation; takes an optional final data string.
    Whatever is returned completes the output; returns undef on error.</p>
</section>
<section class="Ss">
<h2 class="Ss"><b></b><span class="Li"><b>$stream</b></span><b>-&gt;error</b></h2>
<p class="Pp">Like the function, but applies to the current object only. Note
    that errors in a stream object are also returned by the function.</p>
</section>
<section class="Ss">
<h2 class="Ss"><b></b><span class="Li"><b>$stream</b></span><b>-&gt;input_size</b></h2>
<p class="Pp">Alias to total_in. Total bytes passed to the stream.</p>
</section>
<section class="Ss">
<h2 class="Ss"><b></b><span class="Li"><b>$stream</b></span><b>-&gt;output_size</b></h2>
<p class="Pp">Alias to total_out. Total bytes received from the stream.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="GZIP_COMPATIBILITY_INTERFACE"><a class="permalink" href="#GZIP_COMPATIBILITY_INTERFACE">GZIP
  COMPATIBILITY INTERFACE</a></h1>
<p class="Pp">Except for the exact state and error numbers, this package
    presents an interface very much like that given by the Compress::Zlib
    package. Mostly, if you take the method name, state or error number from
    Compress::Zlib and replace the &quot;g&quot; with a &quot;b&quot;, your code
    should work.</p>
<p class="Pp">To make the interoperability even easier, all the Compress::Zlib
    method names have been used as aliases or cover functions for the bzip2
    methods.</p>
<p class="Pp">Therefore, most code that uses Compress::Zlib should be able to
    use this package, with a one line change.</p>
<p class="Pp">Simply change</p>
<p class="Pp"></p>
<pre>   $gz = Compress::Zlib::gzopen( &quot;filename&quot;, &quot;w&quot; );
</pre>
<p class="Pp">to</p>
<p class="Pp"></p>
<pre>   $gz = Compress::Bzip2::gzopen( &quot;filename&quot;, &quot;w&quot; );
</pre>
<p class="Pp">Some of the Compress::Zlib aliases don't return anything useful,
    like crc32 or adler32, cause bzip2 doesn't do that sort of thing.</p>
<section class="Ss">
<h2 class="Ss"><b> </b><span class="Li"><b>$gz</b></span><b> = gzopen(
  </b><span class="Li"><b>$filename</b></span><b>,
  </b><span class="Li"><b>$mode</b></span><b> ) </b></h2>
<p class="Pp">Alias for bzopen.</p>
</section>
<section class="Ss">
<h2 class="Ss"><b> </b><span class="Li"><b>$gz</b></span><b>-&gt;gzread(
  </b><span class="Li"><b>$buffer</b></span><b>, [
  </b><span class="Li"><b>$length</b></span><b> ] ) </b></h2>
<p class="Pp">Alias for bzread.</p>
</section>
<section class="Ss">
<h2 class="Ss"><b> </b><span class="Li"><b>$gz</b></span><b>-&gt;gzreadline(
  </b><span class="Li"><b>$buffer</b></span><b> ) </b></h2>
<p class="Pp">Alias for bzreadline.</p>
</section>
<section class="Ss">
<h2 class="Ss"><b> </b><span class="Li"><b>$gz</b></span><b>-&gt;gzwrite(
  </b><span class="Li"><b>$buffer</b></span><b> ) </b></h2>
<p class="Pp">Alias for bzwrite.</p>
</section>
<section class="Ss">
<h2 class="Ss"><b> </b><span class="Li"><b>$gz</b></span><b>-&gt;gzflush(
  [$flushtype] ) </b></h2>
<p class="Pp">Alias for bzflush, with return code translation.</p>
</section>
<section class="Ss">
<h2 class="Ss"><b> </b><span class="Li"><b>$gz</b></span><b>-&gt;gzclose( )
  </b></h2>
<p class="Pp">Alias for bzclose.</p>
</section>
<section class="Ss">
<h2 class="Ss"><b> </b><span class="Li"><b>$gz</b></span><b>-&gt;gzeof( )
  </b></h2>
<p class="Pp">Alias for bzeof.</p>
</section>
<section class="Ss">
<h2 class="Ss"><b> </b><span class="Li"><b>$gz</b></span><b>-&gt;gzerror( )
  </b></h2>
<p class="Pp">Alias for bzerror.</p>
</section>
<section class="Ss">
<h2 class="Ss"><b> </b><span class="Li"><b>$gz</b></span><b>-&gt;gzsetparams(
  </b><span class="Li"><b>$level</b></span><b>,
  </b><span class="Li"><b>$strategy</b></span><b> ) </b></h2>
<p class="Pp">This is a no-op.</p>
</section>
<section class="Ss">
<h2 class="Ss"><b> </b><span class="Li"><b>$d</b></span><b> = deflateInit(
  [OPTS] ) </b></h2>
<p class="Pp">Alias for bzdeflateInit, with return code translation.</p>
<p class="Pp">All OPTS are ignored.</p>
</section>
<section class="Ss">
<h2 class="Ss"><b> </b><span class="Li"><b>$d</b></span><b>-&gt;deflate(
  </b><span class="Li"><b>$buffer</b></span><b> ) </b></h2>
<p class="Pp">Alias for bzdeflate, with return code translation.</p>
</section>
<section class="Ss">
<h2 class="Ss"><b> </b><span class="Li"><b>$d</b></span><b>-&gt;deflateParams(
  [OPTS] ) </b></h2>
<p class="Pp">This is a no-op.</p>
</section>
<section class="Ss">
<h2 class="Ss"><b> </b><span class="Li"><b>$d</b></span><b>-&gt;flush(
  [$flushtype] ) </b></h2>
<p class="Pp">Cover function for bzflush or bzclose, depending on
    <span class="Li">$flushtype</span>.</p>
<p class="Pp">See the Compress::Zlib documentation for more information.</p>
</section>
<section class="Ss">
<h2 class="Ss"><b> </b><span class="Li"><b>$d</b></span><b>-&gt;dict_adler( )
  </b></h2>
<p class="Pp">This is a no-op.</p>
</section>
<section class="Ss">
<h2 class="Ss"><b> </b><span class="Li"><b>$d</b></span><b>-&gt;msg( ) </b></h2>
<p class="Pp">This is a no-op.</p>
</section>
<section class="Ss">
<h2 class="Ss"><b> </b><span class="Li"><b>$d</b></span><b> = inflateInit(
  [OPTS] ) </b></h2>
<p class="Pp">Alias for bzinflateInit, with return code translation.</p>
<p class="Pp">All OPTS are ignored.</p>
</section>
<section class="Ss">
<h2 class="Ss"><b> </b><span class="Li"><b>$d</b></span><b>-&gt;inflate( )
  </b></h2>
<p class="Pp">Alias for bzinflate, with return code translation.</p>
</section>
<section class="Ss">
<h2 class="Ss"><b> </b><span class="Li"><b>$d</b></span><b>-&gt;inflateSync( )
  </b></h2>
<p class="Pp">This is a no-op.</p>
</section>
<section class="Ss">
<h2 class="Ss"><b> </b><span class="Li"><b>$d</b></span><b>-&gt;adler32(
  </b><span class="Li"><b>$crc</b></span><b> ) </b></h2>
<p class="Pp">This is a no-op.</p>
</section>
<section class="Ss">
<h2 class="Ss"><b> </b><span class="Li"><b>$d</b></span><b>-&gt;crc32(
  </b><span class="Li"><b>$crc</b></span><b> ) </b></h2>
<p class="Pp">This is a no-op.</p>
</section>
<section class="Ss">
<h2 class="Ss"><b> </b><span class="Li"><b>$buffer</b></span><b> = memGzip(
  </b><span class="Li"><b>$buffer</b></span><b> ) </b></h2>
<p class="Pp">Alias for memBzip.</p>
</section>
<section class="Ss">
<h2 class="Ss"><b> </b><span class="Li"><b>$buffer</b></span><b> = memGunzip(
  </b><span class="Li"><b>$buffer</b></span><b> ) </b></h2>
<p class="Pp">Alias for memBunzip.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="IN-MEMORY_COMPRESS/UNCOMPRESS"><a class="permalink" href="#IN-MEMORY_COMPRESS/UNCOMPRESS">IN-MEMORY
  COMPRESS/UNCOMPRESS</a></h1>
<p class="Pp">Two high-level functions are provided by <i>bzlib</i> to perform
    in-memory compression. They are <b>memBzip</b> and <b>memBunzip</b>. Two
    Perl subs are provided which provide similar functionality.</p>
<section class="Ss">
<h2 class="Ss"><b></b><span class="Li"><b>$compressed</b></span><b> =
  memBzip($buffer);</b></h2>
<p class="Pp">Compresses <b></b><span class="Li"><b>$buffer</b></span><b></b>.
    If successful it returns the compressed data. Otherwise it returns
    <i>undef</i>.</p>
<p class="Pp">The buffer parameter can either be a scalar or a scalar
  reference.</p>
<p class="Pp">Essentially, an in-memory bzip file is created. It creates a
    minimal bzip header, which adds 5 bytes before the bzip2 specific BZh
    header.</p>
</section>
<section class="Ss">
<h2 class="Ss"><b></b><span class="Li"><b>$uncompressed</b></span><b> =
  memBunzip($buffer);</b></h2>
<p class="Pp">Uncompresses <b></b><span class="Li"><b>$buffer</b></span><b></b>.
    If successful it returns the uncompressed data. Otherwise it returns
    <i>undef</i>.</p>
<p class="Pp">The source buffer can either be a scalar or a scalar
  reference.</p>
<p class="Pp">The buffer parameter can either be a scalar or a scalar reference.
    The contents of the buffer parameter are destroyed after calling this
    function.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="STREAM_DEFLATE_(=_COMPRESS)"><a class="permalink" href="#STREAM_DEFLATE_(=_COMPRESS)">STREAM
  DEFLATE (= COMPRESS)</a></h1>
<p class="Pp">The Perl interface will <i>always</i> consume the complete input
    buffer before returning. Also the output buffer returned will be
    automatically grown to fit the amount of output available.</p>
<p class="Pp">Here is a definition of the interface available:</p>
<section class="Ss">
<h2 class="Ss"><b>($d, </b><span class="Li"><b>$status</b></span><b>) =
  bzdeflateInit( [PARAMS] )</b></h2>
<p class="Pp">Initialises a deflation stream.</p>
<p class="Pp">If successful, it will return the initialised deflation stream,
    <b></b><span class="Li"><b>$d</b></span><b></b> and
    <b></b><span class="Li"><b>$status</b></span><b></b> of
    <span class="Li">&quot;BZ_OK&quot;</span> in a list context. In scalar
    context it returns the deflation stream,
    <b></b><span class="Li"><b>$d</b></span><b></b>, only.</p>
<p class="Pp">If not successful, the returned deflation stream
    (<b></b><span class="Li"><b>$d</b></span><b></b>) will be <i>undef</i> and
    <b></b><span class="Li"><b>$status</b></span><b></b> will hold the exact
    <i>bzip2</i> error code.</p>
<p class="Pp">The function optionally takes a number of named options specified
    as <span class="Li">&quot;-Name=&gt;value&quot;</span> pairs. This allows
    individual options to be tailored without having to specify them all in the
    parameter list.</p>
<p class="Pp">Here is a list of the valid options:</p>
<dl class="Bl-tag">
  <dt id="verbosity~2"><a class="permalink" href="#verbosity~2"><b>-verbosity</b></a></dt>
  <dd>Defines the verbosity level. Valid values are 0 through 4,
    <p class="Pp">The default is <span class="Li">&quot;-verbosity =&gt;
        0&quot;</span>.</p>
  </dd>
  <dt id="blockSize100k~2"><a class="permalink" href="#blockSize100k~2"><b>-blockSize100k</b></a></dt>
  <dd>Defines the buffering factor of compression method. The algorithm buffers
      all data until the buffer is full, then it flushes all the data out. Use
      -blockSize100k to specify the size of the buffer.
    <p class="Pp">Valid settings are 1 through 9, representing a blocking in
        multiples of 100k.</p>
    <p class="Pp">Note that each such block has an overhead of leading and
        trailing synchronization bytes. bzip2 recovery uses this information to
        pull useable data out of a corrupted file.</p>
    <p class="Pp">A streaming application would probably want to set the
        blocking low.</p>
  </dd>
  <dt id="workFactor~2"><a class="permalink" href="#workFactor~2"><b>-workFactor</b></a></dt>
  <dd>The workFactor setting tells the deflation algorithm how much work to
      invest to compensate for repetitive data.
    <p class="Pp">workFactor may be a number from 0 to 250 inclusive. The
        default setting is 30.</p>
    <p class="Pp">See the bzip documentation for more information.</p>
  </dd>
</dl>
<p class="Pp">Here is an example of using the <b>deflateInit</b> optional
    parameter list to override the default buffer size and compression level.
    All other options will take their default values.</p>
<p class="Pp"></p>
<pre>    bzdeflateInit( -blockSize100k =&gt; 1, -verbosity =&gt; 1 );
</pre>
</section>
<section class="Ss">
<h2 class="Ss"><b>($out, </b><span class="Li"><b>$status</b></span><b>) =
  </b><span class="Li"><b>$d</b></span><b>-&gt;bzdeflate($buffer)</b></h2>
<p class="Pp">Deflates the contents of
    <b></b><span class="Li"><b>$buffer</b></span><b></b>. The buffer can either
    be a scalar or a scalar reference. When finished,
    <b></b><span class="Li"><b>$buffer</b></span><b></b> will be completely
    processed (assuming there were no errors). If the deflation was successful
    it returns deflated output,
    <b></b><span class="Li"><b>$out</b></span><b></b>, and a status value,
    <b></b><span class="Li"><b>$status</b></span><b></b>, of
    <span class="Li">&quot;Z_OK&quot;</span>.</p>
<p class="Pp">On error, <b></b><span class="Li"><b>$out</b></span><b></b> will
    be <i>undef</i> and <b></b><span class="Li"><b>$status</b></span><b></b>
    will contain the <i>zlib</i> error code.</p>
<p class="Pp">In a scalar context <b>bzdeflate</b> will return
    <b></b><span class="Li"><b>$out</b></span><b></b> only.</p>
<p class="Pp">As with the internal buffering of the <i>deflate</i> function in
    <i>bzip2</i>, it is not necessarily the case that any output will be
    produced by this method. So don't rely on the fact that
    <b></b><span class="Li"><b>$out</b></span><b></b> is empty for an error
    test. In fact, given the size of bzdeflates internal buffer, with most files
    it's likely you won't see any output at all until flush or close.</p>
</section>
<section class="Ss">
<h2 class="Ss"><b>($out, </b><span class="Li"><b>$status</b></span><b>) =
  </b><span class="Li"><b>$d</b></span><b>-&gt;bzflush([flush_type])</b></h2>
<p class="Pp">Typically used to finish the deflation. Any pending output will be
    returned via <b></b><span class="Li"><b>$out</b></span><b></b>.
    <b></b><span class="Li"><b>$status</b></span><b></b> will have a value
    <span class="Li">&quot;BZ_OK&quot;</span> if successful.</p>
<p class="Pp">In a scalar context <b>bzflush</b> will return
    <b></b><span class="Li"><b>$out</b></span><b></b> only.</p>
<p class="Pp">Note that flushing can seriously degrade the compression ratio, so
    it should only be used to terminate a decompression (using
    <span class="Li">&quot;BZ_FLUSH&quot;</span>) or when you want to create a
    <i>full flush point</i> (using
    <span class="Li">&quot;BZ_FINISH&quot;</span>).</p>
<p class="Pp">The allowable values for
    <span class="Li">&quot;flush_type&quot;</span> are
    <span class="Li">&quot;BZ_FLUSH&quot;</span> and
    <span class="Li">&quot;BZ_FINISH&quot;</span>.</p>
<p class="Pp">For a handle opened for &quot;w&quot; (bzwrite), the default is
    <span class="Li">&quot;BZ_FLUSH&quot;</span>. For a stream, the default for
    <span class="Li">&quot;flush_type&quot;</span> is
    <span class="Li">&quot;BZ_FINISH&quot;</span> (which is essentially a close
    and reopen).</p>
<p class="Pp">It is strongly recommended that you only set the
    <span class="Li">&quot;flush_type&quot;</span> parameter if you fully
    understand the implications of what it does. See the
    <span class="Li">&quot;bzip2&quot;</span> documentation for details.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Example"><a class="permalink" href="#Example">Example</a></h2>
<p class="Pp">Here is a trivial example of using <b>bzdeflate</b>. It simply
    reads standard input, deflates it and writes it to standard output.</p>
<p class="Pp"></p>
<pre>    use strict ;
    use warnings ;
    use Compress::Bzip2 ;
    binmode STDIN;
    binmode STDOUT;
    my $x = bzdeflateInit()
       or die &quot;Cannot create a deflation stream\n&quot; ;
    my ($output, $status) ;
    while (&lt;&gt;)
    {
        ($output, $status) = $x-&gt;bzdeflate($_) ;
        $status == BZ_OK
            or die &quot;deflation failed\n&quot; ;
        print $output ;
    }
    ($output, $status) = $x-&gt;bzclose() ;
    $status == BZ_OK
        or die &quot;deflation failed\n&quot; ;
    print $output ;
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="STREAM_INFLATE"><a class="permalink" href="#STREAM_INFLATE">STREAM
  INFLATE</a></h1>
<p class="Pp">Here is a definition of the interface:</p>
<section class="Ss">
<h2 class="Ss"><b>($i, </b><span class="Li"><b>$status</b></span><b>) =
  inflateInit()</b></h2>
<p class="Pp">Initialises an inflation stream.</p>
<p class="Pp">In a list context it returns the inflation stream,
    <b></b><span class="Li"><b>$i</b></span><b></b>, and the <i>zlib</i> status
    code (<b></b><span class="Li"><b>$status</b></span><b></b>). In a scalar
    context it returns the inflation stream only.</p>
<p class="Pp">If successful, <b></b><span class="Li"><b>$i</b></span><b></b>
    will hold the inflation stream and
    <b></b><span class="Li"><b>$status</b></span><b></b> will be
    <span class="Li">&quot;BZ_OK&quot;</span>.</p>
<p class="Pp">If not successful, <b></b><span class="Li"><b>$i</b></span><b></b>
    will be <i>undef</i> and
    <b></b><span class="Li"><b>$status</b></span><b></b> will hold the
    <i>bzlib.h</i> error code.</p>
<p class="Pp">The function optionally takes a number of named options specified
    as <span class="Li">&quot;-Name=&gt;value&quot;</span> pairs. This allows
    individual options to be tailored without having to specify them all in the
    parameter list.</p>
<p class="Pp">For backward compatibility, it is also possible to pass the
    parameters as a reference to a hash containing the name=&gt;value pairs.</p>
<p class="Pp">The function takes one optional parameter, a reference to a hash.
    The contents of the hash allow the deflation interface to be tailored.</p>
<p class="Pp">Here is a list of the valid options:</p>
<dl class="Bl-tag">
  <dt id="small~2"><a class="permalink" href="#small~2"><b>-small</b></a></dt>
  <dd><b>small</b> may be 0 or 1. Set <span class="Li">&quot;small&quot;</span>
      to one to use a slower, less memory intensive algorithm.</dd>
  <dt id="verbosity~3"><a class="permalink" href="#verbosity~3"><b>-verbosity</b></a></dt>
  <dd>Defines the verbosity level. Valid values are 0 through 4,
    <p class="Pp">The default is <span class="Li">&quot;-verbosity =&gt;
        0&quot;</span>.</p>
  </dd>
</dl>
<p class="Pp">Here is an example of using the <b>bzinflateInit</b> optional
    parameter.</p>
<p class="Pp"></p>
<pre>    bzinflateInit( -small =&gt; 1, -verbosity =&gt; 1 );
</pre>
</section>
<section class="Ss">
<h2 class="Ss"><b>($out, </b><span class="Li"><b>$status</b></span><b>) =
  </b><span class="Li"><b>$i</b></span><b>-&gt;bzinflate($buffer)</b></h2>
<p class="Pp">Inflates the complete contents of
    <b></b><span class="Li"><b>$buffer</b></span><b></b>. The buffer can either
    be a scalar or a scalar reference.</p>
<p class="Pp">Returns <span class="Li">&quot;BZ_OK&quot;</span> if successful
    and <span class="Li">&quot;BZ_STREAM_END&quot;</span> if the end of the
    compressed data has been successfully reached. If not successful,
    <b></b><span class="Li"><b>$out</b></span><b></b> will be <i>undef</i> and
    <b></b><span class="Li"><b>$status</b></span><b></b> will hold the
    <i>bzlib</i> error code.</p>
<p class="Pp">The <span class="Li">$buffer</span> parameter is modified by
    <span class="Li">&quot;bzinflate&quot;</span>. On completion it will contain
    what remains of the input buffer after inflation. This means that
    <span class="Li">$buffer</span> will be an empty string when the return
    status is <span class="Li">&quot;BZ_OK&quot;</span>. When the return status
    is <span class="Li">&quot;BZ_STREAM_END&quot;</span> the
    <span class="Li">$buffer</span> parameter will contains what (if anything)
    was stored in the input buffer after the deflated data stream.</p>
<p class="Pp">This feature is useful when processing a file format that
    encapsulates a compressed data stream.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Example~2"><a class="permalink" href="#Example~2">Example</a></h2>
<p class="Pp">Here is an example of using <b>bzinflate</b>.</p>
<p class="Pp"></p>
<pre>    use strict ;
    use warnings ;
    use Compress::Bzip2;
    my $x = bzinflateInit()
       or die &quot;Cannot create a inflation stream\n&quot; ;
    my $input = '' ;
    binmode STDIN;
    binmode STDOUT;
    my ($output, $status) ;
    while (read(STDIN, $input, 4096))
    {
        ($output, $status) = $x-&gt;bzinflate(\$input) ;
        print $output
            if $status == BZ_OK or $status == BZ_STREAM_END ;
        last if $status != BZ_OK ;
    }
    die &quot;inflation failed\n&quot;
        unless $status == BZ_STREAM_END ;
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="EXAMPLES"><a class="permalink" href="#EXAMPLES">EXAMPLES</a></h1>
<p class="Pp">Here are some example scripts of using the interface.</p>
<section class="Ss">
<h2 class="Ss"><b>A bzcat function</b></h2>
<pre>  use strict ;
  use warnings ;
  use Compress::Bzip2 ;
  die &quot;Usage: bzcat file...\n&quot; unless @ARGV ;
  my $file ;
  foreach $file (@ARGV) {
    my $buffer ;
    my $bz = bzopen($file, &quot;rb&quot;)
       or die &quot;Cannot open $file: $bzerrno\n&quot; ;
    print $buffer while $bz-&gt;bzread($buffer) &gt; 0 ;
    die &quot;Error reading from $file: $bzerrno&quot; . ($bzerrno+0) . &quot;\n&quot;
       if $bzerrno != BZ_STREAM_END ;
    $bz-&gt;bzclose() ;
  }
</pre>
</section>
<section class="Ss">
<h2 class="Ss"><b>A grep using bzreadline</b></h2>
<pre>  use strict ;
  use warnings ;
  use Compress::Bzip2 ;
  die &quot;Usage: bzgrep pattern file...\n&quot; unless @ARGV &gt;= 2;
  my $pattern = shift ;
  my $file ;
  foreach $file (@ARGV) {
    my $bz = bzopen($file, &quot;rb&quot;)
       or die &quot;Cannot open $file: $bzerrno\n&quot; ;
    while ($bz-&gt;bzreadline($_) &gt; 0) {
      print if /$pattern/ ;
    }
    die &quot;Error reading from $file: $bzerrno\n&quot;
      if $bzerrno != Z_STREAM_END ;
    $bz-&gt;bzclose() ;
  }
</pre>
</section>
<section class="Ss">
<h2 class="Ss"><b>Streaming Compression</b></h2>
<p class="Pp">This script, <i>bzstream</i>, does the opposite of the
    <i>bzcat</i> script above. It reads from standard input and writes a bzip
    file to standard output.</p>
<p class="Pp"></p>
<pre>  use strict ;
  use warnings ;
  use Compress::Bzip2 ;
  binmode STDOUT;       # bzopen only sets it on the fd
  my $bz = bzopen(\*STDOUT, &quot;wb&quot;)
     or die &quot;Cannot open stdout: $bzerrno\n&quot; ;
  while (&lt;&gt;) {
    $bz-&gt;bzwrite($_) or die &quot;error writing: $bzerrno\n&quot; ;
  }
  $bz-&gt;bzclose ;
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="EXPORT"><a class="permalink" href="#EXPORT">EXPORT</a></h1>
<p class="Pp">Use the tags :all, :utilities, :constants, :bzip1 and :gzip.</p>
<section class="Ss">
<h2 class="Ss" id="Export_tag_:all"><a class="permalink" href="#Export_tag_:all">Export
  tag :all</a></h2>
<p class="Pp">This exports all the exportable methods.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Export_tag_:constants"><a class="permalink" href="#Export_tag_:constants">Export
  tag :constants</a></h2>
<p class="Pp">This exports only the BZ_* constants.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Export_tag_:bzip1"><a class="permalink" href="#Export_tag_:bzip1">Export
  tag :bzip1</a></h2>
<p class="Pp">This exports the Compress::Bzip2 1.x functions, for
  compatibility.</p>
<p class="Pp"></p>
<pre>   compress
   decompress
   compress_init
   decompress_init
   version
</pre>
<p class="Pp">These are actually aliases to memBzip and memBunzip.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Export_tag_:utilities"><a class="permalink" href="#Export_tag_:utilities">Export
  tag :utilities</a></h2>
<p class="Pp">This gives an interface to the bzip2 methods.</p>
<p class="Pp"></p>
<pre>    bzopen
    bzinflateInit
    bzdeflateInit
    memBzip
    memBunzip
    bzip2
    bunzip2
    bzcat
    bzlibversion
    $bzerrno
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Export_tag_:gzip"><a class="permalink" href="#Export_tag_:gzip">Export
  tag :gzip</a></h2>
<p class="Pp">This gives compatibility with Compress::Zlib.</p>
<p class="Pp"></p>
<pre>    gzopen
    gzinflateInit
    gzdeflateInit
    memGzip
    memGunzip
    $gzerrno
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="Exportable_constants"><a class="permalink" href="#Exportable_constants">Exportable
  constants</a></h1>
<p class="Pp">All the <i>bzlib</i> constants are automatically imported when you
    make use of <i>Compress::Bzip2</i>.</p>
<p class="Pp"></p>
<pre>  BZ_CONFIG_ERROR
  BZ_DATA_ERROR
  BZ_DATA_ERROR_MAGIC
  BZ_FINISH
  BZ_FINISH_OK
  BZ_FLUSH
  BZ_FLUSH_OK
  BZ_IO_ERROR
  BZ_MAX_UNUSED
  BZ_MEM_ERROR
  BZ_OK
  BZ_OUTBUFF_FULL
  BZ_PARAM_ERROR
  BZ_RUN
  BZ_RUN_OK
  BZ_SEQUENCE_ERROR
  BZ_STREAM_END
  BZ_UNEXPECTED_EOF
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp">The documentation for zlib, bzip2 and Compress::Zlib.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">Rob Janes, &lt;arjay at cpan.org&gt;</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT_AND_LICENSE"><a class="permalink" href="#COPYRIGHT_AND_LICENSE">COPYRIGHT
  AND LICENSE</a></h1>
<p class="Pp">Copyright (C) 2005 by Rob Janes</p>
<p class="Pp">This library is free software; you can redistribute it and/or
    modify it under the same terms as Perl itself, either Perl version 5.8.3 or,
    at your option, any later version of Perl 5 you may have available.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR~2"><a class="permalink" href="#AUTHOR~2">AUTHOR</a></h1>
<p class="Pp">The <i>Compress::Bzip2</i> module was originally written by Gawdi
    Azem <i>azemgi@rupert.informatik.uni-stuttgart.de</i>.</p>
<p class="Pp">The first <i>Compress::Bzip2</i> module was written by Gawdi Azem
    <i>azemgi@rupert.informatik.uni-stuttgart.de</i>. It provided an interface
    to the in memory inflate and deflate routines.</p>
<p class="Pp"><i>Compress::Bzip2</i> was subsequently passed on to Marco Carnut
    <i>kiko@tempest.com.br</i> who shepherded it through to version 1.03, a set
    of changes which included upgrades to handle bzlib 1.0.2, and improvements
    to the in memory inflate and deflate routines. The streaming interface and
    error information were added by David Robins
    <i>dbrobins@davidrobins.net</i>.</p>
<p class="Pp">Version 2 of <i>Compress::Bzip2</i> is due to Rob Janes, of
    arjay@cpan.org. This release is intended to give an interface close to that
    of Compress::Zlib. It's development forks from 1.00, not 1.03, so the
    streaming interface is not the same as that in 1.03, although apparently
    compatible as it passes the 1.03 test suite.</p>
<p class="Pp">Minor subsequent fixes and releases were done by Reini Urban,
    rurban@cpan.org.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="MODIFICATION_HISTORY"><a class="permalink" href="#MODIFICATION_HISTORY">MODIFICATION
  HISTORY</a></h1>
<p class="Pp">See the Changes file.</p>
<p class="Pp">2.00 Second public release of <i>Compress::Bzip2</i>.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2017-04-10</td>
    <td class="foot-os">perl v5.34.0</td>
  </tr>
</table>
</body>
</html>
