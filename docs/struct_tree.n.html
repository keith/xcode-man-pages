<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Generated from file '/Library/Caches/com.apple.xbs/Sources/tcl/tcl-129.40.1/tcl_ext/tcllib/tcllib/modules/struct/struct_tree.man' by tcllib/doctools with format 'nroff'
   Copyright (c) 2002-2004 Andreas Kupries <andreas_kupries@users.sourceforge.net>
  
   The definitions below are for supplemental macros used in Tcl/Tk
   manual entries.
  
   .AP type name in/out ?indent?
  	Start paragraph describing an argument to a library procedure.
  	type is type of argument (int, etc.), in/out is either "in", "out",
  	or "in/out" to describe whether procedure reads or modifies arg,
  	and indent is equivalent to second arg of .IP (shouldn't ever be
  	needed;  use .AS below instead)
  
   .AS ?type? ?name?
  	Give maximum sizes of arguments for setting tab stops.  Type and
  	name are examples of largest possible arguments that will be passed
  	to .AP later.  If args are omitted, default tab stops are used.
  
   .BS
  	Start box enclosure.  From here until next .BE, everything will be
  	enclosed in one large box.
  
   .BE
  	End of box enclosure.
  
   .CS
  	Begin code excerpt.
  
   .CE
  	End code excerpt.
  
   .VS ?version? ?br?
  	Begin vertical sidebar, for use in marking newly-changed parts
  	of man pages.  The first argument is ignored and used for recording
  	the version when the .VS was added, so that the sidebars can be
  	found and removed when they reach a certain age.  If another argument
  	is present, then a line break is forced before starting the sidebar.
  
   .VE
  	End of vertical sidebar.
  
   .DS
  	Begin an indented unfilled display.
  
   .DE
  	End of indented unfilled display.
  
   .SO
  	Start of list of standard options for a Tk widget.  The
  	options follow on successive lines, in four columns separated
  	by tabs.
  
   .SE
  	End of list of standard options for a Tk widget.
  
   .OP cmdName dbName dbClass
  	Start of description of a specific option.  cmdName gives the
  	option's name as specified in the class command, dbName gives
  	the option's name in the option database, and dbClass gives
  	the option's class in the option database.
  
   .UL arg1 arg2
  	Print arg1 underlined, then print arg2 normally.
  
   RCS: @(#) $Id: man.macros,v 1.1 2009/01/30 04:56:47 andreas_kupries Exp $
  
  	# Set up traps and other miscellaneous stuff for Tcl/Tk man pages.
  	# Start an argument description
  .b
  	# define tabbing values for .AP
  
  	# BS - start boxed text
  	# ^y = starting y location
  	# ^b = 1
  	# BE - end boxed text (draw box now)
  	Draw four-sided box normally, but don't draw top of
  	box if the box started on an earlier page.
  	# VS - start vertical sidebar
  	# ^Y = starting y location
  	# ^v = 1 (for troff;  for nroff this doesn't matter)
  	# VE - end of vertical sidebar
  	# Special macro to handle page bottom:  finish off current
  	# box/sidebar if in box/sidebar mode, then invoked standard
  	# page bottom macro.
  	Draw three-sided box if this is the box's first page,
  	draw two sides but no top otherwise.
  	# DS - begin display
  	# DE - end display
  	# SO - start of list of standard options
  	# SE - end of list of standard options
  	# OP - start of full description for a single option
  	# CS - begin code excerpt
  	# CE - end code excerpt
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>struct::tree(n)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">struct::tree(n)</td>
    <td class="head-vol">Tcl Data Structures</td>
    <td class="head-rtitle">struct::tree(n)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<pre>

</pre>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
struct::tree - Create and manipulate tree objects
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
package require <b>Tcl 8.2</b>
<p class="Pp">package require <b>struct::tree ?2.1.1?</b></p>
<p class="Pp">package require <b>struct::list ?1.5?</b></p>
<p class="Pp"><b>::struct::tree</b> ?<i>treeName</i>?
    ?<b>=</b>|<b>:=</b>|<b>as</b>|<b>deserialize</b> <i>source</i>?</p>
<p class="Pp"><b>treeName</b> <b>option</b> ?<i>arg arg ...</i>?</p>
<p class="Pp"><b>::struct::tree::prune</b></p>
<p class="Pp"><i>treeName</i> <b>=</b> <i>sourcetree</i></p>
<p class="Pp"><i>treeName</i> <b>--&gt;</b> <i>desttree</i></p>
<p class="Pp"><i>treeName</i> <b>ancestors</b> <i>node</i></p>
<p class="Pp"><i>treeName</i> <b>append</b> <i>node</i> <i>key</i>
  <i>value</i></p>
<p class="Pp"><i>treeName</i> <b>attr</b> <i>key</i></p>
<p class="Pp"><i>treeName</i> <b>attr</b> <i>key</i> <b>-nodes</b>
  <i>list</i></p>
<p class="Pp"><i>treeName</i> <b>attr</b> <i>key</i> <b>-glob</b>
    <i>globpattern</i></p>
<p class="Pp"><i>treeName</i> <b>attr</b> <i>key</i> <b>-regexp</b>
    <i>repattern</i></p>
<p class="Pp"><i>treeName</i> <b>children</b> ?<b>-all</b>? <i>node</i>
    ?<b>filter</b> <i>cmdprefix</i>?</p>
<p class="Pp"><i>treeName</i> <b>cut</b> <i>node</i></p>
<p class="Pp"><i>treeName</i> <b>delete</b> <i>node</i> ?<i>node</i> ...?</p>
<p class="Pp"><i>treeName</i> <b>depth</b> <i>node</i></p>
<p class="Pp"><i>treeName</i> <b>descendants</b> <i>node</i> ?<b>filter</b>
    <i>cmdprefix</i>?</p>
<p class="Pp"><i>treeName</i> <b>deserialize</b> <i>serialization</i></p>
<p class="Pp"><i>treeName</i> <b>destroy</b></p>
<p class="Pp"><i>treeName</i> <b>exists</b> <i>node</i></p>
<p class="Pp"><i>treeName</i> <b>get</b> <i>node</i> <i>key</i></p>
<p class="Pp"><i>treeName</i> <b>getall</b> <i>node</i> ?<i>pattern</i>?</p>
<p class="Pp"><i>treeName</i> <b>keys</b> <i>node</i> ?<i>pattern</i>?</p>
<p class="Pp"><i>treeName</i> <b>keyexists</b> <i>node</i> <i>key</i></p>
<p class="Pp"><i>treeName</i> <b>index</b> <i>node</i></p>
<p class="Pp"><i>treeName</i> <b>insert</b> <i>parent</i> <i>index</i>
    ?<i>child</i> ?<i>child</i> ...??</p>
<p class="Pp"><i>treeName</i> <b>isleaf</b> <i>node</i></p>
<p class="Pp"><i>treeName</i> <b>lappend</b> <i>node</i> <i>key</i>
  <i>value</i></p>
<p class="Pp"><i>treeName</i> <b>leaves</b></p>
<p class="Pp"><i>treeName</i> <b>move</b> <i>parent</i> <i>index</i> <i>node</i>
    ?<i>node</i> ...?</p>
<p class="Pp"><i>treeName</i> <b>next</b> <i>node</i></p>
<p class="Pp"><i>treeName</i> <b>numchildren</b> <i>node</i></p>
<p class="Pp"><i>treeName</i> <b>nodes</b></p>
<p class="Pp"><i>treeName</i> <b>parent</b> <i>node</i></p>
<p class="Pp"><i>treeName</i> <b>previous</b> <i>node</i></p>
<p class="Pp"><i>treeName</i> <b>rename</b> <i>node</i> <i>newname</i></p>
<p class="Pp"><i>treeName</i> <b>rootname</b></p>
<p class="Pp"><i>treeName</i> <b>serialize</b> ?<i>node</i>?</p>
<p class="Pp"><i>treeName</i> <b>set</b> <i>node</i> <i>key</i>
  ?<i>value</i>?</p>
<p class="Pp"><i>treeName</i> <b>size</b> ?<i>node</i>?</p>
<p class="Pp"><i>treeName</i> <b>splice</b> <i>parent</i> <i>from</i>
    ?<i>to</i>? ?<i>child</i>?</p>
<p class="Pp"><i>treeName</i> <b>swap</b> <i>node1</i> <i>node2</i></p>
<p class="Pp"><i>treeName</i> <b>unset</b> <i>node</i> <i>key</i></p>
<p class="Pp"><i>treeName</i> <b>walk</b> <i>node</i> ?<b>-order</b>
    <i>order</i>? ?<b>-type</b> <i>type</i>? <i>loopvar</i> <i>script</i></p>
<p class="Pp"><i>treeName</i> <b>walkproc</b> <i>node</i> ?<b>-order</b>
    <i>order</i>? ?<b>-type</b> <i>type</i>? <i>cmdprefix</i></p>
<p class="Pp"></p>
<pre>

</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
A tree is a collection of named elements, called nodes, one of which is
  distinguished as a root, along with a relation (&quot;parenthood&quot;) that
  places a hierarchical structure on the nodes. (Data Structures and Algorithms;
  Aho, Hopcroft and Ullman; Addison-Wesley, 1987). In addition to maintaining
  the node relationships, this tree implementation allows any number of keyed
  values to be associated with each node.
<p class="Pp">The element names can be arbitrary strings.</p>
<p class="Pp">A tree is thus similar to an array, but with three important
    differences:</p>
<dl class="Bl-tag">
  <dt>[1]</dt>
  <dd>Trees are accessed through an object command, whereas arrays are accessed
      as variables. (This means trees cannot be local to a procedure.)</dd>
  <dt>[2]</dt>
  <dd>Trees have a hierarchical structure, whereas an array is just an unordered
      collection.</dd>
  <dt>[3]</dt>
  <dd>Each node of a tree has a separate collection of attributes and values.
      This is like an array where every value is a dictionary.</dd>
</dl>
<p class="Pp"><i>Note:</i> The major version of the package <b>struct</b> has
    been changed to version 2.0, due to backward incompatible changes in the API
    of this module. Please read the section <b>Changes for 2.0</b> for a full
    list of all changes, incompatible and otherwise.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="API"><a class="permalink" href="#API">API</a></h1>
<section class="Ss">
<h2 class="Ss" id="TREE_CLASS_API"><a class="permalink" href="#TREE_CLASS_API">TREE
  CLASS API</a></h2>
The main commands of the package are:
<dl class="Bl-tag">
  <dt><b>::struct::tree</b> ?<i>treeName</i>?
    ?<b>=</b>|<b>:=</b>|<b>as</b>|<b>deserialize</b> <i>source</i>?</dt>
  <dd>The command creates a new tree object with an associated global Tcl
      command whose name is <i>treeName</i>. This command may be used to invoke
      various operations on the tree. It has the following general form:</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>treeName</b> <b>option</b> ?<i>arg arg ...</i>?</dt>
  <dd><i>Option</i> and the <i>arg</i>s determine the exact behavior of the
      command.</dd>
</dl>
</div>
<p class="Pp">If <i>treeName</i> is not specified a unique name will be
    generated by the package itself. If a <i>source</i> is specified the new
    tree will be initialized to it. For the operators <b>=</b>, <b>:=</b>, and
    <b>as</b> <i>source</i> is interpreted as the name of another tree object,
    and the assignment operator <b>=</b> will be executed. For
    <b>deserialize</b> the <i>source</i> is a serialized tree object and
    <b>deserialize</b> will be executed.</p>
<p class="Pp">In other words</p>
<p class="Pp"></p>
<pre>
    ::struct::tree mytree = b
</pre>
<p class="Pp">is equivalent to</p>
<p class="Pp"></p>
<pre>
    ::struct::tree mytree
    mytree = b
</pre>
<p class="Pp">and</p>
<p class="Pp"></p>
<pre>
    ::struct::tree mytree deserialize $b
</pre>
<p class="Pp">is equivalent to</p>
<p class="Pp"></p>
<pre>
    ::struct::tree mytree
    mytree deserialize $b
</pre>
<dl class="Bl-tag">
  <dt><b>::struct::tree::prune</b></dt>
  <dd>This command is provided outside of the tree methods, as it is not a tree
      method per se. It however interacts tightly with the method <b>walk</b>.
      When used in the walk script it causes the traversal to ignore the
      children of the node we are currently at. This command cannot be used with
      the traversal modes which look at children before their parent, i.e.
      <b>post</b> and <b>in</b>. The only applicable orders of traversal are
      <b>pre</b> and <b>both</b>. An error is thrown if the command and chosen
      order of traversal do not fit.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="TREE_OBJECT_API"><a class="permalink" href="#TREE_OBJECT_API">TREE
  OBJECT API</a></h2>
Two general observations beforehand:
<dl class="Bl-tag">
  <dt>[1]</dt>
  <dd>The root node of the tree can be used in most places where a node is asked
      for. The default name of the rootnode is &quot;root&quot;, but this can be
      changed with the method <b>rename</b> (see below). Whatever the current
      name for the root node of the tree is, it can be retrieved by calling the
      method <b>rootname</b>.</dd>
  <dt>[2]</dt>
  <dd>The method <b>insert</b> is the only way to create new nodes, and they are
      automatically added to a parent. A tree object cannot have nodes without a
      parent, save the root node.</dd>
</dl>
<p class="Pp">And now the methods supported by tree objects created by this
    package:</p>
<dl class="Bl-tag">
  <dt><i>treeName</i> <b>=</b> <i>sourcetree</i></dt>
  <dd>This is the assignment operator for tree objects. It copies the tree
      contained in the tree object <i>sourcetree</i> over the tree data in
      <i>treeName</i>. The old contents of <i>treeName</i> are deleted by this
      operation.
    <p class="Pp">This operation is in effect equivalent to</p>
    <p class="Pp"></p>
    <pre>
    <i>treeName</i> <b>deserialize</b> [<i>sourcetree</i> <b>serialize</b>]
    </pre>
  </dd>
  <dt><i>treeName</i> <b>--&gt;</b> <i>desttree</i></dt>
  <dd>This is the reverse assignment operator for tree objects. It copies the
      tree contained in the tree object <i>treeName</i> over the tree data in
      the object <i>desttree</i>. The old contents of <i>desttree</i> are
      deleted by this operation.
    <p class="Pp">This operation is in effect equivalent to</p>
    <p class="Pp"></p>
    <pre>
    <i>desttree</i> <b>deserialize</b> [<i>treeName</i> <b>serialize</b>]
    </pre>
  </dd>
  <dt><i>treeName</i> <b>ancestors</b> <i>node</i></dt>
  <dd>This method extends the method <b>parent</b> and returns a list containing
      all ancestor nodes to the specified <i>node</i>. The immediate ancestor,
      in other words, parent node, is the first element in that list, its parent
      the second element, and so on until the root node is reached, making it
      the last element of the returned list.</dd>
  <dt><i>treeName</i> <b>append</b> <i>node</i> <i>key</i> <i>value</i></dt>
  <dd>Appends a <i>value</i> to one of the keyed values associated with an node.
      Returns the new value given to the attribute <i>key</i>.</dd>
  <dt><i>treeName</i> <b>attr</b> <i>key</i></dt>
  <dd></dd>
  <dt><i>treeName</i> <b>attr</b> <i>key</i> <b>-nodes</b> <i>list</i></dt>
  <dd></dd>
  <dt><i>treeName</i> <b>attr</b> <i>key</i> <b>-glob</b>
    <i>globpattern</i></dt>
  <dd></dd>
  <dt><i>treeName</i> <b>attr</b> <i>key</i> <b>-regexp</b>
    <i>repattern</i></dt>
  <dd>This method retrieves the value of the attribute named <i>key</i>, for all
      nodes in the tree (matching the restriction specified via one of the
      possible options) and having the specified attribute.
    <p class="Pp">The result is a dictionary mapping from node names to the
        value of attribute <i>key</i> at that node. Nodes not having the
        attribute <i>key</i>, or not passing a specified restriction, are not
        listed in the result.</p>
    <p class="Pp">The possible restrictions are:</p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>-nodes</b></dt>
  <dd>The value is a list of nodes. Only the nodes mentioned in this list are
      searched for the attribute.</dd>
  <dt><b>-glob</b></dt>
  <dd>The value is a glob pattern. Only the nodes in the tree whose names match
      this pattern are searched for the attribute.</dd>
  <dt><b>-regexp</b></dt>
  <dd>The value is a regular expression. Only the nodes in the tree whose names
      match this pattern are searched for the attribute.</dd>
</dl>
</div>
<p class="Pp"></p>
<dl class="Bl-tag">
  <dt><i>treeName</i> <b>children</b> ?<b>-all</b>? <i>node</i> ?<b>filter</b>
    <i>cmdprefix</i>?</dt>
  <dd>Return a list of the children of <i>node</i>. If the option <b>-all</b> is
      specified, then not only the direct children, but their children, and so
      on are returned in the result. If a filter command is specified only those
      nodes are listed in the final result which pass the test. The command in
      <i>cmdprefix</i> is called with two arguments, the name of the tree
      object, and the name of the node in question. It is executed in the
      context of the caller and has to return a boolean value. Nodes for which
      the command returns <b>false</b> are removed from the result list before
      it is returned to the caller.
    <p class="Pp">Some examples:</p>
    <p class="Pp"></p>
    <pre>
    mytree insert root end 0 ; mytree set 0 volume 30
    mytree insert root end 1
    mytree insert root end 2
    mytree insert 0    end 3
    mytree insert 0    end 4
    mytree insert 4    end 5 ; mytree set 5 volume 50
    mytree insert 4    end 6
    proc vol {t n} {
	$t keyexists $n volume
    }
    proc vgt40 {t n} {
	if {![$t keyexists $n volume]} {return 0}
	expr {[$t get $n volume] &gt; 40}
    }
    tclsh&gt; lsort [mytree children -all root filter vol]
    0 5
    tclsh&gt; lsort [mytree children -all root filter vgt40]
    5
    tclsh&gt; lsort [mytree children root filter vol]
    0
    tclsh&gt; puts ([lsort [mytree children root filter vgt40]])
    ()
    </pre>
  </dd>
  <dt><i>treeName</i> <b>cut</b> <i>node</i></dt>
  <dd>Removes the node specified by <i>node</i> from the tree, but not its
      children. The children of <i>node</i> are made children of the parent of
      the <i>node</i>, at the index at which <i>node</i> was located.</dd>
  <dt><i>treeName</i> <b>delete</b> <i>node</i> ?<i>node</i> ...?</dt>
  <dd>Remove the specified nodes from the tree. All of the nodes' children will
      be removed as well to prevent orphaned nodes.</dd>
  <dt><i>treeName</i> <b>depth</b> <i>node</i></dt>
  <dd>Return the number of steps from node <i>node</i> to the root node.</dd>
  <dt><i>treeName</i> <b>descendants</b> <i>node</i> ?<b>filter</b>
    <i>cmdprefix</i>?</dt>
  <dd>This method extends the method <b>children</b> and returns a list
      containing all nodes descending from <i>node</i>, and passing the filter,
      if such was specified.
    <p class="Pp">This is actually the same as &quot;<i>treeName</i>
        <b>children</b> <b>-all</b>&quot;. <b>descendants</b> should be
        prefered, and &quot;children -all&quot; will be deprecated sometime in
        the future.</p>
  </dd>
  <dt><i>treeName</i> <b>deserialize</b> <i>serialization</i></dt>
  <dd>This is the complement to <b>serialize</b>. It replaces tree data in
      <i>treeName</i> with the tree described by the <i>serialization</i> value.
      The old contents of <i>treeName</i> are deleted by this operation.</dd>
  <dt><i>treeName</i> <b>destroy</b></dt>
  <dd>Destroy the tree, including its storage space and associated command.</dd>
  <dt><i>treeName</i> <b>exists</b> <i>node</i></dt>
  <dd>Remove true if the specified node exists in the tree.</dd>
  <dt><i>treeName</i> <b>get</b> <i>node</i> <i>key</i></dt>
  <dd>Returns the value associated with the key <i>key</i> for the node
      <i>node</i>.</dd>
  <dt><i>treeName</i> <b>getall</b> <i>node</i> ?<i>pattern</i>?</dt>
  <dd>Returns a dictionary (suitable for use with [<b>array set</b>]) containing
      the attribute data for the <i>node</i>. If the glob <i>pattern</i> is
      specified only the attributes whose names match the pattern will be part
      of the dictionary.</dd>
  <dt><i>treeName</i> <b>keys</b> <i>node</i> ?<i>pattern</i>?</dt>
  <dd>Returns a list of keys for the <i>node</i>. If the <i>pattern</i> is
      specified only the attributes whose names match the pattern will be part
      of the returned list. The pattern is a <b>glob</b> pattern.</dd>
  <dt><i>treeName</i> <b>keyexists</b> <i>node</i> <i>key</i></dt>
  <dd>Return true if the specified <i>key</i> exists for the <i>node</i>.</dd>
  <dt><i>treeName</i> <b>index</b> <i>node</i></dt>
  <dd>Returns the index of <i>node</i> in its parent's list of children. For
      example, if a node has <i>nodeFoo</i>, <i>nodeBar</i>, and <i>nodeBaz</i>
      as children, in that order, the index of <i>nodeBar</i> is 1.</dd>
  <dt><i>treeName</i> <b>insert</b> <i>parent</i> <i>index</i> ?<i>child</i>
    ?<i>child</i> ...??</dt>
  <dd>Insert one or more nodes into the tree as children of the node
      <i>parent</i>. The nodes will be added in the order they are given. If
      <i>parent</i> is <b>root</b>, it refers to the root of the tree. The new
      nodes will be added to the <i>parent</i> node's child list at the index
      given by <i>index</i>. The <i>index</i> can be <b>end</b> in which case
      the new nodes will be added after the current last child. Indices of the
      form &quot;end-<b>n</b>&quot; are accepted as well.
    <p class="Pp">If any of the specified children already exist in
        <i>treeName</i>, those nodes will be moved from their original location
        to the new location indicated by this command.</p>
    <p class="Pp">If no <i>child</i> is specified, a single node will be added,
        and a name will be generated for the new node. The generated name is of
        the form <i>node</i><b>x</b>, where <b>x</b> is a number. If names are
        specified they must neither contain whitespace nor colons
        (&quot;:&quot;).</p>
    <p class="Pp">The return result from this command is a list of nodes
      added.</p>
  </dd>
  <dt><i>treeName</i> <b>isleaf</b> <i>node</i></dt>
  <dd>Returns true if <i>node</i> is a leaf of the tree (if <i>node</i> has no
      children), false otherwise.</dd>
  <dt><i>treeName</i> <b>lappend</b> <i>node</i> <i>key</i> <i>value</i></dt>
  <dd>Appends a <i>value</i> (as a list) to one of the keyed values associated
      with an <i>node</i>. Returns the new value given to the attribute
      <i>key</i>.</dd>
  <dt><i>treeName</i> <b>leaves</b></dt>
  <dd>Return a list containing all leaf nodes known to the tree.</dd>
  <dt><i>treeName</i> <b>move</b> <i>parent</i> <i>index</i> <i>node</i>
    ?<i>node</i> ...?</dt>
  <dd>Make the specified nodes children of <i>parent</i>, inserting them into
      the parent's child list at the index given by <i>index</i>. Note that the
      command will take all nodes out of the tree before inserting them under
      the new parent, and that it determines the position to place them into
      after the removal, before the re-insertion. This behaviour is important
      when it comes to moving one or more nodes to a different index without
      changing their parent node.</dd>
  <dt><i>treeName</i> <b>next</b> <i>node</i></dt>
  <dd>Return the right sibling of <i>node</i>, or the empty string if
      <i>node</i> was the last child of its parent.</dd>
  <dt><i>treeName</i> <b>numchildren</b> <i>node</i></dt>
  <dd>Return the number of immediate children of <i>node</i>.</dd>
  <dt><i>treeName</i> <b>nodes</b></dt>
  <dd>Return a list containing all nodes known to the tree.</dd>
  <dt><i>treeName</i> <b>parent</b> <i>node</i></dt>
  <dd>Return the parent of <i>node</i>.</dd>
  <dt><i>treeName</i> <b>previous</b> <i>node</i></dt>
  <dd>Return the left sibling of <i>node</i>, or the empty string if <i>node</i>
      was the first child of its parent.</dd>
  <dt><i>treeName</i> <b>rename</b> <i>node</i> <i>newname</i></dt>
  <dd>Renames the node <i>node</i> to <i>newname</i>. An error is thrown if
      either the node does not exist, or a node with name <i>newname</i> does
      exist. The result of the command is the new name of the node.</dd>
  <dt><i>treeName</i> <b>rootname</b></dt>
  <dd>Returns the name of the root node of the tree.</dd>
  <dt><i>treeName</i> <b>serialize</b> ?<i>node</i>?</dt>
  <dd>This method serializes the sub-tree starting at <i>node</i>. In other
      words it returns a tcl <i>value</i> completely describing the tree
      starting at <i>node</i>. This allows, for example, the transfer of tree
      objects (or parts thereof) over arbitrary channels, persistence, etc. This
      method is also the basis for both the copy constructor and the assignment
      operator.
    <p class="Pp">The result of this method has to be semantically identical
        over all implementations of the tree interface. This is what will enable
        us to copy tree data between different implementations of the same
        interface.</p>
    <p class="Pp">The result is a list containing containing a multiple of three
        elements. It is like a serialized array except that there are two values
        following each key. They are the names of the nodes in the serialized
        tree. The two values are a reference to the parent node and the
        attribute data, in this order.</p>
    <p class="Pp">The reference to the parent node is the empty string for the
        root node of the tree. For all other nodes it is the index of the parent
        node in the list. This means that they are integers, greater than or
        equal to zero, less than the length of the list, and multiples of three.
        The order of the nodes in the list is important insofar as it is used to
        reconstruct the lists of children for each node. The children of a node
        have to be listed in the serialization in the same order as they are
        listed in their parent in the tree.</p>
    <p class="Pp">The attribute data of a node is a dictionary, i.e. a list of
        even length containing a serialized array. For a node without attribute
        data the dictionary is the empty list.</p>
    <p class="Pp"><i>Note:</i> While the current implementation returns the root
        node as the first element of the list, followed by its children and
        their children in a depth-first traversal this is not necessarily true
        for other implementations. The only information a reader of the
        serialized data can rely on for the structure of the tree is that the
        root node is signaled by the empty string for the parent reference, that
        all other nodes refer to their parent through the index in the list, and
        that children occur in the same order as in their parent.</p>
    <p class="Pp"></p>
    <pre>
 A possible serialization for the tree structure
             +- d
       +- a -+
 root -+- b  +- e
       +- c
 is
 {root {} {} a 0 {} d 3 {} e 3 {} b 0 {} c 0 {}}
 The above assumes that none of the nodes have attributes.
    </pre>
  </dd>
  <dt><i>treeName</i> <b>set</b> <i>node</i> <i>key</i> ?<i>value</i>?</dt>
  <dd>Set or get one of the keyed values associated with a node. A node may have
      any number of keyed values associated with it. If <i>value</i> is not
      specified, this command returns the current value assigned to the key; if
      <i>value</i> is specified, this command assigns that value to the key, and
      returns it.</dd>
  <dt><i>treeName</i> <b>size</b> ?<i>node</i>?</dt>
  <dd>Return a count of the number of descendants of the node <i>node</i>; if no
      node is specified, <b>root</b> is assumed.</dd>
  <dt><i>treeName</i> <b>splice</b> <i>parent</i> <i>from</i> ?<i>to</i>?
    ?<i>child</i>?</dt>
  <dd>Insert a node named <i>child</i> into the tree as a child of the node
      <i>parent</i>. If <i>parent</i> is <b>root</b>, it refers to the root of
      the tree. The new node will be added to the parent node's child list at
      the index given by <i>from</i>. The children of <i>parent</i> which are in
      the range of the indices <i>from</i> and <i>to</i> are made children of
      <i>child</i>. If the value of <i>to</i> is not specified it defaults to
      <b>end</b>. If no name is given for <i>child</i>, a name will be generated
      for the new node. The generated name is of the form <i>node</i><b>x</b>,
      where <b>x</b> is a number. The return result from this command is the
      name of the new node.
    <p class="Pp">The arguments <i>from</i> and <i>to</i> are regular list
        indices, i.e. the form &quot;end-<b>n</b>&quot; is accepted as well.</p>
  </dd>
  <dt><i>treeName</i> <b>swap</b> <i>node1</i> <i>node2</i></dt>
  <dd>Swap the position of <i>node1</i> and <i>node2</i> in the tree.</dd>
  <dt><i>treeName</i> <b>unset</b> <i>node</i> <i>key</i></dt>
  <dd>Remove a keyed value from the node <i>node</i>. The method will do nothing
      if the <i>key</i> does not exist.</dd>
  <dt><i>treeName</i> <b>walk</b> <i>node</i> ?<b>-order</b> <i>order</i>?
    ?<b>-type</b> <i>type</i>? <i>loopvar</i> <i>script</i></dt>
  <dd>Perform a breadth-first or depth-first walk of the tree starting at the
      node <i>node</i>. The type of walk, breadth-first or depth-first, is
      determined by the value of <i>type</i>; <b>bfs</b> indicates
      breadth-first, <b>dfs</b> indicates depth-first. Depth-first is the
      default. The order of the walk, pre-, post-, both- or in-order is
      determined by the value of <i>order</i>; <b>pre</b> indicates pre-order,
      <b>post</b> indicates post-order, <b>both</b> indicates both-order and
      <b>in</b> indicates in-order. Pre-order is the default.
    <p class="Pp">Pre-order walking means that a parent node is visited before
        any of its children. For example, a breadth-first search starting from
        the root will visit the root, followed by all of the root's children,
        followed by all of the root's grandchildren. Post-order walking means
        that a parent node is visited after any of its children. Both-order
        walking means that a parent node is visited before <i>and</i> after any
        of its children. In-order walking means that a parent node is visited
        after its first child and before the second. This is a generalization of
        in-order walking for binary trees and will do the right thing if a
        binary tree is walked. The combination of a breadth-first walk with
        in-order is illegal.</p>
    <p class="Pp">As the walk progresses, the <i>script</i> will be evaluated at
        each node. The evaluation takes place in the context of the caller of
        the method. Regarding loop variables, these are listed in
        <i>loopvar</i>. If one only one variable is specified it will be set to
        the id of the node. When two variables are specified, i.e.
        <i>loopvar</i> is a true list, then the first variable will be set to
        the action performed at the node, and the other to the id of the node
        itself. All loop variables are created in the context of the caller.</p>
    <p class="Pp">There are three possible actions: <b>enter</b>, <b>leave</b>,
        or <b>visit</b>. <b>enter</b> actions occur during pre-order walks;
        <b>leave</b> actions occur during post-order walks; <b>visit</b> actions
        occur during in-order walks. In a both-order walk, the command will be
        evaluated twice for each node; the action is <b>enter</b> for the first
        evaluation, and <b>leave</b> for the second.</p>
    <p class="Pp"><i>Note</i>: The <b>enter</b> action for a node is always
        performed before the walker will look at the children of that node. This
        means that changes made by the <i>script</i> to the children of the node
        will immediately influence the walker and the steps it will take.</p>
    <p class="Pp">Any other manipulation, for example of nodes higher in the
        tree (i.e already visited), or upon leaving will have undefined results.
        They may succeed, error out, silently compute the wrong result, or
        anything in between.</p>
    <p class="Pp">At last a small table showing the relationship between the
        various options and the possible actions.</p>
    <p class="Pp"></p>
    <pre>
 order       type    actions         notes
 -----       ----    -----           -----
 pre         dfs     enter           parent before children
 post        dfs     leave           parent after children
 in          dfs     visit           parent between first and second child.
 both        dfs     enter, leave    parent before and after children
 -----       ----    -----           -----
 pre         bfs     enter           parent before children
 post        bfs     leave           parent after children
 in          bfs             -- illegal --
 both        bfs     enter, leave    parent before and after children
 -----       ----    -----           -----
    </pre>
    <p class="Pp">Note the command <b>::struct::tree::prune</b>. This command
        can be used in the walk script to force the command to ignore the
        children of the node we are currently at. It will throw an error if the
        order of traversal is either <b>post</b> or <b>in</b> as these modes
        visit the children before their parent, making pruning non-sensical.</p>
  </dd>
  <dt><i>treeName</i> <b>walkproc</b> <i>node</i> ?<b>-order</b> <i>order</i>?
    ?<b>-type</b> <i>type</i>? <i>cmdprefix</i></dt>
  <dd>This method is like method <b>walk</b> in all essentials, except the
      interface to the user code. This method invokes a command prefix with
      three additional arguments (tree, node, and action), instead of evaluating
      a script and passing the node via a loop variable.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="CHANGES_FOR_2.0"><a class="permalink" href="#CHANGES_FOR_2.0">CHANGES
  FOR 2.0</a></h2>
The following noteworthy changes have occurred:
<dl class="Bl-tag">
  <dt>[1]</dt>
  <dd>The API for accessing attributes and their values has been simplified.
    <p class="Pp">All functionality regarding the default attribute
        &quot;data&quot; has been removed. This default attribute does not exist
        anymore. All accesses to attributes have to specify the name of the
        attribute in question. This backward <i>incompatible</i> change allowed
        us to simplify the signature of all methods handling attributes.</p>
    <p class="Pp">Especially the flag <b>-key</b> is not required anymore, even
        more, its use is now forbidden. Please read the documentation for the
        methods <b>set</b>, <b>get</b>, <b>getall</b>, <b>unset</b>,
        <b>append</b>, <b>lappend</b>, <b>keyexists</b> and <b>keys</b> for a
        description of the new API's.</p>
  </dd>
  <dt>[2]</dt>
  <dd>The methods <b>keys</b> and <b>getall</b> now take an optional pattern
      argument and will return only attribute data for keys matching this
      pattern.</dd>
  <dt>[3]</dt>
  <dd>Nodes can now be renamed. See the documentation for the method
      <b>rename</b>.</dd>
  <dt>[4]</dt>
  <dd>The structure has been extended with API's for the serialization and
      deserialization of tree objects, and a number of operations based on them
      (tree assignment, copy construction).
    <p class="Pp">Please read the documentation for the methods
        <b>serialize</b>, <b>deserialize</b>, <b>=</b>, and <b>--&gt;</b>, and
        the documentation on the construction of tree objects.</p>
    <p class="Pp">Beyond the copying of whole tree objects these new API's also
        enable the transfer of tree objects over arbitrary channels and for easy
        persistence.</p>
  </dd>
  <dt>[5]</dt>
  <dd>The walker API has been streamlined and made more similar to the command
      <b>foreach</b>. In detail:</dd>
</dl>
<div class="Bd-indent">
<ul class="Bl-bullet">
  <li>The superfluous option <b>-command</b> has been removed.</li>
  <li>Ditto for the place holders. Instead of the placeholders two loop
      variables have to be specified to contain node and action
    information.</li>
  <li>The old command argument has been documented as a script now, which it was
      in the past too.</li>
  <li>The fact that <b>enter</b> actions are called before the walker looks at
      the children of a node has been documented now. In other words it is now
      officially allowed to manipulate the list of children for a node under
      <i>these</i> circumstances. It has been made clear that changes under any
      other circumstances will have undefined results, from silently computing
      the wrong result to erroring out.</li>
</ul>
</div>
<dl class="Bl-tag">
  <dt>[6]</dt>
  <dd>A new method, <b>attr</b>, was added allowing the query and retrieval of
      attribute data without regard to the node relationship.</dd>
  <dt>[7]</dt>
  <dd>The method <b>children</b> has been extended with the ability to select
      from the children of the node based on an arbitrary filtering criterium.
      Another extension is the ability to look not only at the immediate
      children of the node, but the whole tree below it.</dd>
</dl>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="EXAMPLES"><a class="permalink" href="#EXAMPLES">EXAMPLES</a></h1>
The following example demonstrates the creation of new nodes:
<pre>
    mytree insert root end 0   ; # Create node 0, as child of the root
    mytree insert root end 1 2 ; # Ditto nodes 1 &amp; 2
    mytree insert 0    end 3   ; # Now create node 3 as child of node 0
    mytree insert 0    end     ; # Create another child of 0, with a
    #                              generated name. The name is returned
    #                              as the result of the command.
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="BUGS,_IDEAS,_FEEDBACK"><a class="permalink" href="#BUGS,_IDEAS,_FEEDBACK">BUGS,
  IDEAS, FEEDBACK</a></h1>
This document, and the package it describes, will undoubtedly contain bugs and
  other problems. Please report such in the category <i>struct :: tree</i> of
  the <i>Tcllib SF Trackers</i>
  [http://sourceforge.net/tracker/?group_id=12883]. Please also report any ideas
  for enhancements you may have for either package and/or documentation.
</section>
<section class="Sh">
<h1 class="Sh" id="KEYWORDS"><a class="permalink" href="#KEYWORDS">KEYWORDS</a></h1>
breadth-first, depth-first, in-order, node, post-order, pre-order,
  serialization, tree
</section>
<section class="Sh">
<h1 class="Sh" id="CATEGORY"><a class="permalink" href="#CATEGORY">CATEGORY</a></h1>
Data structures
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT"><a class="permalink" href="#COPYRIGHT">COPYRIGHT</a></h1>
<pre>
Copyright (c) 2002-2004 Andreas Kupries &lt;andreas_kupries@users.sourceforge.net&gt;
</pre>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2.1.1</td>
    <td class="foot-os">struct</td>
  </tr>
</table>
</body>
</html>
