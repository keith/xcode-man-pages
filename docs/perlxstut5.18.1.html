<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>PERLXSTUT(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">PERLXSTUT(1)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">PERLXSTUT(1)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
perlxstut - Tutorial for writing XSUBs
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
This tutorial will educate the reader on the steps involved in creating a Perl
  extension. The reader is assumed to have access to perlguts, perlapi and
  perlxs.
<p class="Pp">This tutorial starts with very simple examples and becomes more
    complex, with each new example adding new features. Certain concepts may not
    be completely explained until later in the tutorial in order to slowly ease
    the reader into building extensions.</p>
<p class="Pp">This tutorial was written from a Unix point of view. Where I know
    them to be otherwise different for other platforms (e.g. Win32), I will list
    them. If you find something that was missed, please let me know.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SPECIAL_NOTES"><a class="permalink" href="#SPECIAL_NOTES">SPECIAL
  NOTES</a></h1>
<section class="Ss">
<h2 class="Ss" id="make"><a class="permalink" href="#make">make</a></h2>
This tutorial assumes that the make program that Perl is configured to use is
  called <span class="Li">&quot;make&quot;</span>. Instead of running
  &quot;make&quot; in the examples that follow, you may have to substitute
  whatever make program Perl has been configured to use. Running <b>perl
  -V:make</b> should tell you what it is.
</section>
<section class="Ss">
<h2 class="Ss" id="Version_caveat"><a class="permalink" href="#Version_caveat">Version
  caveat</a></h2>
When writing a Perl extension for general consumption, one should expect that
  the extension will be used with versions of Perl different from the version
  available on your machine. Since you are reading this document, the version of
  Perl on your machine is probably 5.005 or later, but the users of your
  extension may have more ancient versions.
<p class="Pp">To understand what kinds of incompatibilities one may expect, and
    in the rare case that the version of Perl on your machine is older than this
    document, see the section on &quot;Troubleshooting these Examples&quot; for
    more information.</p>
<p class="Pp">If your extension uses some features of Perl which are not
    available on older releases of Perl, your users would appreciate an early
    meaningful warning. You would probably put this information into the
    <i>README</i> file, but nowadays installation of extensions may be performed
    automatically, guided by <i>CPAN.pm</i> module or other tools.</p>
<p class="Pp">In MakeMaker-based installations, <i>Makefile.PL</i> provides the
    earliest opportunity to perform version checks. One can put something like
    this in <i>Makefile.PL</i> for this purpose:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    eval { require 5.007 }
        or die &lt;&lt;EOD;
    ############
    ### This module uses frobnication framework which is not available before
    ### version 5.007 of Perl.  Upgrade your Perl before installing Kara::Mba.
    ############
    EOD
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Dynamic_Loading_versus_Static_Loading"><a class="permalink" href="#Dynamic_Loading_versus_Static_Loading">Dynamic
  Loading versus Static Loading</a></h2>
It is commonly thought that if a system does not have the capability to
  dynamically load a library, you cannot build XSUBs. This is incorrect. You
  <i>can</i> build them, but you must link the XSUBs subroutines with the rest
  of Perl, creating a new executable. This situation is similar to Perl 4.
<p class="Pp">This tutorial can still be used on such a system. The XSUB build
    mechanism will check the system and build a dynamically-loadable library if
    possible, or else a static library and then, optionally, a new
    statically-linked executable with that static library linked in.</p>
<p class="Pp">Should you wish to build a statically-linked executable on a
    system which can dynamically load libraries, you may, in all the following
    examples, where the command
    &quot;<span class="Li">&quot;make&quot;</span>&quot; with no arguments is
    executed, run the command &quot;<span class="Li">&quot;make
    perl&quot;</span>&quot; instead.</p>
<p class="Pp">If you have generated such a statically-linked executable by
    choice, then instead of saying &quot;<span class="Li">&quot;make
    test&quot;</span>&quot;, you should say &quot;<span class="Li">&quot;make
    test_static&quot;</span>&quot;. On systems that cannot build
    dynamically-loadable libraries at all, simply saying
    &quot;<span class="Li">&quot;make test&quot;</span>&quot; is sufficient.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="TUTORIAL"><a class="permalink" href="#TUTORIAL">TUTORIAL</a></h1>
Now let's go on with the show!
<section class="Ss">
<h2 class="Ss" id="_s-1EXAMPLE_1_s0"><a class="permalink" href="#_s-1EXAMPLE_1_s0">EXAMPLE
  1</a></h2>
Our first extension will be very simple. When we call the routine in the
  extension, it will print out a well-known message and return.
<p class="Pp">Run &quot;<span class="Li">&quot;h2xs -A -n
    Mytest&quot;</span>&quot;. This creates a directory named Mytest, possibly
    under ext/ if that directory exists in the current working directory.
    Several files will be created under the Mytest dir, including MANIFEST,
    Makefile.PL, lib/Mytest.pm, Mytest.xs, t/Mytest.t, and Changes.</p>
<p class="Pp">The MANIFEST file contains the names of all the files just created
    in the Mytest directory.</p>
<p class="Pp">The file Makefile.PL should look something like this:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    use ExtUtils::MakeMaker;
    # See lib/ExtUtils/MakeMaker.pm for details of how to influence
    # the contents of the Makefile that is written.
    WriteMakefile(
        NAME         =&gt; 'Mytest',
        VERSION_FROM =&gt; 'Mytest.pm', # finds $VERSION
        LIBS         =&gt; [''],   # e.g., '-lm'
        DEFINE       =&gt; '',     # e.g., '-DHAVE_SOMETHING'
        INC          =&gt; '',     # e.g., '-I/usr/include/other'
    );
</pre>
<p class="Pp">The file Mytest.pm should start with something like this:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    package Mytest;

    use 5.008008;
    use strict;
    use warnings;

    require Exporter;

    our @ISA = qw(Exporter);
    our %EXPORT_TAGS = ( 'all' =&gt; [ qw(

    ) ] );

    our @EXPORT_OK = ( @{ $EXPORT_TAGS{'all'} } );

    our @EXPORT = qw(

    );

    our $VERSION = '0.01';

    require XSLoader;
    XSLoader::load('Mytest', $VERSION);

    # Preloaded methods go here.

    1;
    __END__
    # Below is the stub of documentation for your module. You better edit it!
</pre>
<p class="Pp">The rest of the .pm file contains sample code for providing
    documentation for the extension.</p>
<p class="Pp">Finally, the Mytest.xs file should look something like this:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    #include &quot;EXTERN.h&quot;
    #include &quot;perl.h&quot;
    #include &quot;XSUB.h&quot;

    #include &quot;ppport.h&quot;

    MODULE = Mytest             PACKAGE = Mytest
</pre>
<p class="Pp">Let's edit the .xs file by adding this to the end of the file:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    void
    hello()
        CODE:
            printf(&quot;Hello, world!\n&quot;);
</pre>
<p class="Pp">It is okay for the lines starting at the &quot;CODE:&quot; line to
    not be indented. However, for readability purposes, it is suggested that you
    indent CODE: one level and the lines following one more level.</p>
<p class="Pp">Now we'll run &quot;<span class="Li">&quot;perl
    Makefile.PL&quot;</span>&quot;. This will create a real Makefile, which make
    needs. Its output looks something like:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    % perl Makefile.PL
    Checking if your kit is complete...
    Looks good
    Writing Makefile for Mytest
    %
</pre>
<p class="Pp">Now, running make will produce output that looks something like
    this (some long lines have been shortened for clarity and some extraneous
    lines have been deleted):</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    % make
    cp lib/Mytest.pm blib/lib/Mytest.pm
    perl xsubpp  -typemap typemap  Mytest.xs &gt; Mytest.xsc &amp;&amp; mv Mytest.xsc Mytest.c
    Please specify prototyping behavior for Mytest.xs (see perlxs manual)
    cc -c     Mytest.c
    Running Mkbootstrap for Mytest ()
    chmod 644 Mytest.bs
    rm -f blib/arch/auto/Mytest/Mytest.so
    cc  -shared -L/usr/local/lib Mytest.o  -o blib/arch/auto/Mytest/Mytest.so   \
                \

    chmod 755 blib/arch/auto/Mytest/Mytest.so
    cp Mytest.bs blib/arch/auto/Mytest/Mytest.bs
    chmod 644 blib/arch/auto/Mytest/Mytest.bs
    Manifying blib/man3/Mytest.3pm
    %
</pre>
<p class="Pp">You can safely ignore the line about &quot;prototyping
    behavior&quot; - it is explained in &quot;The PROTOTYPES: Keyword&quot; in
    perlxs.</p>
<p class="Pp">Perl has its own special way of easily writing test scripts, but
    for this example only, we'll create our own test script. Create a file
    called hello that looks like this:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    #! /opt/perl5/bin/perl

    use ExtUtils::testlib;

    use Mytest;

    Mytest::hello();
</pre>
<p class="Pp">Now we make the script executable (<span class="Li">&quot;chmod +x
    hello&quot;</span>), run the script and we should see the following
  output:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    % ./hello
    Hello, world!
    %
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="_s-1EXAMPLE_2_s0"><a class="permalink" href="#_s-1EXAMPLE_2_s0">EXAMPLE
  2</a></h2>
Now let's add to our extension a subroutine that will take a single numeric
  argument as input and return 1 if the number is even or 0 if the number is
  odd.
<p class="Pp">Add the following to the end of Mytest.xs:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    int
    is_even(input)
            int input
        CODE:
            RETVAL = (input % 2 == 0);
        OUTPUT:
            RETVAL
</pre>
<p class="Pp">There does not need to be whitespace at the start of the
    &quot;<span class="Li">&quot;int input&quot;</span>&quot; line, but it is
    useful for improving readability. Placing a semi-colon at the end of that
    line is also optional. Any amount and kind of whitespace may be placed
    between the &quot;<span class="Li">&quot;int&quot;</span>&quot; and
    &quot;<span class="Li">&quot;input&quot;</span>&quot;.</p>
<p class="Pp">Now re-run make to rebuild our new shared library.</p>
<p class="Pp">Now perform the same steps as before, generating a Makefile from
    the Makefile.PL file, and running make.</p>
<p class="Pp">In order to test that our extension works, we now need to look at
    the file Mytest.t. This file is set up to imitate the same kind of testing
    structure that Perl itself has. Within the test script, you perform a number
    of tests to confirm the behavior of the extension, printing &quot;ok&quot;
    when the test is correct, &quot;not ok&quot; when it is not.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    use Test::More tests =&gt; 4;
    BEGIN { use_ok('Mytest') };

    #########################

    # Insert your test code below, the Test::More module is use()ed here so read
    # its man page ( perldoc Test::More ) for help writing this test script.

    is(&amp;Mytest::is_even(0), 1);
    is(&amp;Mytest::is_even(1), 0);
    is(&amp;Mytest::is_even(2), 1);
</pre>
<p class="Pp">We will be calling the test script through the command
    &quot;<span class="Li">&quot;make test&quot;</span>&quot;. You should see
    output that looks something like this:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    %make test
    PERL_DL_NONLAZY=1 /usr/bin/perl &quot;-MExtUtils::Command::MM&quot; &quot;-e&quot; &quot;test_harness(0, 'blib/lib', 'blib/arch')&quot; t/*.t
    t/Mytest....ok
    All tests successful.
    Files=1, Tests=4,  0 wallclock secs ( 0.03 cusr +  0.00 csys =  0.03 CPU)
    %
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="What_has_gone_on?"><a class="permalink" href="#What_has_gone_on?">What
  has gone on?</a></h2>
The program h2xs is the starting point for creating extensions. In later
  examples we'll see how we can use h2xs to read header files and generate
  templates to connect to C routines.
<p class="Pp">h2xs creates a number of files in the extension directory. The
    file Makefile.PL is a perl script which will generate a true Makefile to
    build the extension. We'll take a closer look at it later.</p>
<p class="Pp">The .pm and .xs files contain the meat of the extension. The .xs
    file holds the C routines that make up the extension. The .pm file contains
    routines that tell Perl how to load your extension.</p>
<p class="Pp">Generating the Makefile and running
    <span class="Li">&quot;make&quot;</span> created a directory called blib
    (which stands for &quot;build library&quot;) in the current working
    directory. This directory will contain the shared library that we will
    build. Once we have tested it, we can install it into its final
  location.</p>
<p class="Pp">Invoking the test script via &quot;<span class="Li">&quot;make
    test&quot;</span>&quot; did something very important. It invoked perl with
    all those <span class="Li">&quot;-I&quot;</span> arguments so that it could
    find the various files that are part of the extension. It is <i>very</i>
    important that while you are still testing extensions that you use
    &quot;<span class="Li">&quot;make test&quot;</span>&quot;. If you try to run
    the test script all by itself, you will get a fatal error. Another reason it
    is important to use &quot;<span class="Li">&quot;make
    test&quot;</span>&quot; to run your test script is that if you are testing
    an upgrade to an already-existing version, using
    &quot;<span class="Li">&quot;make test&quot;</span>&quot; ensures that you
    will test your new extension, not the already-existing version.</p>
<p class="Pp">When Perl sees a <span class="Li">&quot;use
    extension;&quot;</span>, it searches for a file with the same name as the
    <span class="Li">&quot;use&quot;</span>'d extension that has a .pm suffix.
    If that file cannot be found, Perl dies with a fatal error. The default
    search path is contained in the <span class="Li">@INC</span> array.</p>
<p class="Pp">In our case, Mytest.pm tells perl that it will need the Exporter
    and Dynamic Loader extensions. It then sets the <span class="Li">@ISA</span>
    and <span class="Li">@EXPORT</span> arrays and the
    <span class="Li">$VERSION</span> scalar; finally it tells perl to bootstrap
    the module. Perl will call its dynamic loader routine (if there is one) and
    load the shared library.</p>
<p class="Pp">The two arrays <span class="Li">@ISA</span> and
    <span class="Li">@EXPORT</span> are very important. The
    <span class="Li">@ISA</span> array contains a list of other packages in
    which to search for methods (or subroutines) that do not exist in the
    current package. This is usually only important for object-oriented
    extensions (which we will talk about much later), and so usually doesn't
    need to be modified.</p>
<p class="Pp">The <span class="Li">@EXPORT</span> array tells Perl which of the
    extension's variables and subroutines should be placed into the calling
    package's namespace. Because you don't know if the user has already used
    your variable and subroutine names, it's vitally important to carefully
    select what to export. Do <i>not</i> export method or variable names <i>by
    default</i> without a good reason.</p>
<p class="Pp">As a general rule, if the module is trying to be object-oriented
    then don't export anything. If it's just a collection of functions and
    variables, then you can export them via another array, called
    <span class="Li">@EXPORT_OK</span>. This array does not automatically place
    its subroutine and variable names into the namespace unless the user
    specifically requests that this be done.</p>
<p class="Pp">See perlmod for more information.</p>
<p class="Pp">The <span class="Li">$VERSION</span> variable is used to ensure
    that the .pm file and the shared library are &quot;in sync&quot; with each
    other. Any time you make changes to the .pm or .xs files, you should
    increment the value of this variable.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Writing_good_test_scripts"><a class="permalink" href="#Writing_good_test_scripts">Writing
  good test scripts</a></h2>
The importance of writing good test scripts cannot be over-emphasized. You
  should closely follow the &quot;ok/not ok&quot; style that Perl itself uses,
  so that it is very easy and unambiguous to determine the outcome of each test
  case. When you find and fix a bug, make sure you add a test case for it.
<p class="Pp">By running &quot;<span class="Li">&quot;make
    test&quot;</span>&quot;, you ensure that your Mytest.t script runs and uses
    the correct version of your extension. If you have many test cases, save
    your test files in the &quot;t&quot; directory and use the suffix
    &quot;.t&quot;. When you run &quot;<span class="Li">&quot;make
    test&quot;</span>&quot;, all of these test files will be executed.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_s-1EXAMPLE_3_s0"><a class="permalink" href="#_s-1EXAMPLE_3_s0">EXAMPLE
  3</a></h2>
Our third extension will take one argument as its input, round off that value,
  and set the <i>argument</i> to the rounded value.
<p class="Pp">Add the following to the end of Mytest.xs:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
        void
        round(arg)
                double  arg
            CODE:
                if (arg &gt; 0.0) {
                        arg = floor(arg + 0.5);
                } else if (arg &lt; 0.0) {
                        arg = ceil(arg - 0.5);
                } else {
                        arg = 0.0;
                }
            OUTPUT:
                arg
</pre>
<p class="Pp">Edit the Makefile.PL file so that the corresponding line looks
    like this:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
        'LIBS'      =&gt; ['-lm'],   # e.g., '-lm'
</pre>
<p class="Pp">Generate the Makefile and run make. Change the test number in
    Mytest.t to &quot;9&quot; and add the following tests:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
        $i = -1.5; &amp;Mytest::round($i); is( $i, -2.0 );
        $i = -1.1; &amp;Mytest::round($i); is( $i, -1.0 );
        $i = 0.0; &amp;Mytest::round($i);  is( $i,  0.0 );
        $i = 0.5; &amp;Mytest::round($i);  is( $i,  1.0 );
        $i = 1.2; &amp;Mytest::round($i);  is( $i,  1.0 );
</pre>
<p class="Pp">Running &quot;<span class="Li">&quot;make test&quot;</span>&quot;
    should now print out that all nine tests are okay.</p>
<p class="Pp">Notice that in these new test cases, the argument passed to round
    was a scalar variable. You might be wondering if you can round a constant or
    literal. To see what happens, temporarily add the following line to
    Mytest.t:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
        &amp;Mytest::round(3);
</pre>
<p class="Pp">Run &quot;<span class="Li">&quot;make test&quot;</span>&quot; and
    notice that Perl dies with a fatal error. Perl won't let you change the
    value of constants!</p>
</section>
<section class="Ss">
<h2 class="Ss" id="What's_new_here?"><a class="permalink" href="#What's_new_here?">What's
  new here?</a></h2>
<ul class="Bl-bullet">
  <li>We've made some changes to Makefile.PL. In this case, we've specified an
      extra library to be linked into the extension's shared library, the math
      library libm in this case. We'll talk later about how to write XSUBs that
      can call every routine in a library.</li>
  <li>The value of the function is not being passed back as the function's
      return value, but by changing the value of the variable that was passed
      into the function. You might have guessed that when you saw that the
      return value of round is of type &quot;void&quot;.</li>
</ul>
</section>
<section class="Ss">
<h2 class="Ss" id="Input_and_Output_Parameters"><a class="permalink" href="#Input_and_Output_Parameters">Input
  and Output Parameters</a></h2>
You specify the parameters that will be passed into the XSUB on the line(s)
  after you declare the function's return value and name. Each input parameter
  line starts with optional whitespace, and may have an optional terminating
  semicolon.
<p class="Pp">The list of output parameters occurs at the very end of the
    function, just after the OUTPUT: directive. The use of RETVAL tells Perl
    that you wish to send this value back as the return value of the XSUB
    function. In Example 3, we wanted the &quot;return value&quot; placed in the
    original variable which we passed in, so we listed it (and not RETVAL) in
    the OUTPUT: section.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="The__s-1XSUBPP_s0_Program"><a class="permalink" href="#The__s-1XSUBPP_s0_Program">The
  XSUBPP Program</a></h2>
The <b>xsubpp</b> program takes the XS code in the .xs file and translates it
  into C code, placing it in a file whose suffix is .c. The C code created makes
  heavy use of the C functions within Perl.
</section>
<section class="Ss">
<h2 class="Ss" id="The__s-1TYPEMAP_s0_file"><a class="permalink" href="#The__s-1TYPEMAP_s0_file">The
  TYPEMAP file</a></h2>
The <b>xsubpp</b> program uses rules to convert from Perl's data types (scalar,
  array, etc.) to C's data types (int, char, etc.). These rules are stored in
  the typemap file ($PERLLIB/ExtUtils/typemap). There's a brief discussion
  below, but all the nitty-gritty details can be found in perlxstypemap. If you
  have a new-enough version of perl (5.16 and up) or an upgraded XS compiler
  (<span class="Li">&quot;ExtUtils::ParseXS&quot;</span> 3.13_01 or better),
  then you can inline typemaps in your XS instead of writing separate files.
  Either way, this typemap thing is split into three parts:
<p class="Pp">The first section maps various C data types to a name, which
    corresponds somewhat with the various Perl types. The second section
    contains C code which <b>xsubpp</b> uses to handle input parameters. The
    third section contains C code which <b>xsubpp</b> uses to handle output
    parameters.</p>
<p class="Pp">Let's take a look at a portion of the .c file created for our
    extension. The file name is Mytest.c:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
        XS(XS_Mytest_round)
        {
            dXSARGS;
            if (items != 1)
                Perl_croak(aTHX_ &quot;Usage: Mytest::round(arg)&quot;);
            PERL_UNUSED_VAR(cv); /* -W */
            {
                double  arg = (double)SvNV(ST(0));      /* XXXXX */
                if (arg &gt; 0.0) {
                        arg = floor(arg + 0.5);
                } else if (arg &lt; 0.0) {
                        arg = ceil(arg - 0.5);
                } else {
                        arg = 0.0;
                }
                sv_setnv(ST(0), (double)arg);   /* XXXXX */
                SvSETMAGIC(ST(0));
            }
            XSRETURN_EMPTY;
        }
</pre>
<p class="Pp">Notice the two lines commented with &quot;XXXXX&quot;. If you
    check the first part of the typemap file (or section), you'll see that
    doubles are of type T_DOUBLE. In the INPUT part of the typemap, an argument
    that is T_DOUBLE is assigned to the variable arg by calling the routine SvNV
    on something, then casting it to double, then assigned to the variable arg.
    Similarly, in the OUTPUT section, once arg has its final value, it is passed
    to the sv_setnv function to be passed back to the calling subroutine. These
    two functions are explained in perlguts; we'll talk more later about what
    that &quot;<i>ST</i>(0)&quot; means in the section on the argument
  stack.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Warning_about_Output_Arguments"><a class="permalink" href="#Warning_about_Output_Arguments">Warning
  about Output Arguments</a></h2>
In general, it's not a good idea to write extensions that modify their input
  parameters, as in Example 3. Instead, you should probably return multiple
  values in an array and let the caller handle them (we'll do this in a later
  example). However, in order to better accommodate calling pre-existing C
  routines, which often do modify their input parameters, this behavior is
  tolerated.
</section>
<section class="Ss">
<h2 class="Ss" id="_s-1EXAMPLE_4_s0"><a class="permalink" href="#_s-1EXAMPLE_4_s0">EXAMPLE
  4</a></h2>
In this example, we'll now begin to write XSUBs that will interact with
  pre-defined C libraries. To begin with, we will build a small library of our
  own, then let h2xs write our .pm and .xs files for us.
<p class="Pp">Create a new directory called Mytest2 at the same level as the
    directory Mytest. In the Mytest2 directory, create another directory called
    mylib, and cd into that directory.</p>
<p class="Pp">Here we'll create some files that will generate a test library.
    These will include a C source file and a header file. We'll also create a
    Makefile.PL in this directory. Then we'll make sure that running make at the
    Mytest2 level will automatically run this Makefile.PL file and the resulting
    Makefile.</p>
<p class="Pp">In the mylib directory, create a file mylib.h that looks like
    this:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
        #define TESTVAL 4

        extern double   foo(int, long, const char*);
</pre>
<p class="Pp">Also create a file mylib.c that looks like this:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
        #include &lt;stdlib.h&gt;
        #include &quot;./mylib.h&quot;

        double
        foo(int a, long b, const char *c)
        {
                return (a + b + atof(c) + TESTVAL);
        }
</pre>
<p class="Pp">And finally create a file Makefile.PL that looks like this:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
        use ExtUtils::MakeMaker;
        $Verbose = 1;
        WriteMakefile(
            NAME   =&gt; 'Mytest2::mylib',
            SKIP   =&gt; [qw(all static static_lib dynamic dynamic_lib)],
            clean  =&gt; {'FILES' =&gt; 'libmylib$(LIB_EXT)'},
        );


        sub MY::top_targets {
                '
        all :: static

        pure_all :: static

        static ::       libmylib$(LIB_EXT)

        libmylib$(LIB_EXT): $(O_FILES)
                $(AR) cr libmylib$(LIB_EXT) $(O_FILES)
                $(RANLIB) libmylib$(LIB_EXT)

        ';
        }
</pre>
<p class="Pp">Make sure you use a tab and not spaces on the lines beginning with
    &quot;$(AR)&quot; and &quot;$(RANLIB)&quot;. Make will not function properly
    if you use spaces. It has also been reported that the &quot;cr&quot;
    argument to $(AR) is unnecessary on Win32 systems.</p>
<p class="Pp">We will now create the main top-level Mytest2 files. Change to the
    directory above Mytest2 and run the following command:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
        % h2xs -O -n Mytest2 ./Mytest2/mylib/mylib.h
</pre>
<p class="Pp">This will print out a warning about overwriting Mytest2, but
    that's okay. Our files are stored in Mytest2/mylib, and will be
  untouched.</p>
<p class="Pp">The normal Makefile.PL that h2xs generates doesn't know about the
    mylib directory. We need to tell it that there is a subdirectory and that we
    will be generating a library in it. Let's add the argument MYEXTLIB to the
    WriteMakefile call so that it looks like this:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
        WriteMakefile(
            'NAME'      =&gt; 'Mytest2',
            'VERSION_FROM' =&gt; 'Mytest2.pm', # finds $VERSION
            'LIBS'      =&gt; [''],   # e.g., '-lm'
            'DEFINE'    =&gt; '',     # e.g., '-DHAVE_SOMETHING'
            'INC'       =&gt; '',     # e.g., '-I/usr/include/other'
            'MYEXTLIB' =&gt; 'mylib/libmylib$(LIB_EXT)',
        );
</pre>
<p class="Pp">and then at the end add a subroutine (which will override the
    pre-existing subroutine). Remember to use a tab character to indent the line
    beginning with &quot;cd&quot;!</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
        sub MY::postamble {
        '
        $(MYEXTLIB): mylib/Makefile
                cd mylib &amp;&amp; $(MAKE) $(PASSTHRU)
        ';
        }
</pre>
<p class="Pp">Let's also fix the MANIFEST file so that it accurately reflects
    the contents of our extension. The single line that says &quot;mylib&quot;
    should be replaced by the following three lines:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
        mylib/Makefile.PL
        mylib/mylib.c
        mylib/mylib.h
</pre>
<p class="Pp">To keep our namespace nice and unpolluted, edit the .pm file and
    change the variable <span class="Li">@EXPORT</span> to
    <span class="Li">@EXPORT_OK</span>. Finally, in the .xs file, edit the
    #include line to read:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
        #include &quot;mylib/mylib.h&quot;
</pre>
<p class="Pp">And also add the following function definition to the end of the
    .xs file:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
        double
        foo(a,b,c)
                int             a
                long            b
                const char *    c
            OUTPUT:
                RETVAL
</pre>
<p class="Pp">Now we also need to create a typemap because the default Perl
    doesn't currently support the <span class="Li">&quot;const char
    *&quot;</span> type. Include a new TYPEMAP section in your XS code before
    the above function:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
        TYPEMAP: &lt;&lt;END;
        const char *    T_PV
        END
</pre>
<p class="Pp">Now run perl on the top-level Makefile.PL. Notice that it also
    created a Makefile in the mylib directory. Run make and watch that it does
    cd into the mylib directory and run make in there as well.</p>
<p class="Pp">Now edit the Mytest2.t script and change the number of tests to
    &quot;4&quot;, and add the following lines to the end of the script:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
        is( &amp;Mytest2::foo(1, 2, &quot;Hello, world!&quot;), 7 );
        is( &amp;Mytest2::foo(1, 2, &quot;0.0&quot;), 7 );
        ok( abs(&amp;Mytest2::foo(0, 0, &quot;-3.4&quot;) - 0.6) &lt;= 0.01 );
</pre>
<p class="Pp">(When dealing with floating-point comparisons, it is best to not
    check for equality, but rather that the difference between the expected and
    actual result is below a certain amount (called epsilon) which is 0.01 in
    this case)</p>
<p class="Pp">Run &quot;<span class="Li">&quot;make test&quot;</span>&quot; and
    all should be well. There are some warnings on missing tests for the
    Mytest2::mylib extension, but you can ignore them.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="What_has_happened_here?"><a class="permalink" href="#What_has_happened_here?">What
  has happened here?</a></h2>
Unlike previous examples, we've now run h2xs on a real include file. This has
  caused some extra goodies to appear in both the .pm and .xs files.
<ul class="Bl-bullet">
  <li>In the .xs file, there's now a #include directive with the absolute path
      to the mylib.h header file. We changed this to a relative path so that we
      could move the extension directory if we wanted to.</li>
  <li>There's now some new C code that's been added to the .xs file. The purpose
      of the <span class="Li">&quot;constant&quot;</span> routine is to make the
      values that are #define'd in the header file accessible by the Perl script
      (by calling either <span class="Li">&quot;TESTVAL&quot;</span> or
      <span class="Li">&amp;Mytest2::TESTVAL</span>). There's also some XS code
      to allow calls to the <span class="Li">&quot;constant&quot;</span>
      routine.</li>
  <li>The .pm file originally exported the name
      <span class="Li">&quot;TESTVAL&quot;</span> in the
      <span class="Li">@EXPORT</span> array. This could lead to name clashes. A
      good rule of thumb is that if the #define is only going to be used by the
      C routines themselves, and not by the user, they should be removed from
      the <span class="Li">@EXPORT</span> array. Alternately, if you don't mind
      using the &quot;fully qualified name&quot; of a variable, you could move
      most or all of the items from the <span class="Li">@EXPORT</span> array
      into the <span class="Li">@EXPORT_OK</span> array.</li>
  <li>If our include file had contained #include directives, these would not
      have been processed by h2xs. There is no good solution to this right
    now.</li>
  <li>We've also told Perl about the library that we built in the mylib
      subdirectory. That required only the addition of the
      <span class="Li">&quot;MYEXTLIB&quot;</span> variable to the WriteMakefile
      call and the replacement of the postamble subroutine to cd into the
      subdirectory and run make. The Makefile.PL for the library is a bit more
      complicated, but not excessively so. Again we replaced the postamble
      subroutine to insert our own code. This code simply specified that the
      library to be created here was a static archive library (as opposed to a
      dynamically loadable library) and provided the commands to build it.</li>
</ul>
</section>
<section class="Ss">
<h2 class="Ss" id="Anatomy_of_.xs_file"><a class="permalink" href="#Anatomy_of_.xs_file">Anatomy
  of .xs file</a></h2>
The .xs file of &quot;EXAMPLE 4&quot; contained some new elements. To understand
  the meaning of these elements, pay attention to the line which reads
<p class="Pp"><span class="Li"></span></p>
<pre>
        MODULE = Mytest2                PACKAGE = Mytest2
</pre>
<p class="Pp">Anything before this line is plain C code which describes which
    headers to include, and defines some convenience functions. No translations
    are performed on this part, apart from having embedded POD documentation
    skipped over (see perlpod) it goes into the generated output C file as
  is.</p>
<p class="Pp">Anything after this line is the description of XSUB functions.
    These descriptions are translated by <b>xsubpp</b> into C code which
    implements these functions using Perl calling conventions, and which makes
    these functions visible from Perl interpreter.</p>
<p class="Pp">Pay a special attention to the function
    <span class="Li">&quot;constant&quot;</span>. This name appears twice in the
    generated .xs file: once in the first part, as a static C function, then
    another time in the second part, when an XSUB interface to this static C
    function is defined.</p>
<p class="Pp">This is quite typical for .xs files: usually the .xs file provides
    an interface to an existing C function. Then this C function is defined
    somewhere (either in an external library, or in the first part of .xs file),
    and a Perl interface to this function (i.e. &quot;Perl glue&quot;) is
    described in the second part of .xs file. The situation in &quot;EXAMPLE
    1&quot;, &quot;EXAMPLE 2&quot;, and &quot;EXAMPLE 3&quot;, when all the work
    is done inside the &quot;Perl glue&quot;, is somewhat of an exception rather
    than the rule.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Getting_the_fat_out_of_XSUBs"><a class="permalink" href="#Getting_the_fat_out_of_XSUBs">Getting
  the fat out of XSUBs</a></h2>
In &quot;EXAMPLE 4&quot; the second part of .xs file contained the following
  description of an XSUB:
<p class="Pp"><span class="Li"></span></p>
<pre>
        double
        foo(a,b,c)
                int             a
                long            b
                const char *    c
            OUTPUT:
                RETVAL
</pre>
<p class="Pp">Note that in contrast with &quot;EXAMPLE 1&quot;, &quot;EXAMPLE
    2&quot; and &quot;EXAMPLE 3&quot;, this description does not contain the
    actual <i>code</i> for what is done during a call to Perl function
    <i>foo()</i>. To understand what is going on here, one can add a CODE
    section to this XSUB:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
        double
        foo(a,b,c)
                int             a
                long            b
                const char *    c
            CODE:
                RETVAL = foo(a,b,c);
            OUTPUT:
                RETVAL
</pre>
<p class="Pp">However, these two XSUBs provide almost identical generated C
    code: <b>xsubpp</b> compiler is smart enough to figure out the
    <span class="Li">&quot;CODE:&quot;</span> section from the first two lines
    of the description of XSUB. What about
    <span class="Li">&quot;OUTPUT:&quot;</span> section? In fact, that is
    absolutely the same! The <span class="Li">&quot;OUTPUT:&quot;</span> section
    can be removed as well, <i>as far as </i><i>&quot;CODE:&quot;</i><i> section
    or </i><i>&quot;PPCODE:&quot;</i><i> section</i> is not specified:
    <b>xsubpp</b> can see that it needs to generate a function call section, and
    will autogenerate the OUTPUT section too. Thus one can shortcut the XSUB to
    become:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
        double
        foo(a,b,c)
                int             a
                long            b
                const char *    c
</pre>
<p class="Pp">Can we do the same with an XSUB</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
        int
        is_even(input)
                int     input
            CODE:
                RETVAL = (input % 2 == 0);
            OUTPUT:
                RETVAL
</pre>
<p class="Pp">of &quot;EXAMPLE 2&quot;? To do this, one needs to define a C
    function <span class="Li">&quot;int</span> <span class="Li">is_even(int
    input)&quot;</span>. As we saw in &quot;Anatomy of .xs file&quot;, a proper
    place for this definition is in the first part of .xs file. In fact a C
    function</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
        int
        is_even(int arg)
        {
                return (arg % 2 == 0);
        }
</pre>
<p class="Pp">is probably overkill for this. Something as simple as a
    <span class="Li">&quot;#define&quot;</span> will do too:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
        #define is_even(arg)    ((arg) % 2 == 0)
</pre>
<p class="Pp">After having this in the first part of .xs file, the &quot;Perl
    glue&quot; part becomes as simple as</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
        int
        is_even(input)
                int     input
</pre>
<p class="Pp">This technique of separation of the glue part from the workhorse
    part has obvious tradeoffs: if you want to change a Perl interface, you need
    to change two places in your code. However, it removes a lot of clutter, and
    makes the workhorse part independent from idiosyncrasies of Perl calling
    convention. (In fact, there is nothing Perl-specific in the above
    description, a different version of <b>xsubpp</b> might have translated this
    to TCL glue or Python glue as well.)</p>
</section>
<section class="Ss">
<h2 class="Ss" id="More_about__s-1XSUB_s0_arguments"><a class="permalink" href="#More_about__s-1XSUB_s0_arguments">More
  about XSUB arguments</a></h2>
With the completion of Example 4, we now have an easy way to simulate some
  real-life libraries whose interfaces may not be the cleanest in the world. We
  shall now continue with a discussion of the arguments passed to the
  <b>xsubpp</b> compiler.
<p class="Pp">When you specify arguments to routines in the .xs file, you are
    really passing three pieces of information for each argument listed. The
    first piece is the order of that argument relative to the others (first,
    second, etc). The second is the type of argument, and consists of the type
    declaration of the argument (e.g., int, char*, etc). The third piece is the
    calling convention for the argument in the call to the library function.</p>
<p class="Pp">While Perl passes arguments to functions by reference, C passes
    arguments by value; to implement a C function which modifies data of one of
    the &quot;arguments&quot;, the actual argument of this C function would be a
    pointer to the data. Thus two C functions with declarations</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
        int string_length(char *s);
        int upper_case_char(char *cp);
</pre>
<p class="Pp">may have completely different semantics: the first one may inspect
    an array of chars pointed by s, and the second one may immediately
    dereference <span class="Li">&quot;cp&quot;</span> and manipulate
    <span class="Li">*cp</span> only (using the return value as, say, a success
    indicator). From Perl one would use these functions in a completely
    different manner.</p>
<p class="Pp">One conveys this info to <b>xsubpp</b> by replacing
    <span class="Li">&quot;*&quot;</span> before the argument by
    <span class="Li">&quot;&amp;&quot;</span>.
    <span class="Li">&quot;&amp;&quot;</span> means that the argument should be
    passed to a library function by its address. The above two function may be
    XSUB-ified as</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
        int
        string_length(s)
                char *  s

        int
        upper_case_char(cp)
                char    &amp;cp
</pre>
<p class="Pp">For example, consider:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
        int
        foo(a,b)
                char    &amp;a
                char *  b
</pre>
<p class="Pp">The first Perl argument to this function would be treated as a
    char and assigned to the variable a, and its address would be passed into
    the function foo. The second Perl argument would be treated as a string
    pointer and assigned to the variable b. The <i>value</i> of b would be
    passed into the function foo. The actual call to the function foo that
    <b>xsubpp</b> generates would look like this:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
        foo(&amp;a, b);
</pre>
<p class="Pp"><b>xsubpp</b> will parse the following function argument lists
    identically:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
        char    &amp;a
        char&amp;a
        char    &amp; a
</pre>
<p class="Pp">However, to help ease understanding, it is suggested that you
    place a &quot;&amp;&quot; next to the variable name and away from the
    variable type), and place a &quot;*&quot; near the variable type, but away
    from the variable name (as in the call to foo above). By doing so, it is
    easy to understand exactly what will be passed to the C function; it will be
    whatever is in the &quot;last column&quot;.</p>
<p class="Pp">You should take great pains to try to pass the function the type
    of variable it wants, when possible. It will save you a lot of trouble in
    the long run.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="The_Argument_Stack"><a class="permalink" href="#The_Argument_Stack">The
  Argument Stack</a></h2>
If we look at any of the C code generated by any of the examples except example
  1, you will notice a number of references to ST(n), where n is usually 0.
  &quot;ST&quot; is actually a macro that points to the n'th argument on the
  argument stack. <i>ST</i>(0) is thus the first argument on the stack and
  therefore the first argument passed to the XSUB, <i>ST</i>(1) is the second
  argument, and so on.
<p class="Pp">When you list the arguments to the XSUB in the .xs file, that
    tells <b>xsubpp</b> which argument corresponds to which of the argument
    stack (i.e., the first one listed is the first argument, and so on). You
    invite disaster if you do not list them in the same order as the function
    expects them.</p>
<p class="Pp">The actual values on the argument stack are pointers to the values
    passed in. When an argument is listed as being an OUTPUT value, its
    corresponding value on the stack (i.e., <i>ST</i>(0) if it was the first
    argument) is changed. You can verify this by looking at the C code generated
    for Example 3. The code for the <i>round()</i> XSUB routine contains lines
    that look like this:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
        double  arg = (double)SvNV(ST(0));
        /* Round the contents of the variable arg */
        sv_setnv(ST(0), (double)arg);
</pre>
<p class="Pp">The arg variable is initially set by taking the value from
    <i>ST</i>(0), then is stored back into <i>ST</i>(0) at the end of the
    routine.</p>
<p class="Pp">XSUBs are also allowed to return lists, not just scalars. This
    must be done by manipulating stack values <i>ST</i>(0), <i>ST</i>(1), etc,
    in a subtly different way. See perlxs for details.</p>
<p class="Pp">XSUBs are also allowed to avoid automatic conversion of Perl
    function arguments to C function arguments. See perlxs for details. Some
    people prefer manual conversion by inspecting <span class="Li">ST(i)</span>
    even in the cases when automatic conversion will do, arguing that this makes
    the logic of an XSUB call clearer. Compare with &quot;Getting the fat out of
    XSUBs&quot; for a similar tradeoff of a complete separation of &quot;Perl
    glue&quot; and &quot;workhorse&quot; parts of an XSUB.</p>
<p class="Pp">While experts may argue about these idioms, a novice to Perl guts
    may prefer a way which is as little Perl-guts-specific as possible, meaning
    automatic conversion and automatic call generation, as in &quot;Getting the
    fat out of XSUBs&quot;. This approach has the additional benefit of
    protecting the XSUB writer from future changes to the Perl API.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Extending_your_Extension"><a class="permalink" href="#Extending_your_Extension">Extending
  your Extension</a></h2>
Sometimes you might want to provide some extra methods or subroutines to assist
  in making the interface between Perl and your extension simpler or easier to
  understand. These routines should live in the .pm file. Whether they are
  automatically loaded when the extension itself is loaded or only loaded when
  called depends on where in the .pm file the subroutine definition is placed.
  You can also consult AutoLoader for an alternate way to store and load your
  extra subroutines.
</section>
<section class="Ss">
<h2 class="Ss" id="Documenting_your_Extension"><a class="permalink" href="#Documenting_your_Extension">Documenting
  your Extension</a></h2>
There is absolutely no excuse for not documenting your extension. Documentation
  belongs in the .pm file. This file will be fed to pod2man, and the embedded
  documentation will be converted to the manpage format, then placed in the blib
  directory. It will be copied to Perl's manpage directory when the extension is
  installed.
<p class="Pp">You may intersperse documentation and Perl code within the .pm
    file. In fact, if you want to use method autoloading, you must do this, as
    the comment inside the .pm file explains.</p>
<p class="Pp">See perlpod for more information about the pod format.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Installing_your_Extension"><a class="permalink" href="#Installing_your_Extension">Installing
  your Extension</a></h2>
Once your extension is complete and passes all its tests, installing it is quite
  simple: you simply run &quot;make install&quot;. You will either need to have
  write permission into the directories where Perl is installed, or ask your
  system administrator to run the make for you.
<p class="Pp">Alternately, you can specify the exact directory to place the
    extension's files by placing a &quot;PREFIX=/destination/directory&quot;
    after the make install. (or in between the make and install if you have a
    brain-dead version of make). This can be very useful if you are building an
    extension that will eventually be distributed to multiple systems. You can
    then just archive the files in the destination directory and distribute them
    to your destination systems.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_s-1EXAMPLE_5_s0"><a class="permalink" href="#_s-1EXAMPLE_5_s0">EXAMPLE
  5</a></h2>
In this example, we'll do some more work with the argument stack. The previous
  examples have all returned only a single value. We'll now create an extension
  that returns an array.
<p class="Pp">This extension is very Unix-oriented (struct statfs and the statfs
    system call). If you are not running on a Unix system, you can substitute
    for statfs any other function that returns multiple values, you can
    hard-code values to be returned to the caller (although this will be a bit
    harder to test the error case), or you can simply not do this example. If
    you change the XSUB, be sure to fix the test cases to match the changes.</p>
<p class="Pp">Return to the Mytest directory and add the following code to the
    end of Mytest.xs:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
        void
        statfs(path)
                char *  path
            INIT:
                int i;
                struct statfs buf;

            PPCODE:
                i = statfs(path, &amp;buf);
                if (i == 0) {
                        XPUSHs(sv_2mortal(newSVnv(buf.f_bavail)));
                        XPUSHs(sv_2mortal(newSVnv(buf.f_bfree)));
                        XPUSHs(sv_2mortal(newSVnv(buf.f_blocks)));
                        XPUSHs(sv_2mortal(newSVnv(buf.f_bsize)));
                        XPUSHs(sv_2mortal(newSVnv(buf.f_ffree)));
                        XPUSHs(sv_2mortal(newSVnv(buf.f_files)));
                        XPUSHs(sv_2mortal(newSVnv(buf.f_type)));
                } else {
                        XPUSHs(sv_2mortal(newSVnv(errno)));
                }
</pre>
<p class="Pp">You'll also need to add the following code to the top of the .xs
    file, just after the include of &quot;XSUB.h&quot;:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
        #include &lt;sys/vfs.h&gt;
</pre>
<p class="Pp">Also add the following code segment to Mytest.t while incrementing
    the &quot;9&quot; tests to &quot;11&quot;:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
        @a = &amp;Mytest::statfs(&quot;/blech&quot;);
        ok( scalar(@a) == 1 &amp;&amp; $a[0] == 2 );
        @a = &amp;Mytest::statfs(&quot;/&quot;);
        is( scalar(@a), 7 );
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="New_Things_in_this_Example"><a class="permalink" href="#New_Things_in_this_Example">New
  Things in this Example</a></h2>
This example added quite a few new concepts. We'll take them one at a time.
<ul class="Bl-bullet">
  <li>The INIT: directive contains code that will be placed immediately after
      the argument stack is decoded. C does not allow variable declarations at
      arbitrary locations inside a function, so this is usually the best way to
      declare local variables needed by the XSUB. (Alternatively, one could put
      the whole <span class="Li">&quot;PPCODE:&quot;</span> section into braces,
      and put these declarations on top.)</li>
  <li>This routine also returns a different number of arguments depending on the
      success or failure of the call to statfs. If there is an error, the error
      number is returned as a single-element array. If the call is successful,
      then a 7-element array is returned. Since only one argument is passed into
      this function, we need room on the stack to hold the 7 values which may be
      returned.
    <p class="Pp">We do this by using the PPCODE: directive, rather than the
        CODE: directive. This tells <b>xsubpp</b> that we will be managing the
        return values that will be put on the argument stack by ourselves.</p>
  </li>
  <li>When we want to place values to be returned to the caller onto the stack,
      we use the series of macros that begin with &quot;XPUSH&quot;. There are
      five different versions, for placing integers, unsigned integers, doubles,
      strings, and Perl scalars on the stack. In our example, we placed a Perl
      scalar onto the stack. (In fact this is the only macro which can be used
      to return multiple values.)
    <p class="Pp">The XPUSH* macros will automatically extend the return stack
        to prevent it from being overrun. You push values onto the stack in the
        order you want them seen by the calling program.</p>
  </li>
  <li>The values pushed onto the return stack of the XSUB are actually mortal
      SV's. They are made mortal so that once the values are copied by the
      calling program, the SV's that held the returned values can be
      deallocated. If they were not mortal, then they would continue to exist
      after the XSUB routine returned, but would not be accessible. This is a
      memory leak.</li>
  <li>If we were interested in performance, not in code compactness, in the
      success branch we would not use <span class="Li">&quot;XPUSHs&quot;</span>
      macros, but <span class="Li">&quot;PUSHs&quot;</span> macros, and would
      pre-extend the stack before pushing the return values:
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        EXTEND(SP, 7);
    </pre>
    <p class="Pp">The tradeoff is that one needs to calculate the number of
        return values in advance (though overextending the stack will not
        typically hurt anything but memory consumption).</p>
    <p class="Pp">Similarly, in the failure branch we could use
        <span class="Li">&quot;PUSHs&quot;</span> <i>without</i> extending the
        stack: the Perl function reference comes to an XSUB on the stack, thus
        the stack is <i>always</i> large enough to take one return value.</p>
  </li>
</ul>
</section>
<section class="Ss">
<h2 class="Ss" id="_s-1EXAMPLE_6_s0"><a class="permalink" href="#_s-1EXAMPLE_6_s0">EXAMPLE
  6</a></h2>
In this example, we will accept a reference to an array as an input parameter,
  and return a reference to an array of hashes. This will demonstrate
  manipulation of complex Perl data types from an XSUB.
<p class="Pp">This extension is somewhat contrived. It is based on the code in
    the previous example. It calls the statfs function multiple times, accepting
    a reference to an array of filenames as input, and returning a reference to
    an array of hashes containing the data for each of the filesystems.</p>
<p class="Pp">Return to the Mytest directory and add the following code to the
    end of Mytest.xs:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    SV *
    multi_statfs(paths)
            SV * paths
        INIT:
            AV * results;
            I32 numpaths = 0;
            int i, n;
            struct statfs buf;

            SvGETMAGIC(paths);
            if ((!SvROK(paths))
                || (SvTYPE(SvRV(paths)) != SVt_PVAV)
                || ((numpaths = av_top_index((AV *)SvRV(paths))) &lt; 0))
            {
                XSRETURN_UNDEF;
            }
            results = (AV *)sv_2mortal((SV *)newAV());
        CODE:
            for (n = 0; n &lt;= numpaths; n++) {
                HV * rh;
                STRLEN l;
                char * fn = SvPV(*av_fetch((AV *)SvRV(paths), n, 0), l);

                i = statfs(fn, &amp;buf);
                if (i != 0) {
                    av_push(results, newSVnv(errno));
                    continue;
                }

                rh = (HV *)sv_2mortal((SV *)newHV());

                hv_store(rh, &quot;f_bavail&quot;, 8, newSVnv(buf.f_bavail), 0);
                hv_store(rh, &quot;f_bfree&quot;,  7, newSVnv(buf.f_bfree),  0);
                hv_store(rh, &quot;f_blocks&quot;, 8, newSVnv(buf.f_blocks), 0);
                hv_store(rh, &quot;f_bsize&quot;,  7, newSVnv(buf.f_bsize),  0);
                hv_store(rh, &quot;f_ffree&quot;,  7, newSVnv(buf.f_ffree),  0);
                hv_store(rh, &quot;f_files&quot;,  7, newSVnv(buf.f_files),  0);
                hv_store(rh, &quot;f_type&quot;,   6, newSVnv(buf.f_type),   0);

                av_push(results, newRV((SV *)rh));
            }
            RETVAL = newRV((SV *)results);
        OUTPUT:
            RETVAL
</pre>
<p class="Pp">And add the following code to Mytest.t, while incrementing the
    &quot;11&quot; tests to &quot;13&quot;:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
        $results = Mytest::multi_statfs([ '/', '/blech' ]);
        ok( ref $results-&gt;[0] );
        ok( ! ref $results-&gt;[1] );
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="New_Things_in_this_Example_2"><a class="permalink" href="#New_Things_in_this_Example_2">New
  Things in this Example</a></h2>
There are a number of new concepts introduced here, described below:
<ul class="Bl-bullet">
  <li>This function does not use a typemap. Instead, we declare it as accepting
      one SV* (scalar) parameter, and returning an SV* value, and we take care
      of populating these scalars within the code. Because we are only returning
      one value, we don't need a <span class="Li">&quot;PPCODE:&quot;</span>
      directive - instead, we use <span class="Li">&quot;CODE:&quot;</span> and
      <span class="Li">&quot;OUTPUT:&quot;</span> directives.</li>
  <li>When dealing with references, it is important to handle them with caution.
      The <span class="Li">&quot;INIT:&quot;</span> block first calls
      SvGETMAGIC(paths), in case paths is a tied variable. Then it checks that
      <span class="Li">&quot;SvROK&quot;</span> returns true, which indicates
      that paths is a valid reference. (Simply checking
      <span class="Li">&quot;SvROK&quot;</span> won't trigger FETCH on a tied
      variable.) It then verifies that the object referenced by paths is an
      array, using <span class="Li">&quot;SvRV&quot;</span> to dereference
      paths, and <span class="Li">&quot;SvTYPE&quot;</span> to discover its
      type. As an added test, it checks that the array referenced by paths is
      non-empty, using the <span class="Li">&quot;av_top_index&quot;</span>
      function (which returns -1 if the array is empty). The XSRETURN_UNDEF
      macro is used to abort the XSUB and return the undefined value whenever
      all three of these conditions are not met.</li>
  <li>We manipulate several arrays in this XSUB. Note that an array is
      represented internally by an AV* pointer. The functions and macros for
      manipulating arrays are similar to the functions in Perl:
      <span class="Li">&quot;av_top_index&quot;</span> returns the highest index
      in an AV*, much like $#array; <span class="Li">&quot;av_fetch&quot;</span>
      fetches a single scalar value from an array, given its index;
      <span class="Li">&quot;av_push&quot;</span> pushes a scalar value onto the
      end of the array, automatically extending the array as necessary.
    <p class="Pp">Specifically, we read pathnames one at a time from the input
        array, and store the results in an output array (results) in the same
        order. If statfs fails, the element pushed onto the return array is the
        value of errno after the failure. If statfs succeeds, though, the value
        pushed onto the return array is a reference to a hash containing some of
        the information in the statfs structure.</p>
    <p class="Pp">As with the return stack, it would be possible (and a small
        performance win) to pre-extend the return array before pushing data into
        it, since we know how many elements we will return:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        av_extend(results, numpaths);
    </pre>
  </li>
  <li>We are performing only one hash operation in this function, which is
      storing a new scalar under a key using
      <span class="Li">&quot;hv_store&quot;</span>. A hash is represented by an
      HV* pointer. Like arrays, the functions for manipulating hashes from an
      XSUB mirror the functionality available from Perl. See perlguts and
      perlapi for details.</li>
  <li>To create a reference, we use the
      <span class="Li">&quot;newRV&quot;</span> function. Note that you can cast
      an AV* or an HV* to type SV* in this case (and many others). This allows
      you to take references to arrays, hashes and scalars with the same
      function. Conversely, the <span class="Li">&quot;SvRV&quot;</span>
      function always returns an SV*, which may need to be cast to the
      appropriate type if it is something other than a scalar (check with
      <span class="Li">&quot;SvTYPE&quot;</span>).</li>
  <li>At this point, xsubpp is doing very little work - the differences between
      Mytest.xs and Mytest.c are minimal.</li>
</ul>
</section>
<section class="Ss">
<h2 class="Ss" id="_s-1EXAMPLE_7__s0(Coming_Soon)"><a class="permalink" href="#_s-1EXAMPLE_7__s0(Coming_Soon)">EXAMPLE
  7 (Coming Soon)</a></h2>
XPUSH args AND set RETVAL AND assign return value to array
</section>
<section class="Ss">
<h2 class="Ss" id="_s-1EXAMPLE_8__s0(Coming_Soon)"><a class="permalink" href="#_s-1EXAMPLE_8__s0(Coming_Soon)">EXAMPLE
  8 (Coming Soon)</a></h2>
Setting $!
</section>
<section class="Ss">
<h2 class="Ss" id="_s-1EXAMPLE_9_s0_Passing_open_files_to_XSes"><a class="permalink" href="#_s-1EXAMPLE_9_s0_Passing_open_files_to_XSes">EXAMPLE
  9 Passing open files to XSes</a></h2>
You would think passing files to an XS is difficult, with all the typeglobs and
  stuff. Well, it isn't.
<p class="Pp">Suppose that for some strange reason we need a wrapper around the
    standard C library function <span class="Li">&quot;fputs()&quot;</span>.
    This is all we need:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
        #define PERLIO_NOT_STDIO 0
        #include &quot;EXTERN.h&quot;
        #include &quot;perl.h&quot;
        #include &quot;XSUB.h&quot;

        #include &lt;stdio.h&gt;

        int
        fputs(s, stream)
                char *          s
                FILE *          stream
</pre>
<p class="Pp">The real work is done in the standard typemap.</p>
<p class="Pp"><b>But</b> you lose all the fine stuff done by the perlio layers.
    This calls the stdio function <span class="Li">&quot;fputs()&quot;</span>,
    which knows nothing about them.</p>
<p class="Pp">The standard typemap offers three variants of PerlIO *:
    <span class="Li">&quot;InputStream&quot;</span> (T_IN),
    <span class="Li">&quot;InOutStream&quot;</span> (T_INOUT) and
    <span class="Li">&quot;OutputStream&quot;</span> (T_OUT). A bare
    <span class="Li">&quot;PerlIO *&quot;</span> is considered a T_INOUT. If it
    matters in your code (see below for why it might) #define or typedef one of
    the specific names and use that as the argument or result type in your XS
    file.</p>
<p class="Pp">The standard typemap does not contain PerlIO * before perl 5.7,
    but it has the three stream variants. Using a PerlIO * directly is not
    backwards compatible unless you provide your own typemap.</p>
<p class="Pp">For streams coming <i>from</i> perl the main difference is that
    <span class="Li">&quot;OutputStream&quot;</span> will get the output PerlIO
    * - which may make a difference on a socket. Like in our example...</p>
<p class="Pp">For streams being handed <i>to</i> perl a new file handle is
    created (i.e. a reference to a new glob) and associated with the PerlIO *
    provided. If the read/write state of the PerlIO * is not correct then you
    may get errors or warnings from when the file handle is used. So if you
    opened the PerlIO * as &quot;w&quot; it should really be an
    <span class="Li">&quot;OutputStream&quot;</span> if open as &quot;r&quot; it
    should be an <span class="Li">&quot;InputStream&quot;</span>.</p>
<p class="Pp">Now, suppose you want to use perlio layers in your XS. We'll use
    the perlio <span class="Li">&quot;PerlIO_puts()&quot;</span> function as an
    example.</p>
<p class="Pp">In the C part of the XS file (above the first MODULE line) you
    have</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
        #define OutputStream    PerlIO *
    or
        typedef PerlIO *        OutputStream;
</pre>
<p class="Pp">And this is the XS code:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
        int
        perlioputs(s, stream)
                char *          s
                OutputStream    stream
        CODE:
                RETVAL = PerlIO_puts(stream, s);
        OUTPUT:
                RETVAL
</pre>
<p class="Pp">We have to use a <span class="Li">&quot;CODE&quot;</span> section
    because <span class="Li">&quot;PerlIO_puts()&quot;</span> has the arguments
    reversed compared to <span class="Li">&quot;fputs()&quot;</span>, and we
    want to keep the arguments the same.</p>
<p class="Pp">Wanting to explore this thoroughly, we want to use the stdio
    <span class="Li">&quot;fputs()&quot;</span> on a PerlIO *. This means we
    have to ask the perlio system for a stdio <span class="Li">&quot;FILE
    *&quot;</span>:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
        int
        perliofputs(s, stream)
                char *          s
                OutputStream    stream
        PREINIT:
                FILE *fp = PerlIO_findFILE(stream);
        CODE:
                if (fp != (FILE*) 0) {
                        RETVAL = fputs(s, fp);
                } else {
                        RETVAL = -1;
                }
        OUTPUT:
                RETVAL
</pre>
<p class="Pp">Note: <span class="Li">&quot;PerlIO_findFILE()&quot;</span> will
    search the layers for a stdio layer. If it can't find one, it will call
    <span class="Li">&quot;PerlIO_exportFILE()&quot;</span> to generate a new
    stdio <span class="Li">&quot;FILE&quot;</span>. Please only call
    <span class="Li">&quot;PerlIO_exportFILE()&quot;</span> if you want a
    <i>new</i> <span class="Li">&quot;FILE&quot;</span>. It will generate one on
    each call and push a new stdio layer. So don't call it repeatedly on the
    same file. <span class="Li">&quot;PerlIO_findFILE()&quot;</span> will
    retrieve the stdio layer once it has been generated by
    <span class="Li">&quot;PerlIO_exportFILE()&quot;</span>.</p>
<p class="Pp">This applies to the perlio system only. For versions before 5.7,
    <span class="Li">&quot;PerlIO_exportFILE()&quot;</span> is equivalent to
    <span class="Li">&quot;PerlIO_findFILE()&quot;</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Troubleshooting_these_Examples"><a class="permalink" href="#Troubleshooting_these_Examples">Troubleshooting
  these Examples</a></h2>
As mentioned at the top of this document, if you are having problems with these
  example extensions, you might see if any of these help you.
<ul class="Bl-bullet">
  <li>In versions of 5.002 prior to the gamma version, the test script in
      Example 1 will not function properly. You need to change the &quot;use
      lib&quot; line to read:
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        use lib './blib';
    </pre>
  </li>
  <li>In versions of 5.002 prior to version 5.002b1h, the test.pl file was not
      automatically created by h2xs. This means that you cannot say &quot;make
      test&quot; to run the test script. You will need to add the following line
      before the &quot;use extension&quot; statement:
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        use lib './blib';
    </pre>
  </li>
  <li>In versions 5.000 and 5.001, instead of using the above line, you will
      need to use the following line:
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        BEGIN { unshift(@INC, &quot;./blib&quot;) }
    </pre>
  </li>
  <li>This document assumes that the executable named &quot;perl&quot; is Perl
      version 5. Some systems may have installed Perl version 5 as
      &quot;perl5&quot;.</li>
</ul>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="See_also"><a class="permalink" href="#See_also">See
  also</a></h1>
For more information, consult perlguts, perlapi, perlxs, perlmod, and perlpod.
</section>
<section class="Sh">
<h1 class="Sh" id="Author"><a class="permalink" href="#Author">Author</a></h1>
Jeff Okamoto &lt;<i>okamoto@corp.hp.com</i>&gt;
<p class="Pp">Reviewed and assisted by Dean Roehrich, Ilya Zakharevich, Andreas
    Koenig, and Tim Bunce.</p>
<p class="Pp">PerlIO material contributed by Lupe Christoph, with some
    clarification by Nick Ing-Simmons.</p>
<p class="Pp">Changes for h2xs as of Perl 5.8.x by Renee Baecker</p>
<section class="Ss">
<h2 class="Ss" id="Last_Changed"><a class="permalink" href="#Last_Changed">Last
  Changed</a></h2>
2012-01-20
</section>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2014-09-30</td>
    <td class="foot-os">perl v5.18.4</td>
  </tr>
</table>
</body>
</html>
