<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>Exporter(3pm)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Exporter(3pm)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">Exporter(3pm)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
Exporter - Implements default import method for modules
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
In module <i>YourModule.pm</i>:
<p class="Pp"><span class="Li"></span></p>
<pre>
  package YourModule;
  require Exporter;
  @ISA = qw(Exporter);
  @EXPORT_OK = qw(munge frobnicate);  # symbols to export on request
</pre>
<p class="Pp">or</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  package YourModule;
  use Exporter 'import'; # gives you Exporter's import() method directly
  @EXPORT_OK = qw(munge frobnicate);  # symbols to export on request
</pre>
<p class="Pp">In other files which wish to use
    <span class="Li">&quot;YourModule&quot;</span>:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  use YourModule qw(frobnicate);      # import listed symbols
  frobnicate ($left, $right)          # calls YourModule::frobnicate
</pre>
<p class="Pp">Take a look at &quot;Good Practices&quot; for some variants you
    will like to use in modern Perl code.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
The Exporter module implements an <span class="Li">&quot;import&quot;</span>
  method which allows a module to export functions and variables to its users'
  namespaces. Many modules use Exporter rather than implementing their own
  <span class="Li">&quot;import&quot;</span> method because Exporter provides a
  highly flexible interface, with an implementation optimised for the common
  case.
<p class="Pp">Perl automatically calls the
    <span class="Li">&quot;import&quot;</span> method when processing a
    <span class="Li">&quot;use&quot;</span> statement for a module. Modules and
    <span class="Li">&quot;use&quot;</span> are documented in perlfunc and
    perlmod. Understanding the concept of modules and how the
    <span class="Li">&quot;use&quot;</span> statement operates is important to
    understanding the Exporter.</p>
<section class="Ss">
<h2 class="Ss" id="How_to_Export"><a class="permalink" href="#How_to_Export">How
  to Export</a></h2>
The arrays <span class="Li">@EXPORT</span> and
  <span class="Li">@EXPORT_OK</span> in a module hold lists of symbols that are
  going to be exported into the users name space by default, or which they can
  request to be exported, respectively. The symbols can represent functions,
  scalars, arrays, hashes, or typeglobs. The symbols must be given by full name
  with the exception that the ampersand in front of a function is optional, e.g.
<p class="Pp"><span class="Li"></span></p>
<pre>
    @EXPORT    = qw(afunc $scalar @array);   # afunc is a function
    @EXPORT_OK = qw(&amp;bfunc %hash *typeglob); # explicit prefix on &amp;bfunc
</pre>
<p class="Pp">If you are only exporting function names it is recommended to omit
    the ampersand, as the implementation is faster this way.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Selecting_What_to_Export"><a class="permalink" href="#Selecting_What_to_Export">Selecting
  What to Export</a></h2>
Do <b>not</b> export method names!
<p class="Pp">Do <b>not</b> export anything else by default without a good
    reason!</p>
<p class="Pp">Exports pollute the namespace of the module user. If you must
    export try to use <span class="Li">@EXPORT_OK</span> in preference to
    <span class="Li">@EXPORT</span> and avoid short or common symbol names to
    reduce the risk of name clashes.</p>
<p class="Pp">Generally anything not exported is still accessible from outside
    the module using the
    <span class="Li">&quot;YourModule::item_name&quot;</span> (or
    <span class="Li">&quot;$blessed_ref-&gt;method&quot;</span>) syntax. By
    convention you can use a leading underscore on names to informally indicate
    that they are 'internal' and not for public use.</p>
<p class="Pp">(It is actually possible to get private functions by saying:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  my $subref = sub { ... };
  $subref-&gt;(@args);            # Call it as a function
  $obj-&gt;$subref(@args);        # Use it as a method
</pre>
<p class="Pp">However if you use them for methods it is up to you to figure out
    how to make inheritance work.)</p>
<p class="Pp">As a general rule, if the module is trying to be object oriented
    then export nothing. If it's just a collection of functions then
    <span class="Li">@EXPORT_OK</span> anything but use
    <span class="Li">@EXPORT</span> with caution. For function and method names
    use barewords in preference to names prefixed with ampersands for the export
    lists.</p>
<p class="Pp">Other module design guidelines can be found in perlmod.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="How_to_Import"><a class="permalink" href="#How_to_Import">How
  to Import</a></h2>
In other files which wish to use your module there are three basic ways for them
  to load your module and import its symbols:
<dl class="Bl-tag">
  <dt>&quot;use YourModule;&quot;</dt>
  <dd>This imports all the symbols from YourModule's
      <span class="Li">@EXPORT</span> into the namespace of the
      <span class="Li">&quot;use&quot;</span> statement.</dd>
  <dt>&quot;use YourModule ();&quot;</dt>
  <dd>This causes perl to load your module but does not import any symbols.</dd>
  <dt>&quot;use YourModule qw(...);&quot;</dt>
  <dd>This imports only the symbols listed by the caller into their namespace.
      All listed symbols must be in your <span class="Li">@EXPORT</span> or
      <span class="Li">@EXPORT_OK</span>, else an error occurs. The advanced
      export features of Exporter are accessed like this, but with list entries
      that are syntactically distinct from symbol names.</dd>
</dl>
<p class="Pp">Unless you want to use its advanced features, this is probably all
    you need to know to use Exporter.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="Advanced_Features"><a class="permalink" href="#Advanced_Features">Advanced
  Features</a></h1>
<section class="Ss">
<h2 class="Ss" id="Specialised_Import_Lists"><a class="permalink" href="#Specialised_Import_Lists">Specialised
  Import Lists</a></h2>
If any of the entries in an import list begins with !, : or / then the list is
  treated as a series of specifications which either add to or delete from the
  list of names to import. They are processed left to right. Specifications are
  in the form:
<p class="Pp"><span class="Li"></span></p>
<pre>
    [!]name         This name only
    [!]:DEFAULT     All names in @EXPORT
    [!]:tag         All names in $EXPORT_TAGS{tag} anonymous list
    [!]/pattern/    All names in @EXPORT and @EXPORT_OK which match
</pre>
<p class="Pp">A leading ! indicates that matching names should be deleted from
    the list of names to import. If the first specification is a deletion it is
    treated as though preceded by :DEFAULT. If you just want to import extra
    names in addition to the default set you will still need to include :DEFAULT
    explicitly.</p>
<p class="Pp">e.g., <i>Module.pm</i> defines:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    @EXPORT      = qw(A1 A2 A3 A4 A5);
    @EXPORT_OK   = qw(B1 B2 B3 B4 B5);
    %EXPORT_TAGS = (T1 =&gt; [qw(A1 A2 B1 B2)], T2 =&gt; [qw(A1 A2 B3 B4)]);
</pre>
<p class="Pp">Note that you cannot use tags in <span class="Li">@EXPORT</span>
    or <span class="Li">@EXPORT_OK</span>.</p>
<p class="Pp">Names in EXPORT_TAGS must also appear in
    <span class="Li">@EXPORT</span> or <span class="Li">@EXPORT_OK</span>.</p>
<p class="Pp">An application using Module can say something like:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    use Module qw(:DEFAULT :T2 !B3 A3);
</pre>
<p class="Pp">Other examples include:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    use Socket qw(!/^[AP]F_/ !SOMAXCONN !SOL_SOCKET);
    use POSIX  qw(:errno_h :termios_h !TCSADRAIN !/^EXIT/);
</pre>
<p class="Pp">Remember that most patterns (using //) will need to be anchored
    with a leading ^, e.g., <span class="Li">&quot;/^EXIT/&quot;</span> rather
    than <span class="Li">&quot;/EXIT/&quot;</span>.</p>
<p class="Pp">You can say <span class="Li">&quot;BEGIN { $Exporter::Verbose=1
    }&quot;</span> to see how the specifications are being processed and what is
    actually being imported into modules.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Exporting_Without_Using_Exporter's_import_Method"><a class="permalink" href="#Exporting_Without_Using_Exporter's_import_Method">Exporting
  Without Using Exporter's import Method</a></h2>
Exporter has a special method, 'export_to_level' which is used in situations
  where you can't directly call Exporter's import method. The export_to_level
  method looks like:
<p class="Pp"><span class="Li"></span></p>
<pre>
    MyPackage-&gt;export_to_level(
        $where_to_export, $package, @what_to_export
    );
</pre>
<p class="Pp">where <span class="Li">$where_to_export</span> is an integer
    telling how far up the calling stack to export your symbols, and
    <span class="Li">@what_to_export</span> is an array telling what symbols
    *to* export (usually this is <span class="Li">@_</span>). The
    <span class="Li">$package</span> argument is currently unused.</p>
<p class="Pp">For example, suppose that you have a module, A, which already has
    an import function:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    package A;

    @ISA = qw(Exporter);
    @EXPORT_OK = qw ($b);

    sub import
    {
        $A::b = 1;     # not a very useful import method
    }
</pre>
<p class="Pp">and you want to Export symbol <span class="Li">$A::b</span> back
    to the module that called package A. Since Exporter relies on the import
    method to work, via inheritance, as it stands <i>Exporter::import()</i> will
    never get called. Instead, say the following:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    package A;
    @ISA = qw(Exporter);
    @EXPORT_OK = qw ($b);

    sub import
    {
        $A::b = 1;
        A-&gt;export_to_level(1, @_);
    }
</pre>
<p class="Pp">This will export the symbols one level 'above' the current package
    - ie: to the program or module that used package A.</p>
<p class="Pp">Note: Be careful not to modify <span class="Li">@_</span> at all
    before you call export_to_level - or people using your package will get very
    unexplained results!</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Exporting_Without_Inheriting_from_Exporter"><a class="permalink" href="#Exporting_Without_Inheriting_from_Exporter">Exporting
  Without Inheriting from Exporter</a></h2>
By including Exporter in your <span class="Li">@ISA</span> you inherit an
  Exporter's <i>import()</i> method but you also inherit several other helper
  methods which you probably don't want. To avoid this you can do
<p class="Pp"><span class="Li"></span></p>
<pre>
  package YourModule;
  use Exporter qw( import );
</pre>
<p class="Pp">which will export Exporter's own <i>import()</i> method into
    YourModule. Everything will work as before but you won't need to include
    Exporter in <span class="Li">@YourModule::ISA</span>.</p>
<p class="Pp">Note: This feature was introduced in version 5.57 of Exporter,
    released with perl 5.8.3.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Module_Version_Checking"><a class="permalink" href="#Module_Version_Checking">Module
  Version Checking</a></h2>
The Exporter module will convert an attempt to import a number from a module
  into a call to
  <span class="Li">&quot;$module_name-&gt;VERSION($value)&quot;</span>. This can
  be used to validate that the version of the module being used is greater than
  or equal to the required version.
<p class="Pp">For historical reasons, Exporter supplies a
    <span class="Li">&quot;require_version&quot;</span> method that simply
    delegates to <span class="Li">&quot;VERSION&quot;</span>. Originally, before
    <span class="Li">&quot;UNIVERSAL::VERSION&quot;</span> existed, Exporter
    would call <span class="Li">&quot;require_version&quot;</span>.</p>
<p class="Pp">Since the <span class="Li">&quot;UNIVERSAL::VERSION&quot;</span>
    method treats the <span class="Li">$VERSION</span> number as a simple
    numeric value it will regard version 1.10 as lower than 1.9. For this reason
    it is strongly recommended that you use numbers with at least two decimal
    places, e.g., 1.09.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Managing_Unknown_Symbols"><a class="permalink" href="#Managing_Unknown_Symbols">Managing
  Unknown Symbols</a></h2>
In some situations you may want to prevent certain symbols from being exported.
  Typically this applies to extensions which have functions or constants that
  may not exist on some systems.
<p class="Pp">The names of any symbols that cannot be exported should be listed
    in the <span class="Li">@EXPORT_FAIL</span> array.</p>
<p class="Pp">If a module attempts to import any of these symbols the Exporter
    will give the module an opportunity to handle the situation before
    generating an error. The Exporter will call an export_fail method with a
    list of the failed symbols:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  @failed_symbols = $module_name-&gt;export_fail(@failed_symbols);
</pre>
<p class="Pp">If the <span class="Li">&quot;export_fail&quot;</span> method
    returns an empty list then no error is recorded and all the requested
    symbols are exported. If the returned list is not empty then an error is
    generated for each symbol and the export fails. The Exporter provides a
    default <span class="Li">&quot;export_fail&quot;</span> method which simply
    returns the list unchanged.</p>
<p class="Pp">Uses for the <span class="Li">&quot;export_fail&quot;</span>
    method include giving better error messages for some symbols and performing
    lazy architectural checks (put more symbols into
    <span class="Li">@EXPORT_FAIL</span> by default and then take them out if
    someone actually tries to use them and an expensive check shows that they
    are usable on that platform).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Tag_Handling_Utility_Functions"><a class="permalink" href="#Tag_Handling_Utility_Functions">Tag
  Handling Utility Functions</a></h2>
Since the symbols listed within <span class="Li">%EXPORT_TAGS</span> must also
  appear in either <span class="Li">@EXPORT</span> or
  <span class="Li">@EXPORT_OK</span>, two utility functions are provided which
  allow you to easily add tagged sets of symbols to
  <span class="Li">@EXPORT</span> or <span class="Li">@EXPORT_OK</span>:
<p class="Pp"><span class="Li"></span></p>
<pre>
  %EXPORT_TAGS = (foo =&gt; [qw(aa bb cc)], bar =&gt; [qw(aa cc dd)]);

  Exporter::export_tags('foo');     # add aa, bb and cc to @EXPORT
  Exporter::export_ok_tags('bar');  # add aa, cc and dd to @EXPORT_OK
</pre>
<p class="Pp">Any names which are not tags are added to
    <span class="Li">@EXPORT</span> or <span class="Li">@EXPORT_OK</span>
    unchanged but will trigger a warning (with
    <span class="Li">&quot;-w&quot;</span>) to avoid misspelt tags names being
    silently added to <span class="Li">@EXPORT</span> or
    <span class="Li">@EXPORT_OK</span>. Future versions may make this a fatal
    error.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Generating_Combined_Tags"><a class="permalink" href="#Generating_Combined_Tags">Generating
  Combined Tags</a></h2>
If several symbol categories exist in <span class="Li">%EXPORT_TAGS</span>, it's
  usually useful to create the utility &quot;:all&quot; to simplify
  &quot;use&quot; statements.
<p class="Pp">The simplest way to do this is:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  %EXPORT_TAGS = (foo =&gt; [qw(aa bb cc)], bar =&gt; [qw(aa cc dd)]);

  # add all the other &quot;:class&quot; tags to the &quot;:all&quot; class,
  # deleting duplicates
  {
    my %seen;

    push @{$EXPORT_TAGS{all}},
      grep {!$seen{$_}++} @{$EXPORT_TAGS{$_}} foreach keys %EXPORT_TAGS;
  }
</pre>
<p class="Pp"><i>CGI.pm</i> creates an &quot;:all&quot; tag which contains some
    (but not really all) of its categories. That could be done with one small
    change:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  # add some of the other &quot;:class&quot; tags to the &quot;:all&quot; class,
  # deleting duplicates
  {
    my %seen;

    push @{$EXPORT_TAGS{all}},
      grep {!$seen{$_}++} @{$EXPORT_TAGS{$_}}
        foreach qw/html2 html3 netscape form cgi internal/;
  }
</pre>
<p class="Pp">Note that the tag names in <span class="Li">%EXPORT_TAGS</span>
    don't have the leading ':'.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_AUTOLOAD_ed_Constants"><a class="permalink" href="#_AUTOLOAD_ed_Constants">&quot;AUTOLOAD&quot;ed
  Constants</a></h2>
Many modules make use of <span class="Li">&quot;AUTOLOAD&quot;</span>ing for
  constant subroutines to avoid having to compile and waste memory on rarely
  used values (see perlsub for details on constant subroutines). Calls to such
  constant subroutines are not optimized away at compile time because they can't
  be checked at compile time for constancy.
<p class="Pp">Even if a prototype is available at compile time, the body of the
    subroutine is not (it hasn't been
    <span class="Li">&quot;AUTOLOAD&quot;</span>ed yet). perl needs to examine
    both the <span class="Li">&quot;()&quot;</span> prototype and the body of a
    subroutine at compile time to detect that it can safely replace calls to
    that subroutine with the constant value.</p>
<p class="Pp">A workaround for this is to call the constants once in a
    <span class="Li">&quot;BEGIN&quot;</span> block:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
   package My ;

   use Socket ;

   foo( SO_LINGER );  ## SO_LINGER NOT optimized away; called at runtime
   BEGIN { SO_LINGER }
   foo( SO_LINGER );  ## SO_LINGER optimized away at compile time.
</pre>
<p class="Pp">This forces the <span class="Li">&quot;AUTOLOAD&quot;</span> for
    <span class="Li">&quot;SO_LINGER&quot;</span> to take place before SO_LINGER
    is encountered later in <span class="Li">&quot;My&quot;</span> package.</p>
<p class="Pp">If you are writing a package that
    <span class="Li">&quot;AUTOLOAD&quot;</span>s, consider forcing an
    <span class="Li">&quot;AUTOLOAD&quot;</span> for any constants explicitly
    imported by other packages or which are usually used when your package is
    <span class="Li">&quot;use&quot;</span>d.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="Good_Practices"><a class="permalink" href="#Good_Practices">Good
  Practices</a></h1>
<section class="Ss">
<h2 class="Ss" id="Declaring_@EXPORT_OK_and_Friends"><a class="permalink" href="#Declaring_@EXPORT_OK_and_Friends">Declaring
  @EXPORT_OK and Friends</a></h2>
When using <span class="Li">&quot;Exporter&quot;</span> with the standard
  <span class="Li">&quot;strict&quot;</span> and
  <span class="Li">&quot;warnings&quot;</span> pragmas, the
  <span class="Li">&quot;our&quot;</span> keyword is needed to declare the
  package variables <span class="Li">@EXPORT_OK</span>,
  <span class="Li">@EXPORT</span>, <span class="Li">@ISA</span>, etc.
<p class="Pp"><span class="Li"></span></p>
<pre>
  our @ISA = qw(Exporter);
  our @EXPORT_OK = qw(munge frobnicate);
</pre>
<p class="Pp">If backward compatibility for Perls under 5.6 is important, one
    must write instead a <span class="Li">&quot;use vars&quot;</span>
  statement.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  use vars qw(@ISA @EXPORT_OK);
  @ISA = qw(Exporter);
  @EXPORT_OK = qw(munge frobnicate);
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Playing_Safe"><a class="permalink" href="#Playing_Safe">Playing
  Safe</a></h2>
There are some caveats with the use of runtime statements like
  <span class="Li">&quot;require Exporter&quot;</span> and the assignment to
  package variables, which can very subtle for the unaware programmer. This may
  happen for instance with mutually recursive modules, which are affected by the
  time the relevant constructions are executed.
<p class="Pp">The ideal (but a bit ugly) way to never have to think about that
    is to use <span class="Li">&quot;BEGIN&quot;</span> blocks. So the first
    part of the &quot;SYNOPSIS&quot; code could be rewritten as:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  package YourModule;

  use strict;
  use warnings;

  our (@ISA, @EXPORT_OK);
  BEGIN {
     require Exporter;
     @ISA = qw(Exporter);
     @EXPORT_OK = qw(munge frobnicate);  # symbols to export on request
  }
</pre>
<p class="Pp">The <span class="Li">&quot;BEGIN&quot;</span> will assure that the
    loading of <i>Exporter.pm</i> and the assignments to
    <span class="Li">@ISA</span> and <span class="Li">@EXPORT_OK</span> happen
    immediately, leaving no room for something to get awry or just plain
  wrong.</p>
<p class="Pp">With respect to loading
    <span class="Li">&quot;Exporter&quot;</span> and inheriting, there are
    alternatives with the use of modules like
    <span class="Li">&quot;base&quot;</span> and
    <span class="Li">&quot;parent&quot;</span>.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  use base qw( Exporter );
  # or
  use parent qw( Exporter );
</pre>
<p class="Pp">Any of these statements are nice replacements for
    <span class="Li">&quot;BEGIN { require Exporter; @ISA = qw(Exporter);
    }&quot;</span> with the same compile-time effect. The basic difference is
    that <span class="Li">&quot;base&quot;</span> code interacts with declared
    <span class="Li">&quot;fields&quot;</span> while
    <span class="Li">&quot;parent&quot;</span> is a streamlined version of the
    older <span class="Li">&quot;base&quot;</span> code to just establish the
    IS-A relationship.</p>
<p class="Pp">For more details, see the documentation and code of base and
    parent.</p>
<p class="Pp">Another thorough remedy to that runtime vs. compile-time trap is
    to use Exporter::Easy, which is a wrapper of Exporter that allows all
    boilerplate code at a single gulp in the use statement.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
   use Exporter::Easy (
       OK =&gt; [ qw(munge frobnicate) ],
   );
   # @ISA setup is automatic
   # all assignments happen at compile time
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="What_Not_to_Export"><a class="permalink" href="#What_Not_to_Export">What
  Not to Export</a></h2>
You have been warned already in &quot;Selecting What to Export&quot; to not
  export:
<ul class="Bl-bullet">
  <li>method names (because you don't need to and that's likely to not do what
      you want),</li>
  <li>anything by default (because you don't want to surprise your users...
      badly)</li>
  <li>anything you don't need to (because less is more)</li>
</ul>
<p class="Pp">There's one more item to add to this list. Do <b>not</b> export
    variable names. Just because <span class="Li">&quot;Exporter&quot;</span>
    lets you do that, it does not mean you should.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  @EXPORT_OK = qw( $svar @avar %hvar ); # DON'T!
</pre>
<p class="Pp">Exporting variables is not a good idea. They can change under the
    hood, provoking horrible effects at-a-distance, that are too hard to track
    and to fix. Trust me: they are not worth it.</p>
<p class="Pp">To provide the capability to set/get class-wide settings, it is
    best instead to provide accessors as subroutines or class methods
  instead.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<span class="Li">&quot;Exporter&quot;</span> is definitely not the only module
  with symbol exporter capabilities. At CPAN, you may find a bunch of them. Some
  are lighter. Some provide improved APIs and features. Peek the one that fits
  your needs. The following is a sample list of such modules.
<p class="Pp"><span class="Li"></span></p>
<pre>
    Exporter::Easy
    Exporter::Lite
    Exporter::Renaming
    Exporter::Tidy
    Sub::Exporter / Sub::Installer
    Perl6::Export / Perl6::Export::Attrs
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="LICENSE"><a class="permalink" href="#LICENSE">LICENSE</a></h1>
This library is free software. You can redistribute it and/or modify it under
  the same terms as Perl itself.
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2014-09-30</td>
    <td class="foot-os">perl v5.18.4</td>
  </tr>
</table>
</body>
</html>
