<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    .Nd, .Bf, .Op { display: inline; }
    .Pa, .Ad { font-style: italic; }
    .Ms { font-weight: bold; }
    .Bl-diag > dt { font-weight: bold; }
    code.Nm, .Fl, .Cm, .Ic, code.In, .Fd, .Fn, .Cd { font-weight: bold;
      font-family: inherit; }
  </style>
  <title>DBD::Proxy(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">DBD::Proxy(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">DBD::Proxy(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">DBD::Proxy - A proxy driver for the DBI</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>  use DBI;
  $dbh = DBI-&gt;connect(&quot;dbi:Proxy:hostname=$host;port=$port;dsn=$db&quot;,
                      $user, $passwd);
  # See the DBI module documentation for full details
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">DBD::Proxy is a Perl module for connecting to a database via a
    remote DBI driver. See DBD::Gofer for an alternative with different
    trade-offs.</p>
<p class="Pp">This is of course not needed for DBI drivers which already support
    connecting to a remote database, but there are engines which don't offer
    network connectivity.</p>
<p class="Pp">Another application is offering database access through a
    firewall, as the driver offers query based restrictions. For example you can
    restrict queries to exactly those that are used in a given CGI
  application.</p>
<p class="Pp">Speaking of CGI, another application is (or rather, will be) to
    reduce the database connect/disconnect overhead from CGI scripts by using
    proxying the connect_cached method. The proxy server will hold the database
    connections open in a cache. The CGI script then trades the database
    connect/disconnect overhead for the DBD::Proxy connect/disconnect overhead
    which is typically much less.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="CONNECTING_TO_THE_DATABASE"><a class="permalink" href="#CONNECTING_TO_THE_DATABASE">CONNECTING
  TO THE DATABASE</a></h1>
<p class="Pp">Before connecting to a remote database, you must ensure, that a
    Proxy server is running on the remote machine. There's no default port, so
    you have to ask your system administrator for the port number. See
    DBI::ProxyServer for details.</p>
<p class="Pp">Say, your Proxy server is running on machine &quot;alpha&quot;,
    port 3334, and you'd like to connect to an ODBC database called
    &quot;mydb&quot; as user &quot;joe&quot; with password &quot;hello&quot;.
    When using DBD::ODBC directly, you'd do a</p>
<p class="Pp"></p>
<pre>  $dbh = DBI-&gt;connect(&quot;DBI:ODBC:mydb&quot;, &quot;joe&quot;, &quot;hello&quot;);
</pre>
<p class="Pp">With DBD::Proxy this becomes</p>
<p class="Pp"></p>
<pre>  $dsn = &quot;DBI:Proxy:hostname=alpha;port=3334;dsn=DBI:ODBC:mydb&quot;;
  $dbh = DBI-&gt;connect($dsn, &quot;joe&quot;, &quot;hello&quot;);
</pre>
<p class="Pp">You see, this is mainly the same. The DBD::Proxy module will
    create a connection to the Proxy server on &quot;alpha&quot; which in turn
    will connect to the ODBC database.</p>
<p class="Pp">Refer to the DBI documentation on the
    <span class="Li">&quot;connect&quot;</span> method for a way to
    automatically use DBD::Proxy without having to change your code.</p>
<p class="Pp">DBD::Proxy's DSN string has the format</p>
<p class="Pp"></p>
<pre>  $dsn = &quot;DBI:Proxy:key1=val1; ... ;keyN=valN;dsn=valDSN&quot;;
</pre>
<p class="Pp">In other words, it is a collection of key/value pairs. The
    following keys are recognized:</p>
<dl class="Bl-tag">
  <dt id="hostname"><a class="permalink" href="#hostname">hostname</a></dt>
  <dd></dd>
  <dt id="port"><a class="permalink" href="#port">port</a></dt>
  <dd>Hostname and port of the Proxy server; these keys must be present, no
      defaults. Example:
    <p class="Pp"></p>
    <pre>    hostname=alpha;port=3334
    </pre>
  </dd>
  <dt id="dsn"><a class="permalink" href="#dsn">dsn</a></dt>
  <dd>The value of this attribute will be used as a dsn name by the Proxy
      server. Thus it must have the format
      <span class="Li">&quot;DBI:driver:...&quot;</span>, in particular it will
      contain colons. The <i>dsn</i> value may contain semicolons, hence this
      key *must* be the last and it's value will be the complete remaining part
      of the dsn. Example:
    <p class="Pp"></p>
    <pre>    dsn=DBI:ODBC:mydb
    </pre>
  </dd>
  <dt id="cipher"><a class="permalink" href="#cipher">cipher</a></dt>
  <dd></dd>
  <dt id="key"><a class="permalink" href="#key">key</a></dt>
  <dd></dd>
  <dt id="usercipher"><a class="permalink" href="#usercipher">usercipher</a></dt>
  <dd></dd>
  <dt id="userkey"><a class="permalink" href="#userkey">userkey</a></dt>
  <dd>By using these fields you can enable encryption. If you set, for example,
    <p class="Pp"></p>
    <pre>    cipher=$class;key=$key
    </pre>
    <p class="Pp">(note the semicolon) then DBD::Proxy will create a new cipher
        object by executing</p>
    <p class="Pp"></p>
    <pre>    $cipherRef = $class-&gt;new(pack(&quot;H*&quot;, $key));
    </pre>
    <p class="Pp">and pass this object to the RPC::PlClient module when creating
        a client. See RPC::PlClient. Example:</p>
    <p class="Pp"></p>
    <pre>    cipher=IDEA;key=97cd2375efa329aceef2098babdc9721
    </pre>
    <p class="Pp">The usercipher/userkey attributes allow you to use two phase
        encryption: The cipher/key encryption will be used in the login and
        authorisation phase. Once the client is authorised, he will change to
        usercipher/userkey encryption. Thus the cipher/key pair is a <b>host</b>
        based secret, typically less secure than the usercipher/userkey secret
        and readable by anyone. The usercipher/userkey secret is <b>your</b>
        private secret.</p>
    <p class="Pp">Of course encryption requires an appropriately configured
        server. See &quot;CONFIGURATION FILE&quot; in DBD::ProxyServer.</p>
  </dd>
  <dt id="debug"><a class="permalink" href="#debug">debug</a></dt>
  <dd>Turn on debugging mode</dd>
  <dt id="stderr"><a class="permalink" href="#stderr">stderr</a></dt>
  <dd>This attribute will set the corresponding attribute of the RPC::PlClient
      object, thus logging will not use <b>syslog()</b>, but redirected to
      stderr. This is the default under Windows.
    <p class="Pp"></p>
    <pre>    stderr=1
    </pre>
  </dd>
  <dt id="logfile"><a class="permalink" href="#logfile">logfile</a></dt>
  <dd>Similar to the stderr attribute, but output will be redirected to the
      given file.
    <p class="Pp"></p>
    <pre>    logfile=/dev/null
    </pre>
  </dd>
  <dt id="RowCacheSize"><a class="permalink" href="#RowCacheSize">RowCacheSize</a></dt>
  <dd>The DBD::Proxy driver supports this attribute (which is DBI standard, as
      of DBI 1.02). It's used to reduce network round-trips by fetching multiple
      rows in one go. The current default value is 20, but this may change.</dd>
  <dt id="proxy_no_finish"><a class="permalink" href="#proxy_no_finish">proxy_no_finish</a></dt>
  <dd>This attribute can be used to reduce network traffic: If the application
      is calling <span class="Li">$sth</span>-&gt;<b>finish()</b> then the proxy
      tells the server to finish the remote statement handle. Of course this
      slows down things quite a lot, but is perfectly good for reducing memory
      usage with persistent connections.
    <p class="Pp">However, if you set the <i>proxy_no_finish</i> attribute to a
        TRUE value, either in the database handle or in the statement handle,
        then <b>finish()</b> calls will be suppressed. This is what you want,
        for example, in small and fast CGI applications.</p>
  </dd>
  <dt id="proxy_quote"><a class="permalink" href="#proxy_quote">proxy_quote</a></dt>
  <dd>This attribute can be used to reduce network traffic: By default calls to
      <span class="Li">$dbh</span>-&gt;<b>quote()</b> are passed to the remote
      driver. Of course this slows down things quite a lot, but is the safest
      default behaviour.
    <p class="Pp">However, if you set the <i>proxy_quote</i> attribute to the
        value '<span class="Li">&quot;local&quot;</span>' either in the database
        handle or in the statement handle, and the call to quote has only one
        parameter, then the local default DBI quote method will be used (which
        will be faster but may be wrong).</p>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="KNOWN_ISSUES"><a class="permalink" href="#KNOWN_ISSUES">KNOWN
  ISSUES</a></h1>
<section class="Ss">
<h2 class="Ss" id="Unproxied_method_calls"><a class="permalink" href="#Unproxied_method_calls">Unproxied
  method calls</a></h2>
<p class="Pp">If a method isn't being proxied, try declaring a stub sub in the
    appropriate package (DBD::Proxy::db for a dbh method, and DBD::Proxy::st for
    an sth method). For example:</p>
<p class="Pp"></p>
<pre>    sub DBD::Proxy::db::selectall_arrayref;
</pre>
<p class="Pp">That will enable selectall_arrayref to be proxied.</p>
<p class="Pp">Currently many methods aren't explicitly proxied and so you get
    the DBI's default methods executed on the client.</p>
<p class="Pp">Some of those methods, like selectall_arrayref, may then call
    other methods that are proxied (selectall_arrayref calls fetchall_arrayref
    which calls fetch which is proxied). So things may appear to work but
    operate more slowly than the could.</p>
<p class="Pp">This may all change in a later version.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Complex_handle_attributes"><a class="permalink" href="#Complex_handle_attributes">Complex
  handle attributes</a></h2>
<p class="Pp">Sometimes handles are having complex attributes like hash refs or
    array refs and not simple strings or integers. For example, with DBD::CSV,
    you would like to write something like</p>
<p class="Pp"></p>
<pre>  $dbh-&gt;{&quot;csv_tables&quot;}-&gt;{&quot;passwd&quot;} =
        { &quot;sep_char&quot; =&gt; &quot;:&quot;, &quot;eol&quot; =&gt; &quot;\n&quot;;
</pre>
<p class="Pp">The above example would advice the CSV driver to assume the file
    &quot;passwd&quot; to be in the format of the /etc/passwd file: Colons as
    separators and a line feed without carriage return as line terminator.</p>
<p class="Pp">Surprisingly this example doesn't work with the proxy driver. To
    understand the reasons, you should consider the following: The Perl compiler
    is executing the above example in two steps:</p>
<dl class="Bl-tag">
  <dt>1.</dt>
  <dd>The first step is fetching the value of the key &quot;csv_tables&quot; in
      the handle <span class="Li">$dbh</span>. The value returned is complex, a
      hash ref.</dd>
  <dt>2.</dt>
  <dd>The second step is storing some value (the right hand side of the
      assignment) as the key &quot;passwd&quot; in the hash ref from step
    1.</dd>
</dl>
<p class="Pp">This becomes a little bit clearer, if we rewrite the above
  code:</p>
<p class="Pp"></p>
<pre>  $tables = $dbh-&gt;{&quot;csv_tables&quot;};
  $tables-&gt;{&quot;passwd&quot;} = { &quot;sep_char&quot; =&gt; &quot;:&quot;, &quot;eol&quot; =&gt; &quot;\n&quot;;
</pre>
<p class="Pp">While the examples work fine without the proxy, the fail due to a
    subtle difference in step 1: By DBI magic, the hash ref
    <span class="Li">$dbh</span>-&gt;{'csv_tables'} is returned from the server
    to the client. The client creates a local copy. This local copy is the
    result of step 1. In other words, step 2 modifies a local copy of the hash
    ref, but not the server's hash ref.</p>
<p class="Pp">The workaround is storing the modified local copy back to the
    server:</p>
<p class="Pp"></p>
<pre>  $tables = $dbh-&gt;{&quot;csv_tables&quot;};
  $tables-&gt;{&quot;passwd&quot;} = { &quot;sep_char&quot; =&gt; &quot;:&quot;, &quot;eol&quot; =&gt; &quot;\n&quot;;
  $dbh-&gt;{&quot;csv_tables&quot;} = $tables;
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="SECURITY_WARNING"><a class="permalink" href="#SECURITY_WARNING">SECURITY
  WARNING</a></h1>
<p class="Pp">RPC::PlClient used underneath is not secure due to serializing and
    deserializing data with Storable module. Use the proxy driver only in
    trusted environment.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR_AND_COPYRIGHT"><a class="permalink" href="#AUTHOR_AND_COPYRIGHT">AUTHOR
  AND COPYRIGHT</a></h1>
<p class="Pp">This module is Copyright (c) 1997, 1998</p>
<p class="Pp"></p>
<pre>    Jochen Wiedmann
    Am Eisteich 9
    72555 Metzingen
    Germany
    Email: joe@ispsoft.de
    Phone: +49 7123 14887
</pre>
<p class="Pp">The DBD::Proxy module is free software; you can redistribute it
    and/or modify it under the same terms as Perl itself. In particular
    permission is granted to Tim Bunce for distributing this as a part of the
    DBI.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp">DBI, RPC::PlClient, Storable</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2014-09-21</td>
    <td class="foot-os">perl v5.30.2</td>
  </tr>
</table>
</body>
</html>
