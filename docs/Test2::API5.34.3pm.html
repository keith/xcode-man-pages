<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    .Nd, .Bf, .Op { display: inline; }
    .Pa, .Ad { font-style: italic; }
    .Ms { font-weight: bold; }
    .Bl-diag > dt { font-weight: bold; }
    code.Nm, .Fl, .Cm, .Ic, code.In, .Fd, .Fn, .Cd { font-weight: bold;
      font-family: inherit; }
  </style>
  <title>Test2::API(3pm)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Test2::API(3pm)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">Test2::API(3pm)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Test2::API - Primary interface for writing Test2 based testing
    tools.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="***INTERNALS_NOTE***"><a class="permalink" href="#***INTERNALS_NOTE***">***INTERNALS
  NOTE***</a></h1>
<p class="Pp"><b>The internals of this package are subject to change at any
    time!</b> The public methods provided will not change in
    backwards-incompatible ways (once there is a stable release), but the
    underlying implementation details might. <b>Do not break encapsulation
    here!</b></p>
<p class="Pp">Currently the implementation is to create a single instance of the
    Test2::API::Instance Object. All class methods defer to the single instance.
    There is no public access to the singleton, and that is intentional. The
    class methods provided by this package provide the only functionality
    publicly exposed.</p>
<p class="Pp">This is done primarily to avoid the problems Test::Builder had by
    exposing its singleton. We do not want anyone to replace this singleton,
    rebless it, or directly muck with its internals. If you need to do something
    and cannot because of the restrictions placed here, then please report it as
    an issue. If possible, we will create a way for you to implement your
    functionality without exposing things that should not be exposed.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">This package exports all the functions necessary to write and/or
    verify testing tools. Using these building blocks you can begin writing test
    tools very quickly. You are also provided with tools that help you to test
    the tools you write.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<section class="Ss">
<h2 class="Ss">WRITING A TOOL</h2>
<p class="Pp">The <span class="Li">&quot;context()&quot;</span> method is your
    primary interface into the Test2 framework.</p>
<p class="Pp"></p>
<pre>    package My::Ok;
    use Test2::API qw/context/;
    our @EXPORT = qw/my_ok/;
    use base 'Exporter';
    # Just like ok() from Test::More
    sub my_ok($;$) {
        my ($bool, $name) = @_;
        my $ctx = context(); # Get a context
        $ctx-&gt;ok($bool, $name);
        $ctx-&gt;release; # Release the context
        return $bool;
    }
</pre>
<p class="Pp">See Test2::API::Context for a list of methods available on the
    context object.</p>
</section>
<section class="Ss">
<h2 class="Ss">TESTING YOUR TOOLS</h2>
<p class="Pp">The <span class="Li">&quot;intercept { ... }&quot;</span> tool
    lets you temporarily intercept all events generated by the test system:</p>
<p class="Pp"></p>
<pre>    use Test2::API qw/intercept/;
    use My::Ok qw/my_ok/;
    my $events = intercept {
        # These events are not displayed
        my_ok(1, &quot;pass&quot;);
        my_ok(0, &quot;fail&quot;);
    };
</pre>
<p class="Pp">As of version 1.302178 this now returns an arrayref that is also
    an instance of Test2::API::InterceptResult. See the
    Test2::API::InterceptResult documentation for details on how to best use
  it.</p>
</section>
<section class="Ss">
<h2 class="Ss">OTHER API FUNCTIONS</h2>
<pre>    use Test2::API qw{
        test2_init_done
        test2_stack
        test2_set_is_end
        test2_get_is_end
        test2_ipc
        test2_formatter_set
        test2_formatter
        test2_is_testing_done
    };
    my $init  = test2_init_done();
    my $stack = test2_stack();
    my $ipc   = test2_ipc();
    test2_formatter_set($FORMATTER)
    my $formatter = test2_formatter();
    ... And others ...
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="MAIN_API_EXPORTS"><a class="permalink" href="#MAIN_API_EXPORTS">MAIN
  API EXPORTS</a></h1>
<p class="Pp">All exports are optional. You must specify subs to import.</p>
<p class="Pp"></p>
<pre>    use Test2::API qw/context intercept run_subtest/;
</pre>
<p class="Pp">This is the list of exports that are most commonly needed. If you
    are simply writing a tool, then this is probably all you need. If you need
    something and you cannot find it here, then you can also look at &quot;OTHER
    API EXPORTS&quot;.</p>
<p class="Pp">These exports lack the 'test2_' prefix because of how
    important/common they are. Exports in the &quot;OTHER API EXPORTS&quot;
    section have the 'test2_' prefix to ensure they stand out.</p>
<section class="Ss">
<h2 class="Ss" id="context(...)"><a class="permalink" href="#context(...)">context(...)</a></h2>
<p class="Pp">Usage:</p>
<dl class="Bl-tag">
  <dt>$ctx = <b>context()</b></dt>
  <dd></dd>
  <dt>$ctx = context(%params)</dt>
  <dd></dd>
</dl>
<p class="Pp">The <span class="Li">&quot;context()&quot;</span> function will
    always return the current context. If there is already a context active, it
    will be returned. If there is not an active context, one will be generated.
    When a context is generated it will default to using the file and line
    number where the currently running sub was called from.</p>
<p class="Pp">Please see &quot;CRITICAL DETAILS&quot; in Test2::API::Context for
    important rules about what you can and cannot do with a context once it is
    obtained.</p>
<p class="Pp"><b>Note</b> This function will throw an exception if you ignore
    the context object it returns.</p>
<p class="Pp"><b>Note</b> On perls 5.14+ a depth check is used to insure there
    are no context leaks. This cannot be safely done on older perls due to
    &lt;https://rt.perl.org/Public/Bug/Display.html?id=127774&gt; You can
    forcefully enable it either by setting
    <span class="Li">&quot;$ENV{T2_CHECK_DEPTH} = 1&quot;</span> or
    <span class="Li">&quot;$Test2::API::DO_DEPTH_CHECK = 1&quot;</span>
    <b>BEFORE</b> loading Test2::API.</p>
<p class="Pp"><i>OPTIONAL PARAMETERS</i></p>
<p class="Pp">All parameters to <span class="Li">&quot;context&quot;</span> are
    optional.</p>
<dl class="Bl-tag">
  <dt id="level"><a class="permalink" href="#level">level =&gt; $int</a></dt>
  <dd>If you must obtain a context in a sub deeper than your entry point you can
      use this to tell it how many EXTRA stack frames to look back. If this
      option is not provided the default of <span class="Li">0</span> is used.
    <p class="Pp"></p>
    <pre>    sub third_party_tool {
        my $sub = shift;
        ... # Does not obtain a context
        $sub-&gt;();
        ...
    }
    third_party_tool(sub {
        my $ctx = context(level =&gt; 1);
        ...
        $ctx-&gt;release;
    });
    </pre>
  </dd>
  <dt id="wrapped"><a class="permalink" href="#wrapped">wrapped =&gt;
    $int</a></dt>
  <dd>Use this if you need to write your own tool that wraps a call to
      <span class="Li">&quot;context()&quot;</span> with the intent that it
      should return a context object.
    <p class="Pp"></p>
    <pre>    sub my_context {
        my %params = ( wrapped =&gt; 0, @_ );
        $params{wrapped}++;
        my $ctx = context(%params);
        ...
        return $ctx;
    }
    sub my_tool {
        my $ctx = my_context();
        ...
        $ctx-&gt;release;
    }
    </pre>
    <p class="Pp">If you do not do this, then tools you call that also check for
        a context will notice that the context they grabbed was created at the
        same stack depth, which will trigger protective measures that warn you
        and destroy the existing context.</p>
  </dd>
  <dt id="stack"><a class="permalink" href="#stack">stack =&gt; $stack</a></dt>
  <dd>Normally <span class="Li">&quot;context()&quot;</span> looks at the global
      hub stack. If you are maintaining your own Test2::API::Stack instance you
      may pass it in to be used instead of the global one.</dd>
  <dt id="hub"><a class="permalink" href="#hub">hub =&gt; $hub</a></dt>
  <dd>Use this parameter if you want to obtain the context for a specific hub
      instead of whatever one happens to be at the top of the stack.</dd>
  <dt id="on_init"><a class="permalink" href="#on_init">on_init =&gt; sub { ...
    }</a></dt>
  <dd>This lets you provide a callback sub that will be called <b>ONLY</b> if
      your call to <span class="Li">&quot;context()&quot;</span> generated a new
      context. The callback <b>WILL NOT</b> be called if
      <span class="Li">&quot;context()&quot;</span> is returning an existing
      context. The only argument passed into the callback will be the context
      object itself.
    <p class="Pp"></p>
    <pre>    sub foo {
        my $ctx = context(on_init =&gt; sub { 'will run' });
        my $inner = sub {
            # This callback is not run since we are getting the existing
            # context from our parent sub.
            my $ctx = context(on_init =&gt; sub { 'will NOT run' });
            $ctx-&gt;release;
        }
        $inner-&gt;();
        $ctx-&gt;release;
    }
    </pre>
  </dd>
  <dt id="on_release"><a class="permalink" href="#on_release">on_release =&gt;
    sub { ... }</a></dt>
  <dd>This lets you provide a callback sub that will be called when the context
      instance is released. This callback will be added to the returned context
      even if an existing context is returned. If multiple calls to context add
      callbacks, then all will be called in reverse order when the context is
      finally released.
    <p class="Pp"></p>
    <pre>    sub foo {
        my $ctx = context(on_release =&gt; sub { 'will run second' });
        my $inner = sub {
            my $ctx = context(on_release =&gt; sub { 'will run first' });
            # Neither callback runs on this release
            $ctx-&gt;release;
        }
        $inner-&gt;();
        # Both callbacks run here.
        $ctx-&gt;release;
    }
    </pre>
  </dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="release($;$)"><a class="permalink" href="#release($;$)">release($;$)</a></h2>
<p class="Pp">Usage:</p>
<dl class="Bl-tag">
  <dt id="release"><a class="permalink" href="#release">release $ctx;</a></dt>
  <dd></dd>
  <dt id="release~2"><a class="permalink" href="#release~2">release $ctx,
    ...;</a></dt>
  <dd></dd>
</dl>
<p class="Pp">This is intended as a shortcut that lets you release your context
    and return a value in one statement. This function will get your context,
    and an optional return value. It will release your context, then return your
    value. Scalar context is always assumed.</p>
<p class="Pp"></p>
<pre>    sub tool {
        my $ctx = context();
        ...
        return release $ctx, 1;
    }
</pre>
<p class="Pp">This tool is most useful when you want to return the value you get
    from calling a function that needs to see the current context:</p>
<p class="Pp"></p>
<pre>    my $ctx = context();
    my $out = some_tool(...);
    $ctx-&gt;release;
    return $out;
</pre>
<p class="Pp">We can combine the last 3 lines of the above like so:</p>
<p class="Pp"></p>
<pre>    my $ctx = context();
    release $ctx, some_tool(...);
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="context_do(&amp;;@)"><a class="permalink" href="#context_do(&amp;;@)">context_do(&amp;;@)</a></h2>
<p class="Pp">Usage:</p>
<p class="Pp"></p>
<pre>    sub my_tool {
        context_do {
            my $ctx = shift;
            my (@args) = @_;
            $ctx-&gt;ok(1, &quot;pass&quot;);
            ...
            # No need to call $ctx-&gt;release, done for you on scope exit.
        } @_;
    }
</pre>
<p class="Pp">Using this inside your test tool takes care of a lot of
    boilerplate for you. It will ensure a context is acquired. It will capture
    and rethrow any exception. It will insure the context is released when you
    are done. It preserves the subroutine call context (array, scalar,
  void).</p>
<p class="Pp">This is the safest way to write a test tool. The only two
    downsides to this are a slight performance decrease, and some extra
    indentation in your source. If the indentation is a problem for you then you
    can take a peek at the next section.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="no_context(&amp;;$)"><a class="permalink" href="#no_context(&amp;;$)">no_context(&amp;;$)</a></h2>
<p class="Pp">Usage:</p>
<dl class="Bl-tag">
  <dt id="no_context"><a class="permalink" href="#no_context">no_context { ...
    };</a></dt>
  <dd></dd>
  <dt id="no_context~2"><a class="permalink" href="#no_context~2">no_context {
    ... } $hid;</a></dt>
  <dd>
    <pre>    sub my_tool(&amp;) {
        my $code = shift;
        my $ctx = context();
        ...
        no_context {
            # Things in here will not see our current context, they get a new
            # one.
            $code-&gt;();
        };
        ...
        $ctx-&gt;release;
    };
    </pre>
  </dd>
</dl>
<p class="Pp">This tool will hide a context for the provided block of code. This
    means any tools run inside the block will get a completely new context if
    they acquire one. The new context will be inherited by tools nested below
    the one that acquired it.</p>
<p class="Pp">This will normally hide the current context for the top hub. If
    you need to hide the context for a different hub you can pass in the
    optional <span class="Li">$hid</span> parameter.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="intercept(&amp;)"><a class="permalink" href="#intercept(&amp;)">intercept(&amp;)</a></h2>
<p class="Pp">Usage:</p>
<p class="Pp"></p>
<pre>    my $events = intercept {
        ok(1, &quot;pass&quot;);
        ok(0, &quot;fail&quot;);
        ...
    };
</pre>
<p class="Pp">This function takes a codeblock as its only argument, and it has a
    prototype. It will execute the codeblock, intercepting any generated events
    in the process. It will return an array reference with all the generated
    event objects. All events should be subclasses of Test2::Event.</p>
<p class="Pp">As of version 1.302178 the events array that is returned is blssed
    as an Test2::API::InterceptResult instance. Test2::API::InterceptResult
    Provides a helpful interface for filtering and/or inspecting the events list
    overall, or individual events within the list.</p>
<p class="Pp">This is intended to help you test your test code. This is not
    intended for people simply writing tests.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="run_subtest(...)"><a class="permalink" href="#run_subtest(...)">run_subtest(...)</a></h2>
<p class="Pp">Usage:</p>
<p class="Pp"></p>
<pre>    run_subtest($NAME, \&amp;CODE, $BUFFERED, @ARGS)
    # or
    run_subtest($NAME, \&amp;CODE, \%PARAMS, @ARGS)
</pre>
<p class="Pp">This will run the provided codeblock with the args in
    <span class="Li">@args</span>. This codeblock will be run as a subtest. A
    subtest is an isolated test state that is condensed into a single
    Test2::Event::Subtest event, which contains all events generated inside the
    subtest.</p>
<p class="Pp"><i>ARGUMENTS:</i></p>
<dl class="Bl-tag">
  <dt>$NAME</dt>
  <dd>The name of the subtest.</dd>
  <dt>\&amp;CODE</dt>
  <dd>The code to run inside the subtest.</dd>
  <dt>$BUFFERED or \%PARAMS</dt>
  <dd>If this is a simple scalar then it will be treated as a boolean for the
      'buffered' setting. If this is a hash reference then it will be used as a
      parameters hash. The param hash will be used for hub construction (with
      the specified keys removed).
    <p class="Pp">Keys that are removed and used by run_subtest:</p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>'buffered' =&gt; $bool</dt>
  <dd>Toggle buffered status.</dd>
  <dt>'inherit_trace' =&gt; $bool</dt>
  <dd>Normally the subtest hub is pushed and the sub is allowed to generate its
      own root context for the hub. When this setting is turned on a root
      context will be created for the hub that shares the same trace as the
      current context.
    <p class="Pp">Set this to true if your tool is producing subtests without
        user-specified subs.</p>
  </dd>
  <dt>'no_fork' =&gt; $bool</dt>
  <dd>Defaults to off. Normally forking inside a subtest will actually fork the
      subtest, resulting in 2 final subtest events. This parameter will turn off
      that behavior, only the original process/thread will return a final
      subtest event.</dd>
</dl>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>@ARGS</dt>
  <dd>Any extra arguments you want passed into the subtest code.</dd>
</dl>
<p class="Pp"><i>BUFFERED VS UNBUFFERED (OR STREAMED)</i></p>
<p class="Pp">Normally all events inside and outside a subtest are sent to the
    formatter immediately by the hub. Sometimes it is desirable to hold off
    sending events within a subtest until the subtest is complete. This usually
    depends on the formatter being used.</p>
<dl class="Bl-tag">
  <dt id="Things"><a class="permalink" href="#Things">Things not effected by
    this flag</a></dt>
  <dd>In both cases events are generated and stored in an array. This array is
      eventually used to populate the
      <span class="Li">&quot;subevents&quot;</span> attribute on the
      Test2::Event::Subtest event that is generated at the end of the subtest.
      This flag has no effect on this part, it always happens.
    <p class="Pp">At the end of the subtest, the final Test2::Event::Subtest
        event is sent to the formatter.</p>
  </dd>
  <dt id="Things~2"><a class="permalink" href="#Things~2">Things that are
    effected by this flag</a></dt>
  <dd>The <span class="Li">&quot;buffered&quot;</span> attribute of the
      Test2::Event::Subtest event will be set to the value of this flag. This
      means any formatter, listener, etc which looks at the event will know if
      it was buffered.</dd>
  <dt id="Things~3"><a class="permalink" href="#Things~3">Things that are
    formatter dependant</a></dt>
  <dd>Events within a buffered subtest may or may not be sent to the formatter
      as they happen. If a formatter fails to specify then the default is to
      <b>NOT SEND</b> the events as they are generated, instead the formatter
      can pull them from the <span class="Li">&quot;subevents&quot;</span>
      attribute.
    <p class="Pp">A formatter can specify by implementing the
        <span class="Li">&quot;hide_buffered()&quot;</span> method. If this
        method returns true then events generated inside a buffered subtest will
        not be sent independently of the final subtest event.</p>
  </dd>
</dl>
<p class="Pp">An example of how this is used is the Test2::Formatter::TAP
    formatter. For unbuffered subtests the events are rendered as they are
    generated. At the end of the subtest, the final subtest event is rendered,
    but the <span class="Li">&quot;subevents&quot;</span> attribute is ignored.
    For buffered subtests the opposite occurs, the events are NOT rendered as
    they are generated, instead the
    <span class="Li">&quot;subevents&quot;</span> attribute is used to render
    them all at once. This is useful when running subtests tests in parallel,
    since without it the output from subtests would be interleaved together.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="OTHER_API_EXPORTS"><a class="permalink" href="#OTHER_API_EXPORTS">OTHER
  API EXPORTS</a></h1>
<p class="Pp">Exports in this section are not commonly needed. These all have
    the 'test2_' prefix to help ensure they stand out. You should look at the
    &quot;MAIN API EXPORTS&quot; section before looking here. This section is
    one where &quot;Great power comes with great responsibility&quot;. It is
    possible to break things badly if you are not careful with these.</p>
<p class="Pp">All exports are optional. You need to list which ones you want at
    import time:</p>
<p class="Pp"></p>
<pre>    use Test2::API qw/test2_init_done .../;
</pre>
<section class="Ss">
<h2 class="Ss">STATUS AND INITIALIZATION STATE</h2>
<p class="Pp">These provide access to internal state and object instances.</p>
<dl class="Bl-tag">
  <dt>$bool = <b>test2_init_done()</b></dt>
  <dd>This will return true if the stack and IPC instances have already been
      initialized. It will return false if they have not. Init happens as late
      as possible. It happens as soon as a tool requests the IPC instance, the
      formatter, or the stack.</dd>
  <dt>$bool = <b>test2_load_done()</b></dt>
  <dd>This will simply return the boolean value of the loaded flag. If Test2 has
      finished loading this will be true, otherwise false. Loading is considered
      complete the first time a tool requests a context.</dd>
  <dt id="test2_set_is_end()"><a class="permalink" href="#test2_set_is_end()"><b>test2_set_is_end()</b></a></dt>
  <dd></dd>
  <dt id="test2_set_is_end($bool)"><a class="permalink" href="#test2_set_is_end($bool)">test2_set_is_end($bool)</a></dt>
  <dd>This is used to toggle Test2's belief that the END phase has already
      started. With no arguments this will set it to true. With arguments it
      will set it to the first argument's value.
    <p class="Pp">This is used to prevent the use of
        <span class="Li">&quot;caller()&quot;</span> in END blocks which can
        cause segfaults. This is only necessary in some persistent environments
        that may have multiple END phases.</p>
  </dd>
  <dt>$bool = <b>test2_get_is_end()</b></dt>
  <dd>Check if Test2 believes it is the END phase.</dd>
  <dt>$stack = <b>test2_stack()</b></dt>
  <dd>This will return the global Test2::API::Stack instance. If this has not
      yet been initialized it will be initialized now.</dd>
  <dt>$bool = <b>test2_is_testing_done()</b></dt>
  <dd>This will return true if testing is complete and no other events should be
      sent. This is useful in things like warning handlers where you might want
      to turn warnings into events, but need them to start acting like normal
      warnings when testing is done.
    <p class="Pp"></p>
    <pre>    $SIG{__WARN__} = sub {
        my ($warning) = @_;
        if (test2_is_testing_done()) {
            warn @_;
        }
        else {
            my $ctx = context();
            ...
            $ctx-&gt;release
        }
    }
    </pre>
  </dd>
  <dt id="test2_ipc_disable"><a class="permalink" href="#test2_ipc_disable">test2_ipc_disable</a></dt>
  <dd>Disable IPC.</dd>
  <dt>$bool = test2_ipc_diabled</dt>
  <dd>Check if IPC is disabled.</dd>
  <dt id="test2_ipc_wait_enable()"><a class="permalink" href="#test2_ipc_wait_enable()"><b>test2_ipc_wait_enable()</b></a></dt>
  <dd></dd>
  <dt id="test2_ipc_wait_disable()"><a class="permalink" href="#test2_ipc_wait_disable()"><b>test2_ipc_wait_disable()</b></a></dt>
  <dd></dd>
  <dt>$bool = <b>test2_ipc_wait_enabled()</b></dt>
  <dd>These can be used to turn IPC waiting on and off, or check the current
      value of the flag.
    <p class="Pp">Waiting is turned on by default. Waiting will cause the parent
        process/thread to wait until all child processes and threads are
        finished before exiting. You will almost never want to turn this
      off.</p>
  </dd>
  <dt>$bool = <b>test2_no_wait()</b></dt>
  <dd></dd>
  <dt id="test2_no_wait($bool)"><a class="permalink" href="#test2_no_wait($bool)">test2_no_wait($bool)</a></dt>
  <dd><b>DISCOURAGED</b>: This is a confusing interface, it is better to use
      <span class="Li">&quot;test2_ipc_wait_enable()&quot;</span>,
      <span class="Li">&quot;test2_ipc_wait_disable()&quot;</span> and
      <span class="Li">&quot;test2_ipc_wait_enabled()&quot;</span>.
    <p class="Pp">This can be used to get/set the no_wait status. Waiting is
        turned on by default. Waiting will cause the parent process/thread to
        wait until all child processes and threads are finished before exiting.
        You will almost never want to turn this off.</p>
  </dd>
  <dt>$fh = <b>test2_stdout()</b></dt>
  <dd></dd>
  <dt>$fh = <b>test2_stderr()</b></dt>
  <dd>These functions return the filehandles that test output should be written
      to. They are primarily useful when writing a custom formatter and code
      that turns events into actual output (TAP, etc.). They will return a dupe
      of the original filehandles that formatted output can be sent to
      regardless of whatever state the currently running test may have left
      STDOUT and STDERR in.</dd>
  <dt id="test2_reset_io()"><a class="permalink" href="#test2_reset_io()"><b>test2_reset_io()</b></a></dt>
  <dd>Re-dupe the internal filehandles returned by
      <span class="Li">&quot;test2_stdout()&quot;</span> and
      <span class="Li">&quot;test2_stderr()&quot;</span> from the current STDOUT
      and STDERR. You shouldn't need to do this except in very peculiar
      situations (for example, you're testing a new formatter and you need
      control over where the formatter is sending its output.)</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss">BEHAVIOR HOOKS</h2>
<p class="Pp">These are hooks that allow you to add custom behavior to actions
    taken by Test2 and tools built on top of it.</p>
<dl class="Bl-tag">
  <dt id="test2_add_callback_exit(sub"><a class="permalink" href="#test2_add_callback_exit(sub">test2_add_callback_exit(sub
    { ... })</a></dt>
  <dd>This can be used to add a callback that is called after all testing is
      done. This is too late to add additional results, the main use of this
      callback is to set the exit code.
    <p class="Pp"></p>
    <pre>    test2_add_callback_exit(
        sub {
            my ($context, $exit, \$new_exit) = @_;
            ...
        }
    );
    </pre>
    <p class="Pp">The <span class="Li">$context</span> passed in will be an
        instance of Test2::API::Context. The <span class="Li">$exit</span>
        argument will be the original exit code before anything modified it.
        <span class="Li">$$new_exit</span> is a reference to the new exit code.
        You may modify this to change the exit code. Please note that
        <span class="Li">$$new_exit</span> may already be different from
        <span class="Li">$exit</span></p>
  </dd>
  <dt id="test2_add_callback_post_load(sub"><a class="permalink" href="#test2_add_callback_post_load(sub">test2_add_callback_post_load(sub
    { ... })</a></dt>
  <dd>Add a callback that will be called when Test2 is finished loading. This
      means the callback will be run once, the first time a context is obtained.
      If Test2 has already finished loading then the callback will be run
      immediately.</dd>
  <dt id="test2_add_callback_testing_done(sub"><a class="permalink" href="#test2_add_callback_testing_done(sub">test2_add_callback_testing_done(sub
    { ... })</a></dt>
  <dd>This adds your coderef as a follow-up to the root hub after Test2 is
      finished loading.
    <p class="Pp">This is essentially a helper to do the following:</p>
    <p class="Pp"></p>
    <pre>    test2_add_callback_post_load(sub {
        my $stack = test2_stack();
        $stack-&gt;top; # Insure we have a hub
        my ($hub) = Test2::API::test2_stack-&gt;all;
        $hub-&gt;set_active(1);
        $hub-&gt;follow_up(sub { ... }); # &lt;-- Your coderef here
    });
    </pre>
  </dd>
  <dt id="test2_add_callback_context_acquire(sub"><a class="permalink" href="#test2_add_callback_context_acquire(sub">test2_add_callback_context_acquire(sub
    { ... })</a></dt>
  <dd>Add a callback that will be called every time someone tries to acquire a
      context. This will be called on EVERY call to
      <span class="Li">&quot;context()&quot;</span>. It gets a single argument,
      a reference to the hash of parameters being used the construct the
      context. This is your chance to change the parameters by directly altering
      the hash.
    <p class="Pp"></p>
    <pre>    test2_add_callback_context_acquire(sub {
        my $params = shift;
        $params-&gt;{level}++;
    });
    </pre>
    <p class="Pp">This is a very scary API function. Please do not use this
        unless you need to. This is here for Test::Builder and backwards
        compatibility. This has you directly manipulate the hash instead of
        returning a new one for performance reasons.</p>
  </dd>
  <dt id="test2_add_callback_context_init(sub"><a class="permalink" href="#test2_add_callback_context_init(sub">test2_add_callback_context_init(sub
    { ... })</a></dt>
  <dd>Add a callback that will be called every time a new context is created.
      The callback will receive the newly created context as its only
    argument.</dd>
  <dt id="test2_add_callback_context_release(sub"><a class="permalink" href="#test2_add_callback_context_release(sub">test2_add_callback_context_release(sub
    { ... })</a></dt>
  <dd>Add a callback that will be called every time a context is released. The
      callback will receive the released context as its only argument.</dd>
  <dt id="test2_add_callback_pre_subtest(sub"><a class="permalink" href="#test2_add_callback_pre_subtest(sub">test2_add_callback_pre_subtest(sub
    { ... })</a></dt>
  <dd>Add a callback that will be called every time a subtest is going to be
      run. The callback will receive the subtest name, coderef, and any
      arguments.</dd>
  <dt>@list = <b>test2_list_context_acquire_callbacks()</b></dt>
  <dd>Return all the context acquire callback references.</dd>
  <dt>@list = <b>test2_list_context_init_callbacks()</b></dt>
  <dd>Returns all the context init callback references.</dd>
  <dt>@list = <b>test2_list_context_release_callbacks()</b></dt>
  <dd>Returns all the context release callback references.</dd>
  <dt>@list = <b>test2_list_exit_callbacks()</b></dt>
  <dd>Returns all the exit callback references.</dd>
  <dt>@list = <b>test2_list_post_load_callbacks()</b></dt>
  <dd>Returns all the post load callback references.</dd>
  <dt>@list = <b>test2_list_pre_subtest_callbacks()</b></dt>
  <dd>Returns all the pre-subtest callback references.</dd>
  <dt id="test2_add_uuid_via(sub"><a class="permalink" href="#test2_add_uuid_via(sub">test2_add_uuid_via(sub
    { ... })</a></dt>
  <dd></dd>
  <dt>$sub = <b>test2_add_uuid_via()</b></dt>
  <dd>This allows you to provide a UUID generator. If provided UUIDs will be
      attached to all events, hubs, and contexts. This is useful for storing,
      tracking, and linking these objects.
    <p class="Pp">The sub you provide should always return a unique identifier.
        Most things will expect a proper UUID string, however nothing in
        Test2::API enforces this.</p>
    <p class="Pp">The sub will receive exactly 1 argument, the type of thing
        being tagged 'context', 'hub', or 'event'. In the future additional
        things may be tagged, in which case new strings will be passed in. These
        are purely informative, you can (and usually should) ignore them.</p>
  </dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss">IPC AND CONCURRENCY</h2>
<p class="Pp">These let you access, or specify, the IPC system internals.</p>
<dl class="Bl-tag">
  <dt>$bool = <b>test2_has_ipc()</b></dt>
  <dd>Check if IPC is enabled.</dd>
  <dt>$ipc = <b>test2_ipc()</b></dt>
  <dd>This will return the global Test2::IPC::Driver instance. If this has not
      yet been initialized it will be initialized now.</dd>
  <dt id="test2_ipc_add_driver($DRIVER)"><a class="permalink" href="#test2_ipc_add_driver($DRIVER)">test2_ipc_add_driver($DRIVER)</a></dt>
  <dd>Add an IPC driver to the list. This will add the driver to the start of
      the list.</dd>
  <dt>@drivers = <b>test2_ipc_drivers()</b></dt>
  <dd>Get the list of IPC drivers.</dd>
  <dt>$bool = <b>test2_ipc_polling()</b></dt>
  <dd>Check if polling is enabled.</dd>
  <dt id="test2_ipc_enable_polling()"><a class="permalink" href="#test2_ipc_enable_polling()"><b>test2_ipc_enable_polling()</b></a></dt>
  <dd>Turn on polling. This will cull events from other processes and threads
      every time a context is created.</dd>
  <dt id="test2_ipc_disable_polling()"><a class="permalink" href="#test2_ipc_disable_polling()"><b>test2_ipc_disable_polling()</b></a></dt>
  <dd>Turn off IPC polling.</dd>
  <dt id="test2_ipc_enable_shm()"><a class="permalink" href="#test2_ipc_enable_shm()"><b>test2_ipc_enable_shm()</b></a></dt>
  <dd>Legacy, this is currently a no-op that returns 0;</dd>
  <dt id="test2_ipc_set_pending($uniq_val)"><a class="permalink" href="#test2_ipc_set_pending($uniq_val)">test2_ipc_set_pending($uniq_val)</a></dt>
  <dd>Tell other processes and events that an event is pending.
      <span class="Li">$uniq_val</span> should be a unique value no other
      thread/process will generate.
    <p class="Pp"><b>Note:</b> After calling this
        <span class="Li">&quot;test2_ipc_get_pending()&quot;</span> will return
        1. This is intentional, and not avoidable.</p>
  </dd>
  <dt>$pending = <b>test2_ipc_get_pending()</b></dt>
  <dd>This returns -1 if there is no way to check (assume yes)
    <p class="Pp">This returns 0 if there are (most likely) no pending
      events.</p>
    <p class="Pp">This returns 1 if there are (likely) pending events. Upon
        return it will reset, nothing else will be able to see that there were
        pending events.</p>
  </dd>
  <dt>$timeout = <b>test2_ipc_get_timeout()</b></dt>
  <dd></dd>
  <dt id="test2_ipc_set_timeout($timeout)"><a class="permalink" href="#test2_ipc_set_timeout($timeout)">test2_ipc_set_timeout($timeout)</a></dt>
  <dd>Get/Set the timeout value for the IPC system. This timeout is how long the
      IPC system will wait for child processes and threads to finish before
      aborting.
    <p class="Pp">The default value is <span class="Li">30</span> seconds.</p>
  </dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss">MANAGING FORMATTERS</h2>
<p class="Pp">These let you access, or specify, the formatters that can/should
    be used.</p>
<dl class="Bl-tag">
  <dt>$formatter = test2_formatter</dt>
  <dd>This will return the global formatter class. This is not an instance. By
      default the formatter is set to Test2::Formatter::TAP.
    <p class="Pp">You can override this default using the
        <span class="Li">&quot;T2_FORMATTER&quot;</span> environment
      variable.</p>
    <p class="Pp">Normally 'Test2::Formatter::' is prefixed to the value in the
        environment variable:</p>
    <p class="Pp"></p>
    <pre>    $ T2_FORMATTER='TAP' perl test.t     # Use the Test2::Formatter::TAP formatter
    $ T2_FORMATTER='Foo' perl test.t     # Use the Test2::Formatter::Foo formatter
    </pre>
    <p class="Pp">If you want to specify a full module name you use the '+'
        prefix:</p>
    <p class="Pp"></p>
    <pre>    $ T2_FORMATTER='+Foo::Bar' perl test.t     # Use the Foo::Bar formatter
    </pre>
  </dd>
  <dt id="test2_formatter_set($class_or_instance)"><a class="permalink" href="#test2_formatter_set($class_or_instance)">test2_formatter_set($class_or_instance)</a></dt>
  <dd>Set the global formatter class. This can only be set once. <b>Note:</b>
      This will override anything specified in the 'T2_FORMATTER' environment
      variable.</dd>
  <dt>@formatters = <b>test2_formatters()</b></dt>
  <dd>Get a list of all loaded formatters.</dd>
  <dt id="test2_formatter_add($class_or_instance)"><a class="permalink" href="#test2_formatter_add($class_or_instance)">test2_formatter_add($class_or_instance)</a></dt>
  <dd>Add a formatter to the list. Last formatter added is used at
      initialization. If this is called after initialization a warning will be
      issued.</dd>
</dl>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="OTHER_EXAMPLES"><a class="permalink" href="#OTHER_EXAMPLES">OTHER
  EXAMPLES</a></h1>
<p class="Pp">See the <span class="Li">&quot;/Examples/&quot;</span> directory
    included in this distribution.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp">Test2::API::Context - Detailed documentation of the context
    object.</p>
<p class="Pp">Test2::IPC - The IPC system used for threading/fork support.</p>
<p class="Pp">Test2::Formatter - Formatters such as TAP live here.</p>
<p class="Pp">Test2::Event - Events live in this namespace.</p>
<p class="Pp">Test2::Hub - All events eventually funnel through a hub. Custom
    hubs are how <span class="Li">&quot;intercept()&quot;</span> and
    <span class="Li">&quot;run_subtest()&quot;</span> are implemented.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="MAGIC"><a class="permalink" href="#MAGIC">MAGIC</a></h1>
<p class="Pp">This package has an END block. This END block is responsible for
    setting the exit code based on the test results. This end block also calls
    the callbacks that can be added to this package.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SOURCE"><a class="permalink" href="#SOURCE">SOURCE</a></h1>
<p class="Pp">The source code repository for Test2 can be found at
    <i>http://github.com/Test-More/test-more/</i>.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="MAINTAINERS"><a class="permalink" href="#MAINTAINERS">MAINTAINERS</a></h1>
<dl class="Bl-tag">
  <dt id="Chad"><a class="permalink" href="#Chad">Chad Granum
    &lt;exodist@cpan.org&gt;</a></dt>
  <dd></dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHORS"><a class="permalink" href="#AUTHORS">AUTHORS</a></h1>
<dl class="Bl-tag">
  <dt id="Chad~2"><a class="permalink" href="#Chad~2">Chad Granum
    &lt;exodist@cpan.org&gt;</a></dt>
  <dd></dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT"><a class="permalink" href="#COPYRIGHT">COPYRIGHT</a></h1>
<p class="Pp">Copyright 2020 Chad Granum &lt;exodist@cpan.org&gt;.</p>
<p class="Pp">This program is free software; you can redistribute it and/or
    modify it under the same terms as Perl itself.</p>
<p class="Pp">See <i>http://dev.perl.org/licenses/</i></p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2020-11-18</td>
    <td class="foot-os">perl v5.34.0</td>
  </tr>
</table>
</body>
</html>
