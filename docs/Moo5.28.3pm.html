<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.10 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>Moo(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Moo(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Moo(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
Moo - Minimalist Object Orientation (with Moose compatibility)
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<span class="Li"></span>
<pre>
  package Cat::Food;

  use Moo;
  use strictures 2;
  use namespace::clean;

  sub feed_lion {
    my $self = shift;
    my $amount = shift || 1;

    $self-&gt;pounds( $self-&gt;pounds - $amount );
  }

  has taste =&gt; (
    is =&gt; 'ro',
  );

  has brand =&gt; (
    is  =&gt; 'ro',
    isa =&gt; sub {
      die &quot;Only SWEET-TREATZ supported!&quot; unless $_[0] eq 'SWEET-TREATZ'
    },
  );

  has pounds =&gt; (
    is  =&gt; 'rw',
    isa =&gt; sub { die &quot;$_[0] is too much cat food!&quot; unless $_[0] &lt; 15 },
  );

  1;
</pre>
<p class="Pp">And elsewhere:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  my $full = Cat::Food-&gt;new(
      taste  =&gt; 'DELICIOUS.',
      brand  =&gt; 'SWEET-TREATZ',
      pounds =&gt; 10,
  );

  $full-&gt;feed_lion;

  say $full-&gt;pounds;
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<span class="Li">&quot;Moo&quot;</span> is an extremely light-weight Object
  Orientation system. It allows one to concisely define objects and roles with a
  convenient syntax that avoids the details of Perl's object system.
  <span class="Li">&quot;Moo&quot;</span> contains a subset of Moose and is
  optimised for rapid startup.
<p class="Pp"><span class="Li">&quot;Moo&quot;</span> avoids depending on any XS
    modules to allow for simple deployments. The name
    <span class="Li">&quot;Moo&quot;</span> is based on the idea that it
    provides almost -- but not quite -- two thirds of Moose. As such, the
    Moose::Manual can serve as an effective guide to
    <span class="Li">&quot;Moo&quot;</span> aside from the MOP and Types
    sections.</p>
<p class="Pp">Unlike Mouse this module does not aim at full compatibility with
    Moose's surface syntax, preferring instead to provide full interoperability
    via the metaclass inflation capabilities described in &quot;MOO AND
    MOOSE&quot;.</p>
<p class="Pp">For a full list of the minor differences between Moose and Moo's
    surface syntax, see &quot;INCOMPATIBILITIES WITH MOOSE&quot;.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="WHY_MOO_EXISTS"><a class="permalink" href="#WHY_MOO_EXISTS">WHY
  MOO EXISTS</a></h1>
If you want a full object system with a rich Metaprotocol, Moose is already
  wonderful.
<p class="Pp">But if you don't want to use Moose, you may not want &quot;less
    metaprotocol&quot; like Mouse offers, but you probably want &quot;no
    metaprotocol&quot;, which is what Moo provides.
    <span class="Li">&quot;Moo&quot;</span> is ideal for some situations where
    deployment or startup time precludes using Moose and Mouse:</p>
<dl class="Bl-tag">
  <dt>a command line or CGI script where fast startup is essential</dt>
  <dd></dd>
  <dt>code designed to be deployed as a single file via App::FatPacker</dt>
  <dd></dd>
  <dt>a CPAN module that may be used by others in the above situations</dt>
  <dd></dd>
</dl>
<p class="Pp"><span class="Li">&quot;Moo&quot;</span> maintains transparent
    compatibility with Moose so if you install and load Moose you can use Moo
    classes and roles in Moose code without modification.</p>
<p class="Pp">Moo -- Minimal Object Orientation -- aims to make it smooth to
    upgrade to Moose when you need more than the minimal features offered by
    Moo.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="MOO_AND_MOOSE"><a class="permalink" href="#MOO_AND_MOOSE">MOO
  AND MOOSE</a></h1>
If Moo detects Moose being loaded, it will automatically register metaclasses
  for your Moo and Moo::Role packages, so you should be able to use them in
  Moose code without modification.
<p class="Pp">Moo will also create Moose type constraints for Moo classes and
    roles, so that in Moose classes <span class="Li">&quot;isa =&gt;
    'MyMooClass'&quot;</span> and <span class="Li">&quot;isa =&gt;
    'MyMooRole'&quot;</span> work the same as for Moose classes and roles.</p>
<p class="Pp">Extending a Moose class or consuming a Moose::Role will also
  work.</p>
<p class="Pp">Extending a Mouse class or consuming a Mouse::Role will also work.
    But note that we don't provide Mouse metaclasses or metaroles so the other
    way around doesn't work. This feature exists for Any::Moose users porting to
    Moo; enabling Mouse users to use Moo classes is not a priority for us.</p>
<p class="Pp">This means that there is no need for anything like Any::Moose for
    Moo code - Moo and Moose code should simply interoperate without problem. To
    handle Mouse code, you'll likely need an empty Moo role or class consuming
    or extending the Mouse stuff since it doesn't register true Moose
    metaclasses like Moo does.</p>
<p class="Pp">If you need to disable the metaclass creation, add:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  no Moo::sification;
</pre>
<p class="Pp">to your code before Moose is loaded, but bear in mind that this
    switch is global and turns the mechanism off entirely so don't put this in
    library code.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="MOO_AND_CLASS::XSACCESSOR"><a class="permalink" href="#MOO_AND_CLASS::XSACCESSOR">MOO
  AND CLASS::XSACCESSOR</a></h1>
If a new enough version of Class::XSAccessor is available, it will be used to
  generate simple accessors, readers, and writers for better performance. Simple
  accessors are those without lazy defaults, type checks/coercions, or triggers.
  Simple readers are those without lazy defaults. Readers and writers generated
  by Class::XSAccessor will behave slightly differently: they will reject
  attempts to call them with the incorrect number of parameters.
</section>
<section class="Sh">
<h1 class="Sh" id="MOO_VERSUS_ANY::MOOSE"><a class="permalink" href="#MOO_VERSUS_ANY::MOOSE">MOO
  VERSUS ANY::MOOSE</a></h1>
Any::Moose will load Mouse normally, and Moose in a program using Moose - which
  theoretically allows you to get the startup time of Mouse without
  disadvantaging Moose users.
<p class="Pp">Sadly, this doesn't entirely work, since the selection is load
    order dependent - Moo's metaclass inflation system explained above in
    &quot;MOO AND MOOSE&quot; is significantly more reliable.</p>
<p class="Pp">So if you want to write a CPAN module that loads fast or has only
    pure perl dependencies but is also fully usable by Moose users, you should
    be using Moo.</p>
<p class="Pp">For a full explanation, see the article
    &lt;https://shadow.cat/blog/matt-s-trout/moo-versus-any-moose&gt; which
    explains the differing strategies in more detail and provides a direct
    example of where Moo succeeds and Any::Moose fails.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="PUBLIC_METHODS"><a class="permalink" href="#PUBLIC_METHODS">PUBLIC
  METHODS</a></h1>
Moo provides several methods to any class using it.
<section class="Ss">
<h2 class="Ss" id="new"><a class="permalink" href="#new">new</a></h2>
<span class="Li"></span>
<pre>
  Foo::Bar-&gt;new( attr1 =&gt; 3 );
</pre>
<p class="Pp">or</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  Foo::Bar-&gt;new({ attr1 =&gt; 3 });
</pre>
<p class="Pp">The constructor for the class. By default it will accept
    attributes either as a hashref, or a list of key value pairs. This can be
    customized with the &quot;BUILDARGS&quot; method.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="does"><a class="permalink" href="#does">does</a></h2>
<span class="Li"></span>
<pre>
  if ($foo-&gt;does('Some::Role1')) {
    ...
  }
</pre>
<p class="Pp">Returns true if the object composes in the passed role.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_s-1DOES_s0"><a class="permalink" href="#_s-1DOES_s0">DOES</a></h2>
<span class="Li"></span>
<pre>
  if ($foo-&gt;DOES('Some::Role1') || $foo-&gt;DOES('Some::Class1')) {
    ...
  }
</pre>
<p class="Pp">Similar to &quot;does&quot;, but will also return true for both
    composed roles and superclasses.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="meta"><a class="permalink" href="#meta">meta</a></h2>
<span class="Li"></span>
<pre>
  my $meta = Foo::Bar-&gt;meta;
  my @methods = $meta-&gt;get_method_list;
</pre>
<p class="Pp">Returns an object that will behave as if it is a Moose metaclass
    object for the class. If you call anything other than
    <span class="Li">&quot;make_immutable&quot;</span> on it, the object will be
    transparently upgraded to a genuine Moose::Meta::Class instance, loading
    Moose in the process if required.
    <span class="Li">&quot;make_immutable&quot;</span> itself is a no-op, since
    we generate metaclasses that are already immutable, and users converting
    from Moose had an unfortunate tendency to accidentally load Moose by calling
    it.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="LIFECYCLE_METHODS"><a class="permalink" href="#LIFECYCLE_METHODS">LIFECYCLE
  METHODS</a></h1>
There are several methods that you can define in your class to control
  construction and destruction of objects. They should be used rather than
  trying to modify <span class="Li">&quot;new&quot;</span> or
  <span class="Li">&quot;DESTROY&quot;</span> yourself.
<section class="Ss">
<h2 class="Ss" id="_s-1BUILDARGS_s0"><a class="permalink" href="#_s-1BUILDARGS_s0">BUILDARGS</a></h2>
<span class="Li"></span>
<pre>
  around BUILDARGS =&gt; sub {
    my ( $orig, $class, @args ) = @_;

    return { attr1 =&gt; $args[0] }
      if @args == 1 &amp;&amp; !ref $args[0];

    return $class-&gt;$orig(@args);
  };

  Foo::Bar-&gt;new( 3 );
</pre>
<p class="Pp">This class method is used to transform the arguments to
    <span class="Li">&quot;new&quot;</span> into a hash reference of attribute
    values.</p>
<p class="Pp">The default implementation accepts a hash or hash reference of
    named parameters. If it receives a single argument that isn't a hash
    reference it will throw an error.</p>
<p class="Pp">You can override this method in your class to handle other types
    of options passed to the constructor.</p>
<p class="Pp">This method should always return a hash reference of named
    options.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_s-1FOREIGNBUILDARGS_s0"><a class="permalink" href="#_s-1FOREIGNBUILDARGS_s0">FOREIGNBUILDARGS</a></h2>
<span class="Li"></span>
<pre>
  sub FOREIGNBUILDARGS {
    my ( $class, $options ) = @_;
    return $options-&gt;{foo};
  }
</pre>
<p class="Pp">If you are inheriting from a non-Moo class, the arguments passed
    to the parent class constructor can be manipulated by defining a
    <span class="Li">&quot;FOREIGNBUILDARGS&quot;</span> method. It will receive
    the same arguments as &quot;BUILDARGS&quot;, and should return a list of
    arguments to pass to the parent class constructor.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_s-1BUILD_s0"><a class="permalink" href="#_s-1BUILD_s0">BUILD</a></h2>
<span class="Li"></span>
<pre>
  sub BUILD {
    my ($self, $args) = @_;
    die &quot;foo and bar cannot be used at the same time&quot;
      if exists $args-&gt;{foo} &amp;&amp; exists $args-&gt;{bar};
  }
</pre>
<p class="Pp">On object creation, any <span class="Li">&quot;BUILD&quot;</span>
    methods in the class's inheritance hierarchy will be called on the object
    and given the results of &quot;BUILDARGS&quot;. They each will be called in
    order from the parent classes down to the child, and thus should not
    themselves call the parent's method. Typically this is used for object
    validation or possibly logging.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_s-1DEMOLISH_s0"><a class="permalink" href="#_s-1DEMOLISH_s0">DEMOLISH</a></h2>
<span class="Li"></span>
<pre>
  sub DEMOLISH {
    my ($self, $in_global_destruction) = @_;
    ...
  }
</pre>
<p class="Pp">When an object is destroyed, any
    <span class="Li">&quot;DEMOLISH&quot;</span> methods in the inheritance
    hierarchy will be called on the object. They are given boolean to inform
    them if global destruction is in progress, and are called from the child
    class upwards to the parent. This is similar to &quot;BUILD&quot; methods
    but in the opposite order.</p>
<p class="Pp">Note that this is implemented by a
    <span class="Li">&quot;DESTROY&quot;</span> method, which is only created on
    on the first construction of an object of your class. This saves on overhead
    for classes that are never instantiated or those without
    <span class="Li">&quot;DEMOLISH&quot;</span> methods. If you try to define
    your own <span class="Li">&quot;DESTROY&quot;</span>, this will cause
    undefined results.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="IMPORTED_SUBROUTINES"><a class="permalink" href="#IMPORTED_SUBROUTINES">IMPORTED
  SUBROUTINES</a></h1>
<section class="Ss">
<h2 class="Ss" id="extends"><a class="permalink" href="#extends">extends</a></h2>
<span class="Li"></span>
<pre>
  extends 'Parent::Class';
</pre>
<p class="Pp">Declares a base class. Multiple superclasses can be passed for
    multiple inheritance but please consider using roles instead. The class will
    be loaded but no errors will be triggered if the class can't be found and
    there are already subs in the class.</p>
<p class="Pp">Calling extends more than once will REPLACE your superclasses, not
    add to them like 'use base' would.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="with"><a class="permalink" href="#with">with</a></h2>
<span class="Li"></span>
<pre>
  with 'Some::Role1';
</pre>
<p class="Pp">or</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  with 'Some::Role1', 'Some::Role2';
</pre>
<p class="Pp">Composes one or more Moo::Role (or Role::Tiny) roles into the
    current class. An error will be raised if these roles cannot be composed
    because they have conflicting method definitions. The roles will be loaded
    using the same mechanism as <span class="Li">&quot;extends&quot;</span>
    uses.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="has"><a class="permalink" href="#has">has</a></h2>
<span class="Li"></span>
<pre>
  has attr =&gt; (
    is =&gt; 'ro',
  );
</pre>
<p class="Pp">Declares an attribute for the class.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  package Foo;
  use Moo;
  has 'attr' =&gt; (
    is =&gt; 'ro'
  );

  package Bar;
  use Moo;
  extends 'Foo';
  has '+attr' =&gt; (
    default =&gt; sub { &quot;blah&quot; },
  );
</pre>
<p class="Pp">Using the <span class="Li">&quot;+&quot;</span> notation, it's
    possible to override an attribute.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  has [qw(attr1 attr2 attr3)] =&gt; (
    is =&gt; 'ro',
  );
</pre>
<p class="Pp">Using an arrayref with multiple attribute names, it's possible to
    declare multiple attributes with the same options.</p>
<p class="Pp">The options for <span class="Li">&quot;has&quot;</span> are as
    follows:</p>
<dl class="Bl-tag">
  <dt>&quot;is&quot;</dt>
  <dd><b>required</b>, may be <span class="Li">&quot;ro&quot;</span>,
      <span class="Li">&quot;lazy&quot;</span>,
      <span class="Li">&quot;rwp&quot;</span> or
      <span class="Li">&quot;rw&quot;</span>.
    <p class="Pp"><span class="Li">&quot;ro&quot;</span> stands for
        &quot;read-only&quot; and generates an accessor that dies if you attempt
        to write to it - i.e. a getter only - by defaulting
        <span class="Li">&quot;reader&quot;</span> to the name of the
      attribute.</p>
    <p class="Pp"><span class="Li">&quot;lazy&quot;</span> generates a reader
        like <span class="Li">&quot;ro&quot;</span>, but also sets
        <span class="Li">&quot;lazy&quot;</span> to 1 and
        <span class="Li">&quot;builder&quot;</span> to
        <span class="Li">&quot;_build_${attribute_name}&quot;</span> to allow
        on-demand generated attributes. This feature was my attempt to fix my
        incompetence when originally designing
        <span class="Li">&quot;lazy_build&quot;</span>, and is also implemented
        by MooseX::AttributeShortcuts. There is, however, nothing to stop you
        using <span class="Li">&quot;lazy&quot;</span> and
        <span class="Li">&quot;builder&quot;</span> yourself with
        <span class="Li">&quot;rwp&quot;</span> or
        <span class="Li">&quot;rw&quot;</span> - it's just that this isn't
        generally a good idea so we don't provide a shortcut for it.</p>
    <p class="Pp"><span class="Li">&quot;rwp&quot;</span> stands for
        &quot;read-write protected&quot; and generates a reader like
        <span class="Li">&quot;ro&quot;</span>, but also sets
        <span class="Li">&quot;writer&quot;</span> to
        <span class="Li">&quot;_set_${attribute_name}&quot;</span> for
        attributes that are designed to be written from inside of the class, but
        read-only from outside. This feature comes from
        MooseX::AttributeShortcuts.</p>
    <p class="Pp"><span class="Li">&quot;rw&quot;</span> stands for
        &quot;read-write&quot; and generates a normal getter/setter by
        defaulting the <span class="Li">&quot;accessor&quot;</span> to the name
        of the attribute specified.</p>
  </dd>
  <dt>&quot;isa&quot;</dt>
  <dd>Takes a coderef which is used to validate the attribute. Unlike Moose, Moo
      does not include a basic type system, so instead of doing
      <span class="Li">&quot;isa =&gt; 'Num'&quot;</span>, one should do
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  use Scalar::Util qw(looks_like_number);
  ...
  isa =&gt; sub {
    die &quot;$_[0] is not a number!&quot; unless looks_like_number $_[0]
  },
    </pre>
    <p class="Pp">Note that the return value for
        <span class="Li">&quot;isa&quot;</span> is discarded. Only if the sub
        dies does type validation fail.</p>
    <p class="Pp">Sub::Quote aware</p>
    <p class="Pp">Since Moo does <b>not</b> run the
        <span class="Li">&quot;isa&quot;</span> check before
        <span class="Li">&quot;coerce&quot;</span> if a coercion subroutine has
        been supplied, <span class="Li">&quot;isa&quot;</span> checks are not
        structural to your code and can, if desired, be omitted on non-debug
        builds (although if this results in an uncaught bug causing your program
        to break, the Moo authors guarantee nothing except that you get to keep
        both halves).</p>
    <p class="Pp">If you want Moose compatible or MooseX::Types style named
        types, look at Type::Tiny.</p>
    <p class="Pp">To cause your <span class="Li">&quot;isa&quot;</span> entries
        to be automatically mapped to named Moose::Meta::TypeConstraint objects
        (rather than the default behaviour of creating an anonymous type),
      set:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  $Moo::HandleMoose::TYPE_MAP{$isa_coderef} = sub {
    require MooseX::Types::Something;
    return MooseX::Types::Something::TypeName();
  };
    </pre>
    <p class="Pp">Note that this example is purely illustrative; anything that
        returns a Moose::Meta::TypeConstraint object or something similar enough
        to it to make Moose happy is fine.</p>
  </dd>
  <dt>&quot;coerce&quot;</dt>
  <dd>Takes a coderef which is meant to coerce the attribute. The basic idea is
      to do something like the following:
    <p class="Pp"><span class="Li"></span></p>
    <pre>
 coerce =&gt; sub {
   $_[0] % 2 ? $_[0] : $_[0] + 1
 },
    </pre>
    <p class="Pp">Note that Moo will always execute your coercion: this is to
        permit <span class="Li">&quot;isa&quot;</span> entries to be used purely
        for bug trapping, whereas coercions are always structural to your code.
        We do, however, apply any supplied
        <span class="Li">&quot;isa&quot;</span> check after the coercion has run
        to ensure that it returned a valid value.</p>
    <p class="Pp">Sub::Quote aware</p>
    <p class="Pp">If the <span class="Li">&quot;isa&quot;</span> option is a
        blessed object providing a <span class="Li">&quot;coerce&quot;</span> or
        <span class="Li">&quot;coercion&quot;</span> method, then the
        <span class="Li">&quot;coerce&quot;</span> option may be set to just
        <span class="Li">1</span>.</p>
  </dd>
  <dt>&quot;handles&quot;</dt>
  <dd>Takes a string
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  handles =&gt; 'RobotRole'
    </pre>
    <p class="Pp">Where <span class="Li">&quot;RobotRole&quot;</span> is a role
        that defines an interface which becomes the list of methods to
      handle.</p>
    <p class="Pp">Takes a list of methods</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  handles =&gt; [ qw( one two ) ]
    </pre>
    <p class="Pp">Takes a hashref</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  handles =&gt; {
    un =&gt; 'one',
  }
    </pre>
  </dd>
  <dt>&quot;trigger&quot;</dt>
  <dd>Takes a coderef which will get called any time the attribute is set. This
      includes the constructor, but not default or built values. The coderef
      will be invoked against the object with the new value as an argument.
    <p class="Pp">If you set this to just <span class="Li">1</span>, it
        generates a trigger which calls the
        <span class="Li">&quot;_trigger_${attr_name}&quot;</span> method on
        <span class="Li">$self</span>. This feature comes from
        MooseX::AttributeShortcuts.</p>
    <p class="Pp">Note that Moose also passes the old value, if any; this
        feature is not yet supported.</p>
    <p class="Pp">Sub::Quote aware</p>
  </dd>
  <dt>&quot;default&quot;</dt>
  <dd>Takes a coderef which will get called with <span class="Li">$self</span>
      as its only argument to populate an attribute if no value for that
      attribute was supplied to the constructor. Alternatively, if the attribute
      is lazy, <span class="Li">&quot;default&quot;</span> executes when the
      attribute is first retrieved if no value has yet been provided.
    <p class="Pp">If a simple scalar is provided, it will be inlined as a
        string. Any non-code reference (hash, array) will result in an error -
        for that case instead use a code reference that returns the desired
        value.</p>
    <p class="Pp">Note that if your default is fired during <b>new()</b> there
        is no guarantee that other attributes have been populated yet so you
        should not rely on their existence.</p>
    <p class="Pp">Sub::Quote aware</p>
  </dd>
  <dt>&quot;predicate&quot;</dt>
  <dd>Takes a method name which will return true if an attribute has a value.
    <p class="Pp">If you set this to just <span class="Li">1</span>, the
        predicate is automatically named
        <span class="Li">&quot;has_${attr_name}&quot;</span> if your attribute's
        name does not start with an underscore, or
        <span class="Li">&quot;_has_${attr_name_without_the_underscore}&quot;</span>
        if it does. This feature comes from MooseX::AttributeShortcuts.</p>
  </dd>
  <dt>&quot;builder&quot;</dt>
  <dd>Takes a method name which will be called to create the attribute -
      functions exactly like default except that instead of calling
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  $default-&gt;($self);
    </pre>
    <p class="Pp">Moo will call</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  $self-&gt;$builder;
    </pre>
    <p class="Pp">The following features come from
      MooseX::AttributeShortcuts:</p>
    <p class="Pp">If you set this to just <span class="Li">1</span>, the builder
        is automatically named
        <span class="Li">&quot;_build_${attr_name}&quot;</span>.</p>
    <p class="Pp">If you set this to a coderef or code-convertible object, that
        variable will be installed under
        <span class="Li">&quot;$class::_build_${attr_name}&quot;</span> and the
        builder set to the same name.</p>
  </dd>
  <dt>&quot;clearer&quot;</dt>
  <dd>Takes a method name which will clear the attribute.
    <p class="Pp">If you set this to just <span class="Li">1</span>, the clearer
        is automatically named
        <span class="Li">&quot;clear_${attr_name}&quot;</span> if your
        attribute's name does not start with an underscore, or
        <span class="Li">&quot;_clear_${attr_name_without_the_underscore}&quot;</span>
        if it does. This feature comes from MooseX::AttributeShortcuts.</p>
    <p class="Pp"><b>NOTE:</b> If the attribute is
        <span class="Li">&quot;lazy&quot;</span>, it will be regenerated from
        <span class="Li">&quot;default&quot;</span> or
        <span class="Li">&quot;builder&quot;</span> the next time it is
        accessed. If it is not lazy, it will be
        <span class="Li">&quot;undef&quot;</span>.</p>
  </dd>
  <dt>&quot;lazy&quot;</dt>
  <dd><b>Boolean</b>. Set this if you want values for the attribute to be
      grabbed lazily. This is usually a good idea if you have a
      &quot;builder&quot; which requires another attribute to be set.</dd>
  <dt>&quot;required&quot;</dt>
  <dd><b>Boolean</b>. Set this if the attribute must be passed on object
      instantiation.</dd>
  <dt>&quot;reader&quot;</dt>
  <dd>The name of the method that returns the value of the attribute. If you
      like Java style methods, you might set this to
      <span class="Li">&quot;get_foo&quot;</span></dd>
  <dt>&quot;writer&quot;</dt>
  <dd>The value of this attribute will be the name of the method to set the
      value of the attribute. If you like Java style methods, you might set this
      to <span class="Li">&quot;set_foo&quot;</span>.</dd>
  <dt>&quot;weak_ref&quot;</dt>
  <dd><b>Boolean</b>. Set this if you want the reference that the attribute
      contains to be weakened. Use this when circular references, which cause
      memory leaks, are possible.</dd>
  <dt>&quot;init_arg&quot;</dt>
  <dd>Takes the name of the key to look for at instantiation time of the object.
      A common use of this is to make an underscored attribute have a
      non-underscored initialization name.
      <span class="Li">&quot;undef&quot;</span> means that passing the value in
      on instantiation is ignored.</dd>
  <dt>&quot;moosify&quot;</dt>
  <dd>Takes either a coderef or array of coderefs which is meant to transform
      the given attributes specifications if necessary when upgrading to a Moose
      role or class. You shouldn't need this by default, but is provided as a
      means of possible extensibility.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="before"><a class="permalink" href="#before">before</a></h2>
<span class="Li"></span>
<pre>
  before foo =&gt; sub { ... };
</pre>
<p class="Pp">See &quot;before method(s) =&gt; sub { ... };&quot; in
    Class::Method::Modifiers for full documentation.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="around"><a class="permalink" href="#around">around</a></h2>
<span class="Li"></span>
<pre>
  around foo =&gt; sub { ... };
</pre>
<p class="Pp">See &quot;around method(s) =&gt; sub { ... };&quot; in
    Class::Method::Modifiers for full documentation.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="after"><a class="permalink" href="#after">after</a></h2>
<span class="Li"></span>
<pre>
  after foo =&gt; sub { ... };
</pre>
<p class="Pp">See &quot;after method(s) =&gt; sub { ... };&quot; in
    Class::Method::Modifiers for full documentation.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="SUB_QUOTE_AWARE"><a class="permalink" href="#SUB_QUOTE_AWARE">SUB
  QUOTE AWARE</a></h1>
&quot;quote_sub&quot; in Sub::Quote allows us to create coderefs that are
  &quot;inlineable,&quot; giving us a handy, XS-free speed boost. Any option
  that is Sub::Quote aware can take advantage of this.
<p class="Pp">To do this, you can write</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  use Sub::Quote;

  use Moo;
  use namespace::clean;

  has foo =&gt; (
    is =&gt; 'ro',
    isa =&gt; quote_sub(q{ die &quot;Not &lt;3&quot; unless $_[0] &lt; 3 })
  );
</pre>
<p class="Pp">which will be inlined as</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  do {
    local @_ = ($_[0]-&gt;{foo});
    die &quot;Not &lt;3&quot; unless $_[0] &lt; 3;
  }
</pre>
<p class="Pp">or to avoid localizing <span class="Li">@_</span>,</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  has foo =&gt; (
    is =&gt; 'ro',
    isa =&gt; quote_sub(q{ my ($val) = @_; die &quot;Not &lt;3&quot; unless $val &lt; 3 })
  );
</pre>
<p class="Pp">which will be inlined as</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  do {
    my ($val) = ($_[0]-&gt;{foo});
    die &quot;Not &lt;3&quot; unless $val &lt; 3;
  }
</pre>
<p class="Pp">See Sub::Quote for more information, including how to pass lexical
    captures that will also be compiled into the subroutine.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="CLEANING_UP_IMPORTS"><a class="permalink" href="#CLEANING_UP_IMPORTS">CLEANING
  UP IMPORTS</a></h1>
Moo will not clean up imported subroutines for you; you will have to do that
  manually. The recommended way to do this is to declare your imports first,
  then <span class="Li">&quot;use Moo&quot;</span>, then
  <span class="Li">&quot;use namespace::clean&quot;</span>. Anything imported
  before namespace::clean will be scrubbed. Anything imported or declared after
  will be still be available.
<p class="Pp"><span class="Li"></span></p>
<pre>
  package Record;

  use Digest::MD5 qw(md5_hex);

  use Moo;
  use namespace::clean;

  has name =&gt; (is =&gt; 'ro', required =&gt; 1);
  has id =&gt; (is =&gt; 'lazy');
  sub _build_id {
    my ($self) = @_;
    return md5_hex($self-&gt;name);
  }

  1;
</pre>
<p class="Pp">For example if you were to import these subroutines after
    namespace::clean like this</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  use namespace::clean;

  use Digest::MD5 qw(md5_hex);
  use Moo;
</pre>
<p class="Pp">then any <span class="Li">&quot;Record&quot;</span>
    <span class="Li">$r</span> would have methods such as
    <span class="Li">&quot;$r-&gt;md5_hex()&quot;</span>,
    <span class="Li">&quot;$r-&gt;has()&quot;</span> and
    <span class="Li">&quot;$r-&gt;around()&quot;</span> - almost certainly not
    what you intend!</p>
<p class="Pp">Moo::Roles behave slightly differently. Since their methods are
    composed into the consuming class, they can do a little more for you
    automatically. As long as you declare your imports before calling
    <span class="Li">&quot;use Moo::Role&quot;</span>, those imports and the
    ones Moo::Role itself provides will not be composed into consuming classes
    so there's usually no need to use namespace::clean.</p>
<p class="Pp"><b>On namespace::autoclean:</b> Older versions of
    namespace::autoclean would inflate Moo classes to full Moose classes, losing
    the benefits of Moo. If you want to use namespace::autoclean with a Moo
    class, make sure you are using version 0.16 or newer.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="INCOMPATIBILITIES_WITH_MOOSE"><a class="permalink" href="#INCOMPATIBILITIES_WITH_MOOSE">INCOMPATIBILITIES
  WITH MOOSE</a></h1>
<section class="Ss">
<h2 class="Ss" id="_s-1TYPES_s0"><a class="permalink" href="#_s-1TYPES_s0">TYPES</a></h2>
There is no built-in type system. <span class="Li">&quot;isa&quot;</span> is
  verified with a coderef; if you need complex types, Type::Tiny can provide
  types, type libraries, and will work seamlessly with both Moo and Moose.
  Type::Tiny can be considered the successor to MooseX::Types and provides a
  similar API, so that you can write
<p class="Pp"><span class="Li"></span></p>
<pre>
  use Types::Standard qw(Int);
  has days_to_live =&gt; (is =&gt; 'ro', isa =&gt; Int);
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="_s-1API_INCOMPATIBILITIES_s0"><a class="permalink" href="#_s-1API_INCOMPATIBILITIES_s0">API
  INCOMPATIBILITIES</a></h2>
<span class="Li">&quot;initializer&quot;</span> is not supported in core since
  the author considers it to be a bad idea and Moose best practices recommend
  avoiding it. Meanwhile <span class="Li">&quot;trigger&quot;</span> or
  <span class="Li">&quot;coerce&quot;</span> are more likely to be able to
  fulfill your needs.
<p class="Pp">No support for <span class="Li">&quot;super&quot;</span>,
    <span class="Li">&quot;override&quot;</span>,
    <span class="Li">&quot;inner&quot;</span>, or
    <span class="Li">&quot;augment&quot;</span> - the author considers augment
    to be a bad idea, and override can be translated:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  override foo =&gt; sub {
    ...
    super();
    ...
  };

  around foo =&gt; sub {
    my ($orig, $self) = (shift, shift);
    ...
    $self-&gt;$orig(@_);
    ...
  };
</pre>
<p class="Pp">The <span class="Li">&quot;dump&quot;</span> method is not
    provided by default. The author suggests loading Devel::Dwarn into
    <span class="Li">&quot;main::&quot;</span> (via <span class="Li">&quot;perl
    -MDevel::Dwarn ...&quot;</span> for example) and using
    <span class="Li">&quot;$obj-&gt;$::Dwarn()&quot;</span> instead.</p>
<p class="Pp">&quot;default&quot; only supports coderefs and plain scalars,
    because passing a hash or array reference as a default is almost always
    incorrect since the value is then shared between all objects using that
    default.</p>
<p class="Pp"><span class="Li">&quot;lazy_build&quot;</span> is not supported;
    you are instead encouraged to use the <span class="Li">&quot;is =&gt;
    'lazy'&quot;</span> option supported by Moo and
  MooseX::AttributeShortcuts.</p>
<p class="Pp"><span class="Li">&quot;auto_deref&quot;</span> is not supported
    since the author considers it a bad idea and it has been considered best
    practice to avoid it for some time.</p>
<p class="Pp"><span class="Li">&quot;documentation&quot;</span> will show up in
    a Moose metaclass created from your class but is otherwise ignored. Then
    again, Moose ignores it as well, so this is arguably not an
  incompatibility.</p>
<p class="Pp">Since <span class="Li">&quot;coerce&quot;</span> does not require
    <span class="Li">&quot;isa&quot;</span> to be defined but Moose does require
    it, the metaclass inflation for coerce alone is a trifle insane and if you
    attempt to subtype the result will almost certainly break.</p>
<p class="Pp">Handling of warnings: when you <span class="Li">&quot;use
    Moo&quot;</span> we enable strict and warnings, in a similar way to Moose.
    The authors recommend the use of
    <span class="Li">&quot;strictures&quot;</span>, which enables FATAL
    warnings, and several extra pragmas when used in development: indirect,
    multidimensional, and bareword::filehandles.</p>
<p class="Pp">Additionally, Moo supports a set of attribute option shortcuts
    intended to reduce common boilerplate. The set of shortcuts is the same as
    in the Moose module MooseX::AttributeShortcuts as of its version 0.009+. So
    if you:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  package MyClass;
  use Moo;
  use strictures 2;
</pre>
<p class="Pp">The nearest Moose invocation would be:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  package MyClass;

  use Moose;
  use warnings FATAL =&gt; &quot;all&quot;;
  use MooseX::AttributeShortcuts;
</pre>
<p class="Pp">or, if you're inheriting from a non-Moose class,</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  package MyClass;

  use Moose;
  use MooseX::NonMoose;
  use warnings FATAL =&gt; &quot;all&quot;;
  use MooseX::AttributeShortcuts;
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="_s-1META_OBJECT_s0"><a class="permalink" href="#_s-1META_OBJECT_s0">META
  OBJECT</a></h2>
There is no meta object. If you need this level of complexity you need Moose -
  Moo is small because it explicitly does not provide a metaprotocol. However,
  if you load Moose, then
<p class="Pp"><span class="Li"></span></p>
<pre>
  Class::MOP::class_of($moo_class_or_role)
</pre>
<p class="Pp">will return an appropriate metaclass pre-populated by Moo.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_s-1IMMUTABILITY_s0"><a class="permalink" href="#_s-1IMMUTABILITY_s0">IMMUTABILITY</a></h2>
Finally, Moose requires you to call
<p class="Pp"><span class="Li"></span></p>
<pre>
  __PACKAGE__-&gt;meta-&gt;make_immutable;
</pre>
<p class="Pp">at the end of your class to get an inlined (i.e. not horribly
    slow) constructor. Moo does it automatically the first time -&gt;new is
    called on your class. (<span class="Li">&quot;make_immutable&quot;</span> is
    a no-op in Moo to ease migration.)</p>
<p class="Pp">An extension MooX::late exists to ease translating Moose packages
    to Moo by providing a more Moose-like interface.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="COMPATIBILITY_WITH_OLDER_PERL_VERSIONS"><a class="permalink" href="#COMPATIBILITY_WITH_OLDER_PERL_VERSIONS">COMPATIBILITY
  WITH OLDER PERL VERSIONS</a></h1>
Moo is compatible with perl versions back to 5.6. When running on older
  versions, additional prerequisites will be required. If you are packaging a
  script with its dependencies, such as with App::FatPacker, you will need to be
  certain that the extra prerequisites are included.
<dl class="Bl-tag">
  <dt>MRO::Compat</dt>
  <dd>Required on perl versions prior to 5.10.0.</dd>
  <dt>Devel::GlobalDestruction</dt>
  <dd>Required on perl versions prior to 5.14.0.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="SUPPORT"><a class="permalink" href="#SUPPORT">SUPPORT</a></h1>
IRC: #moose on irc.perl.org
<p class="Pp">Bugtracker:
    &lt;https://rt.cpan.org/Public/Dist/Display.html?Name=Moo&gt;</p>
<p class="Pp">Git repository: &lt;git://github.com/moose/Moo.git&gt;</p>
<p class="Pp">Git browser: &lt;https://github.com/moose/Moo&gt;</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
mst - Matt S. Trout (cpan:MSTROUT) &lt;mst@shadowcat.co.uk&gt;
</section>
<section class="Sh">
<h1 class="Sh" id="CONTRIBUTORS"><a class="permalink" href="#CONTRIBUTORS">CONTRIBUTORS</a></h1>
dg - David Leadbeater (cpan:DGL) &lt;dgl@dgl.cx&gt;
<p class="Pp">frew - Arthur Axel &quot;fREW&quot; Schmidt (cpan:FREW)
    &lt;frioux@gmail.com&gt;</p>
<p class="Pp">hobbs - Andrew Rodland (cpan:ARODLAND)
  &lt;arodland@cpan.org&gt;</p>
<p class="Pp">jnap - John Napiorkowski (cpan:JJNAPIORK)
    &lt;jjn1056@yahoo.com&gt;</p>
<p class="Pp">ribasushi - Peter Rabbitson (cpan:RIBASUSHI)
    &lt;ribasushi@cpan.org&gt;</p>
<p class="Pp">chip - Chip Salzenberg (cpan:CHIPS) &lt;chip@pobox.com&gt;</p>
<p class="Pp">ajgb - Alex J. G. Burzy&#x0144;ski (cpan:AJGB)
    &lt;ajgb@cpan.org&gt;</p>
<p class="Pp">doy - Jesse Luehrs (cpan:DOY) &lt;doy at tozt dot net&gt;</p>
<p class="Pp">perigrin - Chris Prather (cpan:PERIGRIN)
  &lt;chris@prather.org&gt;</p>
<p class="Pp">Mithaldu - Christian Walde (cpan:MITHALDU)
    &lt;walde.christian@googlemail.com&gt;</p>
<p class="Pp">ilmari - Dagfinn Ilmari Manns&#x00E5;ker (cpan:ILMARI)
    &lt;ilmari@ilmari.org&gt;</p>
<p class="Pp">tobyink - Toby Inkster (cpan:TOBYINK) &lt;tobyink@cpan.org&gt;</p>
<p class="Pp">haarg - Graham Knop (cpan:HAARG) &lt;haarg@cpan.org&gt;</p>
<p class="Pp">mattp - Matt Phillips (cpan:MATTP) &lt;mattp@cpan.org&gt;</p>
<p class="Pp">bluefeet - Aran Deltac (cpan:BLUEFEET)
  &lt;bluefeet@gmail.com&gt;</p>
<p class="Pp">bubaflub - Bob Kuo (cpan:BUBAFLUB) &lt;bubaflub@cpan.org&gt;</p>
<p class="Pp">ether = Karen Etheridge (cpan:ETHER) &lt;ether@cpan.org&gt;</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT"><a class="permalink" href="#COPYRIGHT">COPYRIGHT</a></h1>
Copyright (c) 2010-2015 the Moo &quot;AUTHOR&quot; and &quot;CONTRIBUTORS&quot;
  as listed above.
</section>
<section class="Sh">
<h1 class="Sh" id="LICENSE"><a class="permalink" href="#LICENSE">LICENSE</a></h1>
This library is free software and may be distributed under the same terms as
  perl itself. See &lt;https://dev.perl.org/licenses/&gt;.
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2020-04-09</td>
    <td class="foot-os">perl v5.28.2</td>
  </tr>
</table>
</body>
</html>
