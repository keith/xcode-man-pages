<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>Moose::Manual::Construction(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Moose::Manual::Construction(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Moose::Manual::Construction(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
Moose::Manual::Construction - Object construction (and destruction) with Moose
</section>
<section class="Sh">
<h1 class="Sh" id="VERSION"><a class="permalink" href="#VERSION">VERSION</a></h1>
version 2.1202
</section>
<section class="Sh">
<h1 class="Sh" id="WHERE'S_THE_CONSTRUCTOR?"><a class="permalink" href="#WHERE'S_THE_CONSTRUCTOR?">WHERE'S
  THE CONSTRUCTOR?</a></h1>
<b>Do not define a </b><b>&quot;new()&quot;</b><b> method for your classes!</b>
<p class="Pp">When you <span class="Li">&quot;use Moose&quot;</span> in your
    class, your class becomes a subclass of Moose::Object. The Moose::Object
    provides a <span class="Li">&quot;new()&quot;</span> method for your class.
    If you follow our recommendations in Moose::Manual::BestPractices and make
    your class immutable, then you actually get a class-specific
    <span class="Li">&quot;new()&quot;</span> method &quot;inlined&quot; in your
    class.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="OBJECT_CONSTRUCTION_AND_ATTRIBUTES"><a class="permalink" href="#OBJECT_CONSTRUCTION_AND_ATTRIBUTES">OBJECT
  CONSTRUCTION AND ATTRIBUTES</a></h1>
The Moose-provided constructor accepts a hash or hash reference of named
  parameters matching your attributes (actually, matching their
  <span class="Li">&quot;init_arg&quot;</span>s). This is just another way in
  which Moose keeps you from worrying <i>how</i> classes are implemented. Simply
  define a class and you're ready to start creating objects!
</section>
<section class="Sh">
<h1 class="Sh" id="OBJECT_CONSTRUCTION_HOOKS"><a class="permalink" href="#OBJECT_CONSTRUCTION_HOOKS">OBJECT
  CONSTRUCTION HOOKS</a></h1>
Moose lets you hook into object construction. You can validate an object's
  state, do logging, customize construction from parameters which do not match
  your attributes, or maybe allow non-hash(ref) constructor arguments. You can
  do this by creating <span class="Li">&quot;BUILD&quot;</span> and/or
  <span class="Li">&quot;BUILDARGS&quot;</span> methods.
<p class="Pp">If these methods exist in your class, Moose will arrange for them
    to be called as part of the object construction process.</p>
<section class="Ss">
<h2 class="Ss" id="_s-1BUILDARGS_s0"><a class="permalink" href="#_s-1BUILDARGS_s0">BUILDARGS</a></h2>
The <span class="Li">&quot;BUILDARGS&quot;</span> method is called as a class
  method <i>before</i> an object is created. It will receive all of the
  arguments that were passed to <span class="Li">&quot;new()&quot;</span>
  <i>as-is</i>, and is expected to return a hash reference. This hash reference
  will be used to construct the object, so it should contain keys matching your
  attributes' names (well, <span class="Li">&quot;init_arg&quot;</span>s).
<p class="Pp">One common use for <span class="Li">&quot;BUILDARGS&quot;</span>
    is to accommodate a non-hash(ref) calling style. For example, we might want
    to allow our Person class to be called with a single argument of a social
    security number,
  <span class="Li">&quot;Person-&gt;new($ssn)&quot;</span>.</p>
<p class="Pp">Without a <span class="Li">&quot;BUILDARGS&quot;</span> method,
    Moose will complain, because it expects a hash or hash reference. We can use
    the <span class="Li">&quot;BUILDARGS&quot;</span> method to accommodate this
    calling style:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  around BUILDARGS =&gt; sub {
      my $orig  = shift;
      my $class = shift;

      if ( @_ == 1 &amp;&amp; !ref $_[0] ) {
          return $class-&gt;$orig( ssn =&gt; $_[0] );
      }
      else {
          return $class-&gt;$orig(@_);
      }
  };
</pre>
<p class="Pp">Note the call to
    <span class="Li">&quot;$class-&gt;$orig&quot;</span>. This will call the
    default <span class="Li">&quot;BUILDARGS&quot;</span> in Moose::Object. This
    method takes care of distinguishing between a hash reference and a plain
    hash for you.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_s-1BUILD_s0"><a class="permalink" href="#_s-1BUILD_s0">BUILD</a></h2>
The <span class="Li">&quot;BUILD&quot;</span> method is called <i>after</i> an
  object is created. There are several reasons to use a
  <span class="Li">&quot;BUILD&quot;</span> method. One of the most common is to
  check that the object state is valid. While we can validate individual
  attributes through the use of types, we can't validate the state of a whole
  object that way.
<p class="Pp"><span class="Li"></span></p>
<pre>
  sub BUILD {
      my $self = shift;

      if ( $self-&gt;country_of_residence eq 'USA' ) {
          die 'All US residents must have an SSN'
              unless $self-&gt;has_ssn;
      }
  }
</pre>
<p class="Pp">Another use of a <span class="Li">&quot;BUILD&quot;</span> method
    could be for logging or tracking object creation.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  sub BUILD {
      my $self = shift;

      debug( 'Made a new person - SSN = ', $self-&gt;ssn, );
  }
</pre>
<p class="Pp">The <span class="Li">&quot;BUILD&quot;</span> method is called
    with the hash reference of the parameters passed to the constructor (after
    munging by <span class="Li">&quot;BUILDARGS&quot;</span>). This gives you a
    chance to do something with parameters that do not represent object
    attributes.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  sub BUILD {
      my $self = shift;
      my $args = shift;

      $self-&gt;add_friend(
          My::User-&gt;new(
              user_id =&gt; $args-&gt;{user_id},
          )
      );
  }
</pre>
<p class="Pp"><i>BUILD and parent classes</i></p>
<p class="Pp">The interaction between multiple
    <span class="Li">&quot;BUILD&quot;</span> methods in an inheritance
    hierarchy is different from normal Perl methods. <b>You should never call
    </b> <b>&quot;$self-&gt;SUPER::BUILD&quot;</b><b></b>, nor should you ever
    apply a method modifier to <span class="Li">&quot;BUILD&quot;</span>.</p>
<p class="Pp">Moose arranges to have all of the
    <span class="Li">&quot;BUILD&quot;</span> methods in a hierarchy called when
    an object is constructed, <i>from parents to</i> <i>children</i>. This might
    be surprising at first, because it reverses the normal order of method
    inheritance.</p>
<p class="Pp">The theory behind this is that
    <span class="Li">&quot;BUILD&quot;</span> methods can only be used for
    increasing specialization of a class's constraints, so it makes sense to
    call the least specific <span class="Li">&quot;BUILD&quot;</span> method
    first. Also, this is how Perl 6 does it.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="OBJECT_DESTRUCTION"><a class="permalink" href="#OBJECT_DESTRUCTION">OBJECT
  DESTRUCTION</a></h1>
Moose provides a hook for object destruction with the
  <span class="Li">&quot;DEMOLISH&quot;</span> method. As with
  <span class="Li">&quot;BUILD&quot;</span>, you should never explicitly call
  <span class="Li">&quot;$self-&gt;SUPER::DEMOLISH&quot;</span>. Moose will
  arrange for all of the <span class="Li">&quot;DEMOLISH&quot;</span> methods in
  your hierarchy to be called, from most to least specific.
<p class="Pp">Each <span class="Li">&quot;DEMOLISH&quot;</span> method is called
    with a single argument.</p>
<p class="Pp">In most cases, Perl's built-in garbage collection is sufficient,
    and you won't need to provide a <span class="Li">&quot;DEMOLISH&quot;</span>
    method.</p>
<section class="Ss">
<h2 class="Ss" id="Error_Handling_During_Destruction"><a class="permalink" href="#Error_Handling_During_Destruction">Error
  Handling During Destruction</a></h2>
The interaction of object destruction and Perl's global
  <span class="Li">$@</span> and <span class="Li">$?</span> variables can be
  very confusing.
<p class="Pp">Moose always localizes <span class="Li">$?</span> when an object
    is being destroyed. This means that if you explicitly call
    <span class="Li">&quot;exit&quot;</span>, that exit code will be preserved
    even if an object's destructor makes a system call.</p>
<p class="Pp">Moose also preserves <span class="Li">$@</span> against any
    <span class="Li">&quot;eval&quot;</span> calls that may happen during object
    destruction. However, if an object's
    <span class="Li">&quot;DEMOLISH&quot;</span> method actually dies, Moose
    explicitly rethrows that error.</p>
<p class="Pp">If you do not like this behavior, you will have to provide your
    own <span class="Li">&quot;DESTROY&quot;</span> method and use that instead
    of the one provided by Moose::Object. You can do this to preserve
    <span class="Li">$@</span> <i>and</i> capture any errors from object
    destruction by creating an error stack.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHORS"><a class="permalink" href="#AUTHORS">AUTHORS</a></h1>
<ul class="Bl-bullet">
  <li>Stevan Little &lt;stevan.little@iinteractive.com&gt;</li>
  <li>Dave Rolsky &lt;autarch@urth.org&gt;</li>
  <li>Jesse Luehrs &lt;doy@tozt.net&gt;</li>
  <li>Shawn M Moore &lt;code@sartak.org&gt;</li>
  <li>XXXX XXX'XX (Yuval Kogman) &lt;nothingmuch@woobling.org&gt;</li>
  <li>Karen Etheridge &lt;ether@cpan.org&gt;</li>
  <li>Florian Ragwitz &lt;rafl@debian.org&gt;</li>
  <li>Hans Dieter Pearcey &lt;hdp@weftsoar.net&gt;</li>
  <li>Chris Prather &lt;chris@prather.org&gt;</li>
  <li>Matt S Trout &lt;mst@shadowcat.co.uk&gt;</li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT_AND_LICENSE"><a class="permalink" href="#COPYRIGHT_AND_LICENSE">COPYRIGHT
  AND LICENSE</a></h1>
This software is copyright (c) 2006 by Infinity Interactive, Inc..
<p class="Pp">This is free software; you can redistribute it and/or modify it
    under the same terms as the Perl 5 programming language system itself.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2014-01-19</td>
    <td class="foot-os">perl v5.18.4</td>
  </tr>
</table>
</body>
</html>
