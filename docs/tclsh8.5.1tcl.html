<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Copyright (c) 1993 The Regents of the University of California.
   Copyright (c) 1994-1996 Sun Microsystems, Inc.
  
   See the file "license.terms" for information on usage and redistribution
   of this file, and for a DISCLAIMER OF ALL WARRANTIES.
  
   RCS: @(#) $Id: tclsh.1,v 1.14 2007/12/13 15:22:33 dgp Exp $
  
   The -*- nroff -*- definitions below are for supplemental macros used
   in Tcl/Tk manual entries.
  
   .AP type name in/out ?indent?
  	Start paragraph describing an argument to a library procedure.
  	type is type of argument (int, etc.), in/out is either "in", "out",
  	or "in/out" to describe whether procedure reads or modifies arg,
  	and indent is equivalent to second arg of .IP (shouldn't ever be
  	needed;  use .AS below instead)
  
   .AS ?type? ?name?
  	Give maximum sizes of arguments for setting tab stops.  Type and
  	name are examples of largest possible arguments that will be passed
  	to .AP later.  If args are omitted, default tab stops are used.
  
   .BS
  	Start box enclosure.  From here until next .BE, everything will be
  	enclosed in one large box.
  
   .BE
  	End of box enclosure.
  
   .CS
  	Begin code excerpt.
  
   .CE
  	End code excerpt.
  
   .VS ?version? ?br?
  	Begin vertical sidebar, for use in marking newly-changed parts
  	of man pages.  The first argument is ignored and used for recording
  	the version when the .VS was added, so that the sidebars can be
  	found and removed when they reach a certain age.  If another argument
  	is present, then a line break is forced before starting the sidebar.
  
   .VE
  	End of vertical sidebar.
  
   .DS
  	Begin an indented unfilled display.
  
   .DE
  	End of indented unfilled display.
  
   .SO ?manpage?
  	Start of list of standard options for a Tk widget. The manpage
  	argument defines where to look up the standard options; if
  	omitted, defaults to "options". The options follow on successive
  	lines, in three columns separated by tabs.
  
   .SE
  	End of list of standard options for a Tk widget.
  
   .OP cmdName dbName dbClass
  	Start of description of a specific option.  cmdName gives the
  	option's name as specified in the class command, dbName gives
  	the option's name in the option database, and dbClass gives
  	the option's class in the option database.
  
   .UL arg1 arg2
  	Print arg1 underlined, then print arg2 normally.
  
   .QW arg1 ?arg2?
  	Print arg1 in quotes, then arg2 normally (for trailing punctuation).
  
   .PQ arg1 ?arg2?
  	Print an open parenthesis, arg1 in quotes, then arg2 normally
  	(for trailing punctuation) and then a closing parenthesis.
  
   RCS: @(#) $Id: man.macros,v 1.9 2008/01/29 15:32:33 dkf Exp $
  
  	# Set up traps and other miscellaneous stuff for Tcl/Tk man pages.
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    .Nd, .Bf, .Op { display: inline; }
    .Pa, .Ad { font-style: italic; }
    .Ms { font-weight: bold; }
    .Bl-diag > dt { font-weight: bold; }
    code.Nm, .Fl, .Cm, .Ic, code.In, .Fd, .Fn, .Cd { font-weight: bold;
      font-family: inherit; }
  </style>
  <title>tclsh(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">tclsh(1)</td>
    <td class="head-vol">Tcl Applications</td>
    <td class="head-rtitle">tclsh(1)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<pre>
</pre>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">tclsh - Simple shell containing Tcl interpreter</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<p class="Pp"><b>tclsh</b> ?-encoding <i>name</i>? ?<i>fileName arg arg
  ...</i>?</p>
<pre>
</pre>
<p class="Pp"></p>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp"><b>Tclsh</b> is a shell-like application that reads Tcl commands
    from its standard input or from a file and evaluates them. If invoked with
    no arguments then it runs interactively, reading Tcl commands from standard
    input and printing command results and error messages to standard output. It
    runs until the <b>exit</b> command is invoked or until it reaches
    end-of-file on its standard input. If there exists a file <b>.tclshrc</b>
    (or <b>tclshrc.tcl</b> on the Windows platforms) in the home directory of
    the user, interactive <b>tclsh</b> evaluates the file as a Tcl script just
    before reading the first command from standard input.</p>
<p class="Pp"></p>
</section>
<section class="Sh">
<h1 class="Sh" id="SCRIPT_FILES"><a class="permalink" href="#SCRIPT_FILES">SCRIPT
  FILES</a></h1>
<p class="Pp">If <b>tclsh</b> is invoked with arguments then the first few
    arguments specify the name of a script file, and, optionally, the encoding
    of the text data stored in that script file. Any additional arguments are
    made available to the script as variables (see below). Instead of reading
    commands from standard input <b>tclsh</b> will read Tcl commands from the
    named file; <b>tclsh</b> will exit when it reaches the end of the file. The
    end of the file may be marked either by the physical end of the medium, or
    by the character, &#x201C;\032&#x201D; (&#x201C;\u001a&#x201D;, control-Z).
    If this character is present in the file, the <b>tclsh</b> application will
    read text up to but not including the character. An application that
    requires this character in the file may safely encode it as
    &#x201C;\032&#x201D;, &#x201C;\x1a&#x201D;, or &#x201C;\u001a&#x201D;; or
    may generate it by use of commands such as <b>format</b> or <b>binary</b>.
    There is no automatic evaluation of <b>.tclshrc</b> when the name of a
    script file is presented on the <b>tclsh</b> command line, but the script
    file can always <b>source</b> it if desired.</p>
<p class="Pp">If you create a Tcl script in a file whose first line is</p>
<div class="Bd-indent">
<pre>
<b>#!/usr/bin/tclsh</b></pre>
</div>
then you can invoke the script file directly from your shell if you mark the
  file as executable. This assumes that <b>tclsh</b> has been installed in the
  default location in /usr/bin; if it is installed somewhere else then you will
  have to modify the above line to match. Many UNIX systems do not allow the
  <b>#!</b> line to exceed about 30 characters in length, so be sure that the
  <b>tclsh</b> executable can be accessed with a short file name.
<p class="Pp">An even better approach is to start your script files with the
    following three lines:</p>
<div class="Bd-indent">
<pre>
<b>#!/bin/sh</b>
<b># the next line restarts using tclsh \</b>
<b>exec tclsh &quot;$0&quot; &quot;$@&quot;</b></pre>
</div>
This approach has three advantages over the approach in the previous paragraph.
  First, the location of the <b>tclsh</b> binary does not have to be hard-wired
  into the script: it can be anywhere in your shell search path. Second, it gets
  around the 30-character file name limit in the previous approach. Third, this
  approach will work even if <b>tclsh</b> is itself a shell script (this is done
  on some systems in order to handle multiple architectures or operating
  systems: the <b>tclsh</b> script selects one of several binaries to run). The
  three lines cause both <b>sh</b> and <b>tclsh</b> to process the script, but
  the <b>exec</b> is only executed by <b>sh</b>. <b>sh</b> processes the script
  first; it treats the second line as a comment and executes the third line. The
  <b>exec</b> statement cause the shell to stop processing and instead to start
  up <b>tclsh</b> to reprocess the entire script. When <b>tclsh</b> starts up,
  it treats all three lines as comments, since the backslash at the end of the
  second line causes the third line to be treated as part of the comment on the
  second line.
<p class="Pp">You should note that it is also common practice to install tclsh
    with its version number as part of the name. This has the advantage of
    allowing multiple versions of Tcl to exist on the same system at once, but
    also the disadvantage of making it harder to write scripts that start up
    uniformly across different versions of Tcl.</p>
<p class="Pp"></p>
</section>
<section class="Sh">
<h1 class="Sh" id="VARIABLES"><a class="permalink" href="#VARIABLES">VARIABLES</a></h1>
<p class="Pp"><b>Tclsh</b> sets the following Tcl variables:</p>
<dl class="Bl-tag">
  <dt id="argc"><a class="permalink" href="#argc"><b>argc</b></a></dt>
  <dd>Contains a count of the number of <i>arg</i> arguments (0 if none), not
      including the name of the script file.</dd>
  <dt id="argv"><a class="permalink" href="#argv"><b>argv</b></a></dt>
  <dd>Contains a Tcl list whose elements are the <i>arg</i> arguments, in order,
      or an empty string if there are no <i>arg</i> arguments.</dd>
  <dt id="argv0"><a class="permalink" href="#argv0"><b>argv0</b></a></dt>
  <dd>Contains <i>fileName</i> if it was specified. Otherwise, contains the name
      by which <b>tclsh</b> was invoked.</dd>
  <dt id="tcl_interactive"><a class="permalink" href="#tcl_interactive"><b>tcl_interactive</b></a></dt>
  <dd>Contains 1 if <b>tclsh</b> is running interactively (no <i>fileName</i>
      was specified and standard input is a terminal-like device), 0 otherwise.
    <p class="Pp"></p>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="PROMPTS"><a class="permalink" href="#PROMPTS">PROMPTS</a></h1>
<p class="Pp">When <b>tclsh</b> is invoked interactively it normally prompts for
    each command with &#x201C;<b>% </b>&#x201D;. You can change the prompt by
    setting the variables <b>tcl_prompt1</b> and <b>tcl_prompt2</b>. If variable
    <b>tcl_prompt1</b> exists then it must consist of a Tcl script to output a
    prompt; instead of outputting a prompt <b>tclsh</b> will evaluate the script
    in <b>tcl_prompt1</b>. The variable <b>tcl_prompt2</b> is used in a similar
    way when a newline is typed but the current command is not yet complete; if
    <b>tcl_prompt2</b> is not set then no prompt is output for incomplete
    commands.</p>
<p class="Pp"></p>
</section>
<section class="Sh">
<h1 class="Sh" id="STANDARD_CHANNELS"><a class="permalink" href="#STANDARD_CHANNELS">STANDARD
  CHANNELS</a></h1>
<p class="Pp">See <b>Tcl_StandardChannels</b> for more explanations.</p>
<p class="Pp"></p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp">encoding(n), fconfigure(n), tclvars(n)</p>
<p class="Pp"></p>
</section>
<section class="Sh">
<h1 class="Sh" id="KEYWORDS"><a class="permalink" href="#KEYWORDS">KEYWORDS</a></h1>
<p class="Pp">argument, interpreter, prompt, script file, shell</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date"></td>
    <td class="foot-os">Tcl</td>
  </tr>
</table>
</body>
</html>
