<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    .Nd, .Bf, .Op { display: inline; }
    .Pa, .Ad { font-style: italic; }
    .Ms { font-weight: bold; }
    .Bl-diag > dt { font-weight: bold; }
    code.Nm, .Fl, .Cm, .Ic, code.In, .Fd, .Fn, .Cd { font-weight: bold;
      font-family: inherit; }
  </style>
  <title>YAML::PP(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">YAML::PP(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">YAML::PP(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">YAML::PP - YAML 1.2 processor</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<p class="Pp">WARNING: Most of the inner API is not stable yet.</p>
<p class="Pp">Here are a few examples of the basic load and dump methods:</p>
<p class="Pp"></p>
<pre>    use YAML::PP;
    my $ypp = YAML::PP-&gt;new;
    my $yaml = &lt;&lt;'EOM';
    --- # Document one is a mapping
    name: Tina
    age: 29
    favourite language: Perl
    --- # Document two is a sequence
    - plain string
    - 'in single quotes'
    - &quot;in double quotes we have escapes! like \t and \n&quot;
    - | # a literal block scalar
      line1
      line2
    - &gt; # a folded block scalar
      this is all one
      single line because the
      linebreaks will be folded
    EOM
    my @documents = $ypp-&gt;load_string($yaml);
    my @documents = $ypp-&gt;load_file($filename);
    my $yaml = $ypp-&gt;dump_string($data1, $data2);
    $ypp-&gt;dump_file($filename, $data1, $data2);
    # The loader offers JSON::PP::Boolean, boolean.pm or
    # perl 1/'' (currently default) for booleans
    my $ypp = YAML::PP-&gt;new(boolean =&gt; 'JSON::PP');
    my $ypp = YAML::PP-&gt;new(boolean =&gt; 'boolean');
    my $ypp = YAML::PP-&gt;new(boolean =&gt; 'perl');
    # Enable perl data types and objects
    my $ypp = YAML::PP-&gt;new(schema =&gt; [qw/ + Perl /]);
    my $yaml = $yp-&gt;dump_string($data_with_perl_objects);
    # Legacy interface
    use YAML::PP qw/ Load Dump LoadFile DumpFile /;
    my @documents = Load($yaml);
    my @documents = LoadFile($filename);
    my @documents = LoadFile($filehandle);
    my $yaml = = Dump(@documents);
    DumpFile($filename, @documents);
    DumpFile($filenhandle @documents);
</pre>
<p class="Pp">Some utility scripts, mostly useful for debugging:</p>
<p class="Pp"></p>
<pre>    # Load YAML into a data structure and dump with Data::Dumper
    yamlpp-load &lt; file.yaml
    # Load and Dump
    yamlpp-load-dump &lt; file.yaml
    # Print the events from the parser in yaml-test-suite format
    yamlpp-events &lt; file.yaml
    # Parse and emit events directly without loading
    yamlpp-parse-emit &lt; file.yaml
    # Create ANSI colored YAML. Can also be useful for invalid YAML, showing
    # you the exact location of the error
    yamlpp-highlight &lt; file.yaml
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">YAML::PP is a modular YAML processor.</p>
<p class="Pp">It aims to support <span class="Li">&quot;YAML 1.2&quot;</span>
    and <span class="Li">&quot;YAML 1.1&quot;</span>. See
    &lt;https://yaml.org/&gt;. Some (rare) syntax elements are not yet supported
    and documented below.</p>
<p class="Pp">YAML is a serialization language. The YAML input is called
    &quot;YAML Stream&quot;. A stream consists of one or more
    &quot;Documents&quot;, separated by a line with a document start marker
    <span class="Li">&quot;---&quot;</span>. A document optionally ends with the
    document end marker <span class="Li">&quot;...&quot;</span>.</p>
<p class="Pp">This allows one to process continuous streams additionally to a
    fixed input file or string.</p>
<p class="Pp">The YAML::PP frontend will currently load all documents, and
    return only the first if called with scalar context.</p>
<p class="Pp">The YAML backend is implemented in a modular way that allows one
    to add custom handling of YAML tags, perl objects and data types. The inner
    API is not yet stable. Suggestions welcome.</p>
<p class="Pp">You can check out all current parse and load results from the
    yaml-test-suite here:
    &lt;https://perlpunk.github.io/YAML-PP-p5/test-suite.html&gt;</p>
</section>
<section class="Sh">
<h1 class="Sh" id="METHODS"><a class="permalink" href="#METHODS">METHODS</a></h1>
<section class="Ss">
<h2 class="Ss" id="new"><a class="permalink" href="#new">new</a></h2>
<pre>    my $ypp = YAML::PP-&gt;new;
    # load booleans via boolean.pm
    my $ypp = YAML::PP-&gt;new( boolean =&gt; 'boolean' );
    # load booleans via JSON::PP::true/false
    my $ypp = YAML::PP-&gt;new( boolean =&gt; 'JSON::PP' );
    
    # use YAML 1.2 Failsafe Schema
    my $ypp = YAML::PP-&gt;new( schema =&gt; ['Failsafe'] );
    # use YAML 1.2 JSON Schema
    my $ypp = YAML::PP-&gt;new( schema =&gt; ['JSON'] );
    # use YAML 1.2 Core Schema
    my $ypp = YAML::PP-&gt;new( schema =&gt; ['Core'] );
    
    # Die when detecting cyclic references
    my $ypp = YAML::PP-&gt;new( cyclic_refs =&gt; 'fatal' );
    
    my $ypp = YAML::PP-&gt;new(
        boolean =&gt; 'JSON::PP',
        schema =&gt; ['Core'],
        cyclic_refs =&gt; 'fatal',
        indent =&gt; 4,
        header =&gt; 1,
        footer =&gt; 1,
        version_directive =&gt; 1,
    );
</pre>
<p class="Pp">Options:</p>
<dl class="Bl-tag">
  <dt id="boolean"><a class="permalink" href="#boolean">boolean</a></dt>
  <dd>Values: <span class="Li">&quot;perl&quot;</span> (currently default),
      <span class="Li">&quot;JSON::PP&quot;</span>,
      <span class="Li">&quot;boolean&quot;</span>
    <p class="Pp">This option is for loading and dumping.</p>
    <p class="Pp">Note that when dumping, only the chosen boolean style will be
        recognized. So if you choose
        <span class="Li">&quot;JSON::PP&quot;</span>,
        <span class="Li">&quot;boolean&quot;</span> objects will not be
        recognized as booleans and will be dumped as ordinary objects (if you
        enable the Perl schema).</p>
  </dd>
  <dt id="schema"><a class="permalink" href="#schema">schema</a></dt>
  <dd>Default: <span class="Li">&quot;['Core']&quot;</span>
    <p class="Pp">This option is for loading and dumping.</p>
    <p class="Pp">Array reference. Here you can define what schema to use.
        Supported standard Schemas are:
        <span class="Li">&quot;Failsafe&quot;</span>,
        <span class="Li">&quot;JSON&quot;</span>,
        <span class="Li">&quot;Core&quot;</span>,
        <span class="Li">&quot;YAML1_1&quot;</span>.</p>
    <p class="Pp">To get an overview how the different Schemas behave, see
        &lt;https://perlpunk.github.io/YAML-PP-p5/schemas.html&gt;</p>
    <p class="Pp">Additionally you can add further schemas, for example
        <span class="Li">&quot;Merge&quot;</span>.</p>
  </dd>
  <dt id="cyclic_refs"><a class="permalink" href="#cyclic_refs">cyclic_refs</a></dt>
  <dd>Default: 'allow' but will be switched to fatal in the future for safety!
    <p class="Pp">This option is for loading only.</p>
    <p class="Pp">Defines what to do when a cyclic reference is detected when
        loading.</p>
    <p class="Pp"></p>
    <pre>    # fatal  - die
    # warn   - Just warn about them and replace with undef
    # ignore - replace with undef
    # allow  - Default
    </pre>
  </dd>
  <dt id="duplicate_keys"><a class="permalink" href="#duplicate_keys">duplicate_keys</a></dt>
  <dd>Default: 1
    <p class="Pp">Since version 0.026</p>
    <p class="Pp">This option is for loading.</p>
    <p class="Pp">NOTE: THIS OPTION WILL BE SET TO 0 IN THE NEXT RELEASE.</p>
    <p class="Pp">The YAML Spec says duplicate mapping keys should be
      forbidden.</p>
    <p class="Pp">When set to true, duplicate keys in mappings are allowed (and
        will overwrite the previous key).</p>
    <p class="Pp">When set to false, duplicate keys will result in an error when
        loading.</p>
    <p class="Pp">This is especially useful when you have a longer mapping and
        don't see the duplicate key in your editor:</p>
    <p class="Pp"></p>
    <pre>    ---
    a: 1
    b: 2
    # .............
    a: 23 # error
    </pre>
  </dd>
  <dt id="indent"><a class="permalink" href="#indent">indent</a></dt>
  <dd>Default: 2
    <p class="Pp">This option is for dumping.</p>
    <p class="Pp">Use that many spaces for indenting</p>
  </dd>
  <dt id="width"><a class="permalink" href="#width">width</a></dt>
  <dd>Since version 0.025
    <p class="Pp">Default: 80</p>
    <p class="Pp">This option is for dumping.</p>
    <p class="Pp">Maximum columns when dumping.</p>
    <p class="Pp">This is only respected when dumping flow collections right
        now.</p>
    <p class="Pp">in the future it will be used also for wrapping long
      strings.</p>
  </dd>
  <dt id="header"><a class="permalink" href="#header">header</a></dt>
  <dd>Default: 1
    <p class="Pp">This option is for dumping.</p>
    <p class="Pp">Print document heaader
      <span class="Li">&quot;---&quot;</span></p>
  </dd>
  <dt id="footer"><a class="permalink" href="#footer">footer</a></dt>
  <dd>Default: 0
    <p class="Pp">This option is for dumping.</p>
    <p class="Pp">Print document footer
      <span class="Li">&quot;...&quot;</span></p>
  </dd>
  <dt id="yaml_version"><a class="permalink" href="#yaml_version">yaml_version</a></dt>
  <dd>Since version 0.020
    <p class="Pp">This option is for loading and dumping.</p>
    <p class="Pp">Default: <span class="Li">1.2</span></p>
    <p class="Pp">Note that in this case, a directive
        <span class="Li">&quot;%YAML 1.1&quot;</span> will basically be ignored
        and everything loaded with the <span class="Li">&quot;1.2
        Core&quot;</span> Schema.</p>
    <p class="Pp">If you want to support both YAML 1.1 and 1.2, you have to
        specify that, and the schema (<span class="Li">&quot;Core&quot;</span>
        or <span class="Li">&quot;YAML1_1&quot;</span>) will be chosen
        automatically.</p>
    <p class="Pp"></p>
    <pre>    my $yp = YAML::PP-&gt;new(
        yaml_version =&gt; ['1.2', '1.1'],
    );
    </pre>
    <p class="Pp">This is the same as</p>
    <p class="Pp"></p>
    <pre>    my $yp = YAML::PP-&gt;new(
        schema =&gt; ['+'],
        yaml_version =&gt; ['1.2', '1.1'],
    );
    </pre>
    <p class="Pp">because the <span class="Li">&quot;+&quot;</span> stands for
        the default schema per version.</p>
    <p class="Pp">When loading, and there is no <span class="Li">%YAML</span>
        directive, <span class="Li">1.2</span> will be considered as default,
        and the <span class="Li">&quot;Core&quot;</span> schema will be
      used.</p>
    <p class="Pp">If there is a <span class="Li">&quot;%YAML 1.1&quot;</span>
        directive, the <span class="Li">&quot;YAML1_1&quot;</span> schema will
        be used.</p>
    <p class="Pp">Of course, you can also make <span class="Li">1.1</span> the
        default:</p>
    <p class="Pp"></p>
    <pre>    my $yp = YAML::PP-&gt;new(
        yaml_version =&gt; ['1.1', '1.2'],
    );
    </pre>
    <p class="Pp">You can also specify <span class="Li">1.1</span> only:</p>
    <p class="Pp"></p>
    <pre>    my $yp = YAML::PP-&gt;new(
        yaml_version =&gt; ['1.1'],
    );
    </pre>
    <p class="Pp">In this case also documents with <span class="Li">&quot;%YAML
        1.2&quot;</span> will be loaded with the
        <span class="Li">&quot;YAML1_1&quot;</span> schema.</p>
  </dd>
  <dt id="version_directive"><a class="permalink" href="#version_directive">version_directive</a></dt>
  <dd>Since version 0.020
    <p class="Pp">This option is for dumping.</p>
    <p class="Pp">Default: 0</p>
    <p class="Pp">Print Version Directive <span class="Li">&quot;%YAML
        1.2&quot;</span> (or <span class="Li">&quot;%YAML 1.1&quot;</span>) on
        top of each YAML document. It will use the first version specified in
        the <span class="Li">&quot;yaml_version&quot;</span> option.</p>
  </dd>
  <dt id="preserve"><a class="permalink" href="#preserve">preserve</a></dt>
  <dd>Since version 0.021
    <p class="Pp">Default: false</p>
    <p class="Pp">This option is for loading and dumping.</p>
    <p class="Pp">Preserving scalar styles is still experimental.</p>
    <p class="Pp"></p>
    <pre>    use YAML::PP::Common qw/ PRESERVE_ORDER PRESERVE_SCALAR_STYLE /;
    # Preserve the order of hash keys
    my $yp = YAML::PP-&gt;new( preserve =&gt; PRESERVE_ORDER );
    # Preserve the quoting style of scalars
    my $yp = YAML::PP-&gt;new( preserve =&gt; PRESERVE_SCALAR_STYLE );
    # Preserve block/flow style (since 0.024)
    my $yp = YAML::PP-&gt;new( preserve =&gt; PRESERVE_FLOW_STYLE );
    # Combine, e.g. preserve order and scalar style
    my $yp = YAML::PP-&gt;new( preserve =&gt; PRESERVE_ORDER | PRESERVE_SCALAR_STYLE );
    </pre>
    <p class="Pp">Do NOT rely on the internal implementation of it.</p>
    <p class="Pp">If you load the following input:</p>
    <p class="Pp"></p>
    <pre>    ---
    z: 1
    a: 2
    ---
    - plain
    - 'single'
    - &quot;double&quot;
    - |
      literal
    ---
    block mapping:
      flow sequence: [a, b]
    flow mapping: {a: b}
    </pre>
    <p class="Pp">with this code:</p>
    <p class="Pp"></p>
    <pre>    my $yp = YAML::PP-&gt;new(
        preserve =&gt; PRESERVE_ORDER | PRESERVE_SCALAR_STYLE | PRESERVE_FLOW_STYLE
    );
    my ($hash, $styles, $flow) = $yp-&gt;load_file($file);
    $yp-&gt;dump_file($hash, $styles, $flow);
    </pre>
    <p class="Pp">Then dumping it will return the same output. Only folded block
        scalars '&gt;' cannot preserve the style yet.</p>
    <p class="Pp">When loading, hashes will be tied to an internal class
        (<span class="Li">&quot;YAML::PP::Preserve::Hash&quot;</span>) that
        keeps the key order.</p>
    <p class="Pp">Scalars will be returned as objects of an internal class
        (<span class="Li">&quot;YAML::PP::Preserve::Scalar&quot;</span>) with
        overloading. If you assign to such a scalar, the object will be replaced
        by a simple scalar.</p>
    <p class="Pp"></p>
    <pre>    # assignment, style gets lost
    $styles-&gt;[1] .= ' append';
    </pre>
    <p class="Pp">You can also pass <span class="Li">1</span> as a value. In
        this case all preserving options will be enabled, also if there are new
        options added in the future.</p>
    <p class="Pp">There are also methods to craete preserved nodes from scratch.
        See the
        <span class="Li">&quot;preserved_(scalar|mapping|sequence&quot;</span>
        &quot;METHODS&quot; below.</p>
  </dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="load_string"><a class="permalink" href="#load_string">load_string</a></h2>
<pre>    my $doc = $ypp-&gt;load_string(&quot;foo: bar&quot;);
    my @docs = $ypp-&gt;load_string(&quot;foo: bar\n---\n- a&quot;);
</pre>
<p class="Pp">Input should be Unicode characters.</p>
<p class="Pp">So if you read from a file, you should decode it, for example with
    <span class="Li">&quot;Encode::decode()&quot;</span>.</p>
<p class="Pp">Note that in scalar context,
    <span class="Li">&quot;load_string&quot;</span> and
    <span class="Li">&quot;load_file&quot;</span> return the first document
    (like YAML::Syck), while YAML and YAML::XS return the last.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="load_file"><a class="permalink" href="#load_file">load_file</a></h2>
<pre>    my $doc = $ypp-&gt;load_file(&quot;file.yaml&quot;);
    my @docs = $ypp-&gt;load_file(&quot;file.yaml&quot;);
</pre>
<p class="Pp">Strings will be loaded as unicode characters.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="dump_string"><a class="permalink" href="#dump_string">dump_string</a></h2>
<pre>    my $yaml = $ypp-&gt;dump_string($doc);
    my $yaml = $ypp-&gt;dump_string($doc1, $doc2);
    my $yaml = $ypp-&gt;dump_string(@docs);
</pre>
<p class="Pp">Input strings should be Unicode characters.</p>
<p class="Pp">Output will return Unicode characters.</p>
<p class="Pp">So if you want to write that to a file (or pass to YAML::XS, for
    example), you typically encode it via
    <span class="Li">&quot;Encode::encode()&quot;</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="dump_file"><a class="permalink" href="#dump_file">dump_file</a></h2>
<pre>    $ypp-&gt;dump_file(&quot;file.yaml&quot;, $doc);
    $ypp-&gt;dump_file(&quot;file.yaml&quot;, $doc1, $doc2);
    $ypp-&gt;dump_file(&quot;file.yaml&quot;, @docs);
</pre>
<p class="Pp">Input data should be Unicode characters.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="dump"><a class="permalink" href="#dump">dump</a></h2>
<p class="Pp">This will dump to a predefined writer. By default it will just use
    the YAML::PP::Writer and output a string.</p>
<p class="Pp"></p>
<pre>    my $writer = MyWriter-&gt;new(\my $output);
    my $yp = YAML::PP-&gt;new(
        writer =&gt; $writer,
    );
    $yp-&gt;dump($data);
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="preserved_scalar"><a class="permalink" href="#preserved_scalar">preserved_scalar</a></h2>
<p class="Pp">Since version 0.024</p>
<p class="Pp">Experimental. Please report bugs or let me know this is useful and
    works.</p>
<p class="Pp">You can define a certain scalar style when dumping data. Figuring
    out the best style is a hard task and practically impossible to get it right
    for all cases. It's also a matter of taste.</p>
<p class="Pp"></p>
<pre>    use YAML::PP::Common qw/ PRESERVE_SCALAR_STYLE /;
    my $yp = YAML::PP-&gt;new(
        preserve =&gt; PRESERVE_SCALAR_STYLE,
    );
    # a single linebreak would normally be dumped with double quotes: &quot;\n&quot;
    my $scalar = $yp-&gt;preserved_scalar(&quot;\n&quot;, style =&gt; YAML_LITERAL_SCALAR_STYLE );
    my $data = { literal =&gt; $scalar };
    my $dump = $yp-&gt;dump_string($data);
    # output
    ---
    literal: |+
    ...
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="preserved_mapping,_preserved_sequence"><a class="permalink" href="#preserved_mapping,_preserved_sequence">preserved_mapping,
  preserved_sequence</a></h2>
<p class="Pp">Since version 0.024</p>
<p class="Pp">Experimental. Please report bugs or let me know this is useful and
    works.</p>
<p class="Pp">With this you can define which nodes are dumped with the more
    compact flow style instead of block style.</p>
<p class="Pp">If you add <span class="Li">&quot;PRESERVE_ORDER&quot;</span> to
    the <span class="Li">&quot;preserve&quot;</span> option, it will also keep
    the order of the keys in a hash.</p>
<p class="Pp"></p>
<pre>    use YAML::PP::Common qw/ PRESERVE_ORDER PRESERVE_FLOW_STYLE /;
    my $yp = YAML::PP-&gt;new(
        preserve =&gt; PRESERVE_FLOW_STYLE | PRESERVE_ORDER
    );
    my $hash = $yp-&gt;preserved_mapping({}, style =&gt; YAML_FLOW_MAPPING_STYLE);
    # Add values after initialization to preserve order
    %$hash = (z =&gt; 1, a =&gt; 2, y =&gt; 3, b =&gt; 4);
    my $array = $yp-&gt;preserved_sequence([23, 24], style =&gt; YAML_FLOW_SEQUENCE_STYLE);
    my $data = $yp-&gt;preserved_mapping({});
    %$data = ( map =&gt; $hash, seq =&gt; $array );
    my $dump = $yp-&gt;dump_string($data);
    # output
    ---
    map: {z: 1, a: 2, y: 3, b: 4}
    seq: [23, 24]
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="loader"><a class="permalink" href="#loader">loader</a></h2>
<p class="Pp">Returns or sets the loader object, by default YAML::PP::Loader</p>
</section>
<section class="Ss">
<h2 class="Ss" id="dumper"><a class="permalink" href="#dumper">dumper</a></h2>
<p class="Pp">Returns or sets the dumper object, by default YAML::PP::Dumper</p>
</section>
<section class="Ss">
<h2 class="Ss" id="schema~2"><a class="permalink" href="#schema~2">schema</a></h2>
<p class="Pp">Returns or sets the schema object</p>
</section>
<section class="Ss">
<h2 class="Ss" id="default_schema"><a class="permalink" href="#default_schema">default_schema</a></h2>
<p class="Pp">Creates and returns the default schema</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="FUNCTIONS"><a class="permalink" href="#FUNCTIONS">FUNCTIONS</a></h1>
<p class="Pp">The functions <span class="Li">&quot;Load&quot;</span>,
    <span class="Li">&quot;LoadFile&quot;</span>,
    <span class="Li">&quot;Dump&quot;</span> and
    <span class="Li">&quot;DumpFile&quot;</span> are provided as a drop-in
    replacement for other existing YAML processors. No function is exported by
    default.</p>
<p class="Pp">Note that in scalar context,
    <span class="Li">&quot;Load&quot;</span> and
    <span class="Li">&quot;LoadFile&quot;</span> return the first document (like
    YAML::Syck), while YAML and YAML::XS return the last.</p>
<dl class="Bl-tag">
  <dt id="Load"><a class="permalink" href="#Load">Load</a></dt>
  <dd>
    <pre>    use YAML::PP qw/ Load /;
    my $doc = Load($yaml);
    my @docs = Load($yaml);
    </pre>
    <p class="Pp">Works like
      <span class="Li">&quot;load_string&quot;</span>.</p>
  </dd>
  <dt id="LoadFile"><a class="permalink" href="#LoadFile">LoadFile</a></dt>
  <dd>
    <pre>    use YAML::PP qw/ LoadFile /;
    my $doc = LoadFile($file);
    my @docs = LoadFile($file);
    my @docs = LoadFile($filehandle);
    </pre>
    <p class="Pp">Works like <span class="Li">&quot;load_file&quot;</span>.</p>
  </dd>
  <dt id="Dump"><a class="permalink" href="#Dump">Dump</a></dt>
  <dd>
    <pre>    use YAML::PP qw/ Dump /;
    my $yaml = Dump($doc);
    my $yaml = Dump(@docs);
    </pre>
    <p class="Pp">Works like
      <span class="Li">&quot;dump_string&quot;</span>.</p>
  </dd>
  <dt id="DumpFile"><a class="permalink" href="#DumpFile">DumpFile</a></dt>
  <dd>
    <pre>    use YAML::PP qw/ DumpFile /;
    DumpFile($file, $doc);
    DumpFile($file, @docs);
    DumpFile($filehandle, @docs);
    </pre>
    <p class="Pp">Works like <span class="Li">&quot;dump_file&quot;</span>.</p>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="PLUGINS"><a class="permalink" href="#PLUGINS">PLUGINS</a></h1>
<p class="Pp">You can alter the behaviour of YAML::PP by using the following
    schema classes:</p>
<dl class="Bl-tag">
  <dt id="YAML::PP::Schema::Failsafe"><a class="permalink" href="#YAML::PP::Schema::Failsafe">YAML::PP::Schema::Failsafe</a></dt>
  <dd>One of the three YAML 1.2 official schemas</dd>
  <dt id="YAML::PP::Schema::JSON"><a class="permalink" href="#YAML::PP::Schema::JSON">YAML::PP::Schema::JSON</a></dt>
  <dd>One of the three YAML 1.2 official schemas.</dd>
  <dt id="YAML::PP::Schema::Core"><a class="permalink" href="#YAML::PP::Schema::Core">YAML::PP::Schema::Core</a></dt>
  <dd>One of the three YAML 1.2 official schemas. Default</dd>
  <dt id="YAML::PP::Schema::YAML1_1"><a class="permalink" href="#YAML::PP::Schema::YAML1_1">YAML::PP::Schema::YAML1_1</a></dt>
  <dd>Schema implementing the most common YAML 1.1 types</dd>
  <dt id="YAML::PP::Schema::Perl"><a class="permalink" href="#YAML::PP::Schema::Perl">YAML::PP::Schema::Perl</a></dt>
  <dd>Serializing Perl objects and types</dd>
  <dt id="YAML::PP::Schema::Binary"><a class="permalink" href="#YAML::PP::Schema::Binary">YAML::PP::Schema::Binary</a></dt>
  <dd>Serializing binary data</dd>
  <dt id="YAML::PP::Schema::Tie::IxHash"><a class="permalink" href="#YAML::PP::Schema::Tie::IxHash">YAML::PP::Schema::Tie::IxHash</a></dt>
  <dd>Deprecated. See option <span class="Li">&quot;preserve&quot;</span></dd>
  <dt id="YAML::PP::Schema::Merge"><a class="permalink" href="#YAML::PP::Schema::Merge">YAML::PP::Schema::Merge</a></dt>
  <dd>YAML 1.1 merge keys for mappings</dd>
  <dt id="YAML::PP::Schema::Include"><a class="permalink" href="#YAML::PP::Schema::Include">YAML::PP::Schema::Include</a></dt>
  <dd>Include other YAML files via <span class="Li">&quot;!include&quot;</span>
      tags</dd>
</dl>
<p class="Pp">To make the parsing process faster, you can plugin the libyaml
    parser with YAML::PP::LibYAML.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="IMPLEMENTATION"><a class="permalink" href="#IMPLEMENTATION">IMPLEMENTATION</a></h1>
<p class="Pp">The process of loading and dumping is split into the following
    steps:</p>
<p class="Pp"></p>
<pre>    Load:
    YAML Stream        Tokens        Event List        Data Structure
              ---------&gt;    ---------&gt;        ---------&gt;
                lex           parse           construct
    Dump:
    Data Structure       Event List        YAML Stream
                ---------&gt;        ---------&gt;
                represent           emit
</pre>
<p class="Pp">You can dump basic perl types like hashes, arrays, scalars
    (strings, numbers). For dumping blessed objects and things like coderefs
    have a look at YAML::PP::Perl/YAML::PP::Schema::Perl.</p>
<dl class="Bl-tag">
  <dt id="YAML::PP::Lexer"><a class="permalink" href="#YAML::PP::Lexer">YAML::PP::Lexer</a></dt>
  <dd>The Lexer is reading the YAML stream into tokens. This makes it possible
      to generate syntax highlighted YAML output.
    <p class="Pp">Note that the API to retrieve the tokens will change.</p>
  </dd>
  <dt id="YAML::PP::Parser"><a class="permalink" href="#YAML::PP::Parser">YAML::PP::Parser</a></dt>
  <dd>The Parser retrieves the tokens from the Lexer. The main YAML content is
      then parsed with the Grammar.</dd>
  <dt id="YAML::PP::Grammar"><a class="permalink" href="#YAML::PP::Grammar">YAML::PP::Grammar</a></dt>
  <dd></dd>
  <dt id="YAML::PP::Constructor"><a class="permalink" href="#YAML::PP::Constructor">YAML::PP::Constructor</a></dt>
  <dd>The Constructor creates a data structure from the Parser events.</dd>
  <dt id="YAML::PP::Loader"><a class="permalink" href="#YAML::PP::Loader">YAML::PP::Loader</a></dt>
  <dd>The Loader combines the constructor and parser.</dd>
  <dt id="YAML::PP::Dumper"><a class="permalink" href="#YAML::PP::Dumper">YAML::PP::Dumper</a></dt>
  <dd>The Dumper will delegate to the Representer</dd>
  <dt id="YAML::PP::Representer"><a class="permalink" href="#YAML::PP::Representer">YAML::PP::Representer</a></dt>
  <dd>The Representer will create Emitter events from the given data
    structure.</dd>
  <dt id="YAML::PP::Emitter"><a class="permalink" href="#YAML::PP::Emitter">YAML::PP::Emitter</a></dt>
  <dd>The Emitter creates a YAML stream.</dd>
</dl>
<section class="Ss">
<h2 class="Ss" id="YAML::PP::Parser~2"><a class="permalink" href="#YAML::PP::Parser~2">YAML::PP::Parser</a></h2>
<p class="Pp">Still TODO:</p>
<dl class="Bl-tag">
  <dt id="Implicit"><a class="permalink" href="#Implicit">Implicit collection
    keys</a></dt>
  <dd>
    <pre>    ---
    [ a, b, c ]: value
    </pre>
  </dd>
  <dt id="Implicit~2"><a class="permalink" href="#Implicit~2">Implicit mapping
    in flow style sequences</a></dt>
  <dd>
    <pre>    ---
    [ a, b, c: d ]
    # equals
    [ a, b, { c: d } ]
    </pre>
  </dd>
  <dt id="Plain"><a class="permalink" href="#Plain">Plain mapping keys ending
    with colons</a></dt>
  <dd>
    <pre>    ---
    key ends with two colons::: value
    </pre>
  </dd>
  <dt id="Supported"><a class="permalink" href="#Supported">Supported
    Characters</a></dt>
  <dd>If you have valid YAML that's not parsed, or the other way round, please
      create an issue.</dd>
  <dt id="Line"><a class="permalink" href="#Line">Line and Column
    Numbers</a></dt>
  <dd>You will see line and column numbers in the error message. The column
      numbers might still be wrong in some cases.</dd>
  <dt id="Error"><a class="permalink" href="#Error">Error Messages</a></dt>
  <dd>The error messages need to be improved.</dd>
  <dt id="Unicode"><a class="permalink" href="#Unicode">Unicode Surrogate
    Pairs</a></dt>
  <dd>Currently loaded as single characters without validating</dd>
  <dt id="Possibly"><a class="permalink" href="#Possibly">Possibly more</a></dt>
  <dd></dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="YAML::PP::Constructor~2"><a class="permalink" href="#YAML::PP::Constructor~2">YAML::PP::Constructor</a></h2>
<p class="Pp">The Constructor now supports all three YAML 1.2 Schemas, Failsafe,
    JSON and Core. Additionally you can choose the schema for YAML 1.1 as
    <span class="Li">&quot;YAML1_1&quot;</span>.</p>
<p class="Pp">Too see what strings are resolved as booleans, numbers, null etc.
    look at
  &lt;https://perlpunk.github.io/YAML-PP-p5/schema-examples.html&gt;.</p>
<p class="Pp">You can choose the Schema like this:</p>
<p class="Pp"></p>
<pre>    my $ypp = YAML::PP-&gt;new(schema =&gt; ['JSON']); # default is 'Core'
</pre>
<p class="Pp">The Tags <span class="Li">&quot;!!seq&quot;</span> and
    <span class="Li">&quot;!!map&quot;</span> are still ignored for now.</p>
<p class="Pp">It supports:</p>
<dl class="Bl-tag">
  <dt id="Handling"><a class="permalink" href="#Handling">Handling of
    Anchors/Aliases</a></dt>
  <dd>Like in modules like YAML, the Constructor will use references for
      mappings and sequences, but obviously not for scalars.
    <p class="Pp">YAML::XS uses real aliases, which allows also aliasing
        scalars. I might add an option for that since aliasing is now available
        in pure perl.</p>
  </dd>
  <dt id="Boolean"><a class="permalink" href="#Boolean">Boolean
    Handling</a></dt>
  <dd>You can choose between <span class="Li">'perl'</span> (1/'', currently
      default), <span class="Li">'JSON::PP'</span> and
      <span class="Li">'boolean'</span>.pm for handling boolean types. That
      allows you to dump the data structure with one of the JSON modules without
      losing information about booleans.</dd>
  <dt id="Numbers"><a class="permalink" href="#Numbers">Numbers</a></dt>
  <dd>Numbers are created as real numbers instead of strings, so that they are
      dumped correctly by modules like JSON::PP or JSON::XS, for example.</dd>
  <dt id="Complex"><a class="permalink" href="#Complex">Complex Keys</a></dt>
  <dd>Mapping Keys in YAML can be more than just scalars. Of course, you can't
      load that into a native perl structure. The Constructor will stringify
      those keys with Data::Dumper instead of just returning something like
      <span class="Li">&quot;HASH(0x55dc1b5d0178)&quot;</span>.
    <p class="Pp">Example:</p>
    <p class="Pp"></p>
    <pre>    use YAML::PP;
    use JSON::PP;
    my $ypp = YAML::PP-&gt;new;
    my $coder = JSON::PP-&gt;new-&gt;ascii-&gt;pretty-&gt;allow_nonref-&gt;canonical;
    my $yaml = &lt;&lt;'EOM';
    complex:
        ?
            ?
                a: 1
                c: 2
            : 23
        : 42
    EOM
    my $data = $yppl-&gt;load_string($yaml);
    say $coder-&gt;encode($data);
    __END__
    {
       &quot;complex&quot; : {
          &quot;{'{a =&gt; 1,c =&gt; 2}' =&gt; 23}&quot; : 42
       }
    }
    </pre>
  </dd>
</dl>
<p class="Pp">TODO:</p>
<dl class="Bl-tag">
  <dt id="Parse"><a class="permalink" href="#Parse">Parse Tree</a></dt>
  <dd>I would like to generate a complete parse tree, that allows you to
      manipulate the data structure and also dump it, including all whitespaces
      and comments. The spec says that this is throwaway content, but I read
      that many people wish to be able to keep the comments.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="YAML::PP::Dumper,_YAML::PP::Emitter"><a class="permalink" href="#YAML::PP::Dumper,_YAML::PP::Emitter">YAML::PP::Dumper,
  YAML::PP::Emitter</a></h2>
<p class="Pp">The Dumper should be able to dump strings correctly, adding quotes
    whenever a plain scalar would look like a special string, like
    <span class="Li">&quot;true&quot;</span>, or when it contains or starts with
    characters that are not allowed.</p>
<p class="Pp">Most strings will be dumped as plain scalars without quotes. If
    they contain special characters or have a special meaning, they will be
    dumped with single quotes. If they contain control characters, including
    &lt;&quot;\n&quot;&gt;, they will be dumped with double quotes.</p>
<p class="Pp">It will recognize JSON::PP::Boolean and boolean.pm objects and
    dump them correctly.</p>
<p class="Pp">Numbers which also have a PV flag will be recognized as numbers
    and not as strings:</p>
<p class="Pp"></p>
<pre>    my $int = 23;
    say &quot;int: $int&quot;; # $int will now also have a PV flag
</pre>
<p class="Pp">That means that if you accidentally use a string in numeric
    context, it will also be recognized as a number:</p>
<p class="Pp"></p>
<pre>    my $string = &quot;23&quot;;
    my $something = $string + 0;
    print $yp-&gt;dump_string($string);
    # will be emitted as an integer without quotes!
</pre>
<p class="Pp">The layout is like libyaml output:</p>
<p class="Pp"></p>
<pre>    key:
    - a
    - b
    - c
    ---
    - key1: 1
      key2: 2
      key3: 3
    ---
    - - a1
      - a2
    - - b1
      - b2
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="WHY"><a class="permalink" href="#WHY">WHY</a></h1>
<p class="Pp">All the available parsers and loaders for Perl are behaving
    differently, and more important, aren't conforming to the spec. YAML::XS is
    doing pretty well, but <span class="Li">&quot;libyaml&quot;</span> only
    handles YAML 1.1 and diverges a bit from the spec. The pure perl loaders
    lack support for a number of features.</p>
<p class="Pp">I was going over YAML.pm issues end of 2016, integrating old
    patches from rt.cpan.org and creating some pull requests myself. I realized
    that it would be difficult to patch YAML.pm to parse YAML 1.1 or even 1.2,
    and it would also break existing usages relying on the current
  behaviour.</p>
<p class="Pp">In 2016 Ingy d&#x00F6;t Net initiated two really cool
  projects:</p>
<dl class="Bl-tag">
  <dt>&quot;YAML TEST SUITE&quot;</dt>
  <dd></dd>
  <dt>&quot;YAML EDITOR&quot;</dt>
  <dd></dd>
</dl>
<p class="Pp">These projects are a big help for any developer. So I got the idea
    to write my own parser and started on New Year's Day 2017. Without the test
    suite and the editor I would have never started this.</p>
<p class="Pp">I also started another YAML Test project which allows one to get a
    quick overview of which frameworks support which YAML features:</p>
<dl class="Bl-tag">
  <dt>&quot;YAML TEST MATRIX&quot;</dt>
  <dd></dd>
</dl>
<section class="Ss">
<h2 class="Ss">YAML TEST SUITE</h2>
<p class="Pp">&lt;https://github.com/yaml/yaml-test-suite&gt;</p>
<p class="Pp">It contains about 230 test cases and expected parsing events and
    more. There will be more tests coming. This test suite allows you to write
    parsers without turning the examples from the Specification into tests
    yourself. Also the examples aren't completely covering all cases - the test
    suite aims to do that.</p>
<p class="Pp">The suite contains .tml files, and in a separate 'data' release
    you will find the content in separate files, if you can't or don't want to
    use TestML.</p>
<p class="Pp">Thanks also to Felix Krause, who is writing a YAML parser in Nim.
    He turned all the spec examples into test cases.</p>
</section>
<section class="Ss">
<h2 class="Ss">YAML EDITOR</h2>
<p class="Pp">This is a tool to play around with several YAML parsers and
    loaders in vim.</p>
<p class="Pp">&lt;https://github.com/yaml/yaml-editor&gt;</p>
<p class="Pp">The project contains the code to build the frameworks (16 as of
    this writing) and put it into one big Docker image.</p>
<p class="Pp">It also contains the yaml-editor itself, which will start a vim in
    the docker container. It uses a lot of funky vimscript that makes playing
    with it easy and useful. You can choose which frameworks you want to test
    and see the output in a grid of vim windows.</p>
<p class="Pp">Especially when writing a parser it is extremely helpful to have
    all the test cases and be able to play around with your own examples to see
    how they are handled.</p>
</section>
<section class="Ss">
<h2 class="Ss">YAML TEST MATRIX</h2>
<p class="Pp">I was curious to see how the different frameworks handle the test
    cases, so, using the test suite and the docker image, I wrote some code that
    runs the tests, manipulates the output to compare it with the expected
    output, and created a matrix view.</p>
<p class="Pp">&lt;https://github.com/perlpunk/yaml-test-matrix&gt;</p>
<p class="Pp">You can find the latest build at
  &lt;https://matrix.yaml.io&gt;</p>
<p class="Pp">As of this writing, the test matrix only contains valid test
    cases. Invalid ones will be added.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="CONTRIBUTORS"><a class="permalink" href="#CONTRIBUTORS">CONTRIBUTORS</a></h1>
<dl class="Bl-tag">
  <dt id="Ingy"><a class="permalink" href="#Ingy">Ingy d&#x00F6;t Net</a></dt>
  <dd>Ingy is one of the creators of YAML. In 2016 he started the YAML Test
      Suite and the YAML Editor. He also made useful suggestions on the class
      hierarchy of YAML::PP.</dd>
  <dt id="Felix"><a class="permalink" href="#Felix">Felix &quot;flyx&quot;
    Krause</a></dt>
  <dd>Felix answered countless questions about the YAML Specification.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<dl class="Bl-tag">
  <dt id="YAML"><a class="permalink" href="#YAML">YAML</a></dt>
  <dd></dd>
  <dt id="YAML::XS"><a class="permalink" href="#YAML::XS">YAML::XS</a></dt>
  <dd></dd>
  <dt id="YAML::Syck"><a class="permalink" href="#YAML::Syck">YAML::Syck</a></dt>
  <dd></dd>
  <dt id="YAML::Tiny"><a class="permalink" href="#YAML::Tiny">YAML::Tiny</a></dt>
  <dd></dd>
  <dt id="YAML::PP::LibYAML"><a class="permalink" href="#YAML::PP::LibYAML">YAML::PP::LibYAML</a></dt>
  <dd></dd>
  <dt id="YAML::LibYAML::API"><a class="permalink" href="#YAML::LibYAML::API">YAML::LibYAML::API</a></dt>
  <dd></dd>
  <dt>&lt;https://www.yaml.info&gt;</dt>
  <dd></dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="SPONSORS"><a class="permalink" href="#SPONSORS">SPONSORS</a></h1>
<p class="Pp">The Perl Foundation &lt;https://www.perlfoundation.org/&gt;
    sponsored this project (and the YAML Test Suite) with a grant of 2500 USD in
    2017-2018.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT_AND_LICENSE"><a class="permalink" href="#COPYRIGHT_AND_LICENSE">COPYRIGHT
  AND LICENSE</a></h1>
<p class="Pp">Copyright 2017-2020 by Tina M&#x00FC;ller</p>
<p class="Pp">This library is free software and may be distributed under the
    same terms as perl itself.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2020-09-10</td>
    <td class="foot-os">perl v5.34.0</td>
  </tr>
</table>
</body>
</html>
