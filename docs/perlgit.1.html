<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    .Nd, .Bf, .Op { display: inline; }
    .Pa, .Ad { font-style: italic; }
    .Ms { font-weight: bold; }
    .Bl-diag > dt { font-weight: bold; }
    code.Nm, .Fl, .Cm, .Ic, code.In, .Fd, .Fn, .Cd { font-weight: bold;
      font-family: inherit; }
  </style>
  <title>PERLGIT(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">PERLGIT(1)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">PERLGIT(1)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">perlgit - Detailed information about git and the Perl
  repository</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">This document provides details on using git to develop Perl. If
    you are just interested in working on a quick patch, see perlhack first.
    This document is intended for people who are regular contributors to Perl,
    including those with write access to the git repository.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="CLONING_THE_REPOSITORY"><a class="permalink" href="#CLONING_THE_REPOSITORY">CLONING
  THE REPOSITORY</a></h1>
<p class="Pp">All of Perl's source code is kept centrally in a Git repository at
    <i>github.com</i>.</p>
<p class="Pp">You can make a read-only clone of the repository by running:</p>
<p class="Pp"></p>
<pre>  % git clone git://github.com/Perl/perl5.git perl
</pre>
<p class="Pp">This uses the git protocol (port 9418).</p>
<p class="Pp">If you cannot use the git protocol for firewall reasons, you can
    also clone via http:</p>
<p class="Pp"></p>
<pre>  % git clone https://github.com/Perl/perl5.git perl
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="WORKING_WITH_THE_REPOSITORY"><a class="permalink" href="#WORKING_WITH_THE_REPOSITORY">WORKING
  WITH THE REPOSITORY</a></h1>
<p class="Pp">Once you have changed into the repository directory, you can
    inspect it. After a clone the repository will contain a single local branch,
    which will be the current branch as well, as indicated by the asterisk.</p>
<p class="Pp"></p>
<pre>  % git branch
  * blead
</pre>
<p class="Pp">Using the -a switch to <span class="Li">&quot;branch&quot;</span>
    will also show the remote tracking branches in the repository:</p>
<p class="Pp"></p>
<pre>  % git branch -a
  * blead
    origin/HEAD
    origin/blead
  ...
</pre>
<p class="Pp">The branches that begin with &quot;origin&quot; correspond to the
    &quot;git remote&quot; that you cloned from (which is named
    &quot;origin&quot;). Each branch on the remote will be exactly tracked by
    these branches. You should NEVER do work on these remote tracking branches.
    You only ever do work in a local branch. Local branches can be configured to
    automerge (on pull) from a designated remote tracking branch. This is the
    case with the default branch <span class="Li">&quot;blead&quot;</span> which
    will be configured to merge from the remote tracking branch
    <span class="Li">&quot;origin/blead&quot;</span>.</p>
<p class="Pp">You can see recent commits:</p>
<p class="Pp"></p>
<pre>  % git log
</pre>
<p class="Pp">And pull new changes from the repository, and update your local
    repository (must be clean first)</p>
<p class="Pp"></p>
<pre>  % git pull
</pre>
<p class="Pp">Assuming we are on the branch
    <span class="Li">&quot;blead&quot;</span> immediately after a pull, this
    command would be more or less equivalent to:</p>
<p class="Pp"></p>
<pre>  % git fetch
  % git merge origin/blead
</pre>
<p class="Pp">In fact if you want to update your local repository without
    touching your working directory you do:</p>
<p class="Pp"></p>
<pre>  % git fetch
</pre>
<p class="Pp">And if you want to update your remote-tracking branches for all
    defined remotes simultaneously you can do</p>
<p class="Pp"></p>
<pre>  % git remote update
</pre>
<p class="Pp">Neither of these last two commands will update your working
    directory, however both will update the remote-tracking branches in your
    repository.</p>
<p class="Pp">To make a local branch of a remote branch:</p>
<p class="Pp"></p>
<pre>  % git checkout -b maint-5.10 origin/maint-5.10
</pre>
<p class="Pp">To switch back to blead:</p>
<p class="Pp"></p>
<pre>  % git checkout blead
</pre>
<section class="Ss">
<h2 class="Ss" id="Finding_out_your_status"><a class="permalink" href="#Finding_out_your_status">Finding
  out your status</a></h2>
<p class="Pp">The most common git command you will use will probably be</p>
<p class="Pp"></p>
<pre>  % git status
</pre>
<p class="Pp">This command will produce as output a description of the current
    state of the repository, including modified files and unignored untracked
    files, and in addition it will show things like what files have been staged
    for the next commit, and usually some useful information about how to change
    things. For instance the following:</p>
<p class="Pp"></p>
<pre> % git status
 On branch blead
 Your branch is ahead of 'origin/blead' by 1 commit.
 Changes to be committed:
   (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)
       modified:   pod/perlgit.pod
 Changes not staged for commit:
   (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)
   (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working
                                                              directory)
       modified:   pod/perlgit.pod
 Untracked files:
   (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)
       deliberate.untracked
</pre>
<p class="Pp">This shows that there were changes to this document staged for
    commit, and that there were further changes in the working directory not yet
    staged. It also shows that there was an untracked file in the working
    directory, and as you can see shows how to change all of this. It also shows
    that there is one commit on the working branch
    <span class="Li">&quot;blead&quot;</span> which has not been pushed to the
    <span class="Li">&quot;origin&quot;</span> remote yet. <b>NOTE</b>: This
    output is also what you see as a template if you do not provide a message to
    <span class="Li">&quot;git commit&quot;</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Patch_workflow"><a class="permalink" href="#Patch_workflow">Patch
  workflow</a></h2>
<p class="Pp">First, please read perlhack for details on hacking the Perl core.
    That document covers many details on how to create a good patch.</p>
<p class="Pp">If you already have a Perl repository, you should ensure that
    you're on the <i>blead</i> branch, and your repository is up to date:</p>
<p class="Pp"></p>
<pre>  % git checkout blead
  % git pull
</pre>
<p class="Pp">It's preferable to patch against the latest blead version, since
    this is where new development occurs for all changes other than critical bug
    fixes. Critical bug fix patches should be made against the relevant maint
    branches, or should be submitted with a note indicating all the branches
    where the fix should be applied.</p>
<p class="Pp">Now that we have everything up to date, we need to create a
    temporary new branch for these changes and switch into it:</p>
<p class="Pp"></p>
<pre>  % git checkout -b orange
</pre>
<p class="Pp">which is the short form of</p>
<p class="Pp"></p>
<pre>  % git branch orange
  % git checkout orange
</pre>
<p class="Pp">Creating a topic branch makes it easier for the maintainers to
    rebase or merge back into the master blead for a more linear history. If you
    don't work on a topic branch the maintainer has to manually cherry pick your
    changes onto blead before they can be applied.</p>
<p class="Pp">That'll get you scolded on perl5-porters, so don't do that. Be
    Awesome.</p>
<p class="Pp">Then make your changes. For example, if Leon Brocard changes his
    name to Orange Brocard, we should change his name in the AUTHORS file:</p>
<p class="Pp"></p>
<pre>  % perl -pi -e 's{Leon Brocard}{Orange Brocard}' AUTHORS
</pre>
<p class="Pp">You can see what files are changed:</p>
<p class="Pp"></p>
<pre>  % git status
  On branch orange
  Changes to be committed:
    (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)
     modified:   AUTHORS
</pre>
<p class="Pp">And you can see the changes:</p>
<p class="Pp"></p>
<pre> % git diff
 diff --git a/AUTHORS b/AUTHORS
 index 293dd70..722c93e 100644
 --- a/AUTHORS
 +++ b/AUTHORS
 @@ -541,7 +541,7 @@    Lars Hecking              &lt;lhecking@nmrc.ucc.ie&gt;
  Laszlo Molnar                  &lt;laszlo.molnar@eth.ericsson.se&gt;
  Leif Huhn                      &lt;leif@hale.dkstat.com&gt;
  Len Johnson                    &lt;lenjay@ibm.net&gt;
 -Leon Brocard                   &lt;acme@astray.com&gt;
 +Orange Brocard                 &lt;acme@astray.com&gt;
  Les Peters                     &lt;lpeters@aol.net&gt;
  Lesley Binks                   &lt;lesley.binks@gmail.com&gt;
  Lincoln D. Stein               &lt;lstein@cshl.org&gt;
</pre>
<p class="Pp">Now commit your change locally:</p>
<p class="Pp"></p>
<pre> % git commit -a -m 'Rename Leon Brocard to Orange Brocard'
 Created commit 6196c1d: Rename Leon Brocard to Orange Brocard
  1 files changed, 1 insertions(+), 1 deletions(-)
</pre>
<p class="Pp">The <span class="Li">&quot;-a&quot;</span> option is used to
    include all files that git tracks that you have changed. If at this time,
    you only want to commit some of the files you have worked on, you can omit
    the <span class="Li">&quot;-a&quot;</span> and use the command
    <span class="Li">&quot;git&#x00A0;add&#x00A0;</span><span class="Li"><i>FILE&#x00A0;...</i></span><span class="Li">&quot;</span>
    before doing the commit.
    <span class="Li">&quot;git&#x00A0;add&#x00A0;--interactive&quot;</span>
    allows you to even just commit portions of files instead of all the changes
    in them.</p>
<p class="Pp">The <span class="Li">&quot;-m&quot;</span> option is used to
    specify the commit message. If you omit it, git will open a text editor for
    you to compose the message interactively. This is useful when the changes
    are more complex than the sample given here, and, depending on the editor,
    to know that the first line of the commit message doesn't exceed the 50
    character legal maximum. See &quot;Commit message&quot; in perlhack for more
    information about what makes a good commit message.</p>
<p class="Pp">Once you've finished writing your commit message and exited your
    editor, git will write your change to disk and tell you something like
  this:</p>
<p class="Pp"></p>
<pre> Created commit daf8e63: explain git status and stuff about remotes
  1 files changed, 83 insertions(+), 3 deletions(-)
</pre>
<p class="Pp">If you re-run <span class="Li">&quot;git status&quot;</span>, you
    should see something like this:</p>
<p class="Pp"></p>
<pre> % git status
 On branch orange
 Untracked files:
   (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)
       deliberate.untracked
 nothing added to commit but untracked files present (use &quot;git add&quot; to
                                                                  track)
</pre>
<p class="Pp">When in doubt, before you do anything else, check your status and
    read it carefully, many questions are answered directly by the git status
    output.</p>
<p class="Pp">You can examine your last commit with:</p>
<p class="Pp"></p>
<pre>  % git show HEAD
</pre>
<p class="Pp">and if you are not happy with either the description or the patch
    itself you can fix it up by editing the files once more and then issue:</p>
<p class="Pp"></p>
<pre>  % git commit -a --amend
</pre>
<p class="Pp">Now, create a fork on GitHub to push your branch to, and add it as
    a remote if you haven't already, as described in the GitHub documentation at
    &lt;https://help.github.com/en/articles/working-with-forks&gt;:</p>
<p class="Pp"></p>
<pre>  % git remote add fork git@github.com:MyUser/perl5.git
</pre>
<p class="Pp">And push the branch to your fork:</p>
<p class="Pp"></p>
<pre>  % git push -u fork orange
</pre>
<p class="Pp">You should now submit a Pull Request (PR) on GitHub from the new
    branch to blead. For more information, see the GitHub documentation at
    &lt;https://help.github.com/en/articles/creating-a-pull-request-from-a-fork&gt;.</p>
<p class="Pp">You can also send patch files to perl5-porters@perl.org
    &lt;mailto:perl5-porters@perl.org&gt; directly if the patch is not ready to
    be applied, but intended for discussion.</p>
<p class="Pp">To create a patch file for all your local changes:</p>
<p class="Pp"></p>
<pre>  % git format-patch -M blead..
  0001-Rename-Leon-Brocard-to-Orange-Brocard.patch
</pre>
<p class="Pp">Or for a lot of changes, e.g. from a topic branch:</p>
<p class="Pp"></p>
<pre>  % git format-patch --stdout -M blead.. &gt; topic-branch-changes.patch
</pre>
<p class="Pp">If you want to delete your temporary branch, you may do so
  with:</p>
<p class="Pp"></p>
<pre> % git checkout blead
 % git branch -d orange
 error: The branch 'orange' is not an ancestor of your current HEAD.
 If you are sure you want to delete it, run 'git branch -D orange'.
 % git branch -D orange
 Deleted branch orange.
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="A_note_on_derived_files"><a class="permalink" href="#A_note_on_derived_files">A
  note on derived files</a></h2>
<p class="Pp">Be aware that many files in the distribution are derivative--avoid
    patching them, because git won't see the changes to them, and the build
    process will overwrite them. Patch the originals instead. Most utilities
    (like perldoc) are in this category, i.e. patch <i>utils/perldoc.PL</i>
    rather than <i>utils/perldoc</i>. Similarly, don't create patches for files
    under <i></i><span class="Li"><i>$src_root</i></span><i>/ext</i> from their
    copies found in
    <i></i><span class="Li"><i>$install_root</i></span><i>/lib</i>. If you are
    unsure about the proper location of a file that may have gotten copied while
    building the source distribution, consult the <i>MANIFEST</i>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Cleaning_a_working_directory"><a class="permalink" href="#Cleaning_a_working_directory">Cleaning
  a working directory</a></h2>
<p class="Pp">The command <span class="Li">&quot;git clean&quot;</span> can with
    varying arguments be used as a replacement for <span class="Li">&quot;make
    clean&quot;</span>.</p>
<p class="Pp">To reset your working directory to a pristine condition you can
    do:</p>
<p class="Pp"></p>
<pre>  % git clean -dxf
</pre>
<p class="Pp">However, be aware this will delete ALL untracked content. You can
    use</p>
<p class="Pp"></p>
<pre>  % git clean -Xf
</pre>
<p class="Pp">to remove all ignored untracked files, such as build and test
    byproduct, but leave any manually created files alone.</p>
<p class="Pp">If you only want to cancel some uncommitted edits, you can use
    <span class="Li">&quot;git</span> <span class="Li">checkout&quot;</span> and
    give it a list of files to be reverted, or <span class="Li">&quot;git
    checkout</span> <span class="Li">-f&quot;</span> to revert them all.</p>
<p class="Pp">If you want to cancel one or several commits, you can use
    <span class="Li">&quot;git reset&quot;</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Bisecting"><a class="permalink" href="#Bisecting">Bisecting</a></h2>
<p class="Pp"><span class="Li">&quot;git&quot;</span> provides a built-in way to
    determine which commit should be blamed for introducing a given bug.
    <span class="Li">&quot;git bisect&quot;</span> performs a binary search of
    history to locate the first failing commit. It is fast, powerful and
    flexible, but requires some setup and to automate the process an auxiliary
    shell script is needed.</p>
<p class="Pp">The core provides a wrapper program, <i>Porting/bisect.pl</i>,
    which attempts to simplify as much as possible, making bisecting as simple
    as running a Perl one-liner. For example, if you want to know when this
    became an error:</p>
<p class="Pp"></p>
<pre>    perl -e 'my $a := 2'
</pre>
<p class="Pp">you simply run this:</p>
<p class="Pp"></p>
<pre>    .../Porting/bisect.pl -e 'my $a := 2;'
</pre>
<p class="Pp">Using <i>Porting/bisect.pl</i>, with one command (and no other
    files) it's easy to find out</p>
<ul class="Bl-bullet">
  <li>Which commit caused this example code to break?</li>
  <li>Which commit caused this example code to start working?</li>
  <li>Which commit added the first file to match this regex?</li>
  <li>Which commit removed the last file to match this regex?</li>
</ul>
<p class="Pp">usually without needing to know which versions of perl to use as
    start and end revisions, as <i>Porting/bisect.pl</i> automatically searches
    to find the earliest stable version for which the test case passes. Run
    <span class="Li">&quot;Porting/bisect.pl --help&quot;</span> for the full
    documentation, including how to set the
    <span class="Li">&quot;Configure&quot;</span> and build time options.</p>
<p class="Pp">If you require more flexibility than <i>Porting/bisect.pl</i> has
    to offer, you'll need to run <span class="Li">&quot;git bisect&quot;</span>
    yourself. It's most useful to use <span class="Li">&quot;git bisect
    run&quot;</span> to automate the building and testing of perl revisions. For
    this you'll need a shell script for <span class="Li">&quot;git&quot;</span>
    to call to test a particular revision. An example script is
    <i>Porting/bisect-example.sh</i>, which you should copy <b>outside</b> of
    the repository, as the bisect process will reset the state to a clean
    checkout as it runs. The instructions below assume that you copied it as
    <i>~/run</i> and then edited it as appropriate.</p>
<p class="Pp">You first enter in bisect mode with:</p>
<p class="Pp"></p>
<pre>  % git bisect start
</pre>
<p class="Pp">For example, if the bug is present on
    <span class="Li">&quot;HEAD&quot;</span> but wasn't in 5.10.0,
    <span class="Li">&quot;git&quot;</span> will learn about this when you
    enter:</p>
<p class="Pp"></p>
<pre>  % git bisect bad
  % git bisect good perl-5.10.0
  Bisecting: 853 revisions left to test after this
</pre>
<p class="Pp">This results in checking out the median commit between
    <span class="Li">&quot;HEAD&quot;</span> and
    <span class="Li">&quot;perl-5.10.0&quot;</span>. You can then run the
    bisecting process with:</p>
<p class="Pp"></p>
<pre>  % git bisect run ~/run
</pre>
<p class="Pp">When the first bad commit is isolated, <span class="Li">&quot;git
    bisect&quot;</span> will tell you so:</p>
<p class="Pp"></p>
<pre>  ca4cfd28534303b82a216cfe83a1c80cbc3b9dc5 is first bad commit
  commit ca4cfd28534303b82a216cfe83a1c80cbc3b9dc5
  Author: Dave Mitchell &lt;davem@fdisolutions.com&gt;
  Date:   Sat Feb 9 14:56:23 2008 +0000
      [perl #49472] Attributes + Unknown Error
      ...
  bisect run success
</pre>
<p class="Pp">You can peek into the bisecting process with
    <span class="Li">&quot;git bisect log&quot;</span> and
    <span class="Li">&quot;git bisect visualize&quot;</span>.
    <span class="Li">&quot;git bisect reset&quot;</span> will get you out of
    bisect mode.</p>
<p class="Pp">Please note that the first
    <span class="Li">&quot;good&quot;</span> state must be an ancestor of the
    first <span class="Li">&quot;bad&quot;</span> state. If you want to search
    for the commit that <i>solved</i> some bug, you have to negate your test
    case (i.e. exit with <span class="Li">1</span> if OK and
    <span class="Li">0</span> if not) and still mark the lower bound as
    <span class="Li">&quot;good&quot;</span> and the upper as
    <span class="Li">&quot;bad&quot;</span>. The &quot;first bad commit&quot;
    has then to be understood as the &quot;first commit where the bug is
    solved&quot;.</p>
<p class="Pp"><span class="Li">&quot;git help bisect&quot;</span> has much more
    information on how you can tweak your binary searches.</p>
<p class="Pp">Following bisection you may wish to configure, build and test perl
    at commits identified by the bisection process. Sometimes, particularly with
    older perls, <span class="Li">&quot;make&quot;</span> may fail during this
    process. In this case you may be able to patch the source code at the older
    commit point. To do so, please follow the suggestions provided in
    &quot;Building perl at older commits&quot; in perlhack.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Topic_branches_and_rewriting_history"><a class="permalink" href="#Topic_branches_and_rewriting_history">Topic
  branches and rewriting history</a></h2>
<p class="Pp">Individual committers should create topic branches under
    <b>yourname</b>/<b>some_descriptive_name</b>:</p>
<p class="Pp"></p>
<pre>  % branch=&quot;$yourname/$some_descriptive_name&quot;
  % git checkout -b $branch
  ... do local edits, commits etc ...
  % git push origin -u $branch
</pre>
<p class="Pp">Should you be stuck with an ancient version of git (prior to 1.7),
    then <span class="Li">&quot;git push&quot;</span> will not have the
    <span class="Li">&quot;-u&quot;</span> switch, and you have to replace the
    last step with the following sequence:</p>
<p class="Pp"></p>
<pre>  % git push origin $branch:refs/heads/$branch
  % git config branch.$branch.remote origin
  % git config branch.$branch.merge refs/heads/$branch
</pre>
<p class="Pp">If you want to make changes to someone else's topic branch, you
    should check with its creator before making any change to it.</p>
<p class="Pp">You might sometimes find that the original author has edited the
    branch's history. There are lots of good reasons for this. Sometimes, an
    author might simply be rebasing the branch onto a newer source point.
    Sometimes, an author might have found an error in an early commit which they
    wanted to fix before merging the branch to blead.</p>
<p class="Pp">Currently the master repository is configured to forbid
    non-fast-forward merges. This means that the branches within can not be
    rebased and pushed as a single step.</p>
<p class="Pp">The only way you will ever be allowed to rebase or modify the
    history of a pushed branch is to delete it and push it as a new branch under
    the same name. Please think carefully about doing this. It may be better to
    sequentially rename your branches so that it is easier for others working
    with you to cherry-pick their local changes onto the new version. (XXX:
    needs explanation).</p>
<p class="Pp">If you want to rebase a personal topic branch, you will have to
    delete your existing topic branch and push as a new version of it. You can
    do this via the following formula (see the explanation about
    <span class="Li">&quot;refspec&quot;</span>'s in the git push documentation
    for details) after you have rebased your branch:</p>
<p class="Pp"></p>
<pre>  # first rebase
  % git checkout $user/$topic
  % git fetch
  % git rebase origin/blead
  # then &quot;delete-and-push&quot;
  % git push origin :$user/$topic
  % git push origin $user/$topic
</pre>
<p class="Pp"><b>NOTE:</b> it is forbidden at the repository level to delete any
    of the &quot;primary&quot; branches. That is any branch matching
    <span class="Li">&quot;m!^(blead|maint|perl)!&quot;</span>. Any attempt to
    do so will result in git producing an error like this:</p>
<p class="Pp"></p>
<pre>  % git push origin :blead
  *** It is forbidden to delete blead/maint branches in this repository
  error: hooks/update exited with error code 1
  error: hook declined to update refs/heads/blead
  To ssh://perl5.git.perl.org/perl
   ! [remote rejected] blead (hook declined)
   error: failed to push some refs to 'ssh://perl5.git.perl.org/perl'
</pre>
<p class="Pp">As a matter of policy we do <b>not</b> edit the history of the
    blead and maint-* branches. If a typo (or worse) sneaks into a commit to
    blead or maint-*, we'll fix it in another commit. The only types of updates
    allowed on these branches are &quot;fast-forwards&quot;, where all history
    is preserved.</p>
<p class="Pp">Annotated tags in the canonical perl.git repository will never be
    deleted or modified. Think long and hard about whether you want to push a
    local tag to perl.git before doing so. (Pushing simple tags is not
  allowed.)</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Grafts"><a class="permalink" href="#Grafts">Grafts</a></h2>
<p class="Pp">The perl history contains one mistake which was not caught in the
    conversion: a merge was recorded in the history between blead and maint-5.10
    where no merge actually occurred. Due to the nature of git, this is now
    impossible to fix in the public repository. You can remove this mis-merge
    locally by adding the following line to your
    <span class="Li">&quot;.git/info/grafts&quot;</span> file:</p>
<p class="Pp"></p>
<pre> 296f12bbbbaa06de9be9d09d3dcf8f4528898a49 434946e0cb7a32589ed92d18008aaa1d88515930
</pre>
<p class="Pp">It is particularly important to have this graft line if any
    bisecting is done in the area of the &quot;merge&quot; in question.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="WRITE_ACCESS_TO_THE_GIT_REPOSITORY"><a class="permalink" href="#WRITE_ACCESS_TO_THE_GIT_REPOSITORY">WRITE
  ACCESS TO THE GIT REPOSITORY</a></h1>
<p class="Pp">Once you have write access, you will need to modify the URL for
    the origin remote to enable pushing. Edit <i>.git/config</i> with the
    <b>git-config</b>(1) command:</p>
<p class="Pp"></p>
<pre>  % git config remote.origin.url git@github.com:Perl/perl5.git
</pre>
<p class="Pp">You can also set up your user name and e-mail address. Most people
    do this once globally in their <i>~/.gitconfig</i> by doing something
  like:</p>
<p class="Pp"></p>
<pre>  % git config --global user.name &quot;AEvar Arnfjoerd` Bjarmason&quot;
  % git config --global user.email avarab@gmail.com
</pre>
<p class="Pp">However, if you'd like to override that just for perl, execute
    something like the following in <i>perl</i>:</p>
<p class="Pp"></p>
<pre>  % git config user.email avar@cpan.org
</pre>
<p class="Pp">It is also possible to keep
    <span class="Li">&quot;origin&quot;</span> as a git remote, and add a new
    remote for ssh access:</p>
<p class="Pp"></p>
<pre>  % git remote add camel git@github.com:Perl/perl5.git
</pre>
<p class="Pp">This allows you to update your local repository by pulling from
    <span class="Li">&quot;origin&quot;</span>, which is faster and doesn't
    require you to authenticate, and to push your changes back with the
    <span class="Li">&quot;camel&quot;</span> remote:</p>
<p class="Pp"></p>
<pre>  % git fetch camel
  % git push camel
</pre>
<p class="Pp">The <span class="Li">&quot;fetch&quot;</span> command just updates
    the <span class="Li">&quot;camel&quot;</span> refs, as the objects
    themselves should have been fetched when pulling from
    <span class="Li">&quot;origin&quot;</span>.</p>
<section class="Ss">
<h2 class="Ss" id="Working_with_Github_pull_requests"><a class="permalink" href="#Working_with_Github_pull_requests">Working
  with Github pull requests</a></h2>
<p class="Pp">Pull requests typically originate from outside of the
    <span class="Li">&quot;Perl/perl.git&quot;</span> repository, so if you want
    to test or work with it locally a vanilla <span class="Li">&quot;git
    fetch&quot;</span> from the
    <span class="Li">&quot;Perl/perl5.git&quot;</span> repository won't fetch
    it.</p>
<p class="Pp">However Github does provide a mechanism to fetch a pull request to
    a local branch. They are available on Github remotes under
    <span class="Li">&quot;pull/&quot;</span>, so you can use
    <span class="Li">&quot;git fetch
    pull/</span><span class="Li"><i>PRID</i></span><span class="Li">/head:</span><span class="Li"><i>localname</i></span><span class="Li">&quot;</span>
    to make a local copy. eg. to fetch pull request 9999 to the local branch
    <span class="Li">&quot;local-branch-name&quot;</span> run:</p>
<p class="Pp"></p>
<pre>  git fetch origin pull/9999/head:local-branch-name
</pre>
<p class="Pp">and then:</p>
<p class="Pp"></p>
<pre>  git checkout local-branch-name
</pre>
<p class="Pp">Note: this branch is not rebased on
    <span class="Li">&quot;blead&quot;</span>, so instead of the checkout above,
    you might want:</p>
<p class="Pp"></p>
<pre>  git rebase origin/blead local-branch-name
</pre>
<p class="Pp">which rebases
    <span class="Li">&quot;local-branch-name&quot;</span> on
    <span class="Li">&quot;blead&quot;</span>, and checks it out.</p>
<p class="Pp">Alternatively you can configure the remote to fetch all pull
    requests as remote-tracking branches. To do this edit the remote in
    <i>.git/config</i>, for example if your github remote is
    <span class="Li">&quot;origin&quot;</span> you'd have:</p>
<p class="Pp"></p>
<pre>  [remote &quot;origin&quot;]
          url = git@github.com:/Perl/perl5.git
          fetch = +refs/heads/*:refs/remotes/origin/*
</pre>
<p class="Pp">Add a line to map the remote pull request branches to
    remote-tracking branches:</p>
<p class="Pp"></p>
<pre>  [remote &quot;origin&quot;]
          url = git@github.com:/Perl/perl5.git
          fetch = +refs/heads/*:refs/remotes/origin/*
          fetch = +refs/pull/*/head:refs/remotes/origin/pull/*
</pre>
<p class="Pp">and then do a fetch as normal:</p>
<p class="Pp"></p>
<pre>  git fetch origin
</pre>
<p class="Pp">This will create a remote-tracking branch for every pull request,
    including closed requests.</p>
<p class="Pp">To remove those remote-tracking branches, remove the line added
    above and prune:</p>
<p class="Pp"></p>
<pre>  git fetch -p origin # or git remote prune origin
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Accepting_a_patch"><a class="permalink" href="#Accepting_a_patch">Accepting
  a patch</a></h2>
<p class="Pp">If you have received a patch file generated using the above
    section, you should try out the patch.</p>
<p class="Pp">First we need to create a temporary new branch for these changes
    and switch into it:</p>
<p class="Pp"></p>
<pre> % git checkout -b experimental
</pre>
<p class="Pp">Patches that were formatted by <span class="Li">&quot;git
    format-patch&quot;</span> are applied with <span class="Li">&quot;git
    am&quot;</span>:</p>
<p class="Pp"></p>
<pre> % git am 0001-Rename-Leon-Brocard-to-Orange-Brocard.patch
 Applying Rename Leon Brocard to Orange Brocard
</pre>
<p class="Pp">Note that some UNIX mail systems can mess with text attachments
    containing 'From '. This will fix them up:</p>
<p class="Pp"></p>
<pre> % perl -pi -e's/^&gt;From /From /' \
                        0001-Rename-Leon-Brocard-to-Orange-Brocard.patch
</pre>
<p class="Pp">If just a raw diff is provided, it is also possible use this
    two-step process:</p>
<p class="Pp"></p>
<pre> % git apply bugfix.diff
 % git commit -a -m &quot;Some fixing&quot; \
                            --author=&quot;That Guy &lt;that.guy@internets.com&gt;&quot;
</pre>
<p class="Pp">Now we can inspect the change:</p>
<p class="Pp"></p>
<pre> % git show HEAD
 commit b1b3dab48344cff6de4087efca3dbd63548ab5e2
 Author: Leon Brocard &lt;acme@astray.com&gt;
 Date:   Fri Dec 19 17:02:59 2008 +0000
   Rename Leon Brocard to Orange Brocard
 diff --git a/AUTHORS b/AUTHORS
 index 293dd70..722c93e 100644
 --- a/AUTHORS
 +++ b/AUTHORS
 @@ -541,7 +541,7 @@ Lars Hecking                 &lt;lhecking@nmrc.ucc.ie&gt;
  Laszlo Molnar                  &lt;laszlo.molnar@eth.ericsson.se&gt;
  Leif Huhn                      &lt;leif@hale.dkstat.com&gt;
  Len Johnson                    &lt;lenjay@ibm.net&gt;
 -Leon Brocard                   &lt;acme@astray.com&gt;
 +Orange Brocard                 &lt;acme@astray.com&gt;
  Les Peters                     &lt;lpeters@aol.net&gt;
  Lesley Binks                   &lt;lesley.binks@gmail.com&gt;
  Lincoln D. Stein               &lt;lstein@cshl.org&gt;
</pre>
<p class="Pp">If you are a committer to Perl and you think the patch is good,
    you can then merge it into blead then push it out to the main
  repository:</p>
<p class="Pp"></p>
<pre>  % git checkout blead
  % git merge experimental
  % git push origin blead
</pre>
<p class="Pp">If you want to delete your temporary branch, you may do so
  with:</p>
<p class="Pp"></p>
<pre> % git checkout blead
 % git branch -d experimental
 error: The branch 'experimental' is not an ancestor of your current
 HEAD.  If you are sure you want to delete it, run 'git branch -D
 experimental'.
 % git branch -D experimental
 Deleted branch experimental.
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Committing_to_blead"><a class="permalink" href="#Committing_to_blead">Committing
  to blead</a></h2>
<p class="Pp">The 'blead' branch will become the next production release of
    Perl.</p>
<p class="Pp">Before pushing <i>any</i> local change to blead, it's incredibly
    important that you do a few things, lest other committers come after you
    with pitchforks and torches:</p>
<ul class="Bl-bullet">
  <li>Make sure you have a good commit message. See &quot;Commit message&quot;
      in perlhack for details.</li>
  <li>Run the test suite. You might not think that one typo fix would break a
      test file. You'd be wrong. Here's an example of where not running the
      suite caused problems. A patch was submitted that added a couple of tests
      to an existing <i>.t</i>. It couldn't possibly affect anything else, so no
      need to test beyond the single affected <i>.t</i>, right? But, the
      submitter's email address had changed since the last of their submissions,
      and this caused other tests to fail. Running the test target given in the
      next item would have caught this problem.</li>
  <li>If you don't run the full test suite, at least <span class="Li">&quot;make
      test_porting&quot;</span>. This will run basic sanity checks. To see which
      sanity checks, have a look in <i>t/porting</i>.</li>
  <li>If you make any changes that affect miniperl or core routines that have
      different code paths for miniperl, be sure to run
      <span class="Li">&quot;make minitest&quot;</span>. This will catch
      problems that even the full test suite will not catch because it runs a
      subset of tests under miniperl rather than perl.</li>
</ul>
</section>
<section class="Ss">
<h2 class="Ss" id="On_merging_and_rebasing"><a class="permalink" href="#On_merging_and_rebasing">On
  merging and rebasing</a></h2>
<p class="Pp">Simple, one-off commits pushed to the 'blead' branch should be
    simple commits that apply cleanly. In other words, you should make sure your
    work is committed against the current position of blead, so that you can
    push back to the master repository without merging.</p>
<p class="Pp">Sometimes, blead will move while you're building or testing your
    changes. When this happens, your push will be rejected with a message like
    this:</p>
<p class="Pp"></p>
<pre> To ssh://perl5.git.perl.org/perl.git
  ! [rejected]        blead -&gt; blead (non-fast-forward)
 error: failed to push some refs to 'ssh://perl5.git.perl.org/perl.git'
 To prevent you from losing history, non-fast-forward updates were
 rejected Merge the remote changes (e.g. 'git pull') before pushing
 again.  See the 'Note about fast-forwards' section of 'git push --help'
 for details.
</pre>
<p class="Pp">When this happens, you can just <i>rebase</i> your work against
    the new position of blead, like this (assuming your remote for the master
    repository is &quot;p5p&quot;):</p>
<p class="Pp"></p>
<pre>  % git fetch p5p
  % git rebase p5p/blead
</pre>
<p class="Pp">You will see your commits being re-applied, and you will then be
    able to push safely. More information about rebasing can be found in the
    documentation for the <b>git-rebase</b>(1) command.</p>
<p class="Pp">For larger sets of commits that only make sense together, or that
    would benefit from a summary of the set's purpose, you should use a merge
    commit. You should perform your work on a topic branch, which you should
    regularly rebase against blead to ensure that your code is not broken by
    blead moving. When you have finished your work, please perform a final
    rebase and test. Linear history is something that gets lost with every
    commit on blead, but a final rebase makes the history linear again, making
    it easier for future maintainers to see what has happened. Rebase as follows
    (assuming your work was on the branch
    <span class="Li">&quot;committer/somework&quot;</span>):</p>
<p class="Pp"></p>
<pre>  % git checkout committer/somework
  % git rebase blead
</pre>
<p class="Pp">Then you can merge it into master like this:</p>
<p class="Pp"></p>
<pre>  % git checkout blead
  % git merge --no-ff --no-commit committer/somework
  % git commit -a
</pre>
<p class="Pp">The switches above deserve explanation.
    <span class="Li">&quot;--no-ff&quot;</span> indicates that even if all your
    work can be applied linearly against blead, a merge commit should still be
    prepared. This ensures that all your work will be shown as a side branch,
    with all its commits merged into the mainstream blead by the merge
  commit.</p>
<p class="Pp"><span class="Li">&quot;--no-commit&quot;</span> means that the
    merge commit will be <i>prepared</i> but not <i>committed</i>. The commit is
    then actually performed when you run the next command, which will bring up
    your editor to describe the commit. Without
    <span class="Li">&quot;--no-commit&quot;</span>, the commit would be made
    with nearly no useful message, which would greatly diminish the value of the
    merge commit as a placeholder for the work's description.</p>
<p class="Pp">When describing the merge commit, explain the purpose of the
    branch, and keep in mind that this description will probably be used by the
    eventual release engineer when reviewing the next perldelta document.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Committing_to_maintenance_versions"><a class="permalink" href="#Committing_to_maintenance_versions">Committing
  to maintenance versions</a></h2>
<p class="Pp">Maintenance versions should only be altered to add critical bug
    fixes, see perlpolicy.</p>
<p class="Pp">To commit to a maintenance version of perl, you need to create a
    local tracking branch:</p>
<p class="Pp"></p>
<pre>  % git checkout --track -b maint-5.005 origin/maint-5.005
</pre>
<p class="Pp">This creates a local branch named
    <span class="Li">&quot;maint-5.005&quot;</span>, which tracks the remote
    branch <span class="Li">&quot;origin/maint-5.005&quot;</span>. Then you can
    pull, commit, merge and push as before.</p>
<p class="Pp">You can also cherry-pick commits from blead and another branch, by
    using the <span class="Li">&quot;git cherry-pick&quot;</span> command. It is
    recommended to use the <b>-x</b> option to <span class="Li">&quot;git
    cherry-pick&quot;</span> in order to record the SHA1 of the original commit
    in the new commit message.</p>
<p class="Pp">Before pushing any change to a maint version, make sure you've
    satisfied the steps in &quot;Committing to blead&quot; above.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Using_a_smoke-me_branch_to_test_changes"><a class="permalink" href="#Using_a_smoke-me_branch_to_test_changes">Using
  a smoke-me branch to test changes</a></h2>
<p class="Pp">Sometimes a change affects code paths which you cannot test on the
    OSes which are directly available to you and it would be wise to have users
    on other OSes test the change before you commit it to blead.</p>
<p class="Pp">Fortunately, there is a way to get your change smoke-tested on
    various OSes: push it to a &quot;smoke-me&quot; branch and wait for certain
    automated smoke-testers to report the results from their OSes. A
    &quot;smoke-me&quot; branch is identified by the branch name: specifically,
    as seen on github.com it must be a local branch whose first name component
    is precisely <span class="Li">&quot;smoke-me&quot;</span>.</p>
<p class="Pp">The procedure for doing this is roughly as follows (using the
    example of tonyc's smoke-me branch called win32stat):</p>
<p class="Pp">First, make a local branch and switch to it:</p>
<p class="Pp"></p>
<pre>  % git checkout -b win32stat
</pre>
<p class="Pp">Make some changes, build perl and test your changes, then commit
    them to your local branch. Then push your local branch to a remote smoke-me
    branch:</p>
<p class="Pp"></p>
<pre>  % git push origin win32stat:smoke-me/tonyc/win32stat
</pre>
<p class="Pp">Now you can switch back to blead locally:</p>
<p class="Pp"></p>
<pre>  % git checkout blead
</pre>
<p class="Pp">and continue working on other things while you wait a day or two,
    keeping an eye on the results reported for your smoke-me branch at
    &lt;http://perl.develop-help.com/?b=smoke-me/tonyc/win32state&gt;.</p>
<p class="Pp">If all is well then update your blead branch:</p>
<p class="Pp"></p>
<pre>  % git pull
</pre>
<p class="Pp">then checkout your smoke-me branch once more and rebase it on
    blead:</p>
<p class="Pp"></p>
<pre>  % git rebase blead win32stat
</pre>
<p class="Pp">Now switch back to blead and merge your smoke-me branch into
  it:</p>
<p class="Pp"></p>
<pre>  % git checkout blead
  % git merge win32stat
</pre>
<p class="Pp">As described earlier, if there are many changes on your smoke-me
    branch then you should prepare a merge commit in which to give an overview
    of those changes by using the following command instead of the last command
    above:</p>
<p class="Pp"></p>
<pre>  % git merge win32stat --no-ff --no-commit
</pre>
<p class="Pp">You should now build perl and test your (merged) changes one last
    time (ideally run the whole test suite, but failing that at least run the
    <i>t/porting/*.t</i> tests) before pushing your changes as usual:</p>
<p class="Pp"></p>
<pre>  % git push origin blead
</pre>
<p class="Pp">Finally, you should then delete the remote smoke-me branch:</p>
<p class="Pp"></p>
<pre>  % git push origin :smoke-me/tonyc/win32stat
</pre>
<p class="Pp">(which is likely to produce a warning like this, which can be
    ignored:</p>
<p class="Pp"></p>
<pre> remote: fatal: ambiguous argument
                                  'refs/heads/smoke-me/tonyc/win32stat':
 unknown revision or path not in the working tree.
 remote: Use '--' to separate paths from revisions
</pre>
<p class="Pp">) and then delete your local branch:</p>
<p class="Pp"></p>
<pre>  % git branch -d win32stat
</pre>
</section>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2019-10-28</td>
    <td class="foot-os">perl v5.30.3</td>
  </tr>
</table>
</body>
</html>
