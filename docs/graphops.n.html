<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Generated from file '/System/Volumes/Data/SWE/macOS/BuildRoots/0ed32b12e4/Library/Caches/com.apple.xbs/Sources/tcl/tcl-134/tcl_ext/tcllib/tcllib/modules/struct/graphops.man' by tcllib/doctools with format 'nroff'
   Copyright (c) 2008 Alejandro Paz <vidriloco@gmail.com>
   Copyright (c) 2008 (docs) Andreas Kupries <andreas_kupries@users.sourceforge.net>
   Copyright (c) 2009 Michal Antoniewski <antoniewski.m@gmail.com>
  
   The definitions below are for supplemental macros used in Tcl/Tk
   manual entries.
  
   .AP type name in/out ?indent?
  	Start paragraph describing an argument to a library procedure.
  	type is type of argument (int, etc.), in/out is either "in", "out",
  	or "in/out" to describe whether procedure reads or modifies arg,
  	and indent is equivalent to second arg of .IP (shouldn't ever be
  	needed;  use .AS below instead)
  
   .AS ?type? ?name?
  	Give maximum sizes of arguments for setting tab stops.  Type and
  	name are examples of largest possible arguments that will be passed
  	to .AP later.  If args are omitted, default tab stops are used.
  
   .BS
  	Start box enclosure.  From here until next .BE, everything will be
  	enclosed in one large box.
  
   .BE
  	End of box enclosure.
  
   .CS
  	Begin code excerpt.
  
   .CE
  	End code excerpt.
  
   .VS ?version? ?br?
  	Begin vertical sidebar, for use in marking newly-changed parts
  	of man pages.  The first argument is ignored and used for recording
  	the version when the .VS was added, so that the sidebars can be
  	found and removed when they reach a certain age.  If another argument
  	is present, then a line break is forced before starting the sidebar.
  
   .VE
  	End of vertical sidebar.
  
   .DS
  	Begin an indented unfilled display.
  
   .DE
  	End of indented unfilled display.
  
   .SO
  	Start of list of standard options for a Tk widget.  The
  	options follow on successive lines, in four columns separated
  	by tabs.
  
   .SE
  	End of list of standard options for a Tk widget.
  
   .OP cmdName dbName dbClass
  	Start of description of a specific option.  cmdName gives the
  	option's name as specified in the class command, dbName gives
  	the option's name in the option database, and dbClass gives
  	the option's class in the option database.
  
   .UL arg1 arg2
  	Print arg1 underlined, then print arg2 normally.
  
   RCS: @(#) $Id: man.macros,v 1.1 2009/01/30 04:56:47 andreas_kupries Exp $
  
  	# Set up traps and other miscellaneous stuff for Tcl/Tk man pages.
  	# Start an argument description
  .b
  	# define tabbing values for .AP
  
  	# BS - start boxed text
  	# ^y = starting y location
  	# ^b = 1
  	# BE - end boxed text (draw box now)
  	Draw four-sided box normally, but don't draw top of
  	box if the box started on an earlier page.
  	# VS - start vertical sidebar
  	# ^Y = starting y location
  	# ^v = 1 (for troff;  for nroff this doesn't matter)
  	# VE - end of vertical sidebar
  	# Special macro to handle page bottom:  finish off current
  	# box/sidebar if in box/sidebar mode, then invoked standard
  	# page bottom macro.
  	Draw three-sided box if this is the box's first page,
  	draw two sides but no top otherwise.
  	# DS - begin display
  	# DE - end display
  	# SO - start of list of standard options
  	# SE - end of list of standard options
  	# OP - start of full description for a single option
  	# CS - begin code excerpt
  	# CE - end code excerpt
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>struct::graph::op(n)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">struct::graph::op(n)</td>
    <td class="head-vol">Tcl Data Structures</td>
    <td class="head-rtitle">struct::graph::op(n)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<pre>

</pre>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
struct::graph::op - Operation for (un)directed graph objects
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
package require <b>Tcl 8.4</b>
<p class="Pp">package require <b>struct::graph::op ?0.11.3?</b></p>
<p class="Pp"><b>struct::graph:op::toAdjacencyMatrix</b> <i>g</i></p>
<p class="Pp"><b>struct::graph:op::toAdjacencyList</b> <i>G</i>
    ?<i>options</i>...?</p>
<p class="Pp"><b>struct::graph:op::kruskal</b> <i>g</i></p>
<p class="Pp"><b>struct::graph:op::prim</b> <i>g</i></p>
<p class="Pp"><b>struct::graph:op::isBipartite?</b> <i>g</i>
  ?<i>bipartvar</i>?</p>
<p class="Pp"><b>struct::graph:op::tarjan</b> <i>g</i></p>
<p class="Pp"><b>struct::graph:op::connectedComponents</b> <i>g</i></p>
<p class="Pp"><b>struct::graph:op::connectedComponentOf</b> <i>g</i>
  <i>n</i></p>
<p class="Pp"><b>struct::graph:op::isConnected?</b> <i>g</i></p>
<p class="Pp"><b>struct::graph:op::isCutVertex?</b> <i>g</i> <i>n</i></p>
<p class="Pp"><b>struct::graph:op::isBridge?</b> <i>g</i> <i>a</i></p>
<p class="Pp"><b>struct::graph:op::isEulerian?</b> <i>g</i> ?<i>tourvar</i>?</p>
<p class="Pp"><b>struct::graph:op::isSemiEulerian?</b> <i>g</i>
  ?<i>pathvar</i>?</p>
<p class="Pp"><b>struct::graph:op::dijkstra</b> <i>g</i> <i>start</i>
    ?<i>options</i>...?</p>
<p class="Pp"><b>struct::graph:op::distance</b> <i>g</i> <i>origin</i>
    <i>destination</i> ?<i>options</i>...?</p>
<p class="Pp"><b>struct::graph:op::eccentricity</b> <i>g</i> <i>n</i>
    ?<i>options</i>...?</p>
<p class="Pp"><b>struct::graph:op::radius</b> <i>g</i> ?<i>options</i>...?</p>
<p class="Pp"><b>struct::graph:op::diameter</b> <i>g</i> ?<i>options</i>...?</p>
<p class="Pp"><b>struct::graph::op::BellmanFord</b> <i>G</i>
  <i>startnode</i></p>
<p class="Pp"><b>struct::graph::op::Johnsons</b> <i>G</i>
  ?<i>options</i>...?</p>
<p class="Pp"><b>struct::graph::op::FloydWarshall</b> <i>G</i></p>
<p class="Pp"><b>struct::graph::op::MetricTravellingSalesman</b> <i>G</i></p>
<p class="Pp"><b>struct::graph::op::Christofides</b> <i>G</i></p>
<p class="Pp"><b>struct::graph::op::GreedyMaxMatching</b> <i>G</i></p>
<p class="Pp"><b>struct::graph::op::MaxCut</b> <i>G</i> <i>U</i> <i>V</i></p>
<p class="Pp"><b>struct::graph::op::UnweightedKCenter</b> <i>G</i> <i>k</i></p>
<p class="Pp"><b>struct::graph::op::WeightedKCenter</b> <i>G</i>
    <i>nodeWeights</i> <i>W</i></p>
<p class="Pp"><b>struct::graph::op::GreedyMaxIndependentSet</b> <i>G</i></p>
<p class="Pp"><b>struct::graph::op::GreedyWeightedMaxIndependentSet</b> <i>G</i>
    <i>nodeWeights</i></p>
<p class="Pp"><b>struct::graph::op::VerticesCover</b> <i>G</i></p>
<p class="Pp"><b>struct::graph::op::EdmondsKarp</b> <i>G</i> <i>s</i>
  <i>t</i></p>
<p class="Pp"><b>struct::graph::op::BusackerGowen</b> <i>G</i>
    <i>desiredFlow</i> <i>s</i> <i>t</i></p>
<p class="Pp"><b>struct::graph::op::ShortestsPathsByBFS</b> <i>G</i> <i>s</i>
    <i>outputFormat</i></p>
<p class="Pp"><b>struct::graph::op::BFS</b> <i>G</i> <i>s</i>
    ?<i>outputFormat</i>...?</p>
<p class="Pp"><b>struct::graph::op::MinimumDiameterSpanningTree</b> <i>G</i></p>
<p class="Pp"><b>struct::graph::op::MinimumDegreeSpanningTree</b> <i>G</i></p>
<p class="Pp"><b>struct::graph::op::MaximumFlowByDinic</b> <i>G</i> <i>s</i>
    <i>t</i> <i>blockingFlowAlg</i></p>
<p class="Pp"><b>struct::graph::op::BlockingFlowByDinic</b> <i>G</i> <i>s</i>
    <i>t</i></p>
<p class="Pp"><b>struct::graph::op::BlockingFlowByMKM</b> <i>G</i> <i>s</i>
    <i>t</i></p>
<p class="Pp"><b>struct::graph::op::createResidualGraph</b> <i>G</i>
  <i>f</i></p>
<p class="Pp"><b>struct::graph::op::createAugmentingNetwork</b> <i>G</i>
    <i>f</i> <i>path</i></p>
<p class="Pp"><b>struct::graph::op::createLevelGraph</b> <i>Gf</i> <i>s</i></p>
<p class="Pp"><b>struct::graph::op::TSPLocalSearching</b> <i>G</i> <i>C</i></p>
<p class="Pp"><b>struct::graph::op::TSPLocalSearching3Approx</b> <i>G</i>
    <i>C</i></p>
<p class="Pp"><b>struct::graph::op::createSquaredGraph</b> <i>G</i></p>
<p class="Pp"><b>struct::graph::op::createCompleteGraph</b> <i>G</i>
    <i>originalEdges</i></p>
<p class="Pp"></p>
<pre>

</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
The package described by this document, <b>struct::graph::op</b>, is a companion
  to the package <b>struct::graph</b>. It provides a series of common operations
  and algorithms applicable to (un)directed graphs.
<p class="Pp">Despite being a companion the package is not directly dependent on
    <b>struct::graph</b>, only on the API defined by that package. I.e. the
    operations of this package can be applied to any and all graph objects which
    provide the same API as the objects created through
  <b>struct::graph</b>.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="OPERATIONS"><a class="permalink" href="#OPERATIONS">OPERATIONS</a></h1>
<dl class="Bl-tag">
  <dt><b>struct::graph:op::toAdjacencyMatrix</b> <i>g</i></dt>
  <dd>This command takes the graph <i>g</i> and returns a nested list containing
      the adjacency matrix of <i>g</i>.
    <p class="Pp">The elements of the outer list are the rows of the matrix, the
        inner elements are the column values in each row. The matrix has
        &quot;<b>n</b>+1&quot; rows and columns, with the first row and column
        (index 0) containing the name of the node the row/column is for. All
        other elements are boolean values, <b>True</b> if there is an arc
        between the 2 nodes of the respective row and column, and <b>False</b>
        otherwise.</p>
    <p class="Pp">Note that the matrix is symmetric. It does not represent the
        directionality of arcs, only their presence between nodes. It is also
        unable to represent parallel arcs in <i>g</i>.</p>
  </dd>
  <dt><b>struct::graph:op::toAdjacencyList</b> <i>G</i> ?<i>options</i>...?</dt>
  <dd>Procedure creates for input graph <i>G</i>, it's representation as
      <i>Adjacency List</i>. It handles both directed and undirected graphs
      (default is undirected). It returns dictionary that for each node (key)
      returns list of nodes adjacent to it. When considering weighted version,
      for each adjacent node there is also weight of the edge included.
    <p class="Pp"></p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>Arguments:</dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>Graph object <i>G</i> (input)</dt>
  <dd>A graph to convert into an <i>Adjacency List</i>.</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt>Options:</dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>-directed</b></dt>
  <dd>By default <i>G</i> is operated as if it were an <i>Undirected graph</i>.
      Using this option tells the command to handle <i>G</i> as the directed
      graph it is.</dd>
  <dt><b>-weights</b></dt>
  <dd>By default any weight information the graph <i>G</i> may have is ignored.
      Using this option tells the command to put weight information into the
      result. In that case it is expected that all arcs have a proper weight,
      and an error is thrown if that is not the case.</dd>
</dl>
</div>
</div>
<dl class="Bl-tag">
  <dt><b>struct::graph:op::kruskal</b> <i>g</i></dt>
  <dd>This command takes the graph <i>g</i> and returns a list containing the
      names of the arcs in <i>g</i> which span up a minimum weight spanning tree
      (MST), or, in the case of an un-connected graph, a minimum weight spanning
      forest (except for the 1-vertex components). Kruskal's algorithm is used
      to compute the tree or forest. This algorithm has a time complexity of
      <i>O(E*log E)</i> or <i>O(E* log V)</i>, where <i>V</i> is the number of
      vertices and <i>E</i> is the number of edges in graph <i>g</i>.
    <p class="Pp">The command will throw an error if one or more arcs in
        <i>g</i> have no weight associated with them.</p>
    <p class="Pp">A note regarding the result, the command refrains from
        explicitly listing the nodes of the MST as this information is
        implicitly provided in the arcs already.</p>
  </dd>
  <dt><b>struct::graph:op::prim</b> <i>g</i></dt>
  <dd>This command takes the graph <i>g</i> and returns a list containing the
      names of the arcs in <i>g</i> which span up a minimum weight spanning tree
      (MST), or, in the case of an un-connected graph, a minimum weight spanning
      forest (except for the 1-vertex components). Prim's algorithm is used to
      compute the tree or forest. This algorithm has a time complexity between
      <i>O(E+V*log V)</i> and <i>O(V*V)</i>, depending on the implementation
      (Fibonacci heap + Adjacency list versus Adjacency Matrix). As usual
      <i>V</i> is the number of vertices and <i>E</i> the number of edges in
      graph <i>g</i>.
    <p class="Pp">The command will throw an error if one or more arcs in
        <i>g</i> have no weight associated with them.</p>
    <p class="Pp">A note regarding the result, the command refrains from
        explicitly listing the nodes of the MST as this information is
        implicitly provided in the arcs already.</p>
  </dd>
  <dt><b>struct::graph:op::isBipartite?</b> <i>g</i> ?<i>bipartvar</i>?</dt>
  <dd>This command takes the graph <i>g</i> and returns a boolean value
      indicating whether it is bipartite (<b>true</b>) or not (<b>false</b>). If
      the variable <i>bipartvar</i> is specified the two partitions of the graph
      are there as a list, if, and only if the graph is bipartit. If it is not
      the variable, if specified, is not touched.</dd>
  <dt><b>struct::graph:op::tarjan</b> <i>g</i></dt>
  <dd>This command computes the set of <i>strongly connected</i> components
      (SCCs) of the graph <i>g</i>. The result of the command is a list of sets,
      each of which contains the nodes for one of the SCCs of <i>g</i>. The
      union of all SCCs covers the whole graph, and no two SCCs intersect with
      each other.
    <p class="Pp">The graph <i>g</i> is <i>acyclic</i> if all SCCs in the result
        contain only a single node. The graph <i>g</i> is <i>strongly
        connected</i> if the result contains only a single SCC containing all
        nodes of <i>g</i>.</p>
  </dd>
  <dt><b>struct::graph:op::connectedComponents</b> <i>g</i></dt>
  <dd>This command computes the set of <i>connected</i> components (CCs) of the
      graph <i>g</i>. The result of the command is a list of sets, each of which
      contains the nodes for one of the CCs of <i>g</i>. The union of all CCs
      covers the whole graph, and no two CCs intersect with each other.
    <p class="Pp">The graph <i>g</i> is <i>connected</i> if the result contains
        only a single SCC containing all nodes of <i>g</i>.</p>
  </dd>
  <dt><b>struct::graph:op::connectedComponentOf</b> <i>g</i> <i>n</i></dt>
  <dd>This command computes the <i>connected</i> component (CC) of the graph
      <i>g</i> containing the node <i>n</i>. The result of the command is a sets
      which contains the nodes for the CC of <i>n</i> in <i>g</i>.
    <p class="Pp">The command will throw an error if <i>n</i> is not a node of
        the graph <i>g</i>.</p>
  </dd>
  <dt><b>struct::graph:op::isConnected?</b> <i>g</i></dt>
  <dd>This is a convenience command determining whether the graph <i>g</i> is
      <i>connected</i> or not. The result is a boolean value, <b>true</b> if the
      graph is connected, and <b>false</b> otherwise.</dd>
  <dt><b>struct::graph:op::isCutVertex?</b> <i>g</i> <i>n</i></dt>
  <dd>This command determines whether the node <i>n</i> in the graph <i>g</i> is
      a <i>cut vertex</i> (aka <i>articulation point</i>). The result is a
      boolean value, <b>true</b> if the node is a cut vertex, and <b>false</b>
      otherwise.
    <p class="Pp">The command will throw an error if <i>n</i> is not a node of
        the graph <i>g</i>.</p>
  </dd>
  <dt><b>struct::graph:op::isBridge?</b> <i>g</i> <i>a</i></dt>
  <dd>This command determines whether the arc <i>a</i> in the graph <i>g</i> is
      a <i>bridge</i> (aka <i>cut edge</i>, or <i>isthmus</i>). The result is a
      boolean value, <b>true</b> if the arc is a bridge, and <b>false</b>
      otherwise.
    <p class="Pp">The command will throw an error if <i>a</i> is not an arc of
        the graph <i>g</i>.</p>
  </dd>
  <dt><b>struct::graph:op::isEulerian?</b> <i>g</i> ?<i>tourvar</i>?</dt>
  <dd>This command determines whether the graph <i>g</i> is <i>eulerian</i> or
      not. The result is a boolean value, <b>true</b> if the graph is eulerian,
      and <b>false</b> otherwise.
    <p class="Pp">If the graph is eulerian and <i>tourvar</i> is specified then
        an euler tour is computed as well and stored in the named variable. The
        tour is represented by the list of arcs traversed, in the order of
        traversal.</p>
  </dd>
  <dt><b>struct::graph:op::isSemiEulerian?</b> <i>g</i> ?<i>pathvar</i>?</dt>
  <dd>This command determines whether the graph <i>g</i> is <i>semi-eulerian</i>
      or not. The result is a boolean value, <b>true</b> if the graph is
      semi-eulerian, and <b>false</b> otherwise.
    <p class="Pp">If the graph is semi-eulerian and <i>pathvar</i> is specified
        then an euler path is computed as well and stored in the named variable.
        The path is represented by the list of arcs traversed, in the order of
        traversal.</p>
  </dd>
  <dt><b>struct::graph:op::dijkstra</b> <i>g</i> <i>start</i>
    ?<i>options</i>...?</dt>
  <dd>This command determines distances in the weighted <i>g</i> from the node
      <i>start</i> to all other nodes in the graph. The options specify how to
      traverse graphs, and the format of the result.
    <p class="Pp">Two options are recognized</p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>-arcmode</b> mode</dt>
  <dd>The accepted mode values are <b>directed</b> and <b>undirected</b>. For
      directed traversal all arcs are traversed from source to target. For
      undirected traversal all arcs are traversed in the opposite direction as
      well. Undirected traversal is the default.</dd>
  <dt><b>-outputformat</b> format</dt>
  <dd>The accepted format values are <b>distances</b> and <b>tree</b>. In both
      cases the result is a dictionary keyed by the names of all nodes in the
      graph. For <b>distances</b> the value is the distance of the node to
      <i>start</i>, whereas for <b>tree</b> the value is the path from the node
      to <i>start</i>, excluding the node itself, but including <i>start</i>.
      Tree format is the default.</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt><b>struct::graph:op::distance</b> <i>g</i> <i>origin</i>
    <i>destination</i> ?<i>options</i>...?</dt>
  <dd>This command determines the (un)directed distance between the two nodes
      <i>origin</i> and <i>destination</i> in the graph <i>g</i>. It accepts the
      option <b>-arcmode</b> of <b>struct::graph:op::dijkstra</b>.</dd>
  <dt><b>struct::graph:op::eccentricity</b> <i>g</i> <i>n</i>
    ?<i>options</i>...?</dt>
  <dd>This command determines the (un)directed <i>eccentricity</i> of the node
      <i>n</i> in the graph <i>g</i>. It accepts the option <b>-arcmode</b> of
      <b>struct::graph:op::dijkstra</b>.
    <p class="Pp">The (un)directed <i>eccentricity</i> of a node is the maximal
        (un)directed distance between the node and any other node in the
      graph.</p>
  </dd>
  <dt><b>struct::graph:op::radius</b> <i>g</i> ?<i>options</i>...?</dt>
  <dd>This command determines the (un)directed <i>radius</i> of the graph
      <i>g</i>. It accepts the option <b>-arcmode</b> of
      <b>struct::graph:op::dijkstra</b>.
    <p class="Pp">The (un)directed <i>radius</i> of a graph is the minimal
        (un)directed <i>eccentricity</i> of all nodes in the graph.</p>
  </dd>
  <dt><b>struct::graph:op::diameter</b> <i>g</i> ?<i>options</i>...?</dt>
  <dd>This command determines the (un)directed <i>diameter</i> of the graph
      <i>g</i>. It accepts the option <b>-arcmode</b> of
      <b>struct::graph:op::dijkstra</b>.
    <p class="Pp">The (un)directed <i>diameter</i> of a graph is the maximal
        (un)directed <i>eccentricity</i> of all nodes in the graph.</p>
  </dd>
  <dt><b>struct::graph::op::BellmanFord</b> <i>G</i> <i>startnode</i></dt>
  <dd>Searching for <b>shortests paths</b> between chosen node and all other
      nodes in graph <i>G</i>. Based on relaxation method. In comparison to
      <b>struct::graph::op::dijkstra</b> it doesn't need assumption that all
      weights on edges in input graph <i>G</i> have to be positive.
    <p class="Pp">That generality sets the complexity of algorithm to -
        <i>O(V*E)</i>, where <i>V</i> is the number of vertices and <i>E</i> is
        number of edges in graph <i>G</i>.</p>
    <p class="Pp"></p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>Arguments:</dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>Graph object <i>G</i> (input)</dt>
  <dd>Directed, connected and edge weighted graph <i>G</i>, without any negative
      cycles ( presence of cycles with the negative sum of weight means that
      there is no shortest path, since the total weight becomes lower each time
      the cycle is traversed ). Negative weights on edges are allowed.</dd>
  <dt>Node <i>startnode</i> (input)</dt>
  <dd>The node for which we find all shortest paths to each other node in graph
      <i>G</i>.</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt>Result:</dt>
  <dd>Dictionary containing for each node (key) distances to each other node in
      graph <i>G</i>.</dd>
</dl>
</div>
<p class="Pp"><i>Note:</i> If algorithm finds a negative cycle, it will return
    error message.</p>
<dl class="Bl-tag">
  <dt><b>struct::graph::op::Johnsons</b> <i>G</i> ?<i>options</i>...?</dt>
  <dd>Searching for <b>shortest paths</b> between all pairs of vertices in
      graph. For sparse graphs asymptotically quicker than
      <b>struct::graph::op::FloydWarshall</b> algorithm. Johnson's algorithm
      uses <b>struct::graph::op::BellmanFord</b> and
      <b>struct::graph::op::dijkstra</b> as subprocedures.
    <p class="Pp">Time complexity: <i>O(n**2*log(n) +n*m)</i>, where <i>n</i> is
        the number of nodes and <i>m</i> is the number of edges in graph
        <i>G</i>.</p>
    <p class="Pp"></p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>Arguments:</dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>Graph object <i>G</i> (input)</dt>
  <dd>Directed graph <i>G</i>, weighted on edges and not containing any cycles
      with negative sum of weights ( the presence of such cycles means there is
      no shortest path, since the total weight becomes lower each time the cycle
      is traversed ). Negative weights on edges are allowed.</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt>Options:</dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>-filter</b></dt>
  <dd>Returns only existing distances, cuts all <i>Inf</i> values for
      non-existing connections between pairs of nodes.</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt>Result:</dt>
  <dd>Dictionary containing distances between all pairs of vertices.</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt><b>struct::graph::op::FloydWarshall</b> <i>G</i></dt>
  <dd>Searching for <b>shortest paths</b> between all pairs of edges in weighted
      graphs.
    <p class="Pp">Time complexity: <i>O(V^3)</i> - where <i>V</i> is number of
        vertices.</p>
    <p class="Pp">Memory complexity: <i>O(V^2)</i>.</p>
    <p class="Pp"></p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>Arguments:</dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>Graph object <i>G</i> (input)</dt>
  <dd>Directed and weighted graph <i>G</i>.</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt>Result:</dt>
  <dd>Dictionary containing shortest distances to each node from each node.</dd>
</dl>
</div>
<i>Note:</i> Algorithm finds solutions dynamically. It compares all possible
  paths through the graph between each pair of vertices. Graph shouldn't possess
  any cycle with negative sum of weights (the presence of such cycles means
  there is no shortest path, since the total weight becomes lower each time the
  cycle is traversed).
<p class="Pp">On the other hand algorithm can be used to find those cycles - if
    any shortest distance found by algorithm for any nodes <i>v</i> and <i>u</i>
    (when <i>v</i> is the same node as <i>u</i>) is negative, that node surely
    belong to at least one negative cycle.</p>
<dl class="Bl-tag">
  <dt><b>struct::graph::op::MetricTravellingSalesman</b> <i>G</i></dt>
  <dd>Algorithm for solving a metric variation of <b>Travelling salesman
      problem</b>. <i>TSP problem</i> is <i>NP-Complete</i>, so there is no
      efficient algorithm to solve it. Greedy methods are getting extremely
      slow, with the increase in the set of nodes.
    <p class="Pp"></p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>Arguments:</dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>Graph object <i>G</i> (input)</dt>
  <dd>Undirected, weighted graph <i>G</i>.</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt>Result:</dt>
  <dd>Approximated solution of minimum <i>Hamilton Cycle</i> - closed path
      visiting all nodes, each exactly one time.</dd>
</dl>
</div>
<i>Note:</i> <b>It's 2-approximation algorithm.</b>
<dl class="Bl-tag">
  <dt><b>struct::graph::op::Christofides</b> <i>G</i></dt>
  <dd>Another algorithm for solving <b>metric </b><i>TSP problem</i>.
      Christofides implementation uses <i>Max Matching</i> for reaching better
      approximation factor.
    <p class="Pp"></p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>Arguments:</dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>Graph Object <i>G</i> (input)</dt>
  <dd>Undirected, weighted graph <i>G</i>.</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt>Result:</dt>
  <dd>Approximated solution of minimum <i>Hamilton Cycle</i> - closed path
      visiting all nodes, each exactly one time.</dd>
</dl>
</div>
<p class="Pp"><i>Note:</i> <b>It's is a 3/2 approximation algorithm. </b></p>
<dl class="Bl-tag">
  <dt><b>struct::graph::op::GreedyMaxMatching</b> <i>G</i></dt>
  <dd><i>Greedy Max Matching</i> procedure, which finds <b>maximal matching</b>
      (not maximum) for given graph <i>G</i>. It adds edges to solution,
      beginning from edges with the lowest cost.
    <p class="Pp"></p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>Arguments:</dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>Graph Object <i>G</i> (input)</dt>
  <dd>Undirected graph <i>G</i>.</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt>Result:</dt>
  <dd>Set of edges - the max matching for graph <i>G</i>.</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt><b>struct::graph::op::MaxCut</b> <i>G</i> <i>U</i> <i>V</i></dt>
  <dd>Algorithm solving a <b>Maximum Cut Problem</b>.
    <p class="Pp"></p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>Arguments:</dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>Graph Object <i>G</i> (input)</dt>
  <dd>The graph to cut.</dd>
  <dt>List <i>U</i> (output)</dt>
  <dd>Variable storing first set of nodes (cut) given by solution.</dd>
  <dt>List <i>V</i> (output)</dt>
  <dd>Variable storing second set of nodes (cut) given by solution.</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt>Result:</dt>
  <dd>Algorithm returns number of edges between found two sets of nodes.</dd>
</dl>
</div>
<i>Note:</i> <i>MaxCut</i> is a <b>2-approximation algorithm.</b>
<dl class="Bl-tag">
  <dt><b>struct::graph::op::UnweightedKCenter</b> <i>G</i> <i>k</i></dt>
  <dd>Approximation algorithm that solves a <b>k-center problem</b>.
    <p class="Pp"></p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>Arguments:</dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>Graph Object <i>G</i> (input)</dt>
  <dd>Undirected complete graph <i>G</i>, which satisfies triangle inequality.
    <p class="Pp"></p>
  </dd>
  <dt>Integer <i>k</i> (input)</dt>
  <dd>Positive integer that sets the number of nodes that will be included in
      <i>k-center</i>.</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt>Result:</dt>
  <dd>Set of nodes - <i>k</i> center for graph <i>G</i>.</dd>
</dl>
</div>
<i>Note:</i> <i>UnweightedKCenter</i> is a <b>2-approximation algorithm.</b>
<dl class="Bl-tag">
  <dt><b>struct::graph::op::WeightedKCenter</b> <i>G</i> <i>nodeWeights</i>
    <i>W</i></dt>
  <dd>Approximation algorithm that solves a weighted version of <b>k-center
      problem</b>.
    <p class="Pp"></p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>Arguments:</dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>Graph Object <i>G</i> (input)</dt>
  <dd>Undirected complete graph <i>G</i>, which satisfies triangle
    inequality.</dd>
  <dt>Integer <i>W</i> (input)</dt>
  <dd>Positive integer that sets the maximum possible weight of <i>k-center</i>
      found by algorithm.</dd>
  <dt>List <i>nodeWeights</i> (input)</dt>
  <dd>List of nodes and its weights in graph <i>G</i>.</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt>Result:</dt>
  <dd>Set of nodes, which is solution found by algorithm.</dd>
</dl>
</div>
<i>Note:</i><i>WeightedKCenter</i> is a <b>3-approximation algorithm.</b>
<dl class="Bl-tag">
  <dt><b>struct::graph::op::GreedyMaxIndependentSet</b> <i>G</i></dt>
  <dd>A <i>maximal independent set</i> is an <i>independent set</i> such that
      adding any other node to the set forces the set to contain an edge.
    <p class="Pp">Algorithm for input graph <i>G</i> returns set of nodes
        (list), which are contained in Max Independent Set found by
      algorithm.</p>
  </dd>
  <dt><b>struct::graph::op::GreedyWeightedMaxIndependentSet</b> <i>G</i>
    <i>nodeWeights</i></dt>
  <dd>Weighted variation of <i>Maximal Independent Set</i>. It takes as an input
      argument not only graph <i>G</i> but also set of weights for all vertices
      in graph <i>G</i>.
    <p class="Pp"><i>Note:</i> Read also <i>Maximal Independent Set</i>
        description for more info.</p>
  </dd>
  <dt><b>struct::graph::op::VerticesCover</b> <i>G</i></dt>
  <dd><i>Vertices cover</i> is a set of vertices such that each edge of the
      graph is incident to at least one vertex of the set. This 2-approximation
      algorithm searches for minimum <i>vertices cover</i>, which is a classical
      optimization problem in computer science and is a typical example of an
      <i>NP-hard</i> optimization problem that has an approximation algorithm.
      For input graph <i>G</i> algorithm returns the set of edges (list), which
      is Vertex Cover found by algorithm.</dd>
  <dt><b>struct::graph::op::EdmondsKarp</b> <i>G</i> <i>s</i> <i>t</i></dt>
  <dd>Improved Ford-Fulkerson's algorithm, computing the <b>maximum flow</b> in
      given flow network <i>G</i>.
    <p class="Pp"></p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>Arguments:</dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>Graph Object <i>G</i> (input)</dt>
  <dd>Weighted and directed graph. Each edge should have set integer attribute
      considered as maximum throughputs that can be carried by that link
    (edge).</dd>
  <dt>Node <i>s</i> (input)</dt>
  <dd>The node that is a source for graph <i>G</i>.</dd>
  <dt>Node <i>t</i> (input)</dt>
  <dd>The node that is a sink for graph <i>G</i>.</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt>Result:</dt>
  <dd>Procedure returns the dictionary containing throughputs for all edges. For
      each key ( the edge between nodes <i>u</i> and <i>v</i> in the form of
      <i>list u v</i> ) there is a value that is a throughput for that key.
      Edges where throughput values are equal to 0 are not returned ( it is like
      there was no link in the flow network between nodes connected by such
      edge).</dd>
</dl>
</div>
<p class="Pp">The general idea of algorithm is finding the shortest augumenting
    paths in graph <i>G</i>, as long as they exist, and for each path updating
    the edge's weights along that path, with maximum possible throughput. The
    final (maximum) flow is found when there is no other augumenting path from
    source to sink.</p>
<p class="Pp"><i>Note:</i> Algorithm complexity : <i>O(V*E)</i>, where <i>V</i>
    is the number of nodes and <i>E</i> is the number of edges in graph
    <i>G</i>.</p>
<dl class="Bl-tag">
  <dt><b>struct::graph::op::BusackerGowen</b> <i>G</i> <i>desiredFlow</i>
    <i>s</i> <i>t</i></dt>
  <dd>Algorithm finds solution for a <b>minimum cost flow problem</b>. So, the
      goal is to find a flow, whose max value can be <i>desiredFlow</i>, from
      source node <i>s</i> to sink node <i>t</i> in given flow network <i>G</i>.
      That network except throughputs at edges has also defined a non-negative
      cost on each edge - cost of using that edge when directing flow with that
      edge ( it can illustrate e.g. fuel usage, time or any other measure
      dependent on usages ).
    <p class="Pp"></p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>Arguments:</dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>Graph Object <i>G</i> (input)</dt>
  <dd>Flow network (directed graph), each edge in graph should have two integer
      attributes: <i>cost</i> and <i>throughput</i>.</dd>
  <dt>Integer <i>desiredFlow</i> (input)</dt>
  <dd>Max value of the flow for that network.</dd>
  <dt>Node <i>s</i> (input)</dt>
  <dd>The source node for graph <i>G</i>.</dd>
  <dt>Node <i>t</i> (input)</dt>
  <dd>The sink node for graph <i>G</i>.</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt>Result:</dt>
  <dd>Dictionary containing values of used throughputs for each edge ( key ).
      found by algorithm.</dd>
</dl>
</div>
<i>Note:</i> Algorithm complexity : <i>O(V**2*desiredFlow)</i>, where <i>V</i>
  is the number of nodes in graph <i>G</i>.
<dl class="Bl-tag">
  <dt><b>struct::graph::op::ShortestsPathsByBFS</b> <i>G</i> <i>s</i>
    <i>outputFormat</i></dt>
  <dd>Shortest pathfinding algorithm using BFS method. In comparison to
      <b>struct::graph::op::dijkstra</b> it can work with negative weights on
      edges. Of course negative cycles are not allowed. Algorithm is better than
      dijkstra for sparse graphs, but also there exist some pathological cases
      (those cases generally don't appear in practise) that make time complexity
      increase exponentially with the growth of the number of nodes.
    <p class="Pp"></p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>Arguments:</dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>Graph Object <i>G</i> (input)</dt>
  <dd>Input graph.</dd>
  <dt>Node <i>s</i> (input)</dt>
  <dd>Source node for which all distances to each other node in graph <i>G</i>
      are computed.</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt>Options and result:</dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>distances</b></dt>
  <dd>When selected <i>outputFormat</i> is <b>distances</b> - procedure returns
      dictionary containing distances between source node <i>s</i> and each
      other node in graph <i>G</i>.</dd>
  <dt><b>paths</b></dt>
  <dd>When selected <i>outputFormat</i> is <b>paths</b> - procedure returns
      dictionary containing for each node <i>v</i>, a list of nodes, which is a
      path between source node <i>s</i> and node <i>v</i>.</dd>
</dl>
</div>
</div>
<dl class="Bl-tag">
  <dt><b>struct::graph::op::BFS</b> <i>G</i> <i>s</i>
    ?<i>outputFormat</i>...?</dt>
  <dd>Breadth-First Search - algorithm creates the BFS Tree. Memory and time
      complexity: <i>O(V + E)</i>, where <i>V</i> is the number of nodes and
      <i>E</i> is number of edges.
    <p class="Pp"></p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>Arguments:</dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>Graph Object <i>G</i> (input)</dt>
  <dd>Input graph.</dd>
  <dt>Node <i>s</i> (input)</dt>
  <dd>Source node for BFS procedure.</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt>Options and result:</dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>graph</b></dt>
  <dd>When selected <b>outputFormat</b> is <b>graph</b> - procedure returns a
      graph structure (<b>struct::graph</b>), which is equivalent to BFS tree
      found by algorithm.</dd>
  <dt><b>tree</b></dt>
  <dd>When selected <b>outputFormat</b> is <b>tree</b> - procedure returns a
      tree structure (<b>struct::tree</b>), which is equivalent to BFS tree
      found by algorithm.</dd>
</dl>
</div>
</div>
<dl class="Bl-tag">
  <dt><b>struct::graph::op::MinimumDiameterSpanningTree</b> <i>G</i></dt>
  <dd>The goal is to find for input graph <i>G</i>, the <i>spanning tree</i>
      that has the minimum <i>diameter</i> value.
    <p class="Pp">General idea of algorithm is to run <i>BFS</i> over all
        vertices in graph <i>G</i>. If the diameter <i>d</i> of the tree is odd,
        then we are sure that tree given by <i>BFS</i> is minimum (considering
        diameter value). When, diameter <i>d</i> is even, then optimal tree can
        have minimum <i>diameter</i> equal to <i>d</i> or <i>d-1</i>.</p>
    <p class="Pp">In that case, what algorithm does is rebuilding the tree given
        by <i>BFS</i>, by adding a vertice between root node and root's child
        node (nodes), such that subtree created with child node as root node is
        the greatest one (has the greatests height). In the next step for such
        rebuilded tree, we run again <i>BFS</i> with new node as root node. If
        the height of the tree didn't changed, we have found a better
      solution.</p>
    <p class="Pp">For input graph <i>G</i> algorithm returns the graph structure
        (<b>struct::graph</b>) that is a spanning tree with minimum diameter
        found by algorithm.</p>
  </dd>
  <dt><b>struct::graph::op::MinimumDegreeSpanningTree</b> <i>G</i></dt>
  <dd>Algorithm finds for input graph <i>G</i>, a spanning tree <i>T</i> with
      the minimum possible degree. That problem is <i>NP-hard</i>, so algorithm
      is an approximation algorithm.
    <p class="Pp">Let <i>V</i> be the set of nodes for graph <i>G</i> and let
        <i>W</i> be any subset of <i>V</i>. Lets assume also that <i>OPT</i> is
        optimal solution and <i>ALG</i> is solution found by algorithm for input
        graph <i>G</i>.</p>
    <p class="Pp">It can be proven that solution found with the algorithm must
        fulfil inequality:</p>
    <p class="Pp"><i>((|W| + k - 1) / |W|) &lt;= ALG &lt;= 2*OPT + log2(n) +
        1</i>.</p>
    <p class="Pp"></p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>Arguments:</dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>Graph Object <i>G</i> (input)</dt>
  <dd>Undirected simple graph.</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt>Result:</dt>
  <dd>Algorithm returns graph structure, which is equivalent to spanning tree
      <i>T</i> found by algorithm.</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt><b>struct::graph::op::MaximumFlowByDinic</b> <i>G</i> <i>s</i> <i>t</i>
    <i>blockingFlowAlg</i></dt>
  <dd>Algorithm finds <b>maximum flow</b> for the flow network represented by
      graph <i>G</i>. It is based on the blocking-flow finding methods, which
      give us different complexities what makes a better fit for different
      graphs.
    <p class="Pp"></p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>Arguments:</dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>Graph Object <i>G</i> (input)</dt>
  <dd>Directed graph <i>G</i> representing the flow network. Each edge should
      have attribute <i>throughput</i> set with integer value.</dd>
  <dt>Node <i>s</i> (input)</dt>
  <dd>The source node for the flow network <i>G</i>.</dd>
  <dt>Node <i>t</i> (input)</dt>
  <dd>The sink node for the flow network <i>G</i>.</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt>Options:</dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>dinic</b></dt>
  <dd>Procedure will find maximum flow for flow network <i>G</i> using Dinic's
      algorithm (<b>struct::graph::op::BlockingFlowByDinic</b>) for blocking
      flow computation.</dd>
  <dt><b>mkm</b></dt>
  <dd>Procedure will find maximum flow for flow network <i>G</i> using Malhotra,
      Kumar and Maheshwari's algorithm
      (<b>struct::graph::op::BlockingFlowByMKM</b>) for blocking flow
      computation.</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt>Result:</dt>
  <dd>Algorithm returns dictionary containing it's flow value for each edge
      (key) in network <i>G</i>.</dd>
</dl>
</div>
<p class="Pp"><i>Note:</i> <b>struct::graph::op::BlockingFlowByDinic</b> gives
    <i>O(m*n^2)</i> complexity and <b>struct::graph::op::BlockingFlowByMKM</b>
    gives <i>O(n^3)</i> complexity, where <i>n</i> is the number of nodes and
    <i>m</i> is the number of edges in flow network <i>G</i>.</p>
<dl class="Bl-tag">
  <dt><b>struct::graph::op::BlockingFlowByDinic</b> <i>G</i> <i>s</i>
    <i>t</i></dt>
  <dd>Algorithm for given network <i>G</i> with source <i>s</i> and sink
      <i>t</i>, finds a <b>blocking</b> <b>flow</b>, which can be used to obtain
      a <i>maximum flow</i> for that network <i>G</i>.
    <p class="Pp"></p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>Arguments:</dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>Graph Object <i>G</i> (input)</dt>
  <dd>Directed graph <i>G</i> representing the flow network. Each edge should
      have attribute <i>throughput</i> set with integer value.</dd>
  <dt>Node <i>s</i> (input)</dt>
  <dd>The source node for the flow network <i>G</i>.</dd>
  <dt>Node <i>t</i> (input)</dt>
  <dd>The sink node for the flow network <i>G</i>.</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt>Result:</dt>
  <dd>Algorithm returns dictionary containing it's blocking flow value for each
      edge (key) in network <i>G</i>.</dd>
</dl>
</div>
<i>Note:</i> Algorithm's complexity is <i>O(n*m)</i>, where <i>n</i> is the
  number of nodes and <i>m</i> is the number of edges in flow network <i>G</i>.
<dl class="Bl-tag">
  <dt><b>struct::graph::op::BlockingFlowByMKM</b> <i>G</i> <i>s</i>
    <i>t</i></dt>
  <dd>Algorithm for given network <i>G</i> with source <i>s</i> and sink
      <i>t</i>, finds a <b>blocking</b> <b>flow</b>, which can be used to obtain
      a <i>maximum flow</i> for that <i>network</i> <i>G</i>.
    <p class="Pp"></p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>Arguments:</dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>Graph Object <i>G</i> (input)</dt>
  <dd>Directed graph <i>G</i> representing the flow network. Each edge should
      have attribute <i>throughput</i> set with integer value.</dd>
  <dt>Node <i>s</i> (input)</dt>
  <dd>The source node for the flow network <i>G</i>.</dd>
  <dt>Node <i>t</i> (input)</dt>
  <dd>The sink node for the flow network <i>G</i>.</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt>Result:</dt>
  <dd>Algorithm returns dictionary containing it's blocking flow value for each
      edge (key) in network <i>G</i>.</dd>
</dl>
</div>
<i>Note:</i> Algorithm's complexity is <i>O(n^2)</i>, where <i>n</i> is the
  number of nodes in flow network <i>G</i>.
<dl class="Bl-tag">
  <dt><b>struct::graph::op::createResidualGraph</b> <i>G</i> <i>f</i></dt>
  <dd>Procedure creates a <i>residual graph</i> (or <b>residual network</b> )
      for network <i>G</i> and given flow <i>f</i>.
    <p class="Pp"></p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>Arguments:</dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>Graph Object <i>G</i> (input)</dt>
  <dd>Flow network (directed graph where each edge has set attribute:
      <i>throughput</i> ).</dd>
  <dt>dictionary <i>f</i> (input)</dt>
  <dd>Current flows in flow network <i>G</i>.</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt>Result:</dt>
  <dd>Procedure returns graph structure that is a <i>residual graph</i> created
      from input flow network <i>G</i>.</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt><b>struct::graph::op::createAugmentingNetwork</b> <i>G</i> <i>f</i>
    <i>path</i></dt>
  <dd>Procedure creates an <b>augmenting network</b> for a given residual
      network <i>G</i> , flow <i>f</i> and augmenting path <i>path</i>.
    <p class="Pp"></p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>Arguments:</dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>Graph Object <i>G</i> (input)</dt>
  <dd>Residual network (directed graph), where for every edge there are set two
      attributes: throughput and cost.</dd>
  <dt>Dictionary <i>f</i> (input)</dt>
  <dd>Dictionary which contains for every edge (key), current value of the flow
      on that edge.</dd>
  <dt>List <i>path</i> (input)</dt>
  <dd>Augmenting path, set of edges (list) for which we create the network
      modification.</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt>Result:</dt>
  <dd>Algorithm returns graph structure containing the modified augmenting
      network.</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt><b>struct::graph::op::createLevelGraph</b> <i>Gf</i> <i>s</i></dt>
  <dd>For given residual graph <i>Gf</i> procedure finds the <b>level graph</b>.
    <p class="Pp"></p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>Arguments:</dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>Graph Object <i>Gf</i> (input)</dt>
  <dd>Residual network, where each edge has it's attribute <i>throughput</i> set
      with certain value.</dd>
  <dt>Node <i>s</i> (input)</dt>
  <dd>The source node for the residual network <i>Gf</i>.</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt>Result:</dt>
  <dd>Procedure returns a <i>level graph</i> created from input <i>residual
      network</i>.</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt><b>struct::graph::op::TSPLocalSearching</b> <i>G</i> <i>C</i></dt>
  <dd>Algorithm is a <i>heuristic of local searching</i> for <i>Travelling
      Salesman Problem</i>. For some solution of <i>TSP problem</i>, it checks
      if it's possible to find a better solution. As <i>TSP</i> is well known
      NP-Complete problem, so algorithm is a approximation algorithm (with 2
      approximation factor).
    <p class="Pp"></p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>Arguments:</dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>Graph Object <i>G</i> (input)</dt>
  <dd>Undirected and complete graph with attributes &quot;weight&quot; set on
      each single edge.</dd>
  <dt>List <i>C</i> (input)</dt>
  <dd>A list of edges being <i>Hamiltonian cycle</i>, which is solution of
      <i>TSP Problem</i> for graph <i>G</i>.</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt>Result:</dt>
  <dd>Algorithm returns the best solution for <i>TSP problem</i>, it was able to
      find.</dd>
</dl>
</div>
<i>Note:</i> The solution depends on the choosing of the beginning cycle
  <i>C</i>. It's not true that better cycle assures that better solution will be
  found, but practise shows that we should give starting cycle with as small sum
  of weights as possible.
<dl class="Bl-tag">
  <dt><b>struct::graph::op::TSPLocalSearching3Approx</b> <i>G</i> <i>C</i></dt>
  <dd>Algorithm is a <i>heuristic of local searching</i> for <i>Travelling
      Salesman Problem</i>. For some solution of <i>TSP problem</i>, it checks
      if it's possible to find a better solution. As <i>TSP</i> is well known
      NP-Complete problem, so algorithm is a approximation algorithm (with 3
      approximation factor).
    <p class="Pp"></p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>Arguments:</dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>Graph Object <i>G</i> (input)</dt>
  <dd>Undirected and complete graph with attributes &quot;weight&quot; set on
      each single edge.</dd>
  <dt>List <i>C</i> (input)</dt>
  <dd>A list of edges being <i>Hamiltonian cycle</i>, which is solution of
      <i>TSP Problem</i> for graph <i>G</i>.</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt>Result:</dt>
  <dd>Algorithm returns the best solution for <i>TSP problem</i>, it was able to
      find.</dd>
</dl>
</div>
<i>Note:</i> In practise 3-approximation algorithm turns out to be far more
  effective than 2-approximation, but it gives worser approximation factor.
  Further heuristics of local searching (e.g. 4-approximation) doesn't give
  enough boost to square the increase of approximation factor, so 2 and 3
  approximations are mainly used.
<dl class="Bl-tag">
  <dt><b>struct::graph::op::createSquaredGraph</b> <i>G</i></dt>
  <dd>X-Squared graph is a graph with the same set of nodes as input graph
      <i>G</i>, but a different set of edges. X-Squared graph has edge
      <i>(u,v)</i>, if and only if, the distance between <i>u</i> and <i>v</i>
      nodes is not greater than X and <i>u != v</i>.
    <p class="Pp">Procedure for input graph <i>G</i>, returns its two-squared
        graph.</p>
    <p class="Pp"><i>Note:</i> Distances used in choosing new set of edges are
        considering the number of edges, not the sum of weights at edges.</p>
  </dd>
  <dt><b>struct::graph::op::createCompleteGraph</b> <i>G</i>
    <i>originalEdges</i></dt>
  <dd>For input graph <i>G</i> procedure adds missing arcs to make it a
      <i>complete graph</i>. It also holds in variable <i>originalEdges</i> the
      set of arcs that graph <i>G</i> possessed before that operation.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="BACKGROUND_THEORY_AND_TERMS"><a class="permalink" href="#BACKGROUND_THEORY_AND_TERMS">BACKGROUND
  THEORY AND TERMS</a></h1>
<section class="Ss">
<h2 class="Ss" id="SHORTEST_PATH_PROBLEM"><a class="permalink" href="#SHORTEST_PATH_PROBLEM">SHORTEST
  PATH PROBLEM</a></h2>
<dl class="Bl-tag">
  <dt>Definition (<i>single-pair shortest path problem</i>):</dt>
  <dd>Formally, given a weighted graph (let <i>V</i> be the set of vertices, and
      <i>E</i> a set of edges), and one vertice <i>v</i> of <i>V</i>, find a
      path <i>P</i> from <i>v</i> to a <i>v'</i> of V so that the sum of weights
      on edges along the path is minimal among all paths connecting v to
    v'.</dd>
  <dt>Generalizations:</dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<ul class="Bl-bullet">
  <li><i>The single-source shortest path problem</i>, in which we have to find
      shortest paths from a source vertex v to all other vertices in the
    graph.</li>
  <li><i>The single-destination shortest path problem</i>, in which we have to
      find shortest paths from all vertices in the graph to a single destination
      vertex v. This can be reduced to the single-source shortest path problem
      by reversing the edges in the graph.</li>
  <li><i>The all-pairs shortest path problem</i>, in which we have to find
      shortest paths between every pair of vertices v, v' in the graph.</li>
</ul>
</div>
<i>Note:</i> The result of <i>Shortest Path problem</i> can be <i>Shortest Path
  tree</i>, which is a subgraph of a given (possibly weighted) graph constructed
  so that the distance between a selected root node and all other nodes is
  minimal. It is a tree because if there are two paths between the root node and
  some vertex v (i.e. a cycle), we can delete the last edge of the longer path
  without increasing the distance from the root node to any node in the
  subgraph.
</section>
<section class="Ss">
<h2 class="Ss" id="TRAVELLING_SALESMAN_PROBLEM"><a class="permalink" href="#TRAVELLING_SALESMAN_PROBLEM">TRAVELLING
  SALESMAN PROBLEM</a></h2>
<dl class="Bl-tag">
  <dt>Definition:</dt>
  <dd>For given edge-weighted (weights on edges should be positive) graph the
      goal is to find the cycle that visits each node in graph exactly once
      (<i>Hamiltonian cycle</i>).</dd>
  <dt>Generalizations:</dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<ul class="Bl-bullet">
  <li><i>Metric TSP</i> - A very natural restriction of the <i>TSP</i> is to
      require that the distances between cities form a <i>metric</i>, i.e., they
      satisfy <i>the triangle inequality</i>. That is, for any 3 cities
      <i>A</i>, <i>B</i> and <i>C</i>, the distance between <i>A</i> and
      <i>C</i> must be at most the distance from <i>A</i> to <i>B</i> plus the
      distance from <i>B</i> to <i>C</i>. Most natural instances of <i>TSP</i>
      satisfy this constraint.</li>
  <li><i>Euclidean TSP</i> - Euclidean TSP, or <i>planar TSP</i>, is the
      <i>TSP</i> with the distance being the ordinary <i>Euclidean distance</i>.
      <i>Euclidean TSP</i> is a particular case of <i>TSP</i> with <i>triangle
      inequality</i>, since distances in plane obey triangle inequality.
      However, it seems to be easier than general <i>TSP</i> with <i>triangle
      inequality</i>. For example, <i>the minimum spanning tree</i> of the graph
      associated with an instance of <i>Euclidean TSP</i> is a <i>Euclidean
      minimum spanning tree</i>, and so can be computed in expected <i>O(n log
      n)</i> time for <i>n</i> points (considerably less than the number of
      edges). This enables the simple <i>2-approximation algorithm</i> for TSP
      with triangle inequality above to operate more quickly.</li>
  <li><i>Asymmetric TSP</i> - In most cases, the distance between two nodes in
      the <i>TSP</i> network is the same in both directions. The case where the
      distance from <i>A</i> to <i>B</i> is not equal to the distance from
      <i>B</i> to <i>A</i> is called <i>asymmetric TSP</i>. A practical
      application of an <i>asymmetric TSP</i> is route optimisation using
      street-level routing (asymmetric due to one-way streets, slip-roads and
      motorways).</li>
</ul>
</div>
</section>
<section class="Ss">
<h2 class="Ss" id="MATCHING_PROBLEM"><a class="permalink" href="#MATCHING_PROBLEM">MATCHING
  PROBLEM</a></h2>
<dl class="Bl-tag">
  <dt>Definition:</dt>
  <dd>Given a graph <i>G = (V,E)</i>, a matching or <i>edge-independent set</i>
      <i>M</i> in <i>G</i> is a set of pairwise non-adjacent edges, that is, no
      two edges share a common vertex. A vertex is <i>matched</i> if it is
      incident to an edge in the <i>matching M</i>. Otherwise the vertex is
      <i>unmatched</i>.</dd>
  <dt>Generalizations:</dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<ul class="Bl-bullet">
  <li><i>Maximal matching</i> - a matching <i>M</i> of a graph G with the
      property that if any edge not in <i>M</i> is added to <i>M</i>, it is no
      longer a <i>matching</i>, that is, <i>M</i> is maximal if it is not a
      proper subset of any other <i>matching</i> in graph G. In other words, a
      <i>matching M</i> of a graph G is maximal if every edge in G has a
      non-empty intersection with at least one edge in <i>M</i>.</li>
  <li><i>Maximum matching</i> - a matching that contains the largest possible
      number of edges. There may be many <i>maximum matchings</i>. The
      <i>matching number</i> of a graph G is the size of a <i>maximum
      matching</i>. Note that every <i>maximum matching</i> is <i>maximal</i>,
      but not every <i>maximal matching</i> is a <i>maximum matching</i>.</li>
  <li><i>Perfect matching</i> - a matching which matches all vertices of the
      graph. That is, every vertex of the graph is incident to exactly one edge
      of the matching. Every <i>perfect matching</i> is <i>maximum</i> and hence
      <i>maximal</i>. In some literature, the term <i>complete matching</i> is
      used. A <i>perfect matching</i> is also a <i>minimum-size edge cover</i>.
      Moreover, the size of a <i>maximum matching</i> is no larger than the size
      of a <i>minimum edge cover</i>.</li>
  <li><i>Near-perfect matching</i> - a matching in which exactly one vertex is
      unmatched. This can only occur when the graph has an odd number of
      vertices, and such a <i>matching</i> must be <i>maximum</i>. If, for every
      vertex in a graph, there is a near-perfect matching that omits only that
      vertex, the graph is also called <i>factor-critical</i>.</li>
</ul>
</div>
<dl class="Bl-tag">
  <dt>Related terms:</dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<ul class="Bl-bullet">
  <li><i>Alternating path</i> - given a matching <i>M</i>, an <i>alternating
      path</i> is a path in which the edges belong alternatively to the matching
      and not to the matching.</li>
  <li><i>Augmenting path</i> - given a matching <i>M</i>, an <i>augmenting
      path</i> is an <i>alternating path</i> that starts from and ends on free
      (unmatched) vertices.</li>
</ul>
</div>
</section>
<section class="Ss">
<h2 class="Ss" id="CUT_PROBLEMS"><a class="permalink" href="#CUT_PROBLEMS">CUT
  PROBLEMS</a></h2>
<dl class="Bl-tag">
  <dt>Definition:</dt>
  <dd>A <i>cut</i> is a partition of the vertices of a graph into two
      <i>disjoint subsets</i>. The <i>cut-set</i> of the <i>cut</i> is the set
      of edges whose end points are in different subsets of the partition. Edges
      are said to be crossing the cut if they are in its <i>cut-set</i>.
    <p class="Pp">Formally:</p>
  </dd>
</dl>
<div class="Bd-indent">
<ul class="Bl-bullet">
  <li>a <i>cut</i> <i>C = (S,T)</i> is a partition of <i>V</i> of a graph <i>G =
      (V, E)</i>.</li>
  <li>an <i>s-t cut</i> <i>C = (S,T)</i> of a <i>flow network</i> <i>N = (V,
      E)</i> is a cut of <i>N</i> such that <i>s</i> is included in <i>S</i> and
      <i>t</i> is included in <i>T</i>, where <i>s</i> and <i>t</i> are the
      <i>source</i> and the <i>sink</i> of <i>N</i> respectively.</li>
  <li>The <i>cut-set</i> of a <i>cut C = (S,T)</i> is such set of edges from
      graph <i>G = (V, E)</i> that each edge <i>(u, v)</i> satisfies condition
      that <i>u</i> is included in <i>S</i> and <i>v</i> is included in
      <i>T</i>.</li>
</ul>
</div>
<p class="Pp">In an <i>unweighted undirected</i> graph, the size or weight of a
    cut is the number of edges crossing the cut. In a <i>weighted graph</i>, the
    same term is defined by the sum of the weights of the edges crossing the
    cut.</p>
<p class="Pp">In a <i>flow network</i>, an <i>s-t cut</i> is a cut that requires
    the <i>source</i> and the <i>sink</i> to be in different subsets, and its
    <i>cut-set</i> only consists of edges going from the <i>source's</i> side to
    the <i>sink's</i> side. The capacity of an <i>s-t cut</i> is defined by the
    sum of capacity of each edge in the <i>cut-set</i>.</p>
<p class="Pp">The <i>cut</i> of a graph can sometimes refer to its
    <i>cut-set</i> instead of the partition.</p>
<dl class="Bl-tag">
  <dt>Generalizations:</dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<ul class="Bl-bullet">
  <li><i>Minimum cut</i> - A cut is minimum if the size of the cut is not larger
      than the size of any other cut.</li>
  <li><i>Maximum cut</i> - A cut is maximum if the size of the cut is not
      smaller than the size of any other cut.</li>
  <li><i>Sparsest cut</i> - The <i>Sparsest cut problem</i> is to bipartition
      the vertices so as to minimize the ratio of the number of edges across the
      cut divided by the number of vertices in the smaller half of the
      partition.</li>
</ul>
</div>
</section>
<section class="Ss">
<h2 class="Ss" id="K-CENTER_PROBLEM"><a class="permalink" href="#K-CENTER_PROBLEM">K-CENTER
  PROBLEM</a></h2>
<dl class="Bl-tag">
  <dt>Definitions:</dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><i>Unweighted K-Center</i></dt>
  <dd>For any set <i>S</i> ( which is subset of <i>V</i> ) and node <i>v</i>,
      let the <i>connect(v,S)</i> be the cost of cheapest edge connecting
      <i>v</i> with any node in <i>S</i>. The goal is to find such <i>S</i>,
      that <i>|S| = k</i> and <i>max_v{connect(v,S)}</i> is possibly small.
    <p class="Pp">In other words, we can use it i.e. for finding best locations
        in the city ( nodes of input graph ) for placing k buildings, such that
        those buildings will be as close as possible to all other locations in
        town.</p>
    <p class="Pp"></p>
  </dd>
  <dt><i>Weighted K-Center</i></dt>
  <dd>The variation of <i>unweighted k-center problem</i>. Besides the fact
      graph is edge-weighted, there are also weights on vertices of input graph
      <i>G</i>. We've got also restriction <i>W</i>. The goal is to choose such
      set of nodes <i>S</i> ( which is a subset of <i>V</i> ), that it's total
      weight is not greater than <i>W</i> and also function: <i>max_v { min_u {
      cost(u,v) }}</i> has the smallest possible worth ( <i>v</i> is a node in
      <i>V</i> and <i>u</i> is a node in <i>S</i> ).</dd>
</dl>
</div>
</section>
<section class="Ss">
<h2 class="Ss" id="FLOW_PROBLEMS"><a class="permalink" href="#FLOW_PROBLEMS">FLOW
  PROBLEMS</a></h2>
<dl class="Bl-tag">
  <dt>Definitions:</dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>&#x2022;</dt>
  <dd><i>the maximum flow problem</i> - the goal is to find a feasible flow
      through a single-source, single-sink flow network that is maximum. The
      <i>maximum flow problem</i> can be seen as a special case of more complex
      network flow problems, such as the <i>circulation problem</i>. The maximum
      value of an <i>s-t flow</i> is equal to the minimum capacity of an <i>s-t
      cut</i> in the network, as stated in the <i>max-flow min-cut theorem</i>.
    <p class="Pp">More formally for flow network <i>G = (V,E)</i>, where for
        each edge <i>(u, v)</i> we have its throuhgput <i>c(u,v)</i> defined. As
        <i>flow</i> <i>F</i> we define set of non-negative integer attributes
        <i>f(u,v)</i> assigned to edges, satisfying such conditions:</p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>[1]</dt>
  <dd>for each edge <i>(u, v)</i> in <i>G</i> such condition should be
      satisfied: 0 &lt;= f(u,v) &lt;= c(u,v)</dd>
  <dt>[2]</dt>
  <dd>Network <i>G</i> has source node <i>s</i> such that the flow <i>F</i> is
      equal to the sum of outcoming flow decreased by the sum of incoming flow
      from that source node <i>s</i>.</dd>
  <dt>[3]</dt>
  <dd>Network <i>G</i> has sink node <i>t</i> such that the the <i>-F</i> value
      is equal to the sum of the incoming flow decreased by the sum of outcoming
      flow from that sink node <i>t</i>.</dd>
  <dt>[4]</dt>
  <dd>For each node that is not a <i>source</i> or <i>sink</i> the sum of
      incoming flow and sum of outcoming flow should be equal.</dd>
</dl>
</div>
<ul class="Bl-bullet">
  <li><i>the minimum cost flow problem</i> - the goal is finding the cheapest
      possible way of sending a certain amount of flow through a <i>flow
      network</i>.</li>
  <li><i>blocking flow</i> - a <i>blocking flow</i> for a <i>residual
      network</i> <i>Gf</i> we name such flow <i>b</i> in <i>Gf</i> that:</li>
</ul>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>[1]</dt>
  <dd>Each path from <i>sink</i> to <i>source</i> is the shortest path in
      <i>Gf</i>.</dd>
  <dt>[2]</dt>
  <dd>Each shortest path in <i>Gf</i> contains an edge with fully used
      throughput in <i>Gf+b</i>.</dd>
</dl>
</div>
<ul class="Bl-bullet">
  <li><i>residual network</i> - for a flow network <i>G</i> and flow <i>f</i>
      <i>residual network</i> is built with those edges, which can send larger
      flow. It contains only those edges, which can send flow larger than
    0.</li>
  <li><i>level network</i> - it has the same set of nodes as <i>residual
      graph</i>, but has only those edges <i>(u,v)</i> from <i>Gf</i> for which
      such equality is satisfied: <i>distance(s,u)+1 = distance(s,v)</i>.</li>
  <li><i>augmenting network</i> - it is a modification of <i>residual
      network</i> considering the new flow values. Structure stays unchanged but
      values of throughputs and costs at edges are different.</li>
</ul>
</div>
</section>
<section class="Ss">
<h2 class="Ss" id="APPROXIMATION_ALGORITHM"><a class="permalink" href="#APPROXIMATION_ALGORITHM">APPROXIMATION
  ALGORITHM</a></h2>
<dl class="Bl-tag">
  <dt>k-approximation algorithm:</dt>
  <dd>Algorithm is a k-approximation, when for <i>ALG</i> (solution returned by
      algorithm) and <i>OPT</i> (optimal solution), such inequality is
    true:</dd>
</dl>
<div class="Bd-indent">
<ul class="Bl-bullet">
  <li>for minimalization problems: <i>ALG/OPT &lt;= k</i></li>
  <li>for maximalization problems: <i>OPT/ALG &lt;= k</i></li>
</ul>
</div>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="REFERENCES"><a class="permalink" href="#REFERENCES">REFERENCES</a></h1>
<dl class="Bl-tag">
  <dt>[1]</dt>
  <dd><i>Adjacency matrix</i>
    [http://en.wikipedia.org/wiki/Adjacency_matrix]</dd>
  <dt>[2]</dt>
  <dd><i>Adjacency list</i> [http://en.wikipedia.org/wiki/Adjacency_list]</dd>
  <dt>[3]</dt>
  <dd><i>Kruskal's algorithm</i>
      [http://en.wikipedia.org/wiki/Kruskal%27s_algorithm]</dd>
  <dt>[4]</dt>
  <dd><i>Prim's algorithm</i>
    [http://en.wikipedia.org/wiki/Prim%27s_algorithm]</dd>
  <dt>[5]</dt>
  <dd><i>Bipartite graph</i> [http://en.wikipedia.org/wiki/Bipartite_graph]</dd>
  <dt>[6]</dt>
  <dd><i>Strongly connected components</i>
      [http://en.wikipedia.org/wiki/Strongly_connected_components]</dd>
  <dt>[7]</dt>
  <dd><i>Tarjan's strongly connected components algorithm</i>
      [http://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm]</dd>
  <dt>[8]</dt>
  <dd><i>Cut vertex</i> [http://en.wikipedia.org/wiki/Cut_vertex]</dd>
  <dt>[9]</dt>
  <dd><i>Bridge</i> [http://en.wikipedia.org/wiki/Bridge_(graph_theory)]</dd>
  <dt>[10]</dt>
  <dd><i>Bellman-Ford's algorithm</i>
      [http://en.wikipedia.org/wiki/Bellman-Ford_algorithm]</dd>
  <dt>[11]</dt>
  <dd><i>Johnson's algorithm</i>
      [http://en.wikipedia.org/wiki/Johnson_algorithm]</dd>
  <dt>[12]</dt>
  <dd><i>Floyd-Warshall's algorithm</i>
      [http://en.wikipedia.org/wiki/Floyd-Warshall_algorithm]</dd>
  <dt>[13]</dt>
  <dd><i>Travelling Salesman Problem</i>
      [http://en.wikipedia.org/wiki/Travelling_salesman_problem]</dd>
  <dt>[14]</dt>
  <dd><i>Christofides Algorithm</i>
      [http://en.wikipedia.org/wiki/Christofides_algorithm]</dd>
  <dt>[15]</dt>
  <dd><i>Max Cut</i> [http://en.wikipedia.org/wiki/Maxcut]</dd>
  <dt>[16]</dt>
  <dd><i>Matching</i> [http://en.wikipedia.org/wiki/Matching]</dd>
  <dt>[17]</dt>
  <dd><i>Max Independent Set</i>
      [http://en.wikipedia.org/wiki/Maximal_independent_set]</dd>
  <dt>[18]</dt>
  <dd><i>Vertex Cover</i>
    [http://en.wikipedia.org/wiki/Vertex_cover_problem]</dd>
  <dt>[19]</dt>
  <dd><i>Ford-Fulkerson's algorithm</i>
      [http://en.wikipedia.org/wiki/Ford-Fulkerson_algorithm]</dd>
  <dt>[20]</dt>
  <dd><i>Maximum Flow problem</i>
      [http://en.wikipedia.org/wiki/Maximum_flow_problem]</dd>
  <dt>[21]</dt>
  <dd><i>Busacker-Gowen's algorithm</i>
      [http://en.wikipedia.org/wiki/Minimum_cost_flow_problem]</dd>
  <dt>[22]</dt>
  <dd><i>Dinic's algorithm</i>
    [http://en.wikipedia.org/wiki/Dinic's_algorithm]</dd>
  <dt>[23]</dt>
  <dd><i>K-Center problem</i>
      [http://www.csc.kth.se/~viggo/wwwcompendium/node128.html]</dd>
  <dt>[24]</dt>
  <dd><i>BFS</i> [http://en.wikipedia.org/wiki/Breadth-first_search]</dd>
  <dt>[25]</dt>
  <dd><i>Minimum Degree Spanning Tree</i>
      [http://en.wikipedia.org/wiki/Degree-constrained_spanning_tree]</dd>
  <dt>[26]</dt>
  <dd><i>Approximation algorithm</i>
      [http://en.wikipedia.org/wiki/Approximation_algorithm]</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="BUGS,_IDEAS,_FEEDBACK"><a class="permalink" href="#BUGS,_IDEAS,_FEEDBACK">BUGS,
  IDEAS, FEEDBACK</a></h1>
This document, and the package it describes, will undoubtedly contain bugs and
  other problems. Please report such in the category <i>struct :: graph</i> of
  the <i>Tcllib SF Trackers</i>
  [http://sourceforge.net/tracker/?group_id=12883]. Please also report any ideas
  for enhancements you may have for either package and/or documentation.
</section>
<section class="Sh">
<h1 class="Sh" id="KEYWORDS"><a class="permalink" href="#KEYWORDS">KEYWORDS</a></h1>
adjacency list, adjacency matrix, adjacent, approximation algorithm, arc,
  articulation point, augmenting network, augmenting path, bfs, bipartite,
  blocking flow, bridge, complete graph, connected component, cut edge, cut
  vertex, degree, degree constrained spanning tree, diameter, dijkstra,
  distance, eccentricity, edge, flow network, graph, heuristic, independent set,
  isthmus, level graph, local searching, loop, matching, max cut, maximum flow,
  minimal spanning tree, minimum cost flow, minimum degree spanning tree,
  minimum diameter spanning tree, neighbour, node, radius, residual graph,
  shortest path, squared graph, strongly connected component, subgraph,
  travelling salesman, vertex, vertex cover
</section>
<section class="Sh">
<h1 class="Sh" id="CATEGORY"><a class="permalink" href="#CATEGORY">CATEGORY</a></h1>
Data structures
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT"><a class="permalink" href="#COPYRIGHT">COPYRIGHT</a></h1>
<pre>
Copyright (c) 2008 Alejandro Paz &lt;vidriloco@gmail.com&gt;
Copyright (c) 2008 (docs) Andreas Kupries &lt;andreas_kupries@users.sourceforge.net&gt;
Copyright (c) 2009 Michal Antoniewski &lt;antoniewski.m@gmail.com&gt;
</pre>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">0.11.3</td>
    <td class="foot-os">struct</td>
  </tr>
</table>
</body>
</html>
