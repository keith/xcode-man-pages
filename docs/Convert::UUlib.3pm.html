<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.10 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>UUlib(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">UUlib(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">UUlib(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
Convert::UUlib - Perl interface to the uulib library (a.k.a. uudeview/uuenview).
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<span class="Li"></span>
<pre>
 use Convert::UUlib ':all';
 
 # read all the files named on the commandline and decode them
 # into the CURRENT directory. See below for a longer example.
 LoadFile $_ for @ARGV;

 for my $uu (GetFileList) {
    if ($uu-&gt;state &amp; FILE_OK) {
      $uu-&gt;decode;
      print $uu-&gt;filename, &quot;\n&quot;;
    }
 }
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
Read the file doc/library.pdf from the distribution for in-depth information
  about the C-library used in this interface, and the rest of this document and
  especially the non-trivial decoder program at the end.
</section>
<section class="Sh">
<h1 class="Sh" id="EXPORTED_CONSTANTS"><a class="permalink" href="#EXPORTED_CONSTANTS">EXPORTED
  CONSTANTS</a></h1>
<section class="Ss">
<h2 class="Ss" id="Action_code_constants"><a class="permalink" href="#Action_code_constants">Action
  code constants</a></h2>
<span class="Li"></span>
<pre>
  ACT_IDLE      we don't do anything
  ACT_SCANNING  scanning an input file
  ACT_DECODING  decoding into a temp file
  ACT_COPYING   copying temp to target
  ACT_ENCODING  encoding a file
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Message_severity_levels"><a class="permalink" href="#Message_severity_levels">Message
  severity levels</a></h2>
<span class="Li"></span>
<pre>
  MSG_MESSAGE   just a message, nothing important
  MSG_NOTE      something that should be noticed
  MSG_WARNING   important msg, processing continues
  MSG_ERROR     processing has been terminated
  MSG_FATAL     decoder cannot process further requests
  MSG_PANIC     recovery impossible, app must terminate
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Options"><a class="permalink" href="#Options">Options</a></h2>
<span class="Li"></span>
<pre>
  OPT_VERSION   version number MAJOR.MINORplPATCH (ro)
  OPT_FAST      assumes only one part per file
  OPT_DUMBNESS  switch off the program's intelligence
  OPT_BRACKPOL  give numbers in [] higher precendence
  OPT_VERBOSE   generate informative messages
  OPT_DESPERATE try to decode incomplete files
  OPT_IGNREPLY  ignore RE:plies (off by default)
  OPT_OVERWRITE whether it's OK to overwrite ex. files
  OPT_SAVEPATH  prefix to save-files on disk
  OPT_IGNMODE   ignore the original file mode
  OPT_DEBUG     print messages with FILE/LINE info
  OPT_ERRNO     get last error code for RET_IOERR (ro)
  OPT_PROGRESS  retrieve progress information
  OPT_USETEXT   handle text messages
  OPT_PREAMB    handle Mime preambles/epilogues
  OPT_TINYB64   detect short B64 outside of Mime
  OPT_ENCEXT    extension for single-part encoded files
  OPT_REMOVE    remove input files after decoding (dangerous)
  OPT_MOREMIME  strict MIME adherence
  OPT_DOTDOT    &quot;..&quot;-unescaping has not yet been done on input files
  OPT_RBUF      set default read I/O buffer size in bytes
  OPT_WBUF      set default write I/O buffer size in bytes
  OPT_AUTOCHECK automatically check file list after every loadfile
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Result/Error_codes"><a class="permalink" href="#Result/Error_codes">Result/Error
  codes</a></h2>
<span class="Li"></span>
<pre>
  RET_OK        everything went fine
  RET_IOERR     I/O Error - examine errno
  RET_NOMEM     not enough memory
  RET_ILLVAL    illegal value for operation
  RET_NODATA    decoder didn't find any data
  RET_NOEND     encoded data wasn't ended properly
  RET_UNSUP     unsupported function (encoding)
  RET_EXISTS    file exists (decoding)
  RET_CONT      continue -- special from ScanPart
  RET_CANCEL    operation canceled
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="File_States"><a class="permalink" href="#File_States">File
  States</a></h2>
<span class="Li"></span>
<pre>
 This code is zero, i.e. &quot;false&quot;:

  UUFILE_READ   Read in, but not further processed

 The following state codes are or'ed together:

  FILE_MISPART  Missing Part(s) detected
  FILE_NOBEGIN  No 'begin' found
  FILE_NOEND    No 'end' found
  FILE_NODATA   File does not contain valid uudata
  FILE_OK       All Parts found, ready to decode
  FILE_ERROR    Error while decoding
  FILE_DECODED  Successfully decoded
  FILE_TMPFILE  Temporary decoded file exists
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Encoding_types"><a class="permalink" href="#Encoding_types">Encoding
  types</a></h2>
<span class="Li"></span>
<pre>
  UU_ENCODED    UUencoded data
  B64_ENCODED   Mime-Base64 data
  XX_ENCODED    XXencoded data
  BH_ENCODED    Binhex encoded
  PT_ENCODED    Plain-Text encoded (MIME)
  QP_ENCODED    Quoted-Printable (MIME)
  YENC_ENCODED  yEnc encoded (non-MIME)
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="EXPORTED_FUNCTIONS"><a class="permalink" href="#EXPORTED_FUNCTIONS">EXPORTED
  FUNCTIONS</a></h1>
<section class="Ss">
<h2 class="Ss" id="Initializing_and_cleanup"><a class="permalink" href="#Initializing_and_cleanup">Initializing
  and cleanup</a></h2>
Initialize is automatically called when the module is loaded and allocates quite
  a small amount of memory for todays machines ;) CleanUp releases that again.
<p class="Pp">On my machine, a fairly complete decode with DBI backend needs
    about 10MB RSS to decode 20000 files.</p>
<dl class="Bl-tag">
  <dt>CleanUp</dt>
  <dd>Release memory, file items and clean up files. Should be called after a
      decoidng run, if you want to start a new one.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Setting_and_querying_options"><a class="permalink" href="#Setting_and_querying_options">Setting
  and querying options</a></h2>
<dl class="Bl-tag">
  <dt>$option = GetOption OPT_xxx</dt>
  <dd></dd>
  <dt>SetOption OPT_xxx, opt-value</dt>
  <dd></dd>
</dl>
<p class="Pp">See the <span class="Li">&quot;OPT_xxx&quot;</span> constants
    above to see which options exist.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Setting_various_callbacks"><a class="permalink" href="#Setting_various_callbacks">Setting
  various callbacks</a></h2>
<dl class="Bl-tag">
  <dt>SetMsgCallback [callback-function]</dt>
  <dd></dd>
  <dt>SetBusyCallback [callback-function]</dt>
  <dd></dd>
  <dt>SetFileCallback [callback-function]</dt>
  <dd></dd>
  <dt>SetFNameFilter [callback-function]</dt>
  <dd></dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Call_the_currently_selected_FNameFilter"><a class="permalink" href="#Call_the_currently_selected_FNameFilter">Call
  the currently selected FNameFilter</a></h2>
<dl class="Bl-tag">
  <dt>$file = FNameFilter $file</dt>
  <dd></dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Loading_sourcefiles,_optionally_fuzzy_merge_and_start_decoding"><a class="permalink" href="#Loading_sourcefiles,_optionally_fuzzy_merge_and_start_decoding">Loading
  sourcefiles, optionally fuzzy merge and start decoding</a></h2>
<dl class="Bl-tag">
  <dt>($retval, $count) = LoadFile $fname, [$id, [$delflag, [$partno]]]</dt>
  <dd>Load the given file and scan it for encoded contents. Optionally tag it
      with the given id, and if <span class="Li">$delflag</span> is true, delete
      the file after it is no longer necessary. If you are certain of the part
      number, you can specify it as the last argument.
    <p class="Pp">A better (usually faster) way of doing this is using the
        <span class="Li">&quot;SetFNameFilter&quot;</span> functionality.</p>
  </dd>
  <dt>$retval = Smerge $pass</dt>
  <dd>If you are desperate, try to call
      <span class="Li">&quot;Smerge&quot;</span> with increasing
      <span class="Li">$pass</span> values, beginning at
      <span class="Li">0</span>, to try to merge parts that usually would not
      have been merged.
    <p class="Pp">Most probably this will result in garbled files, so never do
        this by default, except:</p>
    <p class="Pp">If the <span class="Li">&quot;OPT_AUTOCHECK&quot;</span>
        option has been disabled (by default it is enabled) to speed up file
        loading, then you <i>have</i> to call <span class="Li">&quot;Smerge
        -1&quot;</span> after loading all files as an additional pre-pass (which
        is normally done by <span class="Li">&quot;LoadFile&quot;</span>).</p>
  </dd>
  <dt>$item = GetFileListItem $item_number</dt>
  <dd>Return the <span class="Li">$item</span> structure for the
      <span class="Li">$item_number</span>'th found file, or
      <span class="Li">&quot;undef&quot;</span> of no file with that number
      exists.
    <p class="Pp">The first file has number <span class="Li">0</span>, and the
        series has no holes, so you can iterate over all files by starting with
        zero and incrementing until you hit
        <span class="Li">&quot;undef&quot;</span>.</p>
    <p class="Pp">This function has to walk the linear list of fils on each
        access, so if you want to iterate over all items, it is usually faster
        to use <span class="Li">&quot;GetFileList&quot;</span>.</p>
  </dd>
  <dt>@items = GetFileList</dt>
  <dd>Similar to <span class="Li">&quot;GetFileListItem&quot;</span>, but
      returns all files in one go.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Decoding_files"><a class="permalink" href="#Decoding_files">Decoding
  files</a></h2>
<dl class="Bl-tag">
  <dt>$retval = $item-&gt;rename ($newname)</dt>
  <dd>Change the ondisk filename where the decoded file will be saved.</dd>
  <dt>$retval = $item-&gt;decode_temp</dt>
  <dd>Decode the file into a temporary location, use
      <span class="Li">&quot;$item-&gt;infile&quot;</span> to retrieve the
      temporary filename.</dd>
  <dt>$retval = $item-&gt;remove_temp</dt>
  <dd>Remove the temporarily decoded file again.</dd>
  <dt>$retval = $item-&gt;decode ([$target_path])</dt>
  <dd>Decode the file to its destination, or the given target path.</dd>
  <dt>$retval = $item-&gt;info (callback-function)</dt>
  <dd></dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Querying_(and_setting)_item_attributes"><a class="permalink" href="#Querying_(and_setting)_item_attributes">Querying
  (and setting) item attributes</a></h2>
<dl class="Bl-tag">
  <dt>$state = $item-&gt;state</dt>
  <dd></dd>
  <dt>$mode = $item-&gt;mode ([newmode])</dt>
  <dd></dd>
  <dt>$uudet = $item-&gt;uudet</dt>
  <dd></dd>
  <dt>$size = $item-&gt;size</dt>
  <dd></dd>
  <dt>$filename = $item-&gt;filename ([newfilename})</dt>
  <dd></dd>
  <dt>$subfname = $item-&gt;subfname</dt>
  <dd></dd>
  <dt>$mimeid = $item-&gt;mimeid</dt>
  <dd></dd>
  <dt>$mimetype = $item-&gt;mimetype</dt>
  <dd></dd>
  <dt>$binfile = $item-&gt;binfile</dt>
  <dd></dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Information_about_source_parts"><a class="permalink" href="#Information_about_source_parts">Information
  about source parts</a></h2>
<dl class="Bl-tag">
  <dt>$parts = $item-&gt;parts</dt>
  <dd>Return information about all parts (source files) used to decode the file
      as a list of hashrefs with the following structure:
    <p class="Pp"><span class="Li"></span></p>
    <pre>
 {
   partno   =&gt; &lt;integer describing the part number, starting with 1&gt;,
   # the following member sonly exist when they contain useful information
   sfname   =&gt; &lt;local pathname of the file where this part is from&gt;,
   filename =&gt; &lt;the ondisk filename of the decoded file&gt;,
   subfname =&gt; &lt;used to cluster postings, possibly the posting filename&gt;,
   subject  =&gt; &lt;the subject of the posting/mail&gt;,
   origin   =&gt; &lt;the possible source (From) address&gt;,
   mimetype =&gt; &lt;the possible mimetype of the decoded file&gt;,
   mimeid   =&gt; &lt;the id part of the Content-Type&gt;,
 }
    </pre>
    <p class="Pp">Usually you are interested mostly the
        <span class="Li">&quot;sfname&quot;</span> and possibly the
        <span class="Li">&quot;partno&quot;</span> and
        <span class="Li">&quot;filename&quot;</span> members.</p>
  </dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Functions_below_are_not_documented_and_not_very_well_tested__-_feedback_welcome"><a class="permalink" href="#Functions_below_are_not_documented_and_not_very_well_tested__-_feedback_welcome">Functions
  below are not documented and not very well tested - feedback welcome</a></h2>
<span class="Li"></span>
<pre>
  QuickDecode
  EncodeMulti
  EncodePartial
  EncodeToStream
  EncodeToFile
  E_PrepSingle
  E_PrepPartial
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="_s-1EXTENSION_FUNCTIONS_s0"><a class="permalink" href="#_s-1EXTENSION_FUNCTIONS_s0">EXTENSION
  FUNCTIONS</a></h2>
Functions found in this module but not documented in the uulib documentation:
<dl class="Bl-tag">
  <dt>$msg = straction ACT_xxx</dt>
  <dd>Return a human readable string representing the given action code.</dd>
  <dt>$msg = strerror RET_xxx</dt>
  <dd>Return a human readable string representing the given error code.</dd>
  <dt>$str = strencoding xxx_ENCODED</dt>
  <dd>Return the name of the encoding type as a string.</dd>
  <dt>$str = strmsglevel MSG_xxx</dt>
  <dd>Returns the message level as a string.</dd>
  <dt>SetFileNameCallback $cb</dt>
  <dd>Sets (or queries) the FileNameCallback, which is called whenever the
      decoding library can't find a filename and wants to extract a filename
      from the subject line of a posting. The callback will be called with two
      arguments, the subject line and the current candidate for the filename.
      The latter argument can be <span class="Li">&quot;undef&quot;</span>,
      which means that no filename could be found (and likely no one exists, so
      it is safe to also return <span class="Li">&quot;undef&quot;</span> in
      this case). If it doesn't return anything (not even
      <span class="Li">&quot;undef&quot;</span>!), then nothing happens, so this
      is a no-op callback:
    <p class="Pp"><span class="Li"></span></p>
    <pre>
   sub cb {
      return ();
   }
    </pre>
    <p class="Pp">If it returns <span class="Li">&quot;undef&quot;</span>, then
        this indicates that no filename could be found. In all other cases, the
        return value is taken to be the filename.</p>
    <p class="Pp">This is a slightly more useful callback:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  sub cb {
     return unless $_[1]; # skip &quot;Re:&quot;-plies et al.
     my ($subject, $filename) = @_;
     # if we find some *.rar, take it
     return $1 if $subject =~ /(\w+\.rar)/;
     # otherwise just pass what we have
     return ();
  }
    </pre>
  </dd>
</dl>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="LARGE_EXAMPLE_DECODER"><a class="permalink" href="#LARGE_EXAMPLE_DECODER">LARGE
  EXAMPLE DECODER</a></h1>
The general workflow for decoding is like this:
<dl class="Bl-tag">
  <dt>1. Configure options with &quot;SetOption&quot; or
    &quot;SetXXXCallback&quot;.</dt>
  <dd></dd>
  <dt>2. Load all source files with &quot;LoadFile&quot;.</dt>
  <dd></dd>
  <dt>3. Optionally &quot;Smerge&quot;.</dt>
  <dd></dd>
  <dt>4. Iterate over all &quot;GetFileList&quot; items (i.e. result
    files).</dt>
  <dd></dd>
  <dt>5. &quot;CleanUp&quot; to delete files and free items.</dt>
  <dd></dd>
</dl>
<p class="Pp">What follows is the file
    <span class="Li">&quot;example-decoder&quot;</span> from the distribution
    that illustrates the above worklfow in a non-trivial example.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
   #!/usr/bin/perl

   # decode all the files in the directory uusrc/ and copy
   # the resulting files to uudst/

   use Convert::UUlib ':all';

   sub namefilter {
      my ($path) = @_;

      $path=~s/^.*[\/\\]//;

      $path
   }

   sub busycb {
      my ($action, $curfile, $partno, $numparts, $percent, $fsize) = @_;
      $_[0]=straction($action);
      print &quot;busy_callback(&quot;, (join &quot;,&quot;,@_), &quot;)\n&quot;;
      0
   }

   SetOption OPT_RBUF, 128*1024;
   SetOption OPT_WBUF, 1024*1024;
   SetOption OPT_IGNMODE, 1;
   SetOption OPT_IGNMODE, 1;
   SetOption OPT_VERBOSE, 1;

   # show the three ways you can set callback functions. I normally
   # prefer the one with the sub inplace.
   SetFNameFilter \&amp;namefilter;

   SetBusyCallback &quot;busycb&quot;, 333;

   SetMsgCallback sub {
      my ($msg, $level) = @_;
      print uc strmsglevel $_[1], &quot;: $msg\n&quot;;
   };

   # the following non-trivial FileNameCallback takes care
   # of some subject lines not detected properly by uulib:
   SetFileNameCallback sub {
      return unless $_[1]; # skip &quot;Re:&quot;-plies et al.
      local $_ = $_[0];

      # the following rules are rather effective on some newsgroups,
      # like alt.binaries.games.anime, where non-mime, uuencoded data
      # is very common

      # if we find some *.rar, take it as the filename
      return $1 if /(\S{3,}\.(?:[rstuvwxyz]\d\d|rar))\s/i;

      # one common subject format
      return $1 if /- &quot;(.{2,}?\..+?)&quot; (?:yenc )?\(\d+\/\d+\)/i;

      # - filename.par (04/55)
      return $1 if /- &quot;?(\S{3,}\.\S+?)&quot;? (?:yenc )?\(\d+\/\d+\)/i;

      # - (xxx) No. 1 sayuri81.jpg 756565 bytes
      # - (20 files) No.17 Roseanne.jpg [2/2]
      return $1 if /No\.[ 0-9]+ (\S+\....) (?:\d+ bytes )?\[/;

      # try to detect some common forms of filenames
      return $1 if /([a-z0-9_\-+.]{3,}\.[a-z]{3,4}(?:.\d+))/i;

      # otherwise just pass what we have
      ()
   };

   # now read all files in the directory uusrc/*
   for (&lt;uusrc/*&gt;) {
      my ($retval, $count) = LoadFile ($_, $_, 1);
      print &quot;file($_), status(&quot;, strerror $retval, &quot;) parts($count)\n&quot;;
   }

   SetOption OPT_SAVEPATH, &quot;uudst/&quot;;

   # now wade through all files and their source parts
   for my $uu (GetFileList) {
      print &quot;file &quot;, $uu-&gt;filename, &quot;\n&quot;;
      print &quot; state &quot;, $uu-&gt;state, &quot;\n&quot;;
      print &quot; mode &quot;, $uu-&gt;mode, &quot;\n&quot;;
      print &quot; uudet &quot;, strencoding $uu-&gt;uudet, &quot;\n&quot;;
      print &quot; size &quot;, $uu-&gt;size, &quot;\n&quot;;
      print &quot; subfname &quot;, $uu-&gt;subfname, &quot;\n&quot;;
      print &quot; mimeid &quot;, $uu-&gt;mimeid, &quot;\n&quot;;
      print &quot; mimetype &quot;, $uu-&gt;mimetype, &quot;\n&quot;;

      # print additional info about all parts
      print &quot; parts&quot;;
      for ($uu-&gt;parts) {
         for my $k (sort keys %$_) {
            print &quot; $k=$_-&gt;{$k}&quot;;
         }
         print &quot;\n&quot;;
      }

      $uu-&gt;remove_temp;

      if (my $err = $uu-&gt;decode) {
         print &quot; ERROR &quot;, strerror $err, &quot;\n&quot;;
      } else {
         print &quot; successfully saved as uudst/&quot;, $uu-&gt;filename, &quot;\n&quot;;
      }
   }

   print &quot;cleanup...\n&quot;;

   CleanUp;
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="PERLMULTICORE_SUPPORT"><a class="permalink" href="#PERLMULTICORE_SUPPORT">PERLMULTICORE
  SUPPORT</a></h1>
This module supports the perlmulticore standard (see
  &lt;http://perlmulticore.schmorp.de/&gt; for more info) for the following
  functions - generally these are functions accessing the disk and/or using
  considerable CPU time:
<p class="Pp"><span class="Li"></span></p>
<pre>
   LoadFile
   $item-&gt;decode
   $item-&gt;decode_temp
   $item-&gt;remove_temp
   $item-&gt;info
</pre>
<p class="Pp">The perl interpreter will be reacquired/released on every callback
    invocation, so for performance reasons, callbacks should be avoided if that
    is costly.</p>
<p class="Pp">Future versions might enable multicore support for more
  functions.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="BUGS_AND_LIMITATIONS"><a class="permalink" href="#BUGS_AND_LIMITATIONS">BUGS
  AND LIMITATIONS</a></h1>
The original uulib library this module uses was written at a time where main
  memory of measured in megabytes and buffer overflows as a security thign
  didn't exist. While a lot of security fixes have been applied over the years
  (includign some defense in depth mechanism that can shield against a lot of
  as-of-yet undetected bugs), using this library for security purposes requires
  care.
<p class="Pp">Likewise, file sizes when the uulib library was written were tiny
    compared to today, so do not expect this library to handle files larger than
    2GB.</p>
<p class="Pp">Lastly, this module uses a very &quot;C-like&quot; interface,
    which means it doesn't protect you from invalid points as you might expect
    from &quot;more perlish&quot; modules - for example, accessing a file item
    object after callinbg <span class="Li">&quot;CleanUp&quot;</span> will
    likely result in crashes, memory corruption, or worse.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
Marc Lehmann &lt;schmorp@schmorp.de&gt;, the original uulib library was written
  by Frank Pilhofer &lt;fp@informatik.uni-frankfurt.de&gt;, and later heavily
  bugfixed by Marc Lehmann.
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<b>perl</b>(1), uudeview homepage at
  &lt;http://www.fpx.de/fp/Software/UUDeview/&gt;.
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2020-03-16</td>
    <td class="foot-os">perl v5.28.2</td>
  </tr>
</table>
</body>
</html>
