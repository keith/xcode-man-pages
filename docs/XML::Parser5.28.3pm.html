<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.10 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>Parser(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Parser(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Parser(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
XML::Parser - A perl module for parsing XML documents
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<span class="Li"></span>
<pre>
  use XML::Parser;

  $p1 = XML::Parser-&gt;new(Style =&gt; 'Debug');
  $p1-&gt;parsefile('REC-xml-19980210.xml');
  $p1-&gt;parse('&lt;foo id=&quot;me&quot;&gt;Hello World&lt;/foo&gt;');

  # Alternative
  $p2 = XML::Parser-&gt;new(Handlers =&gt; {Start =&gt; \&amp;handle_start,
                                     End   =&gt; \&amp;handle_end,
                                     Char  =&gt; \&amp;handle_char});
  $p2-&gt;parse($socket);

  # Another alternative
  $p3 = XML::Parser-&gt;new(ErrorContext =&gt; 2);

  $p3-&gt;setHandlers(Char    =&gt; \&amp;text,
                   Default =&gt; \&amp;other);

  open(my $fh, 'xmlgenerator |');
  $p3-&gt;parse($foo, ProtocolEncoding =&gt; 'ISO-8859-1');
  close($foo);

  $p3-&gt;parsefile('junk.xml', ErrorContext =&gt; 3);
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
This module provides ways to parse XML documents. It is built on top of
  XML::Parser::Expat, which is a lower level interface to James Clark's expat
  library. Each call to one of the parsing methods creates a new instance of
  XML::Parser::Expat which is then used to parse the document. Expat options may
  be provided when the XML::Parser object is created. These options are then
  passed on to the Expat object on each parse call. They can also be given as
  extra arguments to the parse methods, in which case they override options
  given at XML::Parser creation time.
<p class="Pp">The behavior of the parser is controlled either by
    <span class="Li">&quot;STYLES&quot;</span> and/or
    <span class="Li">&quot;HANDLERS&quot;</span> options, or by
    &quot;setHandlers&quot; method. These all provide mechanisms for XML::Parser
    to set the handlers needed by XML::Parser::Expat. If neither
    <span class="Li">&quot;Style&quot;</span> nor
    <span class="Li">&quot;Handlers&quot;</span> are specified, then parsing
    just checks the document for being well-formed.</p>
<p class="Pp">When underlying handlers get called, they receive as their first
    parameter the <i>Expat</i> object, not the Parser object.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="METHODS"><a class="permalink" href="#METHODS">METHODS</a></h1>
<dl class="Bl-tag">
  <dt>new</dt>
  <dd>This is a class method, the constructor for XML::Parser. Options are
      passed as keyword value pairs. Recognized options are:</dd>
</dl>
<div class="Bd-indent">
<ul class="Bl-bullet">
  <li>Style
    <p class="Pp">This option provides an easy way to create a given style of
        parser. The built in styles are: &quot;Debug&quot;, &quot;Subs&quot;,
        &quot;Tree&quot;, &quot;Objects&quot;, and &quot;Stream&quot;. These are
        all defined in separate packages under
        <span class="Li">&quot;XML::Parser::Style::*&quot;</span>, and you can
        find further documentation for each style both below, and in those
        packages.</p>
    <p class="Pp">Custom styles can be provided by giving a full package name
        containing at least one '::'. This package should then have subs defined
        for each handler it wishes to have installed. See &quot;STYLES&quot;
        below for a discussion of each built in style.</p>
  </li>
  <li>Handlers
    <p class="Pp">When provided, this option should be an anonymous hash
        containing as keys the type of handler and as values a sub reference to
        handle that type of event. All the handlers get passed as their 1st
        parameter the instance of expat that is parsing the document. Further
        details on handlers can be found in &quot;HANDLERS&quot;. Any handler
        set here overrides the corresponding handler set with the Style
      option.</p>
  </li>
  <li>Pkg
    <p class="Pp">Some styles will refer to subs defined in this package. If not
        provided, it defaults to the package which called the constructor.</p>
  </li>
  <li>ErrorContext
    <p class="Pp">This is an Expat option. When this option is defined, errors
        are reported in context. The value should be the number of lines to show
        on either side of the line in which the error occurred.</p>
  </li>
  <li>ProtocolEncoding
    <p class="Pp">This is an Expat option. This sets the protocol encoding name.
        It defaults to none. The built-in encodings are:
        <span class="Li">&quot;UTF-8&quot;</span>,
        <span class="Li">&quot;ISO-8859-1&quot;</span>,
        <span class="Li">&quot;UTF-16&quot;</span>, and
        <span class="Li">&quot;US-ASCII&quot;</span>. Other encodings may be
        used if they have encoding maps in one of the directories in the
        <span class="Li">@Encoding_Path</span> list. Check &quot;ENCODINGS&quot;
        for more information on encoding maps. Setting the protocol encoding
        overrides any encoding in the XML declaration.</p>
  </li>
  <li>Namespaces
    <p class="Pp">This is an Expat option. If this is set to a true value, then
        namespace processing is done during the parse. See
        &quot;Namespaces&quot; in XML::Parser::Expat for further discussion of
        namespace processing.</p>
  </li>
  <li>NoExpand
    <p class="Pp">This is an Expat option. Normally, the parser will try to
        expand references to entities defined in the internal subset. If this
        option is set to a true value, and a default handler is also set, then
        the default handler will be called when an entity reference is seen in
        text. This has no effect if a default handler has not been registered,
        and it has no effect on the expansion of entity references inside
        attribute values.</p>
  </li>
  <li>Stream_Delimiter
    <p class="Pp">This is an Expat option. It takes a string value. When this
        string is found alone on a line while parsing from a stream, then the
        parse is ended as if it saw an end of file. The intended use is with a
        stream of xml documents in a MIME multipart format. The string should
        not contain a trailing newline.</p>
  </li>
  <li>ParseParamEnt
    <p class="Pp">This is an Expat option. Unless standalone is set to
        &quot;yes&quot; in the XML declaration, setting this to a true value
        allows the external DTD to be read, and parameter entities to be parsed
        and expanded.</p>
  </li>
  <li>NoLWP
    <p class="Pp">This option has no effect if the ExternEnt or ExternEntFin
        handlers are directly set. Otherwise, if true, it forces the use of a
        file based external entity handler.</p>
  </li>
  <li>Non_Expat_Options
    <p class="Pp">If provided, this should be an anonymous hash whose keys are
        options that shouldn't be passed to Expat. This should only be of
        concern to those subclassing XML::Parser.</p>
  </li>
</ul>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>setHandlers(TYPE, HANDLER [, TYPE, HANDLER [...]])</dt>
  <dd>This method registers handlers for various parser events. It overrides any
      previous handlers registered through the Style or Handler options or
      through earlier calls to setHandlers. By providing a false or undefined
      value as the handler, the existing handler can be unset.
    <p class="Pp">This method returns a list of type, handler pairs
        corresponding to the input. The handlers returned are the ones that were
        in effect prior to the call.</p>
    <p class="Pp">See a description of the handler types in
        &quot;HANDLERS&quot;.</p>
  </dd>
  <dt>parse(SOURCE [, OPT =&gt; OPT_VALUE [...]])</dt>
  <dd>The SOURCE parameter should either be a string containing the whole XML
      document, or it should be an open IO::Handle. Constructor options to
      XML::Parser::Expat given as keyword-value pairs may follow the SOURCE
      parameter. These override, for this call, any options or attributes passed
      through from the XML::Parser instance.
    <p class="Pp">A die call is thrown if a parse error occurs. Otherwise it
        will return 1 or whatever is returned from the <b>Final</b> handler, if
        one is installed. In other words, what parse may return depends on the
        style.</p>
  </dd>
  <dt>parsestring</dt>
  <dd>This is just an alias for parse for backwards compatibility.</dd>
  <dt>parsefile(FILE [, OPT =&gt; OPT_VALUE [...]])</dt>
  <dd>Open FILE for reading, then call parse with the open handle. The file is
      closed no matter how parse returns. Returns what parse returns.</dd>
  <dt>parse_start([ OPT =&gt; OPT_VALUE [...]])</dt>
  <dd>Create and return a new instance of XML::Parser::ExpatNB. Constructor
      options may be provided. If an init handler has been provided, it is
      called before returning the ExpatNB object. Documents are parsed by making
      incremental calls to the parse_more method of this object, which takes a
      string. A single call to the parse_done method of this object, which takes
      no arguments, indicates that the document is finished.
    <p class="Pp">If there is a final handler installed, it is executed by the
        parse_done method before returning and the parse_done method returns
        whatever is returned by the final handler.</p>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="HANDLERS"><a class="permalink" href="#HANDLERS">HANDLERS</a></h1>
Expat is an event based parser. As the parser recognizes parts of the document
  (say the start or end tag for an XML element), then any handlers registered
  for that type of an event are called with suitable parameters. All handlers
  receive an instance of XML::Parser::Expat as their first argument. See
  &quot;METHODS&quot; in XML::Parser::Expat for a discussion of the methods that
  can be called on this object.
<section class="Ss">
<h2 class="Ss" id="Init________________(Expat)"><a class="permalink" href="#Init________________(Expat)">Init
  (Expat)</a></h2>
This is called just before the parsing of the document starts.
</section>
<section class="Ss">
<h2 class="Ss" id="Final________________(Expat)"><a class="permalink" href="#Final________________(Expat)">Final
  (Expat)</a></h2>
This is called just after parsing has finished, but only if no errors occurred
  during the parse. Parse returns what this returns.
</section>
<section class="Ss">
<h2 class="Ss" id="Start________________(Expat,_Element__,_Attr,_Val__,...__)"><a class="permalink" href="#Start________________(Expat,_Element__,_Attr,_Val__,...__)">Start
  (Expat, Element [, Attr, Val [,...]])</a></h2>
This event is generated when an XML start tag is recognized. Element is the name
  of the XML element type that is opened with the start tag. The Attr &amp; Val
  pairs are generated for each attribute in the start tag.
</section>
<section class="Ss">
<h2 class="Ss" id="End________________(Expat,_Element)"><a class="permalink" href="#End________________(Expat,_Element)">End
  (Expat, Element)</a></h2>
This event is generated when an XML end tag is recognized. Note that an XML
  empty tag (&lt;foo/&gt;) generates both a start and an end event.
</section>
<section class="Ss">
<h2 class="Ss" id="Char________________(Expat,_String)"><a class="permalink" href="#Char________________(Expat,_String)">Char
  (Expat, String)</a></h2>
This event is generated when non-markup is recognized. The non-markup sequence
  of characters is in String. A single non-markup sequence of characters may
  generate multiple calls to this handler. Whatever the encoding of the string
  in the original document, this is given to the handler in UTF-8.
</section>
<section class="Ss">
<h2 class="Ss" id="Proc________________(Expat,_Target,_Data)"><a class="permalink" href="#Proc________________(Expat,_Target,_Data)">Proc
  (Expat, Target, Data)</a></h2>
This event is generated when a processing instruction is recognized.
</section>
<section class="Ss">
<h2 class="Ss" id="Comment________________(Expat,_Data)"><a class="permalink" href="#Comment________________(Expat,_Data)">Comment
  (Expat, Data)</a></h2>
This event is generated when a comment is recognized.
</section>
<section class="Ss">
<h2 class="Ss" id="CdataStart________(Expat)"><a class="permalink" href="#CdataStart________(Expat)">CdataStart
  (Expat)</a></h2>
This is called at the start of a CDATA section.
</section>
<section class="Ss">
<h2 class="Ss" id="CdataEnd________________(Expat)"><a class="permalink" href="#CdataEnd________________(Expat)">CdataEnd
  (Expat)</a></h2>
This is called at the end of a CDATA section.
</section>
<section class="Ss">
<h2 class="Ss" id="Default________________(Expat,_String)"><a class="permalink" href="#Default________________(Expat,_String)">Default
  (Expat, String)</a></h2>
This is called for any characters that don't have a registered handler. This
  includes both characters that are part of markup for which no events are
  generated (markup declarations) and characters that could generate events, but
  for which no handler has been registered.
<p class="Pp">Whatever the encoding in the original document, the string is
    returned to the handler in UTF-8.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Unparsed________________(Expat,_Entity,_Base,_Sysid,_Pubid,_Notation)"><a class="permalink" href="#Unparsed________________(Expat,_Entity,_Base,_Sysid,_Pubid,_Notation)">Unparsed
  (Expat, Entity, Base, Sysid, Pubid, Notation)</a></h2>
This is called for a declaration of an unparsed entity. Entity is the name of
  the entity. Base is the base to be used for resolving a relative URI. Sysid is
  the system id. Pubid is the public id. Notation is the notation name. Base and
  Pubid may be undefined.
</section>
<section class="Ss">
<h2 class="Ss" id="Notation________________(Expat,_Notation,_Base,_Sysid,_Pubid)"><a class="permalink" href="#Notation________________(Expat,_Notation,_Base,_Sysid,_Pubid)">Notation
  (Expat, Notation, Base, Sysid, Pubid)</a></h2>
This is called for a declaration of notation. Notation is the notation name.
  Base is the base to be used for resolving a relative URI. Sysid is the system
  id. Pubid is the public id. Base, Sysid, and Pubid may all be undefined.
</section>
<section class="Ss">
<h2 class="Ss" id="ExternEnt________(Expat,_Base,_Sysid,_Pubid)"><a class="permalink" href="#ExternEnt________(Expat,_Base,_Sysid,_Pubid)">ExternEnt
  (Expat, Base, Sysid, Pubid)</a></h2>
This is called when an external entity is referenced. Base is the base to be
  used for resolving a relative URI. Sysid is the system id. Pubid is the public
  id. Base, and Pubid may be undefined.
<p class="Pp">This handler should either return a string, which represents the
    contents of the external entity, or return an open filehandle that can be
    read to obtain the contents of the external entity, or return undef, which
    indicates the external entity couldn't be found and will generate a parse
    error.</p>
<p class="Pp">If an open filehandle is returned, it must be returned as either a
    glob (*FOO) or as a reference to a glob (e.g. an instance of
  IO::Handle).</p>
<p class="Pp">A default handler is installed for this event. The default handler
    is XML::Parser::lwp_ext_ent_handler unless the NoLWP option was provided
    with a true value, otherwise XML::Parser::file_ext_ent_handler is the
    default handler for external entities. Even without the NoLWP option, if the
    URI or LWP modules are missing, the file based handler ends up being used
    after giving a warning on the first external entity reference.</p>
<p class="Pp">The LWP external entity handler will use proxies defined in the
    environment (http_proxy, ftp_proxy, etc.).</p>
<p class="Pp">Please note that the LWP external entity handler reads the entire
    entity into a string and returns it, where as the file handler opens a
    filehandle.</p>
<p class="Pp">Also note that the file external entity handler will likely choke
    on absolute URIs or file names that don't fit the conventions of the local
    operating system.</p>
<p class="Pp">The expat base method can be used to set a basename for relative
    pathnames. If no basename is given, or if the basename is itself a relative
    name, then it is relative to the current working directory.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="ExternEntFin________(Expat)"><a class="permalink" href="#ExternEntFin________(Expat)">ExternEntFin
  (Expat)</a></h2>
This is called after parsing an external entity. It's not called unless an
  ExternEnt handler is also set. There is a default handler installed that pairs
  with the default ExternEnt handler.
<p class="Pp">If you're going to install your own ExternEnt handler, then you
    should set (or unset) this handler too.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Entity________________(Expat,_Name,_Val,_Sysid,_Pubid,_Ndata,_IsParam)"><a class="permalink" href="#Entity________________(Expat,_Name,_Val,_Sysid,_Pubid,_Ndata,_IsParam)">Entity
  (Expat, Name, Val, Sysid, Pubid, Ndata, IsParam)</a></h2>
This is called when an entity is declared. For internal entities, the Val
  parameter will contain the value and the remaining three parameters will be
  undefined. For external entities, the Val parameter will be undefined, the
  Sysid parameter will have the system id, the Pubid parameter will have the
  public id if it was provided (it will be undefined otherwise), the Ndata
  parameter will contain the notation for unparsed entities. If this is a
  parameter entity declaration, then the IsParam parameter is true.
<p class="Pp">Note that this handler and the Unparsed handler above overlap. If
    both are set, then this handler will not be called for unparsed
  entities.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Element________________(Expat,_Name,_Model)"><a class="permalink" href="#Element________________(Expat,_Name,_Model)">Element
  (Expat, Name, Model)</a></h2>
The element handler is called when an element declaration is found. Name is the
  element name, and Model is the content model as an XML::Parser::Content
  object. See &quot;XML::Parser::ContentModel Methods&quot; in
  XML::Parser::Expat for methods available for this class.
</section>
<section class="Ss">
<h2 class="Ss" id="Attlist________________(Expat,_Elname,_Attname,_Type,_Default,_Fixed)"><a class="permalink" href="#Attlist________________(Expat,_Elname,_Attname,_Type,_Default,_Fixed)">Attlist
  (Expat, Elname, Attname, Type, Default, Fixed)</a></h2>
This handler is called for each attribute in an ATTLIST declaration. So an
  ATTLIST declaration that has multiple attributes will generate multiple calls
  to this handler. The Elname parameter is the name of the element with which
  the attribute is being associated. The Attname parameter is the name of the
  attribute. Type is the attribute type, given as a string. Default is the
  default value, which will either be &quot;#REQUIRED&quot;,
  &quot;#IMPLIED&quot; or a quoted string (i.e. the returned string will begin
  and end with a quote character). If Fixed is true, then this is a fixed
  attribute.
</section>
<section class="Ss">
<h2 class="Ss" id="Doctype________________(Expat,_Name,_Sysid,_Pubid,_Internal)"><a class="permalink" href="#Doctype________________(Expat,_Name,_Sysid,_Pubid,_Internal)">Doctype
  (Expat, Name, Sysid, Pubid, Internal)</a></h2>
This handler is called for DOCTYPE declarations. Name is the document type name.
  Sysid is the system id of the document type, if it was provided, otherwise
  it's undefined. Pubid is the public id of the document type, which will be
  undefined if no public id was given. Internal is the internal subset, given as
  a string. If there was no internal subset, it will be undefined. Internal will
  contain all whitespace, comments, processing instructions, and declarations
  seen in the internal subset. The declarations will be there whether or not
  they have been processed by another handler (except for unparsed entities
  processed by the Unparsed handler). However, comments and processing
  instructions will not appear if they've been processed by their respective
  handlers.
</section>
<section class="Ss">
<h2 class="Ss" id="*_DoctypeFin________________(Parser)"><a class="permalink" href="#*_DoctypeFin________________(Parser)">*
  DoctypeFin (Parser)</a></h2>
This handler is called after parsing of the DOCTYPE declaration has finished,
  including any internal or external DTD declarations.
</section>
<section class="Ss">
<h2 class="Ss" id="XMLDecl________________(Expat,_Version,_Encoding,_Standalone)"><a class="permalink" href="#XMLDecl________________(Expat,_Version,_Encoding,_Standalone)">XMLDecl
  (Expat, Version, Encoding, Standalone)</a></h2>
This handler is called for xml declarations. Version is a string containing the
  version. Encoding is either undefined or contains an encoding string.
  Standalone will be either true, false, or undefined if the standalone
  attribute is yes, no, or not made respectively.
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="STYLES"><a class="permalink" href="#STYLES">STYLES</a></h1>
<section class="Ss">
<h2 class="Ss" id="Debug"><a class="permalink" href="#Debug">Debug</a></h2>
This just prints out the document in outline form. Nothing special is returned
  by parse.
</section>
<section class="Ss">
<h2 class="Ss" id="Subs"><a class="permalink" href="#Subs">Subs</a></h2>
Each time an element starts, a sub by that name in the package specified by the
  Pkg option is called with the same parameters that the Start handler gets
  called with.
<p class="Pp">Each time an element ends, a sub with that name appended with an
    underscore (&quot;_&quot;), is called with the same parameters that the End
    handler gets called with.</p>
<p class="Pp">Nothing special is returned by parse.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Tree"><a class="permalink" href="#Tree">Tree</a></h2>
Parse will return a parse tree for the document. Each node in the tree takes the
  form of a tag, content pair. Text nodes are represented with a pseudo-tag of
  &quot;0&quot; and the string that is their content. For elements, the content
  is an array reference. The first item in the array is a (possibly empty) hash
  reference containing attributes. The remainder of the array is a sequence of
  tag-content pairs representing the content of the element.
<p class="Pp">So for example the result of parsing:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  &lt;foo&gt;&lt;head id=&quot;a&quot;&gt;Hello &lt;em&gt;there&lt;/em&gt;&lt;/head&gt;&lt;bar&gt;Howdy&lt;ref/&gt;&lt;/bar&gt;do&lt;/foo&gt;
</pre>
<p class="Pp">would be:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
             Tag   Content
  ==================================================================
  [foo, [{}, head, [{id =&gt; &quot;a&quot;}, 0, &quot;Hello &quot;,  em, [{}, 0, &quot;there&quot;]],
              bar, [         {}, 0, &quot;Howdy&quot;,  ref, [{}]],
                0, &quot;do&quot;
        ]
  ]
</pre>
<p class="Pp">The root document &quot;foo&quot;, has 3 children: a
    &quot;head&quot; element, a &quot;bar&quot; element and the text
    &quot;do&quot;. After the empty attribute hash, these are represented in
    it's contents by 3 tag-content pairs.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Objects"><a class="permalink" href="#Objects">Objects</a></h2>
This is similar to the Tree style, except that a hash object is created for each
  element. The corresponding object will be in the class whose name is created
  by appending &quot;::&quot; and the element name to the package set with the
  Pkg option. Non-markup text will be in the ::Characters class. The contents of
  the corresponding object will be in an anonymous array that is the value of
  the Kids property for that object.
</section>
<section class="Ss">
<h2 class="Ss" id="Stream"><a class="permalink" href="#Stream">Stream</a></h2>
This style also uses the Pkg package. If none of the subs that this style looks
  for is there, then the effect of parsing with this style is to print a
  canonical copy of the document without comments or declarations. All the subs
  receive as their 1st parameter the Expat instance for the document they're
  parsing.
<p class="Pp">It looks for the following routines:</p>
<ul class="Bl-bullet">
  <li>StartDocument
    <p class="Pp">Called at the start of the parse .</p>
  </li>
  <li>StartTag
    <p class="Pp">Called for every start tag with a second parameter of the
        element type. The <span class="Li">$_</span> variable will contain a
        copy of the tag and the <span class="Li">%_</span> variable will contain
        attribute values supplied for that element.</p>
  </li>
  <li>EndTag
    <p class="Pp">Called for every end tag with a second parameter of the
        element type. The <span class="Li">$_</span> variable will contain a
        copy of the end tag.</p>
  </li>
  <li>Text
    <p class="Pp">Called just before start or end tags with accumulated
        non-markup text in the <span class="Li">$_</span> variable.</p>
  </li>
  <li>PI
    <p class="Pp">Called for processing instructions. The
        <span class="Li">$_</span> variable will contain a copy of the PI and
        the target and data are sent as 2nd and 3rd parameters respectively.</p>
  </li>
  <li>EndDocument
    <p class="Pp">Called at conclusion of the parse.</p>
  </li>
</ul>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="ENCODINGS"><a class="permalink" href="#ENCODINGS">ENCODINGS</a></h1>
XML documents may be encoded in character sets other than Unicode as long as
  they may be mapped into the Unicode character set. Expat has further
  restrictions on encodings. Read the xmlparse.h header file in the expat
  distribution to see details on these restrictions.
<p class="Pp">Expat has built-in encodings for:
    <span class="Li">&quot;UTF-8&quot;</span>,
    <span class="Li">&quot;ISO-8859-1&quot;</span>,
    <span class="Li">&quot;UTF-16&quot;</span>, and
    <span class="Li">&quot;US-ASCII&quot;</span>. Encodings are set either
    through the XML declaration encoding attribute or through the
    ProtocolEncoding option to XML::Parser or XML::Parser::Expat.</p>
<p class="Pp">For encodings other than the built-ins, expat calls the function
    load_encoding in the Expat package with the encoding name. This function
    looks for a file in the path list
    <span class="Li">@XML::Parser::Expat::Encoding_Path</span>, that matches the
    lower-cased name with a '.enc' extension. The first one it finds, it
  loads.</p>
<p class="Pp">If you wish to build your own encoding maps, check out the
    XML::Encoding module from CPAN.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHORS"><a class="permalink" href="#AUTHORS">AUTHORS</a></h1>
Larry Wall &lt;<i>larry@wall.org</i>&gt; wrote version 1.0.
<p class="Pp">Clark Cooper &lt;<i>coopercc@netheaven.com</i>&gt; picked up
    support, changed the API for this version (2.x), provided documentation, and
    added some standard package features.</p>
<p class="Pp">Matt Sergeant &lt;<i>matt@sergeant.org</i>&gt; is now maintaining
    XML::Parser</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2019-09-24</td>
    <td class="foot-os">perl v5.28.2</td>
  </tr>
</table>
</body>
</html>
