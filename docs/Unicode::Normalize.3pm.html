<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.10 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>Unicode::Normalize(3pm)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Unicode::Normalize(3pm)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">Unicode::Normalize(3pm)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
Unicode::Normalize - Unicode Normalization Forms
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
(1) using function names exported by default:
<p class="Pp"><span class="Li"></span></p>
<pre>
  use Unicode::Normalize;

  $NFD_string  = NFD($string);  # Normalization Form D
  $NFC_string  = NFC($string);  # Normalization Form C
  $NFKD_string = NFKD($string); # Normalization Form KD
  $NFKC_string = NFKC($string); # Normalization Form KC
</pre>
<p class="Pp">(2) using function names exported on request:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  use Unicode::Normalize 'normalize';

  $NFD_string  = normalize('D',  $string);  # Normalization Form D
  $NFC_string  = normalize('C',  $string);  # Normalization Form C
  $NFKD_string = normalize('KD', $string);  # Normalization Form KD
  $NFKC_string = normalize('KC', $string);  # Normalization Form KC
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
Parameters:
<p class="Pp"><span class="Li">$string</span> is used as a string under
    character semantics (see perlunicode).</p>
<p class="Pp"><span class="Li">$code_point</span> should be an unsigned integer
    representing a Unicode code point.</p>
<p class="Pp">Note: Between XSUB and pure Perl, there is an incompatibility
    about the interpretation of <span class="Li">$code_point</span> as a decimal
    number. XSUB converts <span class="Li">$code_point</span> to an unsigned
    integer, but pure Perl does not. Do not use a floating point nor a negative
    sign in <span class="Li">$code_point</span>.</p>
<section class="Ss">
<h2 class="Ss" id="Normalization_Forms"><a class="permalink" href="#Normalization_Forms">Normalization
  Forms</a></h2>
<dl class="Bl-tag">
  <dt>&quot;$NFD_string = NFD($string)&quot;</dt>
  <dd>It returns the Normalization Form D (formed by canonical
    decomposition).</dd>
  <dt>&quot;$NFC_string = NFC($string)&quot;</dt>
  <dd>It returns the Normalization Form C (formed by canonical decomposition
      followed by canonical composition).</dd>
  <dt>&quot;$NFKD_string = NFKD($string)&quot;</dt>
  <dd>It returns the Normalization Form KD (formed by compatibility
      decomposition).</dd>
  <dt>&quot;$NFKC_string = NFKC($string)&quot;</dt>
  <dd>It returns the Normalization Form KC (formed by compatibility
      decomposition followed by <b>canonical</b> composition).</dd>
  <dt>&quot;$FCD_string = FCD($string)&quot;</dt>
  <dd>If the given string is in FCD (&quot;Fast C or D&quot; form; cf. UTN #5),
      it returns the string without modification; otherwise it returns an FCD
      string.
    <p class="Pp">Note: FCD is not always unique, then plural forms may be
        equivalent each other. <span class="Li">&quot;FCD()&quot;</span> will
        return one of these equivalent forms.</p>
  </dd>
  <dt>&quot;$FCC_string = FCC($string)&quot;</dt>
  <dd>It returns the FCC form (&quot;Fast C Contiguous&quot;; cf. UTN #5).
    <p class="Pp">Note: FCC is unique, as well as four normalization forms
        (NF*).</p>
  </dd>
  <dt>&quot;$normalized_string = normalize($form_name, $string)&quot;</dt>
  <dd>It returns the normalization form of <span class="Li">$form_name</span>.
    <p class="Pp">As <span class="Li">$form_name</span>, one of the following
        names must be given.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  'C'  or 'NFC'  for Normalization Form C  (UAX #15)
  'D'  or 'NFD'  for Normalization Form D  (UAX #15)
  'KC' or 'NFKC' for Normalization Form KC (UAX #15)
  'KD' or 'NFKD' for Normalization Form KD (UAX #15)

  'FCD'          for &quot;Fast C or D&quot; Form  (UTN #5)
  'FCC'          for &quot;Fast C Contiguous&quot; (UTN #5)
    </pre>
  </dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Decomposition_and_Composition"><a class="permalink" href="#Decomposition_and_Composition">Decomposition
  and Composition</a></h2>
<dl class="Bl-tag">
  <dt>&quot;$decomposed_string = decompose($string [,
    $useCompatMapping])&quot;</dt>
  <dd>It returns the concatenation of the decomposition of each character in the
      string.
    <p class="Pp">If the second parameter (a boolean) is omitted or false, the
        decomposition is canonical decomposition; if the second parameter (a
        boolean) is true, the decomposition is compatibility decomposition.</p>
    <p class="Pp">The string returned is not always in NFD/NFKD. Reordering may
        be required.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
 $NFD_string  = reorder(decompose($string));       # eq. to NFD()
 $NFKD_string = reorder(decompose($string, TRUE)); # eq. to NFKD()
    </pre>
  </dd>
  <dt>&quot;$reordered_string = reorder($string)&quot;</dt>
  <dd>It returns the result of reordering the combining characters according to
      Canonical Ordering Behavior.
    <p class="Pp">For example, when you have a list of NFD/NFKD strings, you can
        get the concatenated NFD/NFKD string from them, by saying</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    $concat_NFD  = reorder(join '', @NFD_strings);
    $concat_NFKD = reorder(join '', @NFKD_strings);
    </pre>
  </dd>
  <dt>&quot;$composed_string = compose($string)&quot;</dt>
  <dd>It returns the result of canonical composition without applying any
      decomposition.
    <p class="Pp">For example, when you have a NFD/NFKD string, you can get its
        NFC/NFKC string, by saying</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    $NFC_string  = compose($NFD_string);
    $NFKC_string = compose($NFKD_string);
    </pre>
  </dd>
  <dt>&quot;($processed, $unprocessed) =
    splitOnLastStarter($normalized)&quot;</dt>
  <dd>It returns two strings: the first one, <span class="Li">$processed</span>,
      is a part before the last starter, and the second one,
      <span class="Li">$unprocessed</span> is another part after the first part.
      A starter is a character having a combining class of zero (see UAX #15).
    <p class="Pp">Note that <span class="Li">$processed</span> may be empty
        (when <span class="Li">$normalized</span> contains no starter or starts
        with the last starter), and then <span class="Li">$unprocessed</span>
        should be equal to the entire <span class="Li">$normalized</span>.</p>
    <p class="Pp">When you have a <span class="Li">$normalized</span> string and
        an <span class="Li">$unnormalized</span> string following it, a simple
        concatenation is wrong:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
 $concat = $normalized . normalize($form, $unnormalized); # wrong!
    </pre>
    <p class="Pp">Instead of it, do like this:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
 ($processed, $unprocessed) = splitOnLastStarter($normalized);
 $concat = $processed . normalize($form,$unprocessed.$unnormalized);
    </pre>
    <p class="Pp"><span class="Li">&quot;splitOnLastStarter()&quot;</span>
        should be called with a pre-normalized parameter
        <span class="Li">$normalized</span>, that is in the same form as
        <span class="Li">$form</span> you want.</p>
    <p class="Pp">If you have an array of <span class="Li">@string</span> that
        should be concatenated and then normalized, you can do like this:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    my $result = &quot;&quot;;
    my $unproc = &quot;&quot;;
    foreach my $str (@string) {
        $unproc .= $str;
        my $n = normalize($form, $unproc);
        my($p, $u) = splitOnLastStarter($n);
        $result .= $p;
        $unproc  = $u;
    }
    $result .= $unproc;
    # instead of normalize($form, join('', @string))
    </pre>
  </dd>
  <dt>&quot;$processed = normalize_partial($form, $unprocessed)&quot;</dt>
  <dd>A wrapper for the combination of
      <span class="Li">&quot;normalize()&quot;</span> and
      <span class="Li">&quot;splitOnLastStarter()&quot;</span>. Note that
      <span class="Li">$unprocessed</span> will be modified as a side-effect.
    <p class="Pp">If you have an array of <span class="Li">@string</span> that
        should be concatenated and then normalized, you can do like this:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    my $result = &quot;&quot;;
    my $unproc = &quot;&quot;;
    foreach my $str (@string) {
        $unproc .= $str;
        $result .= normalize_partial($form, $unproc);
    }
    $result .= $unproc;
    # instead of normalize($form, join('', @string))
    </pre>
  </dd>
  <dt>&quot;$processed = NFD_partial($unprocessed)&quot;</dt>
  <dd>It does like <span class="Li">&quot;normalize_partial('NFD',
      $unprocessed)&quot;</span>. Note that <span class="Li">$unprocessed</span>
      will be modified as a side-effect.</dd>
  <dt>&quot;$processed = NFC_partial($unprocessed)&quot;</dt>
  <dd>It does like <span class="Li">&quot;normalize_partial('NFC',
      $unprocessed)&quot;</span>. Note that <span class="Li">$unprocessed</span>
      will be modified as a side-effect.</dd>
  <dt>&quot;$processed = NFKD_partial($unprocessed)&quot;</dt>
  <dd>It does like <span class="Li">&quot;normalize_partial('NFKD',
      $unprocessed)&quot;</span>. Note that <span class="Li">$unprocessed</span>
      will be modified as a side-effect.</dd>
  <dt>&quot;$processed = NFKC_partial($unprocessed)&quot;</dt>
  <dd>It does like <span class="Li">&quot;normalize_partial('NFKC',
      $unprocessed)&quot;</span>. Note that <span class="Li">$unprocessed</span>
      will be modified as a side-effect.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Quick_Check"><a class="permalink" href="#Quick_Check">Quick
  Check</a></h2>
(see Annex 8, UAX #15; and <i>DerivedNormalizationProps.txt</i>)
<p class="Pp">The following functions check whether the string is in that
    normalization form.</p>
<p class="Pp">The result returned will be one of the following:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    YES     The string is in that normalization form.
    NO      The string is not in that normalization form.
    MAYBE   Dubious. Maybe yes, maybe no.
</pre>
<dl class="Bl-tag">
  <dt>&quot;$result = checkNFD($string)&quot;</dt>
  <dd>It returns true (<span class="Li">1</span>) if
      <span class="Li">&quot;YES&quot;</span>; false
      (<span class="Li">&quot;empty string&quot;</span>) if
      <span class="Li">&quot;NO&quot;</span>.</dd>
  <dt>&quot;$result = checkNFC($string)&quot;</dt>
  <dd>It returns true (<span class="Li">1</span>) if
      <span class="Li">&quot;YES&quot;</span>; false
      (<span class="Li">&quot;empty string&quot;</span>) if
      <span class="Li">&quot;NO&quot;</span>;
      <span class="Li">&quot;undef&quot;</span> if
      <span class="Li">&quot;MAYBE&quot;</span>.</dd>
  <dt>&quot;$result = checkNFKD($string)&quot;</dt>
  <dd>It returns true (<span class="Li">1</span>) if
      <span class="Li">&quot;YES&quot;</span>; false
      (<span class="Li">&quot;empty string&quot;</span>) if
      <span class="Li">&quot;NO&quot;</span>.</dd>
  <dt>&quot;$result = checkNFKC($string)&quot;</dt>
  <dd>It returns true (<span class="Li">1</span>) if
      <span class="Li">&quot;YES&quot;</span>; false
      (<span class="Li">&quot;empty string&quot;</span>) if
      <span class="Li">&quot;NO&quot;</span>;
      <span class="Li">&quot;undef&quot;</span> if
      <span class="Li">&quot;MAYBE&quot;</span>.</dd>
  <dt>&quot;$result = checkFCD($string)&quot;</dt>
  <dd>It returns true (<span class="Li">1</span>) if
      <span class="Li">&quot;YES&quot;</span>; false
      (<span class="Li">&quot;empty string&quot;</span>) if
      <span class="Li">&quot;NO&quot;</span>.</dd>
  <dt>&quot;$result = checkFCC($string)&quot;</dt>
  <dd>It returns true (<span class="Li">1</span>) if
      <span class="Li">&quot;YES&quot;</span>; false
      (<span class="Li">&quot;empty string&quot;</span>) if
      <span class="Li">&quot;NO&quot;</span>;
      <span class="Li">&quot;undef&quot;</span> if
      <span class="Li">&quot;MAYBE&quot;</span>.
    <p class="Pp">Note: If a string is not in FCD, it must not be in FCC. So
        <span class="Li">&quot;checkFCC($not_FCD_string)&quot;</span> should
        return <span class="Li">&quot;NO&quot;</span>.</p>
  </dd>
  <dt>&quot;$result = check($form_name, $string)&quot;</dt>
  <dd>It returns true (<span class="Li">1</span>) if
      <span class="Li">&quot;YES&quot;</span>; false
      (<span class="Li">&quot;empty string&quot;</span>) if
      <span class="Li">&quot;NO&quot;</span>;
      <span class="Li">&quot;undef&quot;</span> if
      <span class="Li">&quot;MAYBE&quot;</span>.
    <p class="Pp">As <span class="Li">$form_name</span>, one of the following
        names must be given.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  'C'  or 'NFC'  for Normalization Form C  (UAX #15)
  'D'  or 'NFD'  for Normalization Form D  (UAX #15)
  'KC' or 'NFKC' for Normalization Form KC (UAX #15)
  'KD' or 'NFKD' for Normalization Form KD (UAX #15)

  'FCD'          for &quot;Fast C or D&quot; Form  (UTN #5)
  'FCC'          for &quot;Fast C Contiguous&quot; (UTN #5)
    </pre>
  </dd>
</dl>
<p class="Pp"><b>Note</b></p>
<p class="Pp">In the cases of NFD, NFKD, and FCD, the answer must be either
    <span class="Li">&quot;YES&quot;</span> or
    <span class="Li">&quot;NO&quot;</span>. The answer
    <span class="Li">&quot;MAYBE&quot;</span> may be returned in the cases of
    NFC, NFKC, and FCC.</p>
<p class="Pp">A <span class="Li">&quot;MAYBE&quot;</span> string should contain
    at least one combining character or the like. For example,
    <span class="Li">&quot;COMBINING ACUTE ACCENT&quot;</span> has the
    MAYBE_NFC/MAYBE_NFKC property.</p>
<p class="Pp">Both <span class="Li">&quot;checkNFC(&quot;A\N{COMBINING ACUTE
    ACCENT}&quot;)&quot;</span> and
    <span class="Li">&quot;checkNFC(&quot;B\N{COMBINING ACUTE
    ACCENT}&quot;)&quot;</span> will return
    <span class="Li">&quot;MAYBE&quot;</span>.
    <span class="Li">&quot;A\N{COMBINING ACUTE ACCENT}&quot;</span> is not in
    NFC (its NFC is <span class="Li">&quot;\N{LATIN CAPITAL LETTER A WITH
    ACUTE}&quot;</span>), while <span class="Li">&quot;B\N{COMBINING ACUTE
    ACCENT}&quot;</span> is in NFC.</p>
<p class="Pp">If you want to check exactly, compare the string with its
    NFC/NFKC/FCC.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    if ($string eq NFC($string)) {
        # $string is exactly normalized in NFC;
    } else {
        # $string is not normalized in NFC;
    }

    if ($string eq NFKC($string)) {
        # $string is exactly normalized in NFKC;
    } else {
        # $string is not normalized in NFKC;
    }
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Character_Data"><a class="permalink" href="#Character_Data">Character
  Data</a></h2>
These functions are interface of character data used internally. If you want
  only to get Unicode normalization forms, you don't need call them yourself.
<dl class="Bl-tag">
  <dt>&quot;$canonical_decomposition = getCanon($code_point)&quot;</dt>
  <dd>If the character is canonically decomposable (including Hangul Syllables),
      it returns the (full) canonical decomposition as a string. Otherwise it
      returns <span class="Li">&quot;undef&quot;</span>.
    <p class="Pp"><b>Note:</b> According to the Unicode standard, the canonical
        decomposition of the character that is not canonically decomposable is
        same as the character itself.</p>
  </dd>
  <dt>&quot;$compatibility_decomposition = getCompat($code_point)&quot;</dt>
  <dd>If the character is compatibility decomposable (including Hangul
      Syllables), it returns the (full) compatibility decomposition as a string.
      Otherwise it returns <span class="Li">&quot;undef&quot;</span>.
    <p class="Pp"><b>Note:</b> According to the Unicode standard, the
        compatibility decomposition of the character that is not compatibility
        decomposable is same as the character itself.</p>
  </dd>
  <dt>&quot;$code_point_composite = getComposite($code_point_here,
    $code_point_next)&quot;</dt>
  <dd>If two characters here and next (as code points) are composable (including
      Hangul Jamo/Syllables and Composition Exclusions), it returns the code
      point of the composite.
    <p class="Pp">If they are not composable, it returns
        <span class="Li">&quot;undef&quot;</span>.</p>
  </dd>
  <dt>&quot;$combining_class = getCombinClass($code_point)&quot;</dt>
  <dd>It returns the combining class (as an integer) of the character.</dd>
  <dt>&quot;$may_be_composed_with_prev_char = isComp2nd($code_point)&quot;</dt>
  <dd>It returns a boolean whether the character of the specified codepoint may
      be composed with the previous one in a certain composition (including
      Hangul Compositions, but excluding Composition Exclusions and Non-Starter
      Decompositions).</dd>
  <dt>&quot;$is_exclusion = isExclusion($code_point)&quot;</dt>
  <dd>It returns a boolean whether the code point is a composition
    exclusion.</dd>
  <dt>&quot;$is_singleton = isSingleton($code_point)&quot;</dt>
  <dd>It returns a boolean whether the code point is a singleton</dd>
  <dt>&quot;$is_non_starter_decomposition =
    isNonStDecomp($code_point)&quot;</dt>
  <dd>It returns a boolean whether the code point has Non-Starter
    Decomposition.</dd>
  <dt>&quot;$is_Full_Composition_Exclusion = isComp_Ex($code_point)&quot;</dt>
  <dd>It returns a boolean of the derived property Comp_Ex
      (Full_Composition_Exclusion). This property is generated from Composition
      Exclusions + Singletons + Non-Starter Decompositions.</dd>
  <dt>&quot;$NFD_is_NO = isNFD_NO($code_point)&quot;</dt>
  <dd>It returns a boolean of the derived property NFD_NO
    (NFD_Quick_Check=No).</dd>
  <dt>&quot;$NFC_is_NO = isNFC_NO($code_point)&quot;</dt>
  <dd>It returns a boolean of the derived property NFC_NO
    (NFC_Quick_Check=No).</dd>
  <dt>&quot;$NFC_is_MAYBE = isNFC_MAYBE($code_point)&quot;</dt>
  <dd>It returns a boolean of the derived property NFC_MAYBE
      (NFC_Quick_Check=Maybe).</dd>
  <dt>&quot;$NFKD_is_NO = isNFKD_NO($code_point)&quot;</dt>
  <dd>It returns a boolean of the derived property NFKD_NO
      (NFKD_Quick_Check=No).</dd>
  <dt>&quot;$NFKC_is_NO = isNFKC_NO($code_point)&quot;</dt>
  <dd>It returns a boolean of the derived property NFKC_NO
      (NFKC_Quick_Check=No).</dd>
  <dt>&quot;$NFKC_is_MAYBE = isNFKC_MAYBE($code_point)&quot;</dt>
  <dd>It returns a boolean of the derived property NFKC_MAYBE
      (NFKC_Quick_Check=Maybe).</dd>
</dl>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="EXPORT"><a class="permalink" href="#EXPORT">EXPORT</a></h1>
<span class="Li">&quot;NFC&quot;</span>,
  <span class="Li">&quot;NFD&quot;</span>,
  <span class="Li">&quot;NFKC&quot;</span>,
  <span class="Li">&quot;NFKD&quot;</span>: by default.
<p class="Pp"><span class="Li">&quot;normalize&quot;</span> and other some
    functions: on request.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="CAVEATS"><a class="permalink" href="#CAVEATS">CAVEATS</a></h1>
<dl class="Bl-tag">
  <dt>Perl's version vs. Unicode version</dt>
  <dd>Since this module refers to perl core's Unicode database in the directory
      <i>/lib/unicore</i> (or formerly <i>/lib/unicode</i>), the Unicode version
      of normalization implemented by this module depends on what has been
      compiled into your perl. The following table lists the default Unicode
      version that comes with various perl versions. (It is possible to change
      the Unicode version in any perl version to be any earlier Unicode version,
      so one could cause Unicode 3.2 to be used in any perl version starting
      with 5.8.0. Read <i></i><i>$Config{privlib}</i><i>/unicore/README.perl</i>
      for details.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    perl's version     implemented Unicode version
       5.6.1              3.0.1
       5.7.2              3.1.0
       5.7.3              3.1.1 (normalization is same as 3.1.0)
       5.8.0              3.2.0
         5.8.1-5.8.3      4.0.0
         5.8.4-5.8.6      4.0.1 (normalization is same as 4.0.0)
         5.8.7-5.8.8      4.1.0
       5.10.0             5.0.0
        5.8.9, 5.10.1     5.1.0
       5.12.x             5.2.0
       5.14.x             6.0.0
       5.16.x             6.1.0
       5.18.x             6.2.0
       5.20.x             6.3.0
       5.22.x             7.0.0
    </pre>
  </dd>
  <dt>Correction of decomposition mapping</dt>
  <dd>In older Unicode versions, a small number of characters (all of which are
      CJK compatibility ideographs as far as they have been found) may have an
      erroneous decomposition mapping (see <i>NormalizationCorrections.txt</i>).
      Anyhow, this module will neither refer to
      <i>NormalizationCorrections.txt</i> nor provide any specific version of
      normalization. Therefore this module running on an older perl with an
      older Unicode database may use the erroneous decomposition mapping blindly
      conforming to the Unicode database.</dd>
  <dt>Revised definition of canonical composition</dt>
  <dd>In Unicode 4.1.0, the definition D2 of canonical composition (which
      affects NFC and NFKC) has been changed (see Public Review Issue #29 and
      recent UAX #15). This module has used the newer definition since the
      version 0.07 (Oct 31, 2001). This module will not support the
      normalization according to the older definition, even if the Unicode
      version implemented by perl is lower than 4.1.0.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
SADAHIRO Tomoyuki &lt;SADAHIRO@cpan.org&gt;
<p class="Pp">Currently maintained by &lt;perl5-porters@perl.org&gt;</p>
<p class="Pp">Copyright(C) 2001-2012, SADAHIRO Tomoyuki. Japan. All rights
    reserved.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="LICENSE"><a class="permalink" href="#LICENSE">LICENSE</a></h1>
This module is free software; you can redistribute it and/or modify it under the
  same terms as Perl itself.
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<dl class="Bl-tag">
  <dt>http://www.unicode.org/reports/tr15/</dt>
  <dd>Unicode Normalization Forms - UAX #15</dd>
  <dt>http://www.unicode.org/Public/UNIDATA/CompositionExclusions.txt</dt>
  <dd>Composition Exclusion Table</dd>
  <dt>http://www.unicode.org/Public/UNIDATA/DerivedNormalizationProps.txt</dt>
  <dd>Derived Normalization Properties</dd>
  <dt>http://www.unicode.org/Public/UNIDATA/NormalizationCorrections.txt</dt>
  <dd>Normalization Corrections</dd>
  <dt>http://www.unicode.org/review/pr-29.html</dt>
  <dd>Public Review Issue #29: Normalization Issue</dd>
  <dt>http://www.unicode.org/notes/tn5/</dt>
  <dd>Canonical Equivalence in Applications - UTN #5</dd>
</dl>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2018-11-01</td>
    <td class="foot-os">perl v5.28.2</td>
  </tr>
</table>
</body>
</html>
