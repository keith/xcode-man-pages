<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Generated from file '/System/Volumes/Data/SWE/macOS/BuildRoots/c40be6c978/Library/Caches/com.apple.xbs/Sources/tcl/tcl-134/tcl_ext/tcllib/tcllib/modules/pt/pt_pgen.man' by tcllib/doctools with format 'nroff'
   Copyright (c) 2009 Andreas Kupries <andreas_kupries@users.sourceforge.net>
  
   The definitions below are for supplemental macros used in Tcl/Tk
   manual entries.
  
   .AP type name in/out ?indent?
  	Start paragraph describing an argument to a library procedure.
  	type is type of argument (int, etc.), in/out is either "in", "out",
  	or "in/out" to describe whether procedure reads or modifies arg,
  	and indent is equivalent to second arg of .IP (shouldn't ever be
  	needed;  use .AS below instead)
  
   .AS ?type? ?name?
  	Give maximum sizes of arguments for setting tab stops.  Type and
  	name are examples of largest possible arguments that will be passed
  	to .AP later.  If args are omitted, default tab stops are used.
  
   .BS
  	Start box enclosure.  From here until next .BE, everything will be
  	enclosed in one large box.
  
   .BE
  	End of box enclosure.
  
   .CS
  	Begin code excerpt.
  
   .CE
  	End code excerpt.
  
   .VS ?version? ?br?
  	Begin vertical sidebar, for use in marking newly-changed parts
  	of man pages.  The first argument is ignored and used for recording
  	the version when the .VS was added, so that the sidebars can be
  	found and removed when they reach a certain age.  If another argument
  	is present, then a line break is forced before starting the sidebar.
  
   .VE
  	End of vertical sidebar.
  
   .DS
  	Begin an indented unfilled display.
  
   .DE
  	End of indented unfilled display.
  
   .SO
  	Start of list of standard options for a Tk widget.  The
  	options follow on successive lines, in four columns separated
  	by tabs.
  
   .SE
  	End of list of standard options for a Tk widget.
  
   .OP cmdName dbName dbClass
  	Start of description of a specific option.  cmdName gives the
  	option's name as specified in the class command, dbName gives
  	the option's name in the option database, and dbClass gives
  	the option's class in the option database.
  
   .UL arg1 arg2
  	Print arg1 underlined, then print arg2 normally.
  
   RCS: @(#) $Id: man.macros,v 1.1 2009/01/30 04:56:47 andreas_kupries Exp $
  
  	# Set up traps and other miscellaneous stuff for Tcl/Tk man pages.
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    .Nd, .Bf, .Op { display: inline; }
    .Pa, .Ad { font-style: italic; }
    .Ms { font-weight: bold; }
    .Bl-diag > dt { font-weight: bold; }
    code.Nm, .Fl, .Cm, .Ic, code.In, .Fd, .Fn, .Cd { font-weight: bold;
      font-family: inherit; }
  </style>
  <title>pt::pgen(n)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">pt::pgen(n)</td>
    <td class="head-vol">Parser Tools</td>
    <td class="head-rtitle">pt::pgen(n)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<pre>
</pre>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">pt::pgen - Parser Generator</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<p class="Pp">package require <b>Tcl 8.5</b></p>
<p class="Pp">package require <b>pt::pgen ?1?</b></p>
<p class="Pp"><b>::pt::pgen</b> <i>inputformat</i> <i>text</i>
    <i>resultformat</i> ?<i>options...</i>?</p>
<p class="Pp"></p>
<pre>
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">Are you lost ? Do you have trouble understanding this document ?
    In that case please read the overview provided by the <i>Introduction to
    Parser Tools</i>. This document is the entrypoint to the whole system the
    current package is a part of.</p>
<p class="Pp">This package provides a command implementing a <i>parser
    generator</i> taking parsing expression grammars as input.</p>
<p class="Pp">It is the implementation of method <b>generate</b> of <b>pt</b>,
    the <i>Parser Tools Application</i>.</p>
<p class="Pp">As such the intended audience of this document are people wishing
    to modify and/or extend this part of <b>pt</b>'s functionality. Users of
    <b>pt</b> on the other hand are hereby refered to the applications' manpage,
    i.e. <i>Parser Tools Application</i>.</p>
<p class="Pp">It resides in the User Package Layer of Parser Tools.</p>
<p class="Pp">IMAGE: arch_user_pkg</p>
</section>
<section class="Sh">
<h1 class="Sh" id="API"><a class="permalink" href="#API">API</a></h1>
<dl class="Bl-tag">
  <dt><b>::pt::pgen</b> <i>inputformat</i> <i>text</i> <i>resultformat</i>
    ?<i>options...</i>?</dt>
  <dd>This command takes the parsing expression grammar in <i>text</i> (in the
      format specified by <i>inputformat</i>), and returns the same grammar in
      the format <i>resultformat</i> as the result of the command.
    <p class="Pp">The two known input formats are <b>peg</b> and <b>json</b>.
        Introductions to them, including their formal specifications, can be
        found in the <i>PEG Language Tutorial</i> and <i>The JSON Grammar
        Exchange Format</i>. The packages used to parse these formats are</p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="peg"><a class="permalink" href="#peg"><b>peg</b></a></dt>
  <dd><b>pt::peg::from::peg</b></dd>
  <dt id="json"><a class="permalink" href="#json"><b>json</b></a></dt>
  <dd><b>pt::peg::from::json</b></dd>
</dl>
</div>
<p class="Pp">On the output side the known formats, and the packages used to
    generate them are</p>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="c"><a class="permalink" href="#c"><b>c</b></a></dt>
  <dd><b>pt::peg::to::cparam</b></dd>
  <dt id="container"><a class="permalink" href="#container"><b>container</b></a></dt>
  <dd><b>pt::peg::to::container</b></dd>
  <dt id="critcl"><a class="permalink" href="#critcl"><b>critcl</b></a></dt>
  <dd><b>pt::peg::to::cparam</b> + <b>pt::cparam::configuration::critcl</b></dd>
  <dt id="json~2"><a class="permalink" href="#json~2"><b>json</b></a></dt>
  <dd><b>pt::peg::to::json</b></dd>
  <dt id="oo"><a class="permalink" href="#oo"><b>oo</b></a></dt>
  <dd><b>pt::peg::to::tclparam</b> +
    <b>pt::tclparam::configuration::tcloo</b></dd>
  <dt id="peg~2"><a class="permalink" href="#peg~2"><b>peg</b></a></dt>
  <dd><b>pt::peg::to::peg</b></dd>
  <dt id="snit"><a class="permalink" href="#snit"><b>snit</b></a></dt>
  <dd><b>pt::peg::to::tclparam</b> +
    <b>pt::tclparam::configuration::snit</b></dd>
</dl>
</div>
The options supported by each of these formats are documented with their
  respective packages.
</section>
<section class="Sh">
<h1 class="Sh" id="EXAMPLE"><a class="permalink" href="#EXAMPLE">EXAMPLE</a></h1>
<p class="Pp">In this section we are working a complete example, starting with a
    PEG grammar and ending with running the parser generated from it over some
    input, following the outline shown in the figure below:</p>
<p class="Pp">IMAGE: flow</p>
<p class="Pp">Our grammar, assumed to the stored in the file
    &quot;<i>calculator.peg</i>&quot; is</p>
<pre>
PEG calculator (Expression)
<br/>
    Digit      &lt;- '0'/'1'/'2'/'3'/'4'/'5'/'6'/'7'/'8'/'9'	;
<br/>
    Sign       &lt;- '-' / '+'					;
<br/>
    Number     &lt;- Sign? Digit+					;
<br/>
    Expression &lt;- '(' Expression ')' / (Factor (MulOp Factor)*)	;
<br/>
    MulOp      &lt;- '*' / '/'					;
<br/>
    Factor     &lt;- Term (AddOp Term)*				;
<br/>
    AddOp      &lt;- '+'/'-'					;
<br/>
    Term       &lt;- Number					;
END;
</pre>
From this we create a snit-based parser using the script &quot;<i>gen</i>&quot;
<pre>
package require Tcl 8.5
package require fileutil
package require pt::pgen
lassign $argv name
set grammar [fileutil::cat $name.peg]
set plass [pt::pgen
<br/>
              peg $gr  snit  -class $name      -file  $name.peg  -name  $name]
fileutil::writeFile $name.tcl $pclass
exit 0
</pre>
calling it like
<pre>
<br/>
 tclsh8.5 gen calculator</pre>
which leaves us with the parser package and class written to the file
  &quot;<i>calculator.tcl</i>&quot;. Assuming that this package is then properly
  installed in a place where Tcl can find it we can now use this class via a
  script like
<pre>
<br/>
    package require calculator
<br/>
    lassign $argv input
<br/>
    set channel [open $input r]
<br/>
    set parser [calculator]
<br/>
    set ast [$parser parse $channel]
<br/>
    $parser destroy
<br/>
    close $channel
<br/>
    ... now process the returned abstract syntax tree ...
</pre>
where the abstract syntax tree stored in the variable will look like
<p class="Pp"></p>
<pre>
set ast {Expression 0 4
<br/>
    {Factor 0 4
<br/>
        {Term 0 2
<br/>
            {Number 0 2
<br/>
                {Digit 0 0}
<br/>
                {Digit 1 1}
<br/>
                {Digit 2 2}
<br/>
            }
<br/>
        }
<br/>
        {AddOp 3 3}
<br/>
        {Term 4 4
<br/>
            {Number 4 4
<br/>
                {Digit 4 4}
<br/>
            }
<br/>
        }
<br/>
    }
}
</pre>
<p class="Pp">assuming that the input file and channel contained the text</p>
<pre>
<br/>
 120+5</pre>
A more graphical representation of the tree would be
<p class="Pp">IMAGE: expr_ast</p>
<p class="Pp">Regardless, at this point it is the user's responsibility to work
    with the tree to reach whatever goal she desires. I.e. analyze it, transform
    it, etc. The package <b>pt::ast</b> should be of help here, providing
    commands to walk such ASTs structures in various ways.</p>
<p class="Pp">One important thing to note is that the parsers used here return a
    data structure representing the structure of the input per the grammar
    underlying the parser. There are <i>no</i> callbacks during the parsing
    process, i.e. no <i>parsing actions</i>, as most other parsers will
  have.</p>
<p class="Pp">Going back to the last snippet of code, the execution of the
    parser for some input, note how the parser instance follows the specified
    <i>Parser API</i>.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="BUGS,_IDEAS,_FEEDBACK"><a class="permalink" href="#BUGS,_IDEAS,_FEEDBACK">BUGS,
  IDEAS, FEEDBACK</a></h1>
<p class="Pp">This document, and the package it describes, will undoubtedly
    contain bugs and other problems. Please report such in the category
    <i>pt</i> of the <i>Tcllib SF Trackers</i>
    [http://sourceforge.net/tracker/?group_id=12883]. Please also report any
    ideas for enhancements you may have for either package and/or
  documentation.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="KEYWORDS"><a class="permalink" href="#KEYWORDS">KEYWORDS</a></h1>
<p class="Pp">EBNF, LL(k), PEG, TDPL, context-free languages, expression,
    grammar, matching, parser, parsing expression, parsing expression grammar,
    push down automaton, recursive descent, state, top-down parsing languages,
    transducer</p>
</section>
<section class="Sh">
<h1 class="Sh" id="CATEGORY"><a class="permalink" href="#CATEGORY">CATEGORY</a></h1>
<p class="Pp">Parsing and Grammars</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT"><a class="permalink" href="#COPYRIGHT">COPYRIGHT</a></h1>
<pre>Copyright (c) 2009 Andreas Kupries &lt;andreas_kupries@users.sourceforge.net&gt;
</pre>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">1</td>
    <td class="foot-os">pt</td>
  </tr>
</table>
</body>
</html>
