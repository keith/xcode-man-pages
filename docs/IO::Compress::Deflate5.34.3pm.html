<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    .Nd, .Bf, .Op { display: inline; }
    .Pa, .Ad { font-style: italic; }
    .Ms { font-weight: bold; }
    .Bl-diag > dt { font-weight: bold; }
    code.Nm, .Fl, .Cm, .Ic, code.In, .Fd, .Fn, .Cd { font-weight: bold;
      font-family: inherit; }
  </style>
  <title>IO::Compress::Deflate(3pm)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">IO::Compress::Deflate(3pm)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">IO::Compress::Deflate(3pm)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">IO::Compress::Deflate - Write RFC 1950 files/buffers</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>    use IO::Compress::Deflate qw(deflate $DeflateError) ;
    my $status = deflate $input =&gt; $output [,OPTS]
        or die &quot;deflate failed: $DeflateError\n&quot;;
    my $z = IO::Compress::Deflate-&gt;new( $output [,OPTS] )
        or die &quot;deflate failed: $DeflateError\n&quot;;
    $z-&gt;print($string);
    $z-&gt;printf($format, $string);
    $z-&gt;write($string);
    $z-&gt;syswrite($string [, $length, $offset]);
    $z-&gt;flush();
    $z-&gt;tell();
    $z-&gt;eof();
    $z-&gt;seek($position, $whence);
    $z-&gt;binmode();
    $z-&gt;fileno();
    $z-&gt;opened();
    $z-&gt;autoflush();
    $z-&gt;input_line_number();
    $z-&gt;newStream( [OPTS] );
    $z-&gt;deflateParams();
    $z-&gt;close() ;
    $DeflateError ;
    # IO::File mode
    print $z $string;
    printf $z $format, $string;
    tell $z
    eof $z
    seek $z, $position, $whence
    binmode $z
    fileno $z
    close $z ;
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">This module provides a Perl interface that allows writing
    compressed data to files or buffer as defined in RFC 1950.</p>
<p class="Pp">For reading RFC 1950 files/buffers, see the companion module
    IO::Uncompress::Inflate.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="Functional_Interface"><a class="permalink" href="#Functional_Interface">Functional
  Interface</a></h1>
<p class="Pp">A top-level function, <span class="Li">&quot;deflate&quot;</span>,
    is provided to carry out &quot;one-shot&quot; compression between buffers
    and/or files. For finer control over the compression process, see the
    &quot;OO Interface&quot; section.</p>
<p class="Pp"></p>
<pre>    use IO::Compress::Deflate qw(deflate $DeflateError) ;
    deflate $input_filename_or_reference =&gt; $output_filename_or_reference [,OPTS]
        or die &quot;deflate failed: $DeflateError\n&quot;;
</pre>
<p class="Pp">The functional interface needs Perl5.005 or better.</p>
<section class="Ss">
<h2 class="Ss" id="deflate_$input_filename_or_reference_=__$output_filename_or_reference__,_"><a class="permalink" href="#deflate_$input_filename_or_reference_=__$output_filename_or_reference__,_">deflate
  $input_filename_or_reference =&gt; $output_filename_or_reference [,
  OPTS]</a></h2>
<p class="Pp"><span class="Li">&quot;deflate&quot;</span> expects at least two
    parameters, <span class="Li">$input_filename_or_reference</span> and
    <span class="Li">$output_filename_or_reference</span> and zero or more
    optional parameters (see &quot;Optional Parameters&quot;)</p>
<p class="Pp"><i>The
    </i><span class="Li"><i>$input_filename_or_reference</i></span><i>
    parameter</i></p>
<p class="Pp">The parameter,
    <span class="Li">$input_filename_or_reference</span>, is used to define the
    source of the uncompressed data.</p>
<p class="Pp">It can take one of the following forms:</p>
<dl class="Bl-tag">
  <dt id="A"><a class="permalink" href="#A">A filename</a></dt>
  <dd>If the <span class="Li">$input_filename_or_reference</span> parameter is a
      simple scalar, it is assumed to be a filename. This file will be opened
      for reading and the input data will be read from it.</dd>
  <dt id="A~2"><a class="permalink" href="#A~2">A filehandle</a></dt>
  <dd>If the <span class="Li">$input_filename_or_reference</span> parameter is a
      filehandle, the input data will be read from it. The string '-' can be
      used as an alias for standard input.</dd>
  <dt id="A~3"><a class="permalink" href="#A~3">A scalar reference</a></dt>
  <dd>If <span class="Li">$input_filename_or_reference</span> is a scalar
      reference, the input data will be read from
      <span class="Li">$$input_filename_or_reference</span>.</dd>
  <dt id="An"><a class="permalink" href="#An">An array reference</a></dt>
  <dd>If <span class="Li">$input_filename_or_reference</span> is an array
      reference, each element in the array must be a filename.
    <p class="Pp">The input data will be read from each file in turn.</p>
    <p class="Pp">The complete array will be walked to ensure that it only
        contains valid filenames before any data is compressed.</p>
  </dd>
  <dt id="An~2"><a class="permalink" href="#An~2">An Input FileGlob
    string</a></dt>
  <dd>If <span class="Li">$input_filename_or_reference</span> is a string that
      is delimited by the characters &quot;&lt;&quot; and &quot;&gt;&quot;
      <span class="Li">&quot;deflate&quot;</span> will assume that it is an
      <i>input fileglob string</i>. The input is the list of files that match
      the fileglob.
    <p class="Pp">See File::GlobMapper for more details.</p>
  </dd>
</dl>
<p class="Pp">If the <span class="Li">$input_filename_or_reference</span>
    parameter is any other type, <span class="Li">&quot;undef&quot;</span> will
    be returned.</p>
<p class="Pp"><i>The
    </i><span class="Li"><i>$output_filename_or_reference</i></span><i>
    parameter</i></p>
<p class="Pp">The parameter
    <span class="Li">$output_filename_or_reference</span> is used to control the
    destination of the compressed data. This parameter can take one of these
    forms.</p>
<dl class="Bl-tag">
  <dt id="A~4"><a class="permalink" href="#A~4">A filename</a></dt>
  <dd>If the <span class="Li">$output_filename_or_reference</span> parameter is
      a simple scalar, it is assumed to be a filename. This file will be opened
      for writing and the compressed data will be written to it.</dd>
  <dt id="A~5"><a class="permalink" href="#A~5">A filehandle</a></dt>
  <dd>If the <span class="Li">$output_filename_or_reference</span> parameter is
      a filehandle, the compressed data will be written to it. The string '-'
      can be used as an alias for standard output.</dd>
  <dt id="A~6"><a class="permalink" href="#A~6">A scalar reference</a></dt>
  <dd>If <span class="Li">$output_filename_or_reference</span> is a scalar
      reference, the compressed data will be stored in
      <span class="Li">$$output_filename_or_reference</span>.</dd>
  <dt id="An~3"><a class="permalink" href="#An~3">An Array Reference</a></dt>
  <dd>If <span class="Li">$output_filename_or_reference</span> is an array
      reference, the compressed data will be pushed onto the array.</dd>
  <dt id="An~4"><a class="permalink" href="#An~4">An Output FileGlob</a></dt>
  <dd>If <span class="Li">$output_filename_or_reference</span> is a string that
      is delimited by the characters &quot;&lt;&quot; and &quot;&gt;&quot;
      <span class="Li">&quot;deflate&quot;</span> will assume that it is an
      <i>output fileglob string</i>. The output is the list of files that match
      the fileglob.
    <p class="Pp">When <span class="Li">$output_filename_or_reference</span> is
        an fileglob string, <span class="Li">$input_filename_or_reference</span>
        must also be a fileglob string. Anything else is an error.</p>
    <p class="Pp">See File::GlobMapper for more details.</p>
  </dd>
</dl>
<p class="Pp">If the <span class="Li">$output_filename_or_reference</span>
    parameter is any other type, <span class="Li">&quot;undef&quot;</span> will
    be returned.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Notes"><a class="permalink" href="#Notes">Notes</a></h2>
<p class="Pp">When <span class="Li">$input_filename_or_reference</span> maps to
    multiple files/buffers and
    <span class="Li">$output_filename_or_reference</span> is a single
    file/buffer the input files/buffers will be stored in
    <span class="Li">$output_filename_or_reference</span> as a concatenated
    series of compressed data streams.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Optional_Parameters"><a class="permalink" href="#Optional_Parameters">Optional
  Parameters</a></h2>
<p class="Pp">The optional parameters for the one-shot function
    <span class="Li">&quot;deflate&quot;</span> are (for the most part)
    identical to those used with the OO interface defined in the
    &quot;Constructor Options&quot; section. The exceptions are listed below</p>
<dl class="Bl-tag">
  <dt>&quot;AutoClose =&gt; 0|1&quot;</dt>
  <dd>This option applies to any input or output data streams to
      <span class="Li">&quot;deflate&quot;</span> that are filehandles.
    <p class="Pp">If <span class="Li">&quot;AutoClose&quot;</span> is specified,
        and the value is true, it will result in all input and/or output
        filehandles being closed once
        <span class="Li">&quot;deflate&quot;</span> has completed.</p>
    <p class="Pp">This parameter defaults to 0.</p>
  </dd>
  <dt>&quot;BinModeIn =&gt; 0|1&quot;</dt>
  <dd>This option is now a no-op. All files will be read in binmode.</dd>
  <dt>&quot;Append =&gt; 0|1&quot;</dt>
  <dd>The behaviour of this option is dependent on the type of output data
      stream.</dd>
</dl>
<div class="Bd-indent">
<ul class="Bl-bullet">
  <li>A Buffer
    <p class="Pp">If <span class="Li">&quot;Append&quot;</span> is enabled, all
        compressed data will be append to the end of the output buffer.
        Otherwise the output buffer will be cleared before any compressed data
        is written to it.</p>
  </li>
  <li>A Filename
    <p class="Pp">If <span class="Li">&quot;Append&quot;</span> is enabled, the
        file will be opened in append mode. Otherwise the contents of the file,
        if any, will be truncated before any compressed data is written to
      it.</p>
  </li>
  <li>A Filehandle
    <p class="Pp">If <span class="Li">&quot;Append&quot;</span> is enabled, the
        filehandle will be positioned to the end of the file via a call to
        <span class="Li">&quot;seek&quot;</span> before any compressed data is
        written to it. Otherwise the file pointer will not be moved.</p>
  </li>
</ul>
</div>
<div class="Bd-indent">
<p class="Pp">When <span class="Li">&quot;Append&quot;</span> is specified, and
    set to true, it will <i>append</i> all compressed data to the output data
    stream.</p>
<p class="Pp">So when the output is a filehandle it will carry out a seek to the
    eof before writing any compressed data. If the output is a filename, it will
    be opened for appending. If the output is a buffer, all compressed data will
    be appended to the existing buffer.</p>
<p class="Pp">Conversely when <span class="Li">&quot;Append&quot;</span> is not
    specified, or it is present and is set to false, it will operate as
  follows.</p>
<p class="Pp">When the output is a filename, it will truncate the contents of
    the file before writing any compressed data. If the output is a filehandle
    its position will not be changed. If the output is a buffer, it will be
    wiped before any compressed data is output.</p>
<p class="Pp">Defaults to 0.</p>
</div>
</section>
<section class="Ss">
<h2 class="Ss" id="Examples"><a class="permalink" href="#Examples">Examples</a></h2>
<p class="Pp">Here are a few example that show the capabilities of the
  module.</p>
<p class="Pp"><i>Streaming</i></p>
<p class="Pp">This very simple command line example demonstrates the streaming
    capabilities of the module. The code reads data from STDIN, compresses it,
    and writes the compressed data to STDOUT.</p>
<p class="Pp"></p>
<pre>    $ echo hello world | perl -MIO::Compress::Deflate=deflate -e 'deflate \*STDIN =&gt; \*STDOUT' &gt;output.1950
</pre>
<p class="Pp">The special filename &quot;-&quot; can be used as a standin for
    both <span class="Li">&quot;\*STDIN&quot;</span> and
    <span class="Li">&quot;\*STDOUT&quot;</span>, so the above can be rewritten
    as</p>
<p class="Pp"></p>
<pre>    $ echo hello world | perl -MIO::Compress::Deflate=deflate -e 'deflate &quot;-&quot; =&gt; &quot;-&quot;' &gt;output.1950
</pre>
<p class="Pp"><i>Compressing a file from the filesystem</i></p>
<p class="Pp">To read the contents of the file
    <span class="Li">&quot;file1.txt&quot;</span> and write the compressed data
    to the file <span class="Li">&quot;file1.txt.1950&quot;</span>.</p>
<p class="Pp"></p>
<pre>    use strict ;
    use warnings ;
    use IO::Compress::Deflate qw(deflate $DeflateError) ;
    my $input = &quot;file1.txt&quot;;
    deflate $input =&gt; &quot;$input.1950&quot;
        or die &quot;deflate failed: $DeflateError\n&quot;;
</pre>
<p class="Pp"><i>Reading from a Filehandle and writing to an in-memory
    buffer</i></p>
<p class="Pp">To read from an existing Perl filehandle,
    <span class="Li">$input</span>, and write the compressed data to a buffer,
    <span class="Li">$buffer</span>.</p>
<p class="Pp"></p>
<pre>    use strict ;
    use warnings ;
    use IO::Compress::Deflate qw(deflate $DeflateError) ;
    use IO::File ;
    my $input = IO::File-&gt;new( &quot;&lt;file1.txt&quot; )
        or die &quot;Cannot open 'file1.txt': $!\n&quot; ;
    my $buffer ;
    deflate $input =&gt; \$buffer
        or die &quot;deflate failed: $DeflateError\n&quot;;
</pre>
<p class="Pp"><i>Compressing multiple files</i></p>
<p class="Pp">To compress all files in the directory &quot;/my/home&quot; that
    match &quot;*.txt&quot; and store the compressed data in the same
  directory</p>
<p class="Pp"></p>
<pre>    use strict ;
    use warnings ;
    use IO::Compress::Deflate qw(deflate $DeflateError) ;
    deflate '&lt;/my/home/*.txt&gt;' =&gt; '&lt;*.1950&gt;'
        or die &quot;deflate failed: $DeflateError\n&quot;;
</pre>
<p class="Pp">and if you want to compress each file one at a time, this will do
    the trick</p>
<p class="Pp"></p>
<pre>    use strict ;
    use warnings ;
    use IO::Compress::Deflate qw(deflate $DeflateError) ;
    for my $input ( glob &quot;/my/home/*.txt&quot; )
    {
        my $output = &quot;$input.1950&quot; ;
        deflate $input =&gt; $output
            or die &quot;Error compressing '$input': $DeflateError\n&quot;;
    }
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="OO_Interface"><a class="permalink" href="#OO_Interface">OO
  Interface</a></h1>
<section class="Ss">
<h2 class="Ss" id="Constructor"><a class="permalink" href="#Constructor">Constructor</a></h2>
<p class="Pp">The format of the constructor for
    <span class="Li">&quot;IO::Compress::Deflate&quot;</span> is shown below</p>
<p class="Pp"></p>
<pre>    my $z = IO::Compress::Deflate-&gt;new( $output [,OPTS] )
        or die &quot;IO::Compress::Deflate failed: $DeflateError\n&quot;;
</pre>
<p class="Pp">It returns an
    <span class="Li">&quot;IO::Compress::Deflate&quot;</span> object on success
    and undef on failure. The variable <span class="Li">$DeflateError</span>
    will contain an error message on failure.</p>
<p class="Pp">If you are running Perl 5.005 or better the object,
    <span class="Li">$z</span>, returned from IO::Compress::Deflate can be used
    exactly like an IO::File filehandle. This means that all normal output file
    operations can be carried out with <span class="Li">$z</span>. For example,
    to write to a compressed file/buffer you can use either of these forms</p>
<p class="Pp"></p>
<pre>    $z-&gt;print(&quot;hello world\n&quot;);
    print $z &quot;hello world\n&quot;;
</pre>
<p class="Pp">The mandatory parameter <span class="Li">$output</span> is used to
    control the destination of the compressed data. This parameter can take one
    of these forms.</p>
<dl class="Bl-tag">
  <dt id="A~7"><a class="permalink" href="#A~7">A filename</a></dt>
  <dd>If the <span class="Li">$output</span> parameter is a simple scalar, it is
      assumed to be a filename. This file will be opened for writing and the
      compressed data will be written to it.</dd>
  <dt id="A~8"><a class="permalink" href="#A~8">A filehandle</a></dt>
  <dd>If the <span class="Li">$output</span> parameter is a filehandle, the
      compressed data will be written to it. The string '-' can be used as an
      alias for standard output.</dd>
  <dt id="A~9"><a class="permalink" href="#A~9">A scalar reference</a></dt>
  <dd>If <span class="Li">$output</span> is a scalar reference, the compressed
      data will be stored in <span class="Li">$$output</span>.</dd>
</dl>
<p class="Pp">If the <span class="Li">$output</span> parameter is any other
    type, <span class="Li">&quot;IO::Compress::Deflate&quot;</span>::new will
    return undef.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Constructor_Options"><a class="permalink" href="#Constructor_Options">Constructor
  Options</a></h2>
<p class="Pp"><span class="Li">&quot;OPTS&quot;</span> is any combination of
    zero or more the following options:</p>
<dl class="Bl-tag">
  <dt>&quot;AutoClose =&gt; 0|1&quot;</dt>
  <dd>This option is only valid when the <span class="Li">$output</span>
      parameter is a filehandle. If specified, and the value is true, it will
      result in the <span class="Li">$output</span> being closed once either the
      <span class="Li">&quot;close&quot;</span> method is called or the
      <span class="Li">&quot;IO::Compress::Deflate&quot;</span> object is
      destroyed.
    <p class="Pp">This parameter defaults to 0.</p>
  </dd>
  <dt>&quot;Append =&gt; 0|1&quot;</dt>
  <dd>Opens <span class="Li">$output</span> in append mode.
    <p class="Pp">The behaviour of this option is dependent on the type of
        <span class="Li">$output</span>.</p>
  </dd>
</dl>
<div class="Bd-indent">
<ul class="Bl-bullet">
  <li>A Buffer
    <p class="Pp">If <span class="Li">$output</span> is a buffer and
        <span class="Li">&quot;Append&quot;</span> is enabled, all compressed
        data will be append to the end of <span class="Li">$output</span>.
        Otherwise <span class="Li">$output</span> will be cleared before any
        data is written to it.</p>
  </li>
  <li>A Filename
    <p class="Pp">If <span class="Li">$output</span> is a filename and
        <span class="Li">&quot;Append&quot;</span> is enabled, the file will be
        opened in append mode. Otherwise the contents of the file, if any, will
        be truncated before any compressed data is written to it.</p>
  </li>
  <li>A Filehandle
    <p class="Pp">If <span class="Li">$output</span> is a filehandle, the file
        pointer will be positioned to the end of the file via a call to
        <span class="Li">&quot;seek&quot;</span> before any compressed data is
        written to it. Otherwise the file pointer will not be moved.</p>
  </li>
</ul>
</div>
<div class="Bd-indent">
<p class="Pp">This parameter defaults to 0.</p>
</div>
<dl class="Bl-tag">
  <dt>&quot;Merge =&gt; 0|1&quot;</dt>
  <dd>This option is used to compress input data and append it to an existing
      compressed data stream in <span class="Li">$output</span>. The end result
      is a single compressed data stream stored in
      <span class="Li">$output</span>.
    <p class="Pp">It is a fatal error to attempt to use this option when
        <span class="Li">$output</span> is not an RFC 1950 data stream.</p>
    <p class="Pp">There are a number of other limitations with the
        <span class="Li">&quot;Merge&quot;</span> option:</p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>1.</dt>
  <dd>This module needs to have been built with zlib 1.2.1 or better to work. A
      fatal error will be thrown if <span class="Li">&quot;Merge&quot;</span> is
      used with an older version of zlib.</dd>
  <dt>2.</dt>
  <dd>If <span class="Li">$output</span> is a file or a filehandle, it must be
      seekable.</dd>
</dl>
</div>
<div class="Bd-indent">
<p class="Pp">This parameter defaults to 0.</p>
</div>
<dl class="Bl-tag">
  <dt id="Level"><a class="permalink" href="#Level">-Level</a></dt>
  <dd>Defines the compression level used by zlib. The value should either be a
      number between 0 and 9 (0 means no compression and 9 is maximum
      compression), or one of the symbolic constants defined below.
    <p class="Pp"></p>
    <pre>   Z_NO_COMPRESSION
   Z_BEST_SPEED
   Z_BEST_COMPRESSION
   Z_DEFAULT_COMPRESSION
    </pre>
    <p class="Pp">The default is Z_DEFAULT_COMPRESSION.</p>
    <p class="Pp">Note, these constants are not imported by
        <span class="Li">&quot;IO::Compress::Deflate&quot;</span> by
      default.</p>
    <p class="Pp"></p>
    <pre>    use IO::Compress::Deflate qw(:strategy);
    use IO::Compress::Deflate qw(:constants);
    use IO::Compress::Deflate qw(:all);
    </pre>
  </dd>
  <dt id="Strategy"><a class="permalink" href="#Strategy">-Strategy</a></dt>
  <dd>Defines the strategy used to tune the compression. Use one of the symbolic
      constants defined below.
    <p class="Pp"></p>
    <pre>   Z_FILTERED
   Z_HUFFMAN_ONLY
   Z_RLE
   Z_FIXED
   Z_DEFAULT_STRATEGY
    </pre>
    <p class="Pp">The default is Z_DEFAULT_STRATEGY.</p>
  </dd>
  <dt>&quot;Strict =&gt; 0|1&quot;</dt>
  <dd>This is a placeholder option.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Examples~2"><a class="permalink" href="#Examples~2">Examples</a></h2>
<p class="Pp">TODO</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="Methods"><a class="permalink" href="#Methods">Methods</a></h1>
<section class="Ss">
<h2 class="Ss" id="print"><a class="permalink" href="#print">print</a></h2>
<p class="Pp">Usage is</p>
<p class="Pp"></p>
<pre>    $z-&gt;print($data)
    print $z $data
</pre>
<p class="Pp">Compresses and outputs the contents of the
    <span class="Li">$data</span> parameter. This has the same behaviour as the
    <span class="Li">&quot;print&quot;</span> built-in.</p>
<p class="Pp">Returns true if successful.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="printf"><a class="permalink" href="#printf">printf</a></h2>
<p class="Pp">Usage is</p>
<p class="Pp"></p>
<pre>    $z-&gt;printf($format, $data)
    printf $z $format, $data
</pre>
<p class="Pp">Compresses and outputs the contents of the
    <span class="Li">$data</span> parameter.</p>
<p class="Pp">Returns true if successful.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="syswrite"><a class="permalink" href="#syswrite">syswrite</a></h2>
<p class="Pp">Usage is</p>
<p class="Pp"></p>
<pre>    $z-&gt;syswrite $data
    $z-&gt;syswrite $data, $length
    $z-&gt;syswrite $data, $length, $offset
</pre>
<p class="Pp">Compresses and outputs the contents of the
    <span class="Li">$data</span> parameter.</p>
<p class="Pp">Returns the number of uncompressed bytes written, or
    <span class="Li">&quot;undef&quot;</span> if unsuccessful.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="write"><a class="permalink" href="#write">write</a></h2>
<p class="Pp">Usage is</p>
<p class="Pp"></p>
<pre>    $z-&gt;write $data
    $z-&gt;write $data, $length
    $z-&gt;write $data, $length, $offset
</pre>
<p class="Pp">Compresses and outputs the contents of the
    <span class="Li">$data</span> parameter.</p>
<p class="Pp">Returns the number of uncompressed bytes written, or
    <span class="Li">&quot;undef&quot;</span> if unsuccessful.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="flush"><a class="permalink" href="#flush">flush</a></h2>
<p class="Pp">Usage is</p>
<p class="Pp"></p>
<pre>    $z-&gt;flush;
    $z-&gt;flush($flush_type);
</pre>
<p class="Pp">Flushes any pending compressed data to the output file/buffer.</p>
<p class="Pp">This method takes an optional parameter,
    <span class="Li">$flush_type</span>, that controls how the flushing will be
    carried out. By default the <span class="Li">$flush_type</span> used is
    <span class="Li">&quot;Z_FINISH&quot;</span>. Other valid values for
    <span class="Li">$flush_type</span> are
    <span class="Li">&quot;Z_NO_FLUSH&quot;</span>,
    <span class="Li">&quot;Z_SYNC_FLUSH&quot;</span>,
    <span class="Li">&quot;Z_FULL_FLUSH&quot;</span> and
    <span class="Li">&quot;Z_BLOCK&quot;</span>. It is strongly recommended that
    you only set the <span class="Li">&quot;flush_type&quot;</span> parameter if
    you fully understand the implications of what it does - overuse of
    <span class="Li">&quot;flush&quot;</span> can seriously degrade the level of
    compression achieved. See the <span class="Li">&quot;zlib&quot;</span>
    documentation for details.</p>
<p class="Pp">Returns true on success.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="tell"><a class="permalink" href="#tell">tell</a></h2>
<p class="Pp">Usage is</p>
<p class="Pp"></p>
<pre>    $z-&gt;tell()
    tell $z
</pre>
<p class="Pp">Returns the uncompressed file offset.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="eof"><a class="permalink" href="#eof">eof</a></h2>
<p class="Pp">Usage is</p>
<p class="Pp"></p>
<pre>    $z-&gt;eof();
    eof($z);
</pre>
<p class="Pp">Returns true if the <span class="Li">&quot;close&quot;</span>
    method has been called.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="seek"><a class="permalink" href="#seek">seek</a></h2>
<pre>    $z-&gt;seek($position, $whence);
    seek($z, $position, $whence);
</pre>
<p class="Pp">Provides a sub-set of the <span class="Li">&quot;seek&quot;</span>
    functionality, with the restriction that it is only legal to seek forward in
    the output file/buffer. It is a fatal error to attempt to seek backward.</p>
<p class="Pp">Empty parts of the file/buffer will have NULL (0x00) bytes written
    to them.</p>
<p class="Pp">The <span class="Li">$whence</span> parameter takes one the usual
    values, namely SEEK_SET, SEEK_CUR or SEEK_END.</p>
<p class="Pp">Returns 1 on success, 0 on failure.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="binmode"><a class="permalink" href="#binmode">binmode</a></h2>
<p class="Pp">Usage is</p>
<p class="Pp"></p>
<pre>    $z-&gt;binmode
    binmode $z ;
</pre>
<p class="Pp">This is a noop provided for completeness.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="opened"><a class="permalink" href="#opened">opened</a></h2>
<pre>    $z-&gt;opened()
</pre>
<p class="Pp">Returns true if the object currently refers to a opened
    file/buffer.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="autoflush"><a class="permalink" href="#autoflush">autoflush</a></h2>
<pre>    my $prev = $z-&gt;autoflush()
    my $prev = $z-&gt;autoflush(EXPR)
</pre>
<p class="Pp">If the <span class="Li">$z</span> object is associated with a file
    or a filehandle, this method returns the current autoflush setting for the
    underlying filehandle. If <span class="Li">&quot;EXPR&quot;</span> is
    present, and is non-zero, it will enable flushing after every write/print
    operation.</p>
<p class="Pp">If <span class="Li">$z</span> is associated with a buffer, this
    method has no effect and always returns
    <span class="Li">&quot;undef&quot;</span>.</p>
<p class="Pp"><b>Note</b> that the special variable <span class="Li">$|</span>
    <b>cannot</b> be used to set or retrieve the autoflush setting.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="input_line_number"><a class="permalink" href="#input_line_number">input_line_number</a></h2>
<pre>    $z-&gt;input_line_number()
    $z-&gt;input_line_number(EXPR)
</pre>
<p class="Pp">This method always returns
    <span class="Li">&quot;undef&quot;</span> when compressing.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="fileno"><a class="permalink" href="#fileno">fileno</a></h2>
<pre>    $z-&gt;fileno()
    fileno($z)
</pre>
<p class="Pp">If the <span class="Li">$z</span> object is associated with a file
    or a filehandle, <span class="Li">&quot;fileno&quot;</span> will return the
    underlying file descriptor. Once the
    <span class="Li">&quot;close&quot;</span> method is called
    <span class="Li">&quot;fileno&quot;</span> will return
    <span class="Li">&quot;undef&quot;</span>.</p>
<p class="Pp">If the <span class="Li">$z</span> object is associated with a
    buffer, this method will return
  <span class="Li">&quot;undef&quot;</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="close"><a class="permalink" href="#close">close</a></h2>
<pre>    $z-&gt;close() ;
    close $z ;
</pre>
<p class="Pp">Flushes any pending compressed data and then closes the output
    file/buffer.</p>
<p class="Pp">For most versions of Perl this method will be automatically
    invoked if the IO::Compress::Deflate object is destroyed (either explicitly
    or by the variable with the reference to the object going out of scope). The
    exceptions are Perl versions 5.005 through 5.00504 and 5.8.0. In these
    cases, the <span class="Li">&quot;close&quot;</span> method will be called
    automatically, but not until global destruction of all live objects when the
    program is terminating.</p>
<p class="Pp">Therefore, if you want your scripts to be able to run on all
    versions of Perl, you should call <span class="Li">&quot;close&quot;</span>
    explicitly and not rely on automatic closing.</p>
<p class="Pp">Returns true on success, otherwise 0.</p>
<p class="Pp">If the <span class="Li">&quot;AutoClose&quot;</span> option has
    been enabled when the IO::Compress::Deflate object was created, and the
    object is associated with a file, the underlying file will also be
  closed.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="newStream(_"><a class="permalink" href="#newStream(_">newStream([OPTS])</a></h2>
<p class="Pp">Usage is</p>
<p class="Pp"></p>
<pre>    $z-&gt;newStream( [OPTS] )
</pre>
<p class="Pp">Closes the current compressed data stream and starts a new
  one.</p>
<p class="Pp">OPTS consists of any of the options that are available when
    creating the <span class="Li">$z</span> object.</p>
<p class="Pp">See the &quot;Constructor Options&quot; section for more
  details.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="deflateParams"><a class="permalink" href="#deflateParams">deflateParams</a></h2>
<p class="Pp">Usage is</p>
<p class="Pp"></p>
<pre>    $z-&gt;deflateParams
</pre>
<p class="Pp">TODO</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="Importing"><a class="permalink" href="#Importing">Importing</a></h1>
<p class="Pp">A number of symbolic constants are required by some methods in
    <span class="Li">&quot;IO::Compress::Deflate&quot;</span>. None are imported
    by default.</p>
<dl class="Bl-tag">
  <dt>:all</dt>
  <dd>Imports <span class="Li">&quot;deflate&quot;</span>,
      <span class="Li">$DeflateError</span> and all symbolic constants that can
      be used by <span class="Li">&quot;IO::Compress::Deflate&quot;</span>. Same
      as doing this
    <p class="Pp"></p>
    <pre>    use IO::Compress::Deflate qw(deflate $DeflateError :constants) ;
    </pre>
  </dd>
  <dt>:constants</dt>
  <dd>Import all symbolic constants. Same as doing this
    <p class="Pp"></p>
    <pre>    use IO::Compress::Deflate qw(:flush :level :strategy) ;
    </pre>
  </dd>
  <dt>:flush</dt>
  <dd>These symbolic constants are used by the
      <span class="Li">&quot;flush&quot;</span> method.
    <p class="Pp"></p>
    <pre>    Z_NO_FLUSH
    Z_PARTIAL_FLUSH
    Z_SYNC_FLUSH
    Z_FULL_FLUSH
    Z_FINISH
    Z_BLOCK
    </pre>
  </dd>
  <dt>:level</dt>
  <dd>These symbolic constants are used by the
      <span class="Li">&quot;Level&quot;</span> option in the constructor.
    <p class="Pp"></p>
    <pre>    Z_NO_COMPRESSION
    Z_BEST_SPEED
    Z_BEST_COMPRESSION
    Z_DEFAULT_COMPRESSION
    </pre>
  </dd>
  <dt>:strategy</dt>
  <dd>These symbolic constants are used by the
      <span class="Li">&quot;Strategy&quot;</span> option in the constructor.
    <p class="Pp"></p>
    <pre>    Z_FILTERED
    Z_HUFFMAN_ONLY
    Z_RLE
    Z_FIXED
    Z_DEFAULT_STRATEGY
    </pre>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="EXAMPLES"><a class="permalink" href="#EXAMPLES">EXAMPLES</a></h1>
<section class="Ss">
<h2 class="Ss" id="Apache::GZip_Revisited"><a class="permalink" href="#Apache::GZip_Revisited">Apache::GZip
  Revisited</a></h2>
<p class="Pp">See IO::Compress::FAQ</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Working_with_Net::FTP"><a class="permalink" href="#Working_with_Net::FTP">Working
  with Net::FTP</a></h2>
<p class="Pp">See IO::Compress::FAQ</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="SUPPORT"><a class="permalink" href="#SUPPORT">SUPPORT</a></h1>
<p class="Pp">General feedback/questions/bug reports should be sent to
    &lt;https://github.com/pmqs/IO-Compress/issues&gt; (preferred) or
    &lt;https://rt.cpan.org/Public/Dist/Display.html?Name=IO-Compress&gt;.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp">Compress::Zlib, IO::Compress::Gzip, IO::Uncompress::Gunzip,
    IO::Uncompress::Inflate, IO::Compress::RawDeflate,
    IO::Uncompress::RawInflate, IO::Compress::Bzip2, IO::Uncompress::Bunzip2,
    IO::Compress::Lzma, IO::Uncompress::UnLzma, IO::Compress::Xz,
    IO::Uncompress::UnXz, IO::Compress::Lzip, IO::Uncompress::UnLzip,
    IO::Compress::Lzop, IO::Uncompress::UnLzop, IO::Compress::Lzf,
    IO::Uncompress::UnLzf, IO::Compress::Zstd, IO::Uncompress::UnZstd,
    IO::Uncompress::AnyInflate, IO::Uncompress::AnyUncompress</p>
<p class="Pp">IO::Compress::FAQ</p>
<p class="Pp">File::GlobMapper, Archive::Zip, Archive::Tar, IO::Zlib</p>
<p class="Pp">For RFC 1950, 1951 and 1952 see
    &lt;http://www.faqs.org/rfcs/rfc1950.html&gt;,
    &lt;http://www.faqs.org/rfcs/rfc1951.html&gt; and
    &lt;http://www.faqs.org/rfcs/rfc1952.html&gt;</p>
<p class="Pp">The <i>zlib</i> compression library was written by Jean-loup
    Gailly <span class="Li">&quot;gzip@prep.ai.mit.edu&quot;</span> and Mark
    Adler <span class="Li">&quot;madler@alumni.caltech.edu&quot;</span>.</p>
<p class="Pp">The primary site for the <i>zlib</i> compression library is
    &lt;http://www.zlib.org&gt;.</p>
<p class="Pp">The primary site for gzip is &lt;http://www.gzip.org&gt;.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">This module was written by Paul Marquess,
    <span class="Li">&quot;pmqs@cpan.org&quot;</span>.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="MODIFICATION_HISTORY"><a class="permalink" href="#MODIFICATION_HISTORY">MODIFICATION
  HISTORY</a></h1>
<p class="Pp">See the Changes file.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT_AND_LICENSE"><a class="permalink" href="#COPYRIGHT_AND_LICENSE">COPYRIGHT
  AND LICENSE</a></h1>
<p class="Pp">Copyright (c) 2005-2021 Paul Marquess. All rights reserved.</p>
<p class="Pp">This program is free software; you can redistribute it and/or
    modify it under the same terms as Perl itself.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2022-02-19</td>
    <td class="foot-os">perl v5.34.1</td>
  </tr>
</table>
</body>
</html>
