<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.10 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>DBI::Profile(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">DBI::Profile(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">DBI::Profile(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
DBI::Profile - Performance profiling and benchmarking for the DBI
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
The easiest way to enable DBI profiling is to set the DBI_PROFILE environment
  variable to 2 and then run your code as usual:
<p class="Pp"><span class="Li"></span></p>
<pre>
  DBI_PROFILE=2 prog.pl
</pre>
<p class="Pp">This will profile your program and then output a textual summary
    grouped by query when the program exits. You can also enable profiling by
    setting the Profile attribute of any DBI handle:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  $dbh-&gt;{Profile} = 2;
</pre>
<p class="Pp">Then the summary will be printed when the handle is destroyed.</p>
<p class="Pp">Many other values apart from are possible - see &quot;ENABLING A
    PROFILE&quot; below.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
The DBI::Profile module provides a simple interface to collect and report
  performance and benchmarking data from the DBI.
<p class="Pp">For a more elaborate interface, suitable for larger programs, see
    DBI::ProfileDumper and dbiprof. For Apache/mod_perl applications see
    DBI::ProfileDumper::Apache.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="OVERVIEW"><a class="permalink" href="#OVERVIEW">OVERVIEW</a></h1>
Performance data collection for the DBI is built around several concepts which
  are important to understand clearly.
<dl class="Bl-tag">
  <dt>Method Dispatch</dt>
  <dd>Every method call on a DBI handle passes through a single 'dispatch'
      function which manages all the common aspects of DBI method calls, such as
      handling the RaiseError attribute.</dd>
  <dt>Data Collection</dt>
  <dd>If profiling is enabled for a handle then the dispatch code takes a
      high-resolution timestamp soon after it is entered. Then, after calling
      the appropriate method and just before returning, it takes another
      high-resolution timestamp and calls a function to record the information.
      That function is passed the two timestamps plus the DBI handle and the
      name of the method that was called. That data about a single DBI method
      call is called a <i>profile sample</i>.</dd>
  <dt>Data Filtering</dt>
  <dd>If the method call was invoked by the DBI or by a driver then the call is
      ignored for profiling because the time spent will be accounted for by the
      original 'outermost' call for your code.
    <p class="Pp">For example, the calls that the <b>selectrow_arrayref()</b>
        method makes to <b>prepare()</b> and <b>execute()</b> etc. are not
        counted individually because the time spent in those methods is going to
        be allocated to the <b>selectrow_arrayref()</b> method when it returns.
        If this was not done then it would be very easy to double count time
        spent inside the DBI.</p>
  </dd>
  <dt>Data Storage Tree</dt>
  <dd>The profile data is accumulated as 'leaves on a tree'. The 'path' through
      the branches of the tree to a particular leaf is determined dynamically
      for each sample. This is a key feature of DBI profiling.
    <p class="Pp">For each profiled method call the DBI walks along the Path and
        uses each value in the Path to step into and grow the Data tree.</p>
    <p class="Pp">For example, if the Path is</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  [ 'foo', 'bar', 'baz' ]
    </pre>
    <p class="Pp">then the new profile sample data will be <i>merged</i> into
        the tree at</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  $h-&gt;{Profile}-&gt;{Data}-&gt;{foo}-&gt;{bar}-&gt;{baz}
    </pre>
    <p class="Pp">But it's not very useful to merge all the call data into one
        leaf node (except to get an overall 'time spent inside the DBI' total).
        It's more common to want the Path to include dynamic values such as the
        current statement text and/or the name of the method called to show what
        the time spent inside the DBI was for.</p>
    <p class="Pp">The Path can contain some 'magic cookie' values that are
        automatically replaced by corresponding dynamic values when they're
        used. These magic cookies always start with a punctuation character.</p>
    <p class="Pp">For example a value of
        '<span class="Li">&quot;!MethodName&quot;</span>' in the Path causes the
        corresponding entry in the Data to be the name of the method that was
        called. For example, if the Path was:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  [ 'foo', '!MethodName', 'bar' ]
    </pre>
    <p class="Pp">and the <b>selectall_arrayref()</b> method was called, then
        the profile sample data for that call will be merged into the tree
      at:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  $h-&gt;{Profile}-&gt;{Data}-&gt;{foo}-&gt;{selectall_arrayref}-&gt;{bar}
    </pre>
  </dd>
  <dt>Profile Data</dt>
  <dd>Profile data is stored at the 'leaves' of the tree as references to an
      array of numeric values. For example:
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  [
    106,                  # 0: count of samples at this node
    0.0312958955764771,   # 1: total duration
    0.000490069389343262, # 2: first duration
    0.000176072120666504, # 3: shortest duration
    0.00140702724456787,  # 4: longest duration
    1023115819.83019,     # 5: time of first sample
    1023115819.86576,     # 6: time of last sample
  ]
    </pre>
    <p class="Pp">After the first sample, later samples always update elements
        0, 1, and 6, and may update 3 or 4 depending on the duration of the
        sampled call.</p>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="ENABLING_A_PROFILE"><a class="permalink" href="#ENABLING_A_PROFILE">ENABLING
  A PROFILE</a></h1>
Profiling is enabled for a handle by assigning to the Profile attribute. For
  example:
<p class="Pp"><span class="Li"></span></p>
<pre>
  $h-&gt;{Profile} = DBI::Profile-&gt;new();
</pre>
<p class="Pp">The Profile attribute holds a blessed reference to a hash object
    that contains the profile data and attributes relating to it.</p>
<p class="Pp">The class the Profile object is blessed into is expected to
    provide at least a DESTROY method which will dump the profile data to the
    DBI trace file handle (STDERR by default).</p>
<p class="Pp">All these examples have the same effect as each other:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  $h-&gt;{Profile} = 0;
  $h-&gt;{Profile} = &quot;/DBI::Profile&quot;;
  $h-&gt;{Profile} = DBI::Profile-&gt;new();
  $h-&gt;{Profile} = {};
  $h-&gt;{Profile} = { Path =&gt; [] };
</pre>
<p class="Pp">Similarly, these examples have the same effect as each other:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  $h-&gt;{Profile} = 6;
  $h-&gt;{Profile} = &quot;6/DBI::Profile&quot;;
  $h-&gt;{Profile} = &quot;!Statement:!MethodName/DBI::Profile&quot;;
  $h-&gt;{Profile} = { Path =&gt; [ '!Statement', '!MethodName' ] };
</pre>
<p class="Pp">If a non-blessed hash reference is given then the DBI::Profile
    module is automatically <span class="Li">&quot;require&quot;</span>'d and
    the reference is blessed into that class.</p>
<p class="Pp">If a string is given then it is processed like this:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    ($path, $module, $args) = split /\//, $string, 3

    @path = split /:/, $path
    @args = split /:/, $args

    eval &quot;require $module&quot; if $module
    $module ||= &quot;DBI::Profile&quot;

    $module-&gt;new( Path =&gt; \@Path, @args )
</pre>
<p class="Pp">So the first value is used to select the Path to be used (see
    below). The second value, if present, is used as the name of a module which
    will be loaded and it's <span class="Li">&quot;new&quot;</span> method
    called. If not present it defaults to DBI::Profile. Any other values are
    passed as arguments to the <span class="Li">&quot;new&quot;</span> method.
    For example:
    &quot;<span class="Li">&quot;2/DBIx::OtherProfile/Foo:42&quot;</span>&quot;.</p>
<p class="Pp">Numbers can be used as a shorthand way to enable common Path
    values. The simplest way to explain how the values are interpreted is to
    show the code:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    push @Path, &quot;DBI&quot;           if $path_elem &amp; 0x01;
    push @Path, &quot;!Statement&quot;    if $path_elem &amp; 0x02;
    push @Path, &quot;!MethodName&quot;   if $path_elem &amp; 0x04;
    push @Path, &quot;!MethodClass&quot;  if $path_elem &amp; 0x08;
    push @Path, &quot;!Caller2&quot;      if $path_elem &amp; 0x10;
</pre>
<p class="Pp">So &quot;2&quot; is the same as &quot;!Statement&quot; and
    &quot;6&quot; (2+4) is the same as &quot;!Statement:!Method&quot;. Those are
    the two most commonly used values. Using a negative number will reverse the
    path. Thus &quot;-6&quot; will group by method name then statement.</p>
<p class="Pp">The splitting and parsing of string values assigned to the Profile
    attribute may seem a little odd, but there's a good reason for it. Remember
    that attributes can be embedded in the Data Source Name string which can be
    passed in to a script as a parameter. For example:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    dbi:DriverName(Profile=&gt;2):dbname
    dbi:DriverName(Profile=&gt;{Username}:!Statement/MyProfiler/Foo:42):dbname
</pre>
<p class="Pp">And also, if the <span class="Li">&quot;DBI_PROFILE&quot;</span>
    environment variable is set then The DBI arranges for every driver handle to
    share the same profile object. When perl exits a single profile summary will
    be generated that reflects (as nearly as practical) the total use of the DBI
    by the application.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="THE_PROFILE_OBJECT"><a class="permalink" href="#THE_PROFILE_OBJECT">THE
  PROFILE OBJECT</a></h1>
The DBI core expects the Profile attribute value to be a hash reference and if
  the following values don't exist it will create them as needed:
<section class="Ss">
<h2 class="Ss" id="Data"><a class="permalink" href="#Data">Data</a></h2>
A reference to a hash containing the collected profile data.
</section>
<section class="Ss">
<h2 class="Ss" id="Path"><a class="permalink" href="#Path">Path</a></h2>
The Path value is a reference to an array. Each element controls the value to
  use at the corresponding level of the profile Data tree.
<p class="Pp">If the value of Path is anything other than an array reference, it
    is treated as if it was:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
        [ '!Statement' ]
</pre>
<p class="Pp">The elements of Path array can be one of the following types:</p>
<p class="Pp"><i>Special Constant</i></p>
<p class="Pp"><b>!Statement</b></p>
<p class="Pp">Use the current Statement text. Typically that's the value of the
    Statement attribute for the handle the method was called with. Some methods,
    like <b>commit()</b> and <b>rollback()</b>, are unrelated to a particular
    statement. For those methods !Statement records an empty string.</p>
<p class="Pp">For statement handles this is always simply the string that was
    given to <b>prepare()</b> when the handle was created. For database handles
    this is the statement that was last prepared or executed on that database
    handle. That can lead to a little 'fuzzyness' because, for example, calls to
    the <b>quote()</b> method to build a new statement will typically be
    associated with the previous statement. In practice this isn't a significant
    issue and the dynamic Path mechanism can be used to setup your own
  rules.</p>
<p class="Pp"><b>!MethodName</b></p>
<p class="Pp">Use the name of the DBI method that the profile sample relates
  to.</p>
<p class="Pp"><b>!MethodClass</b></p>
<p class="Pp">Use the fully qualified name of the DBI method, including the
    package, that the profile sample relates to. This shows you where the method
    was implemented. For example:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  'DBD::_::db::selectrow_arrayref' =&gt;
      0.022902s
  'DBD::mysql::db::selectrow_arrayref' =&gt;
      2.244521s / 99 = 0.022445s avg (first 0.022813s, min 0.022051s, max 0.028932s)
</pre>
<p class="Pp">The &quot;DBD::_::db::selectrow_arrayref&quot; shows that the
    driver has inherited the selectrow_arrayref method provided by the DBI.</p>
<p class="Pp">But you'll note that there is only one call to
    DBD::_::db::selectrow_arrayref but another 99 to
    DBD::mysql::db::selectrow_arrayref. Currently the first call doesn't record
    the true location. That may change.</p>
<p class="Pp"><b>!Caller</b></p>
<p class="Pp">Use a string showing the filename and line number of the code
    calling the method.</p>
<p class="Pp"><b>!Caller2</b></p>
<p class="Pp">Use a string showing the filename and line number of the code
    calling the method, as for !Caller, but also include filename and line
    number of the code that called that. Calls from DBI:: and DBD:: packages are
    skipped.</p>
<p class="Pp"><b>!File</b></p>
<p class="Pp">Same as !Caller above except that only the filename is included,
    not the line number.</p>
<p class="Pp"><b>!File2</b></p>
<p class="Pp">Same as !Caller2 above except that only the filenames are
    included, not the line number.</p>
<p class="Pp"><b>!Time</b></p>
<p class="Pp">Use the current value of <b>time()</b>. Rarely used. See the more
    useful <span class="Li">&quot;!Time~N&quot;</span> below.</p>
<p class="Pp"><b>!Time~N</b></p>
<p class="Pp">Where <span class="Li">&quot;N&quot;</span> is an integer. Use the
    current value of <b>time()</b> but with reduced precision. The value used is
    determined in this way:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    int( time() / N ) * N
</pre>
<p class="Pp">This is a useful way to segregate a profile into time slots. For
    example:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    [ '!Time~60', '!Statement' ]
</pre>
<p class="Pp"><i>Code Reference</i></p>
<p class="Pp">The subroutine is passed the handle it was called on and the DBI
    method name. The current Statement is in <span class="Li">$_</span>. The
    statement string should not be modified, so most subs start with
    <span class="Li">&quot;local $_ = $_;&quot;</span>.</p>
<p class="Pp">The list of values it returns is used at that point in the Profile
    Path. Any undefined values are treated as the string
    &quot;<span class="Li">&quot;undef&quot;</span>&quot;.</p>
<p class="Pp">The sub can 'veto' (reject) a profile sample by including a
    reference to undef (<span class="Li">&quot;\undef&quot;</span>) in the
    returned list. That can be useful when you want to only profile statements
    that match a certain pattern, or only profile certain methods.</p>
<p class="Pp"><i>Subroutine Specifier</i></p>
<p class="Pp">A Path element that begins with
    '<span class="Li">&quot;&amp;&quot;</span>' is treated as the name of a
    subroutine in the DBI::ProfileSubs namespace and replaced with the
    corresponding code reference.</p>
<p class="Pp">Currently this only works when the Path is specified by the
    <span class="Li">&quot;DBI_PROFILE&quot;</span> environment variable.</p>
<p class="Pp">Also, currently, the only subroutine in the DBI::ProfileSubs
    namespace is <span class="Li">'&amp;norm_std_n3'</span>. That's a very handy
    subroutine when profiling code that doesn't use placeholders. See
    DBI::ProfileSubs for more information.</p>
<p class="Pp"><i>Attribute Specifier</i></p>
<p class="Pp">A string enclosed in braces, such as
    '<span class="Li">&quot;{Username}&quot;</span>', specifies that the current
    value of the corresponding database handle attribute should be used at that
    point in the Path.</p>
<p class="Pp"><i>Reference to a Scalar</i></p>
<p class="Pp">Specifies that the current value of the referenced scalar be used
    at that point in the Path. This provides an efficient way to get
    'contextual' values into your profile.</p>
<p class="Pp"><i>Other Values</i></p>
<p class="Pp">Any other values are stringified and used literally.</p>
<p class="Pp">(References, and values that begin with punctuation characters are
    reserved.)</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="REPORTING"><a class="permalink" href="#REPORTING">REPORTING</a></h1>
<section class="Ss">
<h2 class="Ss" id="Report_Format"><a class="permalink" href="#Report_Format">Report
  Format</a></h2>
The current accumulated profile data can be formatted and output using
<p class="Pp"><span class="Li"></span></p>
<pre>
    print $h-&gt;{Profile}-&gt;format;
</pre>
<p class="Pp">To discard the profile data and start collecting fresh data you
    can do:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    $h-&gt;{Profile}-&gt;{Data} = undef;
</pre>
<p class="Pp">The default results format looks like this:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  DBI::Profile: 0.001015s 42.7% (5 calls) programname @ YYYY-MM-DD HH:MM:SS
  '' =&gt;
      0.000024s / 2 = 0.000012s avg (first 0.000015s, min 0.000009s, max 0.000015s)
  'SELECT mode,size,name FROM table' =&gt;
      0.000991s / 3 = 0.000330s avg (first 0.000678s, min 0.000009s, max 0.000678s)
</pre>
<p class="Pp">Which shows the total time spent inside the DBI, with a count of
    the total number of method calls and the name of the script being run, then
    a formatted version of the profile data tree.</p>
<p class="Pp">If the results are being formatted when the perl process is
    exiting (which is usually the case when the DBI_PROFILE environment variable
    is used) then the percentage of time the process spent inside the DBI is
    also shown. If the process is not exiting then the percentage is calculated
    using the time between the first and last call to the DBI.</p>
<p class="Pp">In the example above the paths in the tree are only one level deep
    and use the Statement text as the value (that's the default behaviour).</p>
<p class="Pp">The merged profile data at the 'leaves' of the tree are presented
    as total time spent, count, average time spent (which is simply total time
    divided by the count), then the time spent on the first call, the time spent
    on the fastest call, and finally the time spent on the slowest call.</p>
<p class="Pp">The 'avg', 'first', 'min' and 'max' times are not particularly
    useful when the profile data path only contains the statement text. Here's
    an extract of a more detailed example using both statement text and method
    name in the path:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  'SELECT mode,size,name FROM table' =&gt;
      'FETCH' =&gt;
          0.000076s
      'fetchrow_hashref' =&gt;
          0.036203s / 108 = 0.000335s avg (first 0.000490s, min 0.000152s, max 0.002786s)
</pre>
<p class="Pp">Here you can see the 'avg', 'first', 'min' and 'max' for the 108
    calls to <b>fetchrow_hashref()</b> become rather more interesting. Also the
    data for FETCH just shows a time value because it was only called once.</p>
<p class="Pp">Currently the profile data is output sorted by branch names. That
    may change in a later version so the leaf nodes are sorted by total time per
    leaf node.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Report_Destination"><a class="permalink" href="#Report_Destination">Report
  Destination</a></h2>
The default method of reporting is for the DESTROY method of the Profile object
  to format the results and write them using:
<p class="Pp"><span class="Li"></span></p>
<pre>
    DBI-&gt;trace_msg($results, 0);  # see $ON_DESTROY_DUMP below
</pre>
<p class="Pp">to write them to the DBI <b>trace()</b> filehandle (which defaults
    to STDERR). To direct the DBI trace filehandle to write to a file without
    enabling tracing the <b>trace()</b> method can be called with a trace level
    of 0. For example:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    DBI-&gt;trace(0, $filename);
</pre>
<p class="Pp">The same effect can be achieved without changing the code by
    setting the <span class="Li">&quot;DBI_TRACE&quot;</span> environment
    variable to <span class="Li">&quot;0=filename&quot;</span>.</p>
<p class="Pp">The <span class="Li">$DBI::Profile::ON_DESTROY_DUMP</span>
    variable holds a code ref that's called to perform the output of the
    formatted results. The default value is:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  $ON_DESTROY_DUMP = sub { DBI-&gt;trace_msg($results, 0) };
</pre>
<p class="Pp">Apart from making it easy to send the dump elsewhere, it can also
    be useful as a simple way to disable dumping results.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="CHILD_HANDLES"><a class="permalink" href="#CHILD_HANDLES">CHILD
  HANDLES</a></h1>
Child handles inherit a reference to the Profile attribute value of their
  parent. So if profiling is enabled for a database handle then by default the
  statement handles created from it all contribute to the same merged profile
  data tree.
</section>
<section class="Sh">
<h1 class="Sh" id="PROFILE_OBJECT_METHODS"><a class="permalink" href="#PROFILE_OBJECT_METHODS">PROFILE
  OBJECT METHODS</a></h1>
<section class="Ss">
<h2 class="Ss" id="format"><a class="permalink" href="#format">format</a></h2>
See &quot;REPORTING&quot;.
</section>
<section class="Ss">
<h2 class="Ss" id="as_node_path_list"><a class="permalink" href="#as_node_path_list">as_node_path_list</a></h2>
<span class="Li"></span>
<pre>
  @ary = $dbh-&gt;{Profile}-&gt;as_node_path_list();
  @ary = $dbh-&gt;{Profile}-&gt;as_node_path_list($node, $path);
</pre>
<p class="Pp">Returns the collected data ($dbh-&gt;{Profile}{Data}) restructured
    into a list of array refs, one for each leaf node in the Data tree. This
    'flat' structure is often much simpler for applications to work with.</p>
<p class="Pp">The first element of each array ref is a reference to the leaf
    node. The remaining elements are the 'path' through the data tree to that
    node.</p>
<p class="Pp">For example, given a data tree like this:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    {key1a}{key2a}[node1]
    {key1a}{key2b}[node2]
    {key1b}{key2a}{key3a}[node3]
</pre>
<p class="Pp">The <b>as_node_path_list()</b> method will return this list:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    [ [node1], 'key1a', 'key2a' ]
    [ [node2], 'key1a', 'key2b' ]
    [ [node3], 'key1b', 'key2a', 'key3a' ]
</pre>
<p class="Pp">The nodes are ordered by key, depth-first.</p>
<p class="Pp">The <span class="Li">$node</span> argument can be used to focus on
    a sub-tree. If not specified it defaults to
    <span class="Li">$dbh</span>-&gt;{Profile}{Data}.</p>
<p class="Pp">The <span class="Li">$path</span> argument can be used to specify
    a list of path elements that will be added to each element of the returned
    list. If not specified it defaults to a ref to an empty array.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="as_text"><a class="permalink" href="#as_text">as_text</a></h2>
<span class="Li"></span>
<pre>
  @txt = $dbh-&gt;{Profile}-&gt;as_text();
  $txt = $dbh-&gt;{Profile}-&gt;as_text({
      node      =&gt; undef,
      path      =&gt; [],
      separator =&gt; &quot; &gt; &quot;,
      format    =&gt; '%1$s: %11$fs / %10$d = %2$fs avg (first %12$fs, min %13$fs, max %14$fs)'.&quot;\n&quot;;
      sortsub   =&gt; sub { ... },
  );
</pre>
<p class="Pp">Returns the collected data ($dbh-&gt;{Profile}{Data}) reformatted
    into a list of formatted strings. In scalar context the list is returned as
    a single concatenated string.</p>
<p class="Pp">A hashref can be used to pass in arguments, the default values are
    shown in the example above.</p>
<p class="Pp">The <span class="Li">&quot;node&quot;</span> and &lt;path&gt;
    arguments are passed to <b>as_node_path_list()</b>.</p>
<p class="Pp">The <span class="Li">&quot;separator&quot;</span> argument is used
    to join the elements of the path for each leaf node.</p>
<p class="Pp">The <span class="Li">&quot;sortsub&quot;</span> argument is used
    to pass in a ref to a sub that will order the list. The subroutine will be
    passed a reference to the array returned by <b>as_node_path_list()</b> and
    should sort the contents of the array in place. The return value from the
    sub is ignored. For example, to sort the nodes by the second level key you
    could use:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  sortsub =&gt; sub { my $ary=shift; @$ary = sort { $a-&gt;[2] cmp $b-&gt;[2] } @$ary }
</pre>
<p class="Pp">The <span class="Li">&quot;format&quot;</span> argument is a
    <span class="Li">&quot;sprintf&quot;</span> format string that specifies the
    format to use for each leaf node. It uses the explicit format parameter
    index mechanism to specify which of the arguments should appear where in the
    string. The arguments to sprintf are:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
     1:  path to node, joined with the separator
     2:  average duration (total duration/count)
         (3 thru 9 are currently unused)
    10:  count
    11:  total duration
    12:  first duration
    13:  smallest duration
    14:  largest duration
    15:  time of first call
    16:  time of first call
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="CUSTOM_DATA_MANIPULATION"><a class="permalink" href="#CUSTOM_DATA_MANIPULATION">CUSTOM
  DATA MANIPULATION</a></h1>
Recall that <span class="Li">&quot;$h-&gt;{Profile}-&gt;{Data}&quot;</span> is a
  reference to the collected data. Either to a 'leaf' array (when the Path is
  empty, i.e., DBI_PROFILE env var is 1), or a reference to hash containing
  values that are either further hash references or leaf array references.
<p class="Pp">Sometimes it's useful to be able to summarise some or all of the
    collected data. The <b>dbi_profile_merge_nodes()</b> function can be used to
    merge leaf node values.</p>
<section class="Ss">
<h2 class="Ss" id="dbi_profile_merge_nodes"><a class="permalink" href="#dbi_profile_merge_nodes">dbi_profile_merge_nodes</a></h2>
<span class="Li"></span>
<pre>
  use DBI qw(dbi_profile_merge_nodes);

  $time_in_dbi = dbi_profile_merge_nodes(my $totals=[], @$leaves);
</pre>
<p class="Pp">Merges profile data node. Given a reference to a destination
    array, and zero or more references to profile data, merges the profile data
    into the destination array. For example:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  $time_in_dbi = dbi_profile_merge_nodes(
      my $totals=[],
      [ 10, 0.51, 0.11, 0.01, 0.22, 1023110000, 1023110010 ],
      [ 15, 0.42, 0.12, 0.02, 0.23, 1023110005, 1023110009 ],
  );
</pre>
<p class="Pp"><span class="Li">$totals</span> will then contain</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  [ 25, 0.93, 0.11, 0.01, 0.23, 1023110000, 1023110010 ]
</pre>
<p class="Pp">and <span class="Li">$time_in_dbi</span> will be 0.93;</p>
<p class="Pp">The second argument need not be just leaf nodes. If given a
    reference to a hash then the hash is recursively searched for leaf nodes and
    all those found are merged.</p>
<p class="Pp">For example, to get the time spent 'inside' the DBI during an http
    request, your logging code run at the end of the request (i.e. mod_perl
    LogHandler) could use:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  my $time_in_dbi = 0;
  if (my $Profile = $dbh-&gt;{Profile}) { # if DBI profiling is enabled
      $time_in_dbi = dbi_profile_merge_nodes(my $total=[], $Profile-&gt;{Data});
      $Profile-&gt;{Data} = {}; # reset the profile data
  }
</pre>
<p class="Pp">If profiling has been enabled then
    <span class="Li">$time_in_dbi</span> will hold the time spent inside the DBI
    for that handle (and any other handles that share the same profile data)
    since the last request.</p>
<p class="Pp">Prior to DBI 1.56 the <b>dbi_profile_merge_nodes()</b> function
    was called <b>dbi_profile_merge()</b>. That name still exists as an
  alias.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="CUSTOM_DATA_COLLECTION"><a class="permalink" href="#CUSTOM_DATA_COLLECTION">CUSTOM
  DATA COLLECTION</a></h1>
<section class="Ss">
<h2 class="Ss" id="Using_The_Path_Attribute"><a class="permalink" href="#Using_The_Path_Attribute">Using
  The Path Attribute</a></h2>
<span class="Li"></span>
<pre>
  XXX example to be added later using a selectall_arrayref call
  XXX nested inside a fetch loop where the first column of the
  XXX outer loop is bound to the profile Path using
  XXX bind_column(1, \${ $dbh-&gt;{Profile}-&gt;{Path}-&gt;[0] })
  XXX so you end up with separate profiles for each loop
  XXX (patches welcome to add this to the docs :)
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Adding_Your_Own_Samples"><a class="permalink" href="#Adding_Your_Own_Samples">Adding
  Your Own Samples</a></h2>
The <b>dbi_profile()</b> function can be used to add extra sample data into the
  profile data tree. For example:
<p class="Pp"><span class="Li"></span></p>
<pre>
    use DBI;
    use DBI::Profile (dbi_profile dbi_time);

    my $t1 = dbi_time(); # floating point high-resolution time

    ... execute code you want to profile here ...

    my $t2 = dbi_time();
    dbi_profile($h, $statement, $method, $t1, $t2);
</pre>
<p class="Pp">The <span class="Li">$h</span> parameter is the handle the extra
    profile sample should be associated with. The
    <span class="Li">$statement</span> parameter is the string to use where the
    Path specifies !Statement. If <span class="Li">$statement</span> is undef
    then <span class="Li">$h</span>-&gt;{Statement} will be used. Similarly
    <span class="Li">$method</span> is the string to use if the Path specifies
    !MethodName. There is no default value for
  <span class="Li">$method</span>.</p>
<p class="Pp">The <span class="Li">$h</span>-&gt;{Profile}{Path} attribute is
    processed by <b>dbi_profile()</b> in the usual way.</p>
<p class="Pp">The <span class="Li">$h</span> parameter is usually a DBI handle
    but it can also be a reference to a hash, in which case the
    <b>dbi_profile()</b> acts on each defined value in the hash. This is an
    efficient way to update multiple profiles with a single sample, and is used
    by the DashProfiler module.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="SUBCLASSING"><a class="permalink" href="#SUBCLASSING">SUBCLASSING</a></h1>
Alternate profile modules must subclass DBI::Profile to help ensure they work
  with future versions of the DBI.
</section>
<section class="Sh">
<h1 class="Sh" id="CAVEATS"><a class="permalink" href="#CAVEATS">CAVEATS</a></h1>
Applications which generate many different statement strings (typically because
  they don't use placeholders) and profile with !Statement in the Path (the
  default) will consume memory in the Profile Data structure for each statement.
  Use a code ref in the Path to return an edited (simplified) form of the
  statement.
<p class="Pp">If a method throws an exception itself (not via RaiseError) then
    it won't be counted in the profile.</p>
<p class="Pp">If a HandleError subroutine throws an exception (rather than
    returning 0 and letting RaiseError do it) then the method call won't be
    counted in the profile.</p>
<p class="Pp">Time spent in DESTROY is added to the profile of the parent
    handle.</p>
<p class="Pp">Time spent in DBI-&gt;*() methods is not counted. The time spent
    in the driver connect method,
    <span class="Li">$drh</span>-&gt;<b>connect()</b>, when it's called by
    DBI-&gt;connect is counted if the DBI_PROFILE environment variable is
  set.</p>
<p class="Pp">Time spent fetching tied variables,
    <span class="Li">$DBI::errstr</span>, is counted.</p>
<p class="Pp">Time spent in FETCH for <span class="Li">$h</span>-&gt;{Profile}
    is not counted, so getting the profile data doesn't alter it.</p>
<p class="Pp">DBI::PurePerl does not support profiling (though it could in
    theory).</p>
<p class="Pp">For asynchronous queries, time spent while the query is running on
    the backend is not counted.</p>
<p class="Pp">A few platforms don't support the <b>gettimeofday()</b> high
    resolution time function used by the DBI (and available via the
    <b>dbi_time()</b> function). In which case you'll get integer resolution
    time which is mostly useless.</p>
<p class="Pp">On Windows platforms the <b>dbi_time()</b> function is limited to
    millisecond resolution. Which isn't sufficiently fine for our needs, but
    still much better than integer resolution. This limited resolution means
    that fast method calls will often register as taking 0 time. And timings in
    general will have much more 'jitter' depending on where within the 'current
    millisecond' the start and end timing was taken.</p>
<p class="Pp">This documentation could be more clear. Probably needs to be
    reordered to start with several examples and build from there. Trying to
    explain the concepts first seems painful and to lead to just as many forward
    references. (Patches welcome!)</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2016-04-21</td>
    <td class="foot-os">perl v5.28.2</td>
  </tr>
</table>
</body>
</html>
