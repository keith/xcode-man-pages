<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>Parse::Eyapp::Driver(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Parse::Eyapp::Driver(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Parse::Eyapp::Driver(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
Parse::Eyapp::Driver - The LR parser
</section>
<section class="Sh">
<h1 class="Sh" id="INTRODUCTION"><a class="permalink" href="#INTRODUCTION">INTRODUCTION</a></h1>
This class has the method <span class="Li">&quot;YYParse&quot;</span>
  implementing the LR generic parsing algorithm plus the methods that give
  support to the generated parser.
</section>
<section class="Sh">
<h1 class="Sh" id="THE__YYParse__METHOD"><a class="permalink" href="#THE__YYParse__METHOD">THE
  &quot;YYParse&quot; METHOD</a></h1>
The <span class="Li">&quot;YYParse&quot;</span> methods implements the generic
  LR parsing algorithm. It very much works
  <span class="Li">&quot;Parse::Yapp::YYParse&quot;</span> and as yacc/bison
  <span class="Li">&quot;yyparse&quot;</span>. It accepts almost the same
  arguments as <span class="Li">&quot;Class-&gt;new&quot;</span> (Being
  <span class="Li">&quot;Class&quot;</span> the name of the generated class).
<p class="Pp">The parser uses two tables and a stack. The two tables are called
    the <i>action</i> table and the <i>goto</i> table. The stack is used to keep
    track of the states visited.</p>
<p class="Pp">At each step the generated parser consults the
    <span class="Li">&quot;action&quot;</span> table and takes one decision: To
    shift to a new state consuming one token (and pushing the current state in
    the stack) or to reduce by some production rule. In the last case the parser
    pops from its stack as many states as symbols are on the right hand side of
    the production rule. Here is a Perl/C like pseudocode summarizing the
    activity of <span class="Li">&quot;YYParse&quot;</span>:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
     1   my $parser = shift; # The parser object
     2   push(@stack, $parser-&gt;{startstate});
     3   $b = $parser-&gt;YYLexer(); # Get the first token
     4   FOREVER: {
     5     $s = top(0);  # Get the state on top of the stack
     6     $a = $b;
     7     switch ($parser-&gt;action[$s-&gt;state][$a]) {
     8       case &quot;shift t&quot; : 
     9         my $t;
    10         $t-&gt;{state} = t;
    11         $t-&gt;{attr}  = $a-&gt;{attr};
    12         push($t); 
    13         $b = $parser-&gt;YYLexer(); # Call the lexical analyzer
    14         break;
    15       case &quot;reduce A-&gt;alpha&quot; : 
    16         # Call the semantic action with the attributes of the rhs as args
    17         my $semantic  = $parser-&gt;Semantic{A -&gt;alpha}; # The semantic action
    18         my $r;
    19         $r-&gt;{attr} = $semantic-&gt;($parser, top(|alpha|-1)-&gt;attr, ... , top(0)-&gt;attr); 
    20  
    21         # Pop as many states as symbols on the rhs of A-&gt;alpha
    22         pop(|alpha|);  
    23  
    24         # Goto next state 
    25         $r-&gt;{state} = $parser-&gt;goto[top(0)][A]; 
    26         push($r); 
    27         break;
    28       case &quot;accept&quot; : return (1); 
    29       default : $parser-&gt;YYError(&quot;syntax error&quot;); 
    30     }
    31     redo FOREVER;
    32   }
</pre>
<p class="Pp">Here <span class="Li">&quot;|alpha|&quot;</span> stands for the
    length of <span class="Li">&quot;alpha&quot;</span>. Function
    <span class="Li">top(k)</span> returns the state in position
    <span class="Li">&quot;k&quot;</span> from the top of the stack, i.e. the
    state at depth <span class="Li">&quot;k&quot;</span>. Function
    <span class="Li">pop(k)</span> extracts
    <span class="Li">&quot;k&quot;</span> states from the stack. The call
    <span class="Li">&quot;$state-&gt;attr&quot;</span> returns the attribute
    associated with <span class="Li">$state</span>. The call
    <span class="Li">&quot;$parser-&gt;Semantic{A -&gt;alpha}&quot;</span>
    returns the semantic action associated with production
    <span class="Li">&quot;A -&gt;alpha&quot;</span>.</p>
<p class="Pp">Let us see a trace for the small grammar in
    <span class="Li">&quot;examples/debuggingtut/aSb.yp&quot;</span>:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  pl@nereida:~/LEyapp/examples$ /usr/local/bin/paste.pl aSb.yp aSb.output | head -5
  %%                                             | Rules:
  S:                 { print &quot;S -&gt; epsilon\n&quot; }  | ------
      |   'a' S 'b'  { print &quot;S -&gt; a S b\n&quot; }    | 0:    $start -&gt; S $end
  ;                                              | 1:    S -&gt; /* empty */
  %%                                             | 2:    S -&gt; 'a' S 'b'
</pre>
<p class="Pp">The tables in file <span class="Li">&quot;aSb.output&quot;</span>
    describe the actions and transitions to take:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  pl@nereida:~/LEyapp/examples$ cat -n aSb.output
     .  .........................................
     7  States:
     8  -------
     9  State 0:
    10
    11          $start -&gt; . S $end      (Rule 0)
    12
    13          'a'     shift, and go to state 2
    14
    15          $default        reduce using rule 1 (S)
    16
    17          S       go to state 1
    18
    19  State 1:
    20
    21          $start -&gt; S . $end      (Rule 0)
    22
    23          $end    shift, and go to state 3
    24
    25  State 2:
    26
    27          S -&gt; 'a' . S 'b'        (Rule 2)
    28
    29          'a'     shift, and go to state 2
    30
    31          $default        reduce using rule 1 (S)
    32
    33          S       go to state 4
    34
    35  State 3:
    36
    37          $start -&gt; S $end .      (Rule 0)
    38
    39          $default        accept
    40
    41  State 4:
    42
    43          S -&gt; 'a' S . 'b'        (Rule 2)
    44
    45          'b'     shift, and go to state 5
    46
    47  State 5:
    48
    49          S -&gt; 'a' S 'b' .        (Rule 2)
    50
    51          $default        reduce using rule 2 (S)
    52
    53
    54  Summary:
    55  --------
    56  Number of rules         : 3
    57  Number of terminals     : 3
    58  Number of non-terminals : 2
    59  Number of states        : 6
</pre>
<p class="Pp">When executed with <span class="Li">&quot;yydebug&quot;</span> set
    and input <span class="Li">&quot;aabb&quot;</span> we obtain the following
    output:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  pl@nereida:~/LEyapp/examples/debuggingtut$ eyapp -b '' -o use_aSb.pl aSb
  pl@nereida:~/LEyapp/examples/debuggingtut$ ./use_aSb.pl -d
  Provide a statement like &quot;a a b b&quot; and press &lt;CR&gt;&lt;CTRL-D&gt;: aabb
  ----------------------------------------                       
  In state 0:                                                    
  Stack:[0]                                                      
  Need token. Got &gt;a&lt;                                            
  Shift and go to state 2.                                       
  ----------------------------------------                       
  In state 2:                                                    
  Stack:[0,2]                                                    
  Need token. Got &gt;a&lt;
  Shift and go to state 2.
  ----------------------------------------
  In state 2:
  Stack:[0,2,2]
  Need token. Got &gt;b&lt;
  Reduce using rule 1 (S --&gt; /* empty */): S -&gt; epsilon
  Back to state 2, then go to state 4.
  ----------------------------------------
  In state 4:
  Stack:[0,2,2,4]
  Shift and go to state 5.
  ----------------------------------------
  In state 5:
  Stack:[0,2,2,4,5]
  Don't need token.
  Reduce using rule 2 (S --&gt; a S b): S -&gt; a S b
  Back to state 2, then go to state 4.
  ----------------------------------------
</pre>
<p class="Pp">As a result of reducing by rule 2 the three last visited states
    are popped from the stack, and the stack becomes
    <span class="Li">&quot;[0,2]&quot;</span>. But that means that we are now in
    state 2 seeing a <span class="Li">&quot;S&quot;</span>. If you look at the
    table above being in state 2 and seeing a
    <span class="Li">&quot;S&quot;</span> we go to state 4.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  In state 4:
  Stack:[0,2,4]
  Need token. Got &gt;b&lt;
  Shift and go to state 5.
  ----------------------------------------
  In state 5:
  Stack:[0,2,4,5]
  Don't need token.
  Reduce using rule 2 (S --&gt; a S b): S -&gt; a S b
  Back to state 0, then go to state 1.
  ----------------------------------------
  In state 1:
  Stack:[0,1]
  Need token. Got &gt;&lt;
  Shift and go to state 3.
  ----------------------------------------
  In state 3:
  Stack:[0,1,3]
  Don't need token.
  Accept.
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="METHODS_IN_THE_GENERATED_CLASS:__Parse::Eyapp::Driver__METHODS"><a class="permalink" href="#METHODS_IN_THE_GENERATED_CLASS:__Parse::Eyapp::Driver__METHODS">METHODS
  IN THE GENERATED CLASS: &quot;Parse::Eyapp::Driver&quot; METHODS</a></h1>
The class containing the parser generated by
  <span class="Li">&quot;Parse::Eyapp&quot;</span> inherits from
  <span class="Li">&quot;Parse::Eyapp::Driver&quot;</span>. Therefore all the
  methods in <span class="Li">&quot;Parse::Eyapp::Driver&quot;</span> are
  available in the generated class.
<p class="Pp">This section describes the methods and objects belonging to the
    class generated either using eyapp or
    <span class="Li">&quot;Parse::Eyapp-&gt;new_grammar&quot;</span>. In the
    incoming paragraphs we will assume that
    <span class="Li">&quot;Class&quot;</span> was the value selected for the
    <span class="Li">&quot;classname&quot;</span> argument when
    <span class="Li">&quot;Parse::Eyapp-&gt;new_grammar&quot;</span> was called.
    Objects belonging to <span class="Li">&quot;Class&quot;</span> are the
    actual parsers for the input grammar.</p>
<section class="Ss">
<h2 class="Ss" id="Class_-_new"><a class="permalink" href="#Class_-_new">Class-&gt;new</a></h2>
The method <span class="Li">&quot;Class-&gt;new&quot;</span> returns a new LALR
  parser object. Here <span class="Li">&quot;Class&quot;</span> stands for the
  name of the class containing the parser. See an example of call:
<p class="Pp"><span class="Li"></span></p>
<pre>
  my $parser = main-&gt;new(yyprefix =&gt; 'Parse::Eyapp::Node::',
                         yylex    =&gt; \&amp;main::_Lexer,
                         yyerror  =&gt; \&amp;main::_Error,
                         yydebug =&gt; 0x1F,
  );
</pre>
<p class="Pp">The meaning of the arguments used in the example are as
  follows:</p>
<dl class="Bl-tag">
  <dt>- yyprefix</dt>
  <dd>Used with <span class="Li">%tree</span> or
      <span class="Li">%metatree</span>. When used, the type names of the nodes
      of the syntax tree will be build prefixing the value associated to
      <span class="Li">&quot;yyprefix&quot;</span> to the name of the production
      rule. The name of the production rule is either explicitly given through a
      <span class="Li">%name</span> directive or the concatenation of the left
      hand side of the rule with the ordinal of the right hand side of the
      production. See section &quot;Compiling with eyapp and treereg&quot; in
      Parse::Eyapp for an example.</dd>
  <dt>- yylex</dt>
  <dd>Reference to the lexical analyzer subroutine</dd>
  <dt>- yyerror</dt>
  <dd>Reference to the error subroutine. The error subroutine receives as first
      argument the reference to the <span class="Li">&quot;Class&quot;</span>
      parser object. This way it can take advantage of methods like
      <span class="Li">&quot;YYCurval&quot;</span> and YYExpect (see below):
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  sub _Error {
    my($token)=$_[0]-&gt;YYCurval;
    my($what)= $token ? &quot;input: '$token'&quot; : &quot;end of input&quot;;
    my @expected = $_[0]-&gt;YYExpect();

    local $&quot; = ', ';
    die &quot;Syntax error near $what. Expected one of these tokens: @expected\n&quot;;
  }
    </pre>
  </dd>
  <dt>- yydebug</dt>
  <dd>Controls the level of debugging. Must be a number.</dd>
</dl>
<p class="Pp">The package produced from the grammar has several methods.</p>
<p class="Pp">The parser object has the following methods that work at parsing
    time exactly as in Parse::Yapp. These methods can be found in the module
    Parse::Eyapp::Driver. Assume you have in <span class="Li">$parser</span> the
    reference to your parser object:</p>
</section>
<section class="Ss">
<h2 class="Ss" id="$parser_-_YYAction"><a class="permalink" href="#$parser_-_YYAction">$parser-&gt;YYAction</a></h2>
Receives the name of a production and a subroutine reference implementing the
  new semantic action. If no subroutine reference is set returns the reference
  to the current semantic action. See the tutorial Parse::Eyapp::defaultaction
  and the examples in the <span class="Li">&quot;examples/recycle/&quot;</span>
  directory
</section>
<section class="Ss">
<h2 class="Ss" id="$parser_-_YYAccept"><a class="permalink" href="#$parser_-_YYAccept">
  $parser-&gt;YYAccept</a></h2>
Works as yacc/bison <span class="Li">&quot;YYACCEPT&quot;</span>. The parser
  finishes returning the current semantic value to indicate success.
</section>
<section class="Ss">
<h2 class="Ss" id="$parser_-_YYAbort"><a class="permalink" href="#$parser_-_YYAbort">
  $parser-&gt;YYAbort</a></h2>
Works as yacc/bison <span class="Li">&quot;YYABORT&quot;</span>. The parser
  finishes returning <span class="Li">&quot;undef&quot;</span> to indicate
  failure.
</section>
<section class="Ss">
<h2 class="Ss" id="Parse::Eyapp::Driver::BeANode"><a class="permalink" href="#Parse::Eyapp::Driver::BeANode">Parse::Eyapp::Driver::BeANode</a></h2>
Is not a method. Receives as input a <span class="Li">&quot;Class&quot;</span>
  name. Introduces <span class="Li">&quot;Parse::Eyapp::Node&quot;</span> as an
  ancestor class of <span class="Li">&quot;Class&quot;</span>. To work
  correctly, objects belonging to <span class="Li">&quot;Class&quot;</span> must
  be hashes with a <span class="Li">&quot;children&quot;</span> key whose value
  must be a reference to the array of children. The children must be also
  <span class="Li">&quot;Parse::Eyapp::Node&quot;</span> nodes. Actually you can
  circumvent this call by directly introducing
  <span class="Li">&quot;Parse::Eyapp::Node&quot;</span> in the ancestors of
  <span class="Li">&quot;Class&quot;</span>:
<p class="Pp"><span class="Li"></span></p>
<pre>
         push @{$class.&quot;::ISA&quot;}, &quot;Parse::Eyapp::Node&quot;
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="$parser_-_YYBuildAST"><a class="permalink" href="#$parser_-_YYBuildAST">$parser-&gt;YYBuildAST</a></h2>
Sometimes the best time to decorate a node with some attributes is just after
  being built. In such cases the programmer can take manual control building the
  node with <span class="Li">&quot;YYBuildAST&quot;</span> to immediately
  proceed to decorate it.
<p class="Pp">The following example from the file
    <span class="Li">&quot;lib/Simple/Types.eyp&quot;</span> in the tarball in
    <span class="Li">&quot;examples/typechecking/Simple-Types-XXX.tar.gz&quot;</span>
    illustrates the idea:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
 Variable:
     %name  VARARRAY
     $ID ('[' binary ']') &lt;%name INDEXSPEC +&gt;
       {
         my $self = shift;
         my $node =  $self-&gt;YYBuildAST(@_);
         $node-&gt;{line} = $ID-&gt;[1];
         return $node;
       }
</pre>
<p class="Pp">Actually, the <span class="Li">%tree</span> directive is
    semantically equivalent to:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  %default action { goto &amp;Parse::Eyapp::Driver::YYBuildAST }
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="$parser_-_YYBuildingTree"><a class="permalink" href="#$parser_-_YYBuildingTree">
  $parser-&gt;YYBuildingTree</a></h2>
Influences the semantic of list operators. If true the action associated with
  <span class="Li">&quot;X+&quot;</span> will be to build a
  <span class="Li">&quot;Parse::Eyapp::Node&quot;</span> node with all the
  attributes of the elements in the list as children. This is the appropriate
  semantic when working under the <span class="Li">%tree</span> directive. If
  set to false the semantic action will return an anonymous list with the
  attributes associated with the <span class="Li">&quot;X&quot;</span> in the
  plus list. Same thing with the operators <span class="Li">&quot;*&quot;</span>
  and <span class="Li">&quot;?&quot;</span>.
</section>
<section class="Ss">
<h2 class="Ss" id="$parser_-_YYBuildTS"><a class="permalink" href="#$parser_-_YYBuildTS">$parser-&gt;YYBuildTS</a></h2>
Similar to <span class="Li">&quot;$parser-&gt;YYBuildAST&quot;</span> but builds
  nodes for translation schemes.
</section>
<section class="Ss">
<h2 class="Ss" id="$parser_-_YYBypass"><a class="permalink" href="#$parser_-_YYBypass">$parser-&gt;YYBypass</a></h2>
Returns TRUE if running under the <span class="Li">&quot;%tree
  bypass&quot;</span> clause
</section>
<section class="Ss">
<h2 class="Ss" id="$parser_-_YYBypassrule"><a class="permalink" href="#$parser_-_YYBypassrule">$parser-&gt;YYBypassrule</a></h2>
Returns TRUE if the production being used for reduction was marked to be
  bypassed.
</section>
<section class="Ss">
<h2 class="Ss" id="$parser_-_YYCurtok"><a class="permalink" href="#$parser_-_YYCurtok">
  $parser-&gt;YYCurtok</a></h2>
Gives the current token
</section>
<section class="Ss">
<h2 class="Ss" id="$parser_-_YYCurval"><a class="permalink" href="#$parser_-_YYCurval">
  $parser-&gt;YYCurval</a></h2>
Gives the attribute associated with the current token
</section>
<section class="Ss">
<h2 class="Ss" id="$parser_-_YYDelegateaction"><a class="permalink" href="#$parser_-_YYDelegateaction">$parser-&gt;YYDelegateaction</a></h2>
Use it as <span class="Li">&quot;defaultaction&quot;</span> if you want to
  recycle your grammar. It is equivalent to:
<p class="Pp"><span class="Li"></span></p>
<pre>
  sub YYDelegateaction {
    my $self = shift;

    my $action = $self-&gt;YYName;

    $self-&gt;$action(@_);
  }
</pre>
<p class="Pp">For a full example illustrating how to use it, see files
    <span class="Li">&quot;examples/recycle/NoacInh.eyp&quot;</span> and
    <span class="Li">&quot;examples/recycle/icalcu_and_ipost.pl&quot;</span> in
    the Parse::Eyapp distribution</p>
</section>
<section class="Ss">
<h2 class="Ss" id="$parser_-_YYEndOfInput"><a class="permalink" href="#$parser_-_YYEndOfInput">
  $parser-&gt;YYEndOfInput</a></h2>
True if the <span class="Li">&quot;pos()&quot;</span> of the input being scanned
  in <span class="Li">&quot;${$parser-&gt;input}&quot;</span> is at the end
</section>
<section class="Ss">
<h2 class="Ss" id="$parser_-_YYErrok"><a class="permalink" href="#$parser_-_YYErrok">
  $parser-&gt;YYErrok</a></h2>
Works as yacc/bison <span class="Li">&quot;yyerrok&quot;</span>. Modifies the
  error status so that subsequent error messages will be emitted.
</section>
<section class="Ss">
<h2 class="Ss" id="$parser_-_YYError"><a class="permalink" href="#$parser_-_YYError">
  $parser-&gt;YYError</a></h2>
Works as yacc/bison <span class="Li">&quot;YYERROR&quot;</span>. Pretends that a
  syntax error has been detected.
</section>
<section class="Ss">
<h2 class="Ss" id="$parser_-_YYExpect"><a class="permalink" href="#$parser_-_YYExpect">
  $parser-&gt;YYExpect</a></h2>
Returns the list of tokens the parser expected when the failure occurred
<p class="Pp"><span class="Li"></span></p>
<pre>
 pl@nereida:~/src/perl/YappWithDefaultAction/examples$ \
                            sed -ne '26,33p' Postfix.eyp
 sub _Error {
   my($token)=$_[0]-&gt;YYCurval;
   my($what)= $token ? &quot;input: '$token'&quot; : &quot;end of input&quot;;
   my @expected = $_[0]-&gt;YYExpect();

   local $&quot; = ', ';
   die &quot;Syntax error near $what. Expected one of these tokens: @expected\n&quot;;
 }
</pre>
<p class="Pp">See the tutorial Parse::Eyapp::datagenerationtut and the section
    <i>TOKENS DEPENDING ON THE SYNTACTIC CONTEXT</i> in the tutorial
    Parse::Eyapp::debuggingtut for more detailed examples of use of
    <span class="Li">&quot;YYExpect&quot;</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="$parser_-_YYFirstline"><a class="permalink" href="#$parser_-_YYFirstline">$parser-&gt;YYFirstline</a></h2>
First line of the input string describing the grammar
</section>
<section class="Ss">
<h2 class="Ss" id="$parser_-_YYGrammar"><a class="permalink" href="#$parser_-_YYGrammar">$parser-&gt;YYGrammar</a></h2>
Return the list of grammar items. Each item is an anonymous list containing
<ul class="Bl-bullet">
  <li>The name of the production</li>
  <li>The LHS of the production</li>
  <li>An anonymous list containing the symbols in the RHS</li>
</ul>
<p class="Pp">If it receives an index as argument returns the corresponding item
    The following debugger session explain its use:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  pl@europa:~/LEyapp/examples/recycle$ perl -wd usepostfix.pl
  main::(usepostfix.pl:5):        my $parser = new Postfix();
    DB&lt;1&gt; n
  main::(usepostfix.pl:6):        $parser-&gt;Run;
    DB&lt;1&gt; x $parser-&gt;YYGrammar
  0  ARRAY(0xde5e20)
     0  '_SUPERSTART'
     1  '$start'
     2  ARRAY(0xc85e80)
        0  'line'
        1  '$end'
     3  0
  1  ARRAY(0xe2b6b0)
     0  'line_1'
     1  'line'
     2  ARRAY(0xe3abc0)
        0  'exp'
     3  0
  2  ARRAY(0xa05530)
     0  'exp_2'
     1  'exp'
     2  ARRAY(0x75bdc0)
        0  'NUM'
     3  0

     ...  etc, etc
</pre>
<p class="Pp">If an index is provided it returns the item for such number:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    DB&lt;2&gt; x $parser-&gt;YYGrammar(10)
  0  'exp_10'
  1  'exp'
  2  ARRAY(0xa05f80)
     0  '('
     1  'exp'
     2  ')'
  3  0
</pre>
<p class="Pp">You can also use a production name as argument:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    DB&lt;3&gt; x $parser-&gt;YYGrammar('exp_7')
  0  'exp_7'
  1  'exp'
  2  ARRAY(0xa05890)
     0  'exp'
     1  '*'
     2  'exp'
  3  0
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="$parser_-_YYGetLRAction($state,_$token)"><a class="permalink" href="#$parser_-_YYGetLRAction($state,_$token)">$parser-&gt;YYGetLRAction($state,
  $token)</a></h2>
Returns the shift-reduce action for state <span class="Li">$state</span> and
  token <span class="Li">$token</span>. A positive number must be interpreted as
  a shift to the state with that number. A negative number
  <span class="Li">&quot;-m&quot;</span> indicates a reduction by production
  with index <span class="Li">&quot;m&quot;</span>. Returns
  <span class="Li">&quot;undef&quot;</span> if no action is defined for such
  combination <span class="Li">&quot;($state, $token)&quot;</span>.
<p class="Pp">See example
    <span class="Li">&quot;DynamicallyChangingTheParser.eyp&quot;</span> in the
    directory <span class="Li">&quot;examples/debuggintut&quot;</span> for an
    example of use.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="$parser_-_YYIssemantic"><a class="permalink" href="#$parser_-_YYIssemantic">$parser-&gt;YYIssemantic</a></h2>
Returns TRUE if the terminal is <i>semantic</i>. <i>Semantics token</i> can be
  declared using the directive <span class="Li">&quot;%semantic
  token&quot;</span>. The opposite of a <i>Semantic token</i> is a <i>Syntactic
  token</i>. <i>Syntactic tokens</i> can be declared using the directive
  <span class="Li">&quot;%syntactic token&quot;</span>.
<p class="Pp">When using the <span class="Li">%tree</span> directive all the
    nodes corresponding to syntactic tokens are pruned from the tree. Under this
    directive tokens in the text delimited by simple quotes (like
    <span class="Li">'+'</span>) are, by default, considered syntactic
  tokens.</p>
<p class="Pp">When using the <span class="Li">%metatree</span> directive all the
    tokens are considered, by default, <i>semantic tokens</i>. Thus, no nodes
    will be - by default- pruned when construction the code augmented tree. The
    exception are string tokens used as separators in the definition of lists,
    like in <span class="Li">&quot;S &lt;* ';'&gt;&quot;</span>. If you want the
    separating string token to appear include an explicit semantic declaration
    for it (example <span class="Li">&quot;%semantic token
  ';'&quot;</span>).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="$parser_-_YYIndex"><a class="permalink" href="#$parser_-_YYIndex">$parser-&gt;YYIndex</a></h2>
Receives the name of production (right hand side). Returns the index in the
  grammar of the production with such name. When called in a list context and
  without a name return the hash containing the relation
<p class="Pp"><span class="Li"></span></p>
<pre>
           production name =&gt; production index
</pre>
<p class="Pp">The following debugger session illustrates its use:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  pl@europa:~/LEyapp/examples/recycle$ perl -wd usepostfix.pl
  main::(usepostfix.pl:5):        my $parser = new Postfix();
  main::(usepostfix.pl:6):        $parser-&gt;Run;
  DB&lt;1&gt; x $parser-&gt;YYIndex
  0  'line_1'
  1  1
  2  'exp_3'
  3  3
  4  'exp_6'
  5  6
  6  'exp_4'
  7  4
  8  'exp_10'
  9  10
  10  'exp_8'
  11  8
  12  'exp_5'
  13  5
  14  'exp_7'
  15  7
  16  'exp_2'
  17  2
  18  '_SUPERSTART'
  19  0
  20  'exp_9'
  21  9
</pre>
<p class="Pp">We can specify a list of names:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  DB&lt;2&gt; x $parser-&gt;YYIndex(qw{exp_4 exp_7})
  0  4
  1  7
  DB&lt;3&gt; x $parser-&gt;YYIndex(qw{exp_4})
  0  4
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="$parser_-_YYInput"><a class="permalink" href="#$parser_-_YYInput">$parser-&gt;YYInput</a></h2>
Alias <span class="Li">&quot;input&quot;</span>. If an argument is provided,
  sets the input for the parser object. The argument is a string or a reference
  to a string. It returns a reference to the input string or
  <span class="Li">&quot;undef&quot;</span> if not set.
</section>
<section class="Ss">
<h2 class="Ss" id="$parser_-_YYIsterm"><a class="permalink" href="#$parser_-_YYIsterm">$parser-&gt;YYIsterm</a></h2>
Returns TRUE if the symbol given as argument is a terminal. Example:
<p class="Pp"><span class="Li"></span></p>
<pre>
  DB&lt;0&gt; x $self-&gt;YYIsterm('exp')
 0  ''
  DB&lt;1&gt; x $self-&gt;YYIsterm('*')
 0  1
</pre>
<p class="Pp">An example of combined use of
    <span class="Li">&quot;YYRightside&quot;</span>,
    <span class="Li">&quot;YYRuleindex&quot;</span>,
    <span class="Li">&quot;YYLhs&quot;</span> and
    <span class="Li">&quot;YYIsterm&quot;</span> can be found
    <span class="Li">&quot;examples/Eyapp/Rule3.yp&quot;</span>:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
 nereida:~/src/perl/YappWithDefaultAction/examples&gt; sed -n -e '4,22p' Rule3.yp | cat -n
  1  sub build_node {
  2    my $self = shift;
  3    my @children = @_;
  4    my @right = $self-&gt;YYRightside();
  5    my $var = $self-&gt;YYLhs;
  6    my $rule = $self-&gt;YYRuleindex();
  7
  8    for(my $i = 0; $i &lt; @right; $i++) {
  9      $_ = $right[$i];
 10      if ($self-&gt;YYIsterm($_)) {
 11        $children[$i] = bless { token =&gt; $_, attr =&gt; $children[$i] },
 12                                            __PACKAGE__.'::TERMINAL';
 13      }
 14    }
 15    bless {
 16            children =&gt; \@children,
 17            info =&gt; &quot;$var -&gt; @right&quot;
 18          }, __PACKAGE__.&quot;::${var}_$rule&quot;
 19  }
</pre>
<p class="Pp">when executed an output similar to this is produced:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
 nereida:~/src/perl/YappWithDefaultAction/examples&gt; userule3.pl
 2*3
 $VAR1 = bless( {
   'info' =&gt; 'exp -&gt; exp * exp',
   'children' =&gt; [
     bless( {
       'info' =&gt; 'exp -&gt; NUM',
       'children' =&gt; [ bless( { 'attr' =&gt; '2', 'token' =&gt; 'NUM' }, 'Rule3::TERMINAL' ) ]
     }, 'Rule3::exp_6' ),
     bless( { 'attr' =&gt; '*', 'token' =&gt; '*' }, 'Rule3::TERMINAL' ),
     bless( {
       'info' =&gt; 'exp -&gt; NUM',
       'children' =&gt; [ bless( { 'attr' =&gt; '3', 'token' =&gt; 'NUM' }, 'Rule3::TERMINAL' )
       ]
     }, 'Rule3::exp_6' )
   ]
 }, 'Rule3::exp_11' );
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="$parser_-_YYLexer"><a class="permalink" href="#$parser_-_YYLexer">
  $parser-&gt;YYLexer</a></h2>
Returns a reference to the lexical analyzer
</section>
<section class="Ss">
<h2 class="Ss" id="$parser_-_YYLhs"><a class="permalink" href="#$parser_-_YYLhs">
  $parser-&gt;YYLhs</a></h2>
Returns the identifier of the left hand side of the current production (the one
  that is being used for reduction/reverse derivation. An example of use can be
  found in <span class="Li">&quot;examples/Eyapp/Lhs1.yp&quot;</span>:
<p class="Pp"><span class="Li"></span></p>
<pre>
  %defaultaction { print $_[0]-&gt;YYLhs,&quot;\n&quot; }
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="$parser_-_YYMain"><a class="permalink" href="#$parser_-_YYMain">$parser-&gt;YYMain</a></h2>
Alias is also <span class="Li">&quot;main&quot;</span>.
<p class="Pp">Other than the package, it has as optional arguments the
    <span class="Li">&quot;prompt&quot;</span> (shown each time it ask for
    input), the name of the input file (if it wasn't specified in the command
    line using <span class="Li">&quot;--file filename&quot;</span>) and also the
    input string.</p>
<p class="Pp">This method provides a default
    <span class="Li">&quot;main&quot;</span> for testing the generated parser.
    It parses the commandline searching for a number of options. See an example
    of use:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  pl@nereida:~/LEyapp/examples/eyapplanguageref$ cat use_list2.pl
  #!/usr/bin/env perl
  use warnings;
  use strict;
  use List2;

  unshift @ARGV, '--noslurp';
  List2-&gt;new-&gt;main(&quot;Try input 'aacbb': &quot;);
  pl@nereida:~/LEyapp/examples/eyapplanguageref$ ./use_list2.pl --help
  Available options:
      --debug                    sets yydebug on
      --nodebug                  sets yydebug off
      --file filepath            read input from filepath
      --commandinput string      read input from string
      --tree                     prints $tree-&gt;str
      --notree                   does not print $tree-&gt;str
      --info                     When printing $tree-&gt;str shows the value of TERMINALs
      --help                     shows this help
      --slurp                    read until EOF reached
      --noslurp                  read until CR is reached
      --argfile                  main() will take the input string from its @_
      --noargfile                main() will not take the input string from its @_
      --yaml                     dumps YAML for $tree: YAML module must be installed
      --margin=i                 controls the indentation of $tree-&gt;str (i.e. $Parse::Eyapp::Node::INDENT)
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="$parser_-_YYName"><a class="permalink" href="#$parser_-_YYName">$parser-&gt;YYName</a></h2>
Returns the name of the current rule (The production whose reduction gave place
  to the execution of the current semantic action).
<p class="Pp"><span class="Li"></span></p>
<pre>
  DB&lt;12&gt; x $self-&gt;YYName
 0  'exp_11'
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="$parser_-_YYNames"><a class="permalink" href="#$parser_-_YYNames">$parser-&gt;YYNames</a></h2>
Return the list of production names. In a scalar context returns a reference to
  such list.
<p class="Pp"><span class="Li"></span></p>
<pre>
  pl@europa:~/LEyapp/examples/recycle$ eyapp Postfix
  pl@europa:~/LEyapp/examples/recycle$ perl -wd usepostfix.pl
  main::(usepostfix.pl:5):        my $parser = new Postfix();
  main::(usepostfix.pl:6):        $parser-&gt;Run;
  DB&lt;1&gt; x $parser-&gt;YYNames
  0  '_SUPERSTART'
  1  'line_1'
  2  'exp_2'
  3  'exp_3'
  4  'exp_4'
  5  'exp_5'
  6  'exp_6'
  7  'exp_7'
  8  'exp_8'
  9  'exp_9'
  10  'exp_10'
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="$parser_-_YYNberr"><a class="permalink" href="#$parser_-_YYNberr">$parser-&gt;YYNberr</a></h2>
The current number of errors
</section>
<section class="Ss">
<h2 class="Ss" id="$parser_-__fIYYNextState()_fP;"><a class="permalink" href="#$parser_-__fIYYNextState()_fP;">$parser-&gt;<i>YYNextState()</i>;</a></h2>
If called inside a semantic action, returns the state after the reduction by the
  current production.
<p class="Pp">Provide a token if called from any other side:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  $parser-&gt;YYNextState($token);
</pre>
<p class="Pp">It will return the state given by the action table for the state
    in the top of the stack and the given token.</p>
<p class="Pp">For an example, see the program
    <span class="Li">&quot;DynamicallyChangingTheParser.eyp&quot;</span> in the
    directory <span class="Li">&quot;examples/debuggintut/&quot;</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="$parser_-_YYPrefix"><a class="permalink" href="#$parser_-_YYPrefix">$parser-&gt;YYPrefix</a></h2>
Return and/or sets the <span class="Li">&quot;yyprefix&quot;</span> attribute.
  This a string that will be concatenated as a prefix to any
  <span class="Li">&quot;Parse::Eyapp::Node&quot;</span> nodes in the syntax
  tree.
</section>
<section class="Ss">
<h2 class="Ss" id="$parser_-__fIYYParse()_fP"><a class="permalink" href="#$parser_-__fIYYParse()_fP">
  $parser-&gt;<i>YYParse()</i></a></h2>
It very much works <span class="Li">&quot;Parse::Yapp::YYParse&quot;</span> and
  as yacc/bison <span class="Li">&quot;yyparse&quot;</span>. It accepts almost
  the same arguments as <span class="Li">&quot;Class-&gt;new&quot;</span> with
  the exception of <span class="Li">&quot;yyprefix&quot;</span> which can be
  used only with <span class="Li">&quot;new&quot;</span>.
</section>
<section class="Ss">
<h2 class="Ss" id="$parser_-_YYRecovering"><a class="permalink" href="#$parser_-_YYRecovering">
  $parser-&gt;YYRecovering</a></h2>
Works as yacc/bison <span class="Li">&quot;YYRECOVERING&quot;</span>. Returns
  <span class="Li">&quot;TRUE&quot;</span> if the parser is recovering from a
  syntax error.
</section>
<section class="Ss">
<h2 class="Ss" id="$parser_-_YYRestoreLRAction('conflictname',_$token)"><a class="permalink" href="#$parser_-_YYRestoreLRAction('conflictname',_$token)">$parser-&gt;YYRestoreLRAction('conflictname',
  $token)</a></h2>
This method has been designed to solve shift-reduce and reduce-reduce conflicts
  at parsing-time using the <i>postponed conflict</i> strategy. It has to be
  called inside the semantic action associated with the postponed conflict rule.
  The LALR table is changed so that the action in the presence of the token
  <span class="Li">$token</span> is restored the one before the last call to
<p class="Pp"><span class="Li"></span></p>
<pre>
  $parser-&gt;YYSetReduce($token, $productionname )
</pre>
<p class="Pp">See the examples in
    <span class="Li">&quot;examples/debuggingtut/&quot;</span> in files
    <span class="Li">&quot;DynamicallyChangingTheParser2.eyp&quot;</span> and
    <span class="Li">&quot;Cplusplus.eyp&quot;</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="$parser_-_YYRHSLength($productionindex)"><a class="permalink" href="#$parser_-_YYRHSLength($productionindex)">$parser-&gt;YYRHSLength($productionindex)</a></h2>
Also:
<p class="Pp"><span class="Li"></span></p>
<pre>
  $parser-&gt;YYRHSLength
</pre>
<p class="Pp">returns the length of the right hand side (the number of symbols)
    of <span class="Li">$productionindex</span>. The name of the production can
    be used instead of its index. If no index or name is provided and the method
    is called inside a semantic action, the length of the current production is
    returned.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="$parser_-_YYRightside"><a class="permalink" href="#$parser_-_YYRightside">$parser-&gt;YYRightside</a></h2>
Also:
<p class="Pp"><span class="Li"></span></p>
<pre>
  $parser-&gt;YYRightside($index)
</pre>
<p class="Pp">Returns an array of strings describing the right hand side of the
    rule. The name of the production can be given instead of
    <span class="Li">$index</span>. If no <span class="Li">$index</span> is
    provided and the method is called inside a semantic action the right hand
    side of the current production is returned.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="$parser_-_YYRuleindex"><a class="permalink" href="#$parser_-_YYRuleindex">$parser-&gt;YYRuleindex</a></h2>
To be called inside a semantic action. Returns the index of the current
  production rule, counting the super rule as rule 0.
<p class="Pp">To know the numbers have a look at the
    <span class="Li">&quot;.output&quot;</span> file. To get a
    <span class="Li">&quot;.output&quot;</span> file use the option
    <span class="Li">&quot;-v&quot;</span> of
    <span class="Li">&quot;eyapp&quot;</span> or the
    <span class="Li">&quot;outputfile&quot;</span> parameter when using method
    <span class="Li">&quot;new_grammar&quot;</span> (see the documentation for
    eyapp).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="$parser_-_YYRule"><a class="permalink" href="#$parser_-_YYRule">$parser-&gt;YYRule</a></h2>
Return the list of rules. The following debugger session illustrates its use:
<p class="Pp"><span class="Li"></span></p>
<pre>
  pl@europa:~/LEyapp/examples/recycle$ perl -wd usepostfix.pl
  main::(usepostfix.pl:5):        my $parser = new Postfix();
  main::(usepostfix.pl:6):        $parser-&gt;Run;
  0  ARRAY(0xa068e0)
     0  '$start'
     1  2
     2  undef
  1  ARRAY(0xa06940)
     0  'line'
     1  1
     2  CODE(0xc22360)
        -&gt; &amp;Postfix::__ANON__[Postfix.eyp:10] in Postfix.eyp:227-10
  ... etc, etc.
</pre>
<p class="Pp">Each item has three components: the LHS of the production, the
    number of symbols in the RHS and the CODE reference to the semantic
  action.</p>
<p class="Pp">If an index is specified as argument it returns the corresponding
    item:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
     DB&lt;2&gt; x $parser-&gt;YYRule(7)
  0  'exp'
  1  3
  2  CODE(0xc1fce0)
     -&gt; &amp;Postfix::__ANON__[Postfix.eyp:7] in Postfix.eyp:276-7
</pre>
<p class="Pp">To know to what production an item is associated we can use the
    <span class="Li">&quot;YYGrammar&quot;</span> method:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
     DB&lt;3&gt; x $parser-&gt;YYGrammar('exp_7')
  0  'exp_7'
  1  'exp'
  2  ARRAY(0xa05290)
     0  'exp'
     1  '*'
     2  'exp'
  3  0
</pre>
<p class="Pp">We can also use the name of the rule to get the item:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
   DB&lt;4&gt; x $parser-&gt;YYRule('exp_7')
  0  'exp'
  1  3
  2  CODE(0xc1fce0)
     -&gt; &amp;Postfix::__ANON__[Postfix.eyp:7] in Postfix.eyp:276-7
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="$parser_-_YYSetaction"><a class="permalink" href="#$parser_-_YYSetaction">$parser-&gt;YYSetaction</a></h2>
Receives a hash with keys the names of the production rules (right hand sides)
  and values the new semantic actions. Used to reuse a grammar without
  overwriting all the semantic actions. See section <i>Reusing Grammars by
  Dynamic Substitution of Semantic Actions</i> in
  Parse::Eyapp::defaultactionsintro.
</section>
<section class="Ss">
<h2 class="Ss" id="$parser_-_YYSetLRAction($conflictstate,_$token,_$shiftreduceaction_)"><a class="permalink" href="#$parser_-_YYSetLRAction($conflictstate,_$token,_$shiftreduceaction_)">$parser-&gt;YYSetLRAction($conflictstate,
  $token, $shiftreduceaction )</a></h2>
It also accepts the syntax:
<p class="Pp"><span class="Li"></span></p>
<pre>
  $parser-&gt;YYSetLRAction($conflictstate, [$token1, ... ], $shiftreduceaction )
</pre>
<p class="Pp">This method has been designed to solve shift-reduce and
    reduce-reduce conflicts at parsing-time (not at parser-generation time).</p>
<p class="Pp">The LR table is changed so that the action in state
    <span class="Li">$conflictstate</span> in the presence of the token
    <span class="Li">$token</span> will be given by
    <span class="Li">$shiftreduceaction</span>. The current shift-reduce action
    isn't saved.</p>
<p class="Pp">See an example in
    <span class="Li">&quot;Cplusplus2.eyp&quot;</span> in the directory
    <span class="Li">&quot;examples/debuggintut&quot;</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="$parser_-_YYSetReduce($token,_$productionname_)"><a class="permalink" href="#$parser_-_YYSetReduce($token,_$productionname_)">$parser-&gt;YYSetReduce($token,
  $productionname )</a></h2>
This method has been designed to solve shift-reduce and reduce-reduce conflicts
  at parsing-time using the <i>postponed conflict</i> strategy. See the
  corresponding section in Parse::Eyapp::debuggintut. It has to be called inside
  the semantic action associated with the postponed conflict rule
  <span class="Li">&quot;conflictname&quot;</span>. The LALR table is changed so
  that the action in the presence of the token <span class="Li">$token</span>
  will be to reduce by <span class="Li">$productionname</span>. The current
  shift-reduce action is saved to be restored using
<p class="Pp"><span class="Li"></span></p>
<pre>
  $parser-&gt;YYRestoreLRAction('conflictname', $token)
</pre>
<p class="Pp">See the examples in
    <span class="Li">&quot;examples/debuggingtut/&quot;</span> in files</p>
<ul class="Bl-bullet">
  <li><span class="Li">&quot;DynamicallyChangingTheParser2.eyp&quot;</span></li>
  <li><span class="Li">&quot;confusingsolveddynamic.eyp&quot;</span></li>
  <li><span class="Li">&quot;DebugDynamicResolution.eyp&quot;</span></li>
  <li><span class="Li">&quot;DynamicallyChangingTheParser2.eyp&quot;</span></li>
  <li><span class="Li">&quot;DynamicallyChangingTheParser3.eyp&quot;</span></li>
  <li><span class="Li">&quot;DynamicallyChangingTheParser.eyp&quot;</span></li>
  <li><span class="Li">&quot;DynamicvsTieIns.eyp&quot;</span></li>
  <li><span class="Li">&quot;nolr_k_grammarsolveddynamic.eyp&quot;</span></li>
  <li><span class="Li">&quot;pascalenumeratedvsrangesolvedviadyn.eyp&quot;</span></li>
  <li><span class="Li">&quot;Cplusplus.eyp&quot;</span>.</li>
</ul>
</section>
<section class="Ss">
<h2 class="Ss" id="$parser_-_YYSetShift($token)"><a class="permalink" href="#$parser_-_YYSetShift($token)">$parser-&gt;YYSetShift($token)</a></h2>
Also:
<p class="Pp"><span class="Li"></span></p>
<pre>
      $parser-&gt;YYSetShift([$token1, $token2, ... ])
</pre>
<p class="Pp">This method has been designed to solve shift-reduce at
    parsing-time using the <i>postponed conflict</i> strategy. See the
    corresponding section in Parse::Eyapp::debuggintut. It has to be called
    inside the semantic action associated with the postponed conflict rule
    <span class="Li">&quot;conflictname&quot;</span>. The LALR table is changed
    so that the action in the presence of the token
    <span class="Li">$token</span> will be to shift.</p>
<p class="Pp">See the examples in
    <span class="Li">&quot;examples/debuggingtut/&quot;</span> in files</p>
<ul class="Bl-bullet">
  <li><span class="Li">&quot;DebugDynamicResolution.eyp&quot;</span></li>
  <li><span class="Li">&quot;DynamicallyChangingTheParser.eyp&quot;</span></li>
</ul>
</section>
<section class="Ss">
<h2 class="Ss" id="$parser_-_YYSlurpFile"><a class="permalink" href="#$parser_-_YYSlurpFile">$parser-&gt;YYSlurpFile</a></h2>
alias:
<p class="Pp"><span class="Li"></span></p>
<pre>
 $parser-&gt;slurp_file($filename[,$prompt[,$mode]])
</pre>
<p class="Pp">Receives the name of the file, reads its contents and stores it in
    <span class="Li">&quot;$parser-&gt;input&quot;</span>.</p>
<p class="Pp">If the file does not exists, it proceeds to read from
    <span class="Li">&quot;STDIN&quot;</span>. If a prompt was set with
    <span class="Li">&quot;$parser-&gt;YYPrompt&quot;</span>, it will be shown.
    The additional optional parameter <span class="Li">$mode</span> is used in
    such case to set <span class="Li">$/</span>. It can also be used as a class
    method.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="$parser_-_YYState"><a class="permalink" href="#$parser_-_YYState">$parser-&gt;YYState</a></h2>
<span class="Li">&quot;YYState&quot;</span> returns a reference to the list of
  states containing the <i>LALR</i>(1) tables: the action and GOTO tables. Each
  state is an anonymous hash:
<p class="Pp"><span class="Li"></span></p>
<pre>
  DB&lt;4&gt; x $parser-&gt;YYState(2)
  0  HASH(0xfa7120)
     'ACTIONS' =&gt; HASH(0xfa70f0) # token =&gt; state
           ':' =&gt; '-7'
     'DEFAULT' =&gt; '-6'
</pre>
<p class="Pp">A negative number means reduction using the corresponding
    production rule (opposite) number. The former example tells to reduce by
    rule 7 when in state 2 and seeing token <span class="Li">':'</span>. By
    default, the action when in state 2 is to reduce by rule number 6.</p>
<p class="Pp">There are three keys: ACTIONS, GOTOS and DEFAULT</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  DB&lt;7&gt; x $parser-&gt;YYState(13)
 0  HASH(0xfa8b50)
    'ACTIONS' =&gt; HASH(0xfa7530)
       'VAR' =&gt; 17
    'GOTOS' =&gt; HASH(0xfa8b20)
       'type' =&gt; 19
</pre>
<p class="Pp">The GOTOS tables contains the DFA transition tables for the
    syntactic variables. The former example tells to move to state 19 when in
    state 13 after seeing the syntactic variable
    <span class="Li">&quot;type&quot;</span> (i.e. if after reducing by a rule
    of <span class="Li">&quot;type&quot;</span> we are in state 13).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="$parser_-_YYTopState($length)"><a class="permalink" href="#$parser_-_YYTopState($length)">$parser-&gt;YYTopState($length)</a></h2>
If <span class="Li">$length</span> is zero or not provided it returns the state
  on top of the stack. Otherwise, returns the state
  <span class="Li">$length</span> units deep in the stack.
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="CONTRIBUTORS"><a class="permalink" href="#CONTRIBUTORS">CONTRIBUTORS</a></h1>
<ul class="Bl-bullet">
  <li>Hal Finkel &lt;http://www.halssoftware.com/&gt;</li>
  <li>G. Williams &lt;http://kasei.us/&gt;</li>
  <li>Thomas L. Shinnick &lt;http://search.cpan.org/~tshinnic/&gt;</li>
  <li>Frank Leray</li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
Casiano Rodriguez-Leon (casiano@ull.es)
</section>
<section class="Sh">
<h1 class="Sh" id="ACKNOWLEDGMENTS"><a class="permalink" href="#ACKNOWLEDGMENTS">ACKNOWLEDGMENTS</a></h1>
This work has been supported by CEE (FEDER) and the Spanish Ministry of
  <i>Educacion y Ciencia</i> through <i>Plan Nacional I+D+I</i> number
  TIN2005-08818-C04-04 (ULL::OPLINK project &lt;http://www.oplink.ull.es/&gt;).
  Support from Gobierno de Canarias was through GC02210601 (<i>Grupos
  Consolidados</i>). The University of La Laguna has also supported my work in
  many ways and for many years.
<p class="Pp">A large percentage of code is verbatim taken from Parse::Yapp
    1.05. The author of Parse::Yapp is Francois Desarmenien.</p>
<p class="Pp">I wish to thank Francois Desarmenien for his Parse::Yapp module,
    to my students at La Laguna and to the Perl Community. Thanks to the people
    who have contributed to improve the module (see &quot;CONTRIBUTORS&quot; in
    Parse::Eyapp). Thanks to Larry Wall for giving us Perl. Special thanks to
    Juana.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="LICENCE_AND_COPYRIGHT"><a class="permalink" href="#LICENCE_AND_COPYRIGHT">LICENCE
  AND COPYRIGHT</a></h1>
Copyright (c) 2006-2008 Casiano Rodriguez-Leon (casiano@ull.es). All rights
  reserved.
<p class="Pp">Parse::Yapp copyright is of Francois Desarmenien, all rights
    reserved. 1998-2001</p>
<p class="Pp">These modules are free software; you can redistribute it and/or
    modify it under the same terms as Perl itself. See perlartistic.</p>
<p class="Pp">This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. </p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2012-03-23</td>
    <td class="foot-os">perl v5.18.2</td>
  </tr>
</table>
</body>
</html>
