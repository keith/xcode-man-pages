<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Copyright (c) 1998 Sun Microsystems, Inc.
   Copyright (c) 1999 Scriptics Corporation
  
   See the file "license.terms" for information on usage and redistribution
   of this file, and for a DISCLAIMER OF ALL WARRANTIES.
  
   RCS: @(#) $Id: re_syntax.n,v 1.18 2007/12/13 15:22:33 dgp Exp $
  
   The -*- nroff -*- definitions below are for supplemental macros used
   in Tcl/Tk manual entries.
  
   .AP type name in/out ?indent?
  	Start paragraph describing an argument to a library procedure.
  	type is type of argument (int, etc.), in/out is either "in", "out",
  	or "in/out" to describe whether procedure reads or modifies arg,
  	and indent is equivalent to second arg of .IP (shouldn't ever be
  	needed;  use .AS below instead)
  
   .AS ?type? ?name?
  	Give maximum sizes of arguments for setting tab stops.  Type and
  	name are examples of largest possible arguments that will be passed
  	to .AP later.  If args are omitted, default tab stops are used.
  
   .BS
  	Start box enclosure.  From here until next .BE, everything will be
  	enclosed in one large box.
  
   .BE
  	End of box enclosure.
  
   .CS
  	Begin code excerpt.
  
   .CE
  	End code excerpt.
  
   .VS ?version? ?br?
  	Begin vertical sidebar, for use in marking newly-changed parts
  	of man pages.  The first argument is ignored and used for recording
  	the version when the .VS was added, so that the sidebars can be
  	found and removed when they reach a certain age.  If another argument
  	is present, then a line break is forced before starting the sidebar.
  
   .VE
  	End of vertical sidebar.
  
   .DS
  	Begin an indented unfilled display.
  
   .DE
  	End of indented unfilled display.
  
   .SO ?manpage?
  	Start of list of standard options for a Tk widget. The manpage
  	argument defines where to look up the standard options; if
  	omitted, defaults to "options". The options follow on successive
  	lines, in three columns separated by tabs.
  
   .SE
  	End of list of standard options for a Tk widget.
  
   .OP cmdName dbName dbClass
  	Start of description of a specific option.  cmdName gives the
  	option's name as specified in the class command, dbName gives
  	the option's name in the option database, and dbClass gives
  	the option's class in the option database.
  
   .UL arg1 arg2
  	Print arg1 underlined, then print arg2 normally.
  
   .QW arg1 ?arg2?
  	Print arg1 in quotes, then arg2 normally (for trailing punctuation).
  
   .PQ arg1 ?arg2?
  	Print an open parenthesis, arg1 in quotes, then arg2 normally
  	(for trailing punctuation) and then a closing parenthesis.
  
   RCS: @(#) $Id: man.macros,v 1.9 2008/01/29 15:32:33 dkf Exp $
  
  	# Set up traps and other miscellaneous stuff for Tcl/Tk man pages.
  	# Start an argument description
  .b
  	# define tabbing values for .AP
  
  	# BS - start boxed text
  	# ^y = starting y location
  	# ^b = 1
  	# BE - end boxed text (draw box now)
  	Draw four-sided box normally, but don't draw top of
  	box if the box started on an earlier page.
  	# VS - start vertical sidebar
  	# ^Y = starting y location
  	# ^v = 1 (for troff;  for nroff this doesn't matter)
  	# VE - end of vertical sidebar
  	# Special macro to handle page bottom:  finish off current
  	# box/sidebar if in box/sidebar mode, then invoked standard
  	# page bottom macro.
  	Draw three-sided box if this is the box's first page,
  	draw two sides but no top otherwise.
  	# DS - begin display
  	# DE - end display
  	# SO - start of list of standard options
  	# SE - end of list of standard options
  	# OP - start of full description for a single option
  	# CS - begin code excerpt
  	# CE - end code excerpt
  	# UL - underline word
  	# QW - apply quotation marks to word
  " fix emacs highlighting
  	# PQ - apply parens and quotation marks to word
  " fix emacs highlighting
  	# QR - quoted range
  " fix emacs highlighting
  	# MT - "empty" string
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>re_syntax(n)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">re_syntax(n)</td>
    <td class="head-vol">Tcl Built-In Commands</td>
    <td class="head-rtitle">re_syntax(n)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<pre>

</pre>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
re_syntax - Syntax of Tcl regular expressions
<pre>

</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
A <i>regular expression</i> describes strings of characters. It's a pattern that
  matches certain strings and does not match others.
</section>
<section class="Sh">
<h1 class="Sh" id="DIFFERENT_FLAVORS_OF_REs"><a class="permalink" href="#DIFFERENT_FLAVORS_OF_REs">DIFFERENT
  FLAVORS OF REs</a></h1>
Regular expressions (&#x201C;RE&#x201D;s), as defined by POSIX, come in two
  flavors: <i>extended</i> REs (&#x201C;ERE&#x201D;s) and <i>basic</i> REs
  (&#x201C;BRE&#x201D;s). EREs are roughly those of the traditional
  <i>egrep</i>, while BREs are roughly those of the traditional <i>ed</i>. This
  implementation adds a third flavor, <i>advanced</i> REs
  (&#x201C;ARE&#x201D;s), basically EREs with some significant extensions.
<p class="Pp">This manual page primarily describes AREs. BREs mostly exist for
    backward compatibility in some old programs; they will be discussed at the
    end. POSIX EREs are almost an exact subset of AREs. Features of AREs that
    are not present in EREs will be indicated.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="REGULAR_EXPRESSION_SYNTAX"><a class="permalink" href="#REGULAR_EXPRESSION_SYNTAX">REGULAR
  EXPRESSION SYNTAX</a></h1>
Tcl regular expressions are implemented using the package written by Henry
  Spencer, based on the 1003.2 spec and some (not quite all) of the Perl5
  extensions (thanks, Henry!). Much of the description of regular expressions
  below is copied verbatim from his manual entry.
<p class="Pp">An ARE is one or more <i>branches</i>, separated by
    &#x201C;<b>|</b>&#x201D;, matching anything that matches any of the
    branches.</p>
<p class="Pp">A branch is zero or more <i>constraints</i> or <i>quantified
    atoms</i>, concatenated. It matches a match for the first, followed by a
    match for the second, etc; an empty branch matches the empty string.</p>
<section class="Ss">
<h2 class="Ss" id="QUANTIFIERS"><a class="permalink" href="#QUANTIFIERS">QUANTIFIERS</a></h2>
A quantified atom is an <i>atom</i> possibly followed by a single
  <i>quantifier</i>. Without a quantifier, it matches a single match for the
  atom. The quantifiers, and what a so-quantified atom matches, are:
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>*</b></dt>
  <dd>a sequence of 0 or more matches of the atom</dd>
  <dt><b>+</b></dt>
  <dd>a sequence of 1 or more matches of the atom</dd>
  <dt><b>?</b></dt>
  <dd>a sequence of 0 or 1 matches of the atom</dd>
  <dt><b>{</b><i>m</i><b>}</b></dt>
  <dd>a sequence of exactly <i>m</i> matches of the atom</dd>
  <dt><b>{</b><i>m</i><b>,}</b></dt>
  <dd>a sequence of <i>m</i> or more matches of the atom</dd>
  <dt><b>{</b><i>m</i><b>,</b><i>n</i><b>}</b></dt>
  <dd>a sequence of <i>m</i> through <i>n</i> (inclusive) matches of the atom;
      <i>m</i> may not exceed <i>n</i></dd>
  <dt><b>*? +? ?? {</b><i>m</i><b>}? {</b><i>m</i><b>,}?
    {</b><i>m</i><b>,</b><i>n</i><b>}?</b></dt>
  <dd><i>non-greedy</i> quantifiers, which match the same possibilities, but
      prefer the smallest number rather than the largest number of matches (see
      <b>MATCHING</b>)</dd>
</dl>
</div>
<p class="Pp">The forms using <b>{</b> and <b>}</b> are known as <i>bound</i>s.
    The numbers <i>m</i> and <i>n</i> are unsigned decimal integers with
    permissible values from 0 to 255 inclusive.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="ATOMS"><a class="permalink" href="#ATOMS">ATOMS</a></h2>
An atom is one of:
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>(</b><i>re</i><b>)</b></dt>
  <dd>matches a match for <i>re</i> (<i>re</i> is any regular expression) with
      the match noted for possible reporting</dd>
  <dt><b>(?:</b><i>re</i><b>)</b></dt>
  <dd>as previous, but does no reporting (a &#x201C;non-capturing&#x201D; set of
      parentheses)</dd>
  <dt><b>()</b></dt>
  <dd>matches an empty string, noted for possible reporting</dd>
  <dt><b>(?:)</b></dt>
  <dd>matches an empty string, without reporting</dd>
  <dt><b>[</b><i>chars</i><b>]</b></dt>
  <dd>a <i>bracket expression</i>, matching any one of the <i>chars</i> (see
      <b>BRACKET EXPRESSIONS</b> for more detail)</dd>
  <dt><b>.</b></dt>
  <dd>matches any single character</dd>
  <dt><b>\</b><i>k</i></dt>
  <dd>matches the non-alphanumeric character <i>k</i> taken as an ordinary
      character, e.g. <b>\\</b> matches a backslash character</dd>
  <dt><b>\</b><i>c</i></dt>
  <dd>where <i>c</i> is alphanumeric (possibly followed by other characters), an
      <i>escape</i> (AREs only), see <b>ESCAPES</b> below</dd>
  <dt><b>{</b></dt>
  <dd>when followed by a character other than a digit, matches the left-brace
      character &#x201C;<b>{</b>&#x201D;; when followed by a digit, it is the
      beginning of a <i>bound</i> (see above)</dd>
  <dt><i>x</i></dt>
  <dd>where <i>x</i> is a single character with no other significance, matches
      that character.</dd>
</dl>
</div>
</section>
<section class="Ss">
<h2 class="Ss" id="CONSTRAINTS"><a class="permalink" href="#CONSTRAINTS">CONSTRAINTS</a></h2>
A <i>constraint</i> matches an empty string when specific conditions are met. A
  constraint may not be followed by a quantifier. The simple constraints are as
  follows; some more constraints are described later, under <b>ESCAPES</b>.
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>^</b></dt>
  <dd>matches at the beginning of a line</dd>
  <dt><b>$</b></dt>
  <dd>matches at the end of a line</dd>
  <dt><b>(?=</b><i>re</i><b>)</b></dt>
  <dd><i>positive lookahead</i> (AREs only), matches at any point where a
      substring matching <i>re</i> begins</dd>
  <dt><b>(?!</b><i>re</i><b>)</b></dt>
  <dd><i>negative lookahead</i> (AREs only), matches at any point where no
      substring matching <i>re</i> begins</dd>
</dl>
</div>
<p class="Pp">The lookahead constraints may not contain back references (see
    later), and all parentheses within them are considered non-capturing.</p>
<p class="Pp">An RE may not end with &#x201C;<b>\</b>&#x201D;.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="BRACKET_EXPRESSIONS"><a class="permalink" href="#BRACKET_EXPRESSIONS">BRACKET
  EXPRESSIONS</a></h1>
A <i>bracket expression</i> is a list of characters enclosed in
  &#x201C;<b>[]</b>&#x201D;. It normally matches any single character from the
  list (but see below). If the list begins with &#x201C;<b>^</b>&#x201D;, it
  matches any single character (but see below) <i>not</i> from the rest of the
  list.
<p class="Pp">If two characters in the list are separated by
    &#x201C;<b>-</b>&#x201D;, this is shorthand for the full <i>range</i> of
    characters between those two (inclusive) in the collating sequence, e.g.
    &#x201C;<b>[0-9]</b>&#x201D; in Unicode matches any conventional decimal
    digit. Two ranges may not share an endpoint, so e.g.
    &#x201C;<b>a-c-e</b>&#x201D; is illegal. Ranges in Tcl always use the
    Unicode collating sequence, but other programs may use other collating
    sequences and this can be a source of incompatability between programs.</p>
<p class="Pp">To include a literal <b>]</b> or <b>-</b> in the list, the
    simplest method is to enclose it in <b>[.</b> and <b>.]</b> to make it a
    collating element (see below). Alternatively, make it the first character
    (following a possible &#x201C;<b>^</b>&#x201D;), or (AREs only) precede it
    with &#x201C;<b>\</b>&#x201D;. Alternatively, for &#x201C;<b>-</b>&#x201D;,
    make it the last character, or the second endpoint of a range. To use a
    literal <b>-</b> as the first endpoint of a range, make it a collating
    element or (AREs only) precede it with &#x201C;<b>\</b>&#x201D;. With the
    exception of these, some combinations using <b>[</b> (see next paragraphs),
    and escapes, all other special characters lose their special significance
    within a bracket expression.</p>
<section class="Ss">
<h2 class="Ss" id="CHARACTER_CLASSES"><a class="permalink" href="#CHARACTER_CLASSES">CHARACTER
  CLASSES</a></h2>
Within a bracket expression, the name of a <i>character class</i> enclosed in
  <b>[:</b> and <b>:]</b> stands for the list of all characters (not all
  collating elements!) belonging to that class. Standard character classes are:
<dl class="Bl-tag">
  <dt><b>alpha</b></dt>
  <dd>A letter.</dd>
  <dt><b>upper</b></dt>
  <dd>An upper-case letter.</dd>
  <dt><b>lower</b></dt>
  <dd>A lower-case letter.</dd>
  <dt><b>digit</b></dt>
  <dd>A decimal digit.</dd>
  <dt><b>xdigit</b></dt>
  <dd>A hexadecimal digit.</dd>
  <dt><b>alnum</b></dt>
  <dd>An alphanumeric (letter or digit).</dd>
  <dt><b>print</b></dt>
  <dd>A &quot;printable&quot; (same as graph, except also including space).</dd>
  <dt><b>blank</b></dt>
  <dd>A space or tab character.</dd>
  <dt><b>space</b></dt>
  <dd>A character producing white space in displayed text.</dd>
  <dt><b>punct</b></dt>
  <dd>A punctuation character.</dd>
  <dt><b>graph</b></dt>
  <dd>A character with a visible representation (includes both alnum and
    punct).</dd>
  <dt><b>cntrl</b></dt>
  <dd>A control character.</dd>
</dl>
<p class="Pp">A locale may provide others. A character class may not be used as
    an endpoint of a range.</p>
<div class="Bd-indent">
<p class="Pp">(<i>Note:</i> the current Tcl implementation has only one locale,
    the Unicode locale, which supports exactly the above classes.)</p>
</div>
</section>
<section class="Ss">
<h2 class="Ss" id="BRACKETED_CONSTRAINTS"><a class="permalink" href="#BRACKETED_CONSTRAINTS">BRACKETED
  CONSTRAINTS</a></h2>
There are two special cases of bracket expressions: the bracket expressions
  &#x201C;<b>[[:&lt;:]]</b>&#x201D; and &#x201C;<b>[[:&gt;:]]</b>&#x201D; are
  constraints, matching empty strings at the beginning and end of a word
  respectively. A word is defined as a sequence of word characters that is
  neither preceded nor followed by word characters. A word character is an
  <i>alnum</i> character or an underscore (&#x201C;<b>_</b>&#x201D;). These
  special bracket expressions are deprecated; users of AREs should use
  constraint escapes instead (see below).
</section>
<section class="Ss">
<h2 class="Ss" id="COLLATING_ELEMENTS"><a class="permalink" href="#COLLATING_ELEMENTS">COLLATING
  ELEMENTS</a></h2>
Within a bracket expression, a collating element (a character, a multi-character
  sequence that collates as if it were a single character, or a
  collating-sequence name for either) enclosed in <b>[.</b> and <b>.]</b> stands
  for the sequence of characters of that collating element. The sequence is a
  single element of the bracket expression's list. A bracket expression in a
  locale that has multi-character collating elements can thus match more than
  one character. So (insidiously), a bracket expression that starts with
  <b>^</b> can match multi-character collating elements even if none of them
  appear in the bracket expression!
<div class="Bd-indent">
<p class="Pp">(<i>Note:</i> Tcl has no multi-character collating elements. This
    information is only for illustration.)</p>
</div>
<p class="Pp">For example, assume the collating sequence includes a <b>ch</b>
    multi-character collating element. Then the RE
    &#x201C;<b>[[.ch.]]*c</b>&#x201D; (zero or more &#x201C;<b>ch</b>s&#x201D;
    followed by &#x201C;<b>c</b>&#x201D;) matches the first five characters of
    &#x201C;<b>chchcc</b>&#x201D;. Also, the RE &#x201C;<b>[^c]b</b>&#x201D;
    matches all of &#x201C;<b>chb</b>&#x201D; (because
    &#x201C;<b>[^c]</b>&#x201D; matches the multi-character
    &#x201C;<b>ch</b>&#x201D;).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="EQUIVALENCE_CLASSES"><a class="permalink" href="#EQUIVALENCE_CLASSES">EQUIVALENCE
  CLASSES</a></h2>
Within a bracket expression, a collating element enclosed in <b>[=</b> and
  <b>=]</b> is an equivalence class, standing for the sequences of characters of
  all collating elements equivalent to that one, including itself. (If there are
  no other equivalent collating elements, the treatment is as if the enclosing
  delimiters were &#x201C;<b>[.</b>&#x201D; and &#x201C;<b>.]</b>&#x201D;.) For
  example, if <b>o</b> and <b>&#x00F4;</b> are the members of an equivalence
  class, then &#x201C;<b>[[=o=]]</b>&#x201D;,
  &#x201C;<b>[[=&#x00F4;=]]</b>&#x201D;, and &#x201C;<b>[o&#x00F4;]</b>&#x201D;
  are all synonymous. An equivalence class may not be an endpoint of a range.
<div class="Bd-indent">
<p class="Pp">(<i>Note:</i> Tcl implements only the Unicode locale. It does not
    define any equivalence classes. The examples above are just
  illustrations.)</p>
</div>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="ESCAPES"><a class="permalink" href="#ESCAPES">ESCAPES</a></h1>
Escapes (AREs only), which begin with a <b>\</b> followed by an alphanumeric
  character, come in several varieties: character entry, class shorthands,
  constraint escapes, and back references. A <b>\</b> followed by an
  alphanumeric character but not constituting a valid escape is illegal in AREs.
  In EREs, there are no escapes: outside a bracket expression, a <b>\</b>
  followed by an alphanumeric character merely stands for that character as an
  ordinary character, and inside a bracket expression, <b>\</b> is an ordinary
  character. (The latter is the one actual incompatibility between EREs and
  AREs.)
<section class="Ss">
<h2 class="Ss" id="CHARACTER-ENTRY_ESCAPES"><a class="permalink" href="#CHARACTER-ENTRY_ESCAPES">CHARACTER-ENTRY
  ESCAPES</a></h2>
Character-entry escapes (AREs only) exist to make it easier to specify
  non-printing and otherwise inconvenient characters in REs:
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>\a</b></dt>
  <dd>alert (bell) character, as in C</dd>
  <dt><b>\b</b></dt>
  <dd>backspace, as in C</dd>
  <dt><b>\B</b></dt>
  <dd>synonym for <b>\</b> to help reduce backslash doubling in some
      applications where there are multiple levels of backslash processing</dd>
  <dt><b>\c</b><i>X</i></dt>
  <dd>(where <i>X</i> is any character) the character whose low-order 5 bits are
      the same as those of <i>X</i>, and whose other bits are all zero</dd>
  <dt><b>\e</b></dt>
  <dd>the character whose collating-sequence name is &#x201C;<b>ESC</b>&#x201D;,
      or failing that, the character with octal value 033</dd>
  <dt><b>\f</b></dt>
  <dd>formfeed, as in C</dd>
  <dt><b>\n</b></dt>
  <dd>newline, as in C</dd>
  <dt><b>\r</b></dt>
  <dd>carriage return, as in C</dd>
  <dt><b>\t</b></dt>
  <dd>horizontal tab, as in C</dd>
  <dt><b>\u</b><i>wxyz</i></dt>
  <dd>(where <i>wxyz</i> is exactly four hexadecimal digits) the Unicode
      character <b>U+</b><i>wxyz</i> in the local byte ordering</dd>
  <dt><b>\U</b><i>stuvwxyz</i></dt>
  <dd>(where <i>stuvwxyz</i> is exactly eight hexadecimal digits) reserved for a
      somewhat-hypothetical Unicode extension to 32 bits</dd>
  <dt><b>\v</b></dt>
  <dd>vertical tab, as in C are all available.</dd>
  <dt><b>\x</b><i>hhh</i></dt>
  <dd>(where <i>hhh</i> is any sequence of hexadecimal digits) the character
      whose hexadecimal value is <b>0x</b><i>hhh</i> (a single character no
      matter how many hexadecimal digits are used).</dd>
  <dt><b>\0</b></dt>
  <dd>the character whose value is <b>0</b></dd>
  <dt><b>\</b><i>xy</i></dt>
  <dd>(where <i>xy</i> is exactly two octal digits, and is not a <i>back</i>
      <i>reference</i> (see below)) the character whose octal value is
      <b>0</b><i>xy</i></dd>
  <dt><b>\</b><i>xyz</i></dt>
  <dd>(where <i>xyz</i> is exactly three octal digits, and is not a back
      reference (see below)) the character whose octal value is
      <b>0</b><i>xyz</i></dd>
</dl>
</div>
<p class="Pp">Hexadecimal digits are
    &#x201C;<b>0</b>&#x201D;-&#x201C;<b>9</b>&#x201D;,
    &#x201C;<b>a</b>&#x201D;-&#x201C;<b>f</b>&#x201D;, and
    &#x201C;<b>A</b>&#x201D;-&#x201C;<b>F</b>&#x201D;. Octal digits are
    &#x201C;<b>0</b>&#x201D;-&#x201C;<b>7</b>&#x201D;.</p>
<p class="Pp">The character-entry escapes are always taken as ordinary
    characters. For example, <b>\135</b> is <b>]</b> in Unicode, but <b>\135</b>
    does not terminate a bracket expression. Beware, however, that some
    applications (e.g., C compilers and the Tcl interpreter if the regular
    expression is not quoted with braces) interpret such sequences themselves
    before the regular-expression package gets to see them, which may require
    doubling (quadrupling, etc.) the &#x201C;<b>\</b>&#x201D;.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="CLASS-SHORTHAND_ESCAPES"><a class="permalink" href="#CLASS-SHORTHAND_ESCAPES">CLASS-SHORTHAND
  ESCAPES</a></h2>
Class-shorthand escapes (AREs only) provide shorthands for certain commonly-used
  character classes:
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>\d</b></dt>
  <dd><b>[[:digit:]]</b></dd>
  <dt><b>\s</b></dt>
  <dd><b>[[:space:]]</b></dd>
  <dt><b>\w</b></dt>
  <dd><b>[[:alnum:]_]</b> (note underscore)</dd>
  <dt><b>\D</b></dt>
  <dd><b>[^[:digit:]]</b></dd>
  <dt><b>\S</b></dt>
  <dd><b>[^[:space:]]</b></dd>
  <dt><b>\W</b></dt>
  <dd><b>[^[:alnum:]_]</b> (note underscore)</dd>
</dl>
</div>
<p class="Pp">Within bracket expressions, &#x201C;<b>\d</b>&#x201D;,
    &#x201C;<b>\s</b>&#x201D;, and &#x201C;<b>\w</b>&#x201D; lose their outer
    brackets, and &#x201C;<b>\D</b>&#x201D;, &#x201C;<b>\S</b>&#x201D;, and
    &#x201C;<b>\W</b>&#x201D; are illegal. (So, for example,
    &#x201C;<b>[a-c\d]</b>&#x201D; is equivalent to
    &#x201C;<b>[a-c[:digit:]]</b>&#x201D;. Also, &#x201C;<b>[a-c\D]</b>&#x201D;,
    which is equivalent to &#x201C;<b>[a-c^[:digit:]]</b>&#x201D;, is
  illegal.)</p>
</section>
<section class="Ss">
<h2 class="Ss" id="CONSTRAINT_ESCAPES"><a class="permalink" href="#CONSTRAINT_ESCAPES">CONSTRAINT
  ESCAPES</a></h2>
A constraint escape (AREs only) is a constraint, matching the empty string if
  specific conditions are met, written as an escape:
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>\A</b></dt>
  <dd>matches only at the beginning of the string (see <b>MATCHING</b>, below,
      for how this differs from &#x201C;<b>^</b>&#x201D;)</dd>
  <dt><b>\m</b></dt>
  <dd>matches only at the beginning of a word</dd>
  <dt><b>\M</b></dt>
  <dd>matches only at the end of a word</dd>
  <dt><b>\y</b></dt>
  <dd>matches only at the beginning or end of a word</dd>
  <dt><b>\Y</b></dt>
  <dd>matches only at a point that is not the beginning or end of a word</dd>
  <dt><b>\Z</b></dt>
  <dd>matches only at the end of the string (see <b>MATCHING</b>, below, for how
      this differs from &#x201C;<b>$</b>&#x201D;)</dd>
  <dt><b>\</b><i>m</i></dt>
  <dd>(where <i>m</i> is a nonzero digit) a <i>back reference</i>, see
    below</dd>
  <dt><b>\</b><i>mnn</i></dt>
  <dd>(where <i>m</i> is a nonzero digit, and <i>nn</i> is some more digits, and
      the decimal value <i>mnn</i> is not greater than the number of closing
      capturing parentheses seen so far) a <i>back reference</i>, see below</dd>
</dl>
</div>
<p class="Pp">A word is defined as in the specification of
    &#x201C;<b>[[:&lt;:]]</b>&#x201D; and &#x201C;<b>[[:&gt;:]]</b>&#x201D;
    above. Constraint escapes are illegal within bracket expressions.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="BACK_REFERENCES"><a class="permalink" href="#BACK_REFERENCES">BACK
  REFERENCES</a></h2>
A back reference (AREs only) matches the same string matched by the
  parenthesized subexpression specified by the number, so that (e.g.)
  &#x201C;<b>([bc])\1</b>&#x201D; matches &#x201C;<b>bb</b>&#x201D; or
  &#x201C;<b>cc</b>&#x201D; but not &#x201C;<b>bc</b>&#x201D;. The subexpression
  must entirely precede the back reference in the RE. Subexpressions are
  numbered in the order of their leading parentheses. Non-capturing parentheses
  do not define subexpressions.
<p class="Pp">There is an inherent historical ambiguity between octal
    character-entry escapes and back references, which is resolved by
    heuristics, as hinted at above. A leading zero always indicates an octal
    escape. A single non-zero digit, not followed by another digit, is always
    taken as a back reference. A multi-digit sequence not starting with a zero
    is taken as a back reference if it comes after a suitable subexpression
    (i.e. the number is in the legal range for a back reference), and otherwise
    is taken as octal.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="METASYNTAX"><a class="permalink" href="#METASYNTAX">METASYNTAX</a></h1>
In addition to the main syntax described above, there are some special forms and
  miscellaneous syntactic facilities available.
<p class="Pp">Normally the flavor of RE being used is specified by
    application-dependent means. However, this can be overridden by a
    <i>director</i>. If an RE of any flavor begins with
    &#x201C;<b>***:</b>&#x201D;, the rest of the RE is an ARE. If an RE of any
    flavor begins with &#x201C;<b>***=</b>&#x201D;, the rest of the RE is taken
    to be a literal string, with all characters considered ordinary
  characters.</p>
<p class="Pp">An ARE may begin with <i>embedded options</i>: a sequence
    <b>(?</b> <i>xyz</i><b>)</b> (where <i>xyz</i> is one or more alphabetic
    characters) specifies options affecting the rest of the RE. These
    supplement, and can override, any options specified by the application. The
    available option letters are:</p>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>b</b></dt>
  <dd>rest of RE is a BRE</dd>
  <dt><b>c</b></dt>
  <dd>case-sensitive matching (usual default)</dd>
  <dt><b>e</b></dt>
  <dd>rest of RE is an ERE</dd>
  <dt><b>i</b></dt>
  <dd>case-insensitive matching (see <b>MATCHING</b>, below)</dd>
  <dt><b>m</b></dt>
  <dd>historical synonym for <b>n</b></dd>
  <dt><b>n</b></dt>
  <dd>newline-sensitive matching (see <b>MATCHING</b>, below)</dd>
  <dt><b>p</b></dt>
  <dd>partial newline-sensitive matching (see <b>MATCHING</b>, below)</dd>
  <dt><b>q</b></dt>
  <dd>rest of RE is a literal (&#x201C;quoted&#x201D;) string, all ordinary
      characters</dd>
  <dt><b>s</b></dt>
  <dd>non-newline-sensitive matching (usual default)</dd>
  <dt><b>t</b></dt>
  <dd>tight syntax (usual default; see below)</dd>
  <dt><b>w</b></dt>
  <dd>inverse partial newline-sensitive (&#x201C;weird&#x201D;) matching (see
      <b>MATCHING</b>, below)</dd>
  <dt><b>x</b></dt>
  <dd>expanded syntax (see below)</dd>
</dl>
</div>
<p class="Pp">Embedded options take effect at the <b>)</b> terminating the
    sequence. They are available only at the start of an ARE, and may not be
    used later within it.</p>
<p class="Pp">In addition to the usual (<i>tight</i>) RE syntax, in which all
    characters are significant, there is an <i>expanded</i> syntax, available in
    all flavors of RE with the <b>-expanded</b> switch, or in AREs with the
    embedded x option. In the expanded syntax, white-space characters are
    ignored and all characters between a <b>#</b> and the following newline (or
    the end of the RE) are ignored, permitting paragraphing and commenting a
    complex RE. There are three exceptions to that basic rule:</p>
<ul class="Bl-bullet">
  <li>a white-space character or &#x201C;<b>#</b>&#x201D; preceded by
      &#x201C;<b>\</b>&#x201D; is retained</li>
  <li>white space or &#x201C;<b>#</b>&#x201D; within a bracket expression is
      retained</li>
  <li>white space and comments are illegal within multi-character symbols like
      the ARE &#x201C;<b>(?:</b>&#x201D; or the BRE
    &#x201C;<b>\(</b>&#x201D;</li>
</ul>
<p class="Pp">Expanded-syntax white-space characters are blank, tab, newline,
    and any character that belongs to the <i>space</i> character class.</p>
<p class="Pp">Finally, in an ARE, outside bracket expressions, the sequence
    &#x201C;<b>(?#</b><i>ttt</i><b>)</b>&#x201D; (where <i>ttt</i> is any text
    not containing a &#x201C;<b>)</b>&#x201D;) is a comment, completely ignored.
    Again, this is not allowed between the characters of multi-character symbols
    like &#x201C;<b>(?:</b>&#x201D;. Such comments are more a historical
    artifact than a useful facility, and their use is deprecated; use the
    expanded syntax instead.</p>
<p class="Pp"><i>None</i> of these metasyntax extensions is available if the
    application (or an initial &#x201C;<b>***=</b>&#x201D; director) has
    specified that the user's input be treated as a literal string rather than
    as an RE.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="MATCHING"><a class="permalink" href="#MATCHING">MATCHING</a></h1>
In the event that an RE could match more than one substring of a given string,
  the RE matches the one starting earliest in the string. If the RE could match
  more than one substring starting at that point, its choice is determined by
  its <i>preference</i>: either the longest substring, or the shortest.
<p class="Pp">Most atoms, and all constraints, have no preference. A
    parenthesized RE has the same preference (possibly none) as the RE. A
    quantified atom with quantifier <b>{</b><i>m</i><b>}</b> or
    <b>{</b><i>m</i><b>}?</b> has the same preference (possibly none) as the
    atom itself. A quantified atom with other normal quantifiers (including
    <b>{</b> <i>m</i><b>,</b><i>n</i><b>}</b> with <i>m</i> equal to <i>n</i>)
    prefers longest match. A quantified atom with other non-greedy quantifiers
    (including <b>{</b><i>m</i><b>,</b><i>n</i><b>}?</b> with <i>m</i> equal to
    <i>n</i>) prefers shortest match. A branch has the same preference as the
    first quantified atom in it which has a preference. An RE consisting of two
    or more branches connected by the <b>|</b> operator prefers longest
  match.</p>
<p class="Pp">Subject to the constraints imposed by the rules for matching the
    whole RE, subexpressions also match the longest or shortest possible
    substrings, based on their preferences, with subexpressions starting earlier
    in the RE taking priority over ones starting later. Note that outer
    subexpressions thus take priority over their component subexpressions.</p>
<p class="Pp">Note that the quantifiers <b>{1,1}</b> and <b>{1,1}?</b> can be
    used to force longest and shortest preference, respectively, on a
    subexpression or a whole RE.</p>
<p class="Pp">Match lengths are measured in characters, not collating elements.
    An empty string is considered longer than no match at all. For example,
    &#x201C;<b>bb*</b>&#x201D; matches the three middle characters of
    &#x201C;<b>abbbc</b>&#x201D;,
    &#x201C;<b>(week|wee)(night|knights)</b>&#x201D; matches all ten characters
    of &#x201C;<b>weeknights</b>&#x201D;, when &#x201C;<b>(.*).*</b>&#x201D; is
    matched against &#x201C;<b>abc</b>&#x201D; the parenthesized subexpression
    matches all three characters, and when &#x201C;<b>(a*)*</b>&#x201D; is
    matched against &#x201C;<b>bc</b>&#x201D; both the whole RE and the
    parenthesized subexpression match an empty string.</p>
<p class="Pp">If case-independent matching is specified, the effect is much as
    if all case distinctions had vanished from the alphabet. When an alphabetic
    that exists in multiple cases appears as an ordinary character outside a
    bracket expression, it is effectively transformed into a bracket expression
    containing both cases, so that <b>x</b> becomes &#x201C;<b>[xX]</b>&#x201D;.
    When it appears inside a bracket expression, all case counterparts of it are
    added to the bracket expression, so that &#x201C;<b>[x]</b>&#x201D; becomes
    &#x201C;<b>[xX]</b>&#x201D; and &#x201C;<b>[^x]</b>&#x201D; becomes
    &#x201C;<b>[^xX]</b>&#x201D;.</p>
<p class="Pp">If newline-sensitive matching is specified, <b>.</b> and bracket
    expressions using <b>^</b> will never match the newline character (so that
    matches will never cross newlines unless the RE explicitly arranges it) and
    <b>^</b> and <b>$</b> will match the empty string after and before a newline
    respectively, in addition to matching at beginning and end of string
    respectively. ARE <b>\A</b> and <b>\Z</b> continue to match beginning or end
    of string <i>only</i>.</p>
<p class="Pp">If partial newline-sensitive matching is specified, this affects
    <b>.</b> and bracket expressions as with newline-sensitive matching, but not
    <b>^</b> and <b>$</b>.</p>
<p class="Pp">If inverse partial newline-sensitive matching is specified, this
    affects <b>^</b> and <b>$</b> as with newline-sensitive matching, but not
    <b>.</b> and bracket expressions. This is not very useful but is provided
    for symmetry.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="LIMITS_AND_COMPATIBILITY"><a class="permalink" href="#LIMITS_AND_COMPATIBILITY">LIMITS
  AND COMPATIBILITY</a></h1>
No particular limit is imposed on the length of REs. Programs intended to be
  highly portable should not employ REs longer than 256 bytes, as a
  POSIX-compliant implementation can refuse to accept such REs.
<p class="Pp">The only feature of AREs that is actually incompatible with POSIX
    EREs is that <b>\</b> does not lose its special significance inside bracket
    expressions. All other ARE features use syntax which is illegal or has
    undefined or unspecified effects in POSIX EREs; the <b>***</b> syntax of
    directors likewise is outside the POSIX syntax for both BREs and EREs.</p>
<p class="Pp">Many of the ARE extensions are borrowed from Perl, but some have
    been changed to clean them up, and a few Perl extensions are not present.
    Incompatibilities of note include &#x201C;<b>\b</b>&#x201D;,
    &#x201C;<b>\B</b>&#x201D;, the lack of special treatment for a trailing
    newline, the addition of complemented bracket expressions to the things
    affected by newline-sensitive matching, the restrictions on parentheses and
    back references in lookahead constraints, and the longest/shortest-match
    (rather than first-match) matching semantics.</p>
<p class="Pp">The matching rules for REs containing both normal and non-greedy
    quantifiers have changed since early beta-test versions of this package.
    (The new rules are much simpler and cleaner, but do not work as hard at
    guessing the user's real intentions.)</p>
<p class="Pp">Henry Spencer's original 1986 <i>regexp</i> package, still in
    widespread use (e.g., in pre-8.1 releases of Tcl), implemented an early
    version of today's EREs. There are four incompatibilities between
    <i>regexp</i>'s near-EREs (&#x201C;RREs&#x201D; for short) and AREs. In
    roughly increasing order of significance:</p>
<ul class="Bl-bullet">
  <li>In AREs, <b>\</b> followed by an alphanumeric character is either an
      escape or an error, while in RREs, it was just another way of writing the
      alphanumeric. This should not be a problem because there was no reason to
      write such a sequence in RREs.</li>
  <li><b>{</b> followed by a digit in an ARE is the beginning of a bound, while
      in RREs, <b>{</b> was always an ordinary character. Such sequences should
      be rare, and will often result in an error because following characters
      will not look like a valid bound.</li>
  <li>In AREs, <b>\</b> remains a special character within
      &#x201C;<b>[]</b>&#x201D;, so a literal <b>\</b> within <b>[]</b> must be
      written &#x201C;<b>\\</b>&#x201D;. <b>\\</b> also gives a literal <b>\</b>
      within <b>[]</b> in RREs, but only truly paranoid programmers routinely
      doubled the backslash.</li>
  <li>AREs report the longest/shortest match for the RE, rather than the first
      found in a specified search order. This may affect some RREs which were
      written in the expectation that the first match would be reported. (The
      careful crafting of RREs to optimize the search order for fast matching is
      obsolete (AREs examine all possible matches in parallel, and their
      performance is largely insensitive to their complexity) but cases where
      the search order was exploited to deliberately find a match which was
      <i>not</i> the longest/shortest will need rewriting.)</li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="BASIC_REGULAR_EXPRESSIONS"><a class="permalink" href="#BASIC_REGULAR_EXPRESSIONS">BASIC
  REGULAR EXPRESSIONS</a></h1>
BREs differ from EREs in several respects. &#x201C;<b>|</b>&#x201D;,
  &#x201C;<b>+</b>&#x201D;, and <b>?</b> are ordinary characters and there is no
  equivalent for their functionality. The delimiters for bounds are <b>\{</b>
  and &#x201C;<b>\}</b>&#x201D;, with <b>{</b> and <b>}</b> by themselves
  ordinary characters. The parentheses for nested subexpressions are <b>\(</b>
  and &#x201C;<b>\)</b>&#x201D;, with <b>(</b> and <b>)</b> by themselves
  ordinary characters. <b>^</b> is an ordinary character except at the beginning
  of the RE or the beginning of a parenthesized subexpression, <b>$</b> is an
  ordinary character except at the end of the RE or the end of a parenthesized
  subexpression, and <b>*</b> is an ordinary character if it appears at the
  beginning of the RE or the beginning of a parenthesized subexpression (after a
  possible leading &#x201C;<b>^</b>&#x201D;). Finally, single-digit back
  references are available, and <b>\&lt;</b> and <b>\&gt;</b> are synonyms for
  &#x201C;<b>[[:&lt;:]]</b>&#x201D; and &#x201C;<b>[[:&gt;:]]</b>&#x201D;
  respectively; no other escapes are available.
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
RegExp(3), regexp(n), regsub(n), lsearch(n), switch(n), text(n)
</section>
<section class="Sh">
<h1 class="Sh" id="KEYWORDS"><a class="permalink" href="#KEYWORDS">KEYWORDS</a></h1>
match, regular expression, string
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">8.1</td>
    <td class="foot-os">Tcl</td>
  </tr>
</table>
</body>
</html>
