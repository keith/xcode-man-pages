<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    .Nd, .Bf, .Op { display: inline; }
    .Pa, .Ad { font-style: italic; }
    .Ms { font-weight: bold; }
    .Bl-diag > dt { font-weight: bold; }
    code.Nm, .Fl, .Cm, .Ic, code.In, .Fd, .Fn, .Cd { font-weight: bold;
      font-family: inherit; }
  </style>
  <title>DBIx::Class::Storage::DBI::Replicated::Balancer(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">DBIx::Class::Storage::DBI::Replicated::Balancer(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">DBIx::Class::Storage::DBI::Replicated::Balancer(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">DBIx::Class::Storage::DBI::Replicated::Balancer - A Software Load
    Balancer</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<p class="Pp">This role is used internally by
    DBIx::Class::Storage::DBI::Replicated.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">Given a pool (DBIx::Class::Storage::DBI::Replicated::Pool) of
    replicated database's (DBIx::Class::Storage::DBI::Replicated::Replicant),
    defines a method by which query load can be spread out across each replicant
    in the pool.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="ATTRIBUTES"><a class="permalink" href="#ATTRIBUTES">ATTRIBUTES</a></h1>
<p class="Pp">This class defines the following attributes.</p>
<section class="Ss">
<h2 class="Ss" id="auto_validate_every_($seconds)"><a class="permalink" href="#auto_validate_every_($seconds)">auto_validate_every
  ($seconds)</a></h2>
<p class="Pp">If auto_validate has some sort of value, run
    &quot;validate_replicants&quot; in
    DBIx::Class::Storage::DBI::Replicated::Pool every
    <span class="Li">$seconds</span>. Be careful with this, because if you set
    it to 0 you will end up validating every query.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="master"><a class="permalink" href="#master">master</a></h2>
<p class="Pp">The DBIx::Class::Storage::DBI object that is the master database
    all the replicants are trying to follow. The balancer needs to know it since
    it's the ultimate fallback.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="pool"><a class="permalink" href="#pool">pool</a></h2>
<p class="Pp">The DBIx::Class::Storage::DBI::Replicated::Pool object that we are
    trying to balance.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="current_replicant"><a class="permalink" href="#current_replicant">current_replicant</a></h2>
<p class="Pp">Replicant storages (slaves) handle all read only traffic. The
    assumption is that your database will become readbound well before it
    becomes write bound and that being able to spread your read only traffic
    around to multiple databases is going to help you to scale traffic.</p>
<p class="Pp">This attribute returns the next slave to handle a read request.
    Your &quot;pool&quot; attribute has methods to help you shuffle through all
    the available replicants via its balancer object.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="METHODS"><a class="permalink" href="#METHODS">METHODS</a></h1>
<p class="Pp">This class defines the following methods.</p>
<section class="Ss">
<h2 class="Ss" id="_build_current_replicant"><a class="permalink" href="#_build_current_replicant">_build_current_replicant</a></h2>
<p class="Pp">Lazy builder for the &quot;current_replicant_storage&quot;
    attribute.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="next_storage"><a class="permalink" href="#next_storage">next_storage</a></h2>
<p class="Pp">This method should be defined in the class which consumes this
    role.</p>
<p class="Pp">Given a pool object, return the next replicant that will serve
    queries. The default behavior is to grab the first replicant it finds but
    you can write your own subclasses of
    DBIx::Class::Storage::DBI::Replicated::Balancer to support other balance
    systems.</p>
<p class="Pp">This returns from the pool of active replicants. If there are no
    active replicants, then you should have it return the master as an ultimate
    fallback.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="around:_next_storage"><a class="permalink" href="#around:_next_storage">around:
  next_storage</a></h2>
<p class="Pp">Advice on next storage to add the autovalidation. We have this
    broken out so that it's easier to break out the auto validation into a
  role.</p>
<p class="Pp">This also returns the master in the case that none of the
    replicants are active or just forgot to create them :)</p>
</section>
<section class="Ss">
<h2 class="Ss" id="increment_storage"><a class="permalink" href="#increment_storage">increment_storage</a></h2>
<p class="Pp">Rolls the Storage to whatever is next in the queue, as defined by
    the Balancer.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="around:_select"><a class="permalink" href="#around:_select">around:
  select</a></h2>
<p class="Pp">Advice on the select attribute. Each time we use a replicant we
    need to change it via the storage pool algorithm. That way we are spreading
    the load evenly (hopefully) across existing capacity.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="around:_select_single"><a class="permalink" href="#around:_select_single">around:
  select_single</a></h2>
<p class="Pp">Advice on the select_single attribute. Each time we use a
    replicant we need to change it via the storage pool algorithm. That way we
    are spreading the load evenly (hopefully) across existing capacity.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="before:_columns_info_for"><a class="permalink" href="#before:_columns_info_for">before:
  columns_info_for</a></h2>
<p class="Pp">Advice on the current_replicant_storage attribute. Each time we
    use a replicant we need to change it via the storage pool algorithm. That
    way we are spreading the load evenly (hopefully) across existing
  capacity.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_get_forced_pool_($name)"><a class="permalink" href="#_get_forced_pool_($name)">_get_forced_pool
  ($name)</a></h2>
<p class="Pp">Given an identifier, find the most correct storage object to
    handle the query.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">John Napiorkowski &lt;jjnapiork@cpan.org&gt;</p>
</section>
<section class="Sh">
<h1 class="Sh" id="LICENSE"><a class="permalink" href="#LICENSE">LICENSE</a></h1>
<p class="Pp">You may distribute this code under the same terms as Perl
  itself.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2014-01-05</td>
    <td class="foot-os">perl v5.18.4</td>
  </tr>
</table>
</body>
</html>
