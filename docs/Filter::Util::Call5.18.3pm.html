<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    .Nd, .Bf, .Op { display: inline; }
    .Pa, .Ad { font-style: italic; }
    .Ms { font-weight: bold; }
    .Bl-diag > dt { font-weight: bold; }
    code.Nm, .Fl, .Cm, .Ic, code.In, .Fd, .Fn, .Cd { font-weight: bold;
      font-family: inherit; }
  </style>
  <title>Filter::Util::Call(3pm)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Filter::Util::Call(3pm)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">Filter::Util::Call(3pm)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Filter::Util::Call - Perl Source Filter Utility Module</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>    use Filter::Util::Call ;
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">This module provides you with the framework to write <i>Source
    Filters</i> in Perl.</p>
<p class="Pp">An alternate interface to Filter::Util::Call is now available. See
    Filter::Simple for more details.</p>
<p class="Pp">A <i>Perl Source Filter</i> is implemented as a Perl module. The
    structure of the module can take one of two broadly similar formats. To
    distinguish between them, the first will be referred to as <i>method</i>
    <i>filter</i> and the second as <i>closure filter</i>.</p>
<p class="Pp">Here is a skeleton for the <i>method filter</i>:</p>
<p class="Pp"></p>
<pre>    package MyFilter ;
    use Filter::Util::Call ;
    sub import
    {
        my($type, @arguments) = @_ ;
        filter_add([]) ;
    }
    sub filter
    {
        my($self) = @_ ;
        my($status) ;
        $status = filter_read() ;
        $status ;
    }
    1 ;
</pre>
<p class="Pp">and this is the equivalent skeleton for the <i>closure
  filter</i>:</p>
<p class="Pp"></p>
<pre>    package MyFilter ;
    use Filter::Util::Call ;
    sub import
    {
        my($type, @arguments) = @_ ;
        filter_add(
            sub 
            {
                my($status) ;
                $status = filter_read() ;
                $status ;
            } )
    }
    1 ;
</pre>
<p class="Pp">To make use of either of the two filter modules above, place the
    line below in a Perl source file.</p>
<p class="Pp"></p>
<pre>    use MyFilter;
</pre>
<p class="Pp">In fact, the skeleton modules shown above are fully functional
    <i>Source</i> <i>Filters</i>, albeit fairly useless ones. All they does is
    filter the source stream without modifying it at all.</p>
<p class="Pp">As you can see both modules have a broadly similar structure. They
    both make use of the <span class="Li">&quot;Filter::Util::Call&quot;</span>
    module and both have an <span class="Li">&quot;import&quot;</span> method.
    The difference between them is that the <i>method filter</i> requires a
    <i>filter</i> method, whereas the <i>closure filter</i> gets the equivalent
    of a <i>filter</i> method with the anonymous sub passed to
    <i>filter_add</i>.</p>
<p class="Pp">To make proper use of the <i>closure filter</i> shown above you
    need to have a good understanding of the concept of a <i>closure</i>. See
    perlref for more details on the mechanics of <i>closures</i>.</p>
<section class="Ss">
<h2 class="Ss"><b>use Filter::Util::Call</b></h2>
<p class="Pp">The following functions are exported by
    <span class="Li">&quot;Filter::Util::Call&quot;</span>:</p>
<p class="Pp"></p>
<pre>    filter_add()
    filter_read()
    filter_read_exact()
    filter_del()
</pre>
</section>
<section class="Ss">
<h2 class="Ss"><b></b><b><i>import()</i></b><b></b></h2>
<p class="Pp">The <span class="Li">&quot;import&quot;</span> method is used to
    create an instance of the filter. It is called indirectly by Perl when it
    encounters the <span class="Li">&quot;use MyFilter&quot;</span> line in a
    source file (See &quot;import&quot; in perlfunc for more details on
    <span class="Li">&quot;import&quot;</span>).</p>
<p class="Pp">It will always have at least one parameter automatically passed by
    Perl - this corresponds to the name of the package. In the example above it
    will be <span class="Li">&quot;MyFilter&quot;</span>.</p>
<p class="Pp">Apart from the first parameter, import can accept an optional list
    of parameters. These can be used to pass parameters to the filter. For
    example:</p>
<p class="Pp"></p>
<pre>    use MyFilter qw(a b c) ;
</pre>
<p class="Pp">will result in the <span class="Li">@_</span> array having the
    following values:</p>
<p class="Pp"></p>
<pre>    @_ [0] =&gt; &quot;MyFilter&quot;
    @_ [1] =&gt; &quot;a&quot;
    @_ [2] =&gt; &quot;b&quot;
    @_ [3] =&gt; &quot;c&quot;
</pre>
<p class="Pp">Before terminating, the <span class="Li">&quot;import&quot;</span>
    function must explicitly install the filter by calling
    <span class="Li">&quot;filter_add&quot;</span>.</p>
<p class="Pp"><b></b><b><i>filter_add()</i></b><b></b></p>
<p class="Pp">The function, <span class="Li">&quot;filter_add&quot;</span>,
    actually installs the filter. It takes one parameter which should be a
    reference. The kind of reference used will dictate which of the two filter
    types will be used.</p>
<p class="Pp">If a CODE reference is used then a <i>closure filter</i> will be
    assumed.</p>
<p class="Pp">If a CODE reference is not used, a <i>method filter</i> will be
    assumed. In a <i>method filter</i>, the reference can be used to store
    context information. The reference will be <i>blessed</i> into the package
    by <span class="Li">&quot;filter_add&quot;</span>.</p>
<p class="Pp">See the filters at the end of this documents for examples of using
    context information using both <i>method filters</i> and <i>closure</i>
    <i>filters</i>.</p>
</section>
<section class="Ss">
<h2 class="Ss"><b></b><b><i>filter()</i></b><b> and anonymous sub</b></h2>
<p class="Pp">Both the <span class="Li">&quot;filter&quot;</span> method used
    with a <i>method filter</i> and the anonymous sub used with a <i>closure
    filter</i> is where the main processing for the filter is done.</p>
<p class="Pp">The big difference between the two types of filter is that the
    <i>method</i> <i>filter</i> uses the object passed to the method to store
    any context data, whereas the <i>closure filter</i> uses the lexical
    variables that are maintained by the closure.</p>
<p class="Pp">Note that the single parameter passed to the <i>method filter</i>,
    <span class="Li">$self</span>, is the same reference that was passed to
    <span class="Li">&quot;filter_add&quot;</span> blessed into the filter's
    package. See the example filters later on for details of using
    <span class="Li">$self</span>.</p>
<p class="Pp">Here is a list of the common features of the anonymous sub and the
    <span class="Li">&quot;filter()&quot;</span> method.</p>
<dl class="Bl-tag">
  <dt><b></b><b>$_</b><b></b></dt>
  <dd>Although <span class="Li">$_</span> doesn't actually appear explicitly in
      the sample filters above, it is implicitly used in a number of places.
    <p class="Pp">Firstly, when either
        <span class="Li">&quot;filter&quot;</span> or the anonymous sub are
        called, a local copy of <span class="Li">$_</span> will automatically be
        created. It will always contain the empty string at this point.</p>
    <p class="Pp">Next, both <span class="Li">&quot;filter_read&quot;</span> and
        <span class="Li">&quot;filter_read_exact&quot;</span> will append any
        source data that is read to the end of <span class="Li">$_</span>.</p>
    <p class="Pp">Finally, when <span class="Li">&quot;filter&quot;</span> or
        the anonymous sub are finished processing, they are expected to return
        the filtered source using <span class="Li">$_</span>.</p>
    <p class="Pp">This implicit use of <span class="Li">$_</span> greatly
        simplifies the filter.</p>
  </dd>
  <dt><b></b><b>$status</b><b></b></dt>
  <dd>The status value that is returned by the user's
      <span class="Li">&quot;filter&quot;</span> method or anonymous sub and the
      <span class="Li">&quot;filter_read&quot;</span> and
      <span class="Li">&quot;read_exact&quot;</span> functions take the same set
      of values, namely:
    <p class="Pp"></p>
    <pre>    &lt; 0  Error
    = 0  EOF
    &gt; 0  OK
    </pre>
  </dd>
  <dt id="filter_read"><a class="permalink" href="#filter_read"><b>filter_read</b>
    and <b>filter_read_exact</b></a></dt>
  <dd>These functions are used by the filter to obtain either a line or block
      from the next filter in the chain or the actual source file if there
      aren't any other filters.
    <p class="Pp">The function <span class="Li">&quot;filter_read&quot;</span>
        takes two forms:</p>
    <p class="Pp"></p>
    <pre>    $status = filter_read() ;
    $status = filter_read($size) ;
    </pre>
    <p class="Pp">The first form is used to request a <i>line</i>, the second
        requests a <i>block</i>.</p>
    <p class="Pp">In line mode, <span class="Li">&quot;filter_read&quot;</span>
        will append the next source line to the end of the
        <span class="Li">$_</span> scalar.</p>
    <p class="Pp">In block mode, <span class="Li">&quot;filter_read&quot;</span>
        will append a block of data which is &lt;= <span class="Li">$size</span>
        to the end of the <span class="Li">$_</span> scalar. It is important to
        emphasise the that <span class="Li">&quot;filter_read&quot;</span> will
        not necessarily read a block which is <i>precisely</i>
        <span class="Li">$size</span> bytes.</p>
    <p class="Pp">If you need to be able to read a block which has an exact
        size, you can use the function
        <span class="Li">&quot;filter_read_exact&quot;</span>. It works
        identically to <span class="Li">&quot;filter_read&quot;</span> in block
        mode, except it will try to read a block which is exactly
        <span class="Li">$size</span> bytes in length. The only circumstances
        when it will not return a block which is <span class="Li">$size</span>
        bytes long is on EOF or error.</p>
    <p class="Pp">It is <i>very</i> important to check the value of
        <span class="Li">$status</span> after <i>every</i> call to
        <span class="Li">&quot;filter_read&quot;</span> or
        <span class="Li">&quot;filter_read_exact&quot;</span>.</p>
  </dd>
  <dt id="filter_del"><a class="permalink" href="#filter_del"><b>filter_del</b></a></dt>
  <dd>The function, <span class="Li">&quot;filter_del&quot;</span>, is used to
      disable the current filter. It does not affect the running of the filter.
      All it does is tell Perl not to call filter any more.
    <p class="Pp">See &quot;Example 4: Using filter_del&quot; for details.</p>
  </dd>
</dl>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="EXAMPLES"><a class="permalink" href="#EXAMPLES">EXAMPLES</a></h1>
<p class="Pp">Here are a few examples which illustrate the key concepts - as
    such most of them are of little practical use.</p>
<p class="Pp">The <span class="Li">&quot;examples&quot;</span> sub-directory has
    copies of all these filters implemented both as <i>method filters</i> and as
    <i>closure filters</i>.</p>
<section class="Ss">
<h2 class="Ss" id="Example_1:_A_simple_filter."><a class="permalink" href="#Example_1:_A_simple_filter.">Example
  1: A simple filter.</a></h2>
<p class="Pp">Below is a <i>method filter</i> which is hard-wired to replace all
    occurrences of the string <span class="Li">&quot;Joe&quot;</span> to
    <span class="Li">&quot;Jim&quot;</span>. Not particularly Useful, but it is
    the first example and I wanted to keep it simple.</p>
<p class="Pp"></p>
<pre>    package Joe2Jim ;
    use Filter::Util::Call ;
    sub import
    {
        my($type) = @_ ;
        filter_add(bless []) ;
    }
    sub filter
    {
        my($self) = @_ ;
        my($status) ;
        s/Joe/Jim/g
            if ($status = filter_read()) &gt; 0 ;
        $status ;
    }
    1 ;
</pre>
<p class="Pp">Here is an example of using the filter:</p>
<p class="Pp"></p>
<pre>    use Joe2Jim ;
    print &quot;Where is Joe?\n&quot; ;
</pre>
<p class="Pp">And this is what the script above will print:</p>
<p class="Pp"></p>
<pre>    Where is Jim?
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Example_2:_Using_the_context"><a class="permalink" href="#Example_2:_Using_the_context">Example
  2: Using the context</a></h2>
<p class="Pp">The previous example was not particularly useful. To make it more
    general purpose we will make use of the context data and allow any arbitrary
    <i>from</i> and <i>to</i> strings to be used. This time we will use a
    <i>closure filter</i>. To reflect its enhanced role, the filter is called
    <span class="Li">&quot;Subst&quot;</span>.</p>
<p class="Pp"></p>
<pre>    package Subst ;
    use Filter::Util::Call ;
    use Carp ;
    sub import
    {
        croak(&quot;usage: use Subst qw(from to)&quot;)
            unless @_ == 3 ;
        my ($self, $from, $to) = @_ ;
        filter_add(
            sub 
            {
                my ($status) ;
                s/$from/$to/
                    if ($status = filter_read()) &gt; 0 ;
                $status ;
            })
    }
    1 ;
</pre>
<p class="Pp">and is used like this:</p>
<p class="Pp"></p>
<pre>    use Subst qw(Joe Jim) ;
    print &quot;Where is Joe?\n&quot; ;
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Example_3:_Using_the_context_within_the_filter"><a class="permalink" href="#Example_3:_Using_the_context_within_the_filter">Example
  3: Using the context within the filter</a></h2>
<p class="Pp">Here is a filter which a variation of the
    <span class="Li">&quot;Joe2Jim&quot;</span> filter. As well as substituting
    all occurrences of <span class="Li">&quot;Joe&quot;</span> to
    <span class="Li">&quot;Jim&quot;</span> it keeps a count of the number of
    substitutions made in the context object.</p>
<p class="Pp">Once EOF is detected (<span class="Li">$status</span> is zero) the
    filter will insert an extra line into the source stream. When this extra
    line is executed it will print a count of the number of substitutions
    actually made. Note that <span class="Li">$status</span> is set to
    <span class="Li">1</span> in this case.</p>
<p class="Pp"></p>
<pre>    package Count ;
    use Filter::Util::Call ;
    sub filter
    {
        my ($self) = @_ ;
        my ($status) ;
        if (($status = filter_read()) &gt; 0 ) {
            s/Joe/Jim/g ;
            ++ $$self ;
        }
        elsif ($$self &gt;= 0) { # EOF
            $_ = &quot;print q[Made ${$self} substitutions\n]&quot; ;
            $status = 1 ;
            $$self = -1 ;
        }
        $status ;
    }
    sub import
    {
        my ($self) = @_ ;
        my ($count) = 0 ;
        filter_add(\$count) ;
    }
    1 ;
</pre>
<p class="Pp">Here is a script which uses it:</p>
<p class="Pp"></p>
<pre>    use Count ;
    print &quot;Hello Joe\n&quot; ;
    print &quot;Where is Joe\n&quot; ;
</pre>
<p class="Pp">Outputs:</p>
<p class="Pp"></p>
<pre>    Hello Jim
    Where is Jim
    Made 2 substitutions
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Example_4:_Using_filter_del"><a class="permalink" href="#Example_4:_Using_filter_del">Example
  4: Using filter_del</a></h2>
<p class="Pp">Another variation on a theme. This time we will modify the
    <span class="Li">&quot;Subst&quot;</span> filter to allow a starting and
    stopping pattern to be specified as well as the <i>from</i> and <i>to</i>
    patterns. If you know the <i>vi</i> editor, it is the equivalent of this
    command:</p>
<p class="Pp"></p>
<pre>    :/start/,/stop/s/from/to/
</pre>
<p class="Pp">When used as a filter we want to invoke it like this:</p>
<p class="Pp"></p>
<pre>    use NewSubst qw(start stop from to) ;
</pre>
<p class="Pp">Here is the module.</p>
<p class="Pp"></p>
<pre>    package NewSubst ;
    use Filter::Util::Call ;
    use Carp ;
    sub import
    {
        my ($self, $start, $stop, $from, $to) = @_ ;
        my ($found) = 0 ;
        croak(&quot;usage: use Subst qw(start stop from to)&quot;)
            unless @_ == 5 ;
        filter_add( 
            sub 
            {
                my ($status) ;
                if (($status = filter_read()) &gt; 0) {
                    $found = 1
                        if $found == 0 and /$start/ ;
                    if ($found) {
                        s/$from/$to/ ;
                        filter_del() if /$stop/ ;
                    }
                }
                $status ;
            } )
    }
    1 ;
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="Filter::Simple"><a class="permalink" href="#Filter::Simple">Filter::Simple</a></h1>
<p class="Pp">If you intend using the Filter::Call functionality, I would
    strongly recommend that you check out Damian Conway's excellent
    Filter::Simple module. Damian's module provides a much cleaner interface
    than Filter::Util::Call. Although it doesn't allow the fine control that
    Filter::Util::Call does, it should be adequate for the majority of
    applications. It's available at</p>
<p class="Pp"></p>
<pre>   http://search.cpan.org/dist/Filter-Simple/
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">Paul Marquess</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DATE"><a class="permalink" href="#DATE">DATE</a></h1>
<p class="Pp">26th January 1996</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2014-09-30</td>
    <td class="foot-os">perl v5.18.4</td>
  </tr>
</table>
</body>
</html>
