<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.10 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>lwptut(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">lwptut(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">lwptut(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
lwptut -- An LWP Tutorial
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
LWP (short for &quot;Library for WWW in Perl&quot;) is a very popular group of
  Perl modules for accessing data on the Web. Like most Perl
  module-distributions, each of LWP's component modules comes with documentation
  that is a complete reference to its interface. However, there are so many
  modules in LWP that it's hard to know where to start looking for information
  on how to do even the simplest most common things.
<p class="Pp">Really introducing you to using LWP would require a whole book --
    a book that just happens to exist, called <i>Perl &amp; LWP</i>. But this
    article should give you a taste of how you can go about some common tasks
    with LWP.</p>
<section class="Ss">
<h2 class="Ss" id="Getting_documents_with_LWP::Simple"><a class="permalink" href="#Getting_documents_with_LWP::Simple">Getting
  documents with LWP::Simple</a></h2>
If you just want to get what's at a particular URL, the simplest way to do it is
  LWP::Simple's functions.
<p class="Pp">In a Perl program, you can call its
    <span class="Li">&quot;get($url)&quot;</span> function. It will try getting
    that URL's content. If it works, then it'll return the content; but if
    there's some error, it'll return undef.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  my $url = 'http://www.npr.org/programs/fa/?todayDate=current';
    # Just an example: the URL for the most recent /Fresh Air/ show

  use LWP::Simple;
  my $content = get $url;
  die &quot;Couldn't get $url&quot; unless defined $content;

  # Then go do things with $content, like this:

  if($content =~ m/jazz/i) {
    print &quot;They're talking about jazz today on Fresh Air!\n&quot;;
  }
  else {
    print &quot;Fresh Air is apparently jazzless today.\n&quot;;
  }
</pre>
<p class="Pp">The handiest variant on <span class="Li">&quot;get&quot;</span> is
    <span class="Li">&quot;getprint&quot;</span>, which is useful in Perl
    one-liners. If it can get the page whose URL you provide, it sends it to
    STDOUT; otherwise it complains to STDERR.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  % perl -MLWP::Simple -e &quot;getprint 'http://www.cpan.org/RECENT'&quot;
</pre>
<p class="Pp">That is the URL of a plain text file that lists new files in CPAN
    in the past two weeks. You can easily make it part of a tidy little shell
    command, like this one that mails you the list of new
    <span class="Li">&quot;Acme::&quot;</span> modules:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  % perl -MLWP::Simple -e &quot;getprint 'http://www.cpan.org/RECENT'&quot;  \
     | grep &quot;/by-module/Acme&quot; | mail -s &quot;New Acme modules! Joy!&quot; $USER
</pre>
<p class="Pp">There are other useful functions in LWP::Simple, including one
    function for running a HEAD request on a URL (useful for checking links, or
    getting the last-revised time of a URL), and two functions for
    saving/mirroring a URL to a local file. See the LWP::Simple documentation
    for the full details, or chapter 2 of <i>Perl</i> <i>&amp; LWP</i> for more
    examples.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="The_Basics_of_the__s-1LWP_s0_Class_Model"><a class="permalink" href="#The_Basics_of_the__s-1LWP_s0_Class_Model">The
  Basics of the LWP Class Model</a></h2>
LWP::Simple's functions are handy for simple cases, but its functions don't
  support cookies or authorization, don't support setting header lines in the
  HTTP request, generally don't support reading header lines in the HTTP
  response (notably the full HTTP error message, in case of an error). To get at
  all those features, you'll have to use the full LWP class model.
<p class="Pp">While LWP consists of dozens of classes, the main two that you
    have to understand are LWP::UserAgent and HTTP::Response. LWP::UserAgent is
    a class for &quot;virtual browsers&quot; which you use for performing
    requests, and HTTP::Response is a class for the responses (or error
    messages) that you get back from those requests.</p>
<p class="Pp">The basic idiom is <span class="Li">&quot;$response =
    $browser-&gt;get($url)&quot;</span>, or more fully illustrated:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  # Early in your program:
  
  use LWP 5.64; # Loads all important LWP classes, and makes
                #  sure your version is reasonably recent.

  my $browser = LWP::UserAgent-&gt;new;
  
  ...
  
  # Then later, whenever you need to make a get request:
  my $url = 'http://www.npr.org/programs/fa/?todayDate=current';
  
  my $response = $browser-&gt;get( $url );
  die &quot;Can't get $url -- &quot;, $response-&gt;status_line
   unless $response-&gt;is_success;

  die &quot;Hey, I was expecting HTML, not &quot;, $response-&gt;content_type
   unless $response-&gt;content_type eq 'text/html';
     # or whatever content-type you're equipped to deal with

  # Otherwise, process the content somehow:
  
  if($response-&gt;decoded_content =~ m/jazz/i) {
    print &quot;They're talking about jazz today on Fresh Air!\n&quot;;
  }
  else {
    print &quot;Fresh Air is apparently jazzless today.\n&quot;;
  }
</pre>
<p class="Pp">There are two objects involved: <span class="Li">$browser</span>,
    which holds an object of class LWP::UserAgent, and then the
    <span class="Li">$response</span> object, which is of class HTTP::Response.
    You really need only one browser object per program; but every time you make
    a request, you get back a new HTTP::Response object, which will have some
    interesting attributes:</p>
<ul class="Bl-bullet">
  <li>A status code indicating success or failure (which you can test with
      <span class="Li">&quot;$response-&gt;is_success&quot;</span>).</li>
  <li>An HTTP status line that is hopefully informative if there's failure
      (which you can see with
      <span class="Li">&quot;$response-&gt;status_line&quot;</span>, returning
      something like &quot;404 Not Found&quot;).</li>
  <li>A MIME content-type like &quot;text/html&quot;, &quot;image/gif&quot;,
      &quot;application/xml&quot;, etc., which you can see with
      <span class="Li">&quot;$response-&gt;content_type&quot;</span></li>
  <li>The actual content of the response, in
      <span class="Li">&quot;$response-&gt;decoded_content&quot;</span>. If the
      response is HTML, that's where the HTML source will be; if it's a GIF,
      then <span class="Li">&quot;$response-&gt;decoded_content&quot;</span>
      will be the binary GIF data.</li>
  <li>And dozens of other convenient and more specific methods that are
      documented in the docs for HTTP::Response, and its superclasses
      HTTP::Message and HTTP::Headers.</li>
</ul>
</section>
<section class="Ss">
<h2 class="Ss" id="Adding_Other__s-1HTTP_s0_Request_Headers"><a class="permalink" href="#Adding_Other__s-1HTTP_s0_Request_Headers">Adding
  Other HTTP Request Headers</a></h2>
The most commonly used syntax for requests is <span class="Li">&quot;$response
  =</span> <span class="Li">$browser-&gt;get($url)&quot;</span>, but in truth,
  you can add extra HTTP header lines to the request by adding a list of
  key-value pairs after the URL, like so:
<p class="Pp"><span class="Li"></span></p>
<pre>
  $response = $browser-&gt;get( $url, $key1, $value1, $key2, $value2, ... );
</pre>
<p class="Pp">For example, here's how to send some commonly used headers, in
    case you're dealing with a site that would otherwise reject your
  request:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  my @ns_headers = (
   'User-Agent' =&gt; 'Mozilla/4.76 [en] (Win98; U)',
   'Accept' =&gt; 'image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, image/png, */*',
   'Accept-Charset' =&gt; 'iso-8859-1,*,utf-8',
   'Accept-Language' =&gt; 'en-US',
  );

  ...
  
  $response = $browser-&gt;get($url, @ns_headers);
</pre>
<p class="Pp">If you weren't reusing that array, you could just go ahead and do
    this:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  $response = $browser-&gt;get($url,
   'User-Agent' =&gt; 'Mozilla/4.76 [en] (Win98; U)',
   'Accept' =&gt; 'image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, image/png, */*',
   'Accept-Charset' =&gt; 'iso-8859-1,*,utf-8',
   'Accept-Language' =&gt; 'en-US',
  );
</pre>
<p class="Pp">If you were only ever changing the 'User-Agent' line, you could
    just change the <span class="Li">$browser</span> object's default line from
    &quot;libwww-perl/5.65&quot; (or the like) to whatever you like, using the
    LWP::UserAgent <span class="Li">&quot;agent&quot;</span> method:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
   $browser-&gt;agent('Mozilla/4.76 [en] (Win98; U)');
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Enabling_Cookies"><a class="permalink" href="#Enabling_Cookies">Enabling
  Cookies</a></h2>
A default LWP::UserAgent object acts like a browser with its cookies support
  turned off. There are various ways of turning it on, by setting its
  <span class="Li">&quot;cookie_jar&quot;</span> attribute. A &quot;cookie
  jar&quot; is an object representing a little database of all the HTTP cookies
  that a browser knows about. It can correspond to a file on disk or an
  in-memory object that starts out empty, and whose collection of cookies will
  disappear once the program is finished running.
<p class="Pp">To give a browser an in-memory empty cookie jar, you set its
    <span class="Li">&quot;cookie_jar&quot;</span> attribute like so:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  use HTTP::CookieJar::LWP;
  $browser-&gt;cookie_jar( HTTP::CookieJar::LWP-&gt;new );
</pre>
<p class="Pp">To save a cookie jar to disk, see &quot;dump_cookies&quot; in
    HTTP::CookieJar. To load cookies from disk into a jar, see
    &quot;load_cookies&quot; in HTTP::CookieJar.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Posting_Form_Data"><a class="permalink" href="#Posting_Form_Data">Posting
  Form Data</a></h2>
Many HTML forms send data to their server using an HTTP POST request, which you
  can send with this syntax:
<p class="Pp"><span class="Li"></span></p>
<pre>
 $response = $browser-&gt;post( $url,
   [
     formkey1 =&gt; value1, 
     formkey2 =&gt; value2, 
     ...
   ],
 );
</pre>
<p class="Pp">Or if you need to send HTTP headers:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
 $response = $browser-&gt;post( $url,
   [
     formkey1 =&gt; value1, 
     formkey2 =&gt; value2, 
     ...
   ],
   headerkey1 =&gt; value1, 
   headerkey2 =&gt; value2, 
 );
</pre>
<p class="Pp">For example, the following program makes a search request to
    AltaVista (by sending some form data via an HTTP POST request), and extracts
    from the HTML the report of the number of matches:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  use strict;
  use warnings;
  use LWP 5.64;
  my $browser = LWP::UserAgent-&gt;new;

  my $word = 'tarragon';

  my $url = 'http://search.yahoo.com/yhs/search';
  my $response = $browser-&gt;post( $url,
    [ 'q' =&gt; $word,  # the Altavista query string
      'fr' =&gt; 'altavista', 'pg' =&gt; 'q', 'avkw' =&gt; 'tgz', 'kl' =&gt; 'XX',
    ]
  );
  die &quot;$url error: &quot;, $response-&gt;status_line
   unless $response-&gt;is_success;
  die &quot;Weird content type at $url -- &quot;, $response-&gt;content_type
   unless $response-&gt;content_is_html;

  if( $response-&gt;decoded_content =~ m{([0-9,]+)(?:&lt;.*?&gt;)? results for} ) {
    # The substring will be like &quot;996,000&lt;/strong&gt; results for&quot;
    print &quot;$word: $1\n&quot;;
  }
  else {
    print &quot;Couldn't find the match-string in the response\n&quot;;
  }
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Sending__s-1GET_s0_Form_Data"><a class="permalink" href="#Sending__s-1GET_s0_Form_Data">Sending
  GET Form Data</a></h2>
Some HTML forms convey their form data not by sending the data in an HTTP POST
  request, but by making a normal GET request with the data stuck on the end of
  the URL. For example, if you went to
  <span class="Li">&quot;www.imdb.com&quot;</span> and ran a search on
  &quot;Blade Runner&quot;, the URL you'd see in your browser window would be:
<p class="Pp"><span class="Li"></span></p>
<pre>
  http://www.imdb.com/find?s=all&amp;q=Blade+Runner
</pre>
<p class="Pp">To run the same search with LWP, you'd use this idiom, which
    involves the URI class:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  use URI;
  my $url = URI-&gt;new( 'http://www.imdb.com/find' );
    # makes an object representing the URL

  $url-&gt;query_form(  # And here the form data pairs:
    'q' =&gt; 'Blade Runner',
    's' =&gt; 'all',
  );

  my $response = $browser-&gt;get($url);
</pre>
<p class="Pp">See chapter 5 of <i>Perl &amp; LWP</i> for a longer discussion of
    HTML forms and of form data, and chapters 6 through 9 for a longer
    discussion of extracting data from HTML.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Absolutizing_URLs"><a class="permalink" href="#Absolutizing_URLs">Absolutizing
  URLs</a></h2>
The URI class that we just mentioned above provides all sorts of methods for
  accessing and modifying parts of URLs (such as asking sort of URL it is with
  <span class="Li">&quot;$url-&gt;scheme&quot;</span>, and asking what host it
  refers to with <span class="Li">&quot;$url-&gt;host&quot;</span>, and so on,
  as described in the docs for the URI class. However, the methods of most
  immediate interest are the <span class="Li">&quot;query_form&quot;</span>
  method seen above, and now the <span class="Li">&quot;new_abs&quot;</span>
  method for taking a probably-relative URL string (like
  &quot;../foo.html&quot;) and getting back an absolute URL (like
  &quot;http://www.perl.com/stuff/foo.html&quot;), as shown here:
<p class="Pp"><span class="Li"></span></p>
<pre>
  use URI;
  $abs = URI-&gt;new_abs($maybe_relative, $base);
</pre>
<p class="Pp">For example, consider this program that matches URLs in the HTML
    list of new modules in CPAN:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  use strict;
  use warnings;
  use LWP;
  my $browser = LWP::UserAgent-&gt;new;
  
  my $url = 'http://www.cpan.org/RECENT.html';
  my $response = $browser-&gt;get($url);
  die &quot;Can't get $url -- &quot;, $response-&gt;status_line
   unless $response-&gt;is_success;
  
  my $html = $response-&gt;decoded_content;
  while( $html =~ m/&lt;A HREF=\&quot;(.*?)\&quot;/g ) {
    print &quot;$1\n&quot;;
  }
</pre>
<p class="Pp">When run, it emits output that starts out something like this:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  MIRRORING.FROM
  RECENT
  RECENT.html
  authors/00whois.html
  authors/01mailrc.txt.gz
  authors/id/A/AA/AASSAD/CHECKSUMS
  ...
</pre>
<p class="Pp">However, if you actually want to have those be absolute URLs, you
    can use the URI module's <span class="Li">&quot;new_abs&quot;</span> method,
    by changing the <span class="Li">&quot;while&quot;</span> loop to this:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  while( $html =~ m/&lt;A HREF=\&quot;(.*?)\&quot;/g ) {
    print URI-&gt;new_abs( $1, $response-&gt;base ) ,&quot;\n&quot;;
  }
</pre>
<p class="Pp">(The <span class="Li">&quot;$response-&gt;base&quot;</span> method
    from HTTP::Message is for returning what URL should be used for resolving
    relative URLs -- it's usually just the same as the URL that you
  requested.)</p>
<p class="Pp">That program then emits nicely absolute URLs:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  http://www.cpan.org/MIRRORING.FROM
  http://www.cpan.org/RECENT
  http://www.cpan.org/RECENT.html
  http://www.cpan.org/authors/00whois.html
  http://www.cpan.org/authors/01mailrc.txt.gz
  http://www.cpan.org/authors/id/A/AA/AASSAD/CHECKSUMS
  ...
</pre>
<p class="Pp">See chapter 4 of <i>Perl &amp; LWP</i> for a longer discussion of
    URI objects.</p>
<p class="Pp">Of course, using a regexp to match hrefs is a bit simplistic, and
    for more robust programs, you'll probably want to use an HTML-parsing module
    like HTML::LinkExtor or HTML::TokeParser or even maybe
  HTML::TreeBuilder.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Other_Browser_Attributes"><a class="permalink" href="#Other_Browser_Attributes">Other
  Browser Attributes</a></h2>
LWP::UserAgent objects have many attributes for controlling how they work. Here
  are a few notable ones:
<ul class="Bl-bullet">
  <li><span class="Li">&quot;$browser-&gt;timeout(15);&quot;</span>
    <p class="Pp">This sets this browser object to give up on requests that
        don't answer within 15 seconds.</p>
  </li>
  <li><span class="Li">&quot;$browser-&gt;protocols_allowed( [ 'http', 'gopher']
      );&quot;</span>
    <p class="Pp">This sets this browser object to not speak any protocols other
        than HTTP and gopher. If it tries accessing any other kind of URL (like
        an &quot;ftp:&quot; or &quot;mailto:&quot; or &quot;news:&quot; URL),
        then it won't actually try connecting, but instead will immediately
        return an error code 500, with a message like &quot;Access to 'ftp' URIs
        has been disabled&quot;.</p>
  </li>
  <li><span class="Li">&quot;use LWP::ConnCache;
      $browser-&gt;conn_cache(LWP::ConnCache-&gt;new());&quot;</span>
    <p class="Pp">This tells the browser object to try using the HTTP/1.1
        &quot;Keep-Alive&quot; feature, which speeds up requests by reusing the
        same socket connection for multiple requests to the same server.</p>
  </li>
  <li><span class="Li">&quot;$browser-&gt;agent( 'SomeName/1.23 (more info here
      maybe)' )&quot;</span>
    <p class="Pp">This changes how the browser object will identify itself in
        the default &quot;User-Agent&quot; line is its HTTP requests. By
        default, it'll send &quot;libwww-perl/<i>versionnumber</i>&quot;, like
        &quot;libwww-perl/5.65&quot;. You can change that to something more
        descriptive like this:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  $browser-&gt;agent( 'SomeName/3.14 (contact@robotplexus.int)' );
    </pre>
    <p class="Pp">Or if need be, you can go in disguise, like this:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  $browser-&gt;agent( 'Mozilla/4.0 (compatible; MSIE 5.12; Mac_PowerPC)' );
    </pre>
  </li>
  <li><span class="Li">&quot;push @{ $ua-&gt;requests_redirectable },
      'POST';&quot;</span>
    <p class="Pp">This tells this browser to obey redirection responses to POST
        requests (like most modern interactive browsers), even though the HTTP
        RFC says that should not normally be done.</p>
  </li>
</ul>
<p class="Pp">For more options and information, see the full documentation for
    LWP::UserAgent.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Writing_Polite_Robots"><a class="permalink" href="#Writing_Polite_Robots">Writing
  Polite Robots</a></h2>
If you want to make sure that your LWP-based program respects <i>robots.txt</i>
  files and doesn't make too many requests too fast, you can use the
  LWP::RobotUA class instead of the LWP::UserAgent class.
<p class="Pp">LWP::RobotUA class is just like LWP::UserAgent, and you can use it
    like so:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  use LWP::RobotUA;
  my $browser = LWP::RobotUA-&gt;new('YourSuperBot/1.34', 'you@yoursite.com');
    # Your bot's name and your email address

  my $response = $browser-&gt;get($url);
</pre>
<p class="Pp">But HTTP::RobotUA adds these features:</p>
<ul class="Bl-bullet">
  <li>If the <i>robots.txt</i> on <span class="Li">$url</span>'s server forbids
      you from accessing <span class="Li">$url</span>, then the
      <span class="Li">$browser</span> object (assuming it's of class
      LWP::RobotUA) won't actually request it, but instead will give you back
      (in <span class="Li">$response</span>) a 403 error with a message
      &quot;Forbidden by robots.txt&quot;. That is, if you have this line:
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  die &quot;$url -- &quot;, $response-&gt;status_line, &quot;\nAborted&quot;
   unless $response-&gt;is_success;
    </pre>
    <p class="Pp">then the program would die with an error message like
      this:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  http://whatever.site.int/pith/x.html -- 403 Forbidden by robots.txt
  Aborted at whateverprogram.pl line 1234
    </pre>
  </li>
  <li>If this <span class="Li">$browser</span> object sees that the last time it
      talked to <span class="Li">$url</span>'s server was too recently, then it
      will pause (via <span class="Li">&quot;sleep&quot;</span>) to avoid making
      too many requests too often. How long it will pause for, is by default one
      minute -- but you can control it with the
      <span class="Li">&quot;$browser-&gt;delay(
      </span><i>minutes</i><span class="Li"> )&quot;</span> attribute.
    <p class="Pp">For example, this code:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  $browser-&gt;delay( 7/60 );
    </pre>
    <p class="Pp">...means that this browser will pause when it needs to avoid
        talking to any given server more than once every 7 seconds.</p>
  </li>
</ul>
<p class="Pp">For more options and information, see the full documentation for
    LWP::RobotUA.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Using_Proxies"><a class="permalink" href="#Using_Proxies">Using
  Proxies</a></h2>
In some cases, you will want to (or will have to) use proxies for accessing
  certain sites and/or using certain protocols. This is most commonly the case
  when your LWP program is running (or could be running) on a machine that is
  behind a firewall.
<p class="Pp">To make a browser object use proxies that are defined in the usual
    environment variables (<span class="Li">&quot;HTTP_PROXY&quot;</span>,
    etc.), just call the <span class="Li">&quot;env_proxy&quot;</span> on a
    user-agent object before you go making any requests on it. Specifically:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  use LWP::UserAgent;
  my $browser = LWP::UserAgent-&gt;new;
  
  # And before you go making any requests:
  $browser-&gt;env_proxy;
</pre>
<p class="Pp">For more information on proxy parameters, see the LWP::UserAgent
    documentation, specifically the <span class="Li">&quot;proxy&quot;</span>,
    <span class="Li">&quot;env_proxy&quot;</span>, and
    <span class="Li">&quot;no_proxy&quot;</span> methods.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_s-1HTTP_s0_Authentication"><a class="permalink" href="#_s-1HTTP_s0_Authentication">HTTP
  Authentication</a></h2>
Many web sites restrict access to documents by using &quot;HTTP
  Authentication&quot;. This isn't just any form of &quot;enter your
  password&quot; restriction, but is a specific mechanism where the HTTP server
  sends the browser an HTTP code that says &quot;That document is part of a
  protected 'realm', and you can access it only if you re-request it and add
  some special authorization headers to your request&quot;.
<p class="Pp">For example, the Unicode.org admins stop email-harvesting bots
    from harvesting the contents of their mailing list archives, by protecting
    them with HTTP Authentication, and then publicly stating the username and
    password (at
    <span class="Li">&quot;http://www.unicode.org/mail-arch/&quot;</span>) --
    namely username &quot;unicode-ml&quot; and password &quot;unicode&quot;.</p>
<p class="Pp">For example, consider this URL, which is part of the protected
    area of the web site:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  http://www.unicode.org/mail-arch/unicode-ml/y2002-m08/0067.html
</pre>
<p class="Pp">If you access that with a browser, you'll get a prompt like
    &quot;Enter username and password for 'Unicode-MailList-Archives' at server
    'www.unicode.org'&quot;.</p>
<p class="Pp">In LWP, if you just request that URL, like this:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  use LWP;
  my $browser = LWP::UserAgent-&gt;new;

  my $url =
   'http://www.unicode.org/mail-arch/unicode-ml/y2002-m08/0067.html';
  my $response = $browser-&gt;get($url);

  die &quot;Error: &quot;, $response-&gt;header('WWW-Authenticate') || 'Error accessing',
    #  ('WWW-Authenticate' is the realm-name)
    &quot;\n &quot;, $response-&gt;status_line, &quot;\n at $url\n Aborting&quot;
   unless $response-&gt;is_success;
</pre>
<p class="Pp">Then you'll get this error:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  Error: Basic realm=&quot;Unicode-MailList-Archives&quot;
   401 Authorization Required
   at http://www.unicode.org/mail-arch/unicode-ml/y2002-m08/0067.html
   Aborting at auth1.pl line 9.  [or wherever]
</pre>
<p class="Pp">...because the <span class="Li">$browser</span> doesn't know any
    the username and password for that realm
    (&quot;Unicode-MailList-Archives&quot;) at that host
    (&quot;www.unicode.org&quot;). The simplest way to let the browser know
    about this is to use the <span class="Li">&quot;credentials&quot;</span>
    method to let it know about a username and password that it can try using
    for that realm at that host. The syntax is:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  $browser-&gt;credentials(
    'servername:portnumber',
    'realm-name',
   'username' =&gt; 'password'
  );
</pre>
<p class="Pp">In most cases, the port number is 80, the default TCP/IP port for
    HTTP; and you usually call the
    <span class="Li">&quot;credentials&quot;</span> method before you make any
    requests. For example:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  $browser-&gt;credentials(
    'reports.mybazouki.com:80',
    'web_server_usage_reports',
    'plinky' =&gt; 'banjo123'
  );
</pre>
<p class="Pp">So if we add the following to the program above, right after the
    <span class="Li">&quot;$browser = LWP::UserAgent-&gt;new;&quot;</span>
    line...</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  $browser-&gt;credentials(  # add this to our $browser 's &quot;key ring&quot;
    'www.unicode.org:80',
    'Unicode-MailList-Archives',
    'unicode-ml' =&gt; 'unicode'
  );
</pre>
<p class="Pp">...then when we run it, the request succeeds, instead of causing
    the <span class="Li">&quot;die&quot;</span> to be called.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Accessing__s-1HTTPS_s0_URLs"><a class="permalink" href="#Accessing__s-1HTTPS_s0_URLs">Accessing
  HTTPS URLs</a></h2>
When you access an HTTPS URL, it'll work for you just like an HTTP URL would --
  if your LWP installation has HTTPS support (via an appropriate Secure Sockets
  Layer library). For example:
<p class="Pp"><span class="Li"></span></p>
<pre>
  use LWP;
  my $url = 'https://www.paypal.com/';   # Yes, HTTPS!
  my $browser = LWP::UserAgent-&gt;new;
  my $response = $browser-&gt;get($url);
  die &quot;Error at $url\n &quot;, $response-&gt;status_line, &quot;\n Aborting&quot;
   unless $response-&gt;is_success;
  print &quot;Whee, it worked!  I got that &quot;,
   $response-&gt;content_type, &quot; document!\n&quot;;
</pre>
<p class="Pp">If your LWP installation doesn't have HTTPS support set up, then
    the response will be unsuccessful, and you'll get this error message:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  Error at https://www.paypal.com/
   501 Protocol scheme 'https' is not supported
   Aborting at paypal.pl line 7.   [or whatever program and line]
</pre>
<p class="Pp">If your LWP installation <i>does</i> have HTTPS support installed,
    then the response should be successful, and you should be able to consult
    <span class="Li">$response</span> just like with any normal HTTP
  response.</p>
<p class="Pp">For information about installing HTTPS support for your LWP
    installation, see the helpful <i>README.SSL</i> file that comes in the
    libwww-perl distribution.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Getting_Large_Documents"><a class="permalink" href="#Getting_Large_Documents">Getting
  Large Documents</a></h2>
When you're requesting a large (or at least potentially large) document, a
  problem with the normal way of using the request methods (like
  <span class="Li">&quot;$response = $browser-&gt;get($url)&quot;</span>) is
  that the response object in memory will have to hold the whole document --
  <i>in memory</i>. If the response is a thirty megabyte file, this is likely to
  be quite an imposition on this process's memory usage.
<p class="Pp">A notable alternative is to have LWP save the content to a file on
    disk, instead of saving it up in memory. This is the syntax to use:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  $response = $ua-&gt;get($url,
                         ':content_file' =&gt; $filespec,
                      );
</pre>
<p class="Pp">For example,</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  $response = $ua-&gt;get('http://search.cpan.org/',
                         ':content_file' =&gt; '/tmp/sco.html'
                      );
</pre>
<p class="Pp">When you use this
    <span class="Li">&quot;:content_file&quot;</span> option, the
    <span class="Li">$response</span> will have all the normal header lines, but
    <span class="Li">&quot;$response-&gt;content&quot;</span> will be empty.
    Errors writing to the content file (for example due to permission denied or
    the filesystem being full) will be reported via the
    <span class="Li">&quot;Client-Aborted&quot;</span> or
    <span class="Li">&quot;X-Died&quot;</span> response headers, and not the
    <span class="Li">&quot;is_success&quot;</span> method:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  if ($response-&gt;header('Client-Aborted') eq 'die') {
    # handle error ...
</pre>
<p class="Pp">Note that this &quot;:content_file&quot; option isn't supported
    under older versions of LWP, so you should consider adding
    <span class="Li">&quot;use LWP 5.66;&quot;</span> to check the LWP version,
    if you think your program might run on systems with older versions.</p>
<p class="Pp">If you need to be compatible with older LWP versions, then use
    this syntax, which does the same thing:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  use HTTP::Request::Common;
  $response = $ua-&gt;request( GET($url), $filespec );
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
Remember, this article is just the most rudimentary introduction to LWP -- to
  learn more about LWP and LWP-related tasks, you really must read from the
  following:
<ul class="Bl-bullet">
  <li>LWP::Simple -- simple functions for getting/heading/mirroring URLs</li>
  <li>LWP -- overview of the libwww-perl modules</li>
  <li>LWP::UserAgent -- the class for objects that represent &quot;virtual
      browsers&quot;</li>
  <li>HTTP::Response -- the class for objects that represent the response to a
      LWP response, as in <span class="Li">&quot;$response =
      $browser-&gt;get(...)&quot;</span></li>
  <li>HTTP::Message and HTTP::Headers -- classes that provide more methods to
      HTTP::Response.</li>
  <li>URI -- class for objects that represent absolute or relative URLs</li>
  <li>URI::Escape -- functions for URL-escaping and URL-unescaping strings (like
      turning &quot;this &amp; that&quot; to and from
      &quot;this%20%26%20that&quot;).</li>
  <li>HTML::Entities -- functions for HTML-escaping and HTML-unescaping strings
      (like turning &quot;C. &amp; E. Bront&#x00EB;&quot; to and from &quot;C.
      &amp;amp; E. Bront&amp;euml;&quot;)</li>
  <li>HTML::TokeParser and HTML::TreeBuilder -- classes for parsing HTML</li>
  <li>HTML::LinkExtor -- class for finding links in HTML documents</li>
  <li>The book <i>Perl &amp; LWP</i> by Sean M. Burke. O'Reilly &amp;
      Associates, 2002. ISBN: 0-596-00178-9,
      &lt;http://oreilly.com/catalog/perllwp/&gt;. The whole book is also
      available free online: &lt;http://lwp.interglacial.com&gt;.</li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT"><a class="permalink" href="#COPYRIGHT">COPYRIGHT</a></h1>
Copyright 2002, Sean M. Burke. You can redistribute this document and/or modify
  it, but only under the same terms as Perl itself.
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
Sean M. Burke <span class="Li">&quot;sburke@cpan.org&quot;</span>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2020-04-14</td>
    <td class="foot-os">perl v5.28.2</td>
  </tr>
</table>
</body>
</html>
