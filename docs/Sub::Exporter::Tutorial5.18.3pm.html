<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>Sub::Exporter::Tutorial(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Sub::Exporter::Tutorial(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Sub::Exporter::Tutorial(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
Sub::Exporter::Tutorial - a friendly guide to exporting with Sub::Exporter
</section>
<section class="Sh">
<h1 class="Sh" id="VERSION"><a class="permalink" href="#VERSION">VERSION</a></h1>
version 0.987
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<section class="Ss">
<h2 class="Ss" id="What's_an_Exporter?"><a class="permalink" href="#What's_an_Exporter?">What's
  an Exporter?</a></h2>
When you <span class="Li">&quot;use&quot;</span> a module, first it is required,
  then its <span class="Li">&quot;import&quot;</span> method is called. The Perl
  documentation tells us that the following two lines are equivalent:
<p class="Pp"><span class="Li"></span></p>
<pre>
  use Module LIST;

  BEGIN { require Module; Module-&gt;import(LIST); }
</pre>
<p class="Pp">The method named <span class="Li">&quot;import&quot;</span> is the
    module's <i>exporter</i>, it exports functions and variables into its
    caller's namespace.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="The_Basics_of_Sub::Exporter"><a class="permalink" href="#The_Basics_of_Sub::Exporter">The
  Basics of Sub::Exporter</a></h2>
Sub::Exporter builds a custom exporter which can then be installed into your
  module. It builds this method based on configuration passed to its
  <span class="Li">&quot;setup_exporter&quot;</span> method.
<p class="Pp">A very basic use case might look like this:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  package Addition;
  use Sub::Exporter;
  Sub::Exporter::setup_exporter({ exports =&gt; [ qw(plus) ]});

  sub plus { my ($x, $y) = @_; return $x + $y; }
</pre>
<p class="Pp">This would mean that when someone used your Addition module, they
    could have its <span class="Li">&quot;plus&quot;</span> routine imported
    into their package:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  use Addition qw(plus);

  my $z = plus(2, 2); # this works, because now plus is in the main package
</pre>
<p class="Pp">That syntax to set up the exporter, above, is a little verbose, so
    for the simple case of just naming some exports, you can write this:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  use Sub::Exporter -setup =&gt; { exports =&gt; [ qw(plus) ] };
</pre>
<p class="Pp">...which is the same as the original example -- except that now
    the exporter is built and installed at compile time. Well, that and you
    typed less.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Using_Export_Groups"><a class="permalink" href="#Using_Export_Groups">Using
  Export Groups</a></h2>
You can specify whole groups of things that should be exportable together. These
  are called groups. Exporter calls these tags. To specify groups, you just pass
  a <span class="Li">&quot;groups&quot;</span> key in your exporter
  configuration:
<p class="Pp"><span class="Li"></span></p>
<pre>
  package Food;
  use Sub::Exporter -setup =&gt; {
    exports =&gt; [ qw(apple banana beef fluff lox rabbit) ],
    groups  =&gt; {
      fauna  =&gt; [ qw(beef lox rabbit) ],
      flora  =&gt; [ qw(apple banana) ],
    }
  };
</pre>
<p class="Pp">Now, to import all that delicious foreign meat, your consumer
    needs only to write:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  use Food qw(:fauna);
  use Food qw(-fauna);
</pre>
<p class="Pp">Either one of the above is acceptable. A colon is more
    traditional, but barewords with a leading colon can't be enquoted by a fat
    arrow. We'll see why that matters later on.</p>
<p class="Pp">Groups can contain other groups. If you include a group name (with
    the leading dash or colon) in a group definition, it will be expanded
    recursively when the exporter is called. The exporter will <b>not</b>
    recurse into the same group twice while expanding groups.</p>
<p class="Pp">There are two special groups:
    <span class="Li">&quot;all&quot;</span> and
    <span class="Li">&quot;default&quot;</span>. The
    <span class="Li">&quot;all&quot;</span> group is defined for you and
    contains all exportable subs. You can redefine it, if you want to export
    only a subset when all exports are requested. The
    <span class="Li">&quot;default&quot;</span> group is the set of routines to
    export when nothing specific is requested. By default, there is no
    <span class="Li">&quot;default&quot;</span> group.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Renaming_Your_Imports"><a class="permalink" href="#Renaming_Your_Imports">Renaming
  Your Imports</a></h2>
Sometimes you want to import something, but you don't like the name as which
  it's imported. Sub::Exporter can rename your imports for you. If you wanted to
  import <span class="Li">&quot;lox&quot;</span> from the Food package, but you
  don't like the name, you could write this:
<p class="Pp"><span class="Li"></span></p>
<pre>
  use Food lox =&gt; { -as =&gt; 'salmon' };
</pre>
<p class="Pp">Now you'd get the <span class="Li">&quot;lox&quot;</span> routine,
    but it would be called salmon in your package. You can also rename entire
    groups by using the <span class="Li">&quot;prefix&quot;</span> option:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  use Food -fauna =&gt; { -prefix =&gt; 'cute_little_' };
</pre>
<p class="Pp">Now you can call your
    <span class="Li">&quot;cute_little_rabbit&quot;</span> routine. (You can
    also call <span class="Li">&quot;cute_little_beef&quot;</span>, but that
    hardly seems as enticing.)</p>
<p class="Pp">When you define groups, you can include renaming.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  use Sub::Exporter -setup =&gt; {
    exports =&gt; [ qw(apple banana beef fluff lox rabbit) ],
    groups  =&gt; {
      fauna  =&gt; [ qw(beef lox), rabbit =&gt; { -as =&gt; 'coney' } ],
    }
  };
</pre>
<p class="Pp">A prefix on a group like that does the right thing. This is when
    it's useful to use a dash instead of a colon to indicate a group: you can
    put a fat arrow between the group and its arguments, then.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  use Food -fauna =&gt; { -prefix =&gt; 'lovely_' };

  eat( lovely_coney ); # this works
</pre>
<p class="Pp">Prefixes also apply recursively. That means that this code
  works:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  use Sub::Exporter -setup =&gt; {
    exports =&gt; [ qw(apple banana beef fluff lox rabbit) ],
    groups  =&gt; {
      fauna   =&gt; [ qw(beef lox), rabbit =&gt; { -as =&gt; 'coney' } ],
      allowed =&gt; [ -fauna =&gt; { -prefix =&gt; 'willing_' }, 'banana' ],
    }
  };

  ...

  use Food -allowed =&gt; { -prefix =&gt; 'any_' };

  $dinner = any_willing_coney; # yum!
</pre>
<p class="Pp">Groups can also be passed a
    <span class="Li">&quot;-suffix&quot;</span> argument.</p>
<p class="Pp">Finally, if the <span class="Li">&quot;-as&quot;</span> argument
    to an exported routine is a reference to a scalar, a reference to the
    routine will be placed in that scalar.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Building_Subroutines_to_Order"><a class="permalink" href="#Building_Subroutines_to_Order">Building
  Subroutines to Order</a></h2>
Sometimes, you want to export things that you don't have on hand. You might want
  to offer customized routines built to the specification of your consumer;
  that's just good business! With Sub::Exporter, this is easy.
<p class="Pp">To offer subroutines to order, you need to provide a generator
    when you set up your exporter. A generator is just a routine that returns a
    new routine. perlref is talking about these when it discusses closures and
    function templates. The canonical example of a generator builds a unique
    incrementor; here's how you'd do that with Sub::Exporter;</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  package Package::Counter;
  use Sub::Exporter -setup =&gt; {
    exports =&gt; [ counter =&gt; sub { my $i = 0; sub { $i++ } } ],
    groups  =&gt; { default =&gt; [ qw(counter) ] },
  };
</pre>
<p class="Pp">Now anyone can use your Package::Counter module and he'll receive
    a <span class="Li">&quot;counter&quot;</span> in his package. It will count
    up by one, and will never interfere with anyone else's counter.</p>
<p class="Pp">This isn't very useful, though, unless the consumer can explain
    what he wants. This is done, in part, by supplying arguments when importing.
    The following example shows how a generator can take and use arguments:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  package Package::Counter;

  sub _build_counter {
    my ($class, $name, $arg) = @_;
    $arg ||= {};
    my $i = $arg-&gt;{start} || 0;
    return sub { $i++ };
  }

  use Sub::Exporter -setup =&gt; {
    exports =&gt; [ counter =&gt; \'_build_counter' ],
    groups  =&gt; { default =&gt; [ qw(counter) ] },
  };
</pre>
<p class="Pp">Now, the consumer can (if he wants) specify a starting value for
    his counter:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  use Package::Counter counter =&gt; { start =&gt; 10 };
</pre>
<p class="Pp">Arguments to a group are passed along to the generators of
    routines in that group, but Sub::Exporter arguments -- anything beginning
    with a dash -- are never passed in. When groups are nested, the arguments
    are merged as the groups are expanded.</p>
<p class="Pp">Notice, too, that in the example above, we gave a reference to a
    method <i>name</i> rather than a method <i>implementation</i>. By giving the
    name rather than the subroutine, we make it possible for subclasses of our
    &quot;Package::Counter&quot; module to replace the
    <span class="Li">&quot;_build_counter&quot;</span> method.</p>
<p class="Pp">When a generator is called, it is passed four parameters:</p>
<ul class="Bl-bullet">
  <li>the invocant on which the exporter was called</li>
  <li>the name of the export being generated (not the name it's being installed
      as)</li>
  <li>the arguments supplied for the routine</li>
  <li>the collection of generic arguments</li>
</ul>
<p class="Pp">The fourth item is the last major feature that hasn't been
    covered.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Argument_Collectors"><a class="permalink" href="#Argument_Collectors">Argument
  Collectors</a></h2>
Sometimes you will want to accept arguments once that can then be available to
  any subroutine that you're going to export. To do this, you specify
  collectors, like this:
<p class="Pp"><span class="Li"></span></p>
<pre>
  package Menu::Airline
  use Sub::Exporter -setup =&gt; {
    exports =&gt;  ... ,
    groups  =&gt;  ... ,
    collectors =&gt; [ qw(allergies ethics) ],
  };
</pre>
<p class="Pp">Collectors look like normal exports in the import call, but they
    don't do anything but collect data which can later be passed to generators.
    If the module was used like this:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  use Menu::Airline allergies =&gt; [ qw(peanuts) ], ethics =&gt; [ qw(vegan) ];
</pre>
<p class="Pp">...the consumer would get a salad. Also, all the generators would
    be passed, as their fourth argument, something like this:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  { allerges =&gt; [ qw(peanuts) ], ethics =&gt; [ qw(vegan) ] }
</pre>
<p class="Pp">Generators may have arguments in their definition, as well. These
    must be code refs that perform validation of the collected values. They are
    passed the collection value and may return true or false. If they return
    false, the exporter will throw an exception.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Generating_Many_Routines_in_One_Scope"><a class="permalink" href="#Generating_Many_Routines_in_One_Scope">Generating
  Many Routines in One Scope</a></h2>
Sometimes it's useful to have multiple routines generated in one scope. This way
  they can share lexical data which is otherwise unavailable. To do this, you
  can supply a generator for a group which returns a hashref of names and code
  references. This generator is passed all the usual data, and the group may
  receive the usual <span class="Li">&quot;-prefix&quot;</span> or
  <span class="Li">&quot;-suffix&quot;</span> arguments.
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<dl class="Bl-tag">
  <dt>&#x2022;</dt>
  <dd>Sub::Exporter for complete documentation and references to other
    exporters</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
Ricardo Signes &lt;rjbs@cpan.org&gt;
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT_AND_LICENSE"><a class="permalink" href="#COPYRIGHT_AND_LICENSE">COPYRIGHT
  AND LICENSE</a></h1>
This software is copyright (c) 2007 by Ricardo Signes.
<p class="Pp">This is free software; you can redistribute it and/or modify it
    under the same terms as the Perl 5 programming language system itself.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2013-10-18</td>
    <td class="foot-os">perl v5.18.4</td>
  </tr>
</table>
</body>
</html>
