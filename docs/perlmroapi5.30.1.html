<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>PERLMROAPI(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">PERLMROAPI(1)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">PERLMROAPI(1)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
perlmroapi - Perl method resolution plugin interface
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
As of Perl 5.10.1 there is a new interface for plugging and using method
  resolution orders other than the default (linear depth first search). The C3
  method resolution order added in 5.10.0 has been re-implemented as a plugin,
  without changing its Perl-space interface.
<p class="Pp">Each plugin should register itself by providing the following
    structure</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    struct mro_alg {
        AV *(*resolve)(pTHX_ HV *stash, U32 level);
        const char *name;
        U16 length;
        U16 kflags;
        U32 hash;
    };
</pre>
<p class="Pp">and calling
  <span class="Li">&quot;Perl_mro_register&quot;</span>:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    Perl_mro_register(aTHX_ &amp;my_mro_alg);
</pre>
<dl class="Bl-tag">
  <dt>resolve</dt>
  <dd>Pointer to the linearisation function, described below.</dd>
  <dt>name</dt>
  <dd>Name of the MRO, either in ISO-8859-1 or UTF-8.</dd>
  <dt>length</dt>
  <dd>Length of the name.</dd>
  <dt>kflags</dt>
  <dd>If the name is given in UTF-8, set this to
      <span class="Li">&quot;HVhek_UTF8&quot;</span>. The value is passed direct
      as the parameter <i>kflags</i> to
      <span class="Li">&quot;hv_common()&quot;</span>.</dd>
  <dt>hash</dt>
  <dd>A precomputed hash value for the MRO's name, or 0.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="Callbacks"><a class="permalink" href="#Callbacks">Callbacks</a></h1>
The <span class="Li">&quot;resolve&quot;</span> function is called to generate a
  linearised ISA for the given stash, using this MRO. It is called with a
  pointer to the stash, and a <i>level</i> of 0. The core always sets
  <i>level</i> to 0 when it calls your function - the parameter is provided to
  allow your implementation to track depth if it needs to recurse.
<p class="Pp">The function should return a reference to an array containing the
    parent classes in order. The names of the classes should be the result of
    calling <span class="Li">&quot;HvENAME()&quot;</span> on the stash. In those
    cases where <span class="Li">&quot;HvENAME()&quot;</span> returns null,
    <span class="Li">&quot;HvNAME()&quot;</span> should be used instead.</p>
<p class="Pp">The caller is responsible for incrementing the reference count of
    the array returned if it wants to keep the structure. Hence, if you have
    created a temporary value that you keep no pointer to,
    <span class="Li">&quot;sv_2mortal()&quot;</span> to ensure that it is
    disposed of correctly. If you have cached your return value, then return a
    pointer to it without changing the reference count.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="Caching"><a class="permalink" href="#Caching">Caching</a></h1>
Computing MROs can be expensive. The implementation provides a cache, in which
  you can store a single <span class="Li">&quot;SV *&quot;</span>, or anything
  that can be cast to <span class="Li">&quot;SV *&quot;</span>, such as
  <span class="Li">&quot;AV *&quot;</span>. To read your private value, use the
  macro <span class="Li">&quot;MRO_GET_PRIVATE_DATA()&quot;</span>, passing it
  the <span class="Li">&quot;mro_meta&quot;</span> structure from the stash, and
  a pointer to your <span class="Li">&quot;mro_alg&quot;</span> structure:
<p class="Pp"><span class="Li"></span></p>
<pre>
    meta = HvMROMETA(stash);
    private_sv = MRO_GET_PRIVATE_DATA(meta, &amp;my_mro_alg);
</pre>
<p class="Pp">To set your private value, call
    <span class="Li">&quot;Perl_mro_set_private_data()&quot;</span>:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    Perl_mro_set_private_data(aTHX_ meta, &amp;c3_alg, private_sv);
</pre>
<p class="Pp">The private data cache will take ownership of a reference to
    private_sv, much the same way that
    <span class="Li">&quot;hv_store()&quot;</span> takes ownership of a
    reference to the value that you pass it.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="Examples"><a class="permalink" href="#Examples">Examples</a></h1>
For examples of MRO implementations, see
  <span class="Li">&quot;S_mro_get_linear_isa_c3()&quot;</span> and the
  <span class="Li">&quot;BOOT:&quot;</span> section of <i>ext/mro/mro.xs</i>,
  and <span class="Li">&quot;S_mro_get_linear_isa_dfs()&quot;</span> in
  <i>mro_core.c</i>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHORS"><a class="permalink" href="#AUTHORS">AUTHORS</a></h1>
The implementation of the C3 MRO and switchable MROs within the perl core was
  written by Brandon L Black. Nicholas Clark created the pluggable interface,
  refactored Brandon's implementation to work with it, and wrote this document.
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2019-10-24</td>
    <td class="foot-os">perl v5.30.2</td>
  </tr>
</table>
</body>
</html>
