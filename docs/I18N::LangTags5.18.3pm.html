<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>I18N::LangTags(3pm)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">I18N::LangTags(3pm)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">I18N::LangTags(3pm)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
I18N::LangTags - functions for dealing with RFC3066-style language tags
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<span class="Li"></span>
<pre>
  use I18N::LangTags();
</pre>
<p class="Pp">...or specify whichever of those functions you want to import,
    like so:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  use I18N::LangTags qw(implicate_supers similarity_language_tag);
</pre>
<p class="Pp">All the exportable functions are listed below -- you're free to
    import only some, or none at all. By default, none are imported. If you
  say:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    use I18N::LangTags qw(:ALL)
</pre>
<p class="Pp">...then all are exported. (This saves you from having to use
    something less obvious like <span class="Li">&quot;use I18N::LangTags
    qw(/./)&quot;</span>.)</p>
<p class="Pp">If you don't import any of these functions, assume a
    <span class="Li">&amp;I18N::LangTags::</span> in front of all the function
    names in the following examples.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
Language tags are a formalism, described in RFC 3066 (obsoleting 1766), for
  declaring what language form (language and possibly dialect) a given chunk of
  information is in.
<p class="Pp">This library provides functions for common tasks involving
    language tags as they are needed in a variety of protocols and
  applications.</p>
<p class="Pp">Please see the &quot;See Also&quot; references for a thorough
    explanation of how to correctly use language tags.</p>
<ul class="Bl-bullet">
  <li>the function is_language_tag($lang1)
    <p class="Pp">Returns true iff <span class="Li">$lang1</span> is a formally
        valid language tag.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
   is_language_tag(&quot;fr&quot;)            is TRUE
   is_language_tag(&quot;x-jicarilla&quot;)   is FALSE
       (Subtags can be 8 chars long at most -- 'jicarilla' is 9)

   is_language_tag(&quot;sgn-US&quot;)    is TRUE
       (That's American Sign Language)

   is_language_tag(&quot;i-Klikitat&quot;)    is TRUE
       (True without regard to the fact noone has actually
        registered Klikitat -- it's a formally valid tag)

   is_language_tag(&quot;fr-patois&quot;)     is TRUE
       (Formally valid -- altho descriptively weak!)

   is_language_tag(&quot;Spanish&quot;)       is FALSE
   is_language_tag(&quot;french-patois&quot;) is FALSE
       (No good -- first subtag has to match
        /^([xXiI]|[a-zA-Z]{2,3})$/ -- see RFC3066)

   is_language_tag(&quot;x-borg-prot2532&quot;) is TRUE
       (Yes, subtags can contain digits, as of RFC3066)
    </pre>
  </li>
  <li>the function extract_language_tags($whatever)
    <p class="Pp">Returns a list of whatever looks like formally valid language
        tags in <span class="Li">$whatever</span>. Not very smart, so don't get
        too creative with what you want to feed it.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  extract_language_tags(&quot;fr, fr-ca, i-mingo&quot;)
    returns:   ('fr', 'fr-ca', 'i-mingo')

  extract_language_tags(&quot;It's like this: I'm in fr -- French!&quot;)
    returns:   ('It', 'in', 'fr')
  (So don't just feed it any old thing.)
    </pre>
    <p class="Pp">The output is untainted. If you don't know what tainting is,
        don't worry about it.</p>
  </li>
  <li>the function same_language_tag($lang1, <span class="Li">$lang2</span>)
    <p class="Pp">Returns true iff <span class="Li">$lang1</span> and
        <span class="Li">$lang2</span> are acceptable variant tags representing
        the same language-form.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
   same_language_tag('x-kadara', 'i-kadara')  is TRUE
      (The x/i- alternation doesn't matter)
   same_language_tag('X-KADARA', 'i-kadara')  is TRUE
      (...and neither does case)
   same_language_tag('en',       'en-US')     is FALSE
      (all-English is not the SAME as US English)
   same_language_tag('x-kadara', 'x-kadar')   is FALSE
      (these are totally unrelated tags)
   same_language_tag('no-bok',    'nb')       is TRUE
      (no-bok is a legacy tag for nb (Norwegian Bokmal))
    </pre>
    <p class="Pp"><span class="Li">&quot;same_language_tag&quot;</span> works by
        just seeing whether
        <span class="Li">&quot;encode_language_tag($lang1)&quot;</span> is the
        same as
      <span class="Li">&quot;encode_language_tag($lang2)&quot;</span>.</p>
    <p class="Pp">(Yes, I know this function is named a bit oddly. Call it
        historic reasons.)</p>
  </li>
  <li>the function similarity_language_tag($lang1,
      <span class="Li">$lang2</span>)
    <p class="Pp">Returns an integer representing the degree of similarity
        between tags <span class="Li">$lang1</span> and
        <span class="Li">$lang2</span> (the order of which does not matter),
        where similarity is the number of common elements on the left, without
        regard to case and to x/i- alternation.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
   similarity_language_tag('fr', 'fr-ca')           is 1
      (one element in common)
   similarity_language_tag('fr-ca', 'fr-FR')        is 1
      (one element in common)

   similarity_language_tag('fr-CA-joual',
                           'fr-CA-PEI')             is 2
   similarity_language_tag('fr-CA-joual', 'fr-CA')  is 2
      (two elements in common)

   similarity_language_tag('x-kadara', 'i-kadara')  is 1
      (x/i- doesn't matter)

   similarity_language_tag('en',       'x-kadar')   is 0
   similarity_language_tag('x-kadara', 'x-kadar')   is 0
      (unrelated tags -- no similarity)

   similarity_language_tag('i-cree-syllabic',
                           'i-cherokee-syllabic')   is 0
      (no B&lt;leftmost&gt; elements in common!)
    </pre>
  </li>
  <li>the function is_dialect_of($lang1, <span class="Li">$lang2</span>)
    <p class="Pp">Returns true iff language tag <span class="Li">$lang1</span>
        represents a subform of language tag <span class="Li">$lang2</span>.</p>
    <p class="Pp"><b>Get the order right! It doesn't work the other way
        around!</b></p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
   is_dialect_of('en-US', 'en')            is TRUE
     (American English IS a dialect of all-English)

   is_dialect_of('fr-CA-joual', 'fr-CA')   is TRUE
   is_dialect_of('fr-CA-joual', 'fr')      is TRUE
     (Joual is a dialect of (a dialect of) French)

   is_dialect_of('en', 'en-US')            is FALSE
     (all-English is a NOT dialect of American English)

   is_dialect_of('fr', 'en-CA')            is FALSE

   is_dialect_of('en',    'en'   )         is TRUE
   is_dialect_of('en-US', 'en-US')         is TRUE
     (B&lt;Note:&gt; these are degenerate cases)

   is_dialect_of('i-mingo-tom', 'x-Mingo') is TRUE
     (the x/i thing doesn't matter, nor does case)

   is_dialect_of('nn', 'no')               is TRUE
     (because 'nn' (New Norse) is aliased to 'no-nyn',
      as a special legacy case, and 'no-nyn' is a
      subform of 'no' (Norwegian))
    </pre>
  </li>
  <li>the function super_languages($lang1)
    <p class="Pp">Returns a list of language tags that are superordinate tags to
        <span class="Li">$lang1</span> -- it gets this by removing subtags from
        the end of <span class="Li">$lang1</span> until nothing (or just
        &quot;i&quot; or &quot;x&quot;) is left.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
   super_languages(&quot;fr-CA-joual&quot;)  is  (&quot;fr-CA&quot;, &quot;fr&quot;)

   super_languages(&quot;en-AU&quot;)  is  (&quot;en&quot;)

   super_languages(&quot;en&quot;)  is  empty-list, ()

   super_languages(&quot;i-cherokee&quot;)  is  empty-list, ()
    ...not (&quot;i&quot;), which would be illegal as well as pointless.
    </pre>
    <p class="Pp">If <span class="Li">$lang1</span> is not a valid language tag,
        returns empty-list in a list context, undef in a scalar context.</p>
    <p class="Pp">A notable and rather unavoidable problem with this method:
        &quot;x-mingo-tom&quot; has an &quot;x&quot; because the whole tag isn't
        an IANA-registered tag -- but super_languages('x-mingo-tom') is
        ('x-mingo') -- which isn't really right, since 'i-mingo' is registered.
        But this module has no way of knowing that. (But note that
        same_language_tag('x-mingo', 'i-mingo') is TRUE.)</p>
    <p class="Pp">More importantly, you assume <i>at your peril</i> that
        superordinates of <span class="Li">$lang1</span> are mutually
        intelligible with <span class="Li">$lang1</span>. Consider this
        carefully.</p>
  </li>
  <li>the function locale2language_tag($locale_identifier)
    <p class="Pp">This takes a locale name (like &quot;en&quot;,
        &quot;en_US&quot;, or &quot;en_US.ISO8859-1&quot;) and maps it to a
        language tag. If it's not mappable (as with, notably, &quot;C&quot; and
        &quot;POSIX&quot;), this returns empty-list in a list context, or undef
        in a scalar context.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
   locale2language_tag(&quot;en&quot;) is &quot;en&quot;

   locale2language_tag(&quot;en_US&quot;) is &quot;en-US&quot;

   locale2language_tag(&quot;en_US.ISO8859-1&quot;) is &quot;en-US&quot;

   locale2language_tag(&quot;C&quot;) is undef or ()

   locale2language_tag(&quot;POSIX&quot;) is undef or ()

   locale2language_tag(&quot;POSIX&quot;) is undef or ()
    </pre>
    <p class="Pp">I'm not totally sure that locale names map satisfactorily to
        language tags. Think REAL hard about how you use this. YOU HAVE BEEN
        WARNED.</p>
    <p class="Pp">The output is untainted. If you don't know what tainting is,
        don't worry about it.</p>
  </li>
  <li>the function encode_language_tag($lang1)
    <p class="Pp">This function, if given a language tag, returns an encoding of
        it such that:</p>
    <p class="Pp">* tags representing different languages never get the same
        encoding.</p>
    <p class="Pp">* tags representing the same language always get the same
        encoding.</p>
    <p class="Pp">* an encoding of a formally valid language tag always is a
        string value that is defined, has length, and is true if considered as a
        boolean.</p>
    <p class="Pp">Note that the encoding itself is <b>not</b> a formally valid
        language tag. Note also that you cannot, currently, go from an encoding
        back to a language tag that it's an encoding of.</p>
    <p class="Pp">Note also that you <b>must</b> consider the encoded value as
        atomic; i.e., you should not consider it as anything but an opaque,
        unanalysable string value. (The internals of the encoding method may
        change in future versions, as the language tagging standard changes over
        time.)</p>
    <p class="Pp"><span class="Li">&quot;encode_language_tag&quot;</span>
        returns undef if given anything other than a formally valid language
        tag.</p>
    <p class="Pp">The reason
        <span class="Li">&quot;encode_language_tag&quot;</span> exists is
        because different language tags may represent the same language; this is
        normally treatable with
        <span class="Li">&quot;same_language_tag&quot;</span>, but consider this
        situation:</p>
    <p class="Pp">You have a data file that expresses greetings in different
        languages. Its format is &quot;[language tag]=[how to say
        'Hello']&quot;, like:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
          en-US=Hiho
          fr=Bonjour
          i-mingo=Hau'
    </pre>
    <p class="Pp">And suppose you write a program that reads that file and then
        runs as a daemon, answering client requests that specify a language tag
        and then expect the string that says how to greet in that language. So
        an interaction looks like:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
          greeting-client asks:    fr
          greeting-server answers: Bonjour
    </pre>
    <p class="Pp">So far so good. But suppose the way you're implementing this
        is:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
          my %greetings;
          die unless open(IN, &quot;&lt;in.dat&quot;);
          while(&lt;IN&gt;) {
            chomp;
            next unless /^([^=]+)=(.+)/s;
            my($lang, $expr) = ($1, $2);
            $greetings{$lang} = $expr;
          }
          close(IN);
    </pre>
    <p class="Pp">at which point <span class="Li">%greetings</span> has the
        contents:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
          &quot;en-US&quot;   =&gt; &quot;Hiho&quot;
          &quot;fr&quot;      =&gt; &quot;Bonjour&quot;
          &quot;i-mingo&quot; =&gt; &quot;Hau'&quot;
    </pre>
    <p class="Pp">And suppose then that you answer client requests for language
        <span class="Li">$wanted</span> by just looking up
        <span class="Li">$greetings</span>{$wanted}.</p>
    <p class="Pp">If the client asks for &quot;fr&quot;, that will look up
        successfully in <span class="Li">%greetings</span>, to the value
        &quot;Bonjour&quot;. And if the client asks for &quot;i-mingo&quot;,
        that will look up successfully in <span class="Li">%greetings</span>, to
        the value &quot;Hau'&quot;.</p>
    <p class="Pp">But if the client asks for &quot;i-Mingo&quot; or
        &quot;x-mingo&quot;, or &quot;Fr&quot;, then the lookup in
        <span class="Li">%greetings</span> fails. That's the Wrong Thing.</p>
    <p class="Pp">You could instead do lookups on
        <span class="Li">$wanted</span> with:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
          use I18N::LangTags qw(same_language_tag);
          my $response = '';
          foreach my $l2 (keys %greetings) {
            if(same_language_tag($wanted, $l2)) {
              $response = $greetings{$l2};
              last;
            }
          }
    </pre>
    <p class="Pp">But that's rather inefficient. A better way to do it is to
        start your program with:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
          use I18N::LangTags qw(encode_language_tag);
          my %greetings;
          die unless open(IN, &quot;&lt;in.dat&quot;);
          while(&lt;IN&gt;) {
            chomp;
            next unless /^([^=]+)=(.+)/s;
            my($lang, $expr) = ($1, $2);
            $greetings{
                        encode_language_tag($lang)
                      } = $expr;
          }
          close(IN);
    </pre>
    <p class="Pp">and then just answer client requests for language
        <span class="Li">$wanted</span> by just looking up</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
          $greetings{encode_language_tag($wanted)}
    </pre>
    <p class="Pp">And that does the Right Thing.</p>
  </li>
  <li>the function alternate_language_tags($lang1)
    <p class="Pp">This function, if given a language tag, returns all language
        tags that are alternate forms of this language tag. (I.e., tags which
        refer to the same language.) This is meant to handle legacy tags caused
        by the minor changes in language tag standards over the years; and the
        x-/i- alternation is also dealt with.</p>
    <p class="Pp">Note that this function does <i>not</i> try to equate new (and
        never-used, and unusable) ISO639-2 three-letter tags to old (and still
        in use) ISO639-1 two-letter equivalents -- like &quot;ara&quot; -&gt;
        &quot;ar&quot; -- because &quot;ara&quot; has <i>never</i> been in use
        as an Internet language tag, and RFC 3066 stipulates that it never
        should be, since a shorter tag (&quot;ar&quot;) exists.</p>
    <p class="Pp">Examples:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  alternate_language_tags('no-bok')       is ('nb')
  alternate_language_tags('nb')           is ('no-bok')
  alternate_language_tags('he')           is ('iw')
  alternate_language_tags('iw')           is ('he')
  alternate_language_tags('i-hakka')      is ('zh-hakka', 'x-hakka')
  alternate_language_tags('zh-hakka')     is ('i-hakka', 'x-hakka')
  alternate_language_tags('en')           is ()
  alternate_language_tags('x-mingo-tom')  is ('i-mingo-tom')
  alternate_language_tags('x-klikitat')   is ('i-klikitat')
  alternate_language_tags('i-klikitat')   is ('x-klikitat')
    </pre>
    <p class="Pp">This function returns empty-list if given anything other than
        a formally valid language tag.</p>
  </li>
  <li>the function <span class="Li">@langs</span> =
      panic_languages(@accept_languages)
    <p class="Pp">This function takes a list of 0 or more language tags that
        constitute a given user's Accept-Language list, and returns a list of
        tags for <i>other</i> (non-super) languages that are probably acceptable
        to the user, to be used <i>if all else fails</i>.</p>
    <p class="Pp">For example, if a user accepts only 'ca' (Catalan) and 'es'
        (Spanish), and the documents/interfaces you have available are just in
        German, Italian, and Chinese, then the user will most likely want the
        Italian one (and not the Chinese or German one!), instead of getting
        nothing. So <span class="Li">&quot;panic_languages('ca',
        'es')&quot;</span> returns a list containing 'it' (Italian).</p>
    <p class="Pp">English ('en') is <i>always</i> in the return list, but
        whether it's at the very end or not depends on the input languages. This
        function works by consulting an internal table that stipulates what
        common languages are &quot;close&quot; to each other.</p>
    <p class="Pp">A useful construct you might consider using is:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  @fallbacks = super_languages(@accept_languages);
  push @fallbacks, panic_languages(
    @accept_languages, @fallbacks,
  );
    </pre>
  </li>
  <li>the function implicate_supers( ...languages... )
    <p class="Pp">This takes a list of strings (which are presumed to be
        language-tags; strings that aren't, are ignored); and after each one,
        this function inserts super-ordinate forms that don't already appear in
        the list. The original list, plus these insertions, is returned.</p>
    <p class="Pp">In other words, it takes this:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  pt-br de-DE en-US fr pt-br-janeiro
    </pre>
    <p class="Pp">and returns this:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  pt-br pt de-DE de en-US en fr pt-br-janeiro
    </pre>
    <p class="Pp">This function is most useful in the idiom</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  implicate_supers( I18N::LangTags::Detect::detect() );
    </pre>
    <p class="Pp">(See I18N::LangTags::Detect.)</p>
  </li>
  <li>the function implicate_supers_strictly( ...languages... )
    <p class="Pp">This works like
        <span class="Li">&quot;implicate_supers&quot;</span> except that the
        implicated forms are added to the end of the return list.</p>
    <p class="Pp">In other words, implicate_supers_strictly takes a list of
        strings (which are presumed to be language-tags; strings that aren't,
        are ignored) and after the whole given list, it inserts the
        super-ordinate forms of all given tags, minus any tags that already
        appear in the input list.</p>
    <p class="Pp">In other words, it takes this:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  pt-br de-DE en-US fr pt-br-janeiro
    </pre>
    <p class="Pp">and returns this:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  pt-br de-DE en-US fr pt-br-janeiro pt de en
    </pre>
    <p class="Pp">The reason this function has &quot;_strictly&quot; in its name
        is that when you're processing an Accept-Language list according to the
        RFCs, if you interpret the RFCs quite strictly, then you would use
        implicate_supers_strictly, but for normal use (i.e., common-sense use,
        as far as I'm concerned) you'd use implicate_supers.</p>
  </li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="ABOUT_LOWERCASING"><a class="permalink" href="#ABOUT_LOWERCASING">ABOUT
  LOWERCASING</a></h1>
I've considered making all the above functions that output language tags return
  all those tags strictly in lowercase. Having all your language tags in
  lowercase does make some things easier. But you might as well just lowercase
  as you like, or call
  <span class="Li">&quot;encode_language_tag($lang1)&quot;</span> where
  appropriate.
</section>
<section class="Sh">
<h1 class="Sh" id="ABOUT_UNICODE_PLAINTEXT_LANGUAGE_TAGS"><a class="permalink" href="#ABOUT_UNICODE_PLAINTEXT_LANGUAGE_TAGS">ABOUT
  UNICODE PLAINTEXT LANGUAGE TAGS</a></h1>
In some future version of I18N::LangTags, I plan to include support for
  RFC2482-style language tags -- which are basically just normal language tags
  with their ASCII characters shifted into Plane 14.
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
* I18N::LangTags::List
<p class="Pp">* RFC 3066,
    <span class="Li">&quot;http://www.ietf.org/rfc/rfc3066.txt&quot;</span>,
    &quot;Tags for the Identification of Languages&quot;. (Obsoletes RFC
  1766)</p>
<p class="Pp">* RFC 2277,
    <span class="Li">&quot;http://www.ietf.org/rfc/rfc2277.txt&quot;</span>,
    &quot;IETF Policy on Character Sets and Languages&quot;.</p>
<p class="Pp">* RFC 2231,
    <span class="Li">&quot;http://www.ietf.org/rfc/rfc2231.txt&quot;</span>,
    &quot;MIME Parameter Value and Encoded Word Extensions: Character Sets,
    Languages, and Continuations&quot;.</p>
<p class="Pp">* RFC 2482,
    <span class="Li">&quot;http://www.ietf.org/rfc/rfc2482.txt&quot;</span>,
    &quot;Language Tagging in Unicode Plain Text&quot;.</p>
<p class="Pp">* Locale::Codes, in
    <span class="Li">&quot;http://www.perl.com/CPAN/modules/by-module/Locale/&quot;</span></p>
<p class="Pp">* ISO 639-2, &quot;Codes for the representation of names of
    languages&quot;, including two-letter and three-letter codes,
    <span class="Li">&quot;http://www.loc.gov/standards/iso639-2/php/code_list.php&quot;</span></p>
<p class="Pp">* The IANA list of registered languages (hopefully up-to-date),
    <span class="Li">&quot;http://www.iana.org/assignments/language-tags&quot;</span></p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT"><a class="permalink" href="#COPYRIGHT">COPYRIGHT</a></h1>
Copyright (c) 1998+ Sean M. Burke. All rights reserved.
<p class="Pp">This library is free software; you can redistribute it and/or
    modify it under the same terms as Perl itself.</p>
<p class="Pp">The programs and documentation in this dist are distributed in the
    hope that they will be useful, but without any warranty; without even the
    implied warranty of merchantability or fitness for a particular purpose.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
Sean M. Burke <span class="Li">&quot;sburke@cpan.org&quot;</span>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2014-09-30</td>
    <td class="foot-os">perl v5.18.4</td>
  </tr>
</table>
</body>
</html>
