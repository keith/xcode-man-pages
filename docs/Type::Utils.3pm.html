<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>Type::Utils(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Type::Utils(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Type::Utils(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
Type::Utils - utility functions to make defining and using type constraints a
  little easier
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<span class="Li"></span>
<pre>
   package Types::Mine;
   
   use Type::Library -base;
   use Type::Utils -all;
   
   BEGIN { extends &quot;Types::Standard&quot; };
   
   declare &quot;AllCaps&quot;,
      as &quot;Str&quot;,
      where { uc($_) eq $_ },
      inline_as { my $varname = $_[1]; &quot;uc($varname) eq $varname&quot; };
   
   coerce &quot;AllCaps&quot;,
      from &quot;Str&quot;, via { uc($_) };
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="STATUS"><a class="permalink" href="#STATUS">STATUS</a></h1>
This module is covered by the Type-Tiny stability policy.
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
This module provides utility functions to make defining and using type
  constraints a little easier.
<section class="Ss">
<h2 class="Ss" id="Type_declaration_functions"><a class="permalink" href="#Type_declaration_functions">Type
  declaration functions</a></h2>
Many of the following are similar to the similarly named functions described in
  Moose::Util::TypeConstraints.
<dl class="Bl-tag">
  <dt>&quot;declare $name, %options&quot;</dt>
  <dd></dd>
  <dt>&quot;declare %options&quot;</dt>
  <dd>Declare a named or anonymous type constraint. Use
      <span class="Li">&quot;as&quot;</span> and
      <span class="Li">&quot;where&quot;</span> to specify the parent type (if
      any) and (possibly) refine its definition.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
   declare EvenInt, as Int, where { $_ % 2 == 0 };

   my $EvenInt = declare as Int, where { $_ % 2 == 0 };
    </pre>
    <p class="Pp"><i>NOTE:</i> If the caller package inherits from Type::Library
        then any non-anonymous types declared in the package will be
        automatically installed into the library.</p>
    <p class="Pp">Hidden gem: if you're inheriting from a type constraint that
        includes some coercions, you can include <span class="Li">&quot;coercion
        =&gt; 1&quot;</span> in the <span class="Li">%options</span> hash to
        inherit the coercions.</p>
  </dd>
  <dt>&quot;subtype $name, %options&quot;</dt>
  <dd></dd>
  <dt>&quot;subtype %options&quot;</dt>
  <dd>Declare a named or anonymous type constraint which is descended from an
      existing type constraint. Use <span class="Li">&quot;as&quot;</span> and
      <span class="Li">&quot;where&quot;</span> to specify the parent type and
      refine its definition.
    <p class="Pp">Actually, you should use
        <span class="Li">&quot;declare&quot;</span> instead; this is just an
        alias.</p>
    <p class="Pp">This function is not exported by default.</p>
  </dd>
  <dt>&quot;type $name, %options&quot;</dt>
  <dd></dd>
  <dt>&quot;type %options&quot;</dt>
  <dd>Declare a named or anonymous type constraint which is not descended from
      an existing type constraint. Use <span class="Li">&quot;where&quot;</span>
      to provide a coderef that constrains values.
    <p class="Pp">Actually, you should use
        <span class="Li">&quot;declare&quot;</span> instead; this is just an
        alias.</p>
    <p class="Pp">This function is not exported by default.</p>
  </dd>
  <dt>&quot;as $parent&quot;</dt>
  <dd>Used with <span class="Li">&quot;declare&quot;</span> to specify a parent
      type constraint:
    <p class="Pp"><span class="Li"></span></p>
    <pre>
   declare EvenInt, as Int, where { $_ % 2 == 0 };
    </pre>
  </dd>
  <dt>&quot;where { BLOCK }&quot;</dt>
  <dd>Used with <span class="Li">&quot;declare&quot;</span> to provide the
      constraint coderef:
    <p class="Pp"><span class="Li"></span></p>
    <pre>
   declare EvenInt, as Int, where { $_ % 2 == 0 };
    </pre>
    <p class="Pp">The coderef operates on <span class="Li">$_</span>, which is
        the value being tested.</p>
  </dd>
  <dt>&quot;message { BLOCK }&quot;</dt>
  <dd>Generate a custom error message when a value fails validation.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
   declare EvenInt,
      as Int,
      where { $_ % 2 == 0 },
      message {
         Int-&gt;validate($_) or &quot;$_ is not divisible by two&quot;;
      };
    </pre>
    <p class="Pp">Without a custom message, the messages generated by Type::Tiny
        are along the lines of <i>Value &quot;33&quot; did not pass type
        constraint &quot;EvenInt&quot;</i>, which is usually reasonable.</p>
  </dd>
  <dt>&quot;inline_as { BLOCK }&quot;</dt>
  <dd>Generate a string of Perl code that can be used to inline the type check
      into other functions. If your type check is being used within a Moose or
      Moo constructor or accessor methods, or used by Type::Params, this can
      lead to significant performance improvements.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
   declare EvenInt,
      as Int,
      where { $_ % 2 == 0 },
      inline_as {
         my ($constraint, $varname) = @_;
         my $perlcode = 
            $constraint-&gt;parent-&gt;inline_check($varname)
            . &quot;&amp;&amp; ($varname % 2 == 0)&quot;;
         return $perlcode;
      };
   
   warn EvenInt-&gt;inline_check('$xxx');  # demonstration
    </pre>
    <p class="Pp">Your <span class="Li">&quot;inline_as&quot;</span> block can
        return a list, in which case these will be smushed together with
        &quot;&amp;&amp;&quot;. The first item on the list may be undef, in
        which case the undef will be replaced by the inlined parent type
        constraint. (And will throw an exception if there is no parent.)</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
   declare EvenInt,
      as Int,
      where { $_ % 2 == 0 },
      inline_as {
         return (undef, &quot;($_ % 2 == 0)&quot;);
      };
    </pre>
  </dd>
  <dt>&quot;class_type $name, { class =&gt; $package, %options }&quot;</dt>
  <dd></dd>
  <dt>&quot;class_type { class =&gt; $package, %options }&quot;</dt>
  <dd></dd>
  <dt>&quot;class_type $name&quot;</dt>
  <dd>Shortcut for declaring a Type::Tiny::Class type constraint.
    <p class="Pp">If <span class="Li">$package</span> is omitted, is assumed to
        be the same as <span class="Li">$name</span>. If
        <span class="Li">$name</span> contains &quot;::&quot; (which would be an
        invalid name as far as Type::Tiny is concerned), this will be
      removed.</p>
    <p class="Pp">So for example,
        <span class="Li">&quot;class_type(&quot;Foo::Bar&quot;)&quot;</span>
        declares a Type::Tiny::Class type constraint named &quot;FooBar&quot;
        which constrains values to objects blessed into the &quot;Foo::Bar&quot;
        package.</p>
  </dd>
  <dt>&quot;role_type $name, { role =&gt; $package, %options }&quot;</dt>
  <dd></dd>
  <dt>&quot;role_type { role =&gt; $package, %options }&quot;</dt>
  <dd></dd>
  <dt>&quot;role_type $name&quot;</dt>
  <dd>Shortcut for declaring a Type::Tiny::Role type constraint.
    <p class="Pp">If <span class="Li">$package</span> is omitted, is assumed to
        be the same as <span class="Li">$name</span>. If
        <span class="Li">$name</span> contains &quot;::&quot; (which would be an
        invalid name as far as Type::Tiny is concerned), this will be
      removed.</p>
  </dd>
  <dt>&quot;duck_type $name, \@methods&quot;</dt>
  <dd></dd>
  <dt>&quot;duck_type \@methods&quot;</dt>
  <dd>Shortcut for declaring a Type::Tiny::Duck type constraint.</dd>
  <dt>&quot;union $name, \@constraints&quot;</dt>
  <dd></dd>
  <dt>&quot;union \@constraints&quot;</dt>
  <dd>Shortcut for declaring a Type::Tiny::Union type constraint.</dd>
  <dt>&quot;enum $name, \@values&quot;</dt>
  <dd></dd>
  <dt>&quot;enum \@values&quot;</dt>
  <dd>Shortcut for declaring a Type::Tiny::Enum type constraint.</dd>
  <dt>&quot;intersection $name, \@constraints&quot;</dt>
  <dd></dd>
  <dt>&quot;intersection \@constraints&quot;</dt>
  <dd>Shortcut for declaring a Type::Tiny::Intersection type constraint.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Coercion_declaration_functions"><a class="permalink" href="#Coercion_declaration_functions">Coercion
  declaration functions</a></h2>
Many of the following are similar to the similarly named functions described in
  Moose::Util::TypeConstraints.
<dl class="Bl-tag">
  <dt>&quot;coerce $target, @coercions&quot;</dt>
  <dd>Add coercions to the target type constraint. The list of coercions is a
      list of type constraint, conversion code pairs. Conversion code can be
      either a string of Perl code or a coderef; in either case the value to be
      converted is <span class="Li">$_</span>.</dd>
  <dt>&quot;from $source&quot;</dt>
  <dd>Sugar to specify a type constraint in a list of coercions:
    <p class="Pp"><span class="Li"></span></p>
    <pre>
   coerce EvenInt, from Int, via { $_ * 2 };  # As a coderef...
   coerce EvenInt, from Int, q { $_ * 2 };    # or as a string!
    </pre>
  </dd>
  <dt>&quot;via { BLOCK }&quot;</dt>
  <dd>Sugar to specify a coderef in a list of coercions.</dd>
  <dt>&quot;declare_coercion $name, \%opts, $type1, $code1, ...&quot;</dt>
  <dd></dd>
  <dt>&quot;declare_coercion \%opts, $type1, $code1, ...&quot;</dt>
  <dd>Declares a coercion that is not explicitly attached to any type in the
      library. For example:
    <p class="Pp"><span class="Li"></span></p>
    <pre>
   declare_coercion &quot;ArrayRefFromAny&quot;, from &quot;Any&quot;, via { [$_] };
    </pre>
    <p class="Pp">This coercion will be exportable from the library as a
        Type::Coercion object, but the ArrayRef type exported by the library
        won't automatically use it.</p>
    <p class="Pp">Coercions declared this way are immutable (frozen).</p>
  </dd>
  <dt>&quot;to_type $type&quot;</dt>
  <dd>Used with <span class="Li">&quot;declare_coercion&quot;</span> to declare
      the target type constraint for a coercion, but still without explicitly
      attaching the coercion to the type constraint:
    <p class="Pp"><span class="Li"></span></p>
    <pre>
   declare_coercion &quot;ArrayRefFromAny&quot;,
      to_type &quot;ArrayRef&quot;,
      from &quot;Any&quot;, via { [$_] };
    </pre>
    <p class="Pp">You should pretty much always use this when declaring an
        unattached coercion because it's exceedingly useful for a type coercion
        to know what it will coerce to - this allows it to skip coercion when no
        coercion is needed (e.g. avoiding coercing
        <span class="Li">&quot;[]&quot;</span> to <span class="Li">&quot;[ []
        ]&quot;</span>) and allows
        <span class="Li">&quot;assert_coerce&quot;</span> to work properly.</p>
  </dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Type_library_management"><a class="permalink" href="#Type_library_management">Type
  library management</a></h2>
<dl class="Bl-tag">
  <dt>&quot;extends @libraries&quot;</dt>
  <dd>Indicates that this type library extends other type libraries, importing
      their type constraints.
    <p class="Pp">Should usually be executed in a
        <span class="Li">&quot;BEGIN&quot;</span> block.</p>
    <p class="Pp">This is not exported by default because it's not fun to export
        it to Moo, Moose or Mouse classes! <span class="Li">&quot;use
        Type::Utils -all&quot;</span> can be used to import it into your type
        library.</p>
  </dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Other"><a class="permalink" href="#Other">Other</a></h2>
<dl class="Bl-tag">
  <dt>&quot;match_on_type $value =&gt; ($type =&gt; \&amp;action, ...,
    \&amp;default?)&quot;</dt>
  <dd>Something like a
      <span class="Li">&quot;switch&quot;</span>/<span class="Li">&quot;case&quot;</span>
      or
      <span class="Li">&quot;given&quot;</span>/<span class="Li">&quot;when&quot;</span>
      construct. Dispatches along different code paths depending on the type of
      the incoming value. Example blatantly stolen from the Moose documentation:
    <p class="Pp"><span class="Li"></span></p>
    <pre>
   sub to_json
   {
      my $value = shift;
      
      return match_on_type $value =&gt; (
         HashRef() =&gt; sub {
            my $hash = shift;
            '{ '
               . (
               join &quot;, &quot; =&gt;
               map { '&quot;' . $_ . '&quot; : ' . to_json( $hash-&gt;{$_} ) }
               sort keys %$hash
            ) . ' }';
         },
         ArrayRef() =&gt; sub {
            my $array = shift;
            '[ '.( join &quot;, &quot; =&gt; map { to_json($_) } @$array ).' ]';
         },
         Num()   =&gt; q {$_},
         Str()   =&gt; q { '&quot;' . $_ . '&quot;' },
         Undef() =&gt; q {'null'},
         =&gt; sub { die &quot;$_ is not acceptable json type&quot; },
      );
   }
    </pre>
    <p class="Pp">Note that unlike Moose, code can be specified as a string
        instead of a coderef. (e.g. for <span class="Li">&quot;Num&quot;</span>,
        <span class="Li">&quot;Str&quot;</span> and
        <span class="Li">&quot;Undef&quot;</span> above.)</p>
    <p class="Pp">For improved performance, try
        <span class="Li">&quot;compile_match_on_type&quot;</span>.</p>
    <p class="Pp">This function is not exported by default.</p>
  </dd>
  <dt>&quot;my $coderef = compile_match_on_type($type =&gt; \&amp;action, ...,
    \&amp;default?)&quot;</dt>
  <dd>Compile a <span class="Li">&quot;match_on_type&quot;</span> block into a
      coderef. The following JSON converter is about two orders of magnitude
      faster than the previous example:
    <p class="Pp"><span class="Li"></span></p>
    <pre>
   sub to_json;
   *to_json = compile_match_on_type(
      HashRef() =&gt; sub {
         my $hash = shift;
         '{ '
            . (
            join &quot;, &quot; =&gt;
            map { '&quot;' . $_ . '&quot; : ' . to_json( $hash-&gt;{$_} ) }
            sort keys %$hash
         ) . ' }';
      },
      ArrayRef() =&gt; sub {
         my $array = shift;
         '[ '.( join &quot;, &quot; =&gt; map { to_json($_) } @$array ).' ]';
      },
      Num()   =&gt; q {$_},
      Str()   =&gt; q { '&quot;' . $_ . '&quot;' },
      Undef() =&gt; q {'null'},
      =&gt; sub { die &quot;$_ is not acceptable json type&quot; },
   );
    </pre>
    <p class="Pp">Remember to store the coderef somewhere fairly permanent so
        that you don't compile it over and over.
        <span class="Li">&quot;state&quot;</span> variables (in Perl &gt;= 5.10)
        are good for this. (Same sort of idea as Type::Params.)</p>
    <p class="Pp">This function is not exported by default.</p>
  </dd>
  <dt>&quot;my $coderef = classifier(@types)&quot;</dt>
  <dd>Returns a coderef that can be used to classify values according to their
      type constraint. The coderef, when passed a value, returns a type
      constraint which the value satisfies.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
   use feature qw( say );
   use Type::Utils qw( classifier );
   use Types::Standard qw( Int Num Str Any );
   
   my $classifier = classifier(Str, Int, Num, Any);
   
   say $classifier-&gt;( &quot;42&quot;  )-&gt;name;   # Int
   say $classifier-&gt;( &quot;4.2&quot; )-&gt;name;   # Num
   say $classifier-&gt;( []    )-&gt;name;   # Any
    </pre>
    <p class="Pp">Note that, for example, &quot;42&quot; satisfies Int, but it
        would satisfy the type constraints Num, Str, and Any as well. In this
        case, the classifier has picked the most specific type constraint that
        &quot;42&quot; satisfies.</p>
    <p class="Pp">If no type constraint is satisfied by the value, then the
        classifier will return undef.</p>
  </dd>
  <dt>&quot;dwim_type($string, %options)&quot;</dt>
  <dd>Given a string like &quot;ArrayRef[Int|CodeRef]&quot;, turns it into a
      type constraint object, hopefully doing what you mean.
    <p class="Pp">It uses the syntax of Type::Parser. Firstly the Type::Registry
        for the caller package is consulted; if that doesn't have a match,
        Types::Standard is consulted for standard type constraint names.</p>
    <p class="Pp">If none of the above yields a type constraint, and the caller
        class is a Moose-based class, then
        <span class="Li">&quot;dwim_type&quot;</span> attempts to look the type
        constraint up in the Moose type registry. If it's a Mouse-based class,
        then the Mouse type registry is used instead.</p>
    <p class="Pp">If no type constraint can be found via these normal methods,
        several fallbacks are available:</p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>&quot;lookup_via_moose&quot;</dt>
  <dd>Lookup in Moose registry even if caller is non-Moose class.</dd>
  <dt>&quot;lookup_via_mouse&quot;</dt>
  <dd>Lookup in Mouse registry even if caller is non-Mouse class.</dd>
  <dt>&quot;make_class_type&quot;</dt>
  <dd>Create a new Type::Tiny::Class constraint.</dd>
  <dt>&quot;make_role_type&quot;</dt>
  <dd>Create a new Type::Tiny::Role constraint.</dd>
</dl>
</div>
<div class="Bd-indent">
<p class="Pp">You can alter which should be attempted, and in which order, by
    passing an option to <span class="Li">&quot;dwim_type&quot;</span>:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
   my $type = Type::Utils::dwim_type(
      &quot;ArrayRef[Int]&quot;,
      fallback      =&gt; [ &quot;lookup_via_mouse&quot; , &quot;make_role_type&quot; ],
   );
</pre>
<p class="Pp">For historical reasons, by default the fallbacks attempted
  are:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
   lookup_via_moose, lookup_via_mouse, make_class_type
</pre>
<p class="Pp">You may set <span class="Li">&quot;fallback&quot;</span> to an
    empty arrayref to avoid using any of these fallbacks.</p>
<p class="Pp">You can specify an alternative for the caller using the
    <span class="Li">&quot;for&quot;</span> option.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
   my $type = dwim_type(&quot;ArrayRef&quot;, for =&gt; &quot;Moose::Object&quot;);
</pre>
<p class="Pp">While it's probably better overall to use the proper
    Type::Registry interface for resolving type constraint strings, this
    function often does what you want.</p>
<p class="Pp">It should never die if it fails to find a type constraint (but may
    die if the type constraint string is syntactically malformed), preferring to
    return undef.</p>
<p class="Pp">This function is not exported by default.</p>
</div>
<dl class="Bl-tag">
  <dt>&quot;is($type, $value)&quot;</dt>
  <dd>Shortcut for <span class="Li">&quot;$type-&gt;check($value)&quot;</span>
      but also if <span class="Li">$type</span> is a string, will look it up via
      <span class="Li">&quot;dwim_type&quot;</span>.
    <p class="Pp">This function is not exported by default. This function is not
        even exported by <span class="Li">&quot;use Type::Utils
        -all&quot;</span>. You must request it explicitly.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  use Type::Utils &quot;is&quot;;
    </pre>
    <p class="Pp">Beware using this in test scripts because it has the same name
        as a function exported by Test::More. Note that you can rename this
        function if <span class="Li">&quot;is&quot;</span> will cause
      conflicts:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
   use Type::Utils &quot;is&quot; =&gt; { -as =&gt; &quot;isntnt&quot; };
    </pre>
  </dd>
  <dt>&quot;assert($type, $value)&quot;</dt>
  <dd>Like <span class="Li">&quot;is&quot;</span> but instead of returning a
      boolean, returns <span class="Li">$value</span> and dies if the value
      fails the type check.
    <p class="Pp">This function is not exported by default, but it is exported
        by <span class="Li">&quot;use Type::Utils -all&quot;</span>.</p>
  </dd>
  <dt>&quot;english_list(\$conjunction, @items)&quot;</dt>
  <dd>Joins the items with commas, placing a conjunction before the final item.
      The conjunction is optional, defaulting to &quot;and&quot;.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
   english_list(qw/foo bar baz/);       # &quot;foo, bar, and baz&quot;
   english_list(\&quot;or&quot;, qw/quux quuux/); # &quot;quux or quuux&quot;
    </pre>
    <p class="Pp">This function is not exported by default.</p>
  </dd>
</dl>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="EXPORT"><a class="permalink" href="#EXPORT">EXPORT</a></h1>
By default, all of the functions documented above are exported, except
  <span class="Li">&quot;subtype&quot;</span> and
  <span class="Li">&quot;type&quot;</span> (prefer
  <span class="Li">&quot;declare&quot;</span> instead),
  <span class="Li">&quot;extends&quot;</span>,
  <span class="Li">&quot;dwim_type&quot;</span>,
  <span class="Li">&quot;match_on_type&quot;</span>/<span class="Li">&quot;compile_match_on_type&quot;</span>,
  <span class="Li">&quot;classifier&quot;</span>, and
  <span class="Li">&quot;english_list&quot;</span>.
<p class="Pp">This module uses Exporter::Tiny; see the documentation of that
    module for tips and tricks importing from Type::Utils.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="BUGS"><a class="permalink" href="#BUGS">BUGS</a></h1>
Please report any bugs to
  &lt;http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny&gt;.
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
Type::Tiny::Manual.
<p class="Pp">Type::Tiny, Type::Library, Types::Standard, Type::Coercion.</p>
<p class="Pp">Type::Tiny::Class, Type::Tiny::Role, Type::Tiny::Duck,
    Type::Tiny::Enum, Type::Tiny::Union.</p>
<p class="Pp">Moose::Util::TypeConstraints, Mouse::Util::TypeConstraints.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
Toby Inkster &lt;tobyink@cpan.org&gt;.
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT_AND_LICENCE"><a class="permalink" href="#COPYRIGHT_AND_LICENCE">COPYRIGHT
  AND LICENCE</a></h1>
This software is copyright (c) 2013-2014, 2017-2020 by Toby Inkster.
<p class="Pp">This is free software; you can redistribute it and/or modify it
    under the same terms as the Perl 5 programming language system itself.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DISCLAIMER_OF_WARRANTIES"><a class="permalink" href="#DISCLAIMER_OF_WARRANTIES">DISCLAIMER
  OF WARRANTIES</a></h1>
THIS PACKAGE IS PROVIDED &quot;AS IS&quot; AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2020-10-28</td>
    <td class="foot-os">perl v5.30.2</td>
  </tr>
</table>
</body>
</html>
