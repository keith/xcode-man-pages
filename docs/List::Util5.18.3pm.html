<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>List::Util(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">List::Util(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">List::Util(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
List::Util - A selection of general-utility list subroutines
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<span class="Li"></span>
<pre>
    use List::Util qw(first max maxstr min minstr reduce shuffle sum);
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<span class="Li">&quot;List::Util&quot;</span> contains a selection of
  subroutines that people have expressed would be nice to have in the perl core,
  but the usage would not really be high enough to warrant the use of a keyword,
  and the size so small such that being individual extensions would be wasteful.
<p class="Pp">By default <span class="Li">&quot;List::Util&quot;</span> does not
    export any subroutines.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="LIST-REDUCTION_FUNCTIONS"><a class="permalink" href="#LIST-REDUCTION_FUNCTIONS">LIST-REDUCTION
  FUNCTIONS</a></h1>
The following set of functions all reduce a list down to a single value.
<section class="Ss">
<h2 class="Ss" id="$result_=_reduce____s-1BLOCK__s0__@list"><a class="permalink" href="#$result_=_reduce____s-1BLOCK__s0__@list">$result
  = reduce { BLOCK } @list</a></h2>
Reduces <span class="Li">@list</span> by calling
  <span class="Li">&quot;BLOCK&quot;</span> in a scalar context multiple times,
  setting <span class="Li">$a</span> and <span class="Li">$b</span> each time.
  The first call will be with <span class="Li">$a</span> and
  <span class="Li">$b</span> set to the first two elements of the list,
  subsequent calls will be done by setting <span class="Li">$a</span> to the
  result of the previous call and <span class="Li">$b</span> to the next element
  in the list.
<p class="Pp">Returns the result of the last call to the
    <span class="Li">&quot;BLOCK&quot;</span>. If <span class="Li">@list</span>
    is empty then <span class="Li">&quot;undef&quot;</span> is returned. If
    <span class="Li">@list</span> only contains one element then that element is
    returned and <span class="Li">&quot;BLOCK&quot;</span> is not executed.</p>
<p class="Pp">The following examples all demonstrate how
    <span class="Li">&quot;reduce&quot;</span> could be used to implement the
    other list-reduction functions in this module. (They are not in fact
    implemented like this, but instead in a more efficient manner in individual
    C functions).</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    $foo = reduce { defined($a)            ? $a :
                    $code-&gt;(local $_ = $b) ? $b :
                                             undef } undef, @list # first

    $foo = reduce { $a &gt; $b ? $a : $b } 1..10       # max
    $foo = reduce { $a gt $b ? $a : $b } 'A'..'Z'   # maxstr
    $foo = reduce { $a &lt; $b ? $a : $b } 1..10       # min
    $foo = reduce { $a lt $b ? $a : $b } 'aa'..'zz' # minstr
    $foo = reduce { $a + $b } 1 .. 10               # sum
    $foo = reduce { $a . $b } @bar                  # concat

    $foo = reduce { $a || $code-&gt;(local $_ = $b) } 0, @bar   # any
    $foo = reduce { $a &amp;&amp; $code-&gt;(local $_ = $b) } 1, @bar   # all
    $foo = reduce { $a &amp;&amp; !$code-&gt;(local $_ = $b) } 1, @bar  # none
    $foo = reduce { $a || !$code-&gt;(local $_ = $b) } 0, @bar  # notall
       # Note that these implementations do not fully short-circuit
</pre>
<p class="Pp">If your algorithm requires that
    <span class="Li">&quot;reduce&quot;</span> produce an identity value, then
    make sure that you always pass that identity value as the first argument to
    prevent <span class="Li">&quot;undef&quot;</span> being returned</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  $foo = reduce { $a + $b } 0, @values;             # sum with 0 identity value
</pre>
<p class="Pp">The remaining list-reduction functions are all specialisations of
    this generic idea.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="$b_=_any____s-1BLOCK__s0__@list"><a class="permalink" href="#$b_=_any____s-1BLOCK__s0__@list">$b
  = any { BLOCK } @list</a></h2>
Similar to <span class="Li">&quot;grep&quot;</span> in that it evaluates
  <span class="Li">&quot;BLOCK&quot;</span> setting <span class="Li">$_</span>
  to each element of <span class="Li">@list</span> in turn.
  <span class="Li">&quot;any&quot;</span> returns true if any element makes the
  <span class="Li">&quot;BLOCK&quot;</span> return a true value. If
  <span class="Li">&quot;BLOCK&quot;</span> never returns true or
  <span class="Li">@list</span> was empty then it returns false.
<p class="Pp">Many cases of using <span class="Li">&quot;grep&quot;</span> in a
    conditional can be written using <span class="Li">&quot;any&quot;</span>
    instead, as it can short-circuit after the first true result.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    if( any { length &gt; 10 } @strings ) {
        # at least one string has more than 10 characters
    }
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="$b_=_all____s-1BLOCK__s0__@list"><a class="permalink" href="#$b_=_all____s-1BLOCK__s0__@list">$b
  = all { BLOCK } @list</a></h2>
Similar to <span class="Li">&quot;any&quot;</span>, except that it requires all
  elements of the <span class="Li">@list</span> to make the
  <span class="Li">&quot;BLOCK&quot;</span> return true. If any element returns
  false, then it returns false. If the <span class="Li">&quot;BLOCK&quot;</span>
  never returns false or the <span class="Li">@list</span> was empty then it
  returns true.
</section>
<section class="Ss">
<h2 class="Ss" id="$b_=_none____s-1BLOCK__s0__@list"><a class="permalink" href="#$b_=_none____s-1BLOCK__s0__@list">$b
  = none { BLOCK } @list</a></h2>
</section>
<section class="Ss">
<h2 class="Ss" id="$b_=_notall____s-1BLOCK__s0__@list"><a class="permalink" href="#$b_=_notall____s-1BLOCK__s0__@list">$b
  = notall { BLOCK } @list</a></h2>
Similar to <span class="Li">&quot;any&quot;</span> and
  <span class="Li">&quot;all&quot;</span>, but with the return sense inverted.
  <span class="Li">&quot;none&quot;</span> returns true only if no value in the
  LIST causes the BLOCK to return true, and
  <span class="Li">&quot;notall&quot;</span> returns true only if not all of the
  values do.
</section>
<section class="Ss">
<h2 class="Ss" id="$val_=_first____s-1BLOCK__s0__@list"><a class="permalink" href="#$val_=_first____s-1BLOCK__s0__@list">$val
  = first { BLOCK } @list</a></h2>
Similar to <span class="Li">&quot;grep&quot;</span> in that it evaluates
  <span class="Li">&quot;BLOCK&quot;</span> setting <span class="Li">$_</span>
  to each element of <span class="Li">@list</span> in turn.
  <span class="Li">&quot;first&quot;</span> returns the first element where the
  result from <span class="Li">&quot;BLOCK&quot;</span> is a true value. If
  <span class="Li">&quot;BLOCK&quot;</span> never returns true or
  <span class="Li">@list</span> was empty then
  <span class="Li">&quot;undef&quot;</span> is returned.
<p class="Pp"><span class="Li"></span></p>
<pre>
    $foo = first { defined($_) } @list    # first defined value in @list
    $foo = first { $_ &gt; $value } @list    # first value in @list which
                                          # is greater than $value
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="$num_=_max_@list"><a class="permalink" href="#$num_=_max_@list">$num
  = max @list</a></h2>
Returns the entry in the list with the highest numerical value. If the list is
  empty then <span class="Li">&quot;undef&quot;</span> is returned.
<p class="Pp"><span class="Li"></span></p>
<pre>
    $foo = max 1..10                # 10
    $foo = max 3,9,12               # 12
    $foo = max @bar, @baz           # whatever
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="$str_=_maxstr_@list"><a class="permalink" href="#$str_=_maxstr_@list">$str
  = maxstr @list</a></h2>
Similar to <span class="Li">&quot;max&quot;</span>, but treats all the entries
  in the list as strings and returns the highest string as defined by the
  <span class="Li">&quot;gt&quot;</span> operator. If the list is empty then
  <span class="Li">&quot;undef&quot;</span> is returned.
<p class="Pp"><span class="Li"></span></p>
<pre>
    $foo = maxstr 'A'..'Z'          # 'Z'
    $foo = maxstr &quot;hello&quot;,&quot;world&quot;   # &quot;world&quot;
    $foo = maxstr @bar, @baz        # whatever
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="$num_=_min_@list"><a class="permalink" href="#$num_=_min_@list">$num
  = min @list</a></h2>
Similar to <span class="Li">&quot;max&quot;</span> but returns the entry in the
  list with the lowest numerical value. If the list is empty then
  <span class="Li">&quot;undef&quot;</span> is returned.
<p class="Pp"><span class="Li"></span></p>
<pre>
    $foo = min 1..10                # 1
    $foo = min 3,9,12               # 3
    $foo = min @bar, @baz           # whatever
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="$str_=_minstr_@list"><a class="permalink" href="#$str_=_minstr_@list">$str
  = minstr @list</a></h2>
Similar to <span class="Li">&quot;min&quot;</span>, but treats all the entries
  in the list as strings and returns the lowest string as defined by the
  <span class="Li">&quot;lt&quot;</span> operator. If the list is empty then
  <span class="Li">&quot;undef&quot;</span> is returned.
<p class="Pp"><span class="Li"></span></p>
<pre>
    $foo = minstr 'A'..'Z'          # 'A'
    $foo = minstr &quot;hello&quot;,&quot;world&quot;   # &quot;hello&quot;
    $foo = minstr @bar, @baz        # whatever
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="$num_=_product_@list"><a class="permalink" href="#$num_=_product_@list">$num
  = product @list</a></h2>
Returns the numerical product of all the elements in
  <span class="Li">@list</span>. If <span class="Li">@list</span> is empty then
  <span class="Li">1</span> is returned.
<p class="Pp"><span class="Li"></span></p>
<pre>
    $foo = product 1..10            # 3628800
    $foo = product 3,9,12           # 324
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="$num_or_undef_=_sum_@list"><a class="permalink" href="#$num_or_undef_=_sum_@list">$num_or_undef
  = sum @list</a></h2>
Returns the numerical sum of all the elements in <span class="Li">@list</span>.
  For backwards compatibility, if <span class="Li">@list</span> is empty then
  <span class="Li">&quot;undef&quot;</span> is returned.
<p class="Pp"><span class="Li"></span></p>
<pre>
    $foo = sum 1..10                # 55
    $foo = sum 3,9,12               # 24
    $foo = sum @bar, @baz           # whatever
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="$num_=_sum0_@list"><a class="permalink" href="#$num_=_sum0_@list">$num
  = sum0 @list</a></h2>
Similar to <span class="Li">&quot;sum&quot;</span>, except this returns 0 when
  given an empty list, rather than <span class="Li">&quot;undef&quot;</span>.
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="KEY/VALUE_PAIR_LIST_FUNCTIONS"><a class="permalink" href="#KEY/VALUE_PAIR_LIST_FUNCTIONS">KEY/VALUE
  PAIR LIST FUNCTIONS</a></h1>
The following set of functions, all inspired by List::Pairwise, consume an
  even-sized list of pairs. The pairs may be key/value associations from a hash,
  or just a list of values. The functions will all preserve the original
  ordering of the pairs, and will not be confused by multiple pairs having the
  same &quot;key&quot; value - nor even do they require that the first of each
  pair be a plain string.
<section class="Ss">
<h2 class="Ss" id="@kvlist_=_pairgrep____s-1BLOCK__s0__@kvlist"><a class="permalink" href="#@kvlist_=_pairgrep____s-1BLOCK__s0__@kvlist">@kvlist
  = pairgrep { BLOCK } @kvlist</a></h2>
</section>
<section class="Ss">
<h2 class="Ss" id="$count_=_pairgrep____s-1BLOCK__s0__@kvlist"><a class="permalink" href="#$count_=_pairgrep____s-1BLOCK__s0__@kvlist">$count
  = pairgrep { BLOCK } @kvlist</a></h2>
Similar to perl's <span class="Li">&quot;grep&quot;</span> keyword, but
  interprets the given list as an even-sized list of pairs. It invokes the
  <span class="Li">&quot;BLOCK&quot;</span> multiple times, in scalar context,
  with <span class="Li">$a</span> and <span class="Li">$b</span> set to
  successive pairs of values from the <span class="Li">@kvlist</span>.
<p class="Pp">Returns an even-sized list of those pairs for which the
    <span class="Li">&quot;BLOCK&quot;</span> returned true in list context, or
    the count of the <b>number of pairs</b> in scalar context. (Note, therefore,
    in scalar context that it returns a number half the size of the count of
    items it would have returned in list context).</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    @subset = pairgrep { $a =~ m/^[[:upper:]]+$/ } @kvlist
</pre>
<p class="Pp">As with <span class="Li">&quot;grep&quot;</span> aliasing
    <span class="Li">$_</span> to list elements,
    <span class="Li">&quot;pairgrep&quot;</span> aliases
    <span class="Li">$a</span> and <span class="Li">$b</span> to elements of the
    given list. Any modifications of it by the code block will be visible to the
    caller.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="(_$key,_$val_)_=_pairfirst____s-1BLOCK__s0__@kvlist"><a class="permalink" href="#(_$key,_$val_)_=_pairfirst____s-1BLOCK__s0__@kvlist">(
  $key, $val ) = pairfirst { BLOCK } @kvlist</a></h2>
</section>
<section class="Ss">
<h2 class="Ss" id="$found_=_pairfirst____s-1BLOCK__s0__@kvlist"><a class="permalink" href="#$found_=_pairfirst____s-1BLOCK__s0__@kvlist">$found
  = pairfirst { BLOCK } @kvlist</a></h2>
Similar to the <span class="Li">&quot;first&quot;</span> function, but
  interprets the given list as an even-sized list of pairs. It invokes the
  <span class="Li">&quot;BLOCK&quot;</span> multiple times, in scalar context,
  with <span class="Li">$a</span> and <span class="Li">$b</span> set to
  successive pairs of values from the <span class="Li">@kvlist</span>.
<p class="Pp">Returns the first pair of values from the list for which the
    <span class="Li">&quot;BLOCK&quot;</span> returned true in list context, or
    an empty list of no such pair was found. In scalar context it returns a
    simple boolean value, rather than either the key or the value found.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    ( $key, $value ) = pairfirst { $a =~ m/^[[:upper:]]+$/ } @kvlist
</pre>
<p class="Pp">As with <span class="Li">&quot;grep&quot;</span> aliasing
    <span class="Li">$_</span> to list elements,
    <span class="Li">&quot;pairfirst&quot;</span> aliases
    <span class="Li">$a</span> and <span class="Li">$b</span> to elements of the
    given list. Any modifications of it by the code block will be visible to the
    caller.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="@list_=_pairmap____s-1BLOCK__s0__@kvlist"><a class="permalink" href="#@list_=_pairmap____s-1BLOCK__s0__@kvlist">@list
  = pairmap { BLOCK } @kvlist</a></h2>
</section>
<section class="Ss">
<h2 class="Ss" id="$count_=_pairmap____s-1BLOCK__s0__@kvlist"><a class="permalink" href="#$count_=_pairmap____s-1BLOCK__s0__@kvlist">$count
  = pairmap { BLOCK } @kvlist</a></h2>
Similar to perl's <span class="Li">&quot;map&quot;</span> keyword, but
  interprets the given list as an even-sized list of pairs. It invokes the
  <span class="Li">&quot;BLOCK&quot;</span> multiple times, in list context,
  with <span class="Li">$a</span> and <span class="Li">$b</span> set to
  successive pairs of values from the <span class="Li">@kvlist</span>.
<p class="Pp">Returns the concatenation of all the values returned by the
    <span class="Li">&quot;BLOCK&quot;</span> in list context, or the count of
    the number of items that would have been returned in scalar context.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    @result = pairmap { &quot;The key $a has value $b&quot; } @kvlist
</pre>
<p class="Pp">As with <span class="Li">&quot;map&quot;</span> aliasing
    <span class="Li">$_</span> to list elements,
    <span class="Li">&quot;pairmap&quot;</span> aliases
    <span class="Li">$a</span> and <span class="Li">$b</span> to elements of the
    given list. Any modifications of it by the code block will be visible to the
    caller.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="@pairs_=_pairs_@kvlist"><a class="permalink" href="#@pairs_=_pairs_@kvlist">@pairs
  = pairs @kvlist</a></h2>
A convenient shortcut to operating on even-sized lists of pairs, this function
  returns a list of ARRAY references, each containing two items from the given
  list. It is a more efficient version of
<p class="Pp"><span class="Li"></span></p>
<pre>
    @pairs = pairmap { [ $a, $b ] } @kvlist
</pre>
<p class="Pp">It is most convenient to use in a
    <span class="Li">&quot;foreach&quot;</span> loop, for example:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    foreach ( pairs @KVLIST ) {
       my ( $key, $value ) = @$_;
       ...
    }
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="@keys_=_pairkeys_@kvlist"><a class="permalink" href="#@keys_=_pairkeys_@kvlist">@keys
  = pairkeys @kvlist</a></h2>
A convenient shortcut to operating on even-sized lists of pairs, this function
  returns a list of the the first values of each of the pairs in the given list.
  It is a more efficient version of
<p class="Pp"><span class="Li"></span></p>
<pre>
    @keys = pairmap { $a } @kvlist
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="@values_=_pairvalues_@kvlist"><a class="permalink" href="#@values_=_pairvalues_@kvlist">@values
  = pairvalues @kvlist</a></h2>
A convenient shortcut to operating on even-sized lists of pairs, this function
  returns a list of the the second values of each of the pairs in the given
  list. It is a more efficient version of
<p class="Pp"><span class="Li"></span></p>
<pre>
    @values = pairmap { $b } @kvlist
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="OTHER_FUNCTIONS"><a class="permalink" href="#OTHER_FUNCTIONS">OTHER
  FUNCTIONS</a></h1>
<section class="Ss">
<h2 class="Ss" id="@values_=_shuffle_@values"><a class="permalink" href="#@values_=_shuffle_@values">@values
  = shuffle @values</a></h2>
Returns the values of the input in a random order
<p class="Pp"><span class="Li"></span></p>
<pre>
    @cards = shuffle 0..51      # 0..51 in a random order
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="KNOWN_BUGS"><a class="permalink" href="#KNOWN_BUGS">KNOWN
  BUGS</a></h1>
With perl versions prior to 5.005 there are some cases where reduce will return
  an incorrect result. This will show up as test 7 of reduce.t failing.
</section>
<section class="Sh">
<h1 class="Sh" id="SUGGESTED_ADDITIONS"><a class="permalink" href="#SUGGESTED_ADDITIONS">SUGGESTED
  ADDITIONS</a></h1>
The following are additions that have been requested, but I have been reluctant
  to add due to them being very simple to implement in perl
<p class="Pp"><span class="Li"></span></p>
<pre>
  # How many elements are true

  sub true { scalar grep { $_ } @_ }

  # How many elements are false

  sub false { scalar grep { !$_ } @_ }
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
Scalar::Util, List::MoreUtils
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT"><a class="permalink" href="#COPYRIGHT">COPYRIGHT</a></h1>
Copyright (c) 1997-2007 Graham Barr &lt;gbarr@pobox.com&gt;. All rights
  reserved. This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
<p class="Pp">Recent additions and current maintenance by Paul Evans,
    &lt;leonerd@leonerd.org.uk&gt;.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2014-01-22</td>
    <td class="foot-os">perl v5.18.4</td>
  </tr>
</table>
</body>
</html>
