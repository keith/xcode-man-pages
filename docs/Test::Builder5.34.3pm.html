<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    .Nd, .Bf, .Op { display: inline; }
    .Pa, .Ad { font-style: italic; }
    .Ms { font-weight: bold; }
    .Bl-diag > dt { font-weight: bold; }
    code.Nm, .Fl, .Cm, .Ic, code.In, .Fd, .Fn, .Cd { font-weight: bold;
      font-family: inherit; }
  </style>
  <title>Test::Builder(3pm)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Test::Builder(3pm)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">Test::Builder(3pm)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Test::Builder - Backend for building test libraries</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>  package My::Test::Module;
  use base 'Test::Builder::Module';
  my $CLASS = __PACKAGE__;
  sub ok {
      my($test, $name) = @_;
      my $tb = $CLASS-&gt;builder;
      $tb-&gt;ok($test, $name);
  }
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">Test::Simple and Test::More have proven to be popular testing
    modules, but they're not always flexible enough. Test::Builder provides a
    building block upon which to write your own test libraries <i>which can</i>
    <i>work together</i>.</p>
<section class="Ss">
<h2 class="Ss" id="Construction"><a class="permalink" href="#Construction">Construction</a></h2>
<dl class="Bl-tag">
  <dt id="new"><a class="permalink" href="#new"><b>new</b></a></dt>
  <dd>
    <pre>  my $Test = Test::Builder-&gt;new;
    </pre>
    <p class="Pp">Returns a Test::Builder object representing the current state
        of the test.</p>
    <p class="Pp">Since you only run one test per program
        <span class="Li">&quot;new&quot;</span> always returns the same
        Test::Builder object. No matter how many times you call
        <span class="Li">&quot;new()&quot;</span>, you're getting the same
        object. This is called a singleton. This is done so that multiple
        modules share such global information as the test counter and where test
        output is going.</p>
    <p class="Pp">If you want a completely new Test::Builder object different
        from the singleton, use <span class="Li">&quot;create&quot;</span>.</p>
  </dd>
  <dt id="create"><a class="permalink" href="#create"><b>create</b></a></dt>
  <dd>
    <pre>  my $Test = Test::Builder-&gt;create;
    </pre>
    <p class="Pp">Ok, so there can be more than one Test::Builder object and
        this is how you get it. You might use this instead of
        <span class="Li">&quot;new()&quot;</span> if you're testing a
        Test::Builder based module, but otherwise you probably want
        <span class="Li">&quot;new&quot;</span>.</p>
    <p class="Pp"><b>NOTE</b>: the implementation is not complete.
        <span class="Li">&quot;level&quot;</span>, for example, is still shared
        by <b>all</b> Test::Builder objects, even ones created using this
        method. Also, the method name may change in the future.</p>
  </dd>
  <dt id="subtest"><a class="permalink" href="#subtest"><b>subtest</b></a></dt>
  <dd>
    <pre>    $builder-&gt;subtest($name, \&amp;subtests, @args);
    </pre>
    <p class="Pp">See documentation of
        <span class="Li">&quot;subtest&quot;</span> in Test::More.</p>
    <p class="Pp"><span class="Li">&quot;subtest&quot;</span> also, and
        optionally, accepts arguments which will be passed to the subtests
        reference.</p>
  </dd>
  <dt id="name"><a class="permalink" href="#name"><b>name</b></a></dt>
  <dd>
    <pre> diag $builder-&gt;name;
    </pre>
    <p class="Pp">Returns the name of the current builder. Top level builders
        default to <span class="Li">$0</span> (the name of the executable).
        Child builders are named via the
        <span class="Li">&quot;child&quot;</span> method. If no name is
        supplied, will be named &quot;Child of
        <span class="Li">$parent</span>-&gt;name&quot;.</p>
  </dd>
  <dt id="reset"><a class="permalink" href="#reset"><b>reset</b></a></dt>
  <dd>
    <pre>  $Test-&gt;reset;
    </pre>
    <p class="Pp">Reinitializes the Test::Builder singleton to its original
        state. Mostly useful for tests run in persistent environments where the
        same test might be run multiple times in the same process.</p>
  </dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Setting_up_tests"><a class="permalink" href="#Setting_up_tests">Setting
  up tests</a></h2>
<p class="Pp">These methods are for setting up tests and declaring how many
    there are. You usually only want to call one of these methods.</p>
<dl class="Bl-tag">
  <dt id="plan"><a class="permalink" href="#plan"><b>plan</b></a></dt>
  <dd>
    <pre>  $Test-&gt;plan('no_plan');
  $Test-&gt;plan( skip_all =&gt; $reason );
  $Test-&gt;plan( tests =&gt; $num_tests );
    </pre>
    <p class="Pp">A convenient way to set up your tests. Call this and
        Test::Builder will print the appropriate headers and take the
        appropriate actions.</p>
    <p class="Pp">If you call <span class="Li">&quot;plan()&quot;</span>, don't
        call any of the other methods below.</p>
  </dd>
  <dt id="expected_tests"><a class="permalink" href="#expected_tests"><b>expected_tests</b></a></dt>
  <dd>
    <pre>    my $max = $Test-&gt;expected_tests;
    $Test-&gt;expected_tests($max);
    </pre>
    <p class="Pp">Gets/sets the number of tests we expect this test to run and
        prints out the appropriate headers.</p>
  </dd>
  <dt id="no_plan"><a class="permalink" href="#no_plan"><b>no_plan</b></a></dt>
  <dd>
    <pre>  $Test-&gt;no_plan;
    </pre>
    <p class="Pp">Declares that this test will run an indeterminate number of
        tests.</p>
  </dd>
  <dt id="done_testing"><a class="permalink" href="#done_testing"><b>done_testing</b></a></dt>
  <dd>
    <pre>  $Test-&gt;done_testing();
  $Test-&gt;done_testing($num_tests);
    </pre>
    <p class="Pp">Declares that you are done testing, no more tests will be run
        after this point.</p>
    <p class="Pp">If a plan has not yet been output, it will do so.</p>
    <p class="Pp"><span class="Li">$num_tests</span> is the number of tests you
        planned to run. If a numbered plan was already declared, and if this
        contradicts, a failing test will be run to reflect the planning mistake.
        If <span class="Li">&quot;no_plan&quot;</span> was declared, this will
        override.</p>
    <p class="Pp">If <span class="Li">&quot;done_testing()&quot;</span> is
        called twice, the second call will issue a failing test.</p>
    <p class="Pp">If <span class="Li">$num_tests</span> is omitted, the number
        of tests run will be used, like no_plan.</p>
    <p class="Pp"><span class="Li">&quot;done_testing()&quot;</span> is, in
        effect, used when you'd want to use
        <span class="Li">&quot;no_plan&quot;</span>, but safer. You'd use it
        like so:</p>
    <p class="Pp"></p>
    <pre>    $Test-&gt;ok($a == $b);
    $Test-&gt;done_testing();
    </pre>
    <p class="Pp">Or to plan a variable number of tests:</p>
    <p class="Pp"></p>
    <pre>    for my $test (@tests) {
        $Test-&gt;ok($test);
    }
    $Test-&gt;done_testing(scalar @tests);
    </pre>
  </dd>
  <dt id="has_plan"><a class="permalink" href="#has_plan"><b>has_plan</b></a></dt>
  <dd>
    <pre>  $plan = $Test-&gt;has_plan
    </pre>
    <p class="Pp">Find out whether a plan has been defined.
        <span class="Li">$plan</span> is either
        <span class="Li">&quot;undef&quot;</span> (no plan has been set),
        <span class="Li">&quot;no_plan&quot;</span> (indeterminate # of tests)
        or an integer (the number of expected tests).</p>
  </dd>
  <dt id="skip_all"><a class="permalink" href="#skip_all"><b>skip_all</b></a></dt>
  <dd>
    <pre>  $Test-&gt;skip_all;
  $Test-&gt;skip_all($reason);
    </pre>
    <p class="Pp">Skips all the tests, using the given
        <span class="Li">$reason</span>. Exits immediately with 0.</p>
  </dd>
  <dt id="exported_to"><a class="permalink" href="#exported_to"><b>exported_to</b></a></dt>
  <dd>
    <pre>  my $pack = $Test-&gt;exported_to;
  $Test-&gt;exported_to($pack);
    </pre>
    <p class="Pp">Tells Test::Builder what package you exported your functions
        to.</p>
    <p class="Pp">This method isn't terribly useful since modules which share
        the same Test::Builder object might get exported to different packages
        and only the last one will be honored.</p>
  </dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Running_tests"><a class="permalink" href="#Running_tests">Running
  tests</a></h2>
<p class="Pp">These actually run the tests, analogous to the functions in
    Test::More.</p>
<p class="Pp">They all return true if the test passed, false if the test
  failed.</p>
<p class="Pp"><span class="Li">$name</span> is always optional.</p>
<dl class="Bl-tag">
  <dt id="ok"><a class="permalink" href="#ok"><b>ok</b></a></dt>
  <dd>
    <pre>  $Test-&gt;ok($test, $name);
    </pre>
    <p class="Pp">Your basic test. Pass if <span class="Li">$test</span> is
        true, fail if <span class="Li">$test</span> is false. Just like
        Test::Simple's <span class="Li">&quot;ok()&quot;</span>.</p>
  </dd>
  <dt id="is_eq"><a class="permalink" href="#is_eq"><b>is_eq</b></a></dt>
  <dd>
    <pre>  $Test-&gt;is_eq($got, $expected, $name);
    </pre>
    <p class="Pp">Like Test::More's <span class="Li">&quot;is()&quot;</span>.
        Checks if <span class="Li">&quot;$got eq $expected&quot;</span>. This is
        the string version.</p>
    <p class="Pp"><span class="Li">&quot;undef&quot;</span> only ever matches
        another <span class="Li">&quot;undef&quot;</span>.</p>
  </dd>
  <dt id="is_num"><a class="permalink" href="#is_num"><b>is_num</b></a></dt>
  <dd>
    <pre>  $Test-&gt;is_num($got, $expected, $name);
    </pre>
    <p class="Pp">Like Test::More's <span class="Li">&quot;is()&quot;</span>.
        Checks if <span class="Li">&quot;$got == $expected&quot;</span>. This is
        the numeric version.</p>
    <p class="Pp"><span class="Li">&quot;undef&quot;</span> only ever matches
        another <span class="Li">&quot;undef&quot;</span>.</p>
  </dd>
  <dt id="isnt_eq"><a class="permalink" href="#isnt_eq"><b>isnt_eq</b></a></dt>
  <dd>
    <pre>  $Test-&gt;isnt_eq($got, $dont_expect, $name);
    </pre>
    <p class="Pp">Like Test::More's <span class="Li">&quot;isnt()&quot;</span>.
        Checks if <span class="Li">&quot;$got ne $dont_expect&quot;</span>. This
        is the string version.</p>
  </dd>
  <dt id="isnt_num"><a class="permalink" href="#isnt_num"><b>isnt_num</b></a></dt>
  <dd>
    <pre>  $Test-&gt;isnt_num($got, $dont_expect, $name);
    </pre>
    <p class="Pp">Like Test::More's <span class="Li">&quot;isnt()&quot;</span>.
        Checks if <span class="Li">&quot;$got ne $dont_expect&quot;</span>. This
        is the numeric version.</p>
  </dd>
  <dt id="like"><a class="permalink" href="#like"><b>like</b></a></dt>
  <dd>
    <pre>  $Test-&gt;like($thing, qr/$regex/, $name);
  $Test-&gt;like($thing, '/$regex/', $name);
    </pre>
    <p class="Pp">Like Test::More's <span class="Li">&quot;like()&quot;</span>.
        Checks if <span class="Li">$thing</span> matches the given
        <span class="Li">$regex</span>.</p>
  </dd>
  <dt id="unlike"><a class="permalink" href="#unlike"><b>unlike</b></a></dt>
  <dd>
    <pre>  $Test-&gt;unlike($thing, qr/$regex/, $name);
  $Test-&gt;unlike($thing, '/$regex/', $name);
    </pre>
    <p class="Pp">Like Test::More's
        <span class="Li">&quot;unlike()&quot;</span>. Checks if
        <span class="Li">$thing</span> <b>does not match</b> the given
        <span class="Li">$regex</span>.</p>
  </dd>
  <dt id="cmp_ok"><a class="permalink" href="#cmp_ok"><b>cmp_ok</b></a></dt>
  <dd>
    <pre>  $Test-&gt;cmp_ok($thing, $type, $that, $name);
    </pre>
    <p class="Pp">Works just like Test::More's
        <span class="Li">&quot;cmp_ok()&quot;</span>.</p>
    <p class="Pp"></p>
    <pre>    $Test-&gt;cmp_ok($big_num, '!=', $other_big_num);
    </pre>
  </dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Other_Testing_Methods"><a class="permalink" href="#Other_Testing_Methods">Other
  Testing Methods</a></h2>
<p class="Pp">These are methods which are used in the course of writing a test
    but are not themselves tests.</p>
<dl class="Bl-tag">
  <dt id="BAIL_OUT"><a class="permalink" href="#BAIL_OUT"><b>BAIL_OUT</b></a></dt>
  <dd>
    <pre>    $Test-&gt;BAIL_OUT($reason);
    </pre>
    <p class="Pp">Indicates to the Test::Harness that things are going so badly
        all testing should terminate. This includes running any additional test
        scripts.</p>
    <p class="Pp">It will exit with 255.</p>
  </dd>
  <dt id="skip"><a class="permalink" href="#skip"><b>skip</b></a></dt>
  <dd>
    <pre>    $Test-&gt;skip;
    $Test-&gt;skip($why);
    </pre>
    <p class="Pp">Skips the current test, reporting
        <span class="Li">$why</span>.</p>
  </dd>
  <dt id="todo_skip"><a class="permalink" href="#todo_skip"><b>todo_skip</b></a></dt>
  <dd>
    <pre>  $Test-&gt;todo_skip;
  $Test-&gt;todo_skip($why);
    </pre>
    <p class="Pp">Like <span class="Li">&quot;skip()&quot;</span>, only it will
        declare the test as failing and TODO. Similar to</p>
    <p class="Pp"></p>
    <pre>    print &quot;not ok $tnum # TODO $why\n&quot;;
    </pre>
  </dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Test_building_utility_methods"><a class="permalink" href="#Test_building_utility_methods">Test
  building utility methods</a></h2>
<p class="Pp">These methods are useful when writing your own test methods.</p>
<dl class="Bl-tag">
  <dt id="maybe_regex"><a class="permalink" href="#maybe_regex"><b>maybe_regex</b></a></dt>
  <dd>
    <pre>  $Test-&gt;maybe_regex(qr/$regex/);
  $Test-&gt;maybe_regex('/$regex/');
    </pre>
    <p class="Pp">This method used to be useful back when Test::Builder worked
        on Perls before 5.6 which didn't have qr//. Now its pretty useless.</p>
    <p class="Pp">Convenience method for building testing functions that take
        regular expressions as arguments.</p>
    <p class="Pp">Takes a quoted regular expression produced by
        <span class="Li">&quot;qr//&quot;</span>, or a string representing a
        regular expression.</p>
    <p class="Pp">Returns a Perl value which may be used instead of the
        corresponding regular expression, or
        <span class="Li">&quot;undef&quot;</span> if its argument is not
        recognized.</p>
    <p class="Pp">For example, a version of
        <span class="Li">&quot;like()&quot;</span>, sans the useful diagnostic
        messages, could be written as:</p>
    <p class="Pp"></p>
    <pre>  sub laconic_like {
      my ($self, $thing, $regex, $name) = @_;
      my $usable_regex = $self-&gt;maybe_regex($regex);
      die &quot;expecting regex, found '$regex'\n&quot;
          unless $usable_regex;
      $self-&gt;ok($thing =~ m/$usable_regex/, $name);
  }
    </pre>
  </dd>
  <dt id="is_fh"><a class="permalink" href="#is_fh"><b>is_fh</b></a></dt>
  <dd>
    <pre>    my $is_fh = $Test-&gt;is_fh($thing);
    </pre>
    <p class="Pp">Determines if the given <span class="Li">$thing</span> can be
        used as a filehandle.</p>
  </dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Test_style"><a class="permalink" href="#Test_style">Test
  style</a></h2>
<dl class="Bl-tag">
  <dt id="level"><a class="permalink" href="#level"><b>level</b></a></dt>
  <dd>
    <pre>    $Test-&gt;level($how_high);
    </pre>
    <p class="Pp">How far up the call stack should <span class="Li">$Test</span>
        look when reporting where the test failed.</p>
    <p class="Pp">Defaults to 1.</p>
    <p class="Pp">Setting <span class="Li">$Test::Builder::Level</span>
        overrides. This is typically useful localized:</p>
    <p class="Pp"></p>
    <pre>    sub my_ok {
        my $test = shift;
        local $Test::Builder::Level = $Test::Builder::Level + 1;
        $TB-&gt;ok($test);
    }
    </pre>
    <p class="Pp">To be polite to other functions wrapping your own you usually
        want to increment <span class="Li">$Level</span> rather than set it to a
        constant.</p>
  </dd>
  <dt id="use_numbers"><a class="permalink" href="#use_numbers"><b>use_numbers</b></a></dt>
  <dd>
    <pre>    $Test-&gt;use_numbers($on_or_off);
    </pre>
    <p class="Pp">Whether or not the test should output numbers. That is, this
        if true:</p>
    <p class="Pp"></p>
    <pre>  ok 1
  ok 2
  ok 3
    </pre>
    <p class="Pp">or this if false</p>
    <p class="Pp"></p>
    <pre>  ok
  ok
  ok
    </pre>
    <p class="Pp">Most useful when you can't depend on the test output order,
        such as when threads or forking is involved.</p>
    <p class="Pp">Defaults to on.</p>
  </dd>
  <dt id="no_diag"><a class="permalink" href="#no_diag"><b>no_diag</b></a></dt>
  <dd>
    <pre>    $Test-&gt;no_diag($no_diag);
    </pre>
    <p class="Pp">If set true no diagnostics will be printed. This includes
        calls to <span class="Li">&quot;diag()&quot;</span>.</p>
  </dd>
  <dt id="no_ending"><a class="permalink" href="#no_ending"><b>no_ending</b></a></dt>
  <dd>
    <pre>    $Test-&gt;no_ending($no_ending);
    </pre>
    <p class="Pp">Normally, Test::Builder does some extra diagnostics when the
        test ends. It also changes the exit code as described below.</p>
    <p class="Pp">If this is true, none of that will be done.</p>
  </dd>
  <dt id="no_header"><a class="permalink" href="#no_header"><b>no_header</b></a></dt>
  <dd>
    <pre>    $Test-&gt;no_header($no_header);
    </pre>
    <p class="Pp">If set to true, no &quot;1..N&quot; header will be
      printed.</p>
  </dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Output"><a class="permalink" href="#Output">Output</a></h2>
<p class="Pp">Controlling where the test output goes.</p>
<p class="Pp">It's ok for your test to change where STDOUT and STDERR point to,
    Test::Builder's default output settings will not be affected.</p>
<dl class="Bl-tag">
  <dt id="diag"><a class="permalink" href="#diag"><b>diag</b></a></dt>
  <dd>
    <pre>    $Test-&gt;diag(@msgs);
    </pre>
    <p class="Pp">Prints out the given <span class="Li">@msgs</span>. Like
        <span class="Li">&quot;print&quot;</span>, arguments are simply appended
        together.</p>
    <p class="Pp">Normally, it uses the
        <span class="Li">&quot;failure_output()&quot;</span> handle, but if this
        is for a TODO test, the
        <span class="Li">&quot;todo_output()&quot;</span> handle is used.</p>
    <p class="Pp">Output will be indented and marked with a # so as not to
        interfere with test output. A newline will be put on the end if there
        isn't one already.</p>
    <p class="Pp">We encourage using this rather than calling print
      directly.</p>
    <p class="Pp">Returns false. Why? Because
        <span class="Li">&quot;diag()&quot;</span> is often used in conjunction
        with a failing test (<span class="Li">&quot;ok() || diag()&quot;</span>)
        it &quot;passes through&quot; the failure.</p>
    <p class="Pp"></p>
    <pre>    return ok(...) || diag(...);
    </pre>
  </dd>
  <dt id="note"><a class="permalink" href="#note"><b>note</b></a></dt>
  <dd>
    <pre>    $Test-&gt;note(@msgs);
    </pre>
    <p class="Pp">Like <span class="Li">&quot;diag()&quot;</span>, but it prints
        to the <span class="Li">&quot;output()&quot;</span> handle so it will
        not normally be seen by the user except in verbose mode.</p>
  </dd>
  <dt id="explain"><a class="permalink" href="#explain"><b>explain</b></a></dt>
  <dd>
    <pre>    my @dump = $Test-&gt;explain(@msgs);
    </pre>
    <p class="Pp">Will dump the contents of any references in a human readable
        format. Handy for things like...</p>
    <p class="Pp"></p>
    <pre>    is_deeply($have, $want) || diag explain $have;
    </pre>
    <p class="Pp">or</p>
    <p class="Pp"></p>
    <pre>    is_deeply($have, $want) || note explain $have;
    </pre>
  </dd>
  <dt id="output"><a class="permalink" href="#output"><b>output</b></a></dt>
  <dd></dd>
  <dt id="failure_output"><a class="permalink" href="#failure_output"><b>failure_output</b></a></dt>
  <dd></dd>
  <dt id="todo_output"><a class="permalink" href="#todo_output"><b>todo_output</b></a></dt>
  <dd>
    <pre>    my $filehandle = $Test-&gt;output;
    $Test-&gt;output($filehandle);
    $Test-&gt;output($filename);
    $Test-&gt;output(\$scalar);
    </pre>
    <p class="Pp">These methods control where Test::Builder will print its
        output. They take either an open <span class="Li">$filehandle</span>, a
        <span class="Li">$filename</span> to open and write to or a
        <span class="Li">$scalar</span> reference to append to. It will always
        return a <span class="Li">$filehandle</span>.</p>
    <p class="Pp"><b>output</b> is where normal &quot;ok/not ok&quot; test
        output goes.</p>
    <p class="Pp">Defaults to STDOUT.</p>
    <p class="Pp"><b>failure_output</b> is where diagnostic output on test
        failures and <span class="Li">&quot;diag()&quot;</span> goes. It is
        normally not read by Test::Harness and instead is displayed to the
      user.</p>
    <p class="Pp">Defaults to STDERR.</p>
    <p class="Pp"><span class="Li">&quot;todo_output&quot;</span> is used
        instead of <span class="Li">&quot;failure_output()&quot;</span> for the
        diagnostics of a failing TODO test. These will not be seen by the
      user.</p>
    <p class="Pp">Defaults to STDOUT.</p>
  </dd>
  <dt id="reset_outputs"><a class="permalink" href="#reset_outputs">reset_outputs</a></dt>
  <dd>
    <pre>  $tb-&gt;reset_outputs;
    </pre>
    <p class="Pp">Resets all the output filehandles back to their defaults.</p>
  </dd>
  <dt id="carp"><a class="permalink" href="#carp">carp</a></dt>
  <dd>
    <pre>  $tb-&gt;carp(@message);
    </pre>
    <p class="Pp">Warns with <span class="Li">@message</span> but the message
        will appear to come from the point where the original test function was
        called (<span class="Li">&quot;$tb-&gt;caller&quot;</span>).</p>
  </dd>
  <dt id="croak"><a class="permalink" href="#croak">croak</a></dt>
  <dd>
    <pre>  $tb-&gt;croak(@message);
    </pre>
    <p class="Pp">Dies with <span class="Li">@message</span> but the message
        will appear to come from the point where the original test function was
        called (<span class="Li">&quot;$tb-&gt;caller&quot;</span>).</p>
  </dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Test_Status_and_Info"><a class="permalink" href="#Test_Status_and_Info">Test
  Status and Info</a></h2>
<dl class="Bl-tag">
  <dt id="no_log_results"><a class="permalink" href="#no_log_results"><b>no_log_results</b></a></dt>
  <dd>This will turn off result long-term storage. Calling this method will make
      <span class="Li">&quot;details&quot;</span> and
      <span class="Li">&quot;summary&quot;</span> useless. You may want to use
      this if you are running enough tests to fill up all available memory.
    <p class="Pp"></p>
    <pre>    Test::Builder-&gt;new-&gt;no_log_results();
    </pre>
    <p class="Pp">There is no way to turn it back on.</p>
  </dd>
  <dt id="current_test"><a class="permalink" href="#current_test"><b>current_test</b></a></dt>
  <dd>
    <pre>    my $curr_test = $Test-&gt;current_test;
    $Test-&gt;current_test($num);
    </pre>
    <p class="Pp">Gets/sets the current test number we're on. You usually
        shouldn't have to set this.</p>
    <p class="Pp">If set forward, the details of the missing tests are filled in
        as 'unknown'. if set backward, the details of the intervening tests are
        deleted. You can erase history if you really want to.</p>
  </dd>
  <dt id="is_passing"><a class="permalink" href="#is_passing"><b>is_passing</b></a></dt>
  <dd>
    <pre>   my $ok = $builder-&gt;is_passing;
    </pre>
    <p class="Pp">Indicates if the test suite is currently passing.</p>
    <p class="Pp">More formally, it will be false if anything has happened which
        makes it impossible for the test suite to pass. True otherwise.</p>
    <p class="Pp">For example, if no tests have run
        <span class="Li">&quot;is_passing()&quot;</span> will be true because
        even though a suite with no tests is a failure you can add a passing
        test to it and start passing.</p>
    <p class="Pp">Don't think about it too much.</p>
  </dd>
  <dt id="summary"><a class="permalink" href="#summary"><b>summary</b></a></dt>
  <dd>
    <pre>    my @tests = $Test-&gt;summary;
    </pre>
    <p class="Pp">A simple summary of the tests so far. True for pass, false for
        fail. This is a logical pass/fail, so todos are passes.</p>
    <p class="Pp">Of course, test #1 is <span class="Li">$tests</span>[0],
        etc...</p>
  </dd>
  <dt id="details"><a class="permalink" href="#details"><b>details</b></a></dt>
  <dd>
    <pre>    my @tests = $Test-&gt;details;
    </pre>
    <p class="Pp">Like <span class="Li">&quot;summary()&quot;</span>, but with a
        lot more detail.</p>
    <p class="Pp"></p>
    <pre>    $tests[$test_num - 1] =
            { 'ok'       =&gt; is the test considered a pass?
              actual_ok  =&gt; did it literally say 'ok'?
              name       =&gt; name of the test (if any)
              type       =&gt; type of test (if any, see below).
              reason     =&gt; reason for the above (if any)
            };
    </pre>
    <p class="Pp">'ok' is true if Test::Harness will consider the test to be a
        pass.</p>
    <p class="Pp">'actual_ok' is a reflection of whether or not the test
        literally printed 'ok' or 'not ok'. This is for examining the result of
        'todo' tests.</p>
    <p class="Pp">'name' is the name of the test.</p>
    <p class="Pp">'type' indicates if it was a special test. Normal tests have a
        type of ''. Type can be one of the following:</p>
    <p class="Pp"></p>
    <pre>    skip        see skip()
    todo        see todo()
    todo_skip   see todo_skip()
    unknown     see below
    </pre>
    <p class="Pp">Sometimes the Test::Builder test counter is incremented
        without it printing any test output, for example, when
        <span class="Li">&quot;current_test()&quot;</span> is changed. In these
        cases, Test::Builder doesn't know the result of the test, so its type is
        'unknown'. These details for these tests are filled in. They are
        considered ok, but the name and actual_ok is left
        <span class="Li">&quot;undef&quot;</span>.</p>
    <p class="Pp">For example &quot;not ok 23 - hole count # TODO insufficient
        donuts&quot; would result in this structure:</p>
    <p class="Pp"></p>
    <pre>    $tests[22] =    # 23 - 1, since arrays start from 0.
      { ok        =&gt; 1,   # logically, the test passed since its todo
        actual_ok =&gt; 0,   # in absolute terms, it failed
        name      =&gt; 'hole count',
        type      =&gt; 'todo',
        reason    =&gt; 'insufficient donuts'
      };
    </pre>
  </dd>
  <dt id="todo"><a class="permalink" href="#todo"><b>todo</b></a></dt>
  <dd>
    <pre>    my $todo_reason = $Test-&gt;todo;
    my $todo_reason = $Test-&gt;todo($pack);
    </pre>
    <p class="Pp">If the current tests are considered &quot;TODO&quot; it will
        return the reason, if any. This reason can come from a
        <span class="Li">$TODO</span> variable or the last call to
        <span class="Li">&quot;todo_start()&quot;</span>.</p>
    <p class="Pp">Since a TODO test does not need a reason, this function can
        return an empty string even when inside a TODO block. Use
        <span class="Li">&quot;$Test-&gt;in_todo&quot;</span> to determine if
        you are currently inside a TODO block.</p>
    <p class="Pp"><span class="Li">&quot;todo()&quot;</span> is about finding
        the right package to look for <span class="Li">$TODO</span> in. It's
        pretty good at guessing the right package to look at. It first looks for
        the caller based on <span class="Li">&quot;$Level + 1&quot;</span>,
        since <span class="Li">&quot;todo()&quot;</span> is usually called
        inside a test function. As a last resort it will use
        <span class="Li">&quot;exported_to()&quot;</span>.</p>
    <p class="Pp">Sometimes there is some confusion about where
        <span class="Li">&quot;todo()&quot;</span> should be looking for the
        <span class="Li">$TODO</span> variable. If you want to be sure, tell it
        explicitly what <span class="Li">$pack</span> to use.</p>
  </dd>
  <dt id="find_TODO"><a class="permalink" href="#find_TODO"><b>find_TODO</b></a></dt>
  <dd>
    <pre>    my $todo_reason = $Test-&gt;find_TODO();
    my $todo_reason = $Test-&gt;find_TODO($pack);
    </pre>
    <p class="Pp">Like <span class="Li">&quot;todo()&quot;</span> but only
        returns the value of <span class="Li">$TODO</span> ignoring
        <span class="Li">&quot;todo_start()&quot;</span>.</p>
    <p class="Pp">Can also be used to set <span class="Li">$TODO</span> to a new
        value while returning the old value:</p>
    <p class="Pp"></p>
    <pre>    my $old_reason = $Test-&gt;find_TODO($pack, 1, $new_reason);
    </pre>
  </dd>
  <dt id="in_todo"><a class="permalink" href="#in_todo"><b>in_todo</b></a></dt>
  <dd>
    <pre>    my $in_todo = $Test-&gt;in_todo;
    </pre>
    <p class="Pp">Returns true if the test is currently inside a TODO block.</p>
  </dd>
  <dt id="todo_start"><a class="permalink" href="#todo_start"><b>todo_start</b></a></dt>
  <dd>
    <pre>    $Test-&gt;todo_start();
    $Test-&gt;todo_start($message);
    </pre>
    <p class="Pp">This method allows you declare all subsequent tests as TODO
        tests, up until the <span class="Li">&quot;todo_end&quot;</span> method
        has been called.</p>
    <p class="Pp">The <span class="Li">&quot;TODO:&quot;</span> and
        <span class="Li">$TODO</span> syntax is generally pretty good about
        figuring out whether or not we're in a TODO test. However, often we find
        that this is not possible to determine (such as when we want to use
        <span class="Li">$TODO</span> but the tests are being executed in other
        packages which can't be inferred beforehand).</p>
    <p class="Pp">Note that you can use this to nest &quot;todo&quot; tests</p>
    <p class="Pp"></p>
    <pre> $Test-&gt;todo_start('working on this');
 # lots of code
 $Test-&gt;todo_start('working on that');
 # more code
 $Test-&gt;todo_end;
 $Test-&gt;todo_end;
    </pre>
    <p class="Pp">This is generally not recommended, but large testing systems
        often have weird internal needs.</p>
    <p class="Pp">We've tried to make this also work with the TODO: syntax, but
        it's not guaranteed and its use is also discouraged:</p>
    <p class="Pp"></p>
    <pre> TODO: {
     local $TODO = 'We have work to do!';
     $Test-&gt;todo_start('working on this');
     # lots of code
     $Test-&gt;todo_start('working on that');
     # more code
     $Test-&gt;todo_end;
     $Test-&gt;todo_end;
 }
    </pre>
    <p class="Pp">Pick one style or another of &quot;TODO&quot; to be on the
        safe side.</p>
  </dd>
  <dt>&quot;todo_end&quot;</dt>
  <dd>
    <pre> $Test-&gt;todo_end;
    </pre>
    <p class="Pp">Stops running tests as &quot;TODO&quot; tests. This method is
        fatal if called without a preceding
        <span class="Li">&quot;todo_start&quot;</span> method call.</p>
  </dd>
  <dt id="caller"><a class="permalink" href="#caller"><b>caller</b></a></dt>
  <dd>
    <pre>    my $package = $Test-&gt;caller;
    my($pack, $file, $line) = $Test-&gt;caller;
    my($pack, $file, $line) = $Test-&gt;caller($height);
    </pre>
    <p class="Pp">Like the normal <span class="Li">&quot;caller()&quot;</span>,
        except it reports according to your
        <span class="Li">&quot;level()&quot;</span>.</p>
    <p class="Pp"><span class="Li">$height</span> will be added to the
        <span class="Li">&quot;level()&quot;</span>.</p>
    <p class="Pp">If <span class="Li">&quot;caller()&quot;</span> winds up off
        the top of the stack it report the highest context.</p>
  </dd>
</dl>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="EXIT_CODES"><a class="permalink" href="#EXIT_CODES">EXIT
  CODES</a></h1>
<p class="Pp">If all your tests passed, Test::Builder will exit with zero (which
    is normal). If anything failed it will exit with how many failed. If you run
    less (or more) tests than you planned, the missing (or extras) will be
    considered failures. If no tests were ever run Test::Builder will throw a
    warning and exit with 255. If the test died, even after having successfully
    completed all its tests, it will still be considered a failure and will exit
    with 255.</p>
<p class="Pp">So the exit codes are...</p>
<p class="Pp"></p>
<pre>    0                   all tests successful
    255                 test died or all passed but wrong # of tests run
    any other number    how many failed (including missing or extras)
</pre>
<p class="Pp">If you fail more than 254 tests, it will be reported as 254.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="THREADS"><a class="permalink" href="#THREADS">THREADS</a></h1>
<p class="Pp">In perl 5.8.1 and later, Test::Builder is thread-safe. The test
    number is shared by all threads. This means if one thread sets the test
    number using <span class="Li">&quot;current_test()&quot;</span> they will
    all be effected.</p>
<p class="Pp">While versions earlier than 5.8.1 had threads they contain too
    many bugs to support.</p>
<p class="Pp">Test::Builder is only thread-aware if threads.pm is loaded
    <i>before</i> Test::Builder.</p>
<p class="Pp">You can directly disable thread support with one of the
  following:</p>
<p class="Pp"></p>
<pre>    $ENV{T2_NO_IPC} = 1
</pre>
<p class="Pp">or</p>
<p class="Pp"></p>
<pre>    no Test2::IPC;
</pre>
<p class="Pp">or</p>
<p class="Pp"></p>
<pre>    Test2::API::test2_ipc_disable()
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="MEMORY"><a class="permalink" href="#MEMORY">MEMORY</a></h1>
<p class="Pp">An informative hash, accessible via
    <span class="Li">&quot;details()&quot;</span>, is stored for each test you
    perform. So memory usage will scale linearly with each test run. Although
    this is not a problem for most test suites, it can become an issue if you do
    large (hundred thousands to million) combinatorics tests in the same
  run.</p>
<p class="Pp">In such cases, you are advised to either split the test file into
    smaller ones, or use a reverse approach, doing &quot;normal&quot; (code)
    compares and triggering <span class="Li">&quot;fail()&quot;</span> should
    anything go unexpected.</p>
<p class="Pp">Future versions of Test::Builder will have a way to turn history
    off.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="EXAMPLES"><a class="permalink" href="#EXAMPLES">EXAMPLES</a></h1>
<p class="Pp">CPAN can provide the best examples. Test::Simple, Test::More,
    Test::Exception and Test::Differences all use Test::Builder.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<section class="Ss">
<h2 class="Ss">INTERNALS</h2>
<p class="Pp">Test2, Test2::API</p>
</section>
<section class="Ss">
<h2 class="Ss">LEGACY</h2>
<p class="Pp">Test::Simple, Test::More</p>
</section>
<section class="Ss">
<h2 class="Ss">EXTERNAL</h2>
<p class="Pp">Test::Harness</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHORS"><a class="permalink" href="#AUTHORS">AUTHORS</a></h1>
<p class="Pp">Original code by chromatic, maintained by Michael G Schwern
    &lt;schwern@pobox.com&gt;</p>
</section>
<section class="Sh">
<h1 class="Sh" id="MAINTAINERS"><a class="permalink" href="#MAINTAINERS">MAINTAINERS</a></h1>
<dl class="Bl-tag">
  <dt id="Chad"><a class="permalink" href="#Chad">Chad Granum
    &lt;exodist@cpan.org&gt;</a></dt>
  <dd></dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT"><a class="permalink" href="#COPYRIGHT">COPYRIGHT</a></h1>
<p class="Pp">Copyright 2002-2008 by chromatic &lt;chromatic@wgz.org&gt; and
  <br/>
   Michael G Schwern &lt;schwern@pobox.com&gt;.</p>
<p class="Pp">This program is free software; you can redistribute it and/or
    modify it under the same terms as Perl itself.</p>
<p class="Pp">See <i>http://www.perl.com/perl/misc/Artistic.html</i></p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2020-11-18</td>
    <td class="foot-os">perl v5.34.0</td>
  </tr>
</table>
</body>
</html>
