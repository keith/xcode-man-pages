<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>DBIx::Class::ResultSource(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">DBIx::Class::ResultSource(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">DBIx::Class::ResultSource(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
DBIx::Class::ResultSource - Result source object
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<span class="Li"></span>
<pre>
  # Create a table based result source, in a result class.

  package MyApp::Schema::Result::Artist;
  use base qw/DBIx::Class::Core/;

  __PACKAGE__-&gt;table('artist');
  __PACKAGE__-&gt;add_columns(qw/ artistid name /);
  __PACKAGE__-&gt;set_primary_key('artistid');
  __PACKAGE__-&gt;has_many(cds =&gt; 'MyApp::Schema::Result::CD');

  1;

  # Create a query (view) based result source, in a result class
  package MyApp::Schema::Result::Year2000CDs;
  use base qw/DBIx::Class::Core/;

  __PACKAGE__-&gt;load_components('InflateColumn::DateTime');
  __PACKAGE__-&gt;table_class('DBIx::Class::ResultSource::View');

  __PACKAGE__-&gt;table('year2000cds');
  __PACKAGE__-&gt;result_source_instance-&gt;is_virtual(1);
  __PACKAGE__-&gt;result_source_instance-&gt;view_definition(
      &quot;SELECT cdid, artist, title FROM cd WHERE year ='2000'&quot;
      );
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
A ResultSource is an object that represents a source of data for querying.
<p class="Pp">This class is a base class for various specialised types of result
    sources, for example DBIx::Class::ResultSource::Table. Table is the default
    result source type, so one is created for you when defining a result class
    as described in the synopsis above.</p>
<p class="Pp">More specifically, the DBIx::Class::Core base class pulls in the
    DBIx::Class::ResultSourceProxy::Table component, which defines the table
    method. When called, <span class="Li">&quot;table&quot;</span> creates and
    stores an instance of DBIx::Class::ResultSoure::Table. Luckily, to use
    tables as result sources, you don't need to remember any of this.</p>
<p class="Pp">Result sources representing select queries, or views, can also be
    created, see DBIx::Class::ResultSource::View for full details.</p>
<section class="Ss">
<h2 class="Ss" id="Finding_result_source_objects"><a class="permalink" href="#Finding_result_source_objects">Finding
  result source objects</a></h2>
As mentioned above, a result source instance is created and stored for you when
  you define a result class.
<p class="Pp">You can retrieve the result source at runtime in the following
    ways:</p>
<dl class="Bl-tag">
  <dt>From a Schema object:</dt>
  <dd><span class="Li"></span>
    <pre>
   $schema-&gt;source($source_name);
    </pre>
  </dd>
  <dt>From a Result object:</dt>
  <dd><span class="Li"></span>
    <pre>
   $result-&gt;result_source;
    </pre>
  </dd>
  <dt>From a ResultSet object:</dt>
  <dd><span class="Li"></span>
    <pre>
   $rs-&gt;result_source;
    </pre>
  </dd>
</dl>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="METHODS"><a class="permalink" href="#METHODS">METHODS</a></h1>
<section class="Ss">
<h2 class="Ss" id="add_columns"><a class="permalink" href="#add_columns">add_columns</a></h2>
<dl class="Bl-tag">
  <dt>Arguments: @columns</dt>
  <dd></dd>
  <dt>Return Value: $result_source</dt>
  <dd></dd>
</dl>
<p class="Pp"><span class="Li"></span></p>
<pre>
  $source-&gt;add_columns(qw/col1 col2 col3/);

  $source-&gt;add_columns('col1' =&gt; \%col1_info, 'col2' =&gt; \%col2_info, ...);
</pre>
<p class="Pp">Adds columns to the result source. If supplied colname =&gt;
    hashref pairs, uses the hashref as the &quot;column_info&quot; for that
    column. Repeated calls of this method will add more columns, not replace
    them.</p>
<p class="Pp">The column names given will be created as accessor methods on your
    Result objects. You can change the name of the accessor by supplying an
    &quot;accessor&quot; in the column_info hash.</p>
<p class="Pp">If a column name beginning with a plus sign ('+col1') is provided,
    the attributes provided will be merged with any existing attributes for the
    column, with the new attributes taking precedence in the case that an
    attribute already exists. Using this without a hashref
    (<span class="Li">&quot;$source-&gt;add_columns(qw/+col1
    +col2/)&quot;</span>) is legal, but useless -- it does the same thing it
    would do without the plus.</p>
<p class="Pp">The contents of the column_info are not set in stone. The
    following keys are currently recognised/used by DBIx::Class:</p>
<dl class="Bl-tag">
  <dt>accessor</dt>
  <dd><span class="Li"></span>
    <pre>
   { accessor =&gt; '_name' }

   # example use, replace standard accessor with one of your own:
   sub name {
       my ($self, $value) = @_;

       die &quot;Name cannot contain digits!&quot; if($value =~ /\d/);
       $self-&gt;_name($value);

       return $self-&gt;_name();
   }
    </pre>
    <p class="Pp">Use this to set the name of the accessor method for this
        column. If unset, the name of the column will be used.</p>
  </dd>
  <dt>data_type</dt>
  <dd><span class="Li"></span>
    <pre>
   { data_type =&gt; 'integer' }
    </pre>
    <p class="Pp">This contains the column type. It is automatically filled if
        you use the SQL::Translator::Producer::DBIx::Class::File producer, or
        the DBIx::Class::Schema::Loader module.</p>
    <p class="Pp">Currently there is no standard set of values for the
        data_type. Use whatever your database supports.</p>
  </dd>
  <dt>size</dt>
  <dd><span class="Li"></span>
    <pre>
   { size =&gt; 20 }
    </pre>
    <p class="Pp">The length of your column, if it is a column type that can
        have a size restriction. This is currently only used to create tables
        from your schema, see &quot;deploy&quot; in DBIx::Class::Schema.</p>
  </dd>
  <dt>is_nullable</dt>
  <dd><span class="Li"></span>
    <pre>
   { is_nullable =&gt; 1 }
    </pre>
    <p class="Pp">Set this to a true value for a columns that is allowed to
        contain NULL values, default is false. This is currently only used to
        create tables from your schema, see &quot;deploy&quot; in
        DBIx::Class::Schema.</p>
  </dd>
  <dt>is_auto_increment</dt>
  <dd><span class="Li"></span>
    <pre>
   { is_auto_increment =&gt; 1 }
    </pre>
    <p class="Pp">Set this to a true value for a column whose value is somehow
        automatically set, defaults to false. This is used to determine which
        columns to empty when cloning objects using &quot;copy&quot; in
        DBIx::Class::Row. It is also used by &quot;deploy&quot; in
        DBIx::Class::Schema.</p>
  </dd>
  <dt>is_numeric</dt>
  <dd><span class="Li"></span>
    <pre>
   { is_numeric =&gt; 1 }
    </pre>
    <p class="Pp">Set this to a true or false value (not
        <span class="Li">&quot;undef&quot;</span>) to explicitly specify if this
        column contains numeric data. This controls how set_column decides
        whether to consider a column dirty after an update: if
        <span class="Li">&quot;is_numeric&quot;</span> is true a numeric
        comparison <span class="Li">&quot;!=&quot;</span> will take place
        instead of the usual <span class="Li">&quot;eq&quot;</span></p>
    <p class="Pp">If not specified the storage class will attempt to figure this
        out on first access to the column, based on the column
        <span class="Li">&quot;data_type&quot;</span>. The result will be cached
        in this attribute.</p>
  </dd>
  <dt>is_foreign_key</dt>
  <dd><span class="Li"></span>
    <pre>
   { is_foreign_key =&gt; 1 }
    </pre>
    <p class="Pp">Set this to a true value for a column that contains a key from
        a foreign table, defaults to false. This is currently only used to
        create tables from your schema, see &quot;deploy&quot; in
        DBIx::Class::Schema.</p>
  </dd>
  <dt>default_value</dt>
  <dd><span class="Li"></span>
    <pre>
   { default_value =&gt; \'now()' }
    </pre>
    <p class="Pp">Set this to the default value which will be inserted into a
        column by the database. Can contain either a value or a function (use a
        reference to a scalar e.g. <span class="Li">&quot;\'now()'&quot;</span>
        if you want a function). This is currently only used to create tables
        from your schema, see &quot;deploy&quot; in DBIx::Class::Schema.</p>
    <p class="Pp">See the note on &quot;new&quot; in DBIx::Class::Row for more
        information about possible issues related to db-side default values.</p>
  </dd>
  <dt>sequence</dt>
  <dd><span class="Li"></span>
    <pre>
   { sequence =&gt; 'my_table_seq' }
    </pre>
    <p class="Pp">Set this on a primary key column to the name of the sequence
        used to generate a new key value. If not specified,
        DBIx::Class::PK::Auto will attempt to retrieve the name of the sequence
        from the database automatically.</p>
  </dd>
  <dt>retrieve_on_insert</dt>
  <dd><span class="Li"></span>
    <pre>
  { retrieve_on_insert =&gt; 1 }
    </pre>
    <p class="Pp">For every column where this is set to true, DBIC will retrieve
        the RDBMS-side value upon a new row insertion (normally only the
        autoincrement PK is retrieved on insert). <span class="Li">&quot;INSERT
        ... RETURNING&quot;</span> is used automatically if supported by the
        underlying storage, otherwise an extra SELECT statement is executed to
        retrieve the missing data.</p>
  </dd>
  <dt>auto_nextval</dt>
  <dd><span class="Li"></span>
    <pre>
   { auto_nextval =&gt; 1 }
    </pre>
    <p class="Pp">Set this to a true value for a column whose value is retrieved
        automatically from a sequence or function (if supported by your Storage
        driver.) For a sequence, if you do not use a trigger to get the nextval,
        you have to set the &quot;sequence&quot; value as well.</p>
    <p class="Pp">Also set this for MSSQL columns with the 'uniqueidentifier'
        data_type whose values you want to automatically generate using
        <span class="Li">&quot;NEWID()&quot;</span>, unless they are a primary
        key in which case this will be done anyway.</p>
  </dd>
  <dt>extra</dt>
  <dd>This is used by &quot;deploy&quot; in DBIx::Class::Schema and
      SQL::Translator to add extra non-generic data to the column. For example:
      <span class="Li">&quot;extra</span> <span class="Li">=&gt; { unsigned
      =&gt; 1}&quot;</span> is used by the MySQL producer to set an integer
      column to unsigned. For more details, see
      SQL::Translator::Producer::MySQL.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="add_column"><a class="permalink" href="#add_column">add_column</a></h2>
<dl class="Bl-tag">
  <dt>Arguments: $colname, \%columninfo?</dt>
  <dd></dd>
  <dt>Return Value: 1/0 (true/false)</dt>
  <dd></dd>
</dl>
<p class="Pp"><span class="Li"></span></p>
<pre>
  $source-&gt;add_column('col' =&gt; \%info);
</pre>
<p class="Pp">Add a single column and optional column info. Uses the same column
    info keys as &quot;add_columns&quot;.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="has_column"><a class="permalink" href="#has_column">has_column</a></h2>
<dl class="Bl-tag">
  <dt>Arguments: $colname</dt>
  <dd></dd>
  <dt>Return Value: 1/0 (true/false)</dt>
  <dd></dd>
</dl>
<p class="Pp"><span class="Li"></span></p>
<pre>
  if ($source-&gt;has_column($colname)) { ... }
</pre>
<p class="Pp">Returns true if the source has a column of this name, false
    otherwise.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="column_info"><a class="permalink" href="#column_info">column_info</a></h2>
<dl class="Bl-tag">
  <dt>Arguments: $colname</dt>
  <dd></dd>
  <dt>Return Value: Hashref of info</dt>
  <dd></dd>
</dl>
<p class="Pp"><span class="Li"></span></p>
<pre>
  my $info = $source-&gt;column_info($col);
</pre>
<p class="Pp">Returns the column metadata hashref for a column, as originally
    passed to &quot;add_columns&quot;. See &quot;add_columns&quot; above for
    information on the contents of the hashref.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="columns"><a class="permalink" href="#columns">columns</a></h2>
<dl class="Bl-tag">
  <dt>Arguments: none</dt>
  <dd></dd>
  <dt>Return Value: Ordered list of column names</dt>
  <dd></dd>
</dl>
<p class="Pp"><span class="Li"></span></p>
<pre>
  my @column_names = $source-&gt;columns;
</pre>
<p class="Pp">Returns all column names in the order they were declared to
    &quot;add_columns&quot;.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="columns_info"><a class="permalink" href="#columns_info">columns_info</a></h2>
<dl class="Bl-tag">
  <dt>Arguments: \@colnames ?</dt>
  <dd></dd>
  <dt>Return Value: Hashref of column name/info pairs</dt>
  <dd></dd>
</dl>
<p class="Pp"><span class="Li"></span></p>
<pre>
  my $columns_info = $source-&gt;columns_info;
</pre>
<p class="Pp">Like &quot;column_info&quot; but returns information for the
    requested columns. If the optional column-list arrayref is omitted it
    returns info on all columns currently defined on the ResultSource via
    &quot;add_columns&quot;.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="remove_columns"><a class="permalink" href="#remove_columns">remove_columns</a></h2>
<dl class="Bl-tag">
  <dt>Arguments: @colnames</dt>
  <dd></dd>
  <dt>Return Value: not defined</dt>
  <dd></dd>
</dl>
<p class="Pp"><span class="Li"></span></p>
<pre>
  $source-&gt;remove_columns(qw/col1 col2 col3/);
</pre>
<p class="Pp">Removes the given list of columns by name, from the result
  source.</p>
<p class="Pp"><b>Warning</b>: Removing a column that is also used in the sources
    primary key, or in one of the sources unique constraints, <b>will</b> result
    in a broken result source.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="remove_column"><a class="permalink" href="#remove_column">remove_column</a></h2>
<dl class="Bl-tag">
  <dt>Arguments: $colname</dt>
  <dd></dd>
  <dt>Return Value: not defined</dt>
  <dd></dd>
</dl>
<p class="Pp"><span class="Li"></span></p>
<pre>
  $source-&gt;remove_column('col');
</pre>
<p class="Pp">Remove a single column by name from the result source, similar to
    &quot;remove_columns&quot;.</p>
<p class="Pp"><b>Warning</b>: Removing a column that is also used in the sources
    primary key, or in one of the sources unique constraints, <b>will</b> result
    in a broken result source.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="set_primary_key"><a class="permalink" href="#set_primary_key">set_primary_key</a></h2>
<dl class="Bl-tag">
  <dt>Arguments: @cols</dt>
  <dd></dd>
  <dt>Return Value: not defined</dt>
  <dd></dd>
</dl>
<p class="Pp">Defines one or more columns as primary key for this source. Must
    be called after &quot;add_columns&quot;.</p>
<p class="Pp">Additionally, defines a unique constraint named
    <span class="Li">&quot;primary&quot;</span>.</p>
<p class="Pp">Note: you normally do want to define a primary key on your sources
    <b>even if the underlying database table does not have a primary key</b>.
    See &quot;The Significance and Importance of Primary Keys&quot; in
    DBIx::Class::Manual::Intro for more info.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="primary_columns"><a class="permalink" href="#primary_columns">primary_columns</a></h2>
<dl class="Bl-tag">
  <dt>Arguments: none</dt>
  <dd></dd>
  <dt>Return Value: Ordered list of primary column names</dt>
  <dd></dd>
</dl>
<p class="Pp">Read-only accessor which returns the list of primary keys,
    supplied by &quot;set_primary_key&quot;.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="sequence"><a class="permalink" href="#sequence">sequence</a></h2>
Manually define the correct sequence for your table, to avoid the overhead
  associated with looking up the sequence automatically. The supplied sequence
  will be applied to the &quot;column_info&quot; of each primary_key
<dl class="Bl-tag">
  <dt>Arguments: $sequence_name</dt>
  <dd></dd>
  <dt>Return Value: not defined</dt>
  <dd></dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="add_unique_constraint"><a class="permalink" href="#add_unique_constraint">add_unique_constraint</a></h2>
<dl class="Bl-tag">
  <dt>Arguments: $name?, \@colnames</dt>
  <dd></dd>
  <dt>Return Value: not defined</dt>
  <dd></dd>
</dl>
<p class="Pp">Declare a unique constraint on this source. Call once for each
    unique constraint.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  # For UNIQUE (column1, column2)
  __PACKAGE__-&gt;add_unique_constraint(
    constraint_name =&gt; [ qw/column1 column2/ ],
  );
</pre>
<p class="Pp">Alternatively, you can specify only the columns:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  __PACKAGE__-&gt;add_unique_constraint([ qw/column1 column2/ ]);
</pre>
<p class="Pp">This will result in a unique constraint named
    <span class="Li">&quot;table_column1_column2&quot;</span>, where
    <span class="Li">&quot;table&quot;</span> is replaced with the table
  name.</p>
<p class="Pp">Unique constraints are used, for example, when you pass the
    constraint name as the <span class="Li">&quot;key&quot;</span> attribute to
    &quot;find&quot; in DBIx::Class::ResultSet. Then only columns in the
    constraint are searched.</p>
<p class="Pp">Throws an error if any of the given column names do not yet exist
    on the result source.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="add_unique_constraints"><a class="permalink" href="#add_unique_constraints">add_unique_constraints</a></h2>
<dl class="Bl-tag">
  <dt>Arguments: @constraints</dt>
  <dd></dd>
  <dt>Return Value: not defined</dt>
  <dd></dd>
</dl>
<p class="Pp">Declare multiple unique constraints on this source.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  __PACKAGE__-&gt;add_unique_constraints(
    constraint_name1 =&gt; [ qw/column1 column2/ ],
    constraint_name2 =&gt; [ qw/column2 column3/ ],
  );
</pre>
<p class="Pp">Alternatively, you can specify only the columns:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  __PACKAGE__-&gt;add_unique_constraints(
    [ qw/column1 column2/ ],
    [ qw/column3 column4/ ]
  );
</pre>
<p class="Pp">This will result in unique constraints named
    <span class="Li">&quot;table_column1_column2&quot;</span> and
    <span class="Li">&quot;table_column3_column4&quot;</span>, where
    <span class="Li">&quot;table&quot;</span> is replaced with the table
  name.</p>
<p class="Pp">Throws an error if any of the given column names do not yet exist
    on the result source.</p>
<p class="Pp">See also &quot;add_unique_constraint&quot;.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="name_unique_constraint"><a class="permalink" href="#name_unique_constraint">name_unique_constraint</a></h2>
<dl class="Bl-tag">
  <dt>Arguments: \@colnames</dt>
  <dd></dd>
  <dt>Return Value: Constraint name</dt>
  <dd></dd>
</dl>
<p class="Pp"><span class="Li"></span></p>
<pre>
  $source-&gt;table('mytable');
  $source-&gt;name_unique_constraint(['col1', 'col2']);
  # returns
  'mytable_col1_col2'
</pre>
<p class="Pp">Return a name for a unique constraint containing the specified
    columns. The name is created by joining the table name and each column name,
    using an underscore character.</p>
<p class="Pp">For example, a constraint on a table named
    <span class="Li">&quot;cd&quot;</span> containing the columns
    <span class="Li">&quot;artist&quot;</span> and
    <span class="Li">&quot;title&quot;</span> would result in a constraint name
    of <span class="Li">&quot;cd_artist_title&quot;</span>.</p>
<p class="Pp">This is used by &quot;add_unique_constraint&quot; if you do not
    specify the optional constraint name.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="unique_constraints"><a class="permalink" href="#unique_constraints">unique_constraints</a></h2>
<dl class="Bl-tag">
  <dt>Arguments: none</dt>
  <dd></dd>
  <dt>Return Value: Hash of unique constraint data</dt>
  <dd></dd>
</dl>
<p class="Pp"><span class="Li"></span></p>
<pre>
  $source-&gt;unique_constraints();
</pre>
<p class="Pp">Read-only accessor which returns a hash of unique constraints on
    this source.</p>
<p class="Pp">The hash is keyed by constraint name, and contains an arrayref of
    column names as values.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="unique_constraint_names"><a class="permalink" href="#unique_constraint_names">unique_constraint_names</a></h2>
<dl class="Bl-tag">
  <dt>Arguments: none</dt>
  <dd></dd>
  <dt>Return Value: Unique constraint names</dt>
  <dd></dd>
</dl>
<p class="Pp"><span class="Li"></span></p>
<pre>
  $source-&gt;unique_constraint_names();
</pre>
<p class="Pp">Returns the list of unique constraint names defined on this
    source.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="unique_constraint_columns"><a class="permalink" href="#unique_constraint_columns">unique_constraint_columns</a></h2>
<dl class="Bl-tag">
  <dt>Arguments: $constraintname</dt>
  <dd></dd>
  <dt>Return Value: List of constraint columns</dt>
  <dd></dd>
</dl>
<p class="Pp"><span class="Li"></span></p>
<pre>
  $source-&gt;unique_constraint_columns('myconstraint');
</pre>
<p class="Pp">Returns the list of columns that make up the specified unique
    constraint.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="sqlt_deploy_callback"><a class="permalink" href="#sqlt_deploy_callback">sqlt_deploy_callback</a></h2>
<dl class="Bl-tag">
  <dt>Arguments: $callback_name | \&amp;callback_code</dt>
  <dd></dd>
  <dt>Return Value: $callback_name | \&amp;callback_code</dt>
  <dd></dd>
</dl>
<p class="Pp"><span class="Li"></span></p>
<pre>
  __PACKAGE__-&gt;sqlt_deploy_callback('mycallbackmethod');

   or

  __PACKAGE__-&gt;sqlt_deploy_callback(sub {
    my ($source_instance, $sqlt_table) = @_;
    ...
  } );
</pre>
<p class="Pp">An accessor to set a callback to be called during deployment of
    the schema via &quot;create_ddl_dir&quot; in DBIx::Class::Schema or
    &quot;deploy&quot; in DBIx::Class::Schema.</p>
<p class="Pp">The callback can be set as either a code reference or the name of
    a method in the current result class.</p>
<p class="Pp">Defaults to &quot;default_sqlt_deploy_hook&quot;.</p>
<p class="Pp">Your callback will be passed the <span class="Li">$source</span>
    object representing the ResultSource instance being deployed, and the
    SQL::Translator::Schema::Table object being created from it. The callback
    can be used to manipulate the table object or add your own customised
    indexes. If you need to manipulate a non-table object, use the
    &quot;sqlt_deploy_hook&quot; in DBIx::Class::Schema.</p>
<p class="Pp">See &quot;Adding Indexes And Functions To Your SQL&quot; in
    DBIx::Class::Manual::Cookbook for examples.</p>
<p class="Pp">This sqlt deployment callback can only be used to manipulate
    SQL::Translator objects as they get turned into SQL. To execute post-deploy
    statements which SQL::Translator does not currently handle, override
    &quot;deploy&quot; in DBIx::Class::Schema in your Schema class and call
    dbh_do.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="default_sqlt_deploy_hook"><a class="permalink" href="#default_sqlt_deploy_hook">default_sqlt_deploy_hook</a></h2>
This is the default deploy hook implementation which checks if your current
  Result class has a <span class="Li">&quot;sqlt_deploy_hook&quot;</span>
  method, and if present invokes it <b>on the Result class directly</b>. This is
  to preserve the semantics of
  <span class="Li">&quot;sqlt_deploy_hook&quot;</span> which was originally
  designed to expect the Result class name and the
  <span class="Li">$sqlt_table</span> instance of the table being deployed.
</section>
<section class="Ss">
<h2 class="Ss" id="result_class"><a class="permalink" href="#result_class">result_class</a></h2>
<dl class="Bl-tag">
  <dt>Arguments: $classname</dt>
  <dd></dd>
  <dt>Return Value: $classname</dt>
  <dd></dd>
</dl>
<p class="Pp"><span class="Li"></span></p>
<pre>
 use My::Schema::ResultClass::Inflator;
 ...

 use My::Schema::Artist;
 ...
 __PACKAGE__-&gt;result_class('My::Schema::ResultClass::Inflator');
</pre>
<p class="Pp">Set the default result class for this source. You can use this to
    create and use your own result inflator. See &quot;result_class&quot; in
    DBIx::Class::ResultSet for more details.</p>
<p class="Pp">Please note that setting this to something like
    DBIx::Class::ResultClass::HashRefInflator will make every result unblessed
    and make life more difficult. Inflators like those are better suited to
    temporary usage via &quot;result_class&quot; in DBIx::Class::ResultSet.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="resultset"><a class="permalink" href="#resultset">resultset</a></h2>
<dl class="Bl-tag">
  <dt>Arguments: none</dt>
  <dd></dd>
  <dt>Return Value: $resultset</dt>
  <dd></dd>
</dl>
<p class="Pp">Returns a resultset for the given source. This will initially be
    created on demand by calling</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  $self-&gt;resultset_class-&gt;new($self, $self-&gt;resultset_attributes)
</pre>
<p class="Pp">but is cached from then on unless resultset_class changes.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="resultset_class"><a class="permalink" href="#resultset_class">resultset_class</a></h2>
<dl class="Bl-tag">
  <dt>Arguments: $classname</dt>
  <dd></dd>
  <dt>Return Value: $classname</dt>
  <dd></dd>
</dl>
<p class="Pp"><span class="Li"></span></p>
<pre>
  package My::Schema::ResultSet::Artist;
  use base 'DBIx::Class::ResultSet';
  ...

  # In the result class
  __PACKAGE__-&gt;resultset_class('My::Schema::ResultSet::Artist');

  # Or in code
  $source-&gt;resultset_class('My::Schema::ResultSet::Artist');
</pre>
<p class="Pp">Set the class of the resultset. This is useful if you want to
    create your own resultset methods. Create your own class derived from
    DBIx::Class::ResultSet, and set it here. If called with no arguments, this
    method returns the name of the existing resultset class, if one exists.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="resultset_attributes"><a class="permalink" href="#resultset_attributes">resultset_attributes</a></h2>
<dl class="Bl-tag">
  <dt>Arguments: \%attrs</dt>
  <dd></dd>
  <dt>Return Value: \%attrs</dt>
  <dd></dd>
</dl>
<p class="Pp"><span class="Li"></span></p>
<pre>
  # In the result class
  __PACKAGE__-&gt;resultset_attributes({ order_by =&gt; [ 'id' ] });

  # Or in code
  $source-&gt;resultset_attributes({ order_by =&gt; [ 'id' ] });
</pre>
<p class="Pp">Store a collection of resultset attributes, that will be set on
    every DBIx::Class::ResultSet produced from this result source.</p>
<p class="Pp"><b>CAVEAT</b>:
    <span class="Li">&quot;resultset_attributes&quot;</span> comes with its own
    set of issues and bugs! While
    <span class="Li">&quot;resultset_attributes&quot;</span> isn't deprecated
    per se, its usage is not recommended!</p>
<p class="Pp">Since relationships use attributes to link tables together, the
    &quot;default&quot; attributes you set may cause unpredictable and undesired
    behavior. Furthermore, the defaults cannot be turned off, so you are stuck
    with them.</p>
<p class="Pp">In most cases, what you should actually be using are
    project-specific methods:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  package My::Schema::ResultSet::Artist;
  use base 'DBIx::Class::ResultSet';
  ...

  # BAD IDEA!
  #__PACKAGE__-&gt;resultset_attributes({ prefetch =&gt; 'tracks' });

  # GOOD IDEA!
  sub with_tracks { shift-&gt;search({}, { prefetch =&gt; 'tracks' }) }

  # in your code
  $schema-&gt;resultset('Artist')-&gt;with_tracks-&gt;...
</pre>
<p class="Pp">This gives you the flexibility of not using it when you don't need
    it.</p>
<p class="Pp">For more complex situations, another solution would be to use a
    virtual view via DBIx::Class::ResultSource::View.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="name"><a class="permalink" href="#name">name</a></h2>
<dl class="Bl-tag">
  <dt>Arguments: none</dt>
  <dd></dd>
  <dt>Result value: $name</dt>
  <dd></dd>
</dl>
<p class="Pp">Returns the name of the result source, which will typically be the
    table name. This may be a scalar reference if the result source has a
    non-standard name.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="source_name"><a class="permalink" href="#source_name">source_name</a></h2>
<dl class="Bl-tag">
  <dt>Arguments: $source_name</dt>
  <dd></dd>
  <dt>Result value: $source_name</dt>
  <dd></dd>
</dl>
<p class="Pp">Set an alternate name for the result source when it is loaded into
    a schema. This is useful if you want to refer to a result source by a name
    other than its class name.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  package ArchivedBooks;
  use base qw/DBIx::Class/;
  __PACKAGE__-&gt;table('books_archive');
  __PACKAGE__-&gt;source_name('Books');

  # from your schema...
  $schema-&gt;resultset('Books')-&gt;find(1);
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="from"><a class="permalink" href="#from">from</a></h2>
<dl class="Bl-tag">
  <dt>Arguments: none</dt>
  <dd></dd>
  <dt>Return Value: FROM clause</dt>
  <dd></dd>
</dl>
<p class="Pp"><span class="Li"></span></p>
<pre>
  my $from_clause = $source-&gt;from();
</pre>
<p class="Pp">Returns an expression of the source to be supplied to storage to
    specify retrieval from this source. In the case of a database, the required
    FROM clause contents.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="schema"><a class="permalink" href="#schema">schema</a></h2>
<dl class="Bl-tag">
  <dt>Arguments: $schema?</dt>
  <dd></dd>
  <dt>Return Value: $schema</dt>
  <dd></dd>
</dl>
<p class="Pp"><span class="Li"></span></p>
<pre>
  my $schema = $source-&gt;schema();
</pre>
<p class="Pp">Sets and/or returns the DBIx::Class::Schema object to which this
    result source instance has been attached to.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="storage"><a class="permalink" href="#storage">storage</a></h2>
<dl class="Bl-tag">
  <dt>Arguments: none</dt>
  <dd></dd>
  <dt>Return Value: $storage</dt>
  <dd></dd>
</dl>
<p class="Pp"><span class="Li"></span></p>
<pre>
  $source-&gt;storage-&gt;debug(1);
</pre>
<p class="Pp">Returns the storage handle for the current schema.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="add_relationship"><a class="permalink" href="#add_relationship">add_relationship</a></h2>
<dl class="Bl-tag">
  <dt>Arguments: $rel_name, $related_source_name, \%cond, \%attrs?</dt>
  <dd></dd>
  <dt>Return Value: 1/true if it succeeded</dt>
  <dd></dd>
</dl>
<p class="Pp"><span class="Li"></span></p>
<pre>
  $source-&gt;add_relationship('rel_name', 'related_source', $cond, $attrs);
</pre>
<p class="Pp">DBIx::Class::Relationship describes a series of methods which
    create pre-defined useful types of relationships. Look there first before
    using this method directly.</p>
<p class="Pp">The relationship name can be arbitrary, but must be unique for
    each relationship attached to this result source. 'related_source' should be
    the name with which the related result source was registered with the
    current schema. For example:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  $schema-&gt;source('Book')-&gt;add_relationship('reviews', 'Review', {
    'foreign.book_id' =&gt; 'self.id',
  });
</pre>
<p class="Pp">The condition <span class="Li">$cond</span> needs to be an
    SQL::Abstract-style representation of the join between the tables. For
    example, if you're creating a relation from Author to Book,</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  { 'foreign.author_id' =&gt; 'self.id' }
</pre>
<p class="Pp">will result in the JOIN clause</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  author me JOIN book foreign ON foreign.author_id = me.id
</pre>
<p class="Pp">You can specify as many foreign =&gt; self mappings as
  necessary.</p>
<p class="Pp">Valid attributes are as follows:</p>
<dl class="Bl-tag">
  <dt>join_type</dt>
  <dd>Explicitly specifies the type of join to use in the relationship. Any SQL
      join type is valid, e.g. <span class="Li">&quot;LEFT&quot;</span> or
      <span class="Li">&quot;RIGHT&quot;</span>. It will be placed in the SQL
      command immediately before <span class="Li">&quot;JOIN&quot;</span>.</dd>
  <dt>proxy</dt>
  <dd>An arrayref containing a list of accessors in the foreign class to proxy
      in the main class. If, for example, you do the following:
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  CD-&gt;might_have(liner_notes =&gt; 'LinerNotes', undef, {
    proxy =&gt; [ qw/notes/ ],
  });
    </pre>
    <p class="Pp">Then, assuming LinerNotes has an accessor named notes, you can
        do:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  my $cd = CD-&gt;find(1);
  # set notes -- LinerNotes object is created if it doesn't exist
  $cd-&gt;notes('Notes go here');
    </pre>
  </dd>
  <dt>accessor</dt>
  <dd>Specifies the type of accessor that should be created for the
      relationship. Valid values are <span class="Li">&quot;single&quot;</span>
      (for when there is only a single related object),
      <span class="Li">&quot;multi&quot;</span> (when there can be many), and
      <span class="Li">&quot;filter&quot;</span> (for when there is a single
      related object, but you also want the relationship accessor to double as a
      column accessor). For <span class="Li">&quot;multi&quot;</span> accessors,
      an add_to_* method is also created, which calls
      <span class="Li">&quot;create_related&quot;</span> for the
    relationship.</dd>
</dl>
<p class="Pp">Throws an exception if the condition is improperly supplied, or
    cannot be resolved.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="relationships"><a class="permalink" href="#relationships">relationships</a></h2>
<dl class="Bl-tag">
  <dt>Arguments: none</dt>
  <dd></dd>
  <dt>Return Value: @rel_names</dt>
  <dd></dd>
</dl>
<p class="Pp"><span class="Li"></span></p>
<pre>
  my @relnames = $source-&gt;relationships();
</pre>
<p class="Pp">Returns all relationship names for this source.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="relationship_info"><a class="permalink" href="#relationship_info">relationship_info</a></h2>
<dl class="Bl-tag">
  <dt>Arguments: $rel_name</dt>
  <dd></dd>
  <dt>Return Value: \%rel_data</dt>
  <dd></dd>
</dl>
<p class="Pp">Returns a hash of relationship information for the specified
    relationship name. The keys/values are as specified for
    &quot;add_relationship&quot; in DBIx::Class::Relationship::Base.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="has_relationship"><a class="permalink" href="#has_relationship">has_relationship</a></h2>
<dl class="Bl-tag">
  <dt>Arguments: $rel_name</dt>
  <dd></dd>
  <dt>Return Value: 1/0 (true/false)</dt>
  <dd></dd>
</dl>
<p class="Pp">Returns true if the source has a relationship of this name, false
    otherwise.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="reverse_relationship_info"><a class="permalink" href="#reverse_relationship_info">reverse_relationship_info</a></h2>
<dl class="Bl-tag">
  <dt>Arguments: $rel_name</dt>
  <dd></dd>
  <dt>Return Value: \%rel_data</dt>
  <dd></dd>
</dl>
<p class="Pp">Looks through all the relationships on the source this
    relationship points to, looking for one whose condition is the reverse of
    the condition on this relationship.</p>
<p class="Pp">A common use of this is to find the name of the
    <span class="Li">&quot;belongs_to&quot;</span> relation opposing a
    <span class="Li">&quot;has_many&quot;</span> relation. For definition of
    these look in DBIx::Class::Relationship.</p>
<p class="Pp">The returned hashref is keyed by the name of the opposing
    relationship, and contains its data in the same manner as
    &quot;relationship_info&quot;.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="related_source"><a class="permalink" href="#related_source">related_source</a></h2>
<dl class="Bl-tag">
  <dt>Arguments: $rel_name</dt>
  <dd></dd>
  <dt>Return Value: $source</dt>
  <dd></dd>
</dl>
<p class="Pp">Returns the result source object for the given relationship.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="related_class"><a class="permalink" href="#related_class">related_class</a></h2>
<dl class="Bl-tag">
  <dt>Arguments: $rel_name</dt>
  <dd></dd>
  <dt>Return Value: $classname</dt>
  <dd></dd>
</dl>
<p class="Pp">Returns the class name for objects in the given relationship.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="handle"><a class="permalink" href="#handle">handle</a></h2>
<dl class="Bl-tag">
  <dt>Arguments: none</dt>
  <dd></dd>
  <dt>Return Value: $source_handle</dt>
  <dd></dd>
</dl>
<p class="Pp">Obtain a new result source handle instance for this source. Used
    as a serializable pointer to this resultsource, as it is not easy (nor
    advisable) to serialize CODErefs which may very well be present in e.g.
    relationship definitions.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="throw_exception"><a class="permalink" href="#throw_exception">throw_exception</a></h2>
See &quot;throw_exception&quot; in DBIx::Class::Schema.
</section>
<section class="Ss">
<h2 class="Ss" id="source_info"><a class="permalink" href="#source_info">source_info</a></h2>
Stores a hashref of per-source metadata. No specific key names have yet been
  standardized, the examples below are purely hypothetical and don't actually
  accomplish anything on their own:
<p class="Pp"><span class="Li"></span></p>
<pre>
  __PACKAGE__-&gt;source_info({
    &quot;_tablespace&quot; =&gt; 'fast_disk_array_3',
    &quot;_engine&quot; =&gt; 'InnoDB',
  });
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="new"><a class="permalink" href="#new">new</a></h2>
<span class="Li"></span>
<pre>
  $class-&gt;new();

  $class-&gt;new({attribute_name =&gt; value});
</pre>
<p class="Pp">Creates a new ResultSource object. Not normally called directly by
    end users.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="column_info_from_storage"><a class="permalink" href="#column_info_from_storage">column_info_from_storage</a></h2>
<dl class="Bl-tag">
  <dt>Arguments: 1/0 (default: 0)</dt>
  <dd></dd>
  <dt>Return Value: 1/0</dt>
  <dd></dd>
</dl>
<p class="Pp"><span class="Li"></span></p>
<pre>
  __PACKAGE__-&gt;column_info_from_storage(1);
</pre>
<p class="Pp">Enables the on-demand automatic loading of the above column
    metadata from storage as necessary. This is *deprecated*, and should not be
    used. It will be removed before 1.0.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR_AND_CONTRIBUTORS"><a class="permalink" href="#AUTHOR_AND_CONTRIBUTORS">AUTHOR
  AND CONTRIBUTORS</a></h1>
See AUTHOR and CONTRIBUTORS in DBIx::Class
</section>
<section class="Sh">
<h1 class="Sh" id="LICENSE"><a class="permalink" href="#LICENSE">LICENSE</a></h1>
You may distribute this code under the same terms as Perl itself.
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2014-01-22</td>
    <td class="foot-os">perl v5.18.4</td>
  </tr>
</table>
</body>
</html>
