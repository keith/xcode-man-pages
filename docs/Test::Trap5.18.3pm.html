<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    .Nd, .Bf, .Op { display: inline; }
    .Pa, .Ad { font-style: italic; }
    .Ms { font-weight: bold; }
    .Bl-diag > dt { font-weight: bold; }
    code.Nm, .Fl, .Cm, .Ic, code.In, .Fd, .Fn, .Cd { font-weight: bold;
      font-family: inherit; }
  </style>
  <title>Test::Trap(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Test::Trap(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Test::Trap(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Test::Trap - Trap exit codes, exceptions, output, etc.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="VERSION"><a class="permalink" href="#VERSION">VERSION</a></h1>
<p class="Pp">Version 0.2.3</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>  use Test::More;
  use Test::Trap;
  my @r = trap { some_code(@some_parameters) };
  is ( $trap-&gt;exit, 1, 'Expecting &amp;some_code to exit with 1' );
  is ( $trap-&gt;stdout, '', 'Expecting no STDOUT' );
  like ( $trap-&gt;stderr, qr/^Bad parameters; exiting\b/, 'Expecting warnings.' );
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">Primarily (but not exclusively) for use in test scripts: A block
    eval on steroids, configurable and extensible, but by default trapping
    (Perl) STDOUT, STDERR, warnings, exceptions, would-be exit codes, and return
    values from boxed blocks of test code.</p>
<p class="Pp">The values collected by the latest trap can then be queried or
    tested through a special trap object.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="EXPORT"><a class="permalink" href="#EXPORT">EXPORT</a></h1>
<p class="Pp">A function and a scalar may be exported by any name. The function
    (by default named <span class="Li">&quot;trap&quot;</span>) is an analogue
    to block <i>eval()</i>, and the scalar (by default named
    <span class="Li">$trap</span>) is the corresponding analogue to
    <span class="Li">$@</span>.</p>
<p class="Pp">Optionally, you may specify the layers of the exported trap.
    Layers may be specified by name, with a colon sigil. Multiple layers may be
    given in a list, or just stringed together like
    <span class="Li">&quot;:flow:stderr:warn&quot;</span>.</p>
<p class="Pp">(For the advanced user, you may also specify anonymous layer
    implementations -- i.e. an appropriate subroutine.)</p>
<p class="Pp">See below for a list of the built-in layers, most of which are
    enabled by default. Note, finally, that the ordering of the layers matter:
    The :raw layer is always on the bottom (anything underneath it is ignored),
    and any other &quot;flow control&quot; layers used should be right down
    there with it.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="FUNCTION"><a class="permalink" href="#FUNCTION">FUNCTION</a></h1>
<section class="Ss">
<h2 class="Ss" id="trap_"><a class="permalink" href="#trap_">trap BLOCK</a></h2>
<p class="Pp">This function may be exported by any name, but defaults to
    <span class="Li">&quot;trap&quot;</span>.</p>
<p class="Pp">By default, traps exceptions (like block eval), but also exits and
    exit codes, returns and return values, context, and (Perl) output on STDOUT
    or STDERR, and warnings. All information trapped can be queried through the
    trap object, which is by default exported as <span class="Li">$trap</span>,
    but can be exported by any name.</p>
<p class="Pp">The value returned from <span class="Li">&quot;trap&quot;</span>
    mimics that returned from <span class="Li">&quot;eval&quot;</span>: If the
    <i>BLOCK</i> would die or exit, it returns an undefined value in scalar
    context or an empty list in list context; otherwise it returns whatever the
    <i>BLOCK</i> would return in the given context (also available as the
    trapped return values).</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="TRAP_LAYERS"><a class="permalink" href="#TRAP_LAYERS">TRAP
  LAYERS</a></h1>
<p class="Pp">Exactly what the <span class="Li">&quot;trap&quot;</span> traps
    depends on the layers of the trap. It is possible to register more (see
    Test::Trap::Builder), but the following layers are pre-defined by this
    module:</p>
<section class="Ss">
<h2 class="Ss" id=":raw"><a class="permalink" href="#:raw">:raw</a></h2>
<p class="Pp">The terminating layer, at which the processing of the layers
    stops, and the actual call to the user code is performed. On success, it
    collects the return value(s) in the appropriate context. Pushing the :raw
    layer on a trap will for most purposes remove all layers below.</p>
</section>
<section class="Ss">
<h2 class="Ss" id=":die"><a class="permalink" href="#:die">:die</a></h2>
<p class="Pp">The layer emulating block eval, capturing normal exceptions.</p>
</section>
<section class="Ss">
<h2 class="Ss" id=":exit"><a class="permalink" href="#:exit">:exit</a></h2>
<p class="Pp">The third &quot;flow control&quot; layer, capturing exit codes if
    anything used in the dynamic scope of the trap calls
    <i>CORE::GLOBAL::exit()</i>. (See CAVEATS below for more.)</p>
</section>
<section class="Ss">
<h2 class="Ss" id=":flow"><a class="permalink" href="#:flow">:flow</a></h2>
<p class="Pp">A pseudo-layer shortcut for :raw:die:exit. Since this includes
    :raw, pushing :flow on a trap will remove all layers below.</p>
</section>
<section class="Ss">
<h2 class="Ss" id=":stdout,_:stderr"><a class="permalink" href="#:stdout,_:stderr">:stdout,
  :stderr</a></h2>
<p class="Pp">Layers trapping Perl output on STDOUT and STDERR,
  respectively.</p>
</section>
<section class="Ss">
<h2 class="Ss" id=":stdout(perlio),_:stderr(perlio)"><a class="permalink" href="#:stdout(perlio),_:stderr(perlio)">:stdout(perlio),
  :stderr(perlio)</a></h2>
<p class="Pp">As above, but specifying a backend implemented using
    PerlIO::scalar. If this backend is not available (typically if PerlIO is
    not), this is an error.</p>
</section>
<section class="Ss">
<h2 class="Ss" id=":stdout(tempfile),_:stderr(tempfile)"><a class="permalink" href="#:stdout(tempfile),_:stderr(tempfile)">:stdout(tempfile),
  :stderr(tempfile)</a></h2>
<p class="Pp">As above, but specifying a backend implemented using File::Temp.
    Note that this is the default implementation, unless the
    <span class="Li">&quot;:output()&quot;</span> layer is used to set another
    default.</p>
</section>
<section class="Ss">
<h2 class="Ss" id=":stdout(a;b;c),_:stderr(a,b,c)"><a class="permalink" href="#:stdout(a;b;c),_:stderr(a,b,c)">:stdout(a;b;c),
  :stderr(a,b,c)</a></h2>
<p class="Pp">(Either syntax, commas or semicolons, is permitted, as is any
    number of names in the list.) As above, but specifying the backend
    implementation by the first existing name among <i>a</i>, <i>b</i>, and
    <i>c</i>. If no such implementation is available, this is an error.</p>
</section>
<section class="Ss">
<h2 class="Ss" id=":warn"><a class="permalink" href="#:warn">:warn</a></h2>
<p class="Pp">A layer trapping warnings, with additional tee: If STDERR is open,
    it will also print the warnings there. (This output may be trapped by the
    :stderr layer, be it above or below the :warn layer.)</p>
</section>
<section class="Ss">
<h2 class="Ss" id=":default"><a class="permalink" href="#:default">:default</a></h2>
<p class="Pp">A pseudo-layer short-cut for :raw:die:exit:stdout:stderr:warn.
    Since this includes :raw, pushing :default on a trap will remove all layers
    below. The other interesting property of :default is that it is what every
    trap starts with: In order not to include any of the six layers that make up
    :default, you need to push a terminating layer (such as :raw or :flow) on
    the trap.</p>
</section>
<section class="Ss">
<h2 class="Ss" id=":on_fail(m)"><a class="permalink" href="#:on_fail(m)">:on_fail(m)</a></h2>
<p class="Pp">A (non-default) pseudo-layer that installs a callback method (by
    name) <i>m</i> to be run on test failures. To run the &quot;diag_all&quot;
    method every time a test fails:</p>
<p class="Pp"></p>
<pre>  use Test::Trap qw/ :on_fail(diag_all) /;
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id=":void,_:scalar,_:list"><a class="permalink" href="#:void,_:scalar,_:list">:void,
  :scalar, :list</a></h2>
<p class="Pp">Runs the trapped user code in void, scalar, or list context,
    respectively. (By default, the code is run in whatever context the trap
    itself is in.)</p>
<p class="Pp">If more than one of these layers are pushed on the trap, the
    deepest (that is, leftmost) takes precedence:</p>
<p class="Pp"></p>
<pre>  use Test::Trap qw/ :scalar:void:list /;
  trap { 42, 13 };
  $trap-&gt;return_is_deeply( [ 13 ], 'Scalar comma.' );
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id=":output(a;b;c)"><a class="permalink" href="#:output(a;b;c)">:output(a;b;c)</a></h2>
<p class="Pp">A (non-default) pseudo-layers that sets the default backend layer
    implementation for any output trapping
    (<span class="Li">&quot;:stdout&quot;</span>,
    <span class="Li">&quot;:stderr&quot;</span>, or other similarly defined)
    layers already on the trap.</p>
<p class="Pp"></p>
<pre>  use Test::Trap qw/ :output(systemsafe) /;
  trap { system echo =&gt; 'Hello Unix!' }; # trapped!
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="RESULT_ACCESSORS"><a class="permalink" href="#RESULT_ACCESSORS">RESULT
  ACCESSORS</a></h1>
<p class="Pp">The following methods may be called on the trap objects after any
    trap has been sprung, and access the outcome of the run.</p>
<p class="Pp">Any property will be undef if not actually trapped -- whether
    because there is no layer to trap them or because flow control passed them
    by. (If there is an active and successful trap layer, empty strings and
    empty arrays trapped will of course be defined.)</p>
<p class="Pp">When properties are set, their values will be as follows:</p>
<section class="Ss">
<h2 class="Ss" id="leaveby"><a class="permalink" href="#leaveby">leaveby</a></h2>
<p class="Pp">A string indicating how the trap terminated:
    <span class="Li">&quot;return&quot;</span>,
    <span class="Li">&quot;die&quot;</span>, or
    <span class="Li">&quot;exit&quot;</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="die"><a class="permalink" href="#die">die</a></h2>
<p class="Pp">The exception, if the latest trap threw one.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="exit"><a class="permalink" href="#exit">exit</a></h2>
<p class="Pp">The exit code, if the latest trap tried to exit (by way of the
    trap's own &amp;CORE::GLOBAL::exit only; see &quot;CAVEATS&quot;).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="return__"><a class="permalink" href="#return__">return [INDEX
  ...]</a></h2>
<p class="Pp">Returns undef if the latest trap did not terminate with a return;
    otherwise returns three different views of the return array:</p>
<ul class="Bl-bullet">
  <li>if no <i>INDEX</i> is passed, returns a reference to the array (NB! an
      empty array of indices qualifies as &quot;no index&quot;)</li>
  <li>if called with at least one <i>INDEX</i> in scalar context, returns the
      array element indexed by the first <i>INDEX</i> (ignoring the rest)</li>
  <li>if called with at least one <i>INDEX</i> in list context, returns the
      slice of the array by these indices</li>
</ul>
<p class="Pp">Note: The array will hold but a single value if the trap was
    sprung in scalar context, and will be empty if it was in void context.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="stdout,_stderr"><a class="permalink" href="#stdout,_stderr">stdout,
  stderr</a></h2>
<p class="Pp">The captured output on the respective file handles.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="warn__"><a class="permalink" href="#warn__">warn
  [INDEX]</a></h2>
<p class="Pp">Returns undef if the latest trap had no warning-trapping layer;
    otherwise returns three different views of the warn array:</p>
<ul class="Bl-bullet">
  <li>if no <i>INDEX</i> is passed, returns a reference to the array (NB! an
      empty array of indices qualifies as &quot;no index&quot;)</li>
  <li>if called with at least one <i>INDEX</i> in scalar context, returns the
      array element indexed by the first <i>INDEX</i> (ignoring the rest)</li>
  <li>if called with at least one <i>INDEX</i> in list context, returns the
      slice of the array by these indices</li>
</ul>
</section>
<section class="Ss">
<h2 class="Ss" id="wantarray"><a class="permalink" href="#wantarray">wantarray</a></h2>
<p class="Pp">The context in which the latest code trapped was called. (By
    default a propagated context, but layers can override this.)</p>
</section>
<section class="Ss">
<h2 class="Ss" id="list,_scalar,_void"><a class="permalink" href="#list,_scalar,_void">list,
  scalar, void</a></h2>
<p class="Pp">True if the latest code trapped was called in the indicated
    context. (By default the code will be called in a propagated context, but
    layers can override this.)</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="RESULT_TESTS"><a class="permalink" href="#RESULT_TESTS">RESULT
  TESTS</a></h1>
<p class="Pp">For each accessor, a number of convenient standard test methods
    are also available. By default, these are a few standard tests from
    Test::More, plus the <span class="Li">&quot;nok&quot;</span> test (a negated
    <span class="Li">&quot;ok&quot;</span> test). All for convenience:</p>
<section class="Ss">
<h2 class="Ss"><i>ACCESSOR</i>_ok [INDEX,] TEST_NAME</h2>
</section>
<section class="Ss">
<h2 class="Ss"><i>ACCESSOR</i>_nok [INDEX,] TEST_NAME</h2>
</section>
<section class="Ss">
<h2 class="Ss"><i>ACCESSOR</i>_is [INDEX,] SCALAR, TEST_NAME</h2>
</section>
<section class="Ss">
<h2 class="Ss"><i>ACCESSOR</i>_isnt [INDEX,] SCALAR, TEST_NAME</h2>
</section>
<section class="Ss">
<h2 class="Ss"><i>ACCESSOR</i>_isa_ok [INDEX,] SCALAR, INVOCANT_NAME</h2>
</section>
<section class="Ss">
<h2 class="Ss"><i>ACCESSOR</i>_like [INDEX,] REGEX, TEST_NAME</h2>
</section>
<section class="Ss">
<h2 class="Ss"><i>ACCESSOR</i>_unlike [INDEX,] REGEX, TEST_NAME</h2>
</section>
<section class="Ss">
<h2 class="Ss"><i>ACCESSOR</i>_is_deeply STRUCTURE, TEST_NAME</h2>
<p class="Pp"><i>INDEX</i> is not optional: It is required for array accessors
    (like <span class="Li">&quot;return&quot;</span> and
    <span class="Li">&quot;warn&quot;</span>), and disallowed for scalar
    accessors. Note that the <span class="Li">&quot;is_deeply&quot;</span> test
    does not accept an index. Even for array accessors, it operates on the
    entire array.</p>
<p class="Pp">For convenience and clarity, tests against a flow control
    <i>ACCESSOR</i> (<span class="Li">&quot;return&quot;</span>,
    <span class="Li">&quot;die&quot;</span>,
    <span class="Li">&quot;exit&quot;</span>, or any you define yourself) will
    first test whether the trap was left by way of the flow control mechanism in
    question, and fail with appropriate diagnostics otherwise.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="did_die,_did_exit,_did_return"><a class="permalink" href="#did_die,_did_exit,_did_return">did_die,
  did_exit, did_return</a></h2>
<p class="Pp">Conveniences: Tests whether the trap was left by way of the flow
    control mechanism in question. Much like
    <span class="Li">&quot;leaveby_is('die')&quot;</span> etc, but with better
    diagnostics and (run-time) spell checking.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="quiet"><a class="permalink" href="#quiet">quiet</a></h2>
<p class="Pp">Convenience: Passes if zero-length output was trapped on both
    STDOUT and STDERR, and generate better diagnostics otherwise.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="UTILITIES"><a class="permalink" href="#UTILITIES">UTILITIES</a></h1>
<section class="Ss">
<h2 class="Ss" id="diag_all"><a class="permalink" href="#diag_all">diag_all</a></h2>
<p class="Pp">Prints a diagnostic message (as per &quot;diag&quot; in
    Test::More) consisting of a dump (in Perl code, as per Data::Dump) of the
    trap object.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="diag_all_once"><a class="permalink" href="#diag_all_once">diag_all_once</a></h2>
<p class="Pp">As &quot;diag_all&quot;, except if this instance of the trap
    object has already been diag_all_once'd, the diagnostic message will instead
    consist of the string <span class="Li">&quot;(as above)&quot;</span>.</p>
<p class="Pp">This could be useful with the
    <span class="Li">&quot;on_fail&quot;</span> layer:</p>
<p class="Pp"></p>
<pre>  use Test::Trap qw/ :on_fail(diag_all_once) /;
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="CAVEATS"><a class="permalink" href="#CAVEATS">CAVEATS</a></h1>
<p class="Pp">This module must be loaded before any code containing
    <i>exit()</i>s to be trapped is compiled. Any <i>exit()</i> already compiled
    won't be trappable, and will terminate the program anyway.</p>
<p class="Pp">This module overrides &amp;CORE::GLOBAL::exit, so may not work
    correctly (or even at all) in the presence of other code overriding
    &amp;CORE::GLOBAL::exit. More precisely: This module installs its own
    <i>exit()</i> on entry of the block, and restores the previous one, if any,
    only upon leaving the block.</p>
<p class="Pp">If you use <i>fork()</i> in the dynamic scope of a trap, beware
    that the (default) :exit layer of that trap does not trap <i>exit()</i> in
    the children, but passes them to the outer handler. If you think about it,
    this is what you are likely to want it to do in most cases.</p>
<p class="Pp">Note that the (default) :exit layer only traps
    &amp;CORE::GLOBAL::exit calls (and bare <i>exit()</i> calls that compile to
    that). It makes no attempt to trap <i>CORE::exit()</i>,
    <i>POSIX::_exit()</i>, <i>exec()</i>, untrapped exceptions from
    <i>die()</i>, nor segfault. Nor does it attempt to trap anything else that
    might terminate the program. The trap is a block eval on steroids -- not the
    last block eval of Krypton!</p>
<p class="Pp">This module traps warnings using
    <span class="Li">$SIG{__WARN__}</span>, so may not work correctly (or even
    at all) in the presence of other code setting this handler. More precisely:
    This module installs its own __WARN__ handler on entry of the block, and
    restores the previous one, if any, only upon leaving the block.</p>
<p class="Pp">The (default) :stdout and :stderr handlers will not trap output
    from <i>system()</i> calls.</p>
<p class="Pp">Threads? No idea. It might even work correctly.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="BUGS"><a class="permalink" href="#BUGS">BUGS</a></h1>
<p class="Pp">Please report any bugs or feature requests directly to the
  author.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">Eirik Berg Hanssen,
    <span class="Li">&quot;&lt;ebhanssen@allverden.no&gt;&quot;</span></p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT_&amp;_LICENSE"><a class="permalink" href="#COPYRIGHT_&amp;_LICENSE">COPYRIGHT
  &amp; LICENSE</a></h1>
<p class="Pp">Copyright 2006-2012 Eirik Berg Hanssen, All Rights Reserved.</p>
<p class="Pp">This program is free software; you can redistribute it and/or
    modify it under the same terms as Perl itself.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2022-02-12</td>
    <td class="foot-os">perl v5.18.4</td>
  </tr>
</table>
</body>
</html>
