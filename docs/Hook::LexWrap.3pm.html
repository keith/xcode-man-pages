<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>Hook::LexWrap(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Hook::LexWrap(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Hook::LexWrap(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
Hook::LexWrap - Lexically scoped subroutine wrappers
</section>
<section class="Sh">
<h1 class="Sh" id="VERSION"><a class="permalink" href="#VERSION">VERSION</a></h1>
This document describes version 0.23 of Hook::LexWrap.
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<span class="Li"></span>
<pre>
        use Hook::LexWrap;

        sub doit { print &quot;[doit:&quot;, caller, &quot;]&quot;; return {my=&gt;&quot;data&quot;} }

        SCOPED: {
                wrap doit,
                        pre  =&gt; sub { print &quot;[pre1: @_]\n&quot; },
                        post =&gt; sub { print &quot;[post1:@_]\n&quot;; $_[1]=9; };

                my $temporarily = wrap doit,
                        post =&gt; sub { print &quot;[post2:@_]\n&quot; },
                        pre  =&gt; sub { print &quot;[pre2: @_]\n  &quot;};

                @args = (1,2,3);
                doit(@args);    # pre2-&gt;pre1-&gt;doit-&gt;post1-&gt;post2
        }

        @args = (4,5,6);
        doit(@args);            # pre1-&gt;doit-&gt;post1
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
Hook::LexWrap allows you to install a pre- or post-wrapper (or both) around an
  existing subroutine. Unlike other modules that provide this capacity (e.g.
  Hook::PreAndPost and Hook::WrapSub), Hook::LexWrap implements wrappers in such
  a way that the standard <span class="Li">&quot;caller&quot;</span> function
  works correctly within the wrapped subroutine.
<p class="Pp">To install a prewrappers, you write:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
        use Hook::LexWrap;

        wrap 'subroutine_name', pre =&gt; \&amp;some_other_sub;

   #or: wrap *subroutine_name,  pre =&gt; \&amp;some_other_sub;
</pre>
<p class="Pp">The first argument to <span class="Li">&quot;wrap&quot;</span> is
    a string containing the name of the subroutine to be wrapped (or the
    typeglob containing it, or a reference to it). The subroutine name may be
    qualified, and the subroutine must already be defined. The second argument
    indicates the type of wrapper being applied and must be either
    <span class="Li">'pre'</span> or <span class="Li">'post'</span>. The third
    argument must be a reference to a subroutine that implements the
  wrapper.</p>
<p class="Pp">To install a post-wrapper, you write:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
        wrap 'subroutine_name', post =&gt; \&amp;yet_another_sub;

   #or: wrap *subroutine_name,  post =&gt; \&amp;yet_another_sub;
</pre>
<p class="Pp">To install both at once:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
        wrap 'subroutine_name',
             pre  =&gt; \&amp;some_other_sub,
             post =&gt; \&amp;yet_another_sub;
</pre>
<p class="Pp">or:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
        wrap *subroutine_name,
             post =&gt; \&amp;yet_another_sub,  # order in which wrappers are
             pre  =&gt; \&amp;some_other_sub;   # specified doesn't matter
</pre>
<p class="Pp">Once they are installed, the pre- and post-wrappers will be called
    before and after the subroutine itself, and will be passed the same argument
    list.</p>
<p class="Pp">The pre- and post-wrappers and the original subroutine also all
    see the same (correct!) values from
    <span class="Li">&quot;caller&quot;</span> and
    <span class="Li">&quot;wantarray&quot;</span>.</p>
<section class="Ss">
<h2 class="Ss" id="Short-circuiting_and_long-circuiting_return_values"><a class="permalink" href="#Short-circuiting_and_long-circuiting_return_values">Short-circuiting
  and long-circuiting return values</a></h2>
The pre- and post-wrappers both receive an extra argument in their
  <span class="Li">@_</span> arrays. That extra argument is appended to the
  original argument list (i.e. is can always be accessed as
  <span class="Li">$_</span>[-1]) and acts as a place-holder for the original
  subroutine's return value.
<p class="Pp">In a pre-wrapper, <span class="Li">$_</span>[-1] is -- for obvious
    reasons -- <span class="Li">&quot;undef&quot;</span>. However,
    <span class="Li">$_</span>[-1] may be assigned to in a pre-wrapper, in which
    case Hook::LexWrap assumes that the original subroutine has been
    &quot;pre-empted&quot;, and that neither it, nor the corresponding
    post-wrapper, nor any wrappers that were applied <i>before</i> the
    pre-empting pre-wrapper was installed, need be run. Note that any
    post-wrappers that were installed after the pre-empting pre-wrapper was
    installed <i>will</i> still be called before the original subroutine call
    returns.</p>
<p class="Pp">In a post-wrapper, <span class="Li">$_</span>[-1] contains the
    return value produced by the wrapped subroutine. In a scalar return context,
    this value is the scalar return value. In an list return context, this value
    is a reference to the array of return values. <span class="Li">$_</span>[-1]
    may be assigned to in a post-wrapper, and this changes the return value
    accordingly.</p>
<p class="Pp">Access to the arguments and return value is useful for
    implementing techniques such as memoization:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
        my %cache;
        wrap fibonacci,
                pre  =&gt; sub { $_[-1] = $cache{$_[0]} if $cache{$_[0]} },
                post =&gt; sub { $cache{$_[0]} = $_[-1] };
</pre>
<p class="Pp">or for converting arguments and return values in a consistent
    manner:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
        # set_temp expects and returns degrees Fahrenheit,
        # but we want to use Celsius
        wrap set_temp,
                pre   =&gt; sub { splice @_, 0, 1, $_[0] * 1.8 + 32 },
                post  =&gt; sub { $_[-1] = ($_[0] - 32) / 1.8 };
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Lexically_scoped_wrappers"><a class="permalink" href="#Lexically_scoped_wrappers">Lexically
  scoped wrappers</a></h2>
Normally, any wrappers installed by <span class="Li">&quot;wrap&quot;</span>
  remain attached to the subroutine until it is undefined. However, it is
  possible to make specific wrappers lexically bound, so that they operate only
  until the end of the scope in which they're created (or until some other
  specific point in the code).
<p class="Pp">If <span class="Li">&quot;wrap&quot;</span> is called in a
    <i>non-void</i> context:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
        my $lexical = wrap 'sub_name', pre =&gt; \&amp;wrapper;
</pre>
<p class="Pp">it returns a special object corresponding to the particular
    wrapper being placed around the original subroutine. When that object is
    destroyed -- when its container variable goes out of scope, or when its
    reference count otherwise falls to zero (e.g. <span class="Li">&quot;undef
    $lexical&quot;</span>), or when it is explicitly destroyed
    (<span class="Li">&quot;$lexical-&gt;DESTROY&quot;</span>) -- the
    corresponding wrapper is removed from around the original subroutine. Note,
    however, that all other wrappers around the subroutine are preserved.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Anonymous_wrappers"><a class="permalink" href="#Anonymous_wrappers">Anonymous
  wrappers</a></h2>
If the subroutine to be wrapped is passed as a reference (rather than by name or
  by typeglob), <span class="Li">&quot;wrap&quot;</span> does not install the
  wrappers around the original subroutine. Instead it generates a new subroutine
  which acts as if it were the original with those wrappers around it. It then
  returns a reference to that new subroutine. Only calls to the original through
  that wrapped reference invoke the wrappers. Direct by-name calls to the
  original, or calls through another reference, do not.
<p class="Pp">If the original is subsequently wrapped by name, the anonymously
    wrapped subroutine reference does not see those wrappers. In other words,
    wrappers installed via a subroutine reference are completely independent of
    those installed via the subroutine's name (or typeglob).</p>
<p class="Pp">For example:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
        sub original { print &quot;ray&quot; }

        # Wrap anonymously...
        my $anon_wrapped = wrap \&amp;original, pre =&gt; sub { print &quot;do...&quot; };

        # Show effects...
        original();             # prints &quot;ray&quot;
        $anon_wrapped-&gt;();      # prints &quot;do..ray&quot;

        # Wrap nonymously...
        wrap *original,
                pre  =&gt; sub { print &quot;fa..&quot; },
                post =&gt; sub { print &quot;..mi&quot; };

        # Show effects...
        original();             #   now prints &quot;fa..ray..mi&quot;
        $anon_wrapped-&gt;();      # still prints &quot;do...ray&quot;
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="DIAGNOSTICS"><a class="permalink" href="#DIAGNOSTICS">DIAGNOSTICS</a></h1>
<dl class="Bl-tag">
  <dt>&quot;Can't wrap non-existent subroutine %s&quot;</dt>
  <dd>An attempt was made to wrap a subroutine that was not defined at the point
      of wrapping.</dd>
  <dt>&quot;'pre' value is not a subroutine reference&quot;</dt>
  <dd>The value passed to <span class="Li">&quot;wrap&quot;</span> after the
      <span class="Li">'pre'</span> flag was not a subroutine reference.
      Typically, someone forgot the <span class="Li">&quot;sub&quot;</span> on
      the anonymous subroutine:
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        wrap 'subname', pre =&gt; { your_code_here() };
    </pre>
    <p class="Pp">and Perl interpreted the last argument as a hash
      constructor.</p>
  </dd>
  <dt>&quot;'post' value is not a subroutine reference&quot;</dt>
  <dd>The value passed to <span class="Li">&quot;wrap&quot;</span> after the
      <span class="Li">'post'</span> flag was not a subroutine reference.</dd>
  <dt>&quot;Uselessly wrapped subroutine reference in void context&quot;
    (warning only)</dt>
  <dd>When the subroutine to be wrapped is passed as a subroutine reference,
      <span class="Li">&quot;wrap&quot;</span> does not install the wrapper
      around the original, but instead returns a reference to a subroutine which
      wraps the original (see &quot;Anonymous wrappers&quot;).
    <p class="Pp">However, there's no point in doing this if you don't catch the
        resulting subroutine reference.</p>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
Damian Conway (damian@conway.org)
</section>
<section class="Sh">
<h1 class="Sh" id="BLAME"><a class="permalink" href="#BLAME">BLAME</a></h1>
Schwern made me do this (by implying it wasn't possible ;-)
</section>
<section class="Sh">
<h1 class="Sh" id="BUGS"><a class="permalink" href="#BUGS">BUGS</a></h1>
There are undoubtedly serious bugs lurking somewhere in code this funky :-)
<p class="Pp">Bug reports and other feedback are most welcome.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
Sub::Prepend
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT"><a class="permalink" href="#COPYRIGHT">COPYRIGHT</a></h1>
<span class="Li"></span>
<pre>
      Copyright (c) 2001, Damian Conway. All Rights Reserved.
    This module is free software. It may be used, redistributed
        and/or modified under the same terms as Perl itself.
</pre>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2020-02-29</td>
    <td class="foot-os">perl v5.18.2</td>
  </tr>
</table>
</body>
</html>
