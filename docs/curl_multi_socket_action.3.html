<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   generated by cd2nroff 0.1 from curl_multi_socket_action.md
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    .Nd, .Bf, .Op { display: inline; }
    .Pa, .Ad { font-style: italic; }
    .Ms { font-weight: bold; }
    .Bl-diag > dt { font-weight: bold; }
    code.Nm, .Fl, .Cm, .Ic, code.In, .Fd, .Fn, .Cd { font-weight: bold;
      font-family: inherit; }
  </style>
  <title>curl_multi_socket_action(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">curl_multi_socket_action(3)</td>
    <td class="head-vol">Library Functions Manual</td>
    <td class="head-rtitle">curl_multi_socket_action(3)</td>
  </tr>
</table>
<div class="manual-text">
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">curl_multi_socket_action - reads/writes available data given an
    action</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>#include &lt;curl/curl.h&gt;
CURLMcode curl_multi_socket_action(CURLM *multi_handle,
<br/>
                                   curl_socket_t sockfd,
<br/>
                                   int ev_bitmask,
<br/>
                                   int *running_handles);</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">When the application has detected action on a socket handled by
    libcurl, it should call <i>curl_multi_socket_action(3)</i> with the
    <b>sockfd</b> argument set to the socket with the action. When the events on
    a socket are known, they can be passed as an events bitmask
    <b>ev_bitmask</b> by first setting <b>ev_bitmask</b> to 0, and then adding
    using bitwise OR (|) any combination of events to be chosen from
    CURL_CSELECT_IN, CURL_CSELECT_OUT or CURL_CSELECT_ERR. When the events on a
    socket are unknown, pass 0 instead, and libcurl tests the descriptor
    internally. It is also permissible to pass CURL_SOCKET_TIMEOUT to the
    <b>sockfd</b> parameter in order to initiate the whole process or when a
    timeout occurs.</p>
<p class="Pp">At return, <b>running_handles</b> points to the number of running
    easy handles within the multi handle. When this number reaches zero, all
    transfers are complete/done. When you call
    <i>curl_multi_socket_action(3)</i> on a specific socket and the counter
    decreases by one, it DOES NOT necessarily mean that this exact
    socket/transfer is the one that completed. Use
    <i>curl_multi_info_read(3)</i> to figure out which easy handle that
    completed.</p>
<p class="Pp">The <i>curl_multi_socket_action(3)</i> function informs the
    application about updates in the socket (file descriptor) status by doing
    none, one, or multiple calls to the socket callback function set with the
    <i>CURLMOPT_SOCKETFUNCTION(3)</i> option to <i>curl_multi_setopt(3)</i>.
    They update the status with changes since the previous time the callback was
    called.</p>
<p class="Pp">Get the timeout time by setting the
    <i>CURLMOPT_TIMERFUNCTION(3)</i> option with <i>curl_multi_setopt(3)</i>.
    Your application then gets called with information on how long to wait for
    socket actions at most before doing the timeout action: call the
    <i>curl_multi_socket_action(3)</i> function with the <b>sockfd</b> argument
    set to CURL_SOCKET_TIMEOUT. You can also use the
    <i>curl_multi_timeout(3)</i> function to poll the value at any given time,
    but for an event-based system using the callback is far better than relying
    on polling the timeout value.</p>
<p class="Pp">When this function returns error, the state of all transfers are
    uncertain and they cannot be continued. <i>curl_multi_socket_action(3)</i>
    should not be called again on the same multi handle after an error has been
    returned, unless first removing all the handles and adding new ones.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="TYPICAL_USAGE"><a class="permalink" href="#TYPICAL_USAGE">TYPICAL
  USAGE</a></h1>
<p class="Pp">1. Create a multi handle</p>
<p class="Pp">2. Set the socket callback with
  <i>CURLMOPT_SOCKETFUNCTION(3)</i></p>
<p class="Pp">3. Set the timeout callback with <i>CURLMOPT_TIMERFUNCTION(3)</i>,
    to get to know what timeout value to use when waiting for socket
  activities.</p>
<p class="Pp">4. Add easy handles with curl_multi_add_handle()</p>
<p class="Pp">5. Provide some means to manage the sockets libcurl is using, so
    you can check them for activity. This can be done through your application
    code, or by way of an external library such as libevent or glib.</p>
<p class="Pp">6. Call curl_multi_socket_action(..., CURL_SOCKET_TIMEOUT, 0, ...)
    to kickstart everything. To get one or more callbacks called.</p>
<p class="Pp">7. Wait for activity on any of libcurl's sockets, use the timeout
    value your callback has been told.</p>
<p class="Pp">8, When activity is detected, call curl_multi_socket_action() for
    the socket(s) that got action. If no activity is detected and the timeout
    expires, call <i>curl_multi_socket_action(3)</i> with
    <i>CURL_SOCKET_TIMEOUT</i>.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="EXAMPLE"><a class="permalink" href="#EXAMPLE">EXAMPLE</a></h1>
<pre>int main(void)
{
<br/>
  /* the event-library gets told when there activity on the socket 'fd',
<br/>
     which we translate to a call to curl_multi_socket_action() */
<br/>
  int running;
<br/>
  CURLM *multi; /* the stack we work with */
<br/>
  int fd; /* the descriptor that had action */
<br/>
  int bitmask; /* what activity that happened */
<br/>
  CURLMcode mc = curl_multi_socket_action(multi, fd, bitmask, &amp;running);
<br/>
  if(mc)
<br/>
    printf(&quot;error: %s\n&quot;, curl_multi_strerror(mc));
}</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="AVAILABILITY"><a class="permalink" href="#AVAILABILITY">AVAILABILITY</a></h1>
<p class="Pp">This function was added in libcurl 7.15.4, and is deemed stable
    since 7.16.0.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="RETURN_VALUE"><a class="permalink" href="#RETURN_VALUE">RETURN
  VALUE</a></h1>
<p class="Pp">CURLMcode type, general libcurl multi interface error code. See
    <i>libcurl-errors(3)</i></p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp"><b>curl_multi_cleanup</b>(3), <b>curl_multi_fdset</b>(3),
    <b>curl_multi_info_read</b>(3), <b>curl_multi_init</b>(3),
    <b>the</b>hiperfifo.c<b>example</b></p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">September 26, 2023</td>
    <td class="foot-os">libcurl 8.4.0</td>
  </tr>
</table>
</body>
</html>
