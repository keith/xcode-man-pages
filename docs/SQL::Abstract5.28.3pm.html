<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.10 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>SQL::Abstract(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">SQL::Abstract(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">SQL::Abstract(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
SQL::Abstract - Generate SQL from Perl data structures
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<span class="Li"></span>
<pre>
    use SQL::Abstract;

    my $sql = SQL::Abstract-&gt;new;

    my($stmt, @bind) = $sql-&gt;select($source, \@fields, \%where, $order);

    my($stmt, @bind) = $sql-&gt;insert($table, \%fieldvals || \@values);

    my($stmt, @bind) = $sql-&gt;update($table, \%fieldvals, \%where);

    my($stmt, @bind) = $sql-&gt;delete($table, \%where);

    # Then, use these in your DBI statements
    my $sth = $dbh-&gt;prepare($stmt);
    $sth-&gt;execute(@bind);

    # Just generate the WHERE clause
    my($stmt, @bind) = $sql-&gt;where(\%where, $order);

    # Return values in the same order, for hashed queries
    # See PERFORMANCE section for more details
    my @bind = $sql-&gt;values(\%fieldvals);
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
This module was inspired by the excellent DBIx::Abstract. However, in using that
  module I found that what I really wanted to do was generate SQL, but still
  retain complete control over my statement handles and use the DBI interface.
  So, I set out to create an abstract SQL generation module.
<p class="Pp">While based on the concepts used by DBIx::Abstract, there are
    several important differences, especially when it comes to WHERE clauses. I
    have modified the concepts used to make the SQL easier to generate from Perl
    data structures and, IMO, more intuitive. The underlying idea is for this
    module to do what you mean, based on the data structures you provide it. The
    big advantage is that you don't have to modify your code every time your
    data changes, as this module figures it out.</p>
<p class="Pp">To begin with, an SQL INSERT is as easy as just specifying a hash
    of <span class="Li">&quot;key=value&quot;</span> pairs:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    my %data = (
        name =&gt; 'Jimbo Bobson',
        phone =&gt; '123-456-7890',
        address =&gt; '42 Sister Lane',
        city =&gt; 'St. Louis',
        state =&gt; 'Louisiana',
    );
</pre>
<p class="Pp">The SQL can then be generated with this:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    my($stmt, @bind) = $sql-&gt;insert('people', \%data);
</pre>
<p class="Pp">Which would give you something like this:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    $stmt = &quot;INSERT INTO people
                    (address, city, name, phone, state)
                    VALUES (?, ?, ?, ?, ?)&quot;;
    @bind = ('42 Sister Lane', 'St. Louis', 'Jimbo Bobson',
             '123-456-7890', 'Louisiana');
</pre>
<p class="Pp">These are then used directly in your DBI code:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    my $sth = $dbh-&gt;prepare($stmt);
    $sth-&gt;execute(@bind);
</pre>
<section class="Ss">
<h2 class="Ss" id="Inserting_and_Updating_Arrays"><a class="permalink" href="#Inserting_and_Updating_Arrays">Inserting
  and Updating Arrays</a></h2>
If your database has array types (like for example Postgres), activate the
  special option <span class="Li">&quot;array_datatypes =&gt; 1&quot;</span>
  when creating the <span class="Li">&quot;SQL::Abstract&quot;</span> object.
  Then you may use an arrayref to insert and update database array types:
<p class="Pp"><span class="Li"></span></p>
<pre>
    my $sql = SQL::Abstract-&gt;new(array_datatypes =&gt; 1);
    my %data = (
        planets =&gt; [qw/Mercury Venus Earth Mars/]
    );

    my($stmt, @bind) = $sql-&gt;insert('solar_system', \%data);
</pre>
<p class="Pp">This results in:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    $stmt = &quot;INSERT INTO solar_system (planets) VALUES (?)&quot;

    @bind = (['Mercury', 'Venus', 'Earth', 'Mars']);
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Inserting_and_Updating__s-1SQL_s0"><a class="permalink" href="#Inserting_and_Updating__s-1SQL_s0">Inserting
  and Updating SQL</a></h2>
In order to apply SQL functions to elements of your
  <span class="Li">%data</span> you may specify a reference to an arrayref for
  the given hash value. For example, if you need to execute the Oracle
  <span class="Li">&quot;to_date&quot;</span> function on a value, you can say
  something like this:
<p class="Pp"><span class="Li"></span></p>
<pre>
    my %data = (
        name =&gt; 'Bill',
        date_entered =&gt; \[ &quot;to_date(?,'MM/DD/YYYY')&quot;, &quot;03/02/2003&quot; ],
    );
</pre>
<p class="Pp">The first value in the array is the actual SQL. Any other values
    are optional and would be included in the bind values array. This gives
  you:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    my($stmt, @bind) = $sql-&gt;insert('people', \%data);

    $stmt = &quot;INSERT INTO people (name, date_entered)
                VALUES (?, to_date(?,'MM/DD/YYYY'))&quot;;
    @bind = ('Bill', '03/02/2003');
</pre>
<p class="Pp">An UPDATE is just as easy, all you change is the name of the
    function:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    my($stmt, @bind) = $sql-&gt;update('people', \%data);
</pre>
<p class="Pp">Notice that your <span class="Li">%data</span> isn't touched; the
    module will generate the appropriately quirky SQL for you automatically.
    Usually you'll want to specify a WHERE clause for your UPDATE, though, which
    is where handling <span class="Li">%where</span> hashes comes in
  handy...</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Complex_where_statements"><a class="permalink" href="#Complex_where_statements">Complex
  where statements</a></h2>
This module can generate pretty complicated WHERE statements easily. For
  example, simple <span class="Li">&quot;key=value&quot;</span> pairs are taken
  to mean equality, and if you want to see if a field is within a set of values,
  you can use an arrayref. Let's say we wanted to SELECT some data based on this
  criteria:
<p class="Pp"><span class="Li"></span></p>
<pre>
    my %where = (
       requestor =&gt; 'inna',
       worker =&gt; ['nwiger', 'rcwe', 'sfz'],
       status =&gt; { '!=', 'completed' }
    );

    my($stmt, @bind) = $sql-&gt;select('tickets', '*', \%where);
</pre>
<p class="Pp">The above would give you something like this:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    $stmt = &quot;SELECT * FROM tickets WHERE
                ( requestor = ? ) AND ( status != ? )
                AND ( worker = ? OR worker = ? OR worker = ? )&quot;;
    @bind = ('inna', 'completed', 'nwiger', 'rcwe', 'sfz');
</pre>
<p class="Pp">Which you could then use in DBI code like so:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    my $sth = $dbh-&gt;prepare($stmt);
    $sth-&gt;execute(@bind);
</pre>
<p class="Pp">Easy, eh?</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="METHODS"><a class="permalink" href="#METHODS">METHODS</a></h1>
The methods are simple. There's one for every major SQL operation, and a
  constructor you use first. The arguments are specified in a similar order for
  each method (table, then fields, then a where clause) to try and simplify
  things.
<section class="Ss">
<h2 class="Ss" id="new(option_=__'value')"><a class="permalink" href="#new(option_=__'value')">new(option
  =&gt; 'value')</a></h2>
The <span class="Li">&quot;new()&quot;</span> function takes a list of options
  and values, and returns a new <b>SQL::Abstract</b> object which can then be
  used to generate SQL through the methods below. The options accepted are:
<dl class="Bl-tag">
  <dt>case</dt>
  <dd>If set to 'lower', then SQL will be generated in all lowercase. By default
      SQL is generated in &quot;textbook&quot; case meaning something like:
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    SELECT a_field FROM a_table WHERE some_field LIKE '%someval%'
    </pre>
    <p class="Pp">Any setting other than 'lower' is ignored.</p>
  </dd>
  <dt>cmp</dt>
  <dd>This determines what the default comparison operator is. By default it is
      <span class="Li">&quot;=&quot;</span>, meaning that a hash like this:
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    %where = (name =&gt; 'nwiger', email =&gt; 'nate@wiger.org');
    </pre>
    <p class="Pp">Will generate SQL like this:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    WHERE name = 'nwiger' AND email = 'nate@wiger.org'
    </pre>
    <p class="Pp">However, you may want loose comparisons by default, so if you
        set <span class="Li">&quot;cmp&quot;</span> to
        <span class="Li">&quot;like&quot;</span> you would get SQL such as:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    WHERE name like 'nwiger' AND email like 'nate@wiger.org'
    </pre>
    <p class="Pp">You can also override the comparison on an individual basis -
        see the huge section on &quot;WHERE CLAUSES&quot; at the bottom.</p>
  </dd>
  <dt>sqltrue, sqlfalse</dt>
  <dd>Expressions for inserting boolean values within SQL statements. By default
      these are <span class="Li">&quot;1=1&quot;</span> and
      <span class="Li">&quot;1=0&quot;</span>. They are used by the special
      operators <span class="Li">&quot;-in&quot;</span> and
      <span class="Li">&quot;-not_in&quot;</span> for generating correct SQL
      even when the argument is an empty array (see below).</dd>
  <dt>logic</dt>
  <dd>This determines the default logical operator for multiple WHERE statements
      in arrays or hashes. If absent, the default logic is &quot;or&quot; for
      arrays, and &quot;and&quot; for hashes. This means that a WHERE array of
      the form:
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    @where = (
        event_date =&gt; {'&gt;=', '2/13/99'},
        event_date =&gt; {'&lt;=', '4/24/03'},
    );
    </pre>
    <p class="Pp">will generate SQL like this:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    WHERE event_date &gt;= '2/13/99' OR event_date &lt;= '4/24/03'
    </pre>
    <p class="Pp">This is probably not what you want given this query, though
        (look at the dates). To change the &quot;OR&quot; to an &quot;AND&quot;,
        simply specify:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    my $sql = SQL::Abstract-&gt;new(logic =&gt; 'and');
    </pre>
    <p class="Pp">Which will change the above
        <span class="Li">&quot;WHERE&quot;</span> to:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    WHERE event_date &gt;= '2/13/99' AND event_date &lt;= '4/24/03'
    </pre>
    <p class="Pp">The logic can also be changed locally by inserting a modifier
        in front of an arrayref:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    @where = (-and =&gt; [event_date =&gt; {'&gt;=', '2/13/99'},
                       event_date =&gt; {'&lt;=', '4/24/03'} ]);
    </pre>
    <p class="Pp">See the &quot;WHERE CLAUSES&quot; section for
      explanations.</p>
  </dd>
  <dt>convert</dt>
  <dd>This will automatically convert comparisons using the specified SQL
      function for both column and value. This is mostly used with an argument
      of <span class="Li">&quot;upper&quot;</span> or
      <span class="Li">&quot;lower&quot;</span>, so that the SQL will have the
      effect of case-insensitive &quot;searches&quot;. For example, this:
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    $sql = SQL::Abstract-&gt;new(convert =&gt; 'upper');
    %where = (keywords =&gt; 'MaKe iT CAse inSeNSItive');
    </pre>
    <p class="Pp">Will turn out the following SQL:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    WHERE upper(keywords) like upper('MaKe iT CAse inSeNSItive')
    </pre>
    <p class="Pp">The conversion can be
        <span class="Li">&quot;upper()&quot;</span>,
        <span class="Li">&quot;lower()&quot;</span>, or any other SQL function
        that can be applied symmetrically to fields (actually
        <b>SQL::Abstract</b> does not validate this option; it will just pass
        through what you specify verbatim).</p>
  </dd>
  <dt>bindtype</dt>
  <dd>This is a kludge because many databases suck. For example, you can't just
      bind values using DBI's <span class="Li">&quot;execute()&quot;</span> for
      Oracle <span class="Li">&quot;CLOB&quot;</span> or
      <span class="Li">&quot;BLOB&quot;</span> fields. Instead, you have to use
      <span class="Li">&quot;bind_param()&quot;</span>:
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    $sth-&gt;bind_param(1, 'reg data');
    $sth-&gt;bind_param(2, $lots, {ora_type =&gt; ORA_CLOB});
    </pre>
    <p class="Pp">The problem is, <b>SQL::Abstract</b> will normally just return
        a <span class="Li">@bind</span> array, which loses track of which field
        each slot refers to. Fear not.</p>
    <p class="Pp">If you specify <span class="Li">&quot;bindtype&quot;</span> in
        new, you can determine how <span class="Li">@bind</span> is returned.
        Currently, you can specify either
        <span class="Li">&quot;normal&quot;</span> (default) or
        <span class="Li">&quot;columns&quot;</span>. If you specify
        <span class="Li">&quot;columns&quot;</span>, you will get an array that
        looks like this:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    my $sql = SQL::Abstract-&gt;new(bindtype =&gt; 'columns');
    my($stmt, @bind) = $sql-&gt;insert(...);

    @bind = (
        [ 'column1', 'value1' ],
        [ 'column2', 'value2' ],
        [ 'column3', 'value3' ],
    );
    </pre>
    <p class="Pp">You can then iterate through this manually, using DBI's
        <span class="Li">&quot;bind_param()&quot;</span>.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    $sth-&gt;prepare($stmt);
    my $i = 1;
    for (@bind) {
        my($col, $data) = @$_;
        if ($col eq 'details' || $col eq 'comments') {
            $sth-&gt;bind_param($i, $data, {ora_type =&gt; ORA_CLOB});
        } elsif ($col eq 'image') {
            $sth-&gt;bind_param($i, $data, {ora_type =&gt; ORA_BLOB});
        } else {
            $sth-&gt;bind_param($i, $data);
        }
        $i++;
    }
    $sth-&gt;execute;      # execute without @bind now
    </pre>
    <p class="Pp">Now, why would you still use <b>SQL::Abstract</b> if you have
        to do this crap? Basically, the advantage is still that you don't have
        to care which fields are or are not included. You could wrap that above
        <span class="Li">&quot;for&quot;</span> loop in a simple sub called
        <span class="Li">&quot;bind_fields()&quot;</span> or something and reuse
        it repeatedly. You still get a layer of abstraction over manual SQL
        specification.</p>
    <p class="Pp">Note that if you set &quot;bindtype&quot; to
        <span class="Li">&quot;columns&quot;</span>, the
        <span class="Li">&quot;\[ $sql, @bind ]&quot;</span> construct (see
        &quot;Literal SQL with placeholders and bind values (subqueries)&quot;)
        will expect the bind values in this format.</p>
  </dd>
  <dt>quote_char</dt>
  <dd>This is the character that a table or column name will be quoted with. By
      default this is an empty string, but you could set it to the character
      <span class="Li">&quot;`&quot;</span>, to generate SQL like this:
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  SELECT `a_field` FROM `a_table` WHERE `some_field` LIKE '%someval%'
    </pre>
    <p class="Pp">Alternatively, you can supply an array ref of two items, the
        first being the left hand quote character, and the second the right hand
        quote character. For example, you could supply
        <span class="Li">&quot;['[',']']&quot;</span> for SQL Server 2000
        compliant quotes that generates SQL like this:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  SELECT [a_field] FROM [a_table] WHERE [some_field] LIKE '%someval%'
    </pre>
    <p class="Pp">Quoting is useful if you have tables or columns names that are
        reserved words in your database's SQL dialect.</p>
  </dd>
  <dt>escape_char</dt>
  <dd>This is the character that will be used to escape &quot;quote_char&quot;s
      appearing in an identifier before it has been quoted.
    <p class="Pp">The parameter default in case of a single
        &quot;quote_char&quot; character is the quote character itself.</p>
    <p class="Pp">When opening-closing-style quoting is used
        (&quot;quote_char&quot; is an arrayref) this parameter defaults to the
        <b>closing (right)</b> &quot;quote_char&quot;. Occurrences of the
        <b>opening (left)</b> &quot;quote_char&quot; within the identifier are
        currently left untouched. The default for opening-closing-style quotes
        may change in future versions, thus you are <b>strongly encouraged</b>
        to specify the escape character explicitly.</p>
  </dd>
  <dt>name_sep</dt>
  <dd>This is the character that separates a table and column name. It is
      necessary to specify this when the
      <span class="Li">&quot;quote_char&quot;</span> option is selected, so that
      tables and column names can be individually quoted like this:
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  SELECT `table`.`one_field` FROM `table` WHERE `table`.`other_field` = 1
    </pre>
  </dd>
  <dt>injection_guard</dt>
  <dd>A regular expression <span class="Li">&quot;qr/.../&quot;</span> that is
      applied to any <span class="Li">&quot;-function&quot;</span> and unquoted
      column name specified in a query structure. This is a safety mechanism to
      avoid injection attacks when mishandling user input e.g.:
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  my %condition_as_column_value_pairs = get_values_from_user();
  $sqla-&gt;select( ... , \%condition_as_column_value_pairs );
    </pre>
    <p class="Pp">If the expression matches an exception is thrown. Note that
        literal SQL supplied via <span class="Li">&quot;\'...'&quot;</span> or
        <span class="Li">&quot;\['...']&quot;</span> is <b>not</b> checked in
        any way.</p>
    <p class="Pp">Defaults to checking for <span class="Li">&quot;;&quot;</span>
        and the <span class="Li">&quot;GO&quot;</span> keyword (TransactSQL)</p>
  </dd>
  <dt>array_datatypes</dt>
  <dd>When this option is true, arrayrefs in INSERT or UPDATE are interpreted as
      array datatypes and are passed directly to the DBI layer. When this option
      is false, arrayrefs are interpreted as literal SQL, just like refs to
      arrayrefs (but this behavior is for backwards compatibility; when writing
      new queries, use the &quot;reference to arrayref&quot; syntax for literal
      SQL).</dd>
  <dt>special_ops</dt>
  <dd>Takes a reference to a list of &quot;special operators&quot; to extend the
      syntax understood by SQL::Abstract. See section &quot;SPECIAL
      OPERATORS&quot; for details.</dd>
  <dt>unary_ops</dt>
  <dd>Takes a reference to a list of &quot;unary operators&quot; to extend the
      syntax understood by SQL::Abstract. See section &quot;UNARY
      OPERATORS&quot; for details.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="insert($table,__e@values_____e_fieldvals,__e_options)"><a class="permalink" href="#insert($table,__e@values_____e_fieldvals,__e_options)">insert($table,
  \@values || \%fieldvals, \%options)</a></h2>
This is the simplest function. You simply give it a table name and either an
  arrayref of values or hashref of field/value pairs. It returns an SQL INSERT
  statement and a list of bind values. See the sections on &quot;Inserting and
  Updating Arrays&quot; and &quot;Inserting and Updating SQL&quot; for
  information on how to insert with those data types.
<p class="Pp">The optional <span class="Li">&quot;\%options&quot;</span> hash
    reference may contain additional options to generate the insert SQL.
    Currently supported options are:</p>
<dl class="Bl-tag">
  <dt>returning</dt>
  <dd>Takes either a scalar of raw SQL fields, or an array reference of field
      names, and adds on an SQL <span class="Li">&quot;RETURNING&quot;</span>
      statement at the end. This allows you to return data generated by the
      insert statement (such as row IDs) without performing another
      <span class="Li">&quot;SELECT&quot;</span> statement. Note, however, this
      is not part of the SQL standard and may not be supported by all database
      engines.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="update($table,__e_fieldvals,__e_where,__e_options)"><a class="permalink" href="#update($table,__e_fieldvals,__e_where,__e_options)">update($table,
  \%fieldvals, \%where, \%options)</a></h2>
This takes a table, hashref of field/value pairs, and an optional hashref WHERE
  clause. It returns an SQL UPDATE function and a list of bind values. See the
  sections on &quot;Inserting and Updating Arrays&quot; and &quot;Inserting and
  Updating SQL&quot; for information on how to insert with those data types.
<p class="Pp">The optional <span class="Li">&quot;\%options&quot;</span> hash
    reference may contain additional options to generate the update SQL.
    Currently supported options are:</p>
<dl class="Bl-tag">
  <dt>returning</dt>
  <dd>See the <span class="Li">&quot;returning&quot;</span> option to
    insert.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="select($source,_$fields,_$where,_$order)"><a class="permalink" href="#select($source,_$fields,_$where,_$order)">select($source,
  $fields, $where, $order)</a></h2>
This returns a SQL SELECT statement and associated list of bind values, as
  specified by the arguments:
<dl class="Bl-tag">
  <dt>$source</dt>
  <dd>Specification of the 'FROM' part of the statement. The argument can be
      either a plain scalar (interpreted as a table name, will be quoted), or an
      arrayref (interpreted as a list of table names, joined by commas, quoted),
      or a scalarref (literal SQL, not quoted).</dd>
  <dt>$fields</dt>
  <dd>Specification of the list of fields to retrieve from the source. The
      argument can be either an arrayref (interpreted as a list of field names,
      will be joined by commas and quoted), or a plain scalar (literal SQL, not
      quoted). Please observe that this API is not as flexible as that of the
      first argument <span class="Li">$source</span>, for backwards
      compatibility reasons.</dd>
  <dt>$where</dt>
  <dd>Optional argument to specify the WHERE part of the query. The argument is
      most often a hashref, but can also be an arrayref or plain scalar -- see
      section WHERE clause for details.</dd>
  <dt>$order</dt>
  <dd>Optional argument to specify the ORDER BY part of the query. The argument
      can be a scalar, a hashref or an arrayref -- see section ORDER BY clause
      for details.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="delete($table,__e_where,__e_options)"><a class="permalink" href="#delete($table,__e_where,__e_options)">delete($table,
  \%where, \%options)</a></h2>
This takes a table name and optional hashref WHERE clause. It returns an SQL
  DELETE statement and list of bind values.
<p class="Pp">The optional <span class="Li">&quot;\%options&quot;</span> hash
    reference may contain additional options to generate the delete SQL.
    Currently supported options are:</p>
<dl class="Bl-tag">
  <dt>returning</dt>
  <dd>See the <span class="Li">&quot;returning&quot;</span> option to
    insert.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="where(_e_where,_$order)"><a class="permalink" href="#where(_e_where,_$order)">where(\%where,
  $order)</a></h2>
This is used to generate just the WHERE clause. For example, if you have an
  arbitrary data structure and know what the rest of your SQL is going to look
  like, but want an easy way to produce a WHERE clause, use this. It returns an
  SQL WHERE clause and list of bind values.
</section>
<section class="Ss">
<h2 class="Ss" id="values(_e_data)"><a class="permalink" href="#values(_e_data)">values(\%data)</a></h2>
This just returns the values from the hash <span class="Li">%data</span>, in the
  same order that would be returned from any of the other above queries. Using
  this allows you to markedly speed up your queries if you are affecting lots of
  rows. See below under the &quot;PERFORMANCE&quot; section.
</section>
<section class="Ss">
<h2 class="Ss" id="generate($any,_'number',_$of,__e@data,_$struct,__e_types)"><a class="permalink" href="#generate($any,_'number',_$of,__e@data,_$struct,__e_types)">generate($any,
  'number', $of, \@data, $struct, \%types)</a></h2>
Warning: This is an experimental method and subject to change.
<p class="Pp">This returns arbitrarily generated SQL. It's a really basic
    shortcut. It will return two different things, depending on return
  context:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    my($stmt, @bind) = $sql-&gt;generate('create table', \$table, \@fields);
    my $stmt_and_val = $sql-&gt;generate('create table', \$table, \@fields);
</pre>
<p class="Pp">These would return the following:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    # First calling form
    $stmt = &quot;CREATE TABLE test (?, ?)&quot;;
    @bind = (field1, field2);

    # Second calling form
    $stmt_and_val = &quot;CREATE TABLE test (field1, field2)&quot;;
</pre>
<p class="Pp">Depending on what you're trying to do, it's up to you to choose
    the correct format. In this example, the second form is what you would
  want.</p>
<p class="Pp">By the same token:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    $sql-&gt;generate('alter session', { nls_date_format =&gt; 'MM/YY' });
</pre>
<p class="Pp">Might give you:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    ALTER SESSION SET nls_date_format = 'MM/YY'
</pre>
<p class="Pp">You get the idea. Strings get their case twiddled, but everything
    else remains verbatim.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="EXPORTABLE_FUNCTIONS"><a class="permalink" href="#EXPORTABLE_FUNCTIONS">EXPORTABLE
  FUNCTIONS</a></h1>
<section class="Ss">
<h2 class="Ss" id="is_plain_value"><a class="permalink" href="#is_plain_value">is_plain_value</a></h2>
Determines if the supplied argument is a plain value as understood by this
  module:
<ul class="Bl-bullet">
  <li>The value is <span class="Li">&quot;undef&quot;</span></li>
  <li>The value is a non-reference</li>
  <li>The value is an object with stringification overloading</li>
  <li>The value is of the form <span class="Li">&quot;{ -value =&gt; $anything
      }&quot;</span></li>
</ul>
<p class="Pp">On failure returns <span class="Li">&quot;undef&quot;</span>, on
    success returns a <b>scalar</b> reference to the original supplied
  argument.</p>
<dl class="Bl-tag">
  <dt>&#x2022;</dt>
  <dd>Note
    <p class="Pp">The stringification overloading detection is rather advanced:
        it takes into consideration not only the presence of a
        <span class="Li">&quot;&quot;</span> overload, but if that fails also
        checks for enabled autogenerated versions of
        <span class="Li">&quot;&quot;</span>, based on either
        <span class="Li">&quot;0+&quot;</span> or
        <span class="Li">&quot;bool&quot;</span>.</p>
    <p class="Pp">Unfortunately testing in the field indicates that this
        detection <b>may tickle a latent bug in perl versions before 5.018</b>,
        but only when very large numbers of stringifying objects are involved.
        At the time of writing ( Sep 2014 ) there is no clear explanation of the
        direct cause, nor is there a manageably small test case that reliably
        reproduces the problem.</p>
    <p class="Pp">If you encounter any of the following exceptions in <b>random
        places within</b> <b>your application stack</b> - this module may be to
        blame:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  Operation &quot;ne&quot;: no method found,
    left argument in overloaded package &lt;something&gt;,
    right argument in overloaded package &lt;something&gt;
    </pre>
    <p class="Pp">or perhaps even</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  Stub found while resolving method &quot;???&quot; overloading &quot;&quot;&quot;&quot; in package &lt;something&gt;
    </pre>
    <p class="Pp">If you fall victim to the above - please attempt to reduce the
        problem to something that could be sent to the SQL::Abstract
      developers</p>
    <p class="Pp">(either publicly or privately). As a workaround in the
        meantime you can set
        <span class="Li">$ENV{SQLA_ISVALUE_IGNORE_AUTOGENERATED_STRINGIFICATION}</span>
        to a true value, which will most likely eliminate your problem (at the
        expense of not being able to properly detect exotic forms of
        stringification).</p>
    <p class="Pp">This notice and environment variable will be removed in a
        future version, as soon as the underlying problem is found and a
        reliable workaround is devised.</p>
  </dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="is_literal_value"><a class="permalink" href="#is_literal_value">is_literal_value</a></h2>
Determines if the supplied argument is a literal value as understood by this
  module:
<ul class="Bl-bullet">
  <li><span class="Li">&quot;\$sql_string&quot;</span></li>
  <li><span class="Li">&quot;\[ $sql_string, @bind_values ]&quot;</span></li>
</ul>
<p class="Pp">On failure returns <span class="Li">&quot;undef&quot;</span>, on
    success returns an <b>array</b> reference containing the unpacked version of
    the supplied literal SQL and bind values.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="WHERE_CLAUSES"><a class="permalink" href="#WHERE_CLAUSES">WHERE
  CLAUSES</a></h1>
<section class="Ss">
<h2 class="Ss" id="Introduction"><a class="permalink" href="#Introduction">Introduction</a></h2>
This module uses a variation on the idea from DBIx::Abstract. It is <b>NOT</b>,
  repeat <i>not</i> 100% compatible. <b>The main logic of this</b> <b>module is
  that things in arrays are OR'ed, and things in hashes</b> <b>are AND'ed.</b>
<p class="Pp">The easiest way to explain is to show lots of examples. After each
    <span class="Li">%where</span> hash shown, it is assumed you used:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    my($stmt, @bind) = $sql-&gt;where(\%where);
</pre>
<p class="Pp">However, note that the <span class="Li">%where</span> hash can be
    used directly in any of the other functions as well, as described above.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Key-value_pairs"><a class="permalink" href="#Key-value_pairs">Key-value
  pairs</a></h2>
So, let's get started. To begin, a simple hash:
<p class="Pp"><span class="Li"></span></p>
<pre>
    my %where  = (
        user   =&gt; 'nwiger',
        status =&gt; 'completed'
    );
</pre>
<p class="Pp">Is converted to SQL <span class="Li">&quot;key = val&quot;</span>
    statements:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    $stmt = &quot;WHERE user = ? AND status = ?&quot;;
    @bind = ('nwiger', 'completed');
</pre>
<p class="Pp">One common thing I end up doing is having a list of values that a
    field can be in. To do this, simply specify a list inside of an
  arrayref:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    my %where  = (
        user   =&gt; 'nwiger',
        status =&gt; ['assigned', 'in-progress', 'pending'];
    );
</pre>
<p class="Pp">This simple code will create the following:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    $stmt = &quot;WHERE user = ? AND ( status = ? OR status = ? OR status = ? )&quot;;
    @bind = ('nwiger', 'assigned', 'in-progress', 'pending');
</pre>
<p class="Pp">A field associated to an empty arrayref will be considered a
    logical false and will generate 0=1.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Tests_for__s-1NULL_s0_values"><a class="permalink" href="#Tests_for__s-1NULL_s0_values">Tests
  for NULL values</a></h2>
If the value part is <span class="Li">&quot;undef&quot;</span> then this is
  converted to SQL &lt;IS NULL&gt;
<p class="Pp"><span class="Li"></span></p>
<pre>
    my %where  = (
        user   =&gt; 'nwiger',
        status =&gt; undef,
    );
</pre>
<p class="Pp">becomes:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    $stmt = &quot;WHERE user = ? AND status IS NULL&quot;;
    @bind = ('nwiger');
</pre>
<p class="Pp">To test if a column IS NOT NULL:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    my %where  = (
        user   =&gt; 'nwiger',
        status =&gt; { '!=', undef },
    );
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Specific_comparison_operators"><a class="permalink" href="#Specific_comparison_operators">Specific
  comparison operators</a></h2>
If you want to specify a different type of operator for your comparison, you can
  use a hashref for a given column:
<p class="Pp"><span class="Li"></span></p>
<pre>
    my %where  = (
        user   =&gt; 'nwiger',
        status =&gt; { '!=', 'completed' }
    );
</pre>
<p class="Pp">Which would generate:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    $stmt = &quot;WHERE user = ? AND status != ?&quot;;
    @bind = ('nwiger', 'completed');
</pre>
<p class="Pp">To test against multiple values, just enclose the values in an
    arrayref:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    status =&gt; { '=', ['assigned', 'in-progress', 'pending'] };
</pre>
<p class="Pp">Which would give you:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    &quot;WHERE status = ? OR status = ? OR status = ?&quot;
</pre>
<p class="Pp">The hashref can also contain multiple pairs, in which case it is
    expanded into an <span class="Li">&quot;AND&quot;</span> of its
  elements:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    my %where  = (
        user   =&gt; 'nwiger',
        status =&gt; { '!=', 'completed', -not_like =&gt; 'pending%' }
    );

    # Or more dynamically, like from a form
    $where{user} = 'nwiger';
    $where{status}{'!='} = 'completed';
    $where{status}{'-not_like'} = 'pending%';

    # Both generate this
    $stmt = &quot;WHERE user = ? AND status != ? AND status NOT LIKE ?&quot;;
    @bind = ('nwiger', 'completed', 'pending%');
</pre>
<p class="Pp">To get an OR instead, you can combine it with the arrayref
  idea:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    my %where =&gt; (
         user =&gt; 'nwiger',
         priority =&gt; [ { '=', 2 }, { '&gt;', 5 } ]
    );
</pre>
<p class="Pp">Which would generate:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    $stmt = &quot;WHERE ( priority = ? OR priority &gt; ? ) AND user = ?&quot;;
    @bind = ('2', '5', 'nwiger');
</pre>
<p class="Pp">If you want to include literal SQL (with or without bind values),
    just use a scalar reference or reference to an arrayref as the value:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    my %where  = (
        date_entered =&gt; { '&gt;' =&gt; \[&quot;to_date(?, 'MM/DD/YYYY')&quot;, &quot;11/26/2008&quot;] },
        date_expires =&gt; { '&lt;' =&gt; \&quot;now()&quot; }
    );
</pre>
<p class="Pp">Which would generate:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    $stmt = &quot;WHERE date_entered &gt; to_date(?, 'MM/DD/YYYY') AND date_expires &lt; now()&quot;;
    @bind = ('11/26/2008');
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Logic_and_nesting_operators"><a class="permalink" href="#Logic_and_nesting_operators">Logic
  and nesting operators</a></h2>
In the example above, there is a subtle trap if you want to say something like
  this (notice the <span class="Li">&quot;AND&quot;</span>):
<p class="Pp"><span class="Li"></span></p>
<pre>
    WHERE priority != ? AND priority != ?
</pre>
<p class="Pp">Because, in Perl you <i>can't</i> do this:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    priority =&gt; { '!=' =&gt; 2, '!=' =&gt; 1 }
</pre>
<p class="Pp">As the second <span class="Li">&quot;!=&quot;</span> key will
    obliterate the first. The solution is to use the special
    <span class="Li">&quot;-modifier&quot;</span> form inside an arrayref:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    priority =&gt; [ -and =&gt; {'!=', 2},
                          {'!=', 1} ]
</pre>
<p class="Pp">Normally, these would be joined by
    <span class="Li">&quot;OR&quot;</span>, but the modifier tells it to use
    <span class="Li">&quot;AND&quot;</span> instead. (Hint: You can use this in
    conjunction with the <span class="Li">&quot;logic&quot;</span> option to
    <span class="Li">&quot;new()&quot;</span> in order to change the way your
    queries work by default.) <b>Important:</b> Note that the
    <span class="Li">&quot;-modifier&quot;</span> goes <b>INSIDE</b> the
    arrayref, as an extra first element. This will <b>NOT</b> do what you think
    it might:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    priority =&gt; -and =&gt; [{'!=', 2}, {'!=', 1}]   # WRONG!
</pre>
<p class="Pp">Here is a quick list of equivalencies, since there is some
    overlap:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    # Same
    status =&gt; {'!=', 'completed', 'not like', 'pending%' }
    status =&gt; [ -and =&gt; {'!=', 'completed'}, {'not like', 'pending%'}]

    # Same
    status =&gt; {'=', ['assigned', 'in-progress']}
    status =&gt; [ -or =&gt; {'=', 'assigned'}, {'=', 'in-progress'}]
    status =&gt; [ {'=', 'assigned'}, {'=', 'in-progress'} ]
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Special_operators:__s-1IN,_BETWEEN,_s0_etc."><a class="permalink" href="#Special_operators:__s-1IN,_BETWEEN,_s0_etc.">Special
  operators: IN, BETWEEN, etc.</a></h2>
You can also use the hashref format to compare a list of fields using the
  <span class="Li">&quot;IN&quot;</span> comparison operator, by specifying the
  list as an arrayref:
<p class="Pp"><span class="Li"></span></p>
<pre>
    my %where  = (
        status   =&gt; 'completed',
        reportid =&gt; { -in =&gt; [567, 2335, 2] }
    );
</pre>
<p class="Pp">Which would generate:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    $stmt = &quot;WHERE status = ? AND reportid IN (?,?,?)&quot;;
    @bind = ('completed', '567', '2335', '2');
</pre>
<p class="Pp">The reverse operator <span class="Li">&quot;-not_in&quot;</span>
    generates SQL <span class="Li">&quot;NOT IN&quot;</span> and is used in the
    same way.</p>
<p class="Pp">If the argument to <span class="Li">&quot;-in&quot;</span> is an
    empty array, 'sqlfalse' is generated (by default:
    <span class="Li">&quot;1=0&quot;</span>). Similarly,
    <span class="Li">&quot;-not_in =&gt; []&quot;</span> generates 'sqltrue' (by
    default: <span class="Li">&quot;1=1&quot;</span>).</p>
<p class="Pp">In addition to the array you can supply a chunk of literal sql or
    literal sql with bind:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    my %where = {
      customer =&gt; { -in =&gt; \[
        'SELECT cust_id FROM cust WHERE balance &gt; ?',
        2000,
      ],
      status =&gt; { -in =&gt; \'SELECT status_codes FROM states' },
    };
</pre>
<p class="Pp">would generate:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    $stmt = &quot;WHERE (
          customer IN ( SELECT cust_id FROM cust WHERE balance &gt; ? )
      AND status IN ( SELECT status_codes FROM states )
    )&quot;;
    @bind = ('2000');
</pre>
<p class="Pp">Finally, if the argument to
    <span class="Li">&quot;-in&quot;</span> is not a reference, it will be
    treated as a single-element array.</p>
<p class="Pp">Another pair of operators is
    <span class="Li">&quot;-between&quot;</span> and
    <span class="Li">&quot;-not_between&quot;</span>, used with an arrayref of
    two values:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    my %where  = (
        user   =&gt; 'nwiger',
        completion_date =&gt; {
           -not_between =&gt; ['2002-10-01', '2003-02-06']
        }
    );
</pre>
<p class="Pp">Would give you:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    WHERE user = ? AND completion_date NOT BETWEEN ( ? AND ? )
</pre>
<p class="Pp">Just like with <span class="Li">&quot;-in&quot;</span> all
    plausible combinations of literal SQL are possible:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    my %where = {
      start0 =&gt; { -between =&gt; [ 1, 2 ] },
      start1 =&gt; { -between =&gt; \[&quot;? AND ?&quot;, 1, 2] },
      start2 =&gt; { -between =&gt; \&quot;lower(x) AND upper(y)&quot; },
      start3 =&gt; { -between =&gt; [
        \&quot;lower(x)&quot;,
        \[&quot;upper(?)&quot;, 'stuff' ],
      ] },
    };
</pre>
<p class="Pp">Would give you:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    $stmt = &quot;WHERE (
          ( start0 BETWEEN ? AND ?                )
      AND ( start1 BETWEEN ? AND ?                )
      AND ( start2 BETWEEN lower(x) AND upper(y)  )
      AND ( start3 BETWEEN lower(x) AND upper(?)  )
    )&quot;;
    @bind = (1, 2, 1, 2, 'stuff');
</pre>
<p class="Pp">These are the two builtin &quot;special operators&quot;; but the
    list can be expanded: see section &quot;SPECIAL OPERATORS&quot; below.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Unary_operators:_bool"><a class="permalink" href="#Unary_operators:_bool">Unary
  operators: bool</a></h2>
If you wish to test against boolean columns or functions within your database
  you can use the <span class="Li">&quot;-bool&quot;</span> and
  <span class="Li">&quot;-not_bool&quot;</span> operators. For example to test
  the column <span class="Li">&quot;is_user&quot;</span> being true and the
  column <span class="Li">&quot;is_enabled&quot;</span> being false you would
  use:-
<p class="Pp"><span class="Li"></span></p>
<pre>
    my %where  = (
        -bool       =&gt; 'is_user',
        -not_bool   =&gt; 'is_enabled',
    );
</pre>
<p class="Pp">Would give you:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    WHERE is_user AND NOT is_enabled
</pre>
<p class="Pp">If a more complex combination is required, testing more
    conditions, then you should use the and/or operators:-</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    my %where  = (
        -and           =&gt; [
            -bool      =&gt; 'one',
            -not_bool  =&gt; { two=&gt; { -rlike =&gt; 'bar' } },
            -not_bool  =&gt; { three =&gt; [ { '=', 2 }, { '&gt;', 5 } ] },
        ],
    );
</pre>
<p class="Pp">Would give you:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    WHERE
      one
        AND
      (NOT two RLIKE ?)
        AND
      (NOT ( three = ? OR three &gt; ? ))
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Nested_conditions,__-and/_-or_prefixes"><a class="permalink" href="#Nested_conditions,__-and/_-or_prefixes">Nested
  conditions, -and/-or prefixes</a></h2>
So far, we've seen how multiple conditions are joined with a top-level
  <span class="Li">&quot;AND&quot;</span>. We can change this by putting the
  different conditions we want in hashes and then putting those hashes in an
  array. For example:
<p class="Pp"><span class="Li"></span></p>
<pre>
    my @where = (
        {
            user   =&gt; 'nwiger',
            status =&gt; { -like =&gt; ['pending%', 'dispatched'] },
        },
        {
            user   =&gt; 'robot',
            status =&gt; 'unassigned',
        }
    );
</pre>
<p class="Pp">This data structure would create the following:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    $stmt = &quot;WHERE ( user = ? AND ( status LIKE ? OR status LIKE ? ) )
                OR ( user = ? AND status = ? ) )&quot;;
    @bind = ('nwiger', 'pending', 'dispatched', 'robot', 'unassigned');
</pre>
<p class="Pp">Clauses in hashrefs or arrayrefs can be prefixed with an
    <span class="Li">&quot;-and&quot;</span> or
    <span class="Li">&quot;-or&quot;</span> to change the logic inside:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    my @where = (
         -and =&gt; [
            user =&gt; 'nwiger',
            [
                -and =&gt; [ workhrs =&gt; {'&gt;', 20}, geo =&gt; 'ASIA' ],
                -or =&gt; { workhrs =&gt; {'&lt;', 50}, geo =&gt; 'EURO' },
            ],
        ],
    );
</pre>
<p class="Pp">That would yield:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    $stmt = &quot;WHERE ( user = ?
               AND ( ( workhrs &gt; ? AND geo = ? )
                  OR ( workhrs &lt; ? OR geo = ? ) ) )&quot;;
    @bind = ('nwiger', '20', 'ASIA', '50', 'EURO');
</pre>
<p class="Pp"><i>Algebraic inconsistency, for historical reasons</i></p>
<p class="Pp"><span class="Li">&quot;Important note&quot;</span>: when
    connecting several conditions, the
    <span class="Li">&quot;-and-&quot;</span>|<span class="Li">&quot;-or&quot;</span>
    operator goes <span class="Li">&quot;outside&quot;</span> of the nested
    structure; whereas when connecting several constraints on one column, the
    <span class="Li">&quot;-and&quot;</span> operator goes
    <span class="Li">&quot;inside&quot;</span> the arrayref. Here is an example
    combining both features:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
   my @where = (
     -and =&gt; [a =&gt; 1, b =&gt; 2],
     -or  =&gt; [c =&gt; 3, d =&gt; 4],
      e   =&gt; [-and =&gt; {-like =&gt; 'foo%'}, {-like =&gt; '%bar'} ]
   )
</pre>
<p class="Pp">yielding</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  WHERE ( (    ( a = ? AND b = ? )
            OR ( c = ? OR d = ? )
            OR ( e LIKE ? AND e LIKE ? ) ) )
</pre>
<p class="Pp">This difference in syntax is unfortunate but must be preserved for
    historical reasons. So be careful: the two examples below would seem
    algebraically equivalent, but they are not</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  { col =&gt; [ -and =&gt;
    { -like =&gt; 'foo%' },
    { -like =&gt; '%bar' },
  ] }
  # yields: WHERE ( ( col LIKE ? AND col LIKE ? ) )

  [ -and =&gt;
    { col =&gt; { -like =&gt; 'foo%' } },
    { col =&gt; { -like =&gt; '%bar' } },
  ]
  # yields: WHERE ( ( col LIKE ? OR col LIKE ? ) )
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Literal__s-1SQL_s0_and_value_type_operators"><a class="permalink" href="#Literal__s-1SQL_s0_and_value_type_operators">Literal
  SQL and value type operators</a></h2>
The basic premise of SQL::Abstract is that in WHERE specifications the
  &quot;left side&quot; is a column name and the &quot;right side&quot; is a
  value (normally rendered as a placeholder). This holds true for both hashrefs
  and arrayref pairs as you see in the &quot;WHERE CLAUSES&quot; examples above.
  Sometimes it is necessary to alter this behavior. There are several ways of
  doing so.
<p class="Pp"><i>-ident</i></p>
<p class="Pp">This is a virtual operator that signals the string to its right
    side is an identifier (a column name) and not a value. For example to
    compare two columns you would write:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    my %where = (
        priority =&gt; { '&lt;', 2 },
        requestor =&gt; { -ident =&gt; 'submitter' },
    );
</pre>
<p class="Pp">which creates:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    $stmt = &quot;WHERE priority &lt; ? AND requestor = submitter&quot;;
    @bind = ('2');
</pre>
<p class="Pp">If you are maintaining legacy code you may see a different
    construct as described in &quot;Deprecated usage of Literal SQL&quot;,
    please use <span class="Li">&quot;-ident&quot;</span> in new code.</p>
<p class="Pp"><i>-value</i></p>
<p class="Pp">This is a virtual operator that signals that the construct to its
    right side is a value to be passed to DBI. This is for example necessary
    when you want to write a where clause against an array (for RDBMS that
    support such datatypes). For example:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    my %where = (
        array =&gt; { -value =&gt; [1, 2, 3] }
    );
</pre>
<p class="Pp">will result in:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    $stmt = 'WHERE array = ?';
    @bind = ([1, 2, 3]);
</pre>
<p class="Pp">Note that if you were to simply say:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    my %where = (
        array =&gt; [1, 2, 3]
    );
</pre>
<p class="Pp">the result would probably not be what you wanted:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    $stmt = 'WHERE array = ? OR array = ? OR array = ?';
    @bind = (1, 2, 3);
</pre>
<p class="Pp"><i>Literal SQL</i></p>
<p class="Pp">Finally, sometimes only literal SQL will do. To include a random
    snippet of SQL verbatim, you specify it as a scalar reference. Consider this
    only as a last resort. Usually there is a better way. For example:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    my %where = (
        priority =&gt; { '&lt;', 2 },
        requestor =&gt; { -in =&gt; \'(SELECT name FROM hitmen)' },
    );
</pre>
<p class="Pp">Would create:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    $stmt = &quot;WHERE priority &lt; ? AND requestor IN (SELECT name FROM hitmen)&quot;
    @bind = (2);
</pre>
<p class="Pp">Note that in this example, you only get one bind parameter back,
    since the verbatim SQL is passed as part of the statement.</p>
<p class="Pp">CAVEAT</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  Never use untrusted input as a literal SQL argument - this is a massive
  security risk (there is no way to check literal snippets for SQL
  injections and other nastyness). If you need to deal with untrusted input
  use literal SQL with placeholders as described next.
</pre>
<p class="Pp"><i>Literal SQL with placeholders and bind values
  (subqueries)</i></p>
<p class="Pp">If the literal SQL to be inserted has placeholders and bind
    values, use a reference to an arrayref (yes this is a double reference --
    not so common, but perfectly legal Perl). For example, to find a date in
    Postgres you can use something like this:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    my %where = (
       date_column =&gt; \[ &quot;= date '2008-09-30' - ?::integer&quot;, 10 ]
    )
</pre>
<p class="Pp">This would create:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    $stmt = &quot;WHERE ( date_column = date '2008-09-30' - ?::integer )&quot;
    @bind = ('10');
</pre>
<p class="Pp">Note that you must pass the bind values in the same format as they
    are returned by where. This means that if you set &quot;bindtype&quot; to
    <span class="Li">&quot;columns&quot;</span>, you must provide the bind
    values in the <span class="Li">&quot;[ column_meta =&gt; value
    ]&quot;</span> format, where <span class="Li">&quot;column_meta&quot;</span>
    is an opaque scalar value; most commonly the column name, but you can use
    any scalar value (including references and blessed references),
    SQL::Abstract will simply pass it through intact. So if
    <span class="Li">&quot;bindtype&quot;</span> is set to
    <span class="Li">&quot;columns&quot;</span> the above example will look
    like:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    my %where = (
       date_column =&gt; \[ &quot;= date '2008-09-30' - ?::integer&quot;, [ {} =&gt; 10 ] ]
    )
</pre>
<p class="Pp">Literal SQL is especially useful for nesting parenthesized clauses
    in the main SQL query. Here is a first example:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  my ($sub_stmt, @sub_bind) = (&quot;SELECT c1 FROM t1 WHERE c2 &lt; ? AND c3 LIKE ?&quot;,
                               100, &quot;foo%&quot;);
  my %where = (
    foo =&gt; 1234,
    bar =&gt; \[&quot;IN ($sub_stmt)&quot; =&gt; @sub_bind],
  );
</pre>
<p class="Pp">This yields:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  $stmt = &quot;WHERE (foo = ? AND bar IN (SELECT c1 FROM t1
                                             WHERE c2 &lt; ? AND c3 LIKE ?))&quot;;
  @bind = (1234, 100, &quot;foo%&quot;);
</pre>
<p class="Pp">Other subquery operators, like for example
    <span class="Li">&quot;&gt; ALL&quot;</span> or <span class="Li">&quot;NOT
    IN&quot;</span>, are expressed in the same way. Of course the
    <span class="Li">$sub_stmt</span> and its associated bind values can be
    generated through a former call to
    <span class="Li">&quot;select()&quot;</span> :</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  my ($sub_stmt, @sub_bind)
     = $sql-&gt;select(&quot;t1&quot;, &quot;c1&quot;, {c2 =&gt; {&quot;&lt;&quot; =&gt; 100},
                                 c3 =&gt; {-like =&gt; &quot;foo%&quot;}});
  my %where = (
    foo =&gt; 1234,
    bar =&gt; \[&quot;&gt; ALL ($sub_stmt)&quot; =&gt; @sub_bind],
  );
</pre>
<p class="Pp">In the examples above, the subquery was used as an operator on a
    column; but the same principle also applies for a clause within the main
    <span class="Li">%where</span> hash, like an EXISTS subquery:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  my ($sub_stmt, @sub_bind)
     = $sql-&gt;select(&quot;t1&quot;, &quot;*&quot;, {c1 =&gt; 1, c2 =&gt; \&quot;&gt; t0.c0&quot;});
  my %where = ( -and =&gt; [
    foo   =&gt; 1234,
    \[&quot;EXISTS ($sub_stmt)&quot; =&gt; @sub_bind],
  ]);
</pre>
<p class="Pp">which yields</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  $stmt = &quot;WHERE (foo = ? AND EXISTS (SELECT * FROM t1
                                        WHERE c1 = ? AND c2 &gt; t0.c0))&quot;;
  @bind = (1234, 1);
</pre>
<p class="Pp">Observe that the condition on
    <span class="Li">&quot;c2&quot;</span> in the subquery refers to column
    <span class="Li">&quot;t0.c0&quot;</span> of the main query: this is
    <i>not</i> a bind value, so we have to express it through a scalar ref.
    Writing <span class="Li">&quot;c2 =&gt; {&quot;&gt;&quot; =&gt;
    &quot;t0.c0&quot;}&quot;</span> would have generated
    <span class="Li">&quot;c2 &gt; ?&quot;</span> with bind value
    <span class="Li">&quot;t0.c0&quot;</span> ... not exactly what we wanted
    here.</p>
<p class="Pp">Finally, here is an example where a subquery is used for
    expressing unary negation:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  my ($sub_stmt, @sub_bind)
     = $sql-&gt;where({age =&gt; [{&quot;&lt;&quot; =&gt; 10}, {&quot;&gt;&quot; =&gt; 20}]});
  $sub_stmt =~ s/^ where //i; # don't want &quot;WHERE&quot; in the subclause
  my %where = (
        lname  =&gt; {like =&gt; '%son%'},
        \[&quot;NOT ($sub_stmt)&quot; =&gt; @sub_bind],
    );
</pre>
<p class="Pp">This yields</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  $stmt = &quot;lname LIKE ? AND NOT ( age &lt; ? OR age &gt; ? )&quot;
  @bind = ('%son%', 10, 20)
</pre>
<p class="Pp"><i>Deprecated usage of Literal SQL</i></p>
<p class="Pp">Below are some examples of archaic use of literal SQL. It is shown
    only as reference for those who deal with legacy code. Each example has a
    much better, cleaner and safer alternative that users should opt for in new
    code.</p>
<ul class="Bl-bullet">
  <li>
    <p class="Pp"></p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    my %where = ( requestor =&gt; \'IS NOT NULL' )

    $stmt = &quot;WHERE requestor IS NOT NULL&quot;
    </pre>
    <p class="Pp">This used to be the way of generating NULL comparisons, before
        the handling of <span class="Li">&quot;undef&quot;</span> got
        formalized. For new code please use the superior syntax as described in
        &quot;Tests for NULL values&quot;.</p>
  </li>
  <li>
    <p class="Pp"></p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    my %where = ( requestor =&gt; \'= submitter' )

    $stmt = &quot;WHERE requestor = submitter&quot;
    </pre>
    <p class="Pp">This used to be the only way to compare columns. Use the
        superior &quot;-ident&quot; method for all new code. For example an
        identifier declared in such a way will be properly quoted if
        &quot;quote_char&quot; is properly set, while the legacy form will
        remain as supplied.</p>
  </li>
  <li>
    <p class="Pp"></p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    my %where = ( is_ready  =&gt; \&quot;&quot;, completed =&gt; { '&gt;', '2012-12-21' } )

    $stmt = &quot;WHERE completed &gt; ? AND is_ready&quot;
    @bind = ('2012-12-21')
    </pre>
    <p class="Pp">Using an empty string literal used to be the only way to
        express a boolean. For all new code please use the much more readable
        -bool operator.</p>
  </li>
</ul>
</section>
<section class="Ss">
<h2 class="Ss" id="Conclusion"><a class="permalink" href="#Conclusion">Conclusion</a></h2>
These pages could go on for a while, since the nesting of the data structures
  this module can handle are pretty much unlimited (the module implements the
  <span class="Li">&quot;WHERE&quot;</span> expansion as a recursive function
  internally). Your best bet is to &quot;play around&quot; with the module a
  little to see how the data structures behave, and choose the best format for
  your data based on that.
<p class="Pp">And of course, all the values above will probably be replaced with
    variables gotten from forms or the command line. After all, if you knew
    everything ahead of time, you wouldn't have to worry about
    dynamically-generating SQL and could just hardwire it into your script.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="ORDER_BY_CLAUSES"><a class="permalink" href="#ORDER_BY_CLAUSES">ORDER
  BY CLAUSES</a></h1>
Some functions take an order by clause. This can either be a scalar (just a
  column name), a hashref of <span class="Li">&quot;{ -desc =&gt; 'col'
  }&quot;</span> or <span class="Li">&quot;{ -asc =&gt; 'col' }&quot;</span>, a
  scalarref, an arrayref-ref, or an arrayref of any of the previous forms.
  Examples:
<p class="Pp"><span class="Li"></span></p>
<pre>
               Given              |         Will Generate
    ---------------------------------------------------------------
                                  |
    'colA'                        | ORDER BY colA
                                  |
    [qw/colA colB/]               | ORDER BY colA, colB
                                  |
    {-asc  =&gt; 'colA'}             | ORDER BY colA ASC
                                  |
    {-desc =&gt; 'colB'}             | ORDER BY colB DESC
                                  |
    ['colA', {-asc =&gt; 'colB'}]    | ORDER BY colA, colB ASC
                                  |
    { -asc =&gt; [qw/colA colB/] }   | ORDER BY colA ASC, colB ASC
                                  |
    \'colA DESC'                  | ORDER BY colA DESC
                                  |
    \[ 'FUNC(colA, ?)', $x ]      | ORDER BY FUNC(colA, ?)
                                  |   /* ...with $x bound to ? */
                                  |
    [                             | ORDER BY
      { -asc =&gt; 'colA' },         |     colA ASC,
      { -desc =&gt; [qw/colB/] },    |     colB DESC,
      { -asc =&gt; [qw/colC colD/] },|     colC ASC, colD ASC,
      \'colE DESC',               |     colE DESC,
      \[ 'FUNC(colF, ?)', $x ],   |     FUNC(colF, ?)
    ]                             |   /* ...with $x bound to ? */
    ===============================================================
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="SPECIAL_OPERATORS"><a class="permalink" href="#SPECIAL_OPERATORS">SPECIAL
  OPERATORS</a></h1>
<span class="Li"></span>
<pre>
  my $sqlmaker = SQL::Abstract-&gt;new(special_ops =&gt; [
     {
      regex =&gt; qr/.../,
      handler =&gt; sub {
        my ($self, $field, $op, $arg) = @_;
        ...
      },
     },
     {
      regex =&gt; qr/.../,
      handler =&gt; 'method_name',
     },
   ]);
</pre>
<p class="Pp">A &quot;special operator&quot; is a SQL syntactic clause that can
    be applied to a field, instead of a usual binary operator. For example:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
   WHERE field IN (?, ?, ?)
   WHERE field BETWEEN ? AND ?
   WHERE MATCH(field) AGAINST (?, ?)
</pre>
<p class="Pp">Special operators IN and BETWEEN are fairly standard and therefore
    are builtin within <span class="Li">&quot;SQL::Abstract&quot;</span> (as the
    overridable methods <span class="Li">&quot;_where_field_IN&quot;</span> and
    <span class="Li">&quot;_where_field_BETWEEN&quot;</span>). For other
    operators, like the MATCH .. AGAINST example above which is specific to
    MySQL, you can write your own operator handlers - supply a
    <span class="Li">&quot;special_ops&quot;</span> argument to the
    <span class="Li">&quot;new&quot;</span> method. That argument takes an
    arrayref of operator definitions; each operator definition is a hashref with
    two entries:</p>
<dl class="Bl-tag">
  <dt>regex</dt>
  <dd>the regular expression to match the operator</dd>
  <dt>handler</dt>
  <dd>Either a coderef or a plain scalar method name. In both cases the expected
      return is <span class="Li">&quot;($sql, @bind)&quot;</span>.
    <p class="Pp">When supplied with a method name, it is simply called on the
        SQL::Abstract object as:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
 $self-&gt;$method_name($field, $op, $arg)

 Where:

  $field is the LHS of the operator
  $op is the part that matched the handler regex
  $arg is the RHS
    </pre>
    <p class="Pp">When supplied with a coderef, it is called as:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
 $coderef-&gt;($self, $field, $op, $arg)
    </pre>
  </dd>
</dl>
<p class="Pp">For example, here is an implementation of the MATCH .. AGAINST
    syntax for MySQL</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  my $sqlmaker = SQL::Abstract-&gt;new(special_ops =&gt; [

    # special op for MySql MATCH (field) AGAINST(word1, word2, ...)
    {regex =&gt; qr/^match$/i,
     handler =&gt; sub {
       my ($self, $field, $op, $arg) = @_;
       $arg = [$arg] if not ref $arg;
       my $label         = $self-&gt;_quote($field);
       my ($placeholder) = $self-&gt;_convert('?');
       my $placeholders  = join &quot;, &quot;, (($placeholder) x @$arg);
       my $sql           = $self-&gt;_sqlcase('match') . &quot; ($label) &quot;
                         . $self-&gt;_sqlcase('against') . &quot; ($placeholders) &quot;;
       my @bind = $self-&gt;_bindtype($field, @$arg);
       return ($sql, @bind);
       }
     },

  ]);
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="UNARY_OPERATORS"><a class="permalink" href="#UNARY_OPERATORS">UNARY
  OPERATORS</a></h1>
<span class="Li"></span>
<pre>
  my $sqlmaker = SQL::Abstract-&gt;new(unary_ops =&gt; [
     {
      regex =&gt; qr/.../,
      handler =&gt; sub {
        my ($self, $op, $arg) = @_;
        ...
      },
     },
     {
      regex =&gt; qr/.../,
      handler =&gt; 'method_name',
     },
   ]);
</pre>
<p class="Pp">A &quot;unary operator&quot; is a SQL syntactic clause that can be
    applied to a field - the operator goes before the field</p>
<p class="Pp">You can write your own operator handlers - supply a
    <span class="Li">&quot;unary_ops&quot;</span> argument to the
    <span class="Li">&quot;new&quot;</span> method. That argument takes an
    arrayref of operator definitions; each operator definition is a hashref with
    two entries:</p>
<dl class="Bl-tag">
  <dt>regex</dt>
  <dd>the regular expression to match the operator</dd>
  <dt>handler</dt>
  <dd>Either a coderef or a plain scalar method name. In both cases the expected
      return is <span class="Li">$sql</span>.
    <p class="Pp">When supplied with a method name, it is simply called on the
        SQL::Abstract object as:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
 $self-&gt;$method_name($op, $arg)

 Where:

  $op is the part that matched the handler regex
  $arg is the RHS or argument of the operator
    </pre>
    <p class="Pp">When supplied with a coderef, it is called as:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
 $coderef-&gt;($self, $op, $arg)
    </pre>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="PERFORMANCE"><a class="permalink" href="#PERFORMANCE">PERFORMANCE</a></h1>
Thanks to some benchmarking by Mark Stosberg, it turns out that this module is
  many orders of magnitude faster than using
  <span class="Li">&quot;DBIx::Abstract&quot;</span>. I must admit this wasn't
  an intentional design issue, but it's a byproduct of the fact that you get to
  control your <span class="Li">&quot;DBI&quot;</span> handles yourself.
<p class="Pp">To maximize performance, use a code snippet like the
  following:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    # prepare a statement handle using the first row
    # and then reuse it for the rest of the rows
    my($sth, $stmt);
    for my $href (@array_of_hashrefs) {
        $stmt ||= $sql-&gt;insert('table', $href);
        $sth  ||= $dbh-&gt;prepare($stmt);
        $sth-&gt;execute($sql-&gt;values($href));
    }
</pre>
<p class="Pp">The reason this works is because the keys in your
    <span class="Li">$href</span> are sorted internally by <b>SQL::Abstract</b>.
    Thus, as long as your data retains the same structure, you only have to
    generate the SQL the first time around. On subsequent queries, simply use
    the <span class="Li">&quot;values&quot;</span> function provided by this
    module to return your values in the correct order.</p>
<p class="Pp">However this depends on the values having the same type - if, for
    example, the values of a where clause may either have values (resulting in
    sql of the form <span class="Li">&quot;column = ?&quot;</span> with a single
    bind value), or alternatively the values might be
    <span class="Li">&quot;undef&quot;</span> (resulting in sql of the form
    <span class="Li">&quot;column IS NULL&quot;</span> with no bind value) then
    the caching technique suggested will not work.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="FORMBUILDER"><a class="permalink" href="#FORMBUILDER">FORMBUILDER</a></h1>
If you use my <span class="Li">&quot;CGI::FormBuilder&quot;</span> module at
  all, you'll hopefully really like this part (I do, at least). Building up a
  complex query can be as simple as the following:
<p class="Pp"><span class="Li"></span></p>
<pre>
    #!/usr/bin/perl

    use warnings;
    use strict;

    use CGI::FormBuilder;
    use SQL::Abstract;

    my $form = CGI::FormBuilder-&gt;new(...);
    my $sql  = SQL::Abstract-&gt;new;

    if ($form-&gt;submitted) {
        my $field = $form-&gt;field;
        my $id = delete $field-&gt;{id};
        my($stmt, @bind) = $sql-&gt;update('table', $field, {id =&gt; $id});
    }
</pre>
<p class="Pp">Of course, you would still have to connect using
    <span class="Li">&quot;DBI&quot;</span> to run the query, but the point is
    that if you make your form look like your table, the actual query script can
    be extremely simplistic.</p>
<p class="Pp">If you're <b>REALLY</b> lazy (I am), check out
    <span class="Li">&quot;HTML::QuickTable&quot;</span> for a fast interface to
    returning and formatting data. I frequently use these three modules together
    to write complex database query apps in under 50 lines.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="HOW_TO_CONTRIBUTE"><a class="permalink" href="#HOW_TO_CONTRIBUTE">HOW
  TO CONTRIBUTE</a></h1>
Contributions are always welcome, in all usable forms (we especially welcome
  documentation improvements). The delivery methods include git- or unified-diff
  formatted patches, GitHub pull requests, or plain bug reports either via RT or
  the Mailing list. Contributors are generally granted full access to the
  official repository after their first several patches pass successful review.
<p class="Pp">This project is maintained in a git repository. The code and
    related tools are accessible at the following locations:</p>
<ul class="Bl-bullet">
  <li>Official repo:
    &lt;git://git.shadowcat.co.uk/dbsrgits/SQL-Abstract.git&gt;</li>
  <li>Official gitweb:
      &lt;http://git.shadowcat.co.uk/gitweb/gitweb.cgi?p=dbsrgits/SQL-Abstract.git&gt;</li>
  <li>GitHub mirror: &lt;https://github.com/dbsrgits/sql-abstract&gt;</li>
  <li>Authorized committers:
      &lt;ssh://dbsrgits@git.shadowcat.co.uk/SQL-Abstract.git&gt;</li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="CHANGES"><a class="permalink" href="#CHANGES">CHANGES</a></h1>
Version 1.50 was a major internal refactoring of
  <span class="Li">&quot;SQL::Abstract&quot;</span>. Great care has been taken
  to preserve the <i>published</i> behavior documented in previous versions in
  the 1.* family; however, some features that were previously undocumented, or
  behaved differently from the documentation, had to be changed in order to
  clarify the semantics. Hence, client code that was relying on some dark areas
  of <span class="Li">&quot;SQL::Abstract&quot;</span> v1.* <b>might behave
  differently</b> in v1.50.
<p class="Pp">The main changes are:</p>
<ul class="Bl-bullet">
  <li>support for literal SQL through the <span class="Li">&quot;\ [ $sql, @bind
      ]&quot;</span> syntax.</li>
  <li>support for the { operator =&gt; \&quot;...&quot; } construct (to embed
      literal SQL)</li>
  <li>support for the { operator =&gt; \[&quot;...&quot;,
      <span class="Li">@bind</span>] } construct (to embed literal SQL with bind
      values)</li>
  <li>optional support for array datatypes</li>
  <li>defensive programming: check arguments</li>
  <li>fixed bug with global logic, which was previously implemented through
      global variables yielding side-effects. Prior versions would interpret
      <span class="Li">&quot;[ {cond1, cond2}, [cond3, cond4] ]&quot;</span> as
      <span class="Li">&quot;(cond1 AND cond2) OR (cond3 AND
      cond4)&quot;</span>. Now this is interpreted as
      <span class="Li">&quot;(cond1 AND cond2) OR (cond3 OR
    cond4)&quot;</span>.</li>
  <li>fixed semantics of _bindtype on array args</li>
  <li>dropped the <span class="Li">&quot;_anoncopy&quot;</span> of the
      <span class="Li">%where</span> tree. No longer necessary, we just avoid
      shifting arrays within that tree.</li>
  <li>dropped the <span class="Li">&quot;_modlogic&quot;</span> function</li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="ACKNOWLEDGEMENTS"><a class="permalink" href="#ACKNOWLEDGEMENTS">ACKNOWLEDGEMENTS</a></h1>
There are a number of individuals that have really helped out with this module.
  Unfortunately, most of them submitted bugs via CPAN so I have no idea who they
  are! But the people I do know are:
<p class="Pp"><span class="Li"></span></p>
<pre>
    Ash Berlin (order_by hash term support)
    Matt Trout (DBIx::Class support)
    Mark Stosberg (benchmarking)
    Chas Owens (initial &quot;IN&quot; operator support)
    Philip Collins (per-field SQL functions)
    Eric Kolve (hashref &quot;AND&quot; support)
    Mike Fragassi (enhancements to &quot;BETWEEN&quot; and &quot;LIKE&quot;)
    Dan Kubb (support for &quot;quote_char&quot; and &quot;name_sep&quot;)
    Guillermo Roditi (patch to cleanup &quot;IN&quot; and &quot;BETWEEN&quot;, fix and tests for _order_by)
    Laurent Dami (internal refactoring, extensible list of special operators, literal SQL)
    Norbert Buchmuller (support for literal SQL in hashpair, misc. fixes &amp; tests)
    Peter Rabbitson (rewrite of SQLA::Test, misc. fixes &amp; tests)
    Oliver Charles (support for &quot;RETURNING&quot; after &quot;INSERT&quot;)
</pre>
<p class="Pp">Thanks!</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
DBIx::Class, DBIx::Abstract, CGI::FormBuilder, HTML::QuickTable.
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
Copyright (c) 2001-2007 Nathan Wiger &lt;nwiger@cpan.org&gt;. All Rights
  Reserved.
<p class="Pp">This module is actively maintained by Matt Trout
    &lt;mst@shadowcatsystems.co.uk&gt;</p>
<p class="Pp">For support, your best bet is to try the
    <span class="Li">&quot;DBIx::Class&quot;</span> users mailing list. While
    not an official support venue,
    <span class="Li">&quot;DBIx::Class&quot;</span> makes heavy use of
    <span class="Li">&quot;SQL::Abstract&quot;</span>, and as such list members
    there are very familiar with how to create queries.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="LICENSE"><a class="permalink" href="#LICENSE">LICENSE</a></h1>
This module is free software; you may copy this under the same terms as perl
  itself (either the GNU General Public License or the Artistic License)
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2018-07-09</td>
    <td class="foot-os">perl v5.28.2</td>
  </tr>
</table>
</body>
</html>
