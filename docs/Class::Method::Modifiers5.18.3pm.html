<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>Class::Method::Modifiers(3pm)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Class::Method::Modifiers(3pm)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Class::Method::Modifiers(3pm)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
Class::Method::Modifiers - provides Moose-like method modifiers
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<span class="Li"></span>
<pre>
    package Child;
    use parent 'Parent';
    use Class::Method::Modifiers;

    sub new_method { }

    before 'old_method' =&gt; sub {
        carp &quot;old_method is deprecated, use new_method&quot;;
    };

    around 'other_method' =&gt; sub {
        my $orig = shift;
        my $ret = $orig-&gt;(@_);
        return $ret =~ /\d/ ? $ret : lc $ret;
    };

    after 'private', 'protected' =&gt; sub {
        debug &quot;finished calling a dangerous method&quot;;
    };

    use Class::Method::Modifiers qw(fresh);

    fresh 'not_in_hierarchy' =&gt; sub {
        warn &quot;freshly added method\n&quot;;
    };
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
Method modifiers are a convenient feature from the CLOS (Common Lisp Object
  System) world.
<p class="Pp">In its most basic form, a method modifier is just a method that
    calls <span class="Li">&quot;$self-&gt;SUPER::foo(@_)&quot;</span>. I for
    one have trouble remembering that exact invocation, so my classes seldom
    re-dispatch to their base classes. Very bad!</p>
<p class="Pp"><span class="Li">&quot;Class::Method::Modifiers&quot;</span>
    provides three modifiers: <span class="Li">&quot;before&quot;</span>,
    <span class="Li">&quot;around&quot;</span>, and
    <span class="Li">&quot;after&quot;</span>.
    <span class="Li">&quot;before&quot;</span> and
    <span class="Li">&quot;after&quot;</span> are run just before and after the
    method they modify, but can not really affect that original method.
    <span class="Li">&quot;around&quot;</span> is run in place of the original
    method, with a hook to easily call that original method. See the
    <span class="Li">&quot;MODIFIERS&quot;</span> section for more details on
    how the particular modifiers work.</p>
<p class="Pp">One clear benefit of using
    <span class="Li">&quot;Class::Method::Modifiers&quot;</span> is that you can
    define multiple modifiers in a single namespace. These separate modifiers
    don't need to know about each other. This makes top-down design easy. Have a
    base class that provides the skeleton methods of each operation, and have
    plugins modify those methods to flesh out the specifics.</p>
<p class="Pp">Parent classes need not know about
    <span class="Li">&quot;Class::Method::Modifiers&quot;</span>. This means you
    should be able to modify methods in <i>any</i> subclass. See
    Term::VT102::ZeroBased for an example of subclassing with
    <span class="Li">&quot;ClasS::Method::Modifiers&quot;</span>.</p>
<p class="Pp">In short,
    <span class="Li">&quot;Class::Method::Modifiers&quot;</span> solves the
    problem of making sure you call
    <span class="Li">&quot;$self-&gt;SUPER::foo(@_)&quot;</span>, and provides a
    cleaner interface for it.</p>
<p class="Pp">As of version 1.00,
    <span class="Li">&quot;Class::Method::Modifiers&quot;</span> is faster in
    some cases than Moose. See
    <span class="Li">&quot;benchmark/method_modifiers.pl&quot;</span> in the
    Moose distribution.</p>
<p class="Pp"><span class="Li">&quot;Class::Method::Modifiers&quot;</span> also
    provides an additional &quot;modifier&quot; type,
    <span class="Li">&quot;fresh&quot;</span>; see below.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="MODIFIERS"><a class="permalink" href="#MODIFIERS">MODIFIERS</a></h1>
<section class="Ss">
<h2 class="Ss" id="before_method(s)_=__sub___...__"><a class="permalink" href="#before_method(s)_=__sub___...__">before
  method(s) =&gt; sub { ... }</a></h2>
<span class="Li">&quot;before&quot;</span> is called before the method it is
  modifying. Its return value is totally ignored. It receives the same
  <span class="Li">@_</span> as the method it is modifying would have received.
  You can modify the <span class="Li">@_</span> the original method will receive
  by changing <span class="Li">$_[0]</span> and friends (or by changing anything
  inside a reference). This is a feature!
</section>
<section class="Ss">
<h2 class="Ss" id="after_method(s)_=__sub___...__"><a class="permalink" href="#after_method(s)_=__sub___...__">after
  method(s) =&gt; sub { ... }</a></h2>
<span class="Li">&quot;after&quot;</span> is called after the method it is
  modifying. Its return value is totally ignored. It receives the same
  <span class="Li">@_</span> as the method it is modifying received, mostly. The
  original method can modify <span class="Li">@_</span> (such as by changing
  <span class="Li">$_[0]</span> or references) and
  <span class="Li">&quot;after&quot;</span> will see the modified version. If
  you don't like this behavior, specify both a
  <span class="Li">&quot;before&quot;</span> and
  <span class="Li">&quot;after&quot;</span>, and copy the
  <span class="Li">@_</span> during <span class="Li">&quot;before&quot;</span>
  for <span class="Li">&quot;after&quot;</span> to use.
</section>
<section class="Ss">
<h2 class="Ss" id="around_method(s)_=__sub___...__"><a class="permalink" href="#around_method(s)_=__sub___...__">around
  method(s) =&gt; sub { ... }</a></h2>
<span class="Li">&quot;around&quot;</span> is called instead of the method it is
  modifying. The method you're overriding is passed in as the first argument
  (called <span class="Li">$orig</span> by convention). Watch out for contextual
  return values of <span class="Li">$orig</span>.
<p class="Pp">You can use <span class="Li">&quot;around&quot;</span> to:</p>
<dl class="Bl-tag">
  <dt>Pass $orig a different @_</dt>
  <dd><span class="Li"></span>
    <pre>
    around 'method' =&gt; sub {
        my $orig = shift;
        my $self = shift;
        $orig-&gt;($self, reverse @_);
    };
    </pre>
  </dd>
  <dt>Munge the return value of $orig</dt>
  <dd><span class="Li"></span>
    <pre>
    around 'method' =&gt; sub {
        my $orig = shift;
        ucfirst $orig-&gt;(@_);
    };
    </pre>
  </dd>
  <dt>Avoid calling $orig -- conditionally</dt>
  <dd><span class="Li"></span>
    <pre>
    around 'method' =&gt; sub {
        my $orig = shift;
        return $orig-&gt;(@_) if time() % 2;
        return &quot;no dice, captain&quot;;
    };
    </pre>
  </dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="fresh_method(s)_=__sub___...__;"><a class="permalink" href="#fresh_method(s)_=__sub___...__;">fresh
  method(s) =&gt; sub { ... };</a></h2>
Unlike the other modifiers, this does not modify an existing method. Ordinarily,
  <span class="Li">&quot;fresh&quot;</span> merely installs the coderef as a
  method in the appropriate class; but if the class hierarchy already contains a
  method of the same name, an exception is thrown. The idea of this
  &quot;modifier&quot; is to increase safety when subclassing. Suppose you're
  writing a subclass of a class Some::Base, and adding a new method:
<p class="Pp"><span class="Li"></span></p>
<pre>
    package My::SubclassOf::C;
    use base 'Some::Base';

    sub foo { ... }
</pre>
<p class="Pp">If a later version of Some::Base also adds a new method named
    <span class="Li">&quot;foo&quot;</span>, your method will shadow that
    method. Alternatively, you can use <span class="Li">&quot;fresh&quot;</span>
    to install the additional method into your subclass:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    package My::SubclassOf::C;
    use base 'Some::Base';

    use Class::Method::Modifiers 'fresh';

    fresh 'foo' =&gt; sub { ... };
</pre>
<p class="Pp">Now upgrading Some::Base to a version with a conflicting
    <span class="Li">&quot;foo&quot;</span> method will cause an exception to be
    thrown; seeing that error will give you the opportunity to fix the problem
    (perhaps by picking a different method name in your subclass, or
  similar).</p>
<p class="Pp">Creating fresh methods with
    <span class="Li">&quot;install_modifier&quot;</span> (see below) provides a
    way to get similar safety benefits when adding local monkeypatches to
    existing classes; see
    &lt;http://aaroncrane.co.uk/talks/monkey_patching_subclassing/&gt;.</p>
<p class="Pp">For API compatibility reasons, this function is exported only when
    you ask for it specifically, or for
    <span class="Li">&quot;:all&quot;</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="install_modifier_$package,_$type,_@names,_sub___...__"><a class="permalink" href="#install_modifier_$package,_$type,_@names,_sub___...__">install_modifier
  $package, $type, @names, sub { ... }</a></h2>
<span class="Li">&quot;install_modifier&quot;</span> is like
  <span class="Li">&quot;before&quot;</span>,
  <span class="Li">&quot;after&quot;</span>,
  <span class="Li">&quot;around&quot;</span>, and
  <span class="Li">&quot;fresh&quot;</span> but it also lets you dynamically
  select the modifier type ('before', 'after', 'around', 'fresh') and package
  that the method modifiers are installed into. This expert-level function is
  exported only when you ask for it specifically, or for
  <span class="Li">&quot;:all&quot;</span>.
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="NOTES"><a class="permalink" href="#NOTES">NOTES</a></h1>
All three normal modifiers; <span class="Li">&quot;before&quot;</span>,
  <span class="Li">&quot;after&quot;</span>, and
  <span class="Li">&quot;around&quot;</span>; are exported into your namespace
  by default. You may <span class="Li">&quot;use Class::Method::Modifiers
  ()&quot;</span> to avoid thrashing your namespace. I may steal more features
  from Moose, namely <span class="Li">&quot;super&quot;</span>,
  <span class="Li">&quot;override&quot;</span>,
  <span class="Li">&quot;inner&quot;</span>,
  <span class="Li">&quot;augment&quot;</span>, and whatever the Moose folks come
  up with next.
<p class="Pp">Note that the syntax and semantics for these modifiers is directly
    borrowed from Moose (the implementations, however, are not).</p>
<p class="Pp">Class::Trigger shares a few similarities with
    <span class="Li">&quot;Class::Method::Modifiers&quot;</span>, and they even
    have some overlap in purpose -- both can be used to implement highly
    pluggable applications. The difference is that Class::Trigger provides a
    mechanism for easily letting parent classes to invoke hooks defined by other
    code. <span class="Li">&quot;Class::Method::Modifiers&quot;</span> provides
    a way of overriding/augmenting methods safely, and the parent class need not
    know about it.</p>
<section class="Ss">
<h2 class="Ss" id=":lvalue__s-1METHODS_s0"><a class="permalink" href="#:lvalue__s-1METHODS_s0">:lvalue
  METHODS</a></h2>
When adding <span class="Li">&quot;before&quot;</span> or
  <span class="Li">&quot;after&quot;</span> modifiers, the wrapper method will
  be an lvalue method if the wrapped sub is, and assigning to the method will
  propagate to the wrapped method as expected. For
  <span class="Li">&quot;around&quot;</span> modifiers, it is the modifier sub
  that determines if the wrapper method is an lvalue method.
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="CAVEATS"><a class="permalink" href="#CAVEATS">CAVEATS</a></h1>
It is erroneous to modify a method that doesn't exist in your class's
  inheritance hierarchy. If this occurs, an exception will be thrown when the
  modifier is defined.
<p class="Pp">It doesn't yet play well with
    <span class="Li">&quot;caller&quot;</span>. There are some
    <span class="Li">&quot;TODO&quot;</span> tests for this. Don't get your
    hopes up though!</p>
<p class="Pp">Applying modifiers to array lvalue methods is not fully supported.
    Attempting to assign to an array lvalue method that has an
    <span class="Li">&quot;after&quot;</span> modifier applied will result in an
    error. Array lvalue methods are not well supported by perl in general, and
    should be avoided.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="VERSION"><a class="permalink" href="#VERSION">VERSION</a></h1>
This module was bumped to 1.00 following a complete reimplementation, to
  indicate breaking backwards compatibility. The &quot;guard&quot; modifier was
  removed, and the internals are completely different.
<p class="Pp">The new version is a few times faster with half the code. It's now
    even faster than Moose.</p>
<p class="Pp">Any code that just used modifiers should not change in behavior,
    except to become more correct. And, of course, faster. :)</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
Class::Method::Modifiers::Fast Moose, Class::Trigger,
  Class::MOP::Method::Wrapped, MRO::Compat, CLOS
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
Shawn M Moore, <span class="Li">&quot;sartak@gmail.com&quot;</span>
</section>
<section class="Sh">
<h1 class="Sh" id="ACKNOWLEDGEMENTS"><a class="permalink" href="#ACKNOWLEDGEMENTS">ACKNOWLEDGEMENTS</a></h1>
Thanks to Stevan Little for Moose, I would never have known about method
  modifiers otherwise.
<p class="Pp">Thanks to Matt Trout and Stevan Little for their advice.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT_AND_LICENSE"><a class="permalink" href="#COPYRIGHT_AND_LICENSE">COPYRIGHT
  AND LICENSE</a></h1>
Copyright 2007-2009 Shawn M Moore.
<p class="Pp">This program is free software; you can redistribute it and/or
    modify it under the same terms as Perl itself.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2013-12-14</td>
    <td class="foot-os">perl v5.18.4</td>
  </tr>
</table>
</body>
</html>
