<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.10 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>Apache::TestRequest(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Apache::TestRequest(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Apache::TestRequest(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
Apache::TestRequest - Send requests to your Apache test server
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<span class="Li"></span>
<pre>
  use Apache::Test qw(ok have_lwp);
  use Apache::TestRequest qw(GET POST);
  use Apache::Constants qw(HTTP_OK);

  plan tests =&gt; 1, have_lwp;

  my $res = GET '/test.html';
  ok $res-&gt;code == HTTP_OK, &quot;Request is ok&quot;;
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<b>Apache::TestRequest</b> provides convenience functions to allow you to make
  requests to your Apache test server in your test scripts. It subclasses
  <span class="Li">&quot;LWP::UserAgent&quot;</span>, so that you have access to
  all if its methods, but also exports a number of useful functions likely
  useful for majority of your test requests. Users of the old
  <span class="Li">&quot;Apache::test&quot;</span> (or
  <span class="Li">&quot;Apache::testold&quot;</span>) module, take note! Herein
  lie most of the functions you'll need to use to replace
  <span class="Li">&quot;Apache::test&quot;</span> in your test suites.
<p class="Pp">Each of the functions exported by
    <span class="Li">&quot;Apache::TestRequest&quot;</span> uses an
    <span class="Li">&quot;LWP::UserAgent&quot;</span> object to submit the
    request and retrieve its results. The return value for many of these
    functions is an HTTP::Response object. See HTTP::Response for documentation
    of its methods, which you can use in your tests. For example, use the
    <span class="Li">&quot;code()&quot;</span> and
    <span class="Li">&quot;content()&quot;</span> methods to test the response
    code and content of your request. Using
    <span class="Li">&quot;GET&quot;</span>, you can perform a couple of tests
    using these methods like this:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  use Apache::Test qw(ok have_lwp);
  use Apache::TestRequest qw(GET POST);
  use Apache::Constants qw(HTTP_OK);

  plan tests =&gt; 2, have_lwp;

  my $uri = &quot;/test.html?foo=1&amp;bar=2&quot;;
  my $res = GET $uri;
  ok $res-&gt;code == HTTP_OK, &quot;Check that the request was OK&quot;;
  ok $res-&gt;content eq &quot;foo =&gt; 1, bar =&gt; 2&quot;, &quot;Check its content&quot;;
</pre>
<p class="Pp">Note that you can also use
    <span class="Li">&quot;Apache::TestRequest&quot;</span> with
    <span class="Li">&quot;Test::Builder&quot;</span> and its derivatives,
    including <span class="Li">&quot;Test::More&quot;</span>:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  use Test::More;
  # ...
  is $res-&gt;code, HTTP_OK, &quot;Check that the request was OK&quot;;
  is $res-&gt;content, &quot;foo =&gt; 1, bar =&gt; 2&quot;, &quot;Check its content&quot;;
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="CONFIGURATION_FUNCTION"><a class="permalink" href="#CONFIGURATION_FUNCTION">CONFIGURATION
  FUNCTION</a></h1>
You can tell <span class="Li">&quot;Apache::TestRequest&quot;</span> what kind
  of <span class="Li">&quot;LWP::UserAgent&quot;</span> object to use for its
  convenience functions with <span class="Li">&quot;user_agent()&quot;</span>.
  This function uses its arguments to construct an internal global
  <span class="Li">&quot;LWP::UserAgent&quot;</span> object that will be used
  for all subsequent requests made by the convenience functions. The arguments
  it takes are the same as for the
  <span class="Li">&quot;LWP::UserAgent&quot;</span> constructor. See the
  <span class="Li">&quot;LWP::UserAgent&quot;</span> documentation for a
  complete list.
<p class="Pp">The <span class="Li">&quot;user_agent()&quot;</span> function only
    creates the internal <span class="Li">&quot;LWP::UserAgent&quot;</span>
    object the first time it is called. Since this function is called internally
    by <span class="Li">&quot;Apache::TestRequest&quot;</span>, you should
    always use the <span class="Li">&quot;reset&quot;</span> parameter to force
    it to create a new global <span class="Li">&quot;LWP::UserAgent&quot;</span>
    Object:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  Apache::TestRequest::user_agent(reset =&gt; 1, %params);
</pre>
<p class="Pp"><span class="Li">&quot;user_agent()&quot;</span> differs from
    <span class="Li">&quot;LWP::UserAgent-&gt;new&quot;</span> in two additional
    ways. First, it supports an additional parameter,
    <span class="Li">&quot;keep_alive&quot;</span>, which enables connection
    persistence, where the same connection is used to process multiple requests
    (and, according to the <span class="Li">&quot;LWP::UserAgent&quot;</span>
    documentation, has the effect of loading and enabling the new experimental
    HTTP/1.1 protocol module).</p>
<p class="Pp">And finally, the semantics of the
    <span class="Li">&quot;requests_redirectable&quot;</span> parameter is
    different than for <span class="Li">&quot;LWP::UserAgent&quot;</span> in
    that you can pass it a boolean value as well as an array for
    <span class="Li">&quot;LWP::UserAgent&quot;</span>. To force
    <span class="Li">&quot;Apache::TestRequest&quot;</span> not to follow
    redirects in any of its convenience functions, pass a false value to
    <span class="Li">&quot;requests_redirectable&quot;</span>:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  Apache::TestRequest::user_agent(reset =&gt; 1,
                                  requests_redirectable =&gt; 0);
</pre>
<p class="Pp">If LWP is not installed, then you can still pass in an array
    reference as <span class="Li">&quot;LWP::UserAgent&quot;</span> expects.
    <span class="Li">&quot;Apache::TestRequest&quot;</span> will examine the
    array and allow redirects if the array contains more than one value or if
    there is only one value and that value is not &quot;POST&quot;:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  # Always allow redirection.
  my $redir = have_lwp() ? [qw(GET HEAD POST)] : 1;
  Apache::TestRequest::user_agent(reset =&gt; 1,
                                  requests_redirectable =&gt; $redir);
</pre>
<p class="Pp">But note that redirection will <b>not</b> work with
    <span class="Li">&quot;POST&quot;</span> unless LWP is installed. It's best,
    therefore, to check <span class="Li">&quot;have_lwp&quot;</span> before
    running tests that rely on a redirection from
    <span class="Li">&quot;POST&quot;</span>.</p>
<p class="Pp">Sometimes it is desireable to have
    <span class="Li">&quot;Apache::TestRequest&quot;</span> remember cookies
    sent by the pages you are testing and send them back to the server on
    subsequent requests. This is especially necessary when testing pages whose
    functionality relies on sessions or the presence of preferences stored in
    cookies.</p>
<p class="Pp">By default, <span class="Li">&quot;LWP::UserAgent&quot;</span>
    does <b>not</b> remember cookies between requests. You can tell it to
    remember cookies between request by adding:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  Apache::TestRequest::user_agent(cookie_jar =&gt; {});
</pre>
<p class="Pp">before issuing the requests.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="FUNCTIONS"><a class="permalink" href="#FUNCTIONS">FUNCTIONS</a></h1>
<span class="Li">&quot;Apache::TestRequest&quot;</span> exports a number of
  functions that will likely prove convenient for use in the majority of your
  request tests.
<section class="Ss">
<h2 class="Ss" id="Optional_Parameters"><a class="permalink" href="#Optional_Parameters">Optional
  Parameters</a></h2>
Each function also takes a number of optional arguments.
<dl class="Bl-tag">
  <dt>redirect_ok</dt>
  <dd>By default a request will follow redirects retrieved from the server. To
      prevent this behavior, pass a false value to a
      <span class="Li">&quot;redirect_ok&quot;</span> parameter:
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  my $res = GET $uri, redirect_ok =&gt; 0;
    </pre>
    <p class="Pp">Alternately, if all of your tests need to disable redirects,
        tell <span class="Li">&quot;Apache::TestRequest&quot;</span> to use an
        <span class="Li">&quot;LWP::UserAgent&quot;</span> object that disables
        redirects:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  Apache::TestRequest::user_agent( reset =&gt; 1,
                                   requests_redirectable =&gt; 0 );
    </pre>
  </dd>
  <dt>cert</dt>
  <dd>If you need to force an SSL request to use a particular SSL certificate,
      pass the name of the certificate via the
      <span class="Li">&quot;cert&quot;</span> parameter:
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  my $res = GET $uri, cert =&gt; 'my_cert';
    </pre>
  </dd>
  <dt>content</dt>
  <dd>If you need to add content to your request, use the
      <span class="Li">&quot;content&quot;</span> parameter:
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  my $res = GET $uri, content =&gt; 'hello world!';
    </pre>
  </dd>
  <dt>filename</dt>
  <dd>The name of a local file on the file system to be sent to the Apache test
      server via <span class="Li">&quot;UPLOAD()&quot;</span> and its
    friends.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="The_Functions"><a class="permalink" href="#The_Functions">The
  Functions</a></h2>
<i>GET</i>
<p class="Pp"><span class="Li"></span></p>
<pre>
  my $res = GET $uri;
</pre>
<p class="Pp">Sends a simple GET request to the Apache test server. Returns an
    <span class="Li">&quot;HTTP::Response&quot;</span> object.</p>
<p class="Pp">You can also supply additional headers to be sent with the request
    by adding their name/value pairs after the
    <span class="Li">&quot;url&quot;</span> parameter, for example:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  my $res = GET $url, 'Accept-Language' =&gt; 'de,en-us,en;q=0.5';
</pre>
<p class="Pp"><i>GET_STR</i></p>
<p class="Pp">A shortcut function for
    <span class="Li">&quot;GET($uri)-&gt;as_string&quot;</span>.</p>
<p class="Pp"><i>GET_BODY</i></p>
<p class="Pp">A shortcut function for
    <span class="Li">&quot;GET($uri)-&gt;content&quot;</span>.</p>
<p class="Pp"><i>GET_BODY_ASSERT</i></p>
<p class="Pp">Use this function when your test is outputting content that you
    need to check, and you want to make sure that the request was successful
    before comparing the contents of the request. If the request was
    unsuccessful, <span class="Li">&quot;GET_BODY_ASSERT&quot;</span> will
    return an error message. Otherwise it will simply return the content of the
    request just as <span class="Li">&quot;GET_BODY&quot;</span> would.</p>
<p class="Pp"><i>GET_OK</i></p>
<p class="Pp">A shortcut function for
    <span class="Li">&quot;GET($uri)-&gt;is_success&quot;</span>.</p>
<p class="Pp"><i>GET_RC</i></p>
<p class="Pp">A shortcut function for
    <span class="Li">&quot;GET($uri)-&gt;code&quot;</span>.</p>
<p class="Pp"><i>GET_HEAD</i></p>
<p class="Pp">Throws out the content of the request, and returns the string
    representation of the request. Since the body has been thrown out, the
    representation will consist solely of the headers. Furthermore,
    <span class="Li">&quot;GET_HEAD&quot;</span> inserts a &quot;#&quot; at the
    beginning of each line of the return string, so that the contents are
    suitable for printing to STDERR during your tests without interfering with
    the workings of <span class="Li">&quot;Test::Harness&quot;</span>.</p>
<p class="Pp"><i>HEAD</i></p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  my $res = HEAD $uri;
</pre>
<p class="Pp">Sends a HEAD request to the Apache test server. Returns an
    <span class="Li">&quot;HTTP::Response&quot;</span> object.</p>
<p class="Pp"><i>HEAD_STR</i></p>
<p class="Pp">A shortcut function for
    <span class="Li">&quot;HEAD($uri)-&gt;as_string&quot;</span>.</p>
<p class="Pp"><i>HEAD_BODY</i></p>
<p class="Pp">A shortcut function for
    <span class="Li">&quot;HEAD($uri)-&gt;content&quot;</span>. Of course, this
    means that it will likely return nothing.</p>
<p class="Pp"><i>HEAD_BODY_ASSERT</i></p>
<p class="Pp">Use this function when your test is outputting content that you
    need to check, and you want to make sure that the request was successful
    before comparing the contents of the request. If the request was
    unsuccessful, <span class="Li">&quot;HEAD_BODY_ASSERT&quot;</span> will
    return an error message. Otherwise it will simply return the content of the
    request just as <span class="Li">&quot;HEAD_BODY&quot;</span> would.</p>
<p class="Pp"><i>HEAD_OK</i></p>
<p class="Pp">A shortcut function for
    <span class="Li">&quot;GET($uri)-&gt;is_success&quot;</span>.</p>
<p class="Pp"><i>HEAD_RC</i></p>
<p class="Pp">A shortcut function for
    <span class="Li">&quot;GET($uri)-&gt;code&quot;</span>.</p>
<p class="Pp"><i>HEAD_HEAD</i></p>
<p class="Pp">Throws out the content of the request, and returns the string
    representation of the request. Since the body has been thrown out, the
    representation will consist solely of the headers. Furthermore,
    <span class="Li">&quot;GET_HEAD&quot;</span> inserts a &quot;#&quot; at the
    beginning of each line of the return string, so that the contents are
    suitable for printing to STDERR during your tests without interfering with
    the workings of <span class="Li">&quot;Test::Harness&quot;</span>.</p>
<p class="Pp"><i>PUT</i></p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  my $res = PUT $uri;
</pre>
<p class="Pp">Sends a simple PUT request to the Apache test server. Returns an
    <span class="Li">&quot;HTTP::Response&quot;</span> object.</p>
<p class="Pp"><i>PUT_STR</i></p>
<p class="Pp">A shortcut function for
    <span class="Li">&quot;PUT($uri)-&gt;as_string&quot;</span>.</p>
<p class="Pp"><i>PUT_BODY</i></p>
<p class="Pp">A shortcut function for
    <span class="Li">&quot;PUT($uri)-&gt;content&quot;</span>.</p>
<p class="Pp"><i>PUT_BODY_ASSERT</i></p>
<p class="Pp">Use this function when your test is outputting content that you
    need to check, and you want to make sure that the request was successful
    before comparing the contents of the request. If the request was
    unsuccessful, <span class="Li">&quot;PUT_BODY_ASSERT&quot;</span> will
    return an error message. Otherwise it will simply return the content of the
    request just as <span class="Li">&quot;PUT_BODY&quot;</span> would.</p>
<p class="Pp"><i>PUT_OK</i></p>
<p class="Pp">A shortcut function for
    <span class="Li">&quot;PUT($uri)-&gt;is_success&quot;</span>.</p>
<p class="Pp"><i>PUT_RC</i></p>
<p class="Pp">A shortcut function for
    <span class="Li">&quot;PUT($uri)-&gt;code&quot;</span>.</p>
<p class="Pp"><i>PUT_HEAD</i></p>
<p class="Pp">Throws out the content of the request, and returns the string
    representation of the request. Since the body has been thrown out, the
    representation will consist solely of the headers. Furthermore,
    <span class="Li">&quot;PUT_HEAD&quot;</span> inserts a &quot;#&quot; at the
    beginning of each line of the return string, so that the contents are
    suitable for printing to STDERR during your tests without interfering with
    the workings of <span class="Li">&quot;Test::Harness&quot;</span>.</p>
<p class="Pp"><i>POST</i></p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  my $res = POST $uri, [ arg =&gt; $val, arg2 =&gt; $val ];
</pre>
<p class="Pp">Sends a POST request to the Apache test server and returns an
    <span class="Li">&quot;HTTP::Response&quot;</span> object. An array
    reference of parameters passed as the second argument will be submitted to
    the Apache test server as the POST content. Parameters corresponding to
    those documented in Optional Parameters can follow the optional array
    reference of parameters, or after <span class="Li">$uri</span>.</p>
<p class="Pp">To upload a chunk of data, simply use:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  my $res = POST $uri, content =&gt; $data;
</pre>
<p class="Pp"><i>POST_STR</i></p>
<p class="Pp">A shortcut function for <span class="Li">&quot;POST($uri,
    @args)-&gt;content&quot;</span>.</p>
<p class="Pp"><i>POST_BODY</i></p>
<p class="Pp">A shortcut function for <span class="Li">&quot;POST($uri,
    @args)-&gt;content&quot;</span>.</p>
<p class="Pp"><i>POST_BODY_ASSERT</i></p>
<p class="Pp">Use this function when your test is outputting content that you
    need to check, and you want to make sure that the request was successful
    before comparing the contents of the request. If the request was
    unsuccessful, <span class="Li">&quot;POST_BODY_ASSERT&quot;</span> will
    return an error message. Otherwise it will simply return the content of the
    request just as <span class="Li">&quot;POST_BODY&quot;</span> would.</p>
<p class="Pp"><i>POST_OK</i></p>
<p class="Pp">A shortcut function for <span class="Li">&quot;POST($uri,
    @args)-&gt;is_success&quot;</span>.</p>
<p class="Pp"><i>POST_RC</i></p>
<p class="Pp">A shortcut function for <span class="Li">&quot;POST($uri,
    @args)-&gt;code&quot;</span>.</p>
<p class="Pp"><i>POST_HEAD</i></p>
<p class="Pp">Throws out the content of the request, and returns the string
    representation of the request. Since the body has been thrown out, the
    representation will consist solely of the headers. Furthermore,
    <span class="Li">&quot;POST_HEAD&quot;</span> inserts a &quot;#&quot; at the
    beginning of each line of the return string, so that the contents are
    suitable for printing to STDERR during your tests without interfering with
    the workings of <span class="Li">&quot;Test::Harness&quot;</span>.</p>
<p class="Pp"><i>UPLOAD</i></p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  my $res = UPLOAD $uri, \@args, filename =&gt; $filename;
</pre>
<p class="Pp">Sends a request to the Apache test server that includes an
    uploaded file. Other POST parameters can be passed as a second argument as
    an array reference.</p>
<p class="Pp"><span class="Li">&quot;Apache::TestRequest&quot;</span> will read
    in the contents of the file named via the
    <span class="Li">&quot;filename&quot;</span> parameter for submission to the
    server. If you'd rather, you can submit use the
    <span class="Li">&quot;content&quot;</span> parameter instead of
    <span class="Li">&quot;filename&quot;</span>, and its value will be
    submitted to the Apache server as file contents:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  my $res = UPLOAD $uri, undef, content =&gt; &quot;This is file content&quot;;
</pre>
<p class="Pp">The name of the file sent to the server will simply be
    &quot;b&quot;. Note that in this case, you cannot pass other POST arguments
    to <span class="Li">&quot;UPLOAD()&quot;</span> -- they would be
  ignored.</p>
<p class="Pp"><i>UPLOAD_BODY</i></p>
<p class="Pp">A shortcut function for <span class="Li">&quot;UPLOAD($uri,
    @params)-&gt;content&quot;</span>.</p>
<p class="Pp"><i>UPLOAD_BODY_ASSERT</i></p>
<p class="Pp">Use this function when your test is outputting content that you
    need to check, and you want to make sure that the request was successful
    before comparing the contents of the request. If the request was
    unsuccessful, <span class="Li">&quot;UPLOAD_BODY_ASSERT&quot;</span> will
    return an error message. Otherwise it will simply return the content of the
    request just as <span class="Li">&quot;UPLOAD_BODY&quot;</span> would.</p>
<p class="Pp"><i>OPTIONS</i></p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  my $res = OPTIONS $uri;
</pre>
<p class="Pp">Sends an <span class="Li">&quot;OPTIONS&quot;</span> request to
    the Apache test server. Returns an
    <span class="Li">&quot;HTTP::Response&quot;</span> object with the
    <i>Allow</i> header, indicating which methods the server supports. Possible
    methods include <span class="Li">&quot;OPTIONS&quot;</span>,
    <span class="Li">&quot;GET&quot;</span>,
    <span class="Li">&quot;HEAD&quot;</span> and
    <span class="Li">&quot;POST&quot;</span>. This function thus can be useful
    for testing what options the Apache server supports. Consult the HTTPD 1.1
    specification, section 9.2, at <i>http://www.faqs.org/rfcs/rfc2616.html</i>
    for more information.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_s-1URL_s0_Manipulation_Functions"><a class="permalink" href="#_s-1URL_s0_Manipulation_Functions">URL
  Manipulation Functions</a></h2>
<span class="Li">&quot;Apache::TestRequest&quot;</span> also includes a few
  helper functions to aid in the creation of urls used in the functions above.
<p class="Pp"><i></i><i>&quot;module2path&quot;</i><i></i></p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  $path = Apache::TestRequest::module2path($module_name);
</pre>
<p class="Pp">Convert a module name to a path, safe for use in the various
    request methods above. e.g. <span class="Li">&quot;::&quot;</span> can't be
    used in URLs on win32. For example:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  $path = Apache::TestRequest::module2path('Foo::Bar');
</pre>
<p class="Pp">returns:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  /Foo__Bar
</pre>
<p class="Pp"><i></i><i>&quot;module2url&quot;</i><i></i></p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  $url = Apache::TestRequest::module2url($module);
  $url = Apache::TestRequest::module2url($module, \%options);
</pre>
<p class="Pp">Convert a module name to a full URL including the current
    configurations <span class="Li">&quot;hostname:port&quot;</span> and sets
    <span class="Li">&quot;module&quot;</span> accordingly.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  $url = Apache::TestRequest::module2url('Foo::Bar');
</pre>
<p class="Pp">returns:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  http://$hostname:$port/Foo__Bar
</pre>
<p class="Pp">The default scheme used is
    <span class="Li">&quot;http&quot;</span>. You can override this by passing
    your preferred scheme into an optional second param. For example:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  $module = 'MyTestModule::TestHandler';
  $url = Apache::TestRequest::module2url($module, {scheme =&gt; 'https'});
</pre>
<p class="Pp">returns:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  https://$hostname:$port/MyTestModule__TestHandler
</pre>
<p class="Pp">You may also override the default path with a path of your
  own:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  $module = 'MyTestModule::TestHandler';
  $url = Apache::TestRequest::module2url($module, {path =&gt; '/foo'});
</pre>
<p class="Pp">returns:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  http://$hostname:$port/foo
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="ENVIRONMENT_VARIABLES"><a class="permalink" href="#ENVIRONMENT_VARIABLES">ENVIRONMENT
  VARIABLES</a></h1>
The following environment variables can affect the behavior of
  <span class="Li">&quot;Apache::TestRequest&quot;</span>:
<dl class="Bl-tag">
  <dt>APACHE_TEST_PRETEND_NO_LWP</dt>
  <dd>If the environment variable
      <span class="Li">&quot;APACHE_TEST_PRETEND_NO_LWP&quot;</span> is set to a
      true value, <span class="Li">&quot;Apache::TestRequest&quot;</span> will
      pretend that LWP is not available so one can test whether the test suite
      will survive on a system which doesn't have libwww-perl installed.</dd>
  <dt>APACHE_TEST_HTTP_09_OK</dt>
  <dd>If the environment variable
      <span class="Li">&quot;APACHE_TEST_HTTP_09_OK&quot;</span> is set to a
      true value, <span class="Li">&quot;Apache::TestRequest&quot;</span> will
      allow HTTP/0.9 responses from the server to proceed. The default behavior
      is to die if the response protocol is not either HTTP/1.0 or
    HTTP/1.1.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
Apache::Test is the main Apache testing module. Use it to set up your tests,
  create a plan, and to ensure that you have the Apache version and modules you
  need.
<p class="Pp">Use Apache::TestMM in your <i>Makefile.PL</i> to set up your
    distribution for testing.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
Doug MacEachern with contributions from Geoffrey Young, Philippe M. Chiasson,
  Stas Bekman and others. Documentation by David Wheeler.
<p class="Pp">Questions can be asked at the test-dev &lt;at&gt; httpd.apache.org
    list. For more information see: <i>http://httpd.apache.org/test/</i> and
    <i>http://perl.apache.org/docs/general/testing/testing.html</i>.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2015-06-18</td>
    <td class="foot-os">perl v5.28.2</td>
  </tr>
</table>
</body>
</html>
