<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>IO::Compress::Zip(3pm)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">IO::Compress::Zip(3pm)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">IO::Compress::Zip(3pm)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
IO::Compress::Zip - Write zip files/buffers
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<span class="Li"></span>
<pre>
    use IO::Compress::Zip qw(zip $ZipError) ;

    my $status = zip $input =&gt; $output [,OPTS]
        or die &quot;zip failed: $ZipError\n&quot;;

    my $z = new IO::Compress::Zip $output [,OPTS]
        or die &quot;zip failed: $ZipError\n&quot;;

    $z-&gt;print($string);
    $z-&gt;printf($format, $string);
    $z-&gt;write($string);
    $z-&gt;syswrite($string [, $length, $offset]);
    $z-&gt;flush();
    $z-&gt;tell();
    $z-&gt;eof();
    $z-&gt;seek($position, $whence);
    $z-&gt;binmode();
    $z-&gt;fileno();
    $z-&gt;opened();
    $z-&gt;autoflush();
    $z-&gt;input_line_number();
    $z-&gt;newStream( [OPTS] );

    $z-&gt;deflateParams();

    $z-&gt;close() ;

    $ZipError ;

    # IO::File mode

    print $z $string;
    printf $z $format, $string;
    tell $z
    eof $z
    seek $z, $position, $whence
    binmode $z
    fileno $z
    close $z ;
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
This module provides a Perl interface that allows writing zip compressed data to
  files or buffer.
<p class="Pp">The primary purpose of this module is to provide streaming write
    access to zip files and buffers. It is not a general-purpose file archiver.
    If that is what you want, check out
    <span class="Li">&quot;Archive::Zip&quot;</span> or
    <span class="Li">&quot;Archive::Zip::SimpleZip&quot;</span>.</p>
<p class="Pp">At present three compression methods are supported by
    IO::Compress::Zip, namely Store (no compression at all), Deflate, Bzip2 and
    LZMA.</p>
<p class="Pp">Note that to create Bzip2 content, the module
    <span class="Li">&quot;IO::Compress::Bzip2&quot;</span> must be
  installed.</p>
<p class="Pp">Note that to create LZMA content, the module
    <span class="Li">&quot;IO::Compress::Lzma&quot;</span> must be
  installed.</p>
<p class="Pp">For reading zip files/buffers, see the companion module
    IO::Uncompress::Unzip.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="Functional_Interface"><a class="permalink" href="#Functional_Interface">Functional
  Interface</a></h1>
A top-level function, <span class="Li">&quot;zip&quot;</span>, is provided to
  carry out &quot;one-shot&quot; compression between buffers and/or files. For
  finer control over the compression process, see the &quot;OO Interface&quot;
  section.
<p class="Pp"><span class="Li"></span></p>
<pre>
    use IO::Compress::Zip qw(zip $ZipError) ;

    zip $input_filename_or_reference =&gt; $output_filename_or_reference [,OPTS]
        or die &quot;zip failed: $ZipError\n&quot;;
</pre>
<p class="Pp">The functional interface needs Perl5.005 or better.</p>
<section class="Ss">
<h2 class="Ss" id="zip_$input_filename_or_reference_=__$output_filename_or_reference__,__s-1OPTS_s0_"><a class="permalink" href="#zip_$input_filename_or_reference_=__$output_filename_or_reference__,__s-1OPTS_s0_">zip
  $input_filename_or_reference =&gt; $output_filename_or_reference [,
  OPTS]</a></h2>
<span class="Li">&quot;zip&quot;</span> expects at least two parameters,
  <span class="Li">$input_filename_or_reference</span> and
  <span class="Li">$output_filename_or_reference</span>.
<p class="Pp"><i>The </i><i>$input_filename_or_reference</i><i>
  parameter</i></p>
<p class="Pp">The parameter,
    <span class="Li">$input_filename_or_reference</span>, is used to define the
    source of the uncompressed data.</p>
<p class="Pp">It can take one of the following forms:</p>
<dl class="Bl-tag">
  <dt>A filename</dt>
  <dd>If the &lt;$input_filename_or_reference&gt; parameter is a simple scalar,
      it is assumed to be a filename. This file will be opened for reading and
      the input data will be read from it.</dd>
  <dt>A filehandle</dt>
  <dd>If the <span class="Li">$input_filename_or_reference</span> parameter is a
      filehandle, the input data will be read from it. The string '-' can be
      used as an alias for standard input.</dd>
  <dt>A scalar reference</dt>
  <dd>If <span class="Li">$input_filename_or_reference</span> is a scalar
      reference, the input data will be read from
      <span class="Li">$$input_filename_or_reference</span>.</dd>
  <dt>An array reference</dt>
  <dd>If <span class="Li">$input_filename_or_reference</span> is an array
      reference, each element in the array must be a filename.
    <p class="Pp">The input data will be read from each file in turn.</p>
    <p class="Pp">The complete array will be walked to ensure that it only
        contains valid filenames before any data is compressed.</p>
  </dd>
  <dt>An Input FileGlob string</dt>
  <dd>If <span class="Li">$input_filename_or_reference</span> is a string that
      is delimited by the characters &quot;&lt;&quot; and &quot;&gt;&quot;
      <span class="Li">&quot;zip&quot;</span> will assume that it is an <i>input
      fileglob string</i>. The input is the list of files that match the
      fileglob.
    <p class="Pp">See File::GlobMapper for more details.</p>
  </dd>
</dl>
<p class="Pp">If the <span class="Li">$input_filename_or_reference</span>
    parameter is any other type, <span class="Li">&quot;undef&quot;</span> will
    be returned.</p>
<p class="Pp">In addition, if
    <span class="Li">$input_filename_or_reference</span> is a simple filename,
    the default values for the <span class="Li">&quot;Name&quot;</span>,
    <span class="Li">&quot;Time&quot;</span>,
    <span class="Li">&quot;TextFlag&quot;</span>,
    <span class="Li">&quot;ExtAttr&quot;</span>,
    <span class="Li">&quot;exUnixN&quot;</span> and
    <span class="Li">&quot;exTime&quot;</span> options will be sourced from that
    file.</p>
<p class="Pp">If you do not want to use these defaults they can be overridden by
    explicitly setting the <span class="Li">&quot;Name&quot;</span>,
    <span class="Li">&quot;Time&quot;</span>,
    <span class="Li">&quot;TextFlag&quot;</span>,
    <span class="Li">&quot;ExtAttr&quot;</span>,
    <span class="Li">&quot;exUnixN&quot;</span> and
    <span class="Li">&quot;exTime&quot;</span> options or by setting the
    <span class="Li">&quot;Minimal&quot;</span> parameter.</p>
<p class="Pp"><i>The </i><i>$output_filename_or_reference</i><i>
  parameter</i></p>
<p class="Pp">The parameter
    <span class="Li">$output_filename_or_reference</span> is used to control the
    destination of the compressed data. This parameter can take one of these
    forms.</p>
<dl class="Bl-tag">
  <dt>A filename</dt>
  <dd>If the <span class="Li">$output_filename_or_reference</span> parameter is
      a simple scalar, it is assumed to be a filename. This file will be opened
      for writing and the compressed data will be written to it.</dd>
  <dt>A filehandle</dt>
  <dd>If the <span class="Li">$output_filename_or_reference</span> parameter is
      a filehandle, the compressed data will be written to it. The string '-'
      can be used as an alias for standard output.</dd>
  <dt>A scalar reference</dt>
  <dd>If <span class="Li">$output_filename_or_reference</span> is a scalar
      reference, the compressed data will be stored in
      <span class="Li">$$output_filename_or_reference</span>.</dd>
  <dt>An Array Reference</dt>
  <dd>If <span class="Li">$output_filename_or_reference</span> is an array
      reference, the compressed data will be pushed onto the array.</dd>
  <dt>An Output FileGlob</dt>
  <dd>If <span class="Li">$output_filename_or_reference</span> is a string that
      is delimited by the characters &quot;&lt;&quot; and &quot;&gt;&quot;
      <span class="Li">&quot;zip&quot;</span> will assume that it is an
      <i>output fileglob string</i>. The output is the list of files that match
      the fileglob.
    <p class="Pp">When <span class="Li">$output_filename_or_reference</span> is
        an fileglob string, <span class="Li">$input_filename_or_reference</span>
        must also be a fileglob string. Anything else is an error.</p>
    <p class="Pp">See File::GlobMapper for more details.</p>
  </dd>
</dl>
<p class="Pp">If the <span class="Li">$output_filename_or_reference</span>
    parameter is any other type, <span class="Li">&quot;undef&quot;</span> will
    be returned.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Notes"><a class="permalink" href="#Notes">Notes</a></h2>
When <span class="Li">$input_filename_or_reference</span> maps to multiple
  files/buffers and <span class="Li">$output_filename_or_reference</span> is a
  single file/buffer the input files/buffers will each be stored in
  <span class="Li">$output_filename_or_reference</span> as a distinct entry.
</section>
<section class="Ss">
<h2 class="Ss" id="Optional_Parameters"><a class="permalink" href="#Optional_Parameters">Optional
  Parameters</a></h2>
Unless specified below, the optional parameters for
  <span class="Li">&quot;zip&quot;</span>,
  <span class="Li">&quot;OPTS&quot;</span>, are the same as those used with the
  OO interface defined in the &quot;Constructor Options&quot; section below.
<dl class="Bl-tag">
  <dt>&quot;AutoClose =&gt; 0|1&quot;</dt>
  <dd>This option applies to any input or output data streams to
      <span class="Li">&quot;zip&quot;</span> that are filehandles.
    <p class="Pp">If <span class="Li">&quot;AutoClose&quot;</span> is specified,
        and the value is true, it will result in all input and/or output
        filehandles being closed once <span class="Li">&quot;zip&quot;</span>
        has completed.</p>
    <p class="Pp">This parameter defaults to 0.</p>
  </dd>
  <dt>&quot;BinModeIn =&gt; 0|1&quot;</dt>
  <dd>This option is now a no-op. All files will be read in binmode.</dd>
  <dt>&quot;Append =&gt; 0|1&quot;</dt>
  <dd>The behaviour of this option is dependent on the type of output data
      stream.</dd>
</dl>
<div class="Bd-indent">
<ul class="Bl-bullet">
  <li>A Buffer
    <p class="Pp">If <span class="Li">&quot;Append&quot;</span> is enabled, all
        compressed data will be append to the end of the output buffer.
        Otherwise the output buffer will be cleared before any compressed data
        is written to it.</p>
  </li>
  <li>A Filename
    <p class="Pp">If <span class="Li">&quot;Append&quot;</span> is enabled, the
        file will be opened in append mode. Otherwise the contents of the file,
        if any, will be truncated before any compressed data is written to
      it.</p>
  </li>
  <li>A Filehandle
    <p class="Pp">If <span class="Li">&quot;Append&quot;</span> is enabled, the
        filehandle will be positioned to the end of the file via a call to
        <span class="Li">&quot;seek&quot;</span> before any compressed data is
        written to it. Otherwise the file pointer will not be moved.</p>
  </li>
</ul>
</div>
<div class="Bd-indent">
<p class="Pp">When <span class="Li">&quot;Append&quot;</span> is specified, and
    set to true, it will <i>append</i> all compressed data to the output data
    stream.</p>
<p class="Pp">So when the output is a filehandle it will carry out a seek to the
    eof before writing any compressed data. If the output is a filename, it will
    be opened for appending. If the output is a buffer, all compressed data will
    be appended to the existing buffer.</p>
<p class="Pp">Conversely when <span class="Li">&quot;Append&quot;</span> is not
    specified, or it is present and is set to false, it will operate as
  follows.</p>
<p class="Pp">When the output is a filename, it will truncate the contents of
    the file before writing any compressed data. If the output is a filehandle
    its position will not be changed. If the output is a buffer, it will be
    wiped before any compressed data is output.</p>
<p class="Pp">Defaults to 0.</p>
</div>
</section>
<section class="Ss">
<h2 class="Ss" id="Examples"><a class="permalink" href="#Examples">Examples</a></h2>
To read the contents of the file <span class="Li">&quot;file1.txt&quot;</span>
  and write the compressed data to the file
  <span class="Li">&quot;file1.txt.zip&quot;</span>.
<p class="Pp"><span class="Li"></span></p>
<pre>
    use strict ;
    use warnings ;
    use IO::Compress::Zip qw(zip $ZipError) ;

    my $input = &quot;file1.txt&quot;;
    zip $input =&gt; &quot;$input.zip&quot;
        or die &quot;zip failed: $ZipError\n&quot;;
</pre>
<p class="Pp">To read from an existing Perl filehandle,
    <span class="Li">$input</span>, and write the compressed data to a buffer,
    <span class="Li">$buffer</span>.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    use strict ;
    use warnings ;
    use IO::Compress::Zip qw(zip $ZipError) ;
    use IO::File ;

    my $input = new IO::File &quot;&lt;file1.txt&quot;
        or die &quot;Cannot open 'file1.txt': $!\n&quot; ;
    my $buffer ;
    zip $input =&gt; \$buffer
        or die &quot;zip failed: $ZipError\n&quot;;
</pre>
<p class="Pp">To create a zip file,
    <span class="Li">&quot;output.zip&quot;</span>, that contains the compressed
    contents of the files <span class="Li">&quot;alpha.txt&quot;</span> and
    <span class="Li">&quot;beta.txt&quot;</span></p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    use strict ;
    use warnings ;
    use IO::Compress::Zip qw(zip $ZipError) ;

    zip [ 'alpha.txt', 'beta.txt' ] =&gt; 'output.zip'
        or die &quot;zip failed: $ZipError\n&quot;;
</pre>
<p class="Pp">Alternatively, rather than having to explicitly name each of the
    files that you want to compress, you could use a fileglob to select all the
    <span class="Li">&quot;txt&quot;</span> files in the current directory, as
    follows</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    use strict ;
    use warnings ;
    use IO::Compress::Zip qw(zip $ZipError) ;

    my @files = &lt;*.txt&gt;;
    zip \@files =&gt; 'output.zip'
        or die &quot;zip failed: $ZipError\n&quot;;
</pre>
<p class="Pp">or more succinctly</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    zip [ &lt;*.txt&gt; ] =&gt; 'output.zip'
        or die &quot;zip failed: $ZipError\n&quot;;
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="OO_Interface"><a class="permalink" href="#OO_Interface">OO
  Interface</a></h1>
<section class="Ss">
<h2 class="Ss" id="Constructor"><a class="permalink" href="#Constructor">Constructor</a></h2>
The format of the constructor for
  <span class="Li">&quot;IO::Compress::Zip&quot;</span> is shown below
<p class="Pp"><span class="Li"></span></p>
<pre>
    my $z = new IO::Compress::Zip $output [,OPTS]
        or die &quot;IO::Compress::Zip failed: $ZipError\n&quot;;
</pre>
<p class="Pp">It returns an
    <span class="Li">&quot;IO::Compress::Zip&quot;</span> object on success and
    undef on failure. The variable <span class="Li">$ZipError</span> will
    contain an error message on failure.</p>
<p class="Pp">If you are running Perl 5.005 or better the object,
    <span class="Li">$z</span>, returned from IO::Compress::Zip can be used
    exactly like an IO::File filehandle. This means that all normal output file
    operations can be carried out with <span class="Li">$z</span>. For example,
    to write to a compressed file/buffer you can use either of these forms</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    $z-&gt;print(&quot;hello world\n&quot;);
    print $z &quot;hello world\n&quot;;
</pre>
<p class="Pp">The mandatory parameter <span class="Li">$output</span> is used to
    control the destination of the compressed data. This parameter can take one
    of these forms.</p>
<dl class="Bl-tag">
  <dt>A filename</dt>
  <dd>If the <span class="Li">$output</span> parameter is a simple scalar, it is
      assumed to be a filename. This file will be opened for writing and the
      compressed data will be written to it.</dd>
  <dt>A filehandle</dt>
  <dd>If the <span class="Li">$output</span> parameter is a filehandle, the
      compressed data will be written to it. The string '-' can be used as an
      alias for standard output.</dd>
  <dt>A scalar reference</dt>
  <dd>If <span class="Li">$output</span> is a scalar reference, the compressed
      data will be stored in <span class="Li">$$output</span>.</dd>
</dl>
<p class="Pp">If the <span class="Li">$output</span> parameter is any other
    type, <span class="Li">&quot;IO::Compress::Zip&quot;</span>::new will return
    undef.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Constructor_Options"><a class="permalink" href="#Constructor_Options">Constructor
  Options</a></h2>
<span class="Li">&quot;OPTS&quot;</span> is any combination of the following
  options:
<dl class="Bl-tag">
  <dt>&quot;AutoClose =&gt; 0|1&quot;</dt>
  <dd>This option is only valid when the <span class="Li">$output</span>
      parameter is a filehandle. If specified, and the value is true, it will
      result in the <span class="Li">$output</span> being closed once either the
      <span class="Li">&quot;close&quot;</span> method is called or the
      <span class="Li">&quot;IO::Compress::Zip&quot;</span> object is destroyed.
    <p class="Pp">This parameter defaults to 0.</p>
  </dd>
  <dt>&quot;Append =&gt; 0|1&quot;</dt>
  <dd>Opens <span class="Li">$output</span> in append mode.
    <p class="Pp">The behaviour of this option is dependent on the type of
        <span class="Li">$output</span>.</p>
  </dd>
</dl>
<div class="Bd-indent">
<ul class="Bl-bullet">
  <li>A Buffer
    <p class="Pp">If <span class="Li">$output</span> is a buffer and
        <span class="Li">&quot;Append&quot;</span> is enabled, all compressed
        data will be append to the end of <span class="Li">$output</span>.
        Otherwise <span class="Li">$output</span> will be cleared before any
        data is written to it.</p>
  </li>
  <li>A Filename
    <p class="Pp">If <span class="Li">$output</span> is a filename and
        <span class="Li">&quot;Append&quot;</span> is enabled, the file will be
        opened in append mode. Otherwise the contents of the file, if any, will
        be truncated before any compressed data is written to it.</p>
  </li>
  <li>A Filehandle
    <p class="Pp">If <span class="Li">$output</span> is a filehandle, the file
        pointer will be positioned to the end of the file via a call to
        <span class="Li">&quot;seek&quot;</span> before any compressed data is
        written to it. Otherwise the file pointer will not be moved.</p>
  </li>
</ul>
</div>
<div class="Bd-indent">
<p class="Pp">This parameter defaults to 0.</p>
</div>
<dl class="Bl-tag">
  <dt>&quot;Name =&gt; $string&quot;</dt>
  <dd>Stores the contents of <span class="Li">$string</span> in the zip filename
      header field.
    <p class="Pp">If <span class="Li">&quot;Name&quot;</span> is not specified
        and the <span class="Li">$input</span> parameter is a filename, the
        value of <span class="Li">$input</span> will be used for the zip
        filename header field.</p>
    <p class="Pp">If <span class="Li">&quot;Name&quot;</span> is not specified
        and the <span class="Li">$input</span> parameter is not a filename, no
        zip filename field will be created.</p>
    <p class="Pp">Note that both the
        <span class="Li">&quot;CanonicalName&quot;</span> and
        <span class="Li">&quot;FilterName&quot;</span> options can modify the
        value used for the zip filename header field.</p>
  </dd>
  <dt>&quot;CanonicalName =&gt; 0|1&quot;</dt>
  <dd>This option controls whether the filename field in the zip header is
      <i>normalized</i> into Unix format before being written to the zip file.
    <p class="Pp">It is recommended that you enable this option unless you
        really need to create a non-standard Zip file.</p>
    <p class="Pp">This is what APPNOTE.TXT has to say on what should be stored
        in the zip filename header field.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    The name of the file, with optional relative path.
    The path stored should not contain a drive or
    device letter, or a leading slash.  All slashes
    should be forward slashes '/' as opposed to
    backwards slashes '\' for compatibility with Amiga
    and UNIX file systems etc.
    </pre>
    <p class="Pp">This option defaults to <b>false</b>.</p>
  </dd>
  <dt>&quot;FilterName =&gt; sub { ... }&quot;</dt>
  <dd>This option allow the filename field in the zip header to be modified
      before it is written to the zip file.
    <p class="Pp">This option takes a parameter that must be a reference to a
        sub. On entry to the sub the <span class="Li">$_</span> variable will
        contain the name to be filtered. If no filename is available
        <span class="Li">$_</span> will contain an empty string.</p>
    <p class="Pp">The value of <span class="Li">$_</span> when the sub returns
        will be stored in the filename header field.</p>
    <p class="Pp">Note that if <span class="Li">&quot;CanonicalName&quot;</span>
        is enabled, a normalized filename will be passed to the sub.</p>
    <p class="Pp">If you use <span class="Li">&quot;FilterName&quot;</span> to
        modify the filename, it is your responsibility to keep the filename in
        Unix format.</p>
    <p class="Pp">Although this option can be used with the OO interface, it is
        of most use with the one-shot interface. For example, the code below
        shows how <span class="Li">&quot;FilterName&quot;</span> can be used to
        remove the path component from a series of filenames before they are
        stored in <span class="Li">$zipfile</span>.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    sub compressTxtFiles
    {
        my $zipfile = shift ;
        my $dir     = shift ;

        zip [ &lt;$dir/*.txt&gt; ] =&gt; $zipfile,
            FilterName =&gt; sub { s[^$dir/][] } ;
    }
    </pre>
  </dd>
  <dt>&quot;Time =&gt; $number&quot;</dt>
  <dd>Sets the last modified time field in the zip header to
      <span class="Li">$number</span>.
    <p class="Pp">This field defaults to the time the
        <span class="Li">&quot;IO::Compress::Zip&quot;</span> object was created
        if this option is not specified and the <span class="Li">$input</span>
        parameter is not a filename.</p>
  </dd>
  <dt>&quot;ExtAttr =&gt; $attr&quot;</dt>
  <dd>This option controls the &quot;external file attributes&quot; field in the
      central header of the zip file. This is a 4 byte field.
    <p class="Pp">If you are running a Unix derivative this value defaults
      to</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    0100644 &lt;&lt; 16
    </pre>
    <p class="Pp">This should allow read/write access to any files that are
        extracted from the zip file/buffer`.</p>
    <p class="Pp">For all other systems it defaults to 0.</p>
  </dd>
  <dt>&quot;exTime =&gt; [$atime, $mtime, $ctime]&quot;</dt>
  <dd>This option expects an array reference with exactly three elements:
      <span class="Li">$atime</span>, <span class="Li">&quot;mtime&quot;</span>
      and <span class="Li">$ctime</span>. These correspond to the last access
      time, last modification time and creation time respectively.
    <p class="Pp">It uses these values to set the extended timestamp field (ID
        is &quot;UT&quot;) in the local zip header using the three values,
        <span class="Li">$atime</span>, <span class="Li">$mtime</span>,
        <span class="Li">$ctime</span>. In addition it sets the extended
        timestamp field in the central zip header using
        <span class="Li">$mtime</span>.</p>
    <p class="Pp">If any of the three values is
        <span class="Li">&quot;undef&quot;</span> that time value will not be
        used. So, for example, to set only the <span class="Li">$mtime</span>
        you would use this</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    exTime =&gt; [undef, $mtime, undef]
    </pre>
    <p class="Pp">If the <span class="Li">&quot;Minimal&quot;</span> option is
        set to true, this option will be ignored.</p>
    <p class="Pp">By default no extended time field is created.</p>
  </dd>
  <dt>&quot;exUnix2 =&gt; [$uid, $gid]&quot;</dt>
  <dd>This option expects an array reference with exactly two elements:
      <span class="Li">$uid</span> and <span class="Li">$gid</span>. These
      values correspond to the numeric User ID (UID) and Group ID (GID) of the
      owner of the files respectively.
    <p class="Pp">When the <span class="Li">&quot;exUnix2&quot;</span> option is
        present it will trigger the creation of a Unix2 extra field (ID is
        &quot;Ux&quot;) in the local zip header. This will be populated with
        <span class="Li">$uid</span> and <span class="Li">$gid</span>. An empty
        Unix2 extra field will also be created in the central zip header.</p>
    <p class="Pp">Note - The UID &amp; GID are stored as 16-bit integers in the
        &quot;Ux&quot; field. Use <span class="Li">&quot;exUnixN&quot;</span> if
        your UID or GID are 32-bit.</p>
    <p class="Pp">If the <span class="Li">&quot;Minimal&quot;</span> option is
        set to true, this option will be ignored.</p>
    <p class="Pp">By default no Unix2 extra field is created.</p>
  </dd>
  <dt>&quot;exUnixN =&gt; [$uid, $gid]&quot;</dt>
  <dd>This option expects an array reference with exactly two elements:
      <span class="Li">$uid</span> and <span class="Li">$gid</span>. These
      values correspond to the numeric User ID (UID) and Group ID (GID) of the
      owner of the files respectively.
    <p class="Pp">When the <span class="Li">&quot;exUnixN&quot;</span> option is
        present it will trigger the creation of a UnixN extra field (ID is
        &quot;ux&quot;) in both the local and central zip headers. This will be
        populated with <span class="Li">$uid</span> and
        <span class="Li">$gid</span>. The UID &amp; GID are stored as 32-bit
        integers.</p>
    <p class="Pp">If the <span class="Li">&quot;Minimal&quot;</span> option is
        set to true, this option will be ignored.</p>
    <p class="Pp">By default no UnixN extra field is created.</p>
  </dd>
  <dt>&quot;Comment =&gt; $comment&quot;</dt>
  <dd>Stores the contents of <span class="Li">$comment</span> in the Central
      File Header of the zip file.
    <p class="Pp">By default, no comment field is written to the zip file.</p>
  </dd>
  <dt>&quot;ZipComment =&gt; $comment&quot;</dt>
  <dd>Stores the contents of <span class="Li">$comment</span> in the End of
      Central Directory record of the zip file.
    <p class="Pp">By default, no comment field is written to the zip file.</p>
  </dd>
  <dt>&quot;Method =&gt; $method&quot;</dt>
  <dd>Controls which compression method is used. At present four compression
      methods are supported, namely Store (no compression at all), Deflate,
      Bzip2 and Lzma.
    <p class="Pp">The symbols, ZIP_CM_STORE, ZIP_CM_DEFLATE, ZIP_CM_BZIP2 and
        ZIP_CM_LZMA are used to select the compression method.</p>
    <p class="Pp">These constants are not imported by
        <span class="Li">&quot;IO::Compress::Zip&quot;</span> by default.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    use IO::Compress::Zip qw(:zip_method);
    use IO::Compress::Zip qw(:constants);
    use IO::Compress::Zip qw(:all);
    </pre>
    <p class="Pp">Note that to create Bzip2 content, the module
        <span class="Li">&quot;IO::Compress::Bzip2&quot;</span> must be
        installed. A fatal error will be thrown if you attempt to create Bzip2
        content when <span class="Li">&quot;IO::Compress::Bzip2&quot;</span> is
        not available.</p>
    <p class="Pp">Note that to create Lzma content, the module
        <span class="Li">&quot;IO::Compress::Lzma&quot;</span> must be
        installed. A fatal error will be thrown if you attempt to create Lzma
        content when <span class="Li">&quot;IO::Compress::Lzma&quot;</span> is
        not available.</p>
    <p class="Pp">The default method is ZIP_CM_DEFLATE.</p>
  </dd>
  <dt>&quot;Stream =&gt; 0|1&quot;</dt>
  <dd>This option controls whether the zip file/buffer output is created in
      streaming mode.
    <p class="Pp">Note that when outputting to a file with streaming mode
        disabled (<span class="Li">&quot;Stream&quot;</span> is 0), the output
        file must be seekable.</p>
    <p class="Pp">The default is 1.</p>
  </dd>
  <dt>&quot;Zip64 =&gt; 0|1&quot;</dt>
  <dd>Create a Zip64 zip file/buffer. This option is used if you want to store
      files larger than 4 Gig or store more than 64K files in a single zip
      archive.
    <p class="Pp"><span class="Li">&quot;Zip64&quot;</span> will be
        automatically set, as needed, if working with the one-shot interface
        when the input is either a filename or a scalar reference.</p>
    <p class="Pp">If you intend to manipulate the Zip64 zip files created with
        this module using an external zip/unzip, make sure that it supports
        Zip64.</p>
    <p class="Pp">In particular, if you are using Info-Zip you need to have zip
        version 3.x or better to update a Zip64 archive and unzip version 6.x to
        read a zip64 archive.</p>
    <p class="Pp">The default is 0.</p>
  </dd>
  <dt>&quot;TextFlag =&gt; 0|1&quot;</dt>
  <dd>This parameter controls the setting of a bit in the zip central header. It
      is used to signal that the data stored in the zip file/buffer is probably
      text.
    <p class="Pp">In one-shot mode this flag will be set to true if the Perl
        <span class="Li">&quot;-T&quot;</span> operator thinks the file contains
        text.</p>
    <p class="Pp">The default is 0.</p>
  </dd>
  <dt>&quot;ExtraFieldLocal =&gt; $data&quot;</dt>
  <dd></dd>
  <dt>&quot;ExtraFieldCentral =&gt; $data&quot;</dt>
  <dd>The <span class="Li">&quot;ExtraFieldLocal&quot;</span> option is used to
      store additional metadata in the local header for the zip file/buffer. The
      <span class="Li">&quot;ExtraFieldCentral&quot;</span> does the same for
      the matching central header.
    <p class="Pp">An extra field consists of zero or more subfields. Each
        subfield consists of a two byte header followed by the subfield
      data.</p>
    <p class="Pp">The list of subfields can be supplied in any of the following
        formats</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    ExtraFieldLocal =&gt; [$id1, $data1,
                        $id2, $data2,
                         ...
                       ]

    ExtraFieldLocal =&gt; [ [$id1 =&gt; $data1],
                         [$id2 =&gt; $data2],
                         ...
                       ]

    ExtraFieldLocal =&gt; { $id1 =&gt; $data1,
                         $id2 =&gt; $data2,
                         ...
                       }
    </pre>
    <p class="Pp">Where <span class="Li">$id1</span>,
        <span class="Li">$id2</span> are two byte subfield ID's.</p>
    <p class="Pp">If you use the hash syntax, you have no control over the order
        in which the ExtraSubFields are stored, plus you cannot have SubFields
        with duplicate ID.</p>
    <p class="Pp">Alternatively the list of subfields can by supplied as a
        scalar, thus</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    ExtraField =&gt; $rawdata
    </pre>
    <p class="Pp">In this case
        <span class="Li">&quot;IO::Compress::Zip&quot;</span> will check that
        <span class="Li">$rawdata</span> consists of zero or more conformant
        sub-fields.</p>
    <p class="Pp">The Extended Time field (ID &quot;UT&quot;), set using the
        <span class="Li">&quot;exTime&quot;</span> option, and the Unix2 extra
        field (ID &quot;Ux), set using the
        <span class="Li">&quot;exUnix2&quot;</span> option, are examples of
        extra fields.</p>
    <p class="Pp">If the <span class="Li">&quot;Minimal&quot;</span> option is
        set to true, this option will be ignored.</p>
    <p class="Pp">The maximum size of an extra field 65535 bytes.</p>
  </dd>
  <dt>&quot;Minimal =&gt; 1|0&quot;</dt>
  <dd>If specified, this option will disable the creation of all extra fields in
      the zip local and central headers. So the
      <span class="Li">&quot;exTime&quot;</span>,
      <span class="Li">&quot;exUnix2&quot;</span>,
      <span class="Li">&quot;exUnixN&quot;</span>,
      <span class="Li">&quot;ExtraFieldLocal&quot;</span> and
      <span class="Li">&quot;ExtraFieldCentral&quot;</span> options will be
      ignored.
    <p class="Pp">This parameter defaults to 0.</p>
  </dd>
  <dt>&quot;BlockSize100K =&gt; number&quot;</dt>
  <dd>Specify the number of 100K blocks bzip2 uses during compression.
    <p class="Pp">Valid values are from 1 to 9, where 9 is best compression.</p>
    <p class="Pp">This option is only valid if the
        <span class="Li">&quot;Method&quot;</span> is ZIP_CM_BZIP2. It is
        ignored otherwise.</p>
    <p class="Pp">The default is 1.</p>
  </dd>
  <dt>&quot;WorkFactor =&gt; number&quot;</dt>
  <dd>Specifies how much effort bzip2 should take before resorting to a slower
      fallback compression algorithm.
    <p class="Pp">Valid values range from 0 to 250, where 0 means use the
        default value 30.</p>
    <p class="Pp">This option is only valid if the
        <span class="Li">&quot;Method&quot;</span> is ZIP_CM_BZIP2. It is
        ignored otherwise.</p>
    <p class="Pp">The default is 0.</p>
  </dd>
  <dt>&quot;Preset =&gt; number&quot;</dt>
  <dd>Used to choose the LZMA compression preset.
    <p class="Pp">Valid values are 0-9 and
        <span class="Li">&quot;LZMA_PRESET_DEFAULT&quot;</span>.</p>
    <p class="Pp">0 is the fastest compression with the lowest memory usage and
        the lowest compression.</p>
    <p class="Pp">9 is the slowest compression with the highest memory usage but
        with the best compression.</p>
    <p class="Pp">This option is only valid if the
        <span class="Li">&quot;Method&quot;</span> is ZIP_CM_LZMA. It is ignored
        otherwise.</p>
    <p class="Pp">Defaults to
        <span class="Li">&quot;LZMA_PRESET_DEFAULT&quot;</span> (6).</p>
  </dd>
  <dt>&quot;Extreme =&gt; 0|1&quot;</dt>
  <dd>Makes LZMA compression a lot slower, but a small compression gain.
    <p class="Pp">This option is only valid if the
        <span class="Li">&quot;Method&quot;</span> is ZIP_CM_LZMA. It is ignored
        otherwise.</p>
    <p class="Pp">Defaults to 0.</p>
  </dd>
  <dt>-Level</dt>
  <dd>Defines the compression level used by zlib. The value should either be a
      number between 0 and 9 (0 means no compression and 9 is maximum
      compression), or one of the symbolic constants defined below.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
   Z_NO_COMPRESSION
   Z_BEST_SPEED
   Z_BEST_COMPRESSION
   Z_DEFAULT_COMPRESSION
    </pre>
    <p class="Pp">The default is Z_DEFAULT_COMPRESSION.</p>
    <p class="Pp">Note, these constants are not imported by
        <span class="Li">&quot;IO::Compress::Zip&quot;</span> by default.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    use IO::Compress::Zip qw(:strategy);
    use IO::Compress::Zip qw(:constants);
    use IO::Compress::Zip qw(:all);
    </pre>
  </dd>
  <dt>-Strategy</dt>
  <dd>Defines the strategy used to tune the compression. Use one of the symbolic
      constants defined below.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
   Z_FILTERED
   Z_HUFFMAN_ONLY
   Z_RLE
   Z_FIXED
   Z_DEFAULT_STRATEGY
    </pre>
    <p class="Pp">The default is Z_DEFAULT_STRATEGY.</p>
  </dd>
  <dt>&quot;Strict =&gt; 0|1&quot;</dt>
  <dd>This is a placeholder option.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Examples_2"><a class="permalink" href="#Examples_2">Examples</a></h2>
TODO
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="Methods"><a class="permalink" href="#Methods">Methods</a></h1>
<section class="Ss">
<h2 class="Ss" id="print"><a class="permalink" href="#print">print</a></h2>
Usage is
<p class="Pp"><span class="Li"></span></p>
<pre>
    $z-&gt;print($data)
    print $z $data
</pre>
<p class="Pp">Compresses and outputs the contents of the
    <span class="Li">$data</span> parameter. This has the same behaviour as the
    <span class="Li">&quot;print&quot;</span> built-in.</p>
<p class="Pp">Returns true if successful.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="printf"><a class="permalink" href="#printf">printf</a></h2>
Usage is
<p class="Pp"><span class="Li"></span></p>
<pre>
    $z-&gt;printf($format, $data)
    printf $z $format, $data
</pre>
<p class="Pp">Compresses and outputs the contents of the
    <span class="Li">$data</span> parameter.</p>
<p class="Pp">Returns true if successful.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="syswrite"><a class="permalink" href="#syswrite">syswrite</a></h2>
Usage is
<p class="Pp"><span class="Li"></span></p>
<pre>
    $z-&gt;syswrite $data
    $z-&gt;syswrite $data, $length
    $z-&gt;syswrite $data, $length, $offset
</pre>
<p class="Pp">Compresses and outputs the contents of the
    <span class="Li">$data</span> parameter.</p>
<p class="Pp">Returns the number of uncompressed bytes written, or
    <span class="Li">&quot;undef&quot;</span> if unsuccessful.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="write"><a class="permalink" href="#write">write</a></h2>
Usage is
<p class="Pp"><span class="Li"></span></p>
<pre>
    $z-&gt;write $data
    $z-&gt;write $data, $length
    $z-&gt;write $data, $length, $offset
</pre>
<p class="Pp">Compresses and outputs the contents of the
    <span class="Li">$data</span> parameter.</p>
<p class="Pp">Returns the number of uncompressed bytes written, or
    <span class="Li">&quot;undef&quot;</span> if unsuccessful.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="flush"><a class="permalink" href="#flush">flush</a></h2>
Usage is
<p class="Pp"><span class="Li"></span></p>
<pre>
    $z-&gt;flush;
    $z-&gt;flush($flush_type);
</pre>
<p class="Pp">Flushes any pending compressed data to the output file/buffer.</p>
<p class="Pp">This method takes an optional parameter,
    <span class="Li">$flush_type</span>, that controls how the flushing will be
    carried out. By default the <span class="Li">$flush_type</span> used is
    <span class="Li">&quot;Z_FINISH&quot;</span>. Other valid values for
    <span class="Li">$flush_type</span> are
    <span class="Li">&quot;Z_NO_FLUSH&quot;</span>,
    <span class="Li">&quot;Z_SYNC_FLUSH&quot;</span>,
    <span class="Li">&quot;Z_FULL_FLUSH&quot;</span> and
    <span class="Li">&quot;Z_BLOCK&quot;</span>. It is strongly recommended that
    you only set the <span class="Li">&quot;flush_type&quot;</span> parameter if
    you fully understand the implications of what it does - overuse of
    <span class="Li">&quot;flush&quot;</span> can seriously degrade the level of
    compression achieved. See the <span class="Li">&quot;zlib&quot;</span>
    documentation for details.</p>
<p class="Pp">Returns true on success.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="tell"><a class="permalink" href="#tell">tell</a></h2>
Usage is
<p class="Pp"><span class="Li"></span></p>
<pre>
    $z-&gt;tell()
    tell $z
</pre>
<p class="Pp">Returns the uncompressed file offset.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="eof"><a class="permalink" href="#eof">eof</a></h2>
Usage is
<p class="Pp"><span class="Li"></span></p>
<pre>
    $z-&gt;eof();
    eof($z);
</pre>
<p class="Pp">Returns true if the <span class="Li">&quot;close&quot;</span>
    method has been called.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="seek"><a class="permalink" href="#seek">seek</a></h2>
<span class="Li"></span>
<pre>
    $z-&gt;seek($position, $whence);
    seek($z, $position, $whence);
</pre>
<p class="Pp">Provides a sub-set of the <span class="Li">&quot;seek&quot;</span>
    functionality, with the restriction that it is only legal to seek forward in
    the output file/buffer. It is a fatal error to attempt to seek backward.</p>
<p class="Pp">Empty parts of the file/buffer will have NULL (0x00) bytes written
    to them.</p>
<p class="Pp">The <span class="Li">$whence</span> parameter takes one the usual
    values, namely SEEK_SET, SEEK_CUR or SEEK_END.</p>
<p class="Pp">Returns 1 on success, 0 on failure.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="binmode"><a class="permalink" href="#binmode">binmode</a></h2>
Usage is
<p class="Pp"><span class="Li"></span></p>
<pre>
    $z-&gt;binmode
    binmode $z ;
</pre>
<p class="Pp">This is a noop provided for completeness.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="opened"><a class="permalink" href="#opened">opened</a></h2>
<span class="Li"></span>
<pre>
    $z-&gt;opened()
</pre>
<p class="Pp">Returns true if the object currently refers to a opened
    file/buffer.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="autoflush"><a class="permalink" href="#autoflush">autoflush</a></h2>
<span class="Li"></span>
<pre>
    my $prev = $z-&gt;autoflush()
    my $prev = $z-&gt;autoflush(EXPR)
</pre>
<p class="Pp">If the <span class="Li">$z</span> object is associated with a file
    or a filehandle, this method returns the current autoflush setting for the
    underlying filehandle. If <span class="Li">&quot;EXPR&quot;</span> is
    present, and is non-zero, it will enable flushing after every write/print
    operation.</p>
<p class="Pp">If <span class="Li">$z</span> is associated with a buffer, this
    method has no effect and always returns
    <span class="Li">&quot;undef&quot;</span>.</p>
<p class="Pp"><b>Note</b> that the special variable <span class="Li">$|</span>
    <b>cannot</b> be used to set or retrieve the autoflush setting.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="input_line_number"><a class="permalink" href="#input_line_number">input_line_number</a></h2>
<span class="Li"></span>
<pre>
    $z-&gt;input_line_number()
    $z-&gt;input_line_number(EXPR)
</pre>
<p class="Pp">This method always returns
    <span class="Li">&quot;undef&quot;</span> when compressing.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="fileno"><a class="permalink" href="#fileno">fileno</a></h2>
<span class="Li"></span>
<pre>
    $z-&gt;fileno()
    fileno($z)
</pre>
<p class="Pp">If the <span class="Li">$z</span> object is associated with a file
    or a filehandle, <span class="Li">&quot;fileno&quot;</span> will return the
    underlying file descriptor. Once the
    <span class="Li">&quot;close&quot;</span> method is called
    <span class="Li">&quot;fileno&quot;</span> will return
    <span class="Li">&quot;undef&quot;</span>.</p>
<p class="Pp">If the <span class="Li">$z</span> object is associated with a
    buffer, this method will return
  <span class="Li">&quot;undef&quot;</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="close"><a class="permalink" href="#close">close</a></h2>
<span class="Li"></span>
<pre>
    $z-&gt;close() ;
    close $z ;
</pre>
<p class="Pp">Flushes any pending compressed data and then closes the output
    file/buffer.</p>
<p class="Pp">For most versions of Perl this method will be automatically
    invoked if the IO::Compress::Zip object is destroyed (either explicitly or
    by the variable with the reference to the object going out of scope). The
    exceptions are Perl versions 5.005 through 5.00504 and 5.8.0. In these
    cases, the <span class="Li">&quot;close&quot;</span> method will be called
    automatically, but not until global destruction of all live objects when the
    program is terminating.</p>
<p class="Pp">Therefore, if you want your scripts to be able to run on all
    versions of Perl, you should call <span class="Li">&quot;close&quot;</span>
    explicitly and not rely on automatic closing.</p>
<p class="Pp">Returns true on success, otherwise 0.</p>
<p class="Pp">If the <span class="Li">&quot;AutoClose&quot;</span> option has
    been enabled when the IO::Compress::Zip object was created, and the object
    is associated with a file, the underlying file will also be closed.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="newStream(__s-1OPTS_s0_)"><a class="permalink" href="#newStream(__s-1OPTS_s0_)">newStream([OPTS])</a></h2>
Usage is
<p class="Pp"><span class="Li"></span></p>
<pre>
    $z-&gt;newStream( [OPTS] )
</pre>
<p class="Pp">Closes the current compressed data stream and starts a new
  one.</p>
<p class="Pp">OPTS consists of any of the options that are available when
    creating the <span class="Li">$z</span> object.</p>
<p class="Pp">See the &quot;Constructor Options&quot; section for more
  details.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="deflateParams"><a class="permalink" href="#deflateParams">deflateParams</a></h2>
Usage is
<p class="Pp"><span class="Li"></span></p>
<pre>
    $z-&gt;deflateParams
</pre>
<p class="Pp">TODO</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="Importing"><a class="permalink" href="#Importing">Importing</a></h1>
A number of symbolic constants are required by some methods in
  <span class="Li">&quot;IO::Compress::Zip&quot;</span>. None are imported by
  default.
<dl class="Bl-tag">
  <dt>:all</dt>
  <dd>Imports <span class="Li">&quot;zip&quot;</span>,
      <span class="Li">$ZipError</span> and all symbolic constants that can be
      used by <span class="Li">&quot;IO::Compress::Zip&quot;</span>. Same as
      doing this
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    use IO::Compress::Zip qw(zip $ZipError :constants) ;
    </pre>
  </dd>
  <dt>:constants</dt>
  <dd>Import all symbolic constants. Same as doing this
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    use IO::Compress::Zip qw(:flush :level :strategy :zip_method) ;
    </pre>
  </dd>
  <dt>:flush</dt>
  <dd>These symbolic constants are used by the
      <span class="Li">&quot;flush&quot;</span> method.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    Z_NO_FLUSH
    Z_PARTIAL_FLUSH
    Z_SYNC_FLUSH
    Z_FULL_FLUSH
    Z_FINISH
    Z_BLOCK
    </pre>
  </dd>
  <dt>:level</dt>
  <dd>These symbolic constants are used by the
      <span class="Li">&quot;Level&quot;</span> option in the constructor.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    Z_NO_COMPRESSION
    Z_BEST_SPEED
    Z_BEST_COMPRESSION
    Z_DEFAULT_COMPRESSION
    </pre>
  </dd>
  <dt>:strategy</dt>
  <dd>These symbolic constants are used by the
      <span class="Li">&quot;Strategy&quot;</span> option in the constructor.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    Z_FILTERED
    Z_HUFFMAN_ONLY
    Z_RLE
    Z_FIXED
    Z_DEFAULT_STRATEGY
    </pre>
  </dd>
  <dt>:zip_method</dt>
  <dd>These symbolic constants are used by the
      <span class="Li">&quot;Method&quot;</span> option in the constructor.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    ZIP_CM_STORE
    ZIP_CM_DEFLATE
    ZIP_CM_BZIP2
    </pre>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="EXAMPLES"><a class="permalink" href="#EXAMPLES">EXAMPLES</a></h1>
<section class="Ss">
<h2 class="Ss" id="Apache::GZip_Revisited"><a class="permalink" href="#Apache::GZip_Revisited">Apache::GZip
  Revisited</a></h2>
See IO::Compress::FAQ
</section>
<section class="Ss">
<h2 class="Ss" id="Working_with_Net::FTP"><a class="permalink" href="#Working_with_Net::FTP">Working
  with Net::FTP</a></h2>
See IO::Compress::FAQ
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
Compress::Zlib, IO::Compress::Gzip, IO::Uncompress::Gunzip,
  IO::Compress::Deflate, IO::Uncompress::Inflate, IO::Compress::RawDeflate,
  IO::Uncompress::RawInflate, IO::Compress::Bzip2, IO::Uncompress::Bunzip2,
  IO::Compress::Lzma, IO::Uncompress::UnLzma, IO::Compress::Xz,
  IO::Uncompress::UnXz, IO::Compress::Lzip, IO::Uncompress::UnLzip,
  IO::Compress::Lzop, IO::Uncompress::UnLzop, IO::Compress::Lzf,
  IO::Uncompress::UnLzf, IO::Compress::Zstd, IO::Uncompress::UnZstd,
  IO::Uncompress::AnyInflate, IO::Uncompress::AnyUncompress
<p class="Pp">IO::Compress::FAQ</p>
<p class="Pp">File::GlobMapper, Archive::Zip, Archive::Tar, IO::Zlib</p>
<p class="Pp">For RFC 1950, 1951 and 1952 see
    &lt;http://www.faqs.org/rfcs/rfc1950.html&gt;,
    &lt;http://www.faqs.org/rfcs/rfc1951.html&gt; and
    &lt;http://www.faqs.org/rfcs/rfc1952.html&gt;</p>
<p class="Pp">The <i>zlib</i> compression library was written by Jean-loup
    Gailly <span class="Li">&quot;gzip@prep.ai.mit.edu&quot;</span> and Mark
    Adler <span class="Li">&quot;madler@alumni.caltech.edu&quot;</span>.</p>
<p class="Pp">The primary site for the <i>zlib</i> compression library is
    &lt;http://www.zlib.org&gt;.</p>
<p class="Pp">The primary site for gzip is &lt;http://www.gzip.org&gt;.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
This module was written by Paul Marquess,
  <span class="Li">&quot;pmqs@cpan.org&quot;</span>.
</section>
<section class="Sh">
<h1 class="Sh" id="MODIFICATION_HISTORY"><a class="permalink" href="#MODIFICATION_HISTORY">MODIFICATION
  HISTORY</a></h1>
See the Changes file.
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT_AND_LICENSE"><a class="permalink" href="#COPYRIGHT_AND_LICENSE">COPYRIGHT
  AND LICENSE</a></h1>
Copyright (c) 2005-2019 Paul Marquess. All rights reserved.
<p class="Pp">This program is free software; you can redistribute it and/or
    modify it under the same terms as Perl itself.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2019-10-24</td>
    <td class="foot-os">perl v5.30.2</td>
  </tr>
</table>
</body>
</html>
