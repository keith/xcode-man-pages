<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    .Nd, .Bf, .Op { display: inline; }
    .Pa, .Ad { font-style: italic; }
    .Ms { font-weight: bold; }
    .Bl-diag > dt { font-weight: bold; }
    code.Nm, .Fl, .Cm, .Ic, code.In, .Fd, .Fn, .Cd { font-weight: bold;
      font-family: inherit; }
  </style>
  <title>Class::MOP(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Class::MOP(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Class::MOP(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Class::MOP - A Meta Object Protocol for Perl 5</p>
</section>
<section class="Sh">
<h1 class="Sh" id="VERSION"><a class="permalink" href="#VERSION">VERSION</a></h1>
<p class="Pp">version 2.2012</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">This module is a fully functioning meta object protocol for the
    Perl 5 object system. It makes no attempt to change the behavior or
    characteristics of the Perl 5 object system, only to create a protocol for
    its manipulation and introspection.</p>
<p class="Pp">That said, it does attempt to create the tools for building a rich
    set of extensions to the Perl 5 object system. Every attempt has been made
    to abide by the spirit of the Perl 5 object system that we all know and
    love.</p>
<p class="Pp">This documentation is sparse on conceptual details. We suggest
    looking at the items listed in the &quot;SEE ALSO&quot; section for more
    information. In particular the book &quot;The Art of the Meta Object
    Protocol&quot; was very influential in the development of this system.</p>
<section class="Ss">
<h2 class="Ss" id="What_is_a_Meta_Object_Protocol?"><a class="permalink" href="#What_is_a_Meta_Object_Protocol?">What
  is a Meta Object Protocol?</a></h2>
<p class="Pp">A meta object protocol is an API to an object system.</p>
<p class="Pp">To be more specific, it abstracts the components of an object
    system (classes, object, methods, object attributes, etc.). These
    abstractions can then be used to inspect and manipulate the object system
    which they describe.</p>
<p class="Pp">It can be said that there are two MOPs for any object system; the
    implicit MOP and the explicit MOP. The implicit MOP handles things like
    method dispatch or inheritance, which happen automatically as part of how
    the object system works. The explicit MOP typically handles the
    introspection/reflection features of the object system.</p>
<p class="Pp">All object systems have implicit MOPs. Without one, they would not
    work. Explicit MOPs are much less common, and depending on the language can
    vary from restrictive (Reflection in Java or C#) to wide open (CLOS is a
    perfect example).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Yet_Another_Class_Builder!_Why?"><a class="permalink" href="#Yet_Another_Class_Builder!_Why?">Yet
  Another Class Builder! Why?</a></h2>
<p class="Pp">This is <b>not</b> a class builder so much as a <i>class
    builder</i> <i></i><b><i>builder</i></b><i></i>. The intent is that an end
    user will not use this module directly, but instead this module is used by
    module authors to build extensions and features onto the Perl 5 object
    system.</p>
<p class="Pp">This system is used by Moose, which supplies a powerful class
    builder system built entirely on top of
    <span class="Li">&quot;Class::MOP&quot;</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Who_is_this_module_for?"><a class="permalink" href="#Who_is_this_module_for?">Who
  is this module for?</a></h2>
<p class="Pp">This module is for anyone who has ever created or wanted to create
    a module for the Class:: namespace. The tools which this module provides
    make doing complex Perl 5 wizardry simpler, by removing such barriers as the
    need to hack symbol tables, or understand the fine details of method
    dispatch.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="What_changes_do_I_have_to_make_to_use_this_module?"><a class="permalink" href="#What_changes_do_I_have_to_make_to_use_this_module?">What
  changes do I have to make to use this module?</a></h2>
<p class="Pp">This module was designed to be as unobtrusive as possible. Many of
    its features are accessible without <b>any</b> change to your existing code.
    It is meant to be a complement to your existing code and not an intrusion on
    your code base. Unlike many other <b>Class::</b> modules, this module
    <b>does not</b> require you subclass it, or even that you
    <span class="Li">&quot;use&quot;</span> it in within your module's
  package.</p>
<p class="Pp">The only features which require additions to your code are the
    attribute handling and instance construction features, and these are both
    completely optional features. The only reason for this is because Perl 5's
    object system does not actually have these features built in. More
    information about this feature can be found below.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="About_Performance"><a class="permalink" href="#About_Performance">About
  Performance</a></h2>
<p class="Pp">It is a common misconception that explicit MOPs are a performance
    hit. This is not a universal truth, it is a side-effect of some specific
    implementations. For instance, using Java reflection is slow because the JVM
    cannot take advantage of any compiler optimizations, and the JVM has to deal
    with much more runtime type information as well.</p>
<p class="Pp">Reflection in C# is marginally better as it was designed into the
    language and runtime (the CLR). In contrast, CLOS (the Common Lisp Object
    System) was built to support an explicit MOP, and so performance is tuned
    for it.</p>
<p class="Pp">This library in particular does its absolute best to avoid putting
    <b>any</b> drain at all upon your code's performance. In fact, by itself it
    does nothing to affect your existing code. So you only pay for what you
    actually use.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="About_Metaclass_compatibility"><a class="permalink" href="#About_Metaclass_compatibility">About
  Metaclass compatibility</a></h2>
<p class="Pp">This module makes sure that all metaclasses created are both
    upwards and downwards compatible. The topic of metaclass compatibility is
    highly esoteric and is something only encountered when doing deep and
    involved metaclass hacking. There are two basic kinds of metaclass
    incompatibility; upwards and downwards.</p>
<p class="Pp">Upwards metaclass compatibility means that the metaclass of a
    given class is either the same as (or a subclass of) all of the metaclasses
    of the class's ancestors.</p>
<p class="Pp">Downward metaclass compatibility means that the metaclasses of a
    given class's ancestors are all the same as (or a subclass of) that class's
    metaclass.</p>
<p class="Pp">Here is a diagram showing a set of two classes
    (<span class="Li">&quot;A&quot;</span> and
    <span class="Li">&quot;B&quot;</span>) and two metaclasses
    (<span class="Li">&quot;Meta::A&quot;</span> and
    <span class="Li">&quot;Meta::B&quot;</span>) which have correct metaclass
    compatibility both upwards and downwards.</p>
<p class="Pp"></p>
<pre>    +---------+     +---------+
    | Meta::A |&lt;----| Meta::B |      &lt;....... (instance of  )
    +---------+     +---------+      &lt;------- (inherits from)
         ^               ^
         :               :
    +---------+     +---------+
    |    A    |&lt;----|    B    |
    +---------+     +---------+
</pre>
<p class="Pp">In actuality, <i>all</i> of a class's metaclasses must be
    compatible, not just the class metaclass. That includes the instance,
    attribute, and method metaclasses, as well as the constructor and destructor
    classes.</p>
<p class="Pp"><span class="Li">&quot;Class::MOP&quot;</span> will attempt to fix
    some simple types of incompatibilities. If all the metaclasses for the
    parent class are <i>subclasses</i> of the child's metaclasses then we can
    simply replace the child's metaclasses with the parent's. In addition, if
    the child is missing a metaclass that the parent has, we can also just make
    the child use the parent's metaclass.</p>
<p class="Pp">As I said this is a highly esoteric topic and one you will only
    run into if you do a lot of subclassing of Class::MOP::Class. If you are
    interested in why this is an issue see the paper <i>Uniform and</i> <i>safe
    metaclass composition</i> linked to in the &quot;SEE ALSO&quot; section of
    this document.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Using_custom_metaclasses"><a class="permalink" href="#Using_custom_metaclasses">Using
  custom metaclasses</a></h2>
<p class="Pp">Always use the metaclass pragma when using a custom metaclass,
    this will ensure the proper initialization order and not accidentally create
    an incorrect type of metaclass for you. This is a very rare problem, and one
    which can only occur if you are doing deep metaclass programming. So in
    other words, don't worry about it.</p>
<p class="Pp">Note that if you're using Moose we encourage you to <i>not</i> use
    the metaclass pragma, and instead use Moose::Util::MetaRole to apply roles
    to a class's metaclasses. This topic is covered at length in various
    Moose::Cookbook recipes.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="PROTOCOLS"><a class="permalink" href="#PROTOCOLS">PROTOCOLS</a></h1>
<p class="Pp">The meta-object protocol is divided into 4 main sub-protocols:</p>
<section class="Ss">
<h2 class="Ss" id="The_Class_protocol"><a class="permalink" href="#The_Class_protocol">The
  Class protocol</a></h2>
<p class="Pp">This provides a means of manipulating and introspecting a Perl 5
    class. It handles symbol table hacking for you, and provides a rich set of
    methods that go beyond simple package introspection.</p>
<p class="Pp">See Class::MOP::Class for more details.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="The_Attribute_protocol"><a class="permalink" href="#The_Attribute_protocol">The
  Attribute protocol</a></h2>
<p class="Pp">This provides a consistent representation for an attribute of a
    Perl 5 class. Since there are so many ways to create and handle attributes
    in Perl 5 OO, the Attribute protocol provide as much of a unified approach
    as possible. Of course, you are always free to extend this protocol by
    subclassing the appropriate classes.</p>
<p class="Pp">See Class::MOP::Attribute for more details.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="The_Method_protocol"><a class="permalink" href="#The_Method_protocol">The
  Method protocol</a></h2>
<p class="Pp">This provides a means of manipulating and introspecting methods in
    the Perl 5 object system. As with attributes, there are many ways to
    approach this topic, so we try to keep it pretty basic, while still making
    it possible to extend the system in many ways.</p>
<p class="Pp">See Class::MOP::Method for more details.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="The_Instance_protocol"><a class="permalink" href="#The_Instance_protocol">The
  Instance protocol</a></h2>
<p class="Pp">This provides a layer of abstraction for creating object
    instances. Since the other layers use this protocol, it is relatively easy
    to change the type of your instances from the default hash reference to some
    other type of reference. Several examples are provided in the
    <i>examples/</i> directory included in this distribution.</p>
<p class="Pp">See Class::MOP::Instance for more details.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="FUNCTIONS"><a class="permalink" href="#FUNCTIONS">FUNCTIONS</a></h1>
<p class="Pp">Note that this module does not export any constants or
  functions.</p>
<section class="Ss">
<h2 class="Ss" id="Utility_functions"><a class="permalink" href="#Utility_functions">Utility
  functions</a></h2>
<p class="Pp">Note that these are all called as <b>functions, not
  methods</b>.</p>
<p class="Pp"><i>Class::MOP::get_code_info($code)</i></p>
<p class="Pp">This function returns two values, the name of the package the
    <span class="Li">$code</span> is from and the name of the
    <span class="Li">$code</span> itself. This is used by several elements of
    the MOP to determine where a given <span class="Li">$code</span> reference
    is from.</p>
<p class="Pp"><i>Class::MOP::class_of($instance_or_class_name)</i></p>
<p class="Pp">This will return the metaclass of the given instance or class
    name. If the class lacks a metaclass, no metaclass will be initialized, and
    <span class="Li">&quot;undef&quot;</span> will be returned.</p>
<p class="Pp">You should almost certainly be using
    <span class="Li">&quot;Moose::Util::find_meta&quot;</span> instead.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Metaclass_cache_functions"><a class="permalink" href="#Metaclass_cache_functions">Metaclass
  cache functions</a></h2>
<p class="Pp"><span class="Li">&quot;Class::MOP&quot;</span> holds a cache of
    metaclasses. The following are functions (<b>not methods</b>) which can be
    used to access that cache. It is not recommended that you mess with these.
    Bad things could happen, but if you are brave and willing to risk it: go for
    it!</p>
<p class="Pp"><i>Class::MOP::get_all_metaclasses</i></p>
<p class="Pp">This will return a hash of all the metaclass instances that have
    been cached by Class::MOP::Class, keyed by the package name.</p>
<p class="Pp"><i>Class::MOP::get_all_metaclass_instances</i></p>
<p class="Pp">This will return a list of all the metaclass instances that have
    been cached by Class::MOP::Class.</p>
<p class="Pp"><i>Class::MOP::get_all_metaclass_names</i></p>
<p class="Pp">This will return a list of all the metaclass names that have been
    cached by Class::MOP::Class.</p>
<p class="Pp"><i>Class::MOP::get_metaclass_by_name($name)</i></p>
<p class="Pp">This will return a cached Class::MOP::Class instance, or nothing
    if no metaclass exists with that <span class="Li">$name</span>.</p>
<p class="Pp"><i>Class::MOP::store_metaclass_by_name($name,
    </i><span class="Li"><i>$meta</i></span><i>)</i></p>
<p class="Pp">This will store a metaclass in the cache at the supplied
    <span class="Li">$key</span>.</p>
<p class="Pp"><i>Class::MOP::weaken_metaclass($name)</i></p>
<p class="Pp">In rare cases (e.g. anonymous metaclasses) it is desirable to
    store a weakened reference in the metaclass cache. This function will weaken
    the reference to the metaclass stored in <span class="Li">$name</span>.</p>
<p class="Pp"><i>Class::MOP::metaclass_is_weak($name)</i></p>
<p class="Pp">Returns true if the metaclass for <span class="Li">$name</span>
    has been weakened (via
    <span class="Li">&quot;weaken_metaclass&quot;</span>).</p>
<p class="Pp"><i>Class::MOP::does_metaclass_exist($name)</i></p>
<p class="Pp">This will return true of there exists a metaclass stored in the
    <span class="Li">$name</span> key, and return false otherwise.</p>
<p class="Pp"><i>Class::MOP::remove_metaclass_by_name($name)</i></p>
<p class="Pp">This will remove the metaclass stored in the
    <span class="Li">$name</span> key.</p>
<p class="Pp">Some utility functions (such as
    <span class="Li">&quot;Class::MOP::load_class&quot;</span>) that were
    previously defined in <span class="Li">&quot;Class::MOP&quot;</span>
    regarding loading of classes have been extracted to Class::Load. Please see
    Class::Load for documentation.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<section class="Ss">
<h2 class="Ss" id="Books"><a class="permalink" href="#Books">Books</a></h2>
<p class="Pp">There are very few books out on Meta Object Protocols and
    Metaclasses because it is such an esoteric topic. The following books are
    really the only ones I have found. If you know of any more,
    <b></b><b><i>please</i></b><b></b> email me and let me know, I would love to
    hear about them.</p>
<dl class="Bl-tag">
  <dt id="The"><a class="permalink" href="#The"><i>The Art of the Meta Object
    Protocol</i></a></dt>
  <dd></dd>
  <dt id="Advances"><a class="permalink" href="#Advances"><i>Advances in
    Object-Oriented Metalevel Architecture and Reflection</i></a></dt>
  <dd></dd>
  <dt id="Putting"><a class="permalink" href="#Putting"><i>Putting MetaClasses
    to Work</i></a></dt>
  <dd></dd>
  <dt id="Smalltalk:"><a class="permalink" href="#Smalltalk:"><i>Smalltalk: The
    Language</i></a></dt>
  <dd></dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Papers"><a class="permalink" href="#Papers">Papers</a></h2>
<dl class="Bl-tag">
  <dt>&quot;Uniform and safe metaclass composition&quot;</dt>
  <dd>An excellent paper by the people who brought us the original Traits paper.
      This paper is on how Traits can be used to do safe metaclass composition,
      and offers an excellent introduction section which delves into the topic
      of metaclass compatibility.
    <p class="Pp">&lt;http://scg.unibe.ch/archive/papers/Duca05ySafeMetaclassTrait.pdf&gt;</p>
  </dd>
  <dt>&quot;Safe Metaclass Programming&quot;</dt>
  <dd>This paper seems to precede the above paper, and propose a mix-in based
      approach as opposed to the Traits based approach. Both papers have similar
      information on the metaclass compatibility problem space.
    <p class="Pp">&lt;http://citeseer.ist.psu.edu/37617.html&gt;</p>
  </dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Prior_Art"><a class="permalink" href="#Prior_Art">Prior
  Art</a></h2>
<dl class="Bl-tag">
  <dt id="The~2"><a class="permalink" href="#The~2">The Perl 6 MetaModel work in
    the Pugs project</a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>&lt;http://github.com/perl6/p5-modules/tree/master/Perl6-ObjectSpace/&gt;</dt>
  <dd></dd>
</dl>
</div>
<div class="Bd-indent"></div>
</section>
<section class="Ss">
<h2 class="Ss" id="Articles"><a class="permalink" href="#Articles">Articles</a></h2>
<dl class="Bl-tag">
  <dt id="CPAN"><a class="permalink" href="#CPAN">CPAN Module Review of
    Class::MOP</a></dt>
  <dd>&lt;http://www.oreillynet.com/onlamp/blog/2006/06/cpan_module_review_classmop.html&gt;</dd>
</dl>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="SIMILAR_MODULES"><a class="permalink" href="#SIMILAR_MODULES">SIMILAR
  MODULES</a></h1>
<p class="Pp">As I have said above, this module is a class-builder-builder, so
    it is not the same thing as modules like Class::Accessor and
    Class::MethodMaker. That being said there are very few modules on CPAN with
    similar goals to this module. The one I have found which is most like this
    module is Class::Meta, although its philosophy and the MOP it creates are
    very different from this modules.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="BUGS"><a class="permalink" href="#BUGS">BUGS</a></h1>
<p class="Pp">All complex software has bugs lurking in it, and this module is no
    exception.</p>
<p class="Pp">Please report any bugs to
    <span class="Li">&quot;bug-class-mop@rt.cpan.org&quot;</span>, or through
    the web interface at &lt;http://rt.cpan.org&gt;.</p>
<p class="Pp">You can also discuss feature requests or possible bugs on the
    Moose mailing list (moose@perl.org) or on IRC at
    &lt;irc://irc.perl.org/#moose&gt;.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="ACKNOWLEDGEMENTS"><a class="permalink" href="#ACKNOWLEDGEMENTS">ACKNOWLEDGEMENTS</a></h1>
<dl class="Bl-tag">
  <dt id="Rob"><a class="permalink" href="#Rob">Rob Kinyon</a></dt>
  <dd>Thanks to Rob for actually getting the development of this module
      kick-started.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHORS"><a class="permalink" href="#AUTHORS">AUTHORS</a></h1>
<ul class="Bl-bullet">
  <li>Stevan Little &lt;stevan.little@iinteractive.com&gt;</li>
  <li>Dave Rolsky &lt;autarch@urth.org&gt;</li>
  <li>Jesse Luehrs &lt;doy@tozt.net&gt;</li>
  <li>Shawn M Moore &lt;code@sartak.org&gt;</li>
  <li>&#x05D9;&#x05D5;&#x05D1;&#x05DC; &#x05E7;&#x05D5;&#x05D2;'&#x05DE;&#x05DF;
      (Yuval Kogman) &lt;nothingmuch@woobling.org&gt;</li>
  <li>Karen Etheridge &lt;ether@cpan.org&gt;</li>
  <li>Florian Ragwitz &lt;rafl@debian.org&gt;</li>
  <li>Hans Dieter Pearcey &lt;hdp@weftsoar.net&gt;</li>
  <li>Chris Prather &lt;chris@prather.org&gt;</li>
  <li>Matt S Trout &lt;mst@shadowcat.co.uk&gt;</li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT_AND_LICENSE"><a class="permalink" href="#COPYRIGHT_AND_LICENSE">COPYRIGHT
  AND LICENSE</a></h1>
<p class="Pp">This software is copyright (c) 2006 by Infinity Interactive,
  Inc.</p>
<p class="Pp">This is free software; you can redistribute it and/or modify it
    under the same terms as the Perl 5 programming language system itself.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2019-11-22</td>
    <td class="foot-os">perl v5.34.0</td>
  </tr>
</table>
</body>
</html>
