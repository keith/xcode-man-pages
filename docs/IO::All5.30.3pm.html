<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    .Nd, .Bf, .Op { display: inline; }
    .Pa, .Ad { font-style: italic; }
    .Ms { font-weight: bold; }
    .Bl-diag > dt { font-weight: bold; }
    code.Nm, .Fl, .Cm, .Ic, code.In, .Fd, .Fn, .Cd { font-weight: bold;
      font-family: inherit; }
  </style>
  <title>IO::All(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">IO::All(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">IO::All(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">IO::All - IO::All to Larry Wall!</p>
</section>
<section class="Sh">
<h1 class="Sh" id="VERSION"><a class="permalink" href="#VERSION">VERSION</a></h1>
<p class="Pp">This document describes IO::All version <b>0.87</b>.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<p class="Pp">First, some safe examples:</p>
<p class="Pp"></p>
<pre>    use IO::All;
    # Some of the many ways to read a whole file into a scalar
    $contents = io-&gt;file('file.txt')-&gt;slurp;    # Read an entire file
    @files    = io-&gt;dir('lib')-&gt;all;            # Get a list of files
    $tail     = io-&gt;pipe('-| tail app.log');    # Open a pipe to a command
    $line     = $tail-&gt;getline;                 # Read from the pipe
</pre>
<p class="Pp">That said, there are a lot more things that are very convenient
    and will help you write code very quickly, though they should be used
    judiciously:</p>
<p class="Pp"></p>
<pre>    use IO::All;                                # Let the madness begin...
    # Some of the many ways to read a whole file into a scalar
    io('file.txt') &gt; $contents;                 # Overloaded &quot;arrow&quot;
    $contents &lt; io 'file.txt';                  # Flipped but same operation
    $io = io 'file.txt';                        # Create a new IO::All object
    $contents = $$io;                           # Overloaded scalar dereference
    $contents = $io-&gt;all;                       # A method to read everything
    $contents = $io-&gt;slurp;                     # Another method for that
    $contents = join '', $io-&gt;getlines;         # Join the separate lines
    $contents = join '', map &quot;$_\n&quot;, @$io;      # Same. Overloaded array deref
    $io-&gt;tie;                                   # Tie the object as a handle
    $contents = join '', &lt;$io&gt;;                 # And use it in builtins
    # and the list goes on ...
    # Other file operations:
    @lines = io('file.txt')-&gt;slurp;             # List context slurp
    $content &gt; io('file.txt');                  # Print to a file
    io('file.txt')-&gt;print($content, $more);     # (ditto)
    $content &gt;&gt; io('file.txt');                 # Append to a file
    io('file.txt')-&gt;append($content);           # (ditto)
    $content &lt;&lt; $io;                            # Append to a string
    io('copy.txt') &lt; io('file.txt');            $ Copy a file
    io('file.txt') &gt; io('copy.txt');            # Invokes File::Copy
    io('more.txt') &gt;&gt; io('all.txt');            # Add on to a file
    io('dir/') &lt; io('file.txt');                $ Copy a file to a directory
    io('file.txt') &gt; io('dir/');                # Invokes File::Copy
    io('more.txt') &gt;&gt; io('dir/');               # Add on to a file in the dir
    # UTF-8 Support
    $contents = io('file.txt')-&gt;utf8-&gt;all;      # Turn on utf8
    use IO::All -utf8;                          # Turn on utf8 for all io
    $contents = io('file.txt')-&gt;all;            #   by default in this package.
    # General Encoding Support
    $contents = io('file.txt')-&gt;encoding('big5')-&gt;all;
    use IO::All -encoding =&gt; 'big5';            # Turn on big5 for all io
    $contents = io('file.txt')-&gt;all;            #   by default in this package.
    # Print the path name of a file:
    print $io-&gt;name;                            # The direct method
    print &quot;$io&quot;;                                # Object stringifies to name
    print $io;                                  # Quotes not needed here
    print $io-&gt;filename;                        # The file portion only
    $io-&gt;os('win32');                           # change the object to be a
                                                # win32 path
    print $io-&gt;ext;                             # The file extension only
    print $io-&gt;mimetype;                        # The mimetype, requires a
                                                #  working File::MimeType
    # Read all the files/directories in a directory:
    $io = io('my/directory/');                  # Create new directory object
    @contents = $io-&gt;all;                       # Get all contents of dir
    @contents = @$io;                           # Directory as an array
    @contents = values %$io;                    # Directory as a hash
    push @contents, $subdir                     # One at a time
      while $subdir = $io-&gt;next;
    # Print the name and file type for all the contents above:
    print &quot;$_ is a &quot; . $_-&gt;type . &quot;\n&quot;          # Each element of @contents
      for @contents;                            # is an IO::All object!!
    # Print first line of each file:
    print $_-&gt;getline                           # getline gets one line
      for io('dir')-&gt;all_files;                 # Files only
    # Print names of all files/dirs three directories deep:
    print &quot;$_\n&quot; for $io-&gt;all(3);               # Pass in the depth. Default=1
    # Print names of all files/dirs recursively:
    print &quot;$_\n&quot; for $io-&gt;all(0);               # Zero means all the way down
    print &quot;$_\n&quot; for $io-&gt;All;                  # Capitalized shortcut
    print &quot;$_\n&quot; for $io-&gt;deep-&gt;all;            # Another way
    # There are some special file names:
    print io('-');                              # Print STDIN to STDOUT
    io('-') &gt; io('-');                          # Do it again
    io('-') &lt; io('-');                          # Same. Context sensitive.
    &quot;Bad puppy&quot; &gt; io('=');                      # Message to STDERR
    $string_file = io('$');                     # Create string based filehandle
    $temp_file = io('?');                       # Create a temporary file
    # Socket operations:
    $server = io('localhost:5555')-&gt;fork;       # Create a daemon socket
    $connection = $server-&gt;accept;              # Get a connection socket
    $input &lt; $connection;                       # Get some data from it
    &quot;Thank you!&quot; &gt; $connection;                 # Thank the caller
    $connection-&gt;close;                         # Hang up
    io(':6666')-&gt;accept-&gt;slurp &gt; io-&gt;devnull;   # Take a complaint and file it
    # DBM database operations:
    $dbm = io 'my/database';                    # Create a database object
    print $dbm-&gt;{grocery_list};                 # Hash context makes it a DBM
    $dbm-&gt;{todo} = $new_list;                   # Write to database
    $dbm-&gt;dbm('GDBM_file');                     # Demand specific DBM
    io('mydb')-&gt;mldbm-&gt;{env} = \%ENV;           # MLDBM support
    # Tie::File support:
    $io = io 'file.txt';
    $io-&gt;[42] = 'Line Forty Three';             # Change a line
    print $io-&gt;[@$io / 2];                      # Print middle line
    @$io = reverse @$io;                        # Reverse lines in a file
    # Stat functions:
    printf &quot;%s %s %s\n&quot;,                        # Print name, uid and size of
      $_-&gt;name, $_-&gt;uid, $_-&gt;size               # contents of current directory
        for io('.')-&gt;all;
    print &quot;$_\n&quot; for sort                       # Use mtime method to sort all
      {$b-&gt;mtime &lt;=&gt; $a-&gt;mtime}                 # files under current directory
        io('.')-&gt;All_Files;                     # by recent modification time.
    # File::Spec support:
    $contents &lt; io-&gt;catfile(qw(dir file.txt));  # Portable IO operation
    # Miscellaneous:
    @lines = io('file.txt')-&gt;chomp-&gt;slurp;      # Chomp as you slurp
    @chunks =
      io('file.txt')-&gt;separator('xxx')-&gt;slurp;  # Use alternnate record sep
    $binary = io('file.bin')-&gt;binary-&gt;all;      # Read a binary file
    io('a-symlink')-&gt;readlink-&gt;slurp;           # Readlink returns an object
    print io('foo')-&gt;absolute-&gt;pathname;        # Print absolute path of foo
    # IO::All External Plugin Methods
    io(&quot;myfile&quot;) &gt; io-&gt;(&quot;ftp://store.org&quot;);     # Upload a file using ftp
    $html &lt; io-&gt;http(&quot;www.google.com&quot;);         # Grab a web page
    io('mailto:worst@enemy.net')-&gt;print($spam); # Email a &quot;friend&quot;
    # This is just the beginning, read on...
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">IO::All combines all of the best Perl IO modules into a single
    nifty object oriented interface to greatly simplify your everyday Perl IO
    idioms. It exports a single function called
    <span class="Li">&quot;io&quot;</span>, which returns a new IO::All object.
    And that object can do it all!</p>
<p class="Pp">The IO::All object is a proxy for IO::File, IO::Dir, IO::Socket,
    Tie::File, File::Spec, File::Path, File::MimeInfo and File::ReadBackwards;
    as well as all the DBM and MLDBM modules. You can use most of the methods
    found in these classes and in IO::Handle (which they inherit from). IO::All
    adds dozens of other helpful idiomatic methods including file stat and
    manipulation functions.</p>
<p class="Pp">IO::All is pluggable, and modules like IO::All::LWP and
    IO::All::Mailto add even more functionality. Optionally, every IO::All
    object can be tied to itself. This means that you can use most perl IO
    builtins on it: readline, <span class="Li">&quot;&lt;&gt;&quot;</span>,
    getc, print, printf, syswrite, sysread, close.</p>
<p class="Pp">The distinguishing magic of IO::All is that it will automatically
    open (and close) files, directories, sockets and other IO things for you.
    You never need to specify the mode
    (<span class="Li">&quot;&lt;&quot;</span>,
    <span class="Li">&quot;&gt;&gt;&quot;</span>, etc), since it is determined
    by the usage context. That means you can replace this:</p>
<p class="Pp"></p>
<pre>    open STUFF, '&lt;', './mystuff'
      or die &quot;Can't open './mystuff' for input:\n$!&quot;;
    local $/;
    my $stuff = &lt;STUFF&gt;;
    close STUFF;
</pre>
<p class="Pp">with this:</p>
<p class="Pp"></p>
<pre>    my $stuff &lt; io './mystuff';
</pre>
<p class="Pp">And that is a <b>good thing</b>!</p>
</section>
<section class="Sh">
<h1 class="Sh" id="USAGE"><a class="permalink" href="#USAGE">USAGE</a></h1>
<p class="Pp">Normally just say:</p>
<p class="Pp"></p>
<pre>    use IO::All;
</pre>
<p class="Pp">and IO::All will export a single function called
    <span class="Li">&quot;io&quot;</span>, which constructs all IO objects.</p>
<section class="Ss">
<h2 class="Ss" id="Note_on__io_"><a class="permalink" href="#Note_on__io_">Note
  on &quot;io&quot;</a></h2>
<p class="Pp">The <span class="Li">&quot;io&quot;</span> function is a <i>magic
    constructor</i>. It is easy to use and will usually do the right thing, but
    can also blow up easily.</p>
<p class="Pp">It takes a single optional argument and determines what type of
    IO::All subclass object to return. With no arguments it returns an
    <span class="Li">&quot;IO::All&quot;</span> object, which has no I/O
    methods, but has methods to construct subclass objects like
    <span class="Li">&quot;IO::All::File&quot;</span>.</p>
<p class="Pp">In other words, these 2 statements are usually the same:</p>
<p class="Pp"></p>
<pre>    $content = io('file.txt')-&gt;all;
    $content = io-&gt;file('file.txt')-&gt;all;
</pre>
<p class="Pp">Use the first form when you are demonstrating your Perl virtues of
    laziness and impatience, and use the second form when your job is on the
    line.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="METHOD_ROLE_CALL"><a class="permalink" href="#METHOD_ROLE_CALL">METHOD
  ROLE CALL</a></h1>
<p class="Pp">Here is an alphabetical list of all the public methods that you
    can call on an IO::All object.</p>
<p class="Pp">&quot;abs2rel&quot;, &quot;absolute&quot;, &quot;accept&quot;,
    &quot;All&quot;, &quot;all&quot;, &quot;All_Dirs&quot;,
    &quot;all_dirs&quot;, &quot;All_Files&quot;, &quot;all_files&quot;,
    &quot;All_Links&quot;, &quot;all_links&quot;, &quot;append&quot;,
    &quot;appendf&quot;, &quot;appendln&quot;, &quot;assert&quot;,
    &quot;atime&quot;, &quot;autoclose&quot;, &quot;autoflush&quot;,
    &quot;backwards&quot;, &quot;bcc&quot;, &quot;binary&quot;,
    &quot;binmode&quot;, &quot;blksize&quot;, &quot;blocks&quot;,
    &quot;block_size&quot;, &quot;buffer&quot;, &quot;canonpath&quot;,
    &quot;case_tolerant&quot;, &quot;catdir&quot;, &quot;catfile&quot;,
    &quot;catpath&quot;, &quot;cc&quot;, &quot;chdir&quot;, &quot;chomp&quot;,
    &quot;clear&quot;, &quot;close&quot;, &quot;confess&quot;,
    &quot;content&quot;, &quot;copy&quot;, &quot;ctime&quot;,
    &quot;curdir&quot;, &quot;dbm&quot;, &quot;deep&quot;, &quot;device&quot;,
    &quot;device_id&quot;, &quot;devnull&quot;, &quot;dir&quot;,
    &quot;domain&quot;, &quot;empty&quot;, &quot;ext&quot;,
    &quot;encoding&quot;, &quot;eof&quot;, &quot;errors&quot;, &quot;file&quot;,
    &quot;filename&quot;, &quot;fileno&quot;, &quot;filepath&quot;,
    &quot;filter&quot;, &quot;fork&quot;, &quot;from&quot;, &quot;ftp&quot;,
    &quot;get&quot;, &quot;getc&quot;, &quot;getline&quot;,
    &quot;getlines&quot;, &quot;gid&quot;, &quot;glob&quot;, &quot;handle&quot;,
    &quot;head&quot;, &quot;http&quot;, &quot;https&quot;, &quot;inode&quot;,
    &quot;io_handle&quot;, &quot;is_absolute&quot;, &quot;is_dir&quot;,
    &quot;is_dbm&quot;, &quot;is_executable&quot;, &quot;is_file&quot;,
    &quot;is_link&quot;, &quot;is_mldbm&quot;, &quot;is_open&quot;,
    &quot;is_pipe&quot;, &quot;is_readable&quot;, &quot;is_socket&quot;,
    &quot;is_stdio&quot;, &quot;is_string&quot;, &quot;is_temp&quot;,
    &quot;is_writable&quot;, &quot;join&quot;, &quot;length&quot;,
    &quot;link&quot;, &quot;lock&quot;, &quot;mailer&quot;, &quot;mailto&quot;,
    &quot;mimetype&quot;, &quot;mkdir&quot;, &quot;mkpath&quot;,
    &quot;mldbm&quot;, &quot;mode&quot;, &quot;modes&quot;, &quot;mtime&quot;,
    &quot;name&quot;, &quot;new&quot;, &quot;next&quot;, &quot;nlink&quot;,
    &quot;open&quot;, &quot;os&quot; &quot;password&quot;, &quot;path&quot;,
    &quot;pathname&quot;, &quot;perms&quot;, &quot;pipe&quot;, &quot;port&quot;,
    &quot;print&quot;, &quot;printf&quot;, &quot;println&quot;, &quot;put&quot;,
    &quot;rdonly&quot;, &quot;rdwr&quot;, &quot;read&quot;, &quot;readdir&quot;,
    &quot;readlink&quot;, &quot;recv&quot;, &quot;rel2abs&quot;,
    &quot;relative&quot;, &quot;rename&quot;, &quot;request&quot;,
    &quot;response&quot;, &quot;rmdir&quot;, &quot;rmtree&quot;,
    &quot;rootdir&quot;, &quot;scalar&quot;, &quot;seek&quot;, &quot;send&quot;,
    &quot;separator&quot;, &quot;shutdown&quot;, &quot;size&quot;,
    &quot;slurp&quot;, &quot;socket&quot;, &quot;sort&quot;,
    &quot;splitdir&quot;, &quot;splitpath&quot;, &quot;stat&quot;,
    &quot;stdio&quot;, &quot;stderr&quot;, &quot;stdin&quot;,
    &quot;stdout&quot;, &quot;string&quot;, &quot;string_ref&quot;,
    &quot;subject&quot;, &quot;sysread&quot;, &quot;syswrite&quot;,
    &quot;tail&quot;, &quot;tell&quot;, &quot;temp&quot;, &quot;tie&quot;,
    &quot;tmpdir&quot;, &quot;to&quot;, &quot;touch&quot;, &quot;truncate&quot;,
    &quot;type&quot;, &quot;user&quot;, &quot;uid&quot;, &quot;unlink&quot;,
    &quot;unlock&quot;, &quot;updir&quot;, &quot;uri&quot;, &quot;utf8&quot;,
    &quot;utime&quot; and &quot;write&quot;.</p>
<p class="Pp">Each method is documented further below.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="OPERATOR_OVERLOADING"><a class="permalink" href="#OPERATOR_OVERLOADING">OPERATOR
  OVERLOADING</a></h1>
<p class="Pp">IO::All objects overload a small set of Perl operators to great
    effect. The overloads are limited to
    <span class="Li">&quot;&lt;&quot;</span>,
    <span class="Li">&quot;&lt;&lt;&quot;</span>,
    <span class="Li">&quot;&gt;&quot;</span>,
    <span class="Li">&quot;&gt;&gt;&quot;</span>, dereferencing operations, and
    stringification.</p>
<p class="Pp">Even though relatively few operations are overloaded, there is
    actually a huge matrix of possibilities for magic. That's because the
    overloading is sensitive to the types, position and context of the
    arguments, and an IO::All object can be one of many types.</p>
<p class="Pp">The most important overload to become familiar with is
    stringification. IO::All objects stringify to their file or directory name.
    Here we print the contents of the current directory:</p>
<p class="Pp"></p>
<pre>    perl -MIO::All -le 'print for io(&quot;.&quot;)-&gt;all'
</pre>
<p class="Pp">is the same as:</p>
<p class="Pp"></p>
<pre>    perl -MIO::All -le 'print $_-&gt;name for io(&quot;.&quot;)-&gt;all'
</pre>
<p class="Pp">Stringification is important because it allows IO::All operations
    to return objects when they might otherwise return file names. Then the
    recipient can use the result either as an object or a string.</p>
<p class="Pp"><span class="Li">&quot;&gt;&quot;</span> and
    <span class="Li">&quot;&lt;&quot;</span> move data between objects in the
    direction pointed to by the operator.</p>
<p class="Pp"></p>
<pre>    $content1 &lt; io('file1');
    $content1 &gt; io('file2');
    io('file2') &gt; $content3;
    io('file3') &lt; $content3;
    io('file3') &gt; io('file4');
    io('file5') &lt; io('file4');
</pre>
<p class="Pp"><span class="Li">&quot;&gt;&gt;&quot;</span> and
    <span class="Li">&quot;&lt;&lt;&quot;</span> do the same thing except the
    recipient string or file is appended to.</p>
<p class="Pp">An IO::All file used as an array reference becomes tied using
    Tie::File:</p>
<p class="Pp"></p>
<pre>    $file = io &quot;file&quot;;
    # Print last line of file
    print $file-&gt;[-1];
    # Insert new line in middle of file
    $file-&gt;[$#$file / 2] = 'New line';
</pre>
<p class="Pp">An IO::All file used as a hash reference becomes tied to a DBM
    class:</p>
<p class="Pp"></p>
<pre>    io('mydbm')-&gt;{ingy} = 'YAML';
</pre>
<p class="Pp">An IO::All directory used as an array reference, will expose each
    file or subdirectory as an element of the array.</p>
<p class="Pp"></p>
<pre>    print &quot;$_\n&quot; for @{io 'dir'};
</pre>
<p class="Pp">IO::All directories used as hash references have file names as
    keys, and IO::All objects as values:</p>
<p class="Pp"></p>
<pre>    print io('dir')-&gt;{'foo.txt'}-&gt;slurp;
</pre>
<p class="Pp">Files used as scalar references get slurped:</p>
<p class="Pp"></p>
<pre>    print ${io('dir')-&gt;{'foo.txt'}};
</pre>
<p class="Pp">Not all combinations of operations and object types are supported.
    Some just haven't been added yet, and some just don't make sense. If you use
    an invalid combination, an error will be thrown.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COOKBOOK"><a class="permalink" href="#COOKBOOK">COOKBOOK</a></h1>
<p class="Pp">This section describes some various things that you can easily
    cook up with IO::All.</p>
<section class="Ss">
<h2 class="Ss" id="File_Locking"><a class="permalink" href="#File_Locking">File
  Locking</a></h2>
<p class="Pp">IO::All makes it very easy to lock files. Just use the
    <span class="Li">&quot;lock&quot;</span> method. Here's a standalone program
    that demonstrates locking for both write and read:</p>
<p class="Pp"></p>
<pre>    use IO::All;
    my $io1 = io('myfile')-&gt;lock;
    $io1-&gt;println('line 1');
    fork or do {
      my $io2 = io('myfile')-&gt;lock;
      print $io2-&gt;slurp;
      exit;
    };
    sleep 1;
    $io1-&gt;println('line 2');
    $io1-&gt;println('line 3');
    $io1-&gt;unlock;
</pre>
<p class="Pp">There are a lot of subtle things going on here. An exclusive lock
    is issued for <span class="Li">$io1</span> on the first
    <span class="Li">&quot;println&quot;</span>. That's because the file isn't
    actually opened until the first IO operation.</p>
<p class="Pp">When the child process tries to read the file using
    <span class="Li">$io2</span>, there is a shared lock put on it. Since
    <span class="Li">$io1</span> has the exclusive lock, the slurp blocks.</p>
<p class="Pp">The parent process sleeps just to make sure the child process gets
    a chance. The parent needs to call
    <span class="Li">&quot;unlock&quot;</span> or
    <span class="Li">&quot;close&quot;</span> to release the lock. If all goes
    well the child will print 3 lines.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="In-place_Editing"><a class="permalink" href="#In-place_Editing">In-place
  Editing</a></h2>
<p class="Pp">Because an IO::All object can be used as an array reference,
    operations on arrays are supported transparently (using Tie::File) so a file
    can be modified in the same way you would modify an array.</p>
<p class="Pp"></p>
<pre>    &gt; cat &gt; x.txt
    The sexy saxophone,
    got the axe.
    ^d
    &gt; perl -MIO::All -e 'map { s/x/X/g; $_ } @{ io(shift) }' x.txt
    &gt; cat x.txt
    The seXy saXophone,
    got the aXe.
 This one liner uses shift() to grab the file from STDIN and create an io
 object that is dereferenced using @{ } and fed to map() like any perl array
 reference.
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Round_Robin"><a class="permalink" href="#Round_Robin">Round
  Robin</a></h2>
<p class="Pp">This simple example will read lines from a file forever. When the
    last line is read, it will reopen the file and read the first one again.</p>
<p class="Pp"></p>
<pre>    my $io = io 'file1.txt';
    $io-&gt;autoclose(1);
    while (my $line = $io-&gt;getline || $io-&gt;getline) {
      print $line;
    }
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Reading_Backwards"><a class="permalink" href="#Reading_Backwards">Reading
  Backwards</a></h2>
<p class="Pp">If you call the <span class="Li">&quot;backwards&quot;</span>
    method on an IO::All object, the <span class="Li">&quot;getline&quot;</span>
    and <span class="Li">&quot;getlines&quot;</span> will work in reverse. They
    will read the lines in the file from the end to the beginning.</p>
<p class="Pp"></p>
<pre>    my @reversed;
    my $io = io('file1.txt');
    $io-&gt;backwards;
    while (my $line = $io-&gt;getline) {
      push @reversed, $line;
    }
</pre>
<p class="Pp">or more simply:</p>
<p class="Pp"></p>
<pre>    my @reversed = io('file1.txt')-&gt;backwards-&gt;getlines;
</pre>
<p class="Pp">The <span class="Li">&quot;backwards&quot;</span> method returns
    the IO::All object so that you can chain the calls.</p>
<p class="Pp">NOTE: This operation requires that you have the
    File::ReadBackwards module
  <br/>
   installed.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Client/Server_Sockets"><a class="permalink" href="#Client/Server_Sockets">Client/Server
  Sockets</a></h2>
<p class="Pp">IO::All makes it really easy to write a forking socket server and
    a client to talk to it.</p>
<p class="Pp">In this example, a server will return 3 lines of text, to every
    client that calls it. Here is the server code:</p>
<p class="Pp"></p>
<pre>    use IO::All;
    my $socket = io(':12345')-&gt;fork-&gt;accept;
    $socket-&gt;print($_) while &lt;DATA&gt;;
    $socket-&gt;close;
    __DATA__
    On your mark,
    Get set,
    Go!
</pre>
<p class="Pp">Here is the client code:</p>
<p class="Pp"></p>
<pre>    use IO::All;
    my $io = io('localhost:12345');
    print while $_ = $io-&gt;getline;
</pre>
<p class="Pp">You can run the server once, and then run the client repeatedly
    (in another terminal window). It should print the 3 data lines each
  time.</p>
<p class="Pp">Note that it is important to close the socket if the server is
    forking, or else the socket won't go out of scope and close.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="A_Tiny_Web_Server"><a class="permalink" href="#A_Tiny_Web_Server">A
  Tiny Web Server</a></h2>
<p class="Pp">Here is how you could write a simplistic web server that works
    with static and dynamic pages:</p>
<p class="Pp"></p>
<pre>    perl -MIO::All -e 'io(&quot;:8080&quot;)-&gt;fork-&gt;accept-&gt;(sub { $_[0] &lt; io(-x $1 ? &quot;./$1 |&quot; : $1) if /^GET \/(.*) / })'
</pre>
<p class="Pp">There is are a lot of subtle things going on here. First we accept
    a socket and fork the server. Then we overload the new socket as a code ref.
    This code ref takes one argument, another code ref, which is used as a
    callback.</p>
<p class="Pp">The callback is called once for every line read on the socket. The
    line is put into <span class="Li">$_</span> and the socket itself is passed
    in to the callback.</p>
<p class="Pp">Our callback is scanning the line in <span class="Li">$_</span>
    for an HTTP GET request. If one is found it parses the file name into
    <span class="Li">$1</span>. Then we use <span class="Li">$1</span> to create
    an new IO::All file object... with a twist. If the file is executable
    (<span class="Li">&quot;-x&quot;</span>), then we create a piped command as
    our IO::All object. This somewhat approximates CGI support.</p>
<p class="Pp">Whatever the resulting object is, we direct the contents back at
    our socket which is in <span class="Li">$_[0]</span>. Pretty simple, eh?</p>
</section>
<section class="Ss">
<h2 class="Ss">DBM Files</h2>
<p class="Pp">IO::All file objects used as a hash reference, treat the file as a
    DBM tied to a hash. Here I write my DB record to STDERR:</p>
<p class="Pp"></p>
<pre>    io(&quot;names.db&quot;)-&gt;{ingy} &gt; io('=');
</pre>
<p class="Pp">Since their are several DBM formats available in Perl, IO::All
    picks the first one of these that is installed on your system:</p>
<p class="Pp"></p>
<pre>    DB_File GDBM_File NDBM_File ODBM_File SDBM_File
</pre>
<p class="Pp">You can override which DBM you want for each IO::All object:</p>
<p class="Pp"></p>
<pre>    my @keys = keys %{io('mydbm')-&gt;dbm('SDBM_File')};
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="File_Subclassing"><a class="permalink" href="#File_Subclassing">File
  Subclassing</a></h2>
<p class="Pp">Subclassing is easy with IO::All. Just create a new module and use
    IO::All as the base class, like this:</p>
<p class="Pp"></p>
<pre>    package NewModule;
    use IO::All -base;
</pre>
<p class="Pp">You need to do it this way so that IO::All will export the
    <span class="Li">&quot;io&quot;</span> function. Here is a simple recipe for
    subclassing:</p>
<p class="Pp">IO::Dumper inherits everything from IO::All and adds an extra
    method called <span class="Li">&quot;dump&quot;</span>, which will dump a
    data structure to the file we specify in the
    <span class="Li">&quot;io&quot;</span> function. Since it needs Data::Dumper
    to do the dumping, we override the <span class="Li">&quot;open&quot;</span>
    method to <span class="Li">&quot;require Data::Dumper&quot;</span> and then
    pass control to the real <span class="Li">&quot;open&quot;</span>.</p>
<p class="Pp">First the code using the module:</p>
<p class="Pp"></p>
<pre>    use IO::Dumper;
    io('./mydump')-&gt;dump($hash);
</pre>
<p class="Pp">And next the IO::Dumper module itself:</p>
<p class="Pp"></p>
<pre>    package IO::Dumper;
    use IO::All -base;
    use Data::Dumper;
    sub dump {
      my $self = shift;
      Dumper(@_) &gt; $self;
    }
    1;
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Inline_Subclassing"><a class="permalink" href="#Inline_Subclassing">Inline
  Subclassing</a></h2>
<p class="Pp">This recipe does the same thing as the previous one, but without
    needing to write a separate module. The only real difference is the first
    line. Since you don't &quot;use&quot; IO::Dumper, you need to still call its
    <span class="Li">&quot;import&quot;</span> method manually.</p>
<p class="Pp"></p>
<pre>    IO::Dumper-&gt;import;
    io('./mydump')-&gt;dump($hash);
    package IO::Dumper;
    use IO::All -base;
    use Data::Dumper;
    sub dump {
      my $self = shift;
      Dumper(@_) &gt; $self;
    }
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="THE_IO::ALL_METHODS"><a class="permalink" href="#THE_IO::ALL_METHODS">THE
  IO::ALL METHODS</a></h1>
<p class="Pp">This section gives a full description of all of the methods that
    you can call on IO::All objects. The methods have been grouped into
    subsections based on object construction, option settings, configuration,
    action methods and support for specific modules.</p>
<section class="Ss">
<h2 class="Ss" id="Object_Construction_and_Initialization_Methods"><a class="permalink" href="#Object_Construction_and_Initialization_Methods">Object
  Construction and Initialization Methods</a></h2>
<dl class="Bl-tag">
  <dt id="new"><a class="permalink" href="#new">new</a></dt>
  <dd>There are three ways to create a new IO::All object. The first is with the
      special function <span class="Li">&quot;io&quot;</span> which really just
      calls <span class="Li">&quot;IO::All-&gt;new&quot;</span>. The second is
      by calling <span class="Li">&quot;new&quot;</span> as a class method. The
      third is calling <span class="Li">&quot;new&quot;</span> as an object
      instance method. In this final case, the new objects attributes are copied
      from the instance object.
    <p class="Pp"></p>
    <pre>    io(file-descriptor);
    IO::All-&gt;new(file-descriptor);
    $io-&gt;new(file-descriptor);
    </pre>
    <p class="Pp">All three forms take a single argument, a file descriptor. A
        file descriptor can be any of the following:</p>
    <p class="Pp"></p>
    <pre>    - A file name
    - A file handle
    - A directory name
    - A directory handle
    - A typeglob reference
    - A piped shell command. eg '| ls -al'
    - A socket domain/port.  eg 'perl.com:5678'
    - '-' means STDIN or STDOUT (depending on usage)
    - '=' means STDERR
    - '$' means an in memory filehandle object
    - '?' means a temporary file
    - A URI including: http, https, ftp and mailto
    - An IO::All object
    </pre>
    <p class="Pp">If you provide an IO::All object, you will simply get that
        <i>same object</i> returned from the constructor.</p>
    <p class="Pp">If no file descriptor is provided, an object will still be
        created, but it must be defined by one of the following methods before
        it can be used for I/O:</p>
  </dd>
  <dt id="file"><a class="permalink" href="#file">file</a></dt>
  <dd>
    <pre>    io-&gt;file(&quot;path/to/my/file.txt&quot;);
    </pre>
    <p class="Pp">Using the <span class="Li">&quot;file&quot;</span> method sets
        the type of the object to <i>file</i> and sets the pathname of the file
        if provided.</p>
    <p class="Pp">It might be important to use this method if you had a file
        whose name was <span class="Li">'-</span> <span class="Li">'</span>, or
        if the name might otherwise be confused with a directory or a socket. In
        this case, either of these statements would work the same:</p>
    <p class="Pp"></p>
    <pre>    my $file = io('-')-&gt;file;
    my $file = io-&gt;file('-');
    </pre>
  </dd>
  <dt id="dir"><a class="permalink" href="#dir">dir</a></dt>
  <dd>
    <pre>    io-&gt;dir($dir_name);
    </pre>
    <p class="Pp">Make the object be of type <i>directory</i>.</p>
  </dd>
  <dt id="socket"><a class="permalink" href="#socket">socket</a></dt>
  <dd>
    <pre>    io-&gt;socket(&quot;${domain}:${port}&quot;);
    </pre>
    <p class="Pp">Make the object be of type <i>socket</i>.</p>
  </dd>
  <dt id="link"><a class="permalink" href="#link">link</a></dt>
  <dd>
    <pre>    io-&gt;link($link_name);
    </pre>
    <p class="Pp">Make the object be of type <i>link</i>.</p>
  </dd>
  <dt id="pipe"><a class="permalink" href="#pipe">pipe</a></dt>
  <dd>
    <pre>    io-&gt;pipe($pipe_command);
    </pre>
    <p class="Pp">Make the object be of type <i>pipe</i>. The following three
        statements are equivalent:</p>
    <p class="Pp"></p>
    <pre>    my $io = io('ls -l |');
    my $io = io('ls -l')-&gt;pipe;
    my $io = io-&gt;pipe('ls -l');
    </pre>
  </dd>
  <dt id="dbm"><a class="permalink" href="#dbm">dbm</a></dt>
  <dd>This method takes the names of zero or more DBM modules. The first one
      that is available is used to process the dbm file.
    <p class="Pp"></p>
    <pre>    io('mydbm')-&gt;dbm('NDBM_File', 'SDBM_File')-&gt;{author} = 'ingy';
    </pre>
    <p class="Pp">If no module names are provided, the first available of the
        following is used:</p>
    <p class="Pp"></p>
    <pre>    DB_File GDBM_File NDBM_File ODBM_File SDBM_File
    </pre>
  </dd>
  <dt id="mldbm"><a class="permalink" href="#mldbm">mldbm</a></dt>
  <dd>Similar to the <span class="Li">&quot;dbm&quot;</span> method, except
      create a Multi Level DBM object using the MLDBM module.
    <p class="Pp">This method takes the names of zero or more DBM modules and an
        optional serialization module. The first DBM module that is available is
        used to process the MLDBM file. The serialization module can be
        Data::Dumper, Storable or FreezeThaw.</p>
    <p class="Pp"></p>
    <pre>    io('mymldbm')-&gt;mldbm('GDBM_File', 'Storable')-&gt;{author} =
      {nickname =&gt; 'ingy'};
    </pre>
  </dd>
  <dt id="string"><a class="permalink" href="#string">string</a></dt>
  <dd>Make the object be an in memory filehandle. These are equivalent:
    <p class="Pp"></p>
    <pre>    my $io = io('$');
    my $io = io-&gt;string;
    </pre>
  </dd>
  <dt id="temp"><a class="permalink" href="#temp">temp</a></dt>
  <dd>Make the object represent a temporary file. It will automatically be open
      for both read and write.</dd>
  <dt id="stdio"><a class="permalink" href="#stdio">stdio</a></dt>
  <dd>Make the object represent either STDIN or STDOUT depending on how it is
      used subsequently. These are equivalent:
    <p class="Pp"></p>
    <pre>    my $io = io('-');
    my $io = io-&gt;stdin;
    </pre>
  </dd>
  <dt id="stdin"><a class="permalink" href="#stdin">stdin</a></dt>
  <dd>Make the object represent STDIN.</dd>
  <dt id="stdout"><a class="permalink" href="#stdout">stdout</a></dt>
  <dd>Make the object represent STDOUT.</dd>
  <dt id="stderr"><a class="permalink" href="#stderr">stderr</a></dt>
  <dd>Make the object represent STDERR.</dd>
  <dt id="handle"><a class="permalink" href="#handle">handle</a></dt>
  <dd>
    <pre>    io-&gt;handle($io_handle);
    </pre>
    <p class="Pp">Forces the object to be created from an pre-existing IO
        handle. You can chain calls together to indicate the type of handle:</p>
    <p class="Pp"></p>
    <pre>    my $file_object = io-&gt;file-&gt;handle($file_handle);
    my $dir_object = io-&gt;dir-&gt;handle($dir_handle);
    </pre>
  </dd>
  <dt id="http"><a class="permalink" href="#http">http</a></dt>
  <dd>Make the object represent an HTTP URI. Requires IO-All-LWP.</dd>
  <dt id="https"><a class="permalink" href="#https">https</a></dt>
  <dd>Make the object represent an HTTPS URI. Requires IO-All-LWP.</dd>
  <dt id="ftp"><a class="permalink" href="#ftp">ftp</a></dt>
  <dd>Make the object represent an FTP URI. Requires IO-All-LWP.</dd>
  <dt id="mailto"><a class="permalink" href="#mailto">mailto</a></dt>
  <dd>Make the object represent a <span class="Li">&quot;mailto:&quot;</span>
      URI. Requires IO-All-Mailto.</dd>
</dl>
<p class="Pp">If you need to use the same options to create a lot of objects,
    and don't want to duplicate the code, just create a dummy object with the
    options you want, and use that object to spawn other objects.</p>
<p class="Pp"></p>
<pre>    my $lt = io-&gt;lock-&gt;tie;
    ...
    my $io1 = $lt-&gt;new('file1');
    my $io2 = $lt-&gt;new('file2');
</pre>
<p class="Pp">Since the new method copies attributes from the calling object,
    both <span class="Li">$io1</span> and <span class="Li">$io2</span> will be
    locked and tied.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Option_Setting_Methods"><a class="permalink" href="#Option_Setting_Methods">Option
  Setting Methods</a></h2>
<p class="Pp">The following methods don't do any actual I<i>O, but they specify
    options about</i> <i>how the I</i>O should be done.</p>
<p class="Pp">Each option can take a single argument of 0 or 1. If no argument
    is given, the value 1 is assumed. Passing 0 turns the option off.</p>
<p class="Pp">All of these options return the object reference that was used to
    invoke them. This is so that the option methods can be chained together. For
    example:</p>
<p class="Pp"></p>
<pre>    my $io = io('path/file')-&gt;tie-&gt;assert-&gt;chomp-&gt;lock;
</pre>
<dl class="Bl-tag">
  <dt id="absolute"><a class="permalink" href="#absolute">absolute</a></dt>
  <dd>Indicates that the <span class="Li">&quot;pathname&quot;</span> for the
      object should be made absolute.
    <p class="Pp"></p>
    <pre>    # Print the full path of the current working directory
    # (like pwd).
    use IO::All;
    print io-&gt;curdir-&gt;absolute;
    </pre>
  </dd>
  <dt id="assert"><a class="permalink" href="#assert">assert</a></dt>
  <dd>This method ensures that the path for a file or directory actually exists
      before the file is open. If the path does not exist, it is created.
    <p class="Pp">For example, here is a program called
        &quot;create-cat-to&quot; that outputs to a file that it creates.</p>
    <p class="Pp"></p>
    <pre>    #!/usr/bin/perl
    # create-cat-to.pl
    # cat to a file that can be created.
    use strict;
    use warnings;
    use IO::All;
    my $filename = shift(@ARGV);
    # Create a file called $filename, including all leading components.
    io('-') &gt; io-&gt;file($filename)-&gt;assert;
    </pre>
    <p class="Pp">Here's an example use of it:</p>
    <p class="Pp"></p>
    <pre>    $ ls -l
    total 0
    $ echo &quot;Hello World&quot; | create-cat-to one/two/three/four.txt
    $ ls -l
    total 4
    drwxr-xr-x 3 shlomif shlomif 4096 2010-10-14 18:03 one/
    $ cat one/two/three/four.txt
    Hello World
    $
    </pre>
  </dd>
  <dt id="autoclose"><a class="permalink" href="#autoclose">autoclose</a></dt>
  <dd>By default, IO::All will close an object opened for input when EOF is
      reached. By closing the handle early, one can immediately do other
      operations on the object without first having to close it.
    <p class="Pp">This option is on by default, so if you don't want this
        behaviour, say so like this:</p>
    <p class="Pp"></p>
    <pre>    $io-&gt;autoclose(0);
    </pre>
    <p class="Pp">The object will then be closed when
        <span class="Li">$io</span> goes out of scope, or you manually call
        <span class="Li">&quot;$io-&gt;close&quot;</span>.</p>
  </dd>
  <dt id="autoflush"><a class="permalink" href="#autoflush">autoflush</a></dt>
  <dd>Proxy for IO::Handle::autoflush</dd>
  <dt id="backwards"><a class="permalink" href="#backwards">backwards</a></dt>
  <dd>Sets the object to 'backwards' mode. All subsequent
      <span class="Li">&quot;getline&quot;</span> operations will read backwards
      from the end of the file.
    <p class="Pp">Requires the File::ReadBackwards CPAN module.</p>
  </dd>
  <dt id="binary"><a class="permalink" href="#binary">binary</a></dt>
  <dd>Adds <span class="Li">&quot;:raw&quot;</span> to the list of PerlIO layers
      applied after <span class="Li">&quot;open&quot;</span>, and applies it
      immediately on an open handle.</dd>
  <dt id="chdir"><a class="permalink" href="#chdir">chdir</a></dt>
  <dd><b>chdir()</b> to the pathname of a directory object. When object goes out
      of scope, chdir back to starting directory.</dd>
  <dt id="chomp"><a class="permalink" href="#chomp">chomp</a></dt>
  <dd>Indicates that all operations that read lines should chomp the lines. If
      the <span class="Li">&quot;separator&quot;</span> method has been called,
      chomp will remove that value from the end of each record.
    <p class="Pp">Note that <span class="Li">&quot;chomp&quot;</span> may cause
        the following idiom to halt prematurely (e.g., if
        <span class="Li">&quot;separator&quot;</span> is
        <span class="Li">&quot;\n&quot;</span> (the default) and
        <span class="Li">&quot;chomp&quot;</span> is in effect, then this
        command will stop reading at the first blank line):</p>
    <p class="Pp"></p>
    <pre>    while ( my $line = $io-&gt;getline ) {...}
    </pre>
    <p class="Pp">Try the following instead:</p>
    <p class="Pp"></p>
    <pre>    while ( defined(my $line = $io-&gt;getline) ) {...}
    </pre>
  </dd>
  <dt id="confess"><a class="permalink" href="#confess">confess</a></dt>
  <dd>Errors should be reported with the very detailed Carp::confess
    function.</dd>
  <dt id="deep"><a class="permalink" href="#deep">deep</a></dt>
  <dd>Indicates that calls to the <span class="Li">&quot;all&quot;</span> family
      of methods should search directories as deep as possible.</dd>
  <dt id="fork"><a class="permalink" href="#fork">fork</a></dt>
  <dd>Indicates that the process should automatically be forked inside the
      <span class="Li">&quot;accept&quot;</span> socket method.</dd>
  <dt id="lock"><a class="permalink" href="#lock">lock</a></dt>
  <dd>Indicate that operations on an object should be locked using flock.</dd>
  <dt id="rdonly"><a class="permalink" href="#rdonly">rdonly</a></dt>
  <dd>This option indicates that certain operations like DBM and Tie::File
      access should be done in read-only mode.</dd>
  <dt id="rdwr"><a class="permalink" href="#rdwr">rdwr</a></dt>
  <dd>This option indicates that DBM and MLDBM files should be opened in
      read/write mode.</dd>
  <dt id="relative"><a class="permalink" href="#relative">relative</a></dt>
  <dd>Indicates that the <span class="Li">&quot;pathname&quot;</span> for the
      object should be made relative. If passed an argument, path will be made
      relative to passed argument.</dd>
  <dt id="sort"><a class="permalink" href="#sort">sort</a></dt>
  <dd>Indicates whether objects returned from one of the
      <span class="Li">&quot;all&quot;</span> methods will be in sorted order by
      name. True by default.</dd>
  <dt id="tie"><a class="permalink" href="#tie">tie</a></dt>
  <dd>Indicate that the object should be tied to itself, thus allowing it to be
      used as a filehandle in any of Perl's builtin IO operations.
    <p class="Pp"></p>
    <pre>    my $io = io('foo')-&gt;tie;
    @lines = &lt;$io&gt;;
    </pre>
  </dd>
  <dt id="utf8"><a class="permalink" href="#utf8">utf8</a></dt>
  <dd>Adds <span class="Li">&quot;:encoding(UTF-8)&quot;</span> to the list of
      PerlIO layers applied after <span class="Li">&quot;open&quot;</span>, and
      applies it immediately on an open handle.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Configuration_Methods"><a class="permalink" href="#Configuration_Methods">Configuration
  Methods</a></h2>
<p class="Pp">The following methods don't do any actual I/O, but they set
    specific values to configure the IO::All object.</p>
<p class="Pp">If these methods are passed no argument, they will return their
    current value. If arguments are passed they will be used to set the current
    value, and the object reference will be returned for potential method
    chaining.</p>
<dl class="Bl-tag">
  <dt id="bcc"><a class="permalink" href="#bcc">bcc</a></dt>
  <dd>Set the Bcc field for a mailto object.</dd>
  <dt id="binmode"><a class="permalink" href="#binmode">binmode</a></dt>
  <dd>Adds the specified layer to the list of PerlIO layers applied after
      <span class="Li">&quot;open&quot;</span>, and applies it immediately on an
      open handle. Does a bare <span class="Li">&quot;binmode&quot;</span> when
      called without argument.</dd>
  <dt id="block_size"><a class="permalink" href="#block_size">block_size</a></dt>
  <dd>The default length to be used for <span class="Li">&quot;read&quot;</span>
      and <span class="Li">&quot;sysread&quot;</span> calls. Defaults to
    1024.</dd>
  <dt id="buffer"><a class="permalink" href="#buffer">buffer</a></dt>
  <dd>Returns a reference to the internal buffer, which is a scalar. You can use
      this method to set the buffer to a scalar of your choice. (You can just
      pass in the scalar, rather than a reference to it.)
    <p class="Pp">This is the buffer that
        <span class="Li">&quot;read&quot;</span> and
        <span class="Li">&quot;write&quot;</span> will use by default.</p>
    <p class="Pp">You can easily have IO::All objects use the same buffer:</p>
    <p class="Pp"></p>
    <pre>    my $input = io('abc');
    my $output = io('xyz');
    my $buffer;
    $output-&gt;buffer($input-&gt;buffer($buffer));
    $output-&gt;write while $input-&gt;read;
    </pre>
  </dd>
  <dt id="cc"><a class="permalink" href="#cc">cc</a></dt>
  <dd>Set the Cc field for a mailto object.</dd>
  <dt id="content"><a class="permalink" href="#content">content</a></dt>
  <dd>Get or set the content for an LWP operation manually.</dd>
  <dt id="domain"><a class="permalink" href="#domain">domain</a></dt>
  <dd>Set the domain name or ip address that a socket should use.</dd>
  <dt id="encoding"><a class="permalink" href="#encoding">encoding</a></dt>
  <dd>Adds the specified encoding to the list of PerlIO layers applied after
      <span class="Li">&quot;open&quot;</span>, and applies it immediately on an
      open handle. Requires an argument.</dd>
  <dt id="errors"><a class="permalink" href="#errors">errors</a></dt>
  <dd>Use this to set a subroutine reference that gets called when an internal
      error is thrown.</dd>
  <dt id="filter"><a class="permalink" href="#filter">filter</a></dt>
  <dd>Use this to set a subroutine reference that will be used to grep which
      objects get returned on a call to one of the
      <span class="Li">&quot;all&quot;</span> methods. For example:
    <p class="Pp"></p>
    <pre>    my @odd = io-&gt;curdir-&gt;filter(sub {$_-&gt;size % 2})-&gt;All_Files;
    </pre>
    <p class="Pp"><span class="Li">@odd</span> will contain all the files under
        the current directory whose size is an odd number of bytes.</p>
  </dd>
  <dt id="from"><a class="permalink" href="#from">from</a></dt>
  <dd>Indicate the sender for a mailto object.</dd>
  <dt id="mailer"><a class="permalink" href="#mailer">mailer</a></dt>
  <dd>Set the mailer program for a mailto transaction. Defaults to
    'sendmail'.</dd>
  <dt id="mode"><a class="permalink" href="#mode">mode</a></dt>
  <dd>Set the mode for which the file should be opened. Examples:
    <p class="Pp"></p>
    <pre>    $io-&gt;mode('&gt;&gt;')-&gt;open;
    $io-&gt;mode(O_RDONLY);
    my $log_appender = io-&gt;file('/var/log/my-application.log')
                         -&gt;mode('&gt;&gt;')-&gt;open();
    $log_appender-&gt;print(&quot;Stardate 5987.6: Mission accomplished.&quot;);
    </pre>
  </dd>
  <dt id="name"><a class="permalink" href="#name">name</a></dt>
  <dd>Set or get the name of the file or directory represented by the IO::All
      object.</dd>
  <dt id="password"><a class="permalink" href="#password">password</a></dt>
  <dd>Set the password for an LWP transaction.</dd>
  <dt id="perms"><a class="permalink" href="#perms">perms</a></dt>
  <dd>Sets the permissions to be used if the file/directory needs to be
    created.</dd>
  <dt id="port"><a class="permalink" href="#port">port</a></dt>
  <dd>Set the port number that a socket should use.</dd>
  <dt id="request"><a class="permalink" href="#request">request</a></dt>
  <dd>Manually specify the request object for an LWP transaction.</dd>
  <dt id="response"><a class="permalink" href="#response">response</a></dt>
  <dd>Returns the resulting response object from an LWP transaction.</dd>
  <dt id="separator"><a class="permalink" href="#separator">separator</a></dt>
  <dd>Sets the record (line) separator to whatever value you pass it. Default is
      <span class="Li">&quot;\n&quot;</span>. Affects the chomp setting
    too.</dd>
  <dt id="string_ref"><a class="permalink" href="#string_ref">string_ref</a></dt>
  <dd>Returns a reference to the internal string that is acting like a
    file.</dd>
  <dt id="subject"><a class="permalink" href="#subject">subject</a></dt>
  <dd>Set the subject for a mailto transaction.</dd>
  <dt id="to"><a class="permalink" href="#to">to</a></dt>
  <dd>Set the recipient address for a mailto request.</dd>
  <dt id="uri"><a class="permalink" href="#uri">uri</a></dt>
  <dd>Direct access to the URI used in LWP transactions.</dd>
  <dt id="user"><a class="permalink" href="#user">user</a></dt>
  <dd>Set the user name for an LWP transaction.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss">IO Action Methods</h2>
<p class="Pp">These are the methods that actually perform I/O operations on an
    IO::All object. The stat methods and the File::Spec methods are documented
    in separate sections below.</p>
<dl class="Bl-tag">
  <dt id="accept"><a class="permalink" href="#accept">accept</a></dt>
  <dd>For sockets. Opens a server socket (LISTEN =&gt; 1, REUSE =&gt; 1).
      Returns an IO::All socket object that you are listening on.
    <p class="Pp">If the <span class="Li">&quot;fork&quot;</span> method was
        called on the object, the process will automatically be forked for every
        connection.</p>
  </dd>
  <dt id="all"><a class="permalink" href="#all">all</a></dt>
  <dd>Read all contents into a single string.
    <p class="Pp"></p>
    <pre>    compare(io('file1')-&gt;all, io('file2')-&gt;all);
    </pre>
  </dd>
  <dt>all (For directories)</dt>
  <dd>Returns a list of IO::All objects for all files and subdirectories in a
      directory.
    <p class="Pp">'.' and '..' are excluded.</p>
    <p class="Pp">Takes an optional argument telling how many directories deep
        to search. The default is 1. Zero (0) means search as deep as
      possible.</p>
    <p class="Pp">The filter method can be used to limit the results.</p>
    <p class="Pp">The items returned are sorted by name unless
        <span class="Li">&quot;-&gt;sort(0)&quot;</span> is used.</p>
  </dd>
  <dt id="All"><a class="permalink" href="#All">All</a></dt>
  <dd>Same as <span class="Li">all(0)</span>.</dd>
  <dt id="all_dirs"><a class="permalink" href="#all_dirs">all_dirs</a></dt>
  <dd>Same as <span class="Li">&quot;all&quot;</span>, but only return
      directories.</dd>
  <dt id="All_Dirs"><a class="permalink" href="#All_Dirs">All_Dirs</a></dt>
  <dd>Same as <span class="Li">all_dirs(0)</span>.</dd>
  <dt id="all_files"><a class="permalink" href="#all_files">all_files</a></dt>
  <dd>Same as <span class="Li">&quot;all&quot;</span>, but only return
    files.</dd>
  <dt id="All_Files"><a class="permalink" href="#All_Files">All_Files</a></dt>
  <dd>Same as <span class="Li">all_files(0)</span>.</dd>
  <dt id="all_links"><a class="permalink" href="#all_links">all_links</a></dt>
  <dd>Same as <span class="Li">&quot;all&quot;</span>, but only return
    links.</dd>
  <dt id="All_Links"><a class="permalink" href="#All_Links">All_Links</a></dt>
  <dd>Same as <span class="Li">all_links(0)</span>.</dd>
  <dt id="append"><a class="permalink" href="#append">append</a></dt>
  <dd>Same as print, but sets the file mode to '&gt;&gt;'.</dd>
  <dt id="appendf"><a class="permalink" href="#appendf">appendf</a></dt>
  <dd>Same as printf, but sets the file mode to '&gt;&gt;'.</dd>
  <dt id="appendln"><a class="permalink" href="#appendln">appendln</a></dt>
  <dd>Same as println, but sets the file mode to '&gt;&gt;'.</dd>
  <dt id="clear"><a class="permalink" href="#clear">clear</a></dt>
  <dd>Clear the internal buffer. This method is called by
      <span class="Li">&quot;write&quot;</span> after it writes the buffer.
      Returns the object reference for chaining.</dd>
  <dt id="close"><a class="permalink" href="#close">close</a></dt>
  <dd>Close will basically unopen the object, which has different meanings for
      different objects. For files and directories it will close and release the
      handle. For sockets it calls shutdown. For tied things it unties them, and
      it unlocks locked things.</dd>
  <dt id="copy"><a class="permalink" href="#copy">copy</a></dt>
  <dd>Copies the object to the path passed. Works on both files and directories,
      but directories require
      <span class="Li">&quot;File::Copy::Recursive&quot;</span> to be
    installed.</dd>
  <dt id="empty"><a class="permalink" href="#empty">empty</a></dt>
  <dd>Returns true if a file exists but has no size, or if a directory exists
      but has no contents.</dd>
  <dt id="eof"><a class="permalink" href="#eof">eof</a></dt>
  <dd>Proxy for IO::Handle::eof</dd>
  <dt id="ext"><a class="permalink" href="#ext">ext</a></dt>
  <dd>Returns the extension of the file. Can also be spelled as
      <span class="Li">&quot;extension&quot;</span></dd>
  <dt id="exists"><a class="permalink" href="#exists">exists</a></dt>
  <dd>Returns whether or not the file or directory exists.</dd>
  <dt id="filename"><a class="permalink" href="#filename">filename</a></dt>
  <dd>Return the name portion of the file path in the object. For example:
    <p class="Pp"></p>
    <pre>    io('my/path/file.txt')-&gt;filename;
    </pre>
    <p class="Pp">would return <span class="Li">&quot;file.txt&quot;</span>.</p>
  </dd>
  <dt id="fileno"><a class="permalink" href="#fileno">fileno</a></dt>
  <dd>Proxy for IO::Handle::fileno</dd>
  <dt id="filepath"><a class="permalink" href="#filepath">filepath</a></dt>
  <dd>Return the path portion of the file path in the object. For example:
    <p class="Pp"></p>
    <pre>    io('my/path/file.txt')-&gt;filepath;
    </pre>
    <p class="Pp">would return <span class="Li">&quot;my/path&quot;</span>.</p>
  </dd>
  <dt id="get"><a class="permalink" href="#get">get</a></dt>
  <dd>Perform an LWP GET request manually.</dd>
  <dt id="getc"><a class="permalink" href="#getc">getc</a></dt>
  <dd>Proxy for IO::Handle::getc</dd>
  <dt id="getline"><a class="permalink" href="#getline">getline</a></dt>
  <dd>Calls IO::File::getline. You can pass in an optional record
    separator.</dd>
  <dt id="getlines"><a class="permalink" href="#getlines">getlines</a></dt>
  <dd>Calls IO::File::getlines. You can pass in an optional record
    separator.</dd>
  <dt id="glob"><a class="permalink" href="#glob">glob</a></dt>
  <dd>Creates IO::All objects for the files matching the glob in the
      IO::All::Dir. For example:
    <p class="Pp"></p>
    <pre>    io-&gt;dir($ENV{HOME})-&gt;glob('*.txt')
    </pre>
  </dd>
  <dt id="head"><a class="permalink" href="#head">head</a></dt>
  <dd>Return the first 10 lines of a file. Takes an optional argument which is
      the number of lines to return. Works as expected in list and scalar
      context. Is subject to the current line separator.</dd>
  <dt id="io_handle"><a class="permalink" href="#io_handle">io_handle</a></dt>
  <dd>Direct access to the actual IO::Handle object being used on an opened
      IO::All object.</dd>
  <dt id="is_dir"><a class="permalink" href="#is_dir">is_dir</a></dt>
  <dd>Returns boolean telling whether or not the IO::All object represents a
      directory.</dd>
  <dt id="is_executable"><a class="permalink" href="#is_executable">is_executable</a></dt>
  <dd>Returns true if file or directory is executable.</dd>
  <dt id="is_dbm"><a class="permalink" href="#is_dbm">is_dbm</a></dt>
  <dd>Returns boolean telling whether or not the IO::All object represents a dbm
      file.</dd>
  <dt id="is_file"><a class="permalink" href="#is_file">is_file</a></dt>
  <dd>Returns boolean telling whether or not the IO::All object represents a
      file.</dd>
  <dt id="is_link"><a class="permalink" href="#is_link">is_link</a></dt>
  <dd>Returns boolean telling whether or not the IO::All object represents a
      symlink.</dd>
  <dt id="is_mldbm"><a class="permalink" href="#is_mldbm">is_mldbm</a></dt>
  <dd>Returns boolean telling whether or not the IO::All object represents a
      mldbm file.</dd>
  <dt id="is_open"><a class="permalink" href="#is_open">is_open</a></dt>
  <dd>Indicates whether the IO::All is currently open for input/output.</dd>
  <dt id="is_pipe"><a class="permalink" href="#is_pipe">is_pipe</a></dt>
  <dd>Returns boolean telling whether or not the IO::All object represents a
      pipe operation.</dd>
  <dt id="is_readable"><a class="permalink" href="#is_readable">is_readable</a></dt>
  <dd>Returns true if file or directory is readable.</dd>
  <dt id="is_socket"><a class="permalink" href="#is_socket">is_socket</a></dt>
  <dd>Returns boolean telling whether or not the IO::All object represents a
      socket.</dd>
  <dt id="is_stdio"><a class="permalink" href="#is_stdio">is_stdio</a></dt>
  <dd>Returns boolean telling whether or not the IO::All object represents a
      STDIO file handle.</dd>
  <dt id="is_string"><a class="permalink" href="#is_string">is_string</a></dt>
  <dd>Returns boolean telling whether or not the IO::All object represents an in
      memory filehandle.</dd>
  <dt id="is_temp"><a class="permalink" href="#is_temp">is_temp</a></dt>
  <dd>Returns boolean telling whether or not the IO::All object represents a
      temporary file.</dd>
  <dt id="is_writable"><a class="permalink" href="#is_writable">is_writable</a></dt>
  <dd>Returns true if file or directory is writable. Can also be spelled as
      <span class="Li">&quot;is_writeable&quot;</span>.</dd>
  <dt id="length"><a class="permalink" href="#length">length</a></dt>
  <dd>Return the length of the internal buffer.</dd>
  <dt id="mimetype"><a class="permalink" href="#mimetype">mimetype</a></dt>
  <dd>Return the mimetype of the file.
    <p class="Pp">Requires a working installation of the File::MimeInfo CPAN
        module.</p>
  </dd>
  <dt id="mkdir"><a class="permalink" href="#mkdir">mkdir</a></dt>
  <dd>Create the directory represented by the object.</dd>
  <dt id="mkpath"><a class="permalink" href="#mkpath">mkpath</a></dt>
  <dd>Create the directory represented by the object, when the path contains
      more than one directory that doesn't exist. Proxy for
    File::Path::mkpath.</dd>
  <dt id="next"><a class="permalink" href="#next">next</a></dt>
  <dd>For a directory, this will return a new IO::All object for each file or
      subdirectory in the directory. Return undef on EOD.</dd>
  <dt id="open"><a class="permalink" href="#open">open</a></dt>
  <dd>Open the IO::All object. Takes two optional arguments
      <span class="Li">&quot;mode&quot;</span> and
      <span class="Li">&quot;perms&quot;</span>, which can also be set ahead of
      time using the <span class="Li">&quot;mode&quot;</span> and
      <span class="Li">&quot;perms&quot;</span> methods.
    <p class="Pp">NOTE: Normally you won't need to call open (or mode/perms),
        since this happens
      <br/>
       automatically for most operations.</p>
  </dd>
  <dt id="os"><a class="permalink" href="#os">os</a></dt>
  <dd>Change the object's os representation. Valid options are:
      <span class="Li">&quot;win32&quot;</span>,
      <span class="Li">&quot;unix&quot;</span>,
      <span class="Li">&quot;vms&quot;</span>,
      <span class="Li">&quot;mac&quot;</span>,
      <span class="Li">&quot;os2&quot;</span>.</dd>
  <dt id="pathname"><a class="permalink" href="#pathname">pathname</a></dt>
  <dd>Return the absolute or relative pathname for a file or directory,
      depending on whether object is in
      <span class="Li">&quot;absolute&quot;</span> or
      <span class="Li">&quot;relative&quot;</span> mode.</dd>
  <dt id="print"><a class="permalink" href="#print">print</a></dt>
  <dd>Proxy for IO::Handle::print</dd>
  <dt id="printf"><a class="permalink" href="#printf">printf</a></dt>
  <dd>Proxy for IO::Handle::printf</dd>
  <dt id="println"><a class="permalink" href="#println">println</a></dt>
  <dd>Same as print, but adds newline to each argument unless it already ends
      with one.</dd>
  <dt id="put"><a class="permalink" href="#put">put</a></dt>
  <dd>Perform an LWP PUT request manually.</dd>
  <dt id="read"><a class="permalink" href="#read">read</a></dt>
  <dd>This method varies depending on its context. Read carefully (no pun
      intended).
    <p class="Pp">For a file, this will proxy IO::File::read. This means you
        must pass it a buffer, a length to read, and optionally a buffer offset
        for where to put the data that is read. The function returns the length
        actually read (which is zero at EOF).</p>
    <p class="Pp">If you don't pass any arguments for a file, IO::All will use
        its own internal buffer, a default length, and the offset will always
        point at the end of the buffer. The buffer can be accessed with the
        <span class="Li">&quot;buffer&quot;</span> method. The length can be set
        with the <span class="Li">&quot;block_size&quot;</span> method. The
        default length is 1024 bytes. The
        <span class="Li">&quot;clear&quot;</span> method can be called to clear
        the buffer.</p>
    <p class="Pp">For a directory, this will proxy IO::Dir::read.</p>
  </dd>
  <dt id="readdir"><a class="permalink" href="#readdir">readdir</a></dt>
  <dd>Similar to the Perl <span class="Li">&quot;readdir&quot;</span> builtin.
      In scalar context, return the next directory entry (ie file or directory
      name), or undef on end of directory. In list context, return all directory
      entries.
    <p class="Pp">Note that <span class="Li">&quot;readdir&quot;</span> does not
        return the special <span class="Li">&quot;.&quot;</span> and
        <span class="Li">&quot;..&quot;</span> entries.</p>
  </dd>
  <dt id="readline"><a class="permalink" href="#readline">readline</a></dt>
  <dd>Same as <span class="Li">&quot;getline&quot;</span>.</dd>
  <dt id="readlink"><a class="permalink" href="#readlink">readlink</a></dt>
  <dd>Calls Perl's readlink function on the link represented by the object.
      Instead of returning the file path, it returns a new IO::All object using
      the file path.</dd>
  <dt id="recv"><a class="permalink" href="#recv">recv</a></dt>
  <dd>Proxy for IO::Socket::recv</dd>
  <dt id="rename"><a class="permalink" href="#rename">rename</a></dt>
  <dd>
    <pre>    my $new = $io-&gt;rename('new-name');
    </pre>
    <p class="Pp">Calls Perl's rename function and returns an IO::All object for
        the renamed file. Returns false if the rename failed.</p>
  </dd>
  <dt id="rewind"><a class="permalink" href="#rewind">rewind</a></dt>
  <dd>Proxy for IO::Dir::rewind</dd>
  <dt id="rmdir"><a class="permalink" href="#rmdir">rmdir</a></dt>
  <dd>Delete the directory represented by the IO::All object.</dd>
  <dt id="rmtree"><a class="permalink" href="#rmtree">rmtree</a></dt>
  <dd>Delete the directory represented by the IO::All object and all the files
      and directories beneath it. Proxy for File::Path::rmtree.</dd>
  <dt id="scalar"><a class="permalink" href="#scalar">scalar</a></dt>
  <dd>Deprecated. Same as <span class="Li">&quot;all()&quot;</span>.</dd>
  <dt id="seek"><a class="permalink" href="#seek">seek</a></dt>
  <dd>Proxy for IO::Handle::seek. If you use seek on an unopened file, it will
      be opened for both read and write.</dd>
  <dt id="send"><a class="permalink" href="#send">send</a></dt>
  <dd>Proxy for IO::Socket::send</dd>
  <dt id="shutdown"><a class="permalink" href="#shutdown">shutdown</a></dt>
  <dd>Proxy for IO::Socket::shutdown</dd>
  <dt id="slurp"><a class="permalink" href="#slurp">slurp</a></dt>
  <dd>Read all file content in one operation. Returns the file content as a
      string. In list context returns every line in the file.</dd>
  <dt id="stat"><a class="permalink" href="#stat">stat</a></dt>
  <dd>Proxy for IO::Handle::stat</dd>
  <dt id="sysread"><a class="permalink" href="#sysread">sysread</a></dt>
  <dd>Proxy for IO::Handle::sysread</dd>
  <dt id="syswrite"><a class="permalink" href="#syswrite">syswrite</a></dt>
  <dd>Proxy for IO::Handle::syswrite</dd>
  <dt id="tail"><a class="permalink" href="#tail">tail</a></dt>
  <dd>Return the last 10 lines of a file. Takes an optional argument which is
      the number of lines to return. Works as expected in list and scalar
      context. Is subject to the current line separator.</dd>
  <dt id="tell"><a class="permalink" href="#tell">tell</a></dt>
  <dd>Proxy for IO::Handle::tell</dd>
  <dt id="throw"><a class="permalink" href="#throw">throw</a></dt>
  <dd>This is an internal method that gets called whenever there is an error. It
      could be useful to override it in a subclass, to provide more control in
      error handling.</dd>
  <dt id="touch"><a class="permalink" href="#touch">touch</a></dt>
  <dd>Update the atime and mtime values for a file or directory. Creates an
      empty file if the file does not exist.</dd>
  <dt id="truncate"><a class="permalink" href="#truncate">truncate</a></dt>
  <dd>Proxy for IO::Handle::truncate</dd>
  <dt id="type"><a class="permalink" href="#type">type</a></dt>
  <dd>Returns a string indicated the type of io object. Possible values are:
    <p class="Pp"></p>
    <pre>    file
    dir
    link
    socket
    string
    pipe
    </pre>
    <p class="Pp">Returns undef if type is not determinable.</p>
  </dd>
  <dt id="unlink"><a class="permalink" href="#unlink">unlink</a></dt>
  <dd>Unlink (delete) the file represented by the IO::All object.
    <p class="Pp">NOTE: You can unlink a file after it is open, and continue
        using it until it
      <br/>
       is closed.</p>
  </dd>
  <dt id="unlock"><a class="permalink" href="#unlock">unlock</a></dt>
  <dd>Release a lock from an object that used the
      <span class="Li">&quot;lock&quot;</span> method.</dd>
  <dt id="utime"><a class="permalink" href="#utime">utime</a></dt>
  <dd>Proxy for the utime Perl function.</dd>
  <dt id="write"><a class="permalink" href="#write">write</a></dt>
  <dd>Opposite of <span class="Li">&quot;read&quot;</span> for file operations
      only.
    <p class="Pp">NOTE: When used with the automatic internal buffer,
        <span class="Li">&quot;write&quot;</span> will clear the
      <br/>
       buffer after writing it.</p>
  </dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Stat_Methods"><a class="permalink" href="#Stat_Methods">Stat
  Methods</a></h2>
<p class="Pp">This methods get individual values from a stat call on the file,
    directory or handle represented by the IO::All object.</p>
<dl class="Bl-tag">
  <dt id="atime"><a class="permalink" href="#atime">atime</a></dt>
  <dd>Last access time in seconds since the epoch</dd>
  <dt id="blksize"><a class="permalink" href="#blksize">blksize</a></dt>
  <dd>Preferred block size for file system I/O</dd>
  <dt id="blocks"><a class="permalink" href="#blocks">blocks</a></dt>
  <dd>Actual number of blocks allocated</dd>
  <dt id="ctime"><a class="permalink" href="#ctime">ctime</a></dt>
  <dd>Inode change time in seconds since the epoch</dd>
  <dt id="device"><a class="permalink" href="#device">device</a></dt>
  <dd>Device number of filesystem</dd>
  <dt id="device_id"><a class="permalink" href="#device_id">device_id</a></dt>
  <dd>Device identifier for special files only</dd>
  <dt id="gid"><a class="permalink" href="#gid">gid</a></dt>
  <dd>Numeric group id of file's owner</dd>
  <dt id="inode"><a class="permalink" href="#inode">inode</a></dt>
  <dd>Inode number</dd>
  <dt id="modes"><a class="permalink" href="#modes">modes</a></dt>
  <dd>File mode - type and permissions</dd>
  <dt id="mtime"><a class="permalink" href="#mtime">mtime</a></dt>
  <dd>Last modify time in seconds since the epoch</dd>
  <dt id="nlink"><a class="permalink" href="#nlink">nlink</a></dt>
  <dd>Number of hard links to the file</dd>
  <dt id="size"><a class="permalink" href="#size">size</a></dt>
  <dd>Total size of file in bytes</dd>
  <dt id="uid"><a class="permalink" href="#uid">uid</a></dt>
  <dd>Numeric user id of file's owner</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="File::Spec_Methods"><a class="permalink" href="#File::Spec_Methods">File::Spec
  Methods</a></h2>
<p class="Pp">These methods are all adaptations from File::Spec. Each method
    actually does call the matching File::Spec method, but the arguments and
    return values differ slightly. Instead of being file and directory
    <b>names</b>, they are IO::All <b>objects</b>. Since IO::All objects
    stringify to their names, you can generally use the methods just like
    File::Spec.</p>
<dl class="Bl-tag">
  <dt id="abs2rel"><a class="permalink" href="#abs2rel">abs2rel</a></dt>
  <dd>Returns the relative path for the absolute path in the IO::All object. Can
      take an optional argument indicating the base path.</dd>
  <dt id="canonpath"><a class="permalink" href="#canonpath">canonpath</a></dt>
  <dd>Returns the canonical path for the IO::All object. The canonical path is
      the fully resolved path if the file exists, so any symlinks will be
      resolved.</dd>
  <dt id="case_tolerant"><a class="permalink" href="#case_tolerant">case_tolerant</a></dt>
  <dd>Returns 0 or 1 indicating whether the file system is case tolerant. Since
      an active IO::All object is not needed for this function, you can code it
      like:
    <p class="Pp"></p>
    <pre>    IO::All-&gt;case_tolerant;
    </pre>
    <p class="Pp">or more simply:</p>
    <p class="Pp"></p>
    <pre>    io-&gt;case_tolerant;
    </pre>
  </dd>
  <dt id="catdir"><a class="permalink" href="#catdir">catdir</a></dt>
  <dd>Concatenate the directory components together, and return a new IO::All
      object representing the resulting directory.</dd>
  <dt id="catfile"><a class="permalink" href="#catfile">catfile</a></dt>
  <dd>Concatenate the directory and file components together, and return a new
      IO::All object representing the resulting file.
    <p class="Pp"></p>
    <pre>    my $contents = io-&gt;catfile(qw(dir subdir file))-&gt;slurp;
    </pre>
    <p class="Pp">This is a very portable way to read
        <span class="Li">&quot;dir/subdir/file&quot;</span>.</p>
  </dd>
  <dt id="catpath"><a class="permalink" href="#catpath">catpath</a></dt>
  <dd>Concatenate the volume, directory and file components together, and return
      a new IO::All object representing the resulting file.</dd>
  <dt id="curdir"><a class="permalink" href="#curdir">curdir</a></dt>
  <dd>Returns an IO::All object representing the current directory.</dd>
  <dt id="devnull"><a class="permalink" href="#devnull">devnull</a></dt>
  <dd>Returns an IO::All object representing the
      <span class="Li">&quot;/dev/null&quot;</span> file.</dd>
  <dt id="is_absolute"><a class="permalink" href="#is_absolute">is_absolute</a></dt>
  <dd>Returns 0 or 1 indicating whether the
      <span class="Li">&quot;name&quot;</span> field of the IO::All object is an
      absolute path.</dd>
  <dt id="join"><a class="permalink" href="#join">join</a></dt>
  <dd>Same as <span class="Li">&quot;catfile&quot;</span>.</dd>
  <dt id="path"><a class="permalink" href="#path">path</a></dt>
  <dd>Returns a list of IO::All directory objects for each directory in your
      path.</dd>
  <dt id="rel2abs"><a class="permalink" href="#rel2abs">rel2abs</a></dt>
  <dd>Returns the absolute path for the relative path in the IO::All object. Can
      take an optional argument indicating the base path.</dd>
  <dt id="rootdir"><a class="permalink" href="#rootdir">rootdir</a></dt>
  <dd>Returns an IO::All object representing the root directory on your file
      system.</dd>
  <dt id="splitdir"><a class="permalink" href="#splitdir">splitdir</a></dt>
  <dd>Returns a list of the directory components of a path in an IO::All
    object.</dd>
  <dt id="splitpath"><a class="permalink" href="#splitpath">splitpath</a></dt>
  <dd>Returns a volume directory and file component of a path in an IO::All
      object.</dd>
  <dt id="tmpdir"><a class="permalink" href="#tmpdir">tmpdir</a></dt>
  <dd>Returns an IO::All object representing a temporary directory on your file
      system.</dd>
  <dt id="updir"><a class="permalink" href="#updir">updir</a></dt>
  <dd>Returns an IO::All object representing the current parent directory.</dd>
</dl>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="OPERATIONAL_NOTES"><a class="permalink" href="#OPERATIONAL_NOTES">OPERATIONAL
  NOTES</a></h1>
<dl class="Bl-tag">
  <dt id="Reblessing"><a class="permalink" href="#Reblessing">Reblessing</a></dt>
  <dd>Each IO::All object gets reblessed into an IO::All::* object as soon as
      IO::All can determine what type of object it should be. Sometimes it gets
      reblessed more than once:
    <p class="Pp"></p>
    <pre>    my $io = io('mydbm.db');
    $io-&gt;dbm('DB_File');
    $io-&gt;{foo} = 'bar';
    </pre>
    <p class="Pp">In the first statement, <span class="Li">$io</span> has a
        reference value of 'IO::All::File', if
        <span class="Li">&quot;mydbm.db&quot;</span> exists. In the second
        statement, the object is reblessed into class 'IO::All::DBM'.</p>
  </dd>
  <dt id="Auto-Open"><a class="permalink" href="#Auto-Open">Auto-Open</a></dt>
  <dd>An IO::All object will automatically be opened as soon as there is enough
      contextual information to know what type of object it is, and what mode it
      should be opened for. This is usually when the first read or write
      operation is invoked but might be sooner.</dd>
  <dt id="Auto-Mode"><a class="permalink" href="#Auto-Mode">Auto-Mode</a></dt>
  <dd>The mode for an object to be opened with is determined heuristically
      unless specified explicitly.</dd>
  <dt id="Auto-Close"><a class="permalink" href="#Auto-Close">Auto-Close</a></dt>
  <dd>For input, IO::All objects will automatically be closed after EOF (or
      EOD). For output, the object closes when it goes out of scope.
    <p class="Pp">To keep input objects from closing at EOF, do this:</p>
    <p class="Pp"></p>
    <pre>    $io-&gt;autoclose(0);
    </pre>
  </dd>
  <dt id="Explicit"><a class="permalink" href="#Explicit">Explicit open and
    close</a></dt>
  <dd>You can always call <span class="Li">&quot;open&quot;</span> and
      <span class="Li">&quot;close&quot;</span> explicitly, if you need that
      level of control. To test if an object is currently open, use the
      <span class="Li">&quot;is_open&quot;</span> method.</dd>
  <dt id="Overload"><a class="permalink" href="#Overload">Overload</a></dt>
  <dd>Overloaded operations return the target object, if one exists.
    <p class="Pp">This would set <span class="Li">$xxx</span> to the IO::All
        object:</p>
    <p class="Pp"></p>
    <pre>    my $xxx = $contents &gt; io('file.txt');
    </pre>
    <p class="Pp">While this would set <span class="Li">$xxx</span> to the
        content string:</p>
    <p class="Pp"></p>
    <pre>    my $xxx = $contents &lt; io('file.txt');
    </pre>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="STABILITY"><a class="permalink" href="#STABILITY">STABILITY</a></h1>
<p class="Pp">The goal of the IO::All project is to continually refine the
    module to be as simple and consistent to use as possible. Therefore, in the
    early stages of the project, I will not hesitate to break backwards
    compatibility with other versions of IO::All if I can find an easier and
    clearer way to do a particular thing.</p>
<p class="Pp">IO is tricky stuff. There is definitely more work to be done. On
    the other hand, this module relies heavily on very stable existing IO
    modules; so it may work fairly well.</p>
<p class="Pp">I am sure you will find many unexpected &quot;features&quot;.
    Please send all problems, ideas and suggestions to ingy@cpan.org.</p>
<section class="Ss">
<h2 class="Ss" id="Known_Bugs_and_Deficiencies"><a class="permalink" href="#Known_Bugs_and_Deficiencies">Known
  Bugs and Deficiencies</a></h2>
<p class="Pp">Not all possible combinations of objects and methods have been
    tested. There are many many combinations. All of the examples have been
    tested. If you find a bug with a particular combination of calls, let me
    know.</p>
<p class="Pp">If you call a method that does not make sense for a particular
    object, the result probably won't make sense. Little attempt is made to
    check for improper usage.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="CREDITS"><a class="permalink" href="#CREDITS">CREDITS</a></h1>
<p class="Pp">A lot of people have sent in suggestions, that have become a part
    of IO::All. Thank you.</p>
<p class="Pp">Special thanks to Ian Langworth for continued testing and
    patching.</p>
<p class="Pp">Thank you Simon Cozens for tipping me off to the overloading
    possibilities.</p>
<p class="Pp">Finally, thanks to Autrijus Tang, for always having one more good
    idea.</p>
<p class="Pp">(It seems IO::All of it to a lot of people!)</p>
</section>
<section class="Sh">
<h1 class="Sh" id="REPOSITORY_AND_COMMUNITY"><a class="permalink" href="#REPOSITORY_AND_COMMUNITY">REPOSITORY
  AND COMMUNITY</a></h1>
<p class="Pp">The IO::All module can be found on CPAN and on GitHub:
    &lt;http://github.com/ingydotnet/io-all-pm&gt;.</p>
<p class="Pp">Please join the IO::All discussion on #io-all on irc.perl.org.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<ul class="Bl-bullet">
  <li>File::Spec</li>
  <li>File::Path</li>
  <li>File::ReadBackwards</li>
  <li>File::MimeInfo</li>
  <li>IO::Handle</li>
  <li>IO::File</li>
  <li>IO::Dir</li>
  <li>IO::Socket</li>
  <li>Tie::File</li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">Ingy d&#x00F6;t Net &lt;ingy@cpan.org&gt;</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT_AND_LICENSE"><a class="permalink" href="#COPYRIGHT_AND_LICENSE">COPYRIGHT
  AND LICENSE</a></h1>
<p class="Pp">Copyright 2004-2017. Ingy d&#x00F6;t Net.</p>
<p class="Pp">This program is free software; you can redistribute it and/or
    modify it under the same terms as Perl itself.</p>
<p class="Pp">See &lt;http://www.perl.com/perl/misc/Artistic.html&gt;</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2017-07-18</td>
    <td class="foot-os">perl v5.30.2</td>
  </tr>
</table>
</body>
</html>
