<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>Parse::CPAN::Meta(3pm)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Parse::CPAN::Meta(3pm)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">Parse::CPAN::Meta(3pm)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
Parse::CPAN::Meta - Parse META.yml and META.json CPAN metadata files
</section>
<section class="Sh">
<h1 class="Sh" id="VERSION"><a class="permalink" href="#VERSION">VERSION</a></h1>
version 2.150010
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<span class="Li"></span>
<pre>
    #############################################
    # In your file

    ---
    name: My-Distribution
    version: 1.23
    resources:
      homepage: &quot;http://example.com/dist/My-Distribution&quot;


    #############################################
    # In your program

    use Parse::CPAN::Meta;

    my $distmeta = Parse::CPAN::Meta-&gt;load_file('META.yml');

    # Reading properties
    my $name     = $distmeta-&gt;{name};
    my $version  = $distmeta-&gt;{version};
    my $homepage = $distmeta-&gt;{resources}{homepage};
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<b>Parse::CPAN::Meta</b> is a parser for <i>META.json</i> and <i>META.yml</i>
  files, using JSON::PP and/or CPAN::Meta::YAML.
<p class="Pp"><b>Parse::CPAN::Meta</b> provides three methods:
    <span class="Li">&quot;load_file&quot;</span>,
    <span class="Li">&quot;load_json_string&quot;</span>, and
    <span class="Li">&quot;load_yaml_string&quot;</span>. These will read and
    deserialize CPAN metafiles, and are described below in detail.</p>
<p class="Pp"><b>Parse::CPAN::Meta</b> provides a legacy API of only two
    functions, based on the YAML functions of the same name. Wherever possible,
    identical calling semantics are used. These may only be used with YAML
    sources.</p>
<p class="Pp">All error reporting is done with exceptions (die'ing).</p>
<p class="Pp">Note that META files are expected to be in UTF-8 encoding, only.
    When converted string data, it must first be decoded from UTF-8.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="METHODS"><a class="permalink" href="#METHODS">METHODS</a></h1>
<section class="Ss">
<h2 class="Ss" id="load_file"><a class="permalink" href="#load_file">load_file</a></h2>
<span class="Li"></span>
<pre>
  my $metadata_structure = Parse::CPAN::Meta-&gt;load_file('META.json');

  my $metadata_structure = Parse::CPAN::Meta-&gt;load_file('META.yml');
</pre>
<p class="Pp">This method will read the named file and deserialize it to a data
    structure, determining whether it should be JSON or YAML based on the
    filename. The file will be read using the &quot;:utf8&quot; IO layer.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="load_yaml_string"><a class="permalink" href="#load_yaml_string">load_yaml_string</a></h2>
<span class="Li"></span>
<pre>
  my $metadata_structure = Parse::CPAN::Meta-&gt;load_yaml_string($yaml_string);
</pre>
<p class="Pp">This method deserializes the given string of YAML and returns the
    first document in it. (CPAN metadata files should always have only one
    document.) If the source was UTF-8 encoded, the string must be decoded
    before calling <span class="Li">&quot;load_yaml_string&quot;</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="load_json_string"><a class="permalink" href="#load_json_string">load_json_string</a></h2>
<span class="Li"></span>
<pre>
  my $metadata_structure = Parse::CPAN::Meta-&gt;load_json_string($json_string);
</pre>
<p class="Pp">This method deserializes the given string of JSON and the result.
    If the source was UTF-8 encoded, the string must be decoded before calling
    <span class="Li">&quot;load_json_string&quot;</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="load_string"><a class="permalink" href="#load_string">load_string</a></h2>
<span class="Li"></span>
<pre>
  my $metadata_structure = Parse::CPAN::Meta-&gt;load_string($some_string);
</pre>
<p class="Pp">If you don't know whether a string contains YAML or JSON data,
    this method will use some heuristics and guess. If it can't tell, it assumes
    YAML.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="yaml_backend"><a class="permalink" href="#yaml_backend">yaml_backend</a></h2>
<span class="Li"></span>
<pre>
  my $backend = Parse::CPAN::Meta-&gt;yaml_backend;
</pre>
<p class="Pp">Returns the module name of the YAML serializer. See
    &quot;ENVIRONMENT&quot; for details.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="json_backend"><a class="permalink" href="#json_backend">json_backend</a></h2>
<span class="Li"></span>
<pre>
  my $backend = Parse::CPAN::Meta-&gt;json_backend;
</pre>
<p class="Pp">Returns the module name of the JSON serializer. If
    <span class="Li">&quot;CPAN_META_JSON_BACKEND&quot;</span> is set, this will
    be whatever that's set to. If not, this will either be JSON::PP or JSON. If
    <span class="Li">&quot;PERL_JSON_BACKEND&quot;</span> is set, this will
    return JSON as further delegation is handled by the JSON module. See
    &quot;ENVIRONMENT&quot; for details.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="json_decoder"><a class="permalink" href="#json_decoder">json_decoder</a></h2>
<span class="Li"></span>
<pre>
  my $decoder = Parse::CPAN::Meta-&gt;json_decoder;
</pre>
<p class="Pp">Returns the module name of the JSON decoder. Unlike
    &quot;json_backend&quot;, this is not necessarily a full JSON-style module,
    but only something that will provide a
    <span class="Li">&quot;decode_json&quot;</span> subroutine. If
    <span class="Li">&quot;CPAN_META_JSON_DECODER&quot;</span> is set, this will
    be whatever that's set to. If not, this will be whatever has been selected
    as &quot;json_backend&quot;. See &quot;ENVIRONMENT&quot; for more notes.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="FUNCTIONS"><a class="permalink" href="#FUNCTIONS">FUNCTIONS</a></h1>
For maintenance clarity, no functions are exported by default. These functions
  are available for backwards compatibility only and are best avoided in favor
  of <span class="Li">&quot;load_file&quot;</span>.
<section class="Ss">
<h2 class="Ss" id="Load"><a class="permalink" href="#Load">Load</a></h2>
<span class="Li"></span>
<pre>
  my @yaml = Parse::CPAN::Meta::Load( $string );
</pre>
<p class="Pp">Parses a string containing a valid YAML stream into a list of Perl
    data structures.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="LoadFile"><a class="permalink" href="#LoadFile">LoadFile</a></h2>
<span class="Li"></span>
<pre>
  my @yaml = Parse::CPAN::Meta::LoadFile( 'META.yml' );
</pre>
<p class="Pp">Reads the YAML stream from a file instead of a string.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="ENVIRONMENT"><a class="permalink" href="#ENVIRONMENT">ENVIRONMENT</a></h1>
<section class="Ss">
<h2 class="Ss" id="_s-1CPAN_META_JSON_DECODER_s0"><a class="permalink" href="#_s-1CPAN_META_JSON_DECODER_s0">CPAN_META_JSON_DECODER</a></h2>
By default, JSON::PP will be used for deserializing JSON data. If the
  <span class="Li">&quot;CPAN_META_JSON_DECODER&quot;</span> environment
  variable exists, this is expected to be the name of a loadable module that
  provides a <span class="Li">&quot;decode_json&quot;</span> subroutine, which
  will then be used for deserialization. Relying only on the existence of said
  subroutine allows for maximum compatibility, since this API is provided by all
  of JSON::PP, JSON::XS, Cpanel::JSON::XS, JSON::MaybeXS, JSON::Tiny, and
  Mojo::JSON.
</section>
<section class="Ss">
<h2 class="Ss" id="_s-1CPAN_META_JSON_BACKEND_s0"><a class="permalink" href="#_s-1CPAN_META_JSON_BACKEND_s0">CPAN_META_JSON_BACKEND</a></h2>
By default, JSON::PP will be used for deserializing JSON data. If the
  <span class="Li">&quot;CPAN_META_JSON_BACKEND&quot;</span> environment
  variable exists, this is expected to be the name of a loadable module that
  provides the JSON API, since downstream code expects to be able to call
  <span class="Li">&quot;new&quot;</span> on this class. As such, while
  JSON::PP, JSON::XS, Cpanel::JSON::XS and JSON::MaybeXS will work for this, to
  use Mojo::JSON or JSON::Tiny for decoding requires setting
  &quot;CPAN_META_JSON_DECODER&quot;.
</section>
<section class="Ss">
<h2 class="Ss" id="_s-1PERL_JSON_BACKEND_s0"><a class="permalink" href="#_s-1PERL_JSON_BACKEND_s0">PERL_JSON_BACKEND</a></h2>
If the <span class="Li">&quot;CPAN_META_JSON_BACKEND&quot;</span> environment
  variable does not exist, and if
  <span class="Li">&quot;PERL_JSON_BACKEND&quot;</span> environment variable
  exists, is true and is not &quot;JSON::PP&quot;, then the JSON module (version
  2.5 or greater) will be loaded and used to interpret
  <span class="Li">&quot;PERL_JSON_BACKEND&quot;</span>. If JSON is not
  installed or is too old, an exception will be thrown. Note that at the time of
  writing, the only useful values are 1, which will tell JSON to guess, or
  JSON::XS - if you want to use a newer JSON module, see
  &quot;CPAN_META_JSON_BACKEND&quot;.
</section>
<section class="Ss">
<h2 class="Ss" id="_s-1PERL_YAML_BACKEND_s0"><a class="permalink" href="#_s-1PERL_YAML_BACKEND_s0">PERL_YAML_BACKEND</a></h2>
By default, CPAN::Meta::YAML will be used for deserializing YAML data. If the
  <span class="Li">&quot;PERL_YAML_BACKEND&quot;</span> environment variable is
  defined, then it is interpreted as a module to use for deserialization. The
  given module must be installed, must load correctly and must implement the
  <span class="Li">&quot;Load()&quot;</span> function or an exception will be
  thrown.
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHORS"><a class="permalink" href="#AUTHORS">AUTHORS</a></h1>
<ul class="Bl-bullet">
  <li>David Golden &lt;dagolden@cpan.org&gt;</li>
  <li>Ricardo Signes &lt;rjbs@cpan.org&gt;</li>
  <li>Adam Kennedy &lt;adamk@cpan.org&gt;</li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT_AND_LICENSE"><a class="permalink" href="#COPYRIGHT_AND_LICENSE">COPYRIGHT
  AND LICENSE</a></h1>
This software is copyright (c) 2010 by David Golden, Ricardo Signes, Adam
  Kennedy and Contributors.
<p class="Pp">This is free software; you can redistribute it and/or modify it
    under the same terms as the Perl 5 programming language system itself.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2019-10-24</td>
    <td class="foot-os">perl v5.30.2</td>
  </tr>
</table>
</body>
</html>
