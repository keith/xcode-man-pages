<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    .Nd, .Bf, .Op { display: inline; }
    .Pa, .Ad { font-style: italic; }
    .Ms { font-weight: bold; }
    .Bl-diag > dt { font-weight: bold; }
    code.Nm, .Fl, .Cm, .Ic, code.In, .Fd, .Fn, .Cd { font-weight: bold;
      font-family: inherit; }
  </style>
  <title>install::TempContent::Objects::mod_perl-2.0.9::docs::api::ModPerl::MethodLookup(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">install::TempContent::Objects::mod_perl-2.0.9::docs::api::ModPerl::MethodLookup(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">install::TempContent::Objects::mod_perl-2.0.9::docs::api::ModPerl::MethodLookup(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">ModPerl::MethodLookup -- Lookup mod_perl modules, objects and
    methods</p>
</section>
<section class="Sh">
<h1 class="Sh" id="Synopsis"><a class="permalink" href="#Synopsis">Synopsis</a></h1>
<pre>  use ModPerl::MethodLookup;
  
  # return all module names containing XS method 'print'
  my ($hint, @modules) =
      ModPerl::MethodLookup::lookup_method('print');
  
  # return only module names containing method 'print' which
  # expects the first argument to be of type 'Apache2::Filter'
  # (here $filter is an Apache2::Filter object)
  my ($hint, @modules) =
      ModPerl::MethodLookup::lookup_method('print', $filter);
  # or
  my ($hint, @modules) =
      ModPerl::MethodLookup::lookup_method('print', 'Apache2::Filter');
  
  # what XS methods defined by module 'Apache2::Filter'
  my ($hint, @methods) =
      ModPerl::MethodLookup::lookup_module('Apache2::Filter');
  
  # what XS methods can be invoked on the object $r (or a ref)
  my ($hint, @methods) =
      ModPerl::MethodLookup::lookup_object($r);
  # or
  my ($hint, @methods) =
      ModPerl::MethodLookup::lookup_object('Apache2::RequestRec');
  
  # preload all mp2 modules in startup.pl
  ModPerl::MethodLookup::preload_all_modules();
  
  # command line shortcuts
  % perl -MModPerl::MethodLookup -e print_module \
    Apache2::RequestRec Apache2::Filter
  % perl -MModPerl::MethodLookup -e print_object Apache2
  % perl -MModPerl::MethodLookup -e print_method \
    get_server_built request
  % perl -MModPerl::MethodLookup -e print_method read
  % perl -MModPerl::MethodLookup -e print_method read APR::Bucket
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="Description"><a class="permalink" href="#Description">Description</a></h1>
<p class="Pp">mod_perl 2.0 provides many methods, which reside in various
    modules. One has to load each of the modules before using the desired
    methods. <span class="Li">&quot;ModPerl::MethodLookup&quot;</span> provides
    the Perl API for finding module names which contain methods in question and
    other helper functions, to find out out what methods defined by some module,
    what methods can be called on a given object, etc.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="API"><a class="permalink" href="#API">API</a></h1>
<section class="Ss">
<h2 class="Ss" id="_lookup_method()_"><a class="permalink" href="#_lookup_method()_">&quot;lookup_method()&quot;</a></h2>
<p class="Pp">Find modules (packages) containing a certain method</p>
<p class="Pp"></p>
<pre>  ($hint, @modules) = lookup_method($method_name);
  ($hint, @modules) = lookup_method($method_name, $object);
  ($hint, @modules) = lookup_method($method_name, $class));
</pre>
<dl class="Bl-tag">
  <dt id="arg1:"><a class="permalink" href="#arg1:">arg1: $method_name ( string
    )</a></dt>
  <dd>the method name to look up</dd>
  <dt id="opt"><a class="permalink" href="#opt">opt arg2: $object or
    $class</a></dt>
  <dd>a blessed object or the name of the class it's blessed into. If there is
      more than one match, this extra information is used to return only modules
      containing methods operating on the objects of the same kind.
    <p class="Pp">If a sub-classed object is passed it'll be handled correctly,
        by checking its super-class(es). This usage is useful when the
        <span class="Li">&quot;AUTOLOAD&quot;</span> is used to find a not yet
        loaded module which include the called method.</p>
  </dd>
  <dt id="ret1:"><a class="permalink" href="#ret1:">ret1: $hint</a></dt>
  <dd>a string containing a human readable lookup result, suggesting which
      modules should be loaded, ready for copy-n-paste or explaining the failure
      if the lookup didn't succeed.</dd>
  <dt id="ret2:"><a class="permalink" href="#ret2:">ret2: @modules</a></dt>
  <dd>an array of modules which have matched the query, i.e. the names of the
      modules which contain the requested method.</dd>
  <dt id="since:"><a class="permalink" href="#since:">since: 2.0.00</a></dt>
  <dd></dd>
</dl>
<p class="Pp">Examples:</p>
<p class="Pp">Return all module names containing XS method <i>print</i>:</p>
<p class="Pp"></p>
<pre>  my ($hint, @modules) =
      ModPerl::MethodLookup::lookup_method('print');
</pre>
<p class="Pp">Return only module names containing method <i>print</i> which
    expects the first argument to be of type
    <span class="Li">&quot;Apache2::Filter&quot;</span>:</p>
<p class="Pp"></p>
<pre>  my $filter = bless {}, 'Apache2::Filter';
  my ($hint, @modules) =
      ModPerl::MethodLookup::lookup_method('print', $filter);
</pre>
<p class="Pp">or:</p>
<p class="Pp"></p>
<pre>  my ($hint, @modules) =
      ModPerl::MethodLookup::lookup_method('print', 'Apache2::Filter');
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="_lookup_module()_"><a class="permalink" href="#_lookup_module()_">&quot;lookup_module()&quot;</a></h2>
<p class="Pp">Find methods contained in a certain module (package)</p>
<p class="Pp"></p>
<pre>  ($hint, @methods) = lookup_module($module_name);
</pre>
<dl class="Bl-tag">
  <dt id="arg1:~2"><a class="permalink" href="#arg1:~2">arg1: $module_name (
    string )</a></dt>
  <dd>the module name</dd>
  <dt id="ret1:~2"><a class="permalink" href="#ret1:~2">ret1: $hint</a></dt>
  <dd>a string containing a human readable lookup result, suggesting, which
      methods the module <span class="Li">$module_name</span> implements, or
      explaining the failure if the lookup failed.</dd>
  <dt id="ret2:~2"><a class="permalink" href="#ret2:~2">ret2: @methods</a></dt>
  <dd>an array of methods which have matched the query, i.e. the names of the
      methods defined in the requested module.</dd>
  <dt id="since:~2"><a class="permalink" href="#since:~2">since: 2.0.00</a></dt>
  <dd></dd>
</dl>
<p class="Pp">Example:</p>
<p class="Pp">What XS methods defined by module
    <span class="Li">&quot;Apache2::Filter&quot;</span>:</p>
<p class="Pp"></p>
<pre>  my ($hint, @methods) =
      ModPerl::MethodLookup::lookup_module('Apache2::Filter');
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="_lookup_object()_"><a class="permalink" href="#_lookup_object()_">&quot;lookup_object()&quot;</a></h2>
<pre>  ($hint, @methods) = lookup_object($object);
  ($hint, @methods) = lookup_object($class);
</pre>
<dl class="Bl-tag">
  <dt id="arg1:~3"><a class="permalink" href="#arg1:~3">arg1: $object or
    $class</a></dt>
  <dd>an object or a name of a class an object is blessed into
    <p class="Pp">If a sub-classed object is passed it'll be handled correctly,
        by including methods provided by its super-class(es).</p>
  </dd>
  <dt id="ret1:~3"><a class="permalink" href="#ret1:~3">ret1: $hint</a></dt>
  <dd>a string containing a human readable lookup result, suggesting, which
      methods the given object can invoke (including module names that need to
      be loaded to use those methods), or explaining the failure if the lookup
      failed.</dd>
  <dt id="ret2:~3"><a class="permalink" href="#ret2:~3">ret2: @methods</a></dt>
  <dd>an array of methods which have matched the query, i.e. the names of the
      methods that can be invoked on the given object (or its class name).</dd>
  <dt id="since:~3"><a class="permalink" href="#since:~3">since: 2.0.00</a></dt>
  <dd></dd>
</dl>
<p class="Pp">META: As of this writing this function may miss some of the
    functions/methods that can be invoked on the given object. Currently we
    can't programmatically deduct the objects they are invoked on, because these
    methods are written in pure XS and manipulate the arguments stack
    themselves. Currently these are mainly XS functions, not methods, which of
    course aren't invoked on objects. There are also logging function wrappers
    (<span class="Li">&quot;Apache2::Log&quot;</span>).</p>
<p class="Pp">Examples:</p>
<p class="Pp">What XS methods can be invoked on the object
    <span class="Li">$r</span>:</p>
<p class="Pp"></p>
<pre>  my ($hint, @methods) =
      ModPerl::MethodLookup::lookup_object($r);
</pre>
<p class="Pp">or <span class="Li">$r</span>'s class --
    <span class="Li">&quot;Apache2::RequestRec&quot;</span>:</p>
<p class="Pp"></p>
<pre>  my ($hint, @methods) =
      ModPerl::MethodLookup::lookup_object('Apache2::RequestRec');
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="_preload_all_modules()_"><a class="permalink" href="#_preload_all_modules()_">&quot;preload_all_modules()&quot;</a></h2>
<p class="Pp">The function
    <span class="Li">&quot;preload_all_modules()&quot;</span> preloads all
    mod_perl 2.0 modules, which implement their API in XS. This is similar to
    the mod_perl 1.0 behavior which has most of its methods loaded at the
    startup.</p>
<p class="Pp">CPAN modules developers should make sure their distribution loads
    each of the used mod_perl 2.0 modules explicitly, and not use this function,
    as it takes the fine control away from the users. One should avoid doing
    this the production server (unless all modules are used indeed) in order to
    save memory.</p>
<dl class="Bl-tag">
  <dt id="since:~4"><a class="permalink" href="#since:~4">since: 2.0.00</a></dt>
  <dd></dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="_print_method()_"><a class="permalink" href="#_print_method()_">&quot;print_method()&quot;</a></h2>
<p class="Pp"><span class="Li">&quot;print_method()&quot;</span> is a
    convenience wrapper for <span class="Li">&quot;lookup_method()&quot;</span>,
    mainly designed to be used from the command line. For example to print all
    the modules which define method <i>read</i> execute:</p>
<p class="Pp"></p>
<pre>  % perl -MModPerl::MethodLookup -e print_method read
</pre>
<p class="Pp">Since this will return more than one module, we can narrow the
    query to only those methods which expect the first argument to be blessed
    into class <span class="Li">&quot;APR::Bucket&quot;</span>:</p>
<p class="Pp"></p>
<pre>  % perl -MModPerl::MethodLookup -e print_method read APR::Bucket
</pre>
<p class="Pp">You can pass more than one method and it'll perform a lookup on
    each of the methods. For example to lookup methods
    <span class="Li">&quot;get_server_built&quot;</span> and
    <span class="Li">&quot;request&quot;</span> you can do:</p>
<p class="Pp"></p>
<pre>  % perl -MModPerl::MethodLookup -e print_method \
    get_server_built request
</pre>
<p class="Pp">The function <span class="Li">&quot;print_method()&quot;</span> is
    exported by default.</p>
<dl class="Bl-tag">
  <dt id="since:~5"><a class="permalink" href="#since:~5">since: 2.0.00</a></dt>
  <dd></dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="_print_module()_"><a class="permalink" href="#_print_module()_">&quot;print_module()&quot;</a></h2>
<p class="Pp"><span class="Li">&quot;print_module()&quot;</span> is a
    convenience wrapper for <span class="Li">&quot;lookup_module()&quot;</span>,
    mainly designed to be used from the command line. For example to print all
    the methods defined in the module
    <span class="Li">&quot;Apache2::RequestRec&quot;</span>, followed by methods
    defined in the module <span class="Li">&quot;Apache2::Filter&quot;</span>
    you can run:</p>
<p class="Pp"></p>
<pre>  % perl -MModPerl::MethodLookup -e print_module \
    Apache2::RequestRec Apache2::Filter
</pre>
<p class="Pp">The function <span class="Li">&quot;print_module()&quot;</span> is
    exported by default.</p>
<dl class="Bl-tag">
  <dt id="since:~6"><a class="permalink" href="#since:~6">since: 2.0.00</a></dt>
  <dd></dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="_print_object()_"><a class="permalink" href="#_print_object()_">&quot;print_object()&quot;</a></h2>
<p class="Pp"><span class="Li">&quot;print_object()&quot;</span> is a
    convenience wrapper for <span class="Li">&quot;lookup_object()&quot;</span>,
    mainly designed to be used from the command line. For example to print all
    the methods that can be invoked on object blessed into a class
    <span class="Li">&quot;Apache2::RequestRec&quot;</span> run:</p>
<p class="Pp"></p>
<pre>  % perl -MModPerl::MethodLookup -e print_object \
    Apache2::RequestRec
</pre>
<p class="Pp">Similar to <span class="Li">&quot;print_object()&quot;</span>,
    more than one class can be passed to this function.</p>
<p class="Pp">The function <span class="Li">&quot;print_object()&quot;</span> is
    exported by default.</p>
<dl class="Bl-tag">
  <dt id="since:~7"><a class="permalink" href="#since:~7">since: 2.0.00</a></dt>
  <dd></dd>
</dl>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="Applications"><a class="permalink" href="#Applications">Applications</a></h1>
<section class="Ss">
<h2 class="Ss" id="_AUTOLOAD_"><a class="permalink" href="#_AUTOLOAD_">&quot;AUTOLOAD&quot;</a></h2>
<p class="Pp">When Perl fails to locate a method it checks whether the package
    the object belongs to has an <span class="Li">&quot;AUTOLOAD&quot;</span>
    function defined and if so, calls it with the same arguments as the missing
    method while setting a global variable <span class="Li">$AUTOLOAD</span> (in
    that package) to the name of the originally called method. We can use this
    facility to lookup the modules to be loaded when such a failure occurs.
    Though since we have many packages to take care of we will use a special
    <span class="Li">&quot;UNIVERSAL::AUTOLOAD&quot;</span> function which Perl
    calls if can't find the <span class="Li">&quot;AUTOLOAD&quot;</span>
    function in the given package.</p>
<p class="Pp">In that function you can query
    <span class="Li">&quot;ModPerl::MethodLookup&quot;</span>, <b>require()</b>
    the module that includes the called method and call that method again using
    the <b>goto()</b> trick:</p>
<p class="Pp"></p>
<pre>  use ModPerl::MethodLookup;
  sub UNIVERSAL::AUTOLOAD {
      my ($hint, @modules) =
          ModPerl::MethodLookup::lookup_method($UNIVERSAL::AUTOLOAD, @_);
      if (@modules) {
          eval &quot;require $_&quot; for @modules;
          goto &amp;$UNIVERSAL::AUTOLOAD;
      }
      else {
          die $hint;
      }
  }
</pre>
<p class="Pp">However we don't endorse this approach. It's a better approach to
    always abort the execution which printing the
    <span class="Li">$hint</span>and use fix the code to load the missing
    module. Moreover installing
    <span class="Li">&quot;UNIVERSAL::AUTOLOAD&quot;</span> may cause a lot of
    problems, since once it's installed Perl will call it every time some method
    is missing (e.g. undefined <span class="Li">&quot;DESTROY&quot;</span>
    methods). The following approach seems to somewhat work for me. It installs
    <span class="Li">&quot;UNIVERSAL::AUTOLOAD&quot;</span> only when the the
    child process starts.</p>
<p class="Pp"></p>
<pre>  httpd.conf:
  -----------
  PerlChildInitHandler ModPerl::MethodLookupAuto
  startup.pl:
  -----------
  {
      package ModPerl::MethodLookupAuto;
      use ModPerl::MethodLookup;
    
      use Carp;
      sub handler {
    
          *UNIVERSAL::AUTOLOAD = sub {
              my $method = $AUTOLOAD;
              return if $method =~ /DESTROY/; # exclude DESTROY resolving
    
              my ($hint, @modules) =
                  ModPerl::MethodLookup::lookup_method($method, @_);
              $hint ||= &quot;Can't find method $AUTOLOAD&quot;;
              croak $hint;
          };
          return 0;
      }
  }
</pre>
<p class="Pp">This example doesn't load the modules for you. It'll print to
    STDERR what module should be loaded, when a method from the not-yet-loaded
    module is called.</p>
<p class="Pp">A similar technique is used by
    <span class="Li">&quot;Apache2::porting&quot;</span>.</p>
<p class="Pp">META: there is a better version of AUTOLOAD discussed on the dev
    list. Replace the current one with it. (search the archive for EazyLife)</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Command_Line_Lookups"><a class="permalink" href="#Command_Line_Lookups">Command
  Line Lookups</a></h2>
<p class="Pp">When a method is used and mod_perl has reported a failure to find
    it, it's often useful to use the command line query to figure out which
    module needs to be loaded. For example if when executing:</p>
<p class="Pp"></p>
<pre>  $r-&gt;construct_url();
</pre>
<p class="Pp">mod_perl complains:</p>
<p class="Pp"></p>
<pre>  Can't locate object method &quot;construct_url&quot; via package
  &quot;Apache2::RequestRec&quot; at ...
</pre>
<p class="Pp">you can ask
    <span class="Li">&quot;ModPerl::MethodLookup&quot;</span> for help:</p>
<p class="Pp"></p>
<pre>  % perl -MModPerl::MethodLookup -e print_method construct_url
  To use method 'construct_url' add:
          use Apache2::URI ();
</pre>
<p class="Pp">and after copy-n-pasting the use statement in our code, the
    problem goes away.</p>
<p class="Pp">One can create a handy alias for this technique. For example,
    C-style shell users can do:</p>
<p class="Pp"></p>
<pre>   % alias lookup &quot;perl -MModPerl::MethodLookup -e print_method&quot;
</pre>
<p class="Pp">For Bash-style shell users:</p>
<p class="Pp"></p>
<pre>   % alias lookup=&quot;perl -MModPerl::MethodLookup -e print_method&quot;
</pre>
<p class="Pp">Now the lookup is even easier:</p>
<p class="Pp"></p>
<pre>  % lookup construct_url
  to use method 'construct_url' add:
          use Apache2::URI;
</pre>
<p class="Pp">Similar aliases can be provided for
    <span class="Li">&quot;print_object()&quot;</span> and
    <span class="Li">&quot;print_module()&quot;</span>.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="Todo"><a class="permalink" href="#Todo">Todo</a></h1>
<p class="Pp">These methods aren't yet picked by this module (the extract from
    the map file):</p>
<p class="Pp"></p>
<pre> modperl_filter_attributes     | MODIFY_CODE_ATTRIBUTES
 modperl_spawn_proc_prog       | spawn_proc_prog
 apr_ipsubnet_create           | new
</pre>
<p class="Pp">Please report to the mod_perl development mailing list if you find
    any other missing methods. But remember that as of this moment the module
    reports only XS functions. In the future we may add support for pure perl
    functions/methods as well.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="See_Also"><a class="permalink" href="#See_Also">See
  Also</a></h1>
<ul class="Bl-bullet">
  <li>the mod_perl 1.0 backward compatibility document</li>
  <li>porting Perl modules</li>
  <li>porting XS modules</li>
  <li><span class="Li">&quot;Apache2::porting&quot;</span></li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="Copyright"><a class="permalink" href="#Copyright">Copyright</a></h1>
<p class="Pp">mod_perl 2.0 and its core modules are copyrighted under The Apache
    Software License, Version 2.0.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="Authors"><a class="permalink" href="#Authors">Authors</a></h1>
<p class="Pp">The mod_perl development team and numerous contributors.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2015-06-18</td>
    <td class="foot-os">perl v5.30.2</td>
  </tr>
</table>
</body>
</html>
