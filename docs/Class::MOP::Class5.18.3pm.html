<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    .Nd, .Bf, .Op { display: inline; }
    .Pa, .Ad { font-style: italic; }
    .Ms { font-weight: bold; }
    .Bl-diag > dt { font-weight: bold; }
    code.Nm, .Fl, .Cm, .Ic, code.In, .Fd, .Fn, .Cd { font-weight: bold;
      font-family: inherit; }
  </style>
  <title>Class::MOP::Class(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Class::MOP::Class(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Class::MOP::Class(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Class::MOP::Class - Class Meta Object</p>
</section>
<section class="Sh">
<h1 class="Sh" id="VERSION"><a class="permalink" href="#VERSION">VERSION</a></h1>
<p class="Pp">version 2.1202</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>  # assuming that class Foo
  # has been defined, you can
  # use this for introspection ...
  # add a method to Foo ...
  Foo-&gt;meta-&gt;add_method( 'bar' =&gt; sub {...} )
  # get a list of all the classes searched
  # the method dispatcher in the correct order
  Foo-&gt;meta-&gt;class_precedence_list()
  # remove a method from Foo
  Foo-&gt;meta-&gt;remove_method('bar');
  # or use this to actually create classes ...
  Class::MOP::Class-&gt;create(
      'Bar' =&gt; (
          version      =&gt; '0.01',
          superclasses =&gt; ['Foo'],
          attributes   =&gt; [
              Class::MOP::Attribute-&gt;new('$bar'),
              Class::MOP::Attribute-&gt;new('$baz'),
          ],
          methods =&gt; {
              calculate_bar =&gt; sub {...},
              construct_baz =&gt; sub {...}
          }
      )
  );
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">The Class Protocol is the largest and most complex part of the
    Class::MOP meta-object protocol. It controls the introspection and
    manipulation of Perl 5 classes, and it can create them as well. The best way
    to understand what this module can do is to read the documentation for each
    of its methods.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="INHERITANCE"><a class="permalink" href="#INHERITANCE">INHERITANCE</a></h1>
<p class="Pp"><span class="Li">&quot;Class::MOP::Class&quot;</span> is a
    subclass of Class::MOP::Module.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="METHODS"><a class="permalink" href="#METHODS">METHODS</a></h1>
<section class="Ss">
<h2 class="Ss" id="Class_construction"><a class="permalink" href="#Class_construction">Class
  construction</a></h2>
<p class="Pp">These methods all create new
    <span class="Li">&quot;Class::MOP::Class&quot;</span> objects. These objects
    can represent existing classes or they can be used to create new classes
    from scratch.</p>
<p class="Pp">The metaclass object for a given class is a singleton. If you
    attempt to create a metaclass for the same class twice, you will just get
    the existing object.</p>
<dl class="Bl-tag">
  <dt id="Class::MOP::Class"><a class="permalink" href="#Class::MOP::Class"><b>Class::MOP::Class-&gt;create($package_name,
    </b><b>%options</b><b>)</b></a></dt>
  <dd>This method creates a new
      <span class="Li">&quot;Class::MOP::Class&quot;</span> object with the
      given package name. It accepts a number of options:</dd>
</dl>
<div class="Bd-indent">
<ul class="Bl-bullet">
  <li>version
    <p class="Pp">An optional version number for the newly created package.</p>
  </li>
  <li>authority
    <p class="Pp">An optional authority for the newly created package.</p>
  </li>
  <li>superclasses
    <p class="Pp">An optional array reference of superclass names.</p>
  </li>
  <li>methods
    <p class="Pp">An optional hash reference of methods for the class. The keys
        of the hash reference are method names and values are subroutine
        references.</p>
  </li>
  <li>attributes
    <p class="Pp">An optional array reference of Class::MOP::Attribute
      objects.</p>
  </li>
  <li>meta_name
    <p class="Pp">Specifies the name to install the
        <span class="Li">&quot;meta&quot;</span> method for this class under. If
        it is not passed, <span class="Li">&quot;meta&quot;</span> is assumed,
        and if <span class="Li">&quot;undef&quot;</span> is explicitly given, no
        meta method will be installed.</p>
  </li>
  <li>weaken
    <p class="Pp">If true, the metaclass that is stored in the global cache will
        be a weak reference.</p>
    <p class="Pp">Classes created in this way are destroyed once the metaclass
        they are attached to goes out of scope, and will be removed from Perl's
        internal symbol table.</p>
    <p class="Pp">All instances of a class with a weakened metaclass keep a
        special reference to the metaclass object, which prevents the metaclass
        from going out of scope while any instances exist.</p>
    <p class="Pp">This only works if the instance is based on a hash reference,
        however.</p>
  </li>
</ul>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt id="Class::MOP::Class~2"><a class="permalink" href="#Class::MOP::Class~2"><b>Class::MOP::Class-&gt;create_anon_class(%options)</b></a></dt>
  <dd>This method works just like
      <span class="Li">&quot;Class::MOP::Class-&gt;create&quot;</span> but it
      creates an &quot;anonymous&quot; class. In fact, the class does have a
      name, but that name is a unique name generated internally by this module.
    <p class="Pp">It accepts the same
        <span class="Li">&quot;superclasses&quot;</span>,
        <span class="Li">&quot;methods&quot;</span>, and
        <span class="Li">&quot;attributes&quot;</span> parameters that
        <span class="Li">&quot;create&quot;</span> accepts.</p>
    <p class="Pp">Anonymous classes default to <span class="Li">&quot;weaken
        =&gt; 1&quot;</span>, although this can be overridden.</p>
  </dd>
  <dt id="Class::MOP::Class~3"><a class="permalink" href="#Class::MOP::Class~3"><b>Class::MOP::Class-&gt;initialize($package_name,
    </b><b>%options</b><b>)</b></a></dt>
  <dd>This method will initialize a
      <span class="Li">&quot;Class::MOP::Class&quot;</span> object for the named
      package. Unlike <span class="Li">&quot;create&quot;</span>, this method
      <i>will not</i> create a new class.
    <p class="Pp">The purpose of this method is to retrieve a
        <span class="Li">&quot;Class::MOP::Class&quot;</span> object for
        introspecting an existing class.</p>
    <p class="Pp">If an existing
        <span class="Li">&quot;Class::MOP::Class&quot;</span> object exists for
        the named package, it will be returned, and any options provided will be
        ignored!</p>
    <p class="Pp">If the object does not yet exist, it will be created.</p>
    <p class="Pp">The valid options that can be passed to this method are
        <span class="Li">&quot;attribute_metaclass&quot;</span>,
        <span class="Li">&quot;method_metaclass&quot;</span>,
        <span class="Li">&quot;wrapped_method_metaclass&quot;</span>, and
        <span class="Li">&quot;instance_metaclass&quot;</span>. These are all
        optional, and default to the appropriate class in the
        <span class="Li">&quot;Class::MOP&quot;</span> distribution.</p>
  </dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Object_instance_construction_and_cloning"><a class="permalink" href="#Object_instance_construction_and_cloning">Object
  instance construction and cloning</a></h2>
<p class="Pp">These methods are all related to creating and/or cloning object
    instances.</p>
<dl class="Bl-tag">
  <dt><b></b><b>$metaclass</b><b>-&gt;clone_object($instance,
    </b><b><i>%params</i></b><b>)</b></dt>
  <dd>This method clones an existing object instance. Any parameters you provide
      are will override existing attribute values in the object.
    <p class="Pp">This is a convenience method for cloning an object instance,
        then blessing it into the appropriate package.</p>
    <p class="Pp">You could implement a clone method in your class, using this
        method:</p>
    <p class="Pp"></p>
    <pre>  sub clone {
      my ($self, %params) = @_;
      $self-&gt;meta-&gt;clone_object($self, %params);
  }
    </pre>
  </dd>
  <dt><b></b><b>$metaclass</b><b>-&gt;rebless_instance($instance,
    </b><b><i>%params</i></b><b>)</b></dt>
  <dd>This method changes the class of <span class="Li">$instance</span> to the
      metaclass's class.
    <p class="Pp">You can only rebless an instance into a subclass of its
        current class. If you pass any additional parameters, these will be
        treated like constructor parameters and used to initialize the object's
        attributes. Any existing attributes that are already set will be
        overwritten.</p>
    <p class="Pp">Before reblessing the instance, this method will call
        <span class="Li">&quot;rebless_instance_away&quot;</span> on the
        instance's current metaclass. This method will be passed the instance,
        the new metaclass, and any parameters specified to
        <span class="Li">&quot;rebless_instance&quot;</span>. By default,
        <span class="Li">&quot;rebless_instance_away&quot;</span> does nothing;
        it is merely a hook.</p>
  </dd>
  <dt><b></b><b>$metaclass</b><b>-&gt;rebless_instance_back($instance)</b></dt>
  <dd>Does the same thing as
      <span class="Li">&quot;rebless_instance&quot;</span>, except that you can
      only rebless an instance into one of its superclasses. Any attributes that
      do not exist in the superclass will be deinitialized.
    <p class="Pp">This is a much more dangerous operation than
        <span class="Li">&quot;rebless_instance&quot;</span>, especially when
        multiple inheritance is involved, so use this carefully!</p>
  </dd>
  <dt><b></b><b>$metaclass</b><b>-&gt;new_object(%params)</b></dt>
  <dd>This method is used to create a new object of the metaclass's class. Any
      parameters you provide are used to initialize the instance's attributes. A
      special <span class="Li">&quot;__INSTANCE__&quot;</span> key can be passed
      to provide an already generated instance, rather than having Class::MOP
      generate it for you. This is mostly useful for using Class::MOP with
      foreign classes which generate instances using their own
    constructors.</dd>
  <dt><b></b><b>$metaclass</b><b>-&gt;instance_metaclass</b></dt>
  <dd>Returns the class name of the instance metaclass. See Class::MOP::Instance
      for more information on the instance metaclass.</dd>
  <dt><b></b><b>$metaclass</b><b>-&gt;get_meta_instance</b></dt>
  <dd>Returns an instance of the
      <span class="Li">&quot;instance_metaclass&quot;</span> to be used in the
      construction of a new instance of the class.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Informational_predicates"><a class="permalink" href="#Informational_predicates">Informational
  predicates</a></h2>
<p class="Pp">These are a few predicate methods for asking information about the
    class itself.</p>
<dl class="Bl-tag">
  <dt><b></b><b>$metaclass</b><b>-&gt;is_anon_class</b></dt>
  <dd>This returns true if the class was created by calling
      <span class="Li">&quot;Class::MOP::Class-&gt;create_anon_class&quot;</span>.</dd>
  <dt><b></b><b>$metaclass</b><b>-&gt;is_mutable</b></dt>
  <dd>This returns true if the class is still mutable.</dd>
  <dt><b></b><b>$metaclass</b><b>-&gt;is_immutable</b></dt>
  <dd>This returns true if the class has been made immutable.</dd>
  <dt><b></b><b>$metaclass</b><b>-&gt;is_pristine</b></dt>
  <dd>A class is <i>not</i> pristine if it has non-inherited attributes or if it
      has any generated methods.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Inheritance_Relationships"><a class="permalink" href="#Inheritance_Relationships">Inheritance
  Relationships</a></h2>
<dl class="Bl-tag">
  <dt><b></b><b>$metaclass</b><b>-&gt;superclasses(@superclasses)</b></dt>
  <dd>This is a read-write accessor which represents the superclass
      relationships of the metaclass's class.
    <p class="Pp">This is basically sugar around getting and setting
        <span class="Li">@ISA</span>.</p>
  </dd>
  <dt><b></b><b>$metaclass</b><b>-&gt;class_precedence_list</b></dt>
  <dd>This returns a list of all of the class's ancestor classes. The classes
      are returned in method dispatch order.</dd>
  <dt><b></b><b>$metaclass</b><b>-&gt;linearized_isa</b></dt>
  <dd>This returns a list based on
      <span class="Li">&quot;class_precedence_list&quot;</span> but with all
      duplicates removed.</dd>
  <dt><b></b><b>$metaclass</b><b>-&gt;subclasses</b></dt>
  <dd>This returns a list of all subclasses for this class, even indirect
      subclasses.</dd>
  <dt><b></b><b>$metaclass</b><b>-&gt;direct_subclasses</b></dt>
  <dd>This returns a list of immediate subclasses for this class, which does not
      include indirect subclasses.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Method_introspection_and_creation"><a class="permalink" href="#Method_introspection_and_creation">Method
  introspection and creation</a></h2>
<p class="Pp">These methods allow you to introspect a class's methods, as well
    as add, remove, or change methods.</p>
<p class="Pp">Determining what is truly a method in a Perl 5 class requires some
    heuristics (aka guessing).</p>
<p class="Pp">Methods defined outside the package with a fully qualified name
    (<span class="Li">&quot;sub</span> <span class="Li">Package::name { ...
    }&quot;</span>) will be included. Similarly, methods named with a fully
    qualified name using Sub::Name are also included.</p>
<p class="Pp">However, we attempt to ignore imported functions.</p>
<p class="Pp">Ultimately, we are using heuristics to determine what truly is a
    method in a class, and these heuristics may get the wrong answer in some
    edge cases. However, for most &quot;normal&quot; cases the heuristics work
    correctly.</p>
<dl class="Bl-tag">
  <dt><b></b><b>$metaclass</b><b>-&gt;get_method($method_name)</b></dt>
  <dd>This will return a Class::MOP::Method for the specified
      <span class="Li">$method_name</span>. If the class does not have the
      specified method, it returns
    <span class="Li">&quot;undef&quot;</span></dd>
  <dt><b></b><b>$metaclass</b><b>-&gt;has_method($method_name)</b></dt>
  <dd>Returns a boolean indicating whether or not the class defines the named
      method. It does not include methods inherited from parent classes.</dd>
  <dt><b></b><b>$metaclass</b><b>-&gt;get_method_list</b></dt>
  <dd>This will return a list of method <i>names</i> for all methods defined in
      this class.</dd>
  <dt><b></b><b>$metaclass</b><b>-&gt;add_method($method_name,
    </b><b><i>$method</i></b><b>)</b></dt>
  <dd>This method takes a method name and a subroutine reference, and adds the
      method to the class.
    <p class="Pp">The subroutine reference can be a Class::MOP::Method, and you
        are strongly encouraged to pass a meta method object instead of a code
        reference. If you do so, that object gets stored as part of the class's
        method map directly. If not, the meta information will have to be
        recreated later, and may be incorrect.</p>
    <p class="Pp">If you provide a method object, this method will clone that
        object if the object's package name does not match the class name. This
        lets us track the original source of any methods added from other
        classes (notably Moose roles).</p>
  </dd>
  <dt><b></b><b>$metaclass</b><b>-&gt;remove_method($method_name)</b></dt>
  <dd>Remove the named method from the class. This method returns the
      Class::MOP::Method object for the method.</dd>
  <dt><b></b><b>$metaclass</b><b>-&gt;method_metaclass</b></dt>
  <dd>Returns the class name of the method metaclass, see Class::MOP::Method for
      more information on the method metaclass.</dd>
  <dt><b></b><b>$metaclass</b><b>-&gt;wrapped_method_metaclass</b></dt>
  <dd>Returns the class name of the wrapped method metaclass, see
      Class::MOP::Method::Wrapped for more information on the wrapped method
      metaclass.</dd>
  <dt><b></b><b>$metaclass</b><b>-&gt;get_all_methods</b></dt>
  <dd>This will traverse the inheritance hierarchy and return a list of all the
      Class::MOP::Method objects for this class and its parents.</dd>
  <dt><b></b><b>$metaclass</b><b>-&gt;find_method_by_name($method_name)</b></dt>
  <dd>This will return a Class::MOP::Method for the specified
      <span class="Li">$method_name</span>. If the class does not have the
      specified method, it returns <span class="Li">&quot;undef&quot;</span>
    <p class="Pp">Unlike <span class="Li">&quot;get_method&quot;</span>, this
        method <i>will</i> look for the named method in superclasses.</p>
  </dd>
  <dt><b></b><b>$metaclass</b><b>-&gt;get_all_method_names</b></dt>
  <dd>This will return a list of method <i>names</i> for all of this class's
      methods, including inherited methods.</dd>
  <dt><b></b><b>$metaclass</b><b>-&gt;find_all_methods_by_name($method_name)</b></dt>
  <dd>This method looks for the named method in the class and all of its
      parents. It returns every matching method it finds in the inheritance
      tree, so it returns a list of methods.
    <p class="Pp">Each method is returned as a hash reference with three keys.
        The keys are <span class="Li">&quot;name&quot;</span>,
        <span class="Li">&quot;class&quot;</span>, and
        <span class="Li">&quot;code&quot;</span>. The
        <span class="Li">&quot;code&quot;</span> key has a Class::MOP::Method
        object as its value.</p>
    <p class="Pp">The list of methods is distinct.</p>
  </dd>
  <dt><b></b><b>$metaclass</b><b>-&gt;find_next_method_by_name($method_name)</b></dt>
  <dd>This method returns the first method in any superclass matching the given
      name. It is effectively the method that
      <span class="Li">&quot;SUPER::$method_name&quot;</span> would dispatch
    to.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Attribute_introspection_and_creation"><a class="permalink" href="#Attribute_introspection_and_creation">Attribute
  introspection and creation</a></h2>
<p class="Pp">Because Perl 5 does not have a core concept of attributes in
    classes, we can only return information about attributes which have been
    added via this class's methods. We cannot discover information about
    attributes which are defined in terms of &quot;regular&quot; Perl 5
  methods.</p>
<dl class="Bl-tag">
  <dt><b></b><b>$metaclass</b><b>-&gt;get_attribute($attribute_name)</b></dt>
  <dd>This will return a Class::MOP::Attribute for the specified
      <span class="Li">$attribute_name</span>. If the class does not have the
      specified attribute, it returns <span class="Li">&quot;undef&quot;</span>.
    <p class="Pp">NOTE that get_attribute does not search superclasses, for that
        you need to use
        <span class="Li">&quot;find_attribute_by_name&quot;</span>.</p>
  </dd>
  <dt><b></b><b>$metaclass</b><b>-&gt;has_attribute($attribute_name)</b></dt>
  <dd>Returns a boolean indicating whether or not the class defines the named
      attribute. It does not include attributes inherited from parent
    classes.</dd>
  <dt><b></b><b>$metaclass</b><b>-&gt;get_attribute_list</b></dt>
  <dd>This will return a list of attributes <i>names</i> for all attributes
      defined in this class. Note that this operates on the current class only,
      it does not traverse the inheritance hierarchy.</dd>
  <dt><b></b><b>$metaclass</b><b>-&gt;get_all_attributes</b></dt>
  <dd>This will traverse the inheritance hierarchy and return a list of all the
      Class::MOP::Attribute objects for this class and its parents.</dd>
  <dt><b></b><b>$metaclass</b><b>-&gt;find_attribute_by_name($attribute_name)</b></dt>
  <dd>This will return a Class::MOP::Attribute for the specified
      <span class="Li">$attribute_name</span>. If the class does not have the
      specified attribute, it returns <span class="Li">&quot;undef&quot;</span>.
    <p class="Pp">Unlike <span class="Li">&quot;get_attribute&quot;</span>, this
        attribute <i>will</i> look for the named attribute in superclasses.</p>
  </dd>
  <dt><b></b><b>$metaclass</b><b>-&gt;add_attribute(...)</b></dt>
  <dd>This method accepts either an existing Class::MOP::Attribute object or
      parameters suitable for passing to that class's
      <span class="Li">&quot;new&quot;</span> method.
    <p class="Pp">The attribute provided will be added to the class.</p>
    <p class="Pp">Any accessor methods defined by the attribute will be added to
        the class when the attribute is added.</p>
    <p class="Pp">If an attribute of the same name already exists, the old
        attribute will be removed first.</p>
  </dd>
  <dt><b></b><b>$metaclass</b><b>-&gt;remove_attribute($attribute_name)</b></dt>
  <dd>This will remove the named attribute from the class, and
      Class::MOP::Attribute object.
    <p class="Pp">Removing an attribute also removes any accessor methods
        defined by the attribute.</p>
    <p class="Pp">However, note that removing an attribute will only affect
        <i>future</i> object instances created for this class, not existing
        instances.</p>
  </dd>
  <dt><b></b><b>$metaclass</b><b>-&gt;attribute_metaclass</b></dt>
  <dd>Returns the class name of the attribute metaclass for this class. By
      default, this is Class::MOP::Attribute.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Overload_introspection_and_creation"><a class="permalink" href="#Overload_introspection_and_creation">Overload
  introspection and creation</a></h2>
<p class="Pp">These methods provide an API to the core overload
  functionality.</p>
<dl class="Bl-tag">
  <dt><b></b><b>$metaclass</b><b>-&gt;is_overloaded</b></dt>
  <dd>Returns true if overloading is enabled for this class. Corresponds to
      overload::Overloaded.</dd>
  <dt><b></b><b>$metaclass</b><b>-&gt;get_overloaded_operator($op)</b></dt>
  <dd>Returns the Class::MOP::Method::Overload object corresponding to the
      operator named <span class="Li">$op</span>, if one exists for this
    class.</dd>
  <dt><b></b><b>$metaclass</b><b>-&gt;has_overloaded_operator($op)</b></dt>
  <dd>Returns whether or not the operator <span class="Li">$op</span> is
      overloaded for this class.</dd>
  <dt><b></b><b>$metaclass</b><b>-&gt;get_overload_list</b></dt>
  <dd>Returns a list of operator names which have been overloaded (see
      &quot;Overloadable Operations&quot; in overload for the list of valid
      operator names).</dd>
  <dt><b></b><b>$metaclass</b><b>-&gt;get_all_overloaded_operators</b></dt>
  <dd>Returns a list of Class::MOP::Method::Overload objects corresponding to
      the operators that have been overloaded.</dd>
  <dt><b></b><b>$metaclass</b><b>-&gt;add_overloaded_operator($op,
    </b><b><i>$impl</i></b><b>)</b></dt>
  <dd>Overloads the operator <span class="Li">$op</span> for this class, with
      the implementation <span class="Li">$impl</span>.
      <span class="Li">$impl</span> can be either a coderef or a method name.
      Corresponds to <span class="Li">&quot;use overload $op =&gt;
      $impl;&quot;</span></dd>
  <dt><b></b><b>$metaclass</b><b>-&gt;remove_overloaded_operator($op)</b></dt>
  <dd>Remove overloading for operator <span class="Li">$op</span>. Corresponds
      to <span class="Li">&quot;no overload $op;&quot;</span></dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Class_Immutability"><a class="permalink" href="#Class_Immutability">Class
  Immutability</a></h2>
<p class="Pp">Making a class immutable &quot;freezes&quot; the class definition.
    You can no longer call methods which alter the class, such as adding or
    removing methods or attributes.</p>
<p class="Pp">Making a class immutable lets us optimize the class by inlining
    some methods, and also allows us to optimize some methods on the metaclass
    object itself.</p>
<p class="Pp">After immutabilization, the metaclass object will cache most
    informational methods that returns information about methods or attributes.
    Methods which would alter the class, such as
    <span class="Li">&quot;add_attribute&quot;</span> and
    <span class="Li">&quot;add_method&quot;</span>, will throw an error on an
    immutable metaclass object.</p>
<p class="Pp">The immutabilization system in Moose takes much greater advantage
    of the inlining features than Class::MOP itself does.</p>
<dl class="Bl-tag">
  <dt><b></b><b>$metaclass</b><b>-&gt;make_immutable(%options)</b></dt>
  <dd>This method will create an immutable transformer and use it to make the
      class and its metaclass object immutable, and returns true (you should not
      rely on the details of this value apart from its truth).
    <p class="Pp">This method accepts the following options:</p>
  </dd>
</dl>
<div class="Bd-indent">
<ul class="Bl-bullet">
  <li>inline_accessors</li>
  <li>inline_constructor</li>
  <li>inline_destructor
    <p class="Pp">These are all booleans indicating whether the specified
        method(s) should be inlined.</p>
    <p class="Pp">By default, accessors and the constructor are inlined, but not
        the destructor.</p>
  </li>
  <li>immutable_trait
    <p class="Pp">The name of a class which will be used as a parent class for
        the metaclass object being made immutable. This &quot;trait&quot;
        implements the post-immutability functionality of the metaclass (but not
        the transformation itself).</p>
    <p class="Pp">This defaults to Class::MOP::Class::Immutable::Trait.</p>
  </li>
  <li>constructor_name
    <p class="Pp">This is the constructor method name. This defaults to
        &quot;new&quot;.</p>
  </li>
  <li>constructor_class
    <p class="Pp">The name of the method metaclass for constructors. It will be
        used to generate the inlined constructor. This defaults to
        &quot;Class::MOP::Method::Constructor&quot;.</p>
  </li>
  <li>replace_constructor
    <p class="Pp">This is a boolean indicating whether an existing constructor
        should be replaced when inlining a constructor. This defaults to
      false.</p>
  </li>
  <li>destructor_class
    <p class="Pp">The name of the method metaclass for destructors. It will be
        used to generate the inlined destructor. This defaults to
        &quot;Class::MOP::Method::Denstructor&quot;.</p>
  </li>
  <li>replace_destructor
    <p class="Pp">This is a boolean indicating whether an existing destructor
        should be replaced when inlining a destructor. This defaults to
      false.</p>
  </li>
</ul>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt><b></b><b>$metaclass</b><b>-&gt;immutable_options</b></dt>
  <dd>Returns a hash of the options used when making the class immutable,
      including both defaults and anything supplied by the user in the call to
      <span class="Li">&quot;$metaclass-&gt;make_immutable&quot;</span>. This is
      useful if you need to temporarily make a class mutable and then restore
      immutability as it was before.</dd>
  <dt><b></b><b>$metaclass</b><b>-&gt;make_mutable</b></dt>
  <dd>Calling this method reverse the immutabilization transformation.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Method_Modifiers"><a class="permalink" href="#Method_Modifiers">Method
  Modifiers</a></h2>
<p class="Pp">Method modifiers are hooks which allow a method to be wrapped with
    <i>before</i>, <i>after</i> and <i>around</i> method modifiers. Every time a
    method is called, its modifiers are also called.</p>
<p class="Pp">A class can modify its own methods, as well as methods defined in
    parent classes.</p>
<p class="Pp"><i>How method modifiers work?</i></p>
<p class="Pp">Method modifiers work by wrapping the original method and then
    replacing it in the class's symbol table. The wrappers will handle calling
    all the modifiers in the appropriate order and preserving the calling
    context for the original method.</p>
<p class="Pp">The return values of <span class="Li">&quot;before&quot;</span>
    and <span class="Li">&quot;after&quot;</span> modifiers are ignored. This is
    because their purpose is <b>not</b> to filter the input and output of the
    primary method (this is done with an <i>around</i> modifier).</p>
<p class="Pp">This may seem like an odd restriction to some, but doing this
    allows for simple code to be added at the beginning or end of a method call
    without altering the function of the wrapped method or placing any extra
    responsibility on the code of the modifier.</p>
<p class="Pp">Of course if you have more complex needs, you can use the
    <span class="Li">&quot;around&quot;</span> modifier which allows you to
    change both the parameters passed to the wrapped method, as well as its
    return value.</p>
<p class="Pp">Before and around modifiers are called in
    last-defined-first-called order, while after modifiers are called in
    first-defined-first-called order. So the call tree might looks something
    like this:</p>
<p class="Pp"></p>
<pre>  before 2
   before 1
    around 2
     around 1
      primary
     around 1
    around 2
   after 1
  after 2
</pre>
<p class="Pp"><i>What is the performance impact?</i></p>
<p class="Pp">Of course there is a performance cost associated with method
    modifiers, but we have made every effort to make that cost directly
    proportional to the number of modifier features you use.</p>
<p class="Pp">The wrapping method does its best to <b>only</b> do as much work
    as it absolutely needs to. In order to do this we have moved some of the
    performance costs to set-up time, where they are easier to amortize.</p>
<p class="Pp">All this said, our benchmarks have indicated the following:</p>
<p class="Pp"></p>
<pre>  simple wrapper with no modifiers             100% slower
  simple wrapper with simple before modifier   400% slower
  simple wrapper with simple after modifier    450% slower
  simple wrapper with simple around modifier   500-550% slower
  simple wrapper with all 3 modifiers          1100% slower
</pre>
<p class="Pp">These numbers may seem daunting, but you must remember, every
    feature comes with some cost. To put things in perspective, just doing a
    simple <span class="Li">&quot;AUTOLOAD&quot;</span> which does nothing but
    extract the name of the method called and return it costs about 400% over a
    normal method call.</p>
<dl class="Bl-tag">
  <dt><b></b><b>$metaclass</b><b>-&gt;add_before_method_modifier($method_name,
    </b><b><i>$code</i></b><b>)</b></dt>
  <dd>This wraps the specified method with the supplied subroutine reference.
      The modifier will be called as a method itself, and will receive the same
      arguments as are passed to the method.
    <p class="Pp">When the modifier exits, the wrapped method will be
      called.</p>
    <p class="Pp">The return value of the modifier will be ignored.</p>
  </dd>
  <dt><b></b><b>$metaclass</b><b>-&gt;add_after_method_modifier($method_name,
    </b><b><i>$code</i></b><b>)</b></dt>
  <dd>This wraps the specified method with the supplied subroutine reference.
      The modifier will be called as a method itself, and will receive the same
      arguments as are passed to the method.
    <p class="Pp">When the wrapped methods exits, the modifier will be
      called.</p>
    <p class="Pp">The return value of the modifier will be ignored.</p>
  </dd>
  <dt><b></b><b>$metaclass</b><b>-&gt;add_around_method_modifier($method_name,
    </b><b><i>$code</i></b><b>)</b></dt>
  <dd>This wraps the specified method with the supplied subroutine reference.
    <p class="Pp">The first argument passed to the modifier will be a subroutine
        reference to the wrapped method. The second argument is the object, and
        after that come any arguments passed when the method is called.</p>
    <p class="Pp">The around modifier can choose to call the original method, as
        well as what arguments to pass if it does so.</p>
    <p class="Pp">The return value of the modifier is what will be seen by the
        caller.</p>
  </dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Introspection"><a class="permalink" href="#Introspection">Introspection</a></h2>
<dl class="Bl-tag">
  <dt id="Class::MOP::Class~4"><a class="permalink" href="#Class::MOP::Class~4"><b>Class::MOP::Class-&gt;meta</b></a></dt>
  <dd>This will return a Class::MOP::Class instance for this class.
    <p class="Pp">It should also be noted that Class::MOP will actually
        bootstrap this module by installing a number of attribute meta-objects
        into its metaclass.</p>
  </dd>
</dl>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHORS"><a class="permalink" href="#AUTHORS">AUTHORS</a></h1>
<ul class="Bl-bullet">
  <li>Stevan Little &lt;stevan.little@iinteractive.com&gt;</li>
  <li>Dave Rolsky &lt;autarch@urth.org&gt;</li>
  <li>Jesse Luehrs &lt;doy@tozt.net&gt;</li>
  <li>Shawn M Moore &lt;code@sartak.org&gt;</li>
  <li>XXXX XXX'XX (Yuval Kogman) &lt;nothingmuch@woobling.org&gt;</li>
  <li>Karen Etheridge &lt;ether@cpan.org&gt;</li>
  <li>Florian Ragwitz &lt;rafl@debian.org&gt;</li>
  <li>Hans Dieter Pearcey &lt;hdp@weftsoar.net&gt;</li>
  <li>Chris Prather &lt;chris@prather.org&gt;</li>
  <li>Matt S Trout &lt;mst@shadowcat.co.uk&gt;</li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT_AND_LICENSE"><a class="permalink" href="#COPYRIGHT_AND_LICENSE">COPYRIGHT
  AND LICENSE</a></h1>
<p class="Pp">This software is copyright (c) 2006 by Infinity Interactive,
  Inc..</p>
<p class="Pp">This is free software; you can redistribute it and/or modify it
    under the same terms as the Perl 5 programming language system itself.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2014-01-19</td>
    <td class="foot-os">perl v5.18.4</td>
  </tr>
</table>
</body>
</html>
