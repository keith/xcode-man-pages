<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>DBIx::Class::Storage::DBI::Replicated(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">DBIx::Class::Storage::DBI::Replicated(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">DBIx::Class::Storage::DBI::Replicated(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
DBIx::Class::Storage::DBI::Replicated - BETA Replicated database support
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
The Following example shows how to change an existing
  <span class="Li">$schema</span> to a replicated storage type, add some
  replicated (read-only) databases, and perform reporting tasks.
<p class="Pp">You should set the 'storage_type attribute to a replicated type.
    You should also define your arguments, such as which balancer you want and
    any arguments that the Pool object should get.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  my $schema = Schema::Class-&gt;clone;
  $schema-&gt;storage_type( ['::DBI::Replicated', {balancer=&gt;'::Random'}] );
  $schema-&gt;connection(...);
</pre>
<p class="Pp">Next, you need to add in the Replicants. Basically this is an
    array of arrayrefs, where each arrayref is database connect information.
    Think of these arguments as what you'd pass to the 'normal'
    <span class="Li">$schema</span>-&gt;connect method.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  $schema-&gt;storage-&gt;connect_replicants(
    [$dsn1, $user, $pass, \%opts],
    [$dsn2, $user, $pass, \%opts],
    [$dsn3, $user, $pass, \%opts],
  );
</pre>
<p class="Pp">Now, just use the <span class="Li">$schema</span> as you normally
    would. Automatically all reads will be delegated to the replicants, while
    writes to the master.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  $schema-&gt;resultset('Source')-&gt;search({name=&gt;'etc'});
</pre>
<p class="Pp">You can force a given query to use a particular storage using the
    search attribute 'force_pool'. For example:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  my $rs = $schema-&gt;resultset('Source')-&gt;search(undef, {force_pool=&gt;'master'});
</pre>
<p class="Pp">Now <span class="Li">$rs</span> will force everything (both reads
    and writes) to use whatever was setup as the master storage. 'master' is
    hardcoded to always point to the Master, but you can also use any Replicant
    name. Please see: DBIx::Class::Storage::DBI::Replicated::Pool and the
    replicants attribute for more.</p>
<p class="Pp">Also see transactions and &quot;execute_reliably&quot; for
    alternative ways to force read traffic to the master. In general, you should
    wrap your statements in a transaction when you are reading and writing to
    the same tables at the same time, since your replicants will often lag a bit
    behind the master.</p>
<p class="Pp">If you have a multi-statement read only transaction you can force
    it to select a random server in the pool by:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  my $rs = $schema-&gt;resultset('Source')-&gt;search( undef,
    { force_pool =&gt; $db-&gt;storage-&gt;read_handler-&gt;next_storage }
  );
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
Warning: This class is marked BETA. This has been running a production website
  using MySQL native replication as its backend and we have some decent test
  coverage but the code hasn't yet been stressed by a variety of databases.
  Individual DBs may have quirks we are not aware of. Please use this in first
  development and pass along your experiences/bug fixes.
<p class="Pp">This class implements replicated data store for DBI. Currently you
    can define one master and numerous slave database connections. All
    write-type queries (INSERT, UPDATE, DELETE and even LAST_INSERT_ID) are
    routed to master database, all read-type queries (SELECTs) go to the slave
    database.</p>
<p class="Pp">Basically, any method request that DBIx::Class::Storage::DBI would
    normally handle gets delegated to one of the two attributes:
    &quot;read_handler&quot; or to &quot;write_handler&quot;. Additionally, some
    methods need to be distributed to all existing storages. This way our
    storage class is a drop in replacement for DBIx::Class::Storage::DBI.</p>
<p class="Pp">Read traffic is spread across the replicants (slaves) occurring to
    a user selected algorithm. The default algorithm is random weighted.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="NOTES"><a class="permalink" href="#NOTES">NOTES</a></h1>
The consistency between master and replicants is database specific. The Pool
  gives you a method to validate its replicants, removing and replacing them
  when they fail/pass predefined criteria. Please make careful use of the ways
  to force a query to run against Master when needed.
</section>
<section class="Sh">
<h1 class="Sh" id="REQUIREMENTS"><a class="permalink" href="#REQUIREMENTS">REQUIREMENTS</a></h1>
Replicated Storage has additional requirements not currently part of
  DBIx::Class. See DBIx::Class::Optional::Dependencies for more details.
</section>
<section class="Sh">
<h1 class="Sh" id="ATTRIBUTES"><a class="permalink" href="#ATTRIBUTES">ATTRIBUTES</a></h1>
This class defines the following attributes.
<section class="Ss">
<h2 class="Ss" id="schema"><a class="permalink" href="#schema">schema</a></h2>
The underlying DBIx::Class::Schema object this storage is attaching
</section>
<section class="Ss">
<h2 class="Ss" id="pool_type"><a class="permalink" href="#pool_type">pool_type</a></h2>
Contains the classname which will instantiate the &quot;pool&quot; object.
  Defaults to: DBIx::Class::Storage::DBI::Replicated::Pool.
</section>
<section class="Ss">
<h2 class="Ss" id="pool_args"><a class="permalink" href="#pool_args">pool_args</a></h2>
Contains a hashref of initialized information to pass to the Balancer object.
  See DBIx::Class::Storage::DBI::Replicated::Pool for available arguments.
</section>
<section class="Ss">
<h2 class="Ss" id="balancer_type"><a class="permalink" href="#balancer_type">balancer_type</a></h2>
The replication pool requires a balance class to provider the methods for choose
  how to spread the query load across each replicant in the pool.
</section>
<section class="Ss">
<h2 class="Ss" id="balancer_args"><a class="permalink" href="#balancer_args">balancer_args</a></h2>
Contains a hashref of initialized information to pass to the Balancer object.
  See DBIx::Class::Storage::DBI::Replicated::Balancer for available arguments.
</section>
<section class="Ss">
<h2 class="Ss" id="pool"><a class="permalink" href="#pool">pool</a></h2>
Is a DBIx::Class::Storage::DBI::Replicated::Pool or derived class. This is a
  container class for one or more replicated databases.
</section>
<section class="Ss">
<h2 class="Ss" id="balancer"><a class="permalink" href="#balancer">balancer</a></h2>
Is a DBIx::Class::Storage::DBI::Replicated::Balancer or derived class. This is a
  class that takes a pool (DBIx::Class::Storage::DBI::Replicated::Pool)
</section>
<section class="Ss">
<h2 class="Ss" id="master"><a class="permalink" href="#master">master</a></h2>
The master defines the canonical state for a pool of connected databases. All
  the replicants are expected to match this databases state. Thus, in a classic
  Master / Slaves distributed system, all the slaves are expected to replicate
  the Master's state as quick as possible. This is the only database in the pool
  of databases that is allowed to handle write traffic.
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="ATTRIBUTES_IMPLEMENTING_THE_DBIx::Storage::DBI_INTERFACE"><a class="permalink" href="#ATTRIBUTES_IMPLEMENTING_THE_DBIx::Storage::DBI_INTERFACE">ATTRIBUTES
  IMPLEMENTING THE DBIx::Storage::DBI INTERFACE</a></h1>
The following methods are delegated all the methods required for the
  DBIx::Class::Storage::DBI interface.
<section class="Ss">
<h2 class="Ss" id="read_handler"><a class="permalink" href="#read_handler">read_handler</a></h2>
Defines an object that implements the read side of BIx::Class::Storage::DBI.
</section>
<section class="Ss">
<h2 class="Ss" id="write_handler"><a class="permalink" href="#write_handler">write_handler</a></h2>
Defines an object that implements the write side of BIx::Class::Storage::DBI, as
  well as methods that don't write or read that can be called on only one
  storage, methods that return a <span class="Li">$dbh</span>, and any methods
  that don't make sense to run on a replicant.
</section>
<section class="Ss">
<h2 class="Ss" id="around:_connect_info"><a class="permalink" href="#around:_connect_info">around:
  connect_info</a></h2>
Preserves master's <span class="Li">&quot;connect_info&quot;</span> options (for
  merging with replicants.) Also sets any Replicated-related options from
  connect_info, such as <span class="Li">&quot;pool_type&quot;</span>,
  <span class="Li">&quot;pool_args&quot;</span>,
  <span class="Li">&quot;balancer_type&quot;</span> and
  <span class="Li">&quot;balancer_args&quot;</span>.
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="METHODS"><a class="permalink" href="#METHODS">METHODS</a></h1>
This class defines the following methods.
<section class="Ss">
<h2 class="Ss" id="_s-1BUILDARGS_s0"><a class="permalink" href="#_s-1BUILDARGS_s0">BUILDARGS</a></h2>
DBIx::Class::Schema when instantiating its storage passed itself as the first
  argument. So we need to massage the arguments a bit so that all the bits get
  put into the correct places.
</section>
<section class="Ss">
<h2 class="Ss" id="_build_master"><a class="permalink" href="#_build_master">_build_master</a></h2>
Lazy builder for the &quot;master&quot; attribute.
</section>
<section class="Ss">
<h2 class="Ss" id="_build_pool"><a class="permalink" href="#_build_pool">_build_pool</a></h2>
Lazy builder for the &quot;pool&quot; attribute.
</section>
<section class="Ss">
<h2 class="Ss" id="_build_balancer"><a class="permalink" href="#_build_balancer">_build_balancer</a></h2>
Lazy builder for the &quot;balancer&quot; attribute. This takes a Pool object so
  that the balancer knows which pool it's balancing.
</section>
<section class="Ss">
<h2 class="Ss" id="_build_write_handler"><a class="permalink" href="#_build_write_handler">_build_write_handler</a></h2>
Lazy builder for the &quot;write_handler&quot; attribute. The default is to set
  this to the &quot;master&quot;.
</section>
<section class="Ss">
<h2 class="Ss" id="_build_read_handler"><a class="permalink" href="#_build_read_handler">_build_read_handler</a></h2>
Lazy builder for the &quot;read_handler&quot; attribute. The default is to set
  this to the &quot;balancer&quot;.
</section>
<section class="Ss">
<h2 class="Ss" id="around:_connect_replicants"><a class="permalink" href="#around:_connect_replicants">around:
  connect_replicants</a></h2>
All calls to connect_replicants needs to have an existing
  <span class="Li">$schema</span> tacked onto top of the args, since
  DBIx::Storage::DBI needs it, and any
  <span class="Li">&quot;connect_info&quot;</span> options merged with the
  master, with replicant opts having higher priority.
</section>
<section class="Ss">
<h2 class="Ss" id="all_storages"><a class="permalink" href="#all_storages">all_storages</a></h2>
Returns an array of all the connected storage backends. The first element in the
  returned array is the master, and the rest are each of the replicants.
</section>
<section class="Ss">
<h2 class="Ss" id="execute_reliably_($coderef,_?@args)"><a class="permalink" href="#execute_reliably_($coderef,_?@args)">execute_reliably
  ($coderef, ?@args)</a></h2>
Given a coderef, saves the current state of the &quot;read_handler&quot;, forces
  it to use reliable storage (e.g. sets it to the master), executes a coderef
  and then restores the original state.
<p class="Pp">Example:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  my $reliably = sub {
    my $name = shift @_;
    $schema-&gt;resultset('User')-&gt;create({name=&gt;$name});
    my $user_rs = $schema-&gt;resultset('User')-&gt;find({name=&gt;$name});
    return $user_rs;
  };

  my $user_rs = $schema-&gt;storage-&gt;execute_reliably($reliably, 'John');
</pre>
<p class="Pp">Use this when you must be certain of your database state, such as
    when you just inserted something and need to get a resultset including it,
    etc.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="set_reliable_storage"><a class="permalink" href="#set_reliable_storage">set_reliable_storage</a></h2>
Sets the current <span class="Li">$schema</span> to be 'reliable', that is all
  queries, both read and write are sent to the master
</section>
<section class="Ss">
<h2 class="Ss" id="set_balanced_storage"><a class="permalink" href="#set_balanced_storage">set_balanced_storage</a></h2>
Sets the current <span class="Li">$schema</span> to be use the &lt;/balancer&gt;
  for all reads, while all writes are sent to the master only
</section>
<section class="Ss">
<h2 class="Ss" id="connected"><a class="permalink" href="#connected">connected</a></h2>
Check that the master and at least one of the replicants is connected.
</section>
<section class="Ss">
<h2 class="Ss" id="ensure_connected"><a class="permalink" href="#ensure_connected">ensure_connected</a></h2>
Make sure all the storages are connected.
</section>
<section class="Ss">
<h2 class="Ss" id="limit_dialect"><a class="permalink" href="#limit_dialect">limit_dialect</a></h2>
Set the limit_dialect for all existing storages
</section>
<section class="Ss">
<h2 class="Ss" id="quote_char"><a class="permalink" href="#quote_char">quote_char</a></h2>
Set the quote_char for all existing storages
</section>
<section class="Ss">
<h2 class="Ss" id="name_sep"><a class="permalink" href="#name_sep">name_sep</a></h2>
Set the name_sep for all existing storages
</section>
<section class="Ss">
<h2 class="Ss" id="set_schema"><a class="permalink" href="#set_schema">set_schema</a></h2>
Set the schema object for all existing storages
</section>
<section class="Ss">
<h2 class="Ss" id="debug"><a class="permalink" href="#debug">debug</a></h2>
set a debug flag across all storages
</section>
<section class="Ss">
<h2 class="Ss" id="debugobj"><a class="permalink" href="#debugobj">debugobj</a></h2>
set a debug object
</section>
<section class="Ss">
<h2 class="Ss" id="debugfh"><a class="permalink" href="#debugfh">debugfh</a></h2>
set a debugfh object
</section>
<section class="Ss">
<h2 class="Ss" id="debugcb"><a class="permalink" href="#debugcb">debugcb</a></h2>
set a debug callback
</section>
<section class="Ss">
<h2 class="Ss" id="disconnect"><a class="permalink" href="#disconnect">disconnect</a></h2>
disconnect everything
</section>
<section class="Ss">
<h2 class="Ss" id="cursor_class"><a class="permalink" href="#cursor_class">cursor_class</a></h2>
set cursor class on all storages, or return master's
</section>
<section class="Ss">
<h2 class="Ss" id="cursor"><a class="permalink" href="#cursor">cursor</a></h2>
set cursor class on all storages, or return master's, alias for
  &quot;cursor_class&quot; above.
</section>
<section class="Ss">
<h2 class="Ss" id="unsafe"><a class="permalink" href="#unsafe">unsafe</a></h2>
sets the &quot;unsafe&quot; in DBIx::Class::Storage::DBI option on all storages
  or returns master's current setting
</section>
<section class="Ss">
<h2 class="Ss" id="disable_sth_caching"><a class="permalink" href="#disable_sth_caching">disable_sth_caching</a></h2>
sets the &quot;disable_sth_caching&quot; in DBIx::Class::Storage::DBI option on
  all storages or returns master's current setting
</section>
<section class="Ss">
<h2 class="Ss" id="lag_behind_master"><a class="permalink" href="#lag_behind_master">lag_behind_master</a></h2>
returns the highest Replicant &quot;lag_behind_master&quot; in
  DBIx::Class::Storage::DBI setting
</section>
<section class="Ss">
<h2 class="Ss" id="is_replicating"><a class="permalink" href="#is_replicating">is_replicating</a></h2>
returns true if all replicants return true for &quot;is_replicating&quot; in
  DBIx::Class::Storage::DBI
</section>
<section class="Ss">
<h2 class="Ss" id="connect_call_datetime_setup"><a class="permalink" href="#connect_call_datetime_setup">connect_call_datetime_setup</a></h2>
calls &quot;connect_call_datetime_setup&quot; in DBIx::Class::Storage::DBI for
  all storages
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="GOTCHAS"><a class="permalink" href="#GOTCHAS">GOTCHAS</a></h1>
Due to the fact that replicants can lag behind a master, you must take care to
  make sure you use one of the methods to force read queries to a master should
  you need realtime data integrity. For example, if you insert a row, and then
  immediately re-read it from the database (say, by doing
  <span class="Li">$result</span>-&gt;discard_changes) or you insert a row and
  then immediately build a query that expects that row to be an item, you should
  force the master to handle reads. Otherwise, due to the lag, there is no
  certainty your data will be in the expected state.
<p class="Pp">For data integrity, all transactions automatically use the master
    storage for all read and write queries. Using a transaction is the preferred
    and recommended method to force the master to handle all read queries.</p>
<p class="Pp">Otherwise, you can force a single query to use the master with the
    'force_pool' attribute:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  my $result = $resultset-&gt;search(undef, {force_pool=&gt;'master'})-&gt;find($pk);
</pre>
<p class="Pp">This attribute will safely be ignore by non replicated storages,
    so you can use the same code for both types of systems.</p>
<p class="Pp">Lastly, you can use the &quot;execute_reliably&quot; method, which
    works very much like a transaction.</p>
<p class="Pp">For debugging, you can turn replication on/off with the methods
    &quot;set_reliable_storage&quot; and &quot;set_balanced_storage&quot;,
    however this operates at a global level and is not suitable if you have a
    shared Schema object being used by multiple processes, such as on a web
    application server. You can get around this limitation by using the Schema
    clone method.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  my $new_schema = $schema-&gt;clone;
  $new_schema-&gt;set_reliable_storage;

  ## $new_schema will use only the Master storage for all reads/writes while
  ## the $schema object will use replicated storage.
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<span class="Li"></span>
<pre>
  John Napiorkowski &lt;john.napiorkowski@takkle.com&gt;
</pre>
<p class="Pp">Based on code originated by:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  Norbert Csongradi &lt;bert@cpan.org&gt;
  Peter Siklosi &lt;einon@einon.hu&gt;
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="LICENSE"><a class="permalink" href="#LICENSE">LICENSE</a></h1>
You may distribute this code under the same terms as Perl itself.
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2014-01-22</td>
    <td class="foot-os">perl v5.18.4</td>
  </tr>
</table>
</body>
</html>
