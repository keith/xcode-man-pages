<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Copyright (c) Mark J. Kilgard, 1996.
   -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>glutEstablishOverlay(3GLUT)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">glutEstablishOverlay(3GLUT)</td>
    <td class="head-vol">GLUT</td>
    <td class="head-rtitle">glutEstablishOverlay(3GLUT)</td>
  </tr>
</table>
<div class="manual-text">
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
glutEstablishOverlay - establishes an overlay (if possible) for the current
  window.
</section>
<section class="Sh">
<h1 class="Sh" id="SYNTAX"><a class="permalink" href="#SYNTAX">SYNTAX</a></h1>
<pre>
#include &lt;GLUT/glut.h&gt;
</pre>
<pre>
void glutEstablishOverlay(void);
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
glutEstablishOverlay establishes an overlay (if possible) for the current
  window. The requested display mode for the overlay is determined by the
  initial display mode. glutLayerGet(GLUT_OVERLAY_POSSIBLE) can be called to
  determine if an overlay is possible for the current window with the current
  initial display mode. Do not attempt to establish an overlay when one is not
  possible; GLUT will terminate the program.
<p class="Pp">If glutEstablishOverlay is called when an overlay already exists,
    the existing overlay is first removed, and then a new overlay is
    established. The state of the old overlay's OpenGL context is discarded.</p>
<p class="Pp">The initial display state of an overlay is shown, however the
    overlay is only actually shown if the overlay's window is shown.</p>
<p class="Pp">Implicitly, the window's layer in use changes to the overlay
    immediately after the overlay is established.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="EXAMPLE"><a class="permalink" href="#EXAMPLE">EXAMPLE</a></h1>
Establishing an overlay is a bit involved, but easy once you get the hang of it.
  Here is an example:
<pre>
  int overlaySupport;
  int transparent, red, white;
  glutInitDisplayMode(GLUT_SINGLE | GLUT_INDEX);
  overlaySupport = glutLayerGet(GLUT_OVERLAY_POSSIBLE);
  if (overlaySupport) {
    glutEstablishOverlay();
    glutHideOverlay();
    transparent = glutLayerGet(GLUT_TRANSPARENT_INDEX);
    glClearIndex(transparent);
    red = (transparent + 1) % glutGet(GLUT_WINDOW_COLORMAP_SIZE);
    white = (transparent + 2) % glutGet(GLUT_WINDOW_COLORMAP_SIZE);
    glutSetColor(red, 1.0, 0.0, 0.0);  /* Red. */
    glutSetColor(white, 1.0, 1.0, 1.0);  /* White. */
    glutOverlayDisplayFunc(redrawOverlay);
    glutReshapeFunc(reshape);
  } else {
    printf(&quot;Sorry, no nifty overlay (try an SGI workstation)!0);
  }
</pre>
<p class="Pp">If you setup an overlay and you install a reshape callback, you
    need to update the viewports and possibly projection matrices of both the
    normal plane and the overlay. For example, your reshape callback might look
    like this:</p>
<pre>
  void
  reshape(int w, int h)
  {
    if (overlaySupport) {
      glutUseLayer(GLUT_OVERLAY);
      /* Setup overlay to have X style coordinate system. */
      glViewport(0, 0, w, h);
      glMatrixMode(GL_PROJECTION);
      glLoadIdentity();
      gluOrtho2D(0, w, 0, h);
      glScalef(1, -1, 1);
      glTranslatef(0, -h, 0);
      glMatrixMode(GL_MODELVIEW);
      glutUseLayer(GLUT_NORMAL);
    }
    glViewport(0, 0, w, h);
  }
</pre>
<p class="Pp">See the glutOverlayDisplayFunc man page for an example showing one
    way to write your overlay display callback.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="X_IMPLEMENTATION_NOTES"><a class="permalink" href="#X_IMPLEMENTATION_NOTES">X
  IMPLEMENTATION NOTES</a></h1>
GLUT for X uses the SERVER_OVERLAY_VISUALS convention is used to determine if
  overlay visuals are available. While the convention allows for opaque overlays
  (no transparency) and overlays with the transparency specified as a bitmask,
  GLUT overlay management only provides access to transparent pixel overlays.
<p class="Pp">Until RGBA overlays are better understood, GLUT only supports
    color index overlays.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
glutUseLayer, glutRemoveLayer, glutCreateWindow, glutPostOverlayRedisplay,
  glutShowOverlay, glutOverlayDisplayFunc
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
Mark J. Kilgard (mjk@nvidia.com)
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">3.7</td>
    <td class="foot-os">GLUT</td>
  </tr>
</table>
</body>
</html>
