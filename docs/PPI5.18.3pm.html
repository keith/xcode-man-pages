<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>PPI(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">PPI(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">PPI(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
PPI - Parse, Analyze and Manipulate Perl (without perl)
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<span class="Li"></span>
<pre>
  use PPI;
  
  # Create a new empty document
  my $Document = PPI::Document-&gt;new;
  
  # Create a document from source
  $Document = PPI::Document-&gt;new(\'print &quot;Hello World!\n&quot;');
  
  # Load a Document from a file
  $Document = PPI::Document-&gt;new('Module.pm');
  
  # Does it contain any POD?
  if ( $Document-&gt;find_any('PPI::Token::Pod') ) {
      print &quot;Module contains POD\n&quot;;
  }
  
  # Get the name of the main package
  $pkg = $Document-&gt;find_first('PPI::Statement::Package')-&gt;namespace;
  
  # Remove all that nasty documentation
  $Document-&gt;prune('PPI::Token::Pod');
  $Document-&gt;prune('PPI::Token::Comment');
  
  # Save the file
  $Document-&gt;save('Module.pm.stripped');
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<section class="Ss">
<h2 class="Ss" id="About_this_Document"><a class="permalink" href="#About_this_Document">About
  this Document</a></h2>
This is the PPI manual. It describes its reason for existing, its general
  structure, its use, an overview of the API, and provides a few implementation
  samples.
</section>
<section class="Ss">
<h2 class="Ss" id="Background"><a class="permalink" href="#Background">Background</a></h2>
The ability to read, and manipulate Perl (the language) programmatically other
  than with perl (the application) was one that caused difficulty for a long
  time.
<p class="Pp">The cause of this problem was Perl's complex and dynamic grammar.
    Although there is typically not a huge diversity in the grammar of most Perl
    code, certain issues cause large problems when it comes to parsing.</p>
<p class="Pp">Indeed, quite early in Perl's history Tom Christenson introduced
    the Perl community to the quote <i>&quot;Nothing but perl can parse
    Perl&quot;</i>, or as it is more often stated now as a truism:</p>
<p class="Pp"><b>&quot;Only perl can parse Perl&quot;</b></p>
<p class="Pp">One example of the sorts of things the prevent Perl being easily
    parsed are function signatures, as demonstrated by the following.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  @result = (dothis $foo, $bar);
  
  # Which of the following is it equivalent to?
  @result = (dothis($foo), $bar);
  @result = dothis($foo, $bar);
</pre>
<p class="Pp">The first line above can be interpreted in two different ways,
    depending on whether the <span class="Li">&amp;dothis</span> function is
    expecting one argument, or two, or several.</p>
<p class="Pp">A &quot;code parser&quot; (something that parses for the purpose
    of execution) such as perl needs information that is not found in the
    immediate vicinity of the statement being parsed.</p>
<p class="Pp">The information might not just be elsewhere in the file, it might
    not even be in the same file at all. It might also not be able to determine
    this information without the prior execution of a
    <span class="Li">&quot;BEGIN {}&quot;</span> block, or the loading and
    execution of one or more external modules. Or worse the &amp;dothis function
    may not even have been written yet.</p>
<p class="Pp"><b>When parsing Perl as code, you must also execute it</b></p>
<p class="Pp">Even perl itself never really fully understands the structure of
    the source code after and indeed <b>as</b> it processes it, and in that
    sense doesn't &quot;parse&quot; Perl source into anything remotely like a
    structured document. This makes it of no real use for any task that needs to
    treat the source code as a document, and do so reliably and robustly.</p>
<p class="Pp">For more information on why it is impossible to parse perl, see
    Randal Schwartz's seminal response to the question of &quot;Why can't you
    parse Perl&quot;.</p>
<p class="Pp">&lt;http://www.perlmonks.org/index.pl?node_id=44722&gt;</p>
<p class="Pp">The purpose of PPI is <b>not</b> to parse Perl <i>Code</i>, but to
    parse Perl <i>Documents</i>. By treating the problem this way, we are able
    to parse a single file containing Perl source code &quot;isolated&quot; from
    any other resources, such as libraries upon which the code may depend, and
    without needing to run an instance of perl alongside or inside the
  parser.</p>
<p class="Pp">Historically, using an embedded perl parser was widely considered
    to be the most likely avenue for finding a solution to
    <span class="Li">&quot;Parse::Perl&quot;</span>. It was investigated from
    time to time and attempts have generally failed or suffered from
    sufficiently bad corner cases that they were abandoned.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="What_Does__s-1PPI_s0_Stand_For?"><a class="permalink" href="#What_Does__s-1PPI_s0_Stand_For?">What
  Does PPI Stand For?</a></h2>
<span class="Li">&quot;PPI&quot;</span> is an acronym for the longer original
  module name <span class="Li">&quot;Parse::Perl::Isolated&quot;</span>. And in
  the spirit or the silly acronym games played by certain unnamed Open Source
  projects you may have <i>hurd</i> of, it also a reverse backronym of &quot;I
  Parse Perl&quot;.
<p class="Pp">Of course, I could just be lying and have just made that second
    bit up 10 minutes before the release of PPI 1.000. Besides, <b>all</b> the
    cool Perl packages have TLAs (Three Letter Acronyms). It's a rule or
    something.</p>
<p class="Pp">Why don't you just think of it as the <b>Perl Parsing
    Interface</b> for simplicity.</p>
<p class="Pp">The original name was shortened to prevent the author (and you the
    users) from contracting RSI by having to type crazy things like
    <span class="Li">&quot;Parse::Perl::Isolated::Token::QuoteLike::Backtick&quot;</span>
    100 times a day.</p>
<p class="Pp">In acknowledgment that someone may some day come up with a valid
    solution for the grammar problem it was decided at the commencement of the
    project to leave the <span class="Li">&quot;Parse::Perl&quot;</span>
    namespace free for any such effort.</p>
<p class="Pp">Since that time I've been able to prove to my own satisfaction
    that it <b>is</b> truly impossible to accurately parse Perl as both code and
    document at once. For the academics, parsing Perl suffers from the
    &quot;Halting Problem&quot;.</p>
<p class="Pp">With this in mind <span class="Li">&quot;Parse::Perl&quot;</span>
    has now been co-opted as the title for the SourceForge project that
    publishes PPI and a large collection of other applications and modules
    related to the (document) parsing of Perl source code.</p>
<p class="Pp">You can find this project at
    &lt;http://sf.net/projects/parseperl&gt;, however we no longer use the
    SourceForge CVS server. Instead, the current development version of PPI is
    available via SVN at &lt;http://svn.ali.as/cpan/trunk/PPI/&gt;.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Why_Parse_Perl?"><a class="permalink" href="#Why_Parse_Perl?">Why
  Parse Perl?</a></h2>
Once you can accept that we will never be able to parse Perl well enough to meet
  the standards of things that treat Perl as code, it is worth re-examining
  <span class="Li">&quot;why&quot;</span> we want to &quot;parse&quot; Perl at
  all.
<p class="Pp">What are the things that people might want a &quot;Perl
    parser&quot; for.</p>
<dl class="Bl-tag">
  <dt>Documentation</dt>
  <dd>Analyzing the contents of a Perl document to automatically generate
      documentation, in parallel to, or as a replacement for, POD documentation.
    <p class="Pp">Allow an indexer to to locate and process all the comments and
        documentation from code for &quot;full text search&quot;
      applications.</p>
  </dd>
  <dt>Structural and Quality Analysis</dt>
  <dd>Determine quality or other metrics across a body of code, and identify
      situations relating to particular phrases, techniques or locations.
    <p class="Pp">Index functions, variables and packages within Perl code, and
        doing search and graph (in the node/edge sense) analysis of large code
        bases.</p>
  </dd>
  <dt>Refactoring</dt>
  <dd>Make structural, syntax, or other changes to code in an automated manner,
      either independently or in assistance to an editor. This sort of task list
      includes backporting, forward porting, partial evaluation,
      &quot;improving&quot; code, or whatever. All the sort of things you'd want
      from a Perl::Editor.</dd>
  <dt>Layout</dt>
  <dd>Change the layout of code without changing its meaning. This includes
      techniques such as tidying (like perltidy), obfuscation, compressing and
      &quot;squishing&quot;, or to implement formatting preferences or
    policies.</dd>
  <dt>Presentation</dt>
  <dd>This includes methods of improving the presentation of code, without
      changing the content of the code. Modify, improve, syntax colour etc the
      presentation of a Perl document. Generating &quot;IntelliText&quot;-like
      functions.</dd>
</dl>
<p class="Pp">If we treat this as a baseline for the sort of things we are going
    to have to build on top of Perl, then it becomes possible to identify a
    standard for how good a Perl parser needs to be.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="How_good_is_Good_Enough(_s-1TM_s0)"><a class="permalink" href="#How_good_is_Good_Enough(_s-1TM_s0)">How
  good is Good Enough(TM)</a></h2>
PPI seeks to be good enough to achieve all of the above tasks, or to provide a
  sufficiently good API on which to allow others to implement modules in these
  and related areas.
<p class="Pp">However, there are going to be limits to this process. Because PPI
    cannot adapt to changing grammars, any code written using source filters
    should not be assumed to be parsable.</p>
<p class="Pp">At one extreme, this includes anything munged by Acme::Bleach, as
    well as (arguably) more common cases like Switch. We do not pretend to be
    able to always parse code using these modules, although as long as it still
    follows a format that looks like Perl syntax, it may be possible to extend
    the lexer to handle them.</p>
<p class="Pp">The ability to extend PPI to handle lexical additions to the
    language is on the drawing board to be done some time post-1.0</p>
<p class="Pp">The goal for success was originally to be able to successfully
    parse 99% of all Perl documents contained in CPAN. This means the entire
    file in each case.</p>
<p class="Pp">PPI has succeeded in this goal far beyond the expectations of even
    the author. At time of writing there are only 28 non-Acme Perl modules in
    CPAN that PPI is incapable of parsing. Most of these are so badly broken
    they do not compile as Perl code anyway.</p>
<p class="Pp">So unless you are actively going out of your way to break PPI, you
    should expect that it will handle your code just fine.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Internationalisation"><a class="permalink" href="#Internationalisation">Internationalisation</a></h2>
PPI provides partial support for internationalisation and localisation.
<p class="Pp">Specifically, it allows the use characters from the Latin-1
    character set to be used in quotes, comments, and POD. Primarily, this
    covers languages from Europe and South America.</p>
<p class="Pp">PPI does <b>not</b> currently provide support for Unicode,
    although there is an initial implementation available in a development
    branch from CVS.</p>
<p class="Pp">If you need Unicode support, and would like to help stress test
    the Unicode support so we can move it to the main branch and enable it in
    the main release should contact the author. (contact details below)</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Round_Trip_Safe"><a class="permalink" href="#Round_Trip_Safe">Round
  Trip Safe</a></h2>
When PPI parses a file it builds <b>everything</b> into the model, including
  whitespace. This is needed in order to make the Document fully &quot;Round
  Trip&quot; safe.
<p class="Pp">The general concept behind a &quot;Round Trip&quot; parser is that
    it knows what it is parsing is somewhat uncertain, and so <b>expects</b> to
    get things wrong from time to time. In the cases where it parses code
    wrongly the tree will serialize back out to the same string of code that was
    read in, repairing the parser's mistake as it heads back out to the
  file.</p>
<p class="Pp">The end result is that if you parse in a file and serialize it
    back out without changing the tree, you are guaranteed to get the same file
    you started with. PPI does this correctly and reliably for 100% of all known
    cases.</p>
<p class="Pp"><b>What goes in, will come out. Every time.</b></p>
<p class="Pp">The one minor exception at this time is that if the newlines for
    your file are wrong (meaning not matching the platform newline format), PPI
    will localise them for you. (It isn't to be convenient, supporting arbitrary
    newlines would make some of the code more complicated)</p>
<p class="Pp">Better control of the newline type is on the wish list though, and
    anyone wanting to help out is encouraged to contact the author.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="IMPLEMENTATION"><a class="permalink" href="#IMPLEMENTATION">IMPLEMENTATION</a></h1>
<section class="Ss">
<h2 class="Ss" id="General_Layout"><a class="permalink" href="#General_Layout">General
  Layout</a></h2>
PPI is built upon two primary &quot;parsing&quot; components, PPI::Tokenizer and
  PPI::Lexer, and a large tree of about 50 classes which implement the various
  the <i>Perl Document Object Model</i> (PDOM).
<p class="Pp">The PDOM is conceptually similar in style and intent to the
    regular DOM or other code Abstract Syntax Trees (ASTs), but contains some
    differences to handle perl-specific cases, and to assist in treating the
    code as a document. Please note that it is <b>not</b> an implementation of
    the official Document Object Model specification, only somewhat similar to
    it.</p>
<p class="Pp">On top of the Tokenizer, Lexer and the classes of the PDOM, sit a
    number of classes intended to make life a little easier when dealing with
    PDOM trees.</p>
<p class="Pp">Both the major parsing components were hand-coded from scratch
    with only plain Perl code and a few small utility modules. There are no
    grammar or patterns mini-languages, no YACC or LEX style tools and only a
    small number of regular expressions.</p>
<p class="Pp">This is primarily because of the sheer volume of accumulated cruft
    that exists in Perl. Not even perl itself is capable of parsing Perl
    documents (remember, it just parses and executes it as code).</p>
<p class="Pp">As a result, PPI needed to be cruftier than perl itself. Feel free
    to shudder at this point, and hope you never have to understand the
    Tokenizer codebase. Speaking of which...</p>
</section>
<section class="Ss">
<h2 class="Ss" id="The_Tokenizer"><a class="permalink" href="#The_Tokenizer">The
  Tokenizer</a></h2>
The Tokenizer takes source code and converts it into a series of tokens. It does
  this using a slow but thorough character by character manual process, rather
  than using a pattern system or complex regexes.
<p class="Pp">Or at least it does so conceptually. If you were to actually trace
    the code you would find it's not truly character by character due to a
    number of regexps and optimisations throughout the code. This lets the
    Tokenizer &quot;skip ahead&quot; when it can find shortcuts, so it tends to
    jump around a line a bit wildly at times.</p>
<p class="Pp">In practice, the number of times the Tokenizer will
    <b>actually</b> move the character cursor itself is only about 5% - 10%
    higher than the number of tokens contained in the file. This makes it about
    as optimal as it can be made without implementing it in something other than
    Perl.</p>
<p class="Pp">In 2001 when PPI was started, this structure made PPI quite slow,
    and not really suitable for interactive tasks. This situation has improved
    greatly with multi-gigahertz processors, but can still be painful when
    working with very large files.</p>
<p class="Pp">The target parsing rate for PPI is about 5000 lines per gigacycle.
    It is currently believed to be at about 1500, and main avenue for making it
    to the target speed has now become PPI::XS, a drop-in XS accelerator for
    PPI.</p>
<p class="Pp">Since PPI::XS has only just gotten off the ground and is currently
    only at proof-of-concept stage, this may take a little while. Anyone
    interested in helping out with PPI::XS is <b>highly</b> encouraged to
    contact the author. In fact, the design of PPI::XS means it's possible to
    port one function at a time safely and reliably. So every little bit will
    help.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="The_Lexer"><a class="permalink" href="#The_Lexer">The
  Lexer</a></h2>
The Lexer takes a token stream, and converts it to a lexical tree. Because we
  are parsing Perl <b>documents</b> this includes whitespace, comments, and all
  number of weird things that have no relevance when code is actually executed.
<p class="Pp">An instantiated PPI::Lexer consumes PPI::Tokenizer objects and
    produces PPI::Document objects. However you should probably never be working
    with the Lexer directly. You should just be able to create PPI::Document
    objects and work with them directly.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="The_Perl_Document_Object_Model"><a class="permalink" href="#The_Perl_Document_Object_Model">The
  Perl Document Object Model</a></h2>
The PDOM is a structured collection of data classes that together provide a
  correct and scalable model for documents that follow the standard Perl syntax.
</section>
<section class="Ss">
<h2 class="Ss" id="The__s-1PDOM_s0_Class_Tree"><a class="permalink" href="#The__s-1PDOM_s0_Class_Tree">The
  PDOM Class Tree</a></h2>
The following lists all of the 67 current PDOM classes, listing with indentation
  based on inheritance.
<p class="Pp"><span class="Li"></span></p>
<pre>
   PPI::Element
      PPI::Node
         PPI::Document
            PPI::Document::Fragment
         PPI::Statement
            PPI::Statement::Package
            PPI::Statement::Include
            PPI::Statement::Sub
               PPI::Statement::Scheduled
            PPI::Statement::Compound
            PPI::Statement::Break
            PPI::Statement::Given
            PPI::Statement::When
            PPI::Statement::Data
            PPI::Statement::End
            PPI::Statement::Expression
               PPI::Statement::Variable
            PPI::Statement::Null
            PPI::Statement::UnmatchedBrace
            PPI::Statement::Unknown
         PPI::Structure
            PPI::Structure::Block
            PPI::Structure::Subscript
            PPI::Structure::Constructor
            PPI::Structure::Condition
            PPI::Structure::List
            PPI::Structure::For
            PPI::Structure::Given
            PPI::Structure::When
            PPI::Structure::Unknown
      PPI::Token
         PPI::Token::Whitespace
         PPI::Token::Comment
         PPI::Token::Pod
         PPI::Token::Number
            PPI::Token::Number::Binary
            PPI::Token::Number::Octal
            PPI::Token::Number::Hex
            PPI::Token::Number::Float
               PPI::Token::Number::Exp
            PPI::Token::Number::Version
         PPI::Token::Word
         PPI::Token::DashedWord
         PPI::Token::Symbol
            PPI::Token::Magic
         PPI::Token::ArrayIndex
         PPI::Token::Operator
         PPI::Token::Quote
            PPI::Token::Quote::Single
            PPI::Token::Quote::Double
            PPI::Token::Quote::Literal
            PPI::Token::Quote::Interpolate
         PPI::Token::QuoteLike
            PPI::Token::QuoteLike::Backtick
            PPI::Token::QuoteLike::Command
            PPI::Token::QuoteLike::Regexp
            PPI::Token::QuoteLike::Words
            PPI::Token::QuoteLike::Readline
         PPI::Token::Regexp
            PPI::Token::Regexp::Match
            PPI::Token::Regexp::Substitute
            PPI::Token::Regexp::Transliterate
         PPI::Token::HereDoc
         PPI::Token::Cast
         PPI::Token::Structure
         PPI::Token::Label
         PPI::Token::Separator
         PPI::Token::Data
         PPI::Token::End
         PPI::Token::Prototype
         PPI::Token::Attribute
         PPI::Token::Unknown
</pre>
<p class="Pp">To summarize the above layout, all PDOM objects inherit from the
    PPI::Element class.</p>
<p class="Pp">Under this are PPI::Token, strings of content with a known type,
    and PPI::Node, syntactically significant containers that hold other
    Elements.</p>
<p class="Pp">The three most important of these are the PPI::Document, the
    PPI::Statement and the PPI::Structure classes.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="The_Document,_Statement_and_Structure"><a class="permalink" href="#The_Document,_Statement_and_Structure">The
  Document, Statement and Structure</a></h2>
At the top of all complete PDOM trees is a PPI::Document object. It represents a
  complete file of Perl source code as you might find it on disk.
<p class="Pp">There are some specialised types of document, such as
    PPI::Document::File and PPI::Document::Normalized but for the purposes of
    the PDOM they are all just considered to be the same thing.</p>
<p class="Pp">Each Document will contain a number of <b>Statements</b>,
    <b>Structures</b> and <b>Tokens</b>.</p>
<p class="Pp">A PPI::Statement is any series of Tokens and Structures that are
    treated as a single contiguous statement by perl itself. You should note
    that a Statement is as close as PPI can get to &quot;parsing&quot; the code
    in the sense that perl-itself parses Perl code when it is building the
    op-tree.</p>
<p class="Pp">Because of the isolation and Perl's syntax, it is provably
    impossible for PPI to accurately determine precedence of operators or which
    tokens are implicit arguments to a sub call.</p>
<p class="Pp">So rather than lead you on with a bad guess that has a strong
    chance of being wrong, PPI does not attempt to determine precedence or sub
    parameters at all.</p>
<p class="Pp">At a fundamental level, it only knows that this series of elements
    represents a single Statement as perl sees it, but it can do so with enough
    certainty that it can be trusted.</p>
<p class="Pp">However, for specific Statement types the PDOM is able to derive
    additional useful information about their meaning. For the best, most
    useful, and most heavily used example, see PPI::Statement::Include.</p>
<p class="Pp">A PPI::Structure is any series of tokens contained within matching
    braces. This includes code blocks, conditions, function argument braces,
    anonymous array and hash constructors, lists, scoping braces and all other
    syntactic structures represented by a matching pair of braces, including
    (although it may not seem obvious at first)
    <span class="Li">&quot;&lt;READLINE&gt;&quot;</span> braces.</p>
<p class="Pp">Each Structure contains none, one, or many Tokens and Structures
    (the rules for which vary for the different Structure subclasses)</p>
<p class="Pp">Under the PDOM structure rules, a Statement can <b>never</b>
    directly contain another child Statement, a Structure can <b>never</b>
    directly contain another child Structure, and a Document can <b>never</b>
    contain another Document anywhere in the tree.</p>
<p class="Pp">Aside from these three rules, the PDOM tree is extremely
  flexible.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="The__s-1PDOM_s0_at_Work"><a class="permalink" href="#The__s-1PDOM_s0_at_Work">The
  PDOM at Work</a></h2>
To demonstrate the PDOM in use lets start with an example showing how the tree
  might look for the following chunk of simple Perl code.
<p class="Pp"><span class="Li"></span></p>
<pre>
  #!/usr/bin/perl

  print( &quot;Hello World!&quot; );

  exit();
</pre>
<p class="Pp">Translated into a PDOM tree it would have the following structure
    (as shown via the included PPI::Dumper).</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  PPI::Document
    PPI::Token::Comment                '#!/usr/bin/perl\n'
    PPI::Token::Whitespace             '\n'
    PPI::Statement::Expression
      PPI::Token::Bareword             'print'
      PPI::Structure::List             ( ... )
        PPI::Token::Whitespace         ' '
        PPI::Statement::Expression
          PPI::Token::Quote::Double    '&quot;Hello World!&quot;'
        PPI::Token::Whitespace         ' '
      PPI::Token::Structure            ';'
    PPI::Token::Whitespace             '\n'
    PPI::Token::Whitespace             '\n'
    PPI::Statement::Expression
      PPI::Token::Bareword             'exit'
      PPI::Structure::List             ( ... )
      PPI::Token::Structure            ';'
    PPI::Token::Whitespace             '\n'
</pre>
<p class="Pp">Please note that in this this example, strings are only listed for
    the <b>actual</b> PPI::Token that contains that string. Structures are
    listed with the type of brace characters it represents noted.</p>
<p class="Pp">The PPI::Dumper module can be used to generate similar trees
    yourself.</p>
<p class="Pp">We can make that PDOM dump a little easier to read if we strip out
    all the whitespace. Here it is again, sans the distracting whitespace
    tokens.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  PPI::Document
    PPI::Token::Comment                '#!/usr/bin/perl\n'
    PPI::Statement::Expression
      PPI::Token::Bareword             'print'
      PPI::Structure::List             ( ... )
        PPI::Statement::Expression
          PPI::Token::Quote::Double    '&quot;Hello World!&quot;'
      PPI::Token::Structure            ';'
    PPI::Statement::Expression
      PPI::Token::Bareword             'exit'
      PPI::Structure::List             ( ... )
      PPI::Token::Structure            ';'
</pre>
<p class="Pp">As you can see, the tree can get fairly deep at time, especially
    when every isolated token in a bracket becomes its own statement. This is
    needed to allow anything inside the tree the ability to grow. It also makes
    the search and analysis algorithms much more flexible.</p>
<p class="Pp">Because of the depth and complexity of PDOM trees, a vast number
    of very easy to use methods have been added wherever possible to help people
    working with PDOM trees do normal tasks relatively quickly and
  efficiently.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Overview_of_the_Primary_Classes"><a class="permalink" href="#Overview_of_the_Primary_Classes">Overview
  of the Primary Classes</a></h2>
The main PPI classes, and links to their own documentation, are listed here in
  alphabetical order.
<dl class="Bl-tag">
  <dt>PPI::Document</dt>
  <dd>The Document object, the root of the PDOM.</dd>
  <dt>PPI::Document::Fragment</dt>
  <dd>A cohesive fragment of a larger Document. Although not of any real current
      use, it is needed for use in certain internal tree manipulation
      algorithms.
    <p class="Pp">For example, doing things like cut/copy/paste etc. Very
        similar to a PPI::Document, but has some additional methods and does not
        represent a lexical scope boundary.</p>
    <p class="Pp">A document fragment is also non-serializable, and so cannot be
        written out to a file.</p>
  </dd>
  <dt>PPI::Dumper</dt>
  <dd>A simple class for dumping readable debugging versions of PDOM structures,
      such as in the demonstration above.</dd>
  <dt>PPI::Element</dt>
  <dd>The Element class is the abstract base class for all objects within the
      PDOM</dd>
  <dt>PPI::Find</dt>
  <dd>Implements an instantiable object form of a PDOM tree search.</dd>
  <dt>PPI::Lexer</dt>
  <dd>The PPI Lexer. Converts Token streams into PDOM trees.</dd>
  <dt>PPI::Node</dt>
  <dd>The Node object, the abstract base class for all PDOM objects that can
      contain other Elements, such as the Document, Statement and Structure
      objects.</dd>
  <dt>PPI::Statement</dt>
  <dd>The base class for all Perl statements. Generic &quot;evaluate for
      side-effects&quot; statements are of this actual type. Other more
      interesting statement types belong to one of its children.
    <p class="Pp">See it's own documentation for a longer description and list
        of all of the different statement types and sub-classes.</p>
  </dd>
  <dt>PPI::Structure</dt>
  <dd>The abstract base class for all structures. A Structure is a language
      construct consisting of matching braces containing a set of other
      elements.
    <p class="Pp">See the PPI::Structure documentation for a description and
        list of all of the different structure types and sub-classes.</p>
  </dd>
  <dt>PPI::Token</dt>
  <dd>A token is the basic unit of content. At its most basic, a Token is just a
      string tagged with metadata (its class, and some additional flags in some
      cases).</dd>
  <dt>PPI::Token::_QuoteEngine</dt>
  <dd>The PPI::Token::Quote and PPI::Token::QuoteLike classes provide abstract
      base classes for the many and varied types of quote and quote-like things
      in Perl. However, much of the actual quote login is implemented in a
      separate quote engine, based at PPI::Token::_QuoteEngine.
    <p class="Pp">Classes that inherit from PPI::Token::Quote,
        PPI::Token::QuoteLike and PPI::Token::Regexp are generally parsed only
        by the Quote Engine.</p>
  </dd>
  <dt>PPI::Tokenizer</dt>
  <dd>The PPI Tokenizer. One Tokenizer consumes a chunk of text and provides
      access to a stream of PPI::Token objects.
    <p class="Pp">The Tokenizer is very very complicated, to the point where
        even the author treads carefully when working with it.</p>
    <p class="Pp">Most of the complication is the result of optimizations which
        have tripled the tokenization speed, at the expense of maintainability.
        We cope with the spaghetti by heavily commenting everything.</p>
  </dd>
  <dt>PPI::Transform</dt>
  <dd>The Perl Document Transformation API. Provides a standard interface and
      abstract base class for objects and classes that manipulate
    Documents.</dd>
</dl>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="INSTALLING"><a class="permalink" href="#INSTALLING">INSTALLING</a></h1>
The core PPI distribution is pure Perl and has been kept as tight as possible
  and with as few dependencies as possible.
<p class="Pp">It should download and install normally on any platform from
    within the CPAN and CPANPLUS applications, or directly using the
    distribution tarball. If installing by hand, you may need to install a few
    small utility modules first. The exact ones will depend on your version of
    perl.</p>
<p class="Pp">There are no special install instructions for PPI, and the normal
    <span class="Li">&quot;Perl Makefile.PL&quot;</span>,
    <span class="Li">&quot;make&quot;</span>, <span class="Li">&quot;make
    test&quot;</span>, <span class="Li">&quot;make install&quot;</span>
    instructions apply.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="EXTENDING"><a class="permalink" href="#EXTENDING">EXTENDING</a></h1>
The PPI namespace itself is reserved for the sole use of the modules under the
  umbrella of the <span class="Li">&quot;Parse::Perl&quot;</span> SourceForge
  project.
<p class="Pp">&lt;http://sf.net/projects/parseperl&gt;</p>
<p class="Pp">You are recommended to use the PPIx:: namespace for PPI-specific
    modifications or prototypes thereof, or Perl:: for modules which provide a
    general Perl language-related functions.</p>
<p class="Pp">If what you wish to implement looks like it fits into PPIx::
    namespace, you should consider contacting the
    <span class="Li">&quot;Parse::Perl&quot;</span> mailing list (detailed on
    the SourceForge site) first, as what you want may already be in progress, or
    you may wish to consider joining the team and doing it within the
    <span class="Li">&quot;Parse::Perl&quot;</span> project itself.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="TO_DO"><a class="permalink" href="#TO_DO">TO DO</a></h1>
- Many more analysis and utility methods for PDOM classes
<p class="Pp">- Creation of a PPI::Tutorial document</p>
<p class="Pp">- Add many more key functions to PPI::XS</p>
<p class="Pp">- We can <b>always</b> write more and better unit tests</p>
<p class="Pp">- Complete the full implementation of -&gt;literal (1.200)</p>
<p class="Pp">- Full understanding of scoping (due 1.300)</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SUPPORT"><a class="permalink" href="#SUPPORT">SUPPORT</a></h1>
This module is stored in an Open Repository at the following address.
<p class="Pp">&lt;http://svn.ali.as/cpan/trunk/PPI&gt;</p>
<p class="Pp">Write access to the repository is made available automatically to
    any published CPAN author, and to most other volunteers on request.</p>
<p class="Pp">If you are able to submit your bug report in the form of new
    (failing) unit tests, or can apply your fix directly instead of submitting a
    patch, you are <b>strongly</b> encouraged to do so, as the author currently
    maintains over 100 modules and it can take some time to deal with
    non-&quot;Critical&quot; bug reports or patches.</p>
<p class="Pp">This will also guarentee that your issue will be addressed in the
    next release of the module.</p>
<p class="Pp">For large changes though, please consider creating a branch so
    that they can be properly reviewed and trialed before being applied to the
    trunk.</p>
<p class="Pp">If you cannot provide a direct test or fix, or don't have time to
    do so, then regular bug reports are still accepted and appreciated via the
    CPAN bug tracker.</p>
<p class="Pp">&lt;http://rt.cpan.org/NoAuth/ReportBug.html?Queue=PPI&gt;</p>
<p class="Pp">For other issues or questions, contact the
    <span class="Li">&quot;Parse::Perl&quot;</span> project mailing list.</p>
<p class="Pp">For commercial or media-related enquiries, or to have your SVN
    commit bit enabled, contact the author.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
Adam Kennedy &lt;adamk@cpan.org&gt;
</section>
<section class="Sh">
<h1 class="Sh" id="ACKNOWLEDGMENTS"><a class="permalink" href="#ACKNOWLEDGMENTS">ACKNOWLEDGMENTS</a></h1>
A huge thank you to Phase N Australia (&lt;http://phase-n.com/&gt;) for
  permitting the original open sourcing and release of this distribution from
  what was originally several thousand hours of commercial work.
<p class="Pp">Another big thank you to The Perl Foundation
    (&lt;http://www.perlfoundation.org/&gt;) for funding for the final big
    refactoring and completion run.</p>
<p class="Pp">Also, to the various co-maintainers that have contributed both
    large and small with tests and patches and especially to those rare few who
    have deep-dived into the guts to (gasp) add a feature.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  - Dan Brook       : PPIx::XPath, Acme::PerlML
  - Audrey Tang     : &quot;Line Noise&quot; Testing
  - Arjen Laarhoven : Three-element -&gt;location support
  - Elliot Shank    : Perl 5.10 support, five-element -&gt;location
</pre>
<p class="Pp">And finally, thanks to those brave ( and foolish :) ) souls
    willing to dive in and use, test drive and provide feedback on PPI before
    version 1.000, in some cases before it made it to beta quality, and still
    did extremely distasteful things (like eating 50 meg of RAM a second).</p>
<p class="Pp">I owe you all a beer. Corner me somewhere and collect at your
    convenience. If I missed someone who wasn't in my email history, thank you
    too :)</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  # In approximate order of appearance
  - Claes Jacobsson
  - Michael Schwern
  - Jeff T. Parsons
  - CPAN Author &quot;CHOCOLATEBOY&quot;
  - Robert Rotherberg
  - CPAN Author &quot;PODMASTER&quot;
  - Richard Soderberg
  - Nadim ibn Hamouda el Khemir
  - Graciliano M. P.
  - Leon Brocard
  - Jody Belka
  - Curtis Ovid
  - Yuval Kogman
  - Michael Schilli
  - Slaven Rezic
  - Lars Thegler
  - Tony Stubblebine
  - Tatsuhiko Miyagawa
  - CPAN Author &quot;CHROMATIC&quot;
  - Matisse Enzer
  - Roy Fulbright
  - Dan Brook
  - Johnny Lee
  - Johan Lindstrom
</pre>
<p class="Pp">And to single one person out, thanks go to Randal Schwartz who
    spent a great number of hours in IRC over a critical 6 month period
    explaining why Perl is impossibly unparsable and constantly shoving evil and
    ugly corner cases in my face. He remained a tireless devil's advocate, and
    without his support this project genuinely could never have been
  completed.</p>
<p class="Pp">So for my schooling in the Deep Magiks, you have my deepest
    gratitude Randal.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT"><a class="permalink" href="#COPYRIGHT">COPYRIGHT</a></h1>
Copyright 2001 - 2011 Adam Kennedy.
<p class="Pp">This program is free software; you can redistribute it and/or
    modify it under the same terms as Perl itself.</p>
<p class="Pp">The full text of the license can be found in the LICENSE file
    included with this module.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2011-02-25</td>
    <td class="foot-os">perl v5.18.4</td>
  </tr>
</table>
</body>
</html>
