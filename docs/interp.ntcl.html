<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Copyright (c) 1995-1996 Sun Microsystems, Inc.
   Copyright (c) 2004 Donal K. Fellows
  
   See the file "license.terms" for information on usage and redistribution
   of this file, and for a DISCLAIMER OF ALL WARRANTIES.
  
   RCS: @(#) $Id: interp.n,v 1.38 2007/12/13 15:22:32 dgp Exp $
  
   The -*- nroff -*- definitions below are for supplemental macros used
   in Tcl/Tk manual entries.
  
   .AP type name in/out ?indent?
  	Start paragraph describing an argument to a library procedure.
  	type is type of argument (int, etc.), in/out is either "in", "out",
  	or "in/out" to describe whether procedure reads or modifies arg,
  	and indent is equivalent to second arg of .IP (shouldn't ever be
  	needed;  use .AS below instead)
  
   .AS ?type? ?name?
  	Give maximum sizes of arguments for setting tab stops.  Type and
  	name are examples of largest possible arguments that will be passed
  	to .AP later.  If args are omitted, default tab stops are used.
  
   .BS
  	Start box enclosure.  From here until next .BE, everything will be
  	enclosed in one large box.
  
   .BE
  	End of box enclosure.
  
   .CS
  	Begin code excerpt.
  
   .CE
  	End code excerpt.
  
   .VS ?version? ?br?
  	Begin vertical sidebar, for use in marking newly-changed parts
  	of man pages.  The first argument is ignored and used for recording
  	the version when the .VS was added, so that the sidebars can be
  	found and removed when they reach a certain age.  If another argument
  	is present, then a line break is forced before starting the sidebar.
  
   .VE
  	End of vertical sidebar.
  
   .DS
  	Begin an indented unfilled display.
  
   .DE
  	End of indented unfilled display.
  
   .SO ?manpage?
  	Start of list of standard options for a Tk widget. The manpage
  	argument defines where to look up the standard options; if
  	omitted, defaults to "options". The options follow on successive
  	lines, in three columns separated by tabs.
  
   .SE
  	End of list of standard options for a Tk widget.
  
   .OP cmdName dbName dbClass
  	Start of description of a specific option.  cmdName gives the
  	option's name as specified in the class command, dbName gives
  	the option's name in the option database, and dbClass gives
  	the option's class in the option database.
  
   .UL arg1 arg2
  	Print arg1 underlined, then print arg2 normally.
  
   .QW arg1 ?arg2?
  	Print arg1 in quotes, then arg2 normally (for trailing punctuation).
  
   .PQ arg1 ?arg2?
  	Print an open parenthesis, arg1 in quotes, then arg2 normally
  	(for trailing punctuation) and then a closing parenthesis.
  
   RCS: @(#) $Id: man.macros,v 1.9 2008/01/29 15:32:33 dkf Exp $
  
  	# Set up traps and other miscellaneous stuff for Tcl/Tk man pages.
  	# Start an argument description
  .b
  	# define tabbing values for .AP
  
  	# BS - start boxed text
  	# ^y = starting y location
  	# ^b = 1
  	# BE - end boxed text (draw box now)
  	Draw four-sided box normally, but don't draw top of
  	box if the box started on an earlier page.
  	# VS - start vertical sidebar
  	# ^Y = starting y location
  	# ^v = 1 (for troff;  for nroff this doesn't matter)
  	# VE - end of vertical sidebar
  	# Special macro to handle page bottom:  finish off current
  	# box/sidebar if in box/sidebar mode, then invoked standard
  	# page bottom macro.
  	Draw three-sided box if this is the box's first page,
  	draw two sides but no top otherwise.
  	# DS - begin display
  	# DE - end display
  	# SO - start of list of standard options
  	# SE - end of list of standard options
  	# OP - start of full description for a single option
  	# CS - begin code excerpt
  	# CE - end code excerpt
  	# UL - underline word
  	# QW - apply quotation marks to word
  " fix emacs highlighting
  	# PQ - apply parens and quotation marks to word
  " fix emacs highlighting
  	# QR - quoted range
  " fix emacs highlighting
  	# MT - "empty" string
 -->
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>interp(n)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">interp(n)</td>
    <td class="head-vol">Tcl Built-In Commands</td>
    <td class="head-rtitle">interp(n)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<pre>

</pre>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
interp - Create and manipulate Tcl interpreters
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<b>interp </b><i>subcommand </i>?<i>arg arg ...</i>?
<pre>

</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
This command makes it possible to create one or more new Tcl interpreters that
  co-exist with the creating interpreter in the same application. The creating
  interpreter is called the <i>master</i> and the new interpreter is called a
  <i>slave</i>. A master can create any number of slaves, and each slave can
  itself create additional slaves for which it is master, resulting in a
  hierarchy of interpreters.
<p class="Pp">Each interpreter is independent from the others: it has its own
    name space for commands, procedures, and global variables. A master
    interpreter may create connections between its slaves and itself using a
    mechanism called an <i>alias</i>. An <i>alias</i> is a command in a slave
    interpreter which, when invoked, causes a command to be invoked in its
    master interpreter or in another slave interpreter. The only other
    connections between interpreters are through environment variables (the
    <b>env</b> variable), which are normally shared among all interpreters in
    the application, and by resource limit exceeded callbacks. Note that the
    name space for files (such as the names returned by the <b>open</b> command)
    is no longer shared between interpreters. Explicit commands are provided to
    share files and to transfer references to open files from one interpreter to
    another.</p>
<p class="Pp">The <b>interp</b> command also provides support for <i>safe</i>
    interpreters. A safe interpreter is a slave whose functions have been
    greatly restricted, so that it is safe to execute untrusted scripts without
    fear of them damaging other interpreters or the application's environment.
    For example, all IO channel creation commands and subprocess creation
    commands are made inaccessible to safe interpreters. See <b>SAFE
    INTERPRETERS</b> below for more information on what features are present in
    a safe interpreter. The dangerous functionality is not removed from the safe
    interpreter; instead, it is <i>hidden</i>, so that only trusted interpreters
    can obtain access to it. For a detailed explanation of hidden commands, see
    <b>HIDDEN COMMANDS</b>, below. The alias mechanism can be used for protected
    communication (analogous to a kernel call) between a slave interpreter and
    its master. See <b>ALIAS INVOCATION</b>, below, for more details on how the
    alias mechanism works.</p>
<p class="Pp">A qualified interpreter name is a proper Tcl lists containing a
    subset of its ancestors in the interpreter hierarchy, terminated by the
    string naming the interpreter in its immediate master. Interpreter names are
    relative to the interpreter in which they are used. For example, if <b>a</b>
    is a slave of the current interpreter and it has a slave <b>a1</b>, which in
    turn has a slave <b>a11</b>, the qualified name of <b>a11</b> in <b>a</b> is
    the list <b>a1 a11</b>.</p>
<p class="Pp">The <b>interp</b> command, described below, accepts qualified
    interpreter names as arguments; the interpreter in which the command is
    being evaluated can always be referred to as <b>{}</b> (the empty list or
    string). Note that it is impossible to refer to a master (ancestor)
    interpreter by name in a slave interpreter except through aliases. Also,
    there is no global name by which one can refer to the first interpreter
    created in an application. Both restrictions are motivated by safety
    concerns.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="THE_INTERP_COMMAND"><a class="permalink" href="#THE_INTERP_COMMAND">THE
  INTERP COMMAND</a></h1>
The <b>interp</b> command is used to create, delete, and manipulate slave
  interpreters, and to share or transfer channels between interpreters. It can
  have any of several forms, depending on the <i>subcommand</i> argument:
<dl class="Bl-tag">
  <dt><b>interp</b> <b>alias</b> <i>srcPath</i> <i>srcToken</i></dt>
  <dd>Returns a Tcl list whose elements are the <i>targetCmd</i> and <i>arg</i>s
      associated with the alias represented by <i>srcToken</i> (this is the
      value returned when the alias was created; it is possible that the name of
      the source command in the slave is different from <i>srcToken</i>).</dd>
  <dt><b>interp</b> <b>alias</b> <i>srcPath</i> <i>srcToken</i> <b>{}</b></dt>
  <dd>Deletes the alias for <i>srcToken</i> in the slave interpreter identified
      by <i>srcPath</i>. <i>srcToken</i> refers to the value returned when the
      alias was created; if the source command has been renamed, the renamed
      command will be deleted.</dd>
  <dt><b>interp</b> <b>alias</b> <i>srcPath</i> <i>srcCmd</i> <i>targetPath</i>
    <i>targetCmd </i>?<i>arg arg ...</i>?</dt>
  <dd>This command creates an alias between one slave and another (see the
      <b>alias</b> slave command below for creating aliases between a slave and
      its master). In this command, either of the slave interpreters may be
      anywhere in the hierarchy of interpreters under the interpreter invoking
      the command. <i>SrcPath</i> and <i>srcCmd</i> identify the source of the
      alias. <i>SrcPath</i> is a Tcl list whose elements select a particular
      interpreter. For example, &#x201C;<b>a b</b>&#x201D; identifies an
      interpreter <b>b</b>, which is a slave of interpreter <b>a</b>, which is a
      slave of the invoking interpreter. An empty list specifies the interpreter
      invoking the command. <i>srcCmd</i> gives the name of a new command, which
      will be created in the source interpreter. <i>TargetPath</i> and
      <i>targetCmd</i> specify a target interpreter and command, and the
      <i>arg</i> arguments, if any, specify additional arguments to
      <i>targetCmd</i> which are prepended to any arguments specified in the
      invocation of <i>srcCmd</i>. <i>TargetCmd</i> may be undefined at the time
      of this call, or it may already exist; it is not created by this command.
      The alias arranges for the given target command to be invoked in the
      target interpreter whenever the given source command is invoked in the
      source interpreter. See <b>ALIAS INVOCATION</b> below for more details.
      The command returns a token that uniquely identifies the command created
      <i>srcCmd</i>, even if the command is renamed afterwards. The token may
      but does not have to be equal to <i>srcCmd</i>.</dd>
  <dt><b>interp</b> <b>aliases </b>?<i>path</i>?</dt>
  <dd>This command returns a Tcl list of the tokens of all the source commands
      for aliases defined in the interpreter identified by <i>path</i>. The
      tokens correspond to the values returned when the aliases were created
      (which may not be the same as the current names of the commands).</dd>
  <dt><b>interp bgerror </b><i>path</i> ?<i>cmdPrefix</i>?</dt>
  <dd>This command either gets or sets the current background error handler for
      the interpreter identified by <i>path</i>. If <i>cmdPrefix</i> is absent,
      the current background error handler is returned, and if it is present, it
      is a list of words (of minimum length one) that describes what to set the
      interpreter's background error to. See the <b>BACKGROUND ERROR
      HANDLING</b> section for more details.</dd>
  <dt><b>interp</b> <b>create </b>?<b>-safe</b>? ?<b>--</b>? ?<i>path</i>?</dt>
  <dd>Creates a slave interpreter identified by <i>path</i> and a new command,
      called a <i>slave command</i>. The name of the slave command is the last
      component of <i>path</i>. The new slave interpreter and the slave command
      are created in the interpreter identified by the path obtained by removing
      the last component from <i>path</i>. For example, if <i>path</i> is <b>a
      b</b> <b>c</b> then a new slave interpreter and slave command named
      <b>c</b> are created in the interpreter identified by the path <b>a b</b>.
      The slave command may be used to manipulate the new interpreter as
      described below. If <i>path</i> is omitted, Tcl creates a unique name of
      the form <b>interp</b><i>x</i>, where <i>x</i> is an integer, and uses it
      for the interpreter and the slave command. If the <b>-safe</b> switch is
      specified (or if the master interpreter is a safe interpreter), the new
      slave interpreter will be created as a safe interpreter with limited
      functionality; otherwise the slave will include the full set of Tcl
      built-in commands and variables. The <b>--</b> switch can be used to mark
      the end of switches; it may be needed if <i>path</i> is an unusual value
      such as <b>-safe</b>. The result of the command is the name of the new
      interpreter. The name of a slave interpreter must be unique among all the
      slaves for its master; an error occurs if a slave interpreter by the given
      name already exists in this master. The initial recursion limit of the
      slave interpreter is set to the current recursion limit of its parent
      interpreter.</dd>
  <dt><b>interp</b> <b>delete </b>?<i>path ...?</i></dt>
  <dd>Deletes zero or more interpreters given by the optional <i>path</i>
      arguments, and for each interpreter, it also deletes its slaves. The
      command also deletes the slave command for each interpreter deleted. For
      each <i>path</i> argument, if no interpreter by that name exists, the
      command raises an error.</dd>
  <dt><b>interp</b> <b>eval</b> <i>path arg </i>?<i>arg ...</i>?</dt>
  <dd>This command concatenates all of the <i>arg</i> arguments in the same
      fashion as the <b>concat</b> command, then evaluates the resulting string
      as a Tcl script in the slave interpreter identified by <i>path</i>. The
      result of this evaluation (including all <b>return</b> options, such as
      <b>-errorinfo</b> and <b>-errorcode</b> information, if an error occurs)
      is returned to the invoking interpreter. Note that the script will be
      executed in the current context stack frame of the <i>path</i>
      interpreter; this is so that the implementations (in a master interpreter)
      of aliases in a slave interpreter can execute scripts in the slave that
      find out information about the slave's current state and stack frame.</dd>
  <dt><b>interp exists </b><i>path</i></dt>
  <dd>Returns <b>1</b> if a slave interpreter by the specified <i>path</i>
      exists in this master, <b>0</b> otherwise. If <i>path</i> is omitted, the
      invoking interpreter is used.</dd>
  <dt><b>interp expose </b><i>path</i> <i>hiddenName</i>
    ?<i>exposedCmdName</i>?</dt>
  <dd>Makes the hidden command <i>hiddenName</i> exposed, eventually bringing it
      back under a new <i>exposedCmdName</i> name (this name is currently
      accepted only if it is a valid global name space name without any ::), in
      the interpreter denoted by <i>path</i>. If an exposed command with the
      targeted name already exists, this command fails. Hidden commands are
      explained in more detail in <b>HIDDEN COMMANDS</b>, below.</dd>
  <dt><b>interp</b> <b>hide</b> <i>path</i> <i>exposedCmdName</i>
    ?<i>hiddenCmdName</i>?</dt>
  <dd>Makes the exposed command <i>exposedCmdName</i> hidden, renaming it to the
      hidden command <i>hiddenCmdName</i>, or keeping the same name if
      <i>hiddenCmdName</i> is not given, in the interpreter denoted by
      <i>path</i>. If a hidden command with the targeted name already exists,
      this command fails. Currently both <i>exposedCmdName</i> and
      <i>hiddenCmdName</i> can not contain namespace qualifiers, or an error is
      raised. Commands to be hidden by <b>interp hide</b> are looked up in the
      global namespace even if the current namespace is not the global one. This
      prevents slaves from fooling a master interpreter into hiding the wrong
      command, by making the current namespace be different from the global one.
      Hidden commands are explained in more detail in <b>HIDDEN COMMANDS</b>,
      below.</dd>
  <dt><b>interp</b> <b>hidden</b> <i>path</i></dt>
  <dd>Returns a list of the names of all hidden commands in the interpreter
      identified by <i>path</i>.</dd>
  <dt><b>interp</b> <b>invokehidden</b> <i>path</i> ?<i>-option ...</i>?
    <i>hiddenCmdName</i> ?<i>arg ...</i>?</dt>
  <dd>Invokes the hidden command <i>hiddenCmdName</i> with the arguments
      supplied in the interpreter denoted by <i>path</i>. No substitutions or
      evaluation are applied to the arguments. Three <i>-option</i>s are
      supported, all of which start with <b>-</b>: <b>-namespace</b> (which
      takes a single argument afterwards, <i>nsName</i>), <b>-global</b>, and
      <b>--</b>. If the <b>-namespace</b> flag is present, the hidden command is
      invoked in the namespace called <i>nsName</i> in the target interpreter.
      If the <b>-global</b> flag is present, the hidden command is invoked at
      the global level in the target interpreter; otherwise it is invoked at the
      current call frame and can access local variables in that and outer call
      frames. The <b>--</b> flag allows the <i>hiddenCmdName</i> argument to
      start with a &#x201C;-&#x201D; character, and is otherwise unnecessary. If
      both the <b>-namespace</b> and <b>-global</b> flags are present, the
      <b>-namespace</b> flag is ignored. Note that the hidden command will be
      executed (by default) in the current context stack frame of the
      <i>path</i> interpreter. Hidden commands are explained in more detail in
      <b>HIDDEN COMMANDS</b>, below.</dd>
  <dt><b>interp</b> <b>limit</b> <i>path</i> <i>limitType</i> ?<i>-option</i>?
    ?<i>value</i> <i>...</i>?</dt>
  <dd>Sets up, manipulates and queries the configuration of the resource limit
      <i>limitType</i> for the interpreter denoted by <i>path</i>. If no
      <i>-option</i> is specified, return the current configuration of the
      limit. If <i>-option</i> is the sole argument, return the value of that
      option. Otherwise, a list of <i>-option</i>/<i>value</i> argument pairs
      must supplied. See <b>RESOURCE LIMITS</b> below for a more detailed
      explanation of what limits and options are supported.</dd>
  <dt><b>interp issafe</b> ?<i>path</i>?</dt>
  <dd>Returns <b>1</b> if the interpreter identified by the specified
      <i>path</i> is safe, <b>0</b> otherwise.</dd>
  <dt><b>interp marktrusted</b> <i>path</i></dt>
  <dd>Marks the interpreter identified by <i>path</i> as trusted. Does not
      expose the hidden commands. This command can only be invoked from a
      trusted interpreter. The command has no effect if the interpreter
      identified by <i>path</i> is already trusted.</dd>
  <dt><b>interp</b> <b>recursionlimit</b> <i>path</i> ?<i>newlimit</i>?</dt>
  <dd>Returns the maximum allowable nesting depth for the interpreter specified
      by <i>path</i>. If <i>newlimit</i> is specified, the interpreter recursion
      limit will be set so that nesting of more than <i>newlimit</i> calls to
      <b>Tcl_Eval()</b> and related procedures in that interpreter will return
      an error. The <i>newlimit</i> value is also returned. The <i>newlimit</i>
      value must be a positive integer between 1 and the maximum value of a
      non-long integer on the platform.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp">The command sets the maximum size of the Tcl call stack only. It
    cannot by itself prevent stack overflows on the C stack being used by the
    application. If your machine has a limit on the size of the C stack, you may
    get stack overflows before reaching the limit set by the command. If this
    happens, see if there is a mechanism in your system for increasing the
    maximum size of the C stack.</p>
</div>
<dl class="Bl-tag">
  <dt><b>interp</b> <b>share</b> <i>srcPath channelId destPath</i></dt>
  <dd>Causes the IO channel identified by <i>channelId</i> to become shared
      between the interpreter identified by <i>srcPath</i> and the interpreter
      identified by <i>destPath</i>. Both interpreters have the same permissions
      on the IO channel. Both interpreters must close it to close the underlying
      IO channel; IO channels accessible in an interpreter are automatically
      closed when an interpreter is destroyed.</dd>
  <dt><b>interp</b> <b>slaves</b> ?<i>path</i>?</dt>
  <dd>Returns a Tcl list of the names of all the slave interpreters associated
      with the interpreter identified by <i>path</i>. If <i>path</i> is omitted,
      the invoking interpreter is used.</dd>
  <dt><b>interp</b> <b>target</b> <i>path alias</i></dt>
  <dd>Returns a Tcl list describing the target interpreter for an alias. The
      alias is specified with an interpreter path and source command name, just
      as in <b>interp alias</b> above. The name of the target interpreter is
      returned as an interpreter path, relative to the invoking interpreter. If
      the target interpreter for the alias is the invoking interpreter then an
      empty list is returned. If the target interpreter for the alias is not the
      invoking interpreter or one of its descendants then an error is generated.
      The target command does not have to be defined at the time of this
      invocation.</dd>
  <dt><b>interp</b> <b>transfer</b> <i>srcPath channelId destPath</i></dt>
  <dd>Causes the IO channel identified by <i>channelId</i> to become available
      in the interpreter identified by <i>destPath</i> and unavailable in the
      interpreter identified by <i>srcPath</i>.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="SLAVE_COMMAND"><a class="permalink" href="#SLAVE_COMMAND">SLAVE
  COMMAND</a></h1>
For each slave interpreter created with the <b>interp</b> command, a new Tcl
  command is created in the master interpreter with the same name as the new
  interpreter. This command may be used to invoke various operations on the
  interpreter. It has the following general form:
<div class="Bd-indent">
<pre>
<i>slave command </i>?<i>arg arg ...</i>?
</pre>
</div>
<i>Slave</i> is the name of the interpreter, and <i>command</i> and the
  <i>arg</i>s determine the exact behavior of the command. The valid forms of
  this command are:
<dl class="Bl-tag">
  <dt><i>slave </i><b>aliases</b></dt>
  <dd>Returns a Tcl list whose elements are the tokens of all the aliases in
      <i>slave</i>. The tokens correspond to the values returned when the
      aliases were created (which may not be the same as the current names of
      the commands).</dd>
  <dt><i>slave </i><b>alias </b><i>srcToken</i></dt>
  <dd>Returns a Tcl list whose elements are the <i>targetCmd</i> and <i>arg</i>s
      associated with the alias represented by <i>srcToken</i> (this is the
      value returned when the alias was created; it is possible that the actual
      source command in the slave is different from <i>srcToken</i>).</dd>
  <dt><i>slave </i><b>alias </b><i>srcToken </i><b>{}</b></dt>
  <dd>Deletes the alias for <i>srcToken</i> in the slave interpreter.
      <i>srcToken</i> refers to the value returned when the alias was created;
      if the source command has been renamed, the renamed command will be
      deleted.</dd>
  <dt><i>slave </i><b>alias </b><i>srcCmd targetCmd </i>?<i>arg ..</i>?</dt>
  <dd>Creates an alias such that whenever <i>srcCmd</i> is invoked in
      <i>slave</i>, <i>targetCmd</i> is invoked in the master. The <i>arg</i>
      arguments will be passed to <i>targetCmd</i> as additional arguments,
      prepended before any arguments passed in the invocation of <i>srcCmd</i>.
      See <b>ALIAS INVOCATION</b> below for details. The command returns a token
      that uniquely identifies the command created <i>srcCmd</i>, even if the
      command is renamed afterwards. The token may but does not have to be equal
      to <i>srcCmd</i>.</dd>
  <dt><i>slave </i><b>bgerror</b> ?<i>cmdPrefix</i>?</dt>
  <dd>This command either gets or sets the current background error handler for
      the <i>slave</i> interpreter. If <i>cmdPrefix</i> is absent, the current
      background error handler is returned, and if it is present, it is a list
      of words (of minimum length one) that describes what to set the
      interpreter's background error to. See the <b>BACKGROUND ERROR
      HANDLING</b> section for more details.</dd>
  <dt><i>slave </i><b>eval </b><i>arg </i>?<i>arg ..</i>?</dt>
  <dd>This command concatenates all of the <i>arg</i> arguments in the same
      fashion as the <b>concat</b> command, then evaluates the resulting string
      as a Tcl script in <i>slave</i>. The result of this evaluation (including
      all <b>return</b> options, such as <b>-errorinfo</b> and <b>-errorcode</b>
      information, if an error occurs) is returned to the invoking interpreter.
      Note that the script will be executed in the current context stack frame
      of <i>slave</i>; this is so that the implementations (in a master
      interpreter) of aliases in a slave interpreter can execute scripts in the
      slave that find out information about the slave's current state and stack
      frame.</dd>
  <dt><i>slave </i><b>expose </b><i>hiddenName </i>?<i>exposedCmdName</i>?</dt>
  <dd>This command exposes the hidden command <i>hiddenName</i>, eventually
      bringing it back under a new <i>exposedCmdName</i> name (this name is
      currently accepted only if it is a valid global name space name without
      any ::), in <i>slave</i>. If an exposed command with the targeted name
      already exists, this command fails. For more details on hidden commands,
      see <b>HIDDEN COMMANDS</b>, below.</dd>
  <dt><i>slave </i><b>hide </b><i>exposedCmdName</i> ?<i>hiddenCmdName</i>?</dt>
  <dd>This command hides the exposed command <i>exposedCmdName</i>, renaming it
      to the hidden command <i>hiddenCmdName</i>, or keeping the same name if
      the argument is not given, in the <i>slave</i> interpreter. If a hidden
      command with the targeted name already exists, this command fails.
      Currently both <i>exposedCmdName</i> and <i>hiddenCmdName</i> can not
      contain namespace qualifiers, or an error is raised. Commands to be hidden
      are looked up in the global namespace even if the current namespace is not
      the global one. This prevents slaves from fooling a master interpreter
      into hiding the wrong command, by making the current namespace be
      different from the global one. For more details on hidden commands, see
      <b>HIDDEN COMMANDS</b>, below.</dd>
  <dt><i>slave </i><b>hidden</b></dt>
  <dd>Returns a list of the names of all hidden commands in <i>slave</i>.</dd>
  <dt><i>slave </i><b>invokehidden</b> ?<i>-option ...</i>? <i>hiddenName
    </i>?<i>arg ..</i>?</dt>
  <dd>This command invokes the hidden command <i>hiddenName</i> with the
      supplied arguments, in <i>slave</i>. No substitutions or evaluations are
      applied to the arguments. Three <i>-option</i>s are supported, all of
      which start with <b>-</b>: <b>-namespace</b> (which takes a single
      argument afterwards, <i>nsName</i>), <b>-global</b>, and <b>--</b>. If the
      <b>-namespace</b> flag is given, the hidden command is invoked in the
      specified namespace in the slave. If the <b>-global</b> flag is given, the
      command is invoked at the global level in the slave; otherwise it is
      invoked at the current call frame and can access local variables in that
      or outer call frames. The <b>--</b> flag allows the <i>hiddenCmdName</i>
      argument to start with a &#x201C;-&#x201D; character, and is otherwise
      unnecessary. If both the <b>-namespace</b> and <b>-global</b> flags are
      given, the <b>-namespace</b> flag is ignored. Note that the hidden command
      will be executed (by default) in the current context stack frame of
      <i>slave</i>. For more details on hidden commands, see <b>HIDDEN
      COMMANDS</b>, below.</dd>
  <dt><i>slave </i><b>issafe</b></dt>
  <dd>Returns <b>1</b> if the slave interpreter is safe, <b>0</b>
    otherwise.</dd>
  <dt><i>slave </i><b>limit</b> <i>limitType</i> ?<i>-option</i>? ?<i>value</i>
    <i>...</i>?</dt>
  <dd>Sets up, manipulates and queries the configuration of the resource limit
      <i>limitType</i> for the slave interpreter. If no <i>-option</i> is
      specified, return the current configuration of the limit. If
      <i>-option</i> is the sole argument, return the value of that option.
      Otherwise, a list of <i>-option</i>/<i>value</i> argument pairs must
      supplied. See <b>RESOURCE LIMITS</b> below for a more detailed explanation
      of what limits and options are supported.</dd>
  <dt><i>slave </i><b>marktrusted</b></dt>
  <dd>Marks the slave interpreter as trusted. Can only be invoked by a trusted
      interpreter. This command does not expose any hidden commands in the slave
      interpreter. The command has no effect if the slave is already
    trusted.</dd>
  <dt><i>slave</i> <b>recursionlimit</b> ?<i>newlimit</i>?</dt>
  <dd>Returns the maximum allowable nesting depth for the <i>slave</i>
      interpreter. If <i>newlimit</i> is specified, the recursion limit in
      <i>slave</i> will be set so that nesting of more than <i>newlimit</i>
      calls to <b>Tcl_Eval()</b> and related procedures in <i>slave</i> will
      return an error. The <i>newlimit</i> value is also returned. The
      <i>newlimit</i> value must be a positive integer between 1 and the maximum
      value of a non-long integer on the platform.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp">The command sets the maximum size of the Tcl call stack only. It
    cannot by itself prevent stack overflows on the C stack being used by the
    application. If your machine has a limit on the size of the C stack, you may
    get stack overflows before reaching the limit set by the command. If this
    happens, see if there is a mechanism in your system for increasing the
    maximum size of the C stack.</p>
</div>
</section>
<section class="Sh">
<h1 class="Sh" id="SAFE_INTERPRETERS"><a class="permalink" href="#SAFE_INTERPRETERS">SAFE
  INTERPRETERS</a></h1>
A safe interpreter is one with restricted functionality, so that is safe to
  execute an arbitrary script from your worst enemy without fear of that script
  damaging the enclosing application or the rest of your computing environment.
  In order to make an interpreter safe, certain commands and variables are
  removed from the interpreter. For example, commands to create files on disk
  are removed, and the <b>exec</b> command is removed, since it could be used to
  cause damage through subprocesses. Limited access to these facilities can be
  provided, by creating aliases to the master interpreter which check their
  arguments carefully and provide restricted access to a safe subset of
  facilities. For example, file creation might be allowed in a particular
  subdirectory and subprocess invocation might be allowed for a carefully
  selected and fixed set of programs.
<p class="Pp">A safe interpreter is created by specifying the <b>-safe</b>
    switch to the <b>interp create</b> command. Furthermore, any slave created
    by a safe interpreter will also be safe.</p>
<p class="Pp">A safe interpreter is created with exactly the following set of
    built-in commands:</p>
<div class="Bd-indent">
<pre>

<b>after</b>	<b>append</b>	<b>apply</b>	<b>array</b>
<b>binary</b>	<b>break</b>	<b>catch</b>	<b>chan</b>
<b>clock</b>	<b>close</b>	<b>concat</b>	<b>continue</b>
<b>dict</b>	<b>eof</b>	<b>error</b>	<b>eval</b>
<b>expr</b>	<b>fblocked</b>	<b>fcopy</b>	<b>fileevent</b>
<b>flush</b>	<b>for</b>	<b>foreach</b>	<b>format</b>
<b>gets</b>	<b>global</b>	<b>if</b>	<b>incr</b>
<b>info</b>	<b>interp</b>	<b>join</b>	<b>lappend</b>
<b>lassign</b>	<b>lindex</b>	<b>linsert</b>	<b>list</b>
<b>llength</b>	<b>lrange</b>	<b>lrepeat</b>	<b>lreplace</b>
<b>lsearch</b>	<b>lset</b>	<b>lsort</b>	<b>namespace</b>
<b>package</b>	<b>pid</b>	<b>proc</b>	<b>puts</b>
<b>read</b>	<b>regexp</b>	<b>regsub</b>	<b>rename</b>
<b>return</b>	<b>scan</b>	<b>seek</b>	<b>set</b>
<b>split</b>	<b>string</b>	<b>subst</b>	<b>switch</b>
<b>tell</b>	<b>time</b>	<b>trace</b>	<b>unset</b>
<b>update</b>	<b>uplevel</b>	<b>upvar</b>	<b>variable</b>
<b>vwait</b>	<b>while</b>
</pre>
</div>
<p class="Pp">The following commands are hidden by <b>interp create</b> when it
    creates a safe interpreter:</p>
<div class="Bd-indent">
<pre>

<b>cd</b>	<b>encoding</b>	<b>exec</b>	<b>exit</b>
<b>fconfigure</b>	<b>file</b>	<b>glob</b>	<b>load</b>
<b>open</b>	<b>pwd</b>	<b>socket</b>	<b>source</b>
<b>unload</b>
</pre>
</div>
<p class="Pp">These commands can be recreated later as Tcl procedures or
    aliases, or re-exposed by <b>interp expose</b>.</p>
<p class="Pp">The following commands from Tcl's library of support procedures
    are not present in a safe interpreter:</p>
<div class="Bd-indent">
<pre>

<b>auto_exec_ok</b>	<b>auto_import</b>	<b>auto_load</b>
<b>auto_load_index</b>	<b>auto_qualify</b>	<b>unknown</b>
</pre>
</div>
<p class="Pp">Note in particular that safe interpreters have no default
    <b>unknown</b> command, so Tcl's default autoloading facilities are not
    available. Autoload access to Tcl's commands that are normally
  autoloaded:</p>
<div class="Bd-indent">
<pre>

<b>auto_mkindex</b>	<b>auto_mkindex_old</b>
<b>auto_reset</b>	<b>history</b>
<b>parray</b>	<b>pkg_mkIndex</b>
<b>::pkg::create</b>	<b>::safe::interpAddToAccessPath</b>
<b>::safe::interpCreate</b>	<b>::safe::interpConfigure</b>
<b>::safe::interpDelete</b>	<b>::safe::interpFindInAccessPath</b>
<b>::safe::interpInit</b>	<b>::safe::setLogCmd</b>
<b>tcl_endOfWord</b>	<b>tcl_findLibrary</b>
<b>tcl_startOfNextWord</b>	<b>tcl_startOfPreviousWord</b>
<b>tcl_wordBreakAfter</b>	<b>tcl_wordBreakBefore</b>
</pre>
</div>
<p class="Pp">can only be provided by explicit definition of an <b>unknown</b>
    command in the safe interpreter. This will involve exposing the
    <b>source</b> command. This is most easily accomplished by creating the safe
    interpreter with Tcl's <b>Safe-Tcl</b> mechanism. <b>Safe-Tcl</b> provides
    safe versions of <b>source</b>, <b>load</b>, and other Tcl commands needed
    to support autoloading of commands and the loading of packages.</p>
<p class="Pp">In addition, the <b>env</b> variable is not present in a safe
    interpreter, so it cannot share environment variables with other
    interpreters. The <b>env</b> variable poses a security risk, because users
    can store sensitive information in an environment variable. For example, the
    PGP manual recommends storing the PGP private key protection password in the
    environment variable <i>PGPPASS</i>. Making this variable available to
    untrusted code executing in a safe interpreter would incur a security
  risk.</p>
<p class="Pp">If extensions are loaded into a safe interpreter, they may also
    restrict their own functionality to eliminate unsafe commands. For a
    discussion of management of extensions for safety see the manual entries for
    <b>Safe-Tcl</b> and the <b>load</b> Tcl command.</p>
<p class="Pp">A safe interpreter may not alter the recursion limit of any
    interpreter, including itself.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="ALIAS_INVOCATION"><a class="permalink" href="#ALIAS_INVOCATION">ALIAS
  INVOCATION</a></h1>
The alias mechanism has been carefully designed so that it can be used safely
  when an untrusted script is executing in a safe slave and the target of the
  alias is a trusted master. The most important thing in guaranteeing safety is
  to ensure that information passed from the slave to the master is never
  evaluated or substituted in the master; if this were to occur, it would enable
  an evil script in the slave to invoke arbitrary functions in the master, which
  would compromise security.
<p class="Pp">When the source for an alias is invoked in the slave interpreter,
    the usual Tcl substitutions are performed when parsing that command. These
    substitutions are carried out in the source interpreter just as they would
    be for any other command invoked in that interpreter. The command procedure
    for the source command takes its arguments and merges them with the
    <i>targetCmd</i> and <i>arg</i>s for the alias to create a new array of
    arguments. If the words of <i>srcCmd</i> were &#x201C;<i>srcCmd arg1 arg2
    ... argN</i>&#x201D;, the new set of words will be &#x201C;<i>targetCmd arg
    arg ... arg arg1 arg2 ... argN</i>&#x201D;, where <i>targetCmd</i> and
    <i>arg</i>s are the values supplied when the alias was created.
    <i>TargetCmd</i> is then used to locate a command procedure in the target
    interpreter, and that command procedure is invoked with the new set of
    arguments. An error occurs if there is no command named <i>targetCmd</i> in
    the target interpreter. No additional substitutions are performed on the
    words: the target command procedure is invoked directly, without going
    through the normal Tcl evaluation mechanism. Substitutions are thus
    performed on each word exactly once: <i>targetCmd</i> and <i>args</i> were
    substituted when parsing the command that created the alias, and <i>arg1 -
    argN</i> are substituted when the alias's source command is parsed in the
    source interpreter.</p>
<p class="Pp">When writing the <i>targetCmd</i>s for aliases in safe
    interpreters, it is very important that the arguments to that command never
    be evaluated or substituted, since this would provide an escape mechanism
    whereby the slave interpreter could execute arbitrary code in the master.
    This in turn would compromise the security of the system.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="HIDDEN_COMMANDS"><a class="permalink" href="#HIDDEN_COMMANDS">HIDDEN
  COMMANDS</a></h1>
Safe interpreters greatly restrict the functionality available to Tcl programs
  executing within them. Allowing the untrusted Tcl program to have direct
  access to this functionality is unsafe, because it can be used for a variety
  of attacks on the environment. However, there are times when there is a
  legitimate need to use the dangerous functionality in the context of the safe
  interpreter. For example, sometimes a program must be <b>source</b>d into the
  interpreter. Another example is Tk, where windows are bound to the hierarchy
  of windows for a specific interpreter; some potentially dangerous functions,
  e.g. window management, must be performed on these windows within the
  interpreter context.
<p class="Pp">The <b>interp</b> command provides a solution to this problem in
    the form of <i>hidden commands</i>. Instead of removing the dangerous
    commands entirely from a safe interpreter, these commands are hidden so they
    become unavailable to Tcl scripts executing in the interpreter. However,
    such hidden commands can be invoked by any trusted ancestor of the safe
    interpreter, in the context of the safe interpreter, using <b>interp</b>
    <b>invoke</b>. Hidden commands and exposed commands reside in separate name
    spaces. It is possible to define a hidden command and an exposed command by
    the same name within one interpreter.</p>
<p class="Pp">Hidden commands in a slave interpreter can be invoked in the body
    of procedures called in the master during alias invocation. For example, an
    alias for <b>source</b> could be created in a slave interpreter. When it is
    invoked in the slave interpreter, a procedure is called in the master
    interpreter to check that the operation is allowable (e.g. it asks to source
    a file that the slave interpreter is allowed to access). The procedure then
    it invokes the hidden <b>source</b> command in the slave interpreter to
    actually source in the contents of the file. Note that two commands named
    <b>source</b> exist in the slave interpreter: the alias, and the hidden
    command.</p>
<p class="Pp">Because a master interpreter may invoke a hidden command as part
    of handling an alias invocation, great care must be taken to avoid
    evaluating any arguments passed in through the alias invocation. Otherwise,
    malicious slave interpreters could cause a trusted master interpreter to
    execute dangerous commands on their behalf. See the section on <b>ALIAS
    INVOCATION</b> for a more complete discussion of this topic. To help avoid
    this problem, no substitutions or evaluations are applied to arguments of
    <b>interp invokehidden</b>.</p>
<p class="Pp">Safe interpreters are not allowed to invoke hidden commands in
    themselves or in their descendants. This prevents safe slaves from gaining
    access to hidden functionality in themselves or their descendants.</p>
<p class="Pp">The set of hidden commands in an interpreter can be manipulated by
    a trusted interpreter using <b>interp expose</b> and <b>interp hide</b>. The
    <b>interp</b> <b>expose</b> command moves a hidden command to the set of
    exposed commands in the interpreter identified by <i>path</i>, potentially
    renaming the command in the process. If an exposed command by the targeted
    name already exists, the operation fails. Similarly, <b>interp hide</b>
    moves an exposed command to the set of hidden commands in that interpreter.
    Safe interpreters are not allowed to move commands between the set of hidden
    and exposed commands, in either themselves or their descendants.</p>
<p class="Pp">Currently, the names of hidden commands cannot contain namespace
    qualifiers, and you must first rename a command in a namespace to the global
    namespace before you can hide it. Commands to be hidden by <b>interp
    hide</b> are looked up in the global namespace even if the current namespace
    is not the global one. This prevents slaves from fooling a master
    interpreter into hiding the wrong command, by making the current namespace
    be different from the global one.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="RESOURCE_LIMITS"><a class="permalink" href="#RESOURCE_LIMITS">RESOURCE
  LIMITS</a></h1>
<p class="Pp">Every interpreter has two kinds of resource limits that may be
    imposed by any master interpreter upon its slaves. Command limits (of type
    <b>command</b>) restrict the total number of Tcl commands that may be
    executed by an interpreter (as can be inspected via the <b>info cmdcount</b>
    command), and time limits (of type <b>time</b>) place a limit by which
    execution within the interpreter must complete. Note that time limits are
    expressed as <i>absolute</i> times (as in <b>clock seconds</b>) and not
    relative times (as in <b>after</b>) because they may be modified after
    creation.</p>
<p class="Pp">When a limit is exceeded for an interpreter, first any handler
    callbacks defined by master interpreters are called. If those callbacks
    increase or remove the limit, execution within the (previously) limited
    interpreter continues. If the limit is still in force, an error is generated
    at that point and normal processing of errors within the interpreter (by the
    <b>catch</b> command) is disabled, so the error propagates outwards
    (building a stack-trace as it goes) to the point where the limited
    interpreter was invoked (e.g. by <b>interp eval</b>) where it becomes the
    responsibility of the calling code to catch and handle.</p>
<section class="Ss">
<h2 class="Ss" id="LIMIT_OPTIONS"><a class="permalink" href="#LIMIT_OPTIONS">LIMIT
  OPTIONS</a></h2>
Every limit has a number of options associated with it, some of which are common
  across all kinds of limits, and others of which are particular to the kind of
  limit.
<dl class="Bl-tag">
  <dt><b>-command</b></dt>
  <dd>This option (common for all limit types) specifies (if non-empty) a Tcl
      script to be executed in the global namespace of the interpreter reading
      and writing the option when the particular limit in the limited
      interpreter is exceeded. The callback may modify the limit on the
      interpreter if it wishes the limited interpreter to continue executing. If
      the callback generates an error, it is reported through the background
      error mechanism (see <b>BACKGROUND ERROR</b> <b>HANDLING</b>). Note that
      the callbacks defined by one interpreter are completely isolated from the
      callbacks defined by another, and that the order in which those callbacks
      are called is undefined.</dd>
  <dt><b>-granularity</b></dt>
  <dd>This option (common for all limit types) specifies how frequently (out of
      the points when the Tcl interpreter is in a consistent state where limit
      checking is possible) that the limit is actually checked. This allows the
      tuning of how frequently a limit is checked, and hence how often the
      limit-checking overhead (which may be substantial in the case of time
      limits) is incurred.</dd>
  <dt><b>-milliseconds</b></dt>
  <dd>This option specifies the number of milliseconds after the moment defined
      in the <b>-seconds</b> option that the time limit will fire. It should
      only ever be specified in conjunction with the <b>-seconds</b> option
      (whether it was set previously or is being set this invocation.)</dd>
  <dt><b>-seconds</b></dt>
  <dd>This option specifies the number of seconds after the epoch (see
      <b>clock</b> <b>seconds</b>) that the time limit for the interpreter will
      be triggered. The limit will be triggered at the start of the second
      unless specified at a sub-second level using the <b>-milliseconds</b>
      option. This option may be the empty string, which indicates that a time
      limit is not set for the interpreter.</dd>
  <dt><b>-value</b></dt>
  <dd>This option specifies the number of commands that the interpreter may
      execute before triggering the command limit. This option may be the empty
      string, which indicates that a command limit is not set for the
      interpreter.</dd>
</dl>
<p class="Pp">Where an interpreter with a resource limit set on it creates a
    slave interpreter, that slave interpreter will have resource limits imposed
    on it that are at least as restrictive as the limits on the creating master
    interpreter. If the master interpreter of the limited master wishes to relax
    these conditions, it should hide the <b>interp</b> command in the child and
    then use aliases and the <b>interp invokehidden</b> subcommand to provide
    such access as it chooses to the <b>interp</b> command to the limited master
    as necessary.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="BACKGROUND_ERROR_HANDLING"><a class="permalink" href="#BACKGROUND_ERROR_HANDLING">BACKGROUND
  ERROR HANDLING</a></h1>
When an error happens in a situation where it cannot be reported directly up the
  stack (e.g. when processing events in an <b>update</b> or <b>vwait</b> call)
  the error is instead reported through the background error handling mechanism.
  Every interpreter has a background error handler registered; the default error
  handler arranges for the <b>bgerror</b> command in the interpreter's global
  namespace to be called, but other error handlers may be installed and process
  background errors in substantially different ways.
<p class="Pp">A background error handler consists of a non-empty list of words
    to which will be appended two further words at invocation time. The first
    word will be the error message string, and the second will a dictionary of
    return options (this is also the sort of information that can be obtained by
    trapping a normal error using <b>catch</b> of course.) The resulting list
    will then be executed in the interpreter's global namespace without further
    substitutions being performed.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="CREDITS"><a class="permalink" href="#CREDITS">CREDITS</a></h1>
The safe interpreter mechanism is based on the Safe-Tcl prototype implemented by
  Nathaniel Borenstein and Marshall Rose.
</section>
<section class="Sh">
<h1 class="Sh" id="EXAMPLES"><a class="permalink" href="#EXAMPLES">EXAMPLES</a></h1>
Creating and using an alias for a command in the current interpreter:
<div class="Bd-indent">
<pre>
<b>interp alias</b> {} getIndex {} lsearch {alpha beta gamma delta}
set idx [getIndex delta]
</pre>
</div>
<p class="Pp">Executing an arbitrary command in a safe interpreter where every
    invocation of <b>lappend</b> is logged:</p>
<div class="Bd-indent">
<pre>
set i [<b>interp create</b> -safe]
<b>interp hide</b> $i lappend
<b>interp alias</b> $i lappend {} loggedLappend $i
proc loggedLappend {i args} {
   puts &quot;logged invocation of lappend $args&quot;
   <b>interp invokehidden</b> $i lappend {*}$args
}
<b>interp eval</b> $i $someUntrustedScript
</pre>
</div>
<p class="Pp">Setting a resource limit on an interpreter so that an infinite
    loop terminates.</p>
<div class="Bd-indent">
<pre>
set i [<b>interp create</b>]
<b>interp limit</b> $i command -value 1000
<b>interp eval</b> $i {
   set x 0
   while {1} {
      puts &quot;Counting up... [incr x]&quot;
   }
}
</pre>
</div>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
bgerror(n), load(n), safe(n), Tcl_CreateSlave(3)
</section>
<section class="Sh">
<h1 class="Sh" id="KEYWORDS"><a class="permalink" href="#KEYWORDS">KEYWORDS</a></h1>
alias, master interpreter, safe interpreter, slave interpreter
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">7.6</td>
    <td class="foot-os">Tcl</td>
  </tr>
</table>
</body>
</html>
