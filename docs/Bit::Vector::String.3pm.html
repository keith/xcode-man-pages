<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.10 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>Bit::Vector::String(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Bit::Vector::String(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Bit::Vector::String(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
Bit::Vector::String - Generic string import/export for Bit::Vector
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<span class="Li"></span>
<pre>
  use Bit::Vector::String;

  to_Oct
      $string = $vector-&gt;to_Oct();

  from_Oct
      $vector-&gt;from_Oct($string);

  new_Oct
      $vector = Bit::Vector-&gt;new_Oct($bits,$string);

  String_Export
      $string = $vector-&gt;String_Export($type);

  String_Import
      $type = $vector-&gt;String_Import($string);

  new_String
      $vector = Bit::Vector-&gt;new_String($bits,$string);
      ($vector,$type) = Bit::Vector-&gt;new_String($bits,$string);
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<ul class="Bl-bullet">
  <li><span class="Li">&quot;$string = $vector-&gt;to_Oct();&quot;</span>
    <p class="Pp">Returns an octal string representing the given bit vector.</p>
    <p class="Pp">Note that this method is not particularly efficient, since it
        is almost completely realized in Perl, and moreover internally operates
        on a Perl list of individual octal digits which it concatenates into the
        final string using &quot;<span class="Li">&quot;join('',
        ...)&quot;</span>&quot;.</p>
    <p class="Pp">A benchmark reveals that this method is about 40 times slower
        than the method &quot;<span class="Li">&quot;to_Bin()&quot;</span>&quot;
        (which is realized in C):</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
 Benchmark: timing 10000 iterations of to_Bin, to_Hex, to_Oct...
     to_Bin:  1 wallclock secs ( 1.09 usr +  0.00 sys =  1.09 CPU)
     to_Hex:  1 wallclock secs ( 0.53 usr +  0.00 sys =  0.53 CPU)
     to_Oct: 40 wallclock secs (40.16 usr +  0.05 sys = 40.21 CPU)
    </pre>
    <p class="Pp">Note that since an octal digit is always worth three bits, the
        length of the resulting string is always a multiple of three bits,
        regardless of the true length (in bits) of the given bit vector.</p>
    <p class="Pp">Also note that the <b>LEAST</b> significant octal digit is
        located at the <b>RIGHT</b> end of the resulting string, and the
        <b>MOST</b> significant digit at the <b>LEFT</b> end.</p>
    <p class="Pp">Finally, note that this method does <b>NOT</b> prepend any
        uniquely identifying format prefix (such as &quot;0o&quot;) to the
        resulting string (which means that the result of this method only
        contains valid octal digits, i.e., [0-7]).</p>
    <p class="Pp">However, this can of course most easily be done as needed, as
        follows:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  $string = '0o' . $vector-&gt;to_Oct();
    </pre>
  </li>
  <li><span class="Li">&quot;$vector-&gt;from_Oct($string);&quot;</span>
    <p class="Pp">Allows to read in the contents of a bit vector from an octal
        string, such as returned by the method
        &quot;<span class="Li">&quot;to_Oct()&quot;</span>&quot; (see
      above).</p>
    <p class="Pp">Note that this method is not particularly efficient, since it
        is almost completely realized in Perl, and moreover chops the input
        string into individual characters using
        &quot;<span class="Li">&quot;split(//, $string)&quot;</span>&quot;.</p>
    <p class="Pp">Remember also that the least significant bits are always to
        the right of an octal string, and the most significant bits to the left.
        Therefore, the string is actually reversed internally before storing it
        in the given bit vector using the method
        &quot;<span class="Li">&quot;Chunk_List_Store()&quot;</span>&quot;,
        which expects the least significant chunks of data at the beginning of a
        list.</p>
    <p class="Pp">A benchmark reveals that this method is about 40 times slower
        than the method
        &quot;<span class="Li">&quot;from_Bin()&quot;</span>&quot; (which is
        realized in C):</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
 Benchmark: timing 10000 iterations of from_Bin, from_Hex, from_Oct...
   from_Bin:  1 wallclock secs ( 1.13 usr +  0.00 sys =  1.13 CPU)
   from_Hex:  1 wallclock secs ( 0.80 usr +  0.00 sys =  0.80 CPU)
   from_Oct: 46 wallclock secs (44.95 usr +  0.00 sys = 44.95 CPU)
    </pre>
    <p class="Pp">If the given string contains any character which is not an
        octal digit (i.e., [0-7]), a fatal syntax error ensues (&quot;unknown
        string type&quot;).</p>
    <p class="Pp">Note especially that this method does <b>NOT</b> accept any
        uniquely identifying format prefix (such as &quot;0o&quot;) in the given
        string; the presence of such a prefix will also lead to the fatal
        &quot;unknown string type&quot; error.</p>
    <p class="Pp">If the given string contains less octal digits than are needed
        to completely fill the given bit vector, the remaining (most
        significant) bits all remain cleared (i.e., set to zero).</p>
    <p class="Pp">This also means that, even if the given string does not
        contain enough digits to completely fill the given bit vector, the
        previous contents of the bit vector are erased completely.</p>
    <p class="Pp">If the given string is longer than it needs to fill the given
        bit vector, the superfluous characters are simply ignored.</p>
    <p class="Pp">This behaviour is intentional so that you may read in the
        string representing one bit vector into another bit vector of different
        size, i.e., as much of it as will fit.</p>
  </li>
  <li><span class="Li">&quot;$vector =
      Bit::Vector-&gt;new_Oct($bits,$string);&quot;</span>
    <p class="Pp">This method is an alternative constructor which allows you to
        create a new bit vector object (with
        &quot;<span class="Li">$bits</span>&quot; bits) and to initialize it all
        in one go.</p>
    <p class="Pp">The method internally first calls the bit vector constructor
        method &quot;<span class="Li">&quot;new()&quot;</span>&quot; and then
        stores the given string in the newly created bit vector using the same
        approach as the method
        &quot;<span class="Li">&quot;from_Oct()&quot;</span>&quot; (described
        above).</p>
    <p class="Pp">Note that this approach is not particularly efficient, since
        it is almost completely realized in Perl, and moreover chops the input
        string into individual characters using
        &quot;<span class="Li">&quot;split(//, $string)&quot;</span>&quot;.</p>
    <p class="Pp">An exception will be raised if the necessary memory cannot be
        allocated (see the description of the method
        &quot;<span class="Li">&quot;new()&quot;</span>&quot; in
        <b>Bit::Vector</b>(3) for possible causes) or if the given string cannot
        be converted successfully (see the description of the method
        &quot;<span class="Li">&quot;from_Oct()&quot;</span>&quot; above for
        details).</p>
    <p class="Pp">Note especially that this method does <b>NOT</b> accept any
        uniquely identifying format prefix (such as &quot;0o&quot;) in the given
        string and that such a prefix will lead to a fatal &quot;unknown string
        type&quot; error.</p>
    <p class="Pp">In case of an error, the memory occupied by the new bit vector
        is released again before the exception is actually thrown.</p>
    <p class="Pp">If the number of bits
        &quot;<span class="Li">$bits</span>&quot; given has the value
        &quot;<span class="Li">&quot;undef&quot;</span>&quot;, the method will
        automatically allocate a bit vector with a size (i.e., number of bits)
        of three times the length of the given string (since every octal digit
        is worth three bits).</p>
    <p class="Pp">Note that this behaviour is different from that of the methods
        &quot;<span class="Li">&quot;new_Hex()&quot;</span>&quot;,
        &quot;<span class="Li">&quot;new_Bin()&quot;</span>&quot;,
        &quot;<span class="Li">&quot;new_Dec()&quot;</span>&quot; and
        &quot;<span class="Li">&quot;new_Enum()&quot;</span>&quot; (which are
        realized in C, internally); these methods will silently assume a value
        of 0 bits if &quot;<span class="Li">&quot;undef&quot;</span>&quot; is
        given (and may warn about the &quot;Use of uninitialized value&quot; if
        warnings are enabled).</p>
  </li>
  <li><span class="Li">&quot;$string =
      $vector-&gt;String_Export($type);&quot;</span>
    <p class="Pp">Returns a string representing the given bit vector in the
        format specified by &quot;<span class="Li">$type</span>&quot;:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  1 | b | bin      =&gt;  binary        (using &quot;to_Bin()&quot;)
  2 | o | oct      =&gt;  octal         (using &quot;to_Oct()&quot;)
  3 | d | dec      =&gt;  decimal       (using &quot;to_Dec()&quot;)
  4 | h | hex | x  =&gt;  hexadecimal   (using &quot;to_Hex()&quot;)
  5 | e | enum     =&gt;  enumeration   (using &quot;to_Enum()&quot;)
  6 | p | pack     =&gt;  packed binary (using &quot;Block_Read()&quot;)
    </pre>
    <p class="Pp">The case (lower/upper/mixed case) of
        &quot;<span class="Li">$type</span>&quot; is ignored.</p>
    <p class="Pp">If &quot;<span class="Li">$type</span>&quot; is omitted or
        &quot;<span class="Li">&quot;undef&quot;</span>&quot; or false
        (&quot;0&quot; or the empty string), a hexadecimal string is returned as
        the default format.</p>
    <p class="Pp">If &quot;<span class="Li">$type</span>&quot; does not have any
        of the values described above, a fatal &quot;unknown string type&quot;
        will occur.</p>
    <p class="Pp">Beware that in order to guarantee that the strings can be
        correctly parsed and read in by the methods
        &quot;<span class="Li">&quot;String_Import()&quot;</span>&quot; and
        &quot;<span class="Li">&quot;new_String()&quot;</span>&quot; (described
        below), the method
        &quot;<span class="Li">&quot;String_Export()&quot;</span>&quot; provides
        uniquely identifying prefixes (and, in one case, a suffix) as
      follows:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  1 | b | bin      =&gt;  '0b' . $vector-&gt;to_Bin();
  2 | o | oct      =&gt;  '0o' . $vector-&gt;to_Oct();
  3 | d | dec      =&gt;         $vector-&gt;to_Dec(); # prefix is [+-]
  4 | h | hex | x  =&gt;  '0x' . $vector-&gt;to_Hex();
  5 | e | enum     =&gt;  '{'  . $vector-&gt;to_Enum() . '}';
  6 | p | pack     =&gt;  ':'  . $vector-&gt;Size() .
                       ':'  . $vector-&gt;Block_Read();
    </pre>
    <p class="Pp">This is necessary because certain strings can be valid
        representations in more than one format.</p>
    <p class="Pp">All strings in binary format, i.e., which only contain
        &quot;0&quot; and &quot;1&quot;, are also valid number representations
        (of a different value, of course) in octal, decimal and hexadecimal.</p>
    <p class="Pp">Likewise, a string in octal format is also valid in decimal
        and hexadecimal, and a string in decimal format is also valid in
        hexadecimal.</p>
    <p class="Pp">Moreover, if the enumeration of set bits (as returned by
        &quot;<span class="Li">&quot;to_Enum()&quot;</span>&quot;) only contains
        one element, this element could be mistaken for a representation of the
        entire bit vector (instead of just one bit) in decimal.</p>
    <p class="Pp">Beware also that the string returned by format &quot;6&quot;
        (&quot;packed binary&quot;) will in general <b>NOT BE PRINTABLE</b>,
        because it will usually consist of many unprintable characters!</p>
  </li>
  <li><span class="Li">&quot;$type =
      $vector-&gt;String_Import($string);&quot;</span>
    <p class="Pp">Allows to read in the contents of a bit vector from a string
        which has previously been produced by
        &quot;<span class="Li">&quot;String_Export()&quot;</span>&quot;,
        &quot;<span class="Li">&quot;to_Bin()&quot;</span>&quot;,
        &quot;<span class="Li">&quot;to_Oct()&quot;</span>&quot;,
        &quot;<span class="Li">&quot;to_Dec()&quot;</span>&quot;,
        &quot;<span class="Li">&quot;to_Hex()&quot;</span>&quot;,
        &quot;<span class="Li">&quot;to_Enum()&quot;</span>&quot;,
        &quot;<span class="Li">&quot;Block_Read()&quot;</span>&quot; or manually
        or by another program.</p>
    <p class="Pp">Beware however that the string must have the correct format;
        otherwise a fatal &quot;unknown string type&quot; error will occur.</p>
    <p class="Pp">The correct format is the one returned by
        &quot;<span class="Li">&quot;String_Export()&quot;</span>&quot; (see
        immediately above).</p>
    <p class="Pp">The method will also try to automatically recognize formats
        without identifying prefix such as returned by the methods
        &quot;<span class="Li">&quot;to_Bin()&quot;</span>&quot;,
        &quot;<span class="Li">&quot;to_Oct()&quot;</span>&quot;,
        &quot;<span class="Li">&quot;to_Dec()&quot;</span>&quot;,
        &quot;<span class="Li">&quot;to_Hex()&quot;</span>&quot; and
        &quot;<span class="Li">&quot;to_Enum()&quot;</span>&quot;.</p>
    <p class="Pp">However, as explained above for the method
        &quot;<span class="Li">&quot;String_Export()&quot;</span>&quot;, due to
        the fact that a string may be a valid representation in more than one
        format, this may lead to unwanted results.</p>
    <p class="Pp">The method will try to match the format of the given string in
        the following order:</p>
    <p class="Pp">If the string consists only of [01], it will be considered to
        be in binary format (although it could be in octal, decimal or
        hexadecimal format or even be an enumeration with only one element as
        well).</p>
    <p class="Pp">If the string consists only of [0-7], it will be considered to
        be in octal format (although it could be in decimal or hexadecimal
        format or even be an enumeration with only one element as well).</p>
    <p class="Pp">If the string consists only of [0-9], it will be considered to
        be in decimal format (although it could be in hexadecimal format or even
        be an enumeration with only one element as well).</p>
    <p class="Pp">If the string consists only of [0-9A-Fa-f], it will be
        considered to be in hexadecimal format.</p>
    <p class="Pp">If the string only contains numbers in decimal format,
        separated by commas (&quot;,&quot;) or dashes (&quot;-&quot;), it is
        considered to be an enumeration (a single decimal number also
        qualifies).</p>
    <p class="Pp">And if the string starts with &quot;:[0-9]:&quot;, the
        remainder of the string is read in with
        &quot;<span class="Li">&quot;Block_Store()&quot;</span>&quot;.</p>
    <p class="Pp">To avoid misinterpretations, it is therefore recommendable to
        always either use the method
        &quot;<span class="Li">&quot;String_Export()&quot;</span>&quot; or to
        provide some uniquely identifying prefix (and suffix, in one case)
        yourself:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  binary         =&gt;  '0b' . $string;
  octal          =&gt;  '0o' . $string;
  decimal        =&gt;  '+'  . $string; # in case &quot;$string&quot;
                 =&gt;  '-'  . $string; # has no sign yet
  hexadecimal    =&gt;  '0x' . $string;
                 =&gt;  '0h' . $string;
  enumeration    =&gt;  '{'  . $string . '}';
                 =&gt;  '['  . $string . ']';
                 =&gt;  '&lt;'  . $string . '&gt;';
                 =&gt;  '('  . $string . ')';
  packed binary  =&gt;  ':'  . $vector-&gt;Size() .
                     ':'  . $vector-&gt;Block_Read();
    </pre>
    <p class="Pp">Note that case (lower/upper/mixed case) is not important and
        will be ignored by this method.</p>
    <p class="Pp">Internally, the method uses the methods
        &quot;<span class="Li">&quot;from_Bin()&quot;</span>&quot;,
        &quot;<span class="Li">&quot;from_Oct()&quot;</span>&quot;,
        &quot;<span class="Li">&quot;from_Dec()&quot;</span>&quot;,
        &quot;<span class="Li">&quot;from_Hex()&quot;</span>&quot;,
        &quot;<span class="Li">&quot;from_Enum()&quot;</span>&quot; and
        &quot;<span class="Li">&quot;Block_Store()&quot;</span>&quot; for
        actually importing the contents of the string into the given bit vector.
        See their descriptions here in this document and in
        <b>Bit::Vector</b>(3) for any further conditions that must be met and
        corresponding possible fatal error messages.</p>
    <p class="Pp">The method returns the number of the format that has been
        recognized:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
                1    =&gt;    binary
                2    =&gt;    octal
                3    =&gt;    decimal
                4    =&gt;    hexadecimal
                5    =&gt;    enumeration
                6    =&gt;    packed binary
    </pre>
  </li>
  <li><span class="Li">&quot;$vector =
      Bit::Vector-&gt;new_String($bits,$string);&quot;</span>
    <p class="Pp"><span class="Li">&quot;($vector,$type) =
        Bit::Vector-&gt;new_String($bits,$string);&quot;</span></p>
    <p class="Pp">This method is an alternative constructor which allows you to
        create a new bit vector object (with
        &quot;<span class="Li">$bits</span>&quot; bits) and to initialize it all
        in one go.</p>
    <p class="Pp">The method internally first calls the bit vector constructor
        method &quot;<span class="Li">&quot;new()&quot;</span>&quot; and then
        stores the given string in the newly created bit vector using the same
        approach as the method
        &quot;<span class="Li">&quot;String_Import()&quot;</span>&quot;
        (described immediately above).</p>
    <p class="Pp">An exception will be raised if the necessary memory cannot be
        allocated (see the description of the method
        &quot;<span class="Li">&quot;new()&quot;</span>&quot; in
        <b>Bit::Vector</b>(3) for possible causes) or if the given string cannot
        be converted successfully (see the description of the method
        &quot;<span class="Li">&quot;String_Import()&quot;</span>&quot; above
        for details).</p>
    <p class="Pp">In case of an error, the memory occupied by the new bit vector
        is released again before the exception is actually thrown.</p>
    <p class="Pp">If the number of bits
        &quot;<span class="Li">$bits</span>&quot; given has the value
        &quot;<span class="Li">&quot;undef&quot;</span>&quot;, the method will
        automatically determine this value for you and allocate a bit vector of
        the calculated size.</p>
    <p class="Pp">Note that this behaviour is different from that of the methods
        &quot;<span class="Li">&quot;new_Hex()&quot;</span>&quot;,
        &quot;<span class="Li">&quot;new_Bin()&quot;</span>&quot;,
        &quot;<span class="Li">&quot;new_Dec()&quot;</span>&quot; and
        &quot;<span class="Li">&quot;new_Enum()&quot;</span>&quot; (which are
        realized in C, internally); these methods will silently assume a value
        of 0 bits if &quot;<span class="Li">&quot;undef&quot;</span>&quot; is
        given (and may warn about the &quot;Use of uninitialized value&quot; if
        warnings are enabled).</p>
    <p class="Pp">The necessary number of bits is calculated as follows:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  binary         =&gt;       length($string);
  octal          =&gt;   3 * length($string);
  decimal        =&gt;  int( length($string) * log(10) / log(2) + 1 );
  hexadecimal    =&gt;   4 * length($string);
  enumeration    =&gt;  maximum of values found in $string + 1
  packed binary  =&gt;  $string =~ /^:(\d+):/;
    </pre>
    <p class="Pp">If called in scalar context, the method returns the newly
        created bit vector object.</p>
    <p class="Pp">If called in list context, the method additionally returns the
        number of the format which has been recognized, as explained above for
        the method
        &quot;<span class="Li">&quot;String_Import()&quot;</span>&quot;.</p>
  </li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<b>Bit::Vector</b>(3), <b>Bit::Vector::Overload</b>(3).
</section>
<section class="Sh">
<h1 class="Sh" id="VERSION"><a class="permalink" href="#VERSION">VERSION</a></h1>
This man page documents &quot;Bit::Vector::String&quot; version 7.4.
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<span class="Li"></span>
<pre>
  Steffen Beyer
  mailto:STBEY@cpan.org
  http://www.engelschall.com/u/sb/download/
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT"><a class="permalink" href="#COPYRIGHT">COPYRIGHT</a></h1>
Copyright (c) 2004 - 2013 by Steffen Beyer. All rights reserved.
</section>
<section class="Sh">
<h1 class="Sh" id="LICENSE"><a class="permalink" href="#LICENSE">LICENSE</a></h1>
This package is free software; you can redistribute it and/or modify it under
  the same terms as Perl itself, i.e., under the terms of the &quot;Artistic
  License&quot; or the &quot;GNU General Public License&quot;.
<p class="Pp">The C library at the core of this Perl module can additionally be
    redistributed and/or modified under the terms of the &quot;GNU Library
    General Public License&quot;.</p>
<p class="Pp">Please refer to the files &quot;Artistic.txt&quot;,
    &quot;GNU_GPL.txt&quot; and &quot;GNU_LGPL.txt&quot; in this distribution
    for details!</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DISCLAIMER"><a class="permalink" href="#DISCLAIMER">DISCLAIMER</a></h1>
This package is distributed in the hope that it will be useful, but WITHOUT ANY
  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
  A PARTICULAR PURPOSE.
<p class="Pp">See the &quot;GNU General Public License&quot; for more
  details.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2013-09-03</td>
    <td class="foot-os">perl v5.28.2</td>
  </tr>
</table>
</body>
</html>
