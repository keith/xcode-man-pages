<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>Try::Tiny(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Try::Tiny(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Try::Tiny(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
Try::Tiny - minimal try/catch with proper preservation of $@
</section>
<section class="Sh">
<h1 class="Sh" id="VERSION"><a class="permalink" href="#VERSION">VERSION</a></h1>
version 0.19
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
You can use Try::Tiny's <span class="Li">&quot;try&quot;</span> and
  <span class="Li">&quot;catch&quot;</span> to expect and handle exceptional
  conditions, avoiding quirks in Perl and common mistakes:
<p class="Pp"><span class="Li"></span></p>
<pre>
  # handle errors with a catch handler
  try {
    die &quot;foo&quot;;
  } catch {
    warn &quot;caught error: $_&quot;; # not $@
  };
</pre>
<p class="Pp">You can also use it like a standalone
    <span class="Li">&quot;eval&quot;</span> to catch and ignore any error
    conditions. Obviously, this is an extreme measure not to be undertaken
    lightly:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  # just silence errors
  try {
    die &quot;foo&quot;;
  };
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
This module provides bare bones
  <span class="Li">&quot;try&quot;</span>/<span class="Li">&quot;catch&quot;</span>/<span class="Li">&quot;finally&quot;</span>
  statements that are designed to minimize common mistakes with eval blocks, and
  NOTHING else.
<p class="Pp">This is unlike TryCatch which provides a nice syntax and avoids
    adding another call stack layer, and supports calling
    <span class="Li">&quot;return&quot;</span> from the
    <span class="Li">&quot;try&quot;</span> block to return from the parent
    subroutine. These extra features come at a cost of a few dependencies,
    namely Devel::Declare and Scope::Upper which are occasionally problematic,
    and the additional catch filtering uses Moose type constraints which may not
    be desirable either.</p>
<p class="Pp">The main focus of this module is to provide simple and reliable
    error handling for those having a hard time installing TryCatch, but who
    still want to write correct <span class="Li">&quot;eval&quot;</span> blocks
    without 5 lines of boilerplate each time.</p>
<p class="Pp">It's designed to work as correctly as possible in light of the
    various pathological edge cases (see &quot;BACKGROUND&quot;) and to be
    compatible with any style of error values (simple strings, references,
    objects, overloaded objects, etc).</p>
<p class="Pp">If the <span class="Li">&quot;try&quot;</span> block dies, it
    returns the value of the last statement executed in the
    <span class="Li">&quot;catch&quot;</span> block, if there is one. Otherwise,
    it returns <span class="Li">&quot;undef&quot;</span> in scalar context or
    the empty list in list context. The following examples all assign
    <span class="Li">&quot;bar&quot;</span> to <span class="Li">$x</span>:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  my $x = try { die &quot;foo&quot; } catch { &quot;bar&quot; };
  my $x = try { die &quot;foo&quot; } || { &quot;bar&quot; };
  my $x = (try { die &quot;foo&quot; }) // { &quot;bar&quot; };

  my $x = eval { die &quot;foo&quot; } || &quot;bar&quot;;
</pre>
<p class="Pp">You can add <span class="Li">&quot;finally&quot;</span> blocks,
    yielding the following:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  my $x;
  try { die 'foo' } finally { $x = 'bar' };
  try { die 'foo' } catch { warn &quot;Got a die: $_&quot; } finally { $x = 'bar' };
</pre>
<p class="Pp"><span class="Li">&quot;finally&quot;</span> blocks are always
    executed making them suitable for cleanup code which cannot be handled using
    local. You can add as many <span class="Li">&quot;finally&quot;</span>
    blocks to a given <span class="Li">&quot;try&quot;</span> block as you
  like.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="EXPORTS"><a class="permalink" href="#EXPORTS">EXPORTS</a></h1>
All functions are exported by default using Exporter.
<p class="Pp">If you need to rename the <span class="Li">&quot;try&quot;</span>,
    <span class="Li">&quot;catch&quot;</span> or
    <span class="Li">&quot;finally&quot;</span> keyword consider using
    Sub::Import to get Sub::Exporter's flexibility.</p>
<dl class="Bl-tag">
  <dt>try (&amp;;@)</dt>
  <dd>Takes one mandatory <span class="Li">&quot;try&quot;</span> subroutine, an
      optional <span class="Li">&quot;catch&quot;</span> subroutine and
      <span class="Li">&quot;finally&quot;</span> subroutine.
    <p class="Pp">The mandatory subroutine is evaluated in the context of an
        <span class="Li">&quot;eval&quot;</span> block.</p>
    <p class="Pp">If no error occurred the value from the first block is
        returned, preserving list/scalar context.</p>
    <p class="Pp">If there was an error and the second subroutine was given it
        will be invoked with the error in <span class="Li">$_</span> (localized)
        and as that block's first and only argument.</p>
    <p class="Pp"><span class="Li">$@</span> does <b>not</b> contain the error.
        Inside the <span class="Li">&quot;catch&quot;</span> block it has the
        same value it had before the <span class="Li">&quot;try&quot;</span>
        block was executed.</p>
    <p class="Pp">Note that the error may be false, but if that happens the
        <span class="Li">&quot;catch&quot;</span> block will still be
      invoked.</p>
    <p class="Pp">Once all execution is finished then the
        <span class="Li">&quot;finally&quot;</span> block, if given, will
        execute.</p>
  </dd>
  <dt>catch (&amp;;@)</dt>
  <dd>Intended to be used in the second argument position of
      <span class="Li">&quot;try&quot;</span>.
    <p class="Pp">Returns a reference to the subroutine it was given but blessed
        as <span class="Li">&quot;Try::Tiny::Catch&quot;</span> which allows try
        to decode correctly what to do with this code reference.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  catch { ... }
    </pre>
    <p class="Pp">Inside the <span class="Li">&quot;catch&quot;</span> block the
        caught error is stored in <span class="Li">$_</span>, while previous
        value of <span class="Li">$@</span> is still available for use. This
        value may or may not be meaningful depending on what happened before the
        <span class="Li">&quot;try&quot;</span>, but it might be a good idea to
        preserve it in an error stack.</p>
    <p class="Pp">For code that captures <span class="Li">$@</span> when
        throwing new errors (i.e. Class::Throwable), you'll need to do:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  local $@ = $_;
    </pre>
  </dd>
  <dt>finally (&amp;;@)</dt>
  <dd><span class="Li"></span>
    <pre>
  try     { ... }
  catch   { ... }
  finally { ... };
    </pre>
    <p class="Pp">Or</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  try     { ... }
  finally { ... };
    </pre>
    <p class="Pp">Or even</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  try     { ... }
  finally { ... }
  catch   { ... };
    </pre>
    <p class="Pp">Intended to be the second or third element of
        <span class="Li">&quot;try&quot;</span>.
        <span class="Li">&quot;finally&quot;</span> blocks are always executed
        in the event of a successful <span class="Li">&quot;try&quot;</span> or
        if <span class="Li">&quot;catch&quot;</span> is run. This allows you to
        locate cleanup code which cannot be done via
        <span class="Li">&quot;local()&quot;</span> e.g. closing a file
      handle.</p>
    <p class="Pp">When invoked, the <span class="Li">&quot;finally&quot;</span>
        block is passed the error that was caught. If no error was caught, it is
        passed nothing. (Note that the
        <span class="Li">&quot;finally&quot;</span> block does not localize
        <span class="Li">$_</span> with the error, since unlike in a
        <span class="Li">&quot;catch&quot;</span> block, there is no way to know
        if <span class="Li">&quot;$_ == undef&quot;</span> implies that there
        were no errors.) In other words, the following code does just what you
        would expect:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  try {
    die_sometimes();
  } catch {
    # ...code run in case of error
  } finally {
    if (@_) {
      print &quot;The try block died with: @_\n&quot;;
    } else {
      print &quot;The try block ran without error.\n&quot;;
    }
  };
    </pre>
    <p class="Pp"><b>You must always do your own error handling in the
        </b><b>&quot;finally&quot;</b><b> block</b>.
        <span class="Li">&quot;Try::Tiny&quot;</span> will not do anything about
        handling possible errors coming from code located in these blocks.</p>
    <p class="Pp">Furthermore <b>exceptions in </b><b>&quot;finally&quot;</b><b>
        blocks are not trappable and are unable</b> <b>to influence the
        execution of your program</b>. This is due to limitation of
        <span class="Li">&quot;DESTROY&quot;</span>-based scope guards, which
        <span class="Li">&quot;finally&quot;</span> is implemented on top of.
        This may change in a future version of Try::Tiny.</p>
    <p class="Pp">In the same way <span class="Li">&quot;catch()&quot;</span>
        blesses the code reference this subroutine does the same except it bless
        them as <span class="Li">&quot;Try::Tiny::Finally&quot;</span>.</p>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="BACKGROUND"><a class="permalink" href="#BACKGROUND">BACKGROUND</a></h1>
There are a number of issues with <span class="Li">&quot;eval&quot;</span>.
<section class="Ss">
<h2 class="Ss" id="Clobbering_$@"><a class="permalink" href="#Clobbering_$@">Clobbering
  $@</a></h2>
When you run an <span class="Li">&quot;eval&quot;</span> block and it succeeds,
  <span class="Li">$@</span> will be cleared, potentially clobbering an error
  that is currently being caught.
<p class="Pp">This causes action at a distance, clearing previous errors your
    caller may have not yet handled.</p>
<p class="Pp"><span class="Li">$@</span> must be properly localized before
    invoking <span class="Li">&quot;eval&quot;</span> in order to avoid this
    issue.</p>
<p class="Pp">More specifically, <span class="Li">$@</span> is clobbered at the
    beginning of the <span class="Li">&quot;eval&quot;</span>, which also makes
    it impossible to capture the previous error before you die (for instance
    when making exception objects with error stacks).</p>
<p class="Pp">For this reason <span class="Li">&quot;try&quot;</span> will
    actually set <span class="Li">$@</span> to its previous value (the one
    available before entering the <span class="Li">&quot;try&quot;</span> block)
    in the beginning of the <span class="Li">&quot;eval&quot;</span> block.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Localizing_$@_silently_masks_errors"><a class="permalink" href="#Localizing_$@_silently_masks_errors">Localizing
  $@ silently masks errors</a></h2>
Inside an <span class="Li">&quot;eval&quot;</span> block,
  <span class="Li">&quot;die&quot;</span> behaves sort of like:
<p class="Pp"><span class="Li"></span></p>
<pre>
  sub die {
    $@ = $_[0];
    return_undef_from_eval();
  }
</pre>
<p class="Pp">This means that if you were polite and localized
    <span class="Li">$@</span> you can't die in that scope, or your error will
    be discarded (printing &quot;Something's wrong&quot; instead).</p>
<p class="Pp">The workaround is very ugly:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  my $error = do {
    local $@;
    eval { ... };
    $@;
  };

  ...
  die $error;
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="$@_might_not_be_a_true_value"><a class="permalink" href="#$@_might_not_be_a_true_value">$@
  might not be a true value</a></h2>
This code is wrong:
<p class="Pp"><span class="Li"></span></p>
<pre>
  if ( $@ ) {
    ...
  }
</pre>
<p class="Pp">because due to the previous caveats it may have been unset.</p>
<p class="Pp"><span class="Li">$@</span> could also be an overloaded error
    object that evaluates to false, but that's asking for trouble anyway.</p>
<p class="Pp">The classic failure mode is:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  sub Object::DESTROY {
    eval { ... }
  }

  eval {
    my $obj = Object-&gt;new;

    die &quot;foo&quot;;
  };

  if ( $@ ) {

  }
</pre>
<p class="Pp">In this case since
    <span class="Li">&quot;Object::DESTROY&quot;</span> is not localizing
    <span class="Li">$@</span> but still uses
    <span class="Li">&quot;eval&quot;</span>, it will set
    <span class="Li">$@</span> to <span class="Li">&quot;&quot;</span>.</p>
<p class="Pp">The destructor is called when the stack is unwound, after
    <span class="Li">&quot;die&quot;</span> sets <span class="Li">$@</span> to
    <span class="Li">&quot;foo at Foo.pm line 42\n&quot;</span>, so by the time
    <span class="Li">&quot;if ( $@ )&quot;</span> is evaluated it has been
    cleared by <span class="Li">&quot;eval&quot;</span> in the destructor.</p>
<p class="Pp">The workaround for this is even uglier than the previous ones.
    Even though we can't save the value of <span class="Li">$@</span> from code
    that doesn't localize, we can at least be sure the
    <span class="Li">&quot;eval&quot;</span> was aborted due to an error:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  my $failed = not eval {
    ...

    return 1;
  };
</pre>
<p class="Pp">This is because an <span class="Li">&quot;eval&quot;</span> that
    caught a <span class="Li">&quot;die&quot;</span> will always return a false
    value.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="SHINY_SYNTAX"><a class="permalink" href="#SHINY_SYNTAX">SHINY
  SYNTAX</a></h1>
Using Perl 5.10 you can use &quot;Switch statements&quot; in perlsyn.
<p class="Pp">The <span class="Li">&quot;catch&quot;</span> block is invoked in
    a topicalizer context (like a <span class="Li">&quot;given&quot;</span>
    block), but note that you can't return a useful value from
    <span class="Li">&quot;catch&quot;</span> using the
    <span class="Li">&quot;when&quot;</span> blocks without an explicit
    <span class="Li">&quot;return&quot;</span>.</p>
<p class="Pp">This is somewhat similar to Perl 6's
    <span class="Li">&quot;CATCH&quot;</span> blocks. You can use it to
    concisely match errors:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  try {
    require Foo;
  } catch {
    when (/^Can't locate .*?\.pm in \@INC/) { } # ignore
    default { die $_ }
  };
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="CAVEATS"><a class="permalink" href="#CAVEATS">CAVEATS</a></h1>
<ul class="Bl-bullet">
  <li><span class="Li">@_</span> is not available within the
      <span class="Li">&quot;try&quot;</span> block, so you need to copy your
      arglist. In case you want to work with argument values directly via
      <span class="Li">@_</span> aliasing (i.e. allow
      <span class="Li">&quot;$_[1] = &quot;foo&quot;&quot;</span>), you need to
      pass <span class="Li">@_</span> by reference:
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  sub foo {
    my ( $self, @args ) = @_;
    try { $self-&gt;bar(@args) }
  }
    </pre>
    <p class="Pp">or</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  sub bar_in_place {
    my $self = shift;
    my $args = \@_;
    try { $_ = $self-&gt;bar($_) for @$args }
  }
    </pre>
  </li>
  <li><span class="Li">&quot;return&quot;</span> returns from the
      <span class="Li">&quot;try&quot;</span> block, not from the parent sub
      (note that this is also how <span class="Li">&quot;eval&quot;</span>
      works, but not how TryCatch works):
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  sub parent_sub {
    try {
      die;
    }
    catch {
      return;
    };

    say &quot;this text WILL be displayed, even though an exception is thrown&quot;;
  }
    </pre>
    <p class="Pp">Instead, you should capture the return value:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  sub parent_sub {
    my $success = try {
      die;
      1;
    };
    return unless $success;

    say &quot;This text WILL NEVER appear!&quot;;
  }
  # OR
  sub parent_sub_with_catch {
    my $success = try {
      die;
      1;
    }
    catch {
      # do something with $_
      return undef; #see note
    };
    return unless $success;

    say &quot;This text WILL NEVER appear!&quot;;
  }
    </pre>
    <p class="Pp">Note that if you have a
        <span class="Li">&quot;catch&quot;</span> block, it must return
        <span class="Li">&quot;undef&quot;</span> for this to work, since if a
        <span class="Li">&quot;catch&quot;</span> block exists, its return value
        is returned in place of <span class="Li">&quot;undef&quot;</span> when
        an exception is thrown.</p>
  </li>
  <li><span class="Li">&quot;try&quot;</span> introduces another caller stack
      frame. Sub::Uplevel is not used. Carp will not report this when using full
      stack traces, though, because <span class="Li">%Carp::Internal</span> is
      used. This lack of magic is considered a feature.</li>
  <li>The value of <span class="Li">$_</span> in the
      <span class="Li">&quot;catch&quot;</span> block is not guaranteed to be
      the value of the exception thrown (<span class="Li">$@</span>) in the
      <span class="Li">&quot;try&quot;</span> block. There is no safe way to
      ensure this, since <span class="Li">&quot;eval&quot;</span> may be used
      unhygenically in destructors. The only guarantee is that the
      <span class="Li">&quot;catch&quot;</span> will be called if an exception
      is thrown.</li>
  <li>The return value of the <span class="Li">&quot;catch&quot;</span> block is
      not ignored, so if testing the result of the expression for truth on
      success, be sure to return a false value from the
      <span class="Li">&quot;catch&quot;</span> block:
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  my $obj = try {
    MightFail-&gt;new;
  } catch {
    ...

    return; # avoid returning a true value;
  };

  return unless $obj;
    </pre>
  </li>
  <li><span class="Li">$SIG{__DIE__}</span> is still in effect.
    <p class="Pp">Though it can be argued that
        <span class="Li">$SIG{__DIE__}</span> should be disabled inside of
        <span class="Li">&quot;eval&quot;</span> blocks, since it isn't people
        have grown to rely on it. Therefore in the interests of compatibility,
        <span class="Li">&quot;try&quot;</span> does not disable
        <span class="Li">$SIG{__DIE__}</span> for the scope of the error
        throwing code.</p>
  </li>
  <li>Lexical <span class="Li">$_</span> may override the one set by
      <span class="Li">&quot;catch&quot;</span>.
    <p class="Pp">For example Perl 5.10's
        <span class="Li">&quot;given&quot;</span> form uses a lexical
        <span class="Li">$_</span>, creating some confusing behavior:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  given ($foo) {
    when (...) {
      try {
        ...
      } catch {
        warn $_; # will print $foo, not the error
        warn $_[0]; # instead, get the error like this
      }
    }
  }
    </pre>
    <p class="Pp">Note that this behavior was changed once again in Perl5
        version 18
      
        &lt;https://metacpan.org/module/perldelta#given-now-aliases-the-global-_&gt;.
        However, since the entirety of lexical <span class="Li">$_</span> is now
        considired experimental
      
        &lt;https://metacpan.org/module/perldelta#Lexical-_-is-now-experimental&gt;,
        it is unclear whether the new version 18 behavior is final.</p>
  </li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<dl class="Bl-tag">
  <dt>TryCatch</dt>
  <dd>Much more feature complete, more convenient semantics, but at the cost of
      implementation complexity.</dd>
  <dt>autodie</dt>
  <dd>Automatic error throwing for builtin functions and more. Also designed to
      work well with
      <span class="Li">&quot;given&quot;</span>/<span class="Li">&quot;when&quot;</span>.</dd>
  <dt>Throwable</dt>
  <dd>A lightweight role for rolling your own exception classes.</dd>
  <dt>Error</dt>
  <dd>Exception object implementation with a
      <span class="Li">&quot;try&quot;</span> statement. Does not localize
      <span class="Li">$@</span>.</dd>
  <dt>Exception::Class::TryCatch</dt>
  <dd>Provides a <span class="Li">&quot;catch&quot;</span> statement, but
      properly calling <span class="Li">&quot;eval&quot;</span> is your
      responsibility.
    <p class="Pp">The <span class="Li">&quot;try&quot;</span> keyword pushes
        <span class="Li">$@</span> onto an error stack, avoiding some of the
        issues with <span class="Li">$@</span>, but you still need to localize
        to prevent clobbering.</p>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="LIGHTNING_TALK"><a class="permalink" href="#LIGHTNING_TALK">LIGHTNING
  TALK</a></h1>
I gave a lightning talk about this module, you can see the slides (Firefox
  only):
<p class="Pp">&lt;http://web.archive.org/web/20100628040134/http://nothingmuch.woobling.org/talks/takahashi.xul&gt;</p>
<p class="Pp">Or read the source:</p>
<p class="Pp">&lt;http://web.archive.org/web/20100305133605/http://nothingmuch.woobling.org/talks/yapc_asia_2009/try_tiny.yml&gt;</p>
</section>
<section class="Sh">
<h1 class="Sh" id="VERSION_CONTROL"><a class="permalink" href="#VERSION_CONTROL">VERSION
  CONTROL</a></h1>
&lt;http://github.com/doy/try-tiny/&gt;
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHORS"><a class="permalink" href="#AUTHORS">AUTHORS</a></h1>
<ul class="Bl-bullet">
  <li>Yuval Kogman &lt;nothingmuch@woobling.org&gt;</li>
  <li>Jesse Luehrs &lt;doy@tozt.net&gt;</li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT_AND_LICENSE"><a class="permalink" href="#COPYRIGHT_AND_LICENSE">COPYRIGHT
  AND LICENSE</a></h1>
This software is Copyright (c) 2014 by Yuval Kogman.
<p class="Pp">This is free software, licensed under:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  The MIT (X11) License
</pre>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2014-01-22</td>
    <td class="foot-os">perl v5.18.4</td>
  </tr>
</table>
</body>
</html>
