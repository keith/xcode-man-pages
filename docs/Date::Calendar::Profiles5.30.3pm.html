<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>Date::Calendar::Profiles(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Date::Calendar::Profiles(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Date::Calendar::Profiles(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
Date::Calendar::Profiles - Some sample profiles for Date::Calendar and
  Date::Calendar::Year
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<span class="Li"></span>
<pre>
  use Date::Calendar::Profiles qw( $Profiles );
  use Date::Calendar;

  $cal_US_AK = Date::Calendar-&gt;new( $Profiles-&gt;{'US-AK'} [,LANG[,WEEKEND]] );
  $cal_DE_BY = Date::Calendar-&gt;new( $Profiles-&gt;{'DE-BY'} [,LANG[,WEEKEND]] );

 or

  use Date::Calendar::Profiles qw( $Profiles );
  use Date::Calendar::Year;

  $year_2000_US_FL = Date::Calendar::Year-&gt;new( 2000, $Profiles-&gt;{'US-FL'} [,LANG[,WEEKEND]] );
  $year_2001_DE_NW = Date::Calendar::Year-&gt;new( 2001, $Profiles-&gt;{'DE-NW'} [,LANG[,WEEKEND]] );

 and also

  use Date::Calendar::Profiles
  qw(
      &amp;Previous_Friday
      &amp;Next_Monday
      &amp;Next_Monday_or_Tuesday
      &amp;Nearest_Workday
      &amp;Sunday_to_Monday
      &amp;Advent1
      &amp;Advent2
      &amp;Advent3
      &amp;Advent4
      &amp;Advent
  );
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="PREFACE"><a class="permalink" href="#PREFACE">PREFACE</a></h1>
This module provides some sample profiles (i.e., holiday schemes) for use with
  the <b>Date::Calendar</b>(3) and <b>Date::Calendar::Year</b>(3) module.
<p class="Pp">You are not required to use these, you can always roll your own
    (this is very easy). See the section &quot;HOW TO ROLL YOUR OWN&quot; below
    for more instructions on how to do this, and take the profiles from this
    module as examples.</p>
<p class="Pp">I intend not to make any fixes to any of the calendar profiles in
    this module anymore unless there are VERY compelling reasons to do so. These
    profiles are merely meant as examples.</p>
<p class="Pp">The suggested way of using these profiles is to copy them to your
    own code and then to modify them as needed. Otherwise many people could be
    negatively affected if I made any changes to a profile someone has been
    using for years.</p>
<p class="Pp">Any improvements are therefore left as an exercise to the inclined
    reader.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
The method &quot;<b>init()</b>&quot; in module <b>Date::Calendar::Year</b>(3) is
  responsible for parsing the calendar schemes contained here in the
  Date::Calendar::Profiles module.
<p class="Pp">This method offers a &quot;mini-language&quot; which allows to
    specify common date formulas, like for instance a simple fixed date (in
    various different formats, e.g. american or european), or things like
    &quot;the second Sunday of May&quot; (Mother's Day), or &quot;Easter Sunday
    minus 46 days&quot; (Ash Wednesday), to cite just a few.</p>
<p class="Pp">See the section &quot;DATE FORMULA SYNTAX&quot; below for more
    details.</p>
<p class="Pp">There are some more complicated formulas, however, which cannot be
    expressed in such simple terms.</p>
<p class="Pp">The rule that if a holiday falls on a weekend, it will be
    substituted by either the adjacent Friday or Monday (whichever lies closer),
    is an example of this.</p>
<p class="Pp">In order to be able to deal with such formulas, and in order to be
    as flexible as possible, the &quot;<b>init()</b>&quot; method offers the
    possibility of using callback functions to deal with such dates and
    formulas.</p>
<p class="Pp">See the section &quot;CALLBACK INTERFACE&quot; below for more
    details on this topic.</p>
<p class="Pp">In order to assist you with more common cases of odd formulas, the
    module Date::Calendar::Profiles exports the following utility subroutines
    (which are meant to be used as &quot;filters&quot; in callback functions of
    your own):</p>
<ul class="Bl-bullet">
  <li><span class="Li">&quot;($year,$month,$day[,ANYTHING]) =
      Previous_Friday($year,$month,$day[,ANYTHING]);&quot;</span>
    <p class="Pp">If the given date falls on a Saturday or Sunday, this function
        changes the date to the adjacent Friday before that, and returns this
        new date.</p>
    <p class="Pp">Otherwise the given date is returned unchanged.</p>
    <p class="Pp">The rest of the input parameters, if any, are simply copied to
        the output.</p>
  </li>
  <li><span class="Li">&quot;($year,$month,$day[,ANYTHING]) =
      Next_Monday($year,$month,$day[,ANYTHING]);&quot;</span>
    <p class="Pp">If the given date falls on a Saturday or Sunday, this function
        changes the date to the adjacent Monday after that, and returns this new
        date.</p>
    <p class="Pp">Otherwise the given date is returned unchanged.</p>
    <p class="Pp">The rest of the input parameters, if any, are simply copied to
        the output.</p>
  </li>
  <li><span class="Li">&quot;($year,$month,$day[,ANYTHING]) =
      Next_Monday_or_Tuesday($year,$month,$day[,ANYTHING]);&quot;</span>
    <p class="Pp">If the given date falls on a Saturday, the date of the next
        Monday (after that weekend) is returned.</p>
    <p class="Pp">If the given date falls on a Sunday, the date of the next
        Tuesday (after that weekend) is returned.</p>
    <p class="Pp">If the given date falls on a Monday, the date of the next
        Tuesday (the day after the Monday) is returned.</p>
    <p class="Pp">Otherwise the given date is returned unchanged.</p>
    <p class="Pp">The rest of the input parameters, if any, are simply copied to
        the output.</p>
    <p class="Pp">This function is used for the second of two adjacent holidays,
        where the first holiday obeys the &quot;Next Monday&quot; rule (see the
        description of the function immediately above).</p>
    <p class="Pp">Examples of this are Christmas and Boxing Day, among
      others.</p>
    <p class="Pp">When the first holiday falls on Friday, the second one falls
        on Saturday and is substituted by Monday.</p>
    <p class="Pp">When the first holiday falls on a Saturday, the second one
        falls on Sunday, so the first holiday is substituted by Monday and the
        second one by Tuesday.</p>
    <p class="Pp">When the first holiday falls on a Sunday, the second one falls
        on a Monday. Therefore the first holiday is substituted by Monday, and
        consequently the second holiday must be substituted by Tuesday.</p>
    <p class="Pp">Or, in other terms:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    Fri Sat =&gt; Fri Mon
    Sat Sun =&gt; Mon Tue
    Sun Mon =&gt; Mon Tue
    </pre>
    <p class="Pp">Note that there is no filter subroutine yet for the second of
        two adjacent holidays when the first holiday obeys the &quot;Nearest
        Workday&quot; rule (see the function described immediately below),
      i.e.,</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    Fri Sat =&gt; Fri Mon
    Sat Sun =&gt; Fri Mon
    Sun Mon =&gt; Mon Tue
    </pre>
    <p class="Pp">This is left as an excercise to the inclined reader.
        <span class="Li">&quot;:-)&quot;</span></p>
  </li>
  <li><span class="Li">&quot;($year,$month,$day[,ANYTHING]) =
      Nearest_Workday($year,$month,$day[,ANYTHING]);&quot;</span>
    <p class="Pp">If the given date falls on a Saturday, this function returns
        the date of the Friday on the day before.</p>
    <p class="Pp">If the given date falls on a Sunday, this function returns the
        date of the Monday on the day after.</p>
    <p class="Pp">Otherwise the given date is returned unchanged.</p>
    <p class="Pp">The rest of the input parameters, if any, are simply copied to
        the output.</p>
  </li>
  <li><span class="Li">&quot;($year,$month,$day[,ANYTHING]) =
      Sunday_to_Monday($year,$month,$day[,ANYTHING]);&quot;</span>
    <p class="Pp">If the given date falls on a Sunday, this function returns the
        date of the Monday on the day after.</p>
    <p class="Pp">Otherwise the given date is returned unchanged.</p>
    <p class="Pp">The rest of the input parameters, if any, are simply copied to
        the output.</p>
  </li>
</ul>
<p class="Pp">The typical use of these filter subroutines is in a
    &quot;return&quot; statement at the end of callback functions of your own,
    when you already have calculated the holiday in question and only need to
    adjust it according to the rule implemented by the filter subroutine in
    question.</p>
<p class="Pp">See also the implementation of the Date::Calendar::Profiles module
    for examples of how to use these functions.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DATE_FORMULA_SYNTAX"><a class="permalink" href="#DATE_FORMULA_SYNTAX">DATE
  FORMULA SYNTAX</a></h1>
<span class="Li"></span>
<pre>
 -  Fixed dates:

    &quot;Christmas&quot;  =&gt;  &quot;24.12&quot;,   # European format (day, month)
    &quot;Christmas&quot;  =&gt;  &quot;24.12.&quot;,

    &quot;Christmas&quot;  =&gt;  &quot;24Dec&quot;,
    &quot;Christmas&quot;  =&gt;  &quot;24.Dec&quot;,
    &quot;Christmas&quot;  =&gt;  &quot;24Dec.&quot;,
    &quot;Christmas&quot;  =&gt;  &quot;24.Dec.&quot;,

    &quot;Christmas&quot;  =&gt;  &quot;24-12&quot;,
    &quot;Christmas&quot;  =&gt;  &quot;24-12-&quot;,

    &quot;Christmas&quot;  =&gt;  &quot;24-Dec&quot;,
    &quot;Christmas&quot;  =&gt;  &quot;24-Dec-&quot;,

    &quot;Christmas&quot;  =&gt;  &quot;12/25&quot;,   # American format (month, day)
    &quot;Christmas&quot;  =&gt;  &quot;Dec25&quot;,
    &quot;Christmas&quot;  =&gt;  &quot;Dec/25&quot;,

 -  Dates relative to Easter Sunday:

    &quot;Ladies' Carnival&quot;  =&gt;  &quot;-52&quot;,
    &quot;Carnival Monday&quot;   =&gt;  &quot;-48&quot;,
    &quot;Mardi Gras&quot;        =&gt;  &quot;-47&quot;,
    &quot;Ash Wednesday&quot;     =&gt;  &quot;-46&quot;,
    &quot;Palm Sunday&quot;       =&gt;   &quot;-7&quot;,
    &quot;Maundy Thursday&quot;   =&gt;   &quot;-3&quot;,
    &quot;Good Friday&quot;       =&gt;   &quot;-2&quot;,
    &quot;Easter Sunday&quot;     =&gt;   &quot;+0&quot;,
    &quot;Easter Monday&quot;     =&gt;   &quot;+1&quot;,
    &quot;Ascension&quot;         =&gt;  &quot;+39&quot;,
    &quot;Whitsunday&quot;        =&gt;  &quot;+49&quot;,
    &quot;Whitmonday&quot;        =&gt;  &quot;+50&quot;,
    &quot;Corpus Christi&quot;    =&gt;  &quot;+60&quot;,

 -  The 1st, 2nd, 3rd, 4th or last day of week:

    &quot;Thanksgiving&quot;      =&gt;  &quot;4Thu11&quot;,
    &quot;Thanksgiving&quot;      =&gt;  &quot;4/Thu/Nov&quot;,
    &quot;Columbus Day&quot;      =&gt;  &quot;2/Mon/Oct&quot;,
    &quot;Columbus Day&quot;      =&gt;  &quot;2/Mon/10&quot;,
    &quot;Columbus Day&quot;      =&gt;  &quot;2/1/Oct&quot;,
    &quot;Columbus Day&quot;      =&gt;  &quot;2/1/10&quot;,
    &quot;Memorial Day&quot;      =&gt;  &quot;5/Mon/May&quot;, # LAST Monday of May

 -  Half holidays, commemorative days:

    &quot;Christmas&quot;         =&gt;  &quot;:24.12.&quot;, # only half a day off
    &quot;Valentine's Day&quot;   =&gt;  &quot;#Feb/14&quot;, # not an official holiday
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="CALLBACK_INTERFACE"><a class="permalink" href="#CALLBACK_INTERFACE">CALLBACK
  INTERFACE</a></h1>
The interface of the callback functions to use with the
  &quot;<b>init()</b>&quot; method of the <b>Date::Calendar::Year</b>(3) module
  is very simple:
<p class="Pp">The callback function receives two arguments when called, first
    the year number for which the holiday is to be calculated, and second the
    name (the &quot;label&quot;) of the holiday in question (which serves as key
    in the hash of a holiday scheme).</p>
<p class="Pp">This second parameter allows you to use the same callback function
    for different holidays, which might be more practical (than separate
    callback functions) if for instance you have a set of similar holidays to
    calculate, like for instance the four Sundays before Christmas
    (&quot;Advent&quot;).</p>
<p class="Pp">The callback function &quot;<b>Advent()</b>&quot; (exported by the
    Date::Calendar::Profiles module) exemplifies this technique.</p>
<p class="Pp">The callback function is expected to return a list
    &quot;<span class="Li">&quot;($year,$month,$day)&quot;</span>&quot; with the
    exact date of the holiday (the year number in the output must of course
    match the year number passed as parameter).</p>
<p class="Pp">A fatal error occurs if the returned list does not constitute a
    valid date, in the requested year.</p>
<p class="Pp">Optionally, the callback function may return a fourth value (after
    the date) containing a string, which may be either &quot;#&quot; or
    &quot;:&quot;.</p>
<p class="Pp">The string &quot;#&quot; signifies that the date in question is a
    purely commemorative date, i.e., that you don't get a day off from work on
    that day.</p>
<p class="Pp">The string &quot;:&quot; means that the date in question is a
    &quot;half&quot; holiday, i.e., a day on which you get half a day off from
    work.</p>
<p class="Pp">In case the holiday in question was not observed or did not exist
    in the requested year, the callback function may also return an empty list.
    This will cause the &quot;<b>init()</b>&quot; method to simply drop this
    holiday for that year.</p>
<p class="Pp">The module Date::Calendar::Profiles exports the sample callback
    functions &quot;<b>Advent1()</b>&quot;, &quot;<b>Advent2()</b>&quot;,
    &quot;<b>Advent3()</b>&quot;, &quot;<b>Advent4()</b>&quot; and
    &quot;<b>Advent()</b>&quot;, which might assist you in rolling your own
    profiles.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="HOW_TO_ROLL_YOUR_OWN"><a class="permalink" href="#HOW_TO_ROLL_YOUR_OWN">HOW
  TO ROLL YOUR OWN</a></h1>
Every calendar profile (holiday scheme) is a hash.
<p class="Pp">The name of the holiday (like &quot;Christmas&quot;, for instance)
    serves as the key in this hash and must therefore be unique (unless you want
    to override a default which was set previously, but see below for more on
    this).</p>
<p class="Pp">The value for each key is either a string, which specifies a
    simple date formula, or the reference of a callback function.</p>
<p class="Pp">See the section &quot;CALLBACK INTERFACE&quot; above for a
    description of the interface (in and out) of these callback functions.</p>
<p class="Pp">See the section &quot;DATE FORMULA SYNTAX&quot; above and the
    description of the &quot;<b>init()</b>&quot; method in
    <b>Date::Calendar::Year</b>(3) for the exact syntax of date formula
  strings.</p>
<p class="Pp"><b>BEWARE</b> that if keys are not unique in the source code,
    later entries will overwrite previous ones! I.e.,</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    ...
    &quot;My special holiday&quot; =&gt; &quot;01-11&quot;,
    &quot;My special holiday&quot; =&gt; &quot;02-11&quot;,
    ...
</pre>
<p class="Pp">will <b>NOT</b> set two holidays of the same name, one on November
    first, the other on November second, but only one, on November second!</p>
<p class="Pp">Therefore, in order to use sets of defaults and to be able to
    override some of them, you must <b>FIRST</b> include any hash containing the
    default definitions, and <b>THEN</b> write down your own definitions (see
    also the Date::Calendar::Profiles module for examples of this!), like
  this:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    $defaults =
    {
        &quot;Holiday #1&quot; =&gt; &quot;01-01&quot;,
        &quot;Holiday #2&quot; =&gt; &quot;02-02&quot;,
        &quot;Holiday #3&quot; =&gt; &quot;03-03&quot;
    };

    $variant1 =
    {
        %$defaults,
        &quot;Holiday #2&quot; =&gt; &quot;09-02&quot;,
        &quot;Holiday #4&quot; =&gt; &quot;04-04&quot;
    };
</pre>
<p class="Pp">This is because of the way hashes work in Perl.</p>
<p class="Pp">Now let's suppose that you want to write a profile containing all
    your relatives' and friends' birthdays or anniversaries.</p>
<p class="Pp">Simply go ahead and list them in your program, in any order you
    like, as follows (for example):</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  $Birthdays =
  {
      &quot;Spouse 1971&quot;             =&gt;  &quot;30.12.&quot;,
      &quot;Wedding Day 1992&quot;        =&gt;  &quot;01.09.&quot;,
      &quot;Valentine's Day&quot;         =&gt;  &quot;14.02.&quot;,
      &quot;Son Richard 1996&quot;        =&gt;  &quot;11.05.&quot;,
      &quot;Daughter Irene 1994&quot;     =&gt;  &quot;17.01.&quot;,
      &quot;Mom 1939&quot;                =&gt;  &quot;19.08.&quot;,
      &quot;Dad 1937&quot;                =&gt;  &quot;23.04.&quot;,
      &quot;Brother Timothy 1969&quot;    =&gt;  &quot;24.04.&quot;,
      &quot;Sister Catherine 1973&quot;   =&gt;  &quot;21.10.&quot;,
      &quot;Cousin Paul 1970&quot;        =&gt;  &quot;16.10.&quot;,
      &quot;Aunt Marjorie 1944&quot;      =&gt;  &quot;09.06.&quot;,
      &quot;Uncle George 1941&quot;       =&gt;  &quot;02.08.&quot;,
      &quot;Friend Alexander 1968&quot;   =&gt;  &quot;12.06.&quot;,
  };
</pre>
<p class="Pp">The year numbers after the names are not really necessary, but
    they allow us to display the person's current age. If this year number is
    omitted, we simply don't display the age.</p>
<p class="Pp">Now in order to query this birthday database, we can use the
    following little program:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  #!perl -w

  use strict;
  no strict &quot;vars&quot;;
  use Date::Calc qw(:all);
  use Date::Calendar;

  $Birthdays =
  {
      ... # (see above)
  };

  @today = Today();
  $calendar = Date::Calendar-&gt;new( $Birthdays );
  $calendar-&gt;year( $today[0] );

  foreach $key (@ARGV)
  {
      if (@list = $calendar-&gt;search( $key ))
      {
          foreach $date (@list)
          {
              @labels = $calendar-&gt;labels( $date );
              $dow = shift(@labels);
              # More than one person might have birthday on the same date:
              $name = $key;
              foreach $person (@labels)
              {
                  if (index(lc($person),lc($key)) &gt;= 0)
                  {
                      $name = $person;
                      last;
                  }
              }
              $delta = Delta_Days(@today, $date-&gt;date());
              $age = '';
              if ($name =~ s!\s*(\d+)\s*$!!)
              {
                  $age = $today[0] - $1;
                  $age-- if ($delta &gt; 0);
                  $age = sprintf(&quot; (%2d years old)&quot;, $age);
              }
              printf
              (
                  &quot;%-20.20s: %+5d days =&gt; %3.3s %2d-%3.3s-%4d%s\n&quot;,
                  $name,
                  $delta,
                  $dow,
                  $date-&gt;day(),
                  Month_to_Text($date-&gt;month()),
                  $date-&gt;year(),
                  $age
              );
          }
      }
      else { print &quot;No entry found in birthday list for '$key'!\n&quot; }
  }

  __END__
</pre>
<p class="Pp">Let us save this program as, say, &quot;birthday.pl&quot;.</p>
<p class="Pp">Then we can query this birthday database by providing search
    strings on the command line, like this (note that this is a
    (case-insensitive) substring search, <b>NOT</b> a regular expression
    match!):</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  &gt; date
  Wed Oct  3 18:05:45 CEST 2001

  &gt; perl birthday.pl wed spo
  Wedding Day         :   -32 days =&gt; Sat  1-Sep-2001 ( 9 years old)
  Spouse              :   +88 days =&gt; Sun 30-Dec-2001 (29 years old)

  &gt; perl birthday.pl son daug
  Son Richard         :  -145 days =&gt; Fri 11-May-2001 ( 5 years old)
  Daughter Irene      :  -259 days =&gt; Wed 17-Jan-2001 ( 7 years old)

  &gt; perl birthday.pl broth sist
  Brother Timothy     :  -162 days =&gt; Tue 24-Apr-2001 (32 years old)
  Sister Catherine    :   +18 days =&gt; Sun 21-Oct-2001 (27 years old)

  &gt; perl birthday.pl mom dad
  Mom                 :   -45 days =&gt; Sun 19-Aug-2001 (62 years old)
  Dad                 :  -163 days =&gt; Mon 23-Apr-2001 (64 years old)

  &gt; perl birthday.pl uncl aunt
  Uncle George        :   -62 days =&gt; Thu  2-Aug-2001 (60 years old)
  Aunt Marjorie       :  -116 days =&gt; Sat  9-Jun-2001 (57 years old)

  &gt; perl birthday.pl alex
  Friend Alexander    :  -113 days =&gt; Tue 12-Jun-2001 (33 years old)
</pre>
<p class="Pp">In order to get the whole list, we can supply a substring which is
    contained in every name, which happens to be a blank
    (<span class="Li">&quot;&#x00A0;&quot;</span>):</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  &gt; perl birthday.pl ' '
  Daughter Irene      :  -259 days =&gt; Wed 17-Jan-2001 ( 7 years old)
  Valentine's Day     :  -231 days =&gt; Wed 14-Feb-2001
  Dad                 :  -163 days =&gt; Mon 23-Apr-2001 (64 years old)
  Brother Timothy     :  -162 days =&gt; Tue 24-Apr-2001 (32 years old)
  Son Richard         :  -145 days =&gt; Fri 11-May-2001 ( 5 years old)
  Aunt Marjorie       :  -116 days =&gt; Sat  9-Jun-2001 (57 years old)
  Friend Alexander    :  -113 days =&gt; Tue 12-Jun-2001 (33 years old)
  Uncle George        :   -62 days =&gt; Thu  2-Aug-2001 (60 years old)
  Mom                 :   -45 days =&gt; Sun 19-Aug-2001 (62 years old)
  Wedding Day         :   -32 days =&gt; Sat  1-Sep-2001 ( 9 years old)
  Cousin Paul         :   +13 days =&gt; Tue 16-Oct-2001 (30 years old)
  Sister Catherine    :   +18 days =&gt; Sun 21-Oct-2001 (27 years old)
  Spouse              :   +88 days =&gt; Sun 30-Dec-2001 (29 years old)
</pre>
<p class="Pp">By the way, a similar program is included in the
    &quot;examples&quot; subdirectory of the Date::Calc distribution, called
    &quot;anniversaries.pl&quot;.</p>
<p class="Pp">See also the file &quot;EXAMPLES.txt&quot; in the distribution's
    main directory for a short description of that little script.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<b>Date::Calendar</b>(3), <b>Date::Calendar::Year</b>(3),
  <b>Date::Calc::Object</b>(3), <b>Date::Calc</b>(3),
  <b>Date::Calc::Util</b>(3).
</section>
<section class="Sh">
<h1 class="Sh" id="LIMITATIONS"><a class="permalink" href="#LIMITATIONS">LIMITATIONS</a></h1>
The calendar profiles included in this module usually do not take historical
  irregularities into account (even though some do in order to show how this can
  be done), they only provide means for calculating <b>regularly</b> recurring
  events (<b>the profiles should therefore not be</b> <b>relied upon for
  historical faithfulness</b>).
</section>
<section class="Sh">
<h1 class="Sh" id="KNOWN_BUGS"><a class="permalink" href="#KNOWN_BUGS">KNOWN
  BUGS</a></h1>
The australian calendar profiles are known to contain wrong dates. This is due
  to the fact that Australia decrees its holidays individually for each year,
  difficulting the calculation of the holidays by way of a formula. An effort to
  compare (and to correct) the current implementation with official documents
  (web pages) by the Australian authorities is under way. This hasn't been
  finished yet because it is very time-consuming.
</section>
<section class="Sh">
<h1 class="Sh" id="VERSION"><a class="permalink" href="#VERSION">VERSION</a></h1>
This man page documents &quot;Date::Calendar::Profiles&quot; version 6.4.
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<span class="Li"></span>
<pre>
  Steffen Beyer
  mailto:STBEY@cpan.org
  http://www.engelschall.com/u/sb/download/
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT"><a class="permalink" href="#COPYRIGHT">COPYRIGHT</a></h1>
Copyright (c) 2000 - 2015 by Steffen Beyer. All rights reserved.
</section>
<section class="Sh">
<h1 class="Sh" id="LICENSE"><a class="permalink" href="#LICENSE">LICENSE</a></h1>
This package is free software; you can use, modify and redistribute it under the
  same terms as Perl itself, i.e., at your option, under the terms either of the
  &quot;Artistic License&quot; or the &quot;GNU General Public License&quot;.
<p class="Pp">The C library at the core of the module &quot;Date::Calc::XS&quot;
    can, at your discretion, also be used, modified and redistributed under the
    terms of the &quot;GNU Library General Public License&quot;.</p>
<p class="Pp">Please refer to the files &quot;Artistic.txt&quot;,
    &quot;GNU_GPL.txt&quot; and &quot;GNU_LGPL.txt&quot; in the
    &quot;license&quot; subdirectory of this distribution for any details!</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DISCLAIMER"><a class="permalink" href="#DISCLAIMER">DISCLAIMER</a></h1>
This package is distributed in the hope that it will be useful, but WITHOUT ANY
  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
  A PARTICULAR PURPOSE.
<p class="Pp">See the &quot;GNU General Public License&quot; for more
  details.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2015-03-07</td>
    <td class="foot-os">perl v5.30.2</td>
  </tr>
</table>
</body>
</html>
