<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.10 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>Class::Accessor(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Class::Accessor(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Class::Accessor(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<span class="Li"></span>
<pre>
  Class::Accessor - Automated accessor generation
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<span class="Li"></span>
<pre>
  package Foo;
  use base qw(Class::Accessor);
  Foo-&gt;follow_best_practice;
  Foo-&gt;mk_accessors(qw(name role salary));

  # or if you prefer a Moose-like interface...

  package Foo;
  use Class::Accessor &quot;antlers&quot;;
  has name =&gt; ( is =&gt; &quot;rw&quot;, isa =&gt; &quot;Str&quot; );
  has role =&gt; ( is =&gt; &quot;rw&quot;, isa =&gt; &quot;Str&quot; );
  has salary =&gt; ( is =&gt; &quot;rw&quot;, isa =&gt; &quot;Num&quot; );

  # Meanwhile, in a nearby piece of code!
  # Class::Accessor provides new().
  my $mp = Foo-&gt;new({ name =&gt; &quot;Marty&quot;, role =&gt; &quot;JAPH&quot; });

  my $job = $mp-&gt;role;  # gets $mp-&gt;{role}
  $mp-&gt;salary(400000);  # sets $mp-&gt;{salary} = 400000 # I wish

  # like my @info = @{$mp}{qw(name role)}
  my @info = $mp-&gt;get(qw(name role));

  # $mp-&gt;{salary} = 400000
  $mp-&gt;set('salary', 400000);
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
This module automagically generates accessors/mutators for your class.
<p class="Pp">Most of the time, writing accessors is an exercise in cutting and
    pasting. You usually wind up with a series of methods like this:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    sub name {
        my $self = shift;
        if(@_) {
            $self-&gt;{name} = $_[0];
        }
        return $self-&gt;{name};
    }

    sub salary {
        my $self = shift;
        if(@_) {
            $self-&gt;{salary} = $_[0];
        }
        return $self-&gt;{salary};
    }

  # etc...
</pre>
<p class="Pp">One for each piece of data in your object. While some will be
    unique, doing value checks and special storage tricks, most will simply be
    exercises in repetition. Not only is it Bad Style to have a bunch of
    repetitious code, but it's also simply not lazy, which is the real
  tragedy.</p>
<p class="Pp">If you make your module a subclass of Class::Accessor and declare
    your accessor fields with <b>mk_accessors()</b> then you'll find yourself
    with a set of automatically generated accessors which can even be
    customized!</p>
<p class="Pp">The basic set up is very simple:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    package Foo;
    use base qw(Class::Accessor);
    Foo-&gt;mk_accessors( qw(far bar car) );
</pre>
<p class="Pp">Done. Foo now has simple <b>far()</b>, <b>bar()</b> and
    <b>car()</b> accessors defined.</p>
<p class="Pp">Alternatively, if you want to follow Damian's <i>best practice</i>
    guidelines you can use:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    package Foo;
    use base qw(Class::Accessor);
    Foo-&gt;follow_best_practice;
    Foo-&gt;mk_accessors( qw(far bar car) );
</pre>
<p class="Pp"><b>Note:</b> you must call
    <span class="Li">&quot;follow_best_practice&quot;</span> before calling
    <span class="Li">&quot;mk_accessors&quot;</span>.</p>
<section class="Ss">
<h2 class="Ss" id="Moose-like"><a class="permalink" href="#Moose-like">Moose-like</a></h2>
By popular demand we now have a simple Moose-like interface. You can now do:
<p class="Pp"><span class="Li"></span></p>
<pre>
    package Foo;
    use Class::Accessor &quot;antlers&quot;;
    has far =&gt; ( is =&gt; &quot;rw&quot; );
    has bar =&gt; ( is =&gt; &quot;rw&quot; );
    has car =&gt; ( is =&gt; &quot;rw&quot; );
</pre>
<p class="Pp">Currently only the <span class="Li">&quot;is&quot;</span>
    attribute is supported.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="CONSTRUCTOR"><a class="permalink" href="#CONSTRUCTOR">CONSTRUCTOR</a></h1>
Class::Accessor provides a basic constructor,
  <span class="Li">&quot;new&quot;</span>. It generates a hash-based object and
  can be called as either a class method or an object method.
<section class="Ss">
<h2 class="Ss" id="new"><a class="permalink" href="#new">new</a></h2>
<span class="Li"></span>
<pre>
    my $obj = Foo-&gt;new;
    my $obj = $other_obj-&gt;new;

    my $obj = Foo-&gt;new(\%fields);
    my $obj = $other_obj-&gt;new(\%fields);
</pre>
<p class="Pp">It takes an optional <span class="Li">%fields</span> hash which is
    used to initialize the object (handy if you use read-only accessors). The
    fields of the hash correspond to the names of your accessors, so...</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    package Foo;
    use base qw(Class::Accessor);
    Foo-&gt;mk_accessors('foo');

    my $obj = Foo-&gt;new({ foo =&gt; 42 });
    print $obj-&gt;foo;    # 42
</pre>
<p class="Pp">however <span class="Li">%fields</span> can contain anything,
    <b>new()</b> will shove them all into your object.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="MAKING_ACCESSORS"><a class="permalink" href="#MAKING_ACCESSORS">MAKING
  ACCESSORS</a></h1>
<section class="Ss">
<h2 class="Ss" id="follow_best_practice"><a class="permalink" href="#follow_best_practice">follow_best_practice</a></h2>
In Damian's Perl Best Practices book he recommends separate get and set methods
  with the prefix set_ and get_ to make it explicit what you intend to do. If
  you want to create those accessor methods instead of the default ones, call:
<p class="Pp"><span class="Li"></span></p>
<pre>
    __PACKAGE__-&gt;follow_best_practice
</pre>
<p class="Pp"><b>before</b> you call any of the accessor-making methods.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="accessor_name_for_/_mutator_name_for"><a class="permalink" href="#accessor_name_for_/_mutator_name_for">accessor_name_for
  / mutator_name_for</a></h2>
You may have your own crazy ideas for the names of the accessors, so you can
  make those happen by overriding
  <span class="Li">&quot;accessor_name_for&quot;</span> and
  <span class="Li">&quot;mutator_name_for&quot;</span> in your subclass. (I
  copied that idea from Class::DBI.)
</section>
<section class="Ss">
<h2 class="Ss" id="mk_accessors"><a class="permalink" href="#mk_accessors">mk_accessors</a></h2>
<span class="Li"></span>
<pre>
    __PACKAGE__-&gt;mk_accessors(@fields);
</pre>
<p class="Pp">This creates accessor/mutator methods for each named field given
    in <span class="Li">@fields</span>. Foreach field in
    <span class="Li">@fields</span> it will generate two accessors. One called
    &quot;<b>field()</b>&quot; and the other called
    &quot;<b>_field_accessor()</b>&quot;. For example:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    # Generates foo(), _foo_accessor(), bar() and _bar_accessor().
    __PACKAGE__-&gt;mk_accessors(qw(foo bar));
</pre>
<p class="Pp">See &quot;Overriding autogenerated accessors&quot; in CAVEATS AND
    TRICKS for details.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="mk_ro_accessors"><a class="permalink" href="#mk_ro_accessors">mk_ro_accessors</a></h2>
<span class="Li"></span>
<pre>
  __PACKAGE__-&gt;mk_ro_accessors(@read_only_fields);
</pre>
<p class="Pp">Same as <b>mk_accessors()</b> except it will generate read-only
    accessors (ie. true accessors). If you attempt to set a value with these
    accessors it will throw an exception. It only uses <b>get()</b> and not
    <b>set()</b>.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    package Foo;
    use base qw(Class::Accessor);
    Foo-&gt;mk_ro_accessors(qw(foo bar));

    # Let's assume we have an object $foo of class Foo...
    print $foo-&gt;foo;  # ok, prints whatever the value of $foo-&gt;{foo} is
    $foo-&gt;foo(42);    # BOOM!  Naughty you.
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="mk_wo_accessors"><a class="permalink" href="#mk_wo_accessors">mk_wo_accessors</a></h2>
<span class="Li"></span>
<pre>
  __PACKAGE__-&gt;mk_wo_accessors(@write_only_fields);
</pre>
<p class="Pp">Same as <b>mk_accessors()</b> except it will generate write-only
    accessors (ie. mutators). If you attempt to read a value with these
    accessors it will throw an exception. It only uses <b>set()</b> and not
    <b>get()</b>.</p>
<p class="Pp"><b>NOTE</b> I'm not entirely sure why this is useful, but I'm sure
    someone will need it. If you've found a use, let me know. Right now it's
    here for orthogonality and because it's easy to implement.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    package Foo;
    use base qw(Class::Accessor);
    Foo-&gt;mk_wo_accessors(qw(foo bar));

    # Let's assume we have an object $foo of class Foo...
    $foo-&gt;foo(42);      # OK.  Sets $self-&gt;{foo} = 42
    print $foo-&gt;foo;    # BOOM!  Can't read from this accessor.
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="Moose!"><a class="permalink" href="#Moose!">Moose!</a></h1>
If you prefer a Moose-like interface to create accessors, you can use
  <span class="Li">&quot;has&quot;</span> by importing this module like this:
<p class="Pp"><span class="Li"></span></p>
<pre>
  use Class::Accessor &quot;antlers&quot;;
</pre>
<p class="Pp">or</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  use Class::Accessor &quot;moose-like&quot;;
</pre>
<p class="Pp">Then you can declare accessors like this:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  has alpha =&gt; ( is =&gt; &quot;rw&quot;, isa =&gt; &quot;Str&quot; );
  has beta  =&gt; ( is =&gt; &quot;ro&quot;, isa =&gt; &quot;Str&quot; );
  has gamma =&gt; ( is =&gt; &quot;wo&quot;, isa =&gt; &quot;Str&quot; );
</pre>
<p class="Pp">Currently only the <span class="Li">&quot;is&quot;</span>
    attribute is supported. And our <span class="Li">&quot;is&quot;</span> also
    supports the &quot;wo&quot; value to make a write-only accessor.</p>
<p class="Pp">If you are using the Moose-like interface then you should use the
    <span class="Li">&quot;extends&quot;</span> rather than tweaking your
    <span class="Li">@ISA</span> directly. Basically, replace</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  @ISA = qw/Foo Bar/;
</pre>
<p class="Pp">with</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  extends(qw/Foo Bar/);
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DETAILS"><a class="permalink" href="#DETAILS">DETAILS</a></h1>
An accessor generated by Class::Accessor looks something like this:
<p class="Pp"><span class="Li"></span></p>
<pre>
    # Your foo may vary.
    sub foo {
        my($self) = shift;
        if(@_) {    # set
            return $self-&gt;set('foo', @_);
        }
        else {
            return $self-&gt;get('foo');
        }
    }
</pre>
<p class="Pp">Very simple. All it does is determine if you're wanting to set a
    value or get a value and calls the appropriate method. Class::Accessor
    provides default <b>get()</b> and <b>set()</b> methods which your class can
    override. They're detailed later.</p>
<section class="Ss">
<h2 class="Ss" id="Modifying_the_behavior_of_the_accessor"><a class="permalink" href="#Modifying_the_behavior_of_the_accessor">Modifying
  the behavior of the accessor</a></h2>
Rather than actually modifying the accessor itself, it is much more sensible to
  simply override the two key methods which the accessor calls. Namely
  <b>set()</b> and <b>get()</b>.
<p class="Pp">If you -really- want to, you can override
  <b>make_accessor()</b>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="set"><a class="permalink" href="#set">set</a></h2>
<span class="Li"></span>
<pre>
    $obj-&gt;set($key, $value);
    $obj-&gt;set($key, @values);
</pre>
<p class="Pp"><b>set()</b> defines how generally one stores data in the
  object.</p>
<p class="Pp">override this method to change how data is stored by your
    accessors.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="get"><a class="permalink" href="#get">get</a></h2>
<span class="Li"></span>
<pre>
    $value  = $obj-&gt;get($key);
    @values = $obj-&gt;get(@keys);
</pre>
<p class="Pp"><b>get()</b> defines how data is retrieved from your objects.</p>
<p class="Pp">override this method to change how it is retrieved.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="make_accessor"><a class="permalink" href="#make_accessor">make_accessor</a></h2>
<span class="Li"></span>
<pre>
    $accessor = __PACKAGE__-&gt;make_accessor($field);
</pre>
<p class="Pp">Generates a subroutine reference which acts as an accessor for the
    given <span class="Li">$field</span>. It calls <b>get()</b> and
    <b>set()</b>.</p>
<p class="Pp">If you wish to change the behavior of your accessors, try
    overriding <b>get()</b> and <b>set()</b> before you start mucking with
    <b>make_accessor()</b>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="make_ro_accessor"><a class="permalink" href="#make_ro_accessor">make_ro_accessor</a></h2>
<span class="Li"></span>
<pre>
    $read_only_accessor = __PACKAGE__-&gt;make_ro_accessor($field);
</pre>
<p class="Pp">Generates a subroutine reference which acts as a read-only
    accessor for the given <span class="Li">$field</span>. It only calls
    <b>get()</b>.</p>
<p class="Pp">Override <b>get()</b> to change the behavior of your
  accessors.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="make_wo_accessor"><a class="permalink" href="#make_wo_accessor">make_wo_accessor</a></h2>
<span class="Li"></span>
<pre>
    $write_only_accessor = __PACKAGE__-&gt;make_wo_accessor($field);
</pre>
<p class="Pp">Generates a subroutine reference which acts as a write-only
    accessor (mutator) for the given <span class="Li">$field</span>. It only
    calls <b>set()</b>.</p>
<p class="Pp">Override <b>set()</b> to change the behavior of your
  accessors.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="EXCEPTIONS"><a class="permalink" href="#EXCEPTIONS">EXCEPTIONS</a></h1>
If something goes wrong Class::Accessor will warn or die by calling Carp::carp
  or Carp::croak. If you don't like this you can override <b>_carp()</b> and
  <b>_croak()</b> in your subclass and do whatever else you want.
</section>
<section class="Sh">
<h1 class="Sh" id="EFFICIENCY"><a class="permalink" href="#EFFICIENCY">EFFICIENCY</a></h1>
Class::Accessor does not employ an autoloader, thus it is much faster than you'd
  think. Its generated methods incur no special penalty over ones you'd write
  yourself.
<p class="Pp"><span class="Li"></span></p>
<pre>
  accessors:
              Rate  Basic   Fast Faster Direct
  Basic   367589/s     --   -51%   -55%   -89%
  Fast    747964/s   103%     --    -9%   -77%
  Faster  819199/s   123%    10%     --   -75%
  Direct 3245887/s   783%   334%   296%     --

  mutators:
              Rate    Acc   Fast Faster Direct
  Acc     265564/s     --   -54%   -63%   -91%
  Fast    573439/s   116%     --   -21%   -80%
  Faster  724710/s   173%    26%     --   -75%
  Direct 2860979/s   977%   399%   295%     --
</pre>
<p class="Pp">Class::Accessor::Fast is faster than methods written by an average
    programmer (where &quot;average&quot; is based on Schwern's example
  code).</p>
<p class="Pp">Class::Accessor is slower than average, but more flexible.</p>
<p class="Pp">Class::Accessor::Faster is even faster than Class::Accessor::Fast.
    It uses an array internally, not a hash. This could be a good or bad feature
    depending on your point of view.</p>
<p class="Pp">Direct hash access is, of course, much faster than all of these,
    but it provides no encapsulation.</p>
<p class="Pp">Of course, it's not as simple as saying &quot;Class::Accessor is
    slower than average&quot;. These are benchmarks for a simple accessor. If
    your accessors do any sort of complicated work (such as talking to a
    database or writing to a file) the time spent doing that work will quickly
    swamp the time spend just calling the accessor. In that case,
    Class::Accessor and the ones you write will be roughly the same speed.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="EXAMPLES"><a class="permalink" href="#EXAMPLES">EXAMPLES</a></h1>
Here's an example of generating an accessor for every public field of your
  class.
<p class="Pp"><span class="Li"></span></p>
<pre>
    package Altoids;

    use base qw(Class::Accessor Class::Fields);
    use fields qw(curiously strong mints);
    Altoids-&gt;mk_accessors( Altoids-&gt;show_fields('Public') );

    sub new {
        my $proto = shift;
        my $class = ref $proto || $proto;
        return fields::new($class);
    }

    my Altoids $tin = Altoids-&gt;new;

    $tin-&gt;curiously('Curiouser and curiouser');
    print $tin-&gt;{curiously};    # prints 'Curiouser and curiouser'


    # Subclassing works, too.
    package Mint::Snuff;
    use base qw(Altoids);

    my Mint::Snuff $pouch = Mint::Snuff-&gt;new;
    $pouch-&gt;strong('Blow your head off!');
    print $pouch-&gt;{strong};     # prints 'Blow your head off!'
</pre>
<p class="Pp">Here's a simple example of altering the behavior of your
    accessors.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    package Foo;
    use base qw(Class::Accessor);
    Foo-&gt;mk_accessors(qw(this that up down));

    sub get {
        my $self = shift;

        # Note every time someone gets some data.
        print STDERR &quot;Getting @_\n&quot;;

        $self-&gt;SUPER::get(@_);
    }

    sub set {
        my ($self, $key) = splice(@_, 0, 2);

        # Note every time someone sets some data.
        print STDERR &quot;Setting $key to @_\n&quot;;

        $self-&gt;SUPER::set($key, @_);
    }
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="CAVEATS_AND_TRICKS"><a class="permalink" href="#CAVEATS_AND_TRICKS">CAVEATS
  AND TRICKS</a></h1>
Class::Accessor has to do some internal wackiness to get its job done quickly
  and efficiently. Because of this, there's a few tricks and traps one must know
  about.
<p class="Pp">Hey, nothing's perfect.</p>
<section class="Ss">
<h2 class="Ss" id="Don't_make_a_field_called__s-1DESTROY_s0"><a class="permalink" href="#Don't_make_a_field_called__s-1DESTROY_s0">Don't
  make a field called DESTROY</a></h2>
This is bad. Since DESTROY is a magical method it would be bad for us to define
  an accessor using that name. Class::Accessor will carp if you try to use it
  with a field named &quot;DESTROY&quot;.
</section>
<section class="Ss">
<h2 class="Ss" id="Overriding_autogenerated_accessors"><a class="permalink" href="#Overriding_autogenerated_accessors">Overriding
  autogenerated accessors</a></h2>
You may want to override the autogenerated accessor with your own, yet have your
  custom accessor call the default one. For instance, maybe you want to have an
  accessor which checks its input. Normally, one would expect this to work:
<p class="Pp"><span class="Li"></span></p>
<pre>
    package Foo;
    use base qw(Class::Accessor);
    Foo-&gt;mk_accessors(qw(email this that whatever));

    # Only accept addresses which look valid.
    sub email {
        my($self) = shift;
        my($email) = @_;

        if( @_ ) {  # Setting
            require Email::Valid;
            unless( Email::Valid-&gt;address($email) ) {
                carp(&quot;$email doesn't look like a valid address.&quot;);
                return;
            }
        }

        return $self-&gt;SUPER::email(@_);
    }
</pre>
<p class="Pp">There's a subtle problem in the last example, and it's in this
    line:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    return $self-&gt;SUPER::email(@_);
</pre>
<p class="Pp">If we look at how Foo was defined, it called <b>mk_accessors()</b>
    which stuck <b>email()</b> right into Foo's namespace. There *is* no
    <b>SUPER::email()</b> to delegate to! Two ways around this... first is to
    make a &quot;pure&quot; base class for Foo. This pure class will generate
    the accessors and provide the necessary super class for Foo to use:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    package Pure::Organic::Foo;
    use base qw(Class::Accessor);
    Pure::Organic::Foo-&gt;mk_accessors(qw(email this that whatever));

    package Foo;
    use base qw(Pure::Organic::Foo);
</pre>
<p class="Pp">And now <b>Foo::email()</b> can override the generated
    <b>Pure::Organic::Foo::email()</b> and use it as <b>SUPER::email()</b>.</p>
<p class="Pp">This is probably the most obvious solution to everyone but me.
    Instead, what first made sense to me was for <b>mk_accessors()</b> to define
    an alias of <b>email()</b>, <b>_email_accessor()</b>. Using this solution,
    <b>Foo::email()</b> would be written with:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    return $self-&gt;_email_accessor(@_);
</pre>
<p class="Pp">instead of the expected <b>SUPER::email()</b>.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHORS"><a class="permalink" href="#AUTHORS">AUTHORS</a></h1>
Copyright 2017 Marty Pauley &lt;marty+perl@martian.org&gt;
<p class="Pp">This program is free software; you can redistribute it and/or
    modify it under the same terms as Perl itself. That means either (a) the GNU
    General Public License or (b) the Artistic License.</p>
<section class="Ss">
<h2 class="Ss" id="_s-1ORIGINAL_AUTHOR_s0"><a class="permalink" href="#_s-1ORIGINAL_AUTHOR_s0">ORIGINAL
  AUTHOR</a></h2>
Michael G Schwern &lt;schwern@pobox.com&gt;
</section>
<section class="Ss">
<h2 class="Ss" id="_s-1THANKS_s0"><a class="permalink" href="#_s-1THANKS_s0">THANKS</a></h2>
Liz and RUZ for performance tweaks.
<p class="Pp">Tels, for his big feature request/bug report.</p>
<p class="Pp">Various presenters at YAPC::Asia 2009 for criticising the
    non-Moose interface.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
See Class::Accessor::Fast and Class::Accessor::Faster if speed is more important
  than flexibility.
<p class="Pp">These are some modules which do similar things in different ways
    Class::Struct, Class::Methodmaker, Class::Generate, Class::Class,
    Class::Contract, Moose, Mouse</p>
<p class="Pp">See Class::DBI for an example of this module in use.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2017-10-22</td>
    <td class="foot-os">perl v5.28.2</td>
  </tr>
</table>
</body>
</html>
