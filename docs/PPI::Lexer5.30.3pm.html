<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    .Nd, .Bf, .Op { display: inline; }
    .Pa, .Ad { font-style: italic; }
    .Ms { font-weight: bold; }
    .Bl-diag > dt { font-weight: bold; }
    code.Nm, .Fl, .Cm, .Ic, code.In, .Fd, .Fn, .Cd { font-weight: bold;
      font-family: inherit; }
  </style>
  <title>PPI::Lexer(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">PPI::Lexer(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">PPI::Lexer(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">PPI::Lexer - The PPI Lexer</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>  use PPI;
  
  # Create a new Lexer
  my $Lexer = PPI::Lexer-&gt;new;
  
  # Build a PPI::Document object from a Token stream
  my $Tokenizer = PPI::Tokenizer-&gt;load('My/Module.pm');
  my $Document = $Lexer-&gt;lex_tokenizer($Tokenizer);
  
  # Build a PPI::Document object for some raw source
  my $source = &quot;print 'Hello World!'; kill(Humans-&gt;all);&quot;;
  $Document = $Lexer-&gt;lex_source($source);
  
  # Build a PPI::Document object for a particular file name
  $Document = $Lexer-&gt;lex_file('My/Module.pm');
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">The is the PPI Lexer. In the larger scheme of things, its job is
    to take token streams, in a variety of forms, and &quot;lex&quot; them into
    nested structures.</p>
<p class="Pp">Pretty much everything in this module happens behind the scenes at
    this point. In fact, at the moment you don't really need to instantiate the
    lexer at all, the three main methods will auto-instantiate themselves a
    <span class="Li">&quot;PPI::Lexer&quot;</span> object as needed.</p>
<p class="Pp">All methods do a one-shot &quot;lex this and give me a
    PPI::Document object&quot;.</p>
<p class="Pp">In fact, if you are reading this, what you <b>probably</b> want to
    do is to just &quot;load a document&quot;, in which case you can do this in
    a much more direct and concise manner with one of the following.</p>
<p class="Pp"></p>
<pre>  use PPI;
  
  $Document = PPI::Document-&gt;load( $filename );
  $Document = PPI::Document-&gt;new( $string );
</pre>
<p class="Pp">See PPI::Document for more details.</p>
<p class="Pp">For more unusual tasks, by all means forge onwards.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="METHODS"><a class="permalink" href="#METHODS">METHODS</a></h1>
<section class="Ss">
<h2 class="Ss" id="new"><a class="permalink" href="#new">new</a></h2>
<p class="Pp">The <span class="Li">&quot;new&quot;</span> constructor creates a
    new <span class="Li">&quot;PPI::Lexer&quot;</span> object. The object itself
    is merely used to hold various buffers and state data during the lexing
    process, and holds no significant data between -&gt;lex_xxxxx calls.</p>
<p class="Pp">Returns a new <span class="Li">&quot;PPI::Lexer&quot;</span>
    object</p>
</section>
<section class="Ss">
<h2 class="Ss" id="lex_file_$filename"><a class="permalink" href="#lex_file_$filename">lex_file
  $filename</a></h2>
<p class="Pp">The <span class="Li">&quot;lex_file&quot;</span> method takes a
    filename as argument. It then loads the file, creates a PPI::Tokenizer for
    the content and lexes the token stream produced by the tokenizer. Basically,
    a sort of all-in-one method for getting a PPI::Document object from a file
    name.</p>
<p class="Pp">Returns a PPI::Document object, or
    <span class="Li">&quot;undef&quot;</span> on error.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="lex_source_$string"><a class="permalink" href="#lex_source_$string">lex_source
  $string</a></h2>
<p class="Pp">The <span class="Li">&quot;lex_source&quot;</span> method takes a
    normal scalar string as argument. It creates a PPI::Tokenizer object for the
    string, and then lexes the resulting token stream.</p>
<p class="Pp">Returns a PPI::Document object, or
    <span class="Li">&quot;undef&quot;</span> on error.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="lex_tokenizer_$Tokenizer"><a class="permalink" href="#lex_tokenizer_$Tokenizer">lex_tokenizer
  $Tokenizer</a></h2>
<p class="Pp">The <span class="Li">&quot;lex_tokenizer&quot;</span> takes as
    argument a PPI::Tokenizer object. It lexes the token stream from the
    tokenizer into a PPI::Document object.</p>
<p class="Pp">Returns a PPI::Document object, or
    <span class="Li">&quot;undef&quot;</span> on error.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="errstr"><a class="permalink" href="#errstr">errstr</a></h2>
<p class="Pp">For any error that occurs, you can use the
    <span class="Li">&quot;errstr&quot;</span>, as either a static or object
    method, to access the error message.</p>
<p class="Pp">If no error occurs for any particular action,
    <span class="Li">&quot;errstr&quot;</span> will return false.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="TO_DO"><a class="permalink" href="#TO_DO">TO DO</a></h1>
<p class="Pp">- Add optional support for some of the more common source
  filters</p>
<p class="Pp">- Some additional checks for blessing things into various
    Statement and Structure subclasses.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SUPPORT"><a class="permalink" href="#SUPPORT">SUPPORT</a></h1>
<p class="Pp">See the support section in the main module.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">Adam Kennedy &lt;adamk@cpan.org&gt;</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT"><a class="permalink" href="#COPYRIGHT">COPYRIGHT</a></h1>
<p class="Pp">Copyright 2001 - 2011 Adam Kennedy.</p>
<p class="Pp">This program is free software; you can redistribute it and/or
    modify it under the same terms as Perl itself.</p>
<p class="Pp">The full text of the license can be found in the LICENSE file
    included with this module.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2019-07-09</td>
    <td class="foot-os">perl v5.30.2</td>
  </tr>
</table>
</body>
</html>
