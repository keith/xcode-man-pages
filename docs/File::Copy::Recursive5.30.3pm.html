<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>File::Copy::Recursive(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">File::Copy::Recursive(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">File::Copy::Recursive(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
File::Copy::Recursive - Perl extension for recursively copying files and
  directories
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<span class="Li"></span>
<pre>
  use File::Copy::Recursive qw(fcopy rcopy dircopy fmove rmove dirmove);

  fcopy($orig,$new[,$buf]) or die $!;
  rcopy($orig,$new[,$buf]) or die $!;
  dircopy($orig,$new[,$buf]) or die $!;

  fmove($orig,$new[,$buf]) or die $!;
  rmove($orig,$new[,$buf]) or die $!;
  dirmove($orig,$new[,$buf]) or die $!;
  
  rcopy_glob(&quot;orig/stuff-*&quot;, $trg [, $buf]) or die $!;
  rmove_glob(&quot;orig/stuff-*&quot;, $trg [,$buf]) or die $!;
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
This module copies and moves directories recursively (or single files, well...
  singley) to an optional depth and attempts to preserve each file or
  directory's mode.
</section>
<section class="Sh">
<h1 class="Sh" id="EXPORT"><a class="permalink" href="#EXPORT">EXPORT</a></h1>
None by default. But you can export all the functions as in the example above
  and the path* functions if you wish.
<section class="Ss">
<h2 class="Ss" id="_fBfcopy()_fP"><a class="permalink" href="#_fBfcopy()_fP"><b>fcopy()</b></a></h2>
This function uses File::Copy's <b>copy()</b> function to copy a file but not a
  directory. Any directories are recursively created if need be. One difference
  to <b>File::Copy::copy()</b> is that fcopy attempts to preserve the mode (see
  Preserving Mode below) The optional <span class="Li">$buf</span> in the
  synopsis is the same as <b>File::Copy::copy()</b>'s 3rd argument. This
  function returns the same as <b>File::Copy::copy()</b> in scalar context and
  1,0,0 in list context to accomodate <b>rcopy()</b>'s list context on regular
  files. (See below for more info)
</section>
<section class="Ss">
<h2 class="Ss" id="_fBdircopy()_fP"><a class="permalink" href="#_fBdircopy()_fP"><b>dircopy()</b></a></h2>
This function recursively traverses the <span class="Li">$orig</span>
  directory's structure and recursively copies it to the
  <span class="Li">$new</span> directory. <span class="Li">$new</span> is
  created if necessary (multiple non existent directories is ok (i.e.
  foo/bar/baz). The script logically and portably creates all of them if
  necessary). It attempts to preserve the mode (see Preserving Mode below) and
  by default it copies all the way down into the directory (see Managing Depth,
  below). If a directory is not specified it croaks just like fcopy croaks if
  its not a file that is specified.
<p class="Pp">This function returns true or false: for true in scalar context it
    returns the number of files and directories copied, whereas in list context
    it returns the number of files and directories, number of directories only,
    depth level traversed.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  my $num_of_files_and_dirs = dircopy($orig,$new);
  my($num_of_files_and_dirs,$num_of_dirs,$depth_traversed) = dircopy($orig,$new);
</pre>
<p class="Pp">Normally it stops and returns if a copy fails. To continue on
    regardless, set <span class="Li">$File::Copy::Recursive::SkipFlop</span> to
    true.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    local $File::Copy::Recursive::SkipFlop = 1;
</pre>
<p class="Pp">That way it will copy everythging it can in a directory and won't
    stop because of permissions, etc...</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_fBrcopy()_fP"><a class="permalink" href="#_fBrcopy()_fP"><b>rcopy()</b></a></h2>
This function will allow you to specify a file *or* a directory. It calls
  <b>fcopy()</b> if you passed file and <b>dircopy()</b> if you passed a
  directory. If you call <b>rcopy()</b> (or <b>fcopy()</b> for that matter) on a
  file in list context, the values will be 1,0,0 since no directories and no
  depth are used. This is important because if it's a directory in list context
  and there is only the initial directory the return value is 1,1,1.
</section>
<section class="Ss">
<h2 class="Ss" id="_fBrcopy_glob()_fP"><a class="permalink" href="#_fBrcopy_glob()_fP"><b>rcopy_glob()</b></a></h2>
This function lets you specify a pattern suitable for perl's
  <b>File::Glob::bsd_glob()</b> as the first argument. Subsequently each path
  returned by perl's <b>File::Glob::bsd_glob()</b> gets <b>rcopy()</b>ied.
<p class="Pp">It returns and array whose items are array refs that contain the
    return value of each <b>rcopy()</b> call.</p>
<p class="Pp">It forces behavior as if
    <span class="Li">$File::Copy::Recursive::CPRFComp</span> is true.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_fBfmove()_fP"><a class="permalink" href="#_fBfmove()_fP"><b>fmove()</b></a></h2>
Copies the file then removes the original. You can manage the path the original
  file is in according to <span class="Li">$RemvBase</span>.
</section>
<section class="Ss">
<h2 class="Ss" id="_fBdirmove()_fP"><a class="permalink" href="#_fBdirmove()_fP"><b>dirmove()</b></a></h2>
Uses <b>dircopy()</b> to copy the directory then removes the original. You can
  manage the path the original directory is in according to
  <span class="Li">$RemvBase</span>.
</section>
<section class="Ss">
<h2 class="Ss" id="_fBrmove()_fP"><a class="permalink" href="#_fBrmove()_fP"><b>rmove()</b></a></h2>
Like <b>rcopy()</b> but calls <b>fmove()</b> or <b>dirmove()</b> instead.
</section>
<section class="Ss">
<h2 class="Ss" id="_fBrmove_glob()_fP"><a class="permalink" href="#_fBrmove_glob()_fP"><b>rmove_glob()</b></a></h2>
Like <b>rcopy_glob()</b> but calls <b>rmove()</b> instead of <b>rcopy()</b>
<p class="Pp"><i></i><i>$RemvBase</i><i></i></p>
<p class="Pp">Default is false. When set to true the *<b>move()</b> functions
    will not only attempt to remove the original file or directory but will
    remove the given path it is in.</p>
<p class="Pp">So if you:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
   rmove('foo/bar/baz', '/etc/');
   # &quot;baz&quot; is removed from foo/bar after it is successfully copied to /etc/
   
   local $File::Copy::Recursive::Remvbase = 1;
   rmove('foo/bar/baz','/etc/');
   # if baz is successfully copied to /etc/ :
   # first &quot;baz&quot; is removed from foo/bar
   # then &quot;foo/bar is removed via pathrm()
</pre>
<p class="Pp"><span class="Li">$ForcePth</span></p>
<p class="Pp">Default is false. When set to true it calls <b>pathempty()</b>
    before any directories are removed to empty the directory so it can be
    <b>rmdir()</b>'ed when <span class="Li">$RemvBase</span> is in effect.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Creating_and_Removing_Paths"><a class="permalink" href="#Creating_and_Removing_Paths">Creating
  and Removing Paths</a></h2>
<i></i><i>$NoFtlPth</i><i></i>
<p class="Pp">Default is false. If set to true <b>rmdir()</b>, <b>mkdir()</b>,
    and <b>pathempty()</b> calls in <b>pathrm()</b> and <b>pathmk()</b> do not
    <b>return()</b> on failure.</p>
<p class="Pp">If its set to true they just silently go about their business
    regardless. This isn't a good idea but it's there if you want it.</p>
<p class="Pp"><i></i><i>$DirPerms</i><i></i></p>
<p class="Pp">Mode to pass to any <b>mkdir()</b> calls. Defaults to 0777 as per
    <b>umask()</b>'s POD. Explicitly having this allows older perls to be able
    to use FCR and might add a bit of flexibility for you.</p>
<p class="Pp">Any value you set it to should be suitable for <b>oct()</b>.</p>
<p class="Pp"><i>Path functions</i></p>
<p class="Pp">These functions exist solely because they were necessary for the
    move and copy functions to have the features they do and not because they
    are of themselves the purpose of this module. That being said, here is how
    they work so you can understand how the copy and move functions work and use
    them by themselves if you wish.</p>
<p class="Pp"><b>pathrm()</b></p>
<p class="Pp">Removes a given path recursively. It removes the *entire* path so
    be careful!!!</p>
<p class="Pp">Returns 2 if the given path is not a directory.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  File::Copy::Recursive::pathrm('foo/bar/baz') or die $!;
  # foo no longer exists
</pre>
<p class="Pp">Same as:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  rmdir 'foo/bar/baz' or die $!;
  rmdir 'foo/bar' or die $!;
  rmdir 'foo' or die $!;
</pre>
<p class="Pp">An optional second argument makes it call <b>pathempty()</b>
    before any <b>rmdir()</b>'s when set to true.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  File::Copy::Recursive::pathrm('foo/bar/baz', 1) or die $!;
  # foo no longer exists
</pre>
<p class="Pp">Same as:PFSCheck</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  File::Copy::Recursive::pathempty('foo/bar/baz') or die $!;
  rmdir 'foo/bar/baz' or die $!;
  File::Copy::Recursive::pathempty('foo/bar/') or die $!;
  rmdir 'foo/bar' or die $!;
  File::Copy::Recursive::pathempty('foo/') or die $!;
  rmdir 'foo' or die $!;
</pre>
<p class="Pp">An optional third argument acts like
    <span class="Li">$File::Copy::Recursive::NoFtlPth</span>, again probably not
    a good idea.</p>
<p class="Pp"><b>pathempty()</b></p>
<p class="Pp">Recursively removes the given directory's contents so it is empty.
    Returns 2 if the given argument is not a directory, 1 on successfully
    emptying the directory.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
   File::Copy::Recursive::pathempty($pth) or die $!;
   # $pth is now an empty directory
</pre>
<p class="Pp"><b>pathmk()</b></p>
<p class="Pp">Creates a given path recursively. Creates foo/bar/baz even if foo
    does not exist.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
   File::Copy::Recursive::pathmk('foo/bar/baz') or die $!;
</pre>
<p class="Pp">An optional second argument if true acts just like
    <span class="Li">$File::Copy::Recursive::NoFtlPth</span>, which means you'd
    never get your <b>die()</b> if something went wrong. Again, probably a *bad*
    idea.</p>
<p class="Pp"><b>pathrmdir()</b></p>
<p class="Pp">Same as <b>rmdir()</b> but it calls <b>pathempty()</b> first to
    recursively empty it first since rmdir can not remove a directory with
    contents. Just removes the top directory the path given instead of the
    entire path like <b>pathrm()</b>. Returns 2 if the given argument does not
    exist (i.e. it's already gone). Returns false if it exists but is not a
    directory.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Preserving_Mode"><a class="permalink" href="#Preserving_Mode">Preserving
  Mode</a></h2>
By default a quiet attempt is made to change the new file or directory to the
  mode of the old one. To turn this behavior off set
 <span class="Li">$File::Copy::Recursive::KeepMode</span> to false;
</section>
<section class="Ss">
<h2 class="Ss" id="Managing_Depth"><a class="permalink" href="#Managing_Depth">Managing
  Depth</a></h2>
You can set the maximum depth a directory structure is recursed by setting:
 <span class="Li">$File::Copy::Recursive::MaxDepth</span> to a whole number
  greater than 0.
</section>
<section class="Ss">
<h2 class="Ss" id="SymLinks"><a class="permalink" href="#SymLinks">SymLinks</a></h2>
If your system supports symlinks then symlinks will be copied as symlinks
  instead of as the target file. Perl's <b>symlink()</b> is used instead of
  File::Copy's <b>copy()</b>. You can customize this behavior by setting
  <span class="Li">$File::Copy::Recursive::CopyLink</span> to a true or false
  value. It is already set to true or false depending on your system's support
  of symlinks so you can check it with an if statement to see how it will
  behave:
<p class="Pp"><span class="Li"></span></p>
<pre>
    if($File::Copy::Recursive::CopyLink) {
        print &quot;Symlinks will be preserved\n&quot;;
    } else {
        print &quot;Symlinks will not be preserved because your system does not support it\n&quot;;
    }
</pre>
<p class="Pp">If symlinks are being copied you can set
    <span class="Li">$File::Copy::Recursive::BdTrgWrn</span> to true to make it
    carp when it copies a link whose target does not exist. It's false by
    default.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    local $File::Copy::Recursive::BdTrgWrn  = 1;
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Removing_existing_target_file_or_directory_before_copying."><a class="permalink" href="#Removing_existing_target_file_or_directory_before_copying.">Removing
  existing target file or directory before copying.</a></h2>
This can be done by setting
  <span class="Li">$File::Copy::Recursive::RMTrgFil</span> or
  <span class="Li">$File::Copy::Recursive::RMTrgDir</span> for file or directory
  behavior respectively.
<p class="Pp">0 = off (This is the default)</p>
<p class="Pp">1 = <b>carp()</b> $! if removal fails</p>
<p class="Pp">2 = return if removal fails</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    local $File::Copy::Recursive::RMTrgFil = 1;
    fcopy($orig, $target) or die $!;
    # if it fails it does warn() and keeps going

    local $File::Copy::Recursive::RMTrgDir = 2;
    dircopy($orig, $target) or die $!;
    # if it fails it does your &quot;or die&quot;
</pre>
<p class="Pp">This should be unnecessary most of the time but it's there if you
    need it :)</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Turning_off__fBstat()_fP_check"><a class="permalink" href="#Turning_off__fBstat()_fP_check">Turning
  off <b>stat()</b> check</a></h2>
By default the files or directories are checked to see if they are the same
  (i.e. linked, or two paths (absolute/relative or different relative paths) to
  the same file) by comparing the file's <b>stat()</b> info. It's a very
  efficient check that croaks if they are and shouldn't be turned off but if you
  must for some weird reason just set
  <span class="Li">$File::Copy::Recursive::PFSCheck</span> to a false value.
  (&quot;PFS&quot; stands for &quot;Physical File System&quot;)
</section>
<section class="Ss">
<h2 class="Ss" id="Emulating_cp__-rf_dir1/_dir2/"><a class="permalink" href="#Emulating_cp__-rf_dir1/_dir2/">Emulating
  cp -rf dir1/ dir2/</a></h2>
By default dircopy($dir1,$dir2) will put <span class="Li">$dir1</span>'s
  contents right into <span class="Li">$dir2</span> whether
  <span class="Li">$dir2</span> exists or not.
<p class="Pp">You can make <b>dircopy()</b> emulate cp -rf by setting
    <span class="Li">$File::Copy::Recursive::CPRFComp</span> to true.</p>
<p class="Pp">NOTE: This only emulates -f in the sense that it does not prompt.
    It does not remove the target file or directory if it exists. If you need to
    do that then use the variables <span class="Li">$RMTrgFil</span> and
    <span class="Li">$RMTrgDir</span> described in &quot;Removing existing
    target file or directory before copying&quot; above.</p>
<p class="Pp">That means that if <span class="Li">$dir2</span> exists it puts
    the contents into <span class="Li">$dir2</span>/$dir1 instead of
    <span class="Li">$dir2</span> just like cp -rf. If
    <span class="Li">$dir2</span> does not exist then the contents go into
    <span class="Li">$dir2</span> like normal (also like cp -rf).</p>
<p class="Pp">So assuming 'foo/file':</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    dircopy('foo', 'bar') or die $!;
    # if bar does not exist the result is bar/file
    # if bar does exist the result is bar/file

    $File::Copy::Recursive::CPRFComp = 1;
    dircopy('foo', 'bar') or die $!;
    # if bar does not exist the result is bar/file
    # if bar does exist the result is bar/foo/file
</pre>
<p class="Pp">You can also specify a star for cp -rf glob type behavior:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    dircopy('foo/*', 'bar') or die $!;
    # if bar does not exist the result is bar/file
    # if bar does exist the result is bar/file

    $File::Copy::Recursive::CPRFComp = 1;
    dircopy('foo/*', 'bar') or die $!;
    # if bar does not exist the result is bar/file
    # if bar does exist the result is bar/file
</pre>
<p class="Pp">NOTE: The '*' is only like cp -rf foo/* and *DOES NOT EXPAND
    PARTIAL DIRECTORY NAMES LIKE YOUR SHELL DOES* (i.e. not like cp -rf fo* to
    copy foo/*).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Allowing_Copy_Loops"><a class="permalink" href="#Allowing_Copy_Loops">Allowing
  Copy Loops</a></h2>
If you want to allow:
<p class="Pp"><span class="Li"></span></p>
<pre>
  cp -rf . foo/
</pre>
<p class="Pp">type behavior set
    <span class="Li">$File::Copy::Recursive::CopyLoop</span> to true.</p>
<p class="Pp">This is false by default so that a check is done to see if the
    source directory will contain the target directory and croaks to avoid this
    problem.</p>
<p class="Pp">If you ever find a situation where
    <span class="Li">$CopyLoop</span> = 1 is desirable let me know. (i.e. it's a
    bad bad idea but is there if you want it)</p>
<p class="Pp">(Note: On Windows this was necessary since it uses <b>stat()</b>
    to determine sameness and <b>stat()</b> is essentially useless for this on
    Windows. The test is now simply skipped on Windows but I'd rather have an
    actual reliable check if anyone in Microsoft land would care to share)</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
File::Copy File::Spec
</section>
<section class="Sh">
<h1 class="Sh" id="TO_DO"><a class="permalink" href="#TO_DO">TO DO</a></h1>
I am currently working on and reviewing some other modules to use in the new
  interface so we can lose the horrid globals as well as some other undesirable
  traits and also more easily make available some long standing requests.
<p class="Pp">Tests will be easier to do with the new interface and hence the
    testing focus will shift to the new interface and aim to be
  comprehensive.</p>
<p class="Pp">The old interface will work, it just won't be brought in until it
    is used, so it will add no overhead for users of the new interface.</p>
<p class="Pp">I'll add this after the latest version has been out for a while
    with no new features or issues found :)</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
Daniel Muey, &lt;http://drmuey.com/cpan_contact.pl&gt;
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT_AND_LICENSE"><a class="permalink" href="#COPYRIGHT_AND_LICENSE">COPYRIGHT
  AND LICENSE</a></h1>
Copyright 2004 by Daniel Muey
<p class="Pp">This library is free software; you can redistribute it and/or
    modify it under the same terms as Perl itself.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2019-07-23</td>
    <td class="foot-os">perl v5.30.2</td>
  </tr>
</table>
</body>
</html>
