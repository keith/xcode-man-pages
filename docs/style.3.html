<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Copyright (c) 2017 Apple Inc. All rights reserved.
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>style(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">style(3)</td>
    <td class="head-vol">Library Functions Manual</td>
    <td class="head-rtitle">style(3)</td>
  </tr>
</table>
<div class="manual-text">
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<code class="Nm">style</code> &#x2014;
<div class="Nd">C language style guide for Darwin low-level userspace
  projects</div>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
This style's primary objective is to be as friendly to the code review process
  as possible. Therefore, the style aims to ensure that code changes to the
  project produce diffs that are
<p class="Pp"></p>
<ul class="Bl-bullet Bd-indent Bl-compact">
  <li>small</li>
  <li>unambiguous</li>
  <li>viewable in side-by-side comparison tools</li>
</ul>
<p class="Pp">As a secondary objective, this style also aims to make code as
    clear as possible for an uninitiated programmer reading it.
    &quot;Clever&quot; syntactic shortcuts are actively discouraged in favor of
    code that is easy to understand, even if it is less concise. Coincidentally,
    this practice also tends to lend itself to generating more readable
  diffs.</p>
<p class="Pp">Like any style, consistent adherence across a project is a virtue
    in and of itself, resulting in less distraction for the reader. However,
    these guidelines should be taken as exactly that: guidelines. No style can
    be completely adhered to all the time. When you have convinced yourself that
    a deviation from the style is called for, just make sure it is for the
    greater good and maintains the style's aims of minimizing diffs and code
    complexity.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="GENERAL_PRINCIPLES"><a class="permalink" href="#GENERAL_PRINCIPLES">GENERAL
  PRINCIPLES</a></h1>
<section class="Ss">
<h2 class="Ss" id="Vertical_space_is_a_commodity"><a class="permalink" href="#Vertical_space_is_a_commodity">Vertical
  space is a commodity</a></h2>
Scrolling vertically has always been easier than scrolling horizontally.
  Computer mouse manufacturers went so far as to dedicate hardware to the task
  of scrolling vertically when they came up with scroll wheels. Even on modern
  trackpads, while it is possible to scroll horizontally, it is far easier to
  scroll vertically. You just flick upwards. Do not be afraid to introduce extra
  lines of code if it will result in clearer, more human-parseable diffs when
  those lines are changed.
</section>
<section class="Ss">
<h2 class="Ss" id="Horizontal_space_is_precious"><a class="permalink" href="#Horizontal_space_is_precious">Horizontal
  space is precious</a></h2>
Scrolling horizontally is typically awkward, imprecise, and does not lend itself
  well toward reading on computers or even in print. (Academic journals
  frequently publish with two narrow columns per page to make reading easier,
  for example.) Lines should be wrapped consciously; this should not be left to
  the editor. A soft-wrapping scheme that looks good in your editor may not look
  good in someone else's editor (or with a different configuration for the same
  editor).
<p class="Pp">Just as natural language comments are difficult to read in one,
    long line, so too are lines of code. Both natural languages and programming
    languages deserve conscious, deliberate wrapping to improve readability.</p>
<p class="Pp">Wrap at a column width narrow enough to accommodate side-by-side
    patch review. 80 is more likely to accommodate this, but 120 might be fine
    too. Pick a reasonable column width and stick to it. Think about the lines
    you are wrapping. If you have to wrap a line, do so in a way that is clear,
    and be willing to make changes to accommodate that (e.g. don't be afraid to
    declare a variable separately if having the declaration and assignment on
    the same line causes it to wrap in an unclear way).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Indentation_is_for_scope_indication_and_nothing_else"><a class="permalink" href="#Indentation_is_for_scope_indication_and_nothing_else">Indentation
  is for scope indication and nothing else</a></h2>
Indentation's sole purpose is to indicate scope. You should not use indentation
  to align characters on two lines of source code (beyond, of course, aligning
  the first characters of each line if they are both in the same scope).
<p class="Pp">Given this aspect of the style, it does not particularly matter
    whether the author chooses spaces or tabs for indentation, and therefore the
    style makes no prescription (other than to pick one and stick with it).</p>
<p class="Pp">This style also has another implication: tabs and spaces should
    never appear in sequence. Each line will be a series of tabs followed by the
    first character of code. Tabs will never appear after the initial
    indentation of the line.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Don't_require_leaving_the_source_to_understand_it"><a class="permalink" href="#Don't_require_leaving_the_source_to_understand_it">Don't
  require leaving the source to understand it</a></h2>
Always think of future maintainers and document your thought process for them.
  Remember, a &quot;future maintainer&quot; might be you after you've forgotten
  why you did something. For non-trivial changes, you should not rely on linking
  to a ticket-tracking system to provide context and explanation for a piece of
  code. You should strive to ensure the reader of your code does not have to
  context-switch out of reading it in order to understand it.
<p class="Pp">This is not to say that linking to external resources in code is
    bad, but if a change's purpose can be reasonably expressed without
    interrupting how the code reads and flows, just do it. You don't need to
    publish a whitepaper in comments, but don't just give a link or ticket
    number with no context.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Each_line_of_code_should_minimize_entropy"><a class="permalink" href="#Each_line_of_code_should_minimize_entropy">Each
  line of code should minimize entropy</a></h2>
It is actually very difficult to construct a hash comparison scheme that humans
  can use without error consistently, and there have been successful social
  engineering attacks on getting humans to read two hashes that are &quot;close
  enough&quot; as identical. This means that humans need a lot of help telling
  the difference between two lines of text.
<p class="Pp">For any expression, divide it up into fundamental atoms (variable
    declarations, conditionals, etc.) and then assign each of those atoms to its
    own line of code. If you do this, when you change a single atom, it is
    immediately obvious that <i class="Em">only</i> that atom changed and
    nothing else did. The more atoms share lines of code, the more likely it is
    that changes to them will generate complex diffs that humans will have
    difficulty understanding.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Don't_assume_a_specific_editor"><a class="permalink" href="#Don't_assume_a_specific_editor">Don't
  assume a specific editor</a></h2>
Assume people will be reading your code in a tool that you do not control and
  cannot influence. Try viewing your code in such a tool and make sure that it
  is understandable. If you follow the guidelines of this style, your code may
  appear different in another viewer (in terms of how many columns are required
  to display a single line), but its structure will appear identical.
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="SPECIFIC_GUIDELINES"><a class="permalink" href="#SPECIFIC_GUIDELINES">SPECIFIC
  GUIDELINES</a></h1>
<section class="Ss">
<h2 class="Ss" id="Column_Width_and_Line_Wrap"><a class="permalink" href="#Column_Width_and_Line_Wrap">Column
  Width and Line Wrap</a></h2>
80 columns opens the door for a three-way, side-by-side comparison, but it could
  be impractical for a number of reasons. 120 columns should provide a nice
  balance, but really all that matters is that you pick a width and stick to it.
<p class="Pp">When indenting a continuation line, indent over by two additional
    tabs. This visually separates the indented line from the next line, which
    may itself be indented. If there is an operator in the middle of the line,
    the operator should <i class="Em">not</i> be wrapped to the continuation
    line.</p>
<p class="Pp"><i class="Em">Good</i></p>
<div class="Bd Pp Bd-indent">
<pre>
if (some_condition &amp;&amp; some_other_condition &amp;&amp;
        yet_another_condition) {
    exit(0);
}
</pre>
</div>
<p class="Pp"><i class="Em">Bad</i></p>
<div class="Bd Pp Bd-indent">
<pre>
if (some_condition &amp;&amp; some_other_condition &amp;&amp;
    yet_another_condition) {
    exit(0);
}

if (some_condition &amp;&amp; some_other_condition
    &amp;&amp; yet_another_condition) {
    exit(0);
}
</pre>
</div>
<p class="Pp">Notice on the good example that the
    <code class="Ic">exit(0)</code> line is made obviously distinct from the
    indented conditions above it. It's very clear on quick visual inspection
    that it's not a part of the conditional checks. The
    <code class="Ic">&amp;&amp;</code> is left on the first line because, when
    reviewing a patch to this area, it will be immediately clear to the reviewer
    that that line continues to the next one.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Avoid_prettifying_alignment"><a class="permalink" href="#Avoid_prettifying_alignment">Avoid
  prettifying alignment</a></h2>
Indentation is used only for indicating scope, so no consideration is given to
  visual alignment of equal signs, colons, etc. across multiple lines.
<p class="Pp"><i class="Em">Good</i></p>
<div class="Bd Pp Bd-indent">
<pre>
typedef enum {
    THING0 = 0,
    THING1 = 1,
    THING_THAT_IS_REALLY_LONG = 2,
} thing_t;
</pre>
</div>
<p class="Pp"><i class="Em">Bad</i></p>
<div class="Bd Pp Bd-indent">
<pre>
enum {
    THING0                    = 0,
    THING1                    = 1,
    THING_THAT_IS_REALLY_LONG = 2,
};
</pre>
</div>
<p class="Pp">This creates bloated diffs. If you have to re-align a ton of lines
    after you've added something longer, you get a bunch of whitespace diffs. So
    for variable declarations, enumerations, assignments, etc. just keep every
    line independent.</p>
<p class="Pp">There is one exception to this rule, and that is if you choose to
    define a flagset in terms of its raw hexadecimal values and wish to align
    them. In this case, it is a significant benefit to have these values
    aligned, and you may do so with spaces.</p>
<p class="Pp"><i class="Em">Example</i></p>
<div class="Bd Pp Bd-indent">
<pre>
typedef enum {
	F_INIT   = 0x00,
	F_FOO    = 0x01,
	F_BARBAZ = 0x02,
	F_CAD    = 0x04,
	F_FAD    = 0x08,
	F_FUD    = 0x10,
	F_FLAME  = 0x20,
	F_FOOD   = 0x40,
} flag_t;
</pre>
</div>
</section>
<section class="Ss">
<h2 class="Ss" id="Only_one_blank_line_at_a_time"><a class="permalink" href="#Only_one_blank_line_at_a_time">Only
  one blank line at a time</a></h2>
Use blank lines to separate logical chunks of code. Do not use more than one.
</section>
<section class="Ss">
<h2 class="Ss" id="Initialization"><a class="permalink" href="#Initialization">Initialization</a></h2>
C99 has named initializers for structures. Prefer those to initializing members
  one-by-one later on. Both structures and arrays should be initialized in the
  same style, with each element of the initializer being on its own line. This
  is so that when an element is added to or removed from the initialization
  list, that change gets its own line of diff.
<p class="Pp">The exception to this is the string literal.</p>
<p class="Pp"><i class="Em">Good</i></p>
<div class="Bd Pp Bd-indent">
<pre>
struct my_struct baz = {
    .ms_foo = 1,
    .ms_bar = NULL,
};

char *strings[] = {
    &quot;string&quot;,
    &quot;other string&quot;,
};
</pre>
</div>
<i class="Em">Bad</i>
<div class="Bd Pp Bd-indent">
<pre>
struct my_struct baz = { 1, NULL };

struct my_struct baz = {
    1,
    NULL
};

struct my_struct baz = { .ms_foo = 1, .ms_bar = NULL, };
</pre>
</div>
<p class="Pp">The last element of an initializer list should be followed by a
    comma. This is so that when you add a new element to that list, it's a
    one-line diff rather rather than a two-line diff (one line of diff to add
    the , to the previous-last element, and another line of diff to add the
    new-last element).</p>
<p class="Pp"><i class="Em">Good</i></p>
<div class="Bd Pp Bd-indent">
<pre>
enum {
    THING0,
    THING1,
};

struct my_point p = {
    .x = 1,
    .y = 0,
    .z = 1,
};
</pre>
</div>
<p class="Pp"><i class="Em">Bad</i></p>
<div class="Bd Pp Bd-indent">
<pre>
enum {
    THING0, THING1,
};

enum {
    THING0,
    THING1
};

struct my_point p = { .x = 1, .y = 0, .z = 1 };
</pre>
</div>
<p class="Pp">Note that, if your project requires ANSI C compliance, you should
    disregard this guideline, as it will not work under C89.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Avoid_function_name_overloading"><a class="permalink" href="#Avoid_function_name_overloading">Avoid
  function name overloading</a></h2>
The <a class="Xr">clang(1)</a> compiler supports extensions to the C language
  which allow for function name overloading. Name overloading generally leads to
  code which is difficult to read and introspect and should be avoided.
</section>
<section class="Ss">
<h2 class="Ss" id="Prefix__struct__members"><a class="permalink" href="#Prefix__struct__members">Prefix
  `struct` members</a></h2>
Any <code class="Ic">struct</code> which is shared or exported should have a
  common prefix for each member. This helps avoid collisions with preprocessor
  macros.
<p class="Pp"><i class="Em">Good</i></p>
<div class="Bd Pp Bd-indent">
<pre>
struct foobar {
	int64_t fb_baz;
	char *fb_string;
};
</pre>
</div>
<p class="Pp"><i class="Em">Bad</i></p>
<div class="Bd Pp Bd-indent">
<pre>
struct foobar {
	int64_t baz;
	char *string;
};
</pre>
</div>
</section>
<section class="Ss">
<h2 class="Ss" id="Types_end_with___t_"><a class="permalink" href="#Types_end_with___t_">Types
  end with `_t`</a></h2>
A type is indicated with <code class="Ic">_t</code> at the end of the
  <code class="Ic">typedef</code>, whether the type refers to a
  <code class="Ic">struct</code>, <code class="Ic">union</code>,
  <code class="Ic">enum</code>, etc. All types are indicated this way. Types are
  in all lower-case letters.
<p class="Pp"><i class="Em">Good</i></p>
<div class="Bd Pp Bd-indent">
<pre>
typedef uint64_t handle_t;
typedef enum foo foo_t;
typedef union bar bar_t;
</pre>
</div>
<p class="Pp"><i class="Em">Bad</i></p>
<div class="Bd Pp Bd-indent">
<pre>
typedef uint64_t Handle;
typedef enum foo foo_e;
typedef union bar bar_u;
</pre>
</div>
</section>
<section class="Ss">
<h2 class="Ss" id="Use_explicitly_sized_integer_types"><a class="permalink" href="#Use_explicitly_sized_integer_types">Use
  explicitly-sized integer types</a></h2>
Avoid integer types whose names do not indicate size, such as
  <code class="Ic">int</code> or <code class="Ic">long</code>. Instead, use the
  types from <code class="Ic">stdint.h</code> (e.g.
  <code class="Ic">int64_t</code>, <code class="Ic">uint32_t</code>, etc.),
  which explicitly indicate size. You may use size-ambiguous integer types if an
  API requires it.
</section>
<section class="Ss">
<h2 class="Ss" id="Use__sizeof()__on_variables_rather_than_types_where_appropriate"><a class="permalink" href="#Use__sizeof()__on_variables_rather_than_types_where_appropriate">Use
  `sizeof()` on variables rather than types where appropriate</a></h2>
The <code class="Ic">sizeof()</code> operator can take both types and variables
  as arguments. Where possible and relevant, always pass a variable. This
  ensures that if the variable's type changes, the proper size is used
  automatically.
<p class="Pp"><i class="Em">Good</i></p>
<div class="Bd Pp Bd-indent">
<pre>
uuid_t ident;
memcpy(ident, buff, sizeof(ident));
</pre>
</div>
<p class="Pp"><i class="Em">Bad</i></p>
<div class="Bd Pp Bd-indent">
<pre>
uuid_t ident;
memcpy(ident, buff, sizeof(uuid_t));
</pre>
</div>
<p class="Pp"><i class="Em">IMPORTANT</i>: When applied to a
    <code class="Ic">char *</code>, <code class="Ic">sizeof()</code> will return
    the width of a pointer, <i class="Em">not</i> the size of the string literal
    it points to, so take care to only use <a class="Xr">strlen(3)</a> for such
    cases.</p>
<p class="Pp">Relatedly, when applied to an array variable that is a parameter
    in a function's parameter list, <code class="Ic">sizeof()</code> will return
    the width of a pointer, <i class="Em">not</i> the size of the type.</p>
<p class="Pp"><i class="Em">Good</i></p>
<div class="Bd Pp Bd-indent">
<pre>
char *string = &quot;the quick brown fox&quot;;
size_t len = strlen(string);

void
foo(uuid_t u)
{
	uuid_t u2;
	memcpy(u2, u, sizeof(uuid_t));
}
</pre>
</div>
<p class="Pp"><i class="Em">Bad</i></p>
<div class="Bd Pp Bd-indent">
<pre>
char *string = &quot;the quick brown fox&quot;;
size_t len = sizeof(string) - 1;

void
foo(uuid_t u)
{
	uuid_t u2;

	// sizeof(u) == sizeof(void *) in this context.
	memcpy(u2, u, sizeof(u));
}
</pre>
</div>
</section>
<section class="Ss">
<h2 class="Ss" id="Functions_which_take_no_parameters_have_a_parameter_list_of__void_"><a class="permalink" href="#Functions_which_take_no_parameters_have_a_parameter_list_of__void_">Functions
  which take no parameters have a parameter list of `void`</a></h2>
In C, an empty function parameter list means that <i class="Em">any</i> set of
  parameters is acceptable. In virtually all cases where you do this, you mean
  to have a parameter list of <code class="Ic">void</code>.
<p class="Pp"><i class="Em">Good</i></p>
<div class="Bd Pp Bd-indent">
<pre>
void
foo(void)
{
    do_a_thing_without_arguments();
}
</pre>
</div>
<p class="Pp"><i class="Em">Bad</i></p>
<div class="Bd Pp Bd-indent">
<pre>
void
foo()
{
    do_a_thing_without_arguments();
}
</pre>
</div>
</section>
<section class="Ss">
<h2 class="Ss" id="Preprocessor_macros"><a class="permalink" href="#Preprocessor_macros">Preprocessor
  macros</a></h2>
Preprocessor definitions are written in all-caps. Macros which are function-like
  may be lower-case provided they do not double-evaluate their arguments.
  Function-like macros that do double-evaluate their arguments should be in
  all-caps.
<p class="Pp"><i class="Em">Good</i></p>
<div class="Bd Pp Bd-indent">
<pre>
#define FOO 1
#define halt() abort()

// Does not double-evaluate _a and _b such that max(i++, j) is safe.
#define max(_a, _b) ({ \
    typeof(_a) a1 = (_a); \
    typeof(_b) b1 = (_b); \
    (a1 &lt; b1 ? b1 : a1); \
})

// Double-evaluates _a and _b, so MAX(i++, j) is not safe.
#define MAX(_a, _b) ((_a) &lt; (_b) ? (_b) : (_a))
</pre>
</div>
<p class="Pp"><i class="Em">Bad</i></p>
<div class="Bd Pp Bd-indent">
<pre>
#define kFoo 1

// Double-evaluates _a and _b.
#define max(_a, _b) ((_a) &lt; (_b) ? (_b) : (_a))
</pre>
</div>
<p class="Pp">Where possible, you should prefer inline functions to preprocessor
    macros, or split a macro into a preprocessor piece and an inline function
    piece.</p>
<p class="Pp"><i class="Em">Example</i></p>
<div class="Bd Pp Bd-indent">
<pre>
static inline void
_debug_uint64_impl(const char *name, uint64_t val)
{
    fprintf(stderr, &quot;%s = %llu\n&quot;, name, val);
}

#define debug_uint64(_v) do { \
	_debug_uint64_impl(#_v, _v); \
} while (0)
</pre>
</div>
<p class="Pp">In this example, the preprocessor is used to do something that
    only the preprocessor can do: stringify the input variable's name. But once
    that work is done, the actual logging of the value is done by an inline
    function. This keeps the code much more readable.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Preprocessor_macro_parameters_should_be_distinguished"><a class="permalink" href="#Preprocessor_macro_parameters_should_be_distinguished">Preprocessor
  macro parameters should be distinguished</a></h2>
Preprocessor macro expansion can run afoul of naming collisions with other
  variables that are in the same scope as the macro being expanded. To help
  avoid such collisions, parameters to preprocessor macros should have a prefix,
  suffix or both. Another good option is to use a <code class="Ic">_[A-Z]</code>
  prefix, since it is reserved by the C standard and will not collide with
  preprocessor evaluation.
<p class="Pp"><i class="Em">Example</i></p>
<div class="Bd Pp Bd-indent">
<pre>
#define foo2(_x_) ((_x_) * 2)
#define foo4(_x) ((_x) * 4)
#define foo8(_X) ((_X) * 8)
</pre>
</div>
</section>
<section class="Ss">
<h2 class="Ss" id="Preprocessor_macro_parameters_should_always_be_evaluated"><a class="permalink" href="#Preprocessor_macro_parameters_should_always_be_evaluated">Preprocessor
  macro parameters should always be evaluated</a></h2>
When passing a parameter to a preprocessor macro, it should always be referred
  to within parentheses to force evaluation. The exception is for parameters
  intended to be string literals.
<p class="Pp"><i class="Em">Good</i></p>
<div class="Bd Pp Bd-indent">
<pre>
#define add2(__x) ((__x) + 2)
#define println(__fmt, ...) printf(__fmt &quot;\n&quot;, ## __VA_ARGS__)
</pre>
</div>
<p class="Pp"><i class="Em">Bad</i></p>
<div class="Bd Pp Bd-indent">
<pre>
#define add2(__x) x + 2
</pre>
</div>
</section>
<section class="Ss">
<h2 class="Ss" id="Preprocessor_directives_always_start_at_column_0"><a class="permalink" href="#Preprocessor_directives_always_start_at_column_0">Preprocessor
  directives always start at column 0</a></h2>
Preprocessor directives do not have scope, and therefore they always start at
  column zero.
<p class="Pp"><i class="Em">Good</i></p>
<div class="Bd Pp Bd-indent">
<pre>
if (do_loop) {
	for (i = 0; i &lt; 10; i++) {
#if CONFIG_FOOBAR
		foobar(i);
#else
		foobaz(i);
#endif
	}
}
</pre>
</div>
<p class="Pp"><i class="Em">Bad</i></p>
<div class="Bd Pp Bd-indent">
<pre>
if (do_loop) {
	for (i = 0; i &lt; 10; i++) {
	#if CONFIG_FOOBAR
		foobar(i);
	#else
		foobaz(i);
	#endif
	}
}
</pre>
</div>
</section>
<section class="Ss">
<h2 class="Ss" id="Always_reference_string_length_directly"><a class="permalink" href="#Always_reference_string_length_directly">Always
  reference string length directly</a></h2>
Do not hard-code the size of a string. Use either <code class="Ic">sizeof(str) -
  1</code> or <code class="Ic">strlen(str)</code>. In the latter case,
  <a class="Xr">clang(1)</a> is smart enough to recognize when a constant string
  is being passed to <a class="Xr">strlen(3)</a> and replace the function call
  with the string's actual length.
<p class="Pp"><i class="Em">Good</i></p>
<div class="Bd Pp Bd-indent">
<pre>
char str[] = &quot;string&quot;;
frob_string(str, sizeof(str) - 1);
frob_string(str, strlen(str));
</pre>
</div>
<p class="Pp"><i class="Em">Bad</i></p>
<div class="Bd Pp Bd-indent">
<pre>
char str[] = &quot;string&quot;;
frob_string(str, 6);
</pre>
</div>
</section>
<section class="Ss">
<h2 class="Ss" id="Don't_pointlessly_validate_inputs"><a class="permalink" href="#Don't_pointlessly_validate_inputs">Don't
  pointlessly validate inputs</a></h2>
If you control all call sites for a function, then there is no point to
  validating the inputs to that function. If none of your call sites pass
  <code class="Ic">NULL</code>, to a pointer parameter, for example, then the a
  <code class="Ic">NULL</code> input indicates that there is state corruption in
  your address space. You may think that it's good to catch such corruption, but
  <code class="Ic">NULL</code> is just <i class="Em">one</i> possible invalid
  pointer value. What if the invalid input is <code class="Ic">0x1</code>? What
  if it is <code class="Ic">0x2</code>? Should you also check for those?
<p class="Pp">This kind of input checking complicates code. Because it indicates
    state corruption, the only sensible thing to do in that situation would be
    to abort. But the operating system has mechanisms in place to detect the
    reference of an invalid resource, such as virtual memory and use-after-free
    detection. There is no point to you duplicating these mechanisms.</p>
<p class="Pp">Of course, you should always validate inputs <i class="Em">when
    they come from untrusted external sources</i> (such as a file or IPC
    message), but if the inputs only ever comes from your program, you should
    trust them.</p>
<p class="Pp"><i class="Em">Good</i></p>
<div class="Bd Pp Bd-indent">
<pre>
static foo_t *
get_item(foo_t *arr, size_t idx)
{
	return &amp;arr[idx];
}

int
only_call_site(foo_t *f)
{
	foo_t *arr = calloc(10, sizeof(arr[0]));
	if (!arr) {
		return errno;
	}

	*f = get_item(arr, 0);
	return 0;
}
</pre>
</div>
<p class="Pp"><i class="Em">Bad</i></p>
<div class="Bd Pp Bd-indent">
<pre>
static foo_t *
get_item(foo_t *arr, size_t idx)
{
	if (!arr) {
		// No point to this check since we'll abort immediately below when we
		// try to dereference `arr`. The crash report will have more than enough
		// information to diagnose the NULL pointer dereference if it ever
		// happens.
		abort();
	}
	return &amp;arr[idx];
}

int
only_call_site(foo_t *f)
{
	foo_t *arr = calloc(10, sizeof(arr[0]));
	if (!arr) {
		return errno;
	}

	*f = get_item(arr, 0);
	return 0;
}
</pre>
</div>
</section>
<section class="Ss">
<h2 class="Ss" id="Abort_on_bad_API_inputs"><a class="permalink" href="#Abort_on_bad_API_inputs">Abort
  on bad API inputs</a></h2>
The C language provides precious few compile-time validation mechanisms, and so
  in many cases it is not possible to fully describe to the compiler the range
  of expected inputs for an API. So your API should validate input from its
  caller and abort on invalid input. Returning an error in such a case is
  pointless, since the caller probably isn't checking the return code anyway.
  The only sure way to get the programmer's attention is to abort the calling
  process with a helpful message. The <code class="Ic">os_crash</code> routine
  allows you to supply such a message that the crash reporter on Darwin will
  display in its crash report.
<p class="Pp"><i class="Em">Good</i></p>
<div class="Bd Pp Bd-indent">
<pre>
uint8_t
foo_a_bar(uint8_t number)
{
	if (number &gt; (UINT8_MAX / 2)) {
		os_crash(&quot;number given to foo_a_bar() too large&quot;);
	}
	return (number * 2);
}
</pre>
</div>
<p class="Pp"><i class="Em">Bad</i></p>
<div class="Bd Pp Bd-indent">
<pre>
int
foo_a_bar(uint8_t number, uint8_t *new_number)
{
	if (number &gt; (UINT8_MAX / 2)) {
		return EINVAL;
	}
	*new_number = (number * 2);
	return 0;
}
</pre>
</div>
</section>
<section class="Ss">
<h2 class="Ss" id="Don't_mingle_POSIX_return_codes_and_errors"><a class="permalink" href="#Don't_mingle_POSIX_return_codes_and_errors">Don't
  mingle POSIX return codes and errors</a></h2>
Some POSIX routines have return values that indicate whether you should check
  <code class="Ic">errno</code>, and others just return the error directly.
  While POSIX generally documents what does what pretty well, there are lots of
  SPIs scattered around the system that use both conventions and aren't
  documented at all, leaving you to spelunk through the implementation to find
  out what's what.
<p class="Pp">To avoid confusion, do not re-use the same variable for the return
    codes from these functions. If an API returns a code indicating that you
    should check <code class="Ic">errno</code>, name it
    <code class="Ic">ret</code> or similar. If it returns the error directly,
    name it <code class="Ic">error</code> or similar and make it of type
    <code class="Ic">errno_t</code>. This makes it very clear to the person
    reading the code that you did the work to find out how the API worked. By
    naming the variable you store the return value in appropriately, a reader of
    your code (possibly Future You) can immediately know what's going on.</p>
<p class="Pp">If you are making new API or SPI that returns an error code, make
    it return <code class="Ic">errno_t</code> and do not use the global
    <code class="Ic">errno</code> for communicating error information.</p>
<p class="Pp"><i class="Em">Good</i></p>
<div class="Bd Pp Bd-indent">
<pre>
#include &lt;sys/types.h&gt;

errno_t error = posix_spawn(NULL, &quot;ls&quot;, NULL, NULL, argv, envp);
switch (error) {
case 0:
    // Handle success.
    break;
case EACCES:
    // Handle &quot;permission denied&quot;.
    break;
}

int ret = reboot(RB_AUTOBOOT);
if (ret == -1) {
    switch (errno) {
    case EPERM:
        // Handle &quot;permission denied&quot;.
        break;
    case EBUSY:
        // Handle &quot;reboot already in progress&quot;.
        break;
    }
}
</pre>
</div>
<p class="Pp"><i class="Em">Bad</i></p>
<div class="Bd Pp Bd-indent">
<pre>
int ret = posix_spawn(NULL, &quot;ls&quot;, NULL, NULL, argv, envp);
switch (error) {
case 0:
    // Handle success.
    break;
case EACCES:
    // Handle &quot;permission denied&quot;.
    break;
}

int error = reboot(RB_AUTOBOOT);
if (error == -1) {
    switch (errno) {
    case EPERM:
        // Handle &quot;permission denied&quot;.
        break;
    case EBUSY:
        // Handle &quot;reboot already in progress&quot;.
        break;
    }
}
</pre>
</div>
</section>
<section class="Ss">
<h2 class="Ss" id="Avoid_complex__if__statements_and_return_distinct_error_codes"><a class="permalink" href="#Avoid_complex__if__statements_and_return_distinct_error_codes">Avoid
  complex `if` statements and return distinct error codes</a></h2>
Breaking up a single complex <code class="Ic">if</code> statement into multiple
  distinct checks is both more readable and makes it possible to be more
  granular about handling failure cases. It also leads to smaller diffs if one
  of those conditions turns out to require special handling.
<p class="Pp">Complex <code class="Ic">if</code> statements are often associated
    with input validation and just returning an error code (usually
    <code class="Ic">EINVAL</code>) if any input is invalid. While deciding
    which error to return in which case is more of an art than a science, that
    doesn't mean you should just give up and return a single error every time
    there isn't an immediately obvious fit to the case you've encountered.</p>
<p class="Pp">Ideally, every case where your routine may fail should be
    represented by a distinct error code, but this is often not practical.
    Still, you should attempt to distinguish each <i class="Em">likely</i>
    failure case with its own error code. The POSIX error space is fairly rich,
    and error descriptions are brief enough that they can be liberally
    interpreted. For example, <code class="Ic">ESRCH</code> can be used to apply
    to any situation where a resource could not be located, not just conditions
    where there is literally &quot;No such process&quot;.</p>
<p class="Pp">This isn't to say that you should never have compound conditions
    in an <code class="Ic">if</code> statement, but the groupings should almost
    always be small, and the grouped checks should be highly likely to require
    change as a group when change is needed.</p>
<p class="Pp"><i class="Em">Good</i></p>
<div class="Bd Pp Bd-indent">
<pre>
if (foo-&gt;f_int &gt; 10 || foo-&gt;f_int &lt; 5)
	return ERANGE;
}

if (!foo-&gt;f_uaddr) {
	return EFAULT;
}

if (foo-&gt;f_has_idx &amp;&amp; foo-&gt;f_idx &gt; 100) {
	return ERANGE;
}

if (foo-&gt;f_state != FS_INITIALIZED) {
	return EBUSY;
}
</pre>
</div>
<p class="Pp"><i class="Em">Bad</i></p>
<div class="Bd Pp Bd-indent">
<pre>
if (foo-&gt;f_int &gt; 10 || foo-&gt;f_int &lt; 5 || !foo-&gt;f_uaddr || (foo-&gt;f_has_idx &amp;&amp; foo-&gt;f_idx &gt; 100) ||
		foo-&gt;f_state != FS_INITIALIZED) {
	return EINVAL;
}
</pre>
</div>
<p class="Pp">See <a class="Xr">intro(2)</a>,
    <code class="Ic">&lt;sys/errno.h&gt;</code>, and
    <code class="Ic">&lt;os/error.h&gt;</code> for the error codes supported on
    Darwin.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Don't_NULL_check_when_calling__free(3)_"><a class="permalink" href="#Don't_NULL_check_when_calling__free(3)_">Don't
  NULL-check when calling `free(3)`</a></h2>
<code class="Ic">NULL</code> is valid input to <a class="Xr">free(3)</a>. It's
  part of the API contract. Armed with this knowledge, you can do things like
  avoid conditional memory calls, which are always weird.
<p class="Pp"><i class="Em">Good</i></p>
<div class="Bd Pp Bd-indent">
<pre>
char buff[1024];
char *ptr = buff;
char *what2free = NULL;

if (condition) {
    ptr = malloc(8);
    what2free = ptr;
}

free(what2free);
</pre>
</div>
<p class="Pp"><i class="Em">Bad</i></p>
<div class="Bd Pp Bd-indent">
<pre>
char buff[1024];
char *ptr = buff;
bool did_malloc = false;

if (condition) {
    ptr = malloc(8);
    did_malloc = true;
}

if (did_malloc) {
    free(ptr);
}
</pre>
</div>
</section>
<section class="Ss">
<h2 class="Ss" id="Distinguish_exported_and_non_exported_symbols"><a class="permalink" href="#Distinguish_exported_and_non_exported_symbols">Distinguish
  exported and non-exported symbols</a></h2>
Any non-exported symbols should be prefixed with a <code class="Ic">_</code>.
  Thus any <code class="Ic">static</code> functions, project-local interfaces,
  etc. should have this prefix. Exported symbols (API or SPI) should
  <i class="Em">not</i> have such a prefix.
<p class="Pp"><i class="Em">Good</i></p>
<div class="Bd Pp Bd-indent">
<pre>
static const char *_thing = &quot;thing&quot;;
static void _foo(void);

void
_project_local_interface(void);
</pre>
</div>
<i class="Em">Bad</i>
<div class="Bd Pp Bd-indent">
<pre>
static const char *thing = &quot;thing&quot;;
static void foo(void);

void
project_local_interface(void);
</pre>
</div>
<p class="Pp">Global variables should have a sensible prefix, preferably related
    to the project name -- e.g. globals in the <a class="Xr">libxpc(3)</a>
    project are prefixed with <code class="Ic">xpc_</code>.</p>
<p class="Pp">You may also consider declaring a global structure which contains
    all of your project's shared, unexported global state. This makes it very
    clear when code is referencing that state. Also, if your project is a
    library at the libSystem layer, this is required if you are ever to adopt
    <a class="Xr">os_alloc_once(3)</a>.</p>
<p class="Pp"><i class="Em">Example</i></p>
<div class="Bd Pp Bd-indent">
<pre>
typedef struct _foobar_globals {
	uint64_t fg_global_int;
	char *fg_global_string;
} foobar_globals_t;

foobar_globals_t _g;
foobar_globals_t *g = &amp;_g;
</pre>
</div>
</section>
<section class="Ss">
<h2 class="Ss" id="Distinguish_SPIs_meant_for_one_caller"><a class="permalink" href="#Distinguish_SPIs_meant_for_one_caller">Distinguish
  SPIs meant for one caller</a></h2>
Sometimes projects must create bespoke SPIs for one particular caller, and these
  SPIs are not considered suitable for general use. Append a suffix to these
  SPIs to indicate their bespokeness and the intended caller with
  <code class="Ic">_4caller</code>. For example, if you add an SPI specifically
  for IOKit, your suffix would likely be <code class="Ic">_4IOKit</code>.
</section>
<section class="Ss">
<h2 class="Ss" id="Use___if__instead_of___ifdef__where_appropriate"><a class="permalink" href="#Use___if__instead_of___ifdef__where_appropriate">Use
  `#if` instead of `#ifdef` where appropriate</a></h2>
<code class="Ic">#ifdef</code> is to check if a token is <i class="Em">defined
  at all to anything.</i> <code class="Ic">#if</code> is to check the token's
  value. The C standard specifies that when a token is undefined,
  <code class="Ic">#if</code> will evaluate it as <code class="Ic">0</code>.
  When checking for features, it's almost always more appropriate to use
  <code class="Ic">#if</code> since the lack of a feature could still be
  communicated by setting the token's value to <code class="Ic">0</code>, which
  would pass the <code class="Ic">#ifdef</code> check.
</section>
<section class="Ss">
<h2 class="Ss" id="Use_Function_Attributes_from___os/base.h__"><a class="permalink" href="#Use_Function_Attributes_from___os/base.h__">Use
  Function Attributes from `&lt;os/base.h&gt;`</a></h2>
If you're on Darwin, <code class="Ic">libplatform</code> defines a lot of nice
  macros for compiler attributes. Use them to decorate your functions. This
  gives the compiler lots more information so it can do fancy optimizations.
  Things like <code class="Ic">OS_NONNULL</code> let the compiler know that a
  parameter should never be <code class="Ic">NULL</code>.
  <code class="Ic">OS_WARN_RESULT</code> is great for enforcing that a caller
  always check the return value of a function.
<p class="Pp"><code class="Ic">OS_MALLOC</code> lets the compiler know that the
    function returns a heap allocation, and
    <code class="Ic">OS_OBJECT_RETURNS_RETAINED</code> lets ARC know that the
    function returns an object with a reference that the caller is responsible
    for releasing.</p>
<p class="Pp">You can avoid having to decorate all your pointer parameters by
    using <code class="Ic">OS_ASSUME_NONNULL_BEGIN</code> and
    <code class="Ic">OS_ASSUME_NONNULL_END</code> and specifically annotating
    variables which <i class="Em">can</i> be <code class="Ic">NULL</code> with
    the <code class="Ic">_Nullable</code> keyword. Either approach is
    acceptable.</p>
<p class="Pp">Generally, use these attributes on functions which will have
    callers who cannot view the implementation. Putting many of these attributes
    on (for example) an inline function is harmless, but the compiler can reason
    about things like <code class="Ic">OS_NONNULL</code> and infer it when it
    can view the implementation at all call sites.</p>
<p class="Pp">So as a rule of thumb, if it's in a header, decorate it
    appropriately. These attributes can also serve as nice implicit
    documentation around API and SPI. For example, if you have a decoration of
    <code class="Ic">OS_NONNULL1</code>, you don't have to spell out in the
    HeaderDoc that you can't pass <code class="Ic">NULL</code> for that
    parameter; it'll be right there in the declaration, and the compiler will
    catch attempts to do so.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Distinguish_C_function_definitions_from_declarations"><a class="permalink" href="#Distinguish_C_function_definitions_from_declarations">Distinguish
  C function definitions from declarations</a></h2>
In C, make the definition of a function findable and distinguishable from its
  declaration (if any) through regular expressions. This way, you can find the
  implementation of <code class="Ic">foo</code> by doing a regex search for
  <code class="Ic">^foo</code>, and you won't get the declaration as a result.
<p class="Pp"><i class="Em">Good</i></p>
<div class="Bd Pp Bd-indent">
<pre>
static int foo(int bar);

int
foo(int bar)
{
    return bar;
}
</pre>
</div>
<p class="Pp"><i class="Em">Bad</i></p>
<div class="Bd Pp Bd-indent">
<pre>
static int foo(int bar);

int foo(int bar)
{
    return bar;
}
</pre>
</div>
<p class="Pp">This has the additional benefit of allowing you to change the
    name/parameter list of a function independently of the return type. A diff
    of either will not be confused with the rest of the function signature.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Use_HeaderDoc_for_API_declarations"><a class="permalink" href="#Use_HeaderDoc_for_API_declarations">Use
  HeaderDoc for API declarations</a></h2>
Make them look nice. Include the appropriate decorations (including an explicit
  export attribute such as <code class="Ic">OS_EXPORT</code> so it's very, very
  clear that it's intended to be API), availability attributes, and HeaderDoc.
  Put this stuff before the function.
<p class="Pp"><i class="Em">Example</i></p>
<div class="Bd Pp Bd-indent">
<pre>
/*!
 * @function foo
 * Returns `bar` and ignores another parameter.
 *
 * @param bar
 * The value to return.
 *
 * @param baz
 * The value to ignore.
 *
 * @result
 * The value of `bar`. This routine cannot fail.
 */
__API_AVAILABLE(macos(10.14), ios(12.0), tvos(12.0), watchos(5.0))
OS_EXPORT OS_WARN_RESULT OS_NONNULL2
int
foo(int bar, char *baz);
</pre>
</div>
</section>
<section class="Ss">
<h2 class="Ss" id="Comments"><a class="permalink" href="#Comments">Comments</a></h2>
In general, use C++/C99-style comments. But there may be good reasons to use the
  classic C-style comments, such as for HeaderDoc, which requires them, e.g.
<div class="Bd Pp Bd-indent">
<pre>
/*!
 * Documentation
 */
</pre>
</div>
<p class="Pp">Long, top-level comments may also use classic C-style
  comments.</p>
<p class="Pp">C++/C99-style comments may directly follow code on the same line
    only if they are extremely brief. Otherwise, in general, comments and code
    should not share a line.</p>
<p class="Pp">Also, do not get cute with <code class="Ic">/* */</code> comments
    and embed them within code.</p>
<p class="Pp"><i class="Em">Good</i></p>
<div class="Bd Pp Bd-indent">
<pre>
// Comment on what the loop does.
for (i = 0; i &lt; cnt; i++) {
    // some code...
}

/*
 * A top-level or very long comment.
 */

int ret = esoteric_spi(); // returns -1 on failure, does not set errno
</pre>
</div>
<p class="Pp"><i class="Em">Bad</i></p>
<div class="Bd Pp Bd-indent">
<pre>
//Comment

int ret = esoteric_spi(); // This SPI returns -1 on failure but does not set
    // errno, so here is a comment explaining that that really should be above
    // the line of code rather than immediately following it.

foo(arg1, /* first argument */, arg2 /* second argument */);
</pre>
</div>
</section>
<section class="Ss">
<h2 class="Ss" id="_case__and__switch__are_indented_at_the_same_level"><a class="permalink" href="#_case__and__switch__are_indented_at_the_same_level">`case`
  and `switch` are indented at the same level</a></h2>
<code class="Ic">case</code> and <code class="Ic">switch</code> belong at the
  same column indent because indentation indicates scope, and due to case
  fall-through, all cases are in the same scope -- one lower than the previous.
  (Unless you scope them explicitly with braces, but you should avoid doing that
  if at all possible.)
<p class="Pp"><i class="Em">Good</i></p>
<div class="Bd Pp Bd-indent">
<pre>
switch (thing) {
case THING1:
    exit(0);
    break;
case THING2:
    exit(1);
    break;
default:
    __builtin_unreachable();
}
</pre>
</div>
<p class="Pp"><i class="Em">Bad</i></p>
<div class="Bd Pp Bd-indent">
<pre>
switch (thing) {
case THING1: {
    exit(0);
    break;
}
case THING2: {
    exit(1);
    break;
}
default:
    __builtin_unreachable();
}

switch (thing) {
    case THING1:
        exit(0);
        break;
    case THING2:
        exit(1);
        break;
    default: {
        __builtin_unreachable();
    }
}
</pre>
</div>
</section>
<section class="Ss">
<h2 class="Ss" id="Use_typed__enum_s"><a class="permalink" href="#Use_typed__enum_s">Use
  typed `enum`s</a></h2>
If you're declaring an <code class="Ic">enum</code>, you should
  <code class="Ic">typedef</code> it so the compiler can reason about valid
  values and know the width of the <code class="Ic">enum</code> type if
  possible. The <code class="Ic">OS_ENUM</code> macro provides the correct
  behavior for C, C++, and Objective-C.
</section>
<section class="Ss">
<h2 class="Ss" id="Initialize_all_variables_and_fail_closed"><a class="permalink" href="#Initialize_all_variables_and_fail_closed">Initialize
  all variables and fail closed</a></h2>
If you pre-declare a variable before using it, initialize it to a sane value. If
  this value is something like the return value of the function, initialize it
  to a value which indicates failure of the operation. You should
  <i class="Em">always</i> do this even if there are no code paths which fail to
  initialize the variable later. It's just good practice, and it gives the
  person reading your code an indication of what ranges of values the variable
  is expected to hold.
<p class="Pp"><i class="Em">Good</i></p>
<div class="Bd Pp Bd-indent">
<pre>
int result = -1;

if (success) {
    result = 0;
}
</pre>
</div>
<p class="Pp"><i class="Em">Bad</i></p>
<div class="Bd Pp Bd-indent">
<pre>
int result;

if (success) {
    result = 0;
}
</pre>
</div>
<p class="Pp">Any error variable should always be initialized to a non-success
    condition. In general, consider success as something that your code must
    <i class="Em">explicitly declare</i> and that the absence of such a
    declaration indicates failure.</p>
<p class="Pp"><i class="Em">Good</i></p>
<div class="Bd Pp Bd-indent">
<pre>
int error = -1;

if (is_root()) {
    error = 0;
} else {
    error = EPERM;
}
</pre>
</div>
<p class="Pp"><i class="Em">Bad</i></p>
<div class="Bd Pp Bd-indent">
<pre>
int error = 0;

if (!is_root()) {
    error = EPERM;
}
</pre>
</div>
<p class="Pp">Note that you may omit an initializer for a complex
    <code class="Ic">struct</code> type (such as the <a class="Xr">stat(2)</a>
    <code class="Ic">struct</code>) but then it is incumbent upon you to ensure
    that that variable is not used uninitialized except to populate it. For many
    <code class="Ic">struct</code> types, you can initialize them with
    <code class="Ic">{0}</code>. This will not work for structures with nested
    structures though. For those you can use <a class="Xr">bzero(3)</a> or
    similar.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Using__goto__is_fine"><a class="permalink" href="#Using__goto__is_fine">Using
  `goto` is fine</a></h2>
<code class="Ic">goto</code> has gotten a bad rap, but it's probably the best
  way in C to do lots of sequential error handling. You don't
  <i class="Em">have</i> to use <code class="Ic">goto</code> if you don't want
  to, but if you do, just keep a a couple things in mind.
<p class="Pp"></p>
<ul class="Bl-bullet Bd-indent Bl-compact">
  <li>Compile with <code class="Ic">-Wsometimes-uninitialized</code>. With this
      warning, <a class="Xr">clang(1)</a> will catch cases where a variable may
      be used uninitialized because a <code class="Ic">goto</code> skipped the
      initialization.</li>
  <li>Never use <code class="Ic">goto</code> as a looping construct. The C
      language has a few different control statements for looping and iteration.
      Use one of those; it's not the 70's anymore.</li>
</ul>
<p class="Pp">These guidelines make it simple to use
    <code class="Ic">goto</code> effectively while avoiding the most common
    pitfalls.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Avoid_magic_Booleans"><a class="permalink" href="#Avoid_magic_Booleans">Avoid
  magic Booleans</a></h2>
Sometimes you have to pass a parameter to a function to trigger some sort of
  behavior. Avoid using a magic Boolean for these cases. Instead, use an
  invariant that describes the behavior you are triggering.
<p class="Pp"><i class="Em">Good</i></p>
<div class="Bd Pp Bd-indent">
<pre>
replace_spaces(string, REPLACE_TABS_TOO);
replace_spaces(string, REPLACE_ONLY_SPACES);
</pre>
</div>
<p class="Pp"><i class="Em">Bad</i></p>
<div class="Bd Pp Bd-indent">
<pre>
replace_spaces(string, true);
replace_spaces(string, false);
</pre>
</div>
<p class="Pp">If you find yourself creating many such Boolean values for
    function parameters, you should seriously considering defining a set of
    flags and passing that as one parameter instead.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Spaces_around_binary_operators"><a class="permalink" href="#Spaces_around_binary_operators">Spaces
  around binary operators</a></h2>
In general, avoid code that looks crunched together, especially around
  operators. Specifically:
<ul class="Bl-bullet Bd-indent Bl-compact">
  <li>Unary operators should <i class="Em">not</i> have spaces around them.</li>
  <li>Binary operators <i class="Em">should</i> have spaces around them.</li>
  <li>The ternary operator <i class="Em">should</i> have spacing around it.</li>
</ul>
<p class="Pp"><i class="Em">Good</i></p>
<div class="Bd Pp Bd-indent">
<pre>
i++;
j = i + k;
k += condition ? i : j;
</pre>
</div>
<p class="Pp"><i class="Em">Bad</i></p>
<div class="Bd Pp Bd-indent">
<pre>
i ++;
j=i+k
k+=condition?i:j;
</pre>
</div>
</section>
<section class="Ss">
<h2 class="Ss" id="Reserve_the_ternary_operator_for_trivial_cases"><a class="permalink" href="#Reserve_the_ternary_operator_for_trivial_cases">Reserve
  the ternary operator for trivial cases</a></h2>
Don't use the ternary operator to choose between complex or long expressions.
  Reserve it for very trivial cases that are highly unlikely to change. In
  general if you've found yourself putting the expressions in your usage of
  ternary operator on multiple lines, you should just be using an
  <code class="Ic">if</code> statement.
<p class="Pp"><i class="Em">Good</i></p>
<div class="Bd Pp Bd-indent">
<pre>
i += condition ? j : k;
</pre>
</div>
<p class="Pp"><i class="Em">Bad</i></p>
<div class="Bd Pp Bd-indent">
<pre>
i += (i &lt; j &amp;&amp; j &gt; k || i == j) ? foo(bar, baz, 0, NULL) : frob(bar, 0, NULL, baz);
</pre>
</div>
</section>
<section class="Ss">
<h2 class="Ss" id="Spaces_around_parentheses"><a class="permalink" href="#Spaces_around_parentheses">Spaces
  around parentheses</a></h2>
<ul class="Bl-bullet Bd-indent Bl-compact">
  <li>Put a space between the control statement and the parenthesis indicating
      its condition.</li>
  <li>Do <i class="Em">not</i> put a space between the end of a function name
      and the parenthesis indicating its argument list.</li>
  <li>Do <i class="Em">not</i> put spaces between any parenthesis and its
      following content.</li>
</ul>
<p class="Pp"><i class="Em">Good</i></p>
<div class="Bd Pp Bd-indent">
<pre>
if (condition) {
    do_thing();
}
</pre>
</div>
<p class="Pp"><i class="Em">Bad</i></p>
<div class="Bd Pp Bd-indent">
<pre>
if(condition) {
    do_thing ();
}

if ( condition ) {
    do_thing ( argument );
}
</pre>
</div>
<p class="Pp"><i class="Em">Worse</i></p>
<div class="Bd Pp Bd-indent">
<pre>
while( condition) {
    do_thing( );
}
</pre>
</div>
</section>
<section class="Ss">
<h2 class="Ss" id="Braces_and_statements"><a class="permalink" href="#Braces_and_statements">Braces
  and statements</a></h2>
Always, always, always use braces for your control statements. Lack of braces
  can and has led to serious security issues that were missed during code
  review, and putting the braces there from the start means that adding new
  statements to that clause does not require you to also add the braces.
<p class="Pp">The clause should be indented on the next line with no blank lines
    in between.</p>
<p class="Pp"><i class="Em">Good</i></p>
<div class="Bd Pp Bd-indent">
<pre>
if (condition) {
    do_thing();
}

while (condition) {
    do_thing();
}
</pre>
</div>
<p class="Pp"><i class="Em">Bad</i></p>
<div class="Bd Pp Bd-indent">
<pre>
if (condition) do_thing();

if (condition)
    do_thing();

while (condition) do_thing();

while (condition) {

    do_thing();
}
</pre>
</div>
<p class="Pp">Even trivial uses of braceless <code class="Ic">if</code>
    statements are problematic. Consider the following:</p>
<p class="Pp"><i class="Em">Bad</i></p>
<div class="Bd Pp Bd-indent">
<pre>
if (error) i++,
i++;
</pre>
</div>
<p class="Pp">This is admittedly contrived, but it would be likely to escape
    code review because it's very easy to miss that the first line ends with a ,
    rather than a ;. Braces in <code class="Ic">if</code> statements are
    sensitive enough to security that the best policy is to simply always use
    them, without exception.</p>
<p class="Pp">Specific rules for braces:</p>
<ul class="Bl-bullet Bd-indent Bl-compact">
  <li><a class="permalink" href="#else"><code class="Ic" id="else">else</code></a>
      goes between two braces on the same line.</li>
  <li>The brace which indicates the expression associated with a control flow
      statement goes on the same line as that statement or the same line as the
      last continuation line of the statement.</li>
  <li>The brace which begins the definition of a <code class="Ic">struct</code>,
      <code class="Ic">union</code>, <code class="Ic">enum</code>, etc. goes on
      the same line as the declaration.</li>
  <li>The brace concluding the expression associated with a control flow
      statement is aligned with the same column as that control flow
    statement.</li>
  <li>The opening brace of a function definition goes on its own line and is
      immediately followed by a new line.</li>
  <li>Control statements with empty bodies should have empty braces.</li>
</ul>
<p class="Pp"><i class="Em">Good</i></p>
<div class="Bd Pp Bd-indent">
<pre>
if (condition) {
    do_thing();
} else {
    do_other_thing();
}

void
function(void)
{
    return;
}

struct my_struct {
    uint32_t thing;
};

for (cur; cur; cur = cur-&gt;next) { }
</pre>
</div>
<p class="Pp"><i class="Em">Bad</i></p>
<div class="Bd Pp Bd-indent">
<pre>
if (condition)
{
    do_thing();
}
else
{
    do_other_thing();
}

if (condition)
{
    do_thing();
}
else
    do_other_thing();

void
function(void) {
    return;
}

struct my_struct
{
    uint32_t thing;
};

for (cur; cur; cur = cur-&gt;next)
</pre>
</div>
<p class="Pp"><i class="Em">Worse</i></p>
<div class="Bd Pp Bd-indent">
<pre>
if (condition)
    {
    do_thing();
    }

void
function(void)
{ return;
}
</pre>
</div>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<a class="Xr">style(9)</a>, <a class="Xr">intro(2)</a>,
  <a class="Xr">errno(3)</a>, <a class="Xr">types(5)</a>
</section>
<section class="Sh">
<h1 class="Sh" id="HISTORY"><a class="permalink" href="#HISTORY">HISTORY</a></h1>
This style was largely derived from the style that evolved through the
  <a class="Xr">launchd(8)</a>, <a class="Xr">libdispatch(3)</a>, and
  <a class="Xr">libxpc(3)</a> projects.
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">12 January, 2018</td>
    <td class="foot-os">Darwin</td>
  </tr>
</table>
</body>
</html>
