<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>Parse::Eyapp::datagenerationtut(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Parse::Eyapp::datagenerationtut(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Parse::Eyapp::datagenerationtut(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
Parse::Eyapp::datagenerationtut - Tutorial on Using Parse::Eyapp as a Data
  Generator for Testing
</section>
<section class="Sh">
<h1 class="Sh" id="INTRODUCTION"><a class="permalink" href="#INTRODUCTION">INTRODUCTION</a></h1>
The examples for this tutorial can be found in the directory
  <span class="Li">&quot;examples/generator&quot;</span> in the distribution of
  <span class="Li">&quot;Parse::Eyapp&quot;</span>.
<p class="Pp">To understand the code you will need some familiarity with
    Test::LectroTest::Generator, however, we will make an attempt to introduce
    the basics of Test::LectroTest::Generator needed.</p>
<p class="Pp">While parsing is the process of determining the membership of a
    string to a language, generation is the reverse problem. Using a context
    free grammar it is possible to generate strings belonging to the language
    described by that grammar.</p>
<p class="Pp">Context free grammars can be used to generate tests. The
    programmer designs a grammar that defines a set of inputs that will be able
    to find some set of bugs.</p>
<p class="Pp">This tutorial shows how to use Parse::Eyapp to generate phrases
    belonging to the language defined by a given grammar. We will generate
    inputs to test a simple calculator.</p>
<section class="Ss">
<h2 class="Ss" id="Compiling_and_Running_the_Example"><a class="permalink" href="#Compiling_and_Running_the_Example">Compiling
  and Running the Example</a></h2>
The grammar describing the language is in the file
  <span class="Li">&quot;Generator.eyp&quot;</span>. Calling eyapp with option
  <span class="Li">&quot;-c&quot;</span> will show the contents of the file
  without the semantic actions:
<p class="Pp"><span class="Li"></span></p>
<pre>
  Parse-Eyapp/examples/generator$ eyapp -c Generator.eyp
  # file: Generator.eyp
  # compile with: eyapp -b '' Generator.eyp
  # then run: ./Generator.pm
  %strict
  %token NUM VARDEF VAR
  %right '='
  %left '-' '+'
  %left '*' '/'
  %left NEG
  %right '^'

  %%

  stmts:
        stmt
      | stmts ';'  stmt
  ;
  stmt:
        VARDEF '=' exp
  ;
  exp:
        NUM
      | VAR
      | exp '+' exp
      | exp '-' exp
      | exp '*' exp
      | exp '/' exp
      | '-'  exp %prec NEG
      | exp '^' exp
      | '('  exp ')'
  ;

  %%
</pre>
<p class="Pp">This grammar defines a language of sequences of semicolon
    separated assignments. The right hand side of an assignment can be any valid
    arithmetic expression including numbers and variables.</p>
<p class="Pp">First we compile the grammar with option <span class="Li">&quot;-b
    ''&quot;</span> to produce a <i>modulino</i>:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  Parse-Eyapp/examples/generator$ eyapp -b '' Generator.eyp
</pre>
<p class="Pp">Now, the module has execution permits and its first line contains
    the <span class="Li">&quot;#!&quot;</span> header:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  Parse-Eyapp/examples/generator$ ls -ltr | tail -1
  -rwxr-xr-x 1 lusasoft lusasoft 7844 2009-01-12 08:30 Generator.pm
  Parse-Eyapp/examples/generator$ head -1 Generator.pm
  #!/usr/bin/perl
</pre>
<p class="Pp">The use of option <span class="Li">&quot;-b ''&quot;</span>
    combined with the fact that we have added these lines</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    67  unless (caller) {
    68    __PACKAGE__-&gt;main(@ARGV);
    69  }
</pre>
<p class="Pp">at the end of the grammar file
    <span class="Li">&quot;Generator.eyp&quot;</span> provide the generated file
    with a dual nature: it is a module and an executable at the same time. This
    is what is know as a modulino (term coined by Brian d Foy).</p>
<p class="Pp">Here follows the results of several executions. Each run produces
    a set of assignments. The first output line reports the result of the
    randomly generated program.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  Parse-Eyapp/examples/generator$ ./Generator.pm
  # result: -3
  SC=-3

  # result: error. Division by zero.
  M=(-4/6+4)+9+2*8*9+4;
  XQ=8/3;
  EI=XQ*2/0/0;
  BL=5+EI+4/5/XQ
</pre>
<p class="Pp">As you can see in the former run, only variables that were defined
    in previous assignments are used in later assignments. However, the
    generated source may produce run-time errors and exceptions (which is good
    thing when testing a calculator).</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  Parse-Eyapp/examples/generator$ ./Generator.pm

  # result: 6
  CF=(6)

  Parse-Eyapp/examples/generator$ ./Generator.pm

  # result: -710.2
  I=(3*-8+7/5);
  R=2+8*I*4+5*2+I/I

  Parse-Eyapp/examples/generator$ ./Generator.pm

  # result: Calculator syntax differs from Perl... 
  RY=2--2+(3+6)+(7*7*4^1+2*0/8*5/3)
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="GENERATING_PHRASES_FROM_A_CONTEXT_FREE_GRAMMAR"><a class="permalink" href="#GENERATING_PHRASES_FROM_A_CONTEXT_FREE_GRAMMAR">GENERATING
  PHRASES FROM A CONTEXT FREE GRAMMAR</a></h1>
<section class="Ss">
<h2 class="Ss" id="Using__YYExpect__and_Test::LectroTest::Generator_to_generate_tokens"><a class="permalink" href="#Using__YYExpect__and_Test::LectroTest::Generator_to_generate_tokens">Using
  &quot;YYExpect&quot; and Test::LectroTest::Generator to generate
  tokens</a></h2>
The basic idea of using Parse::Eyapp to generate phrases for the language
  defined by a given context free grammar is simple: <i>change the lexer by a
  token generator</i>. Instead of reading from some input, randomly generate one
  of the <i>valid tokens</i>.
<p class="Pp">We can use the method <span class="Li">&quot;YYExpect&quot;</span>
    to know what tokens are valid. For versions 1.137 and later of Parse::Eyapp,
    the method <span class="Li">&quot;YYExpect&quot;</span> returns the set of
    valid tokens at the time it is called. For previous versions (and this is
    also true for Parse::Yapp), <span class="Li">&quot;YYExpect&quot;</span>
    only returns a subset of the whole set of valid tokens.</p>
<p class="Pp">In this example, the token generator has been isolated in the sub
    <span class="Li">&quot;gen_lexer&quot;</span> in the file
    <span class="Li">&quot;GenSupport.pm&quot;</span>:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    47  sub gen_lexer {
    48    my $parser = shift;
    49
    50    my $token = $parser-&gt;generate_token;
    51    my $attr = $parser-&gt;generate_attribute($token);
    52    #$attr = $WHITESPACES-&gt;generate.$attr;
    53
    54    return ($token, $attr);
    55  }
</pre>
<p class="Pp">The token and its attribute are generated in lines 50 and 51. The
    methods <span class="Li">&quot;generate_token&quot;</span> and
    <span class="Li">&quot;generate_attribute&quot;</span> are also in the
    module <span class="Li">&quot;GenSupport.pm&quot;</span>. They are methods
    of the parser object since the grammar
    <span class="Li">&quot;Generator.eyp&quot;</span> not only uses but inherits
    this module. See line 3 of
    <span class="Li">&quot;Generator.eyp&quot;</span>:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  Parse-Eyapp/examples/generator$ sed -ne '19,24p' Generator.eyp | cat -n
     1  %{
     2  use base q{Parse::Eyapp::TokenGen};
     3  use base q{GenSupport};
     4  %}
     5
     6  %%
</pre>
<p class="Pp">The method <span class="Li">&quot;generate_token&quot;</span>
    obtains the set of valid tokens using
    <span class="Li">&quot;YYExpect&quot;</span> (line 29). Then uses the
    <span class="Li">&quot;Frequency&quot;</span> function in
    Test::LectroTest::Generator to produce a
    <span class="Li">&quot;Test::LectroTest::Generator&quot;</span> object (line
    31). The method <span class="Li">&quot;generate&quot;</span> of such object
    is used to generate the actual token (line 33).</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    26  sub generate_token {
    27    my $parser = shift;
    28
    29    my @token = $parser-&gt;YYExpect;
    30
    31    my $tokengen = Frequency( map { [$parser-&gt;token_weight($_), Unit($_)] } @token);
    32
    33    return $tokengen-&gt;generate;
    34  }
</pre>
<p class="Pp">The Parse::Eyapp::TokenGen method
    <span class="Li">&quot;token_weight&quot;</span> returns the weight
    associated with a token, assuming it was previously set using one of the
    Parse::Eyapp::TokenGen methods like
    <span class="Li">&quot;set_tokenweightsandgenerators&quot;</span> or
    <span class="Li">&quot;set_tokenweights&quot;</span>. See the code of method
    <span class="Li">&quot;main&quot;</span> in
    <span class="Li">&quot;GenSupport.pm&quot;</span>:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  examples/generator$ sed -ne '98,/^ *)/p' GenSupport.pm | cat -n
     1    my $parser = $package-&gt;new();
     2
     3    $parser-&gt;set_tokenweightsandgenerators(
     4      NUM =&gt; [ 2, Int(range=&gt;[0, 9], sized=&gt;0)],
     5      VAR =&gt; [
     6                0,  # At the beginning, no variables are defined
     7                Gen {
     8                  return  Elements(keys %st)-&gt;generate if keys %st;
     9                  return Int(range=&gt;[0, 9], sized=&gt;0)-&gt;generate;
    10                },
    11              ],
    12      VARDEF =&gt; [
    13                  2,
    14                  String( length=&gt;[1,2], charset=&gt;&quot;A-NP-Z&quot;, size =&gt; 100 )
    15                ],
    16      '=' =&gt; 2, '-' =&gt; 1, '+' =&gt; 2,
    17      '*' =&gt; 4, '/' =&gt; 2, '^' =&gt; 0.5,
    18      ';' =&gt; 1, '(' =&gt; 1, ')' =&gt; 2,
    19      ''  =&gt; 2, 'error' =&gt; 0,
    20    );
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="A_Brief_Introduction_to_Test::LectroTest::Generator"><a class="permalink" href="#A_Brief_Introduction_to_Test::LectroTest::Generator">A
  Brief Introduction to Test::LectroTest::Generator</a></h2>
The module <span class="Li">&quot;GenSupport.pm&quot;</span> uses
  Test::LectroTest::Generator to build generators for the required tokens. Thus
  the call to
<p class="Pp"><span class="Li"></span></p>
<pre>
                   Int(range=&gt;[0, 9], sized=&gt;0)
</pre>
<p class="Pp">builds a Test::LectroTest::Generator object that produces integers
    in the range [0,9]. Such objects have a method
    <span class="Li">&quot;generate&quot;</span> that produces the actual item.
    The following debugger session illustrates the way to use
    Test::LectroTest::Generator:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  pl@europa:~/LEyapp$ perl -wde 0
  main::(-e:1):   0
    DB&lt;1&gt; use Test::LectroTest::Generator qw{:all}
    DB&lt;2&gt; $i = Int(range=&gt;[0, 9], sized=&gt;0)
    DB&lt;3&gt; p $i-&gt;generate
  6
    DB&lt;4&gt; p $i-&gt;generate
  9
</pre>
<p class="Pp">The <span class="Li">&quot;String&quot;</span> method builds a
    Test::LectroTest::Generator object that produces strings:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    DB&lt;5&gt; $v = String( length=&gt;[1,2], charset=&gt;&quot;A-NP-Z&quot;, size =&gt; 100 )
    DB&lt;6&gt; p $v-&gt;generate
  HM
    DB&lt;7&gt; p $v-&gt;generate
  Y
    DB&lt;8&gt; p $v-&gt;generate
  KE
</pre>
<p class="Pp">The <span class="Li">&quot;Elements&quot;</span> method builds a
    Test::LectroTest::Generator object that produces one of a given list of
    elements:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    DB&lt;9&gt; @a = map { $v-&gt;generate } 1..10
    DB&lt;10&gt; x @a
  0  'UC'
  1  'P'
  2  'IF'
  3  'EJ'
  4  'H'
  5  'VC'
  6  'CF'
  7  'K'
  8  'T'
  9  'IG'
    DB&lt;11&gt; $x = Elements(@a)
    DB&lt;12&gt; p $x-&gt;generate
  P
    DB&lt;13&gt; p $x-&gt;generate
  P
    DB&lt;14&gt; p $x-&gt;generate
  EJ
    DB&lt;15&gt; p $x-&gt;generate
  VC
</pre>
<p class="Pp">Even more interesting for our purpose is the
    <span class="Li">&quot;Frequency&quot;</span> method, which produces one of
    a given list of elements with a given probability distribution.</p>
<p class="Pp">The following example illustrates its use. First we build a weight
    list where the odd elements have weight 2 and the even elements have weight
    1:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  DB&lt;16&gt; @w = map { $_ % 2 ? 2 : 1 } 0..9
  DB&lt;21&gt; @w{@a} = @w
  DB&lt;24&gt;  x \%w
    0  HASH(0xd3cc80)
       'CF' =&gt; 1
       'EJ' =&gt; 2
       'H' =&gt; 1
       'IF' =&gt; 1
       'IG' =&gt; 2
       'K' =&gt; 2
       'P' =&gt; 2
       'T' =&gt; 1
       'UC' =&gt; 1
       'VC' =&gt; 2
</pre>
<p class="Pp">We now use <span class="Li">&quot;Frequency&quot;</span> to build
    a Test::LectroTest::Generator object that produces one of the given list of
    elements <span class="Li">@a</span> according to the specified
  probability:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  DB&lt;29&gt; $f = Frequency( map { [$w{$_}, Unit($_)] } @a)
</pre>
<p class="Pp">Let us generate 10 items. We see that odd elements appear more
    frequently than even elements:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  DB&lt;30&gt; @r = map { $f-&gt;generate } 1..10
  DB&lt;31&gt; p &quot;@r&quot;
    VC UC K UC VC VC K EJ P P
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Generating_Token_Attributes"><a class="permalink" href="#Generating_Token_Attributes">Generating
  Token Attributes</a></h2>
Once the token was generated through the call to
  <span class="Li">&quot;generate_token&quot;</span> at line 50:
<p class="Pp"><span class="Li"></span></p>
<pre>
    45  #my $WHITESPACES = String( length=&gt;[0,1], charset=&gt;&quot; \t\n&quot;, size =&gt; 100 );
    46
    47  sub gen_lexer {
    48    my $parser = shift;
    49
    50    my $token = $parser-&gt;generate_token;
    51    my $attr = $parser-&gt;generate_attribute($token);
    52    #$attr = $WHITESPACES-&gt;generate.$attr;
    53
    54    return ($token, $attr);
    55  }
</pre>
<p class="Pp">the associated attributed is generated via the
    <span class="Li">&quot;generate_attribute&quot;</span> method in
    <span class="Li">&quot;GenSupport.pm&quot;</span>. If needed, random
    combination of white spaces can be added to the generated attribute via an
    appropriate generator (line 52).</p>
<p class="Pp">The <span class="Li">&quot;generate_attribute&quot;</span> method
    uses the method <span class="Li">&quot;generate&quot;</span> of the
    generator associated with such token. If no generator object was set, the
    attribute returned is the token itself (line 42):</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    36  sub generate_attribute {
    37    my $parser = shift;
    38    my $token = shift;
    39
    40    my $gen = $parser-&gt;token_generator($token);
    41    return $gen-&gt;generate  if defined($gen);
    42    return $token;
    43  }
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Holding_Semantic_Constraints"><a class="permalink" href="#Holding_Semantic_Constraints">Holding
  Semantic Constraints</a></h2>
The attribute generator associated with the token
  <span class="Li">&quot;VAR&quot;</span> is more complex than the others. It
  was defined in the call to
  <span class="Li">&quot;set_tokenweightsandgenerators&quot;</span>:
<p class="Pp"><span class="Li"></span></p>
<pre>
  examples/generator$ sed -ne '98,/^ *)/p' GenSupport.pm | cat -n
     1    my $parser = $package-&gt;new();
     2
     3    $parser-&gt;set_tokenweightsandgenerators(
     4      NUM =&gt; [ 2, Int(range=&gt;[0, 9], sized=&gt;0)],
     5      VAR =&gt; [
     6                0,  # At the beginning, no variables are defined
     7                Gen {
     8                  return  Elements(keys %st)-&gt;generate if keys %st;
     9                  return Int(range=&gt;[0, 9], sized=&gt;0)-&gt;generate;
    10                },
    11              ],
    12      VARDEF =&gt; [
    13                  2,
    14                  String( length=&gt;[1,2], charset=&gt;&quot;A-NP-Z&quot;, size =&gt; 100 )
    15                ],
    16      '=' =&gt; 2, '-' =&gt; 1, '+' =&gt; 2,
    17      '*' =&gt; 4, '/' =&gt; 2, '^' =&gt; 0.5,
    18      ';' =&gt; 1, '(' =&gt; 1, ')' =&gt; 2,
    19      ''  =&gt; 2, 'error' =&gt; 0,
    20    );
</pre>
<p class="Pp">The <span class="Li">&quot;Gen&quot;</span> function of
    Test::LectroTest::Generator creates a new generator from a given code. Since
    a variable can't be used unless it is defined, we use a symbol table
    <span class="Li">%st</span> to keep record of the variables that were
    defined in previous assignments. If no defined variables exists, the defined
    generator returns a digit between 0 and 9.</p>
<p class="Pp">Each time a new assignment to a variable occurs, such variable is
    added to the symbol table. This is achieved through the semantic action
    associated with the assignment production rule:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  examples/generator$ sed -ne '35,41p' Generator.eyp | cat -n
     1  stmt:
     2      VARDEF '=' exp
     3        {
     4          my $parser = shift;
     5          $parser-&gt;defined_variable($_[0]);
     6          &quot;$_[0]=$_[2]&quot;;
     7        }
</pre>
<p class="Pp">The <span class="Li">&quot;defined_variable&quot;</span> method in
    <span class="Li">&quot;GenSupport.pm&quot;</span> simply sets the
    corresponding entry in the symbol table:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  examples/generator$ sed -ne '19,24p' GenSupport.pm | cat -n
     1  my %st; # Symbol Table
     2  sub defined_variable {
     3    my ($parser, $var) = @_;
     4
     5    $st{$var} = 1;
     6  }
</pre>
<p class="Pp">The semantic action associated with <span class="Li">&quot;VARDEF
    '=' exp&quot;</span> returns the string <span class="Li">
    &quot;$_[0]=$_[2]&quot;</span> containing the actual phrase. Since this is
    the semantic action required for most productions we make it our default
    action:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  examples/generator$ sed -ne '13,17p' Generator.eyp | cat -n
     1  %defaultaction {
     2    my $parser = shift;
     3
     4    return join '', @_;
     5  }
</pre>
<p class="Pp">The syntactic variable <span class="Li">&quot;stmts&quot;</span>
    generates sequences of <span class="Li">&quot;stmt&quot;</span> separated by
    semicolons:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  examples/generator$ sed -ne '26,33p' Generator.eyp | cat -n
     1  stmts:
     2      stmt
     3        {
     4          $_[0]-&gt;deltaweight(VAR =&gt; +1); # At least one variable is defined now
     5          $_[1];
     6        }
     7    | stmts ';' { &quot;\n&quot; } stmt
     8  ;
</pre>
<p class="Pp">The second production is left recursive. As a consequence, the
    <span class="Li">&quot;stmt&quot;</span> in the first production (line 2) is
    the first statement of the sequence. A small derivation can convince you of
    this property:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
                                               stmts-&gt; stmt
   stmts =&gt; stmts';' stmt =&gt; stmts';' stmt ';' stmt =&gt; stmt ';' stmt ';' stmt 
                                                       ----
</pre>
<p class="Pp">Thus, when the reduction by the production
    <span class="Li">&quot;stmts -&gt; stmt&quot;</span> occurs, we are sure
    that the first statement has been processed. In such case we increase the
    weight of token <span class="Li">&quot;VAR&quot;</span> one unit (which was
    initially zero, see the call to
    <span class="Li">&quot;set_tokenweightsandgenerators&quot;</span>),</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
           $_[0]-&gt;deltaweight(VAR =&gt; +1);
</pre>
<p class="Pp">The weight of <span class="Li">&quot;VAR&quot;</span> is now 1,
    giving chances for variables to appear in the right hand side of an
    assignment. The Parse::Eyapp::Tokengen method
    <span class="Li">&quot;deltaweight&quot;</span> increases (decreases if
    negative) the weight of the given tokens using the associated values.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Dynamically_Changing_the_Probability_Distribution"><a class="permalink" href="#Dynamically_Changing_the_Probability_Distribution">Dynamically
  Changing the Probability Distribution</a></h2>
The semantic actions for the productions
<p class="Pp"><span class="Li"></span></p>
<pre>
               exp -&gt; '(' exp ')'
</pre>
<p class="Pp">and</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
               exp -&gt; '-' exp
</pre>
<p class="Pp">show a way to modify the weights associated with some tokens:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
 43 exp:
 44     NUM
 45   | VAR
 46   | exp '+' exp
 47   | exp '-' exp
 48   | exp '*' exp
 49   | exp '/' exp
 50   | '-' { $_[0]-&gt;pushdeltaweight('-' =&gt; -1) } exp %prec NEG
 51       {
 52         $_[0]-&gt;popweight();
 53         &quot;-$_[3]&quot;
 54       }
 55   | exp '^' exp
 56   | '('   { $_[0]-&gt;pushdeltaweight('(' =&gt; -1, ')' =&gt; +1, '+' =&gt; +1, ); }
 57       exp
 58     ')'
 59       {
 60          $_[0]-&gt;popweight;
 61          &quot;($_[3])&quot;
 62       }
 63 ;
</pre>
<p class="Pp">After seeing a <span class="Li">'('</span> we decrease by one the
    weight of <span class="Li">'('</span> to avoid expressions with nested
    parenthesis. We also increase the weight of token
    <span class="Li">'+'</span>, since parenthesis are often used to give more
    priority to a sum over a multiplication or division. This is achieved via
    the <span class="Li">&quot;pushdeltaweight&quot;</span> method. The old
    weight is recovered after the closing parenthesis is seen using the
    <span class="Li">&quot;popweight&quot;</span> method.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Computing_the_Expected_Result"><a class="permalink" href="#Computing_the_Expected_Result">Computing
  the Expected Result</a></h2>
Function <span class="Li">&quot;evaluate_using_perl&quot;</span> in
  <span class="Li">&quot;GenSupport.pm&quot;</span> finds the expected value for
  the generated expression. The calculator expression is roughly translated to a
  Perl expression and evaluated using the Perl interpreter:
<p class="Pp"><span class="Li"></span></p>
<pre>
 57 sub evaluate_using_perl { # if possible
 58   my $perlexp = shift;
 59
 60   $perlexp =~ s/\b([a-zA-Z])/\$$1/g; # substitute A by $A everywhere
 61   $perlexp =~ s/\^/**/g;             # substitute power operator: ^ by **
 62
 63   my $res = eval &quot;no warnings; no strict;$perlexp&quot;;
 64   if ($@ =~ /Illegal division/) {
 65     $res = &quot;error. Division by zero.&quot;;
 66   }
 67   elsif ($@) { # Our calc notation is incompatible with perl in a few gotchas
 68     # Perl interprets -- in a different way
 69     $@ =~ m{(.*)}; # Show only the first line of error message
 70     $res = &quot;Calculator syntax differs from Perl. Can't compute the result: $1&quot;;
 71   }
 72
 73   $res;
 74 }
</pre>
<p class="Pp">The calculator language differs from Perl. In the calculator, two
    consecutive minus like in <span class="Li">&quot;2--3&quot;</span> are
    interpreted as <span class="Li">&quot;2+3&quot;</span> while for Perl the
    former expression is an error. This limitation is here to illustrate a
    limitation of the approach: it gives a way to generate complex structured
    inputs but the programmer must find a way to compute what the expected value
    is.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="APPENDIX:_FILES"><a class="permalink" href="#APPENDIX:_FILES">APPENDIX:
  FILES</a></h1>
<section class="Ss">
<h2 class="Ss" id="File__GenSupport.pm_"><a class="permalink" href="#File__GenSupport.pm_">File
  &quot;GenSupport.pm&quot;</a></h2>
<span class="Li"></span>
<pre>
  Parse-Eyapp/examples/generator$ cat -n GenSupport.pm
     1  package GenSupport;
     2  use strict;
     3  use warnings;
     4
     5  use Getopt::Long;
     6  use Test::LectroTest::Generator qw(:all);
     7  use Parse::Eyapp::TokenGen;
     8
     9  sub _Error {
    10    my $parser = shift;
    11
    12    my $t = $parser-&gt;YYCurval;
    13    my @e = $parser-&gt;YYExpect();
    14    my $attr = $parser-&gt;YYSemval(0);
    15    local $&quot; = &quot; &quot;;
    16    warn &quot;Error:\nCurrent attribute: &lt;$attr&gt;\nCurrent token: &lt;$t&gt;\nExpected: &lt;@e&gt;\n&quot;;
    17  }
    18
    19  my %st; # Symbol Table
    20  sub defined_variable {
    21    my ($parser, $var) = @_;
    22
    23    $st{$var} = 1;
    24  }
    25
    26  sub generate_token {
    27    my $parser = shift;
    28
    29    my @token = $parser-&gt;YYExpect;
    30
    31    my $tokengen = Frequency( map { [$parser-&gt;token_weight($_), Unit($_)] } @token);
    32
    33    return $tokengen-&gt;generate;
    34  }
    35
    36  sub generate_attribute {
    37    my $parser = shift;
    38    my $token = shift;
    39
    40    my $gen = $parser-&gt;token_generator($token);
    41    return $gen-&gt;generate  if defined($gen);
    42    return $token;
    43  }
    44
    45  #my $WHITESPACES = String( length=&gt;[0,1], charset=&gt;&quot; \t\n&quot;, size =&gt; 100 );
    46
    47  sub gen_lexer {
    48    my $parser = shift;
    49
    50    my $token = $parser-&gt;generate_token;
    51    my $attr = $parser-&gt;generate_attribute($token);
    52    #$attr = $WHITESPACES-&gt;generate.$attr;
    53
    54    return ($token, $attr);
    55  }
    56
    57  sub evaluate_using_perl { # if possible
    58    my $perlexp = shift;
    59
    60    $perlexp =~ s/\b([a-zA-Z])/\$$1/g; # substitute A by $A everywhere
    61    $perlexp =~ s/\^/**/g;             # substitute power operator: ^ by **
    62
    63    my $res = eval &quot;no warnings; no strict;$perlexp&quot;;
    64    if ($@ =~ /Illegal division/) {
    65      $res = &quot;error. Division by zero.&quot;;
    66    }
    67    elsif ($@) { # Our calc notation is incompatible with perl in a few gotchas
    68      # Perl interprets -- in a different way
    69      $@ =~ m{(.*)}; # Show only the first line of error message
    70      $res = &quot;Calculator syntax differs from Perl. Can't compute the result: $1&quot;;
    71    }
    72
    73    $res;
    74  }
    75
    76
    77  sub Run {
    78      my($self)=shift;
    79      my $yydebug = shift || 0;
    80
    81      return $self-&gt;YYParse(
    82        yylex =&gt; \&amp;gen_lexer,
    83        yyerror =&gt; \&amp;_Error,
    84        yydebug =&gt; $yydebug, # 0x1F
    85      );
    86  }
    87
    88  sub main {
    89    my $package = shift;
    90
    91    my $debug = shift || 0;
    92    my $result = GetOptions (
    93      &quot;debug!&quot; =&gt; \$debug,
    94    );
    95
    96    $debug = 0x1F if $debug;
    97
    98    my $parser = $package-&gt;new();
    99
   100    $parser-&gt;set_tokenweightsandgenerators(
   101      NUM =&gt; [ 2, Int(range=&gt;[0, 9], sized=&gt;0)],
   102      VAR =&gt; [
   103                0,  # At the beginning, no variables are defined
   104                Gen {
   105                  return  Elements(keys %st)-&gt;generate if keys %st;
   106                  return Int(range=&gt;[0, 9], sized=&gt;0)-&gt;generate;
   107                },
   108              ],
   109      VARDEF =&gt; [
   110                  2,
   111                  String( length=&gt;[1,2], charset=&gt;&quot;A-NP-Z&quot;, size =&gt; 100 )
   112                ],
   113      '=' =&gt; 2, '-' =&gt; 1, '+' =&gt; 2,
   114      '*' =&gt; 4, '/' =&gt; 2, '^' =&gt; 0.5,
   115      ';' =&gt; 1, '(' =&gt; 1, ')' =&gt; 2,
   116      ''  =&gt; 2, 'error' =&gt; 0,
   117    );
   118
   119    my $exp = $parser-&gt;Run( $debug );
   120
   121    my $res = evaluate_using_perl($exp);
   122
   123    print &quot;\n# result: $res\n$exp\n&quot;;
   124  }
   125
   126  1;
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="File__Generator.eyp_"><a class="permalink" href="#File__Generator.eyp_">File
  &quot;Generator.eyp&quot;</a></h2>
<span class="Li"></span>
<pre>
  Parse-Eyapp/examples/generator$ cat -n Generator.eyp
     1  # file: Generator.eyp
     2  # compile with: eyapp -b '' Generator.eyp
     3  # then run: ./Generator.pm
     4  %strict
     5  %token NUM VARDEF VAR
     6
     7  %right  '='
     8  %left   '-' '+'
     9  %left   '*' '/'
    10  %left   NEG
    11  %right  '^'
    12
    13  %defaultaction {
    14    my $parser = shift;
    15
    16    return join '', @_;
    17  }
    18
    19  %{
    20  use base q{Parse::Eyapp::TokenGen};
    21  use base q{GenSupport};
    22  %}
    23
    24  %%
    25
    26  stmts:
    27      stmt
    28        {
    29          $_[0]-&gt;deltaweight(VAR =&gt; +1); # At least one variable is defined now
    30          $_[1];
    31        }
    32    | stmts ';' { &quot;\n&quot; } stmt
    33  ;
    34
    35  stmt:
    36      VARDEF '=' exp
    37        {
    38          my $parser = shift;
    39          $parser-&gt;defined_variable($_[0]);
    40          &quot;$_[0]=$_[2]&quot;;
    41        }
    42  ;
    43  exp:
    44      NUM
    45    | VAR
    46    | exp '+' exp
    47    | exp '-' exp
    48    | exp '*' exp
    49    | exp '/' exp
    50    | '-' { $_[0]-&gt;pushdeltaweight('-' =&gt; -1) } exp %prec NEG
    51        {
    52          $_[0]-&gt;popweight();
    53          &quot;-$_[3]&quot;
    54        }
    55    | exp '^' exp
    56    | '('   { $_[0]-&gt;pushdeltaweight('(' =&gt; -1, ')' =&gt; +1, '+' =&gt; +1, ); }
    57        exp
    58      ')'
    59        {
    60           $_[0]-&gt;popweight;
    61           &quot;($_[3])&quot;
    62        }
    63  ;
    64
    65  %%
    66
    67  unless (caller) {
    68    __PACKAGE__-&gt;main(@ARGV);
    69  }
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<ul class="Bl-bullet">
  <li>Parse::Eyapp::TokenGen</li>
  <li>Test::LectroTest::Generator by Tom Moertel</li>
  <li>The Design and Implementation of a Grammar-based Data Generator (1992) by
      Peter M. Maurer, Software Practice and Experience
      &lt;http://www.cs.ubc.ca/local/reading/proceedings/spe91-95/spe/./vol22/issue3/spe756pm.pdf&gt;</li>
  <li>yagg: an easy-to-use generator for structured test inputs by David Coppit
      and Jiexin Lian. ASE '05: Proceedings of the 20th IEEE/ACM international
      Conference on Automated software engineering. 2005, pages 356-359.</li>
</ul>
<div class="Bd-indent">
<ul class="Bl-bullet">
  <li>&lt;http://search.cpan.org/perldoc?yagg::Tutorial&gt;,</li>
  <li>&lt;http://www.cs.wm.edu/~coppit/wiki/images/4/4e/yagg_short.pdf&gt;,</li>
  <li>&lt;http://www.cs.wm.edu/~coppit/wiki/images/6/69/wm-cs-2005-13.pdf&gt;</li>
</ul>
</div>
<div class="Bd-indent"></div>
<ul class="Bl-bullet">
  <li>Writing Randomly by Randall Schwartz. Linux Magazine Column 04 (Sep 1999).
      &lt;http://www.stonehenge.com/merlyn/LinuxMag/col04.html&gt;</li>
  <li>Generating Test Data with Enhanced Context Free Grammars by Peter M.
      Maurer
      &lt;http://cs.baylor.edu/~maurer/aida/dgl-source/documentation/gen_tst.pdf&gt;</li>
  <li>Modules as Programs by Brian d Foy
      &lt;http://www252.pair.com/comdog/mastering_perl/Chapters/18.modulinos.html&gt;</li>
  <li>How a Script Becomes a Module by Brian d Foy. On Perlmonks:
      &lt;http://www.perlmonks.org/index.pl?node_id=396759&gt;.</li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="CONTRIBUTORS"><a class="permalink" href="#CONTRIBUTORS">CONTRIBUTORS</a></h1>
<ul class="Bl-bullet">
  <li>Hal Finkel &lt;http://www.halssoftware.com/&gt;</li>
  <li>G. Williams &lt;http://kasei.us/&gt;</li>
  <li>Thomas L. Shinnick &lt;http://search.cpan.org/~tshinnic/&gt;</li>
  <li>Frank Leray</li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
Casiano Rodriguez-Leon (casiano@ull.es)
</section>
<section class="Sh">
<h1 class="Sh" id="ACKNOWLEDGMENTS"><a class="permalink" href="#ACKNOWLEDGMENTS">ACKNOWLEDGMENTS</a></h1>
This work has been supported by CEE (FEDER) and the Spanish Ministry of
  <i>Educacion y Ciencia</i> through <i>Plan Nacional I+D+I</i> number
  TIN2005-08818-C04-04 (ULL::OPLINK project &lt;http://www.oplink.ull.es/&gt;).
  Support from Gobierno de Canarias was through GC02210601 (<i>Grupos
  Consolidados</i>). The University of La Laguna has also supported my work in
  many ways and for many years.
<p class="Pp">A large percentage of code is verbatim taken from Parse::Yapp
    1.05. The author of Parse::Yapp is Francois Desarmenien.</p>
<p class="Pp">I wish to thank Francois Desarmenien for his Parse::Yapp module,
    to my students at La Laguna and to the Perl Community. Thanks to the people
    who have contributed to improve the module (see &quot;CONTRIBUTORS&quot; in
    Parse::Eyapp). Thanks to Larry Wall for giving us Perl. Special thanks to
    Juana.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="LICENCE_AND_COPYRIGHT"><a class="permalink" href="#LICENCE_AND_COPYRIGHT">LICENCE
  AND COPYRIGHT</a></h1>
Copyright (c) 2006-2008 Casiano Rodriguez-Leon (casiano@ull.es). All rights
  reserved.
<p class="Pp">Parse::Yapp copyright is of Francois Desarmenien, all rights
    reserved. 1998-2001</p>
<p class="Pp">These modules are free software; you can redistribute it and/or
    modify it under the same terms as Perl itself. See perlartistic.</p>
<p class="Pp">This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. </p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2012-03-23</td>
    <td class="foot-os">perl v5.18.4</td>
  </tr>
</table>
</body>
</html>
