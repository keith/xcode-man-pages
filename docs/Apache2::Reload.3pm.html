<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.10 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>Apache2::Reload(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Apache2::Reload(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Apache2::Reload(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
Apache2::Reload - Reload Perl Modules when Changed on Disk
</section>
<section class="Sh">
<h1 class="Sh" id="Synopsis"><a class="permalink" href="#Synopsis">Synopsis</a></h1>
<span class="Li"></span>
<pre>
  # Monitor and reload all modules in %INC:
  # httpd.conf:
  PerlModule Apache2::Reload
  PerlInitHandler Apache2::Reload

  # when working with protocols and connection filters
  # PerlPreConnectionHandler Apache2::Reload

  # Reload groups of modules:
  # httpd.conf:
  PerlModule Apache2::Reload
  PerlInitHandler Apache2::Reload
  PerlSetVar ReloadAll Off
  PerlSetVar ReloadModules &quot;ModPerl::* Apache2::*&quot;
  #PerlSetVar ReloadDebug On
  #PerlSetVar ReloadByModuleName On
  
  # Reload a single module from within itself:
  package My::Apache2::Module;
  use Apache2::Reload;
  sub handler { ... }
  1;
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="Description"><a class="permalink" href="#Description">Description</a></h1>
<span class="Li">&quot;Apache2::Reload&quot;</span> reloads modules that change
  on the disk.
<p class="Pp">When Perl pulls a file via
    <span class="Li">&quot;require&quot;</span>, it stores the filename in the
    global hash <span class="Li">%INC</span>. The next time Perl tries to
    <span class="Li">&quot;require&quot;</span> the same file, it sees the file
    in <span class="Li">%INC</span> and does not reload from disk. This module's
    handler can be configured to iterate over the modules in
    <span class="Li">%INC</span> and reload those that have changed on disk or
    only specific modules that have registered themselves with
    <span class="Li">&quot;Apache2::Reload&quot;</span>. It can also do the
    check for modified modules, when a special touch-file has been modified.</p>
<p class="Pp">Require-hooks, i.e., entries in <span class="Li">%INC</span> which
    are references, are ignored. The hook should modify
    <span class="Li">%INC</span> itself, adding the path to the module file, for
    it to be reloaded.</p>
<p class="Pp"><span class="Li">&quot;Apache2::Reload&quot;</span> inspects and
    reloads the <b>file</b> associated with a given module. Changes to
    <span class="Li">@INC</span> are not recognized, as it is the file which is
    being re-required, not the module name.</p>
<p class="Pp">In version 0.10 and earlier the <b>module name</b>, not the file,
    is re-required. Meaning it operated on the the current context of
    <span class="Li">@INC</span>. If you still want this behavior set this
    environment variable in <i>httpd.conf</i>:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  PerlSetVar ReloadByModuleName On
</pre>
<p class="Pp">This means, when called as a
    <span class="Li">&quot;Perl*Handler&quot;</span>,
    <span class="Li">&quot;Apache2::Reload&quot;</span> will not see
    <span class="Li">@INC</span> paths added or removed by
    <span class="Li">&quot;ModPerl::Registry&quot;</span> scripts, as the value
    of <span class="Li">@INC</span> is saved on server startup and restored to
    that value after each request. In other words, if you want
    <span class="Li">&quot;Apache2::Reload&quot;</span> to work with modules
    that live in custom <span class="Li">@INC</span> paths, you should modify
    <span class="Li">@INC</span> when the server is started. Besides,
    <span class="Li">'use lib'</span> in the startup script, you can also set
    the <span class="Li">&quot;PERL5LIB&quot;</span> variable in the httpd's
    environment to include any non-standard 'lib' directories that you choose.
    For example, to accomplish that you can include a line:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  PERL5LIB=/home/httpd/perl/extra; export PERL5LIB
</pre>
<p class="Pp">in the script that starts Apache. Alternatively, you can set this
    environment variable in <i>httpd.conf</i>:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  PerlSetEnv PERL5LIB /home/httpd/perl/extra
</pre>
<section class="Ss">
<h2 class="Ss" id="Monitor_All_Modules_in__INC"><a class="permalink" href="#Monitor_All_Modules_in__INC">Monitor
  All Modules in %INC</a></h2>
To monitor and reload all modules in <span class="Li">%INC</span> at the
  beginning of request's processing, simply add the following configuration to
  your <i>httpd.conf</i>:
<p class="Pp"><span class="Li"></span></p>
<pre>
  PerlModule Apache2::Reload
  PerlInitHandler Apache2::Reload
</pre>
<p class="Pp">When working with connection filters and protocol modules
    <span class="Li">&quot;Apache2::Reload&quot;</span> should be invoked in the
    pre_connection stage:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  PerlPreConnectionHandler Apache2::Reload
</pre>
<p class="Pp">See also the discussion on
    <span class="Li">&quot;PerlPreConnectionHandler&quot;</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Register_Modules_Implicitly"><a class="permalink" href="#Register_Modules_Implicitly">Register
  Modules Implicitly</a></h2>
To only reload modules that have registered with
  <span class="Li">&quot;Apache2::Reload&quot;</span>, add the following to the
  <i>httpd.conf</i>:
<p class="Pp"><span class="Li"></span></p>
<pre>
  PerlModule Apache2::Reload
  PerlInitHandler Apache2::Reload
  PerlSetVar ReloadAll Off
  # ReloadAll defaults to On
</pre>
<p class="Pp">Then any modules with the line:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  use Apache2::Reload;
</pre>
<p class="Pp">Will be reloaded when they change.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Register_Modules_Explicitly"><a class="permalink" href="#Register_Modules_Explicitly">Register
  Modules Explicitly</a></h2>
You can also register modules explicitly in your <i>httpd.conf</i> file that you
  want to be reloaded on change:
<p class="Pp"><span class="Li"></span></p>
<pre>
  PerlModule Apache2::Reload
  PerlInitHandler Apache2::Reload
  PerlSetVar ReloadAll Off
  PerlSetVar ReloadModules &quot;My::Foo My::Bar Foo::Bar::Test&quot;
</pre>
<p class="Pp">Note that these are split on whitespace, but the module list
    <b>must</b> be in quotes, otherwise Apache tries to parse the parameter
    list.</p>
<p class="Pp">The <span class="Li">&quot;*&quot;</span> wild character can be
    used to register groups of files under the same namespace. For example the
    setting:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  PerlSetVar ReloadModules &quot;ModPerl::* Apache2::*&quot;
</pre>
<p class="Pp">will monitor all modules under the namespaces
    <span class="Li">&quot;ModPerl::&quot;</span> and
    <span class="Li">&quot;Apache2::&quot;</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Monitor_Only_Certain_Sub_Directories"><a class="permalink" href="#Monitor_Only_Certain_Sub_Directories">Monitor
  Only Certain Sub Directories</a></h2>
To reload modules only in certain directories (and their subdirectories) add the
  following to the <i>httpd.conf</i>:
<p class="Pp"><span class="Li"></span></p>
<pre>
  PerlModule Apache2::Reload
  PerlInitHandler Apache2::Reload
  PerlSetVar ReloadDirectories &quot;/tmp/project1 /tmp/project2&quot;
</pre>
<p class="Pp">You can further narrow the list of modules to be reloaded from the
    chosen directories with <span class="Li">&quot;ReloadModules&quot;</span> as
    in:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  PerlModule Apache2::Reload
  PerlInitHandler Apache2::Reload
  PerlSetVar ReloadDirectories &quot;/tmp/project1 /tmp/project2&quot;
  PerlSetVar ReloadAll Off
  PerlSetVar ReloadModules &quot;MyApache2::*&quot;
</pre>
<p class="Pp">In this configuration example only modules from the namespace
    <span class="Li">&quot;MyApache2::&quot;</span> found in the directories
    <i>/tmp/project1/</i> and <i>/tmp/project2/</i> (and their subdirectories)
    will be reloaded.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Special__Touch__File"><a class="permalink" href="#Special__Touch__File">Special
  &quot;Touch&quot; File</a></h2>
You can also declare a file, which when gets <span class="Li">touch(1)</span>ed,
  causes the reloads to be performed. For example if you set:
<p class="Pp"><span class="Li"></span></p>
<pre>
  PerlSetVar ReloadTouchFile /tmp/reload_modules
</pre>
<p class="Pp">and don't <span class="Li">touch(1)</span> the file
    <i>/tmp/reload_modules</i>, the reloads won't happen until you go to the
    command line and type:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  % touch /tmp/reload_modules
</pre>
<p class="Pp">When you do that, the modules that have been changed, will be
    magically reloaded on the next request. This option works with any mode
    described before.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Unregistering_a_module"><a class="permalink" href="#Unregistering_a_module">Unregistering
  a module</a></h2>
In some cases, it might be necessary to explicitly stop reloading a module.
<p class="Pp"><span class="Li"></span></p>
<pre>
  Apache2::Reload-&gt;unregister_module('Some::Module');
</pre>
<p class="Pp">But be carefull, since unregistering a module in this way will
    only do so for the current interpreter. This feature should be used with
    care.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="Performance_Issues"><a class="permalink" href="#Performance_Issues">Performance
  Issues</a></h1>
This module is perfectly suited for a development environment. Though it's
  possible that you would like to use it in a production environment, since with
  <span class="Li">&quot;Apache2::Reload&quot;</span> you don't have to restart
  the server in order to reload changed modules during software updates. Though
  this convenience comes at a price:
<ul class="Bl-bullet">
  <li>If the &quot;touch&quot; file feature is used,
      <span class="Li">&quot;Apache2::Reload&quot;</span> has to <b>stat</b>(2)
      the touch file on each request, which adds a slight but most likely
      insignificant overhead to response times. Otherwise
      <span class="Li">&quot;Apache2::Reload&quot;</span> will <b>stat</b>(2)
      each registered module or even worse--all modules in
      <span class="Li">%INC</span>, which will significantly slow everything
      down.</li>
  <li>Once the child process reloads the modules, the memory used by these
      modules is not shared with the parent process anymore. Therefore the
      memory consumption may grow significantly.</li>
</ul>
<p class="Pp">Therefore doing a full server stop and restart is probably a
    better solution.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="Debug"><a class="permalink" href="#Debug">Debug</a></h1>
If you aren't sure whether the modules that are supposed to be reloaded, are
  actually getting reloaded, turn the debug mode on:
<p class="Pp"><span class="Li"></span></p>
<pre>
  PerlSetVar ReloadDebug On
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="Caveats"><a class="permalink" href="#Caveats">Caveats</a></h1>
<section class="Ss">
<h2 class="Ss" id="Problems_With_Reloading_Modules_Which_Do_Not_Declare_Their_Package_Name"><a class="permalink" href="#Problems_With_Reloading_Modules_Which_Do_Not_Declare_Their_Package_Name">Problems
  With Reloading Modules Which Do Not Declare Their Package Name</a></h2>
If you modify modules, which don't declare their
  <span class="Li">&quot;package&quot;</span>, and rely on
  <span class="Li">&quot;Apache2::Reload&quot;</span> to reload them, you may
  encounter problems: i.e., it'll appear as if the module wasn't reloaded when
  in fact it was. This happens because when
  <span class="Li">&quot;Apache2::Reload&quot;</span>
  <span class="Li">&quot;require()&quot;</span>s such a module all the global
  symbols end up in the <span class="Li">&quot;Apache2::Reload&quot;</span>
  namespace! So the module does get reloaded and you see the compile time errors
  if there are any, but the symbols don't get imported to the right namespace.
  Therefore the old version of the code is running.
</section>
<section class="Ss">
<h2 class="Ss" id="Failing_to_Find_a_File_to_Reload"><a class="permalink" href="#Failing_to_Find_a_File_to_Reload">Failing
  to Find a File to Reload</a></h2>
<span class="Li">&quot;Apache2::Reload&quot;</span> uses
  <span class="Li">%INC</span> to find the files on the filesystem. If an entry
  for a certain filepath in <span class="Li">%INC</span> is relative,
  <span class="Li">&quot;Apache2::Reload&quot;</span> will use
  <span class="Li">@INC</span> to try to resolve that relative path. Now
  remember that mod_perl freezes the value of <span class="Li">@INC</span> at
  the server startup, and you can modify it only for the duration of one request
  when you need to load some module which is not in on of the
  <span class="Li">@INC</span> directories. So a module gets loaded, and
  registered in <span class="Li">%INC</span> with a relative path. Now when
  <span class="Li">&quot;Apache2::Reload&quot;</span> tries to find that module
  to check whether it has been modified, it can't find since its directory is
  not in <span class="Li">@INC</span>. So
  <span class="Li">&quot;Apache2::Reload&quot;</span> will silently skip that
  module.
<p class="Pp">You can enable the
    <span class="Li">&quot;Debug|/Debug&quot;</span> mode to see what
    <span class="Li">&quot;Apache2::Reload&quot;</span> does behind the
  scenes.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Problems_with_Scripts_Running_with_Registry_Handlers_that_Cache_the_Code"><a class="permalink" href="#Problems_with_Scripts_Running_with_Registry_Handlers_that_Cache_the_Code">Problems
  with Scripts Running with Registry Handlers that Cache the Code</a></h2>
The following problem is relevant only to registry handlers that cache the
  compiled script. For example it concerns
  <span class="Li">&quot;ModPerl::Registry&quot;</span> but not
  <span class="Li">&quot;ModPerl::PerlRun&quot;</span>.
<p class="Pp"><i>The Problem</i></p>
<p class="Pp">Let's say that there is a module
    <span class="Li">&quot;My::Utils&quot;</span>:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  #file:My/Utils.pm
  #----------------
  package My::Utils;
  BEGIN { warn __PACKAGE__ , &quot; was reloaded\n&quot; }
  use base qw(Exporter);
  @EXPORT = qw(colour);
  sub colour { &quot;white&quot; }
  1;
</pre>
<p class="Pp">And a registry script <i>test.pl</i>:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  #file:test.pl
  #------------
  use My::Utils;
  print &quot;Content-type: text/plain\n\n&quot;;
  print &quot;the color is &quot; . colour();
</pre>
<p class="Pp">Assuming that the server is running in a single mode, we request
    the script for the first time and we get the response:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  the color is white
</pre>
<p class="Pp">Now we change <i>My/Utils.pm</i>:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  -  sub colour { &quot;white&quot; }
  +  sub colour { &quot;red&quot; }
</pre>
<p class="Pp">And issue the request again.
    <span class="Li">&quot;Apache2::Reload&quot;</span> does its job and we can
    see that <span class="Li">&quot;My::Utils&quot;</span> was reloaded (look in
    the <i>error_log</i> file). However the script still returns:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  the color is white
</pre>
<p class="Pp"><i>The Explanation</i></p>
<p class="Pp">Even though <i>My/Utils.pm</i> was reloaded,
    <span class="Li">&quot;ModPerl::Registry&quot;</span>'s cached code won't
    run '<span class="Li">&quot;use My::Utils;&quot;</span>' again (since it
    happens only once, i.e. during the compile time). Therefore the script
    doesn't know that the subroutine reference has been changed.</p>
<p class="Pp">This is easy to verify. Let's change the script to be:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  #file:test.pl
  #------------
  use My::Utils;
  print &quot;Content-type: text/plain\n\n&quot;;
  my $sub_int = \&amp;colour;
  my $sub_ext = \&amp;My::Utils::colour;
  print &quot;int $sub_int\n&quot;;
  print &quot;ext $sub_ext\n&quot;;
</pre>
<p class="Pp">Issue a request, you will see something similar to:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  int CODE(0x8510af8)
  ext CODE(0x8510af8)
</pre>
<p class="Pp">As you can see both point to the same CODE reference (meaning that
    it's the same symbol). After modifying <i>My/Utils.pm</i> again:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  -  sub colour { &quot;red&quot; }
  +  sub colour { &quot;blue&quot; }
</pre>
<p class="Pp">and calling the script on the secondnd time, we get:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  int CODE(0x8510af8)
  ext CODE(0x851112c)
</pre>
<p class="Pp">You can see that the internal CODE reference is not the same as
    the external one.</p>
<p class="Pp"><i>The Solution</i></p>
<p class="Pp">There are two solutions to this problem:</p>
<p class="Pp">Solution 1: replace <span class="Li">&quot;use()&quot;</span> with
    an explicit <span class="Li">&quot;require()&quot;</span> +
    <span class="Li">&quot;import()&quot;</span>.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
 - use My::Utils;
 + require My::Utils; My::Utils-&gt;import();
</pre>
<p class="Pp">now the changed functions will be reimported on every request.</p>
<p class="Pp">Solution 2: remember to touch the script itself every time you
    change the module that it requires.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="Threaded_MPM_and_Multiple_Perl_Interpreters"><a class="permalink" href="#Threaded_MPM_and_Multiple_Perl_Interpreters">Threaded
  MPM and Multiple Perl Interpreters</a></h1>
If you use <span class="Li">&quot;Apache2::Reload&quot;</span> with a threaded
  MPM and multiple Perl interpreters, the modules will be reloaded by each
  interpreter as they are used, not every interpreters at once. Similar to
  mod_perl 1.0 where each child has its own Perl interpreter, the modules are
  reloaded as each child is hit with a request.
<p class="Pp">If a module is loaded at startup, the syntax tree of each
    subroutine is shared between interpreters (big win), but each subroutine has
    its own padlist (where lexical my variables are stored). Once
    <span class="Li">&quot;Apache2::Reload&quot;</span> reloads a module, this
    sharing goes away and each Perl interpreter will have its own copy of the
    syntax tree for the reloaded subroutines.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="Pseudo-hashes"><a class="permalink" href="#Pseudo-hashes">Pseudo-hashes</a></h1>
The short summary of this is: Don't use pseudo-hashes. They are deprecated since
  Perl 5.8 and are removed in 5.9.
<p class="Pp">Use an array with constant indexes. Its faster in the general
    case, its more guaranteed, and generally, it works.</p>
<p class="Pp">The long summary is that some work has been done to get this
    module working with modules that use pseudo-hashes, but it's still broken in
    the case of a single module that contains multiple packages that all use
    pseudo-hashes.</p>
<p class="Pp">So don't do that.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="Copyright"><a class="permalink" href="#Copyright">Copyright</a></h1>
mod_perl 2.0 and its core modules are copyrighted under The Apache Software
  License, Version 2.0.
</section>
<section class="Sh">
<h1 class="Sh" id="Authors"><a class="permalink" href="#Authors">Authors</a></h1>
Matt Sergeant, matt@sergeant.org
<p class="Pp">Stas Bekman (porting to mod_perl 2.0)</p>
<p class="Pp">A few concepts borrowed from
    <span class="Li">&quot;Stonehenge::Reload&quot;</span> by Randal Schwartz
    and <span class="Li">&quot;Apache::StatINC&quot;</span> (mod_perl 1.x) by
    Doug MacEachern and Ask Bjoern Hansen.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="MAINTAINERS"><a class="permalink" href="#MAINTAINERS">MAINTAINERS</a></h1>
the mod_perl developers, dev@perl.apache.org
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2015-06-18</td>
    <td class="foot-os">perl v5.28.2</td>
  </tr>
</table>
</body>
</html>
