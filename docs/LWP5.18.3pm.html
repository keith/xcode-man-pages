<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>LWP(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">LWP(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">LWP(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
LWP - The World-Wide Web library for Perl
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<span class="Li"></span>
<pre>
  use LWP;
  print &quot;This is libwww-perl-$LWP::VERSION\n&quot;;
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
The libwww-perl collection is a set of Perl modules which provides a simple and
  consistent application programming interface (API) to the World-Wide Web. The
  main focus of the library is to provide classes and functions that allow you
  to write WWW clients. The library also contain modules that are of more
  general use and even classes that help you implement simple HTTP servers.
<p class="Pp">Most modules in this library provide an object oriented API. The
    user agent, requests sent and responses received from the WWW server are all
    represented by objects. This makes a simple and powerful interface to these
    services. The interface is easy to extend and customize for your own
  needs.</p>
<p class="Pp">The main features of the library are:</p>
<ul class="Bl-bullet">
  <li>Contains various reusable components (modules) that can be used separately
      or together.</li>
  <li>Provides an object oriented model of HTTP-style communication. Within this
      framework we currently support access to http, https, gopher, ftp, news,
      file, and mailto resources.</li>
  <li>Provides a full object oriented interface or a very simple procedural
      interface.</li>
  <li>Supports the basic and digest authorization schemes.</li>
  <li>Supports transparent redirect handling.</li>
  <li>Supports access through proxy servers.</li>
  <li>Provides parser for <i>robots.txt</i> files and a framework for
      constructing robots.</li>
  <li>Supports parsing of HTML forms.</li>
  <li>Implements HTTP content negotiation algorithm that can be used both in
      protocol modules and in server scripts (like CGI scripts).</li>
  <li>Supports HTTP cookies.</li>
  <li>Some simple command line clients, for instance
      <span class="Li">&quot;lwp-request&quot;</span> and
      <span class="Li">&quot;lwp-download&quot;</span>.</li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="HTTP_STYLE_COMMUNICATION"><a class="permalink" href="#HTTP_STYLE_COMMUNICATION">HTTP
  STYLE COMMUNICATION</a></h1>
The libwww-perl library is based on HTTP style communication. This section tries
  to describe what that means.
<p class="Pp">Let us start with this quote from the HTTP specification document
    &lt;URL:http://www.w3.org/Protocols/&gt;:</p>
<dl class="Bl-tag">
  <dt>&#x2022;</dt>
  <dd>The HTTP protocol is based on a request/response paradigm. A client
      establishes a connection with a server and sends a request to the server
      in the form of a request method, URI, and protocol version, followed by a
      MIME-like message containing request modifiers, client information, and
      possible body content. The server responds with a status line, including
      the message's protocol version and a success or error code, followed by a
      MIME-like message containing server information, entity meta-information,
      and possible body content.</dd>
</dl>
<p class="Pp">What this means to libwww-perl is that communication always take
    place through these steps: First a <i>request</i> object is created and
    configured. This object is then passed to a server and we get a
    <i>response</i> object in return that we can examine. A request is always
    independent of any previous requests, i.e. the service is stateless. The
    same simple model is used for any kind of service we want to access.</p>
<p class="Pp">For example, if we want to fetch a document from a remote file
    server, then we send it a request that contains a name for that document and
    the response will contain the document itself. If we access a search engine,
    then the content of the request will contain the query parameters and the
    response will contain the query result. If we want to send a mail message to
    somebody then we send a request object which contains our message to the
    mail server and the response object will contain an acknowledgment that
    tells us that the message has been accepted and will be forwarded to the
    recipient(s).</p>
<p class="Pp">It is as simple as that!</p>
<section class="Ss">
<h2 class="Ss" id="The_Request_Object"><a class="permalink" href="#The_Request_Object">The
  Request Object</a></h2>
The libwww-perl request object has the class name
  <span class="Li">&quot;HTTP::Request&quot;</span>. The fact that the class
  name uses <span class="Li">&quot;HTTP::&quot;</span> as a prefix only implies
  that we use the HTTP model of communication. It does not limit the kind of
  services we can try to pass this <i>request</i> to. For instance, we will send
  <span class="Li">&quot;HTTP::Request&quot;</span>s both to ftp and gopher
  servers, as well as to the local file system.
<p class="Pp">The main attributes of the request objects are:</p>
<ul class="Bl-bullet">
  <li><b>method</b> is a short string that tells what kind of request this is.
      The most common methods are <b>GET</b>, <b>PUT</b>, <b>POST</b> and
      <b>HEAD</b>.</li>
  <li><b>uri</b> is a string denoting the protocol, server and the name of the
      &quot;document&quot; we want to access. The <b>uri</b> might also encode
      various other parameters.</li>
  <li><b>headers</b> contains additional information about the request and can
      also used to describe the content. The headers are a set of keyword/value
      pairs.</li>
  <li><b>content</b> is an arbitrary amount of data.</li>
</ul>
</section>
<section class="Ss">
<h2 class="Ss" id="The_Response_Object"><a class="permalink" href="#The_Response_Object">The
  Response Object</a></h2>
The libwww-perl response object has the class name
  <span class="Li">&quot;HTTP::Response&quot;</span>. The main attributes of
  objects of this class are:
<ul class="Bl-bullet">
  <li><b>code</b> is a numerical value that indicates the overall outcome of the
      request.</li>
  <li><b>message</b> is a short, human readable string that corresponds to the
      <i>code</i>.</li>
  <li><b>headers</b> contains additional information about the response and
      describe the content.</li>
  <li><b>content</b> is an arbitrary amount of data.</li>
</ul>
<p class="Pp">Since we don't want to handle all possible <i>code</i> values
    directly in our programs, a libwww-perl response object has methods that can
    be used to query what kind of response this is. The most commonly used
    response classification methods are:</p>
<dl class="Bl-tag">
  <dt><i>is_success()</i></dt>
  <dd>The request was successfully received, understood or accepted.</dd>
  <dt><i>is_error()</i></dt>
  <dd>The request failed. The server or the resource might not be available,
      access to the resource might be denied or other things might have failed
      for some reason.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="The_User_Agent"><a class="permalink" href="#The_User_Agent">The
  User Agent</a></h2>
Let us assume that we have created a <i>request</i> object. What do we actually
  do with it in order to receive a <i>response</i>?
<p class="Pp">The answer is that you pass it to a <i>user agent</i> object and
    this object takes care of all the things that need to be done (like
    low-level communication and error handling) and returns a <i>response</i>
    object. The user agent represents your application on the network and
    provides you with an interface that can accept <i>requests</i> and return
    <i>responses</i>.</p>
<p class="Pp">The user agent is an interface layer between your application code
    and the network. Through this interface you are able to access the various
    servers on the network.</p>
<p class="Pp">The class name for the user agent is
    <span class="Li">&quot;LWP::UserAgent&quot;</span>. Every libwww-perl
    application that wants to communicate should create at least one object of
    this class. The main method provided by this object is <i>request()</i>.
    This method takes an <span class="Li">&quot;HTTP::Request&quot;</span>
    object as argument and (eventually) returns a
    <span class="Li">&quot;HTTP::Response&quot;</span> object.</p>
<p class="Pp">The user agent has many other attributes that let you configure
    how it will interact with the network and with your application.</p>
<ul class="Bl-bullet">
  <li><b>timeout</b> specifies how much time we give remote servers to respond
      before the library disconnects and creates an internal <i>timeout</i>
      response.</li>
  <li><b>agent</b> specifies the name that your application uses when it
      presents itself on the network.</li>
  <li><b>from</b> can be set to the e-mail address of the person responsible for
      running the application. If this is set, then the address will be sent to
      the servers with every request.</li>
  <li><b>parse_head</b> specifies whether we should initialize response headers
      from the &lt;head&gt; section of HTML documents.</li>
  <li><b>proxy</b> and <b>no_proxy</b> specify if and when to go through a proxy
      server. &lt;URL:http://www.w3.org/History/1994/WWW/Proxies/&gt;</li>
  <li><b>credentials</b> provides a way to set up user names and passwords
      needed to access certain services.</li>
</ul>
<p class="Pp">Many applications want even more control over how they interact
    with the network and they get this by sub-classing
    <span class="Li">&quot;LWP::UserAgent&quot;</span>. The library includes a
    sub-class, <span class="Li">&quot;LWP::RobotUA&quot;</span>, for robot
    applications.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="An_Example"><a class="permalink" href="#An_Example">An
  Example</a></h2>
This example shows how the user agent, a request and a response are represented
  in actual perl code:
<p class="Pp"><span class="Li"></span></p>
<pre>
  # Create a user agent object
  use LWP::UserAgent;
  my $ua = LWP::UserAgent-&gt;new;
  $ua-&gt;agent(&quot;MyApp/0.1 &quot;);

  # Create a request
  my $req = HTTP::Request-&gt;new(POST =&gt; 'http://search.cpan.org/search');
  $req-&gt;content_type('application/x-www-form-urlencoded');
  $req-&gt;content('query=libwww-perl&amp;mode=dist');

  # Pass request to the user agent and get a response back
  my $res = $ua-&gt;request($req);

  # Check the outcome of the response
  if ($res-&gt;is_success) {
      print $res-&gt;content;
  }
  else {
      print $res-&gt;status_line, &quot;\n&quot;;
  }
</pre>
<p class="Pp">The <span class="Li">$ua</span> is created once when the
    application starts up. New request objects should normally created for each
    request sent.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="NETWORK_SUPPORT"><a class="permalink" href="#NETWORK_SUPPORT">NETWORK
  SUPPORT</a></h1>
This section discusses the various protocol schemes and the HTTP style methods
  that headers may be used for each.
<p class="Pp">For all requests, a &quot;User-Agent&quot; header is added and
    initialized from the <span class="Li">$ua</span>-&gt;agent attribute before
    the request is handed to the network layer. In the same way, a
    &quot;From&quot; header is initialized from the
    <span class="Li">$ua</span>-&gt;from attribute.</p>
<p class="Pp">For all responses, the library adds a header called
    &quot;Client-Date&quot;. This header holds the time when the response was
    received by your application. The format and semantics of the header are the
    same as the server created &quot;Date&quot; header. You may also encounter
    other &quot;Client-XXX&quot; headers. They are all generated by the library
    internally and are not received from the servers.</p>
<section class="Ss">
<h2 class="Ss" id="_s-1HTTP_s0_Requests"><a class="permalink" href="#_s-1HTTP_s0_Requests">HTTP
  Requests</a></h2>
HTTP requests are just handed off to an HTTP server and it decides what happens.
  Few servers implement methods beside the usual &quot;GET&quot;,
  &quot;HEAD&quot;, &quot;POST&quot; and &quot;PUT&quot;, but CGI-scripts may
  implement any method they like.
<p class="Pp">If the server is not available then the library will generate an
    internal error response.</p>
<p class="Pp">The library automatically adds a &quot;Host&quot; and a
    &quot;Content-Length&quot; header to the HTTP request before it is sent over
    the network.</p>
<p class="Pp">For a GET request you might want to add a
    &quot;If-Modified-Since&quot; or &quot;If-None-Match&quot; header to make
    the request conditional.</p>
<p class="Pp">For a POST request you should add the &quot;Content-Type&quot;
    header. When you try to emulate HTML &lt;FORM&gt; handling you should
    usually let the value of the &quot;Content-Type&quot; header be
    &quot;application/x-www-form-urlencoded&quot;. See lwpcook for examples of
    this.</p>
<p class="Pp">The libwww-perl HTTP implementation currently support the HTTP/1.1
    and HTTP/1.0 protocol.</p>
<p class="Pp">The library allows you to access proxy server through HTTP. This
    means that you can set up the library to forward all types of request
    through the HTTP protocol module. See LWP::UserAgent for documentation of
    this.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_s-1HTTPS_s0_Requests"><a class="permalink" href="#_s-1HTTPS_s0_Requests">HTTPS
  Requests</a></h2>
HTTPS requests are HTTP requests over an encrypted network connection using the
  SSL protocol developed by Netscape. Everything about HTTP requests above also
  apply to HTTPS requests. In addition the library will add the headers
  &quot;Client-SSL-Cipher&quot;, &quot;Client-SSL-Cert-Subject&quot; and
  &quot;Client-SSL-Cert-Issuer&quot; to the response. These headers denote the
  encryption method used and the name of the server owner.
<p class="Pp">The request can contain the header &quot;If-SSL-Cert-Subject&quot;
    in order to make the request conditional on the content of the server
    certificate. If the certificate subject does not match, no request is sent
    to the server and an internally generated error response is returned. The
    value of the &quot;If-SSL-Cert-Subject&quot; header is interpreted as a Perl
    regular expression.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_s-1FTP_s0_Requests"><a class="permalink" href="#_s-1FTP_s0_Requests">FTP
  Requests</a></h2>
The library currently supports GET, HEAD and PUT requests. GET retrieves a file
  or a directory listing from an FTP server. PUT stores a file on a ftp server.
<p class="Pp">You can specify a ftp account for servers that want this in
    addition to user name and password. This is specified by including an
    &quot;Account&quot; header in the request.</p>
<p class="Pp">User name/password can be specified using basic authorization or
    be encoded in the URL. Failed logins return an UNAUTHORIZED response with
    &quot;WWW-Authenticate: Basic&quot; and can be treated like basic
    authorization for HTTP.</p>
<p class="Pp">The library supports ftp ASCII transfer mode by specifying the
    &quot;type=a&quot; parameter in the URL. It also supports transfer of ranges
    for FTP transfers using the &quot;Range&quot; header.</p>
<p class="Pp">Directory listings are by default returned unprocessed (as
    returned from the ftp server) with the content media type reported to be
    &quot;text/ftp-dir-listing&quot;. The
    <span class="Li">&quot;File::Listing&quot;</span> module provides methods
    for parsing of these directory listing.</p>
<p class="Pp">The ftp module is also able to convert directory listings to HTML
    and this can be requested via the standard HTTP content negotiation
    mechanisms (add an &quot;Accept: text/html&quot; header in the request if
    you want this).</p>
<p class="Pp">For normal file retrievals, the &quot;Content-Type&quot; is
    guessed based on the file name suffix. See LWP::MediaTypes.</p>
<p class="Pp">The &quot;If-Modified-Since&quot; request header works for servers
    that implement the MDTM command. It will probably not work for directory
    listings though.</p>
<p class="Pp">Example:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  $req = HTTP::Request-&gt;new(GET =&gt; 'ftp://me:passwd@ftp.some.where.com/');
  $req-&gt;header(Accept =&gt; &quot;text/html, */*;q=0.1&quot;);
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="News_Requests"><a class="permalink" href="#News_Requests">News
  Requests</a></h2>
Access to the USENET News system is implemented through the NNTP protocol. The
  name of the news server is obtained from the NNTP_SERVER environment variable
  and defaults to &quot;news&quot;. It is not possible to specify the hostname
  of the NNTP server in news: URLs.
<p class="Pp">The library supports GET and HEAD to retrieve news articles
    through the NNTP protocol. You can also post articles to newsgroups by using
    (surprise!) the POST method.</p>
<p class="Pp">GET on newsgroups is not implemented yet.</p>
<p class="Pp">Examples:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  $req = HTTP::Request-&gt;new(GET =&gt; 'news:abc1234@a.sn.no');

  $req = HTTP::Request-&gt;new(POST =&gt; 'news:comp.lang.perl.test');
  $req-&gt;header(Subject =&gt; 'This is a test',
               From    =&gt; 'me@some.where.org');
  $req-&gt;content(&lt;&lt;EOT);
  This is the content of the message that we are sending to
  the world.
  EOT
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Gopher_Request"><a class="permalink" href="#Gopher_Request">Gopher
  Request</a></h2>
The library supports the GET and HEAD methods for gopher requests. All request
  header values are ignored. HEAD cheats and returns a response without even
  talking to server.
<p class="Pp">Gopher menus are always converted to HTML.</p>
<p class="Pp">The response &quot;Content-Type&quot; is generated from the
    document type encoded (as the first letter) in the request URL path
  itself.</p>
<p class="Pp">Example:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  $req = HTTP::Request-&gt;new(GET =&gt; 'gopher://gopher.sn.no/');
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="File_Request"><a class="permalink" href="#File_Request">File
  Request</a></h2>
The library supports GET and HEAD methods for file requests. The
  &quot;If-Modified-Since&quot; header is supported. All other headers are
  ignored. The <i>host</i> component of the file URL must be empty or set to
  &quot;localhost&quot;. Any other <i>host</i> value will be treated as an
  error.
<p class="Pp">Directories are always converted to an HTML document. For normal
    files, the &quot;Content-Type&quot; and &quot;Content-Encoding&quot; in the
    response are guessed based on the file suffix.</p>
<p class="Pp">Example:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  $req = HTTP::Request-&gt;new(GET =&gt; 'file:/etc/passwd');
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Mailto_Request"><a class="permalink" href="#Mailto_Request">Mailto
  Request</a></h2>
You can send (aka &quot;POST&quot;) mail messages using the library. All headers
  specified for the request are passed on to the mail system. The &quot;To&quot;
  header is initialized from the mail address in the URL.
<p class="Pp">Example:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  $req = HTTP::Request-&gt;new(POST =&gt; 'mailto:libwww@perl.org');
  $req-&gt;header(Subject =&gt; &quot;subscribe&quot;);
  $req-&gt;content(&quot;Please subscribe me to the libwww-perl mailing list!\n&quot;);
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="_s-1CPAN_s0_Requests"><a class="permalink" href="#_s-1CPAN_s0_Requests">CPAN
  Requests</a></h2>
URLs with scheme <span class="Li">&quot;cpan:&quot;</span> are redirected to the
  a suitable CPAN mirror. If you have your own local mirror of CPAN you might
  tell LWP to use it for <span class="Li">&quot;cpan:&quot;</span> URLs by an
  assignment like this:
<p class="Pp"><span class="Li"></span></p>
<pre>
  $LWP::Protocol::cpan::CPAN = &quot;file:/local/CPAN/&quot;;
</pre>
<p class="Pp">Suitable CPAN mirrors are also picked up from the configuration
    for the CPAN.pm, so if you have used that module a suitable mirror should be
    picked automatically. If neither of these apply, then a redirect to the
    generic CPAN http location is issued.</p>
<p class="Pp">Example request to download the newest perl:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  $req = HTTP::Request-&gt;new(GET =&gt; &quot;cpan:src/latest.tar.gz&quot;);
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="OVERVIEW_OF_CLASSES_AND_PACKAGES"><a class="permalink" href="#OVERVIEW_OF_CLASSES_AND_PACKAGES">OVERVIEW
  OF CLASSES AND PACKAGES</a></h1>
This table should give you a quick overview of the classes provided by the
  library. Indentation shows class inheritance.
<p class="Pp"><span class="Li"></span></p>
<pre>
 LWP::MemberMixin   -- Access to member variables of Perl5 classes
   LWP::UserAgent   -- WWW user agent class
     LWP::RobotUA   -- When developing a robot applications
   LWP::Protocol          -- Interface to various protocol schemes
     LWP::Protocol::http  -- http:// access
     LWP::Protocol::file  -- file:// access
     LWP::Protocol::ftp   -- ftp:// access
     ...

 LWP::Authen::Basic -- Handle 401 and 407 responses
 LWP::Authen::Digest

 HTTP::Headers      -- MIME/RFC822 style header (used by HTTP::Message)
 HTTP::Message      -- HTTP style message
   HTTP::Request    -- HTTP request
   HTTP::Response   -- HTTP response
 HTTP::Daemon       -- A HTTP server class

 WWW::RobotRules    -- Parse robots.txt files
   WWW::RobotRules::AnyDBM_File -- Persistent RobotRules

 Net::HTTP          -- Low level HTTP client
</pre>
<p class="Pp">The following modules provide various functions and
  definitions.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
 LWP                -- This file.  Library version number and documentation.
 LWP::MediaTypes    -- MIME types configuration (text/html etc.)
 LWP::Simple        -- Simplified procedural interface for common functions
 HTTP::Status       -- HTTP status code (200 OK etc)
 HTTP::Date         -- Date parsing module for HTTP date formats
 HTTP::Negotiate    -- HTTP content negotiation calculation
 File::Listing      -- Parse directory listings
 HTML::Form         -- Processing for &lt;form&gt;s in HTML documents
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="MORE_DOCUMENTATION"><a class="permalink" href="#MORE_DOCUMENTATION">MORE
  DOCUMENTATION</a></h1>
All modules contain detailed information on the interfaces they provide. The
  lwpcook manpage is the libwww-perl cookbook that contain examples of typical
  usage of the library. You might want to take a look at how the scripts
  lwp-request, lwp-download, lwp-dump and lwp-mirror are implemented.
</section>
<section class="Sh">
<h1 class="Sh" id="ENVIRONMENT"><a class="permalink" href="#ENVIRONMENT">ENVIRONMENT</a></h1>
The following environment variables are used by LWP:
<dl class="Bl-tag">
  <dt>HOME</dt>
  <dd>The <span class="Li">&quot;LWP::MediaTypes&quot;</span> functions will
      look for the <i>.media.types</i> and <i>.mime.types</i> files relative to
      you home directory.</dd>
  <dt>http_proxy</dt>
  <dd></dd>
  <dt>ftp_proxy</dt>
  <dd></dd>
  <dt>xxx_proxy</dt>
  <dd></dd>
  <dt>no_proxy</dt>
  <dd>These environment variables can be set to enable communication through a
      proxy server. See the description of the
      <span class="Li">&quot;env_proxy&quot;</span> method in
    LWP::UserAgent.</dd>
  <dt>PERL_LWP_ENV_PROXY</dt>
  <dd>If set to a TRUE value, then the
      <span class="Li">&quot;LWP::UserAgent&quot;</span> will by default call
      <span class="Li">&quot;env_proxy&quot;</span> during initialization. This
      makes LWP honor the proxy variables described above.</dd>
  <dt>PERL_LWP_SSL_VERIFY_HOSTNAME</dt>
  <dd>The default <span class="Li">&quot;verify_hostname&quot;</span> setting
      for <span class="Li">&quot;LWP::UserAgent&quot;</span>. If not set the
      default will be 1. Set it as 0 to disable hostname verification (the
      default prior to libwww-perl 5.840.</dd>
  <dt>PERL_LWP_SSL_CA_FILE</dt>
  <dd></dd>
  <dt>PERL_LWP_SSL_CA_PATH</dt>
  <dd>The file and/or directory where the trusted Certificate Authority
      certificates is located. See LWP::UserAgent for details.</dd>
  <dt>PERL_HTTP_URI_CLASS</dt>
  <dd>Used to decide what URI objects to instantiate. The default is
      <span class="Li">&quot;URI&quot;</span>. You might want to set it to
      <span class="Li">&quot;URI::URL&quot;</span> for compatibility with old
      times.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHORS"><a class="permalink" href="#AUTHORS">AUTHORS</a></h1>
LWP was made possible by contributions from Adam Newby, Albert Dvornik,
  Alexandre Duret-Lutz, Andreas Gustafsson, Andreas Koenig, Andrew Pimlott, Andy
  Lester, Ben Coleman, Benjamin Low, Ben Low, Ben Tilly, Blair Zajac, Bob
  Dalgleish, BooK, Brad Hughes, Brian J. Murrell, Brian McCauley, Charles C. Fu,
  Charles Lane, Chris Nandor, Christian Gilmore, Chris W. Unger, Craig
  Macdonald, Dale Couch, Dan Kubb, Dave Dunkin, Dave W. Smith, David Coppit,
  David Dick, David D. Kilzer, Doug MacEachern, Edward Avis, erik, Gary Shea,
  Gisle Aas, Graham Barr, Gurusamy Sarathy, Hans de Graaff, Harald Joerg, Harry
  Bochner, Hugo, Ilya Zakharevich, INOUE Yoshinari, Ivan Panchenko, Jack
  Shirazi, James Tillman, Jan Dubois, Jared Rhine, Jim Stern, Joao Lopes, John
  Klar, Johnny Lee, Josh Kronengold, Josh Rai, Joshua Chamas, Joshua Hoblitt,
  Kartik Subbarao, Keiichiro Nagano, Ken Williams, KONISHI Katsuhiro, Lee T
  Lindley, Liam Quinn, Marc Hedlund, Marc Langheinrich, Mark D. Anderson, Marko
  Asplund, Mark Stosberg, Markus B Krueger, Markus Laker, Martijn Koster, Martin
  Thurn, Matthew Eldridge, Matthew.van.Eerde, Matt Sergeant, Michael A. Chase,
  Michael Quaranta, Michael Thompson, Mike Schilli, Moshe Kaminsky, Nathan
  Torkington, Nicolai Langfeldt, Norton Allen, Olly Betts, Paul J. Schinder,
  peterm, Philip GuentherDaniel Buenzli, Pon Hwa Lin, Radoslaw Zielinski, Radu
  Greab, Randal L. Schwartz, Richard Chen, Robin Barker, Roy Fielding, Sander
  van Zoest, Sean M. Burke, shildreth, Slaven Rezic, Steve A Fink, Steve Hay,
  Steven Butler, Steve_Kilbane, Takanori Ugai, Thomas Lotterer, Tim Bunce, Tom
  Hughes, Tony Finch, Ville Skyttae, Ward Vandewege, William York, Yale Huang,
  and Yitzchak Scott-Thoennes.
<p class="Pp">LWP owes a lot in motivation, design, and code, to the libwww-perl
    library for Perl4 by Roy Fielding, which included work from Alberto
    Accomazzi, James Casey, Brooks Cutter, Martijn Koster, Oscar Nierstrasz, Mel
    Melchner, Gertjan van Oosten, Jared Rhine, Jack Shirazi, Gene Spafford, Marc
    VanHeyningen, Steven E. Brenner, Marion Hakanson, Waldemar Kebsch, Tony
    Sanders, and Larry Wall; see the libwww-perl-0.40 library for details.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT"><a class="permalink" href="#COPYRIGHT">COPYRIGHT</a></h1>
<span class="Li"></span>
<pre>
  Copyright 1995-2009, Gisle Aas
  Copyright 1995, Martijn Koster
</pre>
<p class="Pp">This library is free software; you can redistribute it and/or
    modify it under the same terms as Perl itself.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AVAILABILITY"><a class="permalink" href="#AVAILABILITY">AVAILABILITY</a></h1>
The latest version of this library is likely to be available from CPAN as well
  as:
<p class="Pp"><span class="Li"></span></p>
<pre>
  http://github.com/libwww-perl/libwww-perl
</pre>
<p class="Pp">The best place to discuss this code is on the
    &lt;libwww@perl.org&gt; mailing list.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2013-03-11</td>
    <td class="foot-os">perl v5.18.4</td>
  </tr>
</table>
</body>
</html>
