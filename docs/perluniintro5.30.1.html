<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>PERLUNIINTRO(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">PERLUNIINTRO(1)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">PERLUNIINTRO(1)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
perluniintro - Perl Unicode introduction
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
This document gives a general idea of Unicode and how to use Unicode in Perl.
  See &quot;Further Resources&quot; for references to more in-depth treatments
  of Unicode.
<section class="Ss">
<h2 class="Ss" id="Unicode"><a class="permalink" href="#Unicode">Unicode</a></h2>
Unicode is a character set standard which plans to codify all of the writing
  systems of the world, plus many other symbols.
<p class="Pp">Unicode and ISO/IEC 10646 are coordinated standards that unify
    almost all other modern character set standards, covering more than 80
    writing systems and hundreds of languages, including all
    commercially-important modern languages. All characters in the largest
    Chinese, Japanese, and Korean dictionaries are also encoded. The standards
    will eventually cover almost all characters in more than 250 writing systems
    and thousands of languages. Unicode 1.0 was released in October 1991, and
    6.0 in October 2010.</p>
<p class="Pp">A Unicode <i>character</i> is an abstract entity. It is not bound
    to any particular integer width, especially not to the C language
    <span class="Li">&quot;char&quot;</span>. Unicode is language-neutral and
    display-neutral: it does not encode the language of the text, and it does
    not generally define fonts or other graphical layout details. Unicode
    operates on characters and on text built from those characters.</p>
<p class="Pp">Unicode defines characters like <span class="Li">&quot;LATIN
    CAPITAL LETTER A&quot;</span> or <span class="Li">&quot;GREEK</span>
    <span class="Li">SMALL LETTER ALPHA&quot;</span> and unique numbers for the
    characters, in this case 0x0041 and 0x03B1, respectively. These unique
    numbers are called <i>code points</i>. A code point is essentially the
    position of the character within the set of all possible Unicode characters,
    and thus in Perl, the term <i>ordinal</i> is often used interchangeably with
    it.</p>
<p class="Pp">The Unicode standard prefers using hexadecimal notation for the
    code points. If numbers like <span class="Li">0x0041</span> are unfamiliar
    to you, take a peek at a later section, &quot;Hexadecimal Notation&quot;.
    The Unicode standard uses the notation <span class="Li">&quot;U+0041 LATIN
    CAPITAL LETTER A&quot;</span>, to give the hexadecimal code point and the
    normative name of the character.</p>
<p class="Pp">Unicode also defines various <i>properties</i> for the characters,
    like &quot;uppercase&quot; or &quot;lowercase&quot;, &quot;decimal
    digit&quot;, or &quot;punctuation&quot;; these properties are independent of
    the names of the characters. Furthermore, various operations on the
    characters like uppercasing, lowercasing, and collating (sorting) are
    defined.</p>
<p class="Pp">A Unicode <i>logical</i> &quot;character&quot; can actually
    consist of more than one internal <i>actual</i> &quot;character&quot; or
    code point. For Western languages, this is adequately modelled by a <i>base
    character</i> (like <span class="Li">&quot;LATIN CAPITAL LETTER
    A&quot;</span>) followed by one or more <i>modifiers</i> (like
    <span class="Li">&quot;COMBINING ACUTE ACCENT&quot;</span>). This sequence
    of base character and modifiers is called a <i>combining character</i>
    <i>sequence</i>. Some non-western languages require more complicated models,
    so Unicode created the <i>grapheme cluster</i> concept, which was later
    further refined into the <i>extended grapheme cluster</i>. For example, a
    Korean Hangul syllable is considered a single logical character, but most
    often consists of three actual Unicode characters: a leading consonant
    followed by an interior vowel followed by a trailing consonant.</p>
<p class="Pp">Whether to call these extended grapheme clusters
    &quot;characters&quot; depends on your point of view. If you are a
    programmer, you probably would tend towards seeing each element in the
    sequences as one unit, or &quot;character&quot;. However from the user's
    point of view, the whole sequence could be seen as one &quot;character&quot;
    since that's probably what it looks like in the context of the user's
    language. In this document, we take the programmer's point of view: one
    &quot;character&quot; is one Unicode code point.</p>
<p class="Pp">For some combinations of base character and modifiers, there are
    <i>precomposed</i> characters. There is a single character equivalent, for
    example, for the sequence <span class="Li">&quot;LATIN CAPITAL LETTER
    A&quot;</span> followed by <span class="Li">&quot;COMBINING ACUTE
    ACCENT&quot;</span>. It is called <span class="Li">&quot;LATIN CAPITAL
    LETTER A WITH</span> <span class="Li">ACUTE&quot;</span>. These precomposed
    characters are, however, only available for some combinations, and are
    mainly meant to support round-trip conversions between Unicode and legacy
    standards (like ISO 8859). Using sequences, as Unicode does, allows for
    needing fewer basic building blocks (code points) to express many more
    potential grapheme clusters. To support conversion between equivalent forms,
    various <i>normalization</i> <i>forms</i> are also defined. Thus,
    <span class="Li">&quot;LATIN CAPITAL LETTER A WITH ACUTE&quot;</span> is in
    <i>Normalization Form Composed</i>, (abbreviated NFC), and the sequence
    <span class="Li">&quot;LATIN CAPITAL LETTER A&quot;</span> followed by
    <span class="Li">&quot;COMBINING ACUTE ACCENT&quot;</span> represents the
    same character in <i>Normalization Form Decomposed</i> (NFD).</p>
<p class="Pp">Because of backward compatibility with legacy encodings, the
    &quot;a unique number for every character&quot; idea breaks down a bit:
    instead, there is &quot;at least one number for every character&quot;. The
    same character could be represented differently in several legacy encodings.
    The converse is not true: some code points do not have an assigned
    character. Firstly, there are unallocated code points within otherwise used
    blocks. Secondly, there are special Unicode control characters that do not
    represent true characters.</p>
<p class="Pp">When Unicode was first conceived, it was thought that all the
    world's characters could be represented using a 16-bit word; that is a
    maximum of <span class="Li">0x10000</span> (or 65,536) characters would be
    needed, from <span class="Li">0x0000</span> to
    <span class="Li">0xFFFF</span>. This soon proved to be wrong, and since
    Unicode 2.0 (July 1996), Unicode has been defined all the way up to 21 bits
    (<span class="Li">0x10FFFF</span>), and Unicode 3.1 (March 2001) defined the
    first characters above <span class="Li">0xFFFF</span>. The first
    <span class="Li">0x10000</span> characters are called the <i>Plane 0</i>, or
    the <i>Basic Multilingual Plane</i> (BMP). With Unicode 3.1, 17 (yes,
    seventeen) planes in all were defined--but they are nowhere near full of
    defined characters, yet.</p>
<p class="Pp">When a new language is being encoded, Unicode generally will
    choose a <span class="Li">&quot;block&quot;</span> of consecutive
    unallocated code points for its characters. So far, the number of code
    points in these blocks has always been evenly divisible by 16. Extras in a
    block, not currently needed, are left unallocated, for future growth. But
    there have been occasions when a later release needed more code points than
    the available extras, and a new block had to allocated somewhere else, not
    contiguous to the initial one, to handle the overflow. Thus, it became
    apparent early on that &quot;block&quot; wasn't an adequate organizing
    principle, and so the <span class="Li">&quot;Script&quot;</span> property
    was created. (Later an improved script property was added as well, the
    <span class="Li">&quot;Script_Extensions&quot;</span> property.) Those code
    points that are in overflow blocks can still have the same script as the
    original ones. The script concept fits more closely with natural language:
    there is <span class="Li">&quot;Latin&quot;</span> script,
    <span class="Li">&quot;Greek&quot;</span> script, and so on; and there are
    several artificial scripts, like <span class="Li">&quot;Common&quot;</span>
    for characters that are used in multiple scripts, such as mathematical
    symbols. Scripts usually span varied parts of several blocks. For more
    information about scripts, see &quot;Scripts&quot; in perlunicode. The
    division into blocks exists, but it is almost completely accidental--an
    artifact of how the characters have been and still are allocated. (Note that
    this paragraph has oversimplified things for the sake of this being an
    introduction. Unicode doesn't really encode languages, but the writing
    systems for them--their scripts; and one script can be used by many
    languages. Unicode also encodes things that aren't really about languages,
    such as symbols like <span class="Li">&quot;BAGGAGE CLAIM&quot;</span>.)</p>
<p class="Pp">The Unicode code points are just abstract numbers. To input and
    output these abstract numbers, the numbers must be <i>encoded</i> or
    <i>serialised</i> somehow. Unicode defines several <i>character encoding</i>
    <i>forms</i>, of which <i>UTF-8</i> is the most popular. UTF-8 is a variable
    length encoding that encodes Unicode characters as 1 to 4 bytes. Other
    encodings include UTF-16 and UTF-32 and their big- and little-endian
    variants (UTF-8 is byte-order independent). The ISO/IEC 10646 defines the
    UCS-2 and UCS-4 encoding forms.</p>
<p class="Pp">For more information about encodings--for instance, to learn what
    <i>surrogates</i> and <i>byte order marks</i> (BOMs) are--see
  perlunicode.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Perl's_Unicode_Support"><a class="permalink" href="#Perl's_Unicode_Support">Perl's
  Unicode Support</a></h2>
Starting from Perl v5.6.0, Perl has had the capacity to handle Unicode natively.
  Perl v5.8.0, however, is the first recommended release for serious Unicode
  work. The maintenance release 5.6.1 fixed many of the problems of the initial
  Unicode implementation, but for example regular expressions still do not work
  with Unicode in 5.6.1. Perl v5.14.0 is the first release where Unicode support
  is (almost) seamlessly integrable without some gotchas. (There are a few
  exceptions. Firstly, some differences in quotemeta were fixed starting in Perl
  5.16.0. Secondly, some differences in the range operator were fixed starting
  in Perl 5.26.0. Thirdly, some differences in split were fixed started in Perl
  5.28.0.)
<p class="Pp">To enable this seamless support, you should
    <span class="Li">&quot;use feature 'unicode_strings'&quot;</span> (which is
    automatically selected if you <span class="Li">&quot;use 5.012&quot;</span>
    or higher). See feature. (5.14 also fixes a number of bugs and departures
    from the Unicode standard.)</p>
<p class="Pp">Before Perl v5.8.0, the use of <span class="Li">&quot;use
    utf8&quot;</span> was used to declare that operations in the current block
    or file would be Unicode-aware. This model was found to be wrong, or at
    least clumsy: the &quot;Unicodeness&quot; is now carried with the data,
    instead of being attached to the operations. Starting with Perl v5.8.0, only
    one case remains where an explicit <span class="Li">&quot;use</span>
    <span class="Li">utf8&quot;</span> is needed: if your Perl script itself is
    encoded in UTF-8, you can use UTF-8 in your identifier names, and in string
    and regular expression literals, by saying <span class="Li">&quot;use
    utf8&quot;</span>. This is not the default because scripts with legacy 8-bit
    data in them would break. See utf8.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Perl's_Unicode_Model"><a class="permalink" href="#Perl's_Unicode_Model">Perl's
  Unicode Model</a></h2>
Perl supports both pre-5.6 strings of eight-bit native bytes, and strings of
  Unicode characters. The general principle is that Perl tries to keep its data
  as eight-bit bytes for as long as possible, but as soon as Unicodeness cannot
  be avoided, the data is transparently upgraded to Unicode. Prior to Perl
  v5.14.0, the upgrade was not completely transparent (see &quot;The
  &quot;Unicode Bug&quot;&quot; in perlunicode), and for backwards
  compatibility, full transparency is not gained unless
  <span class="Li">&quot;use feature</span>
  <span class="Li">'unicode_strings'&quot;</span> (see feature) or
  <span class="Li">&quot;use 5.012&quot;</span> (or higher) is selected.
<p class="Pp">Internally, Perl currently uses either whatever the native
    eight-bit character set of the platform (for example Latin-1) is, defaulting
    to UTF-8, to encode Unicode strings. Specifically, if all code points in the
    string are <span class="Li">0xFF</span> or less, Perl uses the native
    eight-bit character set. Otherwise, it uses UTF-8.</p>
<p class="Pp">A user of Perl does not normally need to know nor care how Perl
    happens to encode its internal strings, but it becomes relevant when
    outputting Unicode strings to a stream without a PerlIO layer (one with the
    &quot;default&quot; encoding). In such a case, the raw bytes used internally
    (the native character set or UTF-8, as appropriate for each string) will be
    used, and a &quot;Wide character&quot; warning will be issued if those
    strings contain a character beyond 0x00FF.</p>
<p class="Pp">For example,</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
      perl -e 'print &quot;\x{DF}\n&quot;, &quot;\x{0100}\x{DF}\n&quot;'
</pre>
<p class="Pp">produces a fairly useless mixture of native bytes and UTF-8, as
    well as a warning:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
     Wide character in print at ...
</pre>
<p class="Pp">To output UTF-8, use the
    <span class="Li">&quot;:encoding&quot;</span> or
    <span class="Li">&quot;:utf8&quot;</span> output layer. Prepending</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
      binmode(STDOUT, &quot;:utf8&quot;);
</pre>
<p class="Pp">to this sample program ensures that the output is completely
    UTF-8, and removes the program's warning.</p>
<p class="Pp">You can enable automatic UTF-8-ification of your standard file
    handles, default <span class="Li">&quot;open()&quot;</span> layer, and
    <span class="Li">@ARGV</span> by using either the
    <span class="Li">&quot;-C&quot;</span> command line switch or the
    <span class="Li">&quot;PERL_UNICODE&quot;</span> environment variable, see
    perlrun for the documentation of the <span class="Li">&quot;-C&quot;</span>
    switch.</p>
<p class="Pp">Note that this means that Perl expects other software to work the
    same way: if Perl has been led to believe that STDIN should be UTF-8, but
    then STDIN coming in from another command is not UTF-8, Perl will likely
    complain about the malformed UTF-8.</p>
<p class="Pp">All features that combine Unicode and I/O also require using the
    new PerlIO feature. Almost all Perl 5.8 platforms do use PerlIO, though: you
    can see whether yours is by running &quot;perl -V&quot; and looking for
    <span class="Li">&quot;useperlio=define&quot;</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Unicode_and__s-1EBCDIC_s0"><a class="permalink" href="#Unicode_and__s-1EBCDIC_s0">Unicode
  and EBCDIC</a></h2>
Perl 5.8.0 added support for Unicode on EBCDIC platforms. This support was
  allowed to lapse in later releases, but was revived in 5.22. Unicode support
  is somewhat more complex to implement since additional conversions are needed.
  See perlebcdic for more information.
<p class="Pp">On EBCDIC platforms, the internal Unicode encoding form is
    UTF-EBCDIC instead of UTF-8. The difference is that as UTF-8 is
    &quot;ASCII-safe&quot; in that ASCII characters encode to UTF-8 as-is, while
    UTF-EBCDIC is &quot;EBCDIC-safe&quot;, in that all the basic characters
    (which includes all those that have ASCII equivalents (like
    <span class="Li">&quot;A&quot;</span>,
    <span class="Li">&quot;0&quot;</span>,
    <span class="Li">&quot;%&quot;</span>, <i>etc.</i>) are the same in both
    EBCDIC and UTF-EBCDIC. Often, documentation will use the term
    &quot;UTF-8&quot; to mean UTF-EBCDIC as well. This is the case in this
    document.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Creating_Unicode"><a class="permalink" href="#Creating_Unicode">Creating
  Unicode</a></h2>
This section applies fully to Perls starting with v5.22. Various caveats for
  earlier releases are in the &quot;Earlier releases caveats&quot; subsection
  below.
<p class="Pp">To create Unicode characters in literals, use the
    <span class="Li">&quot;\N{...}&quot;</span> notation in double-quoted
    strings:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
 my $smiley_from_name = &quot;\N{WHITE SMILING FACE}&quot;;
 my $smiley_from_code_point = &quot;\N{U+263a}&quot;;
</pre>
<p class="Pp">Similarly, they can be used in regular expression literals</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
 $smiley =~ /\N{WHITE SMILING FACE}/;
 $smiley =~ /\N{U+263a}/;
</pre>
<p class="Pp">At run-time you can use:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
 use charnames ();
 my $hebrew_alef_from_name
                      = charnames::string_vianame(&quot;HEBREW LETTER ALEF&quot;);
 my $hebrew_alef_from_code_point = charnames::string_vianame(&quot;U+05D0&quot;);
</pre>
<p class="Pp">Naturally, <span class="Li">&quot;ord()&quot;</span> will do the
    reverse: it turns a character into a code point.</p>
<p class="Pp">There are other runtime options as well. You can use
    <span class="Li">&quot;pack()&quot;</span>:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
 my $hebrew_alef_from_code_point = pack(&quot;U&quot;, 0x05d0);
</pre>
<p class="Pp">Or you can use <span class="Li">&quot;chr()&quot;</span>, though
    it is less convenient in the general case:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
 $hebrew_alef_from_code_point = chr(utf8::unicode_to_native(0x05d0));
 utf8::upgrade($hebrew_alef_from_code_point);
</pre>
<p class="Pp">The <span class="Li">&quot;utf8::unicode_to_native()&quot;</span>
    and <span class="Li">&quot;utf8::upgrade()&quot;</span> aren't needed if the
    argument is above 0xFF, so the above could have been written as</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
 $hebrew_alef_from_code_point = chr(0x05d0);
</pre>
<p class="Pp">since 0x5d0 is above 255.</p>
<p class="Pp"><span class="Li">&quot;\x{}&quot;</span> and
    <span class="Li">&quot;\o{}&quot;</span> can also be used to specify code
    points at compile time in double-quotish strings, but, for backward
    compatibility with older Perls, the same rules apply as with
    <span class="Li">&quot;chr()&quot;</span> for code points less than 256.</p>
<p class="Pp"><span class="Li">&quot;utf8::unicode_to_native()&quot;</span> is
    used so that the Perl code is portable to EBCDIC platforms. You can omit it
    if you're <i>really</i> sure no one will ever want to use your code on a
    non-ASCII platform. Starting in Perl v5.22, calls to it on ASCII platforms
    are optimized out, so there's no performance penalty at all in adding it. Or
    you can simply use the other constructs that don't require it.</p>
<p class="Pp">See &quot;Further Resources&quot; for how to find all these names
    and numeric codes.</p>
<p class="Pp"><i>Earlier releases caveats</i></p>
<p class="Pp">On EBCDIC platforms, prior to v5.22, using
    <span class="Li">&quot;\N{U+...}&quot;</span> doesn't work properly.</p>
<p class="Pp">Prior to v5.16, using <span class="Li">&quot;\N{...}&quot;</span>
    with a character name (as opposed to a
    <span class="Li">&quot;U+...&quot;</span> code point) required a
    <span class="Li">&quot;use&#x00A0;charnames&#x00A0;:full&quot;</span>.</p>
<p class="Pp">Prior to v5.14, there were some bugs in
    <span class="Li">&quot;\N{...}&quot;</span> with a character name (as
    opposed to a <span class="Li">&quot;U+...&quot;</span> code point).</p>
<p class="Pp"><span class="Li">&quot;charnames::string_vianame()&quot;</span>
    was introduced in v5.14. Prior to that,
    <span class="Li">&quot;charnames::vianame()&quot;</span> should work, but
    only if the argument is of the form
    <span class="Li">&quot;U+...&quot;</span>. Your best bet there for runtime
    Unicode by character name is probably:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
 use charnames ();
 my $hebrew_alef_from_name
                  = pack(&quot;U&quot;, charnames::vianame(&quot;HEBREW LETTER ALEF&quot;));
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Handling_Unicode"><a class="permalink" href="#Handling_Unicode">Handling
  Unicode</a></h2>
Handling Unicode is for the most part transparent: just use the strings as
  usual. Functions like <span class="Li">&quot;index()&quot;</span>,
  <span class="Li">&quot;length()&quot;</span>, and
  <span class="Li">&quot;substr()&quot;</span> will work on the Unicode
  characters; regular expressions will work on the Unicode characters (see
  perlunicode and perlretut).
<p class="Pp">Note that Perl considers grapheme clusters to be separate
    characters, so for example</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
 print length(&quot;\N{LATIN CAPITAL LETTER A}\N{COMBINING ACUTE ACCENT}&quot;),
       &quot;\n&quot;;
</pre>
<p class="Pp">will print 2, not 1. The only exception is that regular
    expressions have <span class="Li">&quot;\X&quot;</span> for matching an
    extended grapheme cluster. (Thus <span class="Li">&quot;\X&quot;</span> in a
    regular expression would match the entire sequence of both the example
    characters.)</p>
<p class="Pp">Life is not quite so transparent, however, when working with
    legacy encodings, I/O, and certain special cases:</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Legacy_Encodings"><a class="permalink" href="#Legacy_Encodings">Legacy
  Encodings</a></h2>
When you combine legacy data and Unicode, the legacy data needs to be upgraded
  to Unicode. Normally the legacy data is assumed to be ISO 8859-1 (or EBCDIC,
  if applicable).
<p class="Pp">The <span class="Li">&quot;Encode&quot;</span> module knows about
    many encodings and has interfaces for doing conversions between those
    encodings:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    use Encode 'decode';
    $data = decode(&quot;iso-8859-3&quot;, $data); # convert from legacy
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Unicode_I/O"><a class="permalink" href="#Unicode_I/O">Unicode
  I/O</a></h2>
Normally, writing out Unicode data
<p class="Pp"><span class="Li"></span></p>
<pre>
    print FH $some_string_with_unicode, &quot;\n&quot;;
</pre>
<p class="Pp">produces raw bytes that Perl happens to use to internally encode
    the Unicode string. Perl's internal encoding depends on the system as well
    as what characters happen to be in the string at the time. If any of the
    characters are at code points <span class="Li">0x100</span> or above, you
    will get a warning. To ensure that the output is explicitly rendered in the
    encoding you desire--and to avoid the warning--open the stream with the
    desired encoding. Some examples:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    open FH, &quot;&gt;:utf8&quot;, &quot;file&quot;;

    open FH, &quot;&gt;:encoding(ucs2)&quot;,      &quot;file&quot;;
    open FH, &quot;&gt;:encoding(UTF-8)&quot;,     &quot;file&quot;;
    open FH, &quot;&gt;:encoding(shift_jis)&quot;, &quot;file&quot;;
</pre>
<p class="Pp">and on already open streams, use
    <span class="Li">&quot;binmode()&quot;</span>:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    binmode(STDOUT, &quot;:utf8&quot;);

    binmode(STDOUT, &quot;:encoding(ucs2)&quot;);
    binmode(STDOUT, &quot;:encoding(UTF-8)&quot;);
    binmode(STDOUT, &quot;:encoding(shift_jis)&quot;);
</pre>
<p class="Pp">The matching of encoding names is loose: case does not matter, and
    many encodings have several aliases. Note that the
    <span class="Li">&quot;:utf8&quot;</span> layer must always be specified
    exactly like that; it is <i>not</i> subject to the loose matching of
    encoding names. Also note that currently
    <span class="Li">&quot;:utf8&quot;</span> is unsafe for input, because it
    accepts the data without validating that it is indeed valid UTF-8; you
    should instead use <span class="Li">&quot;:encoding(UTF-8)&quot;</span>
    (with or without a hyphen).</p>
<p class="Pp">See PerlIO for the <span class="Li">&quot;:utf8&quot;</span>
    layer, PerlIO::encoding and Encode::PerlIO for the
    <span class="Li">&quot;:encoding()&quot;</span> layer, and Encode::Supported
    for many encodings supported by the
    <span class="Li">&quot;Encode&quot;</span> module.</p>
<p class="Pp">Reading in a file that you know happens to be encoded in one of
    the Unicode or legacy encodings does not magically turn the data into
    Unicode in Perl's eyes. To do that, specify the appropriate layer when
    opening files</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    open(my $fh,'&lt;:encoding(UTF-8)', 'anything');
    my $line_of_unicode = &lt;$fh&gt;;

    open(my $fh,'&lt;:encoding(Big5)', 'anything');
    my $line_of_unicode = &lt;$fh&gt;;
</pre>
<p class="Pp">The I/O layers can also be specified more flexibly with the
    <span class="Li">&quot;open&quot;</span> pragma. See open, or look at the
    following example.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    use open ':encoding(UTF-8)'; # input/output default encoding will be
                                 # UTF-8
    open X, &quot;&gt;file&quot;;
    print X chr(0x100), &quot;\n&quot;;
    close X;
    open Y, &quot;&lt;file&quot;;
    printf &quot;%#x\n&quot;, ord(&lt;Y&gt;); # this should print 0x100
    close Y;
</pre>
<p class="Pp">With the <span class="Li">&quot;open&quot;</span> pragma you can
    use the <span class="Li">&quot;:locale&quot;</span> layer</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    BEGIN { $ENV{LC_ALL} = $ENV{LANG} = 'ru_RU.KOI8-R' }
    # the :locale will probe the locale environment variables like
    # LC_ALL
    use open OUT =&gt; ':locale'; # russki parusski
    open(O, &quot;&gt;koi8&quot;);
    print O chr(0x430); # Unicode CYRILLIC SMALL LETTER A = KOI8-R 0xc1
    close O;
    open(I, &quot;&lt;koi8&quot;);
    printf &quot;%#x\n&quot;, ord(&lt;I&gt;), &quot;\n&quot;; # this should print 0xc1
    close I;
</pre>
<p class="Pp">These methods install a transparent filter on the I/O stream that
    converts data from the specified encoding when it is read in from the
    stream. The result is always Unicode.</p>
<p class="Pp">The open pragma affects all the
    <span class="Li">&quot;open()&quot;</span> calls after the pragma by setting
    default layers. If you want to affect only certain streams, use explicit
    layers directly in the <span class="Li">&quot;open()&quot;</span> call.</p>
<p class="Pp">You can switch encodings on an already opened stream by using
    <span class="Li">&quot;binmode()&quot;</span>; see &quot;binmode&quot; in
    perlfunc.</p>
<p class="Pp">The <span class="Li">&quot;:locale&quot;</span> does not currently
    work with <span class="Li">&quot;open()&quot;</span> and
    <span class="Li">&quot;binmode()&quot;</span>, only with the
    <span class="Li">&quot;open&quot;</span> pragma. The
    <span class="Li">&quot;:utf8&quot;</span> and
    <span class="Li">&quot;:encoding(...)&quot;</span> methods do work with all
    of <span class="Li">&quot;open()&quot;</span>,
    <span class="Li">&quot;binmode()&quot;</span>, and the
    <span class="Li">&quot;open&quot;</span> pragma.</p>
<p class="Pp">Similarly, you may use these I/O layers on output streams to
    automatically convert Unicode to the specified encoding when it is written
    to the stream. For example, the following snippet copies the contents of the
    file &quot;text.jis&quot; (encoded as ISO-2022-JP, aka JIS) to the file
    &quot;text.utf8&quot;, encoded as UTF-8:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    open(my $nihongo, '&lt;:encoding(iso-2022-jp)', 'text.jis');
    open(my $unicode, '&gt;:utf8',                  'text.utf8');
    while (&lt;$nihongo&gt;) { print $unicode $_ }
</pre>
<p class="Pp">The naming of encodings, both by the
    <span class="Li">&quot;open()&quot;</span> and by the
    <span class="Li">&quot;open&quot;</span> pragma allows for flexible names:
    <span class="Li">&quot;koi8-r&quot;</span> and
    <span class="Li">&quot;KOI8R&quot;</span> will both be understood.</p>
<p class="Pp">Common encodings recognized by ISO, MIME, IANA, and various other
    standardisation organisations are recognised; for a more detailed list see
    Encode::Supported.</p>
<p class="Pp"><span class="Li">&quot;read()&quot;</span> reads characters and
    returns the number of characters. <span class="Li">&quot;seek()&quot;</span>
    and <span class="Li">&quot;tell()&quot;</span> operate on byte counts, as
    does <span class="Li">&quot;sysseek()&quot;</span>.</p>
<p class="Pp"><span class="Li">&quot;sysread()&quot;</span> and
    <span class="Li">&quot;syswrite()&quot;</span> should not be used on file
    handles with character encoding layers, they behave badly, and that
    behaviour has been deprecated since perl 5.24.</p>
<p class="Pp">Notice that because of the default behaviour of not doing any
    conversion upon input if there is no default layer, it is easy to mistakenly
    write code that keeps on expanding a file by repeatedly encoding the
  data:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    # BAD CODE WARNING
    open F, &quot;file&quot;;
    local $/; ## read in the whole file of 8-bit characters
    $t = &lt;F&gt;;
    close F;
    open F, &quot;&gt;:encoding(UTF-8)&quot;, &quot;file&quot;;
    print F $t; ## convert to UTF-8 on output
    close F;
</pre>
<p class="Pp">If you run this code twice, the contents of the <i>file</i> will
    be twice UTF-8 encoded. A <span class="Li">&quot;use open
    ':encoding(UTF-8)'&quot;</span> would have avoided the bug, or explicitly
    opening also the <i>file</i> for input as UTF-8.</p>
<p class="Pp"><b>NOTE</b>: the <span class="Li">&quot;:utf8&quot;</span> and
    <span class="Li">&quot;:encoding&quot;</span> features work only if your
    Perl has been built with PerlIO, which is the default on most systems.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Displaying_Unicode_As_Text"><a class="permalink" href="#Displaying_Unicode_As_Text">Displaying
  Unicode As Text</a></h2>
Sometimes you might want to display Perl scalars containing Unicode as simple
  ASCII (or EBCDIC) text. The following subroutine converts its argument so that
  Unicode characters with code points greater than 255 are displayed as
  <span class="Li">&quot;\x{...}&quot;</span>, control characters (like
  <span class="Li">&quot;\n&quot;</span>) are displayed as
  <span class="Li">&quot;\x..&quot;</span>, and the rest of the characters as
  themselves:
<p class="Pp"><span class="Li"></span></p>
<pre>
 sub nice_string {
        join(&quot;&quot;,
        map { $_ &gt; 255                    # if wide character...
              ? sprintf(&quot;\\x{%04X}&quot;, $_)  # \x{...}
              : chr($_) =~ /[[:cntrl:]]/  # else if control character...
                ? sprintf(&quot;\\x%02X&quot;, $_)  # \x..
                : quotemeta(chr($_))      # else quoted or as themselves
        } unpack(&quot;W*&quot;, $_[0]));           # unpack Unicode characters
   }
</pre>
<p class="Pp">For example,</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
   nice_string(&quot;foo\x{100}bar\n&quot;)
</pre>
<p class="Pp">returns the string</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
   'foo\x{0100}bar\x0A'
</pre>
<p class="Pp">which is ready to be printed.</p>
<p class="Pp">(<span class="Li">&quot;\\x{}&quot;</span> is used here instead of
    <span class="Li">&quot;\\N{}&quot;</span>, since it's most likely that you
    want to see what the native values are.)</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Special_Cases"><a class="permalink" href="#Special_Cases">Special
  Cases</a></h2>
<ul class="Bl-bullet">
  <li>Starting in Perl 5.28, it is illegal for bit operators, like
      <span class="Li">&quot;~&quot;</span>, to operate on strings containing
      code points above 255.</li>
  <li>The <b>vec()</b> function may produce surprising results if used on
      strings containing characters with ordinal values above 255. In such a
      case, the results are consistent with the internal encoding of the
      characters, but not with much else. So don't do that, and starting in Perl
      5.28, a deprecation message is issued if you do so, becoming illegal in
      Perl 5.32.</li>
  <li>Peeking At Perl's Internal Encoding
    <p class="Pp">Normal users of Perl should never care how Perl encodes any
        particular Unicode string (because the normal ways to get at the
        contents of a string with Unicode--via input and output--should always
        be via explicitly-defined I/O layers). But if you must, there are two
        ways of looking behind the scenes.</p>
    <p class="Pp">One way of peeking inside the internal encoding of Unicode
        characters is to use <span class="Li">&quot;unpack(&quot;C*&quot;,
        ...&quot;</span> to get the bytes of whatever the string encoding
        happens to be, or <span class="Li">&quot;unpack(&quot;U0..&quot;,
        ...)&quot;</span> to get the bytes of the UTF-8 encoding:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    # this prints  c4 80  for the UTF-8 bytes 0xc4 0x80
    print join(&quot; &quot;, unpack(&quot;U0(H2)*&quot;, pack(&quot;U&quot;, 0x100))), &quot;\n&quot;;
    </pre>
    <p class="Pp">Yet another way would be to use the Devel::Peek module:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    perl -MDevel::Peek -e 'Dump(chr(0x100))'
    </pre>
    <p class="Pp">That shows the <span class="Li">&quot;UTF8&quot;</span> flag
        in FLAGS and both the UTF-8 bytes and Unicode characters in
        <span class="Li">&quot;PV&quot;</span>. See also later in this document
        the discussion about the
        <span class="Li">&quot;utf8::is_utf8()&quot;</span> function.</p>
  </li>
</ul>
</section>
<section class="Ss">
<h2 class="Ss" id="Advanced_Topics"><a class="permalink" href="#Advanced_Topics">Advanced
  Topics</a></h2>
<ul class="Bl-bullet">
  <li>String Equivalence
    <p class="Pp">The question of string equivalence turns somewhat complicated
        in Unicode: what do you mean by &quot;equal&quot;?</p>
    <p class="Pp">(Is <span class="Li">&quot;LATIN CAPITAL LETTER A WITH
        ACUTE&quot;</span> equal to <span class="Li">&quot;LATIN CAPITAL LETTER
        A&quot;</span>?)</p>
    <p class="Pp">The short answer is that by default Perl compares equivalence
        (<span class="Li">&quot;eq&quot;</span>,
        <span class="Li">&quot;ne&quot;</span>) based only on code points of the
        characters. In the above case, the answer is no (because 0x00C1 !=
        0x0041). But sometimes, any CAPITAL LETTER A's should be considered
        equal, or even A's of any case.</p>
    <p class="Pp">The long answer is that you need to consider character
        normalization and casing issues: see Unicode::Normalize, Unicode
        Technical Report #15, Unicode Normalization Forms
        &lt;http://www.unicode.org/unicode/reports/tr15&gt; and sections on case
        mapping in the Unicode Standard &lt;http://www.unicode.org&gt;.</p>
    <p class="Pp">As of Perl 5.8.0, the &quot;Full&quot; case-folding of
        <i>Case</i> <i>Mappings/SpecialCasing</i> is implemented, but bugs
        remain in <span class="Li">&quot;qr//i&quot;</span> with them, mostly
        fixed by 5.14, and essentially entirely by 5.18.</p>
  </li>
  <li>String Collation
    <p class="Pp">People like to see their strings nicely sorted--or as Unicode
        parlance goes, collated. But again, what do you mean by collate?</p>
    <p class="Pp">(Does <span class="Li">&quot;LATIN CAPITAL LETTER A WITH
        ACUTE&quot;</span> come before or after <span class="Li">&quot;LATIN
        CAPITAL LETTER A WITH GRAVE&quot;</span>?)</p>
    <p class="Pp">The short answer is that by default, Perl compares strings
        (<span class="Li">&quot;lt&quot;</span>,
        <span class="Li">&quot;le&quot;</span>,
        <span class="Li">&quot;cmp&quot;</span>,
        <span class="Li">&quot;ge&quot;</span>,
        <span class="Li">&quot;gt&quot;</span>) based only on the code points of
        the characters. In the above case, the answer is &quot;after&quot;,
        since <span class="Li">0x00C1</span> &gt;
        <span class="Li">0x00C0</span>.</p>
    <p class="Pp">The long answer is that &quot;it depends&quot;, and a good
        answer cannot be given without knowing (at the very least) the language
        context. See Unicode::Collate, and <i>Unicode Collation Algorithm</i>
        &lt;http://www.unicode.org/unicode/reports/tr10/&gt;</p>
  </li>
</ul>
</section>
<section class="Ss">
<h2 class="Ss" id="Miscellaneous"><a class="permalink" href="#Miscellaneous">Miscellaneous</a></h2>
<ul class="Bl-bullet">
  <li>Character Ranges and Classes
    <p class="Pp">Character ranges in regular expression bracketed character
        classes ( e.g., <span class="Li">&quot;/[a-z]/&quot;</span>) and in the
        <span class="Li">&quot;tr///&quot;</span> (also known as
        <span class="Li">&quot;y///&quot;</span>) operator are not magically
        Unicode-aware. What this means is that
        <span class="Li">&quot;[A-Za-z]&quot;</span> will not magically start to
        mean &quot;all alphabetic letters&quot; (not that it does mean that even
        for 8-bit characters; for those, if you are using locales (perllocale),
        use <span class="Li">&quot;/[[:alpha:]]/&quot;</span>; and if not, use
        the 8-bit-aware property
      <span class="Li">&quot;\p{alpha}&quot;</span>).</p>
    <p class="Pp">All the properties that begin with
        <span class="Li">&quot;\p&quot;</span> (and its inverse
        <span class="Li">&quot;\P&quot;</span>) are actually character classes
        that are Unicode-aware. There are dozens of them, see perluniprops.</p>
    <p class="Pp">Starting in v5.22, you can use Unicode code points as the end
        points of regular expression pattern character ranges, and the range
        will include all Unicode code points that lie between those end points,
        inclusive.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
 qr/ [ \N{U+03} - \N{U+20} ] /xx
    </pre>
    <p class="Pp">includes the code points
        <span class="Li">&quot;\N{U+03}&quot;</span>,
        <span class="Li">&quot;\N{U+04}&quot;</span>, ...,
        <span class="Li">&quot;\N{U+20}&quot;</span>.</p>
    <p class="Pp">This also works for ranges in
        <span class="Li">&quot;tr///&quot;</span> starting in Perl v5.24.</p>
  </li>
  <li>String-To-Number Conversions
    <p class="Pp">Unicode does define several other decimal--and
        numeric--characters besides the familiar 0 to 9, such as the Arabic and
        Indic digits. Perl does not support string-to-number conversion for
        digits other than ASCII <span class="Li">0</span> to
        <span class="Li">9</span> (and ASCII
        <span class="Li">&quot;a&quot;</span> to
        <span class="Li">&quot;f&quot;</span> for hexadecimal). To get safe
        conversions from any Unicode string, use &quot;<b>num()</b>&quot; in
        Unicode::UCD.</p>
  </li>
</ul>
</section>
<section class="Ss">
<h2 class="Ss" id="Questions_With_Answers"><a class="permalink" href="#Questions_With_Answers">Questions
  With Answers</a></h2>
<ul class="Bl-bullet">
  <li>Will My Old Scripts Break?
    <p class="Pp">Very probably not. Unless you are generating Unicode
        characters somehow, old behaviour should be preserved. About the only
        behaviour that has changed and which could start generating Unicode is
        the old behaviour of <span class="Li">&quot;chr()&quot;</span> where
        supplying an argument more than 255 produced a character modulo 255.
        <span class="Li">&quot;chr(300)&quot;</span>, for example, was equal to
        <span class="Li">&quot;chr(45)&quot;</span> or &quot;-&quot; (in ASCII),
        now it is LATIN CAPITAL LETTER I WITH BREVE.</p>
  </li>
  <li>How Do I Make My Scripts Work With Unicode?
    <p class="Pp">Very little work should be needed since nothing changes until
        you generate Unicode data. The most important thing is getting input as
        Unicode; for that, see the earlier I/O discussion. To get full seamless
        Unicode support, add <span class="Li">&quot;use feature
        'unicode_strings'&quot;</span> (or <span class="Li">&quot;use
        5.012&quot;</span> or higher) to your script.</p>
  </li>
  <li>How Do I Know Whether My String Is In Unicode?
    <p class="Pp">You shouldn't have to care. But you may if your Perl is before
        5.14.0 or you haven't specified <span class="Li">&quot;use feature
        'unicode_strings'&quot;</span> or <span class="Li">&quot;use</span>
        <span class="Li">5.012&quot;</span> (or higher) because otherwise the
        rules for the code points in the range 128 to 255 are different
        depending on whether the string they are contained within is in Unicode
        or not. (See &quot;When Unicode Does Not Happen&quot; in
      perlunicode.)</p>
    <p class="Pp">To determine if a string is in Unicode, use:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    print utf8::is_utf8($string) ? 1 : 0, &quot;\n&quot;;
    </pre>
    <p class="Pp">But note that this doesn't mean that any of the characters in
        the string are necessary UTF-8 encoded, or that any of the characters
        have code points greater than 0xFF (255) or even 0x80 (128), or that the
        string has any characters at all. All the
        <span class="Li">&quot;is_utf8()&quot;</span> does is to return the
        value of the internal &quot;utf8ness&quot; flag attached to the
        <span class="Li">$string</span>. If the flag is off, the bytes in the
        scalar are interpreted as a single byte encoding. If the flag is on, the
        bytes in the scalar are interpreted as the (variable-length, potentially
        multi-byte) UTF-8 encoded code points of the characters. Bytes added to
        a UTF-8 encoded string are automatically upgraded to UTF-8. If mixed
        non-UTF-8 and UTF-8 scalars are merged (double-quoted interpolation,
        explicit concatenation, or printf/sprintf parameter substitution), the
        result will be UTF-8 encoded as if copies of the byte strings were
        upgraded to UTF-8: for example,</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    $a = &quot;ab\x80c&quot;;
    $b = &quot;\x{100}&quot;;
    print &quot;$a = $b\n&quot;;
    </pre>
    <p class="Pp">the output string will be UTF-8-encoded
        <span class="Li">&quot;ab\x80c = \x{100}\n&quot;</span>, but
        <span class="Li">$a</span> will stay byte-encoded.</p>
    <p class="Pp">Sometimes you might really need to know the byte length of a
        string instead of the character length. For that use the
        <span class="Li">&quot;bytes&quot;</span> pragma and the
        <span class="Li">&quot;length()&quot;</span> function:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    my $unicode = chr(0x100);
    print length($unicode), &quot;\n&quot;; # will print 1
    use bytes;
    print length($unicode), &quot;\n&quot;; # will print 2
                                  # (the 0xC4 0x80 of the UTF-8)
    no bytes;
    </pre>
  </li>
  <li>How Do I Find Out What Encoding a File Has?
    <p class="Pp">You might try Encode::Guess, but it has a number of
        limitations.</p>
  </li>
  <li>How Do I Detect Data That's Not Valid In a Particular Encoding?
    <p class="Pp">Use the <span class="Li">&quot;Encode&quot;</span> package to
        try converting it. For example,</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    use Encode 'decode';

    if (eval { decode('UTF-8', $string, Encode::FB_CROAK); 1 }) {
        # $string is valid UTF-8
    } else {
        # $string is not valid UTF-8
    }
    </pre>
    <p class="Pp">Or use <span class="Li">&quot;unpack&quot;</span> to try
        decoding it:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    use warnings;
    @chars = unpack(&quot;C0U*&quot;, $string_of_bytes_that_I_think_is_utf8);
    </pre>
    <p class="Pp">If invalid, a <span class="Li">&quot;Malformed UTF-8
        character&quot;</span> warning is produced. The &quot;C0&quot; means
        &quot;process the string character per character&quot;. Without that,
        the <span class="Li">&quot;unpack(&quot;U*&quot;, ...)&quot;</span>
        would work in <span class="Li">&quot;U0&quot;</span> mode (the default
        if the format string starts with <span class="Li">&quot;U&quot;</span>)
        and it would return the bytes making up the UTF-8 encoding of the target
        string, something that will always work.</p>
  </li>
  <li>How Do I Convert Binary Data Into a Particular Encoding, Or Vice Versa?
    <p class="Pp">This probably isn't as useful as you might think. Normally,
        you shouldn't need to.</p>
    <p class="Pp">In one sense, what you are asking doesn't make much sense:
        encodings are for characters, and binary data are not
        &quot;characters&quot;, so converting &quot;data&quot; into some
        encoding isn't meaningful unless you know in what character set and
        encoding the binary data is in, in which case it's not just binary data,
        now is it?</p>
    <p class="Pp">If you have a raw sequence of bytes that you know should be
        interpreted via a particular encoding, you can use
        <span class="Li">&quot;Encode&quot;</span>:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    use Encode 'from_to';
    from_to($data, &quot;iso-8859-1&quot;, &quot;UTF-8&quot;); # from latin-1 to UTF-8
    </pre>
    <p class="Pp">The call to <span class="Li">&quot;from_to()&quot;</span>
        changes the bytes in <span class="Li">$data</span>, but nothing material
        about the nature of the string has changed as far as Perl is concerned.
        Both before and after the call, the string <span class="Li">$data</span>
        contains just a bunch of 8-bit bytes. As far as Perl is concerned, the
        encoding of the string remains as &quot;system-native 8-bit
      bytes&quot;.</p>
    <p class="Pp">You might relate this to a fictional 'Translate' module:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
   use Translate;
   my $phrase = &quot;Yes&quot;;
   Translate::from_to($phrase, 'english', 'deutsch');
   ## phrase now contains &quot;Ja&quot;
    </pre>
    <p class="Pp">The contents of the string changes, but not the nature of the
        string. Perl doesn't know any more after the call than before that the
        contents of the string indicates the affirmative.</p>
    <p class="Pp">Back to converting data. If you have (or want) data in your
        system's native 8-bit encoding (e.g. Latin-1, EBCDIC, etc.), you can use
        pack/unpack to convert to/from Unicode.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    $native_string  = pack(&quot;W*&quot;, unpack(&quot;U*&quot;, $Unicode_string));
    $Unicode_string = pack(&quot;U*&quot;, unpack(&quot;W*&quot;, $native_string));
    </pre>
    <p class="Pp">If you have a sequence of bytes you <b>know</b> is valid
        UTF-8, but Perl doesn't know it yet, you can make Perl a believer,
      too:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    $Unicode = $bytes;
    utf8::decode($Unicode);
    </pre>
    <p class="Pp">or:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    $Unicode = pack(&quot;U0a*&quot;, $bytes);
    </pre>
    <p class="Pp">You can find the bytes that make up a UTF-8 sequence with</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    @bytes = unpack(&quot;C*&quot;, $Unicode_string)
    </pre>
    <p class="Pp">and you can create well-formed Unicode with</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    $Unicode_string = pack(&quot;U*&quot;, 0xff, ...)
    </pre>
  </li>
  <li>How Do I Display Unicode? How Do I Input Unicode?
    <p class="Pp">See &lt;http://www.alanwood.net/unicode/&gt; and
        &lt;http://www.cl.cam.ac.uk/~mgk25/unicode.html&gt;</p>
  </li>
  <li>How Does Unicode Work With Traditional Locales?
    <p class="Pp">If your locale is a UTF-8 locale, starting in Perl v5.26, Perl
        works well for all categories; before this, starting with Perl v5.20, it
        works for all categories but
        <span class="Li">&quot;LC_COLLATE&quot;</span>, which deals with sorting
        and the <span class="Li">&quot;cmp&quot;</span> operator. But note that
        the standard <span class="Li">&quot;Unicode::Collate&quot;</span> and
        <span class="Li">&quot;Unicode::Collate::Locale&quot;</span> modules
        offer much more powerful solutions to collation issues, and work on
        earlier releases.</p>
    <p class="Pp">For other locales, starting in Perl 5.16, you can specify</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    use locale ':not_characters';
    </pre>
    <p class="Pp">to get Perl to work well with them. The catch is that you have
        to translate from the locale character set to/from Unicode yourself. See
        &quot;Unicode I/O&quot; above for how to</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    use open ':locale';
    </pre>
    <p class="Pp">to accomplish this, but full details are in &quot;Unicode and
        UTF-8&quot; in perllocale, including gotchas that happen if you don't
        specify <span class="Li">&quot;:not_characters&quot;</span>.</p>
  </li>
</ul>
</section>
<section class="Ss">
<h2 class="Ss" id="Hexadecimal_Notation"><a class="permalink" href="#Hexadecimal_Notation">Hexadecimal
  Notation</a></h2>
The Unicode standard prefers using hexadecimal notation because that more
  clearly shows the division of Unicode into blocks of 256 characters.
  Hexadecimal is also simply shorter than decimal. You can use decimal notation,
  too, but learning to use hexadecimal just makes life easier with the Unicode
  standard. The <span class="Li">&quot;U+HHHH&quot;</span> notation uses
  hexadecimal, for example.
<p class="Pp">The <span class="Li">&quot;0x&quot;</span> prefix means a
    hexadecimal number, the digits are 0-9 <i>and</i> a-f (or A-F, case doesn't
    matter). Each hexadecimal digit represents four bits, or half a byte.
    <span class="Li">&quot;print 0x..., &quot;\n&quot;&quot;</span> will show a
    hexadecimal number in decimal, and <span class="Li">&quot;printf
    &quot;%x\n&quot;, $decimal&quot;</span> will show a decimal number in
    hexadecimal. If you have just the &quot;hex digits&quot; of a hexadecimal
    number, you can use the <span class="Li">&quot;hex()&quot;</span>
  function.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    print 0x0009, &quot;\n&quot;;    # 9
    print 0x000a, &quot;\n&quot;;    # 10
    print 0x000f, &quot;\n&quot;;    # 15
    print 0x0010, &quot;\n&quot;;    # 16
    print 0x0011, &quot;\n&quot;;    # 17
    print 0x0100, &quot;\n&quot;;    # 256

    print 0x0041, &quot;\n&quot;;    # 65

    printf &quot;%x\n&quot;,  65;    # 41
    printf &quot;%#x\n&quot;, 65;    # 0x41

    print hex(&quot;41&quot;), &quot;\n&quot;; # 65
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Further_Resources"><a class="permalink" href="#Further_Resources">Further
  Resources</a></h2>
<ul class="Bl-bullet">
  <li>Unicode Consortium
    <p class="Pp">&lt;http://www.unicode.org/&gt;</p>
  </li>
  <li>Unicode FAQ
    <p class="Pp">&lt;http://www.unicode.org/unicode/faq/&gt;</p>
  </li>
  <li>Unicode Glossary
    <p class="Pp">&lt;http://www.unicode.org/glossary/&gt;</p>
  </li>
  <li>Unicode Recommended Reading List
    <p class="Pp">The Unicode Consortium has a list of articles and books, some
        of which give a much more in depth treatment of Unicode:
        &lt;http://unicode.org/resources/readinglist.html&gt;</p>
  </li>
  <li>Unicode Useful Resources
    <p class="Pp">&lt;http://www.unicode.org/unicode/onlinedat/resources.html&gt;</p>
  </li>
  <li>Unicode and Multilingual Support in HTML, Fonts, Web Browsers and Other
      Applications
    <p class="Pp">&lt;http://www.alanwood.net/unicode/&gt;</p>
  </li>
  <li>UTF-8 and Unicode FAQ for Unix/Linux
    <p class="Pp">&lt;http://www.cl.cam.ac.uk/~mgk25/unicode.html&gt;</p>
  </li>
  <li>Legacy Character Sets
    <p class="Pp">&lt;http://www.czyborra.com/&gt;
        &lt;http://www.eki.ee/letter/&gt;</p>
  </li>
  <li>You can explore various information from the Unicode data files using the
      <span class="Li">&quot;Unicode::UCD&quot;</span> module.</li>
</ul>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="UNICODE_IN_OLDER_PERLS"><a class="permalink" href="#UNICODE_IN_OLDER_PERLS">UNICODE
  IN OLDER PERLS</a></h1>
If you cannot upgrade your Perl to 5.8.0 or later, you can still do some Unicode
  processing by using the modules
  <span class="Li">&quot;Unicode::String&quot;</span>,
  <span class="Li">&quot;Unicode::Map8&quot;</span>, and
  <span class="Li">&quot;Unicode::Map&quot;</span>, available from CPAN. If you
  have the GNU recode installed, you can also use the Perl front-end
  <span class="Li">&quot;Convert::Recode&quot;</span> for character conversions.
<p class="Pp">The following are fast conversions from ISO 8859-1 (Latin-1) bytes
    to UTF-8 bytes and back, the code works even with older Perl 5 versions.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    # ISO 8859-1 to UTF-8
    s/([\x80-\xFF])/chr(0xC0|ord($1)&gt;&gt;6).chr(0x80|ord($1)&amp;0x3F)/eg;

    # UTF-8 to ISO 8859-1
    s/([\xC2\xC3])([\x80-\xBF])/chr(ord($1)&lt;&lt;6&amp;0xC0|ord($2)&amp;0x3F)/eg;
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
perlunitut, perlunicode, Encode, open, utf8, bytes, perlretut, perlrun,
  Unicode::Collate, Unicode::Normalize, Unicode::UCD
</section>
<section class="Sh">
<h1 class="Sh" id="ACKNOWLEDGMENTS"><a class="permalink" href="#ACKNOWLEDGMENTS">ACKNOWLEDGMENTS</a></h1>
Thanks to the kind readers of the perl5-porters@perl.org, perl-unicode@perl.org,
  linux-utf8@nl.linux.org, and unicore@unicode.org mailing lists for their
  valuable feedback.
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR,_COPYRIGHT,_AND_LICENSE"><a class="permalink" href="#AUTHOR,_COPYRIGHT,_AND_LICENSE">AUTHOR,
  COPYRIGHT, AND LICENSE</a></h1>
Copyright 2001-2011 Jarkko Hietaniemi &lt;jhi@iki.fi&gt;. Now maintained by Perl
  5 Porters.
<p class="Pp">This document may be distributed under the same terms as Perl
    itself.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2019-10-24</td>
    <td class="foot-os">perl v5.30.2</td>
  </tr>
</table>
</body>
</html>
