<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    .Nd, .Bf, .Op { display: inline; }
    .Pa, .Ad { font-style: italic; }
    .Ms { font-weight: bold; }
    .Bl-diag > dt { font-weight: bold; }
    code.Nm, .Fl, .Cm, .Ic, code.In, .Fd, .Fn, .Cd { font-weight: bold;
      font-family: inherit; }
  </style>
  <title>DBD::SQLite::Fulltext_search(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">DBD::SQLite::Fulltext_search(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">DBD::SQLite::Fulltext_search(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">DBD::SQLite::Fulltext_search - Using fulltext searches with
    DBD::SQLite</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<section class="Ss">
<h2 class="Ss" id="Introduction"><a class="permalink" href="#Introduction">Introduction</a></h2>
<p class="Pp">SQLite is bundled with an extension module called &quot;FTS&quot;
    for full-text indexing. Tables with this feature enabled can be efficiently
    queried to find rows that contain one or more instances of some specified
    words (also called &quot;tokens&quot;), in any column, even if the table
    contains many large documents.</p>
<p class="Pp">The first full-text search modules for SQLite were called
    <span class="Li">&quot;FTS1&quot;</span> and
    <span class="Li">&quot;FTS2&quot;</span> and are now obsolete. The latest
    version is <span class="Li">&quot;FTS4&quot;</span>, but it shares many
    features with the former module <span class="Li">&quot;FTS3&quot;</span>,
    which is why parts of the API and parts of the documentation still refer to
    <span class="Li">&quot;FTS3&quot;</span>; from a client point of view, both
    can be considered largely equivalent. Detailed documentation can be found at
    &lt;http://www.sqlite.org/fts3.html&gt;.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Short_example"><a class="permalink" href="#Short_example">Short
  example</a></h2>
<p class="Pp">Here is a very short example of using FTS :</p>
<p class="Pp"></p>
<pre>  $dbh-&gt;do(&lt;&lt;&quot;&quot;) or die DBI::errstr;
  CREATE VIRTUAL TABLE fts_example USING fts4(content)
  
  my $sth = $dbh-&gt;prepare(&quot;INSERT INTO fts_example(content) VALUES (?)&quot;);
  $sth-&gt;execute($_) foreach @docs_to_insert;
  
  my $results = $dbh-&gt;selectall_arrayref(&lt;&lt;&quot;&quot;);
  SELECT docid, snippet(fts_example) FROM fts_example WHERE content MATCH 'foo'
</pre>
<p class="Pp">The key points in this example are :</p>
<ul class="Bl-bullet">
  <li>The syntax for creating FTS tables is
    <p class="Pp"></p>
    <pre>  CREATE VIRTUAL TABLE &lt;table_name&gt; USING fts4(&lt;columns&gt;)
    </pre>
    <p class="Pp">where <span class="Li">&quot;&lt;columns&gt;&quot;</span> is a
        list of column names. Columns may be typed, but the type information is
        ignored. If no columns are specified, the default is a single column
        named <span class="Li">&quot;content&quot;</span>. In addition, FTS
        tables have an implicit column called
        <span class="Li">&quot;docid&quot;</span> (or also
        <span class="Li">&quot;rowid&quot;</span>) for numbering the stored
        documents.</p>
  </li>
  <li>Statements for inserting, updating or deleting records use the same syntax
      as for regular SQLite tables.</li>
  <li>Full-text searches are specified with the
      <span class="Li">&quot;MATCH&quot;</span> operator, and an operand which
      may be a single word, a word prefix ending with '*', a list of words, a
      &quot;phrase query&quot; in double quotes, or a boolean combination of the
      above.</li>
  <li>The builtin function <span class="Li">&quot;snippet(...)&quot;</span>
      builds a formatted excerpt of the document text, where the words
      pertaining to the query are highlighted.</li>
</ul>
<p class="Pp">There are many more details to building and searching FTS tables,
    so we strongly invite you to read the full documentation at
    &lt;http://www.sqlite.org/fts3.html&gt;.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="QUERY_SYNTAX"><a class="permalink" href="#QUERY_SYNTAX">QUERY
  SYNTAX</a></h1>
<p class="Pp">Here are some explanation about FTS queries, borrowed from the
    sqlite documentation.</p>
<section class="Ss">
<h2 class="Ss" id="Token_or_token_prefix_queries"><a class="permalink" href="#Token_or_token_prefix_queries">Token
  or token prefix queries</a></h2>
<p class="Pp">An FTS table may be queried for all documents that contain a
    specified term, or for all documents that contain a term with a specified
    prefix. The query expression for a specific term is simply the term itself.
    The query expression used to search for a term prefix is the prefix itself
    with a '*' character appended to it. For example:</p>
<p class="Pp"></p>
<pre>  -- Virtual table declaration
  CREATE VIRTUAL TABLE docs USING fts3(title, body);
  
  -- Query for all documents containing the term &quot;linux&quot;:
  SELECT * FROM docs WHERE docs MATCH 'linux';
  
  -- Query for all documents containing a term with the prefix &quot;lin&quot;.
  SELECT * FROM docs WHERE docs MATCH 'lin*';
</pre>
<p class="Pp">If a search token (on the right-hand side of the MATCH operator)
    begins with &quot;^&quot; then that token must be the first in its field of
    the document : so for example <span class="Li">&quot;^lin*&quot;</span>
    matches 'linux kernel changes ...' but does not match 'new linux
    implementation'.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Column_specifications"><a class="permalink" href="#Column_specifications">Column
  specifications</a></h2>
<p class="Pp">Normally, a token or token prefix query is matched against the FTS
    table column specified as the right-hand side of the MATCH operator. Or, if
    the special column with the same name as the FTS table itself is specified,
    against all columns. This may be overridden by specifying a column-name
    followed by a &quot;:&quot; character before a basic term query. There may
    be space between the &quot;:&quot; and the term to query for, but not
    between the column-name and the &quot;:&quot; character. For example:</p>
<p class="Pp"></p>
<pre>  -- Query the database for documents for which the term &quot;linux&quot; appears in
  -- the document title, and the term &quot;problems&quot; appears in either the title
  -- or body of the document.
  SELECT * FROM docs WHERE docs MATCH 'title:linux problems';
  -- Query the database for documents for which the term &quot;linux&quot; appears in
  -- the document title, and the term &quot;driver&quot; appears in the body of the document
  -- (&quot;driver&quot; may also appear in the title, but this alone will not satisfy the.
  -- query criteria).
  SELECT * FROM docs WHERE body MATCH 'title:linux driver';
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Phrase_queries"><a class="permalink" href="#Phrase_queries">Phrase
  queries</a></h2>
<p class="Pp">A phrase query is a query that retrieves all documents that
    contain a nominated set of terms or term prefixes in a specified order with
    no intervening tokens. Phrase queries are specified by enclosing a space
    separated sequence of terms or term prefixes in double quotes (&quot;). For
    example:</p>
<p class="Pp"></p>
<pre>  -- Query for all documents that contain the phrase &quot;linux applications&quot;.
  SELECT * FROM docs WHERE docs MATCH '&quot;linux applications&quot;';
  -- Query for all documents that contain a phrase that matches &quot;lin* app*&quot;. 
  -- As well as &quot;linux applications&quot;, this will match common phrases such 
  -- as &quot;linoleum appliances&quot; or &quot;link apprentice&quot;.
  SELECT * FROM docs WHERE docs MATCH '&quot;lin* app*&quot;';
</pre>
</section>
<section class="Ss">
<h2 class="Ss">NEAR queries.</h2>
<p class="Pp">A NEAR query is a query that returns documents that contain a two
    or more nominated terms or phrases within a specified proximity of each
    other (by default with 10 or less intervening terms). A NEAR query is
    specified by putting the keyword &quot;NEAR&quot; between two phrase, term
    or prefix queries. To specify a proximity other than the default, an
    operator of the form &quot;NEAR/&lt;N&gt;&quot; may be used, where &lt;N&gt;
    is the maximum number of intervening terms allowed. For example:</p>
<p class="Pp"></p>
<pre>  -- Virtual table declaration.
  CREATE VIRTUAL TABLE docs USING fts4();
  -- Virtual table data.
  INSERT INTO docs VALUES('SQLite is an ACID compliant embedded relational database management system');
  -- Search for a document that contains the terms &quot;sqlite&quot; and &quot;database&quot; with
  -- not more than 10 intervening terms. This matches the only document in
  -- table docs (since there are only six terms between &quot;SQLite&quot; and &quot;database&quot; 
  -- in the document).
  SELECT * FROM docs WHERE docs MATCH 'sqlite NEAR database';
  -- Search for a document that contains the terms &quot;sqlite&quot; and &quot;database&quot; with
  -- not more than 6 intervening terms. This also matches the only document in
  -- table docs. Note that the order in which the terms appear in the document
  -- does not have to be the same as the order in which they appear in the query.
  SELECT * FROM docs WHERE docs MATCH 'database NEAR/6 sqlite';
  -- Search for a document that contains the terms &quot;sqlite&quot; and &quot;database&quot; with
  -- not more than 5 intervening terms. This query matches no documents.
  SELECT * FROM docs WHERE docs MATCH 'database NEAR/5 sqlite';
  -- Search for a document that contains the phrase &quot;ACID compliant&quot; and the term
  -- &quot;database&quot; with not more than 2 terms separating the two. This matches the
  -- document stored in table docs.
  SELECT * FROM docs WHERE docs MATCH 'database NEAR/2 &quot;ACID compliant&quot;';
  -- Search for a document that contains the phrase &quot;ACID compliant&quot; and the term
  -- &quot;sqlite&quot; with not more than 2 terms separating the two. This also matches
  -- the only document stored in table docs.
  SELECT * FROM docs WHERE docs MATCH '&quot;ACID compliant&quot; NEAR/2 sqlite';
</pre>
<p class="Pp">More than one NEAR operator may appear in a single query. In this
    case each pair of terms or phrases separated by a NEAR operator must appear
    within the specified proximity of each other in the document. Using the same
    table and data as in the block of examples above:</p>
<p class="Pp"></p>
<pre>  -- The following query selects documents that contains an instance of the term 
  -- &quot;sqlite&quot; separated by two or fewer terms from an instance of the term &quot;acid&quot;,
  -- which is in turn separated by two or fewer terms from an instance of the term
  -- &quot;relational&quot;.
  SELECT * FROM docs WHERE docs MATCH 'sqlite NEAR/2 acid NEAR/2 relational';
  -- This query matches no documents. There is an instance of the term &quot;sqlite&quot; with
  -- sufficient proximity to an instance of &quot;acid&quot; but it is not sufficiently close
  -- to an instance of the term &quot;relational&quot;.
  SELECT * FROM docs WHERE docs MATCH 'acid NEAR/2 sqlite NEAR/2 relational';
</pre>
<p class="Pp">Phrase and NEAR queries may not span multiple columns within a
    row.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Set_operations"><a class="permalink" href="#Set_operations">Set
  operations</a></h2>
<p class="Pp">The three basic query types described above may be used to query
    the full-text index for the set of documents that match the specified
    criteria. Using the FTS query expression language it is possible to perform
    various set operations on the results of basic queries. There are currently
    three supported operations:</p>
<ul class="Bl-bullet">
  <li>The AND operator determines the intersection of two sets of
    documents.</li>
  <li>The OR operator calculates the union of two sets of documents.</li>
  <li>The NOT operator may be used to compute the relative complement of one set
      of documents with respect to another.</li>
</ul>
<p class="Pp">The AND, OR and NOT binary set operators must be entered using
    capital letters; otherwise, they are interpreted as basic term queries
    instead of set operators. Each of the two operands to an operator may be a
    basic FTS query, or the result of another AND, OR or NOT set operation.
    Parenthesis may be used to control precedence and grouping.</p>
<p class="Pp">The AND operator is implicit for adjacent basic queries without
    any explicit operator. For example, the query expression &quot;implicit
    operator&quot; is a more succinct version of &quot;implicit AND
    operator&quot;.</p>
<p class="Pp">Boolean operations as just described correspond to the so-called
    &quot;enhanced query syntax&quot; of sqlite; this is the version compiled
    with <span class="Li">&quot;DBD::SQLite&quot;</span>, starting from version
    1.31. A former version, called the &quot;standard query syntax&quot;, used
    to support tokens prefixed with '+' or '-' signs (for token inclusion or
    exclusion); if your application needs to support this old syntax, use
    DBD::SQLite::FTS3Transitional (published in a separate distribution) for
    doing the conversion.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="TOKENIZERS"><a class="permalink" href="#TOKENIZERS">TOKENIZERS</a></h1>
<section class="Ss">
<h2 class="Ss" id="Concept"><a class="permalink" href="#Concept">Concept</a></h2>
<p class="Pp">The behaviour of full-text indexes strongly depends on how
    documents are split into <i>tokens</i>; therefore FTS table declarations can
    explicitly specify how to perform tokenization:</p>
<p class="Pp"></p>
<pre>  CREATE ... USING fts4(&lt;columns&gt;, tokenize=&lt;tokenizer&gt;)
</pre>
<p class="Pp">where <span class="Li">&quot;&lt;tokenizer&gt;&quot;</span> is a
    sequence of space-separated words that triggers a specific tokenizer.
    Tokenizers can be SQLite builtins, written in C code, or Perl tokenizers.
    Both are as explained below.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="SQLite_builtin_tokenizers"><a class="permalink" href="#SQLite_builtin_tokenizers">SQLite
  builtin tokenizers</a></h2>
<p class="Pp">SQLite comes with some builtin tokenizers (see
    &lt;http://www.sqlite.org/fts3.html#tokenizer&gt;) :</p>
<dl class="Bl-tag">
  <dt id="simple"><a class="permalink" href="#simple">simple</a></dt>
  <dd>Under the <i>simple</i> tokenizer, a term is a contiguous sequence of
      eligible characters, where eligible characters are all alphanumeric
      characters, the &quot;_&quot; character, and all characters with UTF
      codepoints greater than or equal to 128. All other characters are
      discarded when splitting a document into terms. They serve only to
      separate adjacent terms.
    <p class="Pp">All uppercase characters within the ASCII range (UTF
        codepoints less than 128), are transformed to their lowercase
        equivalents as part of the tokenization process. Thus, full-text queries
        are case-insensitive when using the simple tokenizer.</p>
  </dd>
  <dt id="porter"><a class="permalink" href="#porter">porter</a></dt>
  <dd>The <i>porter</i> tokenizer uses the same rules to separate the input
      document into terms, but as well as folding all terms to lower case it
      uses the Porter Stemming algorithm to reduce related English language
      words to a common root.</dd>
  <dt id="icu"><a class="permalink" href="#icu">icu</a></dt>
  <dd>The <i>icu</i> tokenizer uses the ICU library to decide how to identify
      word characters in different languages; however, this requires SQLite to
      be compiled with the <span class="Li">&quot;SQLITE_ENABLE_ICU&quot;</span>
      pre-processor symbol defined. So, to use this tokenizer, you need edit
      <i>Makefile.PL</i> to add this flag in <span class="Li">@CC_DEFINE</span>,
      and then recompile <span class="Li">&quot;DBD::SQLite&quot;</span>; of
      course, the prerequisite is to have an ICU library available on your
      system.</dd>
  <dt id="unicode61"><a class="permalink" href="#unicode61">unicode61</a></dt>
  <dd>The <i>unicode61</i> tokenizer works very much like &quot;simple&quot;
      except that it does full unicode case folding according to rules in
      Unicode Version 6.1 and it recognizes unicode space and punctuation
      characters and uses those to separate tokens. By contrast, the simple
      tokenizer only does case folding of ASCII characters and only recognizes
      ASCII space and punctuation characters as token separators.
    <p class="Pp">By default, &quot;unicode61&quot; also removes all diacritics
        from Latin script characters. This behaviour can be overridden by adding
        the tokenizer argument
        <span class="Li">&quot;remove_diacritics=0&quot;</span>. For
      example:</p>
    <p class="Pp"></p>
    <pre>  -- Create tables that remove diacritics from Latin script characters
  -- as part of tokenization.
  CREATE VIRTUAL TABLE txt1 USING fts4(tokenize=unicode61);
  CREATE VIRTUAL TABLE txt2 USING fts4(tokenize=unicode61 &quot;remove_diacritics=1&quot;);
  -- Create a table that does not remove diacritics from Latin script
  -- characters as part of tokenization.
  CREATE VIRTUAL TABLE txt3 USING fts4(tokenize=unicode61 &quot;remove_diacritics=0&quot;);
    </pre>
    <p class="Pp">Additional options can customize the set of codepoints that
        unicode61 treats as separator characters or as token characters -- see
        the documentation in
      &lt;http://www.sqlite.org/fts3.html#unicode61&gt;.</p>
  </dd>
</dl>
<p class="Pp">If a more complex tokenizing algorithm is required, for example to
    implement stemming, discard punctuation, or to recognize compound words, use
    the perl tokenizer to implement your own logic, as explained below.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Perl_tokenizers"><a class="permalink" href="#Perl_tokenizers">Perl
  tokenizers</a></h2>
<p class="Pp"><i>Declaring a perl tokenizer</i></p>
<p class="Pp">In addition to the builtin SQLite tokenizers,
    <span class="Li">&quot;DBD::SQLite&quot;</span> implements a <i>perl</i>
    tokenizer, that can hook to any tokenizing algorithm written in Perl. This
    is specified as follows :</p>
<p class="Pp"></p>
<pre>  CREATE ... USING fts4(&lt;columns&gt;, tokenize=perl '&lt;perl_function&gt;')
</pre>
<p class="Pp">where <span class="Li">&quot;&lt;perl_function&gt;&quot;</span> is
    a fully qualified Perl function name (i.e. prefixed by the name of the
    package in which that function is declared). So for example if the function
    is <span class="Li">&quot;my_func&quot;</span> in the main program,
  write</p>
<p class="Pp"></p>
<pre>  CREATE ... USING fts4(&lt;columns&gt;, tokenize=perl 'main::my_func')
</pre>
<p class="Pp"><i>Writing a perl tokenizer by hand</i></p>
<p class="Pp">That function should return a code reference that takes a string
    as single argument, and returns an iterator (another function), which
    returns a tuple <span class="Li">&quot;($term, $len, $start, $end,
    $index)&quot;</span> for each term. Here is a simple example that tokenizes
    on words according to the current perl locale</p>
<p class="Pp"></p>
<pre>  sub locale_tokenizer {
    return sub {
      my $string = shift;
      use locale;
      my $regex      = qr/\w+/;
      my $term_index = 0;
      return sub { # closure
        $string =~ /$regex/g or return; # either match, or no more token
        my ($start, $end) = ($-[0], $+[0]);
        my $len           = $end-$start;
        my $term          = substr($string, $start, $len);
        return ($term, $len, $start, $end, $term_index++);
      }
    };
  }
</pre>
<p class="Pp">There must be three levels of subs, in a kind of &quot;Russian
    dolls&quot; structure, because :</p>
<ul class="Bl-bullet">
  <li>the external, named sub is called whenever accessing a FTS table with that
      tokenizer</li>
  <li>the inner, anonymous sub is called whenever a new string needs to be
      tokenized (either for inserting new text into the table, or for analyzing
      a query).</li>
  <li>the innermost, anonymous sub is called repeatedly for retrieving all terms
      within that string.</li>
</ul>
<p class="Pp"><i>Using Search::Tokenizer</i></p>
<p class="Pp">Instead of writing tokenizers by hand, you can grab one of those
    already implemented in the Search::Tokenizer module. For example, if you
    want ignore differences between accented characters, you can write :</p>
<p class="Pp"></p>
<pre>  use Search::Tokenizer;
  $dbh-&gt;do(&lt;&lt;&quot;&quot;) or die DBI::errstr;
  CREATE ... USING fts4(&lt;columns&gt;, 
                        tokenize=perl 'Search::Tokenizer::unaccent')
</pre>
<p class="Pp">Alternatively, you can use &quot;new&quot; in Search::Tokenizer to
    build your own tokenizer. Here is an example that treats compound words
    (words with an internal dash or dot) as single tokens :</p>
<p class="Pp"></p>
<pre>  sub my_tokenizer {
    return Search::Tokenizer-&gt;new(
      regex =&gt; qr{\p{Word}+(?:[-./]\p{Word}+)*},
     );
  }
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="Fts4aux_"><a class="permalink" href="#Fts4aux_">Fts4aux -
  Direct Access to the Full-Text Index</a></h1>
<p class="Pp">The content of a full-text index can be accessed through the
    virtual table module &quot;fts4aux&quot;. For example, assuming that our
    database contains a full-text indexed table named &quot;ft&quot;, we can
    declare :</p>
<p class="Pp"></p>
<pre>  CREATE VIRTUAL TABLE ft_terms USING fts4aux(ft)
</pre>
<p class="Pp">and then query the <span class="Li">&quot;ft_terms&quot;</span>
    table to access the list of terms, their frequency, etc. Examples are
    documented in &lt;http://www.sqlite.org/fts3.html#fts4aux&gt;.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="How_to_spare_database_space"><a class="permalink" href="#How_to_spare_database_space">How
  to spare database space</a></h1>
<p class="Pp">By default, FTS stores a complete copy of the indexed documents,
    together with the fulltext index. On a large collection of documents, this
    can consume quite a lot of disk space. However, FTS has some options for
    compressing the documents, or even for not storing them at all -- see
    &lt;http://www.sqlite.org/fts3.html#fts4_options&gt;.</p>
<p class="Pp">In particular, the option for <i>contentless FTS tables</i> only
    stores the fulltext index, without the original document content. This is
    specified as <span class="Li">&quot;content=&quot;&quot;&quot;</span>, like
    in the following example :</p>
<p class="Pp"></p>
<pre>  CREATE VIRTUAL TABLE t1 USING fts4(content=&quot;&quot;, a, b)
</pre>
<p class="Pp">Data can be inserted into such an FTS4 table using an INSERT
    statements. However, unlike ordinary FTS4 tables, the user must supply an
    explicit integer docid value. For example:</p>
<p class="Pp"></p>
<pre>  -- This statement is Ok:
  INSERT INTO t1(docid, a, b) VALUES(1, 'a b c', 'd e f');
  -- This statement causes an error, as no docid value has been provided:
  INSERT INTO t1(a, b) VALUES('j k l', 'm n o');
</pre>
<p class="Pp">Of course your application will need an algorithm for finding the
    external resource corresponding to any <i>docid</i> stored within
  SQLite.</p>
<p class="Pp">When using placeholders, the docid must be explicitly typed to
    INTEGER, because this is a &quot;hidden column&quot; for which sqlite is not
    able to automatically infer the proper type. So the following doesn't work
  :</p>
<p class="Pp"></p>
<pre>  my $sth = $dbh-&gt;prepare(&quot;INSERT INTO t1(docid, a, b) VALUES(?, ?, ?)&quot;);
  $sth-&gt;execute(2, 'aa', 'bb'); # constraint error
</pre>
<p class="Pp">but it works with an explicitly cast :</p>
<p class="Pp"></p>
<pre>  my $sql = &quot;INSERT INTO t1(docid, a, b) VALUES(CAST(? AS INTEGER), ?, ?)&quot;,
  my $sth = $dbh-&gt;prepare(sql);
  $sth-&gt;execute(2, 'aa', 'bb');
</pre>
<p class="Pp">or with an explicitly typed &quot;bind_param&quot; in DBI :</p>
<p class="Pp"></p>
<pre>  use DBI qw/SQL_INTEGER/;
  my $sql = &quot;INSERT INTO t1(docid, a, b) VALUES(?, ?, ?)&quot;;
  my $sth = $dbh-&gt;prepare(sql);
  $sth-&gt;bind_param(1, 2, SQL_INTEGER);
  $sth-&gt;bind_param(2, &quot;aa&quot;);
  $sth-&gt;bind_param(3, &quot;bb&quot;);
  $sth-&gt;execute();
</pre>
<p class="Pp">It is not possible to UPDATE or DELETE a row stored in a
    contentless FTS4 table. Attempting to do so is an error.</p>
<p class="Pp">Contentless FTS4 tables also support SELECT statements. However,
    it is an error to attempt to retrieve the value of any table column other
    than the docid column. The auxiliary function
    <span class="Li">&quot;matchinfo()&quot;</span> may be used, but
    <span class="Li">&quot;snippet()&quot;</span> and
    <span class="Li">&quot;offsets()&quot;</span> may not, so if such
    functionality is needed, it has to be directly programmed within the Perl
    application.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">Laurent Dami &lt;dami@cpan.org&gt;</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT"><a class="permalink" href="#COPYRIGHT">COPYRIGHT</a></h1>
<p class="Pp">Copyright 2014 Laurent Dami.</p>
<p class="Pp">Some parts borrowed from the &lt;http://sqlite.org&gt;
    documentation, copyright 2014.</p>
<p class="Pp">This documentation is in the public domain; you can redistribute
    it and/or modify it under the same terms as Perl itself.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2019-05-22</td>
    <td class="foot-os">perl v5.34.0</td>
  </tr>
</table>
</body>
</html>
