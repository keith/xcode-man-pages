<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>DBIx::Class::Storage::DBI::Replicated::Introduction(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">DBIx::Class::Storage::DBI::Replicated::Introduction(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">DBIx::Class::Storage::DBI::Replicated::Introduction(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
DBIx::Class::Storage::DBI::Replicated::Introduction - Minimum Need to Know
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
This is an introductory document for DBIx::Class::Storage::DBI::Replicated.
<p class="Pp">This document is not an overview of what replication is or why you
    should be using it. It is not a document explaining how to setup MySQL
    native replication either. Copious external resources are available for
    both. This document presumes you have the basics down.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
DBIx::Class supports a framework for using database replication. This system is
  integrated completely, which means once it's setup you should be able to
  automatically just start using a replication cluster without additional work
  or changes to your code. Some caveats apply, primarily related to the proper
  use of transactions (you are wrapping all your database modifying statements
  inside a transaction, right ;) ) however in our experience properly written
  DBIC will work transparently with Replicated storage.
<p class="Pp">Currently we have support for MySQL native replication, which is
    relatively easy to install and configure. We also currently support single
    master to one or more replicants (also called 'slaves' in some
    documentation). However the framework is not specifically tied to the MySQL
    framework and supporting other replication systems or topographies should be
    possible. Please bring your patches and ideas to the #dbix-class IRC channel
    or the mailing list.</p>
<p class="Pp">For an easy way to start playing with MySQL native replication,
    see: MySQL::Sandbox.</p>
<p class="Pp">If you are using this with a Catalyst based application, you may
    also want to see more recent updates to Catalyst::Model::DBIC::Schema, which
    has support for replication configuration options as well.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="REPLICATED_STORAGE"><a class="permalink" href="#REPLICATED_STORAGE">REPLICATED
  STORAGE</a></h1>
By default, when you start DBIx::Class, your Schema (DBIx::Class::Schema) is
  assigned a storage_type, which when fully connected will reflect your
  underlying storage engine as defined by your chosen database driver. For
  example, if you connect to a MySQL database, your storage_type will be
  DBIx::Class::Storage::DBI::mysql Your storage type class will contain database
  specific code to help smooth over the differences between databases and let
  DBIx::Class do its thing.
<p class="Pp">If you want to use replication, you will override this setting so
    that the replicated storage engine will 'wrap' your underlying storages and
    present a unified interface to the end programmer. This wrapper storage
    class will delegate method calls to either a master database or one or more
    replicated databases based on if they are read only (by default sent to the
    replicants) or write (reserved for the master). Additionally, the Replicated
    storage will monitor the health of your replicants and automatically drop
    them should one exceed configurable parameters. Later, it can automatically
    restore a replicant when its health is restored.</p>
<p class="Pp">This gives you a very robust system, since you can add or drop
    replicants and DBIC will automatically adjust itself accordingly.</p>
<p class="Pp">Additionally, if you need high data integrity, such as when you
    are executing a transaction, replicated storage will automatically delegate
    all database traffic to the master storage. There are several ways to enable
    this high integrity mode, but wrapping your statements inside a transaction
    is the easy and canonical option.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="PARTS_OF_REPLICATED_STORAGE"><a class="permalink" href="#PARTS_OF_REPLICATED_STORAGE">PARTS
  OF REPLICATED STORAGE</a></h1>
A replicated storage contains several parts. First, there is the replicated
  storage itself (DBIx::Class::Storage::DBI::Replicated). A replicated storage
  takes a pool of replicants (DBIx::Class::Storage::DBI::Replicated::Pool) and a
  software balancer (DBIx::Class::Storage::DBI::Replicated::Balancer). The
  balancer does the job of splitting up all the read traffic amongst the
  replicants in the Pool. Currently there are two types of balancers, a Random
  one which chooses a Replicant in the Pool using a naive randomizer algorithm,
  and a First replicant, which just uses the first one in the Pool (and
  obviously is only of value when you have a single replicant).
</section>
<section class="Sh">
<h1 class="Sh" id="REPLICATED_STORAGE_CONFIGURATION"><a class="permalink" href="#REPLICATED_STORAGE_CONFIGURATION">REPLICATED
  STORAGE CONFIGURATION</a></h1>
All the parts of replication can be altered dynamically at runtime, which makes
  it possibly to create a system that automatically scales under load by
  creating more replicants as needed, perhaps using a cloud system such as
  Amazon EC2. However, for common use you can setup your replicated storage to
  be enabled at the time you connect the databases. The following is a breakdown
  of how you may wish to do this. Again, if you are using Catalyst, I strongly
  recommend you use (or upgrade to) the latest Catalyst::Model::DBIC::Schema,
  which makes this job even easier.
<p class="Pp">First, you need to get a <span class="Li">$schema</span> object
    and set the storage_type:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  my $schema = MyApp::Schema-&gt;clone;
  $schema-&gt;storage_type([
    '::DBI::Replicated' =&gt; {
      balancer_type =&gt; '::Random',
      balancer_args =&gt; {
        auto_validate_every =&gt; 5,
        master_read_weight =&gt; 1
      },
      pool_args =&gt; {
        maximum_lag =&gt;2,
      },
    }
  ]);
</pre>
<p class="Pp">Then, you need to connect your DBIx::Class::Schema.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  $schema-&gt;connection($dsn, $user, $pass);
</pre>
<p class="Pp">Let's break down the settings. The method &quot;storage_type&quot;
    in DBIx::Class::Schema takes one mandatory parameter, a scalar value, and an
    option second value which is a Hash Reference of configuration options for
    that storage. In this case, we are setting the Replicated storage type using
    '::DBI::Replicated' as the first value. You will only use a different value
    if you are subclassing the replicated storage, so for now just copy that
    first parameter.</p>
<p class="Pp">The second parameter contains a hash reference of stuff that gets
    passed to the replicated storage. &quot;balancer_type&quot; in
    DBIx::Class::Storage::DBI::Replicated is the type of software load balancer
    you will use to split up traffic among all your replicants. Right now we
    have two options, &quot;::Random&quot; and &quot;::First&quot;. You can
    review documentation for both at:</p>
<p class="Pp">DBIx::Class::Storage::DBI::Replicated::Balancer::First,
    DBIx::Class::Storage::DBI::Replicated::Balancer::Random.</p>
<p class="Pp">In this case we will have three replicants, so the ::Random option
    is the only one that makes sense.</p>
<p class="Pp">'balancer_args' get passed to the balancer when it's instantiated.
    All balancers have the 'auto_validate_every' option. This is the number of
    seconds we allow to pass between validation checks on a load balanced
    replicant. So the higher the number, the more possibility that your reads to
    the replicant may be inconsistent with what's on the master. Setting this
    number too low will result in increased database loads, so choose a number
    with care. Our experience is that setting the number around 5 seconds
    results in a good performance / integrity balance.</p>
<p class="Pp">'master_read_weight' is an option associated with the ::Random
    balancer. It allows you to let the master be read from. I usually leave this
    off (default is off).</p>
<p class="Pp">The 'pool_args' are configuration options associated with the
    replicant pool. This object (DBIx::Class::Storage::DBI::Replicated::Pool)
    manages all the declared replicants. 'maximum_lag' is the number of seconds
    a replicant is allowed to lag behind the master before being temporarily
    removed from the pool. Keep in mind that the Balancer option
    'auto_validate_every' determines how often a replicant is tested against
    this condition, so the true possible lag can be higher than the number you
    set. The default is zero.</p>
<p class="Pp">No matter how low you set the maximum_lag or the
    auto_validate_every settings, there is always the chance that your
    replicants will lag a bit behind the master for the supported replication
    system built into MySQL. You can ensure reliable reads by using a
    transaction, which will force both read and write activity to the master,
    however this will increase the load on your master database.</p>
<p class="Pp">After you've configured the replicated storage, you need to add
    the connection information for the replicants:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  $schema-&gt;storage-&gt;connect_replicants(
    [$dsn1, $user, $pass, \%opts],
    [$dsn2, $user, $pass, \%opts],
    [$dsn3, $user, $pass, \%opts],
  );
</pre>
<p class="Pp">These replicants should be configured as slaves to the master
    using the instructions for MySQL native replication, or if you are just
    learning, you will find MySQL::Sandbox an easy way to set up a replication
    cluster.</p>
<p class="Pp">And now your <span class="Li">$schema</span> object is properly
    configured! Enjoy!</p>
</section>
<section class="Sh">
<h1 class="Sh" id="FURTHER_QUESTIONS?"><a class="permalink" href="#FURTHER_QUESTIONS?">FURTHER
  QUESTIONS?</a></h1>
Check the list of additional DBIC resources.
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT_AND_LICENSE"><a class="permalink" href="#COPYRIGHT_AND_LICENSE">COPYRIGHT
  AND LICENSE</a></h1>
This module is free software copyright by the DBIx::Class (DBIC) authors. You
  can redistribute it and/or modify it under the same terms as the DBIx::Class
  library.
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2017-12-08</td>
    <td class="foot-os">perl v5.30.2</td>
  </tr>
</table>
</body>
</html>
