<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>YAML::Tiny(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">YAML::Tiny(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">YAML::Tiny(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
YAML::Tiny - Read/Write YAML files with as little code as possible
</section>
<section class="Sh">
<h1 class="Sh" id="VERSION"><a class="permalink" href="#VERSION">VERSION</a></h1>
version 1.73
</section>
<section class="Sh">
<h1 class="Sh" id="PREAMBLE"><a class="permalink" href="#PREAMBLE">PREAMBLE</a></h1>
The YAML specification is huge. Really, <b>really</b> huge. It contains all the
  functionality of XML, except with flexibility and choice, which makes it
  easier to read, but with a formal specification that is more complex than XML.
<p class="Pp">The original pure-Perl implementation YAML costs just over 4
    megabytes of memory to load. Just like with Windows <i>.ini</i> files (3 meg
    to load) and CSS (3.5 meg to load) the situation is just asking for a
    <b>YAML::Tiny</b> module, an incomplete but correct and usable subset of the
    functionality, in as little code as possible.</p>
<p class="Pp">Like the other <span class="Li">&quot;::Tiny&quot;</span> modules,
    YAML::Tiny has no non-core dependencies, does not require a compiler to
    install, is back-compatible to Perl v5.8.1, and can be inlined into other
    modules if needed.</p>
<p class="Pp">In exchange for this adding this extreme flexibility, it provides
    support for only a limited subset of YAML. But the subset supported contains
    most of the features for the more common uses of YAML.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
Assuming <i>file.yml</i> like this:
<p class="Pp"><span class="Li"></span></p>
<pre>
    ---
    rootproperty: blah
    section:
      one: two
      three: four
      Foo: Bar
      empty: ~
</pre>
<p class="Pp">Read and write <i>file.yml</i> like this:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    use YAML::Tiny;

    # Open the config
    my $yaml = YAML::Tiny-&gt;read( 'file.yml' );

    # Get a reference to the first document
    my $config = $yaml-&gt;[0];

    # Or read properties directly
    my $root = $yaml-&gt;[0]-&gt;{rootproperty};
    my $one  = $yaml-&gt;[0]-&gt;{section}-&gt;{one};
    my $Foo  = $yaml-&gt;[0]-&gt;{section}-&gt;{Foo};

    # Change data directly
    $yaml-&gt;[0]-&gt;{newsection} = { this =&gt; 'that' }; # Add a section
    $yaml-&gt;[0]-&gt;{section}-&gt;{Foo} = 'Not Bar!';     # Change a value
    delete $yaml-&gt;[0]-&gt;{section};                  # Delete a value

    # Save the document back to the file
    $yaml-&gt;write( 'file.yml' );
</pre>
<p class="Pp">To create a new YAML file from scratch:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    # Create a new object with a single hashref document
    my $yaml = YAML::Tiny-&gt;new( { wibble =&gt; &quot;wobble&quot; } );

    # Add an arrayref document
    push @$yaml, [ 'foo', 'bar', 'baz' ];

    # Save both documents to a file
    $yaml-&gt;write( 'data.yml' );
</pre>
<p class="Pp">Then <i>data.yml</i> will contain:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    ---
    wibble: wobble
    ---
    - foo
    - bar
    - baz
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<b>YAML::Tiny</b> is a perl class for reading and writing YAML-style files,
  written with as little code as possible, reducing load time and memory
  overhead.
<p class="Pp">Most of the time it is accepted that Perl applications use a lot
    of memory and modules. The <b>::Tiny</b> family of modules is specifically
    intended to provide an ultralight and zero-dependency alternative to many
    more-thorough standard modules.</p>
<p class="Pp">This module is primarily for reading human-written files (like
    simple config files) and generating very simple human-readable files. Note
    that I said <b>human-readable</b> and not <b>geek-readable</b>. The sort of
    files that your average manager or secretary should be able to look at and
    make sense of.</p>
<p class="Pp">YAML::Tiny does not generate comments, it won't necessarily
    preserve the order of your hashes, and it will normalise if reading in and
    writing out again.</p>
<p class="Pp">It only supports a very basic subset of the full YAML
    specification.</p>
<p class="Pp">Usage is targeted at files like Perl's META.yml, for which a small
    and easily-embeddable module is extremely attractive.</p>
<p class="Pp">Features will only be added if they are human readable, and can be
    written in a few lines of code. Please don't be offended if your request is
    refused. Someone has to draw the line, and for YAML::Tiny that someone is
    me.</p>
<p class="Pp">If you need something with more power move up to YAML (7 megabytes
    of memory overhead) or YAML::XS (6 megabytes memory overhead and requires a
    C compiler).</p>
<p class="Pp">To restate, YAML::Tiny does <b>not</b> preserve your comments,
    whitespace, or the order of your YAML data. But it should round-trip from
    Perl structure to file and back again just fine.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="METHODS"><a class="permalink" href="#METHODS">METHODS</a></h1>
<section class="Ss">
<h2 class="Ss" id="new"><a class="permalink" href="#new">new</a></h2>
The constructor <span class="Li">&quot;new&quot;</span> creates a
  <span class="Li">&quot;YAML::Tiny&quot;</span> object as a blessed array
  reference. Any arguments provided are taken as separate documents to be
  serialized.
</section>
<section class="Ss">
<h2 class="Ss" id="read_$filename"><a class="permalink" href="#read_$filename">read
  $filename</a></h2>
The <span class="Li">&quot;read&quot;</span> constructor reads a YAML file from
  a file name, and returns a new <span class="Li">&quot;YAML::Tiny&quot;</span>
  object containing the parsed content.
<p class="Pp">Returns the object on success or throws an error on failure.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="read_string_$string;"><a class="permalink" href="#read_string_$string;">read_string
  $string;</a></h2>
The <span class="Li">&quot;read_string&quot;</span> constructor reads YAML data
  from a character string, and returns a new
  <span class="Li">&quot;YAML::Tiny&quot;</span> object containing the parsed
  content. If you have read the string from a file yourself, be sure that you
  have correctly decoded it into characters first.
<p class="Pp">Returns the object on success or throws an error on failure.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="write_$filename"><a class="permalink" href="#write_$filename">write
  $filename</a></h2>
The <span class="Li">&quot;write&quot;</span> method generates the file content
  for the properties, and writes it to disk using UTF-8 encoding to the filename
  specified.
<p class="Pp">Returns true on success or throws an error on failure.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="write_string"><a class="permalink" href="#write_string">write_string</a></h2>
Generates the file content for the object and returns it as a character string.
  This may contain non-ASCII characters and should be encoded before writing it
  to a file.
<p class="Pp">Returns true on success or throws an error on failure.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="errstr_(_s-1DEPRECATED_s0)"><a class="permalink" href="#errstr_(_s-1DEPRECATED_s0)">errstr
  (DEPRECATED)</a></h2>
Prior to version 1.57, some errors were fatal and others were available only via
  the <span class="Li">$YAML::Tiny::errstr</span> variable, which could be
  accessed via the <span class="Li">&quot;errstr()&quot;</span> method.
<p class="Pp">Starting with version 1.57, all errors are fatal and throw
    exceptions.</p>
<p class="Pp">The <span class="Li">$errstr</span> variable is still set when
    exceptions are thrown, but <span class="Li">$errstr</span> and the
    <span class="Li">&quot;errstr()&quot;</span> method are deprecated and may
    be removed in a future release. The first use of
    <span class="Li">&quot;errstr()&quot;</span> will issue a deprecation
    warning.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="FUNCTIONS"><a class="permalink" href="#FUNCTIONS">FUNCTIONS</a></h1>
YAML::Tiny implements a number of functions to add compatibility with the YAML
  API. These should be a drop-in replacement.
<section class="Ss">
<h2 class="Ss" id="Dump"><a class="permalink" href="#Dump">Dump</a></h2>
<span class="Li"></span>
<pre>
  my $string = Dump(list-of-Perl-data-structures);
</pre>
<p class="Pp">Turn Perl data into YAML. This function works very much like
    <b>Data::Dumper::Dumper()</b>.</p>
<p class="Pp">It takes a list of Perl data structures and dumps them into a
    serialized form.</p>
<p class="Pp">It returns a character string containing the YAML stream. Be sure
    to encode it as UTF-8 before serializing to a file or socket.</p>
<p class="Pp">The structures can be references or plain scalars.</p>
<p class="Pp">Dies on any error.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Load"><a class="permalink" href="#Load">Load</a></h2>
<span class="Li"></span>
<pre>
  my @data_structures = Load(string-containing-a-YAML-stream);
</pre>
<p class="Pp">Turn YAML into Perl data. This is the opposite of Dump.</p>
<p class="Pp">Just like Storable's <b>thaw()</b> function or the <b>eval()</b>
    function in relation to Data::Dumper.</p>
<p class="Pp">It parses a character string containing a valid YAML stream into a
    list of Perl data structures representing the individual YAML documents. Be
    sure to decode the character string correctly if the string came from a file
    or socket.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  my $last_data_structure = Load(string-containing-a-YAML-stream);
</pre>
<p class="Pp">For consistency with YAML.pm, when Load is called in scalar
    context, it returns the data structure corresponding to the last of the YAML
    documents found in the input stream.</p>
<p class="Pp">Dies on any error.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_fBfreeze()_fP_and__fBthaw()_fP"><a class="permalink" href="#_fBfreeze()_fP_and__fBthaw()_fP"><b>freeze()</b>
  and <b>thaw()</b></a></h2>
Aliases to <b>Dump()</b> and <b>Load()</b> for Storable fans. This will also
  allow YAML::Tiny to be plugged directly into modules like POE.pm, that use the
  freeze/thaw API for internal serialization.
</section>
<section class="Ss">
<h2 class="Ss" id="DumpFile(filepath,_list)"><a class="permalink" href="#DumpFile(filepath,_list)">DumpFile(filepath,
  list)</a></h2>
Writes the YAML stream to a file with UTF-8 encoding instead of just returning a
  string.
<p class="Pp">Dies on any error.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="LoadFile(filepath)"><a class="permalink" href="#LoadFile(filepath)">LoadFile(filepath)</a></h2>
Reads the YAML stream from a UTF-8 encoded file instead of a string.
<p class="Pp">Dies on any error.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="YAML_TINY_SPECIFICATION"><a class="permalink" href="#YAML_TINY_SPECIFICATION">YAML
  TINY SPECIFICATION</a></h1>
This section of the documentation provides a specification for &quot;YAML
  Tiny&quot;, a subset of the YAML specification.
<p class="Pp">It is based on and described comparatively to the YAML 1.1 Working
    Draft 2004-12-28 specification, located at
    &lt;http://yaml.org/spec/current.html&gt;.</p>
<p class="Pp">Terminology and chapter numbers are based on that
  specification.</p>
<section class="Ss">
<h2 class="Ss" id="1._Introduction_and_Goals"><a class="permalink" href="#1._Introduction_and_Goals">1.
  Introduction and Goals</a></h2>
The purpose of the YAML Tiny specification is to describe a useful subset of the
  YAML specification that can be used for typical document-oriented use cases
  such as configuration files and simple data structure dumps.
<p class="Pp">Many specification elements that add flexibility or extensibility
    are intentionally removed, as is support for complex data structures, class
    and object-orientation.</p>
<p class="Pp">In general, the YAML Tiny language targets only those data
    structures available in JSON, with the additional limitation that only
    simple keys are supported.</p>
<p class="Pp">As a result, all possible YAML Tiny documents should be able to be
    transformed into an equivalent JSON document, although the reverse is not
    necessarily true (but will be true in simple cases).</p>
<p class="Pp">As a result of these simplifications the YAML Tiny specification
    should be implementable in a (relatively) small amount of code in any
    language that supports Perl Compatible Regular Expressions (PCRE).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="2._Introduction"><a class="permalink" href="#2._Introduction">2.
  Introduction</a></h2>
YAML Tiny supports three data structures. These are scalars (in a variety of
  forms), block-form sequences and block-form mappings. Flow-style sequences and
  mappings are not supported, with some minor exceptions detailed later.
<p class="Pp">The use of three dashes &quot;---&quot; to indicate the start of a
    new document is supported, and multiple documents per file/stream is
    allowed.</p>
<p class="Pp">Both line and inline comments are supported.</p>
<p class="Pp">Scalars are supported via the plain style, single quote and double
    quote, as well as literal-style and folded-style multi-line scalars.</p>
<p class="Pp">The use of explicit tags is not supported.</p>
<p class="Pp">The use of &quot;null&quot; type scalars is supported via the ~
    character.</p>
<p class="Pp">The use of &quot;bool&quot; type scalars is not supported.</p>
<p class="Pp">However, serializer implementations should take care to explicitly
    escape strings that match a &quot;bool&quot; keyword in the following set to
    prevent other implementations that do support &quot;bool&quot; accidentally
    reading a string as a boolean</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  y|Y|yes|Yes|YES|n|N|no|No|NO
  |true|True|TRUE|false|False|FALSE
  |on|On|ON|off|Off|OFF
</pre>
<p class="Pp">The use of anchors and aliases is not supported.</p>
<p class="Pp">The use of directives is supported only for the
    <span class="Li">%YAML</span> directive.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="3._Processing__s-1YAML_s0_Tiny_Information"><a class="permalink" href="#3._Processing__s-1YAML_s0_Tiny_Information">3.
  Processing YAML Tiny Information</a></h2>
<b>Processes</b>
<p class="Pp">The YAML specification dictates three-phase serialization and
    three-phase deserialization.</p>
<p class="Pp">The YAML Tiny specification does not mandate any particular
    methodology or mechanism for parsing.</p>
<p class="Pp">Any compliant parser is only required to parse a single document
    at a time. The ability to support streaming documents is optional and most
    likely non-typical.</p>
<p class="Pp">Because anchors and aliases are not supported, the resulting
    representation graph is thus directed but (unlike the main YAML
    specification) <b>acyclic</b>.</p>
<p class="Pp">Circular references/pointers are not possible, and any YAML Tiny
    serializer detecting a circular reference should error with an appropriate
    message.</p>
<p class="Pp"><b>Presentation Stream</b></p>
<p class="Pp">YAML Tiny reads and write UTF-8 encoded files. Operations on
    strings expect or produce Unicode characters not UTF-8 encoded bytes.</p>
<p class="Pp"><b>Loading Failure Points</b></p>
<p class="Pp">YAML Tiny parsers and emitters are not expected to recover from,
    or adapt to, errors. The specific error modality of any implementation is
    not dictated (return codes, exceptions, etc.) but is expected to be
    consistent.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="4._Syntax"><a class="permalink" href="#4._Syntax">4.
  Syntax</a></h2>
<b>Character Set</b>
<p class="Pp">YAML Tiny streams are processed in memory as Unicode characters
    and read/written with UTF-8 encoding.</p>
<p class="Pp">The escaping and unescaping of the 8-bit YAML escapes is
  required.</p>
<p class="Pp">The escaping and unescaping of 16-bit and 32-bit YAML escapes is
    not required.</p>
<p class="Pp"><b>Indicator Characters</b></p>
<p class="Pp">Support for the &quot;~&quot; null/undefined indicator is
    required.</p>
<p class="Pp">Implementations may represent this as appropriate for the
    underlying language.</p>
<p class="Pp">Support for the &quot;-&quot; block sequence indicator is
    required.</p>
<p class="Pp">Support for the &quot;?&quot; mapping key indicator is <b>not</b>
    required.</p>
<p class="Pp">Support for the &quot;:&quot; mapping value indicator is
  required.</p>
<p class="Pp">Support for the &quot;,&quot; flow collection indicator is
    <b>not</b> required.</p>
<p class="Pp">Support for the &quot;[&quot; flow sequence indicator is
    <b>not</b> required, with one exception (detailed below).</p>
<p class="Pp">Support for the &quot;]&quot; flow sequence indicator is
    <b>not</b> required, with one exception (detailed below).</p>
<p class="Pp">Support for the &quot;{&quot; flow mapping indicator is <b>not</b>
    required, with one exception (detailed below).</p>
<p class="Pp">Support for the &quot;}&quot; flow mapping indicator is <b>not</b>
    required, with one exception (detailed below).</p>
<p class="Pp">Support for the &quot;#&quot; comment indicator is required.</p>
<p class="Pp">Support for the &quot;&amp;&quot; anchor indicator is <b>not</b>
    required.</p>
<p class="Pp">Support for the &quot;*&quot; alias indicator is <b>not</b>
    required.</p>
<p class="Pp">Support for the &quot;!&quot; tag indicator is <b>not</b>
    required.</p>
<p class="Pp">Support for the &quot;|&quot; literal block indicator is
  required.</p>
<p class="Pp">Support for the &quot;&gt;&quot; folded block indicator is
    required.</p>
<p class="Pp">Support for the &quot;'&quot; single quote indicator is
  required.</p>
<p class="Pp">Support for the &quot;&quot;&quot; double quote indicator is
    required.</p>
<p class="Pp">Support for the &quot;%&quot; directive indicator is required, but
    only for the special case of a <span class="Li">%YAML</span> version
    directive before the &quot;---&quot; document header, or on the same line as
    the document header.</p>
<p class="Pp">For example:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  %YAML 1.1
  ---
  - A sequence with a single element
</pre>
<p class="Pp">Special Exception:</p>
<p class="Pp">To provide the ability to support empty sequences and mappings,
    support for the constructs [] (empty sequence) and {} (empty mapping) are
    required.</p>
<p class="Pp">For example,</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  %YAML 1.1
  # A document consisting of only an empty mapping
  --- {}
  # A document consisting of only an empty sequence
  --- []
  # A document consisting of an empty mapping within a sequence
  - foo
  - {}
  - bar
</pre>
<p class="Pp"><b>Syntax Primitives</b></p>
<p class="Pp">Other than the empty sequence and mapping cases described above,
    YAML Tiny supports only the indentation-based block-style group of
  contexts.</p>
<p class="Pp">All five scalar contexts are supported.</p>
<p class="Pp">Indentation spaces work as per the YAML specification in all
    cases.</p>
<p class="Pp">Comments work as per the YAML specification in all simple cases.
    Support for indented multi-line comments is <b>not</b> required.</p>
<p class="Pp">Separation spaces work as per the YAML specification in all
  cases.</p>
<p class="Pp"><b>YAML Tiny Character Stream</b></p>
<p class="Pp">The only directive supported by the YAML Tiny specification is the
    <span class="Li">%YAML</span> language/version identifier. Although
    detected, this directive will have no control over the parsing itself.</p>
<p class="Pp">The parser must recognise both the YAML 1.0 and YAML 1.1+
    formatting of this directive (as well as the commented form, although no
    explicit code should be needed to deal with this case, being a comment
    anyway)</p>
<p class="Pp">That is, all of the following should be supported.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  --- #YAML:1.0
  - foo

  %YAML:1.0
  ---
  - foo

  % YAML 1.1
  ---
  - foo
</pre>
<p class="Pp">Support for the <span class="Li">%TAG</span> directive is
    <b>not</b> required.</p>
<p class="Pp">Support for additional directives is <b>not</b> required.</p>
<p class="Pp">Support for the document boundary marker &quot;---&quot; is
    required.</p>
<p class="Pp">Support for the document boundary market &quot;...&quot; is
    <b>not</b> required.</p>
<p class="Pp">If necessary, a document boundary should simply by indicated with
    a &quot;---&quot; marker, with not preceding &quot;...&quot; marker.</p>
<p class="Pp">Support for empty streams (containing no documents) is
  required.</p>
<p class="Pp">Support for implicit document starts is required.</p>
<p class="Pp">That is, the following must be equivalent.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
 # Full form
 %YAML 1.1
 ---
 foo: bar

 # Implicit form
 foo: bar
</pre>
<p class="Pp"><b>Nodes</b></p>
<p class="Pp">Support for nodes optional anchor and tag properties is <b>not</b>
    required.</p>
<p class="Pp">Support for node anchors is <b>not</b> required.</p>
<p class="Pp">Support for node tags is <b>not</b> required.</p>
<p class="Pp">Support for alias nodes is <b>not</b> required.</p>
<p class="Pp">Support for flow nodes is <b>not</b> required.</p>
<p class="Pp">Support for block nodes is required.</p>
<p class="Pp"><b>Scalar Styles</b></p>
<p class="Pp">Support for all five scalar styles is required as per the YAML
    specification, although support for quoted scalars spanning more than one
    line is <b>not</b> required.</p>
<p class="Pp">Support for multi-line scalar documents starting on the header is
    not required.</p>
<p class="Pp">Support for the chomping indicators on multi-line scalar styles is
    required.</p>
<p class="Pp"><b>Collection Styles</b></p>
<p class="Pp">Support for block-style sequences is required.</p>
<p class="Pp">Support for flow-style sequences is <b>not</b> required.</p>
<p class="Pp">Support for block-style mappings is required.</p>
<p class="Pp">Support for flow-style mappings is <b>not</b> required.</p>
<p class="Pp">Both sequences and mappings should be able to be arbitrarily
    nested.</p>
<p class="Pp">Support for plain-style mapping keys is required.</p>
<p class="Pp">Support for quoted keys in mappings is <b>not</b> required.</p>
<p class="Pp">Support for &quot;?&quot;-indicated explicit keys is <b>not</b>
    required.</p>
<p class="Pp">Here endeth the specification.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Additional_Perl-Specific_Notes"><a class="permalink" href="#Additional_Perl-Specific_Notes">Additional
  Perl-Specific Notes</a></h2>
For some Perl applications, it's important to know if you really have a number
  and not a string.
<p class="Pp">That is, in some contexts is important that 3 the number is
    distinctive from &quot;3&quot; the string.</p>
<p class="Pp">Because even Perl itself is not trivially able to understand the
    difference (certainly without XS-based modules) Perl implementations of the
    YAML Tiny specification are not required to retain the distinctiveness of 3
    vs &quot;3&quot;.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="SUPPORT"><a class="permalink" href="#SUPPORT">SUPPORT</a></h1>
Bugs should be reported via the CPAN bug tracker at
<p class="Pp">&lt;http://rt.cpan.org/NoAuth/ReportBug.html?Queue=YAML-Tiny&gt;</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
Adam Kennedy &lt;adamk@cpan.org&gt;
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<ul class="Bl-bullet">
  <li>YAML</li>
  <li>YAML::Syck</li>
  <li>Config::Tiny</li>
  <li>CSS::Tiny</li>
  <li>&lt;http://use.perl.org/use.perl.org/_Alias/journal/29427.html&gt;</li>
  <li>&lt;http://ali.as/&gt;</li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT"><a class="permalink" href="#COPYRIGHT">COPYRIGHT</a></h1>
Copyright 2006 - 2013 Adam Kennedy.
<p class="Pp">This program is free software; you can redistribute it and/or
    modify it under the same terms as Perl itself.</p>
<p class="Pp">The full text of the license can be found in the LICENSE file
    included with this module.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2018-02-21</td>
    <td class="foot-os">perl v5.30.2</td>
  </tr>
</table>
</body>
</html>
