<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>utf8(3pm)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">utf8(3pm)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">utf8(3pm)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
utf8 - Perl pragma to enable/disable UTF-8 (or UTF-EBCDIC) in source code
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<span class="Li"></span>
<pre>
    use utf8;
    no utf8;

    # Convert the internal representation of a Perl scalar to/from UTF-8.

    $num_octets = utf8::upgrade($string);
    $success    = utf8::downgrade($string[, FAIL_OK]);

    # Change each character of a Perl scalar to/from a series of
    # characters that represent the UTF-8 bytes of each original character.

    utf8::encode($string);  # &quot;\x{100}&quot;  becomes &quot;\xc4\x80&quot;
    utf8::decode($string);  # &quot;\xc4\x80&quot; becomes &quot;\x{100}&quot;

    $flag = utf8::is_utf8(STRING); # since Perl 5.8.1
    $flag = utf8::valid(STRING);
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
The <span class="Li">&quot;use utf8&quot;</span> pragma tells the Perl parser to
  allow UTF-8 in the program text in the current lexical scope (allow UTF-EBCDIC
  on EBCDIC based platforms). The <span class="Li">&quot;no utf8&quot;</span>
  pragma tells Perl to switch back to treating the source text as literal bytes
  in the current lexical scope.
<p class="Pp"><b>Do not use this pragma for anything else than telling Perl that
    your</b> <b>script is written in UTF-8.</b> The utility functions described
    below are directly usable without <span class="Li">&quot;use
    utf8;&quot;</span>.</p>
<p class="Pp">Because it is not possible to reliably tell UTF-8 from native 8
    bit encodings, you need either a Byte Order Mark at the beginning of your
    source code, or <span class="Li">&quot;use utf8;&quot;</span>, to instruct
    perl.</p>
<p class="Pp">When UTF-8 becomes the standard source format, this pragma will
    effectively become a no-op. For convenience in what follows the term
    <i>UTF-X</i> is used to refer to UTF-8 on ASCII and ISO Latin based
    platforms and UTF-EBCDIC on EBCDIC based platforms.</p>
<p class="Pp">See also the effects of the <span class="Li">&quot;-C&quot;</span>
    switch and its cousin, the <span class="Li">$ENV{PERL_UNICODE}</span>, in
    perlrun.</p>
<p class="Pp">Enabling the <span class="Li">&quot;utf8&quot;</span> pragma has
    the following effect:</p>
<dl class="Bl-tag">
  <dt>&#x2022;</dt>
  <dd>Bytes in the source text that have their high-bit set will be treated as
      being part of a literal UTF-X sequence. This includes most literals such
      as identifier names, string constants, and constant regular expression
      patterns.
    <p class="Pp">On EBCDIC platforms characters in the Latin 1 character set
        are treated as being part of a literal UTF-EBCDIC character.</p>
  </dd>
</dl>
<p class="Pp">Note that if you have bytes with the eighth bit on in your script
    (for example embedded Latin-1 in your string literals),
    <span class="Li">&quot;use utf8&quot;</span> will be unhappy since the bytes
    are most probably not well-formed UTF-X. If you want to have such bytes
    under <span class="Li">&quot;use utf8&quot;</span>, you can disable this
    pragma until the end the block (or file, if at top level) by
    <span class="Li">&quot;no utf8;&quot;</span>.</p>
<section class="Ss">
<h2 class="Ss" id="Utility_functions"><a class="permalink" href="#Utility_functions">Utility
  functions</a></h2>
The following functions are defined in the
  <span class="Li">&quot;utf8::&quot;</span> package by the Perl core. You do
  not need to say <span class="Li">&quot;use utf8&quot;</span> to use these and
  in fact you should not say that unless you really want to have UTF-8 source
  code.
<ul class="Bl-bullet">
  <li><span class="Li">$num_octets</span> = utf8::upgrade($string)
    <p class="Pp">Converts in-place the internal representation of the string
        from an octet sequence in the native encoding (Latin-1 or EBCDIC) to
        <i>UTF-X</i>. The logical character sequence itself is unchanged. If
        <i></i> <i>$string</i><i></i> is already stored as <i>UTF-X</i>, then
        this is a no-op. Returns the number of octets necessary to represent the
        string as <i>UTF-X</i>. Can be used to make sure that the UTF-8 flag is
        on, so that <span class="Li">&quot;\w&quot;</span> or
        <span class="Li">&quot;lc()&quot;</span> work as Unicode on strings
        containing characters in the range 0x80-0xFF (on ASCII and
      derivatives).</p>
    <p class="Pp"><b>Note that this function does not handle arbitrary
        encodings.</b> Therefore Encode is recommended for the general purposes;
        see also Encode.</p>
  </li>
  <li><span class="Li">$success</span> = utf8::downgrade($string[, FAIL_OK])
    <p class="Pp">Converts in-place the internal representation of the string
        from <i>UTF-X</i> to the equivalent octet sequence in the native
        encoding (Latin-1 or EBCDIC). The logical character sequence itself is
        unchanged. If <i></i><i>$string</i><i></i> is already stored as native 8
        bit, then this is a no-op. Can be used to make sure that the UTF-8 flag
        is off, e.g. when you want to make sure that the <i>substr()</i> or
        <i>length()</i> function works with the usually faster byte
      algorithm.</p>
    <p class="Pp">Fails if the original <i>UTF-X</i> sequence cannot be
        represented in the native 8 bit encoding. On failure dies or, if the
        value of <span class="Li">&quot;FAIL_OK&quot;</span> is true, returns
        false.</p>
    <p class="Pp">Returns true on success.</p>
    <p class="Pp"><b>Note that this function does not handle arbitrary
        encodings.</b> Therefore Encode is recommended for the general purposes;
        see also Encode.</p>
  </li>
  <li>utf8::encode($string)
    <p class="Pp">Converts in-place the character sequence to the corresponding
        octet sequence in <i>UTF-X</i>. That is, every (possibly wide) character
        gets replaced with a sequence of one or more characters that represent
        the individual <i>UTF-X</i> bytes of the character. The UTF8 flag is
        turned off. Returns nothing.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    my $a = &quot;\x{100}&quot;; # $a contains one character, with ord 0x100
    utf8::encode($a);  # $a contains two characters, with ords 0xc4 and 0x80
    </pre>
    <p class="Pp"><b>Note that this function does not handle arbitrary
        encodings.</b> Therefore Encode is recommended for the general purposes;
        see also Encode.</p>
  </li>
  <li><span class="Li">$success</span> = utf8::decode($string)
    <p class="Pp">Attempts to convert in-place the octet sequence in
        <i>UTF-X</i> to the corresponding character sequence. That is, it
        replaces each sequence of characters in the string whose ords represent
        a valid UTF-X byte sequence, with the corresponding single character.
        The UTF-8 flag is turned on only if the source string contains
        multiple-byte <i>UTF-X</i> characters. If <i></i><i>$string</i><i></i>
        is invalid as <i>UTF-X</i>, returns false; otherwise returns true.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    my $a = &quot;\xc4\x80&quot;; # $a contains two characters, with ords 0xc4 and 0x80
    utf8::decode($a);   # $a contains one character, with ord 0x100
    </pre>
    <p class="Pp"><b>Note that this function does not handle arbitrary
        encodings.</b> Therefore Encode is recommended for the general purposes;
        see also Encode.</p>
  </li>
  <li><span class="Li">$flag</span> = utf8::is_utf8(STRING)
    <p class="Pp">(Since Perl 5.8.1) Test whether STRING is encoded internally
        in UTF-8. Functionally the same as <i>Encode::is_utf8()</i>.</p>
  </li>
  <li><span class="Li">$flag</span> = utf8::valid(STRING)
    <p class="Pp">[INTERNAL] Test whether STRING is in a consistent state
        regarding UTF-8. Will return true if it is well-formed UTF-8 and has the
        UTF-8 flag on <b>or</b> if STRING is held as bytes (both these states
        are 'consistent'). Main reason for this routine is to allow Perl's
        testsuite to check that operations have left strings in a consistent
        state. You most probably want to use <i>utf8::is_utf8()</i> instead.</p>
  </li>
</ul>
<p class="Pp"><span class="Li">&quot;utf8::encode&quot;</span> is like
    <span class="Li">&quot;utf8::upgrade&quot;</span>, but the UTF8 flag is
    cleared. See perlunicode for more on the UTF8 flag and the C API functions
    <span class="Li">&quot;sv_utf8_upgrade&quot;</span>,
    <span class="Li">&quot;sv_utf8_downgrade&quot;</span>,
    <span class="Li">&quot;sv_utf8_encode&quot;</span>, and
    <span class="Li">&quot;sv_utf8_decode&quot;</span>, which are wrapped by the
    Perl functions <span class="Li">&quot;utf8::upgrade&quot;</span>,
    <span class="Li">&quot;utf8::downgrade&quot;</span>,
    <span class="Li">&quot;utf8::encode&quot;</span> and
    <span class="Li">&quot;utf8::decode&quot;</span>. Also, the functions
    utf8::is_utf8, utf8::valid, utf8::encode, utf8::decode, utf8::upgrade, and
    utf8::downgrade are actually internal, and thus always available, without a
    <span class="Li">&quot;require utf8&quot;</span> statement.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="BUGS"><a class="permalink" href="#BUGS">BUGS</a></h1>
One can have Unicode in identifier names, but not in package/class or subroutine
  names. While some limited functionality towards this does exist as of Perl
  5.8.0, that is more accidental than designed; use of Unicode for the said
  purposes is unsupported.
<p class="Pp">One reason of this unfinishedness is its (currently) inherent
    unportability: since both package names and subroutine names may need to be
    mapped to file and directory names, the Unicode capability of the filesystem
    becomes important-- and there unfortunately aren't portable answers.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
perlunitut, perluniintro, perlrun, bytes, perlunicode
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2014-09-30</td>
    <td class="foot-os">perl v5.18.4</td>
  </tr>
</table>
</body>
</html>
