<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    .Nd, .Bf, .Op { display: inline; }
    .Pa, .Ad { font-style: italic; }
    .Ms { font-weight: bold; }
    .Bl-diag > dt { font-weight: bold; }
    code.Nm, .Fl, .Cm, .Ic, code.In, .Fd, .Fn, .Cd { font-weight: bold;
      font-family: inherit; }
  </style>
  <title>IO::Socket::SSL::Intercept(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">IO::Socket::SSL::Intercept(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">IO::Socket::SSL::Intercept(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">IO::Socket::SSL::Intercept -- SSL interception (man in the
  middle)</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>    use IO::Socket::SSL::Intercept;
    # create interceptor with proxy certificates
    my $mitm = IO::Socket::SSL::Intercept-&gt;new(
        proxy_cert_file =&gt; 'proxy_cert.pem',
        proxy_key_file  =&gt; 'proxy_key.pem',
        ...
    );
    my $listen = IO::Socket::INET-&gt;new( LocalAddr =&gt; .., Listen =&gt; .. );
    while (1) {
        # TCP accept new client
        my $client = $listen-&gt;accept or next;
        # SSL connect to server
        my $server = IO::Socket::SSL-&gt;new(
            PeerAddr =&gt; ..,
            SSL_verify_mode =&gt; ...,
            ...
        ) or die &quot;ssl connect failed: $!,$SSL_ERROR&quot;;
        # clone server certificate
        my ($cert,$key) = $mitm-&gt;clone_cert( $server-&gt;peer_certificate );
        # and upgrade client side to SSL with cloned certificate
        IO::Socket::SSL-&gt;start_SSL($client,
            SSL_server =&gt; 1,
            SSL_cert =&gt; $cert,
            SSL_key =&gt; $key
        ) or die &quot;upgrade failed: $SSL_ERROR&quot;;
        # now transfer data between $client and $server and analyze
        # the unencrypted data
        ...
    }
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">This module provides functionality to clone certificates and sign
    them with a proxy certificate, thus making it easy to intercept SSL
    connections (man in the middle). It also manages a cache of the generated
    certificates.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="How_Intercepting_SSL_Works"><a class="permalink" href="#How_Intercepting_SSL_Works">How
  Intercepting SSL Works</a></h1>
<p class="Pp">Intercepting SSL connections is useful for analyzing encrypted
    traffic for security reasons or for testing. It does not break the
    end-to-end security of SSL, e.g. a properly written client will notice the
    interception unless you explicitly configure the client to trust your
    interceptor. Intercepting SSL works the following way:</p>
<ul class="Bl-bullet">
  <li>Create a new CA certificate, which will be used to sign the cloned
      certificates. This proxy CA certificate should be trusted by the client,
      or (a properly written client) will throw error messages or deny the
      connections because it detected a man in the middle attack. Due to the way
      the interception works there no support for client side certificates is
      possible.
    <p class="Pp">Using openssl such a proxy CA certificate and private key can
        be created with:</p>
    <p class="Pp"></p>
    <pre>  openssl genrsa -out proxy_key.pem 1024
  openssl req -new -x509 -extensions v3_ca -key proxy_key.pem -out proxy_cert.pem
  # export as PKCS12 for import into browser
  openssl pkcs12 -export -in proxy_cert.pem -inkey proxy_key.pem -out proxy_cert.p12
    </pre>
  </li>
  <li>Configure client to connect to use intercepting proxy or somehow redirect
      connections from client to the proxy (e.g. packet filter redirects, ARP or
      DNS spoofing etc).</li>
  <li>Accept the TCP connection from the client, e.g. don't do any SSL
      handshakes with the client yet.</li>
  <li>Establish the SSL connection to the server and verify the servers
      certificate as usually. Then create a new certificate based on the
      original servers certificate, but signed by your proxy CA. This is the
      step where IO::Socket::SSL::Intercept helps.</li>
  <li>Upgrade the TCP connection to the client to SSL using the cloned
      certificate from the server. If the client trusts your proxy CA it will
      accept the upgrade to SSL.</li>
  <li>Transfer data between client and server. While the connections to client
      and server are both encrypted with SSL you will read/write the unencrypted
      data in your proxy application.</li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="METHODS"><a class="permalink" href="#METHODS">METHODS</a></h1>
<p class="Pp">IO::Socket::SSL::Intercept helps creating the cloned certificate
    with the following methods:</p>
<dl class="Bl-tag">
  <dt><b></b><span class="Li"><b>$mitm</b></span><b> =
    IO::Socket::SSL::Intercept-&gt;new(%args)</b></dt>
  <dd>This creates a new interceptor object. <span class="Li">%args</span>
      should be</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="proxy_cert"><a class="permalink" href="#proxy_cert">proxy_cert X509 |
    proxy_cert_file filename</a></dt>
  <dd>This is the proxy certificate. It can be either given by an X509 object
      from Net::SSLeays internal representation, or using a file in PEM
    format.</dd>
  <dt id="proxy_key"><a class="permalink" href="#proxy_key">proxy_key EVP_PKEY |
    proxy_key_file filename</a></dt>
  <dd>This is the key for the proxy certificate. It can be either given by an
      EVP_PKEY object from Net::SSLeays internal representation, or using a file
      in PEM format. The key should not have a passphrase.</dd>
  <dt id="pubkey"><a class="permalink" href="#pubkey">pubkey EVP_PKEY |
    pubkey_file filename</a></dt>
  <dd>This optional argument specifies the public key used for the cloned
      certificate. It can be either given by an EVP_PKEY object from
      Net::SSLeays internal representation, or using a file in PEM format. If
      not given it will create a new public key on each call of
      <span class="Li">&quot;new&quot;</span>.</dd>
  <dt id="serial"><a class="permalink" href="#serial">serial
    INTEGER|CODE</a></dt>
  <dd>This optional argument gives the starting point for the serial numbers of
      the newly created certificates. If not set the serial number will be
      created based on the digest of the original certificate. If the value is
      code it will be called with
      <span class="Li">&quot;serial(original_cert,CERT_asHash(original_cert))&quot;</span>
      and should return the new serial number.</dd>
  <dt id="cache"><a class="permalink" href="#cache">cache HASH |
    SUBROUTINE</a></dt>
  <dd>This optional argument gives a way to cache created certificates, so that
      they don't get recreated on future accesses to the same host. If the
      argument ist not given an internal HASH ist used.
    <p class="Pp">If the argument is a hash it will store for each generated
        certificate a hash reference with
        <span class="Li">&quot;cert&quot;</span> and
        <span class="Li">&quot;atime&quot;</span> in the hash, where
        <span class="Li">&quot;atime&quot;</span> is the time of last access (to
        expire unused entries) and <span class="Li">&quot;cert&quot;</span> is
        the certificate. Please note, that the certificate is in Net::SSLeays
        internal X509 format and can thus not be simply dumped and restored. The
        key for the hash is an <span class="Li">&quot;ident&quot;</span> either
        given to <span class="Li">&quot;clone_cert&quot;</span> or generated
        from the original certificate.</p>
    <p class="Pp">If the argument is a subroutine it will be called as
        <span class="Li">&quot;$cache-&gt;(ident,sub)&quot;</span>. This call
        should return either an existing (cached)
        <span class="Li">&quot;(cert,key)&quot;</span> or call
        <span class="Li">&quot;sub&quot;</span> without arguments to create a
        new <span class="Li">&quot;(cert,key)&quot;</span>, store it and return
        it. If called with
        <span class="Li">&quot;$cache-&gt;('type')&quot;</span> the function
        should just return 1 to signal that it supports the current type of
        cache. If it reutrns nothing instead the older cache interface is
        assumed for compatibility reasons.</p>
  </dd>
</dl>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt><b>($clone_cert,$key) =
    </b><span class="Li"><b>$mitm</b></span><b>-&gt;clone_cert($original_cert,[
    </b><span class="Li"><b>$ident</b></span><b> ])</b></dt>
  <dd>This clones the given certificate. An ident as the key into the cache can
      be given (like <span class="Li">&quot;host:port&quot;</span>), if not it
      will be created from the properties of the original certificate. It
      returns the cloned certificate and its key (which is the same for alle
      created certificates).</dd>
  <dt><b></b><span class="Li"><b>$string</b></span><b> =
    </b><span class="Li"><b>$mitm</b></span><b>-&gt;serialize</b></dt>
  <dd>This creates a serialized version of the object (e.g. a string) which can
      then be used to persistantly store created certificates over restarts of
      the application. The cache will only be serialized if it is a HASH. To
      work together with Storable the
      <span class="Li">&quot;STORABLE_freeze&quot;</span> function is defined to
      call <span class="Li">&quot;serialize&quot;</span>.</dd>
  <dt><b></b><span class="Li"><b>$mitm</b></span><b> =
    IO::Socket::SSL::Intercept-&gt;unserialize($string)</b></dt>
  <dd>This restores an Intercept object from a serialized string. To work
      together with Storable the
      <span class="Li">&quot;STORABLE_thaw&quot;</span> function is defined to
      call <span class="Li">&quot;unserialize&quot;</span>.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">Steffen Ullrich</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2020-02-14</td>
    <td class="foot-os">perl v5.30.2</td>
  </tr>
</table>
</body>
</html>
