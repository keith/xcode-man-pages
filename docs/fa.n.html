<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Generated from file '/System/Volumes/Data/SWE/macOS/BuildRoots/0ed32b12e4/Library/Caches/com.apple.xbs/Sources/tcl/tcl-134/tcl_ext/tcllib/tcllib/modules/grammar_fa/fa.man' by tcllib/doctools with format 'nroff'
   Copyright (c) 2004-2009 Andreas Kupries <andreas_kupries@users.sourceforge.net>
  
   The definitions below are for supplemental macros used in Tcl/Tk
   manual entries.
  
   .AP type name in/out ?indent?
  	Start paragraph describing an argument to a library procedure.
  	type is type of argument (int, etc.), in/out is either "in", "out",
  	or "in/out" to describe whether procedure reads or modifies arg,
  	and indent is equivalent to second arg of .IP (shouldn't ever be
  	needed;  use .AS below instead)
  
   .AS ?type? ?name?
  	Give maximum sizes of arguments for setting tab stops.  Type and
  	name are examples of largest possible arguments that will be passed
  	to .AP later.  If args are omitted, default tab stops are used.
  
   .BS
  	Start box enclosure.  From here until next .BE, everything will be
  	enclosed in one large box.
  
   .BE
  	End of box enclosure.
  
   .CS
  	Begin code excerpt.
  
   .CE
  	End code excerpt.
  
   .VS ?version? ?br?
  	Begin vertical sidebar, for use in marking newly-changed parts
  	of man pages.  The first argument is ignored and used for recording
  	the version when the .VS was added, so that the sidebars can be
  	found and removed when they reach a certain age.  If another argument
  	is present, then a line break is forced before starting the sidebar.
  
   .VE
  	End of vertical sidebar.
  
   .DS
  	Begin an indented unfilled display.
  
   .DE
  	End of indented unfilled display.
  
   .SO
  	Start of list of standard options for a Tk widget.  The
  	options follow on successive lines, in four columns separated
  	by tabs.
  
   .SE
  	End of list of standard options for a Tk widget.
  
   .OP cmdName dbName dbClass
  	Start of description of a specific option.  cmdName gives the
  	option's name as specified in the class command, dbName gives
  	the option's name in the option database, and dbClass gives
  	the option's class in the option database.
  
   .UL arg1 arg2
  	Print arg1 underlined, then print arg2 normally.
  
   RCS: @(#) $Id: man.macros,v 1.1 2009/01/30 04:56:47 andreas_kupries Exp $
  
  	# Set up traps and other miscellaneous stuff for Tcl/Tk man pages.
  	# Start an argument description
  .b
  	# define tabbing values for .AP
  
  	# BS - start boxed text
  	# ^y = starting y location
  	# ^b = 1
  	# BE - end boxed text (draw box now)
  	Draw four-sided box normally, but don't draw top of
  	box if the box started on an earlier page.
  	# VS - start vertical sidebar
  	# ^Y = starting y location
  	# ^v = 1 (for troff;  for nroff this doesn't matter)
  	# VE - end of vertical sidebar
  	# Special macro to handle page bottom:  finish off current
  	# box/sidebar if in box/sidebar mode, then invoked standard
  	# page bottom macro.
  	Draw three-sided box if this is the box's first page,
  	draw two sides but no top otherwise.
  	# DS - begin display
  	# DE - end display
  	# SO - start of list of standard options
  	# SE - end of list of standard options
  	# OP - start of full description for a single option
  	# CS - begin code excerpt
  	# CE - end code excerpt
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>grammar::fa(n)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">grammar::fa(n)</td>
    <td class="head-vol">Finite automaton operations and usage</td>
    <td class="head-rtitle">grammar::fa(n)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<pre>

</pre>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
grammar::fa - Create and manipulate finite automatons
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
package require <b>Tcl 8.4</b>
<p class="Pp">package require <b>snit 1.3</b></p>
<p class="Pp">package require <b>struct::list </b></p>
<p class="Pp">package require <b>struct::set </b></p>
<p class="Pp">package require <b>grammar::fa::op ?0.2?</b></p>
<p class="Pp">package require <b>grammar::fa ?0.4?</b></p>
<p class="Pp"><b>::grammar::fa</b> <i>faName</i>
    ?<b>=</b>|<b>:=</b>|<b>&lt;--</b>|<b>as</b>|<b>deserialize</b>
    <i>src</i>|<b>fromRegex</b> <i>re</i> ?<i>over</i>??</p>
<p class="Pp"><b>faName</b> <i>option</i> ?<i>arg arg ...</i>?</p>
<p class="Pp"><i>faName</i> <b>destroy</b></p>
<p class="Pp"><i>faName</i> <b>clear</b></p>
<p class="Pp"><i>faName</i> <b>=</b> <i>srcFA</i></p>
<p class="Pp"><i>faName</i> <b>--&gt;</b> <i>dstFA</i></p>
<p class="Pp"><i>faName</i> <b>serialize</b></p>
<p class="Pp"><i>faName</i> <b>deserialize</b> <i>serialization</i></p>
<p class="Pp"><i>faName</i> <b>states</b></p>
<p class="Pp"><i>faName</i> <b>state</b> <b>add</b> <i>s1</i> ?<i>s2</i>
  ...?</p>
<p class="Pp"><i>faName</i> <b>state</b> <b>delete</b> <i>s1</i> ?<i>s2</i>
  ...?</p>
<p class="Pp"><i>faName</i> <b>state</b> <b>exists</b> <i>s</i></p>
<p class="Pp"><i>faName</i> <b>state</b> <b>rename</b> <i>s</i> <i>snew</i></p>
<p class="Pp"><i>faName</i> <b>startstates</b></p>
<p class="Pp"><i>faName</i> <b>start</b> <b>add</b> <i>s1</i> ?<i>s2</i>
  ...?</p>
<p class="Pp"><i>faName</i> <b>start</b> <b>remove</b> <i>s1</i> ?<i>s2</i>
  ...?</p>
<p class="Pp"><i>faName</i> <b>start?</b> <i>s</i></p>
<p class="Pp"><i>faName</i> <b>start?set</b> <i>stateset</i></p>
<p class="Pp"><i>faName</i> <b>finalstates</b></p>
<p class="Pp"><i>faName</i> <b>final</b> <b>add</b> <i>s1</i> ?<i>s2</i>
  ...?</p>
<p class="Pp"><i>faName</i> <b>final</b> <b>remove</b> <i>s1</i> ?<i>s2</i>
  ...?</p>
<p class="Pp"><i>faName</i> <b>final?</b> <i>s</i></p>
<p class="Pp"><i>faName</i> <b>final?set</b> <i>stateset</i></p>
<p class="Pp"><i>faName</i> <b>symbols</b></p>
<p class="Pp"><i>faName</i> <b>symbols@</b> <i>s</i> ?<i>d</i>?</p>
<p class="Pp"><i>faName</i> <b>symbols@set</b> <i>stateset</i></p>
<p class="Pp"><i>faName</i> <b>symbol</b> <b>add</b> <i>sym1</i> ?<i>sym2</i>
    ...?</p>
<p class="Pp"><i>faName</i> <b>symbol</b> <b>delete</b> <i>sym1</i> ?<i>sym2</i>
    ...?</p>
<p class="Pp"><i>faName</i> <b>symbol</b> <b>rename</b> <i>sym</i>
  <i>newsym</i></p>
<p class="Pp"><i>faName</i> <b>symbol</b> <b>exists</b> <i>sym</i></p>
<p class="Pp"><i>faName</i> <b>next</b> <i>s</i> <i>sym</i> ?<b>--&gt;</b>
    <i>next</i>?</p>
<p class="Pp"><i>faName</i> <b>!next</b> <i>s</i> <i>sym</i> ?<b>--&gt;</b>
    <i>next</i>?</p>
<p class="Pp"><i>faName</i> <b>nextset</b> <i>stateset</i> <i>sym</i></p>
<p class="Pp"><i>faName</i> <b>is</b> <b>deterministic</b></p>
<p class="Pp"><i>faName</i> <b>is</b> <b>complete</b></p>
<p class="Pp"><i>faName</i> <b>is</b> <b>useful</b></p>
<p class="Pp"><i>faName</i> <b>is</b> <b>epsilon-free</b></p>
<p class="Pp"><i>faName</i> <b>reachable_states</b></p>
<p class="Pp"><i>faName</i> <b>unreachable_states</b></p>
<p class="Pp"><i>faName</i> <b>reachable</b> <i>s</i></p>
<p class="Pp"><i>faName</i> <b>useful_states</b></p>
<p class="Pp"><i>faName</i> <b>unuseful_states</b></p>
<p class="Pp"><i>faName</i> <b>useful</b> <i>s</i></p>
<p class="Pp"><i>faName</i> <b>epsilon_closure</b> <i>s</i></p>
<p class="Pp"><i>faName</i> <b>reverse</b></p>
<p class="Pp"><i>faName</i> <b>complete</b></p>
<p class="Pp"><i>faName</i> <b>remove_eps</b></p>
<p class="Pp"><i>faName</i> <b>trim</b> ?<i>what</i>?</p>
<p class="Pp"><i>faName</i> <b>determinize</b> ?<i>mapvar</i>?</p>
<p class="Pp"><i>faName</i> <b>minimize</b> ?<i>mapvar</i>?</p>
<p class="Pp"><i>faName</i> <b>complement</b></p>
<p class="Pp"><i>faName</i> <b>kleene</b></p>
<p class="Pp"><i>faName</i> <b>optional</b></p>
<p class="Pp"><i>faName</i> <b>union</b> <i>fa</i> ?<i>mapvar</i>?</p>
<p class="Pp"><i>faName</i> <b>intersect</b> <i>fa</i> ?<i>mapvar</i>?</p>
<p class="Pp"><i>faName</i> <b>difference</b> <i>fa</i> ?<i>mapvar</i>?</p>
<p class="Pp"><i>faName</i> <b>concatenate</b> <i>fa</i> ?<i>mapvar</i>?</p>
<p class="Pp"><i>faName</i> <b>fromRegex</b> <i>regex</i> ?<i>over</i>?</p>
<p class="Pp"></p>
<pre>

</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
This package provides a container class for <i>finite automatons</i> (Short:
  FA). It allows the incremental definition of the automaton, its manipulation
  and querying of the definition. While the package provides complex operations
  on the automaton (via package <b>grammar::fa::op</b>), it does not have the
  ability to execute a definition for a stream of symbols. Use the packages
  <b>grammar::fa::dacceptor</b> and <b>grammar::fa::dexec</b> for that. Another
  package related to this is <b>grammar::fa::compiler</b>. It turns a FA into an
  executor class which has the definition of the FA hardwired into it. The
  output of this package is configurable to suit a large number of different
  implementation languages and paradigms.
<p class="Pp">For more information about what a finite automaton is see section
    <b>FINITE AUTOMATONS</b>.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="API"><a class="permalink" href="#API">API</a></h1>
The package exports the API described here.
<dl class="Bl-tag">
  <dt><b>::grammar::fa</b> <i>faName</i>
    ?<b>=</b>|<b>:=</b>|<b>&lt;--</b>|<b>as</b>|<b>deserialize</b>
    <i>src</i>|<b>fromRegex</b> <i>re</i> ?<i>over</i>??</dt>
  <dd>Creates a new finite automaton with an associated global Tcl command whose
      name is <i>faName</i>. This command may be used to invoke various
      operations on the automaton. It has the following general form:</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>faName</b> <i>option</i> ?<i>arg arg ...</i>?</dt>
  <dd><i>Option</i> and the <i>arg</i>s determine the exact behavior of the
      command. See section <b>FA METHODS</b> for more explanations. The new
      automaton will be empty if no <i>src</i> is specified. Otherwise it will
      contain a copy of the definition contained in the <i>src</i>. The
      <i>src</i> has to be a FA object reference for all operators except
      <b>deserialize</b> and <b>fromRegex</b>. The <b>deserialize</b> operator
      requires <i>src</i> to be the serialization of a FA instead, and
      <b>fromRegex</b> takes a regular expression in the form a of a syntax
      tree. See <b>::grammar::fa::op::fromRegex</b> for more detail on
    that.</dd>
</dl>
</div>
</section>
<section class="Sh">
<h1 class="Sh" id="FA_METHODS"><a class="permalink" href="#FA_METHODS">FA
  METHODS</a></h1>
All automatons provide the following methods for their manipulation:
<dl class="Bl-tag">
  <dt><i>faName</i> <b>destroy</b></dt>
  <dd>Destroys the automaton, including its storage space and associated
      command.</dd>
  <dt><i>faName</i> <b>clear</b></dt>
  <dd>Clears out the definition of the automaton contained in <i>faName</i>, but
      does <i>not</i> destroy the object.</dd>
  <dt><i>faName</i> <b>=</b> <i>srcFA</i></dt>
  <dd>Assigns the contents of the automaton contained in <i>srcFA</i> to
      <i>faName</i>, overwriting any existing definition. This is the assignment
      operator for automatons. It copies the automaton contained in the FA
      object <i>srcFA</i> over the automaton definition in <i>faName</i>. The
      old contents of <i>faName</i> are deleted by this operation.
    <p class="Pp">This operation is in effect equivalent to</p>
    <p class="Pp"></p>
    <pre>
    <i>faName</i> <b>deserialize</b> [<i>srcFA</i> <b>serialize</b>]
    </pre>
  </dd>
  <dt><i>faName</i> <b>--&gt;</b> <i>dstFA</i></dt>
  <dd>This is the reverse assignment operator for automatons. It copies the
      automation contained in the object <i>faName</i> over the automaton
      definition in the object <i>dstFA</i>. The old contents of <i>dstFA</i>
      are deleted by this operation.
    <p class="Pp">This operation is in effect equivalent to</p>
    <p class="Pp"></p>
    <pre>
    <i>dstFA</i> <b>deserialize</b> [<i>faName</i> <b>serialize</b>]
    </pre>
  </dd>
  <dt><i>faName</i> <b>serialize</b></dt>
  <dd>This method serializes the automaton stored in <i>faName</i>. In other
      words it returns a tcl <i>value</i> completely describing that automaton.
      This allows, for example, the transfer of automatons over arbitrary
      channels, persistence, etc. This method is also the basis for both the
      copy constructor and the assignment operator.
    <p class="Pp">The result of this method has to be semantically identical
        over all implementations of the <b>grammar::fa</b> interface. This is
        what will enable us to copy automatons between different implementations
        of the same interface.</p>
    <p class="Pp">The result is a list of three elements with the following
        structure:</p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>[1]</dt>
  <dd>The constant string <b>grammar::fa</b>.</dd>
  <dt>[2]</dt>
  <dd>A list containing the names of all known input symbols. The order of
      elements in this list is not relevant.</dd>
  <dt>[3]</dt>
  <dd>The last item in the list is a dictionary, however the order of the keys
      is important as well. The keys are the states of the serialized FA, and
      their order is the order in which to create the states when deserializing.
      This is relevant to preserve the order relationship between states.
    <p class="Pp">The value of each dictionary entry is a list of three elements
        describing the state in more detail.</p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>[1]</dt>
  <dd>A boolean flag. If its value is <b>true</b> then the state is a start
      state, otherwise it is not.</dd>
  <dt>[2]</dt>
  <dd>A boolean flag. If its value is <b>true</b> then the state is a final
      state, otherwise it is not.</dd>
  <dt>[3]</dt>
  <dd>The last element is a dictionary describing the transitions for the state.
      The keys are symbols (or the empty string), and the values are sets of
      successor states.</dd>
</dl>
</div>
</div>
<p class="Pp">Assuming the following FA (which describes the life of a truck
    driver in a very simple way :)</p>
<p class="Pp"></p>
<pre>
    Drive -- yellow --&gt; Brake -- red --&gt; (Stop) -- red/yellow --&gt; Attention -- green --&gt; Drive
    (...) is the start state.
</pre>
<p class="Pp">a possible serialization is</p>
<p class="Pp"></p>
<pre>
    grammar::fa \\
    {yellow red green red/yellow} \\
    {Drive     {0 0 {yellow     Brake}} \\
     Brake     {0 0 {red        Stop}} \\
     Stop      {1 0 {red/yellow Attention}} \\
     Attention {0 0 {green      Drive}}}
</pre>
<p class="Pp">A possible one, because I did not care about creation order
  here</p>
<dl class="Bl-tag">
  <dt><i>faName</i> <b>deserialize</b> <i>serialization</i></dt>
  <dd>This is the complement to <b>serialize</b>. It replaces the automaton
      definition in <i>faName</i> with the automaton described by the
      <i>serialization</i> value. The old contents of <i>faName</i> are deleted
      by this operation.</dd>
  <dt><i>faName</i> <b>states</b></dt>
  <dd>Returns the set of all states known to <i>faName</i>.</dd>
  <dt><i>faName</i> <b>state</b> <b>add</b> <i>s1</i> ?<i>s2</i> ...?</dt>
  <dd>Adds the states <i>s1</i>, <i>s2</i>, et cetera to the FA definition in
      <i>faName</i>. The operation will fail any of the new states is already
      declared.</dd>
  <dt><i>faName</i> <b>state</b> <b>delete</b> <i>s1</i> ?<i>s2</i> ...?</dt>
  <dd>Deletes the state <i>s1</i>, <i>s2</i>, et cetera, and all associated
      information from the FA definition in <i>faName</i>. The latter means that
      the information about in- or outbound transitions is deleted as well. If
      the deleted state was a start or final state then this information is
      invalidated as well. The operation will fail if the state <i>s</i> is not
      known to the FA.</dd>
  <dt><i>faName</i> <b>state</b> <b>exists</b> <i>s</i></dt>
  <dd>A predicate. It tests whether the state <i>s</i> is known to the FA in
      <i>faName</i>. The result is a boolean value. It will be set to
      <b>true</b> if the state <i>s</i> is known, and <b>false</b>
    otherwise.</dd>
  <dt><i>faName</i> <b>state</b> <b>rename</b> <i>s</i> <i>snew</i></dt>
  <dd>Renames the state <i>s</i> to <i>snew</i>. Fails if <i>s</i> is not a
      known state. Also fails if <i>snew</i> is already known as a state.</dd>
  <dt><i>faName</i> <b>startstates</b></dt>
  <dd>Returns the set of states which are marked as <i>start</i> states, also
      known as <i>initial</i> states. See <b>FINITE AUTOMATONS</b> for
      explanations what this means.</dd>
  <dt><i>faName</i> <b>start</b> <b>add</b> <i>s1</i> ?<i>s2</i> ...?</dt>
  <dd>Mark the states <i>s1</i>, <i>s2</i>, et cetera in the FA <i>faName</i> as
      <i>start</i> (aka <i>initial</i>).</dd>
  <dt><i>faName</i> <b>start</b> <b>remove</b> <i>s1</i> ?<i>s2</i> ...?</dt>
  <dd>Mark the states <i>s1</i>, <i>s2</i>, et cetera in the FA <i>faName</i> as
      <i>not start</i> (aka <i>not accepting</i>).</dd>
  <dt><i>faName</i> <b>start?</b> <i>s</i></dt>
  <dd>A predicate. It tests if the state <i>s</i> in the FA <i>faName</i> is
      <i>start</i> or not. The result is a boolean value. It will be set to
      <b>true</b> if the state <i>s</i> is <i>start</i>, and <b>false</b>
      otherwise.</dd>
  <dt><i>faName</i> <b>start?set</b> <i>stateset</i></dt>
  <dd>A predicate. It tests if the set of states <i>stateset</i> contains at
      least one start state. They operation will fail if the set contains an
      element which is not a known state. The result is a boolean value. It will
      be set to <b>true</b> if a start state is present in <i>stateset</i>, and
      <b>false</b> otherwise.</dd>
  <dt><i>faName</i> <b>finalstates</b></dt>
  <dd>Returns the set of states which are marked as <i>final</i> states, also
      known as <i>accepting</i> states. See <b>FINITE AUTOMATONS</b> for
      explanations what this means.</dd>
  <dt><i>faName</i> <b>final</b> <b>add</b> <i>s1</i> ?<i>s2</i> ...?</dt>
  <dd>Mark the states <i>s1</i>, <i>s2</i>, et cetera in the FA <i>faName</i> as
      <i>final</i> (aka <i>accepting</i>).</dd>
  <dt><i>faName</i> <b>final</b> <b>remove</b> <i>s1</i> ?<i>s2</i> ...?</dt>
  <dd>Mark the states <i>s1</i>, <i>s2</i>, et cetera in the FA <i>faName</i> as
      <i>not final</i> (aka <i>not accepting</i>).</dd>
  <dt><i>faName</i> <b>final?</b> <i>s</i></dt>
  <dd>A predicate. It tests if the state <i>s</i> in the FA <i>faName</i> is
      <i>final</i> or not. The result is a boolean value. It will be set to
      <b>true</b> if the state <i>s</i> is <i>final</i>, and <b>false</b>
      otherwise.</dd>
  <dt><i>faName</i> <b>final?set</b> <i>stateset</i></dt>
  <dd>A predicate. It tests if the set of states <i>stateset</i> contains at
      least one final state. They operation will fail if the set contains an
      element which is not a known state. The result is a boolean value. It will
      be set to <b>true</b> if a final state is present in <i>stateset</i>, and
      <b>false</b> otherwise.</dd>
  <dt><i>faName</i> <b>symbols</b></dt>
  <dd>Returns the set of all symbols known to the FA <i>faName</i>.</dd>
  <dt><i>faName</i> <b>symbols@</b> <i>s</i> ?<i>d</i>?</dt>
  <dd>Returns the set of all symbols for which the state <i>s</i> has
      transitions. If the empty symbol is present then <i>s</i> has epsilon
      transitions. If two states are specified the result is the set of symbols
      which have transitions from <i>s</i> to <i>t</i>. This set may be empty if
      there are no transitions between the two specified states.</dd>
  <dt><i>faName</i> <b>symbols@set</b> <i>stateset</i></dt>
  <dd>Returns the set of all symbols for which at least one state in the set of
      states <i>stateset</i> has transitions. In other words, the union of
      [<i>faName</i> <b>symbols@</b> <b>s</b>] for all states <b>s</b> in
      <i>stateset</i>. If the empty symbol is present then at least one state
      contained in <i>stateset</i> has epsilon transitions.</dd>
  <dt><i>faName</i> <b>symbol</b> <b>add</b> <i>sym1</i> ?<i>sym2</i> ...?</dt>
  <dd>Adds the symbols <i>sym1</i>, <i>sym2</i>, et cetera to the FA definition
      in <i>faName</i>. The operation will fail any of the symbols is already
      declared. The empty string is not allowed as a value for the symbols.</dd>
  <dt><i>faName</i> <b>symbol</b> <b>delete</b> <i>sym1</i> ?<i>sym2</i>
    ...?</dt>
  <dd>Deletes the symbols <i>sym1</i>, <i>sym2</i> et cetera, and all associated
      information from the FA definition in <i>faName</i>. The latter means that
      all transitions using the symbols are deleted as well. The operation will
      fail if any of the symbols is not known to the FA.</dd>
  <dt><i>faName</i> <b>symbol</b> <b>rename</b> <i>sym</i> <i>newsym</i></dt>
  <dd>Renames the symbol <i>sym</i> to <i>newsym</i>. Fails if <i>sym</i> is not
      a known symbol. Also fails if <i>newsym</i> is already known as a
    symbol.</dd>
  <dt><i>faName</i> <b>symbol</b> <b>exists</b> <i>sym</i></dt>
  <dd>A predicate. It tests whether the symbol <i>sym</i> is known to the FA in
      <i>faName</i>. The result is a boolean value. It will be set to
      <b>true</b> if the symbol <i>sym</i> is known, and <b>false</b>
    otherwise.</dd>
  <dt><i>faName</i> <b>next</b> <i>s</i> <i>sym</i> ?<b>--&gt;</b>
    <i>next</i>?</dt>
  <dd>Define or query transition information.
    <p class="Pp">If <i>next</i> is specified, then the method will add a
        transition from the state <i>s</i> to the <i>successor</i> state
        <i>next</i> labeled with the symbol <i>sym</i> to the FA contained in
        <i>faName</i>. The operation will fail if <i>s</i>, or <i>next</i> are
        not known states, or if <i>sym</i> is not a known symbol. An exception
        to the latter is that <i>sym</i> is allowed to be the empty string. In
        that case the new transition is an <i>epsilon transition</i> which will
        not consume input when traversed. The operation will also fail if the
        combination of (<i>s</i>, <i>sym</i>, and <i>next</i>) is already
        present in the FA.</p>
    <p class="Pp">If <i>next</i> was not specified, then the method will return
        the set of states which can be reached from <i>s</i> through a single
        transition labeled with symbol <i>sym</i>.</p>
  </dd>
  <dt><i>faName</i> <b>!next</b> <i>s</i> <i>sym</i> ?<b>--&gt;</b>
    <i>next</i>?</dt>
  <dd>Remove one or more transitions from the Fa in <i>faName</i>.
    <p class="Pp">If <i>next</i> was specified then the single transition from
        the state <i>s</i> to the state <i>next</i> labeled with the symbol
        <i>sym</i> is removed from the FA. Otherwise <i>all</i> transitions
        originating in state <i>s</i> and labeled with the symbol <i>sym</i>
        will be removed.</p>
    <p class="Pp">The operation will fail if <i>s</i> and/or <i>next</i> are not
        known as states. It will also fail if a non-empty <i>sym</i> is not
        known as symbol. The empty string is acceptable, and allows the removal
        of epsilon transitions.</p>
  </dd>
  <dt><i>faName</i> <b>nextset</b> <i>stateset</i> <i>sym</i></dt>
  <dd>Returns the set of states which can be reached by a single transition
      originating in a state in the set <i>stateset</i> and labeled with the
      symbol <i>sym</i>.
    <p class="Pp">In other words, this is the union of [<i>faName</i> next
        <b>s</b> <i>symbol</i>] for all states <b>s</b> in <i>stateset</i>.</p>
  </dd>
  <dt><i>faName</i> <b>is</b> <b>deterministic</b></dt>
  <dd>A predicate. It tests whether the FA in <i>faName</i> is a deterministic
      FA or not. The result is a boolean value. It will be set to <b>true</b> if
      the FA is deterministic, and <b>false</b> otherwise.</dd>
  <dt><i>faName</i> <b>is</b> <b>complete</b></dt>
  <dd>A predicate. It tests whether the FA in <i>faName</i> is a complete FA or
      not. A FA is complete if it has at least one transition per state and
      symbol. This also means that a FA without symbols, or states is also
      complete. The result is a boolean value. It will be set to <b>true</b> if
      the FA is deterministic, and <b>false</b> otherwise.
    <p class="Pp">Note: When a FA has epsilon-transitions transitions over a
        symbol for a state S can be indirect, i.e. not attached directly to S,
        but to a state in the epsilon-closure of S. The symbols for such
        indirect transitions count when computing completeness.</p>
  </dd>
  <dt><i>faName</i> <b>is</b> <b>useful</b></dt>
  <dd>A predicate. It tests whether the FA in <i>faName</i> is an useful FA or
      not. A FA is useful if all states are <i>reachable</i> and <i>useful</i>.
      The result is a boolean value. It will be set to <b>true</b> if the FA is
      deterministic, and <b>false</b> otherwise.</dd>
  <dt><i>faName</i> <b>is</b> <b>epsilon-free</b></dt>
  <dd>A predicate. It tests whether the FA in <i>faName</i> is an epsilon-free
      FA or not. A FA is epsilon-free if it has no epsilon transitions. This
      definition means that all deterministic FAs are epsilon-free as well, and
      epsilon-freeness is a necessary pre-condition for deterministic'ness. The
      result is a boolean value. It will be set to <b>true</b> if the FA is
      deterministic, and <b>false</b> otherwise.</dd>
  <dt><i>faName</i> <b>reachable_states</b></dt>
  <dd>Returns the set of states which are reachable from a start state by one or
      more transitions.</dd>
  <dt><i>faName</i> <b>unreachable_states</b></dt>
  <dd>Returns the set of states which are not reachable from any start state by
      any number of transitions. This is
    <p class="Pp"></p>
    <pre>
	 [faName states] - [faName reachable_states]
    </pre>
  </dd>
  <dt><i>faName</i> <b>reachable</b> <i>s</i></dt>
  <dd>A predicate. It tests whether the state <i>s</i> in the FA <i>faName</i>
      can be reached from a start state by one or more transitions. The result
      is a boolean value. It will be set to <b>true</b> if the state can be
      reached, and <b>false</b> otherwise.</dd>
  <dt><i>faName</i> <b>useful_states</b></dt>
  <dd>Returns the set of states which are able to reach a final state by one or
      more transitions.</dd>
  <dt><i>faName</i> <b>unuseful_states</b></dt>
  <dd>Returns the set of states which are not able to reach a final state by any
      number of transitions. This is
    <p class="Pp"></p>
    <pre>
	 [faName states] - [faName useful_states]
    </pre>
  </dd>
  <dt><i>faName</i> <b>useful</b> <i>s</i></dt>
  <dd>A predicate. It tests whether the state <i>s</i> in the FA <i>faName</i>
      is able to reach a final state by one or more transitions. The result is a
      boolean value. It will be set to <b>true</b> if the state is useful, and
      <b>false</b> otherwise.</dd>
  <dt><i>faName</i> <b>epsilon_closure</b> <i>s</i></dt>
  <dd>Returns the set of states which are reachable from the state <i>s</i> in
      the FA <i>faName</i> by one or more epsilon transitions, i.e transitions
      over the empty symbol, transitions which do not consume input. This is
      called the <i>epsilon closure</i> of <i>s</i>.</dd>
  <dt><i>faName</i> <b>reverse</b></dt>
  <dd></dd>
  <dt><i>faName</i> <b>complete</b></dt>
  <dd></dd>
  <dt><i>faName</i> <b>remove_eps</b></dt>
  <dd></dd>
  <dt><i>faName</i> <b>trim</b> ?<i>what</i>?</dt>
  <dd></dd>
  <dt><i>faName</i> <b>determinize</b> ?<i>mapvar</i>?</dt>
  <dd></dd>
  <dt><i>faName</i> <b>minimize</b> ?<i>mapvar</i>?</dt>
  <dd></dd>
  <dt><i>faName</i> <b>complement</b></dt>
  <dd></dd>
  <dt><i>faName</i> <b>kleene</b></dt>
  <dd></dd>
  <dt><i>faName</i> <b>optional</b></dt>
  <dd></dd>
  <dt><i>faName</i> <b>union</b> <i>fa</i> ?<i>mapvar</i>?</dt>
  <dd></dd>
  <dt><i>faName</i> <b>intersect</b> <i>fa</i> ?<i>mapvar</i>?</dt>
  <dd></dd>
  <dt><i>faName</i> <b>difference</b> <i>fa</i> ?<i>mapvar</i>?</dt>
  <dd></dd>
  <dt><i>faName</i> <b>concatenate</b> <i>fa</i> ?<i>mapvar</i>?</dt>
  <dd></dd>
  <dt><i>faName</i> <b>fromRegex</b> <i>regex</i> ?<i>over</i>?</dt>
  <dd>These methods provide more complex operations on the FA. Please see the
      same-named commands in the package <b>grammar::fa::op</b> for descriptions
      of what they do.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="EXAMPLES"><a class="permalink" href="#EXAMPLES">EXAMPLES</a></h1>
</section>
<section class="Sh">
<h1 class="Sh" id="FINITE_AUTOMATONS"><a class="permalink" href="#FINITE_AUTOMATONS">FINITE
  AUTOMATONS</a></h1>
For the mathematically inclined, a FA is a 5-tuple (S,Sy,St,Fi,T) where
<ul class="Bl-bullet">
  <li>S is a set of <i>states</i>,</li>
  <li>Sy a set of <i>input symbols</i>,</li>
  <li>St is a subset of S, the set of <i>start</i> states, also known as
      <i>initial</i> states.</li>
  <li>Fi is a subset of S, the set of <i>final</i> states, also known as
      <i>accepting</i>.</li>
  <li>T is a function from S x (Sy + epsilon) to {S}, the <i>transition
      function</i>. Here <b>epsilon</b> denotes the empty input symbol and is
      distinct from all symbols in Sy; and {S} is the set of subsets of S. In
      other words, T maps a combination of State and Input (which can be empty)
      to a set of <i>successor states</i>.</li>
</ul>
<p class="Pp">In computer theory a FA is most often shown as a graph where the
    nodes represent the states, and the edges between the nodes encode the
    transition function: For all n in S' = T (s, sy) we have one edge between
    the nodes representing s and n resp., labeled with sy. The start and
    accepting states are encoded through distinct visual markers, i.e. they are
    attributes of the nodes.</p>
<p class="Pp">FA's are used to process streams of symbols over Sy.</p>
<p class="Pp">A specific FA is said to <i>accept</i> a finite stream sy_1 sy_2
    state in St and ending at a state in Fi whose edges have the labels sy_1,
    sy_2, etc. to sy_n. The set of all strings accepted by the FA is the
    <i>language</i> of the FA. One important equivalence is that the set of
    languages which can be accepted by an FA is the set of <i>regular
    languages</i>.</p>
<p class="Pp">Another important concept is that of deterministic FAs. A FA is
    said to be <i>deterministic</i> if for each string of input symbols there is
    exactly one path in the graph of the FA beginning at the start state and
    whose edges are labeled with the symbols in the string. While it might seem
    that non-deterministic FAs to have more power of recognition, this is not
    so. For each non-deterministic FA we can construct a deterministic FA which
    accepts the same language (--&gt; Thompson's subset construction).</p>
<p class="Pp">While one of the premier applications of FAs is in <i>parsing</i>,
    especially in the <i>lexer</i> stage (where symbols == characters), this is
    not the only possibility by far.</p>
<p class="Pp">Quite a lot of processes can be modeled as a FA, albeit with a
    possibly large set of states. For these the notion of accepting states is
    often less or not relevant at all. What is needed instead is the ability to
    act to state changes in the FA, i.e. to generate some output in response to
    the input. This transforms a FA into a <i>finite transducer</i>, which has
    an additional set OSy of <i>output symbols</i> and also an additional
    <i>output function</i> O which maps from &quot;S x (Sy + epsilon)&quot; to
    &quot;(Osy + epsilon)&quot;, i.e a combination of state and input, possibly
    empty to an output symbol, or nothing.</p>
<p class="Pp">For the graph representation this means that edges are additional
    labeled with the output symbol to write when this edge is traversed while
    matching input. Note that for an application &quot;writing an output
    symbol&quot; can also be &quot;executing some code&quot;.</p>
<p class="Pp">Transducers are not handled by this package. They will get their
    own package in the future.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="BUGS,_IDEAS,_FEEDBACK"><a class="permalink" href="#BUGS,_IDEAS,_FEEDBACK">BUGS,
  IDEAS, FEEDBACK</a></h1>
This document, and the package it describes, will undoubtedly contain bugs and
  other problems. Please report such in the category <i>grammar_fa</i> of the
  <i>Tcllib SF Trackers</i> [http://sourceforge.net/tracker/?group_id=12883].
  Please also report any ideas for enhancements you may have for either package
  and/or documentation.
</section>
<section class="Sh">
<h1 class="Sh" id="KEYWORDS"><a class="permalink" href="#KEYWORDS">KEYWORDS</a></h1>
automaton, finite automaton, grammar, parsing, regular expression, regular
  grammar, regular languages, state, transducer
</section>
<section class="Sh">
<h1 class="Sh" id="CATEGORY"><a class="permalink" href="#CATEGORY">CATEGORY</a></h1>
Grammars and finite automata
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT"><a class="permalink" href="#COPYRIGHT">COPYRIGHT</a></h1>
<pre>
Copyright (c) 2004-2009 Andreas Kupries &lt;andreas_kupries@users.sourceforge.net&gt;
</pre>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">0.4</td>
    <td class="foot-os">grammar_fa</td>
  </tr>
</table>
</body>
</html>
