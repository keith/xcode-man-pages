<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    .Nd, .Bf, .Op { display: inline; }
    .Pa, .Ad { font-style: italic; }
    .Ms { font-weight: bold; }
    .Bl-diag > dt { font-weight: bold; }
    code.Nm, .Fl, .Cm, .Ic, code.In, .Fd, .Fn, .Cd { font-weight: bold;
      font-family: inherit; }
  </style>
  <title>DBD::SQLite::VirtualTable(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">DBD::SQLite::VirtualTable(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">DBD::SQLite::VirtualTable(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">DBD::SQLite::VirtualTable -- SQLite virtual tables implemented in
    Perl</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>  # register the virtual table module within sqlite
  $dbh-&gt;sqlite_create_module(mod_name =&gt; &quot;DBD::SQLite::VirtualTable::Subclass&quot;);
  # create a virtual table
  $dbh-&gt;do(&quot;CREATE VIRTUAL TABLE vtbl USING mod_name(arg1, arg2, ...)&quot;)
  # use it as any regular table
  my $sth = $dbh-&gt;prepare(&quot;SELECT * FROM vtbl WHERE ...&quot;);
</pre>
<p class="Pp"><b>Note</b> : VirtualTable subclasses or instances are not called
    directly from Perl code; everything happens indirectly through SQL
    statements within SQLite.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">This module is an abstract class for implementing SQLite virtual
    tables, written in Perl. Such tables look like regular tables, and are
    accessed through regular SQL instructions and regular DBI API; but the
    implementation is done through hidden calls to a Perl class. This is the
    same idea as Perl's tied variables, but at the SQLite level.</p>
<p class="Pp">The current abstract class cannot be used directly, so the
    synopsis above is just to give a general idea. Concrete, usable classes
    bundled with the present distribution are :</p>
<ul class="Bl-bullet">
  <li>DBD::SQLite::VirtualTable::FileContent : implements a virtual column that
      exposes file contents. This is especially useful in conjunction with a
      fulltext index; see DBD::SQLite::Fulltext_search.</li>
  <li>DBD::SQLite::VirtualTable::PerlData : binds to a Perl array within the
      Perl program. This can be used for simple import/export operations, for
      debugging purposes, for joining data from different sources, etc.</li>
</ul>
<p class="Pp">Other Perl virtual tables may also be published separately on
    CPAN.</p>
<p class="Pp">The following chapters document the structure of the abstract
    class and explain how to write new subclasses; this is meant for <b>module
    authors</b>, not for end users. If you just need to use a virtual table
    module, refer to that module's documentation.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="ARCHITECTURE"><a class="permalink" href="#ARCHITECTURE">ARCHITECTURE</a></h1>
<section class="Ss">
<h2 class="Ss" id="Classes"><a class="permalink" href="#Classes">Classes</a></h2>
<p class="Pp">A virtual table module for SQLite is implemented through a pair of
    classes :</p>
<ul class="Bl-bullet">
  <li>the <b>table</b> class implements methods for creating or connecting a
      virtual table, for destroying it, for opening new searches, etc.</li>
  <li>the <b>cursor</b> class implements methods for performing a specific SQL
      statement</li>
</ul>
</section>
<section class="Ss">
<h2 class="Ss" id="Methods"><a class="permalink" href="#Methods">Methods</a></h2>
<p class="Pp">Most methods in both classes are not called directly from Perl
    code : instead, they are callbacks, called from the sqlite kernel. Following
    common Perl conventions, such methods have names in uppercase.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="TABLE_METHODS"><a class="permalink" href="#TABLE_METHODS">TABLE
  METHODS</a></h1>
<section class="Ss">
<h2 class="Ss" id="Class_methods_for_registering_the_module"><a class="permalink" href="#Class_methods_for_registering_the_module">Class
  methods for registering the module</a></h2>
<p class="Pp"><i>CREATE_MODULE</i></p>
<p class="Pp"></p>
<pre>  $class-&gt;CREATE_MODULE($sqlite_module_name);
</pre>
<p class="Pp">Called when the client code invokes</p>
<p class="Pp"></p>
<pre>  $dbh-&gt;sqlite_create_module($sqlite_module_name =&gt; $class);
</pre>
<p class="Pp">The default implementation is empty.</p>
<p class="Pp"><i>DESTROY_MODULE</i></p>
<p class="Pp"></p>
<pre>  $class-&gt;DESTROY_MODULE();
</pre>
<p class="Pp">Called automatically when the database handle is disconnected. The
    default implementation is empty.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Class_methods_for_creating_a_vtable_instance"><a class="permalink" href="#Class_methods_for_creating_a_vtable_instance">Class
  methods for creating a vtable instance</a></h2>
<p class="Pp"><i>CREATE</i></p>
<p class="Pp"></p>
<pre>  $class-&gt;CREATE($dbh_ref, $module_name, $db_name, $vtab_name, @args);
</pre>
<p class="Pp">Called when sqlite receives a statement</p>
<p class="Pp"></p>
<pre>  CREATE VIRTUAL TABLE $db_name.$vtab_name USING $module_name(@args)
</pre>
<p class="Pp">The default implementation just calls &quot;NEW&quot;.</p>
<p class="Pp"><i>CONNECT</i></p>
<p class="Pp"></p>
<pre>  $class-&gt;CONNECT($dbh_ref, $module_name, $db_name, $vtab_name, @args);
</pre>
<p class="Pp">Called when attempting to access a virtual table that had been
    created during previous database connection. The creation arguments were
    stored within the sqlite database and are passed again to the CONNECT
    method.</p>
<p class="Pp">The default implementation just calls &quot;NEW&quot;.</p>
<p class="Pp"><i>_PREPARE_SELF</i></p>
<p class="Pp"></p>
<pre>  $class-&gt;_PREPARE_SELF($dbh_ref, $module_name, $db_name, $vtab_name, @args);
</pre>
<p class="Pp">Prepares the datastructure for a virtual table instance.
    <span class="Li">@args</span> is
  <br/>
   just the collection of strings (comma-separated) that were given
  <br/>
   within the <span class="Li">&quot;CREATE VIRTUAL TABLE&quot;</span>
    statement; each subclass should
  <br/>
   decide what to do with this information,</p>
<p class="Pp">The method parses <span class="Li">@args</span> to differentiate
    between <i>options</i> (strings of shape
    <span class="Li">$key</span>=<span class="Li">$value</span> or
    <span class="Li">$key</span>=<span class="Li">&quot;$value&quot;</span>,
    stored in <span class="Li">&quot;$self-&gt;{options}&quot;</span>), and
    <i>columns</i> (other <span class="Li">@args</span>, stored in
    <span class="Li">&quot;$self-&gt;{columns}&quot;</span>). It creates a
    hashref with the following fields :</p>
<dl class="Bl-tag">
  <dt>&quot;dbh_ref&quot;</dt>
  <dd>a weak reference to the <span class="Li">$dbh</span> database handle (see
      Scalar::Util for an explanation of weak references).</dd>
  <dt>&quot;module_name&quot;</dt>
  <dd>name of the module as declared to sqlite (not to be confounded with the
      Perl class name).</dd>
  <dt>&quot;db_name&quot;</dt>
  <dd>name of the database (usuallly <span class="Li">'main'</span> or
      <span class="Li">'temp'</span>), but it may also be an attached
    database</dd>
  <dt>&quot;vtab_name&quot;</dt>
  <dd>name of the virtual table</dd>
  <dt>&quot;columns&quot;</dt>
  <dd>arrayref of column declarations</dd>
  <dt>&quot;options&quot;</dt>
  <dd>hashref of option declarations</dd>
</dl>
<p class="Pp">This method should not be redefined, since it performs general
    work which is supposed to be useful for all subclasses. Instead, subclasses
    may override the &quot;NEW&quot; method.</p>
<p class="Pp"><i>NEW</i></p>
<p class="Pp"></p>
<pre>  $class-&gt;NEW($dbh_ref, $module_name, $db_name, $vtab_name, @args);
</pre>
<p class="Pp">Instantiates a virtual table.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Instance_methods_called_from_the_sqlite_kernel"><a class="permalink" href="#Instance_methods_called_from_the_sqlite_kernel">Instance
  methods called from the sqlite kernel</a></h2>
<p class="Pp"><i>DROP</i></p>
<p class="Pp">Called whenever a virtual table is destroyed from the database
    through the <span class="Li">&quot;DROP TABLE&quot;</span> SQL
  instruction.</p>
<p class="Pp">Just after the <span class="Li">&quot;DROP()&quot;</span> call,
    the Perl instance will be destroyed (and will therefore automatically call
    the <span class="Li">&quot;DESTROY()&quot;</span> method if such a method is
    present).</p>
<p class="Pp">The default implementation for DROP is empty.</p>
<p class="Pp"><b>Note</b> : this corresponds to the
    <span class="Li">&quot;xDestroy&quot;</span> method in the SQLite
    documentation; here it was not named
    <span class="Li">&quot;DESTROY&quot;</span>, to avoid any confusion with the
    standard Perl method <span class="Li">&quot;DESTROY&quot;</span> for object
    destruction.</p>
<p class="Pp"><i>DISCONNECT</i></p>
<p class="Pp">Called for every virtual table just before the database handle is
    disconnected.</p>
<p class="Pp">Just after the <span class="Li">&quot;DISCONNECT()&quot;</span>
    call, the Perl instance will be destroyed (and will therefore automatically
    call the <span class="Li">&quot;DESTROY()&quot;</span> method if such a
    method is present).</p>
<p class="Pp">The default implementation for DISCONNECT is empty.</p>
<p class="Pp"><i>VTAB_TO_DECLARE</i></p>
<p class="Pp">This method is called automatically just after &quot;CREATE&quot;
    or &quot;CONNECT&quot;, to register the columns of the virtual table within
    the sqlite kernel. The method should return a string containing a SQL
    <span class="Li">&quot;CREATE TABLE&quot;</span> statement; but only the
    column declaration parts will be considered. Columns may be declared with
    the special keyword &quot;HIDDEN&quot;, which means that they are used
    internally for the the virtual table implementation, and are not visible to
    users -- see &lt;http://sqlite.org/c3ref/declare_vtab.html&gt; and
    &lt;http://www.sqlite.org/vtab.html#hiddencol&gt; for detailed
  explanations.</p>
<p class="Pp">The default implementation returns:</p>
<p class="Pp"></p>
<pre>  CREATE TABLE $self-&gt;{vtab_name}(@{$self-&gt;{columns}})
</pre>
<p class="Pp"><i>BEST_INDEX</i></p>
<p class="Pp"></p>
<pre>  my $index_info = $vtab-&gt;BEST_INDEX($constraints, $order_by)
</pre>
<p class="Pp">This is the most complex method to redefined in subclasses. This
    method will be called at the beginning of a new query on the virtual table;
    the job of the method is to assemble some information that will be used</p>
<dl class="Bl-tag">
  <dt id="a)"><a class="permalink" href="#a)">a)</a></dt>
  <dd>by the sqlite kernel to decide about the best search strategy</dd>
  <dt id="b)"><a class="permalink" href="#b)">b)</a></dt>
  <dd>by the cursor &quot;FILTER&quot; method to produce the desired subset of
      rows from the virtual table.</dd>
</dl>
<p class="Pp">By calling this method, the SQLite core is saying to the virtual
    table that it needs to access some subset of the rows in the virtual table
    and it wants to know the most efficient way to do that access. The
    <span class="Li">&quot;BEST_INDEX&quot;</span> method replies with
    information that the SQLite core can then use to conduct an efficient search
    of the virtual table.</p>
<p class="Pp">The method takes as input a list of
    <span class="Li">$constraints</span> and a list of
    <span class="Li">$order_by</span> instructions. It returns a hashref of
    indexing properties, described below; furthermore, the method also adds
    supplementary information within the input
    <span class="Li">$constraints</span>. Detailed explanations are given in
    &lt;http://sqlite.org/vtab.html#xbestindex&gt;.</p>
<p class="Pp">Input constraints</p>
<p class="Pp">Elements of the <span class="Li">$constraints</span> arrayref
    correspond to specific clauses of the <span class="Li">&quot;WHERE
    ...&quot;</span> part of the SQL query. Each constraint is a hashref with
    keys :</p>
<dl class="Bl-tag">
  <dt>&quot;col&quot;</dt>
  <dd>the integer index of the column on the left-hand side of the
    constraint</dd>
  <dt>&quot;op&quot;</dt>
  <dd>the comparison operator, expressed as string containing
      <span class="Li">'='</span>, <span class="Li">'&gt;'</span>,
      <span class="Li">'&gt;='</span>, <span class="Li">'&lt;'</span>,
      <span class="Li">'&lt;='</span> or <span class="Li">'MATCH'</span>.</dd>
  <dt>&quot;usable&quot;</dt>
  <dd>a boolean indicating if that constraint is usable; some constraints might
      not be usable because of the way tables are ordered in a join.</dd>
</dl>
<p class="Pp">The <span class="Li">$constraints</span> arrayref is used both for
    input and for output. While iterating over the array, the method should add
    the following keys into usable constraints :</p>
<dl class="Bl-tag">
  <dt>&quot;argvIndex&quot;</dt>
  <dd>An index into the <span class="Li">@values</span> array that will be
      passed to the cursor's &quot;FILTER&quot; method. In other words, if the
      current constraint corresponds to the SQL fragment
      <span class="Li">&quot;WHERE ... AND foo &lt; 123 ...&quot;</span>, and
      the corresponding <span class="Li">&quot;argvIndex&quot;</span> takes
      value 5, this means that the <span class="Li">&quot;FILTER&quot;</span>
      method will receive <span class="Li">123</span> in
      <span class="Li">$values[5]</span>.</dd>
  <dt>&quot;omit&quot;</dt>
  <dd>A boolean telling to the sqlite core that it can safely omit to double
      check that constraint before returning the resultset to the calling
      program; this means that the FILTER method has fulfilled the filtering job
      on that constraint and there is no need to do any further checking.</dd>
</dl>
<p class="Pp">The <span class="Li">&quot;BEST_INDEX&quot;</span> method will not
    necessarily receive all constraints from the SQL
    <span class="Li">&quot;WHERE&quot;</span> clause : for example a constraint
    like <span class="Li">&quot;col1 &lt; col2 + col3&quot;</span> cannot be
    handled at this level. Furthemore, the
    <span class="Li">&quot;BEST_INDEX&quot;</span> might decide to ignore some
    of the received constraints. This is why a second pass over the results will
    be performed by the sqlite core.</p>
<p class="Pp">&quot;order_by&quot; input information</p>
<p class="Pp">The <span class="Li">$order_by</span> arrayref corresponds to the
    <span class="Li">&quot;ORDER BY&quot;</span> clauses in the SQL query. Each
    entry is a hashref with keys :</p>
<dl class="Bl-tag">
  <dt>&quot;col&quot;</dt>
  <dd>the integer index of the column being ordered</dd>
  <dt>&quot;desc&quot;</dt>
  <dd>a boolean telling of the ordering is DESCending or ascending</dd>
</dl>
<p class="Pp">This information could be used by some subclasses for optimizing
    the query strategfy; but usually the sqlite core will perform another
    sorting pass once all results are gathered.</p>
<p class="Pp">Hashref information returned by BEST_INDEX</p>
<p class="Pp">The method should return a hashref with the following keys :</p>
<dl class="Bl-tag">
  <dt>&quot;idxNum&quot;</dt>
  <dd>An arbitrary integer associated with that index; this information will be
      passed back to &quot;FILTER&quot;.</dd>
  <dt>&quot;idxStr&quot;</dt>
  <dd>An arbitrary str associated with that index; this information will be
      passed back to &quot;FILTER&quot;.</dd>
  <dt>&quot;orderByConsumed&quot;</dt>
  <dd>A boolean telling the sqlite core if the <span class="Li">$order_by</span>
      information has been taken into account or not.</dd>
  <dt>&quot;estimatedCost&quot;</dt>
  <dd>A float that should be set to the estimated number of disk access
      operations required to execute this query against the virtual table. The
      SQLite core will often call BEST_INDEX multiple times with different
      constraints, obtain multiple cost estimates, then choose the query plan
      that gives the lowest estimate.</dd>
  <dt>&quot;estimatedRows&quot;</dt>
  <dd>An integer giving the estimated number of rows returned by that
    query.</dd>
</dl>
<p class="Pp"><i>OPEN</i></p>
<p class="Pp">Called to instantiate a new cursor. The default implementation
    appends <span class="Li">&quot;::Cursor&quot;</span> to the current
    classname and calls <span class="Li">&quot;NEW()&quot;</span> within that
    cursor class.</p>
<p class="Pp"><i>_SQLITE_UPDATE</i></p>
<p class="Pp">This is the dispatch method implementing the
    <span class="Li">&quot;xUpdate()&quot;</span> callback for virtual tables.
    The default implementation applies the algorithm described in
    &lt;http://sqlite.org/vtab.html#xupdate&gt; to decide to call
    &quot;INSERT&quot;, &quot;DELETE&quot; or &quot;UPDATE&quot;; so there is no
    reason to override this method in subclasses.</p>
<p class="Pp"><i>INSERT</i></p>
<p class="Pp"></p>
<pre>  my $rowid = $vtab-&gt;INSERT($new_rowid, @values);
</pre>
<p class="Pp">This method should be overridden in subclasses to implement
    insertion of a new row into the virtual table. The size of the
    <span class="Li">@values</span> array corresponds to the number of columns
    declared through &quot;VTAB_TO_DECLARE&quot;. The
    <span class="Li">$new_rowid</span> may be explicitly given, or it may be
    <span class="Li">&quot;undef&quot;</span>, in which case the method must
    compute a new id and return it as the result of the method call.</p>
<p class="Pp"><i>DELETE</i></p>
<p class="Pp"></p>
<pre>  $vtab-&gt;INSERT($old_rowid);
</pre>
<p class="Pp">This method should be overridden in subclasses to implement
    deletion of a row from the virtual table.</p>
<p class="Pp"><i>UPDATE</i></p>
<p class="Pp"></p>
<pre>  $vtab-&gt;UPDATE($old_rowid, $new_rowid, @values);
</pre>
<p class="Pp">This method should be overridden in subclasses to implement a row
    update within the virtual table. Usually <span class="Li">$old_rowid</span>
    is equal to <span class="Li">$new_rowid</span>, which is a regular update;
    however, the rowid could be changed from a SQL statement such as</p>
<p class="Pp"></p>
<pre>  UPDATE table SET rowid=rowid+1 WHERE ...;
</pre>
<p class="Pp"><i>FIND_FUNCTION</i></p>
<p class="Pp"></p>
<pre>  $vtab-&gt;FIND_FUNCTION($num_args, $func_name);
</pre>
<p class="Pp">When a function uses a column from a virtual table as its first
    argument, this method is called to see if the virtual table would like to
    overload the function. Parameters are the number of arguments to the
    function, and the name of the function. If no overloading is desired, this
    method should return false. To overload the function, this method should
    return a coderef to the function implementation.</p>
<p class="Pp">Each virtual table keeps a cache of results from FIND_FUNCTION
    calls, so the method will be called only once for each pair
    <span class="Li">&quot;($num_args, $func_name)&quot;</span>.</p>
<p class="Pp"><i>BEGIN_TRANSACTION</i></p>
<p class="Pp">Called to begin a transaction on the virtual table.</p>
<p class="Pp"><i>SYNC_TRANSACTION</i></p>
<p class="Pp">Called to signal the start of a two-phase commit on the virtual
    table.</p>
<p class="Pp"><i>SYNC_TRANSACTION</i></p>
<p class="Pp">Called to commit a virtual table transaction.</p>
<p class="Pp"><i>ROLLBACK_TRANSACTION</i></p>
<p class="Pp">Called to rollback a virtual table transaction.</p>
<p class="Pp"><i>RENAME</i></p>
<p class="Pp"></p>
<pre>  $vtab-&gt;RENAME($new_name)
</pre>
<p class="Pp">Called to rename a virtual table.</p>
<p class="Pp"><i>SAVEPOINT</i></p>
<p class="Pp"></p>
<pre>  $vtab-&gt;SAVEPOINT($savepoint)
</pre>
<p class="Pp">Called to signal the virtual table to save its current state at
    savepoint <span class="Li">$savepoint</span> (an integer).</p>
<p class="Pp"><i>ROLLBACK_TO</i></p>
<p class="Pp"></p>
<pre>  $vtab-&gt;ROLLBACK_TO($savepoint)
</pre>
<p class="Pp">Called to signal the virtual table to return to the state
    <span class="Li">$savepoint</span>. This will invalidate all savepoints with
    values greater than <span class="Li">$savepoint</span>.</p>
<p class="Pp"><i>RELEASE</i></p>
<p class="Pp"></p>
<pre>  $vtab-&gt;RELEASE($savepoint)
</pre>
<p class="Pp">Called to invalidate all savepoints with values greater or equal
    to <span class="Li">$savepoint</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Utility_instance_methods"><a class="permalink" href="#Utility_instance_methods">Utility
  instance methods</a></h2>
<p class="Pp">Methods in this section are in lower case, because they are not
    called directly from the sqlite kernel; these are utility methods to be
    called from other methods described above.</p>
<p class="Pp"><i>dbh</i></p>
<p class="Pp">This method returns the database handle
    (<span class="Li">$dbh</span>) associated with the current virtual
  table.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="CURSOR_METHODS"><a class="permalink" href="#CURSOR_METHODS">CURSOR
  METHODS</a></h1>
<section class="Ss">
<h2 class="Ss" id="Class_methods"><a class="permalink" href="#Class_methods">Class
  methods</a></h2>
<p class="Pp"><i>NEW</i></p>
<p class="Pp"></p>
<pre>  my $cursor = $cursor_class-&gt;NEW($vtable, @args)
</pre>
<p class="Pp">Instantiates a new cursor. The default implementation just returns
    a blessed hashref with keys <span class="Li">&quot;vtable&quot;</span> and
    <span class="Li">&quot;args&quot;</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Instance_methods"><a class="permalink" href="#Instance_methods">Instance
  methods</a></h2>
<p class="Pp"><i>FILTER</i></p>
<p class="Pp"></p>
<pre>  $cursor-&gt;FILTER($idxNum, $idxStr, @values);
</pre>
<p class="Pp">This method begins a search of a virtual table.</p>
<p class="Pp">The <span class="Li">$idxNum</span> and
    <span class="Li">$idxStr</span> arguments correspond to values returned by
    &quot;BEST_INDEX&quot; for the chosen index. The specific meanings of those
    values are unimportant to SQLite, as long as
    <span class="Li">&quot;BEST_INDEX&quot;</span> and
    <span class="Li">&quot;FILTER&quot;</span> agree on what that meaning
  is.</p>
<p class="Pp">The <span class="Li">&quot;BEST_INDEX&quot;</span> method may have
    requested the values of certain expressions using the
    <span class="Li">&quot;argvIndex&quot;</span> values of the
    <span class="Li">$constraints</span> list. Those values are passed to
    <span class="Li">&quot;FILTER&quot;</span> through the
    <span class="Li">@values</span> array.</p>
<p class="Pp">If the virtual table contains one or more rows that match the
    search criteria, then the cursor must be left point at the first row.
    Subsequent calls to &quot;EOF&quot; must return false. If there are no rows
    match, then the cursor must be left in a state that will cause
    &quot;EOF&quot; to return true. The SQLite engine will use the
    &quot;COLUMN&quot; and &quot;ROWID&quot; methods to access that row content.
    The &quot;NEXT&quot; method will be used to advance to the next row.</p>
<p class="Pp"><i>EOF</i></p>
<p class="Pp">This method must return false if the cursor currently points to a
    valid row of data, or true otherwise. This method is called by the SQL
    engine immediately after each &quot;FILTER&quot; and &quot;NEXT&quot;
    invocation.</p>
<p class="Pp"><i>NEXT</i></p>
<p class="Pp">This method advances the cursor to the next row of a result set
    initiated by &quot;FILTER&quot;. If the cursor is already pointing at the
    last row when this method is called, then the cursor no longer points to
    valid data and a subsequent call to the &quot;EOF&quot; method must return
    true. If the cursor is successfully advanced to another row of content, then
    subsequent calls to &quot;EOF&quot; must return false.</p>
<p class="Pp"><i>COLUMN</i></p>
<p class="Pp"></p>
<pre>  my $value = $cursor-&gt;COLUMN($idxCol);
</pre>
<p class="Pp">The SQLite core invokes this method in order to find the value for
    the N-th column of the current row. N is zero-based so the first column is
    numbered 0.</p>
<p class="Pp"><i>ROWID</i></p>
<p class="Pp"></p>
<pre>  my $value = $cursor-&gt;ROWID;
</pre>
<p class="Pp">Returns the <i>rowid</i> of row that the cursor is currently
    pointing at.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp">SQLite::VirtualTable is another module for virtual tables written
    in Perl, but designed for the reverse use case : instead of starting a Perl
    program, and embedding the SQLite library into it, the intended use is to
    start an sqlite program, and embed the Perl interpreter into it.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">Laurent Dami &lt;dami@cpan.org&gt;</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT_AND_LICENSE"><a class="permalink" href="#COPYRIGHT_AND_LICENSE">COPYRIGHT
  AND LICENSE</a></h1>
<p class="Pp">Copyright Laurent Dami, 2014.</p>
<p class="Pp">Parts of the code are borrowed from SQLite::VirtualTable,
    copyright (C) 2006, 2009 by Qindel Formacion y Servicios, S. L.</p>
<p class="Pp">This library is free software; you can redistribute it and/or
    modify it under the same terms as Perl itself.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2019-08-12</td>
    <td class="foot-os">perl v5.30.2</td>
  </tr>
</table>
</body>
</html>
