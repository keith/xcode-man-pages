<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    .Nd, .Bf, .Op { display: inline; }
    .Pa, .Ad { font-style: italic; }
    .Ms { font-weight: bold; }
    .Bl-diag > dt { font-weight: bold; }
    code.Nm, .Fl, .Cm, .Ic, code.In, .Fd, .Fn, .Cd { font-weight: bold;
      font-family: inherit; }
  </style>
  <title>install::TempContent::Objects::mod_perl-2.0.12::docs::api::APR::Error(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">install::TempContent::Objects::mod_perl-2.0.12::docs::api::APR::Error(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">install::TempContent::Objects::mod_perl-2.0.12::docs::api::APR::Error(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">APR::Error - Perl API for APR/Apache/mod_perl exceptions</p>
</section>
<section class="Sh">
<h1 class="Sh" id="Synopsis"><a class="permalink" href="#Synopsis">Synopsis</a></h1>
<pre>  eval { $obj-&gt;mp_method() };
  if ($@ &amp;&amp; $ref $@ eq 'APR::Error' &amp;&amp; $@ == $some_code) {
      # handle the exception
  }
  else {
      die $@; # rethrow it
  }
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="Description"><a class="permalink" href="#Description">Description</a></h1>
<p class="Pp"><span class="Li">&quot;APR::Error&quot;</span> handles
    APR/Apache/mod_perl exceptions for you, while leaving you in control.</p>
<p class="Pp">Apache and APR API return a status code for almost all methods, so
    if you didn't check the return code and handled any possible problems, you
    may have silent failures which may cause all kind of obscure problems. On
    the other hand checking the status code after each call is just too much of
    a kludge and makes quick prototyping/development almost impossible, not
    talking about the code readability. Having methods return status codes, also
    complicates the API if you need to return other values.</p>
<p class="Pp">Therefore to keep things nice and make the API readable we decided
    to not return status codes, but instead throw exceptions with
    <span class="Li">&quot;APR::Error&quot;</span> objects for each method that
    fails. If you don't catch those exceptions, everything works transparently -
    perl will intercept the exception object and
    <span class="Li">&quot;die()&quot;</span> with a proper error message. So
    you get all the errors logged without doing any work.</p>
<p class="Pp">Now, in certain cases you don't want to just die, but instead the
    error needs to be trapped and handled. For example if some IO operation
    times out, may be it is OK to trap that and try again. If we were to die
    with an error message, you would have had to match the error message, which
    is ugly, inefficient and may not work at all if locale error strings are
    involved. Therefore you need to be able to get the original status code that
    Apache or APR has generated. And the exception objects give you that if you
    want to. Moreover the objects contain additional information, such as the
    function name (in case you were eval'ing several commands in one block),
    file and line number where that function was invoked from. More attributes
    could be added in the future.</p>
<p class="Pp"><span class="Li">&quot;APR::Error&quot;</span> uses Perl operator
    overloading, such that in boolean and numerical contexts, the object returns
    the status code; in the string context the full error message is
  returned.</p>
<p class="Pp">When intercepting exceptions you need to check whether
    <span class="Li">$@</span> is an object (reference). If your application
    uses other exception objects you additionally need to check whether this is
    a an <span class="Li">&quot;APR::Error&quot;</span> object. Therefore most
    of the time this is enough:</p>
<p class="Pp"></p>
<pre>  eval { $obj-&gt;mp_method() };
  if ($@ &amp;&amp; $ref $@ &amp;&amp; $@ == $some_code)
      warn &quot;handled exception: $@&quot;;
  }
</pre>
<p class="Pp">But with other, non-mod_perl, exception objects you need to
  do:</p>
<p class="Pp"></p>
<pre>  eval { $obj-&gt;mp_method() };
  if ($@ &amp;&amp; $ref $@ eq 'APR::Error' &amp;&amp; $@ == $some_code)
      warn &quot;handled exception: $@&quot;;
  }
</pre>
<p class="Pp">In theory you could even do:</p>
<p class="Pp"></p>
<pre>  eval { $obj-&gt;mp_method() };
  if ($@ &amp;&amp; $@ == $some_code)
      warn &quot;handled exception: $@&quot;;
  }
</pre>
<p class="Pp">but it's possible that the method will die with a plain string and
    not an object, in which case <span class="Li">&quot;$@ ==
    $some_code&quot;</span> won't quite work. Remember that mod_perl throws
    exception objects only when Apache and APR fail, and in a few other special
    cases of its own (like <span class="Li">&quot;exit&quot;</span>).</p>
<p class="Pp"></p>
<pre>  warn &quot;handled exception: $@&quot; if $@ &amp;&amp; $ref $@;
</pre>
<p class="Pp">There are two ways to figure out whether an error fits your case.
    In most cases you just compare <span class="Li">$@</span> with an the error
    constant. For example if a socket has a timeout set and the data wasn't read
    within the timeout limit a
    <span class="Li">&quot;APR::Const::TIMEUP&quot;</span>)</p>
<p class="Pp"></p>
<pre>  use APR::Const -compile =&gt; qw(TIMEUP);
  $sock-&gt;timeout_set(1_000_000); # 1 sec
  my $buff;
  eval { $sock-&gt;recv($buff, BUFF_LEN) };
  if ($@ &amp;&amp; ref $@ &amp;&amp; $@ == APR::Const::TIMEUP) {
  }
</pre>
<p class="Pp">However there are situations, where on different Operating Systems
    a different error code will be returned. In which case to simplify the code
    you should use the special subroutines provided by the
    <span class="Li">&quot;APR::Status&quot;</span> class. One such condition is
    socket <span class="Li">&quot;recv()&quot;</span> timeout, which on Unix
    throws the <span class="Li">&quot;EAGAIN&quot;</span> error, but on other
    system it throws a different error. In this case
    <span class="Li">&quot;APR::Status::is_EAGAIN&quot;</span> should be
  used.</p>
<p class="Pp">Let's look at a complete example. Here is a code that performs a
    socket read:</p>
<p class="Pp"></p>
<pre>  my $rlen = $sock-&gt;recv(my $buff, 1024);
  warn &quot;read $rlen bytes\n&quot;;
</pre>
<p class="Pp">and in certain cases it times out. The code will die and log the
    reason for the failure, which is fine, but later on you may decide that you
    want to have another attempt to read before dying and add some fine grained
    sleep time between attempts, which can be achieved with
    <span class="Li">&quot;select&quot;</span>. Which gives us:</p>
<p class="Pp"></p>
<pre>  use APR::Status ();
  # ....
  my $tries = 0;
  my $buffer;
  RETRY: my $rlen = eval { $sock-&gt;recv($buffer, SIZE) };
  if ($@)
      die $@ unless ref $@ &amp;&amp; APR::Status::is_EAGAIN($@);
      if ($tries++ &lt; 3) {
          # sleep 250msec
          select undef, undef, undef, 0.25;
          goto RETRY;
      }
      else {
          # do something else
      }
  }
  warn &quot;read $rlen bytes\n&quot;
</pre>
<p class="Pp">Notice that we handle non-object and
    non-<span class="Li">&quot;APR::Error&quot;</span> exceptions as well, by
    simply re-throwing them.</p>
<p class="Pp">Finally, the class is called
    <span class="Li">&quot;APR::Error&quot;</span> because it needs to be used
    outside mod_perl as well, when called from
    <span class="Li">&quot;APR&quot;</span> applications written in Perl.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="API"><a class="permalink" href="#API">API</a></h1>
<section class="Ss">
<h2 class="Ss" id="_cluck_"><a class="permalink" href="#_cluck_">&quot;cluck&quot;</a></h2>
<p class="Pp"><span class="Li">&quot;cluck&quot;</span> is an equivalent of
    <span class="Li">&quot;Carp::cluck&quot;</span> that works with
    <span class="Li">&quot;APR::Error&quot;</span> exception objects.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_confess_"><a class="permalink" href="#_confess_">&quot;confess&quot;</a></h2>
<p class="Pp"><span class="Li">&quot;confess&quot;</span> is an equivalent of
    <span class="Li">&quot;Carp::confess&quot;</span> that works with
    <span class="Li">&quot;APR::Error&quot;</span> exception objects.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_strerror_"><a class="permalink" href="#_strerror_">&quot;strerror&quot;</a></h2>
<p class="Pp">Convert APR error code to its string representation.</p>
<p class="Pp"></p>
<pre>  $error_str = APR::Error::strerror($rc);
</pre>
<dl class="Bl-tag">
  <dt id="ret:"><a class="permalink" href="#ret:">ret: $rc ( &quot;APR::Const
    status constant&quot; )</a></dt>
  <dd>The numerical value for the return (error) code</dd>
  <dt id="ret:~2"><a class="permalink" href="#ret:~2">ret: $error_str ( string
    )</a></dt>
  <dd>The string error message corresponding to the numerical value inside
      <span class="Li">$rc</span>. (Similar to the C function
      <span class="Li">strerror(3)</span>)</dd>
  <dt id="since:"><a class="permalink" href="#since:">since: 2.0.00</a></dt>
  <dd></dd>
</dl>
<p class="Pp">Example:</p>
<p class="Pp">Try to retrieve the bucket brigade, and if the return value
    doesn't indicate success or end of file (usually in protocol handlers) die,
    but give the user the human-readable version of the error and not just the
    code.</p>
<p class="Pp"></p>
<pre>  my $rc = $c-&gt;input_filters-&gt;get_brigade($bb_in,
                                          Apache2::Const::MODE_GETLINE);
  if ($rc != APR::Const::SUCCESS &amp;&amp; $rc != APR::Const::EOF) {
      my $error = APR::Error::strerror($rc);
      die &quot;get_brigade error: $rc: $error\n&quot;;
  }
</pre>
<p class="Pp">It's probably a good idea not to omit the numerical value in the
    error message, in case the error string is generated with non-English
    locale.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="See_Also"><a class="permalink" href="#See_Also">See
  Also</a></h1>
<p class="Pp">mod_perl 2.0 documentation.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="Copyright"><a class="permalink" href="#Copyright">Copyright</a></h1>
<p class="Pp">mod_perl 2.0 and its core modules are copyrighted under The Apache
    Software License, Version 2.0.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="Authors"><a class="permalink" href="#Authors">Authors</a></h1>
<p class="Pp">The mod_perl development team and numerous contributors.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2015-06-18</td>
    <td class="foot-os">perl v5.30.2</td>
  </tr>
</table>
</body>
</html>
