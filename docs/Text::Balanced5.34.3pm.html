<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    .Nd, .Bf, .Op { display: inline; }
    .Pa, .Ad { font-style: italic; }
    .Ms { font-weight: bold; }
    .Bl-diag > dt { font-weight: bold; }
    code.Nm, .Fl, .Cm, .Ic, code.In, .Fd, .Fn, .Cd { font-weight: bold;
      font-family: inherit; }
  </style>
  <title>Text::Balanced(3pm)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Text::Balanced(3pm)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">Text::Balanced(3pm)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Text::Balanced - Extract delimited text sequences from
  strings.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>    use Text::Balanced qw (
        extract_delimited
        extract_bracketed
        extract_quotelike
        extract_codeblock
        extract_variable
        extract_tagged
        extract_multiple
        gen_delimited_pat
        gen_extract_tagged
    );
    # Extract the initial substring of $text that is delimited by
    # two (unescaped) instances of the first character in $delim.
    ($extracted, $remainder) = extract_delimited($text,$delim);
    # Extract the initial substring of $text that is bracketed
    # with a delimiter(s) specified by $delim (where the string
    # in $delim contains one or more of '(){}[]&lt;&gt;').
    ($extracted, $remainder) = extract_bracketed($text,$delim);
    # Extract the initial substring of $text that is bounded by
    # an XML tag.
    ($extracted, $remainder) = extract_tagged($text);
    # Extract the initial substring of $text that is bounded by
    # a C&lt;BEGIN&gt;...C&lt;END&gt; pair. Don't allow nested C&lt;BEGIN&gt; tags
    ($extracted, $remainder) =
        extract_tagged($text,&quot;BEGIN&quot;,&quot;END&quot;,undef,{bad=&gt;[&quot;BEGIN&quot;]});
    # Extract the initial substring of $text that represents a
    # Perl &quot;quote or quote-like operation&quot;
    ($extracted, $remainder) = extract_quotelike($text);
    # Extract the initial substring of $text that represents a block
    # of Perl code, bracketed by any of character(s) specified by $delim
    # (where the string $delim contains one or more of '(){}[]&lt;&gt;').
    ($extracted, $remainder) = extract_codeblock($text,$delim);
    # Extract the initial substrings of $text that would be extracted by
    # one or more sequential applications of the specified functions
    # or regular expressions
    @extracted = extract_multiple($text,
                                  [ \&amp;extract_bracketed,
                                    \&amp;extract_quotelike,
                                    \&amp;some_other_extractor_sub,
                                    qr/[xyz]*/,
                                    'literal',
                                  ]);
    # Create a string representing an optimized pattern (a la Friedl)
    # that matches a substring delimited by any of the specified characters
    # (in this case: any type of quote or a slash)
    $patstring = gen_delimited_pat(q{'&quot;`/});
    # Generate a reference to an anonymous sub that is just like extract_tagged
    # but pre-compiled and optimized for a specific pair of tags, and
    # consequently much faster (i.e. 3 times faster). It uses qr// for better
    # performance on repeated calls.
    $extract_head = gen_extract_tagged('&lt;HEAD&gt;','&lt;/HEAD&gt;');
    ($extracted, $remainder) = $extract_head-&gt;($text);
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">The various <span class="Li">&quot;extract_...&quot;</span>
    subroutines may be used to extract a delimited substring, possibly after
    skipping a specified prefix string. By default, that prefix is optional
    whitespace (<span class="Li">&quot;/\s*/&quot;</span>), but you can change
    it to whatever you wish (see below).</p>
<p class="Pp">The substring to be extracted must appear at the current
    <span class="Li">&quot;pos&quot;</span> location of the string's variable
    (or at index zero, if no <span class="Li">&quot;pos&quot;</span> position is
    defined). In other words, the
    <span class="Li">&quot;extract_...&quot;</span> subroutines <i>don't</i>
    extract the first occurrence of a substring anywhere in a string (like an
    unanchored regex would). Rather, they extract an occurrence of the substring
    appearing immediately at the current matching position in the string (like a
    <span class="Li">&quot;\G&quot;</span>-anchored regex would).</p>
<section class="Ss">
<h2 class="Ss" id="General_Behaviour_in_List_Contexts"><a class="permalink" href="#General_Behaviour_in_List_Contexts">General
  Behaviour in List Contexts</a></h2>
<p class="Pp">In a list context, all the subroutines return a list, the first
    three elements of which are always:</p>
<dl class="Bl-tag">
  <dt>[0]</dt>
  <dd>The extracted string, including the specified delimiters. If the
      extraction fails <span class="Li">&quot;undef&quot;</span> is
    returned.</dd>
  <dt>[1]</dt>
  <dd>The remainder of the input string (i.e. the characters after the extracted
      string). On failure, the entire string is returned.</dd>
  <dt>[2]</dt>
  <dd>The skipped prefix (i.e. the characters before the extracted string). On
      failure, <span class="Li">&quot;undef&quot;</span> is returned.</dd>
</dl>
<p class="Pp">Note that in a list context, the contents of the original input
    text (the first argument) are not modified in any way.</p>
<p class="Pp">However, if the input text was passed in a variable, that
    variable's <span class="Li">&quot;pos&quot;</span> value is updated to point
    at the first character after the extracted text. That means that in a list
    context the various subroutines can be used much like regular expressions.
    For example:</p>
<p class="Pp"></p>
<pre>    while ( $next = (extract_quotelike($text))[0] )
    {
        # process next quote-like (in $next)
    }
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="General_Behaviour_in_Scalar_and_Void_Contexts"><a class="permalink" href="#General_Behaviour_in_Scalar_and_Void_Contexts">General
  Behaviour in Scalar and Void Contexts</a></h2>
<p class="Pp">In a scalar context, the extracted string is returned, having
    first been removed from the input text. Thus, the following code also
    processes each quote-like operation, but actually removes them from
    <span class="Li">$text:</span></p>
<p class="Pp"></p>
<pre>    while ( $next = extract_quotelike($text) )
    {
        # process next quote-like (in $next)
    }
</pre>
<p class="Pp">Note that if the input text is a read-only string (i.e. a
    literal), no attempt is made to remove the extracted text.</p>
<p class="Pp">In a void context the behaviour of the extraction subroutines is
    exactly the same as in a scalar context, except (of course) that the
    extracted substring is not returned.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="A_Note_About_Prefixes"><a class="permalink" href="#A_Note_About_Prefixes">A
  Note About Prefixes</a></h2>
<p class="Pp">Prefix patterns are matched without any trailing modifiers
    (<span class="Li">&quot;/gimsox&quot;</span> etc.) This can bite you if
    you're expecting a prefix specification like '.*?(?=&lt;H1&gt;)' to skip
    everything up to the first &lt;H1&gt; tag. Such a prefix pattern will only
    succeed if the &lt;H1&gt; tag is on the current line, since . normally
    doesn't match newlines.</p>
<p class="Pp">To overcome this limitation, you need to turn on /s matching
    within the prefix pattern, using the
    <span class="Li">&quot;(?s)&quot;</span> directive:
  '(?s).*?(?=&lt;H1&gt;)'</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Functions"><a class="permalink" href="#Functions">Functions</a></h2>
<dl class="Bl-tag">
  <dt>&quot;extract_delimited&quot;</dt>
  <dd>The <span class="Li">&quot;extract_delimited&quot;</span> function
      formalizes the common idiom of extracting a single-character-delimited
      substring from the start of a string. For example, to extract a
      single-quote delimited string, the following code is typically used:
    <p class="Pp"></p>
    <pre>    ($remainder = $text) =~ s/\A('(\\.|[^'])*')//s;
    $extracted = $1;
    </pre>
    <p class="Pp">but with <span class="Li">&quot;extract_delimited&quot;</span>
        it can be simplified to:</p>
    <p class="Pp"></p>
    <pre>    ($extracted,$remainder) = extract_delimited($text, &quot;'&quot;);
    </pre>
    <p class="Pp"><span class="Li">&quot;extract_delimited&quot;</span> takes up
        to four scalars (the input text, the delimiters, a prefix pattern to be
        skipped, and any escape characters) and extracts the initial substring
        of the text that is appropriately delimited. If the delimiter string has
        multiple characters, the first one encountered in the text is taken to
        delimit the substring. The third argument specifies a prefix pattern
        that is to be skipped (but must be present!) before the substring is
        extracted. The final argument specifies the escape character to be used
        for each delimiter.</p>
    <p class="Pp">All arguments are optional. If the escape characters are not
        specified, every delimiter is escaped with a backslash
        (<span class="Li">&quot;\&quot;</span>). If the prefix is not specified,
        the pattern <span class="Li">'\s*'</span> - optional whitespace - is
        used. If the delimiter set is also not specified, the set
        <span class="Li">&quot;/[&quot;'`]/&quot;</span> is used. If the text to
        be processed is not specified either, <span class="Li">$_</span> is
        used.</p>
    <p class="Pp">In list context,
        <span class="Li">&quot;extract_delimited&quot;</span> returns a array of
        three elements, the extracted substring (<i>including the
        surrounding</i> <i>delimiters</i>), the remainder of the text, and the
        skipped prefix (if any). If a suitable delimited substring is not found,
        the first element of the array is the empty string, the second is the
        complete original text, and the prefix returned in the third element is
        an empty string.</p>
    <p class="Pp">In a scalar context, just the extracted substring is returned.
        In a void context, the extracted substring (and any prefix) are simply
        removed from the beginning of the first argument.</p>
    <p class="Pp">Examples:</p>
    <p class="Pp"></p>
    <pre>    # Remove a single-quoted substring from the very beginning of $text:
        $substring = extract_delimited($text, &quot;'&quot;, '');
    # Remove a single-quoted Pascalish substring (i.e. one in which
    # doubling the quote character escapes it) from the very
    # beginning of $text:
        $substring = extract_delimited($text, &quot;'&quot;, '', &quot;'&quot;);
    # Extract a single- or double- quoted substring from the
    # beginning of $text, optionally after some whitespace
    # (note the list context to protect $text from modification):
        ($substring) = extract_delimited $text, q{&quot;'};
    # Delete the substring delimited by the first '/' in $text:
        $text = join '', (extract_delimited($text,'/','[^/]*')[2,1];
    </pre>
    <p class="Pp">Note that this last example is <i>not</i> the same as deleting
        the first quote-like pattern. For instance, if
        <span class="Li">$text</span> contained the string:</p>
    <p class="Pp"></p>
    <pre>    &quot;if ('./cmd' =~ m/$UNIXCMD/s) { $cmd = $1; }&quot;
    </pre>
    <p class="Pp">then after the deletion it would contain:</p>
    <p class="Pp"></p>
    <pre>    &quot;if ('.$UNIXCMD/s) { $cmd = $1; }&quot;
    </pre>
    <p class="Pp">not:</p>
    <p class="Pp"></p>
    <pre>    &quot;if ('./cmd' =~ ms) { $cmd = $1; }&quot;
    </pre>
    <p class="Pp">See &quot;extract_quotelike&quot; for a (partial) solution to
        this problem.</p>
  </dd>
  <dt>&quot;extract_bracketed&quot;</dt>
  <dd>Like <span class="Li">&quot;extract_delimited&quot;</span>, the
      <span class="Li">&quot;extract_bracketed&quot;</span> function takes up to
      three optional scalar arguments: a string to extract from, a delimiter
      specifier, and a prefix pattern. As before, a missing prefix defaults to
      optional whitespace and a missing text defaults to
      <span class="Li">$_</span>. However, a missing delimiter specifier
      defaults to <span class="Li">'{}()[]&lt;&gt;'</span> (see below).
    <p class="Pp"><span class="Li">&quot;extract_bracketed&quot;</span> extracts
        a balanced-bracket-delimited substring (using any one (or more) of the
        user-specified delimiter brackets: '(..)', '{..}', '[..]', or
        '&lt;..&gt;'). Optionally it will also respect quoted unbalanced
        brackets (see below).</p>
    <p class="Pp">A &quot;delimiter bracket&quot; is a bracket in list of
        delimiters passed as
        <span class="Li">&quot;extract_bracketed&quot;</span>'s second argument.
        Delimiter brackets are specified by giving either the left or right (or
        both!) versions of the required bracket(s). Note that the order in which
        two or more delimiter brackets are specified is not significant.</p>
    <p class="Pp">A &quot;balanced-bracket-delimited substring&quot; is a
        substring bounded by matched brackets, such that any other (left or
        right) delimiter bracket <i>within</i> the substring is also matched by
        an opposite (right or left) delimiter bracket <i>at the same level of
        nesting</i>. Any type of bracket not in the delimiter list is treated as
        an ordinary character.</p>
    <p class="Pp">In other words, each type of bracket specified as a delimiter
        must be balanced and correctly nested within the substring, and any
        other kind of (&quot;non-delimiter&quot;) bracket in the substring is
        ignored.</p>
    <p class="Pp">For example, given the string:</p>
    <p class="Pp"></p>
    <pre>    $text = &quot;{ an '[irregularly :-(] {} parenthesized &gt;:-)' string }&quot;;
    </pre>
    <p class="Pp">then a call to
        <span class="Li">&quot;extract_bracketed&quot;</span> in a list
      context:</p>
    <p class="Pp"></p>
    <pre>    @result = extract_bracketed( $text, '{}' );
    </pre>
    <p class="Pp">would return:</p>
    <p class="Pp"></p>
    <pre>    ( &quot;{ an '[irregularly :-(] {} parenthesized &gt;:-)' string }&quot; , &quot;&quot; , &quot;&quot; )
    </pre>
    <p class="Pp">since both sets of <span class="Li">'{..}'</span> brackets are
        properly nested and evenly balanced. (In a scalar context just the first
        element of the array would be returned. In a void context,
        <span class="Li">$text</span> would be replaced by an empty string.)</p>
    <p class="Pp">Likewise the call in:</p>
    <p class="Pp"></p>
    <pre>    @result = extract_bracketed( $text, '{[' );
    </pre>
    <p class="Pp">would return the same result, since all sets of both types of
        specified delimiter brackets are correctly nested and balanced.</p>
    <p class="Pp">However, the call in:</p>
    <p class="Pp"></p>
    <pre>    @result = extract_bracketed( $text, '{([&lt;' );
    </pre>
    <p class="Pp">would fail, returning:</p>
    <p class="Pp"></p>
    <pre>    ( undef , &quot;{ an '[irregularly :-(] {} parenthesized &gt;:-)' string }&quot;  );
    </pre>
    <p class="Pp">because the embedded pairs of <span class="Li">'(..)'</span>s
        and <span class="Li">'[..]'</span>s are &quot;cross-nested&quot; and the
        embedded <span class="Li">'&gt;'</span> is unbalanced. (In a scalar
        context, this call would return an empty string. In a void context,
        <span class="Li">$text</span> would be unchanged.)</p>
    <p class="Pp">Note that the embedded single-quotes in the string don't help
        in this case, since they have not been specified as acceptable
        delimiters and are therefore treated as non-delimiter characters (and
        ignored).</p>
    <p class="Pp">However, if a particular species of quote character is
        included in the delimiter specification, then that type of quote will be
        correctly handled. for example, if <span class="Li">$text</span> is:</p>
    <p class="Pp"></p>
    <pre>    $text = '&lt;A HREF=&quot;&gt;&gt;&gt;&gt;&quot;&gt;link&lt;/A&gt;';
    </pre>
    <p class="Pp">then</p>
    <p class="Pp"></p>
    <pre>    @result = extract_bracketed( $text, '&lt;&quot;&gt;' );
    </pre>
    <p class="Pp">returns:</p>
    <p class="Pp"></p>
    <pre>    ( '&lt;A HREF=&quot;&gt;&gt;&gt;&gt;&quot;&gt;', 'link&lt;/A&gt;', &quot;&quot; )
    </pre>
    <p class="Pp">as expected. Without the specification of
        <span class="Li">&quot;&quot;&quot;</span> as an embedded quoter:</p>
    <p class="Pp"></p>
    <pre>    @result = extract_bracketed( $text, '&lt;&gt;' );
    </pre>
    <p class="Pp">the result would be:</p>
    <p class="Pp"></p>
    <pre>    ( '&lt;A HREF=&quot;&gt;', '&gt;&gt;&gt;&quot;&gt;link&lt;/A&gt;', &quot;&quot; )
    </pre>
    <p class="Pp">In addition to the quote delimiters
        <span class="Li">&quot;'&quot;</span>,
        <span class="Li">&quot;&quot;&quot;</span>, and
        <span class="Li">&quot;`&quot;</span>, full Perl quote-like quoting
        (i.e. q{string}, qq{string}, etc) can be specified by including the
        letter 'q' as a delimiter. Hence:</p>
    <p class="Pp"></p>
    <pre>    @result = extract_bracketed( $text, '&lt;q&gt;' );
    </pre>
    <p class="Pp">would correctly match something like this:</p>
    <p class="Pp"></p>
    <pre>    $text = '&lt;leftop: conj /and/ conj&gt;';
    </pre>
    <p class="Pp">See also:
        <span class="Li">&quot;extract_quotelike&quot;</span> and
        <span class="Li">&quot;extract_codeblock&quot;</span>.</p>
  </dd>
  <dt>&quot;extract_variable&quot;</dt>
  <dd><span class="Li">&quot;extract_variable&quot;</span> extracts any valid
      Perl variable or variable-involved expression, including scalars, arrays,
      hashes, array accesses, hash look-ups, method calls through objects,
      subroutine calls through subroutine references, etc.
    <p class="Pp">The subroutine takes up to two optional arguments:</p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>1.</dt>
  <dd>A string to be processed (<span class="Li">$_</span> if the string is
      omitted or <span class="Li">&quot;undef&quot;</span>)</dd>
  <dt>2.</dt>
  <dd>A string specifying a pattern to be matched as a prefix (which is to be
      skipped). If omitted, optional whitespace is skipped.</dd>
</dl>
</div>
<div class="Bd-indent">
<p class="Pp">On success in a list context, an array of 3 elements is returned.
    The elements are:</p>
<dl class="Bl-tag">
  <dt>[0]</dt>
  <dd>the extracted variable, or variablish expression</dd>
  <dt>[1]</dt>
  <dd>the remainder of the input text,</dd>
  <dt>[2]</dt>
  <dd>the prefix substring (if any),</dd>
</dl>
</div>
<div class="Bd-indent">
<p class="Pp">On failure, all of these values (except the remaining text) are
    <span class="Li">&quot;undef&quot;</span>.</p>
<p class="Pp">In a scalar context,
    <span class="Li">&quot;extract_variable&quot;</span> returns just the
    complete substring that matched a variablish expression.
    <span class="Li">&quot;undef&quot;</span> is returned on failure. In
    addition, the original input text has the returned substring (and any
    prefix) removed from it.</p>
<p class="Pp">In a void context, the input text just has the matched substring
    (and any specified prefix) removed.</p>
</div>
<dl class="Bl-tag">
  <dt>&quot;extract_tagged&quot;</dt>
  <dd><span class="Li">&quot;extract_tagged&quot;</span> extracts and segments
      text between (balanced) specified tags.
    <p class="Pp">The subroutine takes up to five optional arguments:</p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>1.</dt>
  <dd>A string to be processed (<span class="Li">$_</span> if the string is
      omitted or <span class="Li">&quot;undef&quot;</span>)</dd>
  <dt>2.</dt>
  <dd>A string specifying a pattern to be matched as the opening tag. If the
      pattern string is omitted (or <span class="Li">&quot;undef&quot;</span>)
      then a pattern that matches any standard XML tag is used.</dd>
  <dt>3.</dt>
  <dd>A string specifying a pattern to be matched at the closing tag. If the
      pattern string is omitted (or <span class="Li">&quot;undef&quot;</span>)
      then the closing tag is constructed by inserting a
      <span class="Li">&quot;/&quot;</span> after any leading bracket characters
      in the actual opening tag that was matched (<i>not</i> the pattern that
      matched the tag). For example, if the opening tag pattern is specified as
      <span class="Li">'{{\w+}}'</span> and actually matched the opening tag
      <span class="Li">&quot;{{DATA}}&quot;</span>, then the constructed closing
      tag would be <span class="Li">&quot;{{/DATA}}&quot;</span>.</dd>
  <dt>4.</dt>
  <dd>A string specifying a pattern to be matched as a prefix (which is to be
      skipped). If omitted, optional whitespace is skipped.</dd>
  <dt>5.</dt>
  <dd>A hash reference containing various parsing options (see below)</dd>
</dl>
</div>
<div class="Bd-indent">
<p class="Pp">The various options that can be specified are:</p>
<dl class="Bl-tag">
  <dt>&quot;reject =&gt; $listref&quot;</dt>
  <dd>The list reference contains one or more strings specifying patterns that
      must <i>not</i> appear within the tagged text.
    <p class="Pp">For example, to extract an HTML link (which should not contain
        nested links) use:</p>
    <p class="Pp"></p>
    <pre>        extract_tagged($text, '&lt;A&gt;', '&lt;/A&gt;', undef, {reject =&gt; ['&lt;A&gt;']} );
    </pre>
  </dd>
  <dt>&quot;ignore =&gt; $listref&quot;</dt>
  <dd>The list reference contains one or more strings specifying patterns that
      are <i>not</i> to be treated as nested tags within the tagged text (even
      if they would match the start tag pattern).
    <p class="Pp">For example, to extract an arbitrary XML tag, but ignore
        &quot;empty&quot; elements:</p>
    <p class="Pp"></p>
    <pre>        extract_tagged($text, undef, undef, undef, {ignore =&gt; ['&lt;[^&gt;]*/&gt;']} );
    </pre>
    <p class="Pp">(also see &quot;gen_delimited_pat&quot; below).</p>
  </dd>
  <dt>&quot;fail =&gt; $str&quot;</dt>
  <dd>The <span class="Li">&quot;fail&quot;</span> option indicates the action
      to be taken if a matching end tag is not encountered (i.e. before the end
      of the string or some <span class="Li">&quot;reject&quot;</span> pattern
      matches). By default, a failure to match a closing tag causes
      <span class="Li">&quot;extract_tagged&quot;</span> to immediately fail.
    <p class="Pp">However, if the string value associated with &lt;reject&gt; is
        &quot;MAX&quot;, then <span class="Li">&quot;extract_tagged&quot;</span>
        returns the complete text up to the point of failure. If the string is
        &quot;PARA&quot;, <span class="Li">&quot;extract_tagged&quot;</span>
        returns only the first paragraph after the tag (up to the first line
        that is either empty or contains only whitespace characters). If the
        string is &quot;&quot;, the default behaviour (i.e. failure) is
        reinstated.</p>
    <p class="Pp">For example, suppose the start tag &quot;/para&quot;
        introduces a paragraph, which then continues until the next
        &quot;/endpara&quot; tag or until another &quot;/para&quot; tag is
        encountered:</p>
    <p class="Pp"></p>
    <pre>        $text = &quot;/para line 1\n\nline 3\n/para line 4&quot;;
        extract_tagged($text, '/para', '/endpara', undef,
                                {reject =&gt; '/para', fail =&gt; MAX );
        # EXTRACTED: &quot;/para line 1\n\nline 3\n&quot;
    </pre>
    <p class="Pp">Suppose instead, that if no matching &quot;/endpara&quot; tag
        is found, the &quot;/para&quot; tag refers only to the immediately
        following paragraph:</p>
    <p class="Pp"></p>
    <pre>        $text = &quot;/para line 1\n\nline 3\n/para line 4&quot;;
        extract_tagged($text, '/para', '/endpara', undef,
                        {reject =&gt; '/para', fail =&gt; MAX );
        # EXTRACTED: &quot;/para line 1\n&quot;
    </pre>
    <p class="Pp">Note that the specified
        <span class="Li">&quot;fail&quot;</span> behaviour applies to nested
        tags as well.</p>
  </dd>
</dl>
</div>
<div class="Bd-indent">
<p class="Pp">On success in a list context, an array of 6 elements is returned.
    The elements are:</p>
<dl class="Bl-tag">
  <dt>[0]</dt>
  <dd>the extracted tagged substring (including the outermost tags),</dd>
  <dt>[1]</dt>
  <dd>the remainder of the input text,</dd>
  <dt>[2]</dt>
  <dd>the prefix substring (if any),</dd>
  <dt>[3]</dt>
  <dd>the opening tag</dd>
  <dt>[4]</dt>
  <dd>the text between the opening and closing tags</dd>
  <dt>[5]</dt>
  <dd>the closing tag (or &quot;&quot; if no closing tag was found)</dd>
</dl>
</div>
<div class="Bd-indent">
<p class="Pp">On failure, all of these values (except the remaining text) are
    <span class="Li">&quot;undef&quot;</span>.</p>
<p class="Pp">In a scalar context,
    <span class="Li">&quot;extract_tagged&quot;</span> returns just the complete
    substring that matched a tagged text (including the start and end tags).
    <span class="Li">&quot;undef&quot;</span> is returned on failure. In
    addition, the original input text has the returned substring (and any
    prefix) removed from it.</p>
<p class="Pp">In a void context, the input text just has the matched substring
    (and any specified prefix) removed.</p>
</div>
<dl class="Bl-tag">
  <dt>&quot;gen_extract_tagged&quot;</dt>
  <dd><span class="Li">&quot;gen_extract_tagged&quot;</span> generates a new
      anonymous subroutine which extracts text between (balanced) specified
      tags. In other words, it generates a function identical in function to
      <span class="Li">&quot;extract_tagged&quot;</span>.
    <p class="Pp">The difference between
        <span class="Li">&quot;extract_tagged&quot;</span> and the anonymous
        subroutines generated by
        <span class="Li">&quot;gen_extract_tagged&quot;</span>, is that those
        generated subroutines:</p>
  </dd>
</dl>
<div class="Bd-indent">
<ul class="Bl-bullet">
  <li>do not have to reparse tag specification or parsing options every time
      they are called (whereas
      <span class="Li">&quot;extract_tagged&quot;</span> has to effectively
      rebuild its tag parser on every call);</li>
  <li>make use of the new qr// construct to pre-compile the regexes they use
      (whereas <span class="Li">&quot;extract_tagged&quot;</span> uses standard
      string variable interpolation to create tag-matching patterns).</li>
</ul>
</div>
<div class="Bd-indent">
<p class="Pp">The subroutine takes up to four optional arguments (the same set
    as <span class="Li">&quot;extract_tagged&quot;</span> except for the string
    to be processed). It returns a reference to a subroutine which in turn takes
    a single argument (the text to be extracted from).</p>
<p class="Pp">In other words, the implementation of
    <span class="Li">&quot;extract_tagged&quot;</span> is exactly equivalent
  to:</p>
<p class="Pp"></p>
<pre>        sub extract_tagged
        {
                my $text = shift;
                $extractor = gen_extract_tagged(@_);
                return $extractor-&gt;($text);
        }
</pre>
<p class="Pp">(although <span class="Li">&quot;extract_tagged&quot;</span> is
    not currently implemented that way).</p>
<p class="Pp">Using <span class="Li">&quot;gen_extract_tagged&quot;</span> to
    create extraction functions for specific tags is a good idea if those
    functions are going to be called more than once, since their performance is
    typically twice as good as the more general-purpose
    <span class="Li">&quot;extract_tagged&quot;</span>.</p>
</div>
<dl class="Bl-tag">
  <dt>&quot;extract_quotelike&quot;</dt>
  <dd><span class="Li">&quot;extract_quotelike&quot;</span> attempts to
      recognize, extract, and segment any one of the various Perl quotes and
      quotelike operators (see <b>perlop</b>(3)) Nested backslashed delimiters,
      embedded balanced bracket delimiters (for the quotelike operators), and
      trailing modifiers are all caught. For example, in:
    <p class="Pp"></p>
    <pre>        extract_quotelike 'q # an octothorpe: \# (not the end of the q!) #'
        extract_quotelike '  &quot;You said, \&quot;Use sed\&quot;.&quot;  '
        extract_quotelike ' s{([A-Z]{1,8}\.[A-Z]{3})} /\L$1\E/; '
        extract_quotelike ' tr/\\\/\\\\/\\\//ds; '
    </pre>
    <p class="Pp">the full Perl quotelike operations are all extracted
        correctly.</p>
    <p class="Pp">Note too that, when using the /x modifier on a regex, any
        comment containing the current pattern delimiter will cause the regex to
        be immediately terminated. In other words:</p>
    <p class="Pp"></p>
    <pre>        'm /
                (?i)            # CASE INSENSITIVE
                [a-z_]          # LEADING ALPHABETIC/UNDERSCORE
                [a-z0-9]*       # FOLLOWED BY ANY NUMBER OF ALPHANUMERICS
           /x'
    </pre>
    <p class="Pp">will be extracted as if it were:</p>
    <p class="Pp"></p>
    <pre>        'm /
                (?i)            # CASE INSENSITIVE
                [a-z_]          # LEADING ALPHABETIC/'
    </pre>
    <p class="Pp">This behaviour is identical to that of the actual
      compiler.</p>
    <p class="Pp"><span class="Li">&quot;extract_quotelike&quot;</span> takes
        two arguments: the text to be processed and a prefix to be matched at
        the very beginning of the text. If no prefix is specified, optional
        whitespace is the default. If no text is given,
        <span class="Li">$_</span> is used.</p>
    <p class="Pp">In a list context, an array of 11 elements is returned. The
        elements are:</p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>[0]</dt>
  <dd>the extracted quotelike substring (including trailing modifiers),</dd>
  <dt>[1]</dt>
  <dd>the remainder of the input text,</dd>
  <dt>[2]</dt>
  <dd>the prefix substring (if any),</dd>
  <dt>[3]</dt>
  <dd>the name of the quotelike operator (if any),</dd>
  <dt>[4]</dt>
  <dd>the left delimiter of the first block of the operation,</dd>
  <dt>[5]</dt>
  <dd>the text of the first block of the operation (that is, the contents of a
      quote, the regex of a match or substitution or the target list of a
      translation),</dd>
  <dt>[6]</dt>
  <dd>the right delimiter of the first block of the operation,</dd>
  <dt>[7]</dt>
  <dd>the left delimiter of the second block of the operation (that is, if it is
      a <span class="Li">&quot;s&quot;</span>,
      <span class="Li">&quot;tr&quot;</span>, or
      <span class="Li">&quot;y&quot;</span>),</dd>
  <dt>[8]</dt>
  <dd>the text of the second block of the operation (that is, the replacement of
      a substitution or the translation list of a translation),</dd>
  <dt>[9]</dt>
  <dd>the right delimiter of the second block of the operation (if any),</dd>
  <dt>[10]</dt>
  <dd>the trailing modifiers on the operation (if any).</dd>
</dl>
</div>
<div class="Bd-indent">
<p class="Pp">For each of the fields marked &quot;(if any)&quot; the default
    value on success is an empty string. On failure, all of these values (except
    the remaining text) are <span class="Li">&quot;undef&quot;</span>.</p>
<p class="Pp">In a scalar context,
    <span class="Li">&quot;extract_quotelike&quot;</span> returns just the
    complete substring that matched a quotelike operation (or
    <span class="Li">&quot;undef&quot;</span> on failure). In a scalar or void
    context, the input text has the same substring (and any specified prefix)
    removed.</p>
<p class="Pp">Examples:</p>
<p class="Pp"></p>
<pre>        # Remove the first quotelike literal that appears in text
                $quotelike = extract_quotelike($text,'.*?');
        # Replace one or more leading whitespace-separated quotelike
        # literals in $_ with &quot;&lt;QLL&gt;&quot;
                do { $_ = join '&lt;QLL&gt;', (extract_quotelike)[2,1] } until $@;
        # Isolate the search pattern in a quotelike operation from $text
                ($op,$pat) = (extract_quotelike $text)[3,5];
                if ($op =~ /[ms]/)
                {
                        print &quot;search pattern: $pat\n&quot;;
                }
                else
                {
                        print &quot;$op is not a pattern matching operation\n&quot;;
                }
</pre>
</div>
<dl class="Bl-tag">
  <dt>&quot;extract_quotelike&quot;</dt>
  <dd><span class="Li">&quot;extract_quotelike&quot;</span> can successfully
      extract &quot;here documents&quot; from an input string, but with an
      important caveat in list contexts.
    <p class="Pp">Unlike other types of quote-like literals, a here document is
        rarely a contiguous substring. For example, a typical piece of code
        using here document might look like this:</p>
    <p class="Pp"></p>
    <pre>        &lt;&lt;'EOMSG' || die;
        This is the message.
        EOMSG
        exit;
    </pre>
    <p class="Pp">Given this as an input string in a scalar context,
        <span class="Li">&quot;extract_quotelike&quot;</span> would correctly
        return the string &quot;&lt;&lt;'EOMSG'\nThis is the
        message.\nEOMSG&quot;, leaving the string &quot; || die;\nexit;&quot; in
        the original variable. In other words, the two separate pieces of the
        here document are successfully extracted and concatenated.</p>
    <p class="Pp">In a list context,
        <span class="Li">&quot;extract_quotelike&quot;</span> would return the
        list</p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>[0]</dt>
  <dd>&quot;&lt;&lt;'EOMSG'\nThis is the message.\nEOMSG\n&quot; (i.e. the full
      extracted here document, including fore and aft delimiters),</dd>
  <dt>[1]</dt>
  <dd>&quot; || die;\nexit;&quot; (i.e. the remainder of the input text,
      concatenated),</dd>
  <dt>[2]</dt>
  <dd>&quot;&quot; (i.e. the prefix substring -- trivial in this case),</dd>
  <dt>[3]</dt>
  <dd>&quot;&lt;&lt;&quot; (i.e. the &quot;name&quot; of the quotelike
    operator)</dd>
  <dt>[4]</dt>
  <dd>&quot;'EOMSG'&quot; (i.e. the left delimiter of the here document,
      including any quotes),</dd>
  <dt>[5]</dt>
  <dd>&quot;This is the message.\n&quot; (i.e. the text of the here
    document),</dd>
  <dt>[6]</dt>
  <dd>&quot;EOMSG&quot; (i.e. the right delimiter of the here document),</dd>
  <dt>[7..10]</dt>
  <dd>&quot;&quot; (a here document has no second left delimiter, second text,
      second right delimiter, or trailing modifiers).</dd>
</dl>
</div>
<div class="Bd-indent">
<p class="Pp">However, the matching position of the input variable would be set
    to &quot;exit;&quot; (i.e. <i>after</i> the closing delimiter of the here
    document), which would cause the earlier &quot; || die;\nexit;&quot; to be
    skipped in any sequence of code fragment extractions.</p>
<p class="Pp">To avoid this problem, when it encounters a here document whilst
    extracting from a modifiable string,
    <span class="Li">&quot;extract_quotelike&quot;</span> silently rearranges
    the string to an equivalent piece of Perl:</p>
<p class="Pp"></p>
<pre>        &lt;&lt;'EOMSG'
        This is the message.
        EOMSG
        || die;
        exit;
</pre>
<p class="Pp">in which the here document <i>is</i> contiguous. It still leaves
    the matching position after the here document, but now the rest of the line
    on which the here document starts is not skipped.</p>
<p class="Pp">To prevent &lt;extract_quotelike&gt; from mucking about with the
    input in this way (this is the only case where a list-context
    <span class="Li">&quot;extract_quotelike&quot;</span> does so), you can pass
    the input variable as an interpolated literal:</p>
<p class="Pp"></p>
<pre>        $quotelike = extract_quotelike(&quot;$var&quot;);
</pre>
</div>
<dl class="Bl-tag">
  <dt>&quot;extract_codeblock&quot;</dt>
  <dd><span class="Li">&quot;extract_codeblock&quot;</span> attempts to
      recognize and extract a balanced bracket delimited substring that may
      contain unbalanced brackets inside Perl quotes or quotelike operations.
      That is, <span class="Li">&quot;extract_codeblock&quot;</span> is like a
      combination of <span class="Li">&quot;extract_bracketed&quot;</span> and
      <span class="Li">&quot;extract_quotelike&quot;</span>.
    <p class="Pp"><span class="Li">&quot;extract_codeblock&quot;</span> takes
        the same initial three parameters as
        <span class="Li">&quot;extract_bracketed&quot;</span>: a text to
        process, a set of delimiter brackets to look for, and a prefix to match
        first. It also takes an optional fourth parameter, which allows the
        outermost delimiter brackets to be specified separately (see below).</p>
    <p class="Pp">Omitting the first argument (input text) means process
        <span class="Li">$_</span> instead. Omitting the second argument
        (delimiter brackets) indicates that only <span class="Li">'{'</span> is
        to be used. Omitting the third argument (prefix argument) implies
        optional whitespace at the start. Omitting the fourth argument
        (outermost delimiter brackets) indicates that the value of the second
        argument is to be used for the outermost delimiters.</p>
    <p class="Pp">Once the prefix and the outermost opening delimiter bracket
        have been recognized, code blocks are extracted by stepping through the
        input text and trying the following alternatives in sequence:</p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>1.</dt>
  <dd>Try and match a closing delimiter bracket. If the bracket was the same
      species as the last opening bracket, return the substring to that point.
      If the bracket was mismatched, return an error.</dd>
  <dt>2.</dt>
  <dd>Try to match a quote or quotelike operator. If found, call
      <span class="Li">&quot;extract_quotelike&quot;</span> to eat it. If
      <span class="Li">&quot;extract_quotelike&quot;</span> fails, return the
      error it returned. Otherwise go back to step 1.</dd>
  <dt>3.</dt>
  <dd>Try to match an opening delimiter bracket. If found, call
      <span class="Li">&quot;extract_codeblock&quot;</span> recursively to eat
      the embedded block. If the recursive call fails, return an error.
      Otherwise, go back to step 1.</dd>
  <dt>4.</dt>
  <dd>Unconditionally match a bareword or any other single character, and then
      go back to step 1.</dd>
</dl>
</div>
<div class="Bd-indent">
<p class="Pp">Examples:</p>
<p class="Pp"></p>
<pre>        # Find a while loop in the text
                if ($text =~ s/.*?while\s*\{/{/)
                {
                        $loop = &quot;while &quot; . extract_codeblock($text);
                }
        # Remove the first round-bracketed list (which may include
        # round- or curly-bracketed code blocks or quotelike operators)
                extract_codeblock $text, &quot;(){}&quot;, '[^(]*';
</pre>
<p class="Pp">The ability to specify a different outermost delimiter bracket is
    useful in some circumstances. For example, in the Parse::RecDescent module,
    parser actions which are to be performed only on a successful parse are
    specified using a <span class="Li">&quot;&lt;defer:...&gt;&quot;</span>
    directive. For example:</p>
<p class="Pp"></p>
<pre>        sentence: subject verb object
                        &lt;defer: {$::theVerb = $item{verb}} &gt;
</pre>
<p class="Pp">Parse::RecDescent uses
    <span class="Li">&quot;extract_codeblock($text, '{}&lt;&gt;')&quot;</span>
    to extract the code within the
    <span class="Li">&quot;&lt;defer:...&gt;&quot;</span> directive, but there's
    a problem.</p>
<p class="Pp">A deferred action like this:</p>
<p class="Pp"></p>
<pre>                        &lt;defer: {if ($count&gt;10) {$count--}} &gt;
</pre>
<p class="Pp">will be incorrectly parsed as:</p>
<p class="Pp"></p>
<pre>                        &lt;defer: {if ($count&gt;
</pre>
<p class="Pp">because the &quot;less than&quot; operator is interpreted as a
    closing delimiter.</p>
<p class="Pp">But, by extracting the directive using
    <span class="Li">&quot;extract_codeblock($text,&#x00A0;'{}',&#x00A0;undef,&#x00A0;'&lt;&gt;')&quot;</span>
    the '&gt;' character is only treated as a delimited at the outermost level
    of the code block, so the directive is parsed correctly.</p>
</div>
<dl class="Bl-tag">
  <dt>&quot;extract_multiple&quot;</dt>
  <dd>The <span class="Li">&quot;extract_multiple&quot;</span> subroutine takes
      a string to be processed and a list of extractors (subroutines or regular
      expressions) to apply to that string.
    <p class="Pp">In an array context
        <span class="Li">&quot;extract_multiple&quot;</span> returns an array of
        substrings of the original string, as extracted by the specified
        extractors. In a scalar context,
        <span class="Li">&quot;extract_multiple&quot;</span> returns the first
        substring successfully extracted from the original string. In both
        scalar and void contexts the original string has the first successfully
        extracted substring removed from it. In all contexts
        <span class="Li">&quot;extract_multiple&quot;</span> starts at the
        current <span class="Li">&quot;pos&quot;</span> of the string, and sets
        that <span class="Li">&quot;pos&quot;</span> appropriately after it
        matches.</p>
    <p class="Pp">Hence, the aim of a call to
        <span class="Li">&quot;extract_multiple&quot;</span> in a list context
        is to split the processed string into as many non-overlapping fields as
        possible, by repeatedly applying each of the specified extractors to the
        remainder of the string. Thus
        <span class="Li">&quot;extract_multiple&quot;</span> is a generalized
        form of Perl's <span class="Li">&quot;split&quot;</span> subroutine.</p>
    <p class="Pp">The subroutine takes up to four optional arguments:</p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>1.</dt>
  <dd>A string to be processed (<span class="Li">$_</span> if the string is
      omitted or <span class="Li">&quot;undef&quot;</span>)</dd>
  <dt>2.</dt>
  <dd>A reference to a list of subroutine references and/or qr// objects and/or
      literal strings and/or hash references, specifying the extractors to be
      used to split the string. If this argument is omitted (or
      <span class="Li">&quot;undef&quot;</span>) the list:
    <p class="Pp"></p>
    <pre>        [
                sub { extract_variable($_[0], '') },
                sub { extract_quotelike($_[0],'') },
                sub { extract_codeblock($_[0],'{}','') },
        ]
    </pre>
    <p class="Pp">is used.</p>
  </dd>
  <dt>3.</dt>
  <dd>An number specifying the maximum number of fields to return. If this
      argument is omitted (or <span class="Li">&quot;undef&quot;</span>), split
      continues as long as possible.
    <p class="Pp">If the third argument is <i>N</i>, then extraction continues
        until <i>N</i> fields have been successfully extracted, or until the
        string has been completely processed.</p>
    <p class="Pp">Note that in scalar and void contexts the value of this
        argument is automatically reset to 1 (under
        <span class="Li">&quot;-w&quot;</span>, a warning is issued if the
        argument has to be reset).</p>
  </dd>
  <dt>4.</dt>
  <dd>A value indicating whether unmatched substrings (see below) within the
      text should be skipped or returned as fields. If the value is true, such
      substrings are skipped. Otherwise, they are returned.</dd>
</dl>
</div>
<div class="Bd-indent">
<p class="Pp">The extraction process works by applying each extractor in
    sequence to the text string.</p>
<p class="Pp">If the extractor is a subroutine it is called in a list context
    and is expected to return a list of a single element, namely the extracted
    text. It may optionally also return two further arguments: a string
    representing the text left after extraction (like $' for a pattern match),
    and a string representing any prefix skipped before the extraction (like $`
    in a pattern match). Note that this is designed to facilitate the use of
    other Text::Balanced subroutines with
    <span class="Li">&quot;extract_multiple&quot;</span>. Note too that the
    value returned by an extractor subroutine need not bear any relationship to
    the corresponding substring of the original text (see examples below).</p>
<p class="Pp">If the extractor is a precompiled regular expression or a string,
    it is matched against the text in a scalar context with a leading '\G' and
    the gc modifiers enabled. The extracted value is either
    <span class="Li">$1</span> if that variable is defined after the match, or
    else the complete match (i.e. $&amp;).</p>
<p class="Pp">If the extractor is a hash reference, it must contain exactly one
    element. The value of that element is one of the above extractor types
    (subroutine reference, regular expression, or string). The key of that
    element is the name of a class into which the successful return value of the
    extractor will be blessed.</p>
<p class="Pp">If an extractor returns a defined value, that value is immediately
    treated as the next extracted field and pushed onto the list of fields. If
    the extractor was specified in a hash reference, the field is also blessed
    into the appropriate class,</p>
<p class="Pp">If the extractor fails to match (in the case of a regex
    extractor), or returns an empty list or an undefined value (in the case of a
    subroutine extractor), it is assumed to have failed to extract. If none of
    the extractor subroutines succeeds, then one character is extracted from the
    start of the text and the extraction subroutines reapplied. Characters which
    are thus removed are accumulated and eventually become the next field
    (unless the fourth argument is true, in which case they are discarded).</p>
<p class="Pp">For example, the following extracts substrings that are valid Perl
    variables:</p>
<p class="Pp"></p>
<pre>        @fields = extract_multiple($text,
                                   [ sub { extract_variable($_[0]) } ],
                                   undef, 1);
</pre>
<p class="Pp">This example separates a text into fields which are quote
    delimited, curly bracketed, and anything else. The delimited and bracketed
    parts are also blessed to identify them (the &quot;anything else&quot; is
    unblessed):</p>
<p class="Pp"></p>
<pre>        @fields = extract_multiple($text,
                   [
                        { Delim =&gt; sub { extract_delimited($_[0],q{'&quot;}) } },
                        { Brack =&gt; sub { extract_bracketed($_[0],'{}') } },
                   ]);
</pre>
<p class="Pp">This call extracts the next single substring that is a valid Perl
    quotelike operator (and removes it from <span class="Li">$text</span>):</p>
<p class="Pp"></p>
<pre>        $quotelike = extract_multiple($text,
                                      [
                                        sub { extract_quotelike($_[0]) },
                                      ], undef, 1);
</pre>
<p class="Pp">Finally, here is yet another way to do comma-separated value
    parsing:</p>
<p class="Pp"></p>
<pre>        @fields = extract_multiple($csv_text,
                                  [
                                        sub { extract_delimited($_[0],q{'&quot;}) },
                                        qr/([^,]+)(.*)/,
                                  ],
                                  undef,1);
</pre>
<p class="Pp">The list in the second argument means: <i>&quot;Try and extract a
    ' or &quot; delimited string, otherwise extract anything up to a
    comma...&quot;</i>. The undef third argument means: <i>&quot;...as many
    times as possible...&quot;</i>, and the true value in the fourth argument
    means <i>&quot;...discarding anything else that appears (i.e. the
    commas)&quot;</i>.</p>
<p class="Pp">If you wanted the commas preserved as separate fields (i.e. like
    split does if your split pattern has capturing parentheses), you would just
    make the last parameter undefined (or remove it).</p>
</div>
<dl class="Bl-tag">
  <dt>&quot;gen_delimited_pat&quot;</dt>
  <dd>The <span class="Li">&quot;gen_delimited_pat&quot;</span> subroutine takes
      a single (string) argument and
    <br/>
     &gt; builds a Friedl-style optimized regex that matches a string delimited
      by any one of the characters in the single argument. For example:
    <p class="Pp"></p>
    <pre>        gen_delimited_pat(q{'&quot;})
    </pre>
    <p class="Pp">returns the regex:</p>
    <p class="Pp"></p>
    <pre>        (?:\&quot;(?:\\\&quot;|(?!\&quot;).)*\&quot;|\'(?:\\\'|(?!\').)*\')
    </pre>
    <p class="Pp">Note that the specified delimiters are automatically
        quotemeta'd.</p>
    <p class="Pp">A typical use of
        <span class="Li">&quot;gen_delimited_pat&quot;</span> would be to build
        special purpose tags for
        <span class="Li">&quot;extract_tagged&quot;</span>. For example, to
        properly ignore &quot;empty&quot; XML elements (which might contain
        quoted strings):</p>
    <p class="Pp"></p>
    <pre>        my $empty_tag = '&lt;(' . gen_delimited_pat(q{'&quot;}) . '|.)+/&gt;';
        extract_tagged($text, undef, undef, undef, {ignore =&gt; [$empty_tag]} );
    </pre>
    <p class="Pp"><span class="Li">&quot;gen_delimited_pat&quot;</span> may also
        be called with an optional second argument, which specifies the
        &quot;escape&quot; character(s) to be used for each delimiter. For
        example to match a Pascal-style string (where ' is the delimiter and ''
        is a literal ' within the string):</p>
    <p class="Pp"></p>
    <pre>        gen_delimited_pat(q{'},q{'});
    </pre>
    <p class="Pp">Different escape characters can be specified for different
        delimiters. For example, to specify that '/' is the escape for single
        quotes and '%' is the escape for double quotes:</p>
    <p class="Pp"></p>
    <pre>        gen_delimited_pat(q{'&quot;},q{/%});
    </pre>
    <p class="Pp">If more delimiters than escape chars are specified, the last
        escape char is used for the remaining delimiters. If no escape char is
        specified for a given specified delimiter, '\' is used.</p>
  </dd>
  <dt>&quot;delimited_pat&quot;</dt>
  <dd>Note that <span class="Li">&quot;gen_delimited_pat&quot;</span> was
      previously called <span class="Li">&quot;delimited_pat&quot;</span>. That
      name may still be used, but is now deprecated.</dd>
</dl>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="DIAGNOSTICS"><a class="permalink" href="#DIAGNOSTICS">DIAGNOSTICS</a></h1>
<p class="Pp">In a list context, all the functions return
    <span class="Li">&quot;(undef,$original_text)&quot;</span> on failure. In a
    scalar context, failure is indicated by returning
    <span class="Li">&quot;undef&quot;</span> (in this case the input text is
    not modified in any way).</p>
<p class="Pp">In addition, on failure in <i>any</i> context, the
    <span class="Li">$@</span> variable is set. Accessing
    <span class="Li">&quot;$@-&gt;{error}&quot;</span> returns one of the error
    diagnostics listed below. Accessing
    <span class="Li">&quot;$@-&gt;{pos}&quot;</span> returns the offset into the
    original string at which the error was detected (although not necessarily
    where it occurred!) Printing <span class="Li">$@</span> directly produces
    the error message, with the offset appended. On success, the
    <span class="Li">$@</span> variable is guaranteed to be
    <span class="Li">&quot;undef&quot;</span>.</p>
<p class="Pp">The available diagnostics are:</p>
<dl class="Bl-tag">
  <dt>&quot;Did not find a suitable bracket: &quot;%s&quot;&quot;</dt>
  <dd>The delimiter provided to
      <span class="Li">&quot;extract_bracketed&quot;</span> was not one of
      <span class="Li">'()[]&lt;&gt;{}'</span>.</dd>
  <dt>&quot;Did not find prefix: /%s/&quot;</dt>
  <dd>A non-optional prefix was specified but wasn't found at the start of the
      text.</dd>
  <dt>&quot;Did not find opening bracket after prefix: &quot;%s&quot;&quot;</dt>
  <dd><span class="Li">&quot;extract_bracketed&quot;</span> or
      <span class="Li">&quot;extract_codeblock&quot;</span> was expecting a
      particular kind of bracket at the start of the text, and didn't find
    it.</dd>
  <dt>&quot;No quotelike operator found after prefix: &quot;%s&quot;&quot;</dt>
  <dd><span class="Li">&quot;extract_quotelike&quot;</span> didn't find one of
      the quotelike operators <span class="Li">&quot;q&quot;</span>,
      <span class="Li">&quot;qq&quot;</span>,
      <span class="Li">&quot;qw&quot;</span>,
      <span class="Li">&quot;qx&quot;</span>,
      <span class="Li">&quot;s&quot;</span>,
      <span class="Li">&quot;tr&quot;</span> or
      <span class="Li">&quot;y&quot;</span> at the start of the substring it was
      extracting.</dd>
  <dt>&quot;Unmatched closing bracket: &quot;%c&quot;&quot;</dt>
  <dd><span class="Li">&quot;extract_bracketed&quot;</span>,
      <span class="Li">&quot;extract_quotelike&quot;</span> or
      <span class="Li">&quot;extract_codeblock&quot;</span> encountered a
      closing bracket where none was expected.</dd>
  <dt>&quot;Unmatched opening bracket(s): &quot;%s&quot;&quot;</dt>
  <dd><span class="Li">&quot;extract_bracketed&quot;</span>,
      <span class="Li">&quot;extract_quotelike&quot;</span> or
      <span class="Li">&quot;extract_codeblock&quot;</span> ran out of
      characters in the text before closing one or more levels of nested
      brackets.</dd>
  <dt>&quot;Unmatched embedded quote (%s)&quot;</dt>
  <dd><span class="Li">&quot;extract_bracketed&quot;</span> attempted to match
      an embedded quoted substring, but failed to find a closing quote to match
      it.</dd>
  <dt>&quot;Did not find closing delimiter to match '%s'&quot;</dt>
  <dd><span class="Li">&quot;extract_quotelike&quot;</span> was unable to find a
      closing delimiter to match the one that opened the quote-like
    operation.</dd>
  <dt>&quot;Mismatched closing bracket: expected &quot;%c&quot; but found
    &quot;%s&quot;&quot;</dt>
  <dd><span class="Li">&quot;extract_bracketed&quot;</span>,
      <span class="Li">&quot;extract_quotelike&quot;</span> or
      <span class="Li">&quot;extract_codeblock&quot;</span> found a valid
      bracket delimiter, but it was the wrong species. This usually indicates a
      nesting error, but may indicate incorrect quoting or escaping.</dd>
  <dt>&quot;No block delimiter found after quotelike &quot;%s&quot;&quot;</dt>
  <dd><span class="Li">&quot;extract_quotelike&quot;</span> or
      <span class="Li">&quot;extract_codeblock&quot;</span> found one of the
      quotelike operators <span class="Li">&quot;q&quot;</span>,
      <span class="Li">&quot;qq&quot;</span>,
      <span class="Li">&quot;qw&quot;</span>,
      <span class="Li">&quot;qx&quot;</span>,
      <span class="Li">&quot;s&quot;</span>,
      <span class="Li">&quot;tr&quot;</span> or
      <span class="Li">&quot;y&quot;</span> without a suitable block after
    it.</dd>
  <dt>&quot;Did not find leading dereferencer&quot;</dt>
  <dd><span class="Li">&quot;extract_variable&quot;</span> was expecting one of
      '$', '@', or '%' at the start of a variable, but didn't find any of
    them.</dd>
  <dt>&quot;Bad identifier after dereferencer&quot;</dt>
  <dd><span class="Li">&quot;extract_variable&quot;</span> found a '$', '@', or
      '%' indicating a variable, but that character was not followed by a legal
      Perl identifier.</dd>
  <dt>&quot;Did not find expected opening bracket at %s&quot;</dt>
  <dd><span class="Li">&quot;extract_codeblock&quot;</span> failed to find any
      of the outermost opening brackets that were specified.</dd>
  <dt>&quot;Improperly nested codeblock at %s&quot;</dt>
  <dd>A nested code block was found that started with a delimiter that was
      specified as being only to be used as an outermost bracket.</dd>
  <dt>&quot;Missing second block for quotelike &quot;%s&quot;&quot;</dt>
  <dd><span class="Li">&quot;extract_codeblock&quot;</span> or
      <span class="Li">&quot;extract_quotelike&quot;</span> found one of the
      quotelike operators <span class="Li">&quot;s&quot;</span>,
      <span class="Li">&quot;tr&quot;</span> or
      <span class="Li">&quot;y&quot;</span> followed by only one block.</dd>
  <dt>&quot;No match found for opening bracket&quot;</dt>
  <dd><span class="Li">&quot;extract_codeblock&quot;</span> failed to find a
      closing bracket to match the outermost opening bracket.</dd>
  <dt>&quot;Did not find opening tag: /%s/&quot;</dt>
  <dd><span class="Li">&quot;extract_tagged&quot;</span> did not find a suitable
      opening tag (after any specified prefix was removed).</dd>
  <dt>&quot;Unable to construct closing tag to match: /%s/&quot;</dt>
  <dd><span class="Li">&quot;extract_tagged&quot;</span> matched the specified
      opening tag and tried to modify the matched text to produce a matching
      closing tag (because none was specified). It failed to generate the
      closing tag, almost certainly because the opening tag did not start with a
      bracket of some kind.</dd>
  <dt>&quot;Found invalid nested tag: %s&quot;</dt>
  <dd><span class="Li">&quot;extract_tagged&quot;</span> found a nested tag that
      appeared in the &quot;reject&quot; list (and the failure mode was not
      &quot;MAX&quot; or &quot;PARA&quot;).</dd>
  <dt>&quot;Found unbalanced nested tag: %s&quot;</dt>
  <dd><span class="Li">&quot;extract_tagged&quot;</span> found a nested opening
      tag that was not matched by a corresponding nested closing tag (and the
      failure mode was not &quot;MAX&quot; or &quot;PARA&quot;).</dd>
  <dt>&quot;Did not find closing tag&quot;</dt>
  <dd><span class="Li">&quot;extract_tagged&quot;</span> reached the end of the
      text without finding a closing tag to match the original opening tag (and
      the failure mode was not &quot;MAX&quot; or &quot;PARA&quot;).</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="EXPORTS"><a class="permalink" href="#EXPORTS">EXPORTS</a></h1>
<p class="Pp">The following symbols are, or can be, exported by this module:</p>
<dl class="Bl-tag">
  <dt id="Default"><a class="permalink" href="#Default">Default Exports</a></dt>
  <dd><i>None</i>.</dd>
  <dt id="Optional"><a class="permalink" href="#Optional">Optional
    Exports</a></dt>
  <dd><span class="Li">&quot;extract_delimited&quot;</span>,
      <span class="Li">&quot;extract_bracketed&quot;</span>,
      <span class="Li">&quot;extract_quotelike&quot;</span>,
      <span class="Li">&quot;extract_codeblock&quot;</span>,
      <span class="Li">&quot;extract_variable&quot;</span>,
      <span class="Li">&quot;extract_tagged&quot;</span>,
      <span class="Li">&quot;extract_multiple&quot;</span>,
      <span class="Li">&quot;gen_delimited_pat&quot;</span>,
      <span class="Li">&quot;gen_extract_tagged&quot;</span>,
      <span class="Li">&quot;delimited_pat&quot;</span>.</dd>
  <dt id="Export"><a class="permalink" href="#Export">Export Tags</a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>&quot;:ALL&quot;</dt>
  <dd><span class="Li">&quot;extract_delimited&quot;</span>,
      <span class="Li">&quot;extract_bracketed&quot;</span>,
      <span class="Li">&quot;extract_quotelike&quot;</span>,
      <span class="Li">&quot;extract_codeblock&quot;</span>,
      <span class="Li">&quot;extract_variable&quot;</span>,
      <span class="Li">&quot;extract_tagged&quot;</span>,
      <span class="Li">&quot;extract_multiple&quot;</span>,
      <span class="Li">&quot;gen_delimited_pat&quot;</span>,
      <span class="Li">&quot;gen_extract_tagged&quot;</span>,
      <span class="Li">&quot;delimited_pat&quot;</span>.</dd>
</dl>
</div>
<div class="Bd-indent"></div>
</section>
<section class="Sh">
<h1 class="Sh" id="KNOWN_BUGS"><a class="permalink" href="#KNOWN_BUGS">KNOWN
  BUGS</a></h1>
<p class="Pp">See
    &lt;https://rt.cpan.org/Dist/Display.html?Status=Active&amp;Queue=Text-Balanced&gt;.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="FEEDBACK"><a class="permalink" href="#FEEDBACK">FEEDBACK</a></h1>
<p class="Pp">Patches, bug reports, suggestions or any other feedback is
    welcome.</p>
<p class="Pp">Patches can be sent as GitHub pull requests at
    &lt;https://github.com/steve-m-hay/Text-Balanced/pulls&gt;.</p>
<p class="Pp">Bug reports and suggestions can be made on the CPAN Request
    Tracker at
    &lt;https://rt.cpan.org/Public/Bug/Report.html?Queue=Text-Balanced&gt;.</p>
<p class="Pp">Currently active requests on the CPAN Request Tracker can be
    viewed at
    &lt;https://rt.cpan.org/Public/Dist/Display.html?Status=Active;Queue=Text-Balanced&gt;.</p>
<p class="Pp">Please test this distribution. See CPAN Testers Reports at
    &lt;https://www.cpantesters.org/&gt; for details of how to get involved.</p>
<p class="Pp">Previous test results on CPAN Testers Reports can be viewed at
    &lt;https://www.cpantesters.org/distro/T/Text-Balanced.html&gt;.</p>
<p class="Pp">Please rate this distribution on CPAN Ratings at
    &lt;https://cpanratings.perl.org/rate/?distribution=Text-Balanced&gt;.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AVAILABILITY"><a class="permalink" href="#AVAILABILITY">AVAILABILITY</a></h1>
<p class="Pp">The latest version of this module is available from CPAN (see
    &quot;CPAN&quot; in perlmodlib for details) at</p>
<p class="Pp">&lt;https://metacpan.org/release/Text-Balanced&gt; or</p>
<p class="Pp">&lt;https://www.cpan.org/authors/id/S/SH/SHAY/&gt; or</p>
<p class="Pp">&lt;https://www.cpan.org/modules/by-module/Text/&gt;.</p>
<p class="Pp">The latest source code is available from GitHub at
    &lt;https://github.com/steve-m-hay/Text-Balanced&gt;.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="INSTALLATION"><a class="permalink" href="#INSTALLATION">INSTALLATION</a></h1>
<p class="Pp">See the <i>INSTALL</i> file.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">Damian Conway &lt;damian@conway.org
    &lt;mailto:damian@conway.org&gt;&gt;.</p>
<p class="Pp">Steve Hay &lt;shay@cpan.org &lt;mailto:shay@cpan.org&gt;&gt; is
    now maintaining Text::Balanced as of version 2.03.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT"><a class="permalink" href="#COPYRIGHT">COPYRIGHT</a></h1>
<p class="Pp">Copyright (C) 1997-2001 Damian Conway. All rights reserved.</p>
<p class="Pp">Copyright (C) 2009 Adam Kennedy.</p>
<p class="Pp">Copyright (C) 2015, 2020 Steve Hay. All rights reserved.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="LICENCE"><a class="permalink" href="#LICENCE">LICENCE</a></h1>
<p class="Pp">This module is free software; you can redistribute it and/or
    modify it under the same terms as Perl itself, i.e. under the terms of
    either the GNU General Public License or the Artistic License, as specified
    in the <i>LICENCE</i> file.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="VERSION"><a class="permalink" href="#VERSION">VERSION</a></h1>
<p class="Pp">Version 2.04</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DATE"><a class="permalink" href="#DATE">DATE</a></h1>
<p class="Pp">11 Dec 2020</p>
</section>
<section class="Sh">
<h1 class="Sh" id="HISTORY"><a class="permalink" href="#HISTORY">HISTORY</a></h1>
<p class="Pp">See the <i>Changes</i> file.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2022-02-19</td>
    <td class="foot-os">perl v5.34.1</td>
  </tr>
</table>
</body>
</html>
