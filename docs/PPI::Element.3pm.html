<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    .Nd, .Bf, .Op { display: inline; }
    .Pa, .Ad { font-style: italic; }
    .Ms { font-weight: bold; }
    .Bl-diag > dt { font-weight: bold; }
    code.Nm, .Fl, .Cm, .Ic, code.In, .Fd, .Fn, .Cd { font-weight: bold;
      font-family: inherit; }
  </style>
  <title>PPI::Element(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">PPI::Element(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">PPI::Element(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">PPI::Element - The abstract Element class, a base for all source
    objects</p>
</section>
<section class="Sh">
<h1 class="Sh" id="INHERITANCE"><a class="permalink" href="#INHERITANCE">INHERITANCE</a></h1>
<pre>  PPI::Element is the root of the PDOM tree
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">The abstract <span class="Li">&quot;PPI::Element&quot;</span>
    serves as a base class for all source-related objects, from a single
    whitespace token to an entire document. It provides a basic set of methods
    to provide a common interface and basic implementations.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="METHODS"><a class="permalink" href="#METHODS">METHODS</a></h1>
<section class="Ss">
<h2 class="Ss" id="significant"><a class="permalink" href="#significant">significant</a></h2>
<p class="Pp">Because we treat whitespace and other non-code items as Tokens (in
    order to be able to &quot;round trip&quot; the PPI::Document back to a file)
    the <span class="Li">&quot;significant&quot;</span> method allows us to
    distinguish between tokens that form a part of the code, and tokens that
    aren't significant, such as whitespace, POD, or the portion of a file after
    (and including) the <span class="Li">&quot;__END__&quot;</span> token.</p>
<p class="Pp">Returns true if the Element is significant, or false it not.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="class"><a class="permalink" href="#class">class</a></h2>
<p class="Pp">The <span class="Li">&quot;class&quot;</span> method is provided
    as a convenience, and really does nothing more than returning
    <span class="Li">&quot;ref($self)&quot;</span>. However, some people have
    found that they appreciate the laziness of
    <span class="Li">&quot;$Foo-&gt;class eq 'whatever'&quot;</span>, so I have
    caved to popular demand and included it.</p>
<p class="Pp">Returns the class of the Element as a string</p>
</section>
<section class="Ss">
<h2 class="Ss" id="tokens"><a class="permalink" href="#tokens">tokens</a></h2>
<p class="Pp">The <span class="Li">&quot;tokens&quot;</span> method returns a
    list of PPI::Token objects for the Element, essentially getting back that
    part of the document as if it had not been lexed.</p>
<p class="Pp">This also means there are no Statements and no Structures in the
    list, just the Token classes.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="content"><a class="permalink" href="#content">content</a></h2>
<p class="Pp">For <b>any</b> <span class="Li">&quot;PPI::Element&quot;</span>,
    the <span class="Li">&quot;content&quot;</span> method will reconstitute the
    base code for it as a single string. This method is also the method used for
    overloading stringification. When an Element is used in a double-quoted
    string for example, this is the method that is called.</p>
<p class="Pp"><b>WARNING:</b></p>
<p class="Pp">You should be aware that because of the way that here-docs are
    handled, any here-doc content is not included in
    <span class="Li">&quot;content&quot;</span>, and as such you should
    <b>not</b> eval or execute the result if it contains any
    PPI::Token::HereDoc.</p>
<p class="Pp">The PPI::Document method
    <span class="Li">&quot;serialize&quot;</span> should be used to stringify a
    PDOM document into something that can be executed as expected.</p>
<p class="Pp">Returns the basic code as a string (excluding here-doc
  content).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="parent"><a class="permalink" href="#parent">parent</a></h2>
<p class="Pp">Elements themselves are not intended to contain other Elements,
    that is left to the PPI::Node abstract class, a subclass of
    <span class="Li">&quot;PPI::Element&quot;</span>. However, all Elements can
    be contained <b>within</b> a parent Node.</p>
<p class="Pp">If an Element is within a parent Node, the
    <span class="Li">&quot;parent&quot;</span> method returns the Node.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="descendant_of_$element"><a class="permalink" href="#descendant_of_$element">descendant_of
  $element</a></h2>
<p class="Pp">Answers whether a <span class="Li">&quot;PPI::Element&quot;</span>
    is contained within another one.</p>
<p class="Pp"><span class="Li">&quot;PPI::Element&quot;</span>s are considered
    to be descendants of themselves.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="ancestor_of_$element"><a class="permalink" href="#ancestor_of_$element">ancestor_of
  $element</a></h2>
<p class="Pp">Answers whether a <span class="Li">&quot;PPI::Element&quot;</span>
    is contains another one.</p>
<p class="Pp"><span class="Li">&quot;PPI::Element&quot;</span>s are considered
    to be ancestors of themselves.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="statement"><a class="permalink" href="#statement">statement</a></h2>
<p class="Pp">For a <span class="Li">&quot;PPI::Element&quot;</span> that is
    contained (at some depth) within a PPI::Statement, the
    <span class="Li">&quot;statement&quot;</span> method will return the first
    parent Statement object lexically 'above' the Element.</p>
<p class="Pp">Returns a PPI::Statement object, which may be the same Element if
    the Element is itself a PPI::Statement object.</p>
<p class="Pp">Returns false if the Element is not within a Statement and is not
    itself a Statement.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="top"><a class="permalink" href="#top">top</a></h2>
<p class="Pp">For a <span class="Li">&quot;PPI::Element&quot;</span> that is
    contained within a PDOM tree, the <span class="Li">&quot;top&quot;</span>
    method will return the top-level Node in the tree. Most of the time this
    should be a PPI::Document object, however this will not always be so. For
    example, if a subroutine has been removed from its Document, to be moved to
    another Document.</p>
<p class="Pp">Returns the top-most PDOM object, which may be the same Element,
    if it is not within any parent PDOM object.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="document"><a class="permalink" href="#document">document</a></h2>
<p class="Pp">For an Element that is contained within a PPI::Document object,
    the <span class="Li">&quot;document&quot;</span> method will return the
    top-level Document for the Element.</p>
<p class="Pp">Returns the PPI::Document for this Element, or false if the
    Element is not contained within a Document.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="next_sibling"><a class="permalink" href="#next_sibling">next_sibling</a></h2>
<p class="Pp">All PPI::Node objects (specifically, our parent Node) contain a
    number of <span class="Li">&quot;PPI::Element&quot;</span> objects. The
    <span class="Li">&quot;next_sibling&quot;</span> method returns the
    <span class="Li">&quot;PPI::Element&quot;</span> immediately after the
    current one, or false if there is no next sibling.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="snext_sibling"><a class="permalink" href="#snext_sibling">snext_sibling</a></h2>
<p class="Pp">As per the other 's' methods, the
    <span class="Li">&quot;snext_sibling&quot;</span> method returns the next
    <b>significant</b> sibling of the
    <span class="Li">&quot;PPI::Element&quot;</span> object.</p>
<p class="Pp">Returns a <span class="Li">&quot;PPI::Element&quot;</span> object,
    or false if there is no 'next' significant sibling.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="previous_sibling"><a class="permalink" href="#previous_sibling">previous_sibling</a></h2>
<p class="Pp">All PPI::Node objects (specifically, our parent Node) contain a
    number of <span class="Li">&quot;PPI::Element&quot;</span> objects. The
    <span class="Li">&quot;previous_sibling&quot;</span> method returns the
    Element immediately before the current one, or false if there is no
    'previous' <span class="Li">&quot;PPI::Element&quot;</span> object.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="sprevious_sibling"><a class="permalink" href="#sprevious_sibling">sprevious_sibling</a></h2>
<p class="Pp">As per the other 's' methods, the
    <span class="Li">&quot;sprevious_sibling&quot;</span> method returns the
    previous <b>significant</b> sibling of the
    <span class="Li">&quot;PPI::Element&quot;</span> object.</p>
<p class="Pp">Returns a <span class="Li">&quot;PPI::Element&quot;</span> object,
    or false if there is no 'previous' significant sibling.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="first_token"><a class="permalink" href="#first_token">first_token</a></h2>
<p class="Pp">As a support method for higher-order algorithms that deal
    specifically with tokens and actual Perl content, the
    <span class="Li">&quot;first_token&quot;</span> method finds the first
    PPI::Token object within or equal to this one.</p>
<p class="Pp">That is, if called on a PPI::Node subclass, it will descend until
    it finds a PPI::Token. If called on a PPI::Token object, it will return the
    same object.</p>
<p class="Pp">Returns a PPI::Token object, or dies on error (which should be
    extremely rare and only occur if an illegal empty PPI::Statement exists
    below the current Element somewhere.)</p>
</section>
<section class="Ss">
<h2 class="Ss" id="last_token"><a class="permalink" href="#last_token">last_token</a></h2>
<p class="Pp">As a support method for higher-order algorithms that deal
    specifically with tokens and actual Perl content, the
    <span class="Li">&quot;last_token&quot;</span> method finds the last
    PPI::Token object within or equal to this one.</p>
<p class="Pp">That is, if called on a PPI::Node subclass, it will descend until
    it finds a PPI::Token. If called on a PPI::Token object, it will return the
    itself.</p>
<p class="Pp">Returns a PPI::Token object, or dies on error (which should be
    extremely rare and only occur if an illegal empty PPI::Statement exists
    below the current Element somewhere.)</p>
</section>
<section class="Ss">
<h2 class="Ss" id="next_token"><a class="permalink" href="#next_token">next_token</a></h2>
<p class="Pp">As a support method for higher-order algorithms that deal
    specifically with tokens and actual Perl content, the
    <span class="Li">&quot;next_token&quot;</span> method finds the PPI::Token
    object that is immediately after the current Element, even if it is not
    within the same parent PPI::Node as the one for which the method is being
    called.</p>
<p class="Pp">Note that this is <b>not</b> defined as a PPI::Token-specific
    method, because it can be useful to find the next token that is after, say,
    a PPI::Statement, although obviously it would be useless to want the next
    token after a PPI::Document.</p>
<p class="Pp">Returns a PPI::Token object, or false if there are no more tokens
    after the Element.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="previous_token"><a class="permalink" href="#previous_token">previous_token</a></h2>
<p class="Pp">As a support method for higher-order algorithms that deal
    specifically with tokens and actual Perl content, the
    <span class="Li">&quot;previous_token&quot;</span> method finds the
    PPI::Token object that is immediately before the current Element, even if it
    is not within the same parent PPI::Node as this one.</p>
<p class="Pp">Note that this is not defined as a PPI::Token-only method, because
    it can be useful to find the token is before, say, a PPI::Statement,
    although obviously it would be useless to want the next token before a
    PPI::Document.</p>
<p class="Pp">Returns a PPI::Token object, or false if there are no more tokens
    before the <span class="Li">&quot;Element&quot;</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="clone"><a class="permalink" href="#clone">clone</a></h2>
<p class="Pp">As per the Clone module, the
    <span class="Li">&quot;clone&quot;</span> method makes a perfect copy of an
    Element object. In the generic case, the implementation is done using the
    Clone module's mechanism itself. In higher-order cases, such as for Nodes,
    there is more work involved to keep the parent-child links intact.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="insert_before_@Elements"><a class="permalink" href="#insert_before_@Elements">insert_before
  @Elements</a></h2>
<p class="Pp">The <span class="Li">&quot;insert_before&quot;</span> method
    allows you to insert lexical perl content, in the form of
    <span class="Li">&quot;PPI::Element&quot;</span> objects, before the calling
    <span class="Li">&quot;Element&quot;</span>. You need to be very careful
    when modifying perl code, as it's easy to break things.</p>
<p class="Pp">In its initial incarnation, this method allows you to insert a
    single Element, and will perform some basic checking to prevent you
    inserting something that would be structurally wrong (in PDOM terms).</p>
<p class="Pp">In future, this method may be enhanced to allow the insertion of
    multiple Elements, inline-parsed code strings or PPI::Document::Fragment
    objects.</p>
<p class="Pp">Returns true if the Element was inserted, false if it can not be
    inserted, or <span class="Li">&quot;undef&quot;</span> if you do not provide
    a <span class="Li">&quot;PPI::Element&quot;</span> object as a
  parameter.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="insert_after_@Elements"><a class="permalink" href="#insert_after_@Elements">insert_after
  @Elements</a></h2>
<p class="Pp">The <span class="Li">&quot;insert_after&quot;</span> method allows
    you to insert lexical perl content, in the form of
    <span class="Li">&quot;PPI::Element&quot;</span> objects, after the calling
    <span class="Li">&quot;Element&quot;</span>. You need to be very careful
    when modifying perl code, as it's easy to break things.</p>
<p class="Pp">In its initial incarnation, this method allows you to insert a
    single Element, and will perform some basic checking to prevent you
    inserting something that would be structurally wrong (in PDOM terms).</p>
<p class="Pp">In future, this method may be enhanced to allow the insertion of
    multiple Elements, inline-parsed code strings or PPI::Document::Fragment
    objects.</p>
<p class="Pp">Returns true if the Element was inserted, false if it can not be
    inserted, or <span class="Li">&quot;undef&quot;</span> if you do not provide
    a <span class="Li">&quot;PPI::Element&quot;</span> object as a
  parameter.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="remove"><a class="permalink" href="#remove">remove</a></h2>
<p class="Pp">For a given <span class="Li">&quot;PPI::Element&quot;</span>, the
    <span class="Li">&quot;remove&quot;</span> method will remove it from its
    parent <b>intact</b>, along with all of its children.</p>
<p class="Pp">Returns the <span class="Li">&quot;Element&quot;</span> itself as
    a convenience, or <span class="Li">&quot;undef&quot;</span> if an error
    occurs while trying to remove the
    <span class="Li">&quot;Element&quot;</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="delete"><a class="permalink" href="#delete">delete</a></h2>
<p class="Pp">For a given <span class="Li">&quot;PPI::Element&quot;</span>, the
    <span class="Li">&quot;delete&quot;</span> method will remove it from its
    parent, immediately deleting the <span class="Li">&quot;Element&quot;</span>
    and all of its children (if it has any).</p>
<p class="Pp">Returns true if the <span class="Li">&quot;Element&quot;</span>
    was successfully deleted, or <span class="Li">&quot;undef&quot;</span> if an
    error occurs while trying to remove the
    <span class="Li">&quot;Element&quot;</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="replace_$Element"><a class="permalink" href="#replace_$Element">replace
  $Element</a></h2>
<p class="Pp">Although some higher level class support more exotic forms of
    replace, at the basic level the <span class="Li">&quot;replace&quot;</span>
    method takes a single <span class="Li">&quot;Element&quot;</span> as an
    argument and replaces the current
    <span class="Li">&quot;Element&quot;</span> with it.</p>
<p class="Pp">To prevent accidental damage to code, in this initial
    implementation the replacement element <b>must</b> be of the same class (or
    a subclass) as the one being replaced.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="location"><a class="permalink" href="#location">location</a></h2>
<p class="Pp">If the Element exists within a PPI::Document that has indexed the
    Element locations using
    <span class="Li">&quot;PPI::Document::index_locations&quot;</span>, the
    <span class="Li">&quot;location&quot;</span> method will return the location
    of the first character of the Element within the Document.</p>
<p class="Pp">Returns the location as a reference to a five-element array in the
    form <span class="Li">&quot;[</span> <span class="Li">$line, $rowchar, $col,
    $logical_line, $logical_file_name ]&quot;</span>. The values are in a human
    format, with the first character of the file located at
    <span class="Li">&quot;[ 1, 1, 1, ?,</span> <span class="Li">'something'
    ]&quot;</span>.</p>
<p class="Pp">The second and third numbers are similar, except that the second
    is the literal horizontal character, and the third is the visual column,
    taking into account tabbing (see &quot;tab_width [
    <span class="Li">$width</span> ]&quot; in PPI::Document).</p>
<p class="Pp">The fourth number is the line number, taking into account any
    <span class="Li">&quot;#line&quot;</span> directives. The fifth element is
    the name of the file that the element was found in, if available, taking
    into account any <span class="Li">&quot;#line&quot;</span> directives.</p>
<p class="Pp">Returns <span class="Li">&quot;undef&quot;</span> on error, or if
    the PPI::Document object has not been indexed.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="line_number"><a class="permalink" href="#line_number">line_number</a></h2>
<p class="Pp">If the Element exists within a PPI::Document that has indexed the
    Element locations using
    <span class="Li">&quot;PPI::Document::index_locations&quot;</span>, the
    <span class="Li">&quot;line_number&quot;</span> method will return the line
    number of the first character of the Element within the Document.</p>
<p class="Pp">Returns <span class="Li">&quot;undef&quot;</span> on error, or if
    the PPI::Document object has not been indexed.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="column_number"><a class="permalink" href="#column_number">column_number</a></h2>
<p class="Pp">If the Element exists within a PPI::Document that has indexed the
    Element locations using
    <span class="Li">&quot;PPI::Document::index_locations&quot;</span>, the
    <span class="Li">&quot;column_number&quot;</span> method will return the
    column number of the first character of the Element within the Document.</p>
<p class="Pp">Returns <span class="Li">&quot;undef&quot;</span> on error, or if
    the PPI::Document object has not been indexed.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="visual_column_number"><a class="permalink" href="#visual_column_number">visual_column_number</a></h2>
<p class="Pp">If the Element exists within a PPI::Document that has indexed the
    Element locations using
    <span class="Li">&quot;PPI::Document::index_locations&quot;</span>, the
    <span class="Li">&quot;visual_column_number&quot;</span> method will return
    the visual column number of the first character of the Element within the
    Document, according to the value of &quot;tab_width [
    <span class="Li">$width</span> ]&quot; in PPI::Document.</p>
<p class="Pp">Returns <span class="Li">&quot;undef&quot;</span> on error, or if
    the PPI::Document object has not been indexed.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="logical_line_number"><a class="permalink" href="#logical_line_number">logical_line_number</a></h2>
<p class="Pp">If the Element exists within a PPI::Document that has indexed the
    Element locations using
    <span class="Li">&quot;PPI::Document::index_locations&quot;</span>, the
    <span class="Li">&quot;logical_line_number&quot;</span> method will return
    the line number of the first character of the Element within the Document,
    taking into account any <span class="Li">&quot;#line&quot;</span>
    directives.</p>
<p class="Pp">Returns <span class="Li">&quot;undef&quot;</span> on error, or if
    the PPI::Document object has not been indexed.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="logical_filename"><a class="permalink" href="#logical_filename">logical_filename</a></h2>
<p class="Pp">If the Element exists within a PPI::Document that has indexed the
    Element locations using
    <span class="Li">&quot;PPI::Document::index_locations&quot;</span>, the
    <span class="Li">&quot;logical_filename&quot;</span> method will return the
    logical file name containing the first character of the Element within the
    Document, taking into account any <span class="Li">&quot;#line&quot;</span>
    directives.</p>
<p class="Pp">Returns <span class="Li">&quot;undef&quot;</span> on error, or if
    the PPI::Document object has not been indexed.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="TO_DO"><a class="permalink" href="#TO_DO">TO DO</a></h1>
<p class="Pp">It would be nice if <span class="Li">&quot;location&quot;</span>
    could be used in an ad-hoc manner. That is, if called on an Element within a
    Document that has not been indexed, it will do a one-off calculation to find
    the location. It might be very painful if someone started using it a lot,
    without remembering to index the document, but it would be handy for things
    that are only likely to use it once, such as error handlers.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SUPPORT"><a class="permalink" href="#SUPPORT">SUPPORT</a></h1>
<p class="Pp">See the support section in the main module.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">Adam Kennedy &lt;adamk@cpan.org&gt;</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT"><a class="permalink" href="#COPYRIGHT">COPYRIGHT</a></h1>
<p class="Pp">Copyright 2001 - 2011 Adam Kennedy.</p>
<p class="Pp">This program is free software; you can redistribute it and/or
    modify it under the same terms as Perl itself.</p>
<p class="Pp">The full text of the license can be found in the LICENSE file
    included with this module.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2019-07-09</td>
    <td class="foot-os">perl v5.30.2</td>
  </tr>
</table>
</body>
</html>
