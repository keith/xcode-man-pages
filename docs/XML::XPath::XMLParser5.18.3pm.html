<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>XPath::XMLParser(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">XPath::XMLParser(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">XPath::XMLParser(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
XML::XPath::XMLParser - The default XML parsing class that produces a node tree
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<span class="Li"></span>
<pre>
    my $parser = XML::XPath::XMLParser-&gt;new(
                filename =&gt; $self-&gt;get_filename,
                xml =&gt; $self-&gt;get_xml,
                ioref =&gt; $self-&gt;get_ioref,
                parser =&gt; $self-&gt;get_parser,
            );
    my $root_node = $parser-&gt;parse;
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
This module generates a node tree for use as the context node for XPath
  processing. It aims to be a quick parser, nothing fancy, and yet has to store
  more information than most parsers. To achieve this I've used array refs
  everywhere - no hashes. I don't have any performance figures for the speedups
  achieved, so I make no appologies for anyone not used to using arrays instead
  of hashes. I think they make good sense here where we know the attributes of
  each type of node.
</section>
<section class="Sh">
<h1 class="Sh" id="Node_Structure"><a class="permalink" href="#Node_Structure">Node
  Structure</a></h1>
All nodes have the same first 2 entries in the array: node_parent and node_pos.
  The type of the node is determined using the <i>ref()</i> function. The
  node_parent always contains an entry for the parent of the current node -
  except for the root node which has undef in there. And node_pos is the
  position of this node in the array that it is in (think:
  <span class="Li">$node</span> ==
  <span class="Li">$node</span>-&gt;[node_parent]-&gt;[node_children]-&gt;[$node-&gt;[node_pos]]
  )
<p class="Pp">Nodes are structured as follows:</p>
<section class="Ss">
<h2 class="Ss" id="Root_Node"><a class="permalink" href="#Root_Node">Root
  Node</a></h2>
The root node is just an element node with no parent.
<p class="Pp"><span class="Li"></span></p>
<pre>
    [
      undef, # node_parent - check for undef to identify root node
      undef, # node_pos
      undef, # node_prefix
      [ ... ], # node_children (see below)
    ]
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Element_Node"><a class="permalink" href="#Element_Node">Element
  Node</a></h2>
<span class="Li"></span>
<pre>
    [
      $parent, # node_parent
      &lt;position in current array&gt;, # node_pos
      'xxx', # node_prefix - namespace prefix on this element
      [ ... ], # node_children
      'yyy', # node_name - element tag name
      [ ... ], # node_attribs - attributes on this element
      [ ... ], # node_namespaces - namespaces currently in scope
    ]
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Attribute_Node"><a class="permalink" href="#Attribute_Node">Attribute
  Node</a></h2>
<span class="Li"></span>
<pre>
    [
      $parent, # node_parent - the element node
      &lt;position in current array&gt;, # node_pos
      'xxx', # node_prefix - namespace prefix on this element
      'href', # node_key - attribute name
      'ftp://ftp.com/', # node_value - value in the node
    ]
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Namespace_Nodes"><a class="permalink" href="#Namespace_Nodes">Namespace
  Nodes</a></h2>
Each element has an associated set of namespace nodes that are currently in
  scope. Each namespace node stores a prefix and the expanded name (retrieved
  from the xmlns:prefix=&quot;...&quot; attribute).
<p class="Pp"><span class="Li"></span></p>
<pre>
    [
      $parent,
      &lt;pos&gt;,
      'a', # node_prefix - the namespace as it was written as a prefix
      'http://my.namespace.com', # node_expanded - the expanded name.
    ]
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Text_Nodes"><a class="permalink" href="#Text_Nodes">Text
  Nodes</a></h2>
<span class="Li"></span>
<pre>
    [
      $parent,
      &lt;pos&gt;,
      'This is some text' # node_text - the text in the node
    ]
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Comment_Nodes"><a class="permalink" href="#Comment_Nodes">Comment
  Nodes</a></h2>
<span class="Li"></span>
<pre>
    [
      $parent,
      &lt;pos&gt;,
      'This is a comment' # node_comment
    ]
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Processing_Instruction_Nodes"><a class="permalink" href="#Processing_Instruction_Nodes">Processing
  Instruction Nodes</a></h2>
<span class="Li"></span>
<pre>
    [
      $parent,
      &lt;pos&gt;,
      'target', # node_target
      'data', # node_data
    ]
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="Usage"><a class="permalink" href="#Usage">Usage</a></h1>
If you feel the need to use this module outside of XML::XPath (for example you
  might use this module directly so that you can cache parsed trees), you can
  follow the following API:
<section class="Ss">
<h2 class="Ss" id="new"><a class="permalink" href="#new">new</a></h2>
The new method takes either no parameters, or any of the following parameters:
<p class="Pp"><span class="Li"></span></p>
<pre>
        filename
        xml
        parser
        ioref
</pre>
<p class="Pp">This uses the familiar hash syntax, so an example might be:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    use XML::XPath::XMLParser;
    
    my $parser = XML::XPath::XMLParser-&gt;new(filename =&gt; 'example.xml');
</pre>
<p class="Pp">The parameters represent a filename, a string containing XML, an
    XML::Parser instance and an open filehandle ref respectively. You can also
    set or get all of these properties using the get_ and set_ functions that
    have the same name as the property: e.g. get_filename, set_ioref, etc.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="parse"><a class="permalink" href="#parse">parse</a></h2>
The parse method generally takes no parameters, however you are free to pass
  either an open filehandle reference or an XML string if you so require. The
  return value is a tree that XML::XPath can use. The parse method will die if
  there is an error in your XML, so be sure to use perl's exception handling
  mechanism (eval{};) if you want to avoid this.
</section>
<section class="Ss">
<h2 class="Ss" id="parsefile"><a class="permalink" href="#parsefile">parsefile</a></h2>
The parsefile method is identical to <i>parse()</i> except it expects a single
  parameter that is a string naming a file to open and parse. Again it returns a
  tree and also dies if there are XML errors.
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="NOTICES"><a class="permalink" href="#NOTICES">NOTICES</a></h1>
This file is distributed as part of the XML::XPath module, and is copyright 2000
  Fastnet Software Ltd. Please see the documentation for the module as a whole
  for licencing information.
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2001-03-14</td>
    <td class="foot-os">perl v5.18.4</td>
  </tr>
</table>
</body>
</html>
