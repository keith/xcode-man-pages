<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>XPath(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">XPath(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">XPath(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
XML::XPath - a set of modules for parsing and evaluating XPath statements
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
This module aims to comply exactly to the XPath specification at
  http://www.w3.org/TR/xpath and yet allow extensions to be added in the form of
  functions. Modules such as XSLT and XPointer may need to do this as they
  support functionality beyond XPath.
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<span class="Li"></span>
<pre>
    use XML::XPath;
    use XML::XPath::XMLParser;
    
    my $xp = XML::XPath-&gt;new(filename =&gt; 'test.xhtml');
    
    my $nodeset = $xp-&gt;find('/html/body/p'); # find all paragraphs
    
    foreach my $node ($nodeset-&gt;get_nodelist) {
        print &quot;FOUND\n\n&quot;, 
            XML::XPath::XMLParser::as_string($node),
            &quot;\n\n&quot;;
    }
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DETAILS"><a class="permalink" href="#DETAILS">DETAILS</a></h1>
There's an awful lot to all of this, so bear with it - if you stick it out it
  should be worth it. Please get a good understanding of XPath by reading the
  spec before asking me questions. All of the classes and parts herein are named
  to be synonimous with the names in the specification, so consult that if you
  don't understand why I'm doing something in the code.
</section>
<section class="Sh">
<h1 class="Sh" id="API"><a class="permalink" href="#API">API</a></h1>
The API of XML::XPath itself is extremely simple to allow you to get going
  almost immediately. The deeper API's are more complex, but you shouldn't have
  to touch most of that.
<section class="Ss">
<h2 class="Ss" id="_fInew()_fP"><a class="permalink" href="#_fInew()_fP"><i>new()</i></a></h2>
This constructor follows the often seen named parameter method call. Parameters
  you can use are: filename, parser, xml, ioref and context. The filename
  parameter specifies an XML file to parse. The xml parameter specifies a string
  to parse, and the ioref parameter specifies an ioref to parse. The context
  option allows you to specify a context node. The context node has to be in the
  format of a node as specified in XML::XPath::XMLParser. The 4 parameters
  filename, xml, ioref and context are mutually exclusive - you should only
  specify one (if you specify anything other than context, the context node is
  the root of your document). The parser option allows you to pass in an already
  prepared XML::Parser object, to save you having to create more than one in
  your application (if, for example, you're doing more than just XPath).
<p class="Pp"><span class="Li"></span></p>
<pre>
    my $xp = XML::XPath-&gt;new( context =&gt; $node );
</pre>
<p class="Pp">It is very much recommended that you use only 1 XPath object
    throughout the life of your application. This is because the object (and
    it's sub-objects) maintain certain bits of state information that will be
    useful (such as XPath variables) to later calls to <i>find()</i>. It's also
    a good idea because you'll use less memory this way.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_fInodeset_fP_=_find($path,__$context_)"><a class="permalink" href="#_fInodeset_fP_=_find($path,__$context_)"><i>nodeset</i>
  = find($path, [$context])</a></h2>
The find function takes an XPath expression (a string) and returns either an
  XML::XPath::NodeSet object containing the nodes it found (or empty if no nodes
  matched the path), or one of XML::XPath::Literal (a string),
  XML::XPath::Number, or XML::XPath::Boolean. It should always return something
  - and you can use -&gt;<i>isa()</i> to find out what it returned. If you need
  to check how many nodes it found you should check
  <span class="Li">$nodeset</span>-&gt;size. See XML::XPath::NodeSet. An
  optional second parameter of a context node allows you to use this method
  repeatedly, for example XSLT needs to do this.
</section>
<section class="Ss">
<h2 class="Ss" id="findnodes($path,__$context_)"><a class="permalink" href="#findnodes($path,__$context_)">findnodes($path,
  [$context])</a></h2>
Returns a list of nodes found by <span class="Li">$path</span>, optionally in
  context <span class="Li">$context</span>. In scalar context returns an
  XML::XPath::NodeSet object.
</section>
<section class="Ss">
<h2 class="Ss" id="findnodes_as_string($path,__$context_)"><a class="permalink" href="#findnodes_as_string($path,__$context_)">findnodes_as_string($path,
  [$context])</a></h2>
Returns the nodes found reproduced as XML. The result is not guaranteed to be
  valid XML though.
</section>
<section class="Ss">
<h2 class="Ss" id="findvalue($path,__$context_)"><a class="permalink" href="#findvalue($path,__$context_)">findvalue($path,
  [$context])</a></h2>
Returns either a <span class="Li">&quot;XML::XPath::Literal&quot;</span>, a
  <span class="Li">&quot;XML::XPath::Boolean&quot;</span> or a
  <span class="Li">&quot;XML::XPath::Number&quot;</span> object. If the path
  returns a NodeSet, <span class="Li">$nodeset</span>-&gt;to_literal is called
  automatically for you (and thus a
  <span class="Li">&quot;XML::XPath::Literal&quot;</span> is returned). Note
  that for each of the objects stringification is overloaded, so you can just
  print the value found, or manipulate it in the ways you would a normal perl
  value (e.g. using regular expressions).
</section>
<section class="Ss">
<h2 class="Ss" id="exists($path,__$context_)"><a class="permalink" href="#exists($path,__$context_)">exists($path,
  [$context])</a></h2>
Returns true if the given path exists.
</section>
<section class="Ss">
<h2 class="Ss" id="matches($node,_$path,__$context_)"><a class="permalink" href="#matches($node,_$path,__$context_)">matches($node,
  $path, [$context])</a></h2>
Returns true if the node matches the path (optionally in context
  <span class="Li">$context</span>).
</section>
<section class="Ss">
<h2 class="Ss" id="getNodeText($path)"><a class="permalink" href="#getNodeText($path)">getNodeText($path)</a></h2>
Returns the text string for a particular XML node. Returns a string, or undef if
  the node doesn't exist.
</section>
<section class="Ss">
<h2 class="Ss" id="setNodeText($path,_$text)"><a class="permalink" href="#setNodeText($path,_$text)">setNodeText($path,
  $text)</a></h2>
Sets the text string for a particular XML node. The node can be an element or an
  attribute. If the node to be set is an attribute, and the attribute node does
  not exist, it will be created automatically.
</section>
<section class="Ss">
<h2 class="Ss" id="createNode($path)"><a class="permalink" href="#createNode($path)">createNode($path)</a></h2>
Creates the node matching the path given. If part of the path given, or all of
  the path do not exist, the necessary nodes will be created automatically.
</section>
<section class="Ss">
<h2 class="Ss" id="set_namespace($prefix,_$uri)"><a class="permalink" href="#set_namespace($prefix,_$uri)">set_namespace($prefix,
  $uri)</a></h2>
Sets the namespace prefix mapping to the uri.
<p class="Pp">Normally in XML::XPath the prefixes in XPath node tests take their
    context from the current node. This means that foo:bar will always match an
    element &lt;foo:bar&gt; regardless of the namespace that the prefix foo is
    mapped to (which might even change within the document, resulting in
    unexpected results). In order to make prefixes in XPath node tests actually
    map to a real URI, you need to enable that via a call to the set_namespace
    method of your XML::XPath object.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_fIclear_namespaces()_fP"><a class="permalink" href="#_fIclear_namespaces()_fP"><i>clear_namespaces()</i></a></h2>
Clears all previously set namespace mappings.
</section>
<section class="Ss">
<h2 class="Ss" id="$XML::XPath::Namespaces"><a class="permalink" href="#$XML::XPath::Namespaces">$XML::XPath::Namespaces</a></h2>
Set this to 0 if you <i>don't</i> want namespace processing to occur. This will
  make everything a little (tiny) bit faster, but you'll suffer for it,
  probably.
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="Node_Object_Model"><a class="permalink" href="#Node_Object_Model">Node
  Object Model</a></h1>
See XML::XPath::Node, XML::XPath::Node::Element, XML::XPath::Node::Text,
  XML::XPath::Node::Comment, XML::XPath::Node::Attribute,
  XML::XPath::Node::Namespace, and XML::XPath::Node::PI.
</section>
<section class="Sh">
<h1 class="Sh" id="On_Garbage_Collection"><a class="permalink" href="#On_Garbage_Collection">On
  Garbage Collection</a></h1>
XPath nodes work in a special way that allows circular references, and yet still
  lets Perl's reference counting garbage collector to clean up the nodes after
  use. This should be totally transparent to the user, with one caveat: <b>If
  you free your tree before letting go of a sub-tree,</b> <b>consider that
  playing with fire and you may get burned</b>. What does this mean to the
  average user? Not much. Provided you don't free (or let go out of scope)
  either the tree you passed to XML::XPath-&gt;new, or if you didn't pass a
  tree, and passed a filename or IO-ref, then provided you don't let the
  XML::XPath object go out of scope before you let results of <i>find()</i> and
  its friends go out of scope, then you'll be fine. Even if you <b>do</b> let
  the tree go out of scope before results, you'll probably still be fine. The
  only case where you may get stung is when the last part of your path/query is
  either an ancestor or parent axis. In that case the worst that will happen is
  you'll end up with a circular reference that won't get cleared until
  interpreter destruction time. You can get around that by explicitly calling
  <span class="Li">$node</span>-&gt;DESTROY on each of your result nodes, if you
  really need to do that.
<p class="Pp">Mail me direct if that's not clear. Note that it's not doom and
    gloom. It's by no means perfect, but the worst that will happen is a long
    running process could leak memory. Most long running processes will
    therefore be able to explicitly be careful not to free the tree (or
    XML::XPath object) before freeing results. AxKit, an application that uses
    XML::XPath, does this and I didn't have to make any changes to the code -
    it's already sensible programming.</p>
<p class="Pp">If you <i>really</i> don't want all this to happen, then set the
    variable <span class="Li">$XML::XPath::SafeMode</span>, and call
    <span class="Li">$xp</span>-&gt;<i>cleanup()</i> on the XML::XPath object
    when you're finished, or <span class="Li">$tree</span>-&gt;<i>dispose()</i>
    if you have a tree instead.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="Example"><a class="permalink" href="#Example">Example</a></h1>
Please see the test files in t/ for examples on how to use XPath.
</section>
<section class="Sh">
<h1 class="Sh" id="Support/Author"><a class="permalink" href="#Support/Author">Support/Author</a></h1>
This module is copyright 2000 AxKit.com Ltd. This is free software, and as such
  comes with NO WARRANTY. No dates are used in this module. You may distribute
  this module under the terms of either the Gnu GPL, or the Artistic License
  (the same terms as Perl itself).
<p class="Pp">For support, please subscribe to the Perl-XML mailing list at the
    URL http://listserv.activestate.com/mailman/listinfo/perl-xml</p>
<p class="Pp">Matt Sergeant, matt@sergeant.org</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
XML::XPath::Literal, XML::XPath::Boolean, XML::XPath::Number,
  XML::XPath::XMLParser, XML::XPath::NodeSet, XML::XPath::PerlSAX,
  XML::XPath::Builder.
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2003-01-26</td>
    <td class="foot-os">perl v5.18.4</td>
  </tr>
</table>
</body>
</html>
