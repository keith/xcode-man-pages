<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>Term::UI(3pm)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Term::UI(3pm)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">Term::UI(3pm)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
Term::UI - Term::ReadLine UI made easy
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<span class="Li"></span>
<pre>
    use Term::UI;
    use Term::ReadLine;

    my $term = Term::ReadLine-&gt;new('brand');

    my $reply = $term-&gt;get_reply(
                    prompt =&gt; 'What is your favourite colour?',
                    choices =&gt; [qw|blue red green|],
                    default =&gt; 'blue',
    );

    my $bool = $term-&gt;ask_yn(
                        prompt =&gt; 'Do you like cookies?',
                        default =&gt; 'y',
                );


    my $string = q[some_command -option --no-foo --quux='this thing'];

    my ($options,$munged_input) = $term-&gt;parse_options($string);


    ### don't have Term::UI issue warnings -- default is '1'
    $Term::UI::VERBOSE = 0;

    ### always pick the default (good for non-interactive terms)
    ### -- default is '0'
    $Term::UI::AUTOREPLY = 1;

    ### Retrieve the entire session as a printable string:
    $hist = Term::UI::History-&gt;history_as_string;
    $hist = $term-&gt;history_as_string;
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<span class="Li">&quot;Term::UI&quot;</span> is a transparent way of eliminating
  the overhead of having to format a question and then validate the reply,
  informing the user if the answer was not proper and re-issuing the question.
<p class="Pp">Simply give it the question you want to ask, optionally with
    choices the user can pick from and a default and
    <span class="Li">&quot;Term::UI&quot;</span> will DWYM.</p>
<p class="Pp">For asking a yes or no question, there's even a shortcut.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="HOW_IT_WORKS"><a class="permalink" href="#HOW_IT_WORKS">HOW
  IT WORKS</a></h1>
<span class="Li">&quot;Term::UI&quot;</span> places itself at the back of the
  <span class="Li">&quot;Term::ReadLine&quot;</span>
  <span class="Li">@ISA</span> array, so you can call its functions through your
  term object.
<p class="Pp"><span class="Li">&quot;Term::UI&quot;</span> uses
    <span class="Li">&quot;Term::UI::History&quot;</span> to record all
    interactions with the commandline. You can retrieve this history, or alter
    the filehandle the interaction is printed to. See the
    <span class="Li">&quot;Term::UI::History&quot;</span> manpage or the
    <span class="Li">&quot;SYNOPSIS&quot;</span> for details.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="METHODS"><a class="permalink" href="#METHODS">METHODS</a></h1>
<section class="Ss">
<h2 class="Ss" id="$reply_=_$term_-_get_reply(_prompt_=__'question?',__choices_=___e@list,_default_=__$list_0_,_multi_=___s-1BOOL,_s0_print_me_=___extra_text_to_print_&amp;_record_,_allow_=__$ref__);"><a class="permalink" href="#$reply_=_$term_-_get_reply(_prompt_=__'question?',__choices_=___e@list,_default_=__$list_0_,_multi_=___s-1BOOL,_s0_print_me_=___extra_text_to_print_&amp;_record_,_allow_=__$ref__);">$reply
  = $term-&gt;get_reply( prompt =&gt; 'question?', [choices =&gt; \@list,
  default =&gt; $list[0], multi =&gt; BOOL, print_me =&gt; &quot;extra text to
  print &amp; record&quot;, allow =&gt; $ref] );</a></h2>
<span class="Li">&quot;get_reply&quot;</span> asks a user a question, and then
  returns the reply to the caller. If the answer is invalid (more on that
  below), the question will be reposed, until a satisfactory answer has been
  entered.
<p class="Pp">You have the option of providing a list of choices the user can
    pick from using the <span class="Li">&quot;choices&quot;</span> argument. If
    the answer is not in the list of choices presented, the question will be
    reposed.</p>
<p class="Pp">If you provide a <span class="Li">&quot;default&quot;</span>
    answer, this will be returned when either <span class="Li">$AUTOREPLY</span>
    is set to true, (see the <span class="Li">&quot;GLOBAL
    VARIABLES&quot;</span> section further below), or when the user just hits
    <span class="Li">&quot;enter&quot;</span>.</p>
<p class="Pp">You can indicate that the user is allowed to enter multiple
    answers by toggling the <span class="Li">&quot;multi&quot;</span> flag. Note
    that a list of answers will then be returned to you, rather than a simple
    string.</p>
<p class="Pp">By specifying an <span class="Li">&quot;allow&quot;</span> hander,
    you can yourself validate the answer a user gives. This can be any of the
    types that the Params::Check <span class="Li">&quot;allow&quot;</span>
    function allows, so please refer to that manpage for details.</p>
<p class="Pp">Finally, you have the option of adding a
    <span class="Li">&quot;print_me&quot;</span> argument, which is simply
    printed before the prompt. It's printed to the same file handle as the rest
    of the questions, so you can use this to keep track of a full session of
    Q&amp;A with the user, and retrieve it later using the
    <span class="Li">&quot;Term::UI-&gt;history_as_string&quot;</span>
  function.</p>
<p class="Pp">See the <span class="Li">&quot;EXAMPLES&quot;</span> section for
    samples of how to use this function.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="$bool_=_$term_-_ask_yn(_prompt_=___your_question_,__default_=__(y_1,n_0),_print_me_=___extra_text_to_print_&amp;_record___)"><a class="permalink" href="#$bool_=_$term_-_ask_yn(_prompt_=___your_question_,__default_=__(y_1,n_0),_print_me_=___extra_text_to_print_&amp;_record___)">$bool
  = $term-&gt;ask_yn( prompt =&gt; &quot;your question&quot;, [default =&gt;
  (y|1,n|0), print_me =&gt; &quot;extra text to print &amp; record&quot;]
  )</a></h2>
Asks a simple <span class="Li">&quot;yes&quot;</span> or
  <span class="Li">&quot;no&quot;</span> question to the user, returning a
  boolean indicating <span class="Li">&quot;true&quot;</span> or
  <span class="Li">&quot;false&quot;</span> to the caller.
<p class="Pp">The <span class="Li">&quot;default&quot;</span> answer will
    automatically returned, if the user hits
    <span class="Li">&quot;enter&quot;</span> or if
    <span class="Li">$AUTOREPLY</span> is set to true. See the
    <span class="Li">&quot;GLOBAL VARIABLES&quot;</span> section further
  below.</p>
<p class="Pp">Also, you have the option of adding a
    <span class="Li">&quot;print_me&quot;</span> argument, which is simply
    printed before the prompt. It's printed to the same file handle as the rest
    of the questions, so you can use this to keep track of a full session of
    Q&amp;A with the user, and retrieve it later using the
    <span class="Li">&quot;Term::UI-&gt;history_as_string&quot;</span>
  function.</p>
<p class="Pp">See the <span class="Li">&quot;EXAMPLES&quot;</span> section for
    samples of how to use this function.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="($opts,_$munged)_=_$term_-_parse_options(__s-1STRING__s0);"><a class="permalink" href="#($opts,_$munged)_=_$term_-_parse_options(__s-1STRING__s0);">($opts,
  $munged) = $term-&gt;parse_options( STRING );</a></h2>
<span class="Li">&quot;parse_options&quot;</span> will convert all options given
  from an input string to a hash reference. If called in list context it will
  also return the part of the input string that it found no options in.
<p class="Pp">Consider this example:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    my $str =   q[command --no-foo --baz --bar=0 --quux=bleh ] .
                q[--option=&quot;some'thing&quot; -one-dash -single=blah' arg];

    my ($options,$munged) =  $term-&gt;parse_options($str);

    ### $options would contain: ###
    $options = {
                'foo'       =&gt; 0,
                'bar'       =&gt; 0,
                'one-dash'  =&gt; 1,
                'baz'       =&gt; 1,
                'quux'      =&gt; 'bleh',
                'single'    =&gt; 'blah\'',
                'option'    =&gt; 'some\'thing'
    };

    ### and this is the munged version of the input string,
    ### ie what's left of the input minus the options
    $munged = 'command arg';
</pre>
<p class="Pp">As you can see, you can either use a single or a double
    <span class="Li">&quot;-&quot;</span> to indicate an option. If you prefix
    an option with <span class="Li">&quot;no-&quot;</span> and do not give it a
    value, it will be set to 0. If it has no prefix and no value, it will be set
    to 1. Otherwise, it will be set to its value. Note also that it can deal
    fine with single/double quoting issues.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="$str_=_$term_-_history_as_string"><a class="permalink" href="#$str_=_$term_-_history_as_string">$str
  = $term-&gt;history_as_string</a></h2>
Convenience wrapper around
  <span class="Li">&quot;Term::UI::History-&gt;history_as_string&quot;</span>.
<p class="Pp">Consult the <span class="Li">&quot;Term::UI::History&quot;</span>
    man page for details.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="GLOBAL_VARIABLES"><a class="permalink" href="#GLOBAL_VARIABLES">GLOBAL
  VARIABLES</a></h1>
The behaviour of Term::UI can be altered by changing the following global
  variables:
<section class="Ss">
<h2 class="Ss" id="$Term::UI::VERBOSE"><a class="permalink" href="#$Term::UI::VERBOSE">$Term::UI::VERBOSE</a></h2>
This controls whether Term::UI will issue warnings and explanations as to why
  certain things may have failed. If you set it to 0, Term::UI will not output
  any warnings. The default is 1;
</section>
<section class="Ss">
<h2 class="Ss" id="$Term::UI::AUTOREPLY"><a class="permalink" href="#$Term::UI::AUTOREPLY">$Term::UI::AUTOREPLY</a></h2>
This will make every question be answered by the default, and warn if there was
  no default provided. This is particularly useful if your program is run in
  non-interactive mode. The default is 0;
</section>
<section class="Ss">
<h2 class="Ss" id="$Term::UI::INVALID"><a class="permalink" href="#$Term::UI::INVALID">$Term::UI::INVALID</a></h2>
This holds the string that will be printed when the user makes an invalid
  choice. You can override this string from your program if you, for example,
  wish to do localization. The default is <span class="Li">&quot;Invalid
  selection, please try again: &quot;</span>
</section>
<section class="Ss">
<h2 class="Ss" id="$Term::UI::History::HISTORY_FH"><a class="permalink" href="#$Term::UI::History::HISTORY_FH">$Term::UI::History::HISTORY_FH</a></h2>
This is the filehandle all the print statements from this module are being sent
  to. Please consult the <span class="Li">&quot;Term::UI::History&quot;</span>
  manpage for details.
<p class="Pp">This defaults to <span class="Li">*STDOUT</span>.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="EXAMPLES"><a class="permalink" href="#EXAMPLES">EXAMPLES</a></h1>
<section class="Ss">
<h2 class="Ss" id="Basic_get_reply_sample"><a class="permalink" href="#Basic_get_reply_sample">Basic
  get_reply sample</a></h2>
<span class="Li"></span>
<pre>
    ### ask a user (with an open question) for their favourite colour
    $reply = $term-&gt;get_reply( prompt =&gt; 'Your favourite colour? );
</pre>
<p class="Pp">which would look like:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    Your favourite colour?
</pre>
<p class="Pp">and <span class="Li">$reply</span> would hold the text the user
    typed.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="get_reply_with_choices"><a class="permalink" href="#get_reply_with_choices">get_reply
  with choices</a></h2>
<span class="Li"></span>
<pre>
    ### now provide a list of choices, so the user has to pick one
    $reply = $term-&gt;get_reply(
                prompt  =&gt; 'Your favourite colour?',
                choices =&gt; [qw|red green blue|] );
</pre>
<p class="Pp">which would look like:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
      1&gt; red
      2&gt; green
      3&gt; blue

    Your favourite colour?
</pre>
<p class="Pp"><span class="Li">$reply</span> will hold one of the choices
    presented. <span class="Li">&quot;Term::UI&quot;</span> will repose the
    question if the user attempts to enter an answer that's not in the list of
    choices. The string presented is held in the
    <span class="Li">$Term::UI::INVALID</span> variable (see the
    <span class="Li">&quot;GLOBAL VARIABLES&quot;</span> section for
  details.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="get_reply_with_choices_and_default"><a class="permalink" href="#get_reply_with_choices_and_default">get_reply
  with choices and default</a></h2>
<span class="Li"></span>
<pre>
    ### provide a sensible default option -- everyone loves blue!
    $reply = $term-&gt;get_reply(
                prompt  =&gt; 'Your favourite colour?',
                choices =&gt; [qw|red green blue|],
                default =&gt; 'blue' );
</pre>
<p class="Pp">which would look like:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
      1&gt; red
      2&gt; green
      3&gt; blue

    Your favourite colour? [3]:
</pre>
<p class="Pp">Note the default answer after the prompt. A user can now just hit
    <span class="Li">&quot;enter&quot;</span> (or set
    <span class="Li">$Term::UI::AUTOREPLY</span> -- see the
    <span class="Li">&quot;GLOBAL VARIABLES&quot;</span> section) and the
    sensible answer 'blue' will be returned.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="get_reply_using_print_me_&amp;_multi"><a class="permalink" href="#get_reply_using_print_me_&amp;_multi">get_reply
  using print_me &amp; multi</a></h2>
<span class="Li"></span>
<pre>
    ### allow the user to pick more than one colour and add an
    ### introduction text
    @reply = $term-&gt;get_reply(
                print_me    =&gt; 'Tell us what colours you like',
                prompt      =&gt; 'Your favourite colours?',
                choices     =&gt; [qw|red green blue|],
                multi       =&gt; 1 );
</pre>
<p class="Pp">which would look like:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    Tell us what colours you like
      1&gt; red
      2&gt; green
      3&gt; blue

    Your favourite colours?
</pre>
<p class="Pp">An answer of <span class="Li">&quot;3 2 1&quot;</span> would fill
    <span class="Li">@reply</span> with <span class="Li">&quot;blue green
    red&quot;</span></p>
</section>
<section class="Ss">
<h2 class="Ss" id="get_reply_&amp;_allow"><a class="permalink" href="#get_reply_&amp;_allow">get_reply
  &amp; allow</a></h2>
<span class="Li"></span>
<pre>
    ### pose an open question, but do a custom verification on
    ### the answer, which will only exit the question loop, if
    ### the answer matches the allow handler.
    $reply = $term-&gt;get_reply(
                prompt  =&gt; &quot;What is the magic number?&quot;,
                allow   =&gt; 42 );
</pre>
<p class="Pp">Unless the user now enters <span class="Li">42</span>, the
    question will be reposed over and over again. You can use more sophisticated
    <span class="Li">&quot;allow&quot;</span> handlers (even subroutines can be
    used). The <span class="Li">&quot;allow&quot;</span> handler is implemented
    using <span class="Li">&quot;Params::Check&quot;</span>'s
    <span class="Li">&quot;allow&quot;</span> function. Check its manpage for
    details.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="an_elaborate_ask_yn_sample"><a class="permalink" href="#an_elaborate_ask_yn_sample">an
  elaborate ask_yn sample</a></h2>
<span class="Li"></span>
<pre>
    ### ask a user if he likes cookies. Default to a sensible 'yes'
    ### and inform him first what cookies are.
    $bool = $term-&gt;ask_yn( prompt   =&gt; 'Do you like cookies?',
                           default  =&gt; 'y',
                           print_me =&gt; 'Cookies are LOVELY!!!' );
</pre>
<p class="Pp">would print:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    Cookies are LOVELY!!!
    Do you like cookies? [Y/n]:
</pre>
<p class="Pp">If a user then simply hits
    <span class="Li">&quot;enter&quot;</span>, agreeing with the default,
    <span class="Li">$bool</span> would be set to
    <span class="Li">&quot;true&quot;</span>. (Simply hitting 'y' would also
    return <span class="Li">&quot;true&quot;</span>. Hitting 'n' would return
    <span class="Li">&quot;false&quot;</span>)</p>
<p class="Pp">We could later retrieve this interaction by printing out the
    Q&amp;A history as follows:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    print $term-&gt;history_as_string;
</pre>
<p class="Pp">which would then print:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    Cookies are LOVELY!!!
    Do you like cookies? [Y/n]:  y
</pre>
<p class="Pp">There's a chance we're doing this non-interactively, because a
    console is missing, the user indicated he just wanted the defaults, etc.</p>
<p class="Pp">In this case, simply setting
    <span class="Li">$Term::UI::AUTOREPLY</span> to true, will return from every
    question with the default answer set for the question. Do note that if
    <span class="Li">&quot;AUTOREPLY&quot;</span> is true, and no default is
    set, <span class="Li">&quot;Term::UI&quot;</span> will warn about this and
    return <span class="Li">&quot;undef&quot;</span>.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="See_Also"><a class="permalink" href="#See_Also">See
  Also</a></h1>
<span class="Li">&quot;Params::Check&quot;</span>,
  <span class="Li">&quot;Term::ReadLine&quot;</span>,
  <span class="Li">&quot;Term::UI::History&quot;</span>
</section>
<section class="Sh">
<h1 class="Sh" id="BUG_REPORTS"><a class="permalink" href="#BUG_REPORTS">BUG
  REPORTS</a></h1>
Please report bugs or other issues to &lt;bug-term-ui@rt.cpan.org&lt;gt&gt;.
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
This module by Jos Boumans &lt;kane@cpan.org&gt;.
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT"><a class="permalink" href="#COPYRIGHT">COPYRIGHT</a></h1>
This library is free software; you may redistribute and/or modify it under the
  same terms as Perl itself.
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2014-09-30</td>
    <td class="foot-os">perl v5.18.4</td>
  </tr>
</table>
</body>
</html>
