<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   generated by cd2nroff 0.1 from CURLOPT_HEADERFUNCTION.md
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    .Nd, .Bf, .Op { display: inline; }
    .Pa, .Ad { font-style: italic; }
    .Ms { font-weight: bold; }
    .Bl-diag > dt { font-weight: bold; }
    code.Nm, .Fl, .Cm, .Ic, code.In, .Fd, .Fn, .Cd { font-weight: bold;
      font-family: inherit; }
  </style>
  <title>CURLOPT_HEADERFUNCTION(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">CURLOPT_HEADERFUNCTION(3)</td>
    <td class="head-vol">Library Functions Manual</td>
    <td class="head-rtitle">CURLOPT_HEADERFUNCTION(3)</td>
  </tr>
</table>
<div class="manual-text">
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">CURLOPT_HEADERFUNCTION - callback that receives header data</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>#include &lt;curl/curl.h&gt;
size_t header_callback(char *buffer,
<br/>
                       size_t size,
<br/>
                       size_t nitems,
<br/>
                       void *userdata);
CURLcode curl_easy_setopt(CURL *handle, CURLOPT_HEADERFUNCTION,
<br/>
                          header_callback);</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">Pass a pointer to your callback function, which should match the
    prototype shown above.</p>
<p class="Pp">This callback function gets invoked by libcurl as soon as it has
    received header data. The header callback is called once for each header and
    only complete header lines are passed on to the callback. Parsing headers is
    easy to do using this callback. <i>buffer</i> points to the delivered data,
    and the size of that data is <i>nitems</i>; <i>size</i> is always 1. The
    provide header line is not null-terminated!</p>
<p class="Pp">The pointer named <i>userdata</i> is the one you set with the
    <i>CURLOPT_HEADERDATA(3)</i> option.</p>
<p class="Pp">Your callback should return the number of bytes actually taken
    care of. If that amount differs from the amount passed to your callback
    function, it signals an error condition to the library. This causes the
    transfer to get aborted and the libcurl function used returns
    <i>CURLE_WRITE_ERROR</i>.</p>
<p class="Pp">You can also abort the transfer by returning CURL_WRITEFUNC_ERROR.
    (7.87.0)</p>
<p class="Pp">A complete HTTP header that is passed to this function can be up
    to <i>CURL_MAX_HTTP_HEADER</i> (100K) bytes and includes the final line
    terminator.</p>
<p class="Pp">If this option is not set, or if it is set to NULL, but
    <i>CURLOPT_HEADERDATA(3)</i> is set to anything but NULL, the function used
    to accept response data is used instead. That is the function specified with
    <i>CURLOPT_WRITEFUNCTION(3)</i>, or if it is not specified or NULL - the
    default, stream-writing function.</p>
<p class="Pp">It is important to note that the callback is invoked for the
    headers of all responses received after initiating a request and not just
    the final response. This includes all responses which occur during
    authentication negotiation. If you need to operate on only the headers from
    the final response, you need to collect headers in the callback yourself and
    use HTTP status lines, for example, to delimit response boundaries.</p>
<p class="Pp">For an HTTP transfer, the status line and the blank line preceding
    the response body are both included as headers and passed to this
  function.</p>
<p class="Pp">When a server sends a chunked encoded transfer, it may contain a
    trailer. That trailer is identical to an HTTP header and if such a trailer
    is received it is passed to the application using this callback as well.
    There are several ways to detect it being a trailer and not an ordinary
    header: 1) it comes after the response-body. 2) it comes after the final
    header line (CR LF) 3) a Trailer: header among the regular response-headers
    mention what header(s) to expect in the trailer.</p>
<p class="Pp">For non-HTTP protocols like FTP, POP3, IMAP and SMTP this function
    gets called with the server responses to the commands that libcurl
  sends.</p>
<p class="Pp">A more convenient way to get HTTP headers might be to use
    <i>curl_easy_header(3)</i>.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="LIMITATIONS"><a class="permalink" href="#LIMITATIONS">LIMITATIONS</a></h1>
<p class="Pp">libcurl does not unfold HTTP &quot;folded headers&quot;
    (deprecated since RFC 7230). A folded header is a header that continues on a
    subsequent line and starts with a whitespace. Such folds are passed to the
    header callback as separate ones, although strictly they are just
    continuations of the previous lines.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DEFAULT"><a class="permalink" href="#DEFAULT">DEFAULT</a></h1>
<p class="Pp">Nothing.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="PROTOCOLS"><a class="permalink" href="#PROTOCOLS">PROTOCOLS</a></h1>
<p class="Pp">Used for all protocols with headers or meta-data concept: HTTP,
    FTP, POP3, IMAP, SMTP and more.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="EXAMPLE"><a class="permalink" href="#EXAMPLE">EXAMPLE</a></h1>
<pre>static size_t header_callback(char *buffer, size_t size,
<br/>
                              size_t nitems, void *userdata)
{
<br/>
  /* received header is nitems * size long in 'buffer' NOT ZERO TERMINATED */
<br/>
  /* 'userdata' is set with CURLOPT_HEADERDATA */
<br/>
  return nitems * size;
}
int main(void)
{
<br/>
  CURL *curl = curl_easy_init();
<br/>
  if(curl) {
<br/>
    curl_easy_setopt(curl, CURLOPT_URL, &quot;https://example.com&quot;);
<br/>
    curl_easy_setopt(curl, CURLOPT_HEADERFUNCTION, header_callback);
<br/>
    curl_easy_perform(curl);
<br/>
  }
}</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="AVAILABILITY"><a class="permalink" href="#AVAILABILITY">AVAILABILITY</a></h1>
<p class="Pp">Always</p>
</section>
<section class="Sh">
<h1 class="Sh" id="RETURN_VALUE"><a class="permalink" href="#RETURN_VALUE">RETURN
  VALUE</a></h1>
<p class="Pp">Returns CURLE_OK</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp"><b>CURLOPT_HEADERDATA</b>(3), <b>CURLOPT_WRITEFUNCTION</b>(3),
    <b>curl_easy_header</b>(3)</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">March 12 2024</td>
    <td class="foot-os">libcurl</td>
  </tr>
</table>
</body>
</html>
