<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    .Nd, .Bf, .Op { display: inline; }
    .Pa, .Ad { font-style: italic; }
    .Ms { font-weight: bold; }
    .Bl-diag > dt { font-weight: bold; }
    code.Nm, .Fl, .Cm, .Ic, code.In, .Fd, .Fn, .Cd { font-weight: bold;
      font-family: inherit; }
  </style>
  <title>IPC::Run3(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">IPC::Run3(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">IPC::Run3(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">IPC::Run3 - run a subprocess with input/ouput redirection</p>
</section>
<section class="Sh">
<h1 class="Sh" id="VERSION"><a class="permalink" href="#VERSION">VERSION</a></h1>
<p class="Pp">version 0.048</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>    use IPC::Run3;    # Exports run3() by default
    run3 \@cmd, \$in, \$out, \$err;
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">This module allows you to run a subprocess and redirect stdin,
    stdout, and/or stderr to files and perl data structures. It aims to satisfy
    99% of the need for using <span class="Li">&quot;system&quot;</span>,
    <span class="Li">&quot;qx&quot;</span>, and
    <span class="Li">&quot;open3&quot;</span> with a simple, extremely Perlish
    API.</p>
<p class="Pp">Speed, simplicity, and portability are paramount. (That's speed of
    Perl code; which is often much slower than the kind of buffered I/O that
    this module uses to spool input to and output from the child command.)</p>
<section class="Ss">
<h2 class="Ss" id="_run3($cmd,_$stdin,_$stdout,_$stderr,_"><a class="permalink" href="#_run3($cmd,_$stdin,_$stdout,_$stderr,_">&quot;run3($cmd,
  $stdin, $stdout, $stderr, \%options)&quot;</a></h2>
<p class="Pp">All parameters after <span class="Li">$cmd</span> are
  optional.</p>
<p class="Pp">The parameters <span class="Li">$stdin</span>,
    <span class="Li">$stdout</span> and <span class="Li">$stderr</span> indicate
    how the child's corresponding filehandle
    (<span class="Li">&quot;STDIN&quot;</span>,
    <span class="Li">&quot;STDOUT&quot;</span> and
    <span class="Li">&quot;STDERR&quot;</span>, resp.) will be redirected.
    Because the redirects come last, this allows
    <span class="Li">&quot;STDOUT&quot;</span> and
    <span class="Li">&quot;STDERR&quot;</span> to default to the parent's by
    just not specifying them -- a common use case.</p>
<p class="Pp"><span class="Li">&quot;run3&quot;</span> throws an exception if
    the wrapped <span class="Li">&quot;system&quot;</span> call returned -1 or
    anything went wrong with <span class="Li">&quot;run3&quot;</span>'s
    processing of filehandles. Otherwise it returns true. It leaves
    <span class="Li">$?</span> intact for inspection of exit and wait
  status.</p>
<p class="Pp">Note that a true return value from
    <span class="Li">&quot;run3&quot;</span> doesn't mean that the command had a
    successful exit code. Hence you should always check
    <span class="Li">$?</span>.</p>
<p class="Pp">See &quot;%options&quot; for an option to handle the case of
    <span class="Li">&quot;system&quot;</span> returning -1 yourself.</p>
<p class="Pp"><i></i><span class="Li"><i>$cmd</i></span><i></i></p>
<p class="Pp">Usually <span class="Li">$cmd</span> will be an ARRAY reference
    and the child is invoked via</p>
<p class="Pp"></p>
<pre>  system @$cmd;
</pre>
<p class="Pp">But <span class="Li">$cmd</span> may also be a string in which
    case the child is invoked via</p>
<p class="Pp"></p>
<pre>  system $cmd;
</pre>
<p class="Pp">(cf. &quot;system&quot; in perlfunc for the difference and the
    pitfalls of using the latter form).</p>
<p class="Pp"><i></i><span class="Li"><i>$stdin</i></span><i>,
    </i><span class="Li"><i>$stdout</i></span><i>,
    </i><span class="Li"><i>$stderr</i></span><i></i></p>
<p class="Pp">The parameters <span class="Li">$stdin</span>,
    <span class="Li">$stdout</span> and <span class="Li">$stderr</span> can take
    one of the following forms:</p>
<dl class="Bl-tag">
  <dt>&quot;undef&quot; (or not specified at all)</dt>
  <dd>The child inherits the corresponding filehandle from the parent.
    <p class="Pp"></p>
    <pre>  run3 \@cmd, $stdin;                   # child writes to same STDOUT and STDERR as parent
  run3 \@cmd, undef, $stdout, $stderr;  # child reads from same STDIN as parent
    </pre>
  </dd>
  <dt>&quot;\undef&quot;</dt>
  <dd>The child's filehandle is redirected from or to the local equivalent of
      <span class="Li">&quot;/dev/null&quot;</span> (as returned by
      <span class="Li">&quot;File::Spec-&gt;devnull()&quot;</span>).
    <p class="Pp"></p>
    <pre>  run3 \@cmd, \undef, $stdout, $stderr; # child reads from /dev/null
    </pre>
  </dd>
  <dt id="a"><a class="permalink" href="#a">a simple scalar</a></dt>
  <dd>The parameter is taken to be the name of a file to read from or write to.
      In the latter case, the file will be opened via
    <p class="Pp"></p>
    <pre>  open FH, &quot;&gt;&quot;, ...
    </pre>
    <p class="Pp">i.e. it is created if it doesn't exist and truncated
        otherwise. Note that the file is opened by the parent which will croak
        in case of failure.</p>
    <p class="Pp"></p>
    <pre>  run3 \@cmd, \undef, &quot;out.txt&quot;;        # child writes to file &quot;out.txt&quot;
    </pre>
  </dd>
  <dt id="a~2"><a class="permalink" href="#a~2">a filehandle (either a reference
    to a GLOB or an &quot;IO::Handle&quot;)</a></dt>
  <dd>The filehandle is inherited by the child.
    <p class="Pp"></p>
    <pre>  open my $fh, &quot;&gt;&quot;, &quot;out.txt&quot;;
  print $fh &quot;prologue\n&quot;;
  ...
  run3 \@cmd, \undef, $fh;              # child writes to $fh
  ...
  print $fh &quot;epilogue\n&quot;;
  close $fh;
    </pre>
  </dd>
  <dt id="a~3"><a class="permalink" href="#a~3">a SCALAR reference</a></dt>
  <dd>The referenced scalar is treated as a string to be read from or written
      to. In the latter case, the previous content of the string is overwritten.
    <p class="Pp"></p>
    <pre>  my $out;
  run3 \@cmd, \undef, \$out;           # child writes into string
  run3 \@cmd, \&lt;&lt;EOF;                  # child reads from string (can use &quot;here&quot; notation)
  Input
  to
  child
  EOF
    </pre>
  </dd>
  <dt id="an"><a class="permalink" href="#an">an ARRAY reference</a></dt>
  <dd>For <span class="Li">$stdin</span>, the elements of
      <span class="Li">@$stdin</span> are simply spooled to the child.
    <p class="Pp">For <span class="Li">$stdout</span> or
        <span class="Li">$stderr</span>, the child's corresponding file
        descriptor is read line by line (as determined by the current setting of
        <span class="Li">$/</span>) into <span class="Li">@$stdout</span> or
        <span class="Li">@$stderr</span>, resp. The previous content of the
        array is overwritten.</p>
    <p class="Pp"></p>
    <pre>  my @lines;
  run3 \@cmd, \undef, \@lines;         # child writes into array
    </pre>
  </dd>
  <dt id="a~4"><a class="permalink" href="#a~4">a CODE reference</a></dt>
  <dd>For <span class="Li">$stdin</span>, <span class="Li">&amp;$stdin</span>
      will be called repeatedly (with no arguments) and the return values are
      spooled to the child. <span class="Li">&amp;$stdin</span> must signal the
      end of input by returning <span class="Li">&quot;undef&quot;</span>.
    <p class="Pp">For <span class="Li">$stdout</span> or
        <span class="Li">$stderr</span>, the child's corresponding file
        descriptor is read line by line (as determined by the current setting of
        <span class="Li">$/</span>) and <span class="Li">&amp;$stdout</span> or
        <span class="Li">&amp;$stderr</span>, resp., is called with the contents
        of the line. Note that there's no end-of-file indication.</p>
    <p class="Pp"></p>
    <pre>  my $i = 0;
  sub producer {
    return $i &lt; 10 ? &quot;line&quot;.$i++.&quot;\n&quot; : undef;
  }
  run3 \@cmd, \&amp;producer;              # child reads 10 lines
    </pre>
    <p class="Pp">Note that this form of redirecting the child's I/O doesn't
        imply any form of concurrency between parent and child - <b>run3()</b>'s
        method of operation is the same no matter which form of redirection you
        specify.</p>
  </dd>
</dl>
<p class="Pp">If the same value is passed for <span class="Li">$stdout</span>
    and <span class="Li">$stderr</span>, then the child will write both
    <span class="Li">&quot;STDOUT&quot;</span> and
    <span class="Li">&quot;STDERR&quot;</span> to the same filehandle. In
    general, this means that</p>
<p class="Pp"></p>
<pre>    run3 \@cmd, \undef, &quot;foo.txt&quot;, &quot;foo.txt&quot;;
    run3 \@cmd, \undef, \$both, \$both;
</pre>
<p class="Pp">will DWIM and pass a single file handle to the child for both
    <span class="Li">&quot;STDOUT&quot;</span> and
    <span class="Li">&quot;STDERR&quot;</span>, collecting all into file
    &quot;foo.txt&quot; or <span class="Li">$both</span>.</p>
<p class="Pp"><i></i><span class="Li"><i>&quot;\%options&quot;</i></span><i></i></p>
<p class="Pp">The last parameter, <span class="Li">&quot;\%options&quot;</span>,
    must be a hash reference if present.</p>
<p class="Pp">Currently the following keys are supported:</p>
<dl class="Bl-tag">
  <dt>&quot;binmode_stdin&quot;, &quot;binmode_stdout&quot;,
    &quot;binmode_stderr&quot;</dt>
  <dd>The value must a &quot;layer&quot; as described in &quot;binmode&quot; in
      perlfunc. If specified the corresponding parameter
      <span class="Li">$stdin</span>, <span class="Li">$stdout</span> or
      <span class="Li">$stderr</span>, resp., operates with the given layer.
    <p class="Pp">For backward compatibility, a true value that doesn't start
        with &quot;:&quot; (e.g. a number) is interpreted as &quot;:raw&quot;.
        If the value is false or not specified, the default is &quot;:crlf&quot;
        on Windows and &quot;:raw&quot; otherwise.</p>
    <p class="Pp">Don't expect that values other than the built-in layers
        &quot;:raw&quot;, &quot;:crlf&quot;, and (on newer Perls)
        &quot;:bytes&quot;, &quot;:utf8&quot;, &quot;:encoding(...)&quot; will
        work.</p>
  </dd>
  <dt>&quot;append_stdout&quot;, &quot;append_stderr&quot;</dt>
  <dd>If their value is true then the corresponding parameter
      <span class="Li">$stdout</span> or <span class="Li">$stderr</span>, resp.,
      will append the child's output to the existing &quot;contents&quot; of the
      redirector. This only makes sense if the redirector is a simple scalar
      (the corresponding file is opened in append mode), a SCALAR reference (the
      output is appended to the previous contents of the string) or an ARRAY
      reference (the output is <span class="Li">&quot;push&quot;</span>ed onto
      the previous contents of the array).</dd>
  <dt>&quot;return_if_system_error&quot;</dt>
  <dd>If this is true <span class="Li">&quot;run3&quot;</span> does <b>not</b>
      throw an exception if <span class="Li">&quot;system&quot;</span> returns
      -1 (cf. &quot;system&quot; in perlfunc for possible failure scenarios.),
      but returns true instead. In this case <span class="Li">$?</span> has the
      value -1 and <span class="Li">$!</span> contains the errno of the failing
      <span class="Li">&quot;system&quot;</span> call.</dd>
</dl>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="HOW_IT_WORKS"><a class="permalink" href="#HOW_IT_WORKS">HOW
  IT WORKS</a></h1>
<dl class="Bl-tag">
  <dt>(1)</dt>
  <dd>For each redirector <span class="Li">$stdin</span>,
      <span class="Li">$stdout</span>, and <span class="Li">$stderr</span>,
      <span class="Li">&quot;run3()&quot;</span> furnishes a filehandle:</dd>
</dl>
<div class="Bd-indent">
<ul class="Bl-bullet">
  <li>if the redirector already specifies a filehandle it just uses that</li>
  <li>if the redirector specifies a filename,
      <span class="Li">&quot;run3()&quot;</span> opens the file in the
      appropriate mode</li>
  <li>in all other cases, <span class="Li">&quot;run3()&quot;</span> opens a
      temporary file (using tempfile)</li>
</ul>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>(2)</dt>
  <dd>If <span class="Li">&quot;run3()&quot;</span> opened a temporary file for
      <span class="Li">$stdin</span> in step (1), it writes the data using the
      specified method (either from a string, an array or returned by a
      function) to the temporary file and rewinds it.</dd>
  <dt>(3)</dt>
  <dd><span class="Li">&quot;run3()&quot;</span> saves the parent's
      <span class="Li">&quot;STDIN&quot;</span>,
      <span class="Li">&quot;STDOUT&quot;</span> and
      <span class="Li">&quot;STDERR&quot;</span> by duplicating them to new
      filehandles. It duplicates the filehandles from step (1) to
      <span class="Li">&quot;STDIN&quot;</span>,
      <span class="Li">&quot;STDOUT&quot;</span> and
      <span class="Li">&quot;STDERR&quot;</span>, resp.</dd>
  <dt>(4)</dt>
  <dd><span class="Li">&quot;run3()&quot;</span> runs the child by invoking
      system with <span class="Li">$cmd</span> as specified above.</dd>
  <dt>(5)</dt>
  <dd><span class="Li">&quot;run3()&quot;</span> restores the parent's
      <span class="Li">&quot;STDIN&quot;</span>,
      <span class="Li">&quot;STDOUT&quot;</span> and
      <span class="Li">&quot;STDERR&quot;</span> saved in step (3).</dd>
  <dt>(6)</dt>
  <dd>If <span class="Li">&quot;run3()&quot;</span> opened a temporary file for
      <span class="Li">$stdout</span> or <span class="Li">$stderr</span> in step
      (1), it rewinds it and reads back its contents using the specified method
      (either to a string, an array or by calling a function).</dd>
  <dt>(7)</dt>
  <dd><span class="Li">&quot;run3()&quot;</span> closes all filehandles that it
      opened explicitly in step (1).</dd>
</dl>
<p class="Pp">Note that when using temporary files,
    <span class="Li">&quot;run3()&quot;</span> tries to amortize the overhead by
    reusing them (i.e. it keeps them open and rewinds and truncates them before
    the next operation).</p>
</section>
<section class="Sh">
<h1 class="Sh" id="LIMITATIONS"><a class="permalink" href="#LIMITATIONS">LIMITATIONS</a></h1>
<p class="Pp">Often uses intermediate files (determined by File::Temp, and thus
    by the File::Spec defaults and the TMPDIR env. variable) for speed,
    portability and simplicity.</p>
<p class="Pp">Use extreme caution when using
    <span class="Li">&quot;run3&quot;</span> in a threaded environment if
    concurrent calls of <span class="Li">&quot;run3&quot;</span> are possible.
    Most likely, I/O from different invocations will get mixed up. The reason is
    that in most thread implementations all threads in a process share the same
    STDIN/STDOUT/STDERR. Known failures are Perl ithreads on Linux and Win32.
    Note that <span class="Li">&quot;fork&quot;</span> on Win32 is emulated via
    Win32 threads and hence I/O mix up is possible between forked children here
    (<span class="Li">&quot;run3&quot;</span> is &quot;fork safe&quot; on Unix,
    though).</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DEBUGGING"><a class="permalink" href="#DEBUGGING">DEBUGGING</a></h1>
<p class="Pp">To enable debugging use the IPCRUN3DEBUG environment variable to a
    non-zero integer value:</p>
<p class="Pp"></p>
<pre>  $ IPCRUN3DEBUG=1 myapp
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="PROFILING"><a class="permalink" href="#PROFILING">PROFILING</a></h1>
<p class="Pp">To enable profiling, set IPCRUN3PROFILE to a number to enable
    emitting profile information to STDERR (1 to get timestamps, 2 to get a
    summary report at the END of the program, 3 to get mini reports after each
    run) or to a filename to emit raw data to a file for later analysis.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COMPARISON"><a class="permalink" href="#COMPARISON">COMPARISON</a></h1>
<p class="Pp">Here's how it stacks up to existing APIs:</p>
<section class="Ss">
<h2 class="Ss" id="compared_to__system()_,__qx"><a class="permalink" href="#compared_to__system()_,__qx">compared
  to &quot;system()&quot;, &quot;qx''&quot;, &quot;open &quot;...|&quot;&quot;,
  &quot;open &quot;|...&quot;&quot;</a></h2>
<ul class="Bl-bullet">
  <li>better: redirects more than one file descriptor</li>
  <li>better: returns TRUE on success, FALSE on failure</li>
  <li>better: throws an error if problems occur in the parent process (or the
      pre-exec child)</li>
  <li>better: allows a very perlish interface to Perl data structures and
      subroutines</li>
  <li>better: allows 1 word invocations to avoid the shell easily:
    <p class="Pp"></p>
    <pre> run3 [&quot;foo&quot;];  # does not invoke shell
    </pre>
  </li>
  <li>worse: does not return the exit code, leaves it in $?</li>
</ul>
</section>
<section class="Ss">
<h2 class="Ss" id="compared_to__open2()_,__open3()_"><a class="permalink" href="#compared_to__open2()_,__open3()_">compared
  to &quot;open2()&quot;, &quot;open3()&quot;</a></h2>
<ul class="Bl-bullet">
  <li>better: no lengthy, error prone polling/select loop needed</li>
  <li>better: hides OS dependencies</li>
  <li>better: allows SCALAR, ARRAY, and CODE references to source and sink
    I/O</li>
  <li>better: I/O parameter order is like
      <span class="Li">&quot;open3()&quot;</span> (not like
      <span class="Li">&quot;open2()&quot;</span>).</li>
  <li>worse: does not allow interaction with the subprocess</li>
</ul>
</section>
<section class="Ss">
<h2 class="Ss" id="compared_to_"><a class="permalink" href="#compared_to_">compared
  to <b>IPC::Run::run()</b></a></h2>
<ul class="Bl-bullet">
  <li>better: smaller, lower overhead, simpler, more portable</li>
  <li>better: no <b>select()</b> loop portability issues</li>
  <li>better: does not fall prey to Perl closure leaks</li>
  <li>worse: does not allow interaction with the subprocess (which
      <b>IPC::Run::run()</b> allows by redirecting subroutines)</li>
  <li>worse: lacks many features of
      <span class="Li">&quot;IPC::Run::run()&quot;</span> (filters, pipes,
      redirects, pty support)</li>
</ul>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT"><a class="permalink" href="#COPYRIGHT">COPYRIGHT</a></h1>
<p class="Pp">Copyright 2003, R. Barrie Slaymaker, Jr., All Rights Reserved</p>
</section>
<section class="Sh">
<h1 class="Sh" id="LICENSE"><a class="permalink" href="#LICENSE">LICENSE</a></h1>
<p class="Pp">You may use this module under the terms of the BSD, Artistic, or
    GPL licenses, any version.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">Barrie Slaymaker
    &lt;<span class="Li">&quot;barries@slaysys.com&quot;</span>&gt;</p>
<p class="Pp">Ricardo SIGNES
    &lt;<span class="Li">&quot;rjbs@cpan.org&quot;</span>&gt; performed routine
    maintenance since 2010, thanks to help from the following ticket and/or
    patch submitters: Jody Belka, Roderich Schupp, David Morel, Jeff Lavallee,
    and anonymous others.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2014-03-29</td>
    <td class="foot-os">perl v5.34.0</td>
  </tr>
</table>
</body>
</html>
