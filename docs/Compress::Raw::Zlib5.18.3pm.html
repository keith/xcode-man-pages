<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>Compress::Raw::Zlib(3pm)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Compress::Raw::Zlib(3pm)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">Compress::Raw::Zlib(3pm)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
Compress::Raw::Zlib - Low-Level Interface to zlib compression library
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<span class="Li"></span>
<pre>
    use Compress::Raw::Zlib ;

    ($d, $status) = new Compress::Raw::Zlib::Deflate( [OPT] ) ;
    $status = $d-&gt;deflate($input, $output) ;
    $status = $d-&gt;flush($output [, $flush_type]) ;
    $d-&gt;deflateReset() ;
    $d-&gt;deflateParams(OPTS) ;
    $d-&gt;deflateTune(OPTS) ;
    $d-&gt;dict_adler() ;
    $d-&gt;crc32() ;
    $d-&gt;adler32() ;
    $d-&gt;total_in() ;
    $d-&gt;total_out() ;
    $d-&gt;msg() ;
    $d-&gt;get_Strategy();
    $d-&gt;get_Level();
    $d-&gt;get_BufSize();

    ($i, $status) = new Compress::Raw::Zlib::Inflate( [OPT] ) ;
    $status = $i-&gt;inflate($input, $output [, $eof]) ;
    $status = $i-&gt;inflateSync($input) ;
    $i-&gt;inflateReset() ;
    $i-&gt;dict_adler() ;
    $d-&gt;crc32() ;
    $d-&gt;adler32() ;
    $i-&gt;total_in() ;
    $i-&gt;total_out() ;
    $i-&gt;msg() ;
    $d-&gt;get_BufSize();

    $crc = adler32($buffer [,$crc]) ;
    $crc = crc32($buffer [,$crc]) ;

    $crc = adler32_combine($crc1, $crc2, $len2)l
    $crc = crc32_combine($adler1, $adler2, $len2)

    my $version = Compress::Raw::Zlib::zlib_version();
    my $flags = Compress::Raw::Zlib::zlibCompileFlags();
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
The <i>Compress::Raw::Zlib</i> module provides a Perl interface to the
  <i>zlib</i> compression library (see &quot;AUTHOR&quot; for details about
  where to get <i>zlib</i>).
</section>
<section class="Sh">
<h1 class="Sh" id="Compress::Raw::Zlib::Deflate"><a class="permalink" href="#Compress::Raw::Zlib::Deflate">Compress::Raw::Zlib::Deflate</a></h1>
This section defines an interface that allows in-memory compression using the
  <i>deflate</i> interface provided by zlib.
<p class="Pp">Here is a definition of the interface available:</p>
<section class="Ss">
<h2 class="Ss" id="_fB($d,__fP_fB$status_fP_fB)_=_new_Compress::Raw::Zlib::Deflate(___s-1OPT_s0__)__fP"><a class="permalink" href="#_fB($d,__fP_fB$status_fP_fB)_=_new_Compress::Raw::Zlib::Deflate(___s-1OPT_s0__)__fP"><b>($d,
  </b><b>$status</b><b>) = new Compress::Raw::Zlib::Deflate( [OPT] )
  </b></a></h2>
Initialises a deflation object.
<p class="Pp">If you are familiar with the <i>zlib</i> library, it combines the
    features of the <i>zlib</i> functions
    <span class="Li">&quot;deflateInit&quot;</span>,
    <span class="Li">&quot;deflateInit2&quot;</span> and
    <span class="Li">&quot;deflateSetDictionary&quot;</span>.</p>
<p class="Pp">If successful, it will return the initialised deflation object,
    <span class="Li">$d</span> and a <span class="Li">$status</span> of
    <span class="Li">&quot;Z_OK&quot;</span> in a list context. In scalar
    context it returns the deflation object, <span class="Li">$d</span>,
  only.</p>
<p class="Pp">If not successful, the returned deflation object,
    <span class="Li">$d</span>, will be <i>undef</i> and
    <span class="Li">$status</span> will hold the a <i>zlib</i> error code.</p>
<p class="Pp">The function optionally takes a number of named options specified
    as <span class="Li">&quot;Name =&gt; value&quot;</span> pairs. This allows
    individual options to be tailored without having to specify them all in the
    parameter list.</p>
<p class="Pp">For backward compatibility, it is also possible to pass the
    parameters as a reference to a hash containing the name=&gt;value pairs.</p>
<p class="Pp">Below is a list of the valid options:</p>
<dl class="Bl-tag">
  <dt><b>-Level</b></dt>
  <dd>Defines the compression level. Valid values are 0 through 9,
      <span class="Li">&quot;Z_NO_COMPRESSION&quot;</span>,
      <span class="Li">&quot;Z_BEST_SPEED&quot;</span>,
      <span class="Li">&quot;Z_BEST_COMPRESSION&quot;</span>, and
      <span class="Li">&quot;Z_DEFAULT_COMPRESSION&quot;</span>.
    <p class="Pp">The default is
        <span class="Li">&quot;Z_DEFAULT_COMPRESSION&quot;</span>.</p>
  </dd>
  <dt><b>-Method</b></dt>
  <dd>Defines the compression method. The only valid value at present (and the
      default) is <span class="Li">&quot;Z_DEFLATED&quot;</span>.</dd>
  <dt><b>-WindowBits</b></dt>
  <dd>To compress an RFC 1950 data stream, set
      <span class="Li">&quot;WindowBits&quot;</span> to a positive number
      between 8 and 15.
    <p class="Pp">To compress an RFC 1951 data stream, set
        <span class="Li">&quot;WindowBits&quot;</span> to
        <span class="Li">&quot;-MAX_WBITS&quot;</span>.</p>
    <p class="Pp">To compress an RFC 1952 data stream (i.e. gzip), set
        <span class="Li">&quot;WindowBits&quot;</span> to
        <span class="Li">&quot;WANT_GZIP&quot;</span>.</p>
    <p class="Pp">For a definition of the meaning and valid values for
        <span class="Li">&quot;WindowBits&quot;</span> refer to the <i>zlib</i>
        documentation for <i>deflateInit2</i>.</p>
    <p class="Pp">Defaults to <span class="Li">&quot;MAX_WBITS&quot;</span>.</p>
  </dd>
  <dt><b>-MemLevel</b></dt>
  <dd>For a definition of the meaning and valid values for
      <span class="Li">&quot;MemLevel&quot;</span> refer to the <i>zlib</i>
      documentation for <i>deflateInit2</i>.
    <p class="Pp">Defaults to MAX_MEM_LEVEL.</p>
  </dd>
  <dt><b>-Strategy</b></dt>
  <dd>Defines the strategy used to tune the compression. The valid values are
      <span class="Li">&quot;Z_DEFAULT_STRATEGY&quot;</span>,
      <span class="Li">&quot;Z_FILTERED&quot;</span>,
      <span class="Li">&quot;Z_RLE&quot;</span>,
      <span class="Li">&quot;Z_FIXED&quot;</span> and
      <span class="Li">&quot;Z_HUFFMAN_ONLY&quot;</span>.
    <p class="Pp">The default is
        <span class="Li">&quot;Z_DEFAULT_STRATEGY&quot;</span>.</p>
  </dd>
  <dt><b>-Dictionary</b></dt>
  <dd>When a dictionary is specified <i>Compress::Raw::Zlib</i> will
      automatically call
      <span class="Li">&quot;deflateSetDictionary&quot;</span> directly after
      calling <span class="Li">&quot;deflateInit&quot;</span>. The Adler32 value
      for the dictionary can be obtained by calling the method
      <span class="Li">&quot;$d-&gt;dict_adler()&quot;</span>.
    <p class="Pp">The default is no dictionary.</p>
  </dd>
  <dt><b>-Bufsize</b></dt>
  <dd>Sets the initial size for the output buffer used by the
      <span class="Li">&quot;$d-&gt;deflate&quot;</span> and
      <span class="Li">&quot;$d-&gt;flush&quot;</span> methods. If the buffer
      has to be reallocated to increase the size, it will grow in increments of
      <span class="Li">&quot;Bufsize&quot;</span>.
    <p class="Pp">The default buffer size is 4096.</p>
  </dd>
  <dt><b>-AppendOutput</b></dt>
  <dd>This option controls how data is written to the output buffer by the
      <span class="Li">&quot;$d-&gt;deflate&quot;</span> and
      <span class="Li">&quot;$d-&gt;flush&quot;</span> methods.
    <p class="Pp">If the <span class="Li">&quot;AppendOutput&quot;</span> option
        is set to false, the output buffers in the
        <span class="Li">&quot;$d-&gt;deflate&quot;</span> and
        <span class="Li">&quot;$d-&gt;flush&quot;</span> methods will be
        truncated before uncompressed data is written to them.</p>
    <p class="Pp">If the option is set to true, uncompressed data will be
        appended to the output buffer in the
        <span class="Li">&quot;$d-&gt;deflate&quot;</span> and
        <span class="Li">&quot;$d-&gt;flush&quot;</span> methods.</p>
    <p class="Pp">This option defaults to false.</p>
  </dd>
  <dt><b>-CRC32</b></dt>
  <dd>If set to true, a crc32 checksum of the uncompressed data will be
      calculated. Use the <span class="Li">&quot;$d-&gt;crc32&quot;</span>
      method to retrieve this value.
    <p class="Pp">This option defaults to false.</p>
  </dd>
  <dt><b>-ADLER32</b></dt>
  <dd>If set to true, an adler32 checksum of the uncompressed data will be
      calculated. Use the <span class="Li">&quot;$d-&gt;adler32&quot;</span>
      method to retrieve this value.
    <p class="Pp">This option defaults to false.</p>
  </dd>
</dl>
<p class="Pp">Here is an example of using the
    <span class="Li">&quot;Compress::Raw::Zlib::Deflate&quot;</span> optional
    parameter list to override the default buffer size and compression level.
    All other options will take their default values.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    my $d = new Compress::Raw::Zlib::Deflate ( -Bufsize =&gt; 300, 
                                               -Level   =&gt; Z_BEST_SPEED ) ;
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="_fB_fP_fB$status_fP_fB_=__fP_fB$d_fP_fB_-_deflate($input,__fP_fB$output_fP_fB)_fP"><a class="permalink" href="#_fB_fP_fB$status_fP_fB_=__fP_fB$d_fP_fB_-_deflate($input,__fP_fB$output_fP_fB)_fP"><b></b><b>$status</b><b>
  = </b><b>$d</b><b>-&gt;deflate($input, </b><b>$output</b><b>)</b></a></h2>
Deflates the contents of <span class="Li">$input</span> and writes the
  compressed data to <span class="Li">$output</span>.
<p class="Pp">The <span class="Li">$input</span> and
    <span class="Li">$output</span> parameters can be either scalars or scalar
    references.</p>
<p class="Pp">When finished, <span class="Li">$input</span> will be completely
    processed (assuming there were no errors). If the deflation was successful
    it writes the deflated data to <span class="Li">$output</span> and returns a
    status value of <span class="Li">&quot;Z_OK&quot;</span>.</p>
<p class="Pp">On error, it returns a <i>zlib</i> error code.</p>
<p class="Pp">If the <span class="Li">&quot;AppendOutput&quot;</span> option is
    set to true in the constructor for the <span class="Li">$d</span> object,
    the compressed data will be appended to <span class="Li">$output</span>. If
    it is false, <span class="Li">$output</span> will be truncated before any
    compressed data is written to it.</p>
<p class="Pp"><b>Note</b>: This method will not necessarily write compressed
    data to <span class="Li">$output</span> every time it is called. So do not
    assume that there has been an error if the contents of
    <span class="Li">$output</span> is empty on returning from this method. As
    long as the return code from the method is
    <span class="Li">&quot;Z_OK&quot;</span>, the deflate has succeeded.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_fB_fP_fB$status_fP_fB_=__fP_fB$d_fP_fB_-_flush($output__,__fP_fB$flush_type_fP_fB_)__fP"><a class="permalink" href="#_fB_fP_fB$status_fP_fB_=__fP_fB$d_fP_fB_-_flush($output__,__fP_fB$flush_type_fP_fB_)__fP"><b></b><b>$status</b><b>
  = </b><b>$d</b><b>-&gt;flush($output [, </b><b>$flush_type</b><b>])
  </b></a></h2>
Typically used to finish the deflation. Any pending output will be written to
  <span class="Li">$output</span>.
<p class="Pp">Returns <span class="Li">&quot;Z_OK&quot;</span> if
  successful.</p>
<p class="Pp">Note that flushing can seriously degrade the compression ratio, so
    it should only be used to terminate a decompression (using
    <span class="Li">&quot;Z_FINISH&quot;</span>) or when you want to create a
    <i>full flush point</i> (using
    <span class="Li">&quot;Z_FULL_FLUSH&quot;</span>).</p>
<p class="Pp">By default the <span class="Li">&quot;flush_type&quot;</span> used
    is <span class="Li">&quot;Z_FINISH&quot;</span>. Other valid values for
    <span class="Li">&quot;flush_type&quot;</span> are
    <span class="Li">&quot;Z_NO_FLUSH&quot;</span>,
    <span class="Li">&quot;Z_PARTIAL_FLUSH&quot;</span>,
    <span class="Li">&quot;Z_SYNC_FLUSH&quot;</span> and
    <span class="Li">&quot;Z_FULL_FLUSH&quot;</span>. It is strongly recommended
    that you only set the <span class="Li">&quot;flush_type&quot;</span>
    parameter if you fully understand the implications of what it does. See the
    <span class="Li">&quot;zlib&quot;</span> documentation for details.</p>
<p class="Pp">If the <span class="Li">&quot;AppendOutput&quot;</span> option is
    set to true in the constructor for the <span class="Li">$d</span> object,
    the compressed data will be appended to <span class="Li">$output</span>. If
    it is false, <span class="Li">$output</span> will be truncated before any
    compressed data is written to it.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_fB_fP_fB$status_fP_fB_=__fP_fB$d_fP_fB_-__fP_f(BIdeflateReset()_fP_fB__fP"><a class="permalink" href="#_fB_fP_fB$status_fP_fB_=__fP_fB$d_fP_fB_-__fP_f(BIdeflateReset()_fP_fB__fP"><b></b><b>$status</b><b>
  = </b><b>$d</b><b>-&gt;</b><b><i>deflateReset()</i></b><b> </b></a></h2>
This method will reset the deflation object <span class="Li">$d</span>. It can
  be used when you are compressing multiple data streams and want to use the
  same object to compress each of them. It should only be used once the previous
  data stream has been flushed successfully, i.e. a call to
  <span class="Li">&quot;$d-&gt;flush(Z_FINISH)&quot;</span> has returned
  <span class="Li">&quot;Z_OK&quot;</span>.
<p class="Pp">Returns <span class="Li">&quot;Z_OK&quot;</span> if
  successful.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_fB_fP_fB$status_fP_fB_=__fP_fB$d_fP_fB_-_deflateParams(__s-1OPT_s0_)_fP"><a class="permalink" href="#_fB_fP_fB$status_fP_fB_=__fP_fB$d_fP_fB_-_deflateParams(__s-1OPT_s0_)_fP"><b></b><b>$status</b><b>
  = </b><b>$d</b><b>-&gt;deflateParams([OPT])</b></a></h2>
Change settings for the deflate object <span class="Li">$d</span>.
<p class="Pp">The list of the valid options is shown below. Options not
    specified will remain unchanged.</p>
<dl class="Bl-tag">
  <dt><b>-Level</b></dt>
  <dd>Defines the compression level. Valid values are 0 through 9,
      <span class="Li">&quot;Z_NO_COMPRESSION&quot;</span>,
      <span class="Li">&quot;Z_BEST_SPEED&quot;</span>,
      <span class="Li">&quot;Z_BEST_COMPRESSION&quot;</span>, and
      <span class="Li">&quot;Z_DEFAULT_COMPRESSION&quot;</span>.</dd>
  <dt><b>-Strategy</b></dt>
  <dd>Defines the strategy used to tune the compression. The valid values are
      <span class="Li">&quot;Z_DEFAULT_STRATEGY&quot;</span>,
      <span class="Li">&quot;Z_FILTERED&quot;</span> and
      <span class="Li">&quot;Z_HUFFMAN_ONLY&quot;</span>.</dd>
  <dt><b>-BufSize</b></dt>
  <dd>Sets the initial size for the output buffer used by the
      <span class="Li">&quot;$d-&gt;deflate&quot;</span> and
      <span class="Li">&quot;$d-&gt;flush&quot;</span> methods. If the buffer
      has to be reallocated to increase the size, it will grow in increments of
      <span class="Li">&quot;Bufsize&quot;</span>.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="_fB_fP_fB$status_fP_fB_=__fP_fB$d_fP_fB_-_deflateTune($good_length,__fP_fB$max_lazy_fP_fB,__fP_fB$nice_length_fP_fB,__fP_fB$max_chain_fP_fB)_fP"><a class="permalink" href="#_fB_fP_fB$status_fP_fB_=__fP_fB$d_fP_fB_-_deflateTune($good_length,__fP_fB$max_lazy_fP_fB,__fP_fB$nice_length_fP_fB,__fP_fB$max_chain_fP_fB)_fP"><b></b><b>$status</b><b>
  = </b><b>$d</b><b>-&gt;deflateTune($good_length, </b><b>$max_lazy</b><b>,
  </b><b>$nice_length</b><b>, </b><b>$max_chain</b><b>)</b></a></h2>
Tune the internal settings for the deflate object <span class="Li">$d</span>.
  This option is only available if you are running zlib 1.2.2.3 or better.
<p class="Pp">Refer to the documentation in zlib.h for instructions on how to
    fly <span class="Li">&quot;deflateTune&quot;</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_fB_fP_fB$d_fP_fB_-__fP_f(BIdict_adler()_fP_fB_fP"><a class="permalink" href="#_fB_fP_fB$d_fP_fB_-__fP_f(BIdict_adler()_fP_fB_fP"><b></b><b>$d</b><b>-&gt;</b><b><i>dict_adler()</i></b><b></b></a></h2>
Returns the adler32 value for the dictionary.
</section>
<section class="Ss">
<h2 class="Ss" id="_fB_fP_fB$d_fP_fB_-__fP_f(BIcrc32()_fP_fB_fP"><a class="permalink" href="#_fB_fP_fB$d_fP_fB_-__fP_f(BIcrc32()_fP_fB_fP"><b></b><b>$d</b><b>-&gt;</b><b><i>crc32()</i></b><b></b></a></h2>
Returns the crc32 value for the uncompressed data to date.
<p class="Pp">If the <span class="Li">&quot;CRC32&quot;</span> option is not
    enabled in the constructor for this object, this method will always return
    0;</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_fB_fP_fB$d_fP_fB_-__fP_f(BIadler32()_fP_fB_fP"><a class="permalink" href="#_fB_fP_fB$d_fP_fB_-__fP_f(BIadler32()_fP_fB_fP"><b></b><b>$d</b><b>-&gt;</b><b><i>adler32()</i></b><b></b></a></h2>
Returns the adler32 value for the uncompressed data to date.
</section>
<section class="Ss">
<h2 class="Ss" id="_fB_fP_fB$d_fP_fB_-__fP_f(BImsg()_fP_fB_fP"><a class="permalink" href="#_fB_fP_fB$d_fP_fB_-__fP_f(BImsg()_fP_fB_fP"><b></b><b>$d</b><b>-&gt;</b><b><i>msg()</i></b><b></b></a></h2>
Returns the last error message generated by zlib.
</section>
<section class="Ss">
<h2 class="Ss" id="_fB_fP_fB$d_fP_fB_-__fP_f(BItotal_in()_fP_fB_fP"><a class="permalink" href="#_fB_fP_fB$d_fP_fB_-__fP_f(BItotal_in()_fP_fB_fP"><b></b><b>$d</b><b>-&gt;</b><b><i>total_in()</i></b><b></b></a></h2>
Returns the total number of bytes uncompressed bytes input to deflate.
</section>
<section class="Ss">
<h2 class="Ss" id="_fB_fP_fB$d_fP_fB_-__fP_f(BItotal_out()_fP_fB_fP"><a class="permalink" href="#_fB_fP_fB$d_fP_fB_-__fP_f(BItotal_out()_fP_fB_fP"><b></b><b>$d</b><b>-&gt;</b><b><i>total_out()</i></b><b></b></a></h2>
Returns the total number of compressed bytes output from deflate.
</section>
<section class="Ss">
<h2 class="Ss" id="_fB_fP_fB$d_fP_fB_-__fP_f(BIget_Strategy()_fP_fB_fP"><a class="permalink" href="#_fB_fP_fB$d_fP_fB_-__fP_f(BIget_Strategy()_fP_fB_fP"><b></b><b>$d</b><b>-&gt;</b><b><i>get_Strategy()</i></b><b></b></a></h2>
Returns the deflation strategy currently used. Valid values are
  <span class="Li">&quot;Z_DEFAULT_STRATEGY&quot;</span>,
  <span class="Li">&quot;Z_FILTERED&quot;</span> and
  <span class="Li">&quot;Z_HUFFMAN_ONLY&quot;</span>.
</section>
<section class="Ss">
<h2 class="Ss" id="_fB_fP_fB$d_fP_fB_-__fP_f(BIget_Level()_fP_fB_fP"><a class="permalink" href="#_fB_fP_fB$d_fP_fB_-__fP_f(BIget_Level()_fP_fB_fP"><b></b><b>$d</b><b>-&gt;</b><b><i>get_Level()</i></b><b></b></a></h2>
Returns the compression level being used.
</section>
<section class="Ss">
<h2 class="Ss" id="_fB_fP_fB$d_fP_fB_-__fP_f(BIget_BufSize()_fP_fB_fP"><a class="permalink" href="#_fB_fP_fB$d_fP_fB_-__fP_f(BIget_BufSize()_fP_fB_fP"><b></b><b>$d</b><b>-&gt;</b><b><i>get_BufSize()</i></b><b></b></a></h2>
Returns the buffer size used to carry out the compression.
</section>
<section class="Ss">
<h2 class="Ss" id="Example"><a class="permalink" href="#Example">Example</a></h2>
Here is a trivial example of using <span class="Li">&quot;deflate&quot;</span>.
  It simply reads standard input, deflates it and writes it to standard output.
<p class="Pp"><span class="Li"></span></p>
<pre>
    use strict ;
    use warnings ;

    use Compress::Raw::Zlib ;

    binmode STDIN;
    binmode STDOUT;
    my $x = new Compress::Raw::Zlib::Deflate
       or die &quot;Cannot create a deflation stream\n&quot; ;

    my ($output, $status) ;
    while (&lt;&gt;)
    {
        $status = $x-&gt;deflate($_, $output) ;
    
        $status == Z_OK
            or die &quot;deflation failed\n&quot; ;
    
        print $output ;
    }
    
    $status = $x-&gt;flush($output) ;
    
    $status == Z_OK
        or die &quot;deflation failed\n&quot; ;
    
    print $output ;
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="Compress::Raw::Zlib::Inflate"><a class="permalink" href="#Compress::Raw::Zlib::Inflate">Compress::Raw::Zlib::Inflate</a></h1>
This section defines an interface that allows in-memory uncompression using the
  <i>inflate</i> interface provided by zlib.
<p class="Pp">Here is a definition of the interface:</p>
<section class="Ss">
<h2 class="Ss" id="_fB_($i,__fP_fB$status_fP_fB)_=_new_Compress::Raw::Zlib::Inflate(___s-1OPT_s0__)__fP"><a class="permalink" href="#_fB_($i,__fP_fB$status_fP_fB)_=_new_Compress::Raw::Zlib::Inflate(___s-1OPT_s0__)__fP"><b>
  ($i, </b><b>$status</b><b>) = new Compress::Raw::Zlib::Inflate( [OPT] )
  </b></a></h2>
Initialises an inflation object.
<p class="Pp">In a list context it returns the inflation object,
    <span class="Li">$i</span>, and the <i>zlib</i> status code
    (<span class="Li">$status</span>). In a scalar context it returns the
    inflation object only.</p>
<p class="Pp">If successful, <span class="Li">$i</span> will hold the inflation
    object and <span class="Li">$status</span> will be
    <span class="Li">&quot;Z_OK&quot;</span>.</p>
<p class="Pp">If not successful, <span class="Li">$i</span> will be <i>undef</i>
    and <span class="Li">$status</span> will hold the <i>zlib</i> error
  code.</p>
<p class="Pp">The function optionally takes a number of named options specified
    as <span class="Li">&quot;-Name =&gt; value&quot;</span> pairs. This allows
    individual options to be tailored without having to specify them all in the
    parameter list.</p>
<p class="Pp">For backward compatibility, it is also possible to pass the
    parameters as a reference to a hash containing the
    <span class="Li">&quot;name=&gt;value&quot;</span> pairs.</p>
<p class="Pp">Here is a list of the valid options:</p>
<dl class="Bl-tag">
  <dt><b>-WindowBits</b></dt>
  <dd>To uncompress an RFC 1950 data stream, set
      <span class="Li">&quot;WindowBits&quot;</span> to a positive number
      between 8 and 15.
    <p class="Pp">To uncompress an RFC 1951 data stream, set
        <span class="Li">&quot;WindowBits&quot;</span> to
        <span class="Li">&quot;-MAX_WBITS&quot;</span>.</p>
    <p class="Pp">To uncompress an RFC 1952 data stream (i.e. gzip), set
        <span class="Li">&quot;WindowBits&quot;</span> to
        <span class="Li">&quot;WANT_GZIP&quot;</span>.</p>
    <p class="Pp">To auto-detect and uncompress an RFC 1950 or RFC 1952 data
        stream (i.e. gzip), set <span class="Li">&quot;WindowBits&quot;</span>
        to <span class="Li">&quot;WANT_GZIP_OR_ZLIB&quot;</span>.</p>
    <p class="Pp">For a full definition of the meaning and valid values for
        <span class="Li">&quot;WindowBits&quot;</span> refer to the <i>zlib</i>
        documentation for <i>inflateInit2</i>.</p>
    <p class="Pp">Defaults to <span class="Li">&quot;MAX_WBITS&quot;</span>.</p>
  </dd>
  <dt><b>-Bufsize</b></dt>
  <dd>Sets the initial size for the output buffer used by the
      <span class="Li">&quot;$i-&gt;inflate&quot;</span> method. If the output
      buffer in this method has to be reallocated to increase the size, it will
      grow in increments of <span class="Li">&quot;Bufsize&quot;</span>.
    <p class="Pp">Default is 4096.</p>
  </dd>
  <dt><b>-Dictionary</b></dt>
  <dd>The default is no dictionary.</dd>
  <dt><b>-AppendOutput</b></dt>
  <dd>This option controls how data is written to the output buffer by the
      <span class="Li">&quot;$i-&gt;inflate&quot;</span> method.
    <p class="Pp">If the option is set to false, the output buffer in the
        <span class="Li">&quot;$i-&gt;inflate&quot;</span> method will be
        truncated before uncompressed data is written to it.</p>
    <p class="Pp">If the option is set to true, uncompressed data will be
        appended to the output buffer by the
        <span class="Li">&quot;$i-&gt;inflate&quot;</span> method.</p>
    <p class="Pp">This option defaults to false.</p>
  </dd>
  <dt><b>-CRC32</b></dt>
  <dd>If set to true, a crc32 checksum of the uncompressed data will be
      calculated. Use the <span class="Li">&quot;$i-&gt;crc32&quot;</span>
      method to retrieve this value.
    <p class="Pp">This option defaults to false.</p>
  </dd>
  <dt><b>-ADLER32</b></dt>
  <dd>If set to true, an adler32 checksum of the uncompressed data will be
      calculated. Use the <span class="Li">&quot;$i-&gt;adler32&quot;</span>
      method to retrieve this value.
    <p class="Pp">This option defaults to false.</p>
  </dd>
  <dt><b>-ConsumeInput</b></dt>
  <dd>If set to true, this option will remove compressed data from the input
      buffer of the <span class="Li">&quot;$i-&gt;inflate&quot;</span> method as
      the inflate progresses.
    <p class="Pp">This option can be useful when you are processing compressed
        data that is embedded in another file/buffer. In this case the data that
        immediately follows the compressed stream will be left in the input
        buffer.</p>
    <p class="Pp">This option defaults to true.</p>
  </dd>
  <dt><b>-LimitOutput</b></dt>
  <dd>The <span class="Li">&quot;LimitOutput&quot;</span> option changes the
      behavior of the <span class="Li">&quot;$i-&gt;inflate&quot;</span> method
      so that the amount of memory used by the output buffer can be limited.
    <p class="Pp">When <span class="Li">&quot;LimitOutput&quot;</span> is used
        the size of the output buffer used will either be the value of the
        <span class="Li">&quot;Bufsize&quot;</span> option or the amount of
        memory already allocated to <span class="Li">$output</span>, whichever
        is larger. Predicting the output size available is tricky, so don't rely
        on getting an exact output buffer size.</p>
    <p class="Pp">When <span class="Li">&quot;LimitOutout&quot;</span> is not
        specified <span class="Li">&quot;$i-&gt;inflate&quot;</span> will use as
        much memory as it takes to write all the uncompressed data it creates by
        uncompressing the input buffer.</p>
    <p class="Pp">If <span class="Li">&quot;LimitOutput&quot;</span> is enabled,
        the <span class="Li">&quot;ConsumeInput&quot;</span> option will also be
        enabled.</p>
    <p class="Pp">This option defaults to false.</p>
    <p class="Pp">See &quot;The LimitOutput option&quot; for a discussion on why
        <span class="Li">&quot;LimitOutput&quot;</span> is needed and how to use
        it.</p>
  </dd>
</dl>
<p class="Pp">Here is an example of using an optional parameter to override the
    default buffer size.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    my ($i, $status) = new Compress::Raw::Zlib::Inflate( -Bufsize =&gt; 300 ) ;
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="_fB__fP_fB$status_fP_fB_=__fP_fB$i_fP_fB_-_inflate($input,__fP_fB$output_fP_fB__,$eof_)__fP"><a class="permalink" href="#_fB__fP_fB$status_fP_fB_=__fP_fB$i_fP_fB_-_inflate($input,__fP_fB$output_fP_fB__,$eof_)__fP"><b>
  </b><b>$status</b><b> = </b><b>$i</b><b>-&gt;inflate($input,
  </b><b>$output</b><b> [,$eof]) </b></a></h2>
Inflates the complete contents of <span class="Li">$input</span> and writes the
  uncompressed data to <span class="Li">$output</span>. The
  <span class="Li">$input</span> and <span class="Li">$output</span> parameters
  can either be scalars or scalar references.
<p class="Pp">Returns <span class="Li">&quot;Z_OK&quot;</span> if successful and
    <span class="Li">&quot;Z_STREAM_END&quot;</span> if the end of the
    compressed data has been successfully reached.</p>
<p class="Pp">If not successful <span class="Li">$status</span> will hold the
    <i>zlib</i> error code.</p>
<p class="Pp">If the <span class="Li">&quot;ConsumeInput&quot;</span> option has
    been set to true when the
    <span class="Li">&quot;Compress::Raw::Zlib::Inflate&quot;</span> object is
    created, the <span class="Li">$input</span> parameter is modified by
    <span class="Li">&quot;inflate&quot;</span>. On completion it will contain
    what remains of the input buffer after inflation. In practice, this means
    that when the return status is <span class="Li">&quot;Z_OK&quot;</span> the
    <span class="Li">$input</span> parameter will contain an empty string, and
    when the return status is <span class="Li">&quot;Z_STREAM_END&quot;</span>
    the <span class="Li">$input</span> parameter will contains what (if
    anything) was stored in the input buffer after the deflated data stream.</p>
<p class="Pp">This feature is useful when processing a file format that
    encapsulates a compressed data stream (e.g. gzip, zip) and there is useful
    data immediately after the deflation stream.</p>
<p class="Pp">If the <span class="Li">&quot;AppendOutput&quot;</span> option is
    set to true in the constructor for this object, the uncompressed data will
    be appended to <span class="Li">$output</span>. If it is false,
    <span class="Li">$output</span> will be truncated before any uncompressed
    data is written to it.</p>
<p class="Pp">The <span class="Li">$eof</span> parameter needs a bit of
    explanation.</p>
<p class="Pp">Prior to version 1.2.0, zlib assumed that there was at least one
    trailing byte immediately after the compressed data stream when it was
    carrying out decompression. This normally isn't a problem because the
    majority of zlib applications guarantee that there will be data directly
    after the compressed data stream. For example, both gzip (RFC 1950) and zip
    both define trailing data that follows the compressed data stream.</p>
<p class="Pp">The <span class="Li">$eof</span> parameter only needs to be used
    if <b>all</b> of the following conditions apply</p>
<dl class="Bl-tag">
  <dt>1.</dt>
  <dd>You are either using a copy of zlib that is older than version 1.2.0 or
      you want your application code to be able to run with as many different
      versions of zlib as possible.</dd>
  <dt>2.</dt>
  <dd>You have set the <span class="Li">&quot;WindowBits&quot;</span> parameter
      to <span class="Li">&quot;-MAX_WBITS&quot;</span> in the constructor for
      this object, i.e. you are uncompressing a raw deflated data stream (RFC
      1951).</dd>
  <dt>3.</dt>
  <dd>There is no data immediately after the compressed data stream.</dd>
</dl>
<p class="Pp">If <b>all</b> of these are the case, then you need to set the
    <span class="Li">$eof</span> parameter to true on the final call (and only
    the final call) to <span class="Li">&quot;$i-&gt;inflate&quot;</span>.</p>
<p class="Pp">If you have built this module with zlib &gt;= 1.2.0, the
    <span class="Li">$eof</span> parameter is ignored. You can still set it if
    you want, but it won't be used behind the scenes.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_fB_fP_fB$status_fP_fB_=__fP_fB$i_fP_fB_-_inflateSync($input)_fP"><a class="permalink" href="#_fB_fP_fB$status_fP_fB_=__fP_fB$i_fP_fB_-_inflateSync($input)_fP"><b></b><b>$status</b><b>
  = </b><b>$i</b><b>-&gt;inflateSync($input)</b></a></h2>
This method can be used to attempt to recover good data from a compressed data
  stream that is partially corrupt. It scans <span class="Li">$input</span>
  until it reaches either a <i>full flush point</i> or the end of the buffer.
<p class="Pp">If a <i>full flush point</i> is found,
    <span class="Li">&quot;Z_OK&quot;</span> is returned and
    <span class="Li">$input</span> will be have all data up to the flush point
    removed. This data can then be passed to the
    <span class="Li">&quot;$i-&gt;inflate&quot;</span> method to be
    uncompressed.</p>
<p class="Pp">Any other return code means that a flush point was not found. If
    more data is available, <span class="Li">&quot;inflateSync&quot;</span> can
    be called repeatedly with more compressed data until the flush point is
    found.</p>
<p class="Pp">Note <i>full flush points</i> are not present by default in
    compressed data streams. They must have been added explicitly when the data
    stream was created by calling
    <span class="Li">&quot;Compress::Deflate::flush&quot;</span> with
    <span class="Li">&quot;Z_FULL_FLUSH&quot;</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_fB_fP_fB$status_fP_fB_=__fP_fB$i_fP_fB_-__fP_f(BIinflateReset()_fP_fB__fP"><a class="permalink" href="#_fB_fP_fB$status_fP_fB_=__fP_fB$i_fP_fB_-__fP_f(BIinflateReset()_fP_fB__fP"><b></b><b>$status</b><b>
  = </b><b>$i</b><b>-&gt;</b><b><i>inflateReset()</i></b><b> </b></a></h2>
This method will reset the inflation object <span class="Li">$i</span>. It can
  be used when you are uncompressing multiple data streams and want to use the
  same object to uncompress each of them.
<p class="Pp">Returns <span class="Li">&quot;Z_OK&quot;</span> if
  successful.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_fB_fP_fB$i_fP_fB_-__fP_f(BIdict_adler()_fP_fB_fP"><a class="permalink" href="#_fB_fP_fB$i_fP_fB_-__fP_f(BIdict_adler()_fP_fB_fP"><b></b><b>$i</b><b>-&gt;</b><b><i>dict_adler()</i></b><b></b></a></h2>
Returns the adler32 value for the dictionary.
</section>
<section class="Ss">
<h2 class="Ss" id="_fB_fP_fB$i_fP_fB_-__fP_f(BIcrc32()_fP_fB_fP"><a class="permalink" href="#_fB_fP_fB$i_fP_fB_-__fP_f(BIcrc32()_fP_fB_fP"><b></b><b>$i</b><b>-&gt;</b><b><i>crc32()</i></b><b></b></a></h2>
Returns the crc32 value for the uncompressed data to date.
<p class="Pp">If the <span class="Li">&quot;CRC32&quot;</span> option is not
    enabled in the constructor for this object, this method will always return
    0;</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_fB_fP_fB$i_fP_fB_-__fP_f(BIadler32()_fP_fB_fP"><a class="permalink" href="#_fB_fP_fB$i_fP_fB_-__fP_f(BIadler32()_fP_fB_fP"><b></b><b>$i</b><b>-&gt;</b><b><i>adler32()</i></b><b></b></a></h2>
Returns the adler32 value for the uncompressed data to date.
<p class="Pp">If the <span class="Li">&quot;ADLER32&quot;</span> option is not
    enabled in the constructor for this object, this method will always return
    0;</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_fB_fP_fB$i_fP_fB_-__fP_f(BImsg()_fP_fB_fP"><a class="permalink" href="#_fB_fP_fB$i_fP_fB_-__fP_f(BImsg()_fP_fB_fP"><b></b><b>$i</b><b>-&gt;</b><b><i>msg()</i></b><b></b></a></h2>
Returns the last error message generated by zlib.
</section>
<section class="Ss">
<h2 class="Ss" id="_fB_fP_fB$i_fP_fB_-__fP_f(BItotal_in()_fP_fB_fP"><a class="permalink" href="#_fB_fP_fB$i_fP_fB_-__fP_f(BItotal_in()_fP_fB_fP"><b></b><b>$i</b><b>-&gt;</b><b><i>total_in()</i></b><b></b></a></h2>
Returns the total number of bytes compressed bytes input to inflate.
</section>
<section class="Ss">
<h2 class="Ss" id="_fB_fP_fB$i_fP_fB_-__fP_f(BItotal_out()_fP_fB_fP"><a class="permalink" href="#_fB_fP_fB$i_fP_fB_-__fP_f(BItotal_out()_fP_fB_fP"><b></b><b>$i</b><b>-&gt;</b><b><i>total_out()</i></b><b></b></a></h2>
Returns the total number of uncompressed bytes output from inflate.
</section>
<section class="Ss">
<h2 class="Ss" id="_fB_fP_fB$d_fP_fB_-__fP_f(BIget_BufSize()_fP_fB_fP_2"><a class="permalink" href="#_fB_fP_fB$d_fP_fB_-__fP_f(BIget_BufSize()_fP_fB_fP_2"><b></b><b>$d</b><b>-&gt;</b><b><i>get_BufSize()</i></b><b></b></a></h2>
Returns the buffer size used to carry out the decompression.
</section>
<section class="Ss">
<h2 class="Ss" id="Examples"><a class="permalink" href="#Examples">Examples</a></h2>
Here is an example of using <span class="Li">&quot;inflate&quot;</span>.
<p class="Pp"><span class="Li"></span></p>
<pre>
    use strict ;
    use warnings ;
    
    use Compress::Raw::Zlib;
    
    my $x = new Compress::Raw::Zlib::Inflate()
       or die &quot;Cannot create a inflation stream\n&quot; ;
    
    my $input = '' ;
    binmode STDIN;
    binmode STDOUT;
    
    my ($output, $status) ;
    while (read(STDIN, $input, 4096))
    {
        $status = $x-&gt;inflate($input, $output) ;
    
        print $output ;
    
        last if $status != Z_OK ;
    }
    
    die &quot;inflation failed\n&quot;
        unless $status == Z_STREAM_END ;
</pre>
<p class="Pp">The next example show how to use the
    <span class="Li">&quot;LimitOutput&quot;</span> option. Notice the use of
    two nested loops in this case. The outer loop reads the data from the input
    source - STDIN and the inner loop repeatedly calls
    <span class="Li">&quot;inflate&quot;</span> until
    <span class="Li">$input</span> is exhausted, we get an error, or the end of
    the stream is reached. One point worth remembering is by using the
    <span class="Li">&quot;LimitOutput&quot;</span> option you also get
    <span class="Li">&quot;ConsumeInput&quot;</span> set as well - this makes
    the code below much simpler.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    use strict ;
    use warnings ;
    
    use Compress::Raw::Zlib;
    
    my $x = new Compress::Raw::Zlib::Inflate(LimitOutput =&gt; 1)
       or die &quot;Cannot create a inflation stream\n&quot; ;
    
    my $input = '' ;
    binmode STDIN;
    binmode STDOUT;
    
    my ($output, $status) ;

  OUTER:
    while (read(STDIN, $input, 4096))
    {
        do
        {
            $status = $x-&gt;inflate($input, $output) ;

            print $output ;

            last OUTER
                unless $status == Z_OK || $status == Z_BUF_ERROR ;
        }
        while ($status == Z_OK &amp;&amp; length $input);
    }
    
    die &quot;inflation failed\n&quot;
        unless $status == Z_STREAM_END ;
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="CHECKSUM_FUNCTIONS"><a class="permalink" href="#CHECKSUM_FUNCTIONS">CHECKSUM
  FUNCTIONS</a></h1>
Two functions are provided by <i>zlib</i> to calculate checksums. For the Perl
  interface, the order of the two parameters in both functions has been
  reversed. This allows both running checksums and one off calculations to be
  done.
<p class="Pp"><span class="Li"></span></p>
<pre>
    $crc = adler32($buffer [,$crc]) ;
    $crc = crc32($buffer [,$crc]) ;
</pre>
<p class="Pp">The buffer parameters can either be a scalar or a scalar
    reference.</p>
<p class="Pp">If the <span class="Li">$crc</span> parameters is
    <span class="Li">&quot;undef&quot;</span>, the crc value will be reset.</p>
<p class="Pp">If you have built this module with zlib 1.2.3 or better, two more
    CRC-related functions are available.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    $crc = adler32_combine($crc1, $crc2, $len2)l
    $crc = crc32_combine($adler1, $adler2, $len2)
</pre>
<p class="Pp">These functions allow checksums to be merged.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="Misc"><a class="permalink" href="#Misc">Misc</a></h1>
<section class="Ss">
<h2 class="Ss" id="my_$version_=__fICompress::Raw::Zlib::zlib_version()_fP;"><a class="permalink" href="#my_$version_=__fICompress::Raw::Zlib::zlib_version()_fP;">my
  $version = <i>Compress::Raw::Zlib::zlib_version()</i>;</a></h2>
Returns the version of the zlib library.
</section>
<section class="Ss">
<h2 class="Ss" id="my_$flags_=__fICompress::Raw::Zlib::zlibCompileFlags()_fP;"><a class="permalink" href="#my_$flags_=__fICompress::Raw::Zlib::zlibCompileFlags()_fP;">my
  $flags = <i>Compress::Raw::Zlib::zlibCompileFlags()</i>;</a></h2>
Returns the flags indicating compile-time options that were used to build the
  zlib library. See the zlib documentation for a description of the flags
  returned by <span class="Li">&quot;zlibCompileFlags&quot;</span>.
<p class="Pp">Note that when the zlib sources are built along with this module
    the <span class="Li">&quot;sprintf&quot;</span> flags (bits 24, 25 and 26)
    should be ignored.</p>
<p class="Pp">If you are using zlib 1.2.0 or older,
    <span class="Li">&quot;zlibCompileFlags&quot;</span> will return 0.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="The_LimitOutput_option."><a class="permalink" href="#The_LimitOutput_option.">The
  LimitOutput option.</a></h1>
By default <span class="Li">&quot;$i-&gt;inflate($input, $output)&quot;</span>
  will uncompress <i>all</i> data in <span class="Li">$input</span> and write
  <i>all</i> of the uncompressed data it has generated to
  <span class="Li">$output</span>. This makes the interface to
  <span class="Li">&quot;inflate&quot;</span> much simpler - if the method has
  uncompressed <span class="Li">$input</span> successfully <i>all</i> compressed
  data in <span class="Li">$input</span> will have been dealt with. So if you
  are reading from an input source and uncompressing as you go the code will
  look something like this
<p class="Pp"><span class="Li"></span></p>
<pre>
    use strict ;
    use warnings ;
    
    use Compress::Raw::Zlib;
    
    my $x = new Compress::Raw::Zlib::Inflate()
       or die &quot;Cannot create a inflation stream\n&quot; ;
    
    my $input = '' ;
    
    my ($output, $status) ;
    while (read(STDIN, $input, 4096))
    {
        $status = $x-&gt;inflate($input, $output) ;
    
        print $output ;
    
        last if $status != Z_OK ;
    }
    
    die &quot;inflation failed\n&quot;
        unless $status == Z_STREAM_END ;
</pre>
<p class="Pp">The points to note are</p>
<ul class="Bl-bullet">
  <li>The main processing loop in the code handles reading of compressed data
      from STDIN.</li>
  <li>The status code returned from <span class="Li">&quot;inflate&quot;</span>
      will only trigger termination of the main processing loop if it isn't
      <span class="Li">&quot;Z_OK&quot;</span>. When
      <span class="Li">&quot;LimitOutput&quot;</span> has not been used the
      <span class="Li">&quot;Z_OK&quot;</span> status means means that the end
      of the compressed data stream has been reached or there has been an error
      in uncompression.</li>
  <li>After the call to <span class="Li">&quot;inflate&quot;</span> <i>all</i>
      of the uncompressed data in <span class="Li">$input</span> will have been
      processed. This means the subsequent call to
      <span class="Li">&quot;read&quot;</span> can overwrite it's contents
      without any problem.</li>
</ul>
<p class="Pp">For most use-cases the behavior described above is acceptable
    (this module and it's predecessor,
    <span class="Li">&quot;Compress::Zlib&quot;</span>, have used it for over 10
    years without an issue), but in a few very specific use-cases the amount of
    memory required for <span class="Li">$output</span> can prohibitively large.
    For example, if the compressed data stream contains the same pattern
    repeated thousands of times, a relatively small compressed data stream can
    uncompress into hundreds of megabytes. Remember
    <span class="Li">&quot;inflate&quot;</span> will keep allocating memory
    until <i>all</i> the uncompressed data has been written to the output buffer
    - the size of <span class="Li">$output</span> is unbounded.</p>
<p class="Pp">The <span class="Li">&quot;LimitOutput&quot;</span> option is
    designed to help with this use-case.</p>
<p class="Pp">The main difference in your code when using
    <span class="Li">&quot;LimitOutput&quot;</span> is having to deal with cases
    where the <span class="Li">$input</span> parameter still contains some
    uncompressed data that <span class="Li">&quot;inflate&quot;</span> hasn't
    processed yet. The status code returned from
    <span class="Li">&quot;inflate&quot;</span> will be
    <span class="Li">&quot;Z_OK&quot;</span> if uncompression took place and
    <span class="Li">&quot;Z_BUF_ERROR&quot;</span> if the output buffer is
    full.</p>
<p class="Pp">Below is typical code that shows how to use
    <span class="Li">&quot;LimitOutput&quot;</span>.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    use strict ;
    use warnings ;
    
    use Compress::Raw::Zlib;
    
    my $x = new Compress::Raw::Zlib::Inflate(LimitOutput =&gt; 1)
       or die &quot;Cannot create a inflation stream\n&quot; ;
    
    my $input = '' ;
    binmode STDIN;
    binmode STDOUT;
    
    my ($output, $status) ;

  OUTER:
    while (read(STDIN, $input, 4096))
    {
        do
        {
            $status = $x-&gt;inflate($input, $output) ;

            print $output ;

            last OUTER
                unless $status == Z_OK || $status == Z_BUF_ERROR ;
        }
        while ($status == Z_OK &amp;&amp; length $input);
    }
    
    die &quot;inflation failed\n&quot;
        unless $status == Z_STREAM_END ;
</pre>
<p class="Pp">Points to note this time:</p>
<ul class="Bl-bullet">
  <li>There are now two nested loops in the code: the outer loop for reading the
      compressed data from STDIN, as before; and the inner loop to carry out the
      uncompression.</li>
  <li>There are two exit points from the inner uncompression loop.
    <p class="Pp">Firstly when <span class="Li">&quot;inflate&quot;</span> has
        returned a status other than <span class="Li">&quot;Z_OK&quot;</span> or
        <span class="Li">&quot;Z_BUF_ERROR&quot;</span>. This means that either
        the end of the compressed data stream has been reached
        (<span class="Li">&quot;Z_STREAM_END&quot;</span>) or there is an error
        in the compressed data. In either of these cases there is no point in
        continuing with reading the compressed data, so both loops are
        terminated.</p>
    <p class="Pp">The second exit point tests if there is any data left in the
        input buffer, <span class="Li">$input</span> - remember that the
        <span class="Li">&quot;ConsumeInput&quot;</span> option is automatically
        enabled when <span class="Li">&quot;LimitOutput&quot;</span> is used.
        When the input buffer has been exhausted, the outer loop can run again
        and overwrite a now empty <span class="Li">$input</span>.</p>
  </li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="ACCESSING_ZIP_FILES"><a class="permalink" href="#ACCESSING_ZIP_FILES">ACCESSING
  ZIP FILES</a></h1>
Although it is possible (with some effort on your part) to use this module to
  access .zip files, there are other perl modules available that will do all the
  hard work for you. Check out <span class="Li">&quot;Archive::Zip&quot;</span>,
  <span class="Li">&quot;Archive::Zip::SimpleZip&quot;</span>,
  <span class="Li">&quot;IO::Compress::Zip&quot;</span> and
  <span class="Li">&quot;IO::Uncompress::Unzip&quot;</span>.
</section>
<section class="Sh">
<h1 class="Sh" id="FAQ"><a class="permalink" href="#FAQ">FAQ</a></h1>
<section class="Ss">
<h2 class="Ss" id="Compatibility_with_Unix_compress/uncompress."><a class="permalink" href="#Compatibility_with_Unix_compress/uncompress.">Compatibility
  with Unix compress/uncompress.</a></h2>
This module is not compatible with Unix
  <span class="Li">&quot;compress&quot;</span>.
<p class="Pp">If you have the <span class="Li">&quot;uncompress&quot;</span>
    program available, you can use this to read compressed files</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    open F, &quot;uncompress -c $filename |&quot;;
    while (&lt;F&gt;)
    {
        ...
</pre>
<p class="Pp">Alternatively, if you have the
    <span class="Li">&quot;gunzip&quot;</span> program available, you can use
    this to read compressed files</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    open F, &quot;gunzip -c $filename |&quot;;
    while (&lt;F&gt;)
    {
        ...
</pre>
<p class="Pp">and this to write compress files, if you have the
    <span class="Li">&quot;compress&quot;</span> program available</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    open F, &quot;| compress -c $filename &quot;;
    print F &quot;data&quot;;
    ...
    close F ;
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Accessing_.tar.Z_files"><a class="permalink" href="#Accessing_.tar.Z_files">Accessing
  .tar.Z files</a></h2>
See previous FAQ item.
<p class="Pp">If the <span class="Li">&quot;Archive::Tar&quot;</span> module is
    installed and either the <span class="Li">&quot;uncompress&quot;</span> or
    <span class="Li">&quot;gunzip&quot;</span> programs are available, you can
    use one of these workarounds to read
    <span class="Li">&quot;.tar.Z&quot;</span> files.</p>
<p class="Pp">Firstly with <span class="Li">&quot;uncompress&quot;</span></p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    use strict;
    use warnings;
    use Archive::Tar;

    open F, &quot;uncompress -c $filename |&quot;;
    my $tar = Archive::Tar-&gt;new(*F);
    ...
</pre>
<p class="Pp">and this with <span class="Li">&quot;gunzip&quot;</span></p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    use strict;
    use warnings;
    use Archive::Tar;

    open F, &quot;gunzip -c $filename |&quot;;
    my $tar = Archive::Tar-&gt;new(*F);
    ...
</pre>
<p class="Pp">Similarly, if the <span class="Li">&quot;compress&quot;</span>
    program is available, you can use this to write a
    <span class="Li">&quot;.tar.Z&quot;</span> file</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    use strict;
    use warnings;
    use Archive::Tar;
    use IO::File;

    my $fh = new IO::File &quot;| compress -c &gt;$filename&quot;;
    my $tar = Archive::Tar-&gt;new();
    ...
    $tar-&gt;write($fh);
    $fh-&gt;close ;
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Zlib_Library_Version_Support"><a class="permalink" href="#Zlib_Library_Version_Support">Zlib
  Library Version Support</a></h2>
By default <span class="Li">&quot;Compress::Raw::Zlib&quot;</span> will build
  with a private copy of version 1.2.5 of the zlib library. (See the
  <i>README</i> file for details of how to override this behaviour)
<p class="Pp">If you decide to use a different version of the zlib library, you
    need to be aware of the following issues</p>
<ul class="Bl-bullet">
  <li>First off, you must have zlib 1.0.5 or better.</li>
  <li>You need to have zlib 1.2.1 or better if you want to use the
      <span class="Li">&quot;-Merge&quot;</span> option with
      <span class="Li">&quot;IO::Compress::Gzip&quot;</span>,
      <span class="Li">&quot;IO::Compress::Deflate&quot;</span> and
      <span class="Li">&quot;IO::Compress::RawDeflate&quot;</span>.</li>
</ul>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="CONSTANTS"><a class="permalink" href="#CONSTANTS">CONSTANTS</a></h1>
All the <i>zlib</i> constants are automatically imported when you make use of
  <i>Compress::Raw::Zlib</i>.
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
Compress::Zlib, IO::Compress::Gzip, IO::Uncompress::Gunzip,
  IO::Compress::Deflate, IO::Uncompress::Inflate, IO::Compress::RawDeflate,
  IO::Uncompress::RawInflate, IO::Compress::Bzip2, IO::Uncompress::Bunzip2,
  IO::Compress::Lzma, IO::Uncompress::UnLzma, IO::Compress::Xz,
  IO::Uncompress::UnXz, IO::Compress::Lzop, IO::Uncompress::UnLzop,
  IO::Compress::Lzf, IO::Uncompress::UnLzf, IO::Uncompress::AnyInflate,
  IO::Uncompress::AnyUncompress
<p class="Pp">IO::Compress::FAQ</p>
<p class="Pp">File::GlobMapper, Archive::Zip, Archive::Tar, IO::Zlib</p>
<p class="Pp">For RFC 1950, 1951 and 1952 see
    <i>http://www.faqs.org/rfcs/rfc1950.html</i>,
    <i>http://www.faqs.org/rfcs/rfc1951.html</i> and
    <i>http://www.faqs.org/rfcs/rfc1952.html</i></p>
<p class="Pp">The <i>zlib</i> compression library was written by Jean-loup
    Gailly <i>gzip@prep.ai.mit.edu</i> and Mark Adler
    <i>madler@alumni.caltech.edu</i>.</p>
<p class="Pp">The primary site for the <i>zlib</i> compression library is
    <i>http://www.zlib.org</i>.</p>
<p class="Pp">The primary site for gzip is <i>http://www.gzip.org</i>.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
This module was written by Paul Marquess, <i>pmqs@cpan.org</i>.
</section>
<section class="Sh">
<h1 class="Sh" id="MODIFICATION_HISTORY"><a class="permalink" href="#MODIFICATION_HISTORY">MODIFICATION
  HISTORY</a></h1>
See the Changes file.
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT_AND_LICENSE"><a class="permalink" href="#COPYRIGHT_AND_LICENSE">COPYRIGHT
  AND LICENSE</a></h1>
Copyright (c) 2005-2013 Paul Marquess. All rights reserved.
<p class="Pp">This program is free software; you can redistribute it and/or
    modify it under the same terms as Perl itself.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2014-09-30</td>
    <td class="foot-os">perl v5.18.4</td>
  </tr>
</table>
</body>
</html>
