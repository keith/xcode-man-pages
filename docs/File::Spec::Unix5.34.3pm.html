<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    .Nd, .Bf, .Op { display: inline; }
    .Pa, .Ad { font-style: italic; }
    .Ms { font-weight: bold; }
    .Bl-diag > dt { font-weight: bold; }
    code.Nm, .Fl, .Cm, .Ic, code.In, .Fd, .Fn, .Cd { font-weight: bold;
      font-family: inherit; }
  </style>
  <title>File::Spec::Unix(3pm)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">File::Spec::Unix(3pm)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">File::Spec::Unix(3pm)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">File::Spec::Unix - File::Spec for Unix, base for other File::Spec
    modules</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre> require File::Spec::Unix; # Done automatically by File::Spec
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">Methods for manipulating file specifications. Other File::Spec
    modules, such as File::Spec::Mac, inherit from File::Spec::Unix and override
    specific methods.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="METHODS"><a class="permalink" href="#METHODS">METHODS</a></h1>
<dl class="Bl-tag">
  <dt id="canonpath()"><a class="permalink" href="#canonpath()"><b>canonpath()</b></a></dt>
  <dd>No physical check on the filesystem, but a logical cleanup of a path. On
      UNIX eliminates successive slashes and successive &quot;/.&quot;.
    <p class="Pp"></p>
    <pre>    $cpath = File::Spec-&gt;canonpath( $path ) ;
    </pre>
    <p class="Pp">Note that this does *not* collapse <i>x/../y</i> sections into
        <i>y</i>. This is by design. If <i>/foo</i> on your system is a symlink
        to <i>/bar/baz</i>, then <i>/foo/../quux</i> is actually
        <i>/bar/quux</i>, not <i>/quux</i> as a naive <i>../</i>-removal would
        give you. If you want to do this kind of processing, you probably want
        <span class="Li">&quot;Cwd&quot;</span>'s
        <span class="Li">&quot;realpath()&quot;</span> function to actually
        traverse the filesystem cleaning up paths like this.</p>
  </dd>
  <dt id="catdir()"><a class="permalink" href="#catdir()"><b>catdir()</b></a></dt>
  <dd>Concatenate two or more directory names to form a complete path ending
      with a directory. But remove the trailing slash from the resulting string,
      because it doesn't look good, isn't necessary and confuses OS2. Of course,
      if this is the root directory, don't cut off the trailing slash :-)</dd>
  <dt id="catfile"><a class="permalink" href="#catfile">catfile</a></dt>
  <dd>Concatenate one or more directory names and a filename to form a complete
      path ending with a filename</dd>
  <dt id="curdir"><a class="permalink" href="#curdir">curdir</a></dt>
  <dd>Returns a string representation of the current directory. &quot;.&quot; on
      UNIX.</dd>
  <dt id="devnull"><a class="permalink" href="#devnull">devnull</a></dt>
  <dd>Returns a string representation of the null device. &quot;/dev/null&quot;
      on UNIX.</dd>
  <dt id="rootdir"><a class="permalink" href="#rootdir">rootdir</a></dt>
  <dd>Returns a string representation of the root directory. &quot;/&quot; on
      UNIX.</dd>
  <dt id="tmpdir"><a class="permalink" href="#tmpdir">tmpdir</a></dt>
  <dd>Returns a string representation of the first writable directory from the
      following list or the current directory if none from the list are
      writable:
    <p class="Pp"></p>
    <pre>    $ENV{TMPDIR}
    /tmp
    </pre>
    <p class="Pp">If running under taint mode, and if
        <span class="Li">$ENV</span>{TMPDIR} is tainted, it is not used.</p>
  </dd>
  <dt id="updir"><a class="permalink" href="#updir">updir</a></dt>
  <dd>Returns a string representation of the parent directory. &quot;..&quot; on
      UNIX.</dd>
  <dt id="no_upwards"><a class="permalink" href="#no_upwards">no_upwards</a></dt>
  <dd>Given a list of file names, strip out those that refer to a parent
      directory. (Does not strip symlinks, only '.', '..', and
    equivalents.)</dd>
  <dt id="case_tolerant"><a class="permalink" href="#case_tolerant">case_tolerant</a></dt>
  <dd>Returns a true or false value indicating, respectively, that alphabetic is
      not or is significant when comparing file specifications.</dd>
  <dt id="file_name_is_absolute"><a class="permalink" href="#file_name_is_absolute">file_name_is_absolute</a></dt>
  <dd>Takes as argument a path and returns true if it is an absolute path.
    <p class="Pp">This does not consult the local filesystem on Unix, Win32,
        OS/2 or Mac OS (Classic). It does consult the working environment for
        VMS (see &quot;file_name_is_absolute&quot; in File::Spec::VMS).</p>
  </dd>
  <dt id="path"><a class="permalink" href="#path">path</a></dt>
  <dd>Takes no argument, returns the environment variable PATH as an array.</dd>
  <dt id="join"><a class="permalink" href="#join">join</a></dt>
  <dd>join is the same as catfile.</dd>
  <dt id="splitpath"><a class="permalink" href="#splitpath">splitpath</a></dt>
  <dd>
    <pre>    ($volume,$directories,$file) = File::Spec-&gt;splitpath( $path );
    ($volume,$directories,$file) = File::Spec-&gt;splitpath( $path,
                                                          $no_file );
    </pre>
    <p class="Pp">Splits a path into volume, directory, and filename portions.
        On systems with no concept of volume, returns '' for volume.</p>
    <p class="Pp">For systems with no syntax differentiating filenames from
        directories, assumes that the last file is a path unless
        <span class="Li">$no_file</span> is true or a trailing separator or /.
        or /.. is present. On Unix this means that
        <span class="Li">$no_file</span> true makes this return ( '',
        <span class="Li">$path</span>, '' ).</p>
    <p class="Pp">The directory portion may or may not be returned with a
        trailing '/'.</p>
    <p class="Pp">The results can be passed to &quot;<b>catpath()</b>&quot; to
        get back a path equivalent to (usually identical to) the original
      path.</p>
  </dd>
  <dt id="splitdir"><a class="permalink" href="#splitdir">splitdir</a></dt>
  <dd>The opposite of &quot;<b>catdir()</b>&quot;.
    <p class="Pp"></p>
    <pre>    @dirs = File::Spec-&gt;splitdir( $directories );
    </pre>
    <p class="Pp"><span class="Li">$directories</span> must be only the
        directory portion of the path on systems that have the concept of a
        volume or that have path syntax that differentiates files from
        directories.</p>
    <p class="Pp">Unlike just splitting the directories on the separator, empty
        directory names (<span class="Li">''</span>) can be returned, because
        these are significant on some OSs.</p>
    <p class="Pp">On Unix,</p>
    <p class="Pp"></p>
    <pre>    File::Spec-&gt;splitdir( &quot;/a/b//c/&quot; );
    </pre>
    <p class="Pp">Yields:</p>
    <p class="Pp"></p>
    <pre>    ( '', 'a', 'b', '', 'c', '' )
    </pre>
  </dd>
  <dt id="catpath()"><a class="permalink" href="#catpath()"><b>catpath()</b></a></dt>
  <dd>Takes volume, directory and file portions and returns an entire path.
      Under Unix, <span class="Li">$volume</span> is ignored, and directory and
      file are concatenated. A '/' is inserted if needed (though if the
      directory portion doesn't start with '/' it is not added). On other OSs,
      <span class="Li">$volume</span> is significant.</dd>
  <dt id="abs2rel"><a class="permalink" href="#abs2rel">abs2rel</a></dt>
  <dd>Takes a destination path and an optional base path returns a relative path
      from the base path to the destination path:
    <p class="Pp"></p>
    <pre>    $rel_path = File::Spec-&gt;abs2rel( $path ) ;
    $rel_path = File::Spec-&gt;abs2rel( $path, $base ) ;
    </pre>
    <p class="Pp">If <span class="Li">$base</span> is not present or '', then
        <b>cwd()</b> is used. If <span class="Li">$base</span> is relative, then
        it is converted to absolute form using &quot;<b>rel2abs()</b>&quot;.
        This means that it is taken to be relative to <b>cwd()</b>.</p>
    <p class="Pp">On systems that have a grammar that indicates filenames, this
        ignores the <span class="Li">$base</span> filename. Otherwise all path
        components are assumed to be directories.</p>
    <p class="Pp">If <span class="Li">$path</span> is relative, it is converted
        to absolute form using &quot;<b>rel2abs()</b>&quot;. This means that it
        is taken to be relative to <b>cwd()</b>.</p>
    <p class="Pp">No checks against the filesystem are made, so the result may
        not be correct if <span class="Li">$base</span> contains symbolic links.
        (Apply <b>Cwd::abs_path()</b> beforehand if that is a concern.) On VMS,
        there is interaction with the working environment, as logicals and
        macros are expanded.</p>
    <p class="Pp">Based on code written by Shigio Yamaguchi.</p>
  </dd>
  <dt id="rel2abs()"><a class="permalink" href="#rel2abs()"><b>rel2abs()</b></a></dt>
  <dd>Converts a relative path to an absolute path.
    <p class="Pp"></p>
    <pre>    $abs_path = File::Spec-&gt;rel2abs( $path ) ;
    $abs_path = File::Spec-&gt;rel2abs( $path, $base ) ;
    </pre>
    <p class="Pp">If <span class="Li">$base</span> is not present or '', then
        <b>cwd()</b> is used. If <span class="Li">$base</span> is relative, then
        it is converted to absolute form using &quot;<b>rel2abs()</b>&quot;.
        This means that it is taken to be relative to <b>cwd()</b>.</p>
    <p class="Pp">On systems that have a grammar that indicates filenames, this
        ignores the <span class="Li">$base</span> filename. Otherwise all path
        components are assumed to be directories.</p>
    <p class="Pp">If <span class="Li">$path</span> is absolute, it is cleaned up
        and returned using &quot;<b>canonpath()</b>&quot;.</p>
    <p class="Pp">No checks against the filesystem are made. On VMS, there is
        interaction with the working environment, as logicals and macros are
        expanded.</p>
    <p class="Pp">Based on code written by Shigio Yamaguchi.</p>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT"><a class="permalink" href="#COPYRIGHT">COPYRIGHT</a></h1>
<p class="Pp">Copyright (c) 2004 by the Perl 5 Porters. All rights reserved.</p>
<p class="Pp">This program is free software; you can redistribute it and/or
    modify it under the same terms as Perl itself.</p>
<p class="Pp">Please submit bug reports and patches to perlbug@perl.org.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp">File::Spec</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2021-01-20</td>
    <td class="foot-os">perl v5.34.0</td>
  </tr>
</table>
</body>
</html>
