<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>PERLUNIFAQ(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">PERLUNIFAQ(1)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">PERLUNIFAQ(1)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
perlunifaq - Perl Unicode FAQ
</section>
<section class="Sh">
<h1 class="Sh" id="Q_and_A"><a class="permalink" href="#Q_and_A">Q and
  A</a></h1>
This is a list of questions and answers about Unicode in Perl, intended to be
  read after perlunitut.
<section class="Ss">
<h2 class="Ss" id="perlunitut_isn't_really_a_Unicode_tutorial,_is_it?"><a class="permalink" href="#perlunitut_isn't_really_a_Unicode_tutorial,_is_it?">perlunitut
  isn't really a Unicode tutorial, is it?</a></h2>
No, and this isn't really a Unicode FAQ.
<p class="Pp">Perl has an abstracted interface for all supported character
    encodings, so this is actually a generic
    <span class="Li">&quot;Encode&quot;</span> tutorial and
    <span class="Li">&quot;Encode&quot;</span> FAQ. But many people think that
    Unicode is special and magical, and I didn't want to disappoint them, so I
    decided to call the document a Unicode tutorial.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="What_character_encodings_does_Perl_support?"><a class="permalink" href="#What_character_encodings_does_Perl_support?">What
  character encodings does Perl support?</a></h2>
To find out which character encodings your Perl supports, run:
<p class="Pp"><span class="Li"></span></p>
<pre>
    perl -MEncode -le &quot;print for Encode-&gt;encodings(':all')&quot;
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Which_version_of_perl_should_I_use?"><a class="permalink" href="#Which_version_of_perl_should_I_use?">Which
  version of perl should I use?</a></h2>
Well, if you can, upgrade to the most recent, but certainly
  <span class="Li">5.8.1</span> or newer. The tutorial and FAQ assume the latest
  release.
<p class="Pp">You should also check your modules, and upgrade them if necessary.
    For example, HTML::Entities requires version &gt;= 1.32 to function
    correctly, even though the changelog is silent about this.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="What_about_binary_data,_like_images?"><a class="permalink" href="#What_about_binary_data,_like_images?">What
  about binary data, like images?</a></h2>
Well, apart from a bare <span class="Li">&quot;binmode $fh&quot;</span>, you
  shouldn't treat them specially. (The binmode is needed because otherwise Perl
  may convert line endings on Win32 systems.)
<p class="Pp">Be careful, though, to never combine text strings with binary
    strings. If you need text in a binary stream, encode your text strings first
    using the appropriate encoding, then join them with binary strings. See
    also: &quot;What if I don't encode?&quot;.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="When_should_I_decode_or_encode?"><a class="permalink" href="#When_should_I_decode_or_encode?">When
  should I decode or encode?</a></h2>
Whenever you're communicating text with anything that is external to your perl
  process, like a database, a text file, a socket, or another program. Even if
  the thing you're communicating with is also written in Perl.
</section>
<section class="Ss">
<h2 class="Ss" id="What_if_I_don't_decode?"><a class="permalink" href="#What_if_I_don't_decode?">What
  if I don't decode?</a></h2>
Whenever your encoded, binary string is used together with a text string, Perl
  will assume that your binary string was encoded with ISO-8859-1, also known as
  latin-1. If it wasn't latin-1, then your data is unpleasantly converted. For
  example, if it was UTF-8, the individual bytes of multibyte characters are
  seen as separate characters, and then again converted to UTF-8. Such double
  encoding can be compared to double HTML encoding
  (<span class="Li">&quot;&amp;amp;gt;&quot;</span>), or double URI encoding
  (<span class="Li">%253E</span>).
<p class="Pp">This silent implicit decoding is known as &quot;upgrading&quot;.
    That may sound positive, but it's best to avoid it.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="What_if_I_don't_encode?"><a class="permalink" href="#What_if_I_don't_encode?">What
  if I don't encode?</a></h2>
Your text string will be sent using the bytes in Perl's internal format. In some
  cases, Perl will warn you that you're doing something wrong, with a friendly
  warning:
<p class="Pp"><span class="Li"></span></p>
<pre>
    Wide character in print at example.pl line 2.
</pre>
<p class="Pp">Because the internal format is often UTF-8, these bugs are hard to
    spot, because UTF-8 is usually the encoding you wanted! But don't be lazy,
    and don't use the fact that Perl's internal format is UTF-8 to your
    advantage. Encode explicitly to avoid weird bugs, and to show to maintenance
    programmers that you thought this through.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Is_there_a_way_to_automatically_decode_or_encode?"><a class="permalink" href="#Is_there_a_way_to_automatically_decode_or_encode?">Is
  there a way to automatically decode or encode?</a></h2>
If all data that comes from a certain handle is encoded in exactly the same way,
  you can tell the PerlIO system to automatically decode everything, with the
  <span class="Li">&quot;encoding&quot;</span> layer. If you do this, you can't
  accidentally forget to decode or encode anymore, on things that use the
  layered handle.
<p class="Pp">You can provide this layer when
    <span class="Li">&quot;open&quot;</span>ing the file:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  open my $fh, '&gt;:encoding(UTF-8)', $filename;  # auto encoding on write
  open my $fh, '&lt;:encoding(UTF-8)', $filename;  # auto decoding on read
</pre>
<p class="Pp">Or if you already have an open filehandle:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  binmode $fh, ':encoding(UTF-8)';
</pre>
<p class="Pp">Some database drivers for DBI can also automatically encode and
    decode, but that is sometimes limited to the UTF-8 encoding.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="What_if_I_don't_know_which_encoding_was_used?"><a class="permalink" href="#What_if_I_don't_know_which_encoding_was_used?">What
  if I don't know which encoding was used?</a></h2>
Do whatever you can to find out, and if you have to: guess. (Don't forget to
  document your guess with a comment.)
<p class="Pp">You could open the document in a web browser, and change the
    character set or character encoding until you can visually confirm that all
    characters look the way they should.</p>
<p class="Pp">There is no way to reliably detect the encoding automatically, so
    if people keep sending you data without charset indication, you may have to
    educate them.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Can_I_use_Unicode_in_my_Perl_sources?"><a class="permalink" href="#Can_I_use_Unicode_in_my_Perl_sources?">Can
  I use Unicode in my Perl sources?</a></h2>
Yes, you can! If your sources are UTF-8 encoded, you can indicate that with the
  <span class="Li">&quot;use utf8&quot;</span> pragma.
<p class="Pp"><span class="Li"></span></p>
<pre>
    use utf8;
</pre>
<p class="Pp">This doesn't do anything to your input, or to your output. It only
    influences the way your sources are read. You can use Unicode in string
    literals, in identifiers (but they still have to be &quot;word
    characters&quot; according to <span class="Li">&quot;\w&quot;</span>), and
    even in custom delimiters.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Data::Dumper_doesn't_restore_the__s-1UTF8_s0_flag;_is_it_broken?"><a class="permalink" href="#Data::Dumper_doesn't_restore_the__s-1UTF8_s0_flag;_is_it_broken?">Data::Dumper
  doesn't restore the UTF8 flag; is it broken?</a></h2>
No, Data::Dumper's Unicode abilities are as they should be. There have been some
  complaints that it should restore the UTF8 flag when the data is read again
  with <span class="Li">&quot;eval&quot;</span>. However, you should really not
  look at the flag, and nothing indicates that Data::Dumper should break this
  rule.
<p class="Pp">Here's what happens: when Perl reads in a string literal, it
    sticks to 8 bit encoding as long as it can. (But perhaps originally it was
    internally encoded as UTF-8, when you dumped it.) When it has to give that
    up because other characters are added to the text string, it silently
    upgrades the string to UTF-8.</p>
<p class="Pp">If you properly encode your strings for output, none of this is of
    your concern, and you can just <span class="Li">&quot;eval&quot;</span>
    dumped data as always.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Why_do_regex_character_classes_sometimes_match_only_in_the__s-1ASCII_s0_range?"><a class="permalink" href="#Why_do_regex_character_classes_sometimes_match_only_in_the__s-1ASCII_s0_range?">Why
  do regex character classes sometimes match only in the ASCII range?</a></h2>
Starting in Perl 5.14 (and partially in Perl 5.12), just put a
  <span class="Li">&quot;use feature 'unicode_strings'&quot;</span> near the
  beginning of your program. Within its lexical scope you shouldn't have this
  problem. It also is automatically enabled under <span class="Li">&quot;use
  feature ':5.12'&quot;</span> or <span class="Li">&quot;use v5.12&quot;</span>
  or using <span class="Li">&quot;-E&quot;</span> on the command line for Perl
  5.12 or higher.
<p class="Pp">The rationale for requiring this is to not break older programs
    that rely on the way things worked before Unicode came along. Those older
    programs knew only about the ASCII character set, and so may not work
    properly for additional characters. When a string is encoded in UTF-8, Perl
    assumes that the program is prepared to deal with Unicode, but when the
    string isn't, Perl assumes that only ASCII is wanted, and so those
    characters that are not ASCII characters aren't recognized as to what they
    would be in Unicode. <span class="Li">&quot;use feature
    'unicode_strings'&quot;</span> tells Perl to treat all characters as
    Unicode, whether the string is encoded in UTF-8 or not, thus avoiding the
    problem.</p>
<p class="Pp">However, on earlier Perls, or if you pass strings to subroutines
    outside the feature's scope, you can force Unicode rules by changing the
    encoding to UTF-8 by doing
    <span class="Li">&quot;utf8::upgrade($string)&quot;</span>. This can be used
    safely on any string, as it checks and does not change strings that have
    already been upgraded.</p>
<p class="Pp">For a more detailed discussion, see Unicode::Semantics on
  CPAN.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Why_do_some_characters_not_uppercase_or_lowercase_correctly?"><a class="permalink" href="#Why_do_some_characters_not_uppercase_or_lowercase_correctly?">Why
  do some characters not uppercase or lowercase correctly?</a></h2>
See the answer to the previous question.
</section>
<section class="Ss">
<h2 class="Ss" id="How_can_I_determine_if_a_string_is_a_text_string_or_a_binary_string?"><a class="permalink" href="#How_can_I_determine_if_a_string_is_a_text_string_or_a_binary_string?">How
  can I determine if a string is a text string or a binary string?</a></h2>
You can't. Some use the UTF8 flag for this, but that's misuse, and makes well
  behaved modules like Data::Dumper look bad. The flag is useless for this
  purpose, because it's off when an 8 bit encoding (by default ISO-8859-1) is
  used to store the string.
<p class="Pp">This is something you, the programmer, has to keep track of;
    sorry. You could consider adopting a kind of &quot;Hungarian notation&quot;
    to help with this.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="How_do_I_convert_from_encoding__s-1FOO_s0_to_encoding__s-1BAR_s0?"><a class="permalink" href="#How_do_I_convert_from_encoding__s-1FOO_s0_to_encoding__s-1BAR_s0?">How
  do I convert from encoding FOO to encoding BAR?</a></h2>
By first converting the FOO-encoded byte string to a text string, and then the
  text string to a BAR-encoded byte string:
<p class="Pp"><span class="Li"></span></p>
<pre>
    my $text_string = decode('FOO', $foo_string);
    my $bar_string  = encode('BAR', $text_string);
</pre>
<p class="Pp">or by skipping the text string part, and going directly from one
    binary encoding to the other:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    use Encode qw(from_to);
    from_to($string, 'FOO', 'BAR');  # changes contents of $string
</pre>
<p class="Pp">or by letting automatic decoding and encoding do all the work:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    open my $foofh, '&lt;:encoding(FOO)', 'example.foo.txt';
    open my $barfh, '&gt;:encoding(BAR)', 'example.bar.txt';
    print { $barfh } $_ while &lt;$foofh&gt;;
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="What_are__decode_utf8__and__encode_utf8_?"><a class="permalink" href="#What_are__decode_utf8__and__encode_utf8_?">What
  are &quot;decode_utf8&quot; and &quot;encode_utf8&quot;?</a></h2>
These are alternate syntaxes for <span class="Li">&quot;decode('utf8',
  ...)&quot;</span> and <span class="Li">&quot;encode('utf8',</span>
  <span class="Li">...)&quot;</span>. Do not use these functions for data
  exchange. Instead use <span class="Li">&quot;decode('UTF-8', ...)&quot;</span>
  and <span class="Li">&quot;encode('UTF-8', ...)&quot;</span>; see &quot;What's
  the difference between UTF-8 and utf8?&quot; below.
</section>
<section class="Ss">
<h2 class="Ss" id="What_is_a__wide_character_?"><a class="permalink" href="#What_is_a__wide_character_?">What
  is a &quot;wide character&quot;?</a></h2>
This is a term used for characters occupying more than one byte.
<p class="Pp">The Perl warning &quot;Wide character in ...&quot; is caused by
    such a character. With no specified encoding layer, Perl tries to fit things
    into a single byte. When it can't, it emits this warning (if warnings are
    enabled), and uses UTF-8 encoded data instead.</p>
<p class="Pp">To avoid this warning and to avoid having different output
    encodings in a single stream, always specify an encoding explicitly, for
    example with a PerlIO layer:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    binmode STDOUT, &quot;:encoding(UTF-8)&quot;;
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="INTERNALS"><a class="permalink" href="#INTERNALS">INTERNALS</a></h1>
<section class="Ss">
<h2 class="Ss" id="What_is__the__s-1UTF8_s0_flag_?"><a class="permalink" href="#What_is__the__s-1UTF8_s0_flag_?">What
  is &quot;the UTF8 flag&quot;?</a></h2>
Please, unless you're hacking the internals, or debugging weirdness, don't think
  about the UTF8 flag at all. That means that you very probably shouldn't use
  <span class="Li">&quot;is_utf8&quot;</span>,
  <span class="Li">&quot;_utf8_on&quot;</span> or
  <span class="Li">&quot;_utf8_off&quot;</span> at all.
<p class="Pp">The UTF8 flag, also called SvUTF8, is an internal flag that
    indicates that the current internal representation is UTF-8. Without the
    flag, it is assumed to be ISO-8859-1. Perl converts between these
    automatically. (Actually Perl usually assumes the representation is ASCII;
    see &quot;Why do regex character classes sometimes match only in the ASCII
    range?&quot; above.)</p>
<p class="Pp">One of Perl's internal formats happens to be UTF-8. Unfortunately,
    Perl can't keep a secret, so everyone knows about this. That is the source
    of much confusion. It's better to pretend that the internal format is some
    unknown encoding, and that you always have to encode and decode
  explicitly.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="What_about_the__use_bytes__pragma?"><a class="permalink" href="#What_about_the__use_bytes__pragma?">What
  about the &quot;use bytes&quot; pragma?</a></h2>
Don't use it. It makes no sense to deal with bytes in a text string, and it
  makes no sense to deal with characters in a byte string. Do the proper
  conversions (by decoding/encoding), and things will work out well: you get
  character counts for decoded data, and byte counts for encoded data.
<p class="Pp"><span class="Li">&quot;use bytes&quot;</span> is usually a failed
    attempt to do something useful. Just forget about it.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="What_about_the__use_encoding__pragma?"><a class="permalink" href="#What_about_the__use_encoding__pragma?">What
  about the &quot;use encoding&quot; pragma?</a></h2>
Don't use it. Unfortunately, it assumes that the programmer's environment and
  that of the user will use the same encoding. It will use the same encoding for
  the source code and for STDIN and STDOUT. When a program is copied to another
  machine, the source code does not change, but the STDIO environment might.
<p class="Pp">If you need non-ASCII characters in your source code, make it a
    UTF-8 encoded file and <span class="Li">&quot;use utf8&quot;</span>.</p>
<p class="Pp">If you need to set the encoding for STDIN, STDOUT, and STDERR, for
    example based on the user's locale, <span class="Li">&quot;use
    open&quot;</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="What_is_the_difference_between__:encoding__and__:utf8_?"><a class="permalink" href="#What_is_the_difference_between__:encoding__and__:utf8_?">What
  is the difference between &quot;:encoding&quot; and
  &quot;:utf8&quot;?</a></h2>
Because UTF-8 is one of Perl's internal formats, you can often just skip the
  encoding or decoding step, and manipulate the UTF8 flag directly.
<p class="Pp">Instead of <span class="Li">&quot;:encoding(UTF-8)&quot;</span>,
    you can simply use <span class="Li">&quot;:utf8&quot;</span>, which skips
    the encoding step if the data was already represented as UTF8 internally.
    This is widely accepted as good behavior when you're writing, but it can be
    dangerous when reading, because it causes internal inconsistency when you
    have invalid byte sequences. Using <span class="Li">&quot;:utf8&quot;</span>
    for input can sometimes result in security breaches, so please use
    <span class="Li">&quot;:encoding(UTF-8)&quot;</span> instead.</p>
<p class="Pp">Instead of <span class="Li">&quot;decode&quot;</span> and
    <span class="Li">&quot;encode&quot;</span>, you could use
    <span class="Li">&quot;_utf8_on&quot;</span> and
    <span class="Li">&quot;_utf8_off&quot;</span>, but this is considered bad
    style. Especially <span class="Li">&quot;_utf8_on&quot;</span> can be
    dangerous, for the same reason that
    <span class="Li">&quot;:utf8&quot;</span> can.</p>
<p class="Pp">There are some shortcuts for oneliners; see -C in perlrun.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="What's_the_difference_between__UTF_-8__and__utf8_?"><a class="permalink" href="#What's_the_difference_between__UTF_-8__and__utf8_?">What's
  the difference between &quot;UTF-8&quot; and &quot;utf8&quot;?</a></h2>
<span class="Li">&quot;UTF-8&quot;</span> is the official standard.
  <span class="Li">&quot;utf8&quot;</span> is Perl's way of being liberal in
  what it accepts. If you have to communicate with things that aren't so
  liberal, you may want to consider using
  <span class="Li">&quot;UTF-8&quot;</span>. If you have to communicate with
  things that are too liberal, you may have to use
  <span class="Li">&quot;utf8&quot;</span>. The full explanation is in
  &quot;UTF-8 vs. utf8 vs. UTF8&quot; in Encode.
<p class="Pp"><span class="Li">&quot;UTF-8&quot;</span> is internally known as
    <span class="Li">&quot;utf-8-strict&quot;</span>. The tutorial uses UTF-8
    consistently, even where utf8 is actually used internally, because the
    distinction can be hard to make, and is mostly irrelevant.</p>
<p class="Pp">For example, utf8 can be used for code points that don't exist in
    Unicode, like 9999999, but if you encode that to UTF-8, you get a
    substitution character (by default; see &quot;Handling Malformed Data&quot;
    in Encode for more ways of dealing with this.)</p>
<p class="Pp">Okay, if you insist: the &quot;internal format&quot; is utf8, not
    UTF-8. (When it's not some other encoding.)</p>
</section>
<section class="Ss">
<h2 class="Ss" id="I_lost_track;_what_encoding_is_the_internal_format_really?"><a class="permalink" href="#I_lost_track;_what_encoding_is_the_internal_format_really?">I
  lost track; what encoding is the internal format really?</a></h2>
It's good that you lost track, because you shouldn't depend on the internal
  format being any specific encoding. But since you asked: by default, the
  internal format is either ISO-8859-1 (latin-1), or utf8, depending on the
  history of the string. On EBCDIC platforms, this may be different even.
<p class="Pp">Perl knows how it stored the string internally, and will use that
    knowledge when you <span class="Li">&quot;encode&quot;</span>. In other
    words: don't try to find out what the internal encoding for a certain string
    is, but instead just encode it into the encoding that you want.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
Juerd Waalboer &lt;#####@juerd.nl&gt;
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
perlunicode, perluniintro, Encode
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2019-10-24</td>
    <td class="foot-os">perl v5.30.2</td>
  </tr>
</table>
</body>
</html>
