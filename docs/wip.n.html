<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Generated from file '/System/Volumes/Data/SWE/macOS/BuildRoots/c40be6c978/Library/Caches/com.apple.xbs/Sources/tcl/tcl-134/tcl_ext/tcllib/tcllib/modules/wip/wip.man' by tcllib/doctools with format 'nroff'
   Copyright (c) 2007-2010 Andreas Kupries <andreas_kupries@users.sourceforge.net>
  
   The definitions below are for supplemental macros used in Tcl/Tk
   manual entries.
  
   .AP type name in/out ?indent?
  	Start paragraph describing an argument to a library procedure.
  	type is type of argument (int, etc.), in/out is either "in", "out",
  	or "in/out" to describe whether procedure reads or modifies arg,
  	and indent is equivalent to second arg of .IP (shouldn't ever be
  	needed;  use .AS below instead)
  
   .AS ?type? ?name?
  	Give maximum sizes of arguments for setting tab stops.  Type and
  	name are examples of largest possible arguments that will be passed
  	to .AP later.  If args are omitted, default tab stops are used.
  
   .BS
  	Start box enclosure.  From here until next .BE, everything will be
  	enclosed in one large box.
  
   .BE
  	End of box enclosure.
  
   .CS
  	Begin code excerpt.
  
   .CE
  	End code excerpt.
  
   .VS ?version? ?br?
  	Begin vertical sidebar, for use in marking newly-changed parts
  	of man pages.  The first argument is ignored and used for recording
  	the version when the .VS was added, so that the sidebars can be
  	found and removed when they reach a certain age.  If another argument
  	is present, then a line break is forced before starting the sidebar.
  
   .VE
  	End of vertical sidebar.
  
   .DS
  	Begin an indented unfilled display.
  
   .DE
  	End of indented unfilled display.
  
   .SO
  	Start of list of standard options for a Tk widget.  The
  	options follow on successive lines, in four columns separated
  	by tabs.
  
   .SE
  	End of list of standard options for a Tk widget.
  
   .OP cmdName dbName dbClass
  	Start of description of a specific option.  cmdName gives the
  	option's name as specified in the class command, dbName gives
  	the option's name in the option database, and dbClass gives
  	the option's class in the option database.
  
   .UL arg1 arg2
  	Print arg1 underlined, then print arg2 normally.
  
   RCS: @(#) $Id: man.macros,v 1.1 2009/01/30 04:56:47 andreas_kupries Exp $
  
  	# Set up traps and other miscellaneous stuff for Tcl/Tk man pages.
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    .Nd, .Bf, .Op { display: inline; }
    .Pa, .Ad { font-style: italic; }
    .Ms { font-weight: bold; }
    .Bl-diag > dt { font-weight: bold; }
    code.Nm, .Fl, .Cm, .Ic, code.In, .Fd, .Fn, .Cd { font-weight: bold;
      font-family: inherit; }
  </style>
  <title>wip(n)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">wip(n)</td>
    <td class="head-vol">Word Interpreter</td>
    <td class="head-rtitle">wip(n)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<pre>
</pre>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">wip - Word Interpreter</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<p class="Pp">package require <b>Tcl 8.4</b></p>
<p class="Pp">package require <b>wip ?2.2?</b></p>
<p class="Pp">package require <b>snit ?1.3?</b></p>
<p class="Pp">package require <b>struct::set </b></p>
<p class="Pp"><b>::wip</b> <i>wipName</i> <i>engine</i> <i>arg</i>...</p>
<p class="Pp"><b>def</b> <i>name</i></p>
<p class="Pp"><b>def</b> <i>name</i> <i>method_prefix</i></p>
<p class="Pp"><b>wipName</b> <i>option</i> ?<i>arg arg ...</i>?</p>
<p class="Pp"><b>wip::dsl</b> ?<i>suffix</i>?</p>
<p class="Pp"><i>wipName</i> <b>def</b> <i>name</i> ?<i>method_prefix</i>?</p>
<p class="Pp"><i>wipName</i> <b>defl</b> <i>names</i></p>
<p class="Pp"><i>wipName</i> <b>defd</b> <i>dict</i></p>
<p class="Pp"><i>wipName</i> <b>deflva</b> <i>name</i>...</p>
<p class="Pp"><i>wipName</i> <b>defdva</b> (<i>name</i>
  <i>method_prefix</i>)...</p>
<p class="Pp"><i>wipName</i> <b>undefl</b> <i>names</i></p>
<p class="Pp"><i>wipName</i> <b>undefva</b> <i>name</i>...</p>
<p class="Pp"><i>wipName</i> <b>unknown</b> <i>cmdprefix</i></p>
<p class="Pp"><i>wipName</i> <b>runl</b> <i>wordlist</i></p>
<p class="Pp"><i>wipName</i> <b>run</b> <i>word</i>...</p>
<p class="Pp"><i>wipName</i> <b>run_next</b></p>
<p class="Pp"><i>wipName</i> <b>run_next_while</b> <i>acceptable</i></p>
<p class="Pp"><i>wipName</i> <b>run_next_until</b> <i>rejected</i></p>
<p class="Pp"><i>wipName</i> <b>run_next_if</b> <i>acceptable</i></p>
<p class="Pp"><i>wipName</i> <b>run_next_ifnot</b> <i>rejected</i></p>
<p class="Pp"><i>wipName</i> <b>next</b></p>
<p class="Pp"><i>wipName</i> <b>peek</b></p>
<p class="Pp"><i>wipName</i> <b>peekall</b></p>
<p class="Pp"><i>wipName</i> <b>insertl</b> <i>at</i> <i>wordlist</i></p>
<p class="Pp"><i>wipName</i> <b>replacel</b> <i>wordlist</i></p>
<p class="Pp"><i>wipName</i> <b>pushl</b> <i>wordlist</i></p>
<p class="Pp"><i>wipName</i> <b>addl</b> <i>wordlist</i></p>
<p class="Pp"><i>wipName</i> <b>insert</b> <i>at</i> <i>word</i>...</p>
<p class="Pp"><i>wipName</i> <b>replace</b> <i>word</i>...</p>
<p class="Pp"><i>wipName</i> <b>push</b> <i>word</i>...</p>
<p class="Pp"><i>wipName</i> <b>add</b> <i>word</i>...</p>
<p class="Pp"></p>
<pre>
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">This package provides a micro interpreter for lists of words.
    Domain specific languages based on this will have a bit of a Forth feel,
    with the input stream segmented into words and any other structuring left to
    whatever the language desired. Note that we have here in essence only the
    core dispatch loop, and no actual commands whatsoever, making this
    definitely only a Forth feel and not an actual Forth.</p>
<p class="Pp">The idea is derived from Colin McCormack's <b>treeql</b>
    processor, modified to require less boiler plate within the command
    implementations, at the expense of, likely, execution speed. In addition the
    interface between processor core and commands is more complex too.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="GENERAL_BEHAVIOUR"><a class="permalink" href="#GENERAL_BEHAVIOUR">GENERAL
  BEHAVIOUR</a></h1>
<p class="Pp">Word interpreters have a mappping from the names of the language
    commands they shall recognize to the methods in the engine to invoke for
    them, and possibly fixed arguments for these methods. This mapping is
    largely static, however it is possible to change it during the execution of
    a word list (= program).</p>
<p class="Pp">At the time a language command is defined the word interpreter
    will use <b>snit</b>'s introspection capabilities to determine the number of
    arguments expected by the method of the egnine, and together with the number
    of fixed arguments supplied in the method prefix of the mapping it then
    knows how many arguments the language command is expecting. This is the
    command's <i>arity</i>. Variable-argument methods (i.e. with the last
    argument named <i>args</i>) are <i>not</i> allowed and will cause the word
    interpreter to throw an error at definition time.</p>
<p class="Pp">Note that while I said <b>snit</b>'s abilities the engine object
    can be written in any way, as long as it understands the method <b>info
    args</b>, which takes a method name and returns the list of arguments for
    that method.</p>
<p class="Pp">When executing a list of words (aka program) the first word is
    always taken as the name of a language command, and the next words as its
    arguments, per the <i>arity</i> of the command. Command and argument words
    are removed from the list and then associated method of the engine is
    executed with the argument words. The process then repeats using the
    then-first word of the list.</p>
<p class="Pp">Note that the methods implementing the language commands may have
    full access to the list of words and are allowed to manipulate as they see
    fit.</p>
<dl class="Bl-tag">
  <dt>[1]</dt>
  <dd>This means, for example, that while we cannot specify variable-argument
      methods directly they can consume words after their fixed arguments before
      returning to the execution loop. This may be under the control of their
      fixed arguments.</dd>
  <dt>[2]</dt>
  <dd>Another possibility is the use of method <b>run_next</b> and its variants
      to execute commands coming after the current command, changing the order
      of execution.</dd>
  <dt>[3]</dt>
  <dd>Execution can be further changed by use of the program accessor methods
      which allow a command implementation to modify the remaining list of words
      (insert, replace, prepend, append words) without executing them
      immediately.</dd>
  <dt>[4]</dt>
  <dd>At last the basic <b>run</b> methods save and restore an existing list of
      words when used, enabling recursive use from within command
      implementations.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="CLASS_API"><a class="permalink" href="#CLASS_API">CLASS
  API</a></h1>
<p class="Pp">The main command of the package is:</p>
<dl class="Bl-tag">
  <dt><b>::wip</b> <i>wipName</i> <i>engine</i> <i>arg</i>...</dt>
  <dd>The command creates a new word interpreter object with an associated
      global Tcl command whose name is <i>wipName</i>. If however the string
      <b>%AUTO%</b> was used as object name the package will generate its own
      unique name for the object.
    <p class="Pp">The <i>engine</i> is the object the word interpreter will
        dispatch all recognized commands to, and the <i>arg</i>uments are a word
        list which defines an initial mapping from language words to engine
        methods.</p>
    <p class="Pp">The recognized language of this word list is</p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="def"><a class="permalink" href="#def"><b>def</b> <i>name</i></a></dt>
  <dd>Defines <i>name</i> as command of the language, to be mapped to a method
      of the <i>engine</i> having the same name.</dd>
  <dt id="def~2"><a class="permalink" href="#def~2"><b>def</b> <i>name</i>
    <i>method_prefix</i></a></dt>
  <dd>Defines <i>name</i> as command of the language, to be mapped to the method
      of the <i>engine</i> named in the <i>method_prefix</i>.</dd>
</dl>
</div>
<p class="Pp">The returned command may be used to invoke various operations on
    the object. It has the following general form:</p>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="wipName"><a class="permalink" href="#wipName"><b>wipName</b>
    <i>option</i> ?<i>arg arg ...</i>?</a></dt>
  <dd><i>Option</i> and the <i>arg</i>s determine the exact behavior of the
      command.</dd>
</dl>
</div>
<p class="Pp">The package additionally exports the command:</p>
<dl class="Bl-tag">
  <dt id="wip::dsl"><a class="permalink" href="#wip::dsl"><b>wip::dsl</b>
    ?<i>suffix</i>?</a></dt>
  <dd>This command is for use within snit types which wish to use one or more
      wip interpreters as a component. Use within the type definition installs
      most of the boilerplate needed to setup and use a word interpreter.
    <p class="Pp">It installs a component named <i>wip</i>, and a method
        <b>wip_setup</b> for initializing it. This method has to be called from
        within the constructor of the type using the word interpreter. If
        further installs a series of procedures which make the object API of the
        word interpreter directly available to the type's methods, without
        having to specify the component.</p>
    <p class="Pp"><i>Note</i> that this does and cannot install the language to
        interpret, i.e. the mapping from words to engine methods.</p>
    <p class="Pp">It is possible to instantiate multiple word interpreter
        components within a type by using different suffices as arguments to the
        command. In that case the name of the component changes to
        &#x00B4;wip_<b>$suffix</b>', the setup command becomes
        &#x00B4;wip_<b>$suffix</b>_setup' and all the procedures also get the
        suffix &#x00B4;_<b>$suffix</b>'.</p>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="OBJECT_API"><a class="permalink" href="#OBJECT_API">OBJECT
  API</a></h1>
<p class="Pp">The following commands are possible for word interpreter
  objects:</p>
<dl class="Bl-tag">
  <dt id="wipName~2"><a class="permalink" href="#wipName~2"><i>wipName</i>
    <b>def</b> <i>name</i> ?<i>method_prefix</i>?</a></dt>
  <dd>Defines a language command <i>name</i> and maps it to the method named in
      the engine's <i>method_prefix</i>. If the <i>method_prefix</i> name is not
      specified it is simply the name of the language command.</dd>
  <dt id="wipName~3"><a class="permalink" href="#wipName~3"><i>wipName</i>
    <b>defl</b> <i>names</i></a></dt>
  <dd>Defines a series of language commands, specified through the list of
      <i>names</i>, all of which are mapped to engine methods of the same
    name.</dd>
  <dt id="wipName~4"><a class="permalink" href="#wipName~4"><i>wipName</i>
    <b>defd</b> <i>dict</i></a></dt>
  <dd>Defines a series of language commands, specified through the dictionary
      <i>dict</i> of names and method prefixes.</dd>
  <dt id="wipName~5"><a class="permalink" href="#wipName~5"><i>wipName</i>
    <b>deflva</b> <i>name</i>...</a></dt>
  <dd>As method <b>defl</b>, however the list of names is specified through
      multiple arguments.</dd>
  <dt id="wipName~6"><a class="permalink" href="#wipName~6"><i>wipName</i>
    <b>defdva</b> (<i>name</i> <i>method_prefix</i>)...</a></dt>
  <dd>As method <b>defd</b>, however the dictionary of names and method prefixes
      is specified through multiple arguments.</dd>
  <dt id="wipName~7"><a class="permalink" href="#wipName~7"><i>wipName</i>
    <b>undefl</b> <i>names</i></a></dt>
  <dd>Removes the named series of language commands from the mapping.</dd>
  <dt id="wipName~8"><a class="permalink" href="#wipName~8"><i>wipName</i>
    <b>undefva</b> <i>name</i>...</a></dt>
  <dd>As method <b>undefl</b>, however the list of names is specified through
      multiple arguments.</dd>
  <dt id="wipName~9"><a class="permalink" href="#wipName~9"><i>wipName</i>
    <b>unknown</b> <i>cmdprefix</i></a></dt>
  <dd>Sets the handler for unknown words to <i>cmdprefix</i>. This command
      prefix takes one argument, the current word, and either throws some error,
      or returns the result of executing the word, as defined by the handler.
      The default handler simply throws an error.</dd>
  <dt id="wipName~10"><a class="permalink" href="#wipName~10"><i>wipName</i>
    <b>runl</b> <i>wordlist</i></a></dt>
  <dd>Treats the list of words in <i>wordlist</i> as a program and executes the
      contained command one by one. The result of the command executed last is
      returned as the result of this command.
    <p class="Pp">The <i>wordlist</i> is stored in the object for access by the
        other <i>run</i>-methods, and the general program accessor methods (see
        below). A previously stored wordlist is saved during the execution of
        this method and restored before it returns. This enables the recursive
        execution of word lists within word lists.</p>
  </dd>
  <dt id="wipName~11"><a class="permalink" href="#wipName~11"><i>wipName</i>
    <b>run</b> <i>word</i>...</a></dt>
  <dd>As method <b>runl</b>, however the list of words to execute is specified
      through multiple arguments.</dd>
  <dt id="wipName~12"><a class="permalink" href="#wipName~12"><i>wipName</i>
    <b>run_next</b></a></dt>
  <dd>Low-level method. Determines the next word in the list of words, and its
      arguments, and then executes it. The result of the executed word is the
      result of this method.
    <p class="Pp">Exposed for use within command implementations. The methods
        <b>run</b> and <b>runl</b> use it to execute words until their word list
        is exhausted.</p>
  </dd>
  <dt id="wipName~13"><a class="permalink" href="#wipName~13"><i>wipName</i>
    <b>run_next_while</b> <i>acceptable</i></a></dt>
  <dd>Low-level method. Invokes the method <b>run_next</b> as long as the next
      word is in the set of <i>acceptable</i> words, and the program is not
      empty. The result of the command executed last is returned as the result
      of this command.
    <p class="Pp">Exposed for use within command implementations to change the
        order of execution.</p>
  </dd>
  <dt id="wipName~14"><a class="permalink" href="#wipName~14"><i>wipName</i>
    <b>run_next_until</b> <i>rejected</i></a></dt>
  <dd>Low-level method. Invokes the method <b>run_next</b> until the next word
      is in the set of <i>rejected</i> words, and the program is not empty. The
      result of the command executed last is returned as the result of this
      command.
    <p class="Pp">Exposed for use within command implementations to change the
        order of execution.</p>
  </dd>
  <dt id="wipName~15"><a class="permalink" href="#wipName~15"><i>wipName</i>
    <b>run_next_if</b> <i>acceptable</i></a></dt>
  <dd>Low-level method. Invokes the method <b>run_next</b> if the next word is
      in the set of <i>acceptable</i> words, and the program is not empty. The
      result of the command executed last is returned as the result of this
      command.
    <p class="Pp">Exposed for use within command implementations to change the
        order of execution.</p>
  </dd>
  <dt id="wipName~16"><a class="permalink" href="#wipName~16"><i>wipName</i>
    <b>run_next_ifnot</b> <i>rejected</i></a></dt>
  <dd>Low-level method. Invokes the method <b>run_next</b> if the next word is
      not in the set of <i>rejected</i> words, and the program is not empty. The
      result of the command executed last is returned as the result of this
      command.
    <p class="Pp">Exposed for use within command implementations to change the
        order of execution.</p>
  </dd>
  <dt id="wipName~17"><a class="permalink" href="#wipName~17"><i>wipName</i>
    <b>next</b></a></dt>
  <dd>Returns the next word in the programm. The word is also removed.</dd>
  <dt id="wipName~18"><a class="permalink" href="#wipName~18"><i>wipName</i>
    <b>peek</b></a></dt>
  <dd>Returns the next word in the programm without removing it</dd>
  <dt id="wipName~19"><a class="permalink" href="#wipName~19"><i>wipName</i>
    <b>peekall</b></a></dt>
  <dd>Returns the remaining programm in toto.</dd>
  <dt id="wipName~20"><a class="permalink" href="#wipName~20"><i>wipName</i>
    <b>insertl</b> <i>at</i> <i>wordlist</i></a></dt>
  <dd>Basic programm accessor method. Inserts the specified <i>wordlist</i> into
      the program, just before the word at position <i>at</i>. Positions are
      counted from <b>zero</b>.</dd>
  <dt id="wipName~21"><a class="permalink" href="#wipName~21"><i>wipName</i>
    <b>replacel</b> <i>wordlist</i></a></dt>
  <dd>Basic programm accessor method. Replaces the whole stored program with the
      specified <i>wordlist</i>.</dd>
  <dt id="wipName~22"><a class="permalink" href="#wipName~22"><i>wipName</i>
    <b>pushl</b> <i>wordlist</i></a></dt>
  <dd>Program accessor method. The specified <i>wordlist</i> is added to the
      front of the remaining program. Equivalent to
    <p class="Pp"></p>
    <pre>$wip insertl 0 $wordlist</pre>
  </dd>
  <dt id="wipName~23"><a class="permalink" href="#wipName~23"><i>wipName</i>
    <b>addl</b> <i>wordlist</i></a></dt>
  <dd>Program accessor method. The specified <i>wordlist</i> is appended at the
      end of the remaining program. Equivalent to
    <p class="Pp"></p>
    <pre>$wip insertl end $wordlist</pre>
  </dd>
  <dt id="wipName~24"><a class="permalink" href="#wipName~24"><i>wipName</i>
    <b>insert</b> <i>at</i> <i>word</i>...</a></dt>
  <dd>Like method <b>insertl</b>, except the words are specified through
      multiple arguments.</dd>
  <dt id="wipName~25"><a class="permalink" href="#wipName~25"><i>wipName</i>
    <b>replace</b> <i>word</i>...</a></dt>
  <dd>Like method <b>setl</b>, except the words are specified through multiple
      arguments.</dd>
  <dt id="wipName~26"><a class="permalink" href="#wipName~26"><i>wipName</i>
    <b>push</b> <i>word</i>...</a></dt>
  <dd>Like method <b>pushl</b>, except the words are specified through multiple
      arguments.</dd>
  <dt id="wipName~27"><a class="permalink" href="#wipName~27"><i>wipName</i>
    <b>add</b> <i>word</i>...</a></dt>
  <dd>Like method <b>addl</b>, except the words are specified through multiple
      arguments.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="EXAMPLES"><a class="permalink" href="#EXAMPLES">EXAMPLES</a></h1>
<p class="Pp">No examples yet.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="BUGS,_IDEAS,_FEEDBACK"><a class="permalink" href="#BUGS,_IDEAS,_FEEDBACK">BUGS,
  IDEAS, FEEDBACK</a></h1>
<p class="Pp">This document, and the package it describes, will undoubtedly
    contain bugs and other problems. Please report such in the category
    <i>wip</i> of the <i>Tcllib SF Trackers</i>
    [http://sourceforge.net/tracker/?group_id=12883]. Please also report any
    ideas for enhancements you may have for either package and/or
  documentation.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="KEYWORDS"><a class="permalink" href="#KEYWORDS">KEYWORDS</a></h1>
<p class="Pp">interpreter, list, word</p>
</section>
<section class="Sh">
<h1 class="Sh" id="CATEGORY"><a class="permalink" href="#CATEGORY">CATEGORY</a></h1>
<p class="Pp">Programming tools</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT"><a class="permalink" href="#COPYRIGHT">COPYRIGHT</a></h1>
<pre>Copyright (c) 2007-2010 Andreas Kupries &lt;andreas_kupries@users.sourceforge.net&gt;
</pre>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2.2</td>
    <td class="foot-os">wip</td>
  </tr>
</table>
</body>
</html>
