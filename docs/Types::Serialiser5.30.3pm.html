<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    .Nd, .Bf, .Op { display: inline; }
    .Pa, .Ad { font-style: italic; }
    .Ms { font-weight: bold; }
    .Bl-diag > dt { font-weight: bold; }
    code.Nm, .Fl, .Cm, .Ic, code.In, .Fd, .Fn, .Cd { font-weight: bold;
      font-family: inherit; }
  </style>
  <title>Serialiser(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Serialiser(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Serialiser(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Types::Serialiser - simple data types for common serialisation
    formats</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">This module provides some extra datatypes that are used by common
    serialisation formats such as JSON or CBOR. The idea is to have a repository
    of simple/small constants and containers that can be shared by different
    implementations so they become interoperable between each other.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SIMPLE_SCALAR_CONSTANTS"><a class="permalink" href="#SIMPLE_SCALAR_CONSTANTS">SIMPLE
  SCALAR CONSTANTS</a></h1>
<p class="Pp">Simple scalar constants are values that are overloaded to act like
    simple Perl values, but have (class) type to differentiate them from normal
    Perl scalars. This is necessary because these have different representations
    in the serialisation formats.</p>
<section class="Ss">
<h2 class="Ss">BOOLEANS (Types::Serialiser::Boolean class)</h2>
<p class="Pp">This type has only two instances, true and false. A natural
    representation for these in Perl is <span class="Li">1</span> and
    <span class="Li">0</span>, but serialisation formats need to be able to
    differentiate between them and mere numbers.</p>
<dl class="Bl-tag">
  <dt>$Types::Serialiser::true, Types::Serialiser::true</dt>
  <dd>This value represents the &quot;true&quot; value. In most contexts is acts
      like the number <span class="Li">1</span>. It is up to you whether you use
      the variable form (<span class="Li">$Types::Serialiser::true</span>) or
      the constant form
      (<span class="Li">&quot;Types::Serialiser::true&quot;</span>).
    <p class="Pp">The constant is represented as a reference to a scalar
        containing <span class="Li">1</span> - implementations are allowed to
        directly test for this.</p>
  </dd>
  <dt>$Types::Serialiser::false, Types::Serialiser::false</dt>
  <dd>This value represents the &quot;false&quot; value. In most contexts is
      acts like the number <span class="Li">0</span>. It is up to you whether
      you use the variable form
      (<span class="Li">$Types::Serialiser::false</span>) or the constant form
      (<span class="Li">&quot;Types::Serialiser::false&quot;</span>).
    <p class="Pp">The constant is represented as a reference to a scalar
        containing <span class="Li">0</span> - implementations are allowed to
        directly test for this.</p>
  </dd>
  <dt>$is_bool = Types::Serialiser::is_bool $value</dt>
  <dd>Returns true iff the <span class="Li">$value</span> is either
      <span class="Li">$Types::Serialiser::true</span> or
      <span class="Li">$Types::Serialiser::false</span>.
    <p class="Pp">For example, you could differentiate between a perl true value
        and a <span class="Li">&quot;Types::Serialiser::true&quot;</span> by
        using this:</p>
    <p class="Pp"></p>
    <pre>   $value &amp;&amp; Types::Serialiser::is_bool $value
    </pre>
  </dd>
  <dt>$is_true = Types::Serialiser::is_true $value</dt>
  <dd>Returns true iff <span class="Li">$value</span> is
      <span class="Li">$Types::Serialiser::true</span>.</dd>
  <dt>$is_false = Types::Serialiser::is_false $value</dt>
  <dd>Returns false iff <span class="Li">$value</span> is
      <span class="Li">$Types::Serialiser::false</span>.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss">ERROR (Types::Serialiser::Error class)</h2>
<p class="Pp">This class has only a single instance,
    <span class="Li">&quot;error&quot;</span>. It is used to signal an encoding
    or decoding error. In CBOR for example, and object that couldn't be encoded
    will be represented by a CBOR undefined value, which is represented by the
    error value in Perl.</p>
<dl class="Bl-tag">
  <dt>$Types::Serialiser::error, Types::Serialiser::error</dt>
  <dd>This value represents the &quot;error&quot; value. Accessing values of
      this type will throw an exception.
    <p class="Pp">The constant is represented as a reference to a scalar
        containing <span class="Li">&quot;undef&quot;</span> - implementations
        are allowed to directly test for this.</p>
  </dd>
  <dt>$is_error = Types::Serialiser::is_error $value</dt>
  <dd>Returns false iff <span class="Li">$value</span> is
      <span class="Li">$Types::Serialiser::error</span>.</dd>
</dl>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="NOTES_FOR_XS_USERS"><a class="permalink" href="#NOTES_FOR_XS_USERS">NOTES
  FOR XS USERS</a></h1>
<p class="Pp">The recommended way to detect whether a scalar is one of these
    objects is to check whether the stash is the
    <span class="Li">&quot;Types::Serialiser::Boolean&quot;</span> or
    <span class="Li">&quot;Types::Serialiser::Error&quot;</span> stash, and then
    follow the scalar reference to see if it's <span class="Li">1</span> (true),
    <span class="Li">0</span> (false) or
    <span class="Li">&quot;undef&quot;</span> (error).</p>
<p class="Pp">While it is possible to use an isa test, directly comparing stash
    pointers is faster and guaranteed to work.</p>
<p class="Pp">For historical reasons, the
    <span class="Li">&quot;Types::Serialiser::Boolean&quot;</span> stash is just
    an alias for <span class="Li">&quot;JSON::PP::Boolean&quot;</span>. When
    printed, the classname with usually be
    <span class="Li">&quot;JSON::PP::Boolean&quot;</span>, but isa tests and
    stash pointer comparison will normally work correctly (i.e.
    Types::Serialiser::true ISA JSON::PP::Boolean, but also ISA
    Types::Serialiser::Boolean).</p>
</section>
<section class="Sh">
<h1 class="Sh" id="A_GENERIC_OBJECT_SERIALIATION_PROTOCOL"><a class="permalink" href="#A_GENERIC_OBJECT_SERIALIATION_PROTOCOL">A
  GENERIC OBJECT SERIALIATION PROTOCOL</a></h1>
<p class="Pp">This section explains the object serialisation protocol used by
    CBOR::XS. It is meant to be generic enough to support any kind of generic
    object serialiser.</p>
<p class="Pp">This protocol is called &quot;the Types::Serialiser object
    serialisation protocol&quot;.</p>
<section class="Ss">
<h2 class="Ss">ENCODING</h2>
<p class="Pp">When the encoder encounters an object that it cannot otherwise
    encode (for example, CBOR::XS can encode a few special types itself, and
    will first attempt to use the special
    <span class="Li">&quot;TO_CBOR&quot;</span> serialisation protocol), it will
    look up the <span class="Li">&quot;FREEZE&quot;</span> method on the
  object.</p>
<p class="Pp">Note that the <span class="Li">&quot;FREEZE&quot;</span> method
    will normally be called <i>during</i> encoding, and <i>MUST NOT</i> change
    the data structure that is being encoded in any way, or it might cause
    memory corruption or worse.</p>
<p class="Pp">If it exists, it will call it with two arguments: the object to
    serialise, and a constant string that indicates the name of the data model.
    For example CBOR::XS uses <span class="Li">&quot;CBOR&quot;</span>, and the
    JSON and JSON::XS modules (or any other JSON serialiser), would use
    <span class="Li">&quot;JSON&quot;</span> as second argument.</p>
<p class="Pp">The <span class="Li">&quot;FREEZE&quot;</span> method can then
    return zero or more values to identify the object instance. The serialiser
    is then supposed to encode the class name and all of these return values
    (which must be encodable in the format) using the relevant form for Perl
    objects. In CBOR for example, there is a registered tag number for encoded
    perl objects.</p>
<p class="Pp">The values that <span class="Li">&quot;FREEZE&quot;</span> returns
    must be serialisable with the serialiser that calls it. Therefore, it is
    recommended to use simple types such as strings and numbers, and maybe array
    references and hashes (basically, the JSON data model). You can always use a
    more complex format for a specific data model by checking the second
    argument, the data model.</p>
<p class="Pp">The &quot;data model&quot; is not the same as the &quot;data
    format&quot; - the data model indicates what types and kinds of return
    values can be returned from <span class="Li">&quot;FREEZE&quot;</span>. For
    example, in <span class="Li">&quot;CBOR&quot;</span> it is permissible to
    return tagged CBOR values, while JSON does not support these at all, so
    <span class="Li">&quot;JSON&quot;</span> would be a valid (but too limited)
    data model name for <span class="Li">&quot;CBOR::XS&quot;</span>. similarly,
    a serialising format that supports more or less the same data model as JSON
    could use <span class="Li">&quot;JSON&quot;</span> as data model without
    losing anything.</p>
</section>
<section class="Ss">
<h2 class="Ss">DECODING</h2>
<p class="Pp">When the decoder then encounters such an encoded perl object, it
    should look up the <span class="Li">&quot;THAW&quot;</span> method on the
    stored classname, and invoke it with the classname, the constant string to
    identify the data model/data format, and all the return values returned by
    <span class="Li">&quot;FREEZE&quot;</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss">EXAMPLES</h2>
<p class="Pp">See the <span class="Li">&quot;OBJECT SERIALISATION&quot;</span>
    section in the CBOR::XS manpage for more details, an example implementation,
    and code examples.</p>
<p class="Pp">Here is an example
    <span class="Li">&quot;FREEZE&quot;</span>/<span class="Li">&quot;THAW&quot;</span>
    method pair:</p>
<p class="Pp"></p>
<pre>   sub My::Object::FREEZE {
      my ($self, $model) = @_;
      ($self-&gt;{type}, $self-&gt;{id}, $self-&gt;{variant})
   }
   sub My::Object::THAW {
      my ($class, $model, $type, $id, $variant) = @_;
      $class-&gt;new (type =&gt; $type, id =&gt; $id, variant =&gt; $variant)
   }
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="BUGS"><a class="permalink" href="#BUGS">BUGS</a></h1>
<p class="Pp">The use of overload makes this module much heavier than it should
    be (on my system, this module: 4kB RSS, overload: 260kB RSS).</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp">Currently, JSON::XS and CBOR::XS use these types.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<pre> Marc Lehmann &lt;schmorp@schmorp.de&gt;
 http://home.schmorp.de/
</pre>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2013-11-30</td>
    <td class="foot-os">perl v5.30.2</td>
  </tr>
</table>
</body>
</html>
