<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>PERLPERF(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">PERLPERF(1)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">PERLPERF(1)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
perlperf - Perl Performance and Optimization Techniques
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
This is an introduction to the use of performance and optimization techniques
  which can be used with particular reference to perl programs. While many perl
  developers have come from other languages, and can use their prior knowledge
  where appropriate, there are many other people who might benefit from a few
  perl specific pointers. If you want the condensed version, perhaps the best
  advice comes from the renowned Japanese Samurai, Miyamoto Musashi, who said:
<p class="Pp"><span class="Li"></span></p>
<pre>
    &quot;Do Not Engage in Useless Activity&quot;
</pre>
<p class="Pp">in 1645.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="OVERVIEW"><a class="permalink" href="#OVERVIEW">OVERVIEW</a></h1>
Perhaps the most common mistake programmers make is to attempt to optimize their
  code before a program actually does anything useful - this is a bad idea.
  There's no point in having an extremely fast program that doesn't work. The
  first job is to get a program to <i>correctly</i> do something <b>useful</b>,
  (not to mention ensuring the test suite is fully functional), and only then to
  consider optimizing it. Having decided to optimize existing working code,
  there are several simple but essential steps to consider which are intrinsic
  to any optimization process.
<section class="Ss">
<h2 class="Ss" id="_s-1ONE_STEP_SIDEWAYS_s0"><a class="permalink" href="#_s-1ONE_STEP_SIDEWAYS_s0">ONE
  STEP SIDEWAYS</a></h2>
Firstly, you need to establish a baseline time for the existing code, which
  timing needs to be reliable and repeatable. You'll probably want to use the
  <span class="Li">&quot;Benchmark&quot;</span> or
  <span class="Li">&quot;Devel::NYTProf&quot;</span> modules, or something
  similar, for this step, or perhaps the Unix system
  <span class="Li">&quot;time&quot;</span> utility, whichever is appropriate.
  See the base of this document for a longer list of benchmarking and profiling
  modules, and recommended further reading.
</section>
<section class="Ss">
<h2 class="Ss" id="_s-1ONE_STEP_FORWARD_s0"><a class="permalink" href="#_s-1ONE_STEP_FORWARD_s0">ONE
  STEP FORWARD</a></h2>
Next, having examined the program for <i>hot spots</i>, (places where the code
  seems to run slowly), change the code with the intention of making it run
  faster. Using version control software, like
  <span class="Li">&quot;subversion&quot;</span>, will ensure no changes are
  irreversible. It's too easy to fiddle here and fiddle there - don't change too
  much at any one time or you might not discover which piece of code
  <b>really</b> was the slow bit.
</section>
<section class="Ss">
<h2 class="Ss" id="_s-1ANOTHER_STEP_SIDEWAYS_s0"><a class="permalink" href="#_s-1ANOTHER_STEP_SIDEWAYS_s0">ANOTHER
  STEP SIDEWAYS</a></h2>
It's not enough to say: &quot;that will make it run faster&quot;, you have to
  check it. Rerun the code under control of the benchmarking or profiling
  modules, from the first step above, and check that the new code executed the
  <b>same task</b> in <i>less time</i>. Save your work and repeat...
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="GENERAL_GUIDELINES"><a class="permalink" href="#GENERAL_GUIDELINES">GENERAL
  GUIDELINES</a></h1>
The critical thing when considering performance is to remember there is no such
  thing as a <span class="Li">&quot;Golden Bullet&quot;</span>, which is why
  there are no rules, only guidelines.
<p class="Pp">It is clear that inline code is going to be faster than subroutine
    or method calls, because there is less overhead, but this approach has the
    disadvantage of being less maintainable and comes at the cost of greater
    memory usage - there is no such thing as a free lunch. If you are searching
    for an element in a list, it can be more efficient to store the data in a
    hash structure, and then simply look to see whether the key is defined,
    rather than to loop through the entire array using <i>grep()</i> for
    instance. <i>substr()</i> may be (a lot) faster than <i>grep()</i> but not
    as flexible, so you have another trade-off to access. Your code may contain
    a line which takes 0.01 of a second to execute which if you call it 1,000
    times, quite likely in a program parsing even medium sized files for
    instance, you already have a 10 second delay, in just one single code
    location, and if you call that line 100,000 times, your entire program will
    slow down to an unbearable crawl.</p>
<p class="Pp">Using a subroutine as part of your sort is a powerful way to get
    exactly what you want, but will usually be slower than the built-in
    <i>alphabetic</i> <span class="Li">&quot;cmp&quot;</span> and <i>numeric</i>
    <span class="Li">&quot;&lt;=&gt;&quot;</span> sort operators. It is possible
    to make multiple passes over your data, building indices to make the
    upcoming sort more efficient, and to use what is known as the
    <span class="Li">&quot;OM&quot;</span> (Orcish Maneuver) to cache the sort
    keys in advance. The cache lookup, while a good idea, can itself be a source
    of slowdown by enforcing a double pass over the data - once to setup the
    cache, and once to sort the data. Using
    <span class="Li">&quot;pack()&quot;</span> to extract the required sort key
    into a consistent string can be an efficient way to build a single string to
    compare, instead of using multiple sort keys, which makes it possible to use
    the standard, written in <span class="Li">&quot;c&quot;</span> and fast,
    perl <span class="Li">&quot;sort()&quot;</span> function on the output, and
    is the basis of the <span class="Li">&quot;GRT&quot;</span> (Guttman Rossler
    Transform). Some string combinations can slow the
    <span class="Li">&quot;GRT&quot;</span> down, by just being too plain
    complex for it's own good.</p>
<p class="Pp">For applications using database backends, the standard
    <span class="Li">&quot;DBIx&quot;</span> namespace has tries to help with
    keeping things nippy, not least because it tries to <i>not</i> query the
    database until the latest possible moment, but always read the docs which
    come with your choice of libraries. Among the many issues facing developers
    dealing with databases should remain aware of is to always use
    <span class="Li">&quot;SQL&quot;</span> placeholders and to consider
    pre-fetching data sets when this might prove advantageous. Splitting up a
    large file by assigning multiple processes to parsing a single file, using
    say <span class="Li">&quot;POE&quot;</span>,
    <span class="Li">&quot;threads&quot;</span> or
    <span class="Li">&quot;fork&quot;</span> can also be a useful way of
    optimizing your usage of the available
    <span class="Li">&quot;CPU&quot;</span> resources, though this technique is
    fraught with concurrency issues and demands high attention to detail.</p>
<p class="Pp">Every case has a specific application and one or more exceptions,
    and there is no replacement for running a few tests and finding out which
    method works best for your particular environment, this is why writing
    optimal code is not an exact science, and why we love using Perl so much -
    TMTOWTDI.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="BENCHMARKS"><a class="permalink" href="#BENCHMARKS">BENCHMARKS</a></h1>
Here are a few examples to demonstrate usage of Perl's benchmarking tools.
<section class="Ss">
<h2 class="Ss" id="Assigning_and_Dereferencing_Variables."><a class="permalink" href="#Assigning_and_Dereferencing_Variables.">Assigning
  and Dereferencing Variables.</a></h2>
I'm sure most of us have seen code which looks like, (or worse than), this:
<p class="Pp"><span class="Li"></span></p>
<pre>
    if ( $obj-&gt;{_ref}-&gt;{_myscore} &gt;= $obj-&gt;{_ref}-&gt;{_yourscore} ) {
        ...
</pre>
<p class="Pp">This sort of code can be a real eyesore to read, as well as being
    very sensitive to typos, and it's much clearer to dereference the variable
    explicitly. We're side-stepping the issue of working with object-oriented
    programming techniques to encapsulate variable access via methods, only
    accessible through an object. Here we're just discussing the technical
    implementation of choice, and whether this has an effect on performance. We
    can see whether this dereferencing operation, has any overhead by putting
    comparative code in a file and running a
    <span class="Li">&quot;Benchmark&quot;</span> test.</p>
<p class="Pp"># dereference</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    #!/usr/bin/perl

    use strict;
    use warnings;

    use Benchmark;

    my $ref = {
            'ref'   =&gt; {
                _myscore    =&gt; '100 + 1',
                _yourscore  =&gt; '102 - 1',
            },
    };

    timethese(1000000, {
            'direct'       =&gt; sub {
                my $x = $ref-&gt;{ref}-&gt;{_myscore} . $ref-&gt;{ref}-&gt;{_yourscore} ;
            },
            'dereference'  =&gt; sub {
                my $ref  = $ref-&gt;{ref};
                my $myscore = $ref-&gt;{_myscore};
                my $yourscore = $ref-&gt;{_yourscore};
                my $x = $myscore . $yourscore;
            },
    });
</pre>
<p class="Pp">It's essential to run any timing measurements a sufficient number
    of times so the numbers settle on a numerical average, otherwise each run
    will naturally fluctuate due to variations in the environment, to reduce the
    effect of contention for <span class="Li">&quot;CPU&quot;</span> resources
    and network bandwidth for instance. Running the above code for one million
    iterations, we can take a look at the report output by the
    <span class="Li">&quot;Benchmark&quot;</span> module, to see which approach
    is the most effective.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    $&gt; perl dereference

    Benchmark: timing 1000000 iterations of dereference, direct...
    dereference:  2 wallclock secs ( 1.59 usr +  0.00 sys =  1.59 CPU) @ 628930.82/s (n=1000000)
        direct:  1 wallclock secs ( 1.20 usr +  0.00 sys =  1.20 CPU) @ 833333.33/s (n=1000000)
</pre>
<p class="Pp">The difference is clear to see and the dereferencing approach is
    slower. While it managed to execute an average of 628,930 times a second
    during our test, the direct approach managed to run an additional 204,403
    times, unfortunately. Unfortunately, because there are many examples of code
    written using the multiple layer direct variable access, and it's usually
    horrible. It is, however, minusculy faster. The question remains whether the
    minute gain is actually worth the eyestrain, or the loss of
  maintainability.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Search_and_replace_or_tr"><a class="permalink" href="#Search_and_replace_or_tr">Search
  and replace or tr</a></h2>
If we have a string which needs to be modified, while a regex will almost always
  be much more flexible, <span class="Li">&quot;tr&quot;</span>, an oft
  underused tool, can still be a useful. One scenario might be replace all
  vowels with another character. The regex solution might look like this:
<p class="Pp"><span class="Li"></span></p>
<pre>
    $str =~ s/[aeiou]/x/g
</pre>
<p class="Pp">The <span class="Li">&quot;tr&quot;</span> alternative might look
    like this:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    $str =~ tr/aeiou/xxxxx/
</pre>
<p class="Pp">We can put that into a test file which we can run to check which
    approach is the fastest, using a global <span class="Li">$STR</span>
    variable to assign to the <span class="Li">&quot;my $str&quot;</span>
    variable so as to avoid perl trying to optimize any of the work away by
    noticing it's assigned only the once.</p>
<p class="Pp"># regex-transliterate</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    #!/usr/bin/perl

    use strict;
    use warnings;

    use Benchmark;

    my $STR = &quot;$$-this and that&quot;;

    timethese( 1000000, {
            'sr'  =&gt; sub { my $str = $STR; $str =~ s/[aeiou]/x/g; return $str; },
            'tr'  =&gt; sub { my $str = $STR; $str =~ tr/aeiou/xxxxx/; return $str; },
    });
</pre>
<p class="Pp">Running the code gives us our results:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    $&gt; perl regex-transliterate

    Benchmark: timing 1000000 iterations of sr, tr...
            sr:  2 wallclock secs ( 1.19 usr +  0.00 sys =  1.19 CPU) @ 840336.13/s (n=1000000)
            tr:  0 wallclock secs ( 0.49 usr +  0.00 sys =  0.49 CPU) @ 2040816.33/s (n=1000000)
</pre>
<p class="Pp">The <span class="Li">&quot;tr&quot;</span> version is a clear
    winner. One solution is flexible, the other is fast - and it's appropriately
    the programmer's choice which to use.</p>
<p class="Pp">Check the <span class="Li">&quot;Benchmark&quot;</span> docs for
    further useful techniques.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="PROFILING_TOOLS"><a class="permalink" href="#PROFILING_TOOLS">PROFILING
  TOOLS</a></h1>
A slightly larger piece of code will provide something on which a profiler can
  produce more extensive reporting statistics. This example uses the simplistic
  <span class="Li">&quot;wordmatch&quot;</span> program which parses a given
  input file and spews out a short report on the contents.
<p class="Pp"># wordmatch</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    #!/usr/bin/perl

    use strict;
    use warnings;

    =head1 NAME

    filewords - word analysis of input file

    =head1 SYNOPSIS

        filewords -f inputfilename [-d]

    =head1 DESCRIPTION

    This program parses the given filename, specified with C&lt;-f&gt;, and displays a
    simple analysis of the words found therein.  Use the C&lt;-d&gt; switch to enable
    debugging messages.

    =cut

    use FileHandle;
    use Getopt::Long;

    my $debug   =  0;
    my $file    = '';

    my $result = GetOptions (
        'debug'         =&gt; \$debug,
        'file=s'        =&gt; \$file,
    );
    die(&quot;invalid args&quot;) unless $result;

    unless ( -f $file ) {
        die(&quot;Usage: $0 -f filename [-d]&quot;);
    }
    my $FH = FileHandle-&gt;new(&quot;&lt; $file&quot;) or die(&quot;unable to open file($file): $!&quot;);

    my $i_LINES = 0;
    my $i_WORDS = 0;
    my %count   = ();

    my @lines = &lt;$FH&gt;;
    foreach my $line ( @lines ) {
        $i_LINES++;
        $line =~ s/\n//;
        my @words = split(/ +/, $line);
        my $i_words = scalar(@words);
        $i_WORDS = $i_WORDS + $i_words;
        debug(&quot;line: $i_LINES supplying $i_words words: @words&quot;);
        my $i_word = 0;
        foreach my $word ( @words ) {
            $i_word++;
            $count{$i_LINES}{spec} += matches($i_word, $word, '[^a-zA-Z0-9]');
            $count{$i_LINES}{only} += matches($i_word, $word, '^[^a-zA-Z0-9]+$');
            $count{$i_LINES}{cons} += matches($i_word, $word, '^[(?i:bcdfghjklmnpqrstvwxyz)]+$');
            $count{$i_LINES}{vows} += matches($i_word, $word, '^[(?i:aeiou)]+$');
            $count{$i_LINES}{caps} += matches($i_word, $word, '^[(A-Z)]+$');
        }
    }

    print report( %count );

    sub matches {
        my $i_wd  = shift;
        my $word  = shift;
        my $regex = shift;
        my $has = 0;

        if ( $word =~ /($regex)/ ) {
            $has++ if $1;
        }

        debug(&quot;word: $i_wd &quot;.($has ? 'matches' : 'does not match').&quot; chars: /$regex/&quot;);

        return $has;
    }

    sub report {
        my %report = @_;
        my %rep;

        foreach my $line ( keys %report ) {
            foreach my $key ( keys %{ $report{$line} } ) {
                $rep{$key} += $report{$line}{$key};
            }
        }

        my $report = qq|
    $0 report for $file:
    lines in file: $i_LINES
    words in file: $i_WORDS
    words with special (non-word) characters: $i_spec
    words with only special (non-word) characters: $i_only
    words with only consonants: $i_cons
    words with only capital letters: $i_caps
    words with only vowels: $i_vows
    |;

        return $report;
    }

    sub debug {
        my $message = shift;

        if ( $debug ) {
            print STDERR &quot;DBG: $message\n&quot;;
        }
    }

    exit 0;
</pre>
<section class="Ss">
<h2 class="Ss" id="Devel::DProf"><a class="permalink" href="#Devel::DProf">Devel::DProf</a></h2>
This venerable module has been the de-facto standard for Perl code profiling for
  more than a decade, but has been replaced by a number of other modules which
  have brought us back to the 21st century. Although you're recommended to
  evaluate your tool from the several mentioned here and from the CPAN list at
  the base of this document, (and currently Devel::NYTProf seems to be the
  weapon of choice - see below), we'll take a quick look at the output from
  Devel::DProf first, to set a baseline for Perl profiling tools. Run the above
  program under the control of <span class="Li">&quot;Devel::DProf&quot;</span>
  by using the <span class="Li">&quot;-d&quot;</span> switch on the
  command-line.
<p class="Pp"><span class="Li"></span></p>
<pre>
    $&gt; perl -d:DProf wordmatch -f perl5db.pl

    &lt;...multiple lines snipped...&gt;

    wordmatch report for perl5db.pl:
    lines in file: 9428
    words in file: 50243
    words with special (non-word) characters: 20480
    words with only special (non-word) characters: 7790
    words with only consonants: 4801
    words with only capital letters: 1316
    words with only vowels: 1701
</pre>
<p class="Pp"><span class="Li">&quot;Devel::DProf&quot;</span> produces a
    special file, called <i>tmon.out</i> by default, and this file is read by
    the <span class="Li">&quot;dprofpp&quot;</span> program, which is already
    installed as part of the <span class="Li">&quot;Devel::DProf&quot;</span>
    distribution. If you call <span class="Li">&quot;dprofpp&quot;</span> with
    no options, it will read the <i>tmon.out</i> file in the current directory
    and produce a human readable statistics report of the run of your program.
    Note that this may take a little time.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    $&gt; dprofpp

    Total Elapsed Time = 2.951677 Seconds
      User+System Time = 2.871677 Seconds
    Exclusive Times
    %Time ExclSec CumulS #Calls sec/call Csec/c  Name
     102.   2.945  3.003 251215   0.0000 0.0000  main::matches
     2.40   0.069  0.069 260643   0.0000 0.0000  main::debug
     1.74   0.050  0.050      1   0.0500 0.0500  main::report
     1.04   0.030  0.049      4   0.0075 0.0123  main::BEGIN
     0.35   0.010  0.010      3   0.0033 0.0033  Exporter::as_heavy
     0.35   0.010  0.010      7   0.0014 0.0014  IO::File::BEGIN
     0.00       - -0.000      1        -      -  Getopt::Long::FindOption
     0.00       - -0.000      1        -      -  Symbol::BEGIN
     0.00       - -0.000      1        -      -  Fcntl::BEGIN
     0.00       - -0.000      1        -      -  Fcntl::bootstrap
     0.00       - -0.000      1        -      -  warnings::BEGIN
     0.00       - -0.000      1        -      -  IO::bootstrap
     0.00       - -0.000      1        -      -  Getopt::Long::ConfigDefaults
     0.00       - -0.000      1        -      -  Getopt::Long::Configure
     0.00       - -0.000      1        -      -  Symbol::gensym
</pre>
<p class="Pp"><span class="Li">&quot;dprofpp&quot;</span> will produce some
    quite detailed reporting on the activity of the
    <span class="Li">&quot;wordmatch&quot;</span> program. The wallclock, user
    and system, times are at the top of the analysis, and after this are the
    main columns defining which define the report. Check the
    <span class="Li">&quot;dprofpp&quot;</span> docs for details of the many
    options it supports.</p>
<p class="Pp">See also <span class="Li">&quot;Apache::DProf&quot;</span> which
    hooks <span class="Li">&quot;Devel::DProf&quot;</span> into
    <span class="Li">&quot;mod_perl&quot;</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Devel::Profiler"><a class="permalink" href="#Devel::Profiler">Devel::Profiler</a></h2>
Let's take a look at the same program using a different profiler:
  <span class="Li">&quot;Devel::Profiler&quot;</span>, a drop-in Perl-only
  replacement for <span class="Li">&quot;Devel::DProf&quot;</span>. The usage is
  very slightly different in that instead of using the special
  <span class="Li">&quot;-d:&quot;</span> flag, you pull
  <span class="Li">&quot;Devel::Profiler&quot;</span> in directly as a module
  using <span class="Li">&quot;-M&quot;</span>.
<p class="Pp"><span class="Li"></span></p>
<pre>
    $&gt; perl -MDevel::Profiler wordmatch -f perl5db.pl

    &lt;...multiple lines snipped...&gt;

    wordmatch report for perl5db.pl:
    lines in file: 9428
    words in file: 50243
    words with special (non-word) characters: 20480
    words with only special (non-word) characters: 7790
    words with only consonants: 4801
    words with only capital letters: 1316
    words with only vowels: 1701
</pre>
<p class="Pp"><span class="Li">&quot;Devel::Profiler&quot;</span> generates a
    tmon.out file which is compatible with the
    <span class="Li">&quot;dprofpp&quot;</span> program, thus saving the
    construction of a dedicated statistics reader program.
    <span class="Li">&quot;dprofpp&quot;</span> usage is therefore identical to
    the above example.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    $&gt; dprofpp

    Total Elapsed Time =   20.984 Seconds
      User+System Time =   19.981 Seconds
    Exclusive Times
    %Time ExclSec CumulS #Calls sec/call Csec/c  Name
     49.0   9.792 14.509 251215   0.0000 0.0001  main::matches
     24.4   4.887  4.887 260643   0.0000 0.0000  main::debug
     0.25   0.049  0.049      1   0.0490 0.0490  main::report
     0.00   0.000  0.000      1   0.0000 0.0000  Getopt::Long::GetOptions
     0.00   0.000  0.000      2   0.0000 0.0000  Getopt::Long::ParseOptionSpec
     0.00   0.000  0.000      1   0.0000 0.0000  Getopt::Long::FindOption
     0.00   0.000  0.000      1   0.0000 0.0000  IO::File::new
     0.00   0.000  0.000      1   0.0000 0.0000  IO::Handle::new
     0.00   0.000  0.000      1   0.0000 0.0000  Symbol::gensym
     0.00   0.000  0.000      1   0.0000 0.0000  IO::File::open
</pre>
<p class="Pp">Interestingly we get slightly different results, which is mostly
    because the algorithm which generates the report is different, even though
    the output file format was allegedly identical. The elapsed, user and system
    times are clearly showing the time it took for
    <span class="Li">&quot;Devel::Profiler&quot;</span> to execute its own run,
    but the column listings feel more accurate somehow than the ones we had
    earlier from <span class="Li">&quot;Devel::DProf&quot;</span>. The 102%
    figure has disappeared, for example. This is where we have to use the tools
    at our disposal, and recognise their pros and cons, before using them.
    Interestingly, the numbers of calls for each subroutine are identical in the
    two reports, it's the percentages which differ. As the author of
    <span class="Li">&quot;Devel::Proviler&quot;</span> writes:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    ...running HTML::Template's test suite under Devel::DProf shows output()
    taking NO time but Devel::Profiler shows around 10% of the time is in output().
    I don't know which to trust but my gut tells me something is wrong with
    Devel::DProf.  HTML::Template::output() is a big routine that's called for
    every test. Either way, something needs fixing.
</pre>
<p class="Pp">YMMV.</p>
<p class="Pp">See also
    <span class="Li">&quot;Devel::Apache::Profiler&quot;</span> which hooks
    <span class="Li">&quot;Devel::Profiler&quot;</span> into
    <span class="Li">&quot;mod_perl&quot;</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Devel::SmallProf"><a class="permalink" href="#Devel::SmallProf">Devel::SmallProf</a></h2>
The <span class="Li">&quot;Devel::SmallProf&quot;</span> profiler examines the
  runtime of your Perl program and produces a line-by-line listing to show how
  many times each line was called, and how long each line took to execute. It is
  called by supplying the familiar <span class="Li">&quot;-d&quot;</span> flag
  to Perl at runtime.
<p class="Pp"><span class="Li"></span></p>
<pre>
    $&gt; perl -d:SmallProf wordmatch -f perl5db.pl

    &lt;...multiple lines snipped...&gt;

    wordmatch report for perl5db.pl:
    lines in file: 9428
    words in file: 50243
    words with special (non-word) characters: 20480
    words with only special (non-word) characters: 7790
    words with only consonants: 4801
    words with only capital letters: 1316
    words with only vowels: 1701
</pre>
<p class="Pp"><span class="Li">&quot;Devel::SmallProf&quot;</span> writes it's
    output into a file called <i>smallprof.out</i>, by default. The format of
    the file looks like this:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    &lt;num&gt; &lt;time&gt; &lt;ctime&gt; &lt;line&gt;:&lt;text&gt;
</pre>
<p class="Pp">When the program has terminated, the output may be examined and
    sorted using any standard text filtering utilities. Something like the
    following may be sufficient:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    $&gt; cat smallprof.out | grep \d*: | sort -k3 | tac | head -n20

    251215   1.65674   7.68000    75: if ( $word =~ /($regex)/ ) {
    251215   0.03264   4.40000    79: debug(&quot;word: $i_wd &quot;.($has ? 'matches' :
    251215   0.02693   4.10000    81: return $has;
    260643   0.02841   4.07000   128: if ( $debug ) {
    260643   0.02601   4.04000   126: my $message = shift;
    251215   0.02641   3.91000    73: my $has = 0;
    251215   0.03311   3.71000    70: my $i_wd  = shift;
    251215   0.02699   3.69000    72: my $regex = shift;
    251215   0.02766   3.68000    71: my $word  = shift;
     50243   0.59726   1.00000    59:  $count{$i_LINES}{cons} =
     50243   0.48175   0.92000    61:  $count{$i_LINES}{spec} =
     50243   0.00644   0.89000    56:  my $i_cons = matches($i_word, $word,
     50243   0.48837   0.88000    63:  $count{$i_LINES}{caps} =
     50243   0.00516   0.88000    58:  my $i_caps = matches($i_word, $word, '^[(A-
     50243   0.00631   0.81000    54:  my $i_spec = matches($i_word, $word, '[^a-
     50243   0.00496   0.80000    57:  my $i_vows = matches($i_word, $word,
     50243   0.00688   0.80000    53:  $i_word++;
     50243   0.48469   0.79000    62:  $count{$i_LINES}{only} =
     50243   0.48928   0.77000    60:  $count{$i_LINES}{vows} =
     50243   0.00683   0.75000    55:  my $i_only = matches($i_word, $word, '^[^a-
</pre>
<p class="Pp">You can immediately see a slightly different focus to the
    subroutine profiling modules, and we start to see exactly which line of code
    is taking the most time. That regex line is looking a bit suspicious, for
    example. Remember that these tools are supposed to be used together, there
    is no single best way to profile your code, you need to use the best tools
    for the job.</p>
<p class="Pp">See also <span class="Li">&quot;Apache::SmallProf&quot;</span>
    which hooks <span class="Li">&quot;Devel::SmallProf&quot;</span> into
    <span class="Li">&quot;mod_perl&quot;</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Devel::FastProf"><a class="permalink" href="#Devel::FastProf">Devel::FastProf</a></h2>
<span class="Li">&quot;Devel::FastProf&quot;</span> is another Perl line
  profiler. This was written with a view to getting a faster line profiler, than
  is possible with for example
  <span class="Li">&quot;Devel::SmallProf&quot;</span>, because it's written in
  <span class="Li">&quot;C&quot;</span>. To use
  <span class="Li">&quot;Devel::FastProf&quot;</span>, supply the
  <span class="Li">&quot;-d&quot;</span> argument to Perl:
<p class="Pp"><span class="Li"></span></p>
<pre>
    $&gt; perl -d:FastProf wordmatch -f perl5db.pl

    &lt;...multiple lines snipped...&gt;

    wordmatch report for perl5db.pl:
    lines in file: 9428
    words in file: 50243
    words with special (non-word) characters: 20480
    words with only special (non-word) characters: 7790
    words with only consonants: 4801
    words with only capital letters: 1316
    words with only vowels: 1701
</pre>
<p class="Pp"><span class="Li">&quot;Devel::FastProf&quot;</span> writes
    statistics to the file <i>fastprof.out</i> in the current directory. The
    output file, which can be specified, can be interpreted by using the
    <span class="Li">&quot;fprofpp&quot;</span> command-line program.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    $&gt; fprofpp | head -n20

    # fprofpp output format is:
    # filename:line time count: source
    wordmatch:75 3.93338 251215: if ( $word =~ /($regex)/ ) {
    wordmatch:79 1.77774 251215: debug(&quot;word: $i_wd &quot;.($has ? 'matches' : 'does not match').&quot; chars: /$regex/&quot;);
    wordmatch:81 1.47604 251215: return $has;
    wordmatch:126 1.43441 260643: my $message = shift;
    wordmatch:128 1.42156 260643: if ( $debug ) {
    wordmatch:70 1.36824 251215: my $i_wd  = shift;
    wordmatch:71 1.36739 251215: my $word  = shift;
    wordmatch:72 1.35939 251215: my $regex = shift;
</pre>
<p class="Pp">Straightaway we can see that the number of times each line has
    been called is identical to the
    <span class="Li">&quot;Devel::SmallProf&quot;</span> output, and the
    sequence is only very slightly different based on the ordering of the amount
    of time each line took to execute, <span class="Li">&quot;if ( $debug ) {
    &quot;</span> and <span class="Li">&quot;my $message = shift;&quot;</span>,
    for example. The differences in the actual times recorded might be in the
    algorithm used internally, or it could be due to system resource limitations
    or contention.</p>
<p class="Pp">See also the DBIx::Profile which will profile database queries
    running under the <span class="Li">&quot;DBIx::*&quot;</span> namespace.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Devel::NYTProf"><a class="permalink" href="#Devel::NYTProf">Devel::NYTProf</a></h2>
<span class="Li">&quot;Devel::NYTProf&quot;</span> is the <b>next generation</b>
  of Perl code profiler, fixing many shortcomings in other tools and
  implementing many cool features. First of all it can be used as either a
  <i>line</i> profiler, a <i>block</i> or a <i>subroutine</i> profiler, all at
  once. It can also use sub-microsecond (100ns) resolution on systems which
  provide <span class="Li">&quot;clock_gettime()&quot;</span>. It can be started
  and stopped even by the program being profiled. It's a one-line entry to
  profile <span class="Li">&quot;mod_perl&quot;</span> applications. It's
  written in <span class="Li">&quot;c&quot;</span> and is probably the fastest
  profiler available for Perl. The list of coolness just goes on. Enough of
  that, let's see how to it works - just use the familiar
  <span class="Li">&quot;-d&quot;</span> switch to plug it in and run the code.
<p class="Pp"><span class="Li"></span></p>
<pre>
    $&gt; perl -d:NYTProf wordmatch -f perl5db.pl

    wordmatch report for perl5db.pl:
    lines in file: 9427
    words in file: 50243
    words with special (non-word) characters: 20480
    words with only special (non-word) characters: 7790
    words with only consonants: 4801
    words with only capital letters: 1316
    words with only vowels: 1701
</pre>
<p class="Pp"><span class="Li">&quot;NYTProf&quot;</span> will generate a report
    database into the file <i>nytprof.out</i> by default. Human readable reports
    can be generated from here by using the supplied
    <span class="Li">&quot;nytprofhtml&quot;</span> (HTML output) and
    <span class="Li">&quot;nytprofcsv&quot;</span> (CSV output) programs. We've
    used the Unix system <span class="Li">&quot;html2text&quot;</span> utility
    to convert the <i>nytprof/index.html</i> file for convenience here.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    $&gt; html2text nytprof/index.html

    Performance Profile Index
    For wordmatch
      Run on Fri Sep 26 13:46:39 2008
    Reported on Fri Sep 26 13:47:23 2008

             Top 15 Subroutines -- ordered by exclusive time
    |Calls |P |F |Inclusive|Exclusive|Subroutine                          |
    |      |  |  |Time     |Time     |                                    |
    |251215|5 |1 |13.09263 |10.47692 |main::              |matches        |
    |260642|2 |1 |2.71199  |2.71199  |main::              |debug          |
    |1     |1 |1 |0.21404  |0.21404  |main::              |report         |
    |2     |2 |2 |0.00511  |0.00511  |XSLoader::          |load (xsub)    |
    |14    |14|7 |0.00304  |0.00298  |Exporter::          |import         |
    |3     |1 |1 |0.00265  |0.00254  |Exporter::          |as_heavy       |
    |10    |10|4 |0.00140  |0.00140  |vars::              |import         |
    |13    |13|1 |0.00129  |0.00109  |constant::          |import         |
    |1     |1 |1 |0.00360  |0.00096  |FileHandle::        |import         |
    |3     |3 |3 |0.00086  |0.00074  |warnings::register::|import         |
    |9     |3 |1 |0.00036  |0.00036  |strict::            |bits           |
    |13    |13|13|0.00032  |0.00029  |strict::            |import         |
    |2     |2 |2 |0.00020  |0.00020  |warnings::          |import         |
    |2     |1 |1 |0.00020  |0.00020  |Getopt::Long::      |ParseOptionSpec|
    |7     |7 |6 |0.00043  |0.00020  |strict::            |unimport       |

    For more information see the full list of 189 subroutines.
</pre>
<p class="Pp">The first part of the report already shows the critical
    information regarding which subroutines are using the most time. The next
    gives some statistics about the source files profiled.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
            Source Code Files -- ordered by exclusive time then name
    |Stmts  |Exclusive|Avg.   |Reports                     |Source File         |
    |       |Time     |       |                            |                    |
    |2699761|15.66654 |6e-06  |line   .    block   .    sub|wordmatch           |
    |35     |0.02187  |0.00062|line   .    block   .    sub|IO/Handle.pm        |
    |274    |0.01525  |0.00006|line   .    block   .    sub|Getopt/Long.pm      |
    |20     |0.00585  |0.00029|line   .    block   .    sub|Fcntl.pm            |
    |128    |0.00340  |0.00003|line   .    block   .    sub|Exporter/Heavy.pm   |
    |42     |0.00332  |0.00008|line   .    block   .    sub|IO/File.pm          |
    |261    |0.00308  |0.00001|line   .    block   .    sub|Exporter.pm         |
    |323    |0.00248  |8e-06  |line   .    block   .    sub|constant.pm         |
    |12     |0.00246  |0.00021|line   .    block   .    sub|File/Spec/Unix.pm   |
    |191    |0.00240  |0.00001|line   .    block   .    sub|vars.pm             |
    |77     |0.00201  |0.00003|line   .    block   .    sub|FileHandle.pm       |
    |12     |0.00198  |0.00016|line   .    block   .    sub|Carp.pm             |
    |14     |0.00175  |0.00013|line   .    block   .    sub|Symbol.pm           |
    |15     |0.00130  |0.00009|line   .    block   .    sub|IO.pm               |
    |22     |0.00120  |0.00005|line   .    block   .    sub|IO/Seekable.pm      |
    |198    |0.00085  |4e-06  |line   .    block   .    sub|warnings/register.pm|
    |114    |0.00080  |7e-06  |line   .    block   .    sub|strict.pm           |
    |47     |0.00068  |0.00001|line   .    block   .    sub|warnings.pm         |
    |27     |0.00054  |0.00002|line   .    block   .    sub|overload.pm         |
    |9      |0.00047  |0.00005|line   .    block   .    sub|SelectSaver.pm      |
    |13     |0.00045  |0.00003|line   .    block   .    sub|File/Spec.pm        |
    |2701595|15.73869 |       |Total                       |
    |128647 |0.74946  |       |Average                     |
    |       |0.00201  |0.00003|Median                      |
    |       |0.00121  |0.00003|Deviation                   |

    Report produced by the NYTProf 2.03 Perl profiler, developed by Tim Bunce and
    Adam Kaplan.
</pre>
<p class="Pp">At this point, if you're using the <i>html</i> report, you can
    click through the various links to bore down into each subroutine and each
    line of code. Because we're using the text reporting here, and there's a
    whole directory full of reports built for each source file, we'll just
    display a part of the corresponding <i>wordmatch-line.html</i> file,
    sufficient to give an idea of the sort of output you can expect from this
    cool tool.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    $&gt; html2text nytprof/wordmatch-line.html

    Performance Profile -- -block view-.-line view-.-sub view-
    For wordmatch
    Run on Fri Sep 26 13:46:39 2008
    Reported on Fri Sep 26 13:47:22 2008

    File wordmatch

     Subroutines -- ordered by exclusive time
    |Calls |P|F|Inclusive|Exclusive|Subroutine    |
    |      | | |Time     |Time     |              |
    |251215|5|1|13.09263 |10.47692 |main::|matches|
    |260642|2|1|2.71199  |2.71199  |main::|debug  |
    |1     |1|1|0.21404  |0.21404  |main::|report |
    |0     |0|0|0        |0        |main::|BEGIN  |


    |Line|Stmts.|Exclusive|Avg.   |Code                                           |
    |    |      |Time     |       |                                               |
    |1   |      |         |       |#!/usr/bin/perl                                |
    |2   |      |         |       |                                               |
    |    |      |         |       |use strict;                                    |
    |3   |3     |0.00086  |0.00029|# spent 0.00003s making 1 calls to strict::    |
    |    |      |         |       |import                                         |
    |    |      |         |       |use warnings;                                  |
    |4   |3     |0.01563  |0.00521|# spent 0.00012s making 1 calls to warnings::  |
    |    |      |         |       |import                                         |
    |5   |      |         |       |                                               |
    |6   |      |         |       |=head1 NAME                                    |
    |7   |      |         |       |                                               |
    |8   |      |         |       |filewords - word analysis of input file        |
    &lt;...snip...&gt;
    |62  |1     |0.00445  |0.00445|print report( %count );                        |
    |    |      |         |       |# spent 0.21404s making 1 calls to main::report|
    |63  |      |         |       |                                               |
    |    |      |         |       |# spent 23.56955s (10.47692+2.61571) within    |
    |    |      |         |       |main::matches which was called 251215 times,   |
    |    |      |         |       |avg 0.00005s/call: # 50243 times               |
    |    |      |         |       |(2.12134+0.51939s) at line 57 of wordmatch, avg|
    |    |      |         |       |0.00005s/call # 50243 times (2.17735+0.54550s) |
    |64  |      |         |       |at line 56 of wordmatch, avg 0.00005s/call #   |
    |    |      |         |       |50243 times (2.10992+0.51797s) at line 58 of   |
    |    |      |         |       |wordmatch, avg 0.00005s/call # 50243 times     |
    |    |      |         |       |(2.12696+0.51598s) at line 55 of wordmatch, avg|
    |    |      |         |       |0.00005s/call # 50243 times (1.94134+0.51687s) |
    |    |      |         |       |at line 54 of wordmatch, avg 0.00005s/call     |
    |    |      |         |       |sub matches {                                  |
    &lt;...snip...&gt;
    |102 |      |         |       |                                               |
    |    |      |         |       |# spent 2.71199s within main::debug which was  |
    |    |      |         |       |called 260642 times, avg 0.00001s/call: #      |
    |    |      |         |       |251215 times (2.61571+0s) by main::matches at  |
    |103 |      |         |       |line 74 of wordmatch, avg 0.00001s/call # 9427 |
    |    |      |         |       |times (0.09628+0s) at line 50 of wordmatch, avg|
    |    |      |         |       |0.00001s/call                                  |
    |    |      |         |       |sub debug {                                    |
    |104 |260642|0.58496  |2e-06  |my $message = shift;                           |
    |105 |      |         |       |                                               |
    |106 |260642|1.09917  |4e-06  |if ( $debug ) {                                |
    |107 |      |         |       |print STDERR &quot;DBG: $message\n&quot;;                |
    |108 |      |         |       |}                                              |
    |109 |      |         |       |}                                              |
    |110 |      |         |       |                                               |
    |111 |1     |0.01501  |0.01501|exit 0;                                        |
    |112 |      |         |       |                                               |
</pre>
<p class="Pp">Oodles of very useful information in there - this seems to be the
    way forward.</p>
<p class="Pp">See also
    <span class="Li">&quot;Devel::NYTProf::Apache&quot;</span> which hooks
    <span class="Li">&quot;Devel::NYTProf&quot;</span> into
    <span class="Li">&quot;mod_perl&quot;</span>.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="SORTING"><a class="permalink" href="#SORTING">SORTING</a></h1>
Perl modules are not the only tools a performance analyst has at their disposal,
  system tools like <span class="Li">&quot;time&quot;</span> should not be
  overlooked as the next example shows, where we take a quick look at sorting.
  Many books, theses and articles, have been written about efficient sorting
  algorithms, and this is not the place to repeat such work, there's several
  good sorting modules which deserve taking a look at too:
  <span class="Li">&quot;Sort::Maker&quot;</span>,
  <span class="Li">&quot;Sort::Key&quot;</span> spring to mind. However, it's
  still possible to make some observations on certain Perl specific
  interpretations on issues relating to sorting data sets and give an example or
  two with regard to how sorting large data volumes can effect performance.
  Firstly, an often overlooked point when sorting large amounts of data, one can
  attempt to reduce the data set to be dealt with and in many cases
  <span class="Li">&quot;grep()&quot;</span> can be quite useful as a simple
  filter:
<p class="Pp"><span class="Li"></span></p>
<pre>
    @data = sort grep { /$filter/ } @incoming
</pre>
<p class="Pp">A command such as this can vastly reduce the volume of material to
    actually sort through in the first place, and should not be too lightly
    disregarded purely on the basis of its simplicity. The
    <span class="Li">&quot;KISS&quot;</span> principle is too often overlooked -
    the next example uses the simple system
    <span class="Li">&quot;time&quot;</span> utility to demonstrate. Let's take
    a look at an actual example of sorting the contents of a large file, an
    apache logfile would do. This one has over a quarter of a million lines, is
    50M in size, and a snippet of it looks like this:</p>
<p class="Pp"># logfile</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    188.209-65-87.adsl-dyn.isp.belgacom.be - - [08/Feb/2007:12:57:16 +0000] &quot;GET /favicon.ico HTTP/1.1&quot; 404 209 &quot;-&quot; &quot;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1)&quot;
    188.209-65-87.adsl-dyn.isp.belgacom.be - - [08/Feb/2007:12:57:16 +0000] &quot;GET /favicon.ico HTTP/1.1&quot; 404 209 &quot;-&quot; &quot;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1)&quot;
    151.56.71.198 - - [08/Feb/2007:12:57:41 +0000] &quot;GET /suse-on-vaio.html HTTP/1.1&quot; 200 2858 &quot;http://www.linux-on-laptops.com/sony.html&quot; &quot;Mozilla/5.0 (Windows; U; Windows NT 5.2; en-US; rv:1.8.1.1) Gecko/20061204 Firefox/2.0.0.1&quot;
    151.56.71.198 - - [08/Feb/2007:12:57:42 +0000] &quot;GET /data/css HTTP/1.1&quot; 404 206 &quot;http://www.rfi.net/suse-on-vaio.html&quot; &quot;Mozilla/5.0 (Windows; U; Windows NT 5.2; en-US; rv:1.8.1.1) Gecko/20061204 Firefox/2.0.0.1&quot;
    151.56.71.198 - - [08/Feb/2007:12:57:43 +0000] &quot;GET /favicon.ico HTTP/1.1&quot; 404 209 &quot;-&quot; &quot;Mozilla/5.0 (Windows; U; Windows NT 5.2; en-US; rv:1.8.1.1) Gecko/20061204 Firefox/2.0.0.1&quot;
    217.113.68.60 - - [08/Feb/2007:13:02:15 +0000] &quot;GET / HTTP/1.1&quot; 304 - &quot;-&quot; &quot;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1)&quot;
    217.113.68.60 - - [08/Feb/2007:13:02:16 +0000] &quot;GET /data/css HTTP/1.1&quot; 404 206 &quot;http://www.rfi.net/&quot; &quot;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1)&quot;
    debora.to.isac.cnr.it - - [08/Feb/2007:13:03:58 +0000] &quot;GET /suse-on-vaio.html HTTP/1.1&quot; 200 2858 &quot;http://www.linux-on-laptops.com/sony.html&quot; &quot;Mozilla/5.0 (compatible; Konqueror/3.4; Linux) KHTML/3.4.0 (like Gecko)&quot;
    debora.to.isac.cnr.it - - [08/Feb/2007:13:03:58 +0000] &quot;GET /data/css HTTP/1.1&quot; 404 206 &quot;http://www.rfi.net/suse-on-vaio.html&quot; &quot;Mozilla/5.0 (compatible; Konqueror/3.4; Linux) KHTML/3.4.0 (like Gecko)&quot;
    debora.to.isac.cnr.it - - [08/Feb/2007:13:03:58 +0000] &quot;GET /favicon.ico HTTP/1.1&quot; 404 209 &quot;-&quot; &quot;Mozilla/5.0 (compatible; Konqueror/3.4; Linux) KHTML/3.4.0 (like Gecko)&quot;
    195.24.196.99 - - [08/Feb/2007:13:26:48 +0000] &quot;GET / HTTP/1.0&quot; 200 3309 &quot;-&quot; &quot;Mozilla/5.0 (Windows; U; Windows NT 5.1; fr; rv:1.8.0.9) Gecko/20061206 Firefox/1.5.0.9&quot;
    195.24.196.99 - - [08/Feb/2007:13:26:58 +0000] &quot;GET /data/css HTTP/1.0&quot; 404 206 &quot;http://www.rfi.net/&quot; &quot;Mozilla/5.0 (Windows; U; Windows NT 5.1; fr; rv:1.8.0.9) Gecko/20061206 Firefox/1.5.0.9&quot;
    195.24.196.99 - - [08/Feb/2007:13:26:59 +0000] &quot;GET /favicon.ico HTTP/1.0&quot; 404 209 &quot;-&quot; &quot;Mozilla/5.0 (Windows; U; Windows NT 5.1; fr; rv:1.8.0.9) Gecko/20061206 Firefox/1.5.0.9&quot;
    crawl1.cosmixcorp.com - - [08/Feb/2007:13:27:57 +0000] &quot;GET /robots.txt HTTP/1.0&quot; 200 179 &quot;-&quot; &quot;voyager/1.0&quot;
    crawl1.cosmixcorp.com - - [08/Feb/2007:13:28:25 +0000] &quot;GET /links.html HTTP/1.0&quot; 200 3413 &quot;-&quot; &quot;voyager/1.0&quot;
    fhm226.internetdsl.tpnet.pl - - [08/Feb/2007:13:37:32 +0000] &quot;GET /suse-on-vaio.html HTTP/1.1&quot; 200 2858 &quot;http://www.linux-on-laptops.com/sony.html&quot; &quot;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1)&quot;
    fhm226.internetdsl.tpnet.pl - - [08/Feb/2007:13:37:34 +0000] &quot;GET /data/css HTTP/1.1&quot; 404 206 &quot;http://www.rfi.net/suse-on-vaio.html&quot; &quot;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1)&quot;
    80.247.140.134 - - [08/Feb/2007:13:57:35 +0000] &quot;GET / HTTP/1.1&quot; 200 3309 &quot;-&quot; &quot;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; .NET CLR 1.1.4322)&quot;
    80.247.140.134 - - [08/Feb/2007:13:57:37 +0000] &quot;GET /data/css HTTP/1.1&quot; 404 206 &quot;http://www.rfi.net&quot; &quot;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; .NET CLR 1.1.4322)&quot;
    pop.compuscan.co.za - - [08/Feb/2007:14:10:43 +0000] &quot;GET / HTTP/1.1&quot; 200 3309 &quot;-&quot; &quot;www.clamav.net&quot;
    livebot-207-46-98-57.search.live.com - - [08/Feb/2007:14:12:04 +0000] &quot;GET /robots.txt HTTP/1.0&quot; 200 179 &quot;-&quot; &quot;msnbot/1.0 (+http://search.msn.com/msnbot.htm)&quot;
    livebot-207-46-98-57.search.live.com - - [08/Feb/2007:14:12:04 +0000] &quot;GET /html/oracle.html HTTP/1.0&quot; 404 214 &quot;-&quot; &quot;msnbot/1.0 (+http://search.msn.com/msnbot.htm)&quot;
    dslb-088-064-005-154.pools.arcor-ip.net - - [08/Feb/2007:14:12:15 +0000] &quot;GET / HTTP/1.1&quot; 200 3309 &quot;-&quot; &quot;www.clamav.net&quot;
    196.201.92.41 - - [08/Feb/2007:14:15:01 +0000] &quot;GET / HTTP/1.1&quot; 200 3309 &quot;-&quot; &quot;MOT-L7/08.B7.DCR MIB/2.2.1 Profile/MIDP-2.0 Configuration/CLDC-1.1&quot;
</pre>
<p class="Pp">The specific task here is to sort the 286,525 lines of this file
    by Response Code, Query, Browser, Referring Url, and lastly Date. One
    solution might be to use the following code, which iterates over the files
    given on the command-line.</p>
<p class="Pp"># sort-apache-log</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    #!/usr/bin/perl -n

    use strict;
    use warnings;

    my @data;

    LINE:
    while ( &lt;&gt; ) {
        my $line = $_;
        if (
            $line =~ m/^(
                ([\w\.\-]+)             # client
                \s*-\s*-\s*\[
                ([^]]+)                 # date
                \]\s*&quot;\w+\s*
                (\S+)                   # query
                [^&quot;]+&quot;\s*
                (\d+)                   # status
                \s+\S+\s+&quot;[^&quot;]*&quot;\s+&quot;
                ([^&quot;]*)                 # browser
                &quot;
                .*
            )$/x
        ) {
            my @chunks = split(/ +/, $line);
            my $ip      = $1;
            my $date    = $2;
            my $query   = $3;
            my $status  = $4;
            my $browser = $5;

            push(@data, [$ip, $date, $query, $status, $browser, $line]);
        }
    }

    my @sorted = sort {
        $a-&gt;[3] cmp $b-&gt;[3]
                ||
        $a-&gt;[2] cmp $b-&gt;[2]
                ||
        $a-&gt;[0] cmp $b-&gt;[0]
                ||
        $a-&gt;[1] cmp $b-&gt;[1]
                ||
        $a-&gt;[4] cmp $b-&gt;[4]
    } @data;

    foreach my $data ( @sorted ) {
        print $data-&gt;[5];
    }

    exit 0;
</pre>
<p class="Pp">When running this program, redirect
    <span class="Li">&quot;STDOUT&quot;</span> so it is possible to check the
    output is correct from following test runs and use the system
    <span class="Li">&quot;time&quot;</span> utility to check the overall
    runtime.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    $&gt; time ./sort-apache-log logfile &gt; out-sort

    real    0m17.371s
    user    0m15.757s
    sys     0m0.592s
</pre>
<p class="Pp">The program took just over 17 wallclock seconds to run. Note the
    different values <span class="Li">&quot;time&quot;</span> outputs, it's
    important to always use the same one, and to not confuse what each one
    means.</p>
<dl class="Bl-tag">
  <dt>Elapsed Real Time</dt>
  <dd>The overall, or wallclock, time between when
      <span class="Li">&quot;time&quot;</span> was called, and when it
      terminates. The elapsed time includes both user and system times, and time
      spent waiting for other users and processes on the system. Inevitably,
      this is the most approximate of the measurements given.</dd>
  <dt>User CPU Time</dt>
  <dd>The user time is the amount of time the entire process spent on behalf of
      the user on this system executing this program.</dd>
  <dt>System CPU Time</dt>
  <dd>The system time is the amount of time the kernel itself spent executing
      routines, or system calls, on behalf of this process user.</dd>
</dl>
<p class="Pp">Running this same process as a <span class="Li">&quot;Schwarzian
    Transform&quot;</span> it is possible to eliminate the input and output
    arrays for storing all the data, and work on the input directly as it
    arrives too. Otherwise, the code looks fairly similar:</p>
<p class="Pp"># sort-apache-log-schwarzian</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    #!/usr/bin/perl -n

    use strict;
    use warnings;

    print

        map $_-&gt;[0] =&gt;

        sort {
            $a-&gt;[4] cmp $b-&gt;[4]
                    ||
            $a-&gt;[3] cmp $b-&gt;[3]
                    ||
            $a-&gt;[1] cmp $b-&gt;[1]
                    ||
            $a-&gt;[2] cmp $b-&gt;[2]
                    ||
            $a-&gt;[5] cmp $b-&gt;[5]
        }
        map  [ $_, m/^(
            ([\w\.\-]+)             # client
            \s*-\s*-\s*\[
            ([^]]+)                 # date
            \]\s*&quot;\w+\s*
            (\S+)                   # query
            [^&quot;]+&quot;\s*
            (\d+)                   # status
            \s+\S+\s+&quot;[^&quot;]*&quot;\s+&quot;
            ([^&quot;]*)                 # browser
            &quot;
            .*
        )$/xo ]

        =&gt; &lt;&gt;;

    exit 0;
</pre>
<p class="Pp">Run the new code against the same logfile, as above, to check the
    new time.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    $&gt; time ./sort-apache-log-schwarzian logfile &gt; out-schwarz

    real    0m9.664s
    user    0m8.873s
    sys     0m0.704s
</pre>
<p class="Pp">The time has been cut in half, which is a respectable speed
    improvement by any standard. Naturally, it is important to check the output
    is consistent with the first program run, this is where the Unix system
    <span class="Li">&quot;cksum&quot;</span> utility comes in.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    $&gt; cksum out-sort out-schwarz
    3044173777 52029194 out-sort
    3044173777 52029194 out-schwarz
</pre>
<p class="Pp">BTW. Beware too of pressure from managers who see you speed a
    program up by 50% of the runtime once, only to get a request one month later
    to do the same again (true story) - you'll just have to point out your only
    human, even if you are a Perl programmer, and you'll see what you can
  do...</p>
</section>
<section class="Sh">
<h1 class="Sh" id="LOGGING"><a class="permalink" href="#LOGGING">LOGGING</a></h1>
An essential part of any good development process is appropriate error handling
  with appropriately informative messages, however there exists a school of
  thought which suggests that log files should be <i>chatty</i>, as if the chain
  of unbroken output somehow ensures the survival of the program. If speed is in
  any way an issue, this approach is wrong.
<p class="Pp">A common sight is code which looks something like this:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    logger-&gt;debug( &quot;A logging message via process-id: $$ INC: &quot; . Dumper(\%INC) )
</pre>
<p class="Pp">The problem is that this code will always be parsed and executed,
    even when the debug level set in the logging configuration file is zero.
    Once the <i>debug()</i> subroutine has been entered, and the internal
    <span class="Li">$debug</span> variable confirmed to be zero, for example,
    the message which has been sent in will be discarded and the program will
    continue. In the example given though, the \%INC hash will already have been
    dumped, and the message string constructed, all of which work could be
    bypassed by a debug variable at the statement level, like this:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    logger-&gt;debug( &quot;A logging message via process-id: $$ INC: &quot; . Dumper(\%INC) ) if $DEBUG;
</pre>
<p class="Pp">This effect can be demonstrated by setting up a test script with
    both forms, including a <span class="Li">&quot;debug()&quot;</span>
    subroutine to emulate typical <span class="Li">&quot;logger()&quot;</span>
    functionality.</p>
<p class="Pp"># ifdebug</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    #!/usr/bin/perl

    use strict;
    use warnings;

    use Benchmark;
    use Data::Dumper;
    my $DEBUG = 0;

    sub debug {
        my $msg = shift;

        if ( $DEBUG ) {
            print &quot;DEBUG: $msg\n&quot;;
        }
    };

    timethese(100000, {
            'debug'       =&gt; sub {
                debug( &quot;A $0 logging message via process-id: $$&quot; . Dumper(\%INC) )
            },
            'ifdebug'  =&gt; sub {
                debug( &quot;A $0 logging message via process-id: $$&quot; . Dumper(\%INC) ) if $DEBUG
            },
    });
</pre>
<p class="Pp">Let's see what <span class="Li">&quot;Benchmark&quot;</span> makes
    of this:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    $&gt; perl ifdebug
    Benchmark: timing 100000 iterations of constant, sub...
       ifdebug:  0 wallclock secs ( 0.01 usr +  0.00 sys =  0.01 CPU) @ 10000000.00/s (n=100000)
                (warning: too few iterations for a reliable count)
         debug: 14 wallclock secs (13.18 usr +  0.04 sys = 13.22 CPU) @ 7564.30/s (n=100000)
</pre>
<p class="Pp">In the one case the code, which does exactly the same thing as far
    as outputting any debugging information is concerned, in other words
    nothing, takes 14 seconds, and in the other case the code takes one
    hundredth of a second. Looks fairly definitive. Use a
    <span class="Li">$DEBUG</span> variable BEFORE you call the subroutine,
    rather than relying on the smart functionality inside it.</p>
<section class="Ss">
<h2 class="Ss" id="Logging_if__s-1DEBUG__s0(constant)"><a class="permalink" href="#Logging_if__s-1DEBUG__s0(constant)">Logging
  if DEBUG (constant)</a></h2>
It's possible to take the previous idea a little further, by using a compile
  time <span class="Li">&quot;DEBUG&quot;</span> constant.
<p class="Pp"># ifdebug-constant</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    #!/usr/bin/perl

    use strict;
    use warnings;

    use Benchmark;
    use Data::Dumper;
    use constant
        DEBUG =&gt; 0
    ;

    sub debug {
        if ( DEBUG ) {
            my $msg = shift;
            print &quot;DEBUG: $msg\n&quot;;
        }
    };

    timethese(100000, {
            'debug'       =&gt; sub {
                debug( &quot;A $0 logging message via process-id: $$&quot; . Dumper(\%INC) )
            },
            'constant'  =&gt; sub {
                debug( &quot;A $0 logging message via process-id: $$&quot; . Dumper(\%INC) ) if DEBUG
            },
    });
</pre>
<p class="Pp">Running this program produces the following output:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    $&gt; perl ifdebug-constant
    Benchmark: timing 100000 iterations of constant, sub...
      constant:  0 wallclock secs (-0.00 usr +  0.00 sys = -0.00 CPU) @ -7205759403792793600000.00/s (n=100000)
                (warning: too few iterations for a reliable count)
           sub: 14 wallclock secs (13.09 usr +  0.00 sys = 13.09 CPU) @ 7639.42/s (n=100000)
</pre>
<p class="Pp">The <span class="Li">&quot;DEBUG&quot;</span> constant wipes the
    floor with even the <span class="Li">$debug</span> variable, clocking in at
    minus zero seconds, and generates a &quot;warning: too few iterations for a
    reliable count&quot; message into the bargain. To see what is really going
    on, and why we had too few iterations when we thought we asked for 100000,
    we can use the very useful <span class="Li">&quot;B::Deparse&quot;</span> to
    inspect the new code:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    $&gt; perl -MO=Deparse ifdebug-constant

    use Benchmark;
    use Data::Dumper;
    use constant ('DEBUG', 0);
    sub debug {
        use warnings;
        use strict 'refs';
        0;
    }
    use warnings;
    use strict 'refs';
    timethese(100000, {'sub', sub {
        debug &quot;A $0 logging message via process-id: $$&quot; . Dumper(\%INC);
    }
    , 'constant', sub {
        0;
    }
    });
    ifdebug-constant syntax OK
</pre>
<p class="Pp">The output shows the <i>constant()</i> subroutine we're testing
    being replaced with the value of the
    <span class="Li">&quot;DEBUG&quot;</span> constant: zero. The line to be
    tested has been completely optimized away, and you can't get much more
    efficient than that.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="POSTSCRIPT"><a class="permalink" href="#POSTSCRIPT">POSTSCRIPT</a></h1>
This document has provided several way to go about identifying hot-spots, and
  checking whether any modifications have improved the runtime of the code.
<p class="Pp">As a final thought, remember that it's not (at the time of
    writing) possible to produce a useful program which will run in zero or
    negative time and this basic principle can be written as: <i>useful programs
    are slow</i> by their very definition. It is of course possible to write a
    nearly instantaneous program, but it's not going to do very much, here's a
    very efficient one:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    $&gt; perl -e 0
</pre>
<p class="Pp">Optimizing that any further is a job for
    <span class="Li">&quot;p5p&quot;</span>.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
Further reading can be found using the modules and links below.
<section class="Ss">
<h2 class="Ss" id="_s-1PERLDOCS_s0"><a class="permalink" href="#_s-1PERLDOCS_s0">PERLDOCS</a></h2>
For example: <span class="Li">&quot;perldoc -f sort&quot;</span>.
<p class="Pp">perlfaq4.</p>
<p class="Pp">perlfork, perlfunc, perlretut, perlthrtut.</p>
<p class="Pp">threads.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_s-1MAN_PAGES_s0"><a class="permalink" href="#_s-1MAN_PAGES_s0">MAN
  PAGES</a></h2>
<span class="Li">&quot;time&quot;</span>.
</section>
<section class="Ss">
<h2 class="Ss" id="_s-1MODULES_s0"><a class="permalink" href="#_s-1MODULES_s0">MODULES</a></h2>
It's not possible to individually showcase all the performance related code for
  Perl here, naturally, but here's a short list of modules from the CPAN which
  deserve further attention.
<p class="Pp"><span class="Li"></span></p>
<pre>
    Apache::DProf
    Apache::SmallProf
    Benchmark
    DBIx::Profile
    Devel::AutoProfiler
    Devel::DProf
    Devel::DProfLB
    Devel::FastProf
    Devel::GraphVizProf
    Devel::NYTProf
    Devel::NYTProf::Apache
    Devel::Profiler
    Devel::Profile
    Devel::Profit
    Devel::SmallProf
    Devel::WxProf
    POE::Devel::Profiler
    Sort::Key
    Sort::Maker
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="_s-1URLS_s0"><a class="permalink" href="#_s-1URLS_s0">URLS</a></h2>
Very useful online reference material:
<p class="Pp"><span class="Li"></span></p>
<pre>
    http://www.ccl4.org/~nick/P/Fast_Enough/

    http://www-128.ibm.com/developerworks/library/l-optperl.html

    http://perlbuzz.com/2007/11/bind-output-variables-in-dbi-for-speed-and-safety.html

    http://en.wikipedia.org/wiki/Performance_analysis

    http://apache.perl.org/docs/1.0/guide/performance.html

    http://perlgolf.sourceforge.net/

    http://www.sysarch.com/Perl/sort_paper.html
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
Richard Foley &lt;richard.foley@rfi.net&gt; Copyright (c) 2008
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2014-01-31</td>
    <td class="foot-os">perl v5.18.4</td>
  </tr>
</table>
</body>
</html>
