<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
  	$NetBSD: intro.2,v 1.6 1995/02/27 12:33:41 cgd Exp $
  
   Copyright (c) 1980, 1983, 1986, 1991, 1993
  	The Regents of the University of California.  All rights reserved.
  
   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions
   are met:
   1. Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
   2. Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
   3. All advertising materials mentioning features or use of this software
      must display the following acknowledgement:
  	This product includes software developed by the University of
  	California, Berkeley and its contributors.
   4. Neither the name of the University nor the names of its contributors
      may be used to endorse or promote products derived from this software
      without specific prior written permission.
  
   THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
   ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
   ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
   FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
   DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
   OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
   HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
   LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
   OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
   SUCH DAMAGE.
  
       @(#)intro.2	8.3 (Berkeley) 12/11/93
   -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    .Nd, .Bf, .Op { display: inline; }
    .Pa, .Ad { font-style: italic; }
    .Ms { font-weight: bold; }
    .Bl-diag > dt { font-weight: bold; }
    code.Nm, .Fl, .Cm, .Ic, code.In, .Fd, .Fn, .Cd { font-weight: bold;
      font-family: inherit; }
  </style>
  <title>INTRO(2)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">INTRO(2)</td>
    <td class="head-vol">System Calls Manual</td>
    <td class="head-rtitle">INTRO(2)</td>
  </tr>
</table>
<div class="manual-text">
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp"><code class="Nm">intro</code> &#x2014;
    <span class="Nd">introduction to system calls and error numbers</span></p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<p class="Pp"><code class="In">#include
    <a class="In">&lt;sys/errno.h&gt;</a></code></p>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">This section provides an overview of the system calls, their error
    returns, and other common definitions and concepts.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DIAGNOSTICS"><a class="permalink" href="#DIAGNOSTICS">DIAGNOSTICS</a></h1>
<p class="Pp">Nearly all of the system calls provide an error number in the
    external variable <var class="Va">errno</var>, which is defined as:</p>
<p class="Pp"></p>
<div class="Bd Bd-indent"><code class="Li">extern int errno</code></div>
<p class="Pp">When a system call detects an error, it returns an integer value
    indicating failure (usually -1) and sets the variable
    <var class="Va">errno</var> accordingly. &lt;This allows interpretation of
    the failure on receiving a -1 and to take action accordingly.&gt; Successful
    calls never set <var class="Va">errno</var>; once set, it remains until
    another error occurs. It should only be examined after an error. Note that a
    number of system calls overload the meanings of these error numbers, and
    that the meanings must be interpreted according to the type and
    circumstances of the call.</p>
<p class="Pp">The following is a complete list of the errors and their names as
    given in &#x27E8;<span class="Pa">sys/errno.h</span>&#x27E9;.</p>
<dl class="Bl-hang">
  <dt id="Error"><code class="Er">0</code>
    <a class="permalink" href="#Error"><i class="Em">Error 0</i></a>.</dt>
  <dd>Not used.</dd>
  <dt><code class="Er">1 EPERM</code> <i class="Em">Operation not
    permitted</i>.</dt>
  <dd>An attempt was made to perform an operation limited to processes with
      appropriate privileges or to the owner of a file or other resources.</dd>
  <dt><code class="Er">2 ENOENT</code> <i class="Em">No such file or
    directory</i>.</dt>
  <dd>A component of a specified pathname did not exist, or the pathname was an
      empty string.</dd>
  <dt><code class="Er">3 ESRCH</code> <i class="Em">No such process</i>.</dt>
  <dd>No process could be found corresponding to that specified by the given
      process ID.</dd>
  <dt id="Interrupted"><code class="Er">4 EINTR</code>
    <a class="permalink" href="#Interrupted"><i class="Em">Interrupted function
    call</i></a>.</dt>
  <dd>An asynchronous signal (such as <code class="Dv">SIGINT</code> or
      <code class="Dv">SIGQUIT</code>) was caught by the process during the
      execution of an interruptible function. If the signal handler performs a
      normal return, the interrupted function call will seem to have returned
      the error condition.</dd>
  <dt id="Input/output"><code class="Er">5 EIO</code>
    <a class="permalink" href="#Input/output"><i class="Em">Input/output
    error</i></a>.</dt>
  <dd>Some physical input or output error occurred. This error will not be
      reported until a subsequent operation on the same file descriptor and may
      be lost (over written) by any subsequent errors.</dd>
  <dt><code class="Er">6 ENXIO</code> <i class="Em">No such device or
    address</i>.</dt>
  <dd>Input or output on a special file referred to a device that did not exist,
      or made a request beyond the limits of the device. This error may also
      occur when, for example, a tape drive is not online or no disk pack is
      loaded on a drive.</dd>
  <dt id="Arg"><code class="Er">7 E2BIG</code>
    <a class="permalink" href="#Arg"><i class="Em">Arg list too
    long</i></a>.</dt>
  <dd>The number of bytes used for the argument and environment list of the new
      process exceeded the limit <code class="Dv">NCARGS</code> (specified in
      &#x27E8;<span class="Pa">sys/param.h</span>&#x27E9;).</dd>
  <dt id="Exec"><code class="Er">8 ENOEXEC</code>
    <a class="permalink" href="#Exec"><i class="Em">Exec format
    error</i></a>.</dt>
  <dd>A request was made to execute a file that, although it has the appropriate
      permissions, was not in the format required for an executable file.</dd>
  <dt><code class="Er">9 EBADF</code> <i class="Em">Bad file
    descriptor</i>.</dt>
  <dd>A file descriptor argument was out of range, referred to no open file, or
      a read (write) request was made to a file that was only open for writing
      (reading).</dd>
  <dt><code class="Er">10 ECHILD</code> <i class="Em">No child
    processes</i>.</dt>
  <dd>A <a class="Xr">wait</a> or <a class="Xr">waitpid</a> function was
      executed by a process that had no existing or unwaited-for child
      processes.</dd>
  <dt><code class="Er">11 EDEADLK</code> <i class="Em">Resource deadlock
    avoided</i>.</dt>
  <dd>An attempt was made to lock a system resource that would have resulted in
      a deadlock situation.</dd>
  <dt><code class="Er">12 ENOMEM</code> <i class="Em">Cannot allocate
    memory</i>.</dt>
  <dd>The new process image required more memory than was allowed by the
      hardware or by system-imposed memory management constraints. A lack of
      swap space is normally temporary; however, a lack of core is not. Soft
      limits may be increased to their corresponding hard limits.</dd>
  <dt id="Permission"><code class="Er">13 EACCES</code>
    <a class="permalink" href="#Permission"><i class="Em">Permission
    denied</i></a>.</dt>
  <dd>An attempt was made to access a file in a way forbidden by its file access
      permissions.</dd>
  <dt><code class="Er">14 EFAULT</code> <i class="Em">Bad address</i>.</dt>
  <dd>The system detected an invalid address in attempting to use an argument of
      a call.</dd>
  <dt><code class="Er">15 ENOTBLK</code> <i class="Em">Not a block
    device</i>.</dt>
  <dd>A block device operation was attempted on a non-block device or file.</dd>
  <dt><code class="Er">16 EBUSY</code> <i class="Em">Resource busy</i>.</dt>
  <dd>An attempt to use a system resource which was in use at the time in a
      manner which would have conflicted with the request.</dd>
  <dt><code class="Er">17 EEXIST</code> <i class="Em">File exists</i>.</dt>
  <dd>An existing file was mentioned in an inappropriate context, for instance,
      as the new link name in a <a class="Xr">link</a> function.</dd>
  <dt id="Improper"><code class="Er">18 EXDEV</code>
    <a class="permalink" href="#Improper"><i class="Em">Improper
    link</i></a>.</dt>
  <dd>A hard link to a file on another file system was attempted.</dd>
  <dt><code class="Er">19 ENODEV</code> <i class="Em">Operation not supported by
    device</i>.</dt>
  <dd>An attempt was made to apply an inappropriate function to a device, for
      example, trying to read a write-only device such as a printer.</dd>
  <dt><code class="Er">20 ENOTDIR</code> <i class="Em">Not a directory</i>.</dt>
  <dd>A component of the specified pathname existed, but it was not a directory,
      when a directory was expected.</dd>
  <dt id="Is"><code class="Er">21 EISDIR</code>
    <a class="permalink" href="#Is"><i class="Em">Is a directory</i></a>.</dt>
  <dd>An attempt was made to open a directory with write mode specified.</dd>
  <dt id="Invalid"><code class="Er">22 EINVAL</code>
    <a class="permalink" href="#Invalid"><i class="Em">Invalid
    argument</i></a>.</dt>
  <dd>Some invalid argument was supplied. (For example, specifying an undefined
      signal to a <a class="Xr">signal</a> or <a class="Xr">kill</a>
    function).</dd>
  <dt><code class="Er">23 ENFILE</code> <i class="Em">Too many open files in
    system</i>.</dt>
  <dd>Maximum number of file descriptors allowable on the system has been
      reached and a requests for an open cannot be satisfied until at least one
      has been closed.</dd>
  <dt><code class="Er">24 EMFILE</code> <i class="Em">Too many open
    files</i>.</dt>
  <dd>&lt;As released, the limit on the number of open files per process is
      64.&gt; <a class="Xr">Getdtablesize(2)</a> will obtain the current
    limit.</dd>
  <dt><code class="Er">25 ENOTTY</code> <i class="Em">Inappropriate ioctl for
    device</i>.</dt>
  <dd>A control function (see <a class="Xr">ioctl(2)</a>) was attempted for a
      file or special device for which the operation was inappropriate.</dd>
  <dt id="Text"><code class="Er">26 ETXTBSY</code>
    <a class="permalink" href="#Text"><i class="Em">Text file busy</i></a>.</dt>
  <dd>The new process was a pure procedure (shared text) file which was open for
      writing by another process, or while the pure procedure file was being
      executed an <a class="Xr">open</a> call requested write access.</dd>
  <dt><code class="Er">27 EFBIG</code> <i class="Em">File too large</i>.</dt>
  <dd>The size of a file exceeded the maximum (about 2.1E9 bytes on some
      filesystems including UFS, 1.8E19 bytes on HFS+ and others).</dd>
  <dt><code class="Er">28 ENOSPC</code> <i class="Em">Device out of
    space</i>.</dt>
  <dd>A <a class="Xr">write</a> to an ordinary file, the creation of a directory
      or symbolic link, or the creation of a directory entry failed because no
      more disk blocks were available on the file system, or the allocation of
      an inode for a newly created file failed because no more inodes were
      available on the file system.</dd>
  <dt><code class="Er">29 ESPIPE</code> <i class="Em">Illegal seek</i>.</dt>
  <dd>An <a class="Xr">lseek</a> function was issued on a socket, pipe or
    FIFO.</dd>
  <dt id="Read-only"><code class="Er">30 EROFS</code>
    <a class="permalink" href="#Read-only"><i class="Em">Read-only file
    system</i></a>.</dt>
  <dd>An attempt was made to modify a file or directory was made on a file
      system that was read-only at the time.</dd>
  <dt><code class="Er">31 EMLINK</code> <i class="Em">Too many links</i>.</dt>
  <dd>Maximum allowable hard links to a single file has been exceeded (limit of
      32767 hard links per file).</dd>
  <dt id="Broken"><code class="Er">32 EPIPE</code>
    <a class="permalink" href="#Broken"><i class="Em">Broken pipe</i></a>.</dt>
  <dd>A write on a pipe, socket or FIFO for which there is no process to read
      the data.</dd>
  <dt><code class="Er">33 EDOM</code> <i class="Em">Numerical argument out of
    domain</i>.</dt>
  <dd>A numerical input argument was outside the defined domain of the
      mathematical function.</dd>
  <dt><code class="Er">34 ERANGE</code> <i class="Em">Numerical result out of
    range</i>.</dt>
  <dd>A numerical result of the function was too large to fit in the available
      space (perhaps exceeded precision).</dd>
  <dt><code class="Er">35 EAGAIN</code> <i class="Em">Resource temporarily
    unavailable</i>.</dt>
  <dd>This is a temporary condition and later calls to the same routine may
      complete normally.</dd>
  <dt><code class="Er">36 EINPROGRESS</code> <i class="Em">Operation now in
    progress</i>.</dt>
  <dd>An operation that takes a long time to complete (such as a
      <a class="Xr">connect(2)</a> or <a class="Xr">connectx(2)</a>) was
      attempted on a non-blocking object (see <a class="Xr">fcntl(2)</a>).</dd>
  <dt><code class="Er">37 EALREADY</code> <i class="Em">Operation already in
    progress</i>.</dt>
  <dd>An operation was attempted on a non-blocking object that already had an
      operation in progress.</dd>
  <dt><code class="Er">38 ENOTSOCK</code> <i class="Em">Socket operation on
    non-socket</i>.</dt>
  <dd>Self-explanatory.</dd>
  <dt id="Destination"><code class="Er">39 EDESTADDRREQ</code>
    <a class="permalink" href="#Destination"><i class="Em">Destination address
    required</i></a>.</dt>
  <dd>A required address was omitted from an operation on a socket.</dd>
  <dt id="Message"><code class="Er">40 EMSGSIZE</code>
    <a class="permalink" href="#Message"><i class="Em">Message too
    long</i></a>.</dt>
  <dd>A message sent on a socket was larger than the internal message buffer or
      some other network limit.</dd>
  <dt><code class="Er">41 EPROTOTYPE</code> <i class="Em">Protocol wrong type
    for socket</i>.</dt>
  <dd>A protocol was specified that does not support the semantics of the socket
      type requested. For example, you cannot use the ARPA Internet UDP protocol
      with type <code class="Dv">SOCK_STREAM</code>.</dd>
  <dt><code class="Er">42 ENOPROTOOPT</code> <i class="Em">Protocol not
    available</i>.</dt>
  <dd>A bad option or level was specified in a <a class="Xr">getsockopt(2)</a>
      or <a class="Xr">setsockopt(2)</a> call.</dd>
  <dt><code class="Er">43 EPROTONOSUPPORT</code> <i class="Em">Protocol not
    supported</i>.</dt>
  <dd>The protocol has not been configured into the system or no implementation
      for it exists.</dd>
  <dt><code class="Er">44 ESOCKTNOSUPPORT</code> <i class="Em">Socket type not
    supported</i>.</dt>
  <dd>The support for the socket type has not been configured into the system or
      no implementation for it exists.</dd>
  <dt><code class="Er">45 ENOTSUP</code> <i class="Em">Not supported</i>.</dt>
  <dd>The attempted operation is not supported for the type of object
      referenced.</dd>
  <dt><code class="Er">46 EPFNOSUPPORT</code> <i class="Em">Protocol family not
    supported</i>.</dt>
  <dd>The protocol family has not been configured into the system or no
      implementation for it exists.</dd>
  <dt><code class="Er">47 EAFNOSUPPORT</code> <i class="Em">Address family not
    supported by protocol family</i>.</dt>
  <dd>An address incompatible with the requested protocol was used. For example,
      you shouldn't necessarily expect to be able to use NS addresses with ARPA
      Internet protocols.</dd>
  <dt><code class="Er">48 EADDRINUSE</code> <i class="Em">Address already in
    use</i>.</dt>
  <dd>Only one usage of each address is normally permitted.</dd>
  <dt><code class="Er">49 EADDRNOTAVAIL</code> <i class="Em">Cannot assign
    requested address</i>.</dt>
  <dd>Normally results from an attempt to create a socket with an address not on
      this machine.</dd>
  <dt><code class="Er">50 ENETDOWN</code> <i class="Em">Network is
    down</i>.</dt>
  <dd>A socket operation encountered a dead network.</dd>
  <dt><code class="Er">51 ENETUNREACH</code> <i class="Em">Network is
    unreachable</i>.</dt>
  <dd>A socket operation was attempted to an unreachable network.</dd>
  <dt><code class="Er">52 ENETRESET</code> <i class="Em">Network dropped
    connection on reset</i>.</dt>
  <dd>The host you were connected to crashed and rebooted.</dd>
  <dt id="Software"><code class="Er">53 ECONNABORTED</code>
    <a class="permalink" href="#Software"><i class="Em">Software caused
    connection abort</i></a>.</dt>
  <dd>A connection abort was caused internal to your host machine.</dd>
  <dt><code class="Er">54 ECONNRESET</code> <i class="Em">Connection reset by
    peer</i>.</dt>
  <dd>A connection was forcibly closed by a peer. This normally results from a
      loss of the connection on the remote socket due to a timeout or a
    reboot.</dd>
  <dt><code class="Er">55 ENOBUFS</code> <i class="Em">No buffer space
    available</i>.</dt>
  <dd>An operation on a socket or pipe was not performed because the system
      lacked sufficient buffer space or because a queue was full.</dd>
  <dt><code class="Er">56 EISCONN</code> <i class="Em">Socket is already
    connected</i>.</dt>
  <dd>A <a class="Xr">connect</a> or <a class="Xr">connectx</a> request was made
      on an already connected socket; or, a <a class="Xr">sendto</a> or
      <a class="Xr">sendmsg</a> request on a connected socket specified a
      destination when already connected.</dd>
  <dt><code class="Er">57 ENOTCONN</code> <i class="Em">Socket is not
    connected</i>.</dt>
  <dd>An request to send or receive data was disallowed because the socket was
      not connected and (when sending on a datagram socket) no address was
      supplied.</dd>
  <dt><code class="Er">58 ESHUTDOWN</code> <i class="Em">Cannot send after
    socket shutdown</i>.</dt>
  <dd>A request to send data was disallowed because the socket had already been
      shut down with a previous <a class="Xr">shutdown(2)</a> call.</dd>
  <dt><code class="Er">60 ETIMEDOUT</code> <i class="Em">Operation timed
    out</i>.</dt>
  <dd>A <a class="Xr">connect</a>, <a class="Xr">connectx</a> or
      <a class="Xr">send</a> request failed because the connected party did not
      properly respond after a period of time. (The timeout period is dependent
      on the communication protocol.)</dd>
  <dt><code class="Er">61 ECONNREFUSED</code> <i class="Em">Connection
    refused</i>.</dt>
  <dd>No connection could be made because the target machine actively refused
      it. This usually results from trying to connect to a service that is
      inactive on the foreign host.</dd>
  <dt><code class="Er">62 ELOOP</code> <i class="Em">Too many levels of symbolic
    links</i>.</dt>
  <dd>A path name lookup involved more than 8 symbolic links.</dd>
  <dt><code class="Er">63 ENAMETOOLONG</code> <i class="Em">File name too
    long</i>.</dt>
  <dd>A component of a path name exceeded 255
      (<code class="Dv">MAXNAMELEN</code>) characters, or an entire path name
      exceeded 1023 (<code class="Dv">MAXPATHLEN</code>-1) characters.</dd>
  <dt id="Host"><code class="Er">64 EHOSTDOWN</code>
    <a class="permalink" href="#Host"><i class="Em">Host is down</i></a>.</dt>
  <dd>A socket operation failed because the destination host was down.</dd>
  <dt><code class="Er">65 EHOSTUNREACH</code> <i class="Em">No route to
    host</i>.</dt>
  <dd>A socket operation was attempted to an unreachable host.</dd>
  <dt id="Directory"><code class="Er">66 ENOTEMPTY</code>
    <a class="permalink" href="#Directory"><i class="Em">Directory not
    empty</i></a>.</dt>
  <dd>A directory with entries other than
      &#x2018;<code class="Li">.</code>&#x2019; and
      &#x2018;<code class="Li">..</code>&#x2019; was supplied to a remove
      directory or rename call.</dd>
  <dt><code class="Er">67 EPROCLIM</code> <i class="Em">Too many
    processes</i>.</dt>
  <dd></dd>
  <dt><code class="Er">68 EUSERS</code> <i class="Em">Too many users</i>.</dt>
  <dd>The quota system ran out of table entries.</dd>
  <dt id="Disc"><code class="Er">69 EDQUOT</code>
    <a class="permalink" href="#Disc"><i class="Em">Disc quota
    exceeded</i></a>.</dt>
  <dd>A <a class="Xr">write</a> to an ordinary file, the creation of a directory
      or symbolic link, or the creation of a directory entry failed because the
      user's quota of disk blocks was exhausted, or the allocation of an inode
      for a newly created file failed because the user's quota of inodes was
      exhausted.</dd>
  <dt id="Stale"><code class="Er">70 ESTALE</code>
    <a class="permalink" href="#Stale"><i class="Em">Stale NFS file
    handle</i></a>.</dt>
  <dd>An attempt was made to access an open file (on an NFS filesystem) which is
      now unavailable as referenced by the file descriptor. This may indicate
      the file was deleted on the NFS server or some other catastrophic event
      occurred.</dd>
  <dt><code class="Er">72 EBADRPC</code> <i class="Em">RPC struct is
    bad</i>.</dt>
  <dd>Exchange of RPC information was unsuccessful.</dd>
  <dt><code class="Er">73 ERPCMISMATCH</code> <i class="Em">RPC version
    wrong</i>.</dt>
  <dd>The version of RPC on the remote peer is not compatible with the local
      version.</dd>
  <dt><code class="Er">74 EPROGUNAVAIL</code> <i class="Em">RPC prog. not
    avail</i>.</dt>
  <dd>The requested program is not registered on the remote host.</dd>
  <dt id="Program"><code class="Er">75 EPROGMISMATCH</code>
    <a class="permalink" href="#Program"><i class="Em">Program version
    wrong</i></a>.</dt>
  <dd>The requested version of the program is not available on the remote host
      (RPC).</dd>
  <dt><code class="Er">76 EPROCUNAVAIL</code> <i class="Em">Bad procedure for
    program</i>.</dt>
  <dd>An RPC call was attempted for a procedure which doesn't exist in the
      remote program.</dd>
  <dt><code class="Er">77 ENOLCK</code> <i class="Em">No locks
    available</i>.</dt>
  <dd>A system-imposed limit on the number of simultaneous file locks was
      reached.</dd>
  <dt id="Function"><code class="Er">78 ENOSYS</code>
    <a class="permalink" href="#Function"><i class="Em">Function not
    implemented</i></a>.</dt>
  <dd>Attempted a system call that is not available on this system.</dd>
  <dt><code class="Er">79 EFTYPE</code> <i class="Em">Inappropriate file type or
    format</i>.</dt>
  <dd>The file was the wrong type for the operation, or a data file had the
      wrong format.</dd>
  <dt id="Authentication"><code class="Er">80 EAUTH</code>
    <a class="permalink" href="#Authentication"><i class="Em">Authentication
    error</i></a>.</dt>
  <dd>Attempted to use an invalid authentication ticket to mount an NFS file
      system.</dd>
  <dt id="Need"><code class="Er">81 ENEEDAUTH</code>
    <a class="permalink" href="#Need"><i class="Em">Need
    authenticator</i></a>.</dt>
  <dd>An authentication ticket must be obtained before the given NFS file system
      may be mounted.</dd>
  <dt><code class="Er">82 EPWROFF</code> <i class="Em">Device power is
    off</i>.</dt>
  <dd>The device power is off.</dd>
  <dt><code class="Er">83 EDEVERR</code> <i class="Em">Device error</i>.</dt>
  <dd>A device error has occurred, e.g. a printer running out of paper.</dd>
  <dt id="Value"><code class="Er">84 EOVERFLOW</code>
    <a class="permalink" href="#Value"><i class="Em">Value too large to be
    stored in data type</i></a>.</dt>
  <dd>A numerical result of the function was too large to be stored in the
      caller provided space.</dd>
  <dt><code class="Er">85 EBADEXEC</code> <i class="Em">Bad executable (or
    shared library)</i>.</dt>
  <dd>The executable or shared library being referenced was malformed.</dd>
  <dt><code class="Er">86 EBADARCH</code> <i class="Em">Bad CPU type in
    executable</i>.</dt>
  <dd>The executable in question does not support the current CPU.</dd>
  <dt id="Shared"><code class="Er">87 ESHLIBVERS</code>
    <a class="permalink" href="#Shared"><i class="Em">Shared library version
    mismatch</i></a>.</dt>
  <dd>The version of the shared library on the system does not match the version
      which was expected.</dd>
  <dt id="Malformed"><code class="Er">88 EBADMACHO</code>
    <a class="permalink" href="#Malformed"><i class="Em">Malformed Mach-o
    file</i></a>.</dt>
  <dd>The Mach object file is malformed.</dd>
  <dt><code class="Er">89 ECANCELED</code> <i class="Em">Operation
    canceled</i>.</dt>
  <dd>The scheduled operation was canceled.</dd>
  <dt id="Identifier"><code class="Er">90 EIDRM</code>
    <a class="permalink" href="#Identifier"><i class="Em">Identifier
    removed</i></a>.</dt>
  <dd>An IPC identifier was removed while the current process was waiting on
    it.</dd>
  <dt><code class="Er">91 ENOMSG</code> <i class="Em">No message of desired
    type</i>.</dt>
  <dd>An IPC message queue does not contain a message of the desired type, or a
      message catalog does not contain the requested message.</dd>
  <dt><code class="Er">92 EILSEQ</code> <i class="Em">Illegal byte
    sequence</i>.</dt>
  <dd>While decoding a multibyte character the function came along an invalid or
      an incomplete sequence of bytes or the given wide character is
    invalid.</dd>
  <dt id="Attribute"><code class="Er">93 ENOATTR</code>
    <a class="permalink" href="#Attribute"><i class="Em">Attribute not
    found</i></a>.</dt>
  <dd>The specified extended attribute does not exist.</dd>
  <dt><code class="Er">94 EBADMSG</code> <i class="Em">Bad message</i>.</dt>
  <dd>The message to be received is inapprorpiate for the operation being
      attempted.</dd>
  <dt><code class="Er">95 EMULTIHOP</code> <i class="Em">Reserved</i>.</dt>
  <dd>This error is reserved for future use.</dd>
  <dt><code class="Er">96 ENODATA</code> <i class="Em">No message
    available</i>.</dt>
  <dd>No message was available to be received by the requested operation.</dd>
  <dt><code class="Er">97 ENOLINK</code> <i class="Em">Reserved</i>.</dt>
  <dd>This error is reserved for future use.</dd>
  <dt><code class="Er">98 ENOSR</code> <i class="Em">No STREAM
    resources</i>.</dt>
  <dd>This error is reserved for future use.</dd>
  <dt><code class="Er">99 ENOSTR</code> <i class="Em">Not a STREAM</i>.</dt>
  <dd>This error is reserved for future use.</dd>
  <dt><code class="Er">100 EPROTO</code> <i class="Em">Protocol error</i>.</dt>
  <dd>Some protocol error occurred. This error is device-specific, but is
      generally not related to a hardware failure.</dd>
  <dt id="STREAM"><code class="Er">101 ETIME</code>
    <a class="permalink" href="#STREAM"><i class="Em">STREAM ioctl()
    timeout</i></a>.</dt>
  <dd>This error is reserved for future use.</dd>
  <dt id="accept"><code class="Er">102 EOPNOTSUPP</code> <i class="Em">Operation
    not supported on socket</i>.</dt>
  <dd>The attempted operation is not supported for the type of socket
      referenced; for example, trying to
      <a class="permalink" href="#accept"><i class="Em">accept</i></a> a
      connection on a datagram socket.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="DEFINITIONS"><a class="permalink" href="#DEFINITIONS">DEFINITIONS</a></h1>
<dl class="Bl-tag">
  <dt>Process ID.</dt>
  <dd>Each active process in the system is uniquely identified by a non-negative
      integer called a process ID. The range of this ID is from 0 to 30000.</dd>
  <dt>Parent process ID</dt>
  <dd>A new process is created by a currently active process; (see
      <a class="Xr">fork(2)</a>). The parent process ID of a process is
      initially the process ID of its creator. If the creating process exits,
      the parent process ID of each child is set to the ID of a system process,
      <a class="Xr">launchd(8)</a>.</dd>
  <dt>Process Group</dt>
  <dd>Each active process is a member of a process group that is identified by a
      non-negative integer called the process group ID. This is the process ID
      of the group leader. This grouping permits the signaling of related
      processes (see <a class="Xr">termios(4)</a>) and the job control
      mechanisms of <a class="Xr">csh(1)</a>.</dd>
  <dt>Session</dt>
  <dd>A session is a set of one or more process groups. A session is created by
      a successful call to <a class="Xr">setsid(2)</a>, which causes the caller
      to become the only member of the only process group in the new
    session.</dd>
  <dt>Session leader</dt>
  <dd>A process that has created a new session by a successful call to
      <a class="Xr">setsid(2)</a>, is known as a session leader. Only a session
      leader may acquire a terminal as its controlling terminal (see
      <a class="Xr">termios(4)</a>).</dd>
  <dt>Controlling process</dt>
  <dd>A session leader with a controlling terminal is a controlling
    process.</dd>
  <dt>Controlling terminal</dt>
  <dd>A terminal that is associated with a session is known as the controlling
      terminal for that session and its members.</dd>
  <dt>Terminal Process Group ID</dt>
  <dd>A terminal may be acquired by a session leader as its controlling
      terminal. Once a terminal is associated with a session, any of the process
      groups within the session may be placed into the foreground by setting the
      terminal process group ID to the ID of the process group. This facility is
      used to arbitrate between multiple jobs contending for the same terminal;
      (see <a class="Xr">csh(1)</a> and <a class="Xr">tty(4)</a>).</dd>
  <dt id="orphaned">Orphaned Process Group</dt>
  <dd>A process group is considered to be
      <a class="permalink" href="#orphaned"><i class="Em">orphaned</i></a> if it
      is not under the control of a job control shell. More precisely, a process
      group is orphaned when none of its members has a parent process that is in
      the same session as the group, but is in a different process group. Note
      that when a process exits, the parent process for its children is changed
      to be <a class="Xr">launchd(8)</a>, which is in a separate session. Not
      all members of an orphaned process group are necessarily orphaned
      processes (those whose creating process has exited). The process group of
      a session leader is orphaned by definition.</dd>
  <dt>Real User ID and Real Group ID</dt>
  <dd>Each user on the system is identified by a positive integer termed the
      real user ID.
    <p class="Pp">Each user is also a member of one or more groups. One of these
        groups is distinguished from others and used in implementing accounting
        facilities. The positive integer corresponding to this distinguished
        group is termed the real group ID.</p>
    <p class="Pp">All processes have a real user ID and real group ID. These are
        initialized from the equivalent attributes of the process that created
        it.</p>
  </dd>
  <dt>Effective User Id, Effective Group Id, and Group Access List</dt>
  <dd>Access to system resources is governed by two values: the effective user
      ID, and the group access list. The first member of the group access list
      is also known as the effective group ID. (In POSIX.1, the group access
      list is known as the set of supplementary group IDs, and it is unspecified
      whether the effective group ID is a member of the list.)
    <p class="Pp">The effective user ID and effective group ID are initially the
        process's real user ID and real group ID respectively. Either may be
        modified through execution of a set-user-ID or set-group-ID file
        (possibly by one its ancestors) (see <a class="Xr">execve(2)</a>). By
        convention, the effective group ID (the first member of the group access
        list) is duplicated, so that the execution of a set-group-ID program
        does not result in the loss of the original (real) group ID.</p>
    <p class="Pp">The group access list is a set of group IDs used only in
        determining resource accessibility. Access checks are performed as
        described below in ``File Access Permissions''.</p>
  </dd>
  <dt>Saved Set User ID and Saved Set Group ID</dt>
  <dd>When a process executes a new file, the effective user ID is set to the
      owner of the file if the file is set-user-ID, and the effective group ID
      (first element of the group access list) is set to the group of the file
      if the file is set-group-ID. The effective user ID of the process is then
      recorded as the saved set-user-ID, and the effective group ID of the
      process is recorded as the saved set-group-ID. These values may be used to
      regain those values as the effective user or group ID after reverting to
      the real ID (see <a class="Xr">setuid(2)</a>). (In POSIX.1, the saved
      set-user-ID and saved set-group-ID are optional, and are used in setuid
      and setgid, but this does not work as desired for the super-user.)</dd>
  <dt id="super-user">Super-user</dt>
  <dd>A process is recognized as a
      <a class="permalink" href="#super-user"><i class="Em">super-user</i></a>
      process and is granted special privileges if its effective user ID is
    0.</dd>
  <dt>Special Processes</dt>
  <dd>The processes with process IDs of 0, 1, and 2 are special. Process 0 is
      the scheduler. Process 1 is the initialization process
      <a class="Xr">launchd(8)</a>, and is the ancestor of every other process
      in the system. It is used to control the process structure. Process 2 is
      the paging daemon.</dd>
  <dt>Descriptor</dt>
  <dd>An integer assigned by the system when a file is referenced by
      <a class="Xr">open(2)</a> or <a class="Xr">dup(2)</a>, or when a socket is
      created by <a class="Xr">pipe(2)</a>, <a class="Xr">socket(2)</a> or
      <a class="Xr">socketpair(2)</a>, which uniquely identifies an access path
      to that file or socket from a given process or any of its children.</dd>
  <dt>File Name</dt>
  <dd>Names consisting of up to 255 (<code class="Dv">MAXNAMELEN</code>)
      characters may be used to name an ordinary file, special file, or
      directory.
    <p class="Pp">These characters may be selected from the set of all ASCII
        character excluding 0 (NUL) and the ASCII code for
        &#x2018;<code class="Li">/</code>&#x2019; (slash).</p>
    <p class="Pp">Note that it is generally unwise to use
        &#x2018;<code class="Li">*</code>&#x2019;,
        &#x2018;<code class="Li">?</code>&#x2019;,
        &#x2018;<code class="Li">[</code>&#x2019; or
        &#x2018;<code class="Li">]</code>&#x2019; as part of file names because
        of the special meaning attached to these characters by the shell.</p>
  </dd>
  <dt>Path Name</dt>
  <dd>A path name is a NUL-terminated character string starting with an optional
      slash &#x2018;<code class="Li">/</code>&#x2019;, followed by zero or more
      directory names separated by slashes, optionally followed by a file name.
      The total length of a path name must be less than 1024
      (<code class="Dv">MAXPATHLEN</code>) characters.
    <p class="Pp" id="root">If a path name begins with a slash, the path search
        begins at the
        <a class="permalink" href="#root"><i class="Em">root</i></a> directory.
        Otherwise, the search begins from the current working directory. A slash
        by itself names the root directory. An empty pathname refers to the
        current directory.</p>
  </dd>
  <dt id="dot">Directory</dt>
  <dd>A directory is a special type of file that contains entries that are
      references to other files. Directory entries are called links. By
      convention, a directory contains at least two links,
      &#x2018;<code class="Li">.</code>&#x2019; and
      &#x2018;<code class="Li">..</code>&#x2019;, referred to as
      <a class="permalink" href="#dot"><i class="Em">dot</i></a> and
      <a class="permalink" href="#dot-dot"><i class="Em" id="dot-dot">dot-dot</i></a>
      respectively. Dot refers to the directory itself and dot-dot refers to its
      parent directory.</dd>
  <dt>Root Directory and Current Working Directory</dt>
  <dd>Each process has associated with it a concept of a root directory and a
      current working directory for the purpose of resolving path name searches.
      A process's root directory need not be the root directory of the root file
      system.</dd>
  <dt>File Access Permissions</dt>
  <dd>Every file in the file system has a set of access permissions. These
      permissions are used in determining whether a process may perform a
      requested operation on the file (such as opening a file for writing).
      Access permissions are established at the time a file is created. They may
      be changed at some later time through the <a class="Xr">chmod(2)</a> call.
    <p class="Pp">File access is broken down according to whether a file may be:
        read, written, or executed. Directory files use the execute permission
        to control if the directory may be searched.</p>
    <p class="Pp">File access permissions are interpreted by the system as they
        apply to three different classes of users: the owner of the file, those
        users in the file's group, anyone else. Every file has an independent
        set of access permissions for each of these classes. When an access
        check is made, the system decides if permission should be granted by
        checking the access information applicable to the caller.</p>
    <p class="Pp">Read, write, and execute/search permissions on a file are
        granted to a process if:</p>
    <p class="Pp">The process's effective user ID is that of the super-user.
        (Note: even the super-user cannot execute a non-executable file.)</p>
    <p class="Pp">The process's effective user ID matches the user ID of the
        owner of the file and the owner permissions allow the access.</p>
    <p class="Pp">The process's effective user ID does not match the user ID of
        the owner of the file, and either the process's effective group ID
        matches the group ID of the file, or the group ID of the file is in the
        process's group access list, and the group permissions allow the
      access.</p>
    <p class="Pp">Neither the effective user ID nor effective group ID and group
        access list of the process match the corresponding user ID and group ID
        of the file, but the permissions for ``other users'' allow access.</p>
    <p class="Pp">Otherwise, permission is denied.</p>
  </dd>
  <dt>Sockets and Address Families</dt>
  <dd>
    <p class="Pp">A socket is an endpoint for communication between processes.
        Each socket has queues for sending and receiving data.</p>
    <p class="Pp">Sockets are typed according to their communications
        properties. These properties include whether messages sent and received
        at a socket require the name of the partner, whether communication is
        reliable, the format used in naming message recipients, etc.</p>
    <p class="Pp">Each instance of the system supports some collection of socket
        types; consult <a class="Xr">socket(2)</a> for more information about
        the types available and their properties.</p>
    <p class="Pp">Each instance of the system supports some number of sets of
        communications protocols. Each protocol set supports addresses of a
        certain format. An Address Family is the set of addresses for a specific
        group of protocols. Each socket has an address chosen from the address
        family in which the socket was created.</p>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp"><a class="Xr">perror(3)</a></p>
</section>
<section class="Sh">
<h1 class="Sh" id="HISTORY"><a class="permalink" href="#HISTORY">HISTORY</a></h1>
<p class="Pp">An <code class="Nm">intro</code> manual page appeared in
    <span class="Ux">Version&#x00A0;6 AT&amp;T UNIX</span>.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">March 18, 2015</td>
    <td class="foot-os">BSD 4</td>
  </tr>
</table>
</body>
</html>
