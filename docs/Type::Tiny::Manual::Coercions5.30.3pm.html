<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>Type::Tiny::Manual::Coercions(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Type::Tiny::Manual::Coercions(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Type::Tiny::Manual::Coercions(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
Type::Tiny::Manual::Coercions - advanced information on coercions
</section>
<section class="Sh">
<h1 class="Sh" id="MANUAL"><a class="permalink" href="#MANUAL">MANUAL</a></h1>
This section of the manual assumes you've already read
  Type::Tiny::Manual::UsingWithMoo.
<p class="Pp">Type::Tiny takes a slightly different approach to type constraints
    from Moose. In Moose, there is a single flat namespace for type constraints.
    Moose defines a type constraint called <b>Str</b> for strings and a type
    constraint called <b>ArrayRef</b> for arrayrefs. If you want to define
    strings differently (maybe you think that the empty string doesn't really
    count as a string, or maybe you think objects overloading
    <span class="Li">&quot;q[&quot;&quot;]&quot;</span> should count as strings)
    then you can't call it <b>Str</b>; you need to choose a different name.</p>
<p class="Pp">With Type::Tiny, two type libraries can each offer a string type
    constraint with their own definitions for what counts as a string, and you
    can choose which one to import, or import them both with different
  names:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  use Some::Types qw( Str );
  use Other::Types &quot;Str&quot; =&gt; { -as =&gt; &quot;Str2&quot; };
</pre>
<p class="Pp">This might seem to be a small advantage of Type::Tiny, but where
    this global-versus-local philosophy really makes a difference is
  coercions.</p>
<p class="Pp">Let's imagine for a part of your application that deals with
    reading username and password data you need to have a
    &quot;username:password&quot; string. You may wish to accept a
    <span class="Li">&quot;[$username, $password]&quot;</span> arrayref and
    coerce it to a string using <span class="Li">&quot;join &quot;:&quot;,
    @$arrayref&quot;</span>. But another part of your application deals with
    slurping log files, and wants to coerce a string from an arrayref using
    <span class="Li">&quot;join &quot;\n&quot;, @$arrayref&quot;</span>. These
    are both perfectly sensible ways to coerce an arrayref. In Moose, a typical
    way to do this would be:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  package My::UserManager {
    use Moose;
    use Moose::Util::TypeConstraints;
    
    coerce 'Str',
      from 'ArrayRef', via { join &quot;:&quot;, @$_ };
    
    ...;
  }
  
  package My::LogReader {
    use Moose;
    use Moose::Util::TypeConstraints;
    
    coerce 'Str',
      from 'ArrayRef', via { join &quot;\n&quot;, @$_ };
    
    ...;
  }
</pre>
<p class="Pp">However, because in Moose all types and coercions are global, if
    both these classes are loaded, only one of them will work. One class will
    overrule the other's coercion. Which one &quot;wins&quot; will depend on
    load order.</p>
<p class="Pp">It is possible to solve this with Moose native types, but it
    requires extra work. (The solution is for My::UserManager and My::LogReader
    to each create a subtype of <b>Str</b> and define the coercion on that
    subtype instead of on <b>Str</b> directly.)</p>
<p class="Pp">Type::Tiny solves this in two ways:</p>
<dl class="Bl-tag">
  <dt>1.</dt>
  <dd>Type::Tiny makes it possible for type libraries to &quot;protect&quot;
      their type constraints to prevent external code from adding new coercions
      to them.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  $type-&gt;coercion-&gt;freeze();
    </pre>
    <p class="Pp">You can freeze coercions for your entire type library
      using:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  __PACKAGE__-&gt;make_immutable;
    </pre>
    <p class="Pp">If you try to add coercions to a type constraint that has
        frozen coercions, it will throw an error.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  use Types::Standard qw( Str ArrayRef );
  
  Str-&gt;coercion-&gt;add_type_coercions(
    ArrayRef, sub { join &quot;\n&quot;, @$_ },
  );
    </pre>
  </dd>
  <dt>2.</dt>
  <dd>Type::Tiny makes the above-mentioned pattern of adding coercions to a
      subtype much easier.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  use Types::Standard ( Str ArrayRef );
  
  my $subtype = Str-&gt;plus_coercions(
    ArrayRef, sub { join &quot;\n&quot;, @$_ },
  );
    </pre>
    <p class="Pp">The <span class="Li">&quot;plus_coercions&quot;</span> method
        creates a new child type, adds new coercions to it, copies any existing
        coercions from the parent type, and then freezes coercions for the new
        child type.</p>
    <p class="Pp">The end result is you now have a &quot;copy&quot; of
        <b>Str</b> that can coerce from <b>ArrayRef</b> but other copies of
        <b>Str</b> won't be affected by your coercion.</p>
  </dd>
</dl>
<section class="Ss">
<h2 class="Ss" id="Defining_Coercions_within_Type_Libraries"><a class="permalink" href="#Defining_Coercions_within_Type_Libraries">Defining
  Coercions within Type Libraries</a></h2>
Some coercions like joining an arrayref to make a string are not going to be
  coercions that everybody will agree on. Join with a line break in between them
  as above? Or with a colon, a tab, a space, some other chanaracter? It depends
  a lot on your application.
<p class="Pp">Others, like coercing a Path::Tiny object from a string, are
    likely to be very obvious. It is this kind of coercion that it makes sense
    to define within the library itself so it's available to any packages that
    use the library.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  my $pt = __PACKAGE__-&gt;add_type(
    Type::Tiny::Class-&gt;new(
      name    =&gt; 'Path',
      class   =&gt; 'Path::Tiny',
    ),
  );
  
  $pt-&gt;coercion-&gt;add_type_coercions(
    Str, q{ Path::Tiny::path($_) },
  );
  
  $pt-&gt;coercion-&gt;freeze;
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Tweak_Coercions_Outside_Type_Libraries"><a class="permalink" href="#Tweak_Coercions_Outside_Type_Libraries">Tweak
  Coercions Outside Type Libraries</a></h2>
The <span class="Li">&quot;plus_coercions&quot;</span> method creates a new type
  constraint with additional coercions. If the original type already had
  coercions, the new coercions have a higher priority.
<p class="Pp">There's also a
    <span class="Li">&quot;plus_fallback_coercions&quot;</span> method which
    does the same as <span class="Li">&quot;plus_coercions&quot;</span> but adds
    the new coercions with a lower priority than any existing ones.</p>
<p class="Pp">Type::Tiny::Class provides a
    <span class="Li">&quot;plus_constructors&quot;</span> method as a shortcut
    for coercing via a constructor method. The following two are the same:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  Path-&gt;plus_constructors(Str, &quot;new&quot;)
  
  Path-&gt;plus_coercions(Str, q{ Path::Tiny-&gt;new($_) })
</pre>
<p class="Pp">To create a type constraint without particular existing coercions,
    you can use <span class="Li">&quot;minus_coercions&quot;</span>. The
    following uses the <b>Datetime</b> type defined in
    Type::Tiny::Manual::Libraries, removing the coercion from <b>Int</b> but
    keeping the coercions from <b>Undef</b> and <b>Dict</b>.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  use Types::Standard qw( Int );
  use Example::Types qw( Datetime );
  
  has start_date =&gt; (
    is      =&gt; 'ro',
    isa     =&gt; Datetime-&gt;minus_coercions(Int),
    coerce  =&gt; 1,
  );
</pre>
<p class="Pp">There's also a <span class="Li">&quot;no_coercions&quot;</span>
    method that creates a subtype with no coercions at all. This is most useful
    either to create a &quot;blank slate&quot; for
    <span class="Li">&quot;plus_coercions&quot;</span>:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  my $Path = Path-&gt;no_coercions-&gt;plus_coercions(Str, sub { ... });
</pre>
<p class="Pp">Or to disable coercions for Type::Params. Type::Params will always
    automatically coerce a parameter if there is a coercion for that type.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  use Types::Standard qw( Object );
  use Types::Common::String qw( UpperCaseStr );
  use Type::Params;
  
  sub set_account_name {
    state $check = compile( Object, UpperCaseStr-&gt;no_coercions );
    my ($self, $name) = $check-&gt;(@_);
    $self-&gt;_account_name($name);
    $self-&gt;db-&gt;update($self);
    return $self;
  }
  
  # This will die instead of coercing from lowercase
  $robert-&gt;_set_account_name('bob');
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Named_Coercions"><a class="permalink" href="#Named_Coercions">Named
  Coercions</a></h2>
A compromise between defining a coercion in the type library or defining them in
  the package that uses the type library is for a type library to define a named
  collection of coercions which can be optionally added to a type constraint.
<p class="Pp"><span class="Li"></span></p>
<pre>
  {
    package MyApp::Types;
    use Type::Library -base;
    use Type::Utils qw( extends );
    
    BEGIN { extends 'Types::Standard' };
    
    __PACKAGE__-&gt;add_coercion(
      name              =&gt; &quot;FromLines&quot;,
      type_constraint   =&gt; ArrayRef,
      type_coercion_map =&gt; [
        Str,     q{ [split /\n/] },
        Undef,   q{ [] },
      ],
    );
  }
</pre>
<p class="Pp">This set of coercions has a name and can be imported and used:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  use MyApp::Types qw( ArrayRef FromLines );
  
  has lines =&gt; (
    is      =&gt; 'ro',
    isa     =&gt; ArrayRef-&gt;plus_coercions( FromLines ),
    coerce  =&gt; 1,
  );
</pre>
<p class="Pp">Types::Standard defines a named coercion <b>MkOpt</b> designed to
    be used for <b>OptList</b>.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  use Types::Standard qw( OptList MkOpt );
  my $OptList = OptList-&gt;plus_coercions(MkOpt);
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Parameterized_Coercions"><a class="permalink" href="#Parameterized_Coercions">Parameterized
  Coercions</a></h2>
Named coercions can also be parameterizable.
<p class="Pp"><span class="Li"></span></p>
<pre>
  my $ArrayOfLines = ArrayRef-&gt;plus_coercions( Split[ qr{\n} ] );
</pre>
<p class="Pp">Types::Standard defines <b>Split</b> and <b>Join</b>
    parameterizable coercions.</p>
<p class="Pp">Viewing the source code for Types::Standard should give you hints
    as to how they are implemented.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_Deep__Coercions"><a class="permalink" href="#_Deep__Coercions">&quot;Deep&quot;
  Coercions</a></h2>
Certain parameterized type constraints can automatically acquire coercions if
  their parameters have coercions. For example:
<p class="Pp"><span class="Li"></span></p>
<pre>
   ArrayRef[ Int-&gt;plus_coercions(Num, q{int($_)}) ]
</pre>
<p class="Pp">... does what you mean!</p>
<p class="Pp">The parameterized type constraints that do this magic include the
    following ones from Types::Standard:</p>
<ul class="Bl-bullet">
  <li><b>ScalarRef</b></li>
  <li><b>ArrayRef</b></li>
  <li><b>HashRef</b></li>
  <li><b>Map</b></li>
  <li><b>Tuple</b></li>
  <li><b>CycleTuple</b></li>
  <li><b>Dict</b></li>
  <li><b>Optional</b></li>
  <li><b>Maybe</b></li>
</ul>
<p class="Pp">Imagine we're defining a type <b>Paths</b> in a type library:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  __PACKAGE__-&gt;add_type(
    name      =&gt; 'Paths',
    parent    =&gt; ArrayRef[Path],
  );
</pre>
<p class="Pp">The <b>Path</b> type has a coercion from <b>Str</b>, so
    <b>Paths</b> should be able to coerce from an arrayref of strings,
  right?</p>
<p class="Pp"><i>Wrong!</i> Although <b>ArrayRef[Path]</b> could coerce from an
    arrayref of strings, <b>Paths</b> is a separate type constraint which,
    although it inherits from <b>ArrayRef[Path]</b> has its own (currently
    empty) set of coercions.</p>
<p class="Pp">Because that is often not what you want, Type::Tiny provides a
    shortcut when declaring a subtype to copy the parent type constraint's
    coercions:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  __PACKAGE__-&gt;add_type(
    name      =&gt; 'Paths',
    parent    =&gt; ArrayRef[Path],
    coercion  =&gt; 1,   # inherit
  );
</pre>
<p class="Pp">Now <b>Paths</b> can coerce from an arrayref of strings.</p>
<p class="Pp"><i>Deep Caveat</i></p>
<p class="Pp">Currently there exists ill-defined behaviour resulting from mixing
    deep coercions and mutable (non-frozen) coercions. Consider the
  following:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
   class_type Path, { class =&gt; &quot;Path::Tiny&quot; };
   coerce Path,
      from Str, via { &quot;Path::Tiny&quot;-&gt;new($_) };
   
   declare Paths, as ArrayRef[Path], coercion =&gt; 1;
   
   coerce Path,
      from InstanceOf[&quot;My::File&quot;], via { $_-&gt;get_path };
</pre>
<p class="Pp">An arrayref of strings can now be coerced to an arrayref of
    Path::Tiny objects, but is it also now possible to coerce an arrayref of
    My::File objects to an arrayref of Path::Tiny objects?</p>
<p class="Pp">Currently the answer is &quot;no&quot;, but this is mostly down to
    implementation details. It's not clear what the best way to behave in this
    situation is, and it could start working at some point in the future.</p>
<p class="Pp">This is why you should freeze coercions.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Chained_Coercions"><a class="permalink" href="#Chained_Coercions">Chained
  Coercions</a></h2>
Consider the following type library:
<p class="Pp"><span class="Li"></span></p>
<pre>
   package Types::Geometric {
      use Type::Library -base, -declare =&gt; qw(
         VectorArray
         VectorArray3D
         Point
         Point3D
      );
      use Type::Utils;
      use Types::Standard qw( Num Tuple InstanceOf );
      
      declare VectorArray,
         as Tuple[Num, Num];
      
      declare VectorArray3D,
         as Tuple[Num, Num, Num];
      
      coerce VectorArray3D,
         from VectorArray, via {
            [ @$_, 0 ];
         };
      
      class_type Point, { class =&gt; &quot;Point&quot; };
      
      coerce Point,
         from VectorArray, via {
            Point-&gt;new(x =&gt; $_-&gt;[0], y =&gt; $_-&gt;[1]);
         };
      
      class_type Point3D, { class =&gt; &quot;Point3D&quot; };
      
      coerce Point3D,
         from VectorArray3D, via {
            Point3D-&gt;new(x =&gt; $_-&gt;[0], y =&gt; $_-&gt;[1], z =&gt; $_-&gt;[2]);
         },
         from Point, via {
            Point3D-&gt;new(x =&gt; $_-&gt;x, y =&gt; $_-&gt;y, z =&gt; 0);
         };
   }
</pre>
<p class="Pp">Given an arrayref <span class="Li">&quot;[1, 1]&quot;</span> you
    might reasonably expect it to be coercible to a <b>Point3D</b> object; it
    matches the type constraint <b>VectorArray</b> so can be coerced to
    <b>VectorArray3D</b> and thus to <b>Point3D</b>.</p>
<p class="Pp">However, Type::Coercion does not automatically chain coercions
    like this. Firstly, it would be incompatible with Moose's type coercion
    system which does not chain coercions. Secondly, it's ambiguous; in our
    example, the arrayref could be coerced along two different paths (via
    <b>VectorArray3D</b> or via <b>Point</b>); in this case the end result would
    be the same, but in other cases it might not. Thirdly, it runs the risk of
    accidentally creating loops.</p>
<p class="Pp">Doing the chaining manually though is pretty simple. Firstly,
    we'll take note of the <span class="Li">&quot;coercibles&quot;</span> method
    in Type::Tiny. This method called as
    <span class="Li">&quot;VectorArray3D-&gt;coercibles&quot;</span> returns a
    type constraint meaning &quot;anything that can be coerced to a
    <b>VectorArray3D</b>&quot;.</p>
<p class="Pp">So we can define the coercions for <b>Point3D</b> as:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
   coerce Point3D,
      from VectorArray3D-&gt;coercibles, via {
         my $tmp = to_VectorArray3D($_);
         Point3D-&gt;new(x =&gt; $tmp-&gt;[0], y =&gt; $tmp-&gt;[1], z =&gt; $tmp-&gt;[2]);
      },
      from Point, via {
         Point3D-&gt;new(x =&gt; $_-&gt;x, y =&gt; $_-&gt;y, z =&gt; 0);
      };
</pre>
<p class="Pp">... and now coercing from <span class="Li">&quot;[1,
    1]&quot;</span> will work.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
Moose::Manual::BestPractices,
  &lt;https://web.archive.org/web/20090624164256/http://www.catalyzed.org/2009/06/keeping-your-coercions-to-yourself.html&gt;,
  MooseX::Types::MoreUtils.
</section>
<section class="Sh">
<h1 class="Sh" id="NEXT_STEPS"><a class="permalink" href="#NEXT_STEPS">NEXT
  STEPS</a></h1>
After that last example, probably have a little lie down. Once you're recovered,
  here's your next step:
<dl class="Bl-tag">
  <dt>&#x2022;</dt>
  <dd>Type::Tiny::Manual::AllTypes
    <p class="Pp">An alphabetical list of all type constraints bundled with
        Type::Tiny.</p>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
Toby Inkster &lt;tobyink@cpan.org&gt;.
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT_AND_LICENCE"><a class="permalink" href="#COPYRIGHT_AND_LICENCE">COPYRIGHT
  AND LICENCE</a></h1>
This software is copyright (c) 2013-2014, 2017-2020 by Toby Inkster.
<p class="Pp">This is free software; you can redistribute it and/or modify it
    under the same terms as the Perl 5 programming language system itself.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DISCLAIMER_OF_WARRANTIES"><a class="permalink" href="#DISCLAIMER_OF_WARRANTIES">DISCLAIMER
  OF WARRANTIES</a></h1>
THIS PACKAGE IS PROVIDED &quot;AS IS&quot; AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2020-10-28</td>
    <td class="foot-os">perl v5.30.2</td>
  </tr>
</table>
</body>
</html>
