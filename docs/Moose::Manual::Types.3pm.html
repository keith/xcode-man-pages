<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.10 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>Moose::Manual::Types(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Moose::Manual::Types(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Moose::Manual::Types(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
Moose::Manual::Types - Moose's type system
</section>
<section class="Sh">
<h1 class="Sh" id="VERSION"><a class="permalink" href="#VERSION">VERSION</a></h1>
version 2.2012
</section>
<section class="Sh">
<h1 class="Sh" id="TYPES_IN_PERL?"><a class="permalink" href="#TYPES_IN_PERL?">TYPES
  IN PERL?</a></h1>
Moose provides its own type system for attributes. You can also use these types
  to validate method parameters with the help of a MooseX module.
<p class="Pp">Moose's type system is based on a combination of Perl 5's own
    <i>implicit</i> types and some Perl 6 concepts. You can create your own
    subtypes with custom constraints, making it easy to express any sort of
    validation.</p>
<p class="Pp">Types have names, and you can re-use them by name, making it easy
    to share types throughout a large application.</p>
<p class="Pp">However, this is not a &quot;real&quot; type system. Moose does
    not magically make Perl start associating types with variables. This is just
    an advanced parameter checking system which allows you to associate a name
    with a constraint.</p>
<p class="Pp">That said, it's still pretty damn useful, and we think it's one of
    the things that makes Moose both fun and powerful. Taking advantage of the
    type system makes it much easier to ensure that you are getting valid data,
    and it also contributes greatly to code maintainability.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="THE_TYPES"><a class="permalink" href="#THE_TYPES">THE
  TYPES</a></h1>
The basic Moose type hierarchy looks like this
<p class="Pp"><span class="Li"></span></p>
<pre>
  Any
      Item
          Bool
          Maybe[`a]
          Undef
          Defined
              Value
                  Str
                      Num
                          Int
                      ClassName
                      RoleName
              Ref
                  ScalarRef[`a]
                  ArrayRef[`a]
                  HashRef[`a]
                  CodeRef
                  RegexpRef
                  GlobRef
                  FileHandle
                  Object
</pre>
<p class="Pp">In practice, the only difference between
    <span class="Li">&quot;Any&quot;</span> and
    <span class="Li">&quot;Item&quot;</span> is conceptual.
    <span class="Li">&quot;Item&quot;</span> is used as the top-level type in
    the hierarchy.</p>
<p class="Pp">The rest of these types correspond to existing Perl concepts. In
    particular:</p>
<ul class="Bl-bullet">
  <li><span class="Li">&quot;Bool&quot;</span> accepts <span class="Li">1</span>
      for true, and undef, 0, or the empty string as false.</li>
  <li><span class="Li">&quot;Maybe[`a]&quot;</span> accepts either
      <span class="Li">&quot;`a&quot;</span> or
      <span class="Li">&quot;undef&quot;</span>.</li>
  <li><span class="Li">&quot;Num&quot;</span> accepts integers, floating point
      numbers (both in decimal notation &amp; exponential notation), 0, .0, 0.0
      etc. It doesn't accept numbers with whitespace, Inf, Infinity, &quot;0 but
      true&quot;, NaN &amp; other such strings.</li>
  <li><span class="Li">&quot;ClassName&quot;</span> and
      <span class="Li">&quot;RoleName&quot;</span> accept strings that are
      either the name of a class or the name of a role. The class/role must
      already be loaded when the constraint is checked.</li>
  <li><span class="Li">&quot;FileHandle&quot;</span> accepts either an
      IO::Handle object or a builtin perl filehandle (see &quot;openhandle&quot;
      in Scalar::Util).</li>
  <li><span class="Li">&quot;Object&quot;</span> accepts any blessed
    reference.</li>
</ul>
<p class="Pp">The types followed by &quot;[`a]&quot; can be parameterized. So
    instead of just plain <span class="Li">&quot;ArrayRef&quot;</span> we can
    say that we want <span class="Li">&quot;ArrayRef[Int]&quot;</span> instead.
    We can even do something like
    <span class="Li">&quot;HashRef[ArrayRef[Str]]&quot;</span>.</p>
<p class="Pp">The <span class="Li">&quot;Maybe[`a]&quot;</span> type deserves a
    special mention. Used by itself, it doesn't really mean anything (and is
    equivalent to <span class="Li">&quot;Item&quot;</span>). When it is
    parameterized, it means that the value is either
    <span class="Li">&quot;undef&quot;</span> or the parameterized type. So
    <span class="Li">&quot;Maybe[Int]&quot;</span> means an integer or
    <span class="Li">&quot;undef&quot;</span>.</p>
<p class="Pp">For more details on the type hierarchy, see
    Moose::Util::TypeConstraints.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="WHAT_IS_A_TYPE?"><a class="permalink" href="#WHAT_IS_A_TYPE?">WHAT
  IS A TYPE?</a></h1>
It's important to realize that types are not classes (or packages). Types are
  just objects (Moose::Meta::TypeConstraint objects, to be exact) with a name
  and a constraint. Moose maintains a global type registry that lets it convert
  names like <span class="Li">&quot;Num&quot;</span> into the appropriate
  object.
<p class="Pp">However, class names <i>can be</i> type names. When you define a
    new class using Moose, it defines an associated type name behind the
  scenes:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  package MyApp::User;

  use Moose;
</pre>
<p class="Pp">Now you can use <span class="Li">'MyApp::User'</span> as a type
    name:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  has creator =&gt; (
      is  =&gt; 'ro',
      isa =&gt; 'MyApp::User',
  );
</pre>
<p class="Pp">However, for non-Moose classes there's no magic. You may have to
    explicitly declare the class type. This is a bit muddled because Moose
    assumes that any unknown type name passed as the
    <span class="Li">&quot;isa&quot;</span> value for an attribute is a class.
    So this works:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  has 'birth_date' =&gt; (
      is  =&gt; 'ro',
      isa =&gt; 'DateTime',
  );
</pre>
<p class="Pp">In general, when Moose is presented with an unknown name, it
    assumes that the name is a class:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  subtype 'ModernDateTime'
      =&gt; as 'DateTime'
      =&gt; where { $_-&gt;year() &gt;= 1980 }
      =&gt; message { 'The date you provided is not modern enough' };

  has 'valid_dates' =&gt; (
      is  =&gt; 'ro',
      isa =&gt; 'ArrayRef[DateTime]',
  );
</pre>
<p class="Pp">Moose will assume that
    <span class="Li">&quot;DateTime&quot;</span> is a class name in both of
    these instances.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SUBTYPES"><a class="permalink" href="#SUBTYPES">SUBTYPES</a></h1>
Moose uses subtypes in its built-in hierarchy. For example,
  <span class="Li">&quot;Int&quot;</span> is a child of
  <span class="Li">&quot;Num&quot;</span>.
<p class="Pp">A subtype is defined in terms of a parent type and a constraint.
    Any constraints defined by the parent(s) will be checked first, followed by
    constraints defined by the subtype. A value must pass <i>all</i> of these
    checks to be valid for the subtype.</p>
<p class="Pp">Typically, a subtype takes the parent's constraint and makes it
    more specific.</p>
<p class="Pp">A subtype can also define its own constraint failure message. This
    lets you do things like have an error &quot;The value you provided (20), was
    not a valid rating, which must be a number from 1-10.&quot; This is much
    friendlier than the default error, which just says that the value failed a
    validation check for the type. The default error can, however, be made more
    friendly by installing Devel::PartialDump (version 0.14 or higher), which
    Moose will use if possible to display the invalid value.</p>
<p class="Pp">Here's a simple (and useful) subtype example:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  subtype 'PositiveInt',
      as 'Int',
      where { $_ &gt; 0 },
      message { &quot;The number you provided, $_, was not a positive number&quot; };
</pre>
<p class="Pp">Note that the sugar functions for working with types are all
    exported by Moose::Util::TypeConstraints.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="TYPE_NAMES"><a class="permalink" href="#TYPE_NAMES">TYPE
  NAMES</a></h1>
Type names are global throughout the current Perl interpreter. Internally, Moose
  maps names to type objects via a registry.
<p class="Pp">If you have multiple apps or libraries all using Moose in the same
    process, you could have problems with collisions. We recommend that you
    prefix names with some sort of namespace indicator to prevent these sorts of
    collisions.</p>
<p class="Pp">For example, instead of calling a type &quot;PositiveInt&quot;,
    call it &quot;MyApp::Type::PositiveInt&quot; or
    &quot;MyApp::Types::PositiveInt&quot;. We recommend that you centralize all
    of these definitions in a single package,
    <span class="Li">&quot;MyApp::Types&quot;</span>, which can be loaded by
    other classes in your application.</p>
<p class="Pp">However, before you do this, you should look at the MooseX::Types
    module. This module makes it easy to create a &quot;type library&quot;
    module, which can export your types as perl constants.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  has 'counter' =&gt; (is =&gt; 'rw', isa =&gt; PositiveInt);
</pre>
<p class="Pp">This lets you use a short name rather than needing to fully
    qualify the name everywhere. It also allows you to easily create
    parameterized types:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  has 'counts' =&gt; (is =&gt; 'ro', isa =&gt; HashRef[PositiveInt]);
</pre>
<p class="Pp">This module will check your names at compile time, and is
    generally more robust than the string type parsing for complex cases.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COERCION"><a class="permalink" href="#COERCION">COERCION</a></h1>
A coercion lets you tell Moose to automatically convert one type to another.
<p class="Pp"><span class="Li"></span></p>
<pre>
  subtype 'ArrayRefOfInts',
      as 'ArrayRef[Int]';

  coerce 'ArrayRefOfInts',
      from 'Int',
      via { [ $_ ] };
</pre>
<p class="Pp">You'll note that we created a subtype rather than coercing
    <span class="Li">&quot;ArrayRef[Int]&quot;</span> directly. It's a bad idea
    to add coercions to the raw built in types.</p>
<p class="Pp">Coercions are global, just like type names, so a coercion applied
    to a built in type is seen by all modules using Moose types. This is
    <i>another</i> reason why it is good to namespace your types.</p>
<p class="Pp">Moose will <i>never</i> try to coerce a value unless you
    explicitly ask for it. This is done by setting the
    <span class="Li">&quot;coerce&quot;</span> attribute option to a true
  value:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  package Foo;

  has 'sizes' =&gt; (
      is     =&gt; 'ro',
      isa    =&gt; 'ArrayRefOfInts',
      coerce =&gt; 1,
  );

  Foo-&gt;new( sizes =&gt; 42 );
</pre>
<p class="Pp">This code example will do the right thing, and the newly created
    object will have <span class="Li">&quot;[ 42 ]&quot;</span> as its
    <span class="Li">&quot;sizes&quot;</span> attribute.</p>
<section class="Ss">
<h2 class="Ss" id="Deep_coercion"><a class="permalink" href="#Deep_coercion">Deep
  coercion</a></h2>
Deep coercion is the coercion of type parameters for parameterized types. Let's
  take these types as an example:
<p class="Pp"><span class="Li"></span></p>
<pre>
  subtype 'HexNum',
      as 'Str',
      where { /[a-f0-9]/i };

  coerce 'Int',
      from 'HexNum',
      via { hex $_ };

  has 'sizes' =&gt; (
      is     =&gt; 'ro',
      isa    =&gt; 'ArrayRef[Int]',
      coerce =&gt; 1,
  );
</pre>
<p class="Pp">If we try passing an array reference of hex numbers for the
    <span class="Li">&quot;sizes&quot;</span> attribute, Moose will not do any
    coercion.</p>
<p class="Pp">However, you can define a set of subtypes to enable coercion
    between two parameterized types.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  subtype 'ArrayRefOfHexNums',
      as 'ArrayRef[HexNum]';

  subtype 'ArrayRefOfInts',
      as 'ArrayRef[Int]';

  coerce 'ArrayRefOfInts',
      from 'ArrayRefOfHexNums',
      via { [ map { hex } @{$_} ] };

  Foo-&gt;new( sizes =&gt; [ 'a1', 'ff', '22' ] );
</pre>
<p class="Pp">Now Moose will coerce the hex numbers to integers.</p>
<p class="Pp">Moose does not attempt to chain coercions, so it will not coerce a
    single hex number. To do that, we need to define a separate coercion:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  coerce 'ArrayRefOfInts',
      from 'HexNum',
      via { [ hex $_ ] };
</pre>
<p class="Pp">Yes, this can all get verbose, but coercion is tricky magic, and
    we think it's best to make it explicit.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="TYPE_UNIONS"><a class="permalink" href="#TYPE_UNIONS">TYPE
  UNIONS</a></h1>
Moose allows you to say that an attribute can be of two or more disparate types.
  For example, we might allow an <span class="Li">&quot;Object&quot;</span> or
  <span class="Li">&quot;FileHandle&quot;</span>:
<p class="Pp"><span class="Li"></span></p>
<pre>
  has 'output' =&gt; (
      is  =&gt; 'rw',
      isa =&gt; 'Object | FileHandle',
  );
</pre>
<p class="Pp">Moose actually parses that string and recognizes that you are
    creating a type union. The <span class="Li">&quot;output&quot;</span>
    attribute will accept any sort of object, as well as an unblessed file
    handle. It is up to you to do the right thing for each of them in your
  code.</p>
<p class="Pp">Whenever you use a type union, you should consider whether or not
    coercion might be a better answer.</p>
<p class="Pp">For our example above, we might want to be more specific, and
    insist that output be an object with a
    <span class="Li">&quot;print&quot;</span> method:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  duck_type 'CanPrint', [qw(print)];
</pre>
<p class="Pp">We can coerce file handles to an object that satisfies this
    condition with a simple wrapper class:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  package FHWrapper;

  use Moose;

  has 'handle' =&gt; (
      is  =&gt; 'rw',
      isa =&gt; 'FileHandle',
  );

  sub print {
      my $self = shift;
      my $fh   = $self-&gt;handle();

      print {$fh} @_;
  }
</pre>
<p class="Pp">Now we can define a coercion from
    <span class="Li">&quot;FileHandle&quot;</span> to our wrapper class:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  coerce 'CanPrint'
      =&gt; from 'FileHandle'
      =&gt; via { FHWrapper-&gt;new( handle =&gt; $_ ) };

  has 'output' =&gt; (
      is     =&gt; 'rw',
      isa    =&gt; 'CanPrint',
      coerce =&gt; 1,
  );
</pre>
<p class="Pp">This pattern of using a coercion instead of a type union will help
    make your class internals simpler.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="TYPE_CREATION_HELPERS"><a class="permalink" href="#TYPE_CREATION_HELPERS">TYPE
  CREATION HELPERS</a></h1>
The Moose::Util::TypeConstraints module exports a number of helper functions for
  creating specific kinds of types. These include
  <span class="Li">&quot;class_type&quot;</span>,
  <span class="Li">&quot;role_type&quot;</span>,
  <span class="Li">&quot;maybe_type&quot;</span>, and
  <span class="Li">&quot;duck_type&quot;</span>. See the docs for details.
<p class="Pp">One helper worth noting is
    <span class="Li">&quot;enum&quot;</span>, which allows you to create a
    subtype of <span class="Li">&quot;Str&quot;</span> that only allows the
    specified values:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  enum 'RGB', [qw( red green blue )];
</pre>
<p class="Pp">This creates a type named
  <span class="Li">&quot;RGB&quot;</span>.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="ANONYMOUS_TYPES"><a class="permalink" href="#ANONYMOUS_TYPES">ANONYMOUS
  TYPES</a></h1>
All of the type creation functions return a type object. This type object can be
  used wherever you would use a type name, as a parent type, or as the value for
  an attribute's <span class="Li">&quot;isa&quot;</span> option:
<p class="Pp"><span class="Li"></span></p>
<pre>
  has 'size' =&gt; (
      is  =&gt; 'ro',
      isa =&gt; subtype( 'Int' =&gt; where { $_ &gt; 0 } ),
  );
</pre>
<p class="Pp">This is handy when you want to create a one-off type and don't
    want to &quot;pollute&quot; the global namespace registry.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="VALIDATING_METHOD_PARAMETERS"><a class="permalink" href="#VALIDATING_METHOD_PARAMETERS">VALIDATING
  METHOD PARAMETERS</a></h1>
Moose does not provide any means of validating method parameters. However, there
  are several MooseX extensions on CPAN which let you do this.
<p class="Pp">The simplest and least sugary is Params::ValidationCompiler. This
    lets you validate a set of named parameters using Moose types:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  use Moose::Util::TypeConstraints qw( find_type_constraint );
  use Params::ValidationCompiler qw( validation_for );

  {
      my $validator = validation_for(
          params =&gt; {
              foo =&gt; { type =&gt; find_type_constraint('Int') },
              bar =&gt; {
                  type     =&gt; find_type_constraint('Str'),
                  optional =&gt; 1,
              },
              baz =&gt; {
                  type    =&gt; find_type_constraint('Int'),
                  default =&gt; 42,
              },
          },
      );

      sub foo {
          my %args = $validator-&gt;(@_);
      }
}
</pre>
<p class="Pp">Params::ValidationCompiler also supports coercions.</p>
<p class="Pp">There are several more powerful extensions that support method
    parameter validation using Moose types, including Moops, which gives you a
    full-blown <span class="Li">&quot;method&quot;</span> keyword.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  method morning ( Str $name ) {
      $self-&gt;say(&quot;Good morning ${name}!&quot;);
  }
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="LOAD_ORDER_ISSUES"><a class="permalink" href="#LOAD_ORDER_ISSUES">LOAD
  ORDER ISSUES</a></h1>
Because Moose types are defined at runtime, you may run into load order
  problems. In particular, you may want to use a class's type constraint before
  that type has been defined.
<p class="Pp">In order to ameliorate this problem, we recommend defining
    <i>all</i> of your custom types in one module,
    <span class="Li">&quot;MyApp::Types&quot;</span>, and then loading this
    module in all of your other modules.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHORS"><a class="permalink" href="#AUTHORS">AUTHORS</a></h1>
<ul class="Bl-bullet">
  <li>Stevan Little &lt;stevan.little@iinteractive.com&gt;</li>
  <li>Dave Rolsky &lt;autarch@urth.org&gt;</li>
  <li>Jesse Luehrs &lt;doy@tozt.net&gt;</li>
  <li>Shawn M Moore &lt;code@sartak.org&gt;</li>
  <li>&#x05D9;&#x05D5;&#x05D1;&#x05DC; &#x05E7;&#x05D5;&#x05D2;'&#x05DE;&#x05DF;
      (Yuval Kogman) &lt;nothingmuch@woobling.org&gt;</li>
  <li>Karen Etheridge &lt;ether@cpan.org&gt;</li>
  <li>Florian Ragwitz &lt;rafl@debian.org&gt;</li>
  <li>Hans Dieter Pearcey &lt;hdp@weftsoar.net&gt;</li>
  <li>Chris Prather &lt;chris@prather.org&gt;</li>
  <li>Matt S Trout &lt;mst@shadowcat.co.uk&gt;</li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT_AND_LICENSE"><a class="permalink" href="#COPYRIGHT_AND_LICENSE">COPYRIGHT
  AND LICENSE</a></h1>
This software is copyright (c) 2006 by Infinity Interactive, Inc.
<p class="Pp">This is free software; you can redistribute it and/or modify it
    under the same terms as the Perl 5 programming language system itself.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2019-11-22</td>
    <td class="foot-os">perl v5.28.2</td>
  </tr>
</table>
</body>
</html>
