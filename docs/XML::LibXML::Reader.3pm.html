<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.10 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>XML::LibXML::Reader(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">XML::LibXML::Reader(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">XML::LibXML::Reader(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
XML::LibXML::Reader - XML::LibXML::Reader - interface to libxml2 pull parser
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<span class="Li"></span>
<pre>
  use XML::LibXML::Reader;



  my $reader = XML::LibXML::Reader-&gt;new(location =&gt; &quot;file.xml&quot;)
         or die &quot;cannot read file.xml\n&quot;;
  while ($reader-&gt;read) {
    processNode($reader);
  }



  sub processNode {
      my $reader = shift;
      printf &quot;%d %d %s %d\n&quot;, ($reader-&gt;depth,
                               $reader-&gt;nodeType,
                               $reader-&gt;name,
                               $reader-&gt;isEmptyElement);
  }
</pre>
<p class="Pp">or</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  my $reader = XML::LibXML::Reader-&gt;new(location =&gt; &quot;file.xml&quot;)
         or die &quot;cannot read file.xml\n&quot;;
    $reader-&gt;preservePattern('//table/tr');
    $reader-&gt;finish;
    print $reader-&gt;document-&gt;toString(1);
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
This is a perl interface to libxml2's pull-parser implementation xmlTextReader
  <i>http://xmlsoft.org/html/libxml-xmlreader.html</i>. This feature requires at
  least libxml2-2.6.21. Pull-parsers (such as StAX in Java, or XmlReader in C#)
  use an iterator approach to parse XML documents. They are easier to program
  than event-based parser (SAX) and much more lightweight than tree-based parser
  (DOM), which load the complete tree into memory.
<p class="Pp">The Reader acts as a cursor going forward on the document stream
    and stopping at each node in the way. At every point DOM-like methods of the
    Reader object allow to examine the current node (name, namespace,
    attributes, etc.)</p>
<p class="Pp">The user's code keeps control of the progress and simply calls the
    <span class="Li">&quot;read()&quot;</span> function repeatedly to progress
    to the next node in the document order. Other functions provide means for
    skipping complete sub-trees, or nodes until a specific element, etc.</p>
<p class="Pp">At every time, only a very limited portion of the document is kept
    in the memory, which makes the API more memory-efficient than using DOM.
    However, it is also possible to mix Reader with DOM. At every point the user
    may copy the current node (optionally expanded into a complete sub-tree)
    from the processed document to another DOM tree, or to instruct the Reader
    to collect sub-document in form of a DOM tree consisting of selected
  nodes.</p>
<p class="Pp">Reader API also supports namespaces, xml:base, entity handling,
    and DTD validation. Schema and RelaxNG validation support will probably be
    added in some later revision of the Perl interface.</p>
<p class="Pp">The naming of methods compared to libxml2 and C# XmlTextReader has
    been changed slightly to match the conventions of XML::LibXML. Some
    functions have been changed or added with respect to the C interface.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="CONSTRUCTOR"><a class="permalink" href="#CONSTRUCTOR">CONSTRUCTOR</a></h1>
Depending on the XML source, the Reader object can be created with either of:
<p class="Pp"><span class="Li"></span></p>
<pre>
  my $reader = XML::LibXML::Reader-&gt;new( location =&gt; &quot;file.xml&quot;, ... );
    my $reader = XML::LibXML::Reader-&gt;new( string =&gt; $xml_string, ... );
    my $reader = XML::LibXML::Reader-&gt;new( IO =&gt; $file_handle, ... );
    my $reader = XML::LibXML::Reader-&gt;new( FD =&gt; fileno(STDIN), ... );
    my $reader = XML::LibXML::Reader-&gt;new( DOM =&gt; $dom, ... );
</pre>
<p class="Pp">where ... are (optional) reader options described below in
    &quot;Reader options&quot; or various parser options described in
    XML::LibXML::Parser. The constructor recognizes the following XML
  sources:</p>
<section class="Ss">
<h2 class="Ss" id="Source_specification"><a class="permalink" href="#Source_specification">Source
  specification</a></h2>
<dl class="Bl-tag">
  <dt>location</dt>
  <dd>Read XML from a local file or URL.</dd>
  <dt>string</dt>
  <dd>Read XML from a string.</dd>
  <dt>IO</dt>
  <dd>Read XML a Perl IO filehandle.</dd>
  <dt>FD</dt>
  <dd>Read XML from a file descriptor (bypasses Perl I/O layer, only applicable
      to filehandles for regular files or pipes). Possibly faster than IO.</dd>
  <dt>DOM</dt>
  <dd>Use reader API to walk through a pre-parsed XML::LibXML::Document.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Reader_options"><a class="permalink" href="#Reader_options">Reader
  options</a></h2>
<dl class="Bl-tag">
  <dt>encoding =&gt; $encoding</dt>
  <dd>override document encoding.</dd>
  <dt>RelaxNG =&gt; $rng_schema</dt>
  <dd>can be used to pass either a XML::LibXML::RelaxNG object or a filename or
      URL of a RelaxNG schema to the constructor. The schema is then used to
      validate the document as it is processed.</dd>
  <dt>Schema =&gt; $xsd_schema</dt>
  <dd>can be used to pass either a XML::LibXML::Schema object or a filename or
      URL of a W3C XSD schema to the constructor. The schema is then used to
      validate the document as it is processed.</dd>
  <dt>...</dt>
  <dd>the reader further supports various parser options described in
      XML::LibXML::Parser (specifically those labeled by /reader/).</dd>
</dl>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="METHODS_CONTROLLING_PARSING_PROGRESS"><a class="permalink" href="#METHODS_CONTROLLING_PARSING_PROGRESS">METHODS
  CONTROLLING PARSING PROGRESS</a></h1>
<dl class="Bl-tag">
  <dt>read ()</dt>
  <dd>Moves the position to the next node in the stream, exposing its
      properties.
    <p class="Pp">Returns 1 if the node was read successfully, 0 if there is no
        more nodes to read, or -1 in case of error</p>
  </dd>
  <dt>readAttributeValue ()</dt>
  <dd>Parses an attribute value into one or more Text and EntityReference nodes.
    <p class="Pp">Returns 1 in case of success, 0 if the reader was not
        positioned on an attribute node or all the attribute values have been
        read, or -1 in case of error.</p>
  </dd>
  <dt>readState ()</dt>
  <dd>Gets the read state of the reader. Returns the state value, or -1 in case
      of error. The module exports constants for the Reader states, see STATES
      below.</dd>
  <dt>depth ()</dt>
  <dd>The depth of the node in the tree, starts at 0 for the root node.</dd>
  <dt>next ()</dt>
  <dd>Skip to the node following the current one in the document order while
      avoiding the sub-tree if any. Returns 1 if the node was read successfully,
      0 if there is no more nodes to read, or -1 in case of error.</dd>
  <dt>nextElement (localname?,nsURI?)</dt>
  <dd>Skip nodes following the current one in the document order until a
      specific element is reached. The element's name must be equal to a given
      localname if defined, and its namespace must equal to a given nsURI if
      defined. Either of the arguments can be undefined (or omitted, in case of
      the latter or both).
    <p class="Pp">Returns 1 if the element was found, 0 if there is no more
        nodes to read, or -1 in case of error.</p>
  </dd>
  <dt>nextPatternMatch (compiled_pattern)</dt>
  <dd>Skip nodes following the current one in the document order until an
      element matching a given compiled pattern is reached. See
      XML::LibXML::Pattern for information on compiled patterns. See also the
      <span class="Li">&quot;matchesPattern&quot;</span> method.
    <p class="Pp">Returns 1 if the element was found, 0 if there is no more
        nodes to read, or -1 in case of error.</p>
  </dd>
  <dt>skipSiblings ()</dt>
  <dd>Skip all nodes on the same or lower level until the first node on a higher
      level is reached. In particular, if the current node occurs in an element,
      the reader stops at the end tag of the parent element, otherwise it stops
      at a node immediately following the parent node.
    <p class="Pp">Returns 1 if successful, 0 if end of the document is reached,
        or -1 in case of error.</p>
  </dd>
  <dt>nextSibling ()</dt>
  <dd>It skips to the node following the current one in the document order while
      avoiding the sub-tree if any.
    <p class="Pp">Returns 1 if the node was read successfully, 0 if there is no
        more nodes to read, or -1 in case of error</p>
  </dd>
  <dt>nextSiblingElement (name?,nsURI?)</dt>
  <dd>Like nextElement but only processes sibling elements of the current node
      (moving forward using <span class="Li">&quot;nextSibling ()&quot;</span>
      rather than <span class="Li">&quot;read ()&quot;</span>, internally).
    <p class="Pp">Returns 1 if the element was found, 0 if there is no more
        sibling nodes, or -1 in case of error.</p>
  </dd>
  <dt>finish ()</dt>
  <dd>Skip all remaining nodes in the document, reaching end of the document.
    <p class="Pp">Returns 1 if successful, 0 in case of error.</p>
  </dd>
  <dt>close ()</dt>
  <dd>This method releases any resources allocated by the current instance and
      closes any underlying input. It returns 0 on failure and 1 on success.
      This method is automatically called by the destructor when the reader is
      forgotten, therefore you do not have to call it directly.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="METHODS_EXTRACTING_INFORMATION"><a class="permalink" href="#METHODS_EXTRACTING_INFORMATION">METHODS
  EXTRACTING INFORMATION</a></h1>
<dl class="Bl-tag">
  <dt>name ()</dt>
  <dd>Returns the qualified name of the current node, equal to
      (Prefix:)LocalName.</dd>
  <dt>nodeType ()</dt>
  <dd>Returns the type of the current node. See NODE TYPES below.</dd>
  <dt>localName ()</dt>
  <dd>Returns the local name of the node.</dd>
  <dt>prefix ()</dt>
  <dd>Returns the prefix of the namespace associated with the node.</dd>
  <dt>namespaceURI ()</dt>
  <dd>Returns the URI defining the namespace associated with the node.</dd>
  <dt>isEmptyElement ()</dt>
  <dd>Check if the current node is empty, this is a bit bizarre in the sense
      that &lt;a/&gt; will be considered empty while &lt;a&gt;&lt;/a&gt; will
      not.</dd>
  <dt>hasValue ()</dt>
  <dd>Returns true if the node can have a text value.</dd>
  <dt>value ()</dt>
  <dd>Provides the text value of the node if present or undef if not
    available.</dd>
  <dt>readInnerXml ()</dt>
  <dd>Reads the contents of the current node, including child nodes and markup.
      Returns a string containing the XML of the node's content, or undef if the
      current node is neither an element nor attribute, or has no child
    nodes.</dd>
  <dt>readOuterXml ()</dt>
  <dd>Reads the contents of the current node, including child nodes and markup.
    <p class="Pp">Returns a string containing the XML of the node including its
        content, or undef if the current node is neither an element nor
        attribute.</p>
  </dd>
  <dt><b>nodePath()</b></dt>
  <dd>Returns a canonical location path to the current element from the root
      node to the current node. Namespaced elements are matched by '*', because
      there is no way to declare prefixes within XPath patterns. Unlike
      <span class="Li">&quot;XML::LibXML::Node::nodePath()&quot;</span>, this
      function does not provide sibling counts (i.e. instead of e.g. '/a/b[1]'
      and '/a/b[2]' you get '/a/b' for both matches).</dd>
  <dt>matchesPattern(compiled_pattern)</dt>
  <dd>Returns a true value if the current node matches a compiled pattern. See
      XML::LibXML::Pattern for information on compiled patterns. See also the
      <span class="Li">&quot;nextPatternMatch&quot;</span> method.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="METHODS_EXTRACTING_DOM_NODES"><a class="permalink" href="#METHODS_EXTRACTING_DOM_NODES">METHODS
  EXTRACTING DOM NODES</a></h1>
<dl class="Bl-tag">
  <dt>document ()</dt>
  <dd>Provides access to the document tree built by the reader. This function
      can be used to collect the preserved nodes (see
      <span class="Li">&quot;preserveNode()&quot;</span> and preservePattern).
    <p class="Pp">CAUTION: Never use this function to modify the tree unless
        reading of the whole document is completed!</p>
  </dd>
  <dt>copyCurrentNode (deep)</dt>
  <dd>This function is similar a DOM function
      <span class="Li">&quot;copyNode()&quot;</span>. It returns a copy of the
      currently processed node as a corresponding DOM object. Use deep = 1 to
      obtain the full sub-tree.</dd>
  <dt>preserveNode ()</dt>
  <dd>This tells the XML Reader to preserve the current node in the document
      tree. A document tree consisting of the preserved nodes and their content
      can be obtained using the method
      <span class="Li">&quot;document()&quot;</span> once parsing is finished.
    <p class="Pp">Returns the node or NULL in case of error.</p>
  </dd>
  <dt>preservePattern (pattern,\%ns_map)</dt>
  <dd>This tells the XML Reader to preserve all nodes matched by the pattern
      (which is a streaming XPath subset). A document tree consisting of the
      preserved nodes and their content can be obtained using the method
      <span class="Li">&quot;document()&quot;</span> once parsing is finished.
    <p class="Pp">An optional second argument can be used to provide a HASH
        reference mapping prefixes used by the XPath to namespace URIs.</p>
    <p class="Pp">The XPath subset available with this function is described
      at</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  http://www.w3.org/TR/xmlschema-1/#Selector
    </pre>
    <p class="Pp">and matches the production</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  Path ::= ('.//')? ( Step '/' )* ( Step | '@' NameTest )
    </pre>
    <p class="Pp">Returns a positive number in case of success and -1 in case of
        error</p>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="METHODS_PROCESSING_ATTRIBUTES"><a class="permalink" href="#METHODS_PROCESSING_ATTRIBUTES">METHODS
  PROCESSING ATTRIBUTES</a></h1>
<dl class="Bl-tag">
  <dt>attributeCount ()</dt>
  <dd>Provides the number of attributes of the current node.</dd>
  <dt>hasAttributes ()</dt>
  <dd>Whether the node has attributes.</dd>
  <dt>getAttribute (name)</dt>
  <dd>Provides the value of the attribute with the specified qualified name.
    <p class="Pp">Returns a string containing the value of the specified
        attribute, or undef in case of error.</p>
  </dd>
  <dt>getAttributeNs (localName, namespaceURI)</dt>
  <dd>Provides the value of the specified attribute.
    <p class="Pp">Returns a string containing the value of the specified
        attribute, or undef in case of error.</p>
  </dd>
  <dt>getAttributeNo (no)</dt>
  <dd>Provides the value of the attribute with the specified index relative to
      the containing element.
    <p class="Pp">Returns a string containing the value of the specified
        attribute, or undef in case of error.</p>
  </dd>
  <dt>isDefault ()</dt>
  <dd>Returns true if the current attribute node was generated from the default
      value defined in the DTD.</dd>
  <dt>moveToAttribute (name)</dt>
  <dd>Moves the position to the attribute with the specified local name and
      namespace URI.
    <p class="Pp">Returns 1 in case of success, -1 in case of error, 0 if not
        found</p>
  </dd>
  <dt>moveToAttributeNo (no)</dt>
  <dd>Moves the position to the attribute with the specified index relative to
      the containing element.
    <p class="Pp">Returns 1 in case of success, -1 in case of error, 0 if not
        found</p>
  </dd>
  <dt>moveToAttributeNs (localName,namespaceURI)</dt>
  <dd>Moves the position to the attribute with the specified local name and
      namespace URI.
    <p class="Pp">Returns 1 in case of success, -1 in case of error, 0 if not
        found</p>
  </dd>
  <dt>moveToFirstAttribute ()</dt>
  <dd>Moves the position to the first attribute associated with the current
      node.
    <p class="Pp">Returns 1 in case of success, -1 in case of error, 0 if not
        found</p>
  </dd>
  <dt>moveToNextAttribute ()</dt>
  <dd>Moves the position to the next attribute associated with the current node.
    <p class="Pp">Returns 1 in case of success, -1 in case of error, 0 if not
        found</p>
  </dd>
  <dt>moveToElement ()</dt>
  <dd>Moves the position to the node that contains the current attribute node.
    <p class="Pp">Returns 1 in case of success, -1 in case of error, 0 if not
        moved</p>
  </dd>
  <dt>isNamespaceDecl ()</dt>
  <dd>Determine whether the current node is a namespace declaration rather than
      a regular attribute.
    <p class="Pp">Returns 1 if the current node is a namespace declaration, 0 if
        it is a regular attribute or other type of node, or -1 in case of
      error.</p>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="OTHER_METHODS"><a class="permalink" href="#OTHER_METHODS">OTHER
  METHODS</a></h1>
<dl class="Bl-tag">
  <dt>lookupNamespace (prefix)</dt>
  <dd>Resolves a namespace prefix in the scope of the current element.
    <p class="Pp">Returns a string containing the namespace URI to which the
        prefix maps or undef in case of error.</p>
  </dd>
  <dt>encoding ()</dt>
  <dd>Returns a string containing the encoding of the document or undef in case
      of error.</dd>
  <dt>standalone ()</dt>
  <dd>Determine the standalone status of the document being read. Returns 1 if
      the document was declared to be standalone, 0 if it was declared to be not
      standalone, or -1 if the document did not specify its standalone status or
      in case of error.</dd>
  <dt>xmlVersion ()</dt>
  <dd>Determine the XML version of the document being read. Returns a string
      containing the XML version of the document or undef in case of error.</dd>
  <dt>baseURI ()</dt>
  <dd>Returns the base URI of a given node.</dd>
  <dt>isValid ()</dt>
  <dd>Retrieve the validity status from the parser.
    <p class="Pp">Returns 1 if valid, 0 if no, and -1 in case of error.</p>
  </dd>
  <dt>xmlLang ()</dt>
  <dd>The xml:lang scope within which the node resides.</dd>
  <dt>lineNumber ()</dt>
  <dd>Provide the line number of the current parsing point.</dd>
  <dt>columnNumber ()</dt>
  <dd>Provide the column number of the current parsing point.</dd>
  <dt>byteConsumed ()</dt>
  <dd>This function provides the current index of the parser relative to the
      start of the current entity. This function is computed in bytes from the
      beginning starting at zero and finishing at the size in bytes of the file
      if parsing a file. The function is of constant cost if the input is UTF-8
      but can be costly if run on non-UTF-8 input.</dd>
  <dt>setParserProp (prop =&gt; value, ...)</dt>
  <dd>Change the parser processing behaviour by changing some of its internal
      properties. The following properties are available with this function:
      ``load_ext_dtd'', ``complete_attributes'', ``validation'',
      ``expand_entities''.
    <p class="Pp">Since some of the properties can only be changed before any
        read has been done, it is best to set the parsing properties at the
        constructor.</p>
    <p class="Pp">Returns 0 if the call was successful, or -1 in case of
      error</p>
  </dd>
  <dt>getParserProp (prop)</dt>
  <dd>Get value of an parser internal property. The following property names can
      be used: ``load_ext_dtd'', ``complete_attributes'', ``validation'',
      ``expand_entities''.
    <p class="Pp">Returns the value, usually 0 or 1, or -1 in case of error.</p>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="DESTRUCTION"><a class="permalink" href="#DESTRUCTION">DESTRUCTION</a></h1>
XML::LibXML takes care of the reader object destruction when the last reference
  to the reader object goes out of scope. The document tree is preserved,
  though, if either of <span class="Li">$reader</span>-&gt;document or
  <span class="Li">$reader</span>-&gt;preserveNode was used and references to
  the document tree exist.
</section>
<section class="Sh">
<h1 class="Sh" id="NODE_TYPES"><a class="permalink" href="#NODE_TYPES">NODE
  TYPES</a></h1>
The reader interface provides the following constants for node types (the
  constant symbols are exported by default or if tag
  <span class="Li">&quot;:types&quot;</span> is used).
<p class="Pp"><span class="Li"></span></p>
<pre>
  XML_READER_TYPE_NONE                    =&gt; 0
  XML_READER_TYPE_ELEMENT                 =&gt; 1
  XML_READER_TYPE_ATTRIBUTE               =&gt; 2
  XML_READER_TYPE_TEXT                    =&gt; 3
  XML_READER_TYPE_CDATA                   =&gt; 4
  XML_READER_TYPE_ENTITY_REFERENCE        =&gt; 5
  XML_READER_TYPE_ENTITY                  =&gt; 6
  XML_READER_TYPE_PROCESSING_INSTRUCTION  =&gt; 7
  XML_READER_TYPE_COMMENT                 =&gt; 8
  XML_READER_TYPE_DOCUMENT                =&gt; 9
  XML_READER_TYPE_DOCUMENT_TYPE           =&gt; 10
  XML_READER_TYPE_DOCUMENT_FRAGMENT       =&gt; 11
  XML_READER_TYPE_NOTATION                =&gt; 12
  XML_READER_TYPE_WHITESPACE              =&gt; 13
  XML_READER_TYPE_SIGNIFICANT_WHITESPACE  =&gt; 14
  XML_READER_TYPE_END_ELEMENT             =&gt; 15
  XML_READER_TYPE_END_ENTITY              =&gt; 16
  XML_READER_TYPE_XML_DECLARATION         =&gt; 17
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="STATES"><a class="permalink" href="#STATES">STATES</a></h1>
The following constants represent the values returned by
  <span class="Li">&quot;readState()&quot;</span>. They are exported by default,
  or if tag <span class="Li">&quot;:states&quot;</span> is used:
<p class="Pp"><span class="Li"></span></p>
<pre>
  XML_READER_NONE      =&gt; -1
  XML_READER_START     =&gt;  0
  XML_READER_ELEMENT   =&gt;  1
  XML_READER_END       =&gt;  2
  XML_READER_EMPTY     =&gt;  3
  XML_READER_BACKTRACK =&gt;  4
  XML_READER_DONE      =&gt;  5
  XML_READER_ERROR     =&gt;  6
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
XML::LibXML::Pattern for information about compiled patterns.
<p class="Pp">http://xmlsoft.org/html/libxml-xmlreader.html</p>
<p class="Pp">http://dotgnu.org/pnetlib-doc/System/Xml/XmlTextReader.html</p>
</section>
<section class="Sh">
<h1 class="Sh" id="ORIGINAL_IMPLEMENTATION"><a class="permalink" href="#ORIGINAL_IMPLEMENTATION">ORIGINAL
  IMPLEMENTATION</a></h1>
Heiko Klein, &lt;H.Klein@gmx.net&lt;gt&gt; and Petr Pajas
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHORS"><a class="permalink" href="#AUTHORS">AUTHORS</a></h1>
Matt Sergeant, Christian Glahn, Petr Pajas
</section>
<section class="Sh">
<h1 class="Sh" id="VERSION"><a class="permalink" href="#VERSION">VERSION</a></h1>
2.0110
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT"><a class="permalink" href="#COPYRIGHT">COPYRIGHT</a></h1>
2001-2007, AxKit.com Ltd.
<p class="Pp">2002-2006, Christian Glahn.</p>
<p class="Pp">2006-2009, Petr Pajas.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="LICENSE"><a class="permalink" href="#LICENSE">LICENSE</a></h1>
This program is free software; you can redistribute it and/or modify it under
  the same terms as Perl itself.
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2014-02-01</td>
    <td class="foot-os">perl v5.28.2</td>
  </tr>
</table>
</body>
</html>
