<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>HTML::HeadParser(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">HTML::HeadParser(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">HTML::HeadParser(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
HTML::HeadParser - Parse &lt;HEAD&gt; section of a HTML document
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<span class="Li"></span>
<pre>
 require HTML::HeadParser;
 $p = HTML::HeadParser-&gt;new;
 $p-&gt;parse($text) and  print &quot;not finished&quot;;

 $p-&gt;header('Title')          # to access &lt;title&gt;....&lt;/title&gt;
 $p-&gt;header('Content-Base')   # to access &lt;base href=&quot;http://...&quot;&gt;
 $p-&gt;header('Foo')            # to access &lt;meta http-equiv=&quot;Foo&quot; content=&quot;...&quot;&gt;
 $p-&gt;header('X-Meta-Author')  # to access &lt;meta name=&quot;author&quot; content=&quot;...&quot;&gt;
 $p-&gt;header('X-Meta-Charset') # to access &lt;meta charset=&quot;...&quot;&gt;
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
The <span class="Li">&quot;HTML::HeadParser&quot;</span> is a specialized (and
  lightweight) <span class="Li">&quot;HTML::Parser&quot;</span> that will only
  parse the &lt;HEAD&gt;...&lt;/HEAD&gt; section of an HTML document. The
  <b>parse()</b> method will return a FALSE value as soon as some &lt;BODY&gt;
  element or body text are found, and should not be called again after this.
<p class="Pp">Note that the <span class="Li">&quot;HTML::HeadParser&quot;</span>
    might get confused if raw undecoded UTF-8 is passed to the <b>parse()</b>
    method. Make sure the strings are properly decoded before passing them
  on.</p>
<p class="Pp">The <span class="Li">&quot;HTML::HeadParser&quot;</span> keeps a
    reference to a header object, and the parser will update this header object
    as the various elements of the &lt;HEAD&gt; section of the HTML document are
    recognized. The following header fields are affected:</p>
<dl class="Bl-tag">
  <dt>Content-Base:</dt>
  <dd>The <i>Content-Base</i> header is initialized from the &lt;base
      href=&quot;...&quot;&gt; element.</dd>
  <dt>Title:</dt>
  <dd>The <i>Title</i> header is initialized from the
      &lt;title&gt;...&lt;/title&gt; element.</dd>
  <dt>Isindex:</dt>
  <dd>The <i>Isindex</i> header will be added if there is a &lt;isindex&gt;
      element in the &lt;head&gt;. The header value is initialized from the
      <i>prompt</i> attribute if it is present. If no <i>prompt</i> attribute is
      given it will have '?' as the value.</dd>
  <dt>X-Meta-Foo:</dt>
  <dd>All &lt;meta&gt; elements containing a
      <span class="Li">&quot;name&quot;</span> attribute will result in headers
      using the prefix <span class="Li">&quot;X-Meta-&quot;</span> appended with
      the value of the <span class="Li">&quot;name&quot;</span> attribute as the
      name of the header, and the value of the
      <span class="Li">&quot;content&quot;</span> attribute as the pushed header
      value.
    <p class="Pp">&lt;meta&gt; elements containing a
        <span class="Li">&quot;http-equiv&quot;</span> attribute will result in
        headers as in above, but without the
        <span class="Li">&quot;X-Meta-&quot;</span> prefix in the header
      name.</p>
    <p class="Pp">&lt;meta&gt; elements containing a
        <span class="Li">&quot;charset&quot;</span> attribute will result in an
        <span class="Li">&quot;X-Meta-Charset&quot;</span> header, using the
        value of the <span class="Li">&quot;charset&quot;</span> attribute as
        the pushed header value.</p>
    <p class="Pp">The ':' character can't be represented in header field names,
        so if the meta element contains this char it's substituted with '-'
        before forming the field name.</p>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="METHODS"><a class="permalink" href="#METHODS">METHODS</a></h1>
The following methods (in addition to those provided by the superclass) are
  available:
<dl class="Bl-tag">
  <dt>$hp = HTML::HeadParser-&gt;new</dt>
  <dd></dd>
  <dt>$hp = HTML::HeadParser-&gt;new( $header )</dt>
  <dd>The object constructor. The optional <span class="Li">$header</span>
      argument should be a reference to an object that implement the
      <b>header()</b> and <b>push_header()</b> methods as defined by the
      <span class="Li">&quot;HTTP::Headers&quot;</span> class. Normally it will
      be of some class that is a or delegates to the
      <span class="Li">&quot;HTTP::Headers&quot;</span> class.
    <p class="Pp">If no <span class="Li">$header</span> is given
        <span class="Li">&quot;HTML::HeadParser&quot;</span> will create an
        <span class="Li">&quot;HTTP::Headers&quot;</span> object by itself
        (initially empty).</p>
  </dd>
  <dt>$hp-&gt;header;</dt>
  <dd>Returns a reference to the header object.</dd>
  <dt>$hp-&gt;header( $key )</dt>
  <dd>Returns a header value. It is just a shorter way to write
      <span class="Li">&quot;$hp-&gt;header-&gt;header($key)&quot;</span>.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="EXAMPLE"><a class="permalink" href="#EXAMPLE">EXAMPLE</a></h1>
<span class="Li"></span>
<pre>
 $h = HTTP::Headers-&gt;new;
 $p = HTML::HeadParser-&gt;new($h);
 $p-&gt;parse(&lt;&lt;EOT);
 &lt;title&gt;Stupid example&lt;/title&gt;
 &lt;base href=&quot;http://www.linpro.no/lwp/&quot;&gt;
 Normal text starts here.
 EOT
 undef $p;
 print $h-&gt;title;   # should print &quot;Stupid example&quot;
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
HTML::Parser, HTTP::Headers
<p class="Pp">The <span class="Li">&quot;HTTP::Headers&quot;</span> class is
    distributed as part of the <i>libwww-perl</i> package. If you don't have
    that distribution installed you need to provide the
    <span class="Li">$header</span> argument to the
    <span class="Li">&quot;HTML::HeadParser&quot;</span> constructor with your
    own object that implements the documented protocol.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT"><a class="permalink" href="#COPYRIGHT">COPYRIGHT</a></h1>
Copyright 1996-2001 Gisle Aas. All rights reserved.
<p class="Pp">This library is free software; you can redistribute it and/or
    modify it under the same terms as Perl itself.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2013-10-21</td>
    <td class="foot-os">perl v5.30.2</td>
  </tr>
</table>
</body>
</html>
