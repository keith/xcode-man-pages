<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>DBI::SQL::Nano(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">DBI::SQL::Nano(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">DBI::SQL::Nano(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
DBI::SQL::Nano - a very tiny SQL engine
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<span class="Li"></span>
<pre>
 BEGIN { $ENV{DBI_SQL_NANO}=1 } # forces use of Nano rather than SQL::Statement
 use DBI::SQL::Nano;
 use Data::Dumper;
 my $stmt = DBI::SQL::Nano::Statement-&gt;new(
     &quot;SELECT bar,baz FROM foo WHERE qux = 1&quot;
 ) or die &quot;Couldn't parse&quot;;
 print Dumper $stmt;
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<span class="Li">&quot;DBI::SQL::Nano&quot;</span> is meant as a <i>very</i>
  minimal SQL engine for use in situations where SQL::Statement is not
  available. In most situations you are better off installing SQL::Statement
  although DBI::SQL::Nano may be faster for some <b>very</b> simple tasks.
<p class="Pp">DBI::SQL::Nano, like SQL::Statement is primarily intended to
    provide a SQL engine for use with some pure perl DBDs including DBD::DBM,
    DBD::CSV, DBD::AnyData, and DBD::Excel. It is not of much use in and of
    itself. You can dump out the structure of a parsed SQL statement, but that
    is about it.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="USAGE"><a class="permalink" href="#USAGE">USAGE</a></h1>
<section class="Ss">
<h2 class="Ss" id="Setting_the__s-1DBI_SQL_NANO_s0_flag"><a class="permalink" href="#Setting_the__s-1DBI_SQL_NANO_s0_flag">Setting
  the DBI_SQL_NANO flag</a></h2>
By default, when a <span class="Li">&quot;DBD&quot;</span> uses
  <span class="Li">&quot;DBI::SQL::Nano&quot;</span>, the module will look to
  see if <span class="Li">&quot;SQL::Statement&quot;</span> is installed. If it
  is, SQL::Statement objects are used. If SQL::Statement is not available,
  DBI::SQL::Nano objects are used.
<p class="Pp">In some cases, you may wish to use DBI::SQL::Nano objects even if
    SQL::Statement is available. To force usage of DBI::SQL::Nano objects
    regardless of the availability of SQL::Statement, set the environment
    variable DBI_SQL_NANO to 1.</p>
<p class="Pp">You can set the environment variable in your shell prior to
    running your script (with SET or EXPORT or whatever), or else you can set it
    in your script by putting this at the top of the script:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
 BEGIN { $ENV{DBI_SQL_NANO} = 1 }
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Supported__s-1SQL_s0_syntax"><a class="permalink" href="#Supported__s-1SQL_s0_syntax">Supported
  SQL syntax</a></h2>
<span class="Li"></span>
<pre>
 Here's a pseudo-BNF.  Square brackets [] indicate optional items;
 Angle brackets &lt;&gt; indicate items defined elsewhere in the BNF.

  statement ::=
      DROP TABLE [IF EXISTS] &lt;table_name&gt;
    | CREATE TABLE &lt;table_name&gt; &lt;col_def_list&gt;
    | INSERT INTO &lt;table_name&gt; [&lt;insert_col_list&gt;] VALUES &lt;val_list&gt;
    | DELETE FROM &lt;table_name&gt; [&lt;where_clause&gt;]
    | UPDATE &lt;table_name&gt; SET &lt;set_clause&gt; &lt;where_clause&gt;
    | SELECT &lt;select_col_list&gt; FROM &lt;table_name&gt; [&lt;where_clause&gt;]
                                                 [&lt;order_clause&gt;]

  the optional IF EXISTS clause ::=
    * similar to MySQL - prevents errors when trying to drop
      a table that doesn't exist

  identifiers ::=
    * table and column names should be valid SQL identifiers
    * especially avoid using spaces and commas in identifiers
    * note: there is no error checking for invalid names, some
      will be accepted, others will cause parse failures

  table_name ::=
    * only one table (no multiple table operations)
    * see identifier for valid table names

  col_def_list ::=
    * a parens delimited, comma-separated list of column names
    * see identifier for valid column names
    * column types and column constraints may be included but are ignored
      e.g. these are all the same:
        (id,phrase)
        (id INT, phrase VARCHAR(40))
        (id INT PRIMARY KEY, phrase VARCHAR(40) NOT NULL)
    * you are *strongly* advised to put in column types even though
      they are ignored ... it increases portability

  insert_col_list ::=
    * a parens delimited, comma-separated list of column names
    * as in standard SQL, this is optional

  select_col_list ::=
    * a comma-separated list of column names
    * or an asterisk denoting all columns

  val_list ::=
    * a parens delimited, comma-separated list of values which can be:
       * placeholders (an unquoted question mark)
       * numbers (unquoted numbers)
       * column names (unquoted strings)
       * nulls (unquoted word NULL)
       * strings (delimited with single quote marks);
       * note: leading and trailing percent mark (%) and underscore (_)
         can be used as wildcards in quoted strings for use with
         the LIKE and CLIKE operators
       * note: escaped single quotation marks within strings are not
         supported, neither are embedded commas, use placeholders instead

  set_clause ::=
    * a comma-separated list of column = value pairs
    * see val_list for acceptable value formats

  where_clause ::=
    * a single &quot;column/value &lt;op&gt; column/value&quot; predicate, optionally
      preceded by &quot;NOT&quot;
    * note: multiple predicates combined with ORs or ANDs are not supported
    * see val_list for acceptable value formats
    * op may be one of:
         &lt; &gt; &gt;= &lt;= = &lt;&gt; LIKE CLIKE IS
    * CLIKE is a case insensitive LIKE

  order_clause ::= column_name [ASC|DESC]
    * a single column optional ORDER BY clause is supported
    * as in standard SQL, if neither ASC (ascending) nor
      DESC (descending) is specified, ASC becomes the default
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="TABLES"><a class="permalink" href="#TABLES">TABLES</a></h1>
DBI::SQL::Nano::Statement operates on exactly one table. This table will be
  opened by inherit from DBI::SQL::Nano::Statement and implements the
  <span class="Li">&quot;open_table&quot;</span> method.
<p class="Pp"><span class="Li"></span></p>
<pre>
  sub open_table ($$$$$)
  {
      ...
      return Your::Table-&gt;new( \%attributes );
  }
</pre>
<p class="Pp">DBI::SQL::Nano::Statement_ expects a rudimentary interface is
    implemented by the table object, as well as SQL::Statement expects.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  package Your::Table;

  use vars qw(@ISA);
  @ISA = qw(DBI::SQL::Nano::Table);

  sub drop ($$)        { ... }
  sub fetch_row ($$$)  { ... }
  sub push_row ($$$)   { ... }
  sub push_names ($$$) { ... }
  sub truncate ($$)    { ... }
  sub seek ($$$$)      { ... }
</pre>
<p class="Pp">The base class interfaces are provided by DBI::SQL::Nano::Table_
    in case of relying on DBI::SQL::Nano or SQL::Eval::Table (see SQL::Eval for
    details) otherwise.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="BUGS_AND_LIMITATIONS"><a class="permalink" href="#BUGS_AND_LIMITATIONS">BUGS
  AND LIMITATIONS</a></h1>
There are no known bugs in DBI::SQL::Nano::Statement. If you find a one and want
  to report, please see DBI for how to report bugs.
<p class="Pp">DBI::SQL::Nano::Statement is designed to provide a minimal subset
    for executing SQL statements.</p>
<p class="Pp">The most important limitation might be the restriction on one
    table per statement. This implies, that no JOINs are supported and there
    cannot be any foreign key relation between tables.</p>
<p class="Pp">The where clause evaluation of DBI::SQL::Nano::Statement is very
    slow (SQL::Statement uses a precompiled evaluation).</p>
<p class="Pp">INSERT can handle only one row per statement. To insert multiple
    rows, use placeholders as explained in DBI.</p>
<p class="Pp">The DBI::SQL::Nano parser is very limited and does not support any
    additional syntax such as brackets, comments, functions, aggregations
  etc.</p>
<p class="Pp">In contrast to SQL::Statement, temporary tables are not
  supported.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="ACKNOWLEDGEMENTS"><a class="permalink" href="#ACKNOWLEDGEMENTS">ACKNOWLEDGEMENTS</a></h1>
Tim Bunce provided the original idea for this module, helped me out of the
  tangled trap of namespaces, and provided help and advice all along the way.
  Although I wrote it from the ground up, it is based on Jochen Wiedmann's
  original design of SQL::Statement, so much of the credit for the API goes to
  him.
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR_AND_COPYRIGHT"><a class="permalink" href="#AUTHOR_AND_COPYRIGHT">AUTHOR
  AND COPYRIGHT</a></h1>
This module is originally written by Jeff Zucker &lt; jzucker AT cpan.org &gt;
<p class="Pp">This module is currently maintained by Jens Rehsack &lt; jrehsack
    AT cpan.org &gt;</p>
<p class="Pp">Copyright (C) 2010 by Jens Rehsack, all rights reserved. Copyright
    (C) 2004 by Jeff Zucker, all rights reserved.</p>
<p class="Pp">You may freely distribute and/or modify this module under the
    terms of either the GNU General Public License (GPL) or the Artistic
    License, as specified in the Perl README file.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2016-04-23</td>
    <td class="foot-os">perl v5.30.2</td>
  </tr>
</table>
</body>
</html>
