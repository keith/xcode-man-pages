<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Copyright (c) 2011 Apple Inc. All rights reserved.
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    .Nd, .Bf, .Op { display: inline; }
    .Pa, .Ad { font-style: italic; }
    .Ms { font-weight: bold; }
    .Bl-diag > dt { font-weight: bold; }
    code.Nm, .Fl, .Cm, .Ic, code.In, .Fd, .Fn, .Cd { font-weight: bold;
      font-family: inherit; }
  </style>
  <title>xpc_connection_create(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">xpc_connection_create(3)</td>
    <td class="head-vol">Library Functions Manual</td>
    <td class="head-rtitle">xpc_connection_create(3)</td>
  </tr>
</table>
<div class="manual-text">
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp"><code class="Nm">xpc_connection_create</code> &#x2014;
    <span class="Nd">creation and management of XPC connections</span></p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<p class="Pp"><code class="In">#include
    <a class="In">&lt;xpc/xpc.h&gt;</a></code></p>
<p class="Pp"><var class="Ft">xpc_connection_t</var>
  <br/>
  <code class="Fn">xpc_connection_create</code>(<var class="Fa">const char
    *name</var>, <var class="Fa">dispatch_queue_t targetq</var>);</p>
<p class="Pp"><var class="Ft">xpc_connection_t</var>
  <br/>
  <code class="Fn">xpc_connection_create_mach_service</code>(<var class="Fa">const
    char *name</var>, <var class="Fa">dispatch_queue_t targetq</var>,
    <var class="Fa">uint64_t flags</var>);</p>
<p class="Pp"><var class="Ft">xpc_connection_t</var>
  <br/>
  <code class="Fn">xpc_connection_create_from_endpoint</code>(<var class="Fa">xpc_endpoint_t
    endpoint</var>);</p>
<p class="Pp"><var class="Ft">void</var>
  <br/>
  <code class="Fn">xpc_connection_set_target_queue</code>(<var class="Fa">xpc_connection_t
    connection</var>, <var class="Fa">dispatch_queue_t targetq</var>);</p>
<p class="Pp"><var class="Ft">void</var>
  <br/>
  <code class="Fn">xpc_connection_set_event_handler</code>(<var class="Fa">xpc_connection_t
    connection</var>, <var class="Fa">xpc_handler_t handler</var>);</p>
<p class="Pp"><var class="Ft">void</var>
  <br/>
  <code class="Fn">xpc_connection_activate</code>(<var class="Fa">xpc_connection_t
    connection</var>);</p>
<p class="Pp"><var class="Ft">void</var>
  <br/>
  <code class="Fn">xpc_connection_suspend</code>(<var class="Fa">xpc_connection_t
    connection</var>);</p>
<p class="Pp"><var class="Ft">void</var>
  <br/>
  <code class="Fn">xpc_connection_resume</code>(<var class="Fa">xpc_connection_t
    connection</var>);</p>
<p class="Pp"><var class="Ft">void</var>
  <br/>
  <code class="Fn">xpc_connection_send_message</code>(<var class="Fa">xpc_connection_t
    connection</var>, <var class="Fa">xpc_object_t message</var>);</p>
<p class="Pp"><var class="Ft">void</var>
  <br/>
  <code class="Fn">xpc_connection_send_barrier</code>(<var class="Fa">xpc_connection_t
    connection</var>, <var class="Fa">dispatch_block_t barrier</var>);</p>
<p class="Pp"><var class="Ft">void</var>
  <br/>
  <code class="Fn">xpc_connection_send_message_with_reply</code>(<var class="Fa">xpc_connection_t
    connection</var>, <var class="Fa">xpc_object_t message</var>,
    <var class="Fa">dispatch_queue_t targetq</var>,
    <var class="Fa">xpc_handler_t handler</var>);</p>
<p class="Pp"><var class="Ft">xpc_object_t</var>
  <br/>
  <code class="Fn">xpc_connection_send_message_with_reply_sync</code>(<var class="Fa">xpc_connection_t
    connection</var>, <var class="Fa">xpc_object_t message</var>);</p>
<p class="Pp"><var class="Ft">void</var>
  <br/>
  <code class="Fn">xpc_connection_cancel</code>(<var class="Fa">xpc_connection_t
    connection</var>);</p>
<p class="Pp"><var class="Ft">const char *</var>
  <br/>
  <code class="Fn">xpc_connection_get_name</code>(<var class="Fa">xpc_connection_t
    connection</var>);</p>
<p class="Pp"><var class="Ft">uid_t</var>
  <br/>
  <code class="Fn">xpc_connection_get_euid</code>(<var class="Fa">xpc_connection_t
    connection</var>);</p>
<p class="Pp"><var class="Ft">gid_t</var>
  <br/>
  <code class="Fn">xpc_connection_get_guid</code>(<var class="Fa">xpc_connection_t
    connection</var>);</p>
<p class="Pp"><var class="Ft">pid_t</var>
  <br/>
  <code class="Fn">xpc_connection_get_pid</code>(<var class="Fa">xpc_connection_t
    connection</var>);</p>
<p class="Pp"><var class="Ft">au_asid_t</var>
  <br/>
  <code class="Fn">xpc_connection_get_asid</code>(<var class="Fa">xpc_connection_t
    connection</var>);</p>
<p class="Pp"><var class="Ft">void</var>
  <br/>
  <code class="Fn">xpc_connection_set_context</code>(<var class="Fa">xpc_connection_t
    connection</var>, <var class="Fa">void *ctx</var>);</p>
<p class="Pp"><var class="Ft">void *</var>
  <br/>
  <code class="Fn">xpc_connection_get_context</code>(<var class="Fa">xpc_connection_t
    connection</var>);</p>
<p class="Pp"><var class="Ft">void</var>
  <br/>
  <code class="Fn">xpc_connection_set_finalizer_f</code>(<var class="Fa">xpc_connection_t
    connection</var>, <var class="Fa">xpc_finalizer_t finalizer</var>);</p>
<p class="Pp"><var class="Ft">xpc_endpoint_t</var>
  <br/>
  <code class="Fn">xpc_endpoint_create</code>(<var class="Fa">xpc_connection_t
    connection</var>);</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">Connections are the fundamental primitives for sending and
    receiving messages. Connections also inform the caller of certain
    non-message events through errors.</p>
<p class="Pp">Messages sent to a connection are sent in FIFO order, and
    message-send operations over a connection are non-blocking. When a message
    is sent over a connection, it is atomically enqueued on a queue which is
    managed by the XPC runtime. As it becomes possible to successfully deliver
    messages to the remote end of the connection, messages will be dequeued from
    the queue and delivered.</p>
<p class="Pp">Connections may either be used to communicate with XPC services
    residing within an application bundle or with a MachService advertised by a
    launchd job in its <a class="Xr">launchd.plist(5)</a>. XPC connections
    maintain a one-to-one relationship between the local and remote ends of the
    connection. Therefore, for every connection created to a service, the remote
    end will see a distinct peer connection object. This model is semantically
    similar to the <a class="Xr">accept(3)</a> model, whereby the server listens
    on a single file descriptor, and that listening descriptor emits new file
    descriptors for each connection that occurs.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="EVENT_HANDLERS"><a class="permalink" href="#EVENT_HANDLERS">EVENT
  HANDLERS</a></h1>
<p class="Pp">Each connection must have an event handler associated with it. The
    event handler block takes one argument of type
    <var class="Fa">xpc_object_t</var>. The event handler block will deliver
    different types of objects depending on the nature of the event.</p>
<p class="Pp">The type of object can be queried using
    <a class="Xr">xpc_get_type(3)</a>. If the event handler block delivers an
    object of type <var class="Ft">XPC_TYPE_DICTIONARY</var>, the event is a
    message that needs processing. If the event handler delivers an object of
    type <var class="Ft">XPC_TYPE_ERROR</var>, an error has occurred on the
    connection that must be handled.</p>
<p class="Pp">Regardless of the type of object passed to the event handler, the
    caller will NOT implicitly gain a reference to the object. Therefore, if the
    caller wishes to work with the object after the event handler has returned,
    it should call <a class="Xr">xpc_retain(3)</a> to keep a reference on the
    object for itself from within the event handler. It is unsafe to retain the
    object after the event handler has returned.</p>
<p class="Pp" id="xpc_connection_set_event_handler">The event handler of a
    connection may be changed while the connection is processing events using
    the
    <a class="permalink" href="#xpc_connection_set_event_handler"><code class="Fn">xpc_connection_set_event_handler</code></a>()
    API. Calls to this API will <i class="Em">not</i> interrupt
    currently-executing invocations of the connection's event handler. Once the
    currently-executing event handler returns, the new event handler will take
    effect. If called from within the event handler itself, the next invocation
    of the event handler will honor the new one set.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="TARGET_QUEUES"><a class="permalink" href="#TARGET_QUEUES">TARGET
  QUEUES</a></h1>
<p class="Pp">Each connection has an associated target queue. All
    connection-related activity will happen on an internal queue which is
    synchronized with the target queue. Event handler invocations are included
    in connection-related activity. The target queue may be changed prior to
    activating the connection using the
    <code class="Fn">xpc_connection_set_target_queue</code>() API. Once a
    connection is activated or processing events, the queue may no longer be
    changed.</p>
<p class="Pp" id="xpc_connection_set_target_queue">By default, all connections
    target the <a class="Xr">DISPATCH_TARGET_QUEUE_DEFAULT(3)</a> queue. This
    queue will be used if NULL is given as the <var class="Fa">targetq</var>
    argument to
    <a class="permalink" href="#xpc_connection_set_target_queue"><code class="Fn">xpc_connection_set_target_queue</code></a>(),
    <code class="Fn">xpc_connection_create</code>() or
    <code class="Fn">xpc_connection_create_mach_service</code>(). Note that
    connections received either through the <a class="Xr">xpc_main(3)</a> event
    handler or the handler given to a connection created with the
    <var class="Ft">XPC_CONNECTION_MACH_SERVICE_LISTENER</var> flag do not
    inherit the target queue of that connection. It must always be set
    explicitly.</p>
<p class="Pp"><i class="Em">Important</i>: The result of calling
    <a class="Xr">dispatch_get_current_queue(3)</a> from within a connection's
    event handler is undefined and should not be considered reliable for
    attempting to avoid deadlocks.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="LAUNCH-ON-DEMAND"><a class="permalink" href="#LAUNCH-ON-DEMAND">LAUNCH-ON-DEMAND</a></h1>
<p class="Pp">When the caller obtains a connection to a named service, the fact
    that it has a connection does not imply anything about whether the remote
    end is alive and running. Connections are virtual, and if the remote end is
    not yet running, the act of sending a message will cause it to launch
    on-demand.</p>
<p class="Pp">If the caller has a connection to a named service, then the remote
    process closing the connection or crashing will deliver the
    <var class="Ft">XPC_ERROR_CONNECTION_INTERRUPTED</var> error to the event
    handler. This error is recoverable, and after receiving it, the connection
    is still usable. If the caller had previously sent state over the
    connection, this error indicates that that state should be updated, if
    needed, and resent.</p>
<p class="Pp" id="NOTE"><a class="permalink" href="#NOTE"><i class="Em">NOTE</i></a>:
    Services work best when they are as stateless as possible. Even if you write
    perfectly bug-free code, the libraries and frameworks your service links
    against may have bugs that could crash the service. So a service must be
    able to recover from such abnormal exits.</p>
<p class="Pp">One strategy for implementing a robust and recoverable service is
    to have each client of the service maintain state for the service. If the
    service crashes, then each client will detect that condition and resend the
    needed state to the service so that it can resume any interrupted
    operations.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="PEERING"><a class="permalink" href="#PEERING">PEERING</a></h1>
<p class="Pp">The local and remote ends of a connection have a one-to-one
    association. So when a new connection to a service is created and has a
    message sent over it, the service will receive a new connection in the event
    handler it specified to <a class="Xr">xpc_main(3)</a>. If the service is a
    MachService advertised by <a class="Xr">launchd(8)</a>, then the listener
    connection for the named service will receive the new connection in its
    event handler.</p>
<p class="Pp">Even if the same process creates multiple connections to the same
    service, each connection will be distinct. The peer connection received by
    the service will deliver <var class="Ft">XPC_ERROR_CONNECTION_INVALID</var>
    to its event handler when the connection has been closed. These peer
    connections cannot be re-created by the XPC runtime, and therefore they will
    never deliver the <var class="Ft">XPC_ERROR_CONNECTION_INTERRUPTED</var>
    error to their event handlers.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="ACTIVATE,_SUSPEND_AND_RESUME"><a class="permalink" href="#ACTIVATE,_SUSPEND_AND_RESUME">ACTIVATE,
  SUSPEND AND RESUME</a></h1>
<p class="Pp">All connections are created in an inactive state. Therefore, they
    will not begin processing messages or events until an initial call to
    <a class="permalink" href="#xpc_connection_activate"><code class="Fn" id="xpc_connection_activate">xpc_connection_activate</code></a>()
    is made. Before activating the connection, the caller must set an event
    handler using <code class="Fn">xpc_connection_set_event_handler</code>().
    Note that the activation does not need to immediately follow setting the
    event handler. The caller is free to delay the activation as long as it
    chooses.</p>
<p class="Pp">A connection may be suspended to halt the processing of incoming
    events and outgoing messages. This behavior is useful to rate-limit or
    throttle over-active clients who are sending too many messages or to allow
    certain synchronization behaviors with the internal state engine.</p>
<p class="Pp" id="xpc_connection_suspend">Each connection maintains a suspend
    count, so
    <a class="permalink" href="#xpc_connection_suspend"><code class="Fn">xpc_connection_suspend</code></a>()
    may be called multiple times on the same connection. The connection will
    resume processing events when an equal number of calls to
    <code class="Fn">xpc_connection_resume</code>() have been performed on the
    connection, resetting the suspend count to zero.</p>
<p class="Pp" id="All"><i class="Em">Important</i>:
    <a class="permalink" href="#All"><i class="Em">All</i></a> calls to
    <a class="permalink" href="#xpc_connection_suspend~2"><code class="Fn" id="xpc_connection_suspend~2">xpc_connection_suspend</code></a>()
    must be balanced by a call to
    <code class="Fn">xpc_connection_resume</code>() before the final reference
    on a connection is released. It is not valid to release the last reference
    on a suspended or inactive connection.</p>
<p class="Pp" id="xpc_connection_resume"><i class="Em">Important</i>: It is
    invalid to underflow the suspend count by calling
    <a class="permalink" href="#xpc_connection_resume"><code class="Fn">xpc_connection_resume</code></a>()
    more times than <code class="Fn">xpc_connection_suspend</code>() has been
    called.</p>
<p class="Pp" id="Backward"><a class="permalink" href="#Backward"><i class="Em">Backward
    compatibility</i></a>: For backward compatibility reasons, calling
    <a class="permalink" href="#xpc_connection_resume~2"><code class="Fn" id="xpc_connection_resume~2">xpc_connection_resume</code></a>()
    on an inactive connection that is not otherwise suspended behaves like a
    call to <code class="Fn">xpc_connection_activate</code>(). This behavior is
    referred to as the
    <a class="permalink" href="#initial"><i class="Em" id="initial">initial
    resume</i></a> of the connection in older XPC documentation.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="CONTEXT"><a class="permalink" href="#CONTEXT">CONTEXT</a></h1>
<p class="Pp">Connections may have associated context that can be set and
    retrieved using the <code class="Fn">xpc_connection_set_context</code>() and
    <code class="Fn">xpc_connection_get_context</code>() APIs, respectively.
    When setting context on a connection, an optional finalizer may be specified
    using <code class="Fn">xpc_connection_set_finalizer_f</code>(). The function
    given as the <var class="Fa">finalizer</var> argument will be invoked just
    before the connection's memory is being deallocated. For simple context
    structures allocated through <a class="Xr">malloc(3)</a>, this provides a
    convenient shortcut. For example:</p>
<div class="Bd Pp Bd-indent Li">
<pre>struct my_context_s *ctx = malloc(sizeof(*ctx));
xpc_connection_set_context(connection, ctx);
xpc_connection_set_finalizer_f(connection, free);</pre>
</div>
<p class="Pp"><i class="Em">Important</i>: The connection object itself should
    <i class="Em">not</i> be referenced or modified in any way within the
    context of the finalizer.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="MESSAGE_SENDING"><a class="permalink" href="#MESSAGE_SENDING">MESSAGE
  SENDING</a></h1>
<p class="Pp">Messages are sent to the remote end of a connection with the
    <a class="permalink" href="#xpc_connection_send_message"><code class="Fn" id="xpc_connection_send_message">xpc_connection_send_message</code></a>()
    API. This API will enqueue the <var class="Fa">message</var> in a FIFO queue
    which will be drained asynchronously by the XPC runtime. The caller should
    not assume that, when this API returns, the message has been delivered to
    the remote end. If the caller needs to know when the message has been
    processed by the runtime, it should call the
    <a class="permalink" href="#xpc_connection_send_barrier"><code class="Fn" id="xpc_connection_send_barrier">xpc_connection_send_barrier</code></a>()
    API directly after calling
    <code class="Fn">xpc_connection_send_message</code>(). The supplied
    <var class="Fa">barrier</var> block will be invoked by the connection when
    the runtime has finished processing the message.</p>
<section class="Ss">
<h2 class="Ss" id="Execution_Ordering"><a class="permalink" href="#Execution_Ordering">Execution
  Ordering</a></h2>
<p class="Pp">Send barriers are NOT immediately enqueued on the connection's
    target queue and therefore has no guaranteed execution order with respect to
    other blocks scheduled on that queue. The following code illustrates this
    anti-pattern:</p>
<div class="Bd Pp Bd-indent Li">
<pre>xpc_connection_set_target_queue(connection, queue);

static bool aboolean = false;
xpc_connection_send_barrier(connection, ^{
	aboolean = true;
});

dispatch_async(queue, ^{
	// Assertion will fail.
	assert(aboolean == true);
});</pre>
</div>
<p class="Pp">To achieve the desired effect of deferring the second block's
    execution until after the barrier has completed, the caller can use a
    dispatch group <a class="Xr">(dispatch_group_create(3))</a> as follows:</p>
<div class="Bd Pp Bd-indent Li">
<pre>xpc_connection_set_target_queue(connection, queue);

static bool aboolean = false;

dispatch_group_t group = dispatch_group_create();

dispatch_group_enter(group)
xpc_connection_send_barrier(connection, ^{
	aboolean = true;
	dispatch_group_leave(group);
});

dispatch_group_notify(group, queue, ^{
	assert(aboolean == true);
});</pre>
</div>
<p class="Pp">Alternatively, the caller can also
    <a class="Xr">dispatch_async(3)</a> the second block from within the barrier
    block.</p>
<p class="Pp"><i class="Em">Important</i>: The caller should not assume that the
    remote end of the connection has received the message when a barrier is
    invoked. Even though the message has been delivered to the remote end, the
    remote end may not have yet been scheduled for execution or may have
    suspended its end of the connection. The only way for the sender to know
    whether the remote end has received the message is to specify in its message
    protocol that the remote end must send a message back to the sender
    acknowledging receipt of the message.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="REPLY_MESSAGES"><a class="permalink" href="#REPLY_MESSAGES">REPLY
  MESSAGES</a></h1>
<p class="Pp">By default, all messages sent to a connection will result in an
    invocation of the remote end's connection's event handler with that message
    as the argument. If the caller wishes to tie the invocation of a particular
    block to a reply to a particular message, however, it may use the
    <a class="permalink" href="#xpc_connection_send_message_with_reply"><code class="Fn" id="xpc_connection_send_message_with_reply">xpc_connection_send_message_with_reply</code></a>()
    API. Like <code class="Fn">xpc_connection_send_message</code>(), this API
    will return immediately and, when the remote end sends a reply back, the
    supplied <var class="Fa">handler</var> block will be submitted to the
    supplied <var class="Fa">targetq</var> instead of causing the connection's
    event handler to be invoked. The reply handler block may deliver an error to
    the caller, which indicates that the remote end will never send a reply.</p>
<p class="Pp">The remote end must create the reply message by calling
    <a class="Xr">xpc_dictionary_create_reply(3)</a> and sending it to its peer
    connection as it normally would. The caller must, in turn, specify in the
    message itself whether it expects a reply to be delivered.</p>
<p class="Pp" id="CLIENT"><a class="permalink" href="#CLIENT"><i class="Em">CLIENT
    SIDE</i></a></p>
<div class="Bd Pp Bd-indent Li">
<pre>xpc_connection_send_message_with_reply(connection, message, replyq, ^(xpc_object_t reply) {
	if (xpc_get_type(reply) == XPC_TYPE_DICTIONARY) {
		// Process reply message that is specific to the message sent.
	} else {
		// There was an error, indicating that the caller will never receive
		// a reply to this message. Tear down any associated data structures.
	}
});</pre>
</div>
<p class="Pp" id="SERVICE"><a class="permalink" href="#SERVICE"><i class="Em">SERVICE
    SIDE</i></a></p>
<div class="Bd Pp Bd-indent Li">
<pre>void
handle_message(xpc_object_t message)
{
	if (xpc_dictionary_get_bool(message, &quot;ExpectsReply&quot;)) {
		// Sender has set the protocol-defined &quot;ExpectsReply&quot; key, and therefore
		// it expects the reply to be delivered specially.
		xpc_object_t reply = xpc_dictionary_create_reply(message);
		// Populate 'reply' as a normal dictionary.

		// This is the connection from which the message originated.
		xpc_connection_t remote = xpc_dictionary_get_remote_connection(message);
		xpc_connection_send_message(remote, reply);
		xpc_release(reply);
	} else {
		// The sender does not expect any kind of special reply.
	}
}</pre>
</div>
<p class="Pp"><i class="Em">Important</i>: The invocations of reply handlers are
    independent of the connection's normal incoming message stream. Therefore,
    reply messages are delivered to the recipient independently of the
    connection's normal FIFO semantics.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNCHRONOUS_OPERATION"><a class="permalink" href="#SYNCHRONOUS_OPERATION">SYNCHRONOUS
  OPERATION</a></h1>
<p class="Pp">If the caller needs to block execution until a reply to a message
    is received, it should use the
    <a class="permalink" href="#xpc_connection_send_message_with_reply_sync"><code class="Fn" id="xpc_connection_send_message_with_reply_sync">xpc_connection_send_message_with_reply_sync</code></a>()
    API. This result of this API will be the reply sent by the server. Like the
    handler given to
    <code class="Fn">xpc_connection_send_message_with_reply</code>(), this API
    may return errors indicating that the remote end of the connection will
    never deliver a reply.</p>
<p class="Pp"><i class="Em">Important</i>: This API is primarily intended for
    allowing existing synchronous API to be re- implemented in terms of XPC. But
    in cases where the you are designing a new API that calls out to a service
    to retrieve a value, we strongly encourage you to have the API return the
    value asynchronously using a queue/block pair rather than blocking the
    caller until the service returns the requested value:</p>
<div class="Bd Pp Bd-indent Li">
<pre>void
retrieve_uint64(dispatch_queue_t q, void (^handler)(uint64_t value))
{
	xpc_object_t message = xpc_dictionary_create(NULL, NULL, 0);
	xpc_dictionary_set_string(message, &quot;RetrieveValue&quot;, &quot;uint64&quot;);

	// 'connection' is a previously-created singleton.
	xpc_connection_send_message_with_reply(connection, message, q, ^(xpc_object_t reply) {
		if (xpc_get_type(reply) == XPC_TYPE_DICTIONARY) {
			uint64_t replyvalue = xpc_dictionary_get_uint64(reply, &quot;Value&quot;);
			// 'reply' is captured by this block and copied to the heap. It will
			// be released when this block is disposed of.
			handler(replyvalue);
		} else {
			// Invoke 'reply' with a value indicating that there was an error.
		}
		xpc_release(message);
	});
}</pre>
</div>
<p class="Pp">However, such a scheme may introduce unwanted complexity in the
    API. The trade- off for making the example implementation above synchronous
    involves factors such as where the data for the response comes from and how
    likely it is that the API will be called on the main thread.</p>
<p class="Pp">If the response will be constructed with data that exists
    in-memory in the server, it is usually safe to make the API synchronous. But
    if constructing the response requires I/O, and it is likely to be called
    from the main thread (or a thread which synchronizes with the main thread),
    we highly encourage that you take the asynchronous route to avoid the risk
    of blocking the UI.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="CREDENTIALS"><a class="permalink" href="#CREDENTIALS">CREDENTIALS</a></h1>
<p class="Pp">Identifying information about the sending processs can be obtained
    from a connection. Available credential information includes the sending
    process identifer (PID), effective user identifier (EUID), effective group
    identifier (EGID) and audit session identifier (ASID). These values can be
    obtained with the functions
    <a class="permalink" href="#xpc_connection_get_pid"><code class="Fn" id="xpc_connection_get_pid">xpc_connection_get_pid</code></a>(),
    <a class="permalink" href="#xpc_connection_get_euid"><code class="Fn" id="xpc_connection_get_euid">xpc_connection_get_euid</code></a>(),
    <a class="permalink" href="#xpc_connection_get_egid"><code class="Fn" id="xpc_connection_get_egid">xpc_connection_get_egid</code></a>()
    and
    <a class="permalink" href="#xpc_connection_get_asid"><code class="Fn" id="xpc_connection_get_asid">xpc_connection_get_asid</code></a>()
    respectively.</p>
<p class="Pp" id="xpc_connection_create">Credentials for a connection may not be
    immediately available. For example, when creating a new connection with
    <a class="permalink" href="#xpc_connection_create"><code class="Fn">xpc_connection_create</code></a>(),
    XPC will not know the credentials of the remote end of the connection until
    it has actually exchanged messages with it. Until this credential
    information is filled in, these methods will return sensible values to
    indicate absence of crucial information.
    <code class="Fn">xpc_connection_get_pid</code>() will return 0,
    <code class="Fn">xpc_connection_get_euid</code>() and
    <code class="Fn">xpc_connection_get_egid</code>() will return -1 and
    <code class="Fn">xpc_connection_get_asid</code>() will return AU_ASSIGN_ASID
    (see <a class="Xr">setaudit_addr(2))</a>.</p>
<p class="Pp">For peer connections received through a listener's event handler
    or through the handler given to <a class="Xr">xpc_main(3)</a>, credentials
    will be immediately available.</p>
<p class="Pp">Connection credentials have similar semantics to file descriptor
    credentials. That is, the credentials that the connection was created with
    are &quot;baked in&quot; to it and do not change as a result of calls to
    <a class="Xr">setuid(3)</a> and friends. Use of these APIs is heavily
    discouraged in IPC protocols due to the inherently racy nature of credential
    checking.</p>
<p class="Pp"><i class="Em">Important</i>: PIDs on OS X roll over when they
    reach a relatively small value, and a given PID cannot be assumed to be
    unique for a given boot session. For services bundled with an application,
    this is not a practical concern because the application is the only process
    capable of looking up its services. But MachServices advertised through
    launchd have a much higher visibility, so extra care should be taken when
    checking credentials to mitigate <a class="Xr">fork(2)</a> bomb-style
    attacks.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="CANCELLATION"><a class="permalink" href="#CANCELLATION">CANCELLATION</a></h1>
<p class="Pp">A connection may be canceled when it is no longer needed. Once
    canceled, a connection will receive the
    <var class="Ft">XPC_ERROR_CONNECTION_INVALID</var> error in its event
    handler, and no further events will be delivered. Cancellation does not
    affect the reference count of the connection, so if you hold references to
    the connection, they must still be released in order for all of the
    connection's associated resources to be freed.</p>
<p class="Pp" id="xpc_connection_cancel">Note that, if a connection receives
    <var class="Ft">XPC_ERROR_CONNECTION_INVALID</var> in its event handler due
    to other circumstances, it is already in a canceled state, and therefore a
    call to
    <a class="permalink" href="#xpc_connection_cancel"><code class="Fn">xpc_connection_cancel</code></a>()
    is unnecessary (but harmless) in this case.</p>
<p class="Pp">Canceling a connection on one side has effects on the other side
    of a connection. For example, if you cancel a connection received through a
    listener connection's event handler, the remote peer connection will receive
    <var class="Ft">XPC_ERROR_CONNECTION_INTERRUPTED</var> in its event handler.
    Even though the connection was canceled, the remote end is still able to
    send messages to the connection.</p>
<p class="Pp">If, on the other hand, the creator of a named connection cancels
    the connection, the peer connection given to the remote end through a
    listener connection will receive
    <var class="Ft">XPC_ERROR_CONNECTION_INVALID</var> in its event handler.</p>
<p class="Pp" id="xpc_connection_create~2"><i class="Em">Important</i>: As
    discussed previously, some connections (such as named connections created
    through
    <a class="permalink" href="#xpc_connection_create~2"><code class="Fn">xpc_connection_create</code></a>())
    will not receive <var class="Ft">XPC_ERROR_CONNECTION_INVALID</var> in the
    normal course of their operation. But if another part of your code can end
    up calling <code class="Fn">xpc_connection_cancel</code>(), then the
    connection's event handler must handle this error.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="BUNDLED_SERVICES"><a class="permalink" href="#BUNDLED_SERVICES">BUNDLED
  SERVICES</a></h1>
<p class="Pp">Applications may include XPC service bundles in their own bundle.
    When the application is run, the XPC runtime automatically recognizes each
    bundled service and makes it accessible to the application through the
    <code class="Fn">xpc_connection_create</code>() API. To connect to a bundled
    service, the caller must pass the CFBundleIdentifier specified in the
    service's Info.plist as the <var class="Fa">name</var> argument. The service
    itself will call <a class="Xr">xpc_main(3)</a> to initialize its runtime,
    and the provided event handler function will be invoked with any incoming
    connections.</p>
<p class="Pp" id="only">Services bundled with an application are
    <a class="permalink" href="#only"><i class="Em">only</i></a> accessible to
    that application. An external process cannot connect to those services.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="MACH_SERVICES"><a class="permalink" href="#MACH_SERVICES">MACH
  SERVICES</a></h1>
<p class="Pp">If a caller wishes to connect to a MachService advertised in a
    <a class="Xr">launchd.plist(5)</a>, it should pass the MachService name to
    which it wishes to connect with
    <a class="permalink" href="#xpc_connection_create_mach_service"><code class="Fn" id="xpc_connection_create_mach_service">xpc_connection_create_mach_service</code></a>().
    If the destination service is advertised in the root Mach bootstrap (i.e.
    the <a class="Xr">launchd.plist(5)</a> lives in /Library/LaunchDaemons), the
    caller may ensure that the service that it connects to is privileged and not
    being spoofed through a man-in-the-middle attack by OR'ing the
    <var class="Ft">XPC_CONNECTION_MACH_SERVICE_PRIVILEGED</var> flag into the
    <var class="Fa">flags</var> argument. This flag will cause
    <var class="Ft">XPC_ERROR_CONNECTION_INVALID</var> to be given to the event
    handler if the service name was not found in the root Mach bootstrap. If the
    <a class="Xr">launchd.plist(5)</a> lives in /Library/LaunchAgents or
    ~/Library/LaunchAgents, then this flag should not be passed.</p>
<p class="Pp" id="xpc_connection_create_mach_service~2">The launchd job using
    XPC is required to create a listener connection manually by calling
    <a class="permalink" href="#xpc_connection_create_mach_service~2"><code class="Fn">xpc_connection_create_mach_service</code></a>()
    with the <var class="Ft">XPC_CONNECTION_MACH_SERVICE_LISTENER</var> flag
    OR'ed into the <var class="Fa">flags</var> argument. The
    <var class="Fa">XPC_CONNECTION_MACH_SERVICE_PRIVILEGED</var> flag has no
    effect on these connections. If the service name for the connection is not
    present in your launchd.plist's MachServices dictionary, your listener
    connection's event handler will receive the XPC_ERROR_CONNECTION_INVALID
    error, as XPC disallows ad-hoc service name registrations. However, assuming
    your configuration is correct, the listener connection will only ever
    deliver new peer connections to its event handler. The connections received
    by the event handler must have an event hander set on them and resumed along
    with an optional target queue, just like the peer connections delivered to
    the handler given to <a class="Xr">xpc_main(3)</a>. Note connections
    received through listener connection's event handler do not inherit the
    target queue of the listener.</p>
<div class="Bd Pp Bd-indent Li">
<pre>int
main(void)
{
	xpc_connection_t listener = xpc_connection_create_mach_service(&quot;com.apple.myservice&quot;, NULL, XPC_CONNECTION_MACH_SERVICE_LISTENER);
	xpc_connection_set_event_handler(listener, ^(xpc_object_t peer) {
		// It is safe to cast 'peer' to xpc_connection_t assuming
		// we have a correct configuration in our launchd.plist.
		xpc_connection_set_event_handler(peer, ^(xpc_object_t event) {
			// Handle event, whether it is a message or an error.
		});
		xpc_connection_activate(peer);
	});
	xpc_connection_activate(listener);

	dispatch_main();
	exit(EXIT_FAILURE);
}</pre>
</div>
<p class="Pp" id="xpc_connection_create_mach_service~3"><i class="Em">Important</i>:
    New service names may <i class="Em">NOT</i> be dynamically registered using
    <a class="permalink" href="#xpc_connection_create_mach_service~3"><code class="Fn">xpc_connection_create_mach_service</code></a>().
    Only launchd jobs may listen on certain service names, and any service name
    that the job wishes to listen on must be declared in its
    <a class="Xr">launchd.plist(5)</a>. XPC may make allowances for dynamic name
    registration in debug scenarios, but these allowances absolutely will
    <i class="Em">NOT</i> be made in the production scenario.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="UNLOADING"><a class="permalink" href="#UNLOADING">UNLOADING</a></h1>
<p class="Pp">An XPC connection to a MachService advertised by a
    <a class="Xr">launchd(8)</a> job will receive the
    <var class="Ft">XPC_ERROR_CONNECTION_INTERRUPTED</var> error followed by the
    <var class="Ft">XPC_ERROR_CONNECTION_INVALID</var> error if the job is
    unloaded. There will be no indication of when the job has been loaded again.
    Using job loading and unloading as a normal part of your job's operation is
    highly discouraged.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="ANONYMOUS_CONNECTIONS"><a class="permalink" href="#ANONYMOUS_CONNECTIONS">ANONYMOUS
  CONNECTIONS</a></h1>
<p class="Pp">If a caller wishes to create a listener connection that is not
    bound to a particular service name, it may create an anonymous listener
    connection by calling <code class="Fn">xpc_connection_create</code>() and
    passing NULL as the <var class="Fa">name</var>. This connection may be given
    to <a class="Xr">xpc_endpoint_create(3)</a>, and the result may be embedded
    in a message. The recipient of that message will then be able to create a
    connection from that endpoint using
    <a class="permalink" href="#xpc_connection_create_from_endpoint"><code class="Fn" id="xpc_connection_create_from_endpoint">xpc_connection_create_from_endpoint</code></a>().</p>
<p class="Pp" id="xpc_connection_create~3">The resulting connection will behave
    like a connection to a named service created using
    <a class="permalink" href="#xpc_connection_create~3"><code class="Fn">xpc_connection_create</code></a>().
    The fundamental difference is that an anonymous connection is not backed a
    name that can be looked up. Therefore, if an connection created from an
    endpoint is closed, there is no guarantee that it can be re-established. So
    anonymous connections' event handlers must always handle
    <a class="permalink" href="#both"><i class="Em" id="both">both</i></a> the
    <var class="Ft">XPC_ERROR_CONNECTION_INTERRUPTED</var> and
    <var class="Ft">XPC_ERROR_CONNECTION_INVALID</var> errors.</p>
<p class="Pp">The <var class="Ft">endpoint</var> type may be thought of as a
    boxed connection, in the same way that the <var class="Ft">uint64</var> type
    is a boxed <var class="Ft">uint64_t</var>. Like other types, the collection
    APIs provide primitive setters and getters for connections, so instead of
    first boxing a connection in an endpoint, the
    <a class="Xr">xpc_dictionary_set_connection(3)</a>,
    <a class="Xr">xpc_dictionary_create_connection(3)</a>,
    <a class="Xr">xpc_array_set_connection(3)</a>, and
    <a class="Xr">xpc_array_create_connection(3)</a> APIs may be used.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp"><a class="Xr">xpc(3)</a>, <a class="Xr">xpc_main(3)</a>,
    <a class="Xr">xpc_object(3)</a>, <a class="Xr">xpc_dictionary_create(3)</a>,
    <a class="Xr">xpc_objects(3)</a>, <a class="Xr">setaudit_addr(2)</a>,
    <a class="Xr">dispatch_group_create(3)</a></p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">20 June, 2012</td>
    <td class="foot-os">Darwin</td>
  </tr>
</table>
</body>
</html>
