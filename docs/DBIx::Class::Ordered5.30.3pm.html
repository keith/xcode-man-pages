<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>DBIx::Class::Ordered(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">DBIx::Class::Ordered(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">DBIx::Class::Ordered(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
DBIx::Class::Ordered - Modify the position of objects in an ordered list.
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
Create a table for your ordered data.
<p class="Pp"><span class="Li"></span></p>
<pre>
  CREATE TABLE items (
    item_id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT NOT NULL,
    position INTEGER NOT NULL
  );
</pre>
<p class="Pp">Optionally, add one or more columns to specify groupings, allowing
    you to maintain independent ordered lists within one table:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  CREATE TABLE items (
    item_id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT NOT NULL,
    position INTEGER NOT NULL,
    group_id INTEGER NOT NULL
  );
</pre>
<p class="Pp">Or even</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  CREATE TABLE items (
    item_id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT NOT NULL,
    position INTEGER NOT NULL,
    group_id INTEGER NOT NULL,
    other_group_id INTEGER NOT NULL
  );
</pre>
<p class="Pp">In your Schema or DB class add &quot;Ordered&quot; to the top of
    the component list.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  __PACKAGE__-&gt;load_components(qw( Ordered ... ));
</pre>
<p class="Pp">Specify the column that stores the position number for each
  row.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  package My::Item;
  __PACKAGE__-&gt;position_column('position');
</pre>
<p class="Pp">If you are using one grouping column, specify it as follows:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  __PACKAGE__-&gt;grouping_column('group_id');
</pre>
<p class="Pp">Or if you have multiple grouping columns:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  __PACKAGE__-&gt;grouping_column(['group_id', 'other_group_id']);
</pre>
<p class="Pp">That's it, now you can change the position of your objects.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  #!/use/bin/perl
  use My::Item;

  my $item = My::Item-&gt;create({ name=&gt;'Matt S. Trout' });
  # If using grouping_column:
  my $item = My::Item-&gt;create({ name=&gt;'Matt S. Trout', group_id=&gt;1 });

  my $rs = $item-&gt;siblings();
  my @siblings = $item-&gt;siblings();

  my $sibling;
  $sibling = $item-&gt;first_sibling();
  $sibling = $item-&gt;last_sibling();
  $sibling = $item-&gt;previous_sibling();
  $sibling = $item-&gt;next_sibling();

  $item-&gt;move_previous();
  $item-&gt;move_next();
  $item-&gt;move_first();
  $item-&gt;move_last();
  $item-&gt;move_to( $position );
  $item-&gt;move_to_group( 'groupname' );
  $item-&gt;move_to_group( 'groupname', $position );
  $item-&gt;move_to_group( {group_id=&gt;'groupname', 'other_group_id=&gt;'othergroupname'} );
  $item-&gt;move_to_group( {group_id=&gt;'groupname', 'other_group_id=&gt;'othergroupname'}, $position );
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
This module provides a simple interface for modifying the ordered position of
  DBIx::Class objects.
</section>
<section class="Sh">
<h1 class="Sh" id="AUTO_UPDATE"><a class="permalink" href="#AUTO_UPDATE">AUTO
  UPDATE</a></h1>
All of the move_* methods automatically update the rows involved in the query.
  This is not configurable and is due to the fact that if you move a record it
  always causes other records in the list to be updated.
</section>
<section class="Sh">
<h1 class="Sh" id="METHODS"><a class="permalink" href="#METHODS">METHODS</a></h1>
<section class="Ss">
<h2 class="Ss" id="position_column"><a class="permalink" href="#position_column">position_column</a></h2>
<span class="Li"></span>
<pre>
  __PACKAGE__-&gt;position_column('position');
</pre>
<p class="Pp">Sets and retrieves the name of the column that stores the
    positional value of each record. Defaults to &quot;position&quot;.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="grouping_column"><a class="permalink" href="#grouping_column">grouping_column</a></h2>
<span class="Li"></span>
<pre>
  __PACKAGE__-&gt;grouping_column('group_id');
</pre>
<p class="Pp">This method specifies a column to limit all queries in this module
    by. This effectively allows you to have multiple ordered lists within the
    same table.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="null_position_value"><a class="permalink" href="#null_position_value">null_position_value</a></h2>
<span class="Li"></span>
<pre>
  __PACKAGE__-&gt;null_position_value(undef);
</pre>
<p class="Pp">This method specifies a value of &quot;position_column&quot; which
    <b>would</b> <b>never be assigned to a row</b> during normal operation. When
    a row is moved, its position is set to this value temporarily, so that any
    unique constraints can not be violated. This value defaults to 0, which
    should work for all cases except when your positions do indeed start from
  0.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="siblings"><a class="permalink" href="#siblings">siblings</a></h2>
<span class="Li"></span>
<pre>
  my $rs = $item-&gt;siblings();
  my @siblings = $item-&gt;siblings();
</pre>
<p class="Pp">Returns an <b>ordered</b> resultset of all other objects in the
    same group excluding the one you called it on.</p>
<p class="Pp">The ordering is a backwards-compatibility artifact - if you need a
    resultset with no ordering applied use
    <span class="Li">&quot;_siblings&quot;</span></p>
</section>
<section class="Ss">
<h2 class="Ss" id="previous_siblings"><a class="permalink" href="#previous_siblings">previous_siblings</a></h2>
<span class="Li"></span>
<pre>
  my $prev_rs = $item-&gt;previous_siblings();
  my @prev_siblings = $item-&gt;previous_siblings();
</pre>
<p class="Pp">Returns a resultset of all objects in the same group positioned
    before the object on which this method was called.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="next_siblings"><a class="permalink" href="#next_siblings">next_siblings</a></h2>
<span class="Li"></span>
<pre>
  my $next_rs = $item-&gt;next_siblings();
  my @next_siblings = $item-&gt;next_siblings();
</pre>
<p class="Pp">Returns a resultset of all objects in the same group positioned
    after the object on which this method was called.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="previous_sibling"><a class="permalink" href="#previous_sibling">previous_sibling</a></h2>
<span class="Li"></span>
<pre>
  my $sibling = $item-&gt;previous_sibling();
</pre>
<p class="Pp">Returns the sibling that resides one position back. Returns 0 if
    the current object is the first one.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="first_sibling"><a class="permalink" href="#first_sibling">first_sibling</a></h2>
<span class="Li"></span>
<pre>
  my $sibling = $item-&gt;first_sibling();
</pre>
<p class="Pp">Returns the first sibling object, or 0 if the first sibling is
    this sibling.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="next_sibling"><a class="permalink" href="#next_sibling">next_sibling</a></h2>
<span class="Li"></span>
<pre>
  my $sibling = $item-&gt;next_sibling();
</pre>
<p class="Pp">Returns the sibling that resides one position forward. Returns 0
    if the current object is the last one.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="last_sibling"><a class="permalink" href="#last_sibling">last_sibling</a></h2>
<span class="Li"></span>
<pre>
  my $sibling = $item-&gt;last_sibling();
</pre>
<p class="Pp">Returns the last sibling, or 0 if the last sibling is this
    sibling.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="move_previous"><a class="permalink" href="#move_previous">move_previous</a></h2>
<span class="Li"></span>
<pre>
  $item-&gt;move_previous();
</pre>
<p class="Pp">Swaps position with the sibling in the position previous in the
    list. Returns 1 on success, and 0 if the object is already the first
  one.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="move_next"><a class="permalink" href="#move_next">move_next</a></h2>
<span class="Li"></span>
<pre>
  $item-&gt;move_next();
</pre>
<p class="Pp">Swaps position with the sibling in the next position in the list.
    Returns 1 on success, and 0 if the object is already the last in the
  list.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="move_first"><a class="permalink" href="#move_first">move_first</a></h2>
<span class="Li"></span>
<pre>
  $item-&gt;move_first();
</pre>
<p class="Pp">Moves the object to the first position in the list. Returns 1 on
    success, and 0 if the object is already the first.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="move_last"><a class="permalink" href="#move_last">move_last</a></h2>
<span class="Li"></span>
<pre>
  $item-&gt;move_last();
</pre>
<p class="Pp">Moves the object to the last position in the list. Returns 1 on
    success, and 0 if the object is already the last one.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="move_to"><a class="permalink" href="#move_to">move_to</a></h2>
<span class="Li"></span>
<pre>
  $item-&gt;move_to( $position );
</pre>
<p class="Pp">Moves the object to the specified position. Returns 1 on success,
    and 0 if the object is already at the specified position.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="move_to_group"><a class="permalink" href="#move_to_group">move_to_group</a></h2>
<span class="Li"></span>
<pre>
  $item-&gt;move_to_group( $group, $position );
</pre>
<p class="Pp">Moves the object to the specified position of the specified group,
    or to the end of the group if <span class="Li">$position</span> is undef. 1
    is returned on success, and 0 is returned if the object is already at the
    specified position of the specified group.</p>
<p class="Pp"><span class="Li">$group</span> may be specified as a single scalar
    if only one grouping column is in use, or as a hashref of column =&gt; value
    pairs if multiple grouping columns are in use.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="insert"><a class="permalink" href="#insert">insert</a></h2>
Overrides the DBIC <b>insert()</b> method by providing a default position
  number. The default will be the number of rows in the table +1, thus
  positioning the new record at the last position.
</section>
<section class="Ss">
<h2 class="Ss" id="update"><a class="permalink" href="#update">update</a></h2>
Overrides the DBIC <b>update()</b> method by checking for a change to the
  position and/or group columns. Movement within a group or to another group is
  handled by repositioning the appropriate siblings. Position defaults to the
  end of a new group if it has been changed to undef.
</section>
<section class="Ss">
<h2 class="Ss" id="delete"><a class="permalink" href="#delete">delete</a></h2>
Overrides the DBIC <b>delete()</b> method by first moving the object to the last
  position, then deleting it, thus ensuring the integrity of the positions.
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="METHODS_FOR_EXTENDING_ORDERED"><a class="permalink" href="#METHODS_FOR_EXTENDING_ORDERED">METHODS
  FOR EXTENDING ORDERED</a></h1>
You would want to override the methods below if you use sparse (non-linear) or
  non-numeric position values. This can be useful if you are working with
  preexisting non-normalised position data, or if you need to work with
  materialized path columns.
<section class="Ss">
<h2 class="Ss" id="_position_from_value"><a class="permalink" href="#_position_from_value">_position_from_value</a></h2>
<span class="Li"></span>
<pre>
  my $num_pos = $item-&gt;_position_from_value ( $pos_value )
</pre>
<p class="Pp">Returns the <b>absolute numeric position</b> of an object with a
    <b>position</b> <b>value</b> set to <span class="Li">$pos_value</span>. By
    default simply returns <span class="Li">$pos_value</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_position_value"><a class="permalink" href="#_position_value">_position_value</a></h2>
<span class="Li"></span>
<pre>
  my $pos_value = $item-&gt;_position_value ( $pos )
</pre>
<p class="Pp">Returns the <b>value</b> of &quot;position_column&quot; of the
    object at numeric position <span class="Li">$pos</span>. By default simply
    returns <span class="Li">$pos</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_initial_position_value"><a class="permalink" href="#_initial_position_value">_initial_position_value</a></h2>
<span class="Li"></span>
<pre>
  __PACKAGE__-&gt;_initial_position_value(0);
</pre>
<p class="Pp">This method specifies a <b>value</b> of
    &quot;position_column&quot; which is assigned to the first inserted element
    of a group, if no value was supplied at insertion time. All subsequent
    values are derived from this one by &quot;_next_position_value&quot; below.
    Defaults to 1.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_next_position_value"><a class="permalink" href="#_next_position_value">_next_position_value</a></h2>
<span class="Li"></span>
<pre>
  my $new_value = $item-&gt;_next_position_value ( $position_value )
</pre>
<p class="Pp">Returns a position <b>value</b> that would be considered
    <span class="Li">&quot;next&quot;</span> with regards to
    <span class="Li">$position_value</span>. Can be pretty much anything, given
    that <span class="Li">&quot;$position_value &lt; $new_value&quot;</span>
    where <span class="Li">&quot;&lt;&quot;</span> is the SQL comparison
    operator (usually works fine on strings). The default method expects
    <span class="Li">$position_value</span> to be numeric, and returns
    <span class="Li">&quot;$position_value + 1&quot;</span></p>
</section>
<section class="Ss">
<h2 class="Ss" id="_shift_siblings"><a class="permalink" href="#_shift_siblings">_shift_siblings</a></h2>
<span class="Li"></span>
<pre>
  $item-&gt;_shift_siblings ($direction, @between)
</pre>
<p class="Pp">Shifts all siblings with <b>positions values</b> in the range
    <span class="Li">@between</span> (inclusive) by one position as specified by
    <span class="Li">$direction</span> (left if &lt; 0,
   right if &gt; 0). By default simply increments/decrements each
    &quot;position_column&quot; value by 1, doing so in a way as to not violate
    any existing constraints.</p>
<p class="Pp">Note that if you override this method and have unique constraints
    including the &quot;position_column&quot; the shift is not a trivial task.
    Refer to the implementation source of the default method for more
    information.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="CAVEATS"><a class="permalink" href="#CAVEATS">CAVEATS</a></h1>
<section class="Ss">
<h2 class="Ss" id="Resultset_Methods"><a class="permalink" href="#Resultset_Methods">Resultset
  Methods</a></h2>
Note that all Insert/Create/Delete overrides are happening on DBIx::Class::Row
  methods only. If you use the DBIx::Class::ResultSet versions of update or
  delete, all logic present in this module will be bypassed entirely (possibly
  resulting in a broken order-tree). Instead always use the update_all and
  delete_all methods, which will invoke the corresponding row method on every
  member of the given resultset.
</section>
<section class="Ss">
<h2 class="Ss" id="Race_Condition_on_Insert"><a class="permalink" href="#Race_Condition_on_Insert">Race
  Condition on Insert</a></h2>
If a position is not specified for an insert, a position will be chosen based
  either on &quot;_initial_position_value&quot; or
  &quot;_next_position_value&quot;, depending if there are already some items in
  the current group. The space of time between the necessary selects and insert
  introduces a race condition. Having unique constraints on your position/group
  columns, and using transactions (see &quot;txn_do&quot; in
  DBIx::Class::Storage) will prevent such race conditions going undetected.
</section>
<section class="Ss">
<h2 class="Ss" id="Multiple_Moves"><a class="permalink" href="#Multiple_Moves">Multiple
  Moves</a></h2>
If you have multiple same-group result objects already loaded from storage, you
  need to be careful when executing <span class="Li">&quot;move_*&quot;</span>
  operations on them: without a &quot;position_column&quot; reload the
  &quot;_position_value&quot; of the &quot;siblings&quot; will be out of sync
  with the underlying storage.
<p class="Pp">Starting from version <span class="Li">0.082800</span> DBIC will
    implicitly perform such reloads when the
    <span class="Li">&quot;move_*&quot;</span> happens as a part of a
    transaction (a good example of such situation is
    <span class="Li">&quot;$ordered_resultset-&gt;delete_all&quot;</span>).</p>
<p class="Pp">If it is not possible for you to wrap the entire call-chain in a
    transaction, you will need to call &quot;discard_changes&quot; in
    DBIx::Class::Row to get an object up-to-date before proceeding, otherwise
    undefined behavior will result.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Default_Values"><a class="permalink" href="#Default_Values">Default
  Values</a></h2>
Using a database defined default_value on one of your group columns could result
  in the position not being assigned correctly.
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="FURTHER_QUESTIONS?"><a class="permalink" href="#FURTHER_QUESTIONS?">FURTHER
  QUESTIONS?</a></h1>
Check the list of additional DBIC resources.
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT_AND_LICENSE"><a class="permalink" href="#COPYRIGHT_AND_LICENSE">COPYRIGHT
  AND LICENSE</a></h1>
This module is free software copyright by the DBIx::Class (DBIC) authors. You
  can redistribute it and/or modify it under the same terms as the DBIx::Class
  library.
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2018-01-29</td>
    <td class="foot-os">perl v5.30.2</td>
  </tr>
</table>
</body>
</html>
