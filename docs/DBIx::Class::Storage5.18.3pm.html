<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>DBIx::Class::Storage(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">DBIx::Class::Storage(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">DBIx::Class::Storage(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
DBIx::Class::Storage - Generic Storage Handler
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
A base implementation of common Storage methods. For specific information about
  DBI-based storage, see DBIx::Class::Storage::DBI.
</section>
<section class="Sh">
<h1 class="Sh" id="METHODS"><a class="permalink" href="#METHODS">METHODS</a></h1>
<section class="Ss">
<h2 class="Ss" id="new"><a class="permalink" href="#new">new</a></h2>
Arguments: <span class="Li">$schema</span>
<p class="Pp">Instantiates the Storage object.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="set_schema"><a class="permalink" href="#set_schema">set_schema</a></h2>
Used to reset the schema class or object which owns this storage object, such as
  during &quot;clone&quot; in DBIx::Class::Schema.
</section>
<section class="Ss">
<h2 class="Ss" id="connected"><a class="permalink" href="#connected">connected</a></h2>
Returns true if we have an open storage connection, false if it is not (yet)
  open.
</section>
<section class="Ss">
<h2 class="Ss" id="disconnect"><a class="permalink" href="#disconnect">disconnect</a></h2>
Closes any open storage connection unconditionally.
</section>
<section class="Ss">
<h2 class="Ss" id="ensure_connected"><a class="permalink" href="#ensure_connected">ensure_connected</a></h2>
Initiate a connection to the storage if one isn't already open.
</section>
<section class="Ss">
<h2 class="Ss" id="throw_exception"><a class="permalink" href="#throw_exception">throw_exception</a></h2>
Throws an exception - croaks.
</section>
<section class="Ss">
<h2 class="Ss" id="txn_do"><a class="permalink" href="#txn_do">txn_do</a></h2>
<dl class="Bl-tag">
  <dt>Arguments: $coderef, @coderef_args?</dt>
  <dd></dd>
  <dt>Return Value: The return value of $coderef</dt>
  <dd></dd>
</dl>
<p class="Pp">Executes <span class="Li">$coderef</span> with (optional)
    arguments <span class="Li">@coderef_args</span> atomically, returning its
    result (if any). If an exception is caught, a rollback is issued and the
    exception is rethrown. If the rollback fails, (i.e. throws an exception) an
    exception is thrown that includes a &quot;Rollback failed&quot; message.</p>
<p class="Pp">For example,</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  my $author_rs = $schema-&gt;resultset('Author')-&gt;find(1);
  my @titles = qw/Night Day It/;

  my $coderef = sub {
    # If any one of these fails, the entire transaction fails
    $author_rs-&gt;create_related('books', {
      title =&gt; $_
    }) foreach (@titles);

    return $author-&gt;books;
  };

  my $rs;
  try {
    $rs = $schema-&gt;txn_do($coderef);
  } catch {
    my $error = shift;
    # Transaction failed
    die &quot;something terrible has happened!&quot;
      if ($error =~ /Rollback failed/);          # Rollback failed

    deal_with_failed_transaction();
  };
</pre>
<p class="Pp">In a nested transaction (calling <i>txn_do()</i> from within a
    <i>txn_do()</i> coderef) only the outermost transaction will issue a
    &quot;txn_commit&quot;, and <i>txn_do()</i> can be called in void, scalar
    and list context and it will behave as expected.</p>
<p class="Pp">Please note that all of the code in your coderef, including
    non-DBIx::Class code, is part of a transaction. This transaction may fail
    out halfway, or it may get partially double-executed (in the case that our
    DB connection failed halfway through the transaction, in which case we
    reconnect and restart the txn). Therefore it is best that any side-effects
    in your coderef are idempotent (that is, can be re-executed multiple times
    and get the same result), and that you check up on your side-effects in the
    case of transaction failure.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="txn_begin"><a class="permalink" href="#txn_begin">txn_begin</a></h2>
Starts a transaction.
<p class="Pp">See the preferred &quot;txn_do&quot; method, which allows for an
    entire code block to be executed transactionally.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="txn_commit"><a class="permalink" href="#txn_commit">txn_commit</a></h2>
Issues a commit of the current transaction.
<p class="Pp">It does <i>not</i> perform an actual storage commit unless there's
    a DBIx::Class transaction currently in effect (i.e. you called
    &quot;txn_begin&quot;).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="txn_rollback"><a class="permalink" href="#txn_rollback">txn_rollback</a></h2>
Issues a rollback of the current transaction. A nested rollback will throw a
  DBIx::Class::Storage::NESTED_ROLLBACK_EXCEPTION exception, which allows the
  rollback to propagate to the outermost transaction.
</section>
<section class="Ss">
<h2 class="Ss" id="svp_begin"><a class="permalink" href="#svp_begin">svp_begin</a></h2>
Arguments: <span class="Li">$savepoint_name</span>?
<p class="Pp">Created a new savepoint using the name provided as argument. If no
    name is provided, a random name will be used.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="svp_release"><a class="permalink" href="#svp_release">svp_release</a></h2>
Arguments: <span class="Li">$savepoint_name</span>?
<p class="Pp">Release the savepoint provided as argument. If none is provided,
    release the savepoint created most recently. This will implicitly release
    all savepoints created after the one explicitly released as well.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="svp_rollback"><a class="permalink" href="#svp_rollback">svp_rollback</a></h2>
Arguments: <span class="Li">$savepoint_name</span>?
<p class="Pp">Rollback to the savepoint provided as argument. If none is
    provided, rollback to the savepoint created most recently. This will
    implicitly release all savepoints created after the savepoint we rollback
    to.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="txn_scope_guard"><a class="permalink" href="#txn_scope_guard">txn_scope_guard</a></h2>
An alternative way of transaction handling based on
  DBIx::Class::Storage::TxnScopeGuard:
<p class="Pp"><span class="Li"></span></p>
<pre>
 my $txn_guard = $storage-&gt;txn_scope_guard;

 $result-&gt;col1(&quot;val1&quot;);
 $result-&gt;update;

 $txn_guard-&gt;commit;
</pre>
<p class="Pp">If an exception occurs, or the guard object otherwise leaves the
    scope before <span class="Li">&quot;$txn_guard-&gt;commit&quot;</span> is
    called, the transaction will be rolled back by an explicit
    &quot;txn_rollback&quot; call. In essence this is akin to using a
    &quot;txn_begin&quot;/&quot;txn_commit&quot; pair, without having to worry
    about calling &quot;txn_rollback&quot; at the right places. Note that since
    there is no defined code closure, there will be no retries and other magic
    upon database disconnection. If you need such functionality see
    &quot;txn_do&quot;.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="sql_maker"><a class="permalink" href="#sql_maker">sql_maker</a></h2>
Returns a <span class="Li">&quot;sql_maker&quot;</span> object - normally an
  object of class <span class="Li">&quot;DBIx::Class::SQLMaker&quot;</span>.
</section>
<section class="Ss">
<h2 class="Ss" id="debug"><a class="permalink" href="#debug">debug</a></h2>
Causes trace information to be emitted on the &quot;debugobj&quot; object. (or
  <span class="Li">&quot;STDERR&quot;</span> if &quot;debugobj&quot; has not
  specifically been set).
<p class="Pp">This is the equivalent to setting &quot;DBIC_TRACE&quot; in your
    shell environment.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="debugfh"><a class="permalink" href="#debugfh">debugfh</a></h2>
Set or retrieve the filehandle used for trace/debug output. This should be an
  IO::Handle compatible object (only the
  <span class="Li">&quot;print&quot;</span> method is used. Initially set to be
  STDERR - although see information on the DBIC_TRACE environment variable.
</section>
<section class="Ss">
<h2 class="Ss" id="debugobj"><a class="permalink" href="#debugobj">debugobj</a></h2>
Sets or retrieves the object used for metric collection. Defaults to an instance
  of DBIx::Class::Storage::Statistics that is compatible with the original
  method of using a coderef as a callback. See the aforementioned Statistics
  class for more information.
</section>
<section class="Ss">
<h2 class="Ss" id="debugcb"><a class="permalink" href="#debugcb">debugcb</a></h2>
Sets a callback to be executed each time a statement is run; takes a sub
  reference. Callback is executed as <span class="Li">$sub</span>-&gt;($op,
  <span class="Li">$info</span>) where <span class="Li">$op</span> is
  SELECT/INSERT/UPDATE/DELETE and <span class="Li">$info</span> is what would
  normally be printed.
<p class="Pp">See &quot;debugobj&quot; for a better way.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="cursor_class"><a class="permalink" href="#cursor_class">cursor_class</a></h2>
The cursor class for this Storage object.
</section>
<section class="Ss">
<h2 class="Ss" id="deploy"><a class="permalink" href="#deploy">deploy</a></h2>
Deploy the tables to storage (CREATE TABLE and friends in a SQL-based Storage
  class). This would normally be called through &quot;deploy&quot; in
  DBIx::Class::Schema.
</section>
<section class="Ss">
<h2 class="Ss" id="connect_info"><a class="permalink" href="#connect_info">connect_info</a></h2>
The arguments of <span class="Li">&quot;connect_info&quot;</span> are always a
  single array reference, and are Storage-handler specific.
<p class="Pp">This is normally accessed via &quot;connection&quot; in
    DBIx::Class::Schema, which encapsulates its argument list in an arrayref
    before calling <span class="Li">&quot;connect_info&quot;</span> here.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="select"><a class="permalink" href="#select">select</a></h2>
Handle a select statement.
</section>
<section class="Ss">
<h2 class="Ss" id="insert"><a class="permalink" href="#insert">insert</a></h2>
Handle an insert statement.
</section>
<section class="Ss">
<h2 class="Ss" id="update"><a class="permalink" href="#update">update</a></h2>
Handle an update statement.
</section>
<section class="Ss">
<h2 class="Ss" id="delete"><a class="permalink" href="#delete">delete</a></h2>
Handle a delete statement.
</section>
<section class="Ss">
<h2 class="Ss" id="select_single"><a class="permalink" href="#select_single">select_single</a></h2>
Performs a select, fetch and return of data - handles a single row only.
</section>
<section class="Ss">
<h2 class="Ss" id="columns_info_for"><a class="permalink" href="#columns_info_for">columns_info_for</a></h2>
Returns metadata for the given source's columns. This is *deprecated*, and will
  be removed before 1.0. You should be specifying the metadata yourself if you
  need it.
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="ENVIRONMENT_VARIABLES"><a class="permalink" href="#ENVIRONMENT_VARIABLES">ENVIRONMENT
  VARIABLES</a></h1>
<section class="Ss">
<h2 class="Ss" id="_s-1DBIC_TRACE_s0"><a class="permalink" href="#_s-1DBIC_TRACE_s0">DBIC_TRACE</a></h2>
If <span class="Li">&quot;DBIC_TRACE&quot;</span> is set then trace information
  is produced (as when the &quot;debug&quot; method is set).
<p class="Pp">If the value is of the form
    <span class="Li">&quot;1=/path/name&quot;</span> then the trace output is
    written to the file <span class="Li">&quot;/path/name&quot;</span>.</p>
<p class="Pp">This environment variable is checked when the storage object is
    first created (when you call connect on your schema). So, run-time changes
    to this environment variable will not take effect unless you also re-connect
    on your schema.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_s-1DBIC_TRACE_PROFILE_s0"><a class="permalink" href="#_s-1DBIC_TRACE_PROFILE_s0">DBIC_TRACE_PROFILE</a></h2>
If <span class="Li">&quot;DBIC_TRACE_PROFILE&quot;</span> is set,
  DBIx::Class::Storage::Debug::PrettyPrint will be used to format the output
  from <span class="Li">&quot;DBIC_TRACE&quot;</span>. The value it is set to is
  the <span class="Li">&quot;profile&quot;</span> that it will be used. If the
  value is a filename the file is read with Config::Any and the results are used
  as the configuration for tracing. See &quot;new&quot; in SQL::Abstract::Tree
  for what that structure should look like.
</section>
<section class="Ss">
<h2 class="Ss" id="_s-1DBIX_CLASS_STORAGE_DBI_DEBUG_s0"><a class="permalink" href="#_s-1DBIX_CLASS_STORAGE_DBI_DEBUG_s0">DBIX_CLASS_STORAGE_DBI_DEBUG</a></h2>
Old name for DBIC_TRACE
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
DBIx::Class::Storage::DBI - reference storage implementation using SQL::Abstract
  and DBI.
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR_AND_CONTRIBUTORS"><a class="permalink" href="#AUTHOR_AND_CONTRIBUTORS">AUTHOR
  AND CONTRIBUTORS</a></h1>
See AUTHOR and CONTRIBUTORS in DBIx::Class
</section>
<section class="Sh">
<h1 class="Sh" id="LICENSE"><a class="permalink" href="#LICENSE">LICENSE</a></h1>
You may distribute this code under the same terms as Perl itself.
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2014-01-22</td>
    <td class="foot-os">perl v5.18.4</td>
  </tr>
</table>
</body>
</html>
