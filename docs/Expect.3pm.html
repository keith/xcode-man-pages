<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.10 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>Expect(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Expect(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Expect(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
Expect - automate interactions with command line programs that expose a text
  terminal interface.
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<span class="Li"></span>
<pre>
  use Expect;

  # create an Expect object by spawning another process
  my $exp = Expect-&gt;spawn($command, @params)
    or die &quot;Cannot spawn $command: $!\n&quot;;

  # or by using an already opened filehandle (e.g. from Net::Telnet)
  my $exp = Expect-&gt;exp_init(\*FILEHANDLE);

  # if you prefer the OO mindset:
  my $exp = Expect-&gt;new;
  $exp-&gt;raw_pty(1);
  $exp-&gt;spawn($command, @parameters)
    or die &quot;Cannot spawn $command: $!\n&quot;;

  # send some string there:
  $exp-&gt;send(&quot;string\n&quot;);

  # or, for the filehandle mindset:
  print $exp &quot;string\n&quot;;

  # then do some pattern matching with either the simple interface
  $patidx = $exp-&gt;expect($timeout, @match_patterns);

  # or multi-match on several spawned commands with callbacks,
  # just like the Tcl version
  $exp-&gt;expect($timeout,
             [ qr/regex1/ =&gt; sub { my $exp = shift;
                       $exp-&gt;send(&quot;response\n&quot;);
                       exp_continue; } ],
             [ &quot;regexp2&quot; , \&amp;callback, @cbparms ],
            );

  # if no longer needed, do a soft_close to nicely shut down the command
  $exp-&gt;soft_close();

  # or be less patient with
  $exp-&gt;hard_close();
</pre>
<p class="Pp">Expect.pm is built to either spawn a process or take an existing
    filehandle and interact with it such that normally interactive tasks can be
    done without operator assistance. This concept makes more sense if you are
    already familiar with the versatile Tcl version of Expect. The public
    functions that make up Expect.pm are:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  Expect-&gt;new()
  Expect::interconnect(@objects_to_be_read_from)
  Expect::test_handles($timeout, @objects_to_test)
  Expect::version($version_requested | undef);
  $object-&gt;spawn(@command)
  $object-&gt;clear_accum()
  $object-&gt;set_accum($value)
  $object-&gt;debug($debug_level)
  $object-&gt;exp_internal(0 | 1)
  $object-&gt;notransfer(0 | 1)
  $object-&gt;raw_pty(0 | 1)
  $object-&gt;stty(@stty_modes) # See the IO::Stty docs
  $object-&gt;slave()
  $object-&gt;before();
  $object-&gt;match();
  $object-&gt;after();
  $object-&gt;matchlist();
  $object-&gt;match_number();
  $object-&gt;error();
  $object-&gt;command();
  $object-&gt;exitstatus();
  $object-&gt;pty_handle();
  $object-&gt;do_soft_close();
  $object-&gt;restart_timeout_upon_receive(0 | 1);
  $object-&gt;interact($other_object, $escape_sequence)
  $object-&gt;log_group(0 | 1 | undef)
  $object-&gt;log_user(0 | 1 | undef)
  $object-&gt;log_file(&quot;filename&quot; | $filehandle | \&amp;coderef | undef)
  $object-&gt;manual_stty(0 | 1 | undef)
  $object-&gt;match_max($max_buffersize or undef)
  $object-&gt;pid();
  $object-&gt;send_slow($delay, @strings_to_send)
  $object-&gt;set_group(@listen_group_objects | undef)
  $object-&gt;set_seq($sequence,\&amp;function,\@parameters);
</pre>
<p class="Pp">There are several configurable package variables that affect the
    behavior of Expect. They are:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  $Expect::Debug;
  $Expect::Exp_Internal;
  $Expect::IgnoreEintr;
  $Expect::Log_Group;
  $Expect::Log_Stdout;
  $Expect::Manual_Stty;
  $Expect::Multiline_Matching;
  $Expect::Do_Soft_Close;
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
See an explanation of What is Expect &lt;http://code-maven.com/expect&gt;
<p class="Pp">The Expect module is a successor of Comm.pl and a descendent of
    Chat.pl. It more closely resembles the Tcl Expect language than its
    predecessors. It does not contain any of the networking code found in
    Comm.pl. I suspect this would be obsolete anyway given the advent of
    IO::Socket and external tools such as netcat.</p>
<p class="Pp">Expect.pm is an attempt to have more of a <b>switch()</b> &amp;
    case feeling to make decision processing more fluid. Three separate types of
    debugging have been implemented to make code production easier.</p>
<p class="Pp">It is possible to interconnect multiple file handles (and
    processes) much like Tcl's Expect. An attempt was made to enable all the
    features of Tcl's Expect without forcing Tcl on the victim programmer :-)
  .</p>
<p class="Pp">Please, before you consider using Expect, read the FAQs about
    &quot;I want to automate password entry for su/ssh/scp/rsh/...&quot; and
    &quot;I want to use Expect to automate [anything with a
  buzzword]...&quot;</p>
</section>
<section class="Sh">
<h1 class="Sh" id="USAGE"><a class="permalink" href="#USAGE">USAGE</a></h1>
<dl class="Bl-tag">
  <dt>new</dt>
  <dd>Creates a new Expect object, i.e. a pty. You can change parameters on it
      before actually spawning a command. This is important if you want to
      modify the terminal settings for the slave. See <b>slave()</b> below. The
      object returned is actually a reblessed IO::Pty filehandle, so see there
      for additional methods.</dd>
  <dt>Expect-&gt;exp_init(\*FILEHANDLE) <i>or</i></dt>
  <dd></dd>
  <dt>Expect-&gt;init(\*FILEHANDLE)</dt>
  <dd>Initializes <span class="Li">$new_handle_object</span> for use with other
      Expect functions. It must be passed a <b>_reference_</b> to FILEHANDLE if
      you want it to work properly. IO::File objects are preferable. Returns a
      reference to the newly created object.
    <p class="Pp">You can use only real filehandles, certain tied filehandles
        (e.g. Net::SSH2) that lack a <b>fileno()</b> will not work. Net::Telnet
        objects can be used but have been reported to work only for certain
        hosts. YMMV.</p>
  </dd>
  <dt>Expect-&gt;spawn($command, @parameters) <i>or</i></dt>
  <dd></dd>
  <dt>$object-&gt;spawn($command, @parameters) <i>or</i></dt>
  <dd></dd>
  <dt>Expect-&gt;new($command, @parameters)</dt>
  <dd>Forks and execs <span class="Li">$command</span>. Returns an Expect object
      upon success or <span class="Li">&quot;undef&quot;</span> if the fork was
      unsuccessful or the command could not be found. <b>spawn()</b> passes its
      parameters unchanged to Perls <b>exec()</b>, so look there for detailed
      semantics.
    <p class="Pp">Note that if spawn cannot <b>exec()</b> the given command, the
        Expect object is still valid and the next <b>expect()</b> will see
        &quot;Cannot exec&quot;, so you can use that for error handling.</p>
    <p class="Pp">Also note that you cannot reuse an object with an already
        spawned command, even if that command has exited. Sorry, but you have to
        allocate a new object...</p>
  </dd>
  <dt>$object-&gt;debug(0 | 1 | 2 | 3 | undef)</dt>
  <dd>Sets debug level for <span class="Li">$object</span>. 1 refers to general
      debugging information, 2 refers to verbose debugging and 0 refers to no
      debugging. If you call <b>debug()</b> with no parameters it will return
      the current debugging level. When the object is created the debugging
      level will match that <span class="Li">$Expect::Debug</span>, normally 0.
    <p class="Pp">The '3' setting is new with 1.05, and adds the additional
        functionality of having the _full_ accumulated buffer printed every time
        data is read from an Expect object. This was implemented by request. I
        recommend against using this unless you think you need it as it can
        create quite a quantity of output under some circumstances..</p>
  </dd>
  <dt>$object-&gt;exp_internal(1 | 0)</dt>
  <dd>Sets/unsets 'exp_internal' debugging. This is similar in nature to its Tcl
      counterpart. It is extremely valuable when debugging <b>expect()</b>
      sequences. When the object is created the exp_internal setting will match
      the value of <span class="Li">$Expect::Exp_Internal</span>, normally 0.
      Returns the current setting if called without parameters. It is highly
      recommended that you make use of the debugging features lest you have
      angry code.</dd>
  <dt>$object-&gt;raw_pty(1 | 0)</dt>
  <dd>Set pty to raw mode before spawning. This disables echoing, CR-&gt;LF
      translation and an ugly hack for broken Solaris TTYs (which send
      &lt;space&gt;&lt;backspace&gt; to slow things down) and thus gives a more
      pipe-like behaviour (which is important if you want to transfer binary
      content). Note that this must be set <i>before</i> spawning the
    program.</dd>
  <dt>$object-&gt;stty(qw(mode1 mode2...))</dt>
  <dd>Sets the tty mode for <span class="Li">$object</span>'s associated
      terminal to the given modes. Note that on many systems the master side of
      the pty is not a tty, so you have to modify the slave pty instead, see
      next item. This needs IO::Stty installed, which is no longer
    required.</dd>
  <dt>$object-&gt;<b>slave()</b></dt>
  <dd>Returns a filehandle to the slave part of the pty. Very useful in
      modifying the terminal settings:
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  $object-&gt;slave-&gt;stty(qw(raw -echo));
    </pre>
    <p class="Pp">Typical values are 'sane', 'raw', and 'raw -echo'. Note that I
        recommend setting the terminal to 'raw' or 'raw -echo', as this avoids a
        lot of hassle and gives pipe-like (i.e. transparent) behaviour (without
        the buffering issue).</p>
  </dd>
  <dt>$object-&gt;print(@strings) <i>or</i></dt>
  <dd></dd>
  <dt>$object-&gt;send(@strings)</dt>
  <dd>Sends the given strings to the spawned command. Note that the strings are
      not logged in the logfile (see print_log_file) but will probably be echoed
      back by the pty, depending on pty settings (default is echo) and thus end
      up there anyway. This must also be taken into account when
      <b>expect()</b>ing for an answer: the next string will be the command just
      sent. I suggest setting the pty to raw, which disables echo and makes the
      pty transparently act like a bidirectional pipe.</dd>
  <dt>$object-&gt;expect($timeout, @match_patterns)</dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>Simple interface</dt>
  <dd>Given <span class="Li">$timeout</span> in seconds Expect will wait for
      <span class="Li">$object</span>'s handle to produce one of the
      match_patterns, which are matched exactly by default. If you want a regexp
      match, prefix the pattern with '-re'.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  $object-&gt;expect(15, 'match me exactly','-re','match\s+me\s+exactly');
    </pre>
    <p class="Pp">Due to o/s limitations <span class="Li">$timeout</span> should
        be a round number. If <span class="Li">$timeout</span> is 0 Expect will
        check one time to see if <span class="Li">$object</span>'s handle
        contains any of the match_patterns. If <span class="Li">$timeout</span>
        is undef Expect will wait forever for a pattern to match.</p>
    <p class="Pp">If called in a scalar context, <b>expect()</b> will return the
        position of the matched pattern within
        <span class="Li">@matched_patterns</span>, or undef if no pattern was
        matched. This is a position starting from 1, so if you want to know
        which of an array of <span class="Li">@matched_patterns</span> matched
        you should subtract one from the return value.</p>
    <p class="Pp">If called in an array context <b>expect()</b> will return
        ($matched_pattern_position, <span class="Li">$error</span>,
        <span class="Li">$successfully_matching_string</span>,
        <span class="Li">$before_match</span>, and
        <span class="Li">$after_match</span>).</p>
    <p class="Pp"><span class="Li">$matched_pattern_position</span> will contain
        the value that would have been returned if <b>expect()</b> had been
        called in a scalar context.</p>
    <p class="Pp"><span class="Li">$error</span> is the error that occurred that
        caused <b>expect()</b> to return. <span class="Li">$error</span> will
        contain a number followed by a string equivalent expressing the nature
        of the error. Possible values are undef, indicating no error,
        '1:TIMEOUT' indicating that <span class="Li">$timeout</span> seconds had
        elapsed without a match, '2:EOF' indicating an eof was read from
        <span class="Li">$object</span>, '3: spawn id($fileno) died' indicating
        that the process exited before matching and '4:$!' indicating whatever
        error was set in <span class="Li">$ERRNO</span> during the last read on
        <span class="Li">$object</span>'s handle or during <b>select()</b>. All
        handles indicated by set_group plus STDOUT will have all data to come
        out of <span class="Li">$object</span> printed to them during
        <b>expect()</b> if log_group and log_stdout are set.</p>
    <p class="Pp"><span class="Li">$successfully_matching_string</span>
        <span class="Li">$before_match</span>
        <span class="Li">$after_match</span></p>
    <p class="Pp">Changed from older versions is the regular expression
        handling. By default now all strings passed to <b>expect()</b> are
        treated as literals. To match a regular expression pass '-re' as a
        parameter in front of the pattern you want to match as a regexp.</p>
    <p class="Pp">This change makes it possible to match literals and regular
        expressions in the same <b>expect()</b> call.</p>
    <p class="Pp">Also new is multiline matching. ^ will now match the beginning
        of lines. Unfortunately, because perl doesn't use $/ in determining
        where lines break using $ to find the end of a line frequently doesn't
        work. This is because your terminal is returning &quot;\r\n&quot; at the
        end of every line. One way to check for a pattern at the end of a line
        would be to use \r?$ instead of $.</p>
    <p class="Pp">Example: Spawning telnet to a host, you might look for the
        escape character. telnet would return to you &quot;\r\nEscape character
        is '^]'.\r\n&quot;. To find this you might use
        <span class="Li">$match</span>='^Escape char.*\.\r?$';</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  $telnet-&gt;expect(10,'-re',$match);
    </pre>
  </dd>
  <dt>New more Tcl/Expect-like interface</dt>
  <dd><span class="Li"></span>
    <pre>
  expect($timeout,
       '-i', [ $obj1, $obj2, ... ],
             [ $re_pattern, sub { ...; exp_continue; }, @subparms, ],
             [ 'eof', sub { ... } ],
             [ 'timeout', sub { ... }, \$subparm1 ],
       '-i', [ $objn, ...],
       '-ex', $exact_pattern, sub { ... },
              $exact_pattern, sub { ...; exp_continue_timeout; },
       '-re', $re_pattern, sub { ... },
       '-i', \@object_list, @pattern_list,
       ...);
    </pre>
    <p class="Pp">It's now possible to expect on more than one connection at a
        time by specifying '<span class="Li">&quot;-i&quot;</span>' and a single
        Expect object or a ref to an array containing Expect objects, e.g.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
 expect($timeout,
        '-i', $exp1, @patterns_1,
        '-i', [ $exp2, $exp3 ], @patterns_2_3,
       )
    </pre>
    <p class="Pp">Furthermore, patterns can now be specified as array refs
        containing [$regexp, sub { ...},
        <span class="Li">@optional_subprams</span>] . When the pattern matches,
        the subroutine is called with parameters ($matched_expect_obj,
        <span class="Li">@optional_subparms</span>). The subroutine can return
        the symbol `exp_continue' to continue the expect matching with timeout
        starting anew or return the symbol `exp_continue_timeout' for continuing
        expect without resetting the timeout count.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
 $exp-&gt;expect($timeout,
              [ qr/username: /i, sub { my $self = shift;
                                       $self-&gt;send(&quot;$username\n&quot;);
                                       exp_continue; }],
              [ qr/password: /i, sub { my $self = shift;
                                       $self-&gt;send(&quot;$password\n&quot;);
                                       exp_continue; }],
             $shell_prompt);
    </pre>
    <p class="Pp">`expect' is now exported by default.</p>
  </dd>
</dl>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>$object-&gt;<b>exp_before()</b> <i>or</i></dt>
  <dd></dd>
  <dt>$object-&gt;<b>before()</b></dt>
  <dd><b>before()</b> returns the 'before' part of the last <b>expect()</b>
      call. If the last <b>expect()</b> call didn't match anything,
      <b>exp_before()</b> will return the entire output of the object
      accumulated before the <b>expect()</b> call finished.
    <p class="Pp">Note that this is something different than Tcl Expects
        <b>before()</b>!!</p>
  </dd>
  <dt>$object-&gt;<b>exp_after()</b> <i>or</i></dt>
  <dd></dd>
  <dt>$object-&gt;<b>after()</b></dt>
  <dd>returns the 'after' part of the last <b>expect()</b> call. If the last
      <b>expect()</b> call didn't match anything, <b>exp_after()</b> will return
      <b>undef()</b>.</dd>
  <dt>$object-&gt;<b>exp_match()</b> <i>or</i></dt>
  <dd></dd>
  <dt>$object-&gt;<b>match()</b></dt>
  <dd>returns the string matched by the last <b>expect()</b> call, undef if no
      string was matched.</dd>
  <dt>$object-&gt;<b>exp_match_number()</b> <i>or</i></dt>
  <dd></dd>
  <dt>$object-&gt;<b>match_number()</b></dt>
  <dd><b>exp_match_number()</b> returns the number of the pattern matched by the
      last <b>expect()</b> call. Keep in mind that the first pattern in a list
      of patterns is 1, not 0. Returns undef if no pattern was matched.</dd>
  <dt>$object-&gt;<b>exp_matchlist()</b> <i>or</i></dt>
  <dd></dd>
  <dt>$object-&gt;<b>matchlist()</b></dt>
  <dd><b>exp_matchlist()</b> returns a list of matched substrings from the
      brackets () inside the regexp that last matched.
      ($object-&gt;matchlist)[0] thus corresponds to <span class="Li">$1</span>,
      ($object-&gt;matchlist)[1] to <span class="Li">$2</span>, etc.</dd>
  <dt>$object-&gt;<b>exp_error()</b> <i>or</i></dt>
  <dd></dd>
  <dt>$object-&gt;<b>error()</b></dt>
  <dd><b>exp_error()</b> returns the error generated by the last <b>expect()</b>
      call if no pattern was matched. It is typically useful to examine the
      value returned by <b>before()</b> to find out what the output of the
      object was in determining why it didn't match any of the patterns.</dd>
  <dt>$object-&gt;<b>clear_accum()</b></dt>
  <dd>Clear the contents of the accumulator for <span class="Li">$object</span>.
      This gets rid of any residual contents of a handle after <b>expect()</b>
      or <b>send_slow()</b> such that the next <b>expect()</b> call will only
      see new data from <span class="Li">$object</span>. The contents of the
      accumulator are returned.</dd>
  <dt>$object-&gt;set_accum($value)</dt>
  <dd>Sets the content of the accumulator for <span class="Li">$object</span> to
      <span class="Li">$value</span>. The previous content of the accumulator is
      returned.</dd>
  <dt>$object-&gt;<b>exp_command()</b> <i>or</i></dt>
  <dd></dd>
  <dt>$object-&gt;<b>command()</b></dt>
  <dd><b>exp_command()</b> returns the string that was used to spawn the
      command. Helpful for debugging and for reused patternmatch
    subroutines.</dd>
  <dt>$object-&gt;<b>exp_exitstatus()</b> <i>or</i></dt>
  <dd></dd>
  <dt>$object-&gt;<b>exitstatus()</b></dt>
  <dd>Returns the exit status of <span class="Li">$object</span> (if it already
      exited).</dd>
  <dt>$object-&gt;<b>exp_pty_handle()</b> <i>or</i></dt>
  <dd></dd>
  <dt>$object-&gt;<b>pty_handle()</b></dt>
  <dd>Returns a string representation of the attached pty, for example: `spawn
      <b>id</b>(5)' (pty has fileno 5), `handle <b>id</b>(7)' (pty was
      initialized from fileno 7) or `STDIN'. Useful for debugging.</dd>
  <dt>$object-&gt;restart_timeout_upon_receive(0 | 1)</dt>
  <dd>If this is set to 1, the expect timeout is retriggered whenever something
      is received from the spawned command. This allows to perform some
      aliveness testing and still expect for patterns.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    $exp-&gt;restart_timeout_upon_receive(1);
    $exp-&gt;expect($timeout,
                 [ timeout =&gt; \&amp;report_timeout ],
                 [ qr/pattern/ =&gt; \&amp;handle_pattern],
                );
    </pre>
    <p class="Pp">Now the timeout isn't triggered if the command produces any
        kind of output, i.e. is still alive, but you can act upon patterns in
        the output.</p>
  </dd>
  <dt>$object-&gt;notransfer(1 | 0)</dt>
  <dd>Do not truncate the content of the accumulator after a match. Normally,
      the accumulator is set to the remains that come after the matched string.
      Note that this setting is per object and not per pattern, so if you want
      to have normal acting patterns that truncate the accumulator, you have to
      add a
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    $exp-&gt;set_accum($exp-&gt;after);
    </pre>
    <p class="Pp">to their callback, e.g.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    $exp-&gt;notransfer(1);
    $exp-&gt;expect($timeout,
                 # accumulator not truncated, pattern1 will match again
                 [ &quot;pattern1&quot; =&gt; sub { my $self = shift;
                                       ...
                                     } ],
                 # accumulator truncated, pattern2 will not match again
                 [ &quot;pattern2&quot; =&gt; sub { my $self = shift;
                                       ...
                                       $self-&gt;set_accum($self-&gt;after());
                                     } ],
                );
    </pre>
    <p class="Pp">This is only a temporary fix until I can rewrite the pattern
        matching part so it can take that additional -notransfer argument.</p>
  </dd>
  <dt>Expect::interconnect(@objects);</dt>
  <dd>Read from <span class="Li">@objects</span> and print to their
      <span class="Li">@listen_groups</span> until an escape sequence is matched
      from one of <span class="Li">@objects</span> and the associated function
      returns 0 or undef. The special escape sequence 'EOF' is matched when an
      object's handle returns an end of file. Note that it is not necessary to
      include objects that only accept data in <span class="Li">@objects</span>
      since the escape sequence is _read_ from an object. Further note that the
      listen_group for a write-only object is always empty. Why would you want
      to have objects listening to STDOUT (for example)? By default every member
      of <span class="Li">@objects</span> _as well as every member of its listen
      group_ will be set to 'raw -echo' for the duration of interconnection.
      Setting <span class="Li">$object</span>-&gt;<b>manual_stty()</b> will stop
      this behavior per object. The original tty settings will be restored as
      interconnect exits.
    <p class="Pp">For a generic way to interconnect processes, take a look at
        IPC::Run.</p>
  </dd>
  <dt>Expect::test_handles(@objects)</dt>
  <dd>Given a set of objects determines which objects' handles have data ready
      to be read. <b>Returns an array</b> who's members are positions in
      <span class="Li">@objects</span> that have ready handles. Returns undef if
      there are no such handles ready.</dd>
  <dt>Expect::version($version_requested or undef);</dt>
  <dd>Returns current version of Expect. As of .99 earlier versions are not
      supported. Too many things were changed to make versioning possible.</dd>
  <dt>$object-&gt;interact( &quot;\*FILEHANDLE, $escape_sequence&quot;)</dt>
  <dd><b>interact()</b> is essentially a macro for calling <b>interconnect()</b>
      for connecting 2 processes together. \*FILEHANDLE defaults to \*STDIN and
      <span class="Li">$escape_sequence</span> defaults to undef. Interaction
      ceases when <span class="Li">$escape_sequence</span> is read from
      <b>FILEHANDLE</b>, not <span class="Li">$object</span>.
      <span class="Li">$object</span>'s listen group will consist solely of
      \*FILEHANDLE for the duration of the interaction. \*FILEHANDLE will not be
      echoed on STDOUT.</dd>
  <dt>$object-&gt;log_group(0 | 1 | undef)</dt>
  <dd>Set/unset logging of <span class="Li">$object</span> to its 'listen
      group'. If set all objects in the listen group will have output from
      <span class="Li">$object</span> printed to them during
      <span class="Li">$object</span>-&gt;<b>expect()</b>,
      <span class="Li">$object</span>-&gt;<b>send_slow()</b>, and
      <span class="Li">&quot;Expect::interconnect($object</span>
      <span class="Li">, ...)&quot;</span>. Default value is on. During creation
      of <span class="Li">$object</span> the setting will match the value of
      <span class="Li">$Expect::Log_Group</span>, normally 1.</dd>
  <dt>$object-&gt;log_user(0 | 1 | undef) <i>or</i></dt>
  <dd></dd>
  <dt>$object-&gt;log_stdout(0 | 1 | undef)</dt>
  <dd>Set/unset logging of object's handle to STDOUT. This corresponds to Tcl's
      log_user variable. Returns current setting if called without parameters.
      Default setting is off for initialized handles. When a process object is
      created (not a filehandle initialized with exp_init) the log_stdout
      setting will match the value of
      <span class="Li">$Expect::Log_Stdout</span> variable, normally 1. If/when
      you initialize STDIN it is usually associated with a tty which will by
      default echo to STDOUT anyway, so be careful or you will have multiple
      echoes.</dd>
  <dt>$object-&gt;log_file(&quot;filename&quot; | $filehandle | \&amp;coderef |
    undef)</dt>
  <dd>Log session to a file. All characters send to or received from the spawned
      process are written to the file. Normally appends to the logfile, but you
      can pass an additional mode of &quot;w&quot; to truncate the file upon
      <b>open()</b>:
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  $object-&gt;log_file(&quot;filename&quot;, &quot;w&quot;);
    </pre>
    <p class="Pp">Returns the logfilehandle.</p>
    <p class="Pp">If called with an undef value, stops logging and closes
        logfile:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  $object-&gt;log_file(undef);
    </pre>
    <p class="Pp">If called without argument, returns the logfilehandle:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  $fh = $object-&gt;log_file();
    </pre>
    <p class="Pp">Can be set to a code ref, which will be called instead of
        printing to the logfile:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  $object-&gt;log_file(\&amp;myloggerfunc);
    </pre>
  </dd>
  <dt>$object-&gt;print_log_file(@strings)</dt>
  <dd>Prints to logfile (if opened) or calls the logfile hook function. This
      allows the user to add arbitrary text to the logfile. Note that this could
      also be done as
      <span class="Li">$object</span>-&gt;log_file-&gt;<b>print()</b> but would
      only work for log files, not code hooks.</dd>
  <dt>$object-&gt;set_seq($sequence, \&amp;function, \@function_parameters)</dt>
  <dd>During Expect-&gt;<b>interconnect()</b> if
      <span class="Li">$sequence</span> is read from
      <span class="Li">$object</span> &amp;function will be executed with
      parameters <span class="Li">@function_parameters</span>. It is
      <b>_highly</b> <b>recommended_</b> that the escape sequence be a single
      character since the likelihood is great that the sequence will be broken
      into to separate reads from the <span class="Li">$object</span>'s handle,
      making it impossible to strip <span class="Li">$sequence</span> from
      getting printed to <span class="Li">$object</span>'s listen group.
      \&amp;function should be something like 'main::control_w_function' and
      <span class="Li">@function_parameters</span> should be an array defined by
      the caller, passed by reference to <b>set_seq()</b>. Your function should
      return a non-zero value if execution of <b>interconnect()</b> is to resume
      after the function returns, zero or undefined if <b>interconnect()</b>
      should return after your function returns. The special sequence 'EOF'
      matches the end of file being reached by <span class="Li">$object</span>.
      See <b>interconnect()</b> for details.</dd>
  <dt>$object-&gt;set_group(@listener_objects)</dt>
  <dd><span class="Li">@listener_objects</span> is the list of objects that
      should have their handles printed to by <span class="Li">$object</span>
      when Expect::interconnect,
      <span class="Li">$object</span>-&gt;<b>expect()</b> or
      <span class="Li">$object</span>-&gt;<b>send_slow()</b> are called. Calling
      w/out parameters will return the current list of the listener
    objects.</dd>
  <dt>$object-&gt;manual_stty(0 | 1 | undef)</dt>
  <dd>Sets/unsets whether or not Expect should make reasonable guesses as to
      when and how to set tty parameters for <span class="Li">$object</span>.
      Will match <span class="Li">$Expect::Manual_Stty</span> value (normally 0)
      when <span class="Li">$object</span> is created. If called without
      parameters <b>manual_stty()</b> will return the current manual_stty
      setting.</dd>
  <dt>$object-&gt;match_max($maximum_buffer_length | undef) <i>or</i></dt>
  <dd></dd>
  <dt>$object-&gt;max_accum($maximum_buffer_length | undef)</dt>
  <dd>Set the maximum accumulator size for object. This is useful if you think
      that the accumulator will grow out of hand during <b>expect()</b> calls.
      Since the buffer will be matched by every match_pattern it may get slow if
      the buffer gets too large. Returns current value if called without
      parameters. Not defined by default.</dd>
  <dt>$object-&gt;notransfer(0 | 1)</dt>
  <dd>If set, matched strings will not be deleted from the accumulator. Returns
      current value if called without parameters. False by default.</dd>
  <dt>$object-&gt;<b>exp_pid()</b> <i>or</i></dt>
  <dd></dd>
  <dt>$object-&gt;<b>pid()</b></dt>
  <dd>Return pid of <span class="Li">$object</span>, if one exists. Initialized
      filehandles will not have pids (of course).</dd>
  <dt>$object-&gt;send_slow($delay, @strings);</dt>
  <dd>print each character from each string of <span class="Li">@strings</span>
      one at a time with <span class="Li">$delay</span> seconds before each
      character. This is handy for devices such as modems that can be annoying
      if you send them data too fast. After each character
      <span class="Li">$object</span> will be checked to determine whether or
      not it has any new data ready and if so update the accumulator for future
      <b>expect()</b> calls and print the output to STDOUT and
      <span class="Li">@listen_group</span> if log_stdout and log_group are
      appropriately set.</dd>
</dl>
<section class="Ss">
<h2 class="Ss" id="Configurable_Package_Variables:"><a class="permalink" href="#Configurable_Package_Variables:">Configurable
  Package Variables:</a></h2>
<dl class="Bl-tag">
  <dt>$Expect::Debug</dt>
  <dd>Defaults to 0. Newly created objects have a
      <span class="Li">$object</span>-&gt;<b>debug()</b> value of
      <span class="Li">$Expect::Debug</span>. See
      <span class="Li">$object</span>-&gt;<b>debug()</b>;</dd>
  <dt>$Expect::Do_Soft_Close</dt>
  <dd>Defaults to 0. When destroying objects, soft_close may take up to half a
      minute to shut everything down. From now on, only hard_close will be
      called, which is less polite but still gives the process a chance to
      terminate properly. Set this to '1' for old behaviour.</dd>
  <dt>$Expect::Exp_Internal</dt>
  <dd>Defaults to 0. Newly created objects have a
      <span class="Li">$object</span>-&gt;<b>exp_internal()</b> value of
      <span class="Li">$Expect::Exp_Internal</span>. See
      <span class="Li">$object</span>-&gt;<b>exp_internal()</b>.</dd>
  <dt>$Expect::IgnoreEintr</dt>
  <dd>Defaults to 0. If set to 1, when waiting for new data, Expect will ignore
      EINTR errors and restart the <b>select()</b> call instead.</dd>
  <dt>$Expect::Log_Group</dt>
  <dd>Defaults to 1. Newly created objects have a
      <span class="Li">$object</span>-&gt;<b>log_group()</b> value of
      <span class="Li">$Expect::Log_Group</span>. See
      <span class="Li">$object</span>-&gt;<b>log_group()</b>.</dd>
  <dt>$Expect::Log_Stdout</dt>
  <dd>Defaults to 1 for spawned commands, 0 for file handles attached with
      <b>exp_init()</b>. Newly created objects have a
      <span class="Li">$object</span>-&gt;<b>log_stdout()</b> value of
      <span class="Li">$Expect::Log_Stdout</span>. See
      <span class="Li">$object</span>-&gt;<b>log_stdout()</b>.</dd>
  <dt>$Expect::Manual_Stty</dt>
  <dd>Defaults to 0. Newly created objects have a
      <span class="Li">$object</span>-&gt;<b>manual_stty()</b> value of
      <span class="Li">$Expect::Manual_Stty</span>. See
      <span class="Li">$object</span>-&gt;<b>manual_stty()</b>.</dd>
  <dt>$Expect::Multiline_Matching</dt>
  <dd>Defaults to 1. Affects whether or not <b>expect()</b> uses the /m flag for
      doing regular expression matching. If set to 1 /m is used.
    <p class="Pp">This makes a difference when you are trying to match ^ and $.
        If you have this on you can match lines in the middle of a page of
        output using ^ and $ instead of it matching the beginning and end of the
        entire expression. I think this is handy.</p>
    <p class="Pp">The <span class="Li">$Expect::Multiline_Matching</span> turns
        on and off Expect's multi-line matching mode. But this only has an
        effect if you pass in a string, and then use '-re' mode. If you pass in
        a regular expression value (via qr//), then the qr//'s own flags are
        preserved irrespective of what it gets interpolated into. There was a
        bug in Perl 5.8.x where interpolating a regex without /m into a match
        with /m would incorrectly apply the /m to the inner regex too, but this
        was fixed in Perl 5.10. The correct behavior, as seen in Perl 5.10, is
        that if you pass in a regex (via qr//), then
        <span class="Li">$Expect::Multiline_Matching</span> has no effect. So if
        you pass in a regex, then you must use the qr's flags to control whether
        it is multiline (which by default it is not, opposite of the default
        behavior of Expect).</p>
  </dd>
</dl>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="CONTRIBUTIONS"><a class="permalink" href="#CONTRIBUTIONS">CONTRIBUTIONS</a></h1>
Lee Eakin &lt;leakin@japh.itg.ti.com&gt; has ported the kibitz script from
  Tcl/Expect to Perl/Expect.
<p class="Pp">Jeff Carr &lt;jcarr@linuxmachines.com&gt; provided a simple
    example of how handle terminal window resize events (transmitted via the
    WINCH signal) in a ssh session.</p>
<p class="Pp">You can find both scripts in the examples/ subdir. Thanks to
  both!</p>
<p class="Pp">Historical notes:</p>
<p class="Pp">There are still a few lines of code dating back to the
    inspirational Comm.pl and Chat.pl modules without which this would not have
    been possible. Kudos to Eric Arnold &lt;Eric.Arnold@Sun.com&gt; and Randal
    'Nuke your NT box with one line of perl code'
    Schwartz&lt;merlyn@stonehenge.com&gt; for making these available to the perl
    public.</p>
<p class="Pp">As of .98 I think all the old code is toast. No way could this
    have been done without it though. Special thanks to Graham Barr for helping
    make sense of the IO::Handle stuff as well as providing the highly
    recommended IO::Tty module.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="REFERENCES"><a class="permalink" href="#REFERENCES">REFERENCES</a></h1>
Mark Rogaski &lt;rogaski@att.com&gt; wrote:
<p class="Pp">&quot;I figured that you'd like to know that Expect.pm has been
    very useful to AT&amp;T Labs over the past couple of years (since I first
    talked to Austin about design decisions). We use Expect.pm for managing the
    switches in our network via the telnet interface, and such automation has
    significantly increased our reliability. So, you can honestly say that one
    of the largest digital networks in existence (AT&amp;T Frame Relay) uses
    Expect.pm quite extensively.&quot;</p>
</section>
<section class="Sh">
<h1 class="Sh" id="FAQ__-_Frequently_Asked_Questions"><a class="permalink" href="#FAQ__-_Frequently_Asked_Questions">FAQ
  - Frequently Asked Questions</a></h1>
This is a growing collection of things that might help. Please send you
  questions that are not answered here to RGiersig@cpan.org
<section class="Ss">
<h2 class="Ss" id="What_systems_does_Expect_run_on?"><a class="permalink" href="#What_systems_does_Expect_run_on?">What
  systems does Expect run on?</a></h2>
Expect itself doesn't have real system dependencies, but the underlying IO::Tty
  needs pseudoterminals. IO::Stty uses POSIX.pm and Fcntl.pm.
<p class="Pp">I have used it on Solaris, Linux and AIX, others report *BSD and
    OSF as working. Generally, any modern POSIX Unix should do, but there are
    exceptions to every rule. Feedback is appreciated.</p>
<p class="Pp">See IO::Tty for a list of verified systems.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Can_I_use_this_module_with_ActivePerl_on_Windows?"><a class="permalink" href="#Can_I_use_this_module_with_ActivePerl_on_Windows?">Can
  I use this module with ActivePerl on Windows?</a></h2>
Up to now, the answer was 'No', but this has changed.
<p class="Pp">You still cannot use ActivePerl, but if you use the Cygwin
    environment (http://sources.redhat.com), which brings its own perl, and have
    the latest IO::Tty (v0.05 or later) installed, it should work (feedback
    appreciated).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="The_examples_in_the_tutorial_don't_work!"><a class="permalink" href="#The_examples_in_the_tutorial_don't_work!">The
  examples in the tutorial don't work!</a></h2>
The tutorial is hopelessly out of date and needs a serious overhaul. I apologize
  for this, I have concentrated my efforts mainly on the functionality.
  Volunteers welcomed.
</section>
<section class="Ss">
<h2 class="Ss" id="How_can_I_find_out_what_Expect_is_doing?"><a class="permalink" href="#How_can_I_find_out_what_Expect_is_doing?">How
  can I find out what Expect is doing?</a></h2>
If you set
<p class="Pp"><span class="Li"></span></p>
<pre>
  $Expect::Exp_Internal = 1;
</pre>
<p class="Pp">Expect will tell you very verbosely what it is receiving and
    sending, what matching it is trying and what it found. You can do this on a
    per-command base with</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  $exp-&gt;exp_internal(1);
</pre>
<p class="Pp">You can also set</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  $Expect::Debug = 1;  # or 2, 3 for more verbose output
</pre>
<p class="Pp">or</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  $exp-&gt;debug(1);
</pre>
<p class="Pp">which gives you even more output.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="I_am_seeing_the_output_of_the_command_I_spawned.__Can_I_turn_that_off?"><a class="permalink" href="#I_am_seeing_the_output_of_the_command_I_spawned.__Can_I_turn_that_off?">I
  am seeing the output of the command I spawned. Can I turn that off?</a></h2>
Yes, just set
<p class="Pp"><span class="Li"></span></p>
<pre>
  $Expect::Log_Stdout = 0;
</pre>
<p class="Pp">to globally disable it or</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
   $exp-&gt;log_stdout(0);
</pre>
<p class="Pp">for just that command. 'log_user' is provided as an alias so
    Tcl/Expect user get a DWIM experience... :-)</p>
</section>
<section class="Ss">
<h2 class="Ss" id="No,_I_mean_that_when_I_send_some_text_to_the_spawned_process,_it_gets_echoed_back_and_I_have_to_deal_with_it_in_the_next_expect."><a class="permalink" href="#No,_I_mean_that_when_I_send_some_text_to_the_spawned_process,_it_gets_echoed_back_and_I_have_to_deal_with_it_in_the_next_expect.">No,
  I mean that when I send some text to the spawned process, it gets echoed back
  and I have to deal with it in the next expect.</a></h2>
This is caused by the pty, which has probably 'echo' enabled. A solution would
  be to set the pty to raw mode, which in general is cleaner for communication
  between two programs (no more unexpected character translations).
  Unfortunately this would break a lot of old code that sends &quot;\r&quot; to
  the program instead of &quot;\n&quot; (translating this is also handled by the
  pty), so I won't add this to Expect just like that. But feel free to
  experiment with <span class="Li">&quot;$exp-&gt;raw_pty(1)&quot;</span>.
</section>
<section class="Ss">
<h2 class="Ss" id="How_do_I_send_control_characters_to_a_process?"><a class="permalink" href="#How_do_I_send_control_characters_to_a_process?">How
  do I send control characters to a process?</a></h2>
A: You can send any characters to a process with the print command. To represent
  a control character in Perl, use \c followed by the letter. For example,
  control-G can be represented with &quot;\cG&quot; . Note that this will not
  work if you single-quote your string. So, to send control-C to a process in
  <span class="Li">$exp</span>, do:
<p class="Pp"><span class="Li"></span></p>
<pre>
  print $exp &quot;\cC&quot;;
</pre>
<p class="Pp">Or, if you prefer:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  $exp-&gt;send(&quot;\cC&quot;);
</pre>
<p class="Pp">The ability to include control characters in a string like this is
    provided by Perl, not by Expect.pm . Trying to learn Expect.pm without a
    thorough grounding in Perl can be very daunting. We suggest you look into
    some of the excellent Perl learning material, such as the books _Programming
    Perl_ and _Learning Perl_ by O'Reilly, as well as the extensive online Perl
    documentation available through the perldoc command.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="My_script_fails_from_time_to_time_without_any_obvious_reason.__It_seems_that_I_am_sometimes_loosing_output_from_the_spawned_program."><a class="permalink" href="#My_script_fails_from_time_to_time_without_any_obvious_reason.__It_seems_that_I_am_sometimes_loosing_output_from_the_spawned_program.">My
  script fails from time to time without any obvious reason. It seems that I am
  sometimes loosing output from the spawned program.</a></h2>
You could be exiting too fast without giving the spawned program enough time to
  finish. Try adding <span class="Li">$exp</span>-&gt;<b>soft_close()</b> to
  terminate the program gracefully or do an <b>expect()</b> for 'eof'.
<p class="Pp">Alternatively, try adding a 'sleep 1' after you <b>spawn()</b> the
    program. It could be that pty creation on your system is just slow (but this
    is rather improbable if you are using the latest IO-Tty).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="I_want_to_automate_password_entry_for_su/ssh/scp/rsh/..."><a class="permalink" href="#I_want_to_automate_password_entry_for_su/ssh/scp/rsh/...">I
  want to automate password entry for su/ssh/scp/rsh/...</a></h2>
You shouldn't use Expect for this. Putting passwords, especially root passwords,
  into scripts in clear text can mean severe security problems. I strongly
  recommend using other means. For 'su', consider switching to 'sudo', which
  gives you root access on a per-command and per-user basis without the need to
  enter passwords. 'ssh'/'scp' can be set up with RSA authentication without
  passwords. 'rsh' can use the .rhost mechanism, but I'd strongly suggest to
  switch to 'ssh'; to mention 'rsh' and 'security' in the same sentence makes an
  oxymoron.
<p class="Pp">It will work for 'telnet', though, and there are valid uses for
    it, but you still might want to consider using 'ssh', as keeping cleartext
    passwords around is very insecure.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="I_want_to_use_Expect_to_automate__anything_with_a_buzzword_..."><a class="permalink" href="#I_want_to_use_Expect_to_automate__anything_with_a_buzzword_...">I
  want to use Expect to automate [anything with a buzzword]...</a></h2>
Are you sure there is no other, easier way? As a rule of thumb, Expect is useful
  for automating things that expect to talk to a human, where no formal standard
  applies. For other tasks that do follow a well-defined protocol, there are
  often better-suited modules that already can handle those protocols. Don't try
  to do HTTP requests by spawning telnet to port 80, use LWP instead. To
  automate FTP, take a look at Net::FTP or
  <span class="Li">&quot;ncftp&quot;</span> (http://www.ncftp.org). You don't
  use a screwdriver to hammer in your nails either, or do you?
</section>
<section class="Ss">
<h2 class="Ss" id="Is_it_possible_to_use_threads_with_Expect?"><a class="permalink" href="#Is_it_possible_to_use_threads_with_Expect?">Is
  it possible to use threads with Expect?</a></h2>
Basically yes, with one restriction: you must <b>spawn()</b> your programs in
  the main thread and then pass the Expect objects to the handling threads. The
  reason is that <b>spawn()</b> uses <b>fork()</b>, and perlthrtut:
<p class="Pp"><span class="Li"></span></p>
<pre>
  &quot;Thinking of mixing fork() and threads?  Please lie down and wait until the feeling passes.&quot;
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="I_want_to_log_the_whole_session_to_a_file."><a class="permalink" href="#I_want_to_log_the_whole_session_to_a_file.">I
  want to log the whole session to a file.</a></h2>
Use
<p class="Pp"><span class="Li"></span></p>
<pre>
  $exp-&gt;log_file(&quot;filename&quot;);
</pre>
<p class="Pp">or</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  $exp-&gt;log_file($filehandle);
</pre>
<p class="Pp">or even</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  $exp-&gt;log_file(\&amp;log_procedure);
</pre>
<p class="Pp">for maximum flexibility.</p>
<p class="Pp">Note that the logfile is appended to by default, but you can
    specify an optional mode &quot;w&quot; to truncate the logfile:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  $exp-&gt;log_file(&quot;filename&quot;, &quot;w&quot;);
</pre>
<p class="Pp">To stop logging, just call it with a false argument:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  $exp-&gt;log_file(undef);
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="How_can_I_turn_off_multi-line_matching_for_my_regexps?"><a class="permalink" href="#How_can_I_turn_off_multi-line_matching_for_my_regexps?">How
  can I turn off multi-line matching for my regexps?</a></h2>
To globally unset multi-line matching for all regexps:
<p class="Pp"><span class="Li"></span></p>
<pre>
  $Expect::Multiline_Matching = 0;
</pre>
<p class="Pp">You can do that on a per-regexp basis by stating
    <span class="Li">&quot;(?-m)&quot;</span> inside the regexp (you need
    perl5.00503 or later for that).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="How_can_I_expect_on_multiple_spawned_commands?"><a class="permalink" href="#How_can_I_expect_on_multiple_spawned_commands?">How
  can I expect on multiple spawned commands?</a></h2>
You can use the <b>-i</b> parameter to specify a single object or a list of
  Expect objects. All following patterns will be evaluated against that list.
<p class="Pp">You can specify <b>-i</b> multiple times to create groups of
    objects and patterns to match against within the same expect statement.</p>
<p class="Pp">This works just like in Tcl/Expect.</p>
<p class="Pp">See the source example below.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="I_seem_to_have_problems_with_ptys!"><a class="permalink" href="#I_seem_to_have_problems_with_ptys!">I
  seem to have problems with ptys!</a></h2>
Well, pty handling is really a black magic, as it is extremely system dependent.
  I have extensively revised IO-Tty, so these problems should be gone.
<p class="Pp">If your system is listed in the &quot;verified&quot; list of
    IO::Tty, you probably have some non-standard setup, e.g. you compiled your
    Linux-kernel yourself and disabled ptys. Please ask your friendly sysadmin
    for help.</p>
<p class="Pp">If your system is not listed, unpack the latest version of
    IO::Tty, do a 'perl Makefile.PL; make; make test; uname
    <span class="Li">&quot;-a&quot;</span>' and send me the results and I'll see
    what I can deduce from that.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="I_just_want_to_read_the_output_of_a_process_without__fBexpect()_fPing_anything._How_can_I_do_this?"><a class="permalink" href="#I_just_want_to_read_the_output_of_a_process_without__fBexpect()_fPing_anything._How_can_I_do_this?">I
  just want to read the output of a process without <b>expect()</b>ing anything.
  How can I do this?</a></h2>
[ Are you sure you need Expect for this? How about <b>qx()</b> or
  open(&quot;prog|&quot;)? ]
<p class="Pp">By using expect without any patterns to match.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  $process-&gt;expect(undef); # Forever until EOF
  $process-&gt;expect($timeout); # For a few seconds
  $process-&gt;expect(0); # Is there anything ready on the handle now?
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Ok,_so_now_how_do_I_get_what_was_read_on_the_handle?"><a class="permalink" href="#Ok,_so_now_how_do_I_get_what_was_read_on_the_handle?">Ok,
  so now how do I get what was read on the handle?</a></h2>
<span class="Li"></span>
<pre>
  $read = $process-&gt;before();
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Where's_IO::Pty?"><a class="permalink" href="#Where's_IO::Pty?">Where's
  IO::Pty?</a></h2>
Find it on CPAN as IO-Tty, which provides both.
</section>
<section class="Ss">
<h2 class="Ss" id="How_come_when_I_automate_the_passwd_program_to_change_passwords_for_me_passwd_dies_before_changing_the_password_sometimes/every_time?"><a class="permalink" href="#How_come_when_I_automate_the_passwd_program_to_change_passwords_for_me_passwd_dies_before_changing_the_password_sometimes/every_time?">How
  come when I automate the passwd program to change passwords for me passwd dies
  before changing the password sometimes/every time?</a></h2>
What's happening is you are closing the handle before passwd exits. When you
  close the handle to a process, it is sent a signal (SIGPIPE?) telling it that
  STDOUT has gone away. The default behavior for processes is to die in this
  circumstance. Two ways you can make this not happen are:
<p class="Pp"><span class="Li"></span></p>
<pre>
  $process-&gt;soft_close();
</pre>
<p class="Pp">This will wait 15 seconds for a process to come up with an EOF by
    itself before killing it.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  $process-&gt;expect(undef);
</pre>
<p class="Pp">This will wait forever for the process to match an empty set of
    patterns. It will return when the process hits an EOF.</p>
<p class="Pp">As a rule, you should always <b>expect()</b> the result of your
    transaction before you continue with processing.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="How_come_when_I_try_to_make_a_logfile_with__fBlog_file()_fP_or__fBset_group()_fP_it_doesn't_print_anything_after_the_last_time_I_run__fBexpect()_fP?"><a class="permalink" href="#How_come_when_I_try_to_make_a_logfile_with__fBlog_file()_fP_or__fBset_group()_fP_it_doesn't_print_anything_after_the_last_time_I_run__fBexpect()_fP?">How
  come when I try to make a logfile with <b>log_file()</b> or <b>set_group()</b>
  it doesn't print anything after the last time I run <b>expect()</b>?</a></h2>
Output is only printed to the logfile/group when Expect reads from the process,
  during <b>expect()</b>, <b>send_slow()</b> and <b>interconnect()</b>. One way
  you can force this is to make use of
<p class="Pp"><span class="Li"></span></p>
<pre>
  $process-&gt;expect(undef);
</pre>
<p class="Pp">and</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  $process-&gt;expect(0);
</pre>
<p class="Pp">which will make <b>expect()</b> run with an empty pattern set
    forever or just for an instant to capture the output of
    <span class="Li">$process</span>. The output is available in the
    accumulator, so you can grab it using
    <span class="Li">$process</span>-&gt;<b>before()</b>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="I_seem_to_have_problems_with_terminal_settings,_double_echoing,_etc."><a class="permalink" href="#I_seem_to_have_problems_with_terminal_settings,_double_echoing,_etc.">I
  seem to have problems with terminal settings, double echoing, etc.</a></h2>
Tty settings are a major pain to keep track of. If you find unexpected behavior
  such as double-echoing or a frozen session, doublecheck the documentation for
  default settings. When in doubt, handle them yourself using
  <span class="Li">$exp</span>-&gt;<b>stty()</b> and <b>manual_stty()</b>
  functions. As of .98 you shouldn't have to worry about stty settings getting
  fouled unless you use interconnect or intentionally change them (like doing
  -echo to get a password).
<p class="Pp">If you foul up your terminal's tty settings, kill any hung
    processes and enter 'stty sane' at a shell prompt. This should make your
    terminal manageable again.</p>
<p class="Pp">Note that IO::Tty returns ptys with your systems default setting
    regarding echoing, CRLF translation etc. and Expect does not change them. I
    have considered setting the ptys to 'raw' without any translation
    whatsoever, but this would break a lot of existing things, as '\r'
    translation would not work anymore. On the other hand, a raw pty works much
    like a pipe and is more WYGIWYE (what you get is what you expect), so I
    suggest you set it to 'raw' by yourself:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  $exp = Expect-&gt;new;
  $exp-&gt;raw_pty(1);
  $exp-&gt;spawn(...);
</pre>
<p class="Pp">To disable echo:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  $exp-&gt;slave-&gt;stty(qw(-echo));
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="I'm_spawning_a_telnet/ssh_session_and_then_let_the_user_interact_with_it.__But_screen-oriented_applications_on_the_other_side_don't_work_properly."><a class="permalink" href="#I'm_spawning_a_telnet/ssh_session_and_then_let_the_user_interact_with_it.__But_screen-oriented_applications_on_the_other_side_don't_work_properly.">I'm
  spawning a telnet/ssh session and then let the user interact with it. But
  screen-oriented applications on the other side don't work properly.</a></h2>
You have to set the terminal screen size for that. Luckily, IO::Pty already has
  a method for that, so modify your code to look like this:
<p class="Pp"><span class="Li"></span></p>
<pre>
  my $exp = Expect-&gt;new;
  $exp-&gt;slave-&gt;clone_winsize_from(\*STDIN);
  $exp-&gt;spawn(&quot;telnet somehost);
</pre>
<p class="Pp">Also, some applications need the TERM shell variable set so they
    know how to move the cursor across the screen. When logging in, the remote
    shell sends a query (Ctrl-Z I think) and expects the terminal to answer with
    a string, e.g. 'xterm'. If you really want to go that way (be aware, madness
    lies at its end), you can handle that and send back the value in
    <span class="Li">$ENV</span>{TERM}. This is only a hand-waving explanation,
    please figure out the details by yourself.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="I_set_the_terminal_size_as_explained_above,_but_if_I_resize_the_window,_the_application_does_not_notice_this."><a class="permalink" href="#I_set_the_terminal_size_as_explained_above,_but_if_I_resize_the_window,_the_application_does_not_notice_this.">I
  set the terminal size as explained above, but if I resize the window, the
  application does not notice this.</a></h2>
You have to catch the signal WINCH (&quot;window size changed&quot;), change the
  terminal size and propagate the signal to the spawned application:
<p class="Pp"><span class="Li"></span></p>
<pre>
  my $exp = Expect-&gt;new;
  $exp-&gt;slave-&gt;clone_winsize_from(\*STDIN);
  $exp-&gt;spawn(&quot;ssh somehost);
  $SIG{WINCH} = \&amp;winch;

  sub winch {
    $exp-&gt;slave-&gt;clone_winsize_from(\*STDIN);
    kill WINCH =&gt; $exp-&gt;pid if $exp-&gt;pid;
    $SIG{WINCH} = \&amp;winch;
  }

  $exp-&gt;interact();
</pre>
<p class="Pp">There is an example file ssh.pl in the examples/ subdir that shows
    how this works with ssh. Please note that I do strongly object against using
    Expect to automate ssh login, as there are better way to do that (see
    ssh-keygen).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="I_noticed_that_the_test_uses_a_string_that_resembles,_but_not_exactly_matches,_a_well-known_sentence_that_contains_every_character.__What_does_that_mean?"><a class="permalink" href="#I_noticed_that_the_test_uses_a_string_that_resembles,_but_not_exactly_matches,_a_well-known_sentence_that_contains_every_character.__What_does_that_mean?">I
  noticed that the test uses a string that resembles, but not exactly matches, a
  well-known sentence that contains every character. What does that
  mean?</a></h2>
That means you are anal-retentive. :-) [Gotcha there!]
</section>
<section class="Ss">
<h2 class="Ss" id="I_get_a__Could_not_assign_a_pty__error_when_running_as_a_non-root_user_on_an__s-1IRIX_s0_box?"><a class="permalink" href="#I_get_a__Could_not_assign_a_pty__error_when_running_as_a_non-root_user_on_an__s-1IRIX_s0_box?">I
  get a &quot;Could not assign a pty&quot; error when running as a non-root user
  on an IRIX box?</a></h2>
The OS may not be configured to grant additional pty's (pseudo terminals) to
  non-root users. /usr/sbin/mkpts should be 4755, not 700 for this to work. I
  don't know about security implications if you do this.
</section>
<section class="Ss">
<h2 class="Ss" id="How_come_I_don't_notice_when_the_spawned_process_closes_its_stdin/out/err??"><a class="permalink" href="#How_come_I_don't_notice_when_the_spawned_process_closes_its_stdin/out/err??">How
  come I don't notice when the spawned process closes its
  stdin/out/err??</a></h2>
You are probably on one of the systems where the master doesn't get an EOF when
  the slave closes stdin/out/err.
<p class="Pp">One possible solution is when you spawn a process, follow it with
    a unique string that would indicate the process is finished.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  $process = Expect-&gt;spawn('telnet somehost; echo ____END____');
</pre>
<p class="Pp">And then
    <span class="Li">$process</span>-&gt;expect($timeout,'____END____','other','patterns');</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="Source_Examples"><a class="permalink" href="#Source_Examples">Source
  Examples</a></h1>
<section class="Ss">
<h2 class="Ss" id="How_to_automate_login"><a class="permalink" href="#How_to_automate_login">How
  to automate login</a></h2>
<span class="Li"></span>
<pre>
  my $telnet = Net::Telnet-&gt;new(&quot;remotehost&quot;) # see Net::Telnet
    or die &quot;Cannot telnet to remotehost: $!\n&quot;;;
  my $exp = Expect-&gt;exp_init($telnet);

  # deprecated use of spawned telnet command
  # my $exp = Expect-&gt;spawn(&quot;telnet localhost&quot;)
  #   or die &quot;Cannot spawn telnet: $!\n&quot;;;

  my $spawn_ok;
  $exp-&gt;expect($timeout,
           [
        qr'login: $',
        sub {
                  $spawn_ok = 1;
          my $fh = shift;
          $fh-&gt;send(&quot;$username\n&quot;);
                  exp_continue;
        }
           ],
           [
        'Password: $',
        sub {
          my $fh = shift;
          print $fh &quot;$password\n&quot;;
                  exp_continue;
        }
           ],
           [
        eof =&gt;
        sub {
                  if ($spawn_ok) {
            die &quot;ERROR: premature EOF in login.\n&quot;;
                  } else {
            die &quot;ERROR: could not spawn telnet.\n&quot;;
                  }
        }
           ],
           [
        timeout =&gt;
        sub {
          die &quot;No login.\n&quot;;
        }
           ],
           '-re', qr'[#&gt;:] $', #' wait for shell prompt, then exit expect
          );
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="How_to_expect_on_multiple_spawned_commands"><a class="permalink" href="#How_to_expect_on_multiple_spawned_commands">How
  to expect on multiple spawned commands</a></h2>
<span class="Li"></span>
<pre>
  foreach my $cmd (@list_of_commands) {
    push @commands, Expect-&gt;spawn($cmd);
  }

  expect($timeout,
     '-i', \@commands,
     [
      qr&quot;pattern&quot;,        # find this pattern in output of all commands
      sub {
        my $obj = shift;    # object that matched
        print $obj &quot;something\n&quot;;
        exp_continue;    # we don't want to terminate the expect call
      }
     ],
     '-i', $some_other_command,
     [
      &quot;some other pattern&quot;,
      sub {
        my ($obj, $parmref) = @_;
        # ...

        # now we exit the expect command
      },
      \$parm
     ],
    );
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="How_to_propagate_terminal_sizes"><a class="permalink" href="#How_to_propagate_terminal_sizes">How
  to propagate terminal sizes</a></h2>
<span class="Li"></span>
<pre>
  my $exp = Expect-&gt;new;
  $exp-&gt;slave-&gt;clone_winsize_from(\*STDIN);
  $exp-&gt;spawn(&quot;ssh somehost);
  $SIG{WINCH} = \&amp;winch;

  sub winch {
    $exp-&gt;slave-&gt;clone_winsize_from(\*STDIN);
    kill WINCH =&gt; $exp-&gt;pid if $exp-&gt;pid;
    $SIG{WINCH} = \&amp;winch;
  }

  $exp-&gt;interact();
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="HOMEPAGE"><a class="permalink" href="#HOMEPAGE">HOMEPAGE</a></h1>
&lt;http://sourceforge.net/projects/expectperl/&gt; though the source code is
  now in GitHub: &lt;https://github.com/jacoby/expect.pm&gt;
</section>
<section class="Sh">
<h1 class="Sh" id="MAILING_LISTS"><a class="permalink" href="#MAILING_LISTS">MAILING
  LISTS</a></h1>
There are two mailing lists available, expectperl-announce and
  expectperl-discuss, at
<p class="Pp"><span class="Li"></span></p>
<pre>
  http://lists.sourceforge.net/lists/listinfo/expectperl-announce
</pre>
<p class="Pp">and</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  http://lists.sourceforge.net/lists/listinfo/expectperl-discuss
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="BUG_TRACKING"><a class="permalink" href="#BUG_TRACKING">BUG
  TRACKING</a></h1>
You can use the CPAN Request Tracker http://rt.cpan.org/ and submit new bugs
  under
<p class="Pp"><span class="Li"></span></p>
<pre>
  http://rt.cpan.org/Ticket/Create.html?Queue=Expect
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHORS"><a class="permalink" href="#AUTHORS">AUTHORS</a></h1>
(c) 1997 Austin Schutz &lt;<i>ASchutz@users.sourceforge.net</i>&gt; (retired)
<p class="Pp"><b>expect()</b> interface &amp; functionality enhancements (c)
    1999-2006 Roland Giersig.</p>
<p class="Pp">This module is now maintained by Dave Jacoby
    &lt;<i>jacoby@cpan.org</i>&gt;</p>
</section>
<section class="Sh">
<h1 class="Sh" id="LICENSE"><a class="permalink" href="#LICENSE">LICENSE</a></h1>
This module can be used under the same terms as Perl.
</section>
<section class="Sh">
<h1 class="Sh" id="DISCLAIMER"><a class="permalink" href="#DISCLAIMER">DISCLAIMER</a></h1>
THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
  INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
  FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHORS
  BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE.
<p class="Pp">In other words: Use at your own risk. Provided as is. Your mileage
    may vary. Read the source, Luke!</p>
<p class="Pp">And finally, just to be sure:</p>
<p class="Pp">Any Use of This Product, in Any Manner Whatsoever, Will Increase
    the Amount of Disorder in the Universe. Although No Liability Is Implied
    Herein, the Consumer Is Warned That This Process Will Ultimately Lead to the
    Heat Death of the Universe.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2017-05-18</td>
    <td class="foot-os">perl v5.28.2</td>
  </tr>
</table>
</body>
</html>
