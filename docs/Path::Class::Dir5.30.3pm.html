<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>Path::Class::Dir(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Path::Class::Dir(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Path::Class::Dir(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
Path::Class::Dir - Objects representing directories
</section>
<section class="Sh">
<h1 class="Sh" id="VERSION"><a class="permalink" href="#VERSION">VERSION</a></h1>
version 0.37
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<span class="Li"></span>
<pre>
  use Path::Class;  # Exports dir() by default
  
  my $dir = dir('foo', 'bar');       # Path::Class::Dir object
  my $dir = Path::Class::Dir-&gt;new('foo', 'bar');  # Same thing
  
  # Stringifies to 'foo/bar' on Unix, 'foo\bar' on Windows, etc.
  print &quot;dir: $dir\n&quot;;
  
  if ($dir-&gt;is_absolute) { ... }
  if ($dir-&gt;is_relative) { ... }
  
  my $v = $dir-&gt;volume; # Could be 'C:' on Windows, empty string
                        # on Unix, 'Macintosh HD:' on Mac OS
  
  $dir-&gt;cleanup; # Perform logical cleanup of pathname
  $dir-&gt;resolve; # Perform physical cleanup of pathname
  
  my $file = $dir-&gt;file('file.txt'); # A file in this directory
  my $subdir = $dir-&gt;subdir('george'); # A subdirectory
  my $parent = $dir-&gt;parent; # The parent directory, 'foo'
  
  my $abs = $dir-&gt;absolute; # Transform to absolute path
  my $rel = $abs-&gt;relative; # Transform to relative path
  my $rel = $abs-&gt;relative('/foo'); # Relative to /foo
  
  print $dir-&gt;as_foreign('Mac');   # :foo:bar:
  print $dir-&gt;as_foreign('Win32'); #  foo\bar

  # Iterate with IO::Dir methods:
  my $handle = $dir-&gt;open;
  while (my $file = $handle-&gt;read) {
    $file = $dir-&gt;file($file);  # Turn into Path::Class::File object
    ...
  }
  
  # Iterate with Path::Class methods:
  while (my $file = $dir-&gt;next) {
    # $file is a Path::Class::File or Path::Class::Dir object
    ...
  }
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
The <span class="Li">&quot;Path::Class::Dir&quot;</span> class contains
  functionality for manipulating directory names in a cross-platform way.
</section>
<section class="Sh">
<h1 class="Sh" id="METHODS"><a class="permalink" href="#METHODS">METHODS</a></h1>
<dl class="Bl-tag">
  <dt>$dir = Path::Class::Dir-&gt;new( &lt;dir1&gt;, &lt;dir2&gt;, ... )</dt>
  <dd></dd>
  <dt>$dir = dir( &lt;dir1&gt;, &lt;dir2&gt;, ... )</dt>
  <dd>Creates a new <span class="Li">&quot;Path::Class::Dir&quot;</span> object
      and returns it. The arguments specify names of directories which will be
      joined to create a single directory object. A volume may also be specified
      as the first argument, or as part of the first argument. You can use
      platform-neutral syntax:
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  my $dir = dir( 'foo', 'bar', 'baz' );
    </pre>
    <p class="Pp">or platform-native syntax:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  my $dir = dir( 'foo/bar/baz' );
    </pre>
    <p class="Pp">or a mixture of the two:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  my $dir = dir( 'foo/bar', 'baz' );
    </pre>
    <p class="Pp">All three of the above examples create relative paths. To
        create an absolute path, either use the platform native syntax for doing
        so:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  my $dir = dir( '/var/tmp' );
    </pre>
    <p class="Pp">or use an empty string as the first argument:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  my $dir = dir( '', 'var', 'tmp' );
    </pre>
    <p class="Pp">If the second form seems awkward, that's somewhat intentional
        - paths like <span class="Li">&quot;/var/tmp&quot;</span> or
        <span class="Li">&quot;\Windows&quot;</span> aren't cross-platform
        concepts in the first place (many non-Unix platforms don't have a notion
        of a &quot;root directory&quot;), so they probably shouldn't appear in
        your code if you're trying to be cross-platform. The first form is
        perfectly natural, because paths like this may come from config files,
        user input, or whatever.</p>
    <p class="Pp">As a special case, since it doesn't otherwise mean anything
        useful and it's convenient to define this way,
        <span class="Li">&quot;Path::Class::Dir-&gt;new()&quot;</span> (or
        <span class="Li">&quot;dir()&quot;</span>) refers to the current
        directory (<span class="Li">&quot;File::Spec-&gt;curdir&quot;</span>).
        To get the current directory as an absolute path, do
        <span class="Li">&quot;dir()-&gt;absolute&quot;</span>.</p>
    <p class="Pp">Finally, as another special case
        <span class="Li">&quot;dir(undef)&quot;</span> will return undef, since
        that's usually an accident on the part of the caller, and returning the
        root directory would be a nasty surprise just asking for trouble a few
        lines later.</p>
  </dd>
  <dt>$dir-&gt;stringify</dt>
  <dd>This method is called internally when a
      <span class="Li">&quot;Path::Class::Dir&quot;</span> object is used in a
      string context, so the following are equivalent:
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  $string = $dir-&gt;stringify;
  $string = &quot;$dir&quot;;
    </pre>
  </dd>
  <dt>$dir-&gt;volume</dt>
  <dd>Returns the volume (e.g. <span class="Li">&quot;C:&quot;</span> on
      Windows, <span class="Li">&quot;Macintosh HD:&quot;</span> on Mac OS,
      etc.) of the directory object, if any. Otherwise, returns the empty
      string.</dd>
  <dt>$dir-&gt;basename</dt>
  <dd>Returns the last directory name of the path as a string.</dd>
  <dt>$dir-&gt;is_dir</dt>
  <dd>Returns a boolean value indicating whether this object represents a
      directory. Not surprisingly, Path::Class::File objects always return
      false, and <span class="Li">&quot;Path::Class::Dir&quot;</span> objects
      always return true.</dd>
  <dt>$dir-&gt;is_absolute</dt>
  <dd>Returns true or false depending on whether the directory refers to an
      absolute path specifier (like
      <span class="Li">&quot;/usr/local&quot;</span> or
      <span class="Li">&quot;\Windows&quot;</span>).</dd>
  <dt>$dir-&gt;is_relative</dt>
  <dd>Returns true or false depending on whether the directory refers to a
      relative path specifier (like <span class="Li">&quot;lib/foo&quot;</span>
      or <span class="Li">&quot;./dir&quot;</span>).</dd>
  <dt>$dir-&gt;cleanup</dt>
  <dd>Performs a logical cleanup of the file path. For instance:
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  my $dir = dir('/foo//baz/./foo')-&gt;cleanup;
  # $dir now represents '/foo/baz/foo';
    </pre>
  </dd>
  <dt>$dir-&gt;resolve</dt>
  <dd>Performs a physical cleanup of the file path. For instance:
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  my $dir = dir('/foo//baz/../foo')-&gt;resolve;
  # $dir now represents '/foo/foo', assuming no symlinks
    </pre>
    <p class="Pp">This actually consults the filesystem to verify the validity
        of the path.</p>
  </dd>
  <dt>$file = $dir-&gt;file( &lt;dir1&gt;, &lt;dir2&gt;, ..., &lt;file&gt;
    )</dt>
  <dd>Returns a Path::Class::File object representing an entry in
      <span class="Li">$dir</span> or one of its subdirectories. Internally,
      this just calls <span class="Li">&quot;Path::Class::File-&gt;new( @_
      )&quot;</span>.</dd>
  <dt>$subdir = $dir-&gt;subdir( &lt;dir1&gt;, &lt;dir2&gt;, ... )</dt>
  <dd>Returns a new <span class="Li">&quot;Path::Class::Dir&quot;</span> object
      representing a subdirectory of <span class="Li">$dir</span>.</dd>
  <dt>$parent = $dir-&gt;parent</dt>
  <dd>Returns the parent directory of <span class="Li">$dir</span>. Note that
      this is the <i>logical</i> parent, not necessarily the physical parent. It
      really means we just chop off entries from the end of the directory list
      until we cain't chop no more. If the directory is relative, we start using
      the relative forms of parent directories.
    <p class="Pp">The following code demonstrates the behavior on absolute and
        relative directories:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  $dir = dir('/foo/bar');
  for (1..6) {
    print &quot;Absolute: $dir\n&quot;;
    $dir = $dir-&gt;parent;
  }
  
  $dir = dir('foo/bar');
  for (1..6) {
    print &quot;Relative: $dir\n&quot;;
    $dir = $dir-&gt;parent;
  }
  
  ########### Output on Unix ################
  Absolute: /foo/bar
  Absolute: /foo
  Absolute: /
  Absolute: /
  Absolute: /
  Absolute: /
  Relative: foo/bar
  Relative: foo
  Relative: .
  Relative: ..
  Relative: ../..
  Relative: ../../..
    </pre>
  </dd>
  <dt>@list = $dir-&gt;children</dt>
  <dd>Returns a list of Path::Class::File and/or
      <span class="Li">&quot;Path::Class::Dir&quot;</span> objects listed in
      this directory, or in scalar context the number of such objects.
      Obviously, it is necessary for <span class="Li">$dir</span> to exist and
      be readable in order to find its children.
    <p class="Pp">Note that the children are returned as subdirectories of
        <span class="Li">$dir</span>, i.e. the children of <i>foo</i> will be
        <i>foo/bar</i> and <i>foo/baz</i>, not <i>bar</i> and <i>baz</i>.</p>
    <p class="Pp">Ordinarily <span class="Li">&quot;children()&quot;</span> will
        not include the <i>self</i> and <i>parent</i> entries
        <span class="Li">&quot;.&quot;</span> and
        <span class="Li">&quot;..&quot;</span> (or their equivalents on non-Unix
        systems), because that's like I'm-my-own-grandpa business. If you do
        want all directory entries including these special ones, pass a true
        value for the <span class="Li">&quot;all&quot;</span> parameter:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  @c = $dir-&gt;children(); # Just the children
  @c = $dir-&gt;children(all =&gt; 1); # All entries
    </pre>
    <p class="Pp">In addition, there's a
        <span class="Li">&quot;no_hidden&quot;</span> parameter that will
        exclude all normally &quot;hidden&quot; entries - on Unix this means
        excluding all entries that begin with a dot
        (<span class="Li">&quot;.&quot;</span>):</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  @c = $dir-&gt;children(no_hidden =&gt; 1); # Just normally-visible entries
    </pre>
  </dd>
  <dt>$abs = $dir-&gt;absolute</dt>
  <dd>Returns a <span class="Li">&quot;Path::Class::Dir&quot;</span> object
      representing <span class="Li">$dir</span> as an absolute path. An optional
      argument, given as either a string or a
      <span class="Li">&quot;Path::Class::Dir&quot;</span> object, specifies the
      directory to use as the base of relativity - otherwise the current working
      directory will be used.</dd>
  <dt>$rel = $dir-&gt;relative</dt>
  <dd>Returns a <span class="Li">&quot;Path::Class::Dir&quot;</span> object
      representing <span class="Li">$dir</span> as a relative path. An optional
      argument, given as either a string or a
      <span class="Li">&quot;Path::Class::Dir&quot;</span> object, specifies the
      directory to use as the base of relativity - otherwise the current working
      directory will be used.</dd>
  <dt>$boolean = $dir-&gt;subsumes($other)</dt>
  <dd>Returns true if this directory spec subsumes the other spec, and false
      otherwise. Think of &quot;subsumes&quot; as &quot;contains&quot;, but we
      only look at the <i>specs</i>, not whether <span class="Li">$dir</span>
      actually contains <span class="Li">$other</span> on the filesystem.
    <p class="Pp">The <span class="Li">$other</span> argument may be a
        <span class="Li">&quot;Path::Class::Dir&quot;</span> object, a
        Path::Class::File object, or a string. In the latter case, we assume
        it's a directory.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  # Examples:
  dir('foo/bar' )-&gt;subsumes(dir('foo/bar/baz'))  # True
  dir('/foo/bar')-&gt;subsumes(dir('/foo/bar/baz')) # True
  dir('foo/..')-&gt;subsumes(dir('foo/../bar))      # True
  dir('foo/bar' )-&gt;subsumes(dir('bar/baz'))      # False
  dir('/foo/bar')-&gt;subsumes(dir('foo/bar'))      # False
  dir('foo/..')-&gt;subsumes(dir('bar'))            # False! Use C&lt;contains&gt; to resolve &quot;..&quot;
    </pre>
  </dd>
  <dt>$boolean = $dir-&gt;contains($other)</dt>
  <dd>Returns true if this directory actually contains
      <span class="Li">$other</span> on the filesystem.
      <span class="Li">$other</span> doesn't have to be a direct child of
      <span class="Li">$dir</span>, it just has to be subsumed after both paths
      have been resolved.</dd>
  <dt>$foreign = $dir-&gt;as_foreign($type)</dt>
  <dd>Returns a <span class="Li">&quot;Path::Class::Dir&quot;</span> object
      representing <span class="Li">$dir</span> as it would be specified on a
      system of type <span class="Li">$type</span>. Known types include
      <span class="Li">&quot;Unix&quot;</span>,
      <span class="Li">&quot;Win32&quot;</span>,
      <span class="Li">&quot;Mac&quot;</span>,
      <span class="Li">&quot;VMS&quot;</span>, and
      <span class="Li">&quot;OS2&quot;</span>, i.e. anything for which there is
      a subclass of <span class="Li">&quot;File::Spec&quot;</span>.
    <p class="Pp">Any generated objects (subdirectories, files, parents, etc.)
        will also retain this type.</p>
  </dd>
  <dt>$foreign = Path::Class::Dir-&gt;new_foreign($type, @args)</dt>
  <dd>Returns a <span class="Li">&quot;Path::Class::Dir&quot;</span> object
      representing <span class="Li">$dir</span> as it would be specified on a
      system of type <span class="Li">$type</span>. Known types include
      <span class="Li">&quot;Unix&quot;</span>,
      <span class="Li">&quot;Win32&quot;</span>,
      <span class="Li">&quot;Mac&quot;</span>,
      <span class="Li">&quot;VMS&quot;</span>, and
      <span class="Li">&quot;OS2&quot;</span>, i.e. anything for which there is
      a subclass of <span class="Li">&quot;File::Spec&quot;</span>.
    <p class="Pp">The arguments in <span class="Li">@args</span> are the same as
        they would be specified in
      <span class="Li">&quot;new()&quot;</span>.</p>
  </dd>
  <dt>@list = $dir-&gt;dir_list([OFFSET, [LENGTH]])</dt>
  <dd>Returns the list of strings internally representing this directory
      structure. Each successive member of the list is understood to be an entry
      in its predecessor's directory list. By contract,
      <span class="Li">&quot;Path::Class-&gt;new( $dir-&gt;dir_list
      )&quot;</span> should be equivalent to <span class="Li">$dir</span>.
    <p class="Pp">The semantics of this method are similar to Perl's
        <span class="Li">&quot;splice&quot;</span> or
        <span class="Li">&quot;substr&quot;</span> functions; they return
        <span class="Li">&quot;LENGTH&quot;</span> elements starting at
        <span class="Li">&quot;OFFSET&quot;</span>. If
        <span class="Li">&quot;LENGTH&quot;</span> is omitted, returns all the
        elements starting at <span class="Li">&quot;OFFSET&quot;</span> up to
        the end of the list. If <span class="Li">&quot;LENGTH&quot;</span> is
        negative, returns the elements from
        <span class="Li">&quot;OFFSET&quot;</span> onward except for
        <span class="Li">&quot;-LENGTH&quot;</span> elements at the end. If
        <span class="Li">&quot;OFFSET&quot;</span> is negative, it counts
        backward <span class="Li">&quot;OFFSET&quot;</span> elements from the
        end of the list. If <span class="Li">&quot;OFFSET&quot;</span> and
        <span class="Li">&quot;LENGTH&quot;</span> are both omitted, the entire
        list is returned.</p>
    <p class="Pp">In a scalar context,
        <span class="Li">&quot;dir_list()&quot;</span> with no arguments returns
        the number of entries in the directory list;
        <span class="Li">&quot;dir_list(OFFSET)&quot;</span> returns the single
        element at that offset; <span class="Li">&quot;dir_list(OFFSET,
        LENGTH)&quot;</span> returns the final element that would have been
        returned in a list context.</p>
  </dd>
  <dt>$dir-&gt;components</dt>
  <dd>Identical to <span class="Li">&quot;dir_list()&quot;</span>. It exists
      because there's an analogous method
      <span class="Li">&quot;dir_list()&quot;</span> in the
      <span class="Li">&quot;Path::Class::File&quot;</span> class that also
      returns the basename string, so this method lets someone call
      <span class="Li">&quot;components()&quot;</span> without caring whether
      the object is a file or a directory.</dd>
  <dt>$fh = $dir-&gt;<b>open()</b></dt>
  <dd>Passes <span class="Li">$dir</span> to
      <span class="Li">&quot;IO::Dir-&gt;open&quot;</span> and returns the
      result as an IO::Dir object. If the opening fails,
      <span class="Li">&quot;undef&quot;</span> is returned and
      <span class="Li">$!</span> is set.</dd>
  <dt>$dir-&gt;mkpath($verbose, $mode)</dt>
  <dd>Passes all arguments, including <span class="Li">$dir</span>, to
      <span class="Li">&quot;File::Path::mkpath()&quot;</span> and returns the
      result (a list of all directories created).</dd>
  <dt>$dir-&gt;rmtree($verbose, $cautious)</dt>
  <dd>Passes all arguments, including <span class="Li">$dir</span>, to
      <span class="Li">&quot;File::Path::rmtree()&quot;</span> and returns the
      result (the number of files successfully deleted).</dd>
  <dt>$dir-&gt;<b>remove()</b></dt>
  <dd>Removes the directory, which must be empty. Returns a boolean value
      indicating whether or not the directory was successfully removed. This
      method is mainly provided for consistency with
      <span class="Li">&quot;Path::Class::File&quot;</span>'s
      <span class="Li">&quot;remove()&quot;</span> method.</dd>
  <dt>$dir-&gt;tempfile(...)</dt>
  <dd>An interface to File::Temp's
      <span class="Li">&quot;tempfile()&quot;</span> function. Just like that
      function, if you call this in a scalar context, the return value is the
      filehandle and the file is <span class="Li">&quot;unlink&quot;</span>ed as
      soon as possible (which is immediately on Unix-like platforms). If called
      in a list context, the return values are the filehandle and the filename.
    <p class="Pp">The given directory is passed as the
        <span class="Li">&quot;DIR&quot;</span> parameter.</p>
    <p class="Pp">Here's an example of pretty good usage which doesn't allow
        race conditions, won't leave yucky tempfiles around on your filesystem,
        etc.:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  my $fh = $dir-&gt;tempfile;
  print $fh &quot;Here's some data...\n&quot;;
  seek($fh, 0, 0);
  while (&lt;$fh&gt;) { do something... }
    </pre>
    <p class="Pp">Or in combination with a
        <span class="Li">&quot;fork&quot;</span>:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  my $fh = $dir-&gt;tempfile;
  print $fh &quot;Here's some more data...\n&quot;;
  seek($fh, 0, 0);
  if ($pid=fork()) {
    wait;
  } else {
    something($_) while &lt;$fh&gt;;
  }
    </pre>
  </dd>
  <dt>$dir_or_file = $dir-&gt;<b>next()</b></dt>
  <dd>A convenient way to iterate through directory contents. The first time
      <span class="Li">&quot;next()&quot;</span> is called, it will
      <span class="Li">&quot;open()&quot;</span> the directory and read the
      first item from it, returning the result as a
      <span class="Li">&quot;Path::Class::Dir&quot;</span> or Path::Class::File
      object (depending, of course, on its actual type). Each subsequent call to
      <span class="Li">&quot;next()&quot;</span> will simply iterate over the
      directory's contents, until there are no more items in the directory, and
      then the undefined value is returned. For example, to iterate over all the
      regular files in a directory:
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  while (my $file = $dir-&gt;next) {
    next unless -f $file;
    my $fh = $file-&gt;open('r') or die &quot;Can't read $file: $!&quot;;
    ...
  }
    </pre>
    <p class="Pp">If an error occurs when opening the directory (for instance,
        it doesn't exist or isn't readable),
        <span class="Li">&quot;next()&quot;</span> will throw an exception with
        the value of <span class="Li">$!</span>.</p>
  </dd>
  <dt>$dir-&gt;traverse( sub { ... }, @args )</dt>
  <dd>Calls the given callback for the root, passing it a continuation function
      which, when called, will call this recursively on each of its children.
      The callback function should be of the form:
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  sub {
    my ($child, $cont, @args) = @_;
    # ...
  }
    </pre>
    <p class="Pp">For instance, to calculate the number of files in a directory,
        you can do this:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  my $nfiles = $dir-&gt;traverse(sub {
    my ($child, $cont) = @_;
    return sum($cont-&gt;(), ($child-&gt;is_dir ? 0 : 1));
  });
    </pre>
    <p class="Pp">or to calculate the maximum depth of a directory:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  my $depth = $dir-&gt;traverse(sub {
    my ($child, $cont, $depth) = @_;
    return max($cont-&gt;($depth + 1), $depth);
  }, 0);
    </pre>
    <p class="Pp">You can also choose not to call the callback in certain
        situations:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  $dir-&gt;traverse(sub {
    my ($child, $cont) = @_;
    return if -l $child; # don't follow symlinks
    # do something with $child
    return $cont-&gt;();
  });
    </pre>
  </dd>
  <dt>$dir-&gt;traverse_if( sub { ... }, sub { ... }, @args )</dt>
  <dd>traverse with additional &quot;should I visit this child&quot; callback.
      Particularly useful in case examined tree contains inaccessible
      directories.
    <p class="Pp">Canonical example:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  $dir-&gt;traverse_if(
    sub {
       my ($child, $cont) = @_;
       # do something with $child
       return $cont-&gt;();
    }, 
    sub {
       my ($child) = @_;
       # Process only readable items
       return -r $child;
    });
    </pre>
    <p class="Pp">Second callback gets single parameter: child. Only children
        for which it returns true will be processed by the first callback.</p>
    <p class="Pp">Remaining parameters are interpreted as in traverse, in
        particular <span class="Li">&quot;traverse_if(callback, sub { 1 },
        @args&quot;</span> is equivalent to
        <span class="Li">&quot;traverse(callback, @args)&quot;</span>.</p>
  </dd>
  <dt>$dir-&gt;recurse( callback =&gt; sub {...} )</dt>
  <dd>Iterates through this directory and all of its children, and all of its
      children's children, etc., calling the
      <span class="Li">&quot;callback&quot;</span> subroutine for each entry.
      This is a lot like what the File::Find module does, and of course
      <span class="Li">&quot;File::Find&quot;</span> will work fine on
      Path::Class objects, but the advantage of the
      <span class="Li">&quot;recurse()&quot;</span> method is that it will also
      feed your callback routine <span class="Li">&quot;Path::Class&quot;</span>
      objects rather than just pathname strings.
    <p class="Pp">The <span class="Li">&quot;recurse()&quot;</span> method
        requires a <span class="Li">&quot;callback&quot;</span> parameter
        specifying the subroutine to invoke for each entry. It will be passed
        the <span class="Li">&quot;Path::Class&quot;</span> object as its first
        argument.</p>
    <p class="Pp"><span class="Li">&quot;recurse()&quot;</span> also accepts two
        boolean parameters, <span class="Li">&quot;depthfirst&quot;</span> and
        <span class="Li">&quot;preorder&quot;</span> that control the order of
        recursion. The default is a preorder, breadth-first search, i.e.
        <span class="Li">&quot;depthfirst =&gt; 0, preorder =&gt;
        1&quot;</span>. At the time of this writing, all combinations of these
        two parameters are supported <i>except</i>
        <span class="Li">&quot;depthfirst =&gt; 0, preorder =&gt;
        0&quot;</span>.</p>
    <p class="Pp"><span class="Li">&quot;callback&quot;</span> is normally not
        required to return any value. If it returns special constant
        <span class="Li">&quot;Path::Class::Entity::PRUNE()&quot;</span> (more
        easily available as
        <span class="Li">&quot;$item-&gt;PRUNE&quot;</span>), no children of
        analyzed item will be analyzed (mostly as if you set
        <span class="Li">&quot;$File::Find::prune=1&quot;</span>). Of course
        pruning is available only in
        <span class="Li">&quot;preorder&quot;</span>, in postorder return value
        has no effect.</p>
  </dd>
  <dt>$st = $file-&gt;<b>stat()</b></dt>
  <dd>Invokes <span class="Li">&quot;File::stat::stat()&quot;</span> on this
      directory and returns a <span class="Li">&quot;File::stat&quot;</span>
      object representing the result.</dd>
  <dt>$st = $file-&gt;<b>lstat()</b></dt>
  <dd>Same as <span class="Li">&quot;stat()&quot;</span>, but if
      <span class="Li">$file</span> is a symbolic link,
      <span class="Li">&quot;lstat()&quot;</span> stats the link instead of the
      directory the link points to.</dd>
  <dt>$class = $file-&gt;<b>file_class()</b></dt>
  <dd>Returns the class which should be used to create file objects.
    <p class="Pp">Generally overridden whenever this class is subclassed.</p>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
Ken Williams, kwilliams@cpan.org
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
Path::Class, Path::Class::File, File::Spec
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2020-10-19</td>
    <td class="foot-os">perl v5.30.2</td>
  </tr>
</table>
</body>
</html>
