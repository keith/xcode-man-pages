<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Copyright (c) 1996-1997 Sun Microsystems, Inc.
  
   See the file "license.terms" for information on usage and redistribution
   of this file, and for a DISCLAIMER OF ALL WARRANTIES.
  
   RCS: @(#) $Id: OpenFileChnl.3,v 1.36 2007/12/13 15:22:31 dgp Exp $
   The -*- nroff -*- definitions below are for supplemental macros used
   in Tcl/Tk manual entries.
  
   .AP type name in/out ?indent?
  	Start paragraph describing an argument to a library procedure.
  	type is type of argument (int, etc.), in/out is either "in", "out",
  	or "in/out" to describe whether procedure reads or modifies arg,
  	and indent is equivalent to second arg of .IP (shouldn't ever be
  	needed;  use .AS below instead)
  
   .AS ?type? ?name?
  	Give maximum sizes of arguments for setting tab stops.  Type and
  	name are examples of largest possible arguments that will be passed
  	to .AP later.  If args are omitted, default tab stops are used.
  
   .BS
  	Start box enclosure.  From here until next .BE, everything will be
  	enclosed in one large box.
  
   .BE
  	End of box enclosure.
  
   .CS
  	Begin code excerpt.
  
   .CE
  	End code excerpt.
  
   .VS ?version? ?br?
  	Begin vertical sidebar, for use in marking newly-changed parts
  	of man pages.  The first argument is ignored and used for recording
  	the version when the .VS was added, so that the sidebars can be
  	found and removed when they reach a certain age.  If another argument
  	is present, then a line break is forced before starting the sidebar.
  
   .VE
  	End of vertical sidebar.
  
   .DS
  	Begin an indented unfilled display.
  
   .DE
  	End of indented unfilled display.
  
   .SO ?manpage?
  	Start of list of standard options for a Tk widget. The manpage
  	argument defines where to look up the standard options; if
  	omitted, defaults to "options". The options follow on successive
  	lines, in three columns separated by tabs.
  
   .SE
  	End of list of standard options for a Tk widget.
  
   .OP cmdName dbName dbClass
  	Start of description of a specific option.  cmdName gives the
  	option's name as specified in the class command, dbName gives
  	the option's name in the option database, and dbClass gives
  	the option's class in the option database.
  
   .UL arg1 arg2
  	Print arg1 underlined, then print arg2 normally.
  
   .QW arg1 ?arg2?
  	Print arg1 in quotes, then arg2 normally (for trailing punctuation).
  
   .PQ arg1 ?arg2?
  	Print an open parenthesis, arg1 in quotes, then arg2 normally
  	(for trailing punctuation) and then a closing parenthesis.
  
   RCS: @(#) $Id: man.macros,v 1.9 2008/01/29 15:32:33 dkf Exp $
  
  	# Set up traps and other miscellaneous stuff for Tcl/Tk man pages.
  	# Start an argument description
  .b
  	# define tabbing values for .AP
  
  	# BS - start boxed text
  	# ^y = starting y location
  	# ^b = 1
  	# BE - end boxed text (draw box now)
  	Draw four-sided box normally, but don't draw top of
  	box if the box started on an earlier page.
  	# VS - start vertical sidebar
  	# ^Y = starting y location
  	# ^v = 1 (for troff;  for nroff this doesn't matter)
  	# VE - end of vertical sidebar
  	# Special macro to handle page bottom:  finish off current
  	# box/sidebar if in box/sidebar mode, then invoked standard
  	# page bottom macro.
  	Draw three-sided box if this is the box's first page,
  	draw two sides but no top otherwise.
  	# DS - begin display
  	# DE - end display
  	# SO - start of list of standard options
  	# SE - end of list of standard options
  	# OP - start of full description for a single option
  	# CS - begin code excerpt
  	# CE - end code excerpt
  	# UL - underline word
  	# QW - apply quotation marks to word
  " fix emacs highlighting
  	# PQ - apply parens and quotation marks to word
  " fix emacs highlighting
  	# QR - quoted range
  " fix emacs highlighting
  	# MT - "empty" string
 -->
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>Tcl_OpenFileChannel(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Tcl_OpenFileChannel(3)</td>
    <td class="head-vol">Tcl Library Procedures</td>
    <td class="head-rtitle">Tcl_OpenFileChannel(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<pre>

</pre>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
Tcl_OpenFileChannel, Tcl_OpenCommandChannel, Tcl_MakeFileChannel,
  Tcl_GetChannel, Tcl_GetChannelNames, Tcl_GetChannelNamesEx,
  Tcl_RegisterChannel, Tcl_UnregisterChannel, Tcl_DetachChannel,
  Tcl_IsStandardChannel, Tcl_Close, Tcl_ReadChars, Tcl_Read, Tcl_GetsObj,
  Tcl_Gets, Tcl_WriteObj, Tcl_WriteChars, Tcl_Write, Tcl_Flush, Tcl_Seek,
  Tcl_Tell, Tcl_TruncateChannel, Tcl_GetChannelOption, Tcl_SetChannelOption,
  Tcl_Eof, Tcl_InputBlocked, Tcl_InputBuffered, Tcl_OutputBuffered, Tcl_Ungets,
  Tcl_ReadRaw, Tcl_WriteRaw - buffered I/O facilities using channels
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>
<b>#include &lt;tcl.h&gt;</b>

Tcl_Channel
<b>Tcl_OpenFileChannel</b>(<i>interp, fileName, mode, permissions</i>)

Tcl_Channel
<b>Tcl_OpenCommandChannel</b>(<i>interp, argc, argv, flags</i>)

Tcl_Channel
<b>Tcl_MakeFileChannel</b>(<i>handle, readOrWrite</i>)

Tcl_Channel
<b>Tcl_GetChannel</b>(<i>interp, channelName, modePtr</i>)

int
<b>Tcl_GetChannelNames</b>(<i>interp</i>)

int
<b>Tcl_GetChannelNamesEx</b>(<i>interp, pattern</i>)

void
<b>Tcl_RegisterChannel</b>(<i>interp, channel</i>)

int
<b>Tcl_UnregisterChannel</b>(<i>interp, channel</i>)

int
<b>Tcl_DetachChannel</b>(<i>interp, channel</i>)

int
<b>Tcl_IsStandardChannel</b>(<i>channel</i>)

int
<b>Tcl_Close</b>(<i>interp, channel</i>)

int
<b>Tcl_ReadChars</b>(<i>channel, readObjPtr, charsToRead, appendFlag</i>)

int
<b>Tcl_Read</b>(<i>channel, readBuf, bytesToRead</i>)

int
<b>Tcl_GetsObj</b>(<i>channel, lineObjPtr</i>)

int
<b>Tcl_Gets</b>(<i>channel, lineRead</i>)

int
<b>Tcl_Ungets</b>(<i>channel, input, inputLen, addAtEnd</i>)

int
<b>Tcl_WriteObj</b>(<i>channel, writeObjPtr</i>)

int
<b>Tcl_WriteChars</b>(<i>channel, charBuf, bytesToWrite</i>)

int
<b>Tcl_Write</b>(<i>channel, byteBuf, bytesToWrite</i>)

int
<b>Tcl_ReadRaw</b>(<i>channel, readBuf, bytesToRead</i>)

int
<b>Tcl_WriteRaw</b>(<i>channel, byteBuf, bytesToWrite</i>)

int
<b>Tcl_Eof</b>(<i>channel</i>)

int
<b>Tcl_Flush</b>(<i>channel</i>)

int
<b>Tcl_InputBlocked</b>(<i>channel</i>)

int
<b>Tcl_InputBuffered</b>(<i>channel</i>)

int
<b>Tcl_OutputBuffered</b>(<i>channel</i>)

Tcl_WideInt
<b>Tcl_Seek</b>(<i>channel, offset, seekMode</i>)

Tcl_WideInt
<b>Tcl_Tell</b>(<i>channel</i>)

int
<b>Tcl_TruncateChannel</b>(<i>channel, length</i>)

int
<b>Tcl_GetChannelOption</b>(<i>interp, channel, optionName, optionValue</i>)

int
<b>Tcl_SetChannelOption</b>(<i>interp, channel, optionName, newValue</i>)

</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="ARGUMENTS"><a class="permalink" href="#ARGUMENTS">ARGUMENTS</a></h1>
<dl class="Bl-tag">
  <dt>Tcl_Interp <i>*interp</i> (in)</dt>
  <dd>Used for error reporting and to look up a channel registered in it.</dd>
  <dt>const char <i>*fileName</i> (in)</dt>
  <dd>The name of a local or network file.</dd>
  <dt>const char <i>*mode</i> (in)</dt>
  <dd>Specifies how the file is to be accessed. May have any of the values
      allowed for the <i>mode</i> argument to the Tcl <b>open</b> command.</dd>
  <dt>int <i>permissions</i> (in)</dt>
  <dd>POSIX-style permission flags such as 0644. If a new file is created, these
      permissions will be set on the created file.</dd>
  <dt>int <i>argc</i> (in)</dt>
  <dd>The number of elements in <i>argv</i>.</dd>
  <dt>const char <i>**argv</i> (in)</dt>
  <dd>Arguments for constructing a command pipeline. These values have the same
      meaning as the non-switch arguments to the Tcl <b>exec</b> command.</dd>
  <dt>int <i>flags</i> (in)</dt>
  <dd>Specifies the disposition of the stdio handles in pipeline: OR-ed
      combination of <b>TCL_STDIN</b>, <b>TCL_STDOUT</b>, <b>TCL_STDERR</b>, and
      <b>TCL_ENFORCE_MODE</b>. If <b>TCL_STDIN</b> is set, stdin for the first
      child in the pipe is the pipe channel, otherwise it is the same as the
      standard input of the invoking process; likewise for <b>TCL_STDOUT</b> and
      <b>TCL_STDERR</b>. If <b>TCL_ENFORCE_MODE</b> is not set, then the pipe
      can redirect stdio handles to override the stdio handles for which
      <b>TCL_STDIN</b>, <b>TCL_STDOUT</b> and <b>TCL_STDERR</b> have been set.
      If it is set, then such redirections cause an error.</dd>
  <dt>ClientData <i>handle</i> (in)</dt>
  <dd>Operating system specific handle for I/O to a file. For Unix this is a
      file descriptor, for Windows it is a HANDLE.</dd>
  <dt>int <i>readOrWrite</i> (in)</dt>
  <dd>OR-ed combination of <b>TCL_READABLE</b> and <b>TCL_WRITABLE</b> to
      indicate what operations are valid on <i>handle</i>.</dd>
  <dt>const char <i>*channelName</i> (in)</dt>
  <dd>The name of the channel.</dd>
  <dt>int <i>*modePtr</i> (out)</dt>
  <dd>Points at an integer variable that will receive an OR-ed combination of
      <b>TCL_READABLE</b> and <b>TCL_WRITABLE</b> denoting whether the channel
      is open for reading and writing.</dd>
  <dt>const char <i>*pattern</i> (in)</dt>
  <dd>The pattern to match on, passed to Tcl_StringMatch, or NULL.</dd>
  <dt>Tcl_Channel <i>channel</i> (in)</dt>
  <dd>A Tcl channel for input or output. Must have been the return value from a
      procedure such as <b>Tcl_OpenFileChannel</b>.</dd>
  <dt>Tcl_Obj <i>*readObjPtr</i> (in/out)</dt>
  <dd>A pointer to a Tcl Object in which to store the characters read from the
      channel.</dd>
  <dt>int <i>charsToRead</i> (in)</dt>
  <dd>The number of characters to read from the channel. If the channel's
      encoding is <b>binary</b>, this is equivalent to the number of bytes to
      read from the channel.</dd>
  <dt>int <i>appendFlag</i> (in)</dt>
  <dd>If non-zero, data read from the channel will be appended to the object.
      Otherwise, the data will replace the existing contents of the object.</dd>
  <dt>char <i>*readBuf</i> (out)</dt>
  <dd>A buffer in which to store the bytes read from the channel.</dd>
  <dt>int <i>bytesToRead</i> (in)</dt>
  <dd>The number of bytes to read from the channel. The buffer <i>readBuf</i>
      must be large enough to hold this many bytes.</dd>
  <dt>Tcl_Obj <i>*lineObjPtr</i> (in/out)</dt>
  <dd>A pointer to a Tcl object in which to store the line read from the
      channel. The line read will be appended to the current value of the
      object.</dd>
  <dt>Tcl_DString <i>*lineRead</i> (in/out)</dt>
  <dd>A pointer to a Tcl dynamic string in which to store the line read from the
      channel. Must have been initialized by the caller. The line read will be
      appended to any data already in the dynamic string.</dd>
  <dt>const char <i>*input</i> (in)</dt>
  <dd>The input to add to a channel buffer.</dd>
  <dt>int <i>inputLen</i> (in)</dt>
  <dd>Length of the input</dd>
  <dt>int <i>addAtEnd</i> (in)</dt>
  <dd>Flag indicating whether the input should be added to the end or beginning
      of the channel buffer.</dd>
  <dt>Tcl_Obj <i>*writeObjPtr</i> (in)</dt>
  <dd>A pointer to a Tcl Object whose contents will be output to the
    channel.</dd>
  <dt>const char <i>*charBuf</i> (in)</dt>
  <dd>A buffer containing the characters to output to the channel.</dd>
  <dt>const char <i>*byteBuf</i> (in)</dt>
  <dd>A buffer containing the bytes to output to the channel.</dd>
  <dt>int <i>bytesToWrite</i> (in)</dt>
  <dd>The number of bytes to consume from <i>charBuf</i> or <i>byteBuf</i> and
      output to the channel.</dd>
  <dt>Tcl_WideInt <i>offset</i> (in)</dt>
  <dd>How far to move the access point in the channel at which the next input or
      output operation will be applied, measured in bytes from the position
      given by <i>seekMode</i>. May be either positive or negative.</dd>
  <dt>int <i>seekMode</i> (in)</dt>
  <dd>Relative to which point to seek; used with <i>offset</i> to calculate the
      new access point for the channel. Legal values are <b>SEEK_SET</b>,
      <b>SEEK_CUR</b>, and <b>SEEK_END</b>.</dd>
  <dt>Tcl_WideInt <i>length</i> (in)</dt>
  <dd>The (non-negative) length to truncate the channel the channel to.</dd>
  <dt>const char <i>*optionName</i> (in)</dt>
  <dd>The name of an option applicable to this channel, such as
      <b>-blocking</b>. May have any of the values accepted by the
      <b>fconfigure</b> command.</dd>
  <dt>Tcl_DString <i>*optionValue</i> (in)</dt>
  <dd>Where to store the value of an option or a list of all options and their
      values. Must have been initialized by the caller.</dd>
  <dt>const char <i>*newValue</i> (in)</dt>
  <dd>New value for the option given by <i>optionName</i>.
    <pre>

    </pre>
    <p class="Pp"></p>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
The Tcl channel mechanism provides a device-independent and platform-independent
  mechanism for performing buffered input and output operations on a variety of
  file, socket, and device types. The channel mechanism is extensible to new
  channel types, by providing a low-level channel driver for the new type; the
  channel driver interface is described in the manual entry for
  <b>Tcl_CreateChannel</b>. The channel mechanism provides a buffering scheme
  modeled after Unix's standard I/O, and it also allows for nonblocking I/O on
  channels.
<p class="Pp">The procedures described in this manual entry comprise the C APIs
    of the generic layer of the channel architecture. For a description of the
    channel driver architecture and how to implement channel drivers for new
    types of channels, see the manual entry for <b>Tcl_CreateChannel</b>.</p>
<p class="Pp"></p>
</section>
<section class="Sh">
<h1 class="Sh" id="TCL_OPENFILECHANNEL"><a class="permalink" href="#TCL_OPENFILECHANNEL">TCL_OPENFILECHANNEL</a></h1>
<b>Tcl_OpenFileChannel</b> opens a file specified by <i>fileName</i> and returns
  a channel handle that can be used to perform input and output on the file.
  This API is modeled after the <b>fopen</b> procedure of the Unix standard I/O
  library. The syntax and meaning of all arguments is similar to those given in
  the Tcl <b>open</b> command when opening a file. If an error occurs while
  opening the channel, <b>Tcl_OpenFileChannel</b> returns NULL and records a
  POSIX error code that can be retrieved with <b>Tcl_GetErrno</b>. In addition,
  if <i>interp</i> is non-NULL, <b>Tcl_OpenFileChannel</b> leaves an error
  message in <i>interp</i>'s result after any error. As of Tcl 8.4, the
  object-based API <b>Tcl_FSOpenFileChannel</b> should be used in preference to
  <b>Tcl_OpenFileChannel</b> wherever possible.
<p class="Pp">The newly created channel is not registered in the supplied
    interpreter; to register it, use <b>Tcl_RegisterChannel</b>, described
    below. If one of the standard channels, <b>stdin, stdout</b> or
    <b>stderr</b> was previously closed, the act of creating the new channel
    also assigns it as a replacement for the standard channel.</p>
<p class="Pp"></p>
</section>
<section class="Sh">
<h1 class="Sh" id="TCL_OPENCOMMANDCHANNEL"><a class="permalink" href="#TCL_OPENCOMMANDCHANNEL">TCL_OPENCOMMANDCHANNEL</a></h1>
<b>Tcl_OpenCommandChannel</b> provides a C-level interface to the functions of
  the <b>exec</b> and <b>open</b> commands. It creates a sequence of
  subprocesses specified by the <i>argv</i> and <i>argc</i> arguments and
  returns a channel that can be used to communicate with these subprocesses. The
  <i>flags</i> argument indicates what sort of communication will exist with the
  command pipeline.
<p class="Pp">If the <b>TCL_STDIN</b> flag is set then the standard input for
    the first subprocess will be tied to the channel: writing to the channel
    will provide input to the subprocess. If <b>TCL_STDIN</b> is not set, then
    standard input for the first subprocess will be the same as this
    application's standard input. If <b>TCL_STDOUT</b> is set then standard
    output from the last subprocess can be read from the channel; otherwise it
    goes to this application's standard output. If <b>TCL_STDERR</b> is set,
    standard error output for all subprocesses is returned to the channel and
    results in an error when the channel is closed; otherwise it goes to this
    application's standard error. If <b>TCL_ENFORCE_MODE</b> is not set, then
    <i>argc</i> and <i>argv</i> can redirect the stdio handles to override
    <b>TCL_STDIN</b>, <b>TCL_STDOUT</b>, and <b>TCL_STDERR</b>; if it is set,
    then it is an error for argc and argv to override stdio channels for which
    <b>TCL_STDIN</b>, <b>TCL_STDOUT</b>, and <b>TCL_STDERR</b> have been
  set.</p>
<p class="Pp">If an error occurs while opening the channel,
    <b>Tcl_OpenCommandChannel</b> returns NULL and records a POSIX error code
    that can be retrieved with <b>Tcl_GetErrno</b>. In addition,
    <b>Tcl_OpenCommandChannel</b> leaves an error message in the interpreter's
    result if <i>interp</i> is not NULL.</p>
<p class="Pp">The newly created channel is not registered in the supplied
    interpreter; to register it, use <b>Tcl_RegisterChannel</b>, described
    below. If one of the standard channels, <b>stdin, stdout</b> or
    <b>stderr</b> was previously closed, the act of creating the new channel
    also assigns it as a replacement for the standard channel.</p>
<p class="Pp"></p>
</section>
<section class="Sh">
<h1 class="Sh" id="TCL_MAKEFILECHANNEL"><a class="permalink" href="#TCL_MAKEFILECHANNEL">TCL_MAKEFILECHANNEL</a></h1>
<b>Tcl_MakeFileChannel</b> makes a <b>Tcl_Channel</b> from an existing,
  platform-specific, file handle. The newly created channel is not registered in
  the supplied interpreter; to register it, use <b>Tcl_RegisterChannel</b>,
  described below. If one of the standard channels, <b>stdin, stdout</b> or
  <b>stderr</b> was previously closed, the act of creating the new channel also
  assigns it as a replacement for the standard channel.
<p class="Pp"></p>
</section>
<section class="Sh">
<h1 class="Sh" id="TCL_GETCHANNEL"><a class="permalink" href="#TCL_GETCHANNEL">TCL_GETCHANNEL</a></h1>
<b>Tcl_GetChannel</b> returns a channel given the <i>channelName</i> used to
  create it with <b>Tcl_CreateChannel</b> and a pointer to a Tcl interpreter in
  <i>interp</i>. If a channel by that name is not registered in that
  interpreter, the procedure returns NULL. If the <i>modePtr</i> argument is not
  NULL, it points at an integer variable that will receive an OR-ed combination
  of <b>TCL_READABLE</b> and <b>TCL_WRITABLE</b> describing whether the channel
  is open for reading and writing.
<p class="Pp"><b>Tcl_GetChannelNames</b> and <b>Tcl_GetChannelNamesEx</b> write
    the names of the registered channels to the interpreter's result as a list
    object. <b>Tcl_GetChannelNamesEx</b> will filter these names according to
    the <i>pattern</i>. If <i>pattern</i> is NULL, then it will not do any
    filtering. The return value is <b>TCL_OK</b> if no errors occurred writing
    to the result, otherwise it is <b>TCL_ERROR</b>, and the error message is
    left in the interpreter's result.</p>
<p class="Pp"></p>
</section>
<section class="Sh">
<h1 class="Sh" id="TCL_REGISTERCHANNEL"><a class="permalink" href="#TCL_REGISTERCHANNEL">TCL_REGISTERCHANNEL</a></h1>
<b>Tcl_RegisterChannel</b> adds a channel to the set of channels accessible in
  <i>interp</i>. After this call, Tcl programs executing in that interpreter can
  refer to the channel in input or output operations using the name given in the
  call to <b>Tcl_CreateChannel</b>. After this call, the channel becomes the
  property of the interpreter, and the caller should not call <b>Tcl_Close</b>
  for the channel; the channel will be closed automatically when it is
  unregistered from the interpreter.
<p class="Pp">Code executing outside of any Tcl interpreter can call
    <b>Tcl_RegisterChannel</b> with <i>interp</i> as NULL, to indicate that it
    wishes to hold a reference to this channel. Subsequently, the channel can be
    registered in a Tcl interpreter and it will only be closed when the matching
    number of calls to <b>Tcl_UnregisterChannel</b> have been made. This allows
    code executing outside of any interpreter to safely hold a reference to a
    channel that is also registered in a Tcl interpreter.</p>
<p class="Pp">This procedure interacts with the code managing the standard
    channels. If no standard channels were initialized before the first call to
    <b>Tcl_RegisterChannel</b>, they will get initialized by that call. See
    <b>Tcl_StandardChannels</b> for a general treatise about standard channels
    and the behaviour of the Tcl library with regard to them.</p>
<p class="Pp"></p>
</section>
<section class="Sh">
<h1 class="Sh" id="TCL_UNREGISTERCHANNEL"><a class="permalink" href="#TCL_UNREGISTERCHANNEL">TCL_UNREGISTERCHANNEL</a></h1>
<b>Tcl_UnregisterChannel</b> removes a channel from the set of channels
  accessible in <i>interp</i>. After this call, Tcl programs will no longer be
  able to use the channel's name to refer to the channel in that interpreter. If
  this operation removed the last registration of the channel in any
  interpreter, the channel is also closed and destroyed.
<p class="Pp">Code not associated with a Tcl interpreter can call
    <b>Tcl_UnregisterChannel</b> with <i>interp</i> as NULL, to indicate to Tcl
    that it no longer holds a reference to that channel. If this is the last
    reference to the channel, it will now be closed.
    <b>Tcl_UnregisterChannel</b> is very similar to <b>Tcl_DetachChannel</b>
    except that it will also close the channel if no further references to it
    exist.</p>
<p class="Pp"></p>
</section>
<section class="Sh">
<h1 class="Sh" id="TCL_DETACHCHANNEL"><a class="permalink" href="#TCL_DETACHCHANNEL">TCL_DETACHCHANNEL</a></h1>
<b>Tcl_DetachChannel</b> removes a channel from the set of channels accessible
  in <i>interp</i>. After this call, Tcl programs will no longer be able to use
  the channel's name to refer to the channel in that interpreter. Beyond that,
  this command has no further effect. It cannot be used on the standard channels
  (stdout, stderr, stdin), and will return <b>TCL_ERROR</b> if passed one of
  those channels.
<p class="Pp">Code not associated with a Tcl interpreter can call
    <b>Tcl_DetachChannel</b> with <i>interp</i> as NULL, to indicate to Tcl that
    it no longer holds a reference to that channel. If this is the last
    reference to the channel, unlike <b>Tcl_UnregisterChannel</b>, it will not
    be closed.</p>
<p class="Pp"></p>
</section>
<section class="Sh">
<h1 class="Sh" id="TCL_ISSTANDARDCHANNEL"><a class="permalink" href="#TCL_ISSTANDARDCHANNEL">TCL_ISSTANDARDCHANNEL</a></h1>
<b>Tcl_IsStandardChannel</b> tests whether a channel is one of the three
  standard channels, stdin, stdout or stderr. If so, it returns 1, otherwise 0.
<p class="Pp">No attempt is made to check whether the given channel or the
    standard channels are initialized or otherwise valid.</p>
<p class="Pp"></p>
</section>
<section class="Sh">
<h1 class="Sh" id="TCL_CLOSE"><a class="permalink" href="#TCL_CLOSE">TCL_CLOSE</a></h1>
<b>Tcl_Close</b> destroys the channel <i>channel</i>, which must denote a
  currently open channel. The channel should not be registered in any
  interpreter when <b>Tcl_Close</b> is called. Buffered output is flushed to the
  channel's output device prior to destroying the channel, and any buffered
  input is discarded. If this is a blocking channel, the call does not return
  until all buffered data is successfully sent to the channel's output device.
  If this is a nonblocking channel and there is buffered output that cannot be
  written without blocking, the call returns immediately; output is flushed in
  the background and the channel will be closed once all of the buffered data
  has been output. In this case errors during flushing are not reported.
<p class="Pp">If the channel was closed successfully, <b>Tcl_Close</b> returns
    <b>TCL_OK</b>. If an error occurs, <b>Tcl_Close</b> returns <b>TCL_ERROR</b>
    and records a POSIX error code that can be retrieved with
    <b>Tcl_GetErrno</b>. If the channel is being closed synchronously and an
    error occurs during closing of the channel and <i>interp</i> is not NULL, an
    error message is left in the interpreter's result.</p>
<p class="Pp">Note: it is not safe to call <b>Tcl_Close</b> on a channel that
    has been registered using <b>Tcl_RegisterChannel</b>; see the documentation
    for <b>Tcl_RegisterChannel</b>, above, for details. If the channel has ever
    been given as the <b>chan</b> argument in a call to
    <b>Tcl_RegisterChannel</b>, you should instead use
    <b>Tcl_UnregisterChannel</b>, which will internally call <b>Tcl_Close</b>
    when all calls to <b>Tcl_RegisterChannel</b> have been matched by
    corresponding calls to <b>Tcl_UnregisterChannel</b>.</p>
<p class="Pp"></p>
</section>
<section class="Sh">
<h1 class="Sh" id="TCL_READCHARS_AND_TCL_READ"><a class="permalink" href="#TCL_READCHARS_AND_TCL_READ">TCL_READCHARS
  AND TCL_READ</a></h1>
<b>Tcl_ReadChars</b> consumes bytes from <i>channel</i>, converting the bytes to
  UTF-8 based on the channel's encoding and storing the produced data in
  <i>readObjPtr</i>'s string representation. The return value of
  <b>Tcl_ReadChars</b> is the number of characters, up to <i>charsToRead</i>,
  that were stored in <i>readObjPtr</i>. If an error occurs while reading, the
  return value is -1 and <b>Tcl_ReadChars</b> records a POSIX error code that
  can be retrieved with <b>Tcl_GetErrno</b>.
<p class="Pp">Setting <i>charsToRead</i> to <b>-1</b> will cause the command to
    read all characters currently available (non-blocking) or everything until
    eof (blocking mode).</p>
<p class="Pp">The return value may be smaller than the value to read, indicating
    that less data than requested was available. This is called a <i>short
    read</i>. In blocking mode, this can only happen on an end-of-file. In
    nonblocking mode, a short read can also occur if there is not enough input
    currently available: <b>Tcl_ReadChars</b> returns a short count rather than
    waiting for more data.</p>
<p class="Pp">If the channel is in blocking mode, a return value of zero
    indicates an end-of-file condition. If the channel is in nonblocking mode, a
    return value of zero indicates either that no input is currently available
    or an end-of-file condition. Use <b>Tcl_Eof</b> and <b>Tcl_InputBlocked</b>
    to tell which of these conditions actually occurred.</p>
<p class="Pp"><b>Tcl_ReadChars</b> translates the various end-of-line
    representations into the canonical <b>\n</b> internal representation
    according to the current end-of-line recognition mode. End-of-line
    recognition and the various platform-specific modes are described in the
    manual entry for the Tcl <b>fconfigure</b> command.</p>
<p class="Pp">As a performance optimization, when reading from a channel with
    the encoding <b>binary</b>, the bytes are not converted to UTF-8 as they are
    read. Instead, they are stored in <i>readObjPtr</i>'s internal
    representation as a byte-array object. The string representation of this
    object will only be constructed if it is needed (e.g., because of a call to
    <b>Tcl_GetStringFromObj</b>). In this way, byte-oriented data can be read
    from a channel, manipulated by calling <b>Tcl_GetByteArrayFromObj</b> and
    related functions, and then written to a channel without the expense of ever
    converting to or from UTF-8.</p>
<p class="Pp"><b>Tcl_Read</b> is similar to <b>Tcl_ReadChars</b>, except that it
    does not do encoding conversions, regardless of the channel's encoding. It
    is deprecated and exists for backwards compatibility with
    non-internationalized Tcl extensions. It consumes bytes from <i>channel</i>
    and stores them in <i>readBuf</i>, performing end-of-line translations on
    the way. The return value of <b>Tcl_Read</b> is the number of bytes, up to
    <i>bytesToRead</i>, written in <i>readBuf</i>. The buffer produced by
    <b>Tcl_Read</b> is not null-terminated. Its contents are valid from the
    zeroth position up to and excluding the position indicated by the return
    value.</p>
<p class="Pp"><b>Tcl_ReadRaw</b> is the same as <b>Tcl_Read</b> but does not
    compensate for stacking. While <b>Tcl_Read</b> (and the other functions in
    the API) always get their data from the topmost channel in the stack the
    supplied channel is part of, <b>Tcl_ReadRaw</b> does not. Thus this function
    is <b>only</b> usable for transformational channel drivers, i.e. drivers
    used in the middle of a stack of channels, to move data from the channel
    below into the transformation.</p>
<p class="Pp"></p>
</section>
<section class="Sh">
<h1 class="Sh" id="TCL_GETSOBJ_AND_TCL_GETS"><a class="permalink" href="#TCL_GETSOBJ_AND_TCL_GETS">TCL_GETSOBJ
  AND TCL_GETS</a></h1>
<b>Tcl_GetsObj</b> consumes bytes from <i>channel</i>, converting the bytes to
  UTF-8 based on the channel's encoding, until a full line of input has been
  seen. If the channel's encoding is <b>binary</b>, each byte read from the
  channel is treated as an individual Unicode character. All of the characters
  of the line except for the terminating end-of-line character(s) are appended
  to <i>lineObjPtr</i>'s string representation. The end-of-line character(s) are
  read and discarded.
<p class="Pp">If a line was successfully read, the return value is greater than
    or equal to zero and indicates the number of bytes stored in
    <i>lineObjPtr</i>. If an error occurs, <b>Tcl_GetsObj</b> returns -1 and
    records a POSIX error code that can be retrieved with <b>Tcl_GetErrno</b>.
    <b>Tcl_GetsObj</b> also returns -1 if the end of the file is reached; the
    <b>Tcl_Eof</b> procedure can be used to distinguish an error from an
    end-of-file condition.</p>
<p class="Pp">If the channel is in nonblocking mode, the return value can also
    be -1 if no data was available or the data that was available did not
    contain an end-of-line character. When -1 is returned, the
    <b>Tcl_InputBlocked</b> procedure may be invoked to determine if the channel
    is blocked because of input unavailability.</p>
<p class="Pp"><b>Tcl_Gets</b> is the same as <b>Tcl_GetsObj</b> except the
    resulting characters are appended to the dynamic string given by
    <i>lineRead</i> rather than a Tcl object.</p>
<p class="Pp"></p>
</section>
<section class="Sh">
<h1 class="Sh" id="TCL_UNGETS"><a class="permalink" href="#TCL_UNGETS">TCL_UNGETS</a></h1>
<b>Tcl_Ungets</b> is used to add data to the input queue of a channel, at either
  the head or tail of the queue. The pointer <i>input</i> points to the data
  that is to be added. The length of the input to add is given by
  <i>inputLen</i>. A non-zero value of <i>addAtEnd</i> indicates that the data
  is to be added at the end of queue; otherwise it will be added at the head of
  the queue. If <i>channel</i> has a &#x201C;sticky&#x201D; EOF set, no data
  will be added to the input queue. <b>Tcl_Ungets</b> returns <i>inputLen</i> or
  -1 if an error occurs.
<p class="Pp"></p>
</section>
<section class="Sh">
<h1 class="Sh" id="TCL_WRITECHARS,_TCL_WRITEOBJ,_AND_TCL_WRITE"><a class="permalink" href="#TCL_WRITECHARS,_TCL_WRITEOBJ,_AND_TCL_WRITE">TCL_WRITECHARS,
  TCL_WRITEOBJ, AND TCL_WRITE</a></h1>
<b>Tcl_WriteChars</b> accepts <i>bytesToWrite</i> bytes of character data at
  <i>charBuf</i>. The UTF-8 characters in the buffer are converted to the
  channel's encoding and queued for output to <i>channel</i>. If
  <i>bytesToWrite</i> is negative, <b>Tcl_WriteChars</b> expects <i>charBuf</i>
  to be null-terminated and it outputs everything up to the null.
<p class="Pp">Data queued for output may not appear on the output device
    immediately, due to internal buffering. If the data should appear
    immediately, call <b>Tcl_Flush</b> after the call to <b>Tcl_WriteChars</b>,
    or set the <b>-buffering</b> option on the channel to <b>none</b>. If you
    wish the data to appear as soon as a complete line is accepted for output,
    set the <b>-buffering</b> option on the channel to <b>line</b> mode.</p>
<p class="Pp">The return value of <b>Tcl_WriteChars</b> is a count of how many
    bytes were accepted for output to the channel. This is either greater than
    zero to indicate success or -1 to indicate that an error occurred. If an
    error occurs, <b>Tcl_WriteChars</b> records a POSIX error code that may be
    retrieved with <b>Tcl_GetErrno</b>.</p>
<p class="Pp">Newline characters in the output data are translated to
    platform-specific end-of-line sequences according to the <b>-translation</b>
    option for the channel. This is done even if the channel has no
  encoding.</p>
<p class="Pp"><b>Tcl_WriteObj</b> is similar to <b>Tcl_WriteChars</b> except it
    accepts a Tcl object whose contents will be output to the channel. The UTF-8
    characters in <i>writeObjPtr</i>'s string representation are converted to
    the channel's encoding and queued for output to <i>channel</i>. As a
    performance optimization, when writing to a channel with the encoding
    <b>binary</b>, UTF-8 characters are not converted as they are written.
    Instead, the bytes in <i>writeObjPtr</i>'s internal representation as a
    byte-array object are written to the channel. The byte-array representation
    of the object will be constructed if it is needed. In this way,
    byte-oriented data can be read from a channel, manipulated by calling
    <b>Tcl_GetByteArrayFromObj</b> and related functions, and then written to a
    channel without the expense of ever converting to or from UTF-8.</p>
<p class="Pp"><b>Tcl_Write</b> is similar to <b>Tcl_WriteChars</b> except that
    it does not do encoding conversions, regardless of the channel's encoding.
    It is deprecated and exists for backwards compatibility with
    non-internationalized Tcl extensions. It accepts <i>bytesToWrite</i> bytes
    of data at <i>byteBuf</i> and queues them for output to <i>channel</i>. If
    <i>bytesToWrite</i> is negative, <b>Tcl_Write</b> expects <i>byteBuf</i> to
    be null-terminated and it outputs everything up to the null.</p>
<p class="Pp"><b>Tcl_WriteRaw</b> is the same as <b>Tcl_Write</b> but does not
    compensate for stacking. While <b>Tcl_Write</b> (and the other functions in
    the API) always feed their input to the topmost channel in the stack the
    supplied channel is part of, <b>Tcl_WriteRaw</b> does not. Thus this
    function is <b>only</b> usable for transformational channel drivers, i.e.
    drivers used in the middle of a stack of channels, to move data from the
    transformation into the channel below it.</p>
<p class="Pp"></p>
</section>
<section class="Sh">
<h1 class="Sh" id="TCL_FLUSH"><a class="permalink" href="#TCL_FLUSH">TCL_FLUSH</a></h1>
<b>Tcl_Flush</b> causes all of the buffered output data for <i>channel</i> to be
  written to its underlying file or device as soon as possible. If the channel
  is in blocking mode, the call does not return until all the buffered data has
  been sent to the channel or some error occurred. The call returns immediately
  if the channel is nonblocking; it starts a background flush that will write
  the buffered data to the channel eventually, as fast as the channel is able to
  absorb it.
<p class="Pp">The return value is normally <b>TCL_OK</b>. If an error occurs,
    <b>Tcl_Flush</b> returns <b>TCL_ERROR</b> and records a POSIX error code
    that can be retrieved with <b>Tcl_GetErrno</b>.</p>
<p class="Pp"></p>
</section>
<section class="Sh">
<h1 class="Sh" id="TCL_SEEK"><a class="permalink" href="#TCL_SEEK">TCL_SEEK</a></h1>
<b>Tcl_Seek</b> moves the access point in <i>channel</i> where subsequent data
  will be read or written. Buffered output is flushed to the channel and
  buffered input is discarded, prior to the seek operation.
<p class="Pp"><b>Tcl_Seek</b> normally returns the new access point. If an error
    occurs, <b>Tcl_Seek</b> returns -1 and records a POSIX error code that can
    be retrieved with <b>Tcl_GetErrno</b>. After an error, the access point may
    or may not have been moved.</p>
<p class="Pp"></p>
</section>
<section class="Sh">
<h1 class="Sh" id="TCL_TELL"><a class="permalink" href="#TCL_TELL">TCL_TELL</a></h1>
<b>Tcl_Tell</b> returns the current access point for a channel. The returned
  value is -1 if the channel does not support seeking.
<p class="Pp"></p>
</section>
<section class="Sh">
<h1 class="Sh" id="TCL_TRUNCATECHANNEL"><a class="permalink" href="#TCL_TRUNCATECHANNEL">TCL_TRUNCATECHANNEL</a></h1>
<b>Tcl_TruncateChannel</b> truncates the file underlying <i>channel</i> to a
  given <i>length</i> of bytes. It returns <b>TCL_OK</b> if the operation
  succeeded, and <b>TCL_ERROR</b> otherwise.
<p class="Pp"></p>
</section>
<section class="Sh">
<h1 class="Sh" id="TCL_GETCHANNELOPTION"><a class="permalink" href="#TCL_GETCHANNELOPTION">TCL_GETCHANNELOPTION</a></h1>
<b>Tcl_GetChannelOption</b> retrieves, in <i>optionValue</i>, the value of one
  of the options currently in effect for a channel, or a list of all options and
  their values. The <i>channel</i> argument identifies the channel for which to
  query an option or retrieve all options and their values. If <i>optionName</i>
  is not NULL, it is the name of the option to query; the option's value is
  copied to the Tcl dynamic string denoted by <i>optionValue</i>. If
  <i>optionName</i> is NULL, the function stores an alternating list of option
  names and their values in <i>optionValue</i>, using a series of calls to
  <b>Tcl_DStringAppendElement</b>. The various preexisting options and their
  possible values are described in the manual entry for the Tcl
  <b>fconfigure</b> command. Other options can be added by each channel type.
  These channel type specific options are described in the manual entry for the
  Tcl command that creates a channel of that type; for example, the additional
  options for TCP based channels are described in the manual entry for the Tcl
  <b>socket</b> command. The procedure normally returns <b>TCL_OK</b>. If an
  error occurs, it returns <b>TCL_ERROR</b> and calls <b>Tcl_SetErrno</b> to
  store an appropriate POSIX error code.
<p class="Pp"></p>
</section>
<section class="Sh">
<h1 class="Sh" id="TCL_SETCHANNELOPTION"><a class="permalink" href="#TCL_SETCHANNELOPTION">TCL_SETCHANNELOPTION</a></h1>
<b>Tcl_SetChannelOption</b> sets a new value <i>newValue</i> for an option
  <i>optionName</i> on <i>channel</i>. The procedure normally returns
  <b>TCL_OK</b>. If an error occurs, it returns <b>TCL_ERROR</b>; in addition,
  if <i>interp</i> is non-NULL, <b>Tcl_SetChannelOption</b> leaves an error
  message in the interpreter's result.
<p class="Pp"></p>
</section>
<section class="Sh">
<h1 class="Sh" id="TCL_EOF"><a class="permalink" href="#TCL_EOF">TCL_EOF</a></h1>
<b>Tcl_Eof</b> returns a nonzero value if <i>channel</i> encountered an end of
  file during the last input operation.
<p class="Pp"></p>
</section>
<section class="Sh">
<h1 class="Sh" id="TCL_INPUTBLOCKED"><a class="permalink" href="#TCL_INPUTBLOCKED">TCL_INPUTBLOCKED</a></h1>
<b>Tcl_InputBlocked</b> returns a nonzero value if <i>channel</i> is in
  nonblocking mode and the last input operation returned less data than
  requested because there was insufficient data available. The call always
  returns zero if the channel is in blocking mode.
<p class="Pp"></p>
</section>
<section class="Sh">
<h1 class="Sh" id="TCL_INPUTBUFFERED"><a class="permalink" href="#TCL_INPUTBUFFERED">TCL_INPUTBUFFERED</a></h1>
<b>Tcl_InputBuffered</b> returns the number of bytes of input currently buffered
  in the internal buffers for a channel. If the channel is not open for reading,
  this function always returns zero.
<p class="Pp"></p>
</section>
<section class="Sh">
<h1 class="Sh" id="TCL_OUTPUTBUFFERED"><a class="permalink" href="#TCL_OUTPUTBUFFERED">TCL_OUTPUTBUFFERED</a></h1>
<b>Tcl_OutputBuffered</b> returns the number of bytes of output currently
  buffered in the internal buffers for a channel. If the channel is not open for
  writing, this function always returns zero.
<p class="Pp"></p>
</section>
<section class="Sh">
<h1 class="Sh" id="PLATFORM_ISSUES"><a class="permalink" href="#PLATFORM_ISSUES">PLATFORM
  ISSUES</a></h1>
The handles returned from <b>Tcl_GetChannelHandle</b> depend on the platform and
  the channel type. On Unix platforms, the handle is always a Unix file
  descriptor as returned from the <b>open</b> system call. On Windows platforms,
  the handle is a file <b>HANDLE</b> when the channel was created with
  <b>Tcl_OpenFileChannel</b>, <b>Tcl_OpenCommandChannel</b>, or
  <b>Tcl_MakeFileChannel</b>. Other channel types may return a different type of
  handle on Windows platforms.
<p class="Pp"></p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
DString(3), fconfigure(n), filename(n), fopen(3), Tcl_CreateChannel(3)
<p class="Pp"></p>
</section>
<section class="Sh">
<h1 class="Sh" id="KEYWORDS"><a class="permalink" href="#KEYWORDS">KEYWORDS</a></h1>
access point, blocking, buffered I/O, channel, channel driver, end of file,
  flush, input, nonblocking, output, read, seek, write
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">8.3</td>
    <td class="foot-os">Tcl</td>
  </tr>
</table>
</body>
</html>
