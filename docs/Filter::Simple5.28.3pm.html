<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.10 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>Filter::Simple(3pm)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Filter::Simple(3pm)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">Filter::Simple(3pm)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
Filter::Simple - Simplified source filtering
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<span class="Li"></span>
<pre>
 # in MyFilter.pm:

     package MyFilter;

     use Filter::Simple;

     FILTER { ... };

     # or just:
     #
     # use Filter::Simple sub { ... };

 # in user's code:

     use MyFilter;

     # this code is filtered

     no MyFilter;

     # this code is not
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<section class="Ss">
<h2 class="Ss" id="The_Problem"><a class="permalink" href="#The_Problem">The
  Problem</a></h2>
Source filtering is an immensely powerful feature of recent versions of Perl. It
  allows one to extend the language itself (e.g. the Switch module), to simplify
  the language (e.g. Language::Pythonesque), or to completely recast the
  language (e.g. Lingua::Romana::Perligata). Effectively, it allows one to use
  the full power of Perl as its own, recursively applied, macro language.
<p class="Pp">The excellent Filter::Util::Call module (by Paul Marquess)
    provides a usable Perl interface to source filtering, but it is often too
    powerful and not nearly as simple as it could be.</p>
<p class="Pp">To use the module it is necessary to do the following:</p>
<dl class="Bl-tag">
  <dt>1.</dt>
  <dd>Download, build, and install the Filter::Util::Call module. (If you have
      Perl 5.7.1 or later, this is already done for you.)</dd>
  <dt>2.</dt>
  <dd>Set up a module that does a <span class="Li">&quot;use
      Filter::Util::Call&quot;</span>.</dd>
  <dt>3.</dt>
  <dd>Within that module, create an <span class="Li">&quot;import&quot;</span>
      subroutine.</dd>
  <dt>4.</dt>
  <dd>Within the <span class="Li">&quot;import&quot;</span> subroutine do a call
      to <span class="Li">&quot;filter_add&quot;</span>, passing it either a
      subroutine reference.</dd>
  <dt>5.</dt>
  <dd>Within the subroutine reference, call
      <span class="Li">&quot;filter_read&quot;</span> or
      <span class="Li">&quot;filter_read_exact&quot;</span> to &quot;prime&quot;
      <span class="Li">$_</span> with source code data from the source file that
      will <span class="Li">&quot;use&quot;</span> your module. Check the status
      value returned to see if any source code was actually read in.</dd>
  <dt>6.</dt>
  <dd>Process the contents of <span class="Li">$_</span> to change the source
      code in the desired manner.</dd>
  <dt>7.</dt>
  <dd>Return the status value.</dd>
  <dt>8.</dt>
  <dd>If the act of unimporting your module (via a
      <span class="Li">&quot;no&quot;</span>) should cause source code filtering
      to cease, create an <span class="Li">&quot;unimport&quot;</span>
      subroutine, and have it call
      <span class="Li">&quot;filter_del&quot;</span>. Make sure that the call to
      <span class="Li">&quot;filter_read&quot;</span> or
      <span class="Li">&quot;filter_read_exact&quot;</span> in step 5 will not
      accidentally read past the <span class="Li">&quot;no&quot;</span>.
      Effectively this limits source code filters to line-by-line operation,
      unless the <span class="Li">&quot;import&quot;</span> subroutine does some
      fancy pre-pre-parsing of the source code it's filtering.</dd>
</dl>
<p class="Pp">For example, here is a minimal source code filter in a module
    named BANG.pm. It simply converts every occurrence of the sequence
    <span class="Li">&quot;BANG\s+BANG&quot;</span> to the sequence
    <span class="Li">&quot;die 'BANG' if $BANG&quot;</span> in any piece of code
    following a <span class="Li">&quot;use BANG;&quot;</span> statement (until
    the next <span class="Li">&quot;no BANG;&quot;</span> statement, if
  any):</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    package BANG;

    use Filter::Util::Call ;

    sub import {
        filter_add( sub {
        my $caller = caller;
        my ($status, $no_seen, $data);
        while ($status = filter_read()) {
            if (/^\s*no\s+$caller\s*;\s*?$/) {
                $no_seen=1;
                last;
            }
            $data .= $_;
            $_ = &quot;&quot;;
        }
        $_ = $data;
        s/BANG\s+BANG/die 'BANG' if \$BANG/g
            unless $status &lt; 0;
        $_ .= &quot;no $class;\n&quot; if $no_seen;
        return 1;
        })
    }

    sub unimport {
        filter_del();
    }

    1 ;
</pre>
<p class="Pp">This level of sophistication puts filtering out of the reach of
    many programmers.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="A_Solution"><a class="permalink" href="#A_Solution">A
  Solution</a></h2>
The Filter::Simple module provides a simplified interface to Filter::Util::Call;
  one that is sufficient for most common cases.
<p class="Pp">Instead of the above process, with Filter::Simple the task of
    setting up a source code filter is reduced to:</p>
<dl class="Bl-tag">
  <dt>1.</dt>
  <dd>Download and install the Filter::Simple module. (If you have Perl 5.7.1 or
      later, this is already done for you.)</dd>
  <dt>2.</dt>
  <dd>Set up a module that does a <span class="Li">&quot;use
      Filter::Simple&quot;</span> and then calls <span class="Li">&quot;FILTER {
      ... }&quot;</span>.</dd>
  <dt>3.</dt>
  <dd>Within the anonymous subroutine or block that is passed to
      <span class="Li">&quot;FILTER&quot;</span>, process the contents of
      <span class="Li">$_</span> to change the source code in the desired
      manner.</dd>
</dl>
<p class="Pp">In other words, the previous example, would become:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    package BANG;
    use Filter::Simple;

    FILTER {
        s/BANG\s+BANG/die 'BANG' if \$BANG/g;
    };

    1 ;
</pre>
<p class="Pp">Note that the source code is passed as a single string, so any
    regex that uses <span class="Li">&quot;^&quot;</span> or
    <span class="Li">&quot;$&quot;</span> to detect line boundaries will need
    the <span class="Li">&quot;/m&quot;</span> flag.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Disabling_or_changing__no__behaviour"><a class="permalink" href="#Disabling_or_changing__no__behaviour">Disabling
  or changing &lt;no&gt; behaviour</a></h2>
By default, the installed filter only filters up to a line consisting of one of
  the three standard source &quot;terminators&quot;:
<p class="Pp"><span class="Li"></span></p>
<pre>
    no ModuleName;  # optional comment
</pre>
<p class="Pp">or:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    __END__
</pre>
<p class="Pp">or:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    __DATA__
</pre>
<p class="Pp">but this can be altered by passing a second argument to
    <span class="Li">&quot;use Filter::Simple&quot;</span> or
    <span class="Li">&quot;FILTER&quot;</span> (just remember: there's <i>no</i>
    comma after the initial block when you use
    <span class="Li">&quot;FILTER&quot;</span>).</p>
<p class="Pp">That second argument may be either a
    <span class="Li">&quot;qr&quot;</span>'d regular expression (which is then
    used to match the terminator line), or a defined false value (which
    indicates that no terminator line should be looked for), or a reference to a
    hash (in which case the terminator is the value associated with the key
    <span class="Li">'terminator'</span>.</p>
<p class="Pp">For example, to cause the previous filter to filter only up to a
    line of the form:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    GNAB esu;
</pre>
<p class="Pp">you would write:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    package BANG;
    use Filter::Simple;

    FILTER {
        s/BANG\s+BANG/die 'BANG' if \$BANG/g;
    }
    qr/^\s*GNAB\s+esu\s*;\s*?$/;
</pre>
<p class="Pp">or:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    FILTER {
        s/BANG\s+BANG/die 'BANG' if \$BANG/g;
    }
    { terminator =&gt; qr/^\s*GNAB\s+esu\s*;\s*?$/ };
</pre>
<p class="Pp">and to prevent the filter's being turned off in any way:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    package BANG;
    use Filter::Simple;

    FILTER {
        s/BANG\s+BANG/die 'BANG' if \$BANG/g;
    }
    &quot;&quot;;    # or: 0
</pre>
<p class="Pp">or:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    FILTER {
        s/BANG\s+BANG/die 'BANG' if \$BANG/g;
    }
    { terminator =&gt; &quot;&quot; };
</pre>
<p class="Pp"><b>Note that, no matter what you set the terminator pattern
    to,</b> <b>the actual terminator itself </b><b><i>must</i></b><b> be
    contained on a single source line.</b></p>
</section>
<section class="Ss">
<h2 class="Ss" id="All-in-one_interface"><a class="permalink" href="#All-in-one_interface">All-in-one
  interface</a></h2>
Separating the loading of Filter::Simple:
<p class="Pp"><span class="Li"></span></p>
<pre>
    use Filter::Simple;
</pre>
<p class="Pp">from the setting up of the filtering:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    FILTER { ... };
</pre>
<p class="Pp">is useful because it allows other code (typically parser support
    code or caching variables) to be defined before the filter is invoked.
    However, there is often no need for such a separation.</p>
<p class="Pp">In those cases, it is easier to just append the filtering
    subroutine and any terminator specification directly to the
    <span class="Li">&quot;use&quot;</span> statement that loads Filter::Simple,
    like so:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    use Filter::Simple sub {
        s/BANG\s+BANG/die 'BANG' if \$BANG/g;
    };
</pre>
<p class="Pp">This is exactly the same as:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    use Filter::Simple;
    BEGIN {
        Filter::Simple::FILTER {
            s/BANG\s+BANG/die 'BANG' if \$BANG/g;
        };
    }
</pre>
<p class="Pp">except that the <span class="Li">&quot;FILTER&quot;</span>
    subroutine is not exported by Filter::Simple.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Filtering_only_specific_components_of_source_code"><a class="permalink" href="#Filtering_only_specific_components_of_source_code">Filtering
  only specific components of source code</a></h2>
One of the problems with a filter like:
<p class="Pp"><span class="Li"></span></p>
<pre>
    use Filter::Simple;

    FILTER { s/BANG\s+BANG/die 'BANG' if \$BANG/g };
</pre>
<p class="Pp">is that it indiscriminately applies the specified transformation
    to the entire text of your source program. So something like:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    warn 'BANG BANG, YOU'RE DEAD';
    BANG BANG;
</pre>
<p class="Pp">will become:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    warn 'die 'BANG' if $BANG, YOU'RE DEAD';
    die 'BANG' if $BANG;
</pre>
<p class="Pp">It is very common when filtering source to only want to apply the
    filter to the non-character-string parts of the code, or alternatively to
    <i>only</i> the character strings.</p>
<p class="Pp">Filter::Simple supports this type of filtering by automatically
    exporting the <span class="Li">&quot;FILTER_ONLY&quot;</span>
  subroutine.</p>
<p class="Pp"><span class="Li">&quot;FILTER_ONLY&quot;</span> takes a sequence
    of specifiers that install separate (and possibly multiple) filters that act
    on only parts of the source code. For example:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    use Filter::Simple;

    FILTER_ONLY
        code      =&gt; sub { s/BANG\s+BANG/die 'BANG' if \$BANG/g },
        quotelike =&gt; sub { s/BANG\s+BANG/CHITTY CHITTY/g };
</pre>
<p class="Pp">The <span class="Li">&quot;code&quot;</span> subroutine will only
    be used to filter parts of the source code that are not quotelikes, POD, or
    <span class="Li">&quot;__DATA__&quot;</span>. The
    <span class="Li">&quot;quotelike&quot;</span> subroutine only filters Perl
    quotelikes (including here documents).</p>
<p class="Pp">The full list of alternatives is:</p>
<dl class="Bl-tag">
  <dt>&quot;code&quot;</dt>
  <dd>Filters only those sections of the source code that are not quotelikes,
      POD, or <span class="Li">&quot;__DATA__&quot;</span>.</dd>
  <dt>&quot;code_no_comments&quot;</dt>
  <dd>Filters only those sections of the source code that are not quotelikes,
      POD, comments, or <span class="Li">&quot;__DATA__&quot;</span>.</dd>
  <dt>&quot;executable&quot;</dt>
  <dd>Filters only those sections of the source code that are not POD or
      <span class="Li">&quot;__DATA__&quot;</span>.</dd>
  <dt>&quot;executable_no_comments&quot;</dt>
  <dd>Filters only those sections of the source code that are not POD, comments,
      or <span class="Li">&quot;__DATA__&quot;</span>.</dd>
  <dt>&quot;quotelike&quot;</dt>
  <dd>Filters only Perl quotelikes (as interpreted by
      <span class="Li">&amp;Text::Balanced::extract_quotelike</span>).</dd>
  <dt>&quot;string&quot;</dt>
  <dd>Filters only the string literal parts of a Perl quotelike (i.e. the
      contents of a string literal, either half of a
      <span class="Li">&quot;tr///&quot;</span>, the second half of an
      <span class="Li">&quot;s///&quot;</span>).</dd>
  <dt>&quot;regex&quot;</dt>
  <dd>Filters only the pattern literal parts of a Perl quotelike (i.e. the
      contents of a <span class="Li">&quot;qr//&quot;</span> or an
      <span class="Li">&quot;m//&quot;</span>, the first half of an
      <span class="Li">&quot;s///&quot;</span>).</dd>
  <dt>&quot;all&quot;</dt>
  <dd>Filters everything. Identical in effect to
      <span class="Li">&quot;FILTER&quot;</span>.</dd>
</dl>
<p class="Pp">Except for <span class="Li">&quot;FILTER_ONLY code =&gt; sub
    {...}&quot;</span>, each of the component filters is called repeatedly, once
    for each component found in the source code.</p>
<p class="Pp">Note that you can also apply two or more of the same type of
    filter in a single <span class="Li">&quot;FILTER_ONLY&quot;</span>. For
    example, here's a simple macro-preprocessor that is only applied within
    regexes, with a final debugging pass that prints the resulting source
  code:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    use Regexp::Common;
    FILTER_ONLY
        regex =&gt; sub { s/!\[/[^/g },
        regex =&gt; sub { s/%d/$RE{num}{int}/g },
        regex =&gt; sub { s/%f/$RE{num}{real}/g },
        all   =&gt; sub { print if $::DEBUG };
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Filtering_only_the_code_parts_of_source_code"><a class="permalink" href="#Filtering_only_the_code_parts_of_source_code">Filtering
  only the code parts of source code</a></h2>
Most source code ceases to be grammatically correct when it is broken up into
  the pieces between string literals and regexes. So the
  <span class="Li">'code'</span> and <span class="Li">'code_no_comments'</span>
  component filter behave slightly differently from the other partial filters
  described in the previous section.
<p class="Pp">Rather than calling the specified processor on each individual
    piece of code (i.e. on the bits between quotelikes), the
    <span class="Li">'code...'</span> partial filters operate on the entire
    source code, but with the quotelike bits (and, in the case of
    <span class="Li">'code_no_comments'</span>, the comments) &quot;blanked
    out&quot;.</p>
<p class="Pp">That is, a <span class="Li">'code...'</span> filter
    <i>replaces</i> each quoted string, quotelike, regex, POD, and __DATA__
    section with a placeholder. The delimiters of this placeholder are the
    contents of the <span class="Li">$;</span> variable at the time the filter
    is applied (normally <span class="Li">&quot;\034&quot;</span>). The
    remaining four bytes are a unique identifier for the component being
    replaced.</p>
<p class="Pp">This approach makes it comparatively easy to write code
    preprocessors without worrying about the form or contents of strings,
    regexes, etc.</p>
<p class="Pp">For convenience, during a <span class="Li">'code...'</span>
    filtering operation, Filter::Simple provides a package variable
    (<span class="Li">$Filter::Simple::placeholder</span>) that contains a
    pre-compiled regex that matches any placeholder...and captures the
    identifier within the placeholder. Placeholders can be moved and re-ordered
    within the source code as needed.</p>
<p class="Pp">In addition, a second package variable
    (<span class="Li">@Filter::Simple::components</span>) contains a list of the
    various pieces of <span class="Li">$_</span>, as they were originally split
    up to allow placeholders to be inserted.</p>
<p class="Pp">Once the filtering has been applied, the original strings,
    regexes, POD, etc. are re-inserted into the code, by replacing each
    placeholder with the corresponding original component (from
    <span class="Li">@components</span>). Note that this means that the
    <span class="Li">@components</span> variable must be treated with extreme
    care within the filter. The <span class="Li">@components</span> array stores
    the &quot;back- translations&quot; of each placeholder inserted into
    <span class="Li">$_</span>, as well as the interstitial source code between
    placeholders. If the placeholder backtranslations are altered in
    <span class="Li">@components</span>, they will be similarly changed when the
    placeholders are removed from <span class="Li">$_</span> after the filter is
    complete.</p>
<p class="Pp">For example, the following filter detects concatenated pairs of
    strings/quotelikes and reverses the order in which they are
  concatenated:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    package DemoRevCat;
    use Filter::Simple;

    FILTER_ONLY code =&gt; sub {
        my $ph = $Filter::Simple::placeholder;
        s{ ($ph) \s* [.] \s* ($ph) }{ $2.$1 }gx
    };
</pre>
<p class="Pp">Thus, the following code:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    use DemoRevCat;

    my $str = &quot;abc&quot; . q(def);

    print &quot;$str\n&quot;;
</pre>
<p class="Pp">would become:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    my $str = q(def).&quot;abc&quot;;

    print &quot;$str\n&quot;;
</pre>
<p class="Pp">and hence print:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    defabc
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Using_Filter::Simple_with_an_explicit__import__subroutine"><a class="permalink" href="#Using_Filter::Simple_with_an_explicit__import__subroutine">Using
  Filter::Simple with an explicit &quot;import&quot; subroutine</a></h2>
Filter::Simple generates a special <span class="Li">&quot;import&quot;</span>
  subroutine for your module (see &quot;How it works&quot;) which would normally
  replace any <span class="Li">&quot;import&quot;</span> subroutine you might
  have explicitly declared.
<p class="Pp">However, Filter::Simple is smart enough to notice your existing
    <span class="Li">&quot;import&quot;</span> and Do The Right Thing with it.
    That is, if you explicitly define an
    <span class="Li">&quot;import&quot;</span> subroutine in a package that's
    using Filter::Simple, that <span class="Li">&quot;import&quot;</span>
    subroutine will still be invoked immediately after any filter you
  install.</p>
<p class="Pp">The only thing you have to remember is that the
    <span class="Li">&quot;import&quot;</span> subroutine <i>must</i> be
    declared <i>before</i> the filter is installed. If you use
    <span class="Li">&quot;FILTER&quot;</span> to install the filter:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    package Filter::TurnItUpTo11;

    use Filter::Simple;

    FILTER { s/(\w+)/\U$1/ };
</pre>
<p class="Pp">that will almost never be a problem, but if you install a
    filtering subroutine by passing it directly to the
    <span class="Li">&quot;use Filter::Simple&quot;</span> statement:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    package Filter::TurnItUpTo11;

    use Filter::Simple sub{ s/(\w+)/\U$1/ };
</pre>
<p class="Pp">then you must make sure that your
    <span class="Li">&quot;import&quot;</span> subroutine appears before that
    <span class="Li">&quot;use&quot;</span> statement.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Using_Filter::Simple_and_Exporter_together"><a class="permalink" href="#Using_Filter::Simple_and_Exporter_together">Using
  Filter::Simple and Exporter together</a></h2>
Likewise, Filter::Simple is also smart enough to Do The Right Thing if you use
  Exporter:
<p class="Pp"><span class="Li"></span></p>
<pre>
    package Switch;
    use base Exporter;
    use Filter::Simple;

    @EXPORT    = qw(switch case);
    @EXPORT_OK = qw(given  when);

    FILTER { $_ = magic_Perl_filter($_) }
</pre>
<p class="Pp">Immediately after the filter has been applied to the source,
    Filter::Simple will pass control to Exporter, so it can do its magic
  too.</p>
<p class="Pp">Of course, here too, Filter::Simple has to know you're using
    Exporter before it applies the filter. That's almost never a problem, but if
    you're nervous about it, you can guarantee that things will work correctly
    by ensuring that your <span class="Li">&quot;use base Exporter&quot;</span>
    always precedes your <span class="Li">&quot;use
  Filter::Simple&quot;</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="How_it_works"><a class="permalink" href="#How_it_works">How
  it works</a></h2>
The Filter::Simple module exports into the package that calls
  <span class="Li">&quot;FILTER&quot;</span> (or
  <span class="Li">&quot;use&quot;</span>s it directly) -- such as package
  &quot;BANG&quot; in the above example -- two automagically constructed
  subroutines -- <span class="Li">&quot;import&quot;</span> and
  <span class="Li">&quot;unimport&quot;</span> -- which take care of all the
  nasty details.
<p class="Pp">In addition, the generated
    <span class="Li">&quot;import&quot;</span> subroutine passes its own
    argument list to the filtering subroutine, so the BANG.pm filter could
    easily be made parametric:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    package BANG;

    use Filter::Simple;

    FILTER {
        my ($die_msg, $var_name) = @_;
        s/BANG\s+BANG/die '$die_msg' if \${$var_name}/g;
    };

    # and in some user code:

    use BANG &quot;BOOM&quot;, &quot;BAM&quot;;  # &quot;BANG BANG&quot; becomes: die 'BOOM' if $BAM
</pre>
<p class="Pp">The specified filtering subroutine is called every time a
    <span class="Li">&quot;use BANG&quot;</span> is encountered, and passed all
    the source code following that call, up to either the next
    <span class="Li">&quot;no BANG;&quot;</span> (or whatever terminator you've
    set) or the end of the source file, whichever occurs first. By default, any
    <span class="Li">&quot;no</span> <span class="Li">BANG;&quot;</span> call
    must appear by itself on a separate line, or it is ignored.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
Damian Conway
</section>
<section class="Sh">
<h1 class="Sh" id="CONTACT"><a class="permalink" href="#CONTACT">CONTACT</a></h1>
Filter::Simple is now maintained by the Perl5-Porters. Please submit bug via the
  <span class="Li">&quot;perlbug&quot;</span> tool that comes with your perl.
  For usage instructions, read <span class="Li">&quot;perldoc
  perlbug&quot;</span> or possibly <span class="Li">&quot;man
  perlbug&quot;</span>. For mostly anything else, please contact
  &lt;perl5-porters@perl.org&gt;.
<p class="Pp">Maintainer of the CPAN release is Steffen Mueller
    &lt;smueller@cpan.org&gt;. Contact him with technical difficulties with
    respect to the packaging of the CPAN module.</p>
<p class="Pp">Praise of the module, flowers, and presents still go to the
    author, Damian Conway &lt;damian@conway.org&gt;.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT_AND_LICENSE"><a class="permalink" href="#COPYRIGHT_AND_LICENSE">COPYRIGHT
  AND LICENSE</a></h1>
<span class="Li"></span>
<pre>
    Copyright (c) 2000-2014, Damian Conway. All Rights Reserved.
    This module is free software. It may be used, redistributed
    and/or modified under the same terms as Perl itself.
</pre>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2018-11-01</td>
    <td class="foot-os">perl v5.28.2</td>
  </tr>
</table>
</body>
</html>
