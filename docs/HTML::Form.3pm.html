<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    .Nd, .Bf, .Op { display: inline; }
    .Pa, .Ad { font-style: italic; }
    .Ms { font-weight: bold; }
    .Bl-diag > dt { font-weight: bold; }
    code.Nm, .Fl, .Cm, .Ic, code.In, .Fd, .Fn, .Cd { font-weight: bold;
      font-family: inherit; }
  </style>
  <title>HTML::Form(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">HTML::Form(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">HTML::Form(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">HTML::Form - Class that represents an HTML form element</p>
</section>
<section class="Sh">
<h1 class="Sh" id="VERSION"><a class="permalink" href="#VERSION">VERSION</a></h1>
<p class="Pp">version 6.07</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre> use HTML::Form;
 $form = HTML::Form-&gt;parse($html, $base_uri);
 $form-&gt;value(query =&gt; &quot;Perl&quot;);
 use LWP::UserAgent;
 $ua = LWP::UserAgent-&gt;new;
 $response = $ua-&gt;request($form-&gt;click);
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">Objects of the <span class="Li">&quot;HTML::Form&quot;</span>
    class represents a single HTML <span class="Li">&quot;&lt;form&gt; ...
    &lt;/form&gt;&quot;</span> instance. A form consists of a sequence of inputs
    that usually have names, and which can take on various values. The state of
    a form can be tweaked and it can then be asked to provide HTTP::Request
    objects that can be passed to the <b>request()</b> method of
  LWP::UserAgent.</p>
<p class="Pp">The following methods are available:</p>
<dl class="Bl-tag">
  <dt>@forms = HTML::Form-&gt;parse( $html_document, $base_uri )</dt>
  <dd></dd>
  <dt>@forms = HTML::Form-&gt;parse( $html_document, base =&gt; $base_uri, %opt
    )</dt>
  <dd></dd>
  <dt>@forms = HTML::Form-&gt;parse( $response, %opt )</dt>
  <dd>The <b>parse()</b> class method will parse an HTML document and build up
      <span class="Li">&quot;HTML::Form&quot;</span> objects for each
      &lt;form&gt; element found. If called in scalar context only returns the
      first &lt;form&gt;. Returns an empty list if there are no forms to be
      found.
    <p class="Pp">The required arguments is the HTML document to parse
        ($html_document) and the URI used to retrieve the document ($base_uri).
        The base URI is needed to resolve relative action URIs. The provided
        HTML document should be a Unicode string (or US-ASCII).</p>
    <p class="Pp">By default HTML::Form assumes that the original document was
        UTF-8 encoded and thus encode forms that don't specify an explicit
        <i>accept-charset</i> as UTF-8. The charset assumed can be overridden by
        providing the <span class="Li">&quot;charset&quot;</span> option to
        <b>parse()</b>. It's a good idea to be explicit about this parameter as
        well, thus the recommended simplest invocation becomes:</p>
    <p class="Pp"></p>
    <pre>    my @forms = HTML::Form-&gt;parse(
        Encode::decode($encoding, $html_document_bytes),
        base =&gt; $base_uri,
        charset =&gt; $encoding,
    );
    </pre>
    <p class="Pp">If the document was retrieved with LWP then the response
        object provide methods to obtain a proper value for
        <span class="Li">&quot;base&quot;</span> and
        <span class="Li">&quot;charset&quot;</span>:</p>
    <p class="Pp"></p>
    <pre>    my $ua = LWP::UserAgent-&gt;new;
    my $response = $ua-&gt;get(&quot;http://www.example.com/form.html&quot;);
    my @forms = HTML::Form-&gt;parse($response-&gt;decoded_content,
        base =&gt; $response-&gt;base,
        charset =&gt; $response-&gt;content_charset,
    );
    </pre>
    <p class="Pp">In fact, the <b>parse()</b> method can parse from an
        HTTP::Response object directly, so the example above can be more
        conveniently written as:</p>
    <p class="Pp"></p>
    <pre>    my $ua = LWP::UserAgent-&gt;new;
    my $response = $ua-&gt;get(&quot;http://www.example.com/form.html&quot;);
    my @forms = HTML::Form-&gt;parse($response);
    </pre>
    <p class="Pp">Note that any object that implements a
        <b>decoded_content()</b>, <b>base()</b> and <b>content_charset()</b>
        method with similar behaviour as HTTP::Response will do.</p>
    <p class="Pp">Additional options might be passed in to control how the parse
        method behaves. The following are all the options currently
      recognized:</p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>&quot;base =&gt; $uri&quot;</dt>
  <dd>This is the URI used to retrieve the original document. This option is not
      optional ;-)</dd>
  <dt>&quot;charset =&gt; $str&quot;</dt>
  <dd>Specify what charset the original document was encoded in. This is used as
      the default for accept_charset. If not provided this defaults to
      &quot;UTF-8&quot;.</dd>
  <dt>&quot;verbose =&gt; $bool&quot;</dt>
  <dd>Warn (print messages to STDERR) about any bad HTML form constructs found.
      You can trap these with <span class="Li">$SIG</span>{__WARN__}. The
      default is not to issue warnings.</dd>
  <dt>&quot;strict =&gt; $bool&quot;</dt>
  <dd>Initialize any form objects with the given strict attribute. If the strict
      is turned on the methods that change values of the form will croak if you
      try to set illegal values or modify readonly fields. The default is not to
      be strict.</dd>
</dl>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>$form-&gt;push_input( $type, \%attr, $verbose )</dt>
  <dd>This method adds additional inputs to the form. The first argument is the
      type of input (e.g. hidden, option, etc.). The second argument is a
      reference to a hash of the input attributes. The third argument is
      optional, and will issue warnings about unknown input types.
    <p class="Pp">Example:</p>
    <p class="Pp"></p>
    <pre>    push_input( 'hidden', {
        name  =&gt; 'NewFormElement',
        id    =&gt; 'NewFormElementId',
        value =&gt; 'some value',
    });
    </pre>
  </dd>
  <dt>$method = $form-&gt;method</dt>
  <dd></dd>
  <dt>$form-&gt;method( $new_method )</dt>
  <dd>This method is gets/sets the <i>method</i> name used for the HTTP::Request
      generated. It is a string like &quot;GET&quot; or &quot;POST&quot;.</dd>
  <dt>$action = $form-&gt;action</dt>
  <dd></dd>
  <dt>$form-&gt;action( $new_action )</dt>
  <dd>This method gets/sets the URI which we want to apply the request
      <i>method</i> to.</dd>
  <dt>$enctype = $form-&gt;enctype</dt>
  <dd></dd>
  <dt>$form-&gt;enctype( $new_enctype )</dt>
  <dd>This method gets/sets the encoding type for the form data. It is a string
      like &quot;application/x-www-form-urlencoded&quot; or
      &quot;multipart/form-data&quot;.</dd>
  <dt>$accept = $form-&gt;accept_charset</dt>
  <dd></dd>
  <dt>$form-&gt;accept_charset( $new_accept )</dt>
  <dd>This method gets/sets the list of charset encodings that the server
      processing the form accepts. Current implementation supports only
      one-element lists. Default value is &quot;UNKNOWN&quot; which we interpret
      as a request to use document charset as specified by the 'charset'
      parameter of the <b>parse()</b> method.</dd>
  <dt>$value = $form-&gt;attr( $name )</dt>
  <dd></dd>
  <dt>$form-&gt;attr( $name, $new_value )</dt>
  <dd>This method give access to the original HTML attributes of the
      &lt;form&gt; tag. The <span class="Li">$name</span> should always be
      passed in lower case.
    <p class="Pp">Example:</p>
    <p class="Pp"></p>
    <pre>   @f = HTML::Form-&gt;parse( $html, $foo );
   @f = grep $_-&gt;attr(&quot;id&quot;) eq &quot;foo&quot;, @f;
   die &quot;No form named 'foo' found&quot; unless @f;
   $foo = shift @f;
    </pre>
  </dd>
  <dt>$bool = $form-&gt;strict</dt>
  <dd></dd>
  <dt>$form-&gt;strict( $bool )</dt>
  <dd>Gets/sets the strict attribute of a form. If the strict is turned on the
      methods that change values of the form will croak if you try to set
      illegal values or modify readonly fields. The default is not to be
    strict.</dd>
  <dt>@inputs = $form-&gt;inputs</dt>
  <dd>This method returns the list of inputs in the form. If called in scalar
      context it returns the number of inputs contained in the form. See
      &quot;INPUTS&quot; for what methods are available for the input objects
      returned.</dd>
  <dt>$input = $form-&gt;find_input( $selector )</dt>
  <dd></dd>
  <dt>$input = $form-&gt;find_input( $selector, $type )</dt>
  <dd></dd>
  <dt>$input = $form-&gt;find_input( $selector, $type, $index )</dt>
  <dd></dd>
  <dt>@inputs = $form-&gt;find_input( $selector )</dt>
  <dd></dd>
  <dt>@inputs = $form-&gt;find_input( $selector, $type )</dt>
  <dd>This method is used to locate specific inputs within the form. All inputs
      that match the arguments given are returned. In scalar context only the
      first is returned, or <span class="Li">&quot;undef&quot;</span> if none
      match.
    <p class="Pp">If <span class="Li">$selector</span> is not
        <span class="Li">&quot;undef&quot;</span>, then the input's name, id,
        class attribute must match. A selector prefixed with '#' must match the
        id attribute of the input. A selector prefixed with '.' matches the
        class attribute. A selector prefixed with '^' or with no prefix matches
        the name attribute.</p>
    <p class="Pp">If <span class="Li">$type</span> is not
        <span class="Li">&quot;undef&quot;</span>, then the input must have the
        specified type. The following type names are used: &quot;text&quot;,
        &quot;password&quot;, &quot;hidden&quot;, &quot;textarea&quot;,
        &quot;file&quot;, &quot;image&quot;, &quot;submit&quot;,
        &quot;radio&quot;, &quot;checkbox&quot; and &quot;option&quot;.</p>
    <p class="Pp">The <span class="Li">$index</span> is the sequence number of
        the input matched where 1 is the first. If combined with
        <span class="Li">$name</span> and/or <span class="Li">$type</span>, then
        it selects the <i>n</i>th input with the given name and/or type.</p>
  </dd>
  <dt>$value = $form-&gt;value( $selector )</dt>
  <dd></dd>
  <dt>$form-&gt;value( $selector, $new_value )</dt>
  <dd>The <b>value()</b> method can be used to get/set the value of some input.
      If strict is enabled and no input has the indicated name, then this method
      will croak.
    <p class="Pp">If multiple inputs have the same name, only the first one will
        be affected.</p>
    <p class="Pp">The call:</p>
    <p class="Pp"></p>
    <pre>    $form-&gt;value('foo')
    </pre>
    <p class="Pp">is basically a short-hand for:</p>
    <p class="Pp"></p>
    <pre>    $form-&gt;find_input('foo')-&gt;value;
    </pre>
  </dd>
  <dt>@names = $form-&gt;param</dt>
  <dd></dd>
  <dt>@values = $form-&gt;param( $name )</dt>
  <dd></dd>
  <dt>$form-&gt;param( $name, $value, ... )</dt>
  <dd></dd>
  <dt>$form-&gt;param( $name, \@values )</dt>
  <dd>Alternative interface to examining and setting the values of the form.
    <p class="Pp">If called without arguments then it returns the names of all
        the inputs in the form. The names will not repeat even if multiple
        inputs have the same name. In scalar context the number of different
        names is returned.</p>
    <p class="Pp">If called with a single argument then it returns the value or
        values of inputs with the given name. If called in scalar context only
        the first value is returned. If no input exists with the given name,
        then <span class="Li">&quot;undef&quot;</span> is returned.</p>
    <p class="Pp">If called with 2 or more arguments then it will set values of
        the named inputs. This form will croak if no inputs have the given name
        or if any of the values provided does not fit. Values can also be
        provided as a reference to an array. This form will allow unsetting all
        values with the given name as well.</p>
    <p class="Pp">This interface resembles that of the <b>param()</b> function
        of the CGI module.</p>
  </dd>
  <dt>$form-&gt;try_others( \&amp;callback )</dt>
  <dd>This method will iterate over all permutations of unvisited enumerated
      values (&lt;select&gt;, &lt;radio&gt;, &lt;checkbox&gt;) and invoke the
      callback for each. The callback is passed the
      <span class="Li">$form</span> as argument. The return value from the
      callback is ignored and the <b>try_others()</b> method itself does not
      return anything.</dd>
  <dt>$request = $form-&gt;make_request</dt>
  <dd>Will return an HTTP::Request object that reflects the current setting of
      the form. You might want to use the <b>click()</b> method instead.</dd>
  <dt>$request = $form-&gt;click</dt>
  <dd></dd>
  <dt>$request = $form-&gt;click( $selector )</dt>
  <dd></dd>
  <dt>$request = $form-&gt;click( $x, $y )</dt>
  <dd></dd>
  <dt>$request = $form-&gt;click( $selector, $x, $y )</dt>
  <dd>Will &quot;click&quot; on the first clickable input (which will be of type
      <span class="Li">&quot;submit&quot;</span> or
      <span class="Li">&quot;image&quot;</span>). The result of clicking is an
      HTTP::Request object that can then be passed to LWP::UserAgent if you want
      to obtain the server response.
    <p class="Pp">If a <span class="Li">$selector</span> is specified, we will
        click on the first clickable input matching the selector, and the method
        will croak if no matching clickable input is found. If
        <span class="Li">$selector</span> is <i>not</i> specified, then it is ok
        if the form contains no clickable inputs. In this case the
        <b>click()</b> method returns the same request as the
        <b>make_request()</b> method would do. See description of the
        <b>find_input()</b> method above for how the
        <span class="Li">$selector</span> is specified.</p>
    <p class="Pp">If there are multiple clickable inputs with the same name,
        then there is no way to get the <b>click()</b> method of the
        <span class="Li">&quot;HTML::Form&quot;</span> to click on any but the
        first. If you need this you would have to locate the input with
        <b>find_input()</b> and invoke the <b>click()</b> method on the given
        input yourself.</p>
    <p class="Pp">A click coordinate pair can also be provided, but this only
        makes a difference if you clicked on an image. The default coordinate is
        (1,1). The upper-left corner of the image is (0,0), but some badly coded
        CGI scripts are known to not recognize this. Therefore (1,1) was
        selected as a safer default.</p>
  </dd>
  <dt>@kw = $form-&gt;form</dt>
  <dd>Returns the current setting as a sequence of key/value pairs. Note that
      keys might be repeated, which means that some values might be lost if the
      return values are assigned to a hash.
    <p class="Pp">In scalar context this method returns the number of key/value
        pairs generated.</p>
  </dd>
  <dt>$form-&gt;dump</dt>
  <dd>Returns a textual representation of current state of the form. Mainly
      useful for debugging. If called in void context, then the dump is printed
      on STDERR.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="INPUTS"><a class="permalink" href="#INPUTS">INPUTS</a></h1>
<p class="Pp">An <span class="Li">&quot;HTML::Form&quot;</span> objects contains
    a sequence of <i>inputs</i>. References to the inputs can be obtained with
    the <span class="Li">$form</span>-&gt;inputs or
    <span class="Li">$form</span>-&gt;find_input methods.</p>
<p class="Pp">Note that there is <i>not</i> a one-to-one correspondence between
    input <i>objects</i> and &lt;input&gt; <i>elements</i> in the HTML document.
    An input object basically represents a name/value pair, so when multiple
    HTML elements contribute to the same name/value pair in the submitted form
    they are combined.</p>
<p class="Pp">The input elements that are mapped one-to-one are
    &quot;text&quot;, &quot;textarea&quot;, &quot;password&quot;,
    &quot;hidden&quot;, &quot;file&quot;, &quot;image&quot;, &quot;submit&quot;
    and &quot;checkbox&quot;. For the &quot;radio&quot; and &quot;option&quot;
    inputs the story is not as simple: All &lt;input type=&quot;radio&quot;&gt;
    elements with the same name will contribute to the same input radio object.
    The number of radio input objects will be the same as the number of distinct
    names used for the &lt;input type=&quot;radio&quot;&gt; elements. For a
    &lt;select&gt; element without the
    <span class="Li">&quot;multiple&quot;</span> attribute there will be one
    input object of type of &quot;option&quot;. For a &lt;select multiple&gt;
    element there will be one input object for each contained &lt;option&gt;
    element. Each one of these option objects will have the same name.</p>
<p class="Pp">The following methods are available for the <i>input</i>
  objects:</p>
<dl class="Bl-tag">
  <dt>$input-&gt;type</dt>
  <dd>Returns the type of this input. The type is one of the following strings:
      &quot;text&quot;, &quot;password&quot;, &quot;hidden&quot;,
      &quot;textarea&quot;, &quot;file&quot;, &quot;image&quot;,
      &quot;submit&quot;, &quot;radio&quot;, &quot;checkbox&quot; or
      &quot;option&quot;.</dd>
  <dt>$name = $input-&gt;name</dt>
  <dd></dd>
  <dt>$input-&gt;name( $new_name )</dt>
  <dd>This method can be used to get/set the current name of the input.</dd>
  <dt>$input-&gt;id</dt>
  <dd></dd>
  <dt>$input-&gt;class</dt>
  <dd>These methods can be used to get/set the current id or class attribute for
      the input.</dd>
  <dt>$input-&gt;selected( $selector )</dt>
  <dd>Returns TRUE if the given selector matched the input. See the description
      of the <b>find_input()</b> method above for a description of the selector
      syntax.</dd>
  <dt>$value = $input-&gt;value</dt>
  <dd></dd>
  <dt>$input-&gt;value( $new_value )</dt>
  <dd>This method can be used to get/set the current value of an input.
    <p class="Pp">If strict is enabled and the input only can take an enumerated
        list of values, then it is an error to try to set it to something else
        and the method will croak if you try.</p>
    <p class="Pp">You will also be able to set the value of read-only inputs,
        but a warning will be generated if running under
        <span class="Li">&quot;perl -w&quot;</span>.</p>
  </dd>
  <dt>$autocomplete = $input-&gt;autocomplete</dt>
  <dd></dd>
  <dt>$input-&gt;autocomplete( $new_autocomplete )</dt>
  <dd>This method can be used to get/set the current value (if any) of
      <span class="Li">&quot;autcomplete&quot;</span> for the input.</dd>
  <dt>$input-&gt;possible_values</dt>
  <dd>Returns a list of all values that an input can take. For inputs that do
      not have discrete values, this returns an empty list.</dd>
  <dt>$input-&gt;other_possible_values</dt>
  <dd>Returns a list of all values not tried yet.</dd>
  <dt>$input-&gt;value_names</dt>
  <dd>For some inputs the values can have names that are different from the
      values themselves. The number of names returned by this method will match
      the number of values reported by
      <span class="Li">$input</span>-&gt;possible_values.
    <p class="Pp">When setting values using the <b>value()</b> method it is also
        possible to use the value names in place of the value itself.</p>
  </dd>
  <dt>$bool = $input-&gt;readonly</dt>
  <dd></dd>
  <dt>$input-&gt;readonly( $bool )</dt>
  <dd>This method is used to get/set the value of the readonly attribute. You
      are allowed to modify the value of readonly inputs, but setting the value
      will generate some noise when warnings are enabled. Hidden fields always
      start out readonly.</dd>
  <dt>$bool = $input-&gt;disabled</dt>
  <dd></dd>
  <dt>$input-&gt;disabled( $bool )</dt>
  <dd>This method is used to get/set the value of the disabled attribute.
      Disabled inputs do not contribute any key/value pairs for the form
    value.</dd>
  <dt>$input-&gt;form_name_value</dt>
  <dd>Returns a (possible empty) list of key/value pairs that should be
      incorporated in the form value from this input.</dd>
  <dt>$input-&gt;check</dt>
  <dd>Some input types represent toggles that can be turned on/off. This
      includes &quot;checkbox&quot; and &quot;option&quot; inputs. Calling this
      method turns this input on without having to know the value name. If the
      input is already on, then nothing happens.
    <p class="Pp">This has the same effect as:</p>
    <p class="Pp"></p>
    <pre>    $input-&gt;value($input-&gt;possible_values[1]);
    </pre>
    <p class="Pp">The input can be turned off with:</p>
    <p class="Pp"></p>
    <pre>    $input-&gt;value(undef);
    </pre>
  </dd>
  <dt>$input-&gt;click($form, $x, $y)</dt>
  <dd>Some input types (currently &quot;submit&quot; buttons and
      &quot;images&quot;) can be clicked to submit the form. The <b>click()</b>
      method returns the corresponding HTTP::Request object.</dd>
</dl>
<p class="Pp">If the input is of type <span class="Li">&quot;file&quot;</span>,
    then it has these additional methods:</p>
<dl class="Bl-tag">
  <dt>$input-&gt;file</dt>
  <dd>This is just an alias for the <b>value()</b> method. It sets the filename
      to read data from.
    <p class="Pp">For security reasons this field will never be initialized from
        the parsing of a form. This prevents the server from triggering stealth
        uploads of arbitrary files from the client machine.</p>
  </dd>
  <dt>$filename = $input-&gt;filename</dt>
  <dd></dd>
  <dt>$input-&gt;filename( $new_filename )</dt>
  <dd>This get/sets the filename reported to the server during file upload. This
      attribute defaults to the value reported by the <b>file()</b> method.</dd>
  <dt>$content = $input-&gt;content</dt>
  <dd></dd>
  <dt>$input-&gt;content( $new_content )</dt>
  <dd>This get/sets the file content provided to the server during file upload.
      This method can be used if you do not want the content to be read from an
      actual file.</dd>
  <dt>@headers = $input-&gt;headers</dt>
  <dd></dd>
  <dt id="input"><a class="permalink" href="#input">input-&gt;headers($key =&gt;
    $value, .... )</a></dt>
  <dd>This get/set additional header fields describing the file uploaded. This
      can for instance be used to set the
      <span class="Li">&quot;Content-Type&quot;</span> reported for the
    file.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp">LWP, LWP::UserAgent, HTML::Parser</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">Gisle Aas &lt;gisle@activestate.com&gt;</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT_AND_LICENSE"><a class="permalink" href="#COPYRIGHT_AND_LICENSE">COPYRIGHT
  AND LICENSE</a></h1>
<p class="Pp">This software is copyright (c) 1998 by Gisle Aas.</p>
<p class="Pp">This is free software; you can redistribute it and/or modify it
    under the same terms as the Perl 5 programming language system itself.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2020-02-21</td>
    <td class="foot-os">perl v5.30.2</td>
  </tr>
</table>
</body>
</html>
