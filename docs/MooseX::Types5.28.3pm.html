<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.10 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>MooseX::Types(3pm)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">MooseX::Types(3pm)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">MooseX::Types(3pm)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
MooseX::Types - Organise your Moose types in libraries
</section>
<section class="Sh">
<h1 class="Sh" id="VERSION"><a class="permalink" href="#VERSION">VERSION</a></h1>
version 0.50
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<section class="Ss">
<h2 class="Ss" id="Library_Definition"><a class="permalink" href="#Library_Definition">Library
  Definition</a></h2>
<span class="Li"></span>
<pre>
  package MyLibrary;

  # predeclare our own types
  use MooseX::Types -declare =&gt; [
      qw(
          PositiveInt
          NegativeInt
          ArrayRefOfPositiveInt
          ArrayRefOfAtLeastThreeNegativeInts
          LotsOfInnerConstraints
          StrOrArrayRef
          MyDateTime
          )
  ];

  # import builtin types
  use MooseX::Types::Moose qw/Int HashRef/;

  # type definition.
  subtype PositiveInt,
      as Int,
      where { $_ &gt; 0 },
      message { &quot;Int is not larger than 0&quot; };

  subtype NegativeInt,
      as Int,
      where { $_ &lt; 0 },
      message { &quot;Int is not smaller than 0&quot; };

  # type coercion
  coerce PositiveInt,
      from Int,
          via { 1 };

  # with parameterized constraints.

  subtype ArrayRefOfPositiveInt,
    as ArrayRef[PositiveInt];

  subtype ArrayRefOfAtLeastThreeNegativeInts,
    as ArrayRef[NegativeInt],
    where { scalar(@$_) &gt; 2 };

  subtype LotsOfInnerConstraints,
    as ArrayRef[ArrayRef[HashRef[Int]]];

  # with TypeConstraint Unions

  subtype StrOrArrayRef,
    as Str|ArrayRef;

  # class types

  class_type 'DateTime';

  # or better

  class_type MyDateTime, { class =&gt; 'DateTime' };

  coerce MyDateTime,
    from HashRef,
    via { DateTime-&gt;new(%$_) };

  1;
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Usage"><a class="permalink" href="#Usage">Usage</a></h2>
<span class="Li"></span>
<pre>
  package Foo;
  use Moose;
  use MyLibrary qw( PositiveInt NegativeInt );

  # use the exported constants as type names
  has 'bar',
      isa    =&gt; PositiveInt,
      is     =&gt; 'rw';
  has 'baz',
      isa    =&gt; NegativeInt,
      is     =&gt; 'rw';

  sub quux {
      my ($self, $value);

      # test the value
      print &quot;positive\n&quot; if is_PositiveInt($value);
      print &quot;negative\n&quot; if is_NegativeInt($value);

      # coerce the value, NegativeInt doesn't have a coercion
      # helper, since it didn't define any coercions.
      $value = to_PositiveInt($value) or die &quot;Cannot coerce&quot;;
  }

  1;
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
The type system provided by Moose effectively makes all of its builtin type
  global, as are any types you declare with Moose. This means that every module
  that declares a type named <span class="Li">&quot;PositiveInt&quot;</span> is
  sharing the same type object. This can be a problem when different parts of
  the code base want to use the same name for different things.
<p class="Pp">This package lets you declare types using short names, but behind
    the scenes it namespaces all your type declarations, effectively prevent
    name clashes between packages.</p>
<p class="Pp">This is done by creating a type library module like
    <span class="Li">&quot;MyApp::Types&quot;</span> and then importing types
    from that module into other modules.</p>
<p class="Pp">As a side effect, the declaration mechanism allows you to write
    type names as barewords (really function calls), which catches typos in
    names at compile time rather than run time.</p>
<p class="Pp">This module also provides some helper functions for using Moose
    types outside of attribute declarations.</p>
<p class="Pp">If you mix string-based names with types created by this module,
    it will warn, with a few exceptions. If you are declaring a
    <span class="Li">&quot;class_type()&quot;</span> or
    <span class="Li">&quot;role_type()&quot;</span> within your type library, or
    if you use a fully qualified name like
    <span class="Li">&quot;MyApp::Foo&quot;</span>.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="LIBRARY_DEFINITION"><a class="permalink" href="#LIBRARY_DEFINITION">LIBRARY
  DEFINITION</a></h1>
A MooseX::Types is just a normal Perl module. Unlike Moose itself, it does not
  install <span class="Li">&quot;use strict&quot;</span> and
  <span class="Li">&quot;use warnings&quot;</span> in your class by default, so
  this is up to you.
<p class="Pp">The only thing a library is required to do is</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  use MooseX::Types -declare =&gt; \@types;
</pre>
<p class="Pp">with <span class="Li">@types</span> being a list of types you wish
    to define in this library. This line will install a proper base class in
    your package as well as the full set of handlers for your declared types. It
    will then hand control over to Moose::Util::TypeConstraints'
    <span class="Li">&quot;import&quot;</span> method to export the functions
    you will need to declare your types.</p>
<p class="Pp">If you want to use Moose' built-in types (e.g. for subtyping) you
    will want to</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  use MooseX::Types::Moose @types;
</pre>
<p class="Pp">to import the helpers from the shipped MooseX::Types::Moose
    library which can export all types that come with Moose.</p>
<p class="Pp">You will have to define coercions for your types or your library
    won't export a &quot;to_$type&quot; coercion helper for it.</p>
<p class="Pp">Note that you currently cannot define types containing
    <span class="Li">&quot;::&quot;</span>, since exporting would be a
  problem.</p>
<p class="Pp">You also don't need to use
    <span class="Li">&quot;warnings&quot;</span> and
    <span class="Li">&quot;strict&quot;</span>, since the definition of a
    library automatically exports those.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="LIBRARY_USAGE"><a class="permalink" href="#LIBRARY_USAGE">LIBRARY
  USAGE</a></h1>
You can import the &quot;type helpers&quot; of a library by
  <span class="Li">&quot;use&quot;</span>ing it with a list of types to import
  as arguments. If you want all of them, use the
  <span class="Li">&quot;:all&quot;</span> tag. For example:
<p class="Pp"><span class="Li"></span></p>
<pre>
  use MyLibrary      ':all';
  use MyOtherLibrary qw( TypeA TypeB );
</pre>
<p class="Pp">MooseX::Types comes with a library of Moose' built-in types called
    MooseX::Types::Moose.</p>
<p class="Pp">The exporting mechanism is, since version 0.5, implemented via a
    wrapper around Sub::Exporter. This means you can do something like this:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  use MyLibrary TypeA =&gt; { -as =&gt; 'MyTypeA' },
                TypeB =&gt; { -as =&gt; 'MyTypeB' };
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="TYPE_HANDLER_FUNCTIONS"><a class="permalink" href="#TYPE_HANDLER_FUNCTIONS">TYPE
  HANDLER FUNCTIONS</a></h1>
<section class="Ss">
<h2 class="Ss" id="$type"><a class="permalink" href="#$type">$type</a></h2>
A constant with the name of your type. It contains the type's fully qualified
  name. Takes no value, as all constants.
</section>
<section class="Ss">
<h2 class="Ss" id="is_$type"><a class="permalink" href="#is_$type">is_$type</a></h2>
This handler takes a value and tests if it is a valid value for this
  <span class="Li">$type</span>. It will return true or false.
</section>
<section class="Ss">
<h2 class="Ss" id="to_$type"><a class="permalink" href="#to_$type">to_$type</a></h2>
A handler that will take a value and coerce it into the
  <span class="Li">$type</span>. It will return a false value if the type could
  not be coerced.
<p class="Pp"><b>Important Note</b>: This handler will only be exported for
    types that can do type coercion. This has the advantage that a coercion to a
    type that has not defined any coercions will lead to a compile-time
  error.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="WRAPPING_A_LIBRARY"><a class="permalink" href="#WRAPPING_A_LIBRARY">WRAPPING
  A LIBRARY</a></h1>
You can define your own wrapper subclasses to manipulate the behaviour of a set
  of library exports. Here is an example:
<p class="Pp"><span class="Li"></span></p>
<pre>
  package MyWrapper;
  use strict;
  use MRO::Compat;
  use base 'MooseX::Types::Wrapper';

  sub coercion_export_generator {
      my $class = shift;
      my $code = $class-&gt;next::method(@_);
      return sub {
          my $value = $code-&gt;(@_);
          warn &quot;Coercion returned undef!&quot;
              unless defined $value;
          return $value;
      };
  }

  1;
</pre>
<p class="Pp">This class wraps the coercion generator (e.g.,
    <span class="Li">&quot;to_Int()&quot;</span>) and warns if a coercion
    returned an undefined value. You can wrap any library with this:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  package Foo;
  use strict;
  use MyWrapper MyLibrary =&gt; [qw( Foo Bar )],
                Moose     =&gt; [qw( Str Int )];

  ...
  1;
</pre>
<p class="Pp">The <span class="Li">&quot;Moose&quot;</span> library name is a
    special shortcut for MooseX::Types::Moose.</p>
<section class="Ss">
<h2 class="Ss" id="Generator_methods_you_can_overload"><a class="permalink" href="#Generator_methods_you_can_overload">Generator
  methods you can overload</a></h2>
<dl class="Bl-tag">
  <dt>type_export_generator( $short, $full )</dt>
  <dd>Creates a closure returning the type's Moose::Meta::TypeConstraint
    object.</dd>
  <dt>check_export_generator( $short, $full, $undef_message )</dt>
  <dd>This creates the closure used to test if a value is valid for this
    type.</dd>
  <dt>coercion_export_generator( $short, $full, $undef_message )</dt>
  <dd>This is the closure that's doing coercions.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Provided_Parameters"><a class="permalink" href="#Provided_Parameters">Provided
  Parameters</a></h2>
<dl class="Bl-tag">
  <dt>$short</dt>
  <dd>The short, exported name of the type.</dd>
  <dt>$full</dt>
  <dd>The fully qualified name of this type as Moose knows it.</dd>
  <dt>$undef_message</dt>
  <dd>A message that will be thrown when type functionality is used but the type
      does not yet exist.</dd>
</dl>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="RECURSIVE_SUBTYPES"><a class="permalink" href="#RECURSIVE_SUBTYPES">RECURSIVE
  SUBTYPES</a></h1>
As of version 0.08, Moose::Types has experimental support for Recursive
  subtypes. This will allow:
<p class="Pp"><span class="Li"></span></p>
<pre>
    subtype Tree() =&gt; as HashRef[Str|Tree];
</pre>
<p class="Pp">Which validates things like:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    {key=&gt;'value'};
    {key=&gt;{subkey1=&gt;'value', subkey2=&gt;'value'}}
</pre>
<p class="Pp">And so on. This feature is new and there may be lurking bugs so
    don't be afraid to hunt me down with patches and test cases if you have
    trouble.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="NOTES_REGARDING_TYPE_UNIONS"><a class="permalink" href="#NOTES_REGARDING_TYPE_UNIONS">NOTES
  REGARDING TYPE UNIONS</a></h1>
MooseX::Types uses MooseX::Types::TypeDecorator to do some overloading which
  generally allows you to easily create union types:
<p class="Pp"><span class="Li"></span></p>
<pre>
  subtype StrOrArrayRef,
      as Str|ArrayRef;
</pre>
<p class="Pp">As with parameterized constraints, this overloading extends to
    modules using the types you define in a type library.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  use Moose;
  use MooseX::Types::Moose qw(HashRef Int);

  has 'attr' =&gt; ( isa =&gt; HashRef | Int );
</pre>
<p class="Pp">And everything should just work as you'd think.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="METHODS"><a class="permalink" href="#METHODS">METHODS</a></h1>
<section class="Ss">
<h2 class="Ss" id="import"><a class="permalink" href="#import">import</a></h2>
Installs the MooseX::Types::Base class into the caller and exports types
  according to the specification described in &quot;LIBRARY DEFINITION&quot;.
  This will continue to Moose::Util::TypeConstraints'
  <span class="Li">&quot;import&quot;</span> method to export helper functions
  you will need to declare your types.
</section>
<section class="Ss">
<h2 class="Ss" id="type_export_generator"><a class="permalink" href="#type_export_generator">type_export_generator</a></h2>
Generate a type export, e.g. <span class="Li">&quot;Int()&quot;</span>. This
  will return either a Moose::Meta::TypeConstraint object, or alternatively a
  MooseX::Types::UndefinedType object if the type was not yet defined.
</section>
<section class="Ss">
<h2 class="Ss" id="create_arged_type_constraint_($name,_@args)"><a class="permalink" href="#create_arged_type_constraint_($name,_@args)">create_arged_type_constraint
  ($name, @args)</a></h2>
Given a String <span class="Li">$name</span> with <span class="Li">@args</span>
  find the matching type constraint and parameterize it with
  <span class="Li">@args</span>.
</section>
<section class="Ss">
<h2 class="Ss" id="create_base_type_constraint_($name)"><a class="permalink" href="#create_base_type_constraint_($name)">create_base_type_constraint
  ($name)</a></h2>
Given a String <span class="Li">$name</span>, find the matching type constraint.
</section>
<section class="Ss">
<h2 class="Ss" id="create_type_decorator_($type_constraint)"><a class="permalink" href="#create_type_decorator_($type_constraint)">create_type_decorator
  ($type_constraint)</a></h2>
Given a <span class="Li">$type_constraint</span>, return a lightweight
  MooseX::Types::TypeDecorator instance.
</section>
<section class="Ss">
<h2 class="Ss" id="coercion_export_generator"><a class="permalink" href="#coercion_export_generator">coercion_export_generator</a></h2>
This generates a coercion handler function, e.g.
  <span class="Li">&quot;to_Int($value)&quot;</span>.
</section>
<section class="Ss">
<h2 class="Ss" id="check_export_generator"><a class="permalink" href="#check_export_generator">check_export_generator</a></h2>
Generates a constraint check closure, e.g.
  <span class="Li">&quot;is_Int($value)&quot;</span>.
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="CAVEATS"><a class="permalink" href="#CAVEATS">CAVEATS</a></h1>
The following are lists of gotchas and their workarounds for developers coming
  from the standard string based type constraint names
<section class="Ss">
<h2 class="Ss" id="Uniqueness"><a class="permalink" href="#Uniqueness">Uniqueness</a></h2>
A library makes the types quasi-unique by prefixing their names with (by
  default) the library package name. If you're only using the type handler
  functions provided by MooseX::Types, you shouldn't ever have to use a type's
  actual full name.
</section>
<section class="Ss">
<h2 class="Ss" id="Argument_separation_('=_'_versus_',')"><a class="permalink" href="#Argument_separation_('=_'_versus_',')">Argument
  separation ('=&gt;' versus ',')</a></h2>
The perlop manpage has this to say about the '=&gt;' operator: &quot;The =&gt;
  operator is a synonym for the comma, but forces any word (consisting entirely
  of word characters) to its left to be interpreted as a string (as of 5.001).
  This includes words that might otherwise be considered a constant or function
  call.&quot;
<p class="Pp">Due to this stringification, the following will NOT work as you
    might think:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  subtype StrOrArrayRef =&gt; as Str | ArrayRef;
</pre>
<p class="Pp">The <span class="Li">&quot;StrOrArrayRef&quot;</span> type will
    have its stringification activated -- this causes the subtype to not be
    created. Since the bareword type constraints are not strings you really
    should not try to treat them that way. You will have to use the ',' operator
    instead. The authors of this package realize that all the Moose
    documentation and examples nearly uniformly use the '=&gt;' version of the
    comma operator and this could be an issue if you are converting code.</p>
<p class="Pp">Patches welcome for discussion.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Compatibility_with_Sub::Exporter"><a class="permalink" href="#Compatibility_with_Sub::Exporter">Compatibility
  with Sub::Exporter</a></h2>
If you want to use Sub::Exporter with a Type Library, you need to make sure you
  export all the type constraints declared AS WELL AS any additional export
  targets. For example if you do:
<p class="Pp"><span class="Li"></span></p>
<pre>
  package TypeAndSubExporter;

  use MooseX::Types::Moose qw(Str);
  use MooseX::Types -declare =&gt; [qw(MyStr)];
  use Sub::Exporter -setup =&gt; { exports =&gt; [qw(something)] };

  subtype MyStr, as Str;

  sub something {
      return 1;
  }

  # then in another module ...

  package Foo;
  use TypeAndSubExporter qw(MyStr);
</pre>
<p class="Pp">You'll get a <span class="Li">&quot;&quot;MyStr&quot; is not
    exported by the TypeAndSubExporter module&quot;</span> error. It can be
    worked around by:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  - use Sub::Exporter -setup =&gt; { exports =&gt; [ qw(something) ] };
  + use Sub::Exporter -setup =&gt; { exports =&gt; [ qw(something MyStr) ] };
</pre>
<p class="Pp">This is a workaround and I am exploring how to make these modules
    work better together. I realize this workaround will lead a lot of
    duplication in your export declarations and will be onerous for large type
    libraries. Patches and detailed test cases welcome. See the tests directory
    for a start on this.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="COMBINING_TYPE_LIBRARIES"><a class="permalink" href="#COMBINING_TYPE_LIBRARIES">COMBINING
  TYPE LIBRARIES</a></h1>
You may want to combine a set of types for your application with other type
  libraries, like MooseX::Types::Moose or MooseX::Types::Common::String.
<p class="Pp">The MooseX::Types::Combine module provides a simple API for
    combining a set of type libraries together.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
Moose, Moose::Util::TypeConstraints, MooseX::Types::Moose, Sub::Exporter
</section>
<section class="Sh">
<h1 class="Sh" id="ACKNOWLEDGEMENTS"><a class="permalink" href="#ACKNOWLEDGEMENTS">ACKNOWLEDGEMENTS</a></h1>
Many thanks to the <span class="Li">&quot;#moose&quot;</span> cabal on
  <span class="Li">&quot;irc.perl.org&quot;</span>.
</section>
<section class="Sh">
<h1 class="Sh" id="SUPPORT"><a class="permalink" href="#SUPPORT">SUPPORT</a></h1>
Bugs may be submitted through the RT bug tracker
  &lt;https://rt.cpan.org/Public/Dist/Display.html?Name=MooseX-Types&gt; (or
  bug-MooseX-Types@rt.cpan.org &lt;mailto:bug-MooseX-Types@rt.cpan.org&gt;).
<p class="Pp">There is also a mailing list available for users of this
    distribution, at &lt;http://lists.perl.org/list/moose.html&gt;.</p>
<p class="Pp">There is also an irc channel available for users of this
    distribution, at <span class="Li">&quot;#moose&quot;</span> on
    <span class="Li">&quot;irc.perl.org&quot;</span>
    &lt;irc://irc.perl.org/#moose&gt;.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
Robert &quot;phaylon&quot; Sedlacek &lt;rs@474.at&gt;
</section>
<section class="Sh">
<h1 class="Sh" id="CONTRIBUTORS"><a class="permalink" href="#CONTRIBUTORS">CONTRIBUTORS</a></h1>
<ul class="Bl-bullet">
  <li>Karen Etheridge &lt;ether@cpan.org&gt;</li>
  <li>Dave Rolsky &lt;autarch@urth.org&gt;</li>
  <li>John Napiorkowski &lt;jjnapiork@cpan.org&gt;</li>
  <li>Robert 'phaylon' Sedlacek &lt;phaylon@cpan.org&gt;</li>
  <li>Rafael Kitover &lt;rkitover@cpan.org&gt;</li>
  <li>Florian Ragwitz &lt;rafl@debian.org&gt;</li>
  <li>Matt S Trout &lt;mst@shadowcat.co.uk&gt;</li>
  <li>Tomas Doran (t0m) &lt;bobtfish@bobtfish.net&gt;</li>
  <li>Jesse Luehrs &lt;doy@tozt.net&gt;</li>
  <li>Mark Fowler &lt;mark@twoshortplanks.com&gt;</li>
  <li>Hans Dieter Pearcey &lt;hdp@weftsoar.net&gt;</li>
  <li>Graham Knop &lt;haarg@haarg.org&gt;</li>
  <li>Paul Fenwick &lt;pjf@perltraining.com.au&gt;</li>
  <li>Kent Fredric &lt;kentfredric@gmail.com&gt;</li>
  <li>Justin Hunter &lt;justin.d.hunter@gmail.com&gt;</li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT_AND_LICENCE"><a class="permalink" href="#COPYRIGHT_AND_LICENCE">COPYRIGHT
  AND LICENCE</a></h1>
This software is copyright (c) 2007 by Robert &quot;phaylon&quot; Sedlacek.
<p class="Pp">This is free software; you can redistribute it and/or modify it
    under the same terms as the Perl 5 programming language system itself.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2017-02-07</td>
    <td class="foot-os">perl v5.28.2</td>
  </tr>
</table>
</body>
</html>
