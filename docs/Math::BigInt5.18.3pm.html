<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>Math::BigInt(3pm)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Math::BigInt(3pm)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">Math::BigInt(3pm)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
Math::BigInt - Arbitrary size integer/float math package
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<span class="Li"></span>
<pre>
  use Math::BigInt;

  # or make it faster with huge numbers: install (optional)
  # Math::BigInt::GMP and always use (it will fall back to
  # pure Perl if the GMP library is not installed):
  # (See also the L&lt;MATH LIBRARY&gt; section!)

  # will warn if Math::BigInt::GMP cannot be found
  use Math::BigInt lib =&gt; 'GMP';

  # to suppress the warning use this:
  # use Math::BigInt try =&gt; 'GMP';

  # dies if GMP cannot be loaded:
  # use Math::BigInt only =&gt; 'GMP';

  my $str = '1234567890';
  my @values = (64,74,18);
  my $n = 1; my $sign = '-';

  # Number creation     
  my $x = Math::BigInt-&gt;new($str);      # defaults to 0
  my $y = $x-&gt;copy();                   # make a true copy
  my $nan  = Math::BigInt-&gt;bnan();      # create a NotANumber
  my $zero = Math::BigInt-&gt;bzero();     # create a +0
  my $inf = Math::BigInt-&gt;binf();       # create a +inf
  my $inf = Math::BigInt-&gt;binf('-');    # create a -inf
  my $one = Math::BigInt-&gt;bone();       # create a +1
  my $mone = Math::BigInt-&gt;bone('-');   # create a -1

  my $pi = Math::BigInt-&gt;bpi();         # returns '3'
                                        # see Math::BigFloat::bpi()

  $h = Math::BigInt-&gt;new('0x123');      # from hexadecimal
  $b = Math::BigInt-&gt;new('0b101');      # from binary
  $o = Math::BigInt-&gt;from_oct('0101');  # from octal

  # Testing (don't modify their arguments)
  # (return true if the condition is met, otherwise false)

  $x-&gt;is_zero();        # if $x is +0
  $x-&gt;is_nan();         # if $x is NaN
  $x-&gt;is_one();         # if $x is +1
  $x-&gt;is_one('-');      # if $x is -1
  $x-&gt;is_odd();         # if $x is odd
  $x-&gt;is_even();        # if $x is even
  $x-&gt;is_pos();         # if $x &gt; 0
  $x-&gt;is_neg();         # if $x &lt; 0
  $x-&gt;is_inf($sign);    # if $x is +inf, or -inf (sign is default '+')
  $x-&gt;is_int();         # if $x is an integer (not a float)

  # comparing and digit/sign extraction
  $x-&gt;bcmp($y);         # compare numbers (undef,&lt;0,=0,&gt;0)
  $x-&gt;bacmp($y);        # compare absolutely (undef,&lt;0,=0,&gt;0)
  $x-&gt;sign();           # return the sign, either +,- or NaN
  $x-&gt;digit($n);        # return the nth digit, counting from right
  $x-&gt;digit(-$n);       # return the nth digit, counting from left

  # The following all modify their first argument. If you want to pre-
  # serve $x, use $z = $x-&gt;copy()-&gt;bXXX($y); See under L&lt;CAVEATS&gt; for
  # why this is necessary when mixing $a = $b assignments with non-over-
  # loaded math.

  $x-&gt;bzero();          # set $x to 0
  $x-&gt;bnan();           # set $x to NaN
  $x-&gt;bone();           # set $x to +1
  $x-&gt;bone('-');        # set $x to -1
  $x-&gt;binf();           # set $x to inf
  $x-&gt;binf('-');        # set $x to -inf

  $x-&gt;bneg();           # negation
  $x-&gt;babs();           # absolute value
  $x-&gt;bsgn();           # sign function (-1, 0, 1, or NaN)
  $x-&gt;bnorm();          # normalize (no-op in BigInt)
  $x-&gt;bnot();           # two's complement (bit wise not)
  $x-&gt;binc();           # increment $x by 1
  $x-&gt;bdec();           # decrement $x by 1

  $x-&gt;badd($y);         # addition (add $y to $x)
  $x-&gt;bsub($y);         # subtraction (subtract $y from $x)
  $x-&gt;bmul($y);         # multiplication (multiply $x by $y)
  $x-&gt;bdiv($y);         # divide, set $x to quotient
                        # return (quo,rem) or quo if scalar

  $x-&gt;bmuladd($y,$z);   # $x = $x * $y + $z

  $x-&gt;bmod($y);            # modulus (x % y)
  $x-&gt;bmodpow($y,$mod);    # modular exponentiation (($x ** $y) % $mod)
  $x-&gt;bmodinv($mod);       # modular multiplicative inverse
  $x-&gt;bpow($y);            # power of arguments (x ** y)
  $x-&gt;blsft($y);           # left shift in base 2
  $x-&gt;brsft($y);           # right shift in base 2
                           # returns (quo,rem) or quo if in sca-
                           # lar context
  $x-&gt;blsft($y,$n);        # left shift by $y places in base $n
  $x-&gt;brsft($y,$n);        # right shift by $y places in base $n
                           # returns (quo,rem) or quo if in sca-
                           # lar context

  $x-&gt;band($y);            # bitwise and
  $x-&gt;bior($y);            # bitwise inclusive or
  $x-&gt;bxor($y);            # bitwise exclusive or
  $x-&gt;bnot();              # bitwise not (two's complement)

  $x-&gt;bsqrt();             # calculate square-root
  $x-&gt;broot($y);           # $y'th root of $x (e.g. $y == 3 =&gt; cubic root)
  $x-&gt;bfac();              # factorial of $x (1*2*3*4*..$x)

  $x-&gt;bnok($y);            # x over y (binomial coefficient n over k)

  $x-&gt;blog();              # logarithm of $x to base e (Euler's number)
  $x-&gt;blog($base);         # logarithm of $x to base $base (f.i. 2)
  $x-&gt;bexp();              # calculate e ** $x where e is Euler's number

  $x-&gt;round($A,$P,$mode);  # round to accuracy or precision using
                           # mode $mode
  $x-&gt;bround($n);          # accuracy: preserve $n digits
  $x-&gt;bfround($n);         # $n &gt; 0: round $nth digits,
                           # $n &lt; 0: round to the $nth digit after the
                           # dot, no-op for BigInts

  # The following do not modify their arguments in BigInt (are no-ops),
  # but do so in BigFloat:

  $x-&gt;bfloor();            # return integer less or equal than $x
  $x-&gt;bceil();             # return integer greater or equal than $x

  # The following do not modify their arguments:

  # greatest common divisor (no OO style)
  my $gcd = Math::BigInt::bgcd(@values);
  # lowest common multiple (no OO style)
  my $lcm = Math::BigInt::blcm(@values);

  $x-&gt;length();            # return number of digits in number
  ($xl,$f) = $x-&gt;length(); # length of number and length of fraction
                           # part, latter is always 0 digits long
                           # for BigInts

  $x-&gt;exponent();         # return exponent as BigInt
  $x-&gt;mantissa();         # return (signed) mantissa as BigInt
  $x-&gt;parts();            # return (mantissa,exponent) as BigInt
  $x-&gt;copy();             # make a true copy of $x (unlike $y = $x;)
  $x-&gt;as_int();           # return as BigInt (in BigInt: same as copy())
  $x-&gt;numify();           # return as scalar (might overflow!)

  # conversion to string (do not modify their argument)
  $x-&gt;bstr();         # normalized string (e.g. '3')
  $x-&gt;bsstr();        # norm. string in scientific notation (e.g. '3E0')
  $x-&gt;as_hex();       # as signed hexadecimal string with prefixed 0x
  $x-&gt;as_bin();       # as signed binary string with prefixed 0b
  $x-&gt;as_oct();       # as signed octal string with prefixed 0


  # precision and accuracy (see section about rounding for more)
  $x-&gt;precision();       # return P of $x (or global, if P of $x undef)
  $x-&gt;precision($n);     # set P of $x to $n
  $x-&gt;accuracy();        # return A of $x (or global, if A of $x undef)
  $x-&gt;accuracy($n);      # set A $x to $n

  # Global methods
  Math::BigInt-&gt;precision();   # get/set global P for all BigInt objects
  Math::BigInt-&gt;accuracy();    # get/set global A for all BigInt objects
  Math::BigInt-&gt;round_mode();  # get/set global round mode, one of
                               # 'even', 'odd', '+inf', '-inf', 'zero',
                               # 'trunc' or 'common'
  Math::BigInt-&gt;config();      # return hash containing configuration
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
All operators (including basic math operations) are overloaded if you declare
  your big integers as
<p class="Pp"><span class="Li"></span></p>
<pre>
  $i = new Math::BigInt '123_456_789_123_456_789';
</pre>
<p class="Pp">Operations with overloaded operators preserve the arguments which
    is exactly what you expect.</p>
<dl class="Bl-tag">
  <dt>Input</dt>
  <dd>Input values to these routines may be any string, that looks like a number
      and results in an integer, including hexadecimal and binary numbers.
    <p class="Pp">Scalars holding numbers may also be passed, but note that
        non-integer numbers may already have lost precision due to the
        conversion to float. Quote your input if you want BigInt to see all the
        digits:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        $x = Math::BigInt-&gt;new(12345678890123456789);   # bad
        $x = Math::BigInt-&gt;new('12345678901234567890'); # good
    </pre>
    <p class="Pp">You can include one underscore between any two digits.</p>
    <p class="Pp">This means integer values like 1.01E2 or even 1000E-2 are also
        accepted. Non-integer values result in NaN.</p>
    <p class="Pp">Hexadecimal (prefixed with &quot;0x&quot;) and binary numbers
        (prefixed with &quot;0b&quot;) are accepted, too. Please note that octal
        numbers are not recognized by <i>new()</i>, so the following will print
        &quot;123&quot;:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        perl -MMath::BigInt -le 'print Math::BigInt-&gt;new(&quot;0123&quot;)'
    </pre>
    <p class="Pp">To convert an octal number, use <i>from_oct()</i>;</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        perl -MMath::BigInt -le 'print Math::BigInt-&gt;from_oct(&quot;0123&quot;)'
    </pre>
    <p class="Pp">Currently, <i>Math::BigInt::new()</i> defaults to 0, while
        Math::BigInt::new('') results in 'NaN'. This might change in the future,
        so use always the following explicit forms to get a zero or NaN:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        $zero = Math::BigInt-&gt;bzero();
        $nan = Math::BigInt-&gt;bnan();
    </pre>
    <p class="Pp"><span class="Li">&quot;bnorm()&quot;</span> on a BigInt object
        is now effectively a no-op, since the numbers are always stored in
        normalized form. If passed a string, creates a BigInt object from the
        input.</p>
  </dd>
  <dt>Output</dt>
  <dd>Output values are BigInt objects (normalized), except for the methods
      which return a string (see &quot;SYNOPSIS&quot;).
    <p class="Pp">Some routines (<span class="Li">&quot;is_odd()&quot;</span>,
        <span class="Li">&quot;is_even()&quot;</span>,
        <span class="Li">&quot;is_zero()&quot;</span>,
        <span class="Li">&quot;is_one()&quot;</span>,
        <span class="Li">&quot;is_nan()&quot;</span>, etc.) return true or
        false, while others (<span class="Li">&quot;bcmp()&quot;</span>,
        <span class="Li">&quot;bacmp()&quot;</span>) return either undef (if NaN
        is involved), &lt;0, 0 or &gt;0 and are suited for sort.</p>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="METHODS"><a class="permalink" href="#METHODS">METHODS</a></h1>
Each of the methods below (except <i>config()</i>, <i>accuracy()</i> and
  <i>precision()</i>) accepts three additional parameters. These arguments
  <span class="Li">$A</span>, <span class="Li">$P</span> and
  <span class="Li">$R</span> are <span class="Li">&quot;accuracy&quot;</span>,
  <span class="Li">&quot;precision&quot;</span> and
  <span class="Li">&quot;round_mode&quot;</span>. Please see the section about
  &quot;ACCURACY and PRECISION&quot; for more information.
<section class="Ss">
<h2 class="Ss" id="_fIconfig()_fP"><a class="permalink" href="#_fIconfig()_fP"><i>config()</i></a></h2>
<span class="Li"></span>
<pre>
        use Data::Dumper;

        print Dumper ( Math::BigInt-&gt;config() );
        print Math::BigInt-&gt;config()-&gt;{lib},&quot;\n&quot;;
</pre>
<p class="Pp">Returns a hash containing the configuration, e.g. the version
    number, lib loaded etc. The following hash keys are currently filled in with
    the appropriate information.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
        key           Description
                      Example
        ============================================================
        lib           Name of the low-level math library
                      Math::BigInt::Calc
        lib_version   Version of low-level math library (see 'lib')
                      0.30
        class         The class name of config() you just called
                      Math::BigInt
        upgrade       To which class math operations might be upgraded
                      Math::BigFloat
        downgrade     To which class math operations might be downgraded
                      undef
        precision     Global precision
                      undef
        accuracy      Global accuracy
                      undef
        round_mode    Global round mode
                      even
        version       version number of the class you used
                      1.61
        div_scale     Fallback accuracy for div
                      40
        trap_nan      If true, traps creation of NaN via croak()
                      1
        trap_inf      If true, traps creation of +inf/-inf via croak()
                      1
</pre>
<p class="Pp">The following values can be set by passing
    <span class="Li">&quot;config()&quot;</span> a reference to a hash:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
        trap_inf trap_nan
        upgrade downgrade precision accuracy round_mode div_scale
</pre>
<p class="Pp">Example:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
        $new_cfg = Math::BigInt-&gt;config(
            { trap_inf =&gt; 1, precision =&gt; 5 }
        );
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="_fIaccuracy()_fP"><a class="permalink" href="#_fIaccuracy()_fP"><i>accuracy()</i></a></h2>
<span class="Li"></span>
<pre>
    $x-&gt;accuracy(5);         # local for $x
    CLASS-&gt;accuracy(5);      # global for all members of CLASS
                             # Note: This also applies to new()!

    $A = $x-&gt;accuracy();     # read out accuracy that affects $x
    $A = CLASS-&gt;accuracy();  # read out global accuracy
</pre>
<p class="Pp">Set or get the global or local accuracy, aka how many significant
    digits the results have. If you set a global accuracy, then this also
    applies to <i>new()</i>!</p>
<p class="Pp">Warning! The accuracy <i>sticks</i>, e.g. once you created a
    number under the influence of
    <span class="Li">&quot;CLASS-&gt;accuracy($A)&quot;</span>, all results from
    math operations with that number will also be rounded.</p>
<p class="Pp">In most cases, you should probably round the results explicitly
    using one of &quot;<i>round()</i>&quot;, &quot;<i>bround()</i>&quot; or
    &quot;<i>bfround()</i>&quot; or by passing the desired accuracy to the math
    operation as additional parameter:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    my $x = Math::BigInt-&gt;new(30000);
    my $y = Math::BigInt-&gt;new(7);
    print scalar $x-&gt;copy()-&gt;bdiv($y, 2);               # print 4300
    print scalar $x-&gt;copy()-&gt;bdiv($y)-&gt;bround(2);       # print 4300
</pre>
<p class="Pp">Please see the section about &quot;ACCURACY and PRECISION&quot;
    for further details.</p>
<p class="Pp">Value must be greater than zero. Pass an undef value to disable
    it:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    $x-&gt;accuracy(undef);
    Math::BigInt-&gt;accuracy(undef);
</pre>
<p class="Pp">Returns the current accuracy. For
    <span class="Li">&quot;$x-&gt;accuracy()&quot;</span> it will return either
    the local accuracy, or if not defined, the global. This means the return
    value represents the accuracy that will be in effect for
    <span class="Li">$x:</span></p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    $y = Math::BigInt-&gt;new(1234567);       # unrounded
    print Math::BigInt-&gt;accuracy(4),&quot;\n&quot;;  # set 4, print 4
    $x = Math::BigInt-&gt;new(123456);        # $x will be automatic-
                                           # ally rounded!
    print &quot;$x $y\n&quot;;                       # '123500 1234567'
    print $x-&gt;accuracy(),&quot;\n&quot;;             # will be 4
    print $y-&gt;accuracy(),&quot;\n&quot;;             # also 4, since global is 4
    print Math::BigInt-&gt;accuracy(5),&quot;\n&quot;;  # set to 5, print 5
    print $x-&gt;accuracy(),&quot;\n&quot;;             # still 4
    print $y-&gt;accuracy(),&quot;\n&quot;;             # 5, since global is 5
</pre>
<p class="Pp">Note: Works also for subclasses like Math::BigFloat. Each class
    has it's own globals separated from Math::BigInt, but it is possible to
    subclass Math::BigInt and make the globals of the subclass aliases to the
    ones from Math::BigInt.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_fIprecision()_fP"><a class="permalink" href="#_fIprecision()_fP"><i>precision()</i></a></h2>
<span class="Li"></span>
<pre>
    $x-&gt;precision(-2);          # local for $x, round at the second
                                # digit right of the dot
    $x-&gt;precision(2);           # ditto, round at the second digit left
                                # of the dot

    CLASS-&gt;precision(5);        # Global for all members of CLASS
                                # This also applies to new()!
    CLASS-&gt;precision(-5);       # ditto

    $P = CLASS-&gt;precision();    # read out global precision
    $P = $x-&gt;precision();       # read out precision that affects $x
</pre>
<p class="Pp">Note: You probably want to use &quot;<i>accuracy()</i>&quot;
    instead. With &quot;<i>accuracy()</i>&quot; you set the number of digits
    each result should have, with &quot;<i>precision()</i>&quot; you set the
    place where to round!</p>
<p class="Pp"><span class="Li">&quot;precision()&quot;</span> sets or gets the
    global or local precision, aka at which digit before or after the dot to
    round all results. A set global precision also applies to all newly created
    numbers!</p>
<p class="Pp">In Math::BigInt, passing a negative number precision has no effect
    since no numbers have digits after the dot. In Math::BigFloat, it will round
    all results to P digits after the dot.</p>
<p class="Pp">Please see the section about &quot;ACCURACY and PRECISION&quot;
    for further details.</p>
<p class="Pp">Pass an undef value to disable it:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    $x-&gt;precision(undef);
    Math::BigInt-&gt;precision(undef);
</pre>
<p class="Pp">Returns the current precision. For
    <span class="Li">&quot;$x-&gt;precision()&quot;</span> it will return either
    the local precision of <span class="Li">$x</span>, or if not defined, the
    global. This means the return value represents the prevision that will be in
    effect for <span class="Li">$x:</span></p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    $y = Math::BigInt-&gt;new(1234567);        # unrounded
    print Math::BigInt-&gt;precision(4),&quot;\n&quot;;  # set 4, print 4
    $x = Math::BigInt-&gt;new(123456);      # will be automatically rounded
    print $x;                               # print &quot;120000&quot;!
</pre>
<p class="Pp">Note: Works also for subclasses like Math::BigFloat. Each class
    has its own globals separated from Math::BigInt, but it is possible to
    subclass Math::BigInt and make the globals of the subclass aliases to the
    ones from Math::BigInt.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_fIbrsft()_fP"><a class="permalink" href="#_fIbrsft()_fP"><i>brsft()</i></a></h2>
<span class="Li"></span>
<pre>
        $x-&gt;brsft($y,$n);
</pre>
<p class="Pp">Shifts <span class="Li">$x</span> right by
    <span class="Li">$y</span> in base <span class="Li">$n</span>. Default is
    base 2, used are usually 10 and 2, but others work, too.</p>
<p class="Pp">Right shifting usually amounts to dividing
    <span class="Li">$x</span> by <span class="Li">$n</span> **
    <span class="Li">$y</span> and truncating the result:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
        $x = Math::BigInt-&gt;new(10);
        $x-&gt;brsft(1);                   # same as $x &gt;&gt; 1: 5
        $x = Math::BigInt-&gt;new(1234);
        $x-&gt;brsft(2,10);                # result 12
</pre>
<p class="Pp">There is one exception, and that is base 2 with negative
    <span class="Li">$x:</span></p>
<p class="Pp"><span class="Li"></span></p>
<pre>
        $x = Math::BigInt-&gt;new(-5);
        print $x-&gt;brsft(1);
</pre>
<p class="Pp">This will print -3, not -2 (as it would if you divide -5 by 2 and
    truncate the result).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_fInew()_fP"><a class="permalink" href="#_fInew()_fP"><i>new()</i></a></h2>
<span class="Li"></span>
<pre>
        $x = Math::BigInt-&gt;new($str,$A,$P,$R);
</pre>
<p class="Pp">Creates a new BigInt object from a scalar or another BigInt
    object. The input is accepted as decimal, hex (with leading '0x') or binary
    (with leading '0b').</p>
<p class="Pp">See &quot;Input&quot; for more info on accepted input formats.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_fIfrom_oct()_fP"><a class="permalink" href="#_fIfrom_oct()_fP"><i>from_oct()</i></a></h2>
<span class="Li"></span>
<pre>
        $x = Math::BigInt-&gt;from_oct(&quot;0775&quot;);    # input is octal
</pre>
<p class="Pp">Interpret the input as an octal string and return the
    corresponding value. A &quot;0&quot; (zero) prefix is optional. A single
    underscore character may be placed right after the prefix, if present, or
    between any two digits. If the input is invalid, a NaN is returned.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_fIfrom_hex()_fP"><a class="permalink" href="#_fIfrom_hex()_fP"><i>from_hex()</i></a></h2>
<span class="Li"></span>
<pre>
        $x = Math::BigInt-&gt;from_hex(&quot;0xcafe&quot;);  # input is hexadecimal
</pre>
<p class="Pp">Interpret input as a hexadecimal string. A &quot;0x&quot; or
    &quot;x&quot; prefix is optional. A single underscore character may be
    placed right after the prefix, if present, or between any two digits. If the
    input is invalid, a NaN is returned.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_fIfrom_bin()_fP"><a class="permalink" href="#_fIfrom_bin()_fP"><i>from_bin()</i></a></h2>
<span class="Li"></span>
<pre>
        $x = Math::BigInt-&gt;from_bin(&quot;0b10011&quot;); # input is binary
</pre>
<p class="Pp">Interpret the input as a binary string. A &quot;0b&quot; or
    &quot;b&quot; prefix is optional. A single underscore character may be
    placed right after the prefix, if present, or between any two digits. If the
    input is invalid, a NaN is returned.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_fIbnan()_fP"><a class="permalink" href="#_fIbnan()_fP"><i>bnan()</i></a></h2>
<span class="Li"></span>
<pre>
        $x = Math::BigInt-&gt;bnan();
</pre>
<p class="Pp">Creates a new BigInt object representing NaN (Not A Number). If
    used on an object, it will set it to NaN:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
        $x-&gt;bnan();
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="_fIbzero()_fP"><a class="permalink" href="#_fIbzero()_fP"><i>bzero()</i></a></h2>
<span class="Li"></span>
<pre>
        $x = Math::BigInt-&gt;bzero();
</pre>
<p class="Pp">Creates a new BigInt object representing zero. If used on an
    object, it will set it to zero:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
        $x-&gt;bzero();
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="_fIbinf()_fP"><a class="permalink" href="#_fIbinf()_fP"><i>binf()</i></a></h2>
<span class="Li"></span>
<pre>
        $x = Math::BigInt-&gt;binf($sign);
</pre>
<p class="Pp">Creates a new BigInt object representing infinity. The optional
    argument is either '-' or '+', indicating whether you want infinity or minus
    infinity. If used on an object, it will set it to infinity:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
        $x-&gt;binf();
        $x-&gt;binf('-');
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="_fIbone()_fP"><a class="permalink" href="#_fIbone()_fP"><i>bone()</i></a></h2>
<span class="Li"></span>
<pre>
        $x = Math::BigInt-&gt;binf($sign);
</pre>
<p class="Pp">Creates a new BigInt object representing one. The optional
    argument is either '-' or '+', indicating whether you want one or minus one.
    If used on an object, it will set it to one:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
        $x-&gt;bone();             # +1
        $x-&gt;bone('-');          # -1
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="_fIis_one()_fP/_fIis_zero()_fP/_fIis_nan()_fP/_fIis_inf()_fP"><a class="permalink" href="#_fIis_one()_fP/_fIis_zero()_fP/_fIis_nan()_fP/_fIis_inf()_fP"><i>is_one()</i>/<i>is_zero()</i>/<i>is_nan()</i>/<i>is_inf()</i></a></h2>
<span class="Li"></span>
<pre>
        $x-&gt;is_zero();          # true if arg is +0
        $x-&gt;is_nan();           # true if arg is NaN
        $x-&gt;is_one();           # true if arg is +1
        $x-&gt;is_one('-');        # true if arg is -1
        $x-&gt;is_inf();           # true if +inf
        $x-&gt;is_inf('-');        # true if -inf (sign is default '+')
</pre>
<p class="Pp">These methods all test the BigInt for being one specific value and
    return true or false depending on the input. These are faster than doing
    something like:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
        if ($x == 0)
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="_fIis_pos()_fP/_fIis_neg()_fP/_fIis_positive()_fP/_fIis_negative()_fP"><a class="permalink" href="#_fIis_pos()_fP/_fIis_neg()_fP/_fIis_positive()_fP/_fIis_negative()_fP"><i>is_pos()</i>/<i>is_neg()</i>/<i>is_positive()</i>/<i>is_negative()</i></a></h2>
<span class="Li"></span>
<pre>
        $x-&gt;is_pos();                   # true if &gt; 0
        $x-&gt;is_neg();                   # true if &lt; 0
</pre>
<p class="Pp">The methods return true if the argument is positive or negative,
    respectively. <span class="Li">&quot;NaN&quot;</span> is neither positive
    nor negative, while <span class="Li">&quot;+inf&quot;</span> counts as
    positive, and <span class="Li">&quot;-inf&quot;</span> is negative. A
    <span class="Li">&quot;zero&quot;</span> is neither positive nor
  negative.</p>
<p class="Pp">These methods are only testing the sign, and not the value.</p>
<p class="Pp"><span class="Li">&quot;is_positive()&quot;</span> and
    <span class="Li">&quot;is_negative()&quot;</span> are aliases to
    <span class="Li">&quot;is_pos()&quot;</span> and
    <span class="Li">&quot;is_neg()&quot;</span>, respectively.
    <span class="Li">&quot;is_positive()&quot;</span> and
    <span class="Li">&quot;is_negative()&quot;</span> were introduced in v1.36,
    while <span class="Li">&quot;is_pos()&quot;</span> and
    <span class="Li">&quot;is_neg()&quot;</span> were only introduced in
  v1.68.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_fIis_odd()_fP/_fIis_even()_fP/_fIis_int()_fP"><a class="permalink" href="#_fIis_odd()_fP/_fIis_even()_fP/_fIis_int()_fP"><i>is_odd()</i>/<i>is_even()</i>/<i>is_int()</i></a></h2>
<span class="Li"></span>
<pre>
        $x-&gt;is_odd();                   # true if odd, false for even
        $x-&gt;is_even();                  # true if even, false for odd
        $x-&gt;is_int();                   # true if $x is an integer
</pre>
<p class="Pp">The return true when the argument satisfies the condition.
    <span class="Li">&quot;NaN&quot;</span>,
    <span class="Li">&quot;+inf&quot;</span>,
    <span class="Li">&quot;-inf&quot;</span> are not integers and are neither
    odd nor even.</p>
<p class="Pp">In BigInt, all numbers except
    <span class="Li">&quot;NaN&quot;</span>,
    <span class="Li">&quot;+inf&quot;</span> and
    <span class="Li">&quot;-inf&quot;</span> are integers.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_fIbcmp()_fP"><a class="permalink" href="#_fIbcmp()_fP"><i>bcmp()</i></a></h2>
<span class="Li"></span>
<pre>
        $x-&gt;bcmp($y);
</pre>
<p class="Pp">Compares <span class="Li">$x</span> with
    <span class="Li">$y</span> and takes the sign into account. Returns -1, 0, 1
    or undef.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_fIbacmp()_fP"><a class="permalink" href="#_fIbacmp()_fP"><i>bacmp()</i></a></h2>
<span class="Li"></span>
<pre>
        $x-&gt;bacmp($y);
</pre>
<p class="Pp">Compares <span class="Li">$x</span> with
    <span class="Li">$y</span> while ignoring their sign. Returns -1, 0, 1 or
    undef.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_fIsign()_fP"><a class="permalink" href="#_fIsign()_fP"><i>sign()</i></a></h2>
<span class="Li"></span>
<pre>
        $x-&gt;sign();
</pre>
<p class="Pp">Return the sign, of <span class="Li">$x</span>, meaning either
    <span class="Li">&quot;+&quot;</span>,
    <span class="Li">&quot;-&quot;</span>,
    <span class="Li">&quot;-inf&quot;</span>,
    <span class="Li">&quot;+inf&quot;</span> or NaN.</p>
<p class="Pp">If you want <span class="Li">$x</span> to have a certain sign, use
    one of the following methods:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
        $x-&gt;babs();             # '+'
        $x-&gt;babs()-&gt;bneg();     # '-'
        $x-&gt;bnan();             # 'NaN'
        $x-&gt;binf();             # '+inf'
        $x-&gt;binf('-');          # '-inf'
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="_fIdigit()_fP"><a class="permalink" href="#_fIdigit()_fP"><i>digit()</i></a></h2>
<span class="Li"></span>
<pre>
        $x-&gt;digit($n);       # return the nth digit, counting from right
</pre>
<p class="Pp">If <span class="Li">$n</span> is negative, returns the digit
    counting from left.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_fIbneg()_fP"><a class="permalink" href="#_fIbneg()_fP"><i>bneg()</i></a></h2>
<span class="Li"></span>
<pre>
        $x-&gt;bneg();
</pre>
<p class="Pp">Negate the number, e.g. change the sign between '+' and '-', or
    between '+inf' and '-inf', respectively. Does nothing for NaN or zero.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_fIbabs()_fP"><a class="permalink" href="#_fIbabs()_fP"><i>babs()</i></a></h2>
<span class="Li"></span>
<pre>
        $x-&gt;babs();
</pre>
<p class="Pp">Set the number to its absolute value, e.g. change the sign from
    '-' to '+' and from '-inf' to '+inf', respectively. Does nothing for NaN or
    positive numbers.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_fIbsgn()_fP"><a class="permalink" href="#_fIbsgn()_fP"><i>bsgn()</i></a></h2>
<span class="Li"></span>
<pre>
        $x-&gt;bsgn();
</pre>
<p class="Pp">Signum function. Set the number to -1, 0, or 1, depending on
    whether the number is negative, zero, or positive, respectivly. Does not
    modify NaNs.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_fIbnorm()_fP"><a class="permalink" href="#_fIbnorm()_fP"><i>bnorm()</i></a></h2>
<span class="Li"></span>
<pre>
        $x-&gt;bnorm();                    # normalize (no-op)
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="_fIbnot()_fP"><a class="permalink" href="#_fIbnot()_fP"><i>bnot()</i></a></h2>
<span class="Li"></span>
<pre>
        $x-&gt;bnot();
</pre>
<p class="Pp">Two's complement (bitwise not). This is equivalent to</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
        $x-&gt;binc()-&gt;bneg();
</pre>
<p class="Pp">but faster.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_fIbinc()_fP"><a class="permalink" href="#_fIbinc()_fP"><i>binc()</i></a></h2>
<span class="Li"></span>
<pre>
        $x-&gt;binc();             # increment x by 1
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="_fIbdec()_fP"><a class="permalink" href="#_fIbdec()_fP"><i>bdec()</i></a></h2>
<span class="Li"></span>
<pre>
        $x-&gt;bdec();             # decrement x by 1
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="_fIbadd()_fP"><a class="permalink" href="#_fIbadd()_fP"><i>badd()</i></a></h2>
<span class="Li"></span>
<pre>
        $x-&gt;badd($y);           # addition (add $y to $x)
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="_fIbsub()_fP"><a class="permalink" href="#_fIbsub()_fP"><i>bsub()</i></a></h2>
<span class="Li"></span>
<pre>
        $x-&gt;bsub($y);           # subtraction (subtract $y from $x)
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="_fIbmul()_fP"><a class="permalink" href="#_fIbmul()_fP"><i>bmul()</i></a></h2>
<span class="Li"></span>
<pre>
        $x-&gt;bmul($y);           # multiplication (multiply $x by $y)
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="_fIbmuladd()_fP"><a class="permalink" href="#_fIbmuladd()_fP"><i>bmuladd()</i></a></h2>
<span class="Li"></span>
<pre>
        $x-&gt;bmuladd($y,$z);
</pre>
<p class="Pp">Multiply <span class="Li">$x</span> by <span class="Li">$y</span>,
    and then add <span class="Li">$z</span> to the result,</p>
<p class="Pp">This method was added in v1.87 of Math::BigInt (June 2007).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_fIbdiv()_fP"><a class="permalink" href="#_fIbdiv()_fP"><i>bdiv()</i></a></h2>
<span class="Li"></span>
<pre>
        $x-&gt;bdiv($y);           # divide, set $x to quotient
                                # return (quo,rem) or quo if scalar
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="_fIbmod()_fP"><a class="permalink" href="#_fIbmod()_fP"><i>bmod()</i></a></h2>
<span class="Li"></span>
<pre>
        $x-&gt;bmod($y);           # modulus (x % y)
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="_fIbmodinv()_fP"><a class="permalink" href="#_fIbmodinv()_fP"><i>bmodinv()</i></a></h2>
<span class="Li"></span>
<pre>
        $x-&gt;bmodinv($mod);      # modular multiplicative inverse
</pre>
<p class="Pp">Returns the multiplicative inverse of <span class="Li">$x</span>
    modulo <span class="Li">$mod</span>. If</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
        $y = $x -&gt; copy() -&gt; bmodinv($mod)
</pre>
<p class="Pp">then <span class="Li">$y</span> is the number closest to zero, and
    with the same sign as <span class="Li">$mod</span>, satisfying</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
        ($x * $y) % $mod = 1 % $mod
</pre>
<p class="Pp">If <span class="Li">$x</span> and <span class="Li">$y</span> are
    non-zero, they must be relative primes, i.e.,
    <span class="Li">&quot;bgcd($y, $mod)==1&quot;</span>.
    '<span class="Li">&quot;NaN&quot;</span>' is returned when no modular
    multiplicative inverse exists.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_fIbmodpow()_fP"><a class="permalink" href="#_fIbmodpow()_fP"><i>bmodpow()</i></a></h2>
<span class="Li"></span>
<pre>
        $num-&gt;bmodpow($exp,$mod);       # modular exponentiation
                                        # ($num**$exp % $mod)
</pre>
<p class="Pp">Returns the value of <span class="Li">$num</span> taken to the
    power <span class="Li">$exp</span> in the modulus
    <span class="Li">$mod</span> using binary exponentiation.
    <span class="Li">&quot;bmodpow&quot;</span> is far superior to writing</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
        $num ** $exp % $mod
</pre>
<p class="Pp">because it is much faster - it reduces internal variables into the
    modulus whenever possible, so it operates on smaller numbers.</p>
<p class="Pp"><span class="Li">&quot;bmodpow&quot;</span> also supports negative
    exponents.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
        bmodpow($num, -1, $mod)
</pre>
<p class="Pp">is exactly equivalent to</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
        bmodinv($num, $mod)
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="_fIbpow()_fP"><a class="permalink" href="#_fIbpow()_fP"><i>bpow()</i></a></h2>
<span class="Li"></span>
<pre>
        $x-&gt;bpow($y);                 # power of arguments (x ** y)
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="_fIblog()_fP"><a class="permalink" href="#_fIblog()_fP"><i>blog()</i></a></h2>
<span class="Li"></span>
<pre>
        $x-&gt;blog($base, $accuracy);   # logarithm of x to the base $base
</pre>
<p class="Pp">If <span class="Li">$base</span> is not defined, Euler's number
    (e) is used:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
        print $x-&gt;blog(undef, 100);   # log(x) to 100 digits
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="_fIbexp()_fP"><a class="permalink" href="#_fIbexp()_fP"><i>bexp()</i></a></h2>
<span class="Li"></span>
<pre>
        $x-&gt;bexp($accuracy);          # calculate e ** X
</pre>
<p class="Pp">Calculates the expression <span class="Li">&quot;e **
    $x&quot;</span> where <span class="Li">&quot;e&quot;</span> is Euler's
    number.</p>
<p class="Pp">This method was added in v1.82 of Math::BigInt (April 2007).</p>
<p class="Pp">See also &quot;<i>blog()</i>&quot;.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_fIbnok()_fP"><a class="permalink" href="#_fIbnok()_fP"><i>bnok()</i></a></h2>
<span class="Li"></span>
<pre>
        $x-&gt;bnok($y);        # x over y (binomial coefficient n over k)
</pre>
<p class="Pp">Calculates the binomial coefficient n over k, also called the
    &quot;choose&quot; function. The result is equivalent to:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
        ( n )      n!
        | - |  = -------
        ( k )    k!(n-k)!
</pre>
<p class="Pp">This method was added in v1.84 of Math::BigInt (April 2007).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_fIbpi()_fP"><a class="permalink" href="#_fIbpi()_fP"><i>bpi()</i></a></h2>
<span class="Li"></span>
<pre>
        print Math::BigInt-&gt;bpi(100), &quot;\n&quot;;             # 3
</pre>
<p class="Pp">Returns PI truncated to an integer, with the argument being
    ignored. This means under BigInt this always returns
    <span class="Li">3</span>.</p>
<p class="Pp">If upgrading is in effect, returns PI, rounded to N digits with
    the current rounding mode:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
        use Math::BigFloat;
        use Math::BigInt upgrade =&gt; Math::BigFloat;
        print Math::BigInt-&gt;bpi(3), &quot;\n&quot;;               # 3.14
        print Math::BigInt-&gt;bpi(100), &quot;\n&quot;;             # 3.1415....
</pre>
<p class="Pp">This method was added in v1.87 of Math::BigInt (June 2007).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_fIbcos()_fP"><a class="permalink" href="#_fIbcos()_fP"><i>bcos()</i></a></h2>
<span class="Li"></span>
<pre>
        my $x = Math::BigInt-&gt;new(1);
        print $x-&gt;bcos(100), &quot;\n&quot;;
</pre>
<p class="Pp">Calculate the cosinus of <span class="Li">$x</span>, modifying
    <span class="Li">$x</span> in place.</p>
<p class="Pp">In BigInt, unless upgrading is in effect, the result is truncated
    to an integer.</p>
<p class="Pp">This method was added in v1.87 of Math::BigInt (June 2007).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_fIbsin()_fP"><a class="permalink" href="#_fIbsin()_fP"><i>bsin()</i></a></h2>
<span class="Li"></span>
<pre>
        my $x = Math::BigInt-&gt;new(1);
        print $x-&gt;bsin(100), &quot;\n&quot;;
</pre>
<p class="Pp">Calculate the sinus of <span class="Li">$x</span>, modifying
    <span class="Li">$x</span> in place.</p>
<p class="Pp">In BigInt, unless upgrading is in effect, the result is truncated
    to an integer.</p>
<p class="Pp">This method was added in v1.87 of Math::BigInt (June 2007).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_fIbatan2()_fP"><a class="permalink" href="#_fIbatan2()_fP"><i>batan2()</i></a></h2>
<span class="Li"></span>
<pre>
        my $x = Math::BigInt-&gt;new(1);
        my $y = Math::BigInt-&gt;new(1);
        print $y-&gt;batan2($x), &quot;\n&quot;;
</pre>
<p class="Pp">Calculate the arcus tangens of <span class="Li">$y</span> divided
    by <span class="Li">$x</span>, modifying <span class="Li">$y</span> in
    place.</p>
<p class="Pp">In BigInt, unless upgrading is in effect, the result is truncated
    to an integer.</p>
<p class="Pp">This method was added in v1.87 of Math::BigInt (June 2007).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_fIbatan()_fP"><a class="permalink" href="#_fIbatan()_fP"><i>batan()</i></a></h2>
<span class="Li"></span>
<pre>
        my $x = Math::BigFloat-&gt;new(0.5);
        print $x-&gt;batan(100), &quot;\n&quot;;
</pre>
<p class="Pp">Calculate the arcus tangens of <span class="Li">$x</span>,
    modifying <span class="Li">$x</span> in place.</p>
<p class="Pp">In BigInt, unless upgrading is in effect, the result is truncated
    to an integer.</p>
<p class="Pp">This method was added in v1.87 of Math::BigInt (June 2007).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_fIblsft()_fP"><a class="permalink" href="#_fIblsft()_fP"><i>blsft()</i></a></h2>
<span class="Li"></span>
<pre>
        $x-&gt;blsft($y);          # left shift in base 2
        $x-&gt;blsft($y,$n);       # left shift, in base $n (like 10)
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="_fIbrsft()_fP_2"><a class="permalink" href="#_fIbrsft()_fP_2"><i>brsft()</i></a></h2>
<span class="Li"></span>
<pre>
        $x-&gt;brsft($y);          # right shift in base 2
        $x-&gt;brsft($y,$n);       # right shift, in base $n (like 10)
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="_fIband()_fP"><a class="permalink" href="#_fIband()_fP"><i>band()</i></a></h2>
<span class="Li"></span>
<pre>
        $x-&gt;band($y);                   # bitwise and
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="_fIbior()_fP"><a class="permalink" href="#_fIbior()_fP"><i>bior()</i></a></h2>
<span class="Li"></span>
<pre>
        $x-&gt;bior($y);                   # bitwise inclusive or
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="_fIbxor()_fP"><a class="permalink" href="#_fIbxor()_fP"><i>bxor()</i></a></h2>
<span class="Li"></span>
<pre>
        $x-&gt;bxor($y);                   # bitwise exclusive or
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="_fIbnot()_fP_2"><a class="permalink" href="#_fIbnot()_fP_2"><i>bnot()</i></a></h2>
<span class="Li"></span>
<pre>
        $x-&gt;bnot();                     # bitwise not (two's complement)
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="_fIbsqrt()_fP"><a class="permalink" href="#_fIbsqrt()_fP"><i>bsqrt()</i></a></h2>
<span class="Li"></span>
<pre>
        $x-&gt;bsqrt();                    # calculate square-root
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="_fIbroot()_fP"><a class="permalink" href="#_fIbroot()_fP"><i>broot()</i></a></h2>
<span class="Li"></span>
<pre>
        $x-&gt;broot($N);
</pre>
<p class="Pp">Calculates the N'th root of <span class="Li">$x</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_fIbfac()_fP"><a class="permalink" href="#_fIbfac()_fP"><i>bfac()</i></a></h2>
<span class="Li"></span>
<pre>
        $x-&gt;bfac();                     # factorial of $x (1*2*3*4*..$x)
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="_fIround()_fP"><a class="permalink" href="#_fIround()_fP"><i>round()</i></a></h2>
<span class="Li"></span>
<pre>
        $x-&gt;round($A,$P,$round_mode);
</pre>
<p class="Pp">Round <span class="Li">$x</span> to accuracy
    <span class="Li">$A</span> or precision <span class="Li">$P</span> using the
    round mode <span class="Li">$round_mode</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_fIbround()_fP"><a class="permalink" href="#_fIbround()_fP"><i>bround()</i></a></h2>
<span class="Li"></span>
<pre>
        $x-&gt;bround($N);               # accuracy: preserve $N digits
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="_fIbfround()_fP"><a class="permalink" href="#_fIbfround()_fP"><i>bfround()</i></a></h2>
<span class="Li"></span>
<pre>
        $x-&gt;bfround($N);
</pre>
<p class="Pp">If N is &gt; 0, rounds to the Nth digit from the left. If N &lt;
    0, rounds to the Nth digit after the dot. Since BigInts are integers, the
    case N &lt; 0 is a no-op for them.</p>
<p class="Pp">Examples:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
        Input           N               Result
        ===================================================
        123456.123456   3               123500
        123456.123456   2               123450
        123456.123456   -2              123456.12
        123456.123456   -3              123456.123
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="_fIbfloor()_fP"><a class="permalink" href="#_fIbfloor()_fP"><i>bfloor()</i></a></h2>
<span class="Li"></span>
<pre>
        $x-&gt;bfloor();
</pre>
<p class="Pp">Set <span class="Li">$x</span> to the integer less or equal than
    <span class="Li">$x</span>. This is a no-op in BigInt, but does change
    <span class="Li">$x</span> in BigFloat.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_fIbceil()_fP"><a class="permalink" href="#_fIbceil()_fP"><i>bceil()</i></a></h2>
<span class="Li"></span>
<pre>
        $x-&gt;bceil();
</pre>
<p class="Pp">Set <span class="Li">$x</span> to the integer greater or equal
    than <span class="Li">$x</span>. This is a no-op in BigInt, but does change
    <span class="Li">$x</span> in BigFloat.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_fIbgcd()_fP"><a class="permalink" href="#_fIbgcd()_fP"><i>bgcd()</i></a></h2>
<span class="Li"></span>
<pre>
        bgcd(@values);          # greatest common divisor (no OO style)
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="_fIblcm()_fP"><a class="permalink" href="#_fIblcm()_fP"><i>blcm()</i></a></h2>
<span class="Li"></span>
<pre>
        blcm(@values);          # lowest common multiple (no OO style)
</pre>
<p class="Pp">head2 <i>length()</i></p>
<p class="Pp"><span class="Li"></span></p>
<pre>
        $x-&gt;length();
        ($xl,$fl) = $x-&gt;length();
</pre>
<p class="Pp">Returns the number of digits in the decimal representation of the
    number. In list context, returns the length of the integer and fraction
    part. For BigInt's, the length of the fraction part will always be 0.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_fIexponent()_fP"><a class="permalink" href="#_fIexponent()_fP"><i>exponent()</i></a></h2>
<span class="Li"></span>
<pre>
        $x-&gt;exponent();
</pre>
<p class="Pp">Return the exponent of <span class="Li">$x</span> as BigInt.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_fImantissa()_fP"><a class="permalink" href="#_fImantissa()_fP"><i>mantissa()</i></a></h2>
<span class="Li"></span>
<pre>
        $x-&gt;mantissa();
</pre>
<p class="Pp">Return the signed mantissa of <span class="Li">$x</span> as
    BigInt.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_fIparts()_fP"><a class="permalink" href="#_fIparts()_fP"><i>parts()</i></a></h2>
<span class="Li"></span>
<pre>
        $x-&gt;parts();    # return (mantissa,exponent) as BigInt
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="_fIcopy()_fP"><a class="permalink" href="#_fIcopy()_fP"><i>copy()</i></a></h2>
<span class="Li"></span>
<pre>
        $x-&gt;copy();     # make a true copy of $x (unlike $y = $x;)
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="_fIas_int()_fP/_fIas_number()_fP"><a class="permalink" href="#_fIas_int()_fP/_fIas_number()_fP"><i>as_int()</i>/<i>as_number()</i></a></h2>
<span class="Li"></span>
<pre>
        $x-&gt;as_int();
</pre>
<p class="Pp">Returns <span class="Li">$x</span> as a BigInt (truncated towards
    zero). In BigInt this is the same as
    <span class="Li">&quot;copy()&quot;</span>.</p>
<p class="Pp"><span class="Li">&quot;as_number()&quot;</span> is an alias to
    this method. <span class="Li">&quot;as_number&quot;</span> was introduced in
    v1.22, while <span class="Li">&quot;as_int()&quot;</span> was only
    introduced in v1.68.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_fIbstr()_fP"><a class="permalink" href="#_fIbstr()_fP"><i>bstr()</i></a></h2>
<span class="Li"></span>
<pre>
        $x-&gt;bstr();
</pre>
<p class="Pp">Returns a normalized string representation of
    <span class="Li">$x</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_fIbsstr()_fP"><a class="permalink" href="#_fIbsstr()_fP"><i>bsstr()</i></a></h2>
<span class="Li"></span>
<pre>
        $x-&gt;bsstr();    # normalized string in scientific notation
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="_fIas_hex()_fP"><a class="permalink" href="#_fIas_hex()_fP"><i>as_hex()</i></a></h2>
<span class="Li"></span>
<pre>
        $x-&gt;as_hex();   # as signed hexadecimal string with prefixed 0x
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="_fIas_bin()_fP"><a class="permalink" href="#_fIas_bin()_fP"><i>as_bin()</i></a></h2>
<span class="Li"></span>
<pre>
        $x-&gt;as_bin();   # as signed binary string with prefixed 0b
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="_fIas_oct()_fP"><a class="permalink" href="#_fIas_oct()_fP"><i>as_oct()</i></a></h2>
<span class="Li"></span>
<pre>
        $x-&gt;as_oct();   # as signed octal string with prefixed 0
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="_fInumify()_fP"><a class="permalink" href="#_fInumify()_fP"><i>numify()</i></a></h2>
<span class="Li"></span>
<pre>
        print $x-&gt;numify();
</pre>
<p class="Pp">This returns a normal Perl scalar from <span class="Li">$x</span>.
    It is used automatically whenever a scalar is needed, for instance in array
    index operations.</p>
<p class="Pp">This loses precision, to avoid this use <i>as_int()</i>
  instead.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_fImodify()_fP"><a class="permalink" href="#_fImodify()_fP"><i>modify()</i></a></h2>
<span class="Li"></span>
<pre>
        $x-&gt;modify('bpowd');
</pre>
<p class="Pp">This method returns 0 if the object can be modified with the given
    operation, or 1 if not.</p>
<p class="Pp">This is used for instance by Math::BigInt::Constant.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_fIupgrade()_fP/_fIdowngrade()_fP"><a class="permalink" href="#_fIupgrade()_fP/_fIdowngrade()_fP"><i>upgrade()</i>/<i>downgrade()</i></a></h2>
Set/get the class for downgrade/upgrade operations. Thuis is used for instance
  by bignum. The defaults are '', thus the following operation will create a
  BigInt, not a BigFloat:
<p class="Pp"><span class="Li"></span></p>
<pre>
        my $i = Math::BigInt-&gt;new(123);
        my $f = Math::BigFloat-&gt;new('123.1');

        print $i + $f,&quot;\n&quot;;                     # print 246
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="_fIdiv_scale()_fP"><a class="permalink" href="#_fIdiv_scale()_fP"><i>div_scale()</i></a></h2>
Set/get the number of digits for the default precision in divide operations.
</section>
<section class="Ss">
<h2 class="Ss" id="_fIround_mode()_fP"><a class="permalink" href="#_fIround_mode()_fP"><i>round_mode()</i></a></h2>
Set/get the current round mode.
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="ACCURACY_and_PRECISION"><a class="permalink" href="#ACCURACY_and_PRECISION">ACCURACY
  and PRECISION</a></h1>
Since version v1.33, Math::BigInt and Math::BigFloat have full support for
  accuracy and precision based rounding, both automatically after every
  operation, as well as manually.
<p class="Pp">This section describes the accuracy/precision handling in
    Math::Big* as it used to be and as it is now, complete with an explanation
    of all terms and abbreviations.</p>
<p class="Pp">Not yet implemented things (but with correct description) are
    marked with '!', things that need to be answered are marked with '?'.</p>
<p class="Pp">In the next paragraph follows a short description of terms used
    here (because these may differ from terms used by others people or
    documentation).</p>
<p class="Pp">During the rest of this document, the shortcuts A (for accuracy),
    P (for precision), F (fallback) and R (rounding mode) will be used.</p>
<section class="Ss">
<h2 class="Ss" id="Precision_P"><a class="permalink" href="#Precision_P">Precision
  P</a></h2>
A fixed number of digits before (positive) or after (negative) the decimal
  point. For example, 123.45 has a precision of -2. 0 means an integer like 123
  (or 120). A precision of 2 means two digits to the left of the decimal point
  are zero, so 123 with P = 1 becomes 120. Note that numbers with zeros before
  the decimal point may have different precisions, because 1200 can have p = 0,
  1 or 2 (depending on what the initial value was). It could also have p &lt; 0,
  when the digits after the decimal point are zero.
<p class="Pp">The string output (of floating point numbers) will be padded with
    zeros:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
        Initial value   P       A       Result          String
        ------------------------------------------------------------
        1234.01         -3              1000            1000
        1234            -2              1200            1200
        1234.5          -1              1230            1230
        1234.001        1               1234            1234.0
        1234.01         0               1234            1234
        1234.01         2               1234.01         1234.01
        1234.01         5               1234.01         1234.01000
</pre>
<p class="Pp">For BigInts, no padding occurs.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Accuracy_A"><a class="permalink" href="#Accuracy_A">Accuracy
  A</a></h2>
Number of significant digits. Leading zeros are not counted. A number may have
  an accuracy greater than the non-zero digits when there are zeros in it or
  trailing zeros. For example, 123.456 has A of 6, 10203 has 5, 123.0506 has 7,
  123.450000 has 8 and 0.000123 has 3.
<p class="Pp">The string output (of floating point numbers) will be padded with
    zeros:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
        Initial value   P       A       Result          String
        ------------------------------------------------------------
        1234.01                 3       1230            1230
        1234.01                 6       1234.01         1234.01
        1234.1                  8       1234.1          1234.1000
</pre>
<p class="Pp">For BigInts, no padding occurs.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Fallback_F"><a class="permalink" href="#Fallback_F">Fallback
  F</a></h2>
When both A and P are undefined, this is used as a fallback accuracy when
  dividing numbers.
</section>
<section class="Ss">
<h2 class="Ss" id="Rounding_mode_R"><a class="permalink" href="#Rounding_mode_R">Rounding
  mode R</a></h2>
When rounding a number, different 'styles' or 'kinds' of rounding are possible.
  (Note that random rounding, as in Math::Round, is not implemented.)
<dl class="Bl-tag">
  <dt>'trunc'</dt>
  <dd>truncation invariably removes all digits following the rounding place,
      replacing them with zeros. Thus, 987.65 rounded to tens (P=1) becomes 980,
      and rounded to the fourth sigdig becomes 987.6 (A=4). 123.456 rounded to
      the second place after the decimal point (P=-2) becomes 123.46.
    <p class="Pp">All other implemented styles of rounding attempt to round to
        the &quot;nearest digit.&quot; If the digit D immediately to the right
        of the rounding place (skipping the decimal point) is greater than 5,
        the number is incremented at the rounding place (possibly causing a
        cascade of incrementation): e.g. when rounding to units, 0.9 rounds to
        1, and -19.9 rounds to -20. If D &lt; 5, the number is similarly
        truncated at the rounding place: e.g. when rounding to units, 0.4 rounds
        to 0, and -19.4 rounds to -19.</p>
    <p class="Pp">However the results of other styles of rounding differ if the
        digit immediately to the right of the rounding place (skipping the
        decimal point) is 5 and if there are no digits, or no digits other than
        0, after that 5. In such cases:</p>
  </dd>
  <dt>'even'</dt>
  <dd>rounds the digit at the rounding place to 0, 2, 4, 6, or 8 if it is not
      already. E.g., when rounding to the first sigdig, 0.45 becomes 0.4, -0.55
      becomes -0.6, but 0.4501 becomes 0.5.</dd>
  <dt>'odd'</dt>
  <dd>rounds the digit at the rounding place to 1, 3, 5, 7, or 9 if it is not
      already. E.g., when rounding to the first sigdig, 0.45 becomes 0.5, -0.55
      becomes -0.5, but 0.5501 becomes 0.6.</dd>
  <dt>'+inf'</dt>
  <dd>round to plus infinity, i.e. always round up. E.g., when rounding to the
      first sigdig, 0.45 becomes 0.5, -0.55 becomes -0.5, and 0.4501 also
      becomes 0.5.</dd>
  <dt>'-inf'</dt>
  <dd>round to minus infinity, i.e. always round down. E.g., when rounding to
      the first sigdig, 0.45 becomes 0.4, -0.55 becomes -0.6, but 0.4501 becomes
      0.5.</dd>
  <dt>'zero'</dt>
  <dd>round to zero, i.e. positive numbers down, negative ones up. E.g., when
      rounding to the first sigdig, 0.45 becomes 0.4, -0.55 becomes -0.5, but
      0.4501 becomes 0.5.</dd>
  <dt>'common'</dt>
  <dd>round up if the digit immediately to the right of the rounding place is 5
      or greater, otherwise round down. E.g., 0.15 becomes 0.2 and 0.149 becomes
      0.1.</dd>
</dl>
<p class="Pp">The handling of A &amp; P in MBI/MBF (the old core code shipped
    with Perl versions &lt;= 5.7.2) is like this:</p>
<dl class="Bl-tag">
  <dt>Precision</dt>
  <dd><span class="Li"></span>
    <pre>
  * ffround($p) is able to round to $p number of digits after the decimal
    point
  * otherwise P is unused
    </pre>
  </dd>
  <dt>Accuracy (significant digits)</dt>
  <dd><span class="Li"></span>
    <pre>
  * fround($a) rounds to $a significant digits
  * only fdiv() and fsqrt() take A as (optional) parameter
    + other operations simply create the same number (fneg etc), or more (fmul)
      of digits
    + rounding/truncating is only done when explicitly calling one of fround
      or ffround, and never for BigInt (not implemented)
  * fsqrt() simply hands its accuracy argument over to fdiv.
  * the documentation and the comment in the code indicate two different ways
    on how fdiv() determines the maximum number of digits it should calculate,
    and the actual code does yet another thing
    POD:
      max($Math::BigFloat::div_scale,length(dividend)+length(divisor))
    Comment:
      result has at most max(scale, length(dividend), length(divisor)) digits
    Actual code:
      scale = max(scale, length(dividend)-1,length(divisor)-1);
      scale += length(divisor) - length(dividend);
    So for lx = 3, ly = 9, scale = 10, scale will actually be 16 (10+9-3).
    Actually, the 'difference' added to the scale is calculated from the
    number of &quot;significant digits&quot; in dividend and divisor, which is derived
    by looking at the length of the mantissa. Which is wrong, since it includes
    the + sign (oops) and actually gets 2 for '+100' and 4 for '+101'. Oops
    again. Thus 124/3 with div_scale=1 will get you '41.3' based on the strange
    assumption that 124 has 3 significant digits, while 120/7 will get you
    '17', not '17.1' since 120 is thought to have 2 significant digits.
    The rounding after the division then uses the remainder and $y to determine
    whether it must round up or down.
 ?  I have no idea which is the right way. That's why I used a slightly more
 ?  simple scheme and tweaked the few failing testcases to match it.
    </pre>
  </dd>
</dl>
<p class="Pp">This is how it works now:</p>
<dl class="Bl-tag">
  <dt>Setting/Accessing</dt>
  <dd><span class="Li"></span>
    <pre>
  * You can set the A global via Math::BigInt-&gt;accuracy() or
    Math::BigFloat-&gt;accuracy() or whatever class you are using.
  * You can also set P globally by using Math::SomeClass-&gt;precision()
    likewise.
  * Globals are classwide, and not inherited by subclasses.
  * to undefine A, use Math::SomeCLass-&gt;accuracy(undef);
  * to undefine P, use Math::SomeClass-&gt;precision(undef);
  * Setting Math::SomeClass-&gt;accuracy() clears automatically
    Math::SomeClass-&gt;precision(), and vice versa.
  * To be valid, A must be &gt; 0, P can have any value.
  * If P is negative, this means round to the P'th place to the right of the
    decimal point; positive values mean to the left of the decimal point.
    P of 0 means round to integer.
  * to find out the current global A, use Math::SomeClass-&gt;accuracy()
  * to find out the current global P, use Math::SomeClass-&gt;precision()
  * use $x-&gt;accuracy() respective $x-&gt;precision() for the local
    setting of $x.
  * Please note that $x-&gt;accuracy() respective $x-&gt;precision()
    return eventually defined global A or P, when $x's A or P is not
    set.
    </pre>
  </dd>
  <dt>Creating numbers</dt>
  <dd><span class="Li"></span>
    <pre>
  * When you create a number, you can give the desired A or P via:
    $x = Math::BigInt-&gt;new($number,$A,$P);
  * Only one of A or P can be defined, otherwise the result is NaN
  * If no A or P is give ($x = Math::BigInt-&gt;new($number) form), then the
    globals (if set) will be used. Thus changing the global defaults later on
    will not change the A or P of previously created numbers (i.e., A and P of
    $x will be what was in effect when $x was created)
  * If given undef for A and P, NO rounding will occur, and the globals will
    NOT be used. This is used by subclasses to create numbers without
    suffering rounding in the parent. Thus a subclass is able to have its own
    globals enforced upon creation of a number by using
    $x = Math::BigInt-&gt;new($number,undef,undef):

        use Math::BigInt::SomeSubclass;
        use Math::BigInt;

        Math::BigInt-&gt;accuracy(2);
        Math::BigInt::SomeSubClass-&gt;accuracy(3);
        $x = Math::BigInt::SomeSubClass-&gt;new(1234);

    $x is now 1230, and not 1200. A subclass might choose to implement
    this otherwise, e.g. falling back to the parent's A and P.
    </pre>
  </dd>
  <dt>Usage</dt>
  <dd><span class="Li"></span>
    <pre>
  * If A or P are enabled/defined, they are used to round the result of each
    operation according to the rules below
  * Negative P is ignored in Math::BigInt, since BigInts never have digits
    after the decimal point
  * Math::BigFloat uses Math::BigInt internally, but setting A or P inside
    Math::BigInt as globals does not tamper with the parts of a BigFloat.
    A flag is used to mark all Math::BigFloat numbers as 'never round'.
    </pre>
  </dd>
  <dt>Precedence</dt>
  <dd><span class="Li"></span>
    <pre>
  * It only makes sense that a number has only one of A or P at a time.
    If you set either A or P on one object, or globally, the other one will
    be automatically cleared.
  * If two objects are involved in an operation, and one of them has A in
    effect, and the other P, this results in an error (NaN).
  * A takes precedence over P (Hint: A comes before P).
    If neither of them is defined, nothing is used, i.e. the result will have
    as many digits as it can (with an exception for fdiv/fsqrt) and will not
    be rounded.
  * There is another setting for fdiv() (and thus for fsqrt()). If neither of
    A or P is defined, fdiv() will use a fallback (F) of $div_scale digits.
    If either the dividend's or the divisor's mantissa has more digits than
    the value of F, the higher value will be used instead of F.
    This is to limit the digits (A) of the result (just consider what would
    happen with unlimited A and P in the case of 1/3 :-)
  * fdiv will calculate (at least) 4 more digits than required (determined by
    A, P or F), and, if F is not used, round the result
    (this will still fail in the case of a result like 0.12345000000001 with A
    or P of 5, but this can not be helped - or can it?)
  * Thus you can have the math done by on Math::Big* class in two modi:
    + never round (this is the default):
      This is done by setting A and P to undef. No math operation
      will round the result, with fdiv() and fsqrt() as exceptions to guard
      against overflows. You must explicitly call bround(), bfround() or
      round() (the latter with parameters).
      Note: Once you have rounded a number, the settings will 'stick' on it
      and 'infect' all other numbers engaged in math operations with it, since
      local settings have the highest precedence. So, to get SaferRound[tm],
      use a copy() before rounding like this:

        $x = Math::BigFloat-&gt;new(12.34);
        $y = Math::BigFloat-&gt;new(98.76);
        $z = $x * $y;                           # 1218.6984
        print $x-&gt;copy()-&gt;fround(3);            # 12.3 (but A is now 3!)
        $z = $x * $y;                           # still 1218.6984, without
                                                # copy would have been 1210!

    + round after each op:
      After each single operation (except for testing like is_zero()), the
      method round() is called and the result is rounded appropriately. By
      setting proper values for A and P, you can have all-the-same-A or
      all-the-same-P modes. For example, Math::Currency might set A to undef,
      and P to -2, globally.

 ?Maybe an extra option that forbids local A &amp; P settings would be in order,
 ?so that intermediate rounding does not 'poison' further math?
    </pre>
  </dd>
  <dt>Overriding globals</dt>
  <dd><span class="Li"></span>
    <pre>
  * you will be able to give A, P and R as an argument to all the calculation
    routines; the second parameter is A, the third one is P, and the fourth is
    R (shift right by one for binary operations like badd). P is used only if
    the first parameter (A) is undefined. These three parameters override the
    globals in the order detailed as follows, i.e. the first defined value
    wins:
    (local: per object, global: global default, parameter: argument to sub)
      + parameter A
      + parameter P
      + local A (if defined on both of the operands: smaller one is taken)
      + local P (if defined on both of the operands: bigger one is taken)
      + global A
      + global P
      + global F
  * fsqrt() will hand its arguments to fdiv(), as it used to, only now for two
    arguments (A and P) instead of one
    </pre>
  </dd>
  <dt>Local settings</dt>
  <dd><span class="Li"></span>
    <pre>
  * You can set A or P locally by using $x-&gt;accuracy() or
    $x-&gt;precision()
    and thus force different A and P for different objects/numbers.
  * Setting A or P this way immediately rounds $x to the new value.
  * $x-&gt;accuracy() clears $x-&gt;precision(), and vice versa.
    </pre>
  </dd>
  <dt>Rounding</dt>
  <dd><span class="Li"></span>
    <pre>
  * the rounding routines will use the respective global or local settings.
    fround()/bround() is for accuracy rounding, while ffround()/bfround()
    is for precision
  * the two rounding functions take as the second parameter one of the
    following rounding modes (R):
    'even', 'odd', '+inf', '-inf', 'zero', 'trunc', 'common'
  * you can set/get the global R by using Math::SomeClass-&gt;round_mode()
    or by setting $Math::SomeClass::round_mode
  * after each operation, $result-&gt;round() is called, and the result may
    eventually be rounded (that is, if A or P were set either locally,
    globally or as parameter to the operation)
  * to manually round a number, call $x-&gt;round($A,$P,$round_mode);
    this will round the number by using the appropriate rounding function
    and then normalize it.
  * rounding modifies the local settings of the number:

        $x = Math::BigFloat-&gt;new(123.456);
        $x-&gt;accuracy(5);
        $x-&gt;bround(4);

    Here 4 takes precedence over 5, so 123.5 is the result and $x-&gt;accuracy()
    will be 4 from now on.
    </pre>
  </dd>
  <dt>Default values</dt>
  <dd><span class="Li"></span>
    <pre>
  * R: 'even'
  * F: 40
  * A: undef
  * P: undef
    </pre>
  </dd>
  <dt>Remarks</dt>
  <dd><span class="Li"></span>
    <pre>
  * The defaults are set up so that the new code gives the same results as
    the old code (except in a few cases on fdiv):
    + Both A and P are undefined and thus will not be used for rounding
      after each operation.
    + round() is thus a no-op, unless given extra parameters A and P
    </pre>
  </dd>
</dl>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="Infinity_and_Not_a_Number"><a class="permalink" href="#Infinity_and_Not_a_Number">Infinity
  and Not a Number</a></h1>
While BigInt has extensive handling of inf and NaN, certain quirks remain.
<dl class="Bl-tag">
  <dt><i>oct()</i>/<i>hex()</i></dt>
  <dd>These perl routines currently (as of Perl v.5.8.6) cannot handle passed
      inf.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        te@linux:~&gt; perl -wle 'print 2 ** 3333'
        inf
        te@linux:~&gt; perl -wle 'print 2 ** 3333 == 2 ** 3333'
        1
        te@linux:~&gt; perl -wle 'print oct(2 ** 3333)'
        0
        te@linux:~&gt; perl -wle 'print hex(2 ** 3333)'
        Illegal hexadecimal digit 'i' ignored at -e line 1.
        0
    </pre>
    <p class="Pp">The same problems occur if you pass them
        Math::BigInt-&gt;<i>binf()</i> objects. Since overloading these routines
        is not possible, this cannot be fixed from BigInt.</p>
  </dd>
  <dt>==, !=, &lt;, &gt;, &lt;=, &gt;= with NaNs</dt>
  <dd>BigInt's <i>bcmp()</i> routine currently returns undef to signal that a
      NaN was involved in a comparison. However, the overload code turns that
      into either 1 or '' and thus operations like <span class="Li">&quot;NaN !=
      NaN&quot;</span> might return wrong values.</dd>
  <dt>log(-inf)</dt>
  <dd><span class="Li">&quot;log(-inf)&quot;</span> is highly weird. Since
      log(-x)=pi*i+log(x), then log(-inf)=pi*i+inf. However, since the imaginary
      part is finite, the real infinity &quot;overshadows&quot; it, so the
      number might as well just be infinity. However, the result is a complex
      number, and since BigInt/BigFloat can only have real numbers as results,
      the result is NaN.</dd>
  <dt><i>exp()</i>, <i>cos()</i>, <i>sin()</i>, <i>atan2()</i></dt>
  <dd>These all might have problems handling infinity right.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="INTERNALS"><a class="permalink" href="#INTERNALS">INTERNALS</a></h1>
The actual numbers are stored as unsigned big integers (with separate sign).
<p class="Pp">You should neither care about nor depend on the internal
    representation; it might change without notice. Use <b>ONLY</b> method calls
    like <span class="Li">&quot;$x-&gt;sign();&quot;</span> instead relying on
    the internal representation.</p>
<section class="Ss">
<h2 class="Ss" id="_s-1MATH_LIBRARY_s0"><a class="permalink" href="#_s-1MATH_LIBRARY_s0">MATH
  LIBRARY</a></h2>
Math with the numbers is done (by default) by a module called
  <span class="Li">&quot;Math::BigInt::Calc&quot;</span>. This is equivalent to
  saying:
<p class="Pp"><span class="Li"></span></p>
<pre>
        use Math::BigInt try =&gt; 'Calc';
</pre>
<p class="Pp">You can change this backend library by using:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
        use Math::BigInt try =&gt; 'GMP';
</pre>
<p class="Pp"><b>Note</b>: General purpose packages should not be explicit about
    the library to use; let the script author decide which is best.</p>
<p class="Pp">If your script works with huge numbers and Calc is too slow for
    them, you can also for the loading of one of these libraries and if none of
    them can be used, the code will die:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
        use Math::BigInt only =&gt; 'GMP,Pari';
</pre>
<p class="Pp">The following would first try to find Math::BigInt::Foo, then
    Math::BigInt::Bar, and when this also fails, revert to
  Math::BigInt::Calc:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
        use Math::BigInt try =&gt; 'Foo,Math::BigInt::Bar';
</pre>
<p class="Pp">The library that is loaded last will be used. Note that this can
    be overwritten at any time by loading a different library, and numbers
    constructed with different libraries cannot be used in math operations
    together.</p>
<p class="Pp"><i>What library to use?</i></p>
<p class="Pp"><b>Note</b>: General purpose packages should not be explicit about
    the library to use; let the script author decide which is best.</p>
<p class="Pp">Math::BigInt::GMP and Math::BigInt::Pari are in cases involving
    big numbers much faster than Calc, however it is slower when dealing with
    very small numbers (less than about 20 digits) and when converting very
    large numbers to decimal (for instance for printing, rounding, calculating
    their length in decimal etc).</p>
<p class="Pp">So please select carefully what library you want to use.</p>
<p class="Pp">Different low-level libraries use different formats to store the
    numbers. However, you should <b>NOT</b> depend on the number having a
    specific format internally.</p>
<p class="Pp">See the respective math library module documentation for further
    details.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_s-1SIGN_s0"><a class="permalink" href="#_s-1SIGN_s0">SIGN</a></h2>
The sign is either '+', '-', 'NaN', '+inf' or '-inf'.
<p class="Pp">A sign of 'NaN' is used to represent the result when input
    arguments are not numbers or as a result of 0/0. '+inf' and '-inf' represent
    plus respectively minus infinity. You will get '+inf' when dividing a
    positive number by 0, and '-inf' when dividing any negative number by 0.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_fImantissa()_fP,__fIexponent()_fP_and__fIparts()_fP"><a class="permalink" href="#_fImantissa()_fP,__fIexponent()_fP_and__fIparts()_fP"><i>mantissa()</i>,
  <i>exponent()</i> and <i>parts()</i></a></h2>
<span class="Li">&quot;mantissa()&quot;</span> and
  <span class="Li">&quot;exponent()&quot;</span> return the said parts of the
  BigInt such that:
<p class="Pp"><span class="Li"></span></p>
<pre>
        $m = $x-&gt;mantissa();
        $e = $x-&gt;exponent();
        $y = $m * ( 10 ** $e );
        print &quot;ok\n&quot; if $x == $y;
</pre>
<p class="Pp"><span class="Li">&quot;($m,$e) = $x-&gt;parts()&quot;</span> is
    just a shortcut that gives you both of them in one go. Both the returned
    mantissa and exponent have a sign.</p>
<p class="Pp">Currently, for BigInts <span class="Li">$e</span> is always 0,
    except +inf and -inf, where it is <span class="Li">&quot;+inf&quot;</span>;
    and for NaN, where it is <span class="Li">&quot;NaN&quot;</span>; and for
    <span class="Li">&quot;$x == 0&quot;</span>, where it is
    <span class="Li">1</span> (to be compatible with Math::BigFloat's internal
    representation of a zero as <span class="Li">0E1</span>).</p>
<p class="Pp"><span class="Li">$m</span> is currently just a copy of the
    original number. The relation between <span class="Li">$e</span> and
    <span class="Li">$m</span> will stay always the same, though their real
    values might change.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="EXAMPLES"><a class="permalink" href="#EXAMPLES">EXAMPLES</a></h1>
<span class="Li"></span>
<pre>
  use Math::BigInt;

  sub bint { Math::BigInt-&gt;new(shift); }

  $x = Math::BigInt-&gt;bstr(&quot;1234&quot;)       # string &quot;1234&quot;
  $x = &quot;$x&quot;;                            # same as bstr()
  $x = Math::BigInt-&gt;bneg(&quot;1234&quot;);      # BigInt &quot;-1234&quot;
  $x = Math::BigInt-&gt;babs(&quot;-12345&quot;);    # BigInt &quot;12345&quot;
  $x = Math::BigInt-&gt;bnorm(&quot;-0.00&quot;);    # BigInt &quot;0&quot;
  $x = bint(1) + bint(2);               # BigInt &quot;3&quot;
  $x = bint(1) + &quot;2&quot;;                   # ditto (auto-BigIntify of &quot;2&quot;)
  $x = bint(1);                         # BigInt &quot;1&quot;
  $x = $x + 5 / 2;                      # BigInt &quot;3&quot;
  $x = $x ** 3;                         # BigInt &quot;27&quot;
  $x *= 2;                              # BigInt &quot;54&quot;
  $x = Math::BigInt-&gt;new(0);            # BigInt &quot;0&quot;
  $x--;                                 # BigInt &quot;-1&quot;
  $x = Math::BigInt-&gt;badd(4,5)          # BigInt &quot;9&quot;
  print $x-&gt;bsstr();                    # 9e+0
</pre>
<p class="Pp">Examples for rounding:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  use Math::BigFloat;
  use Test;

  $x = Math::BigFloat-&gt;new(123.4567);
  $y = Math::BigFloat-&gt;new(123.456789);
  Math::BigFloat-&gt;accuracy(4);          # no more A than 4

  ok ($x-&gt;copy()-&gt;fround(),123.4);      # even rounding
  print $x-&gt;copy()-&gt;fround(),&quot;\n&quot;;      # 123.4
  Math::BigFloat-&gt;round_mode('odd');    # round to odd
  print $x-&gt;copy()-&gt;fround(),&quot;\n&quot;;      # 123.5
  Math::BigFloat-&gt;accuracy(5);          # no more A than 5
  Math::BigFloat-&gt;round_mode('odd');    # round to odd
  print $x-&gt;copy()-&gt;fround(),&quot;\n&quot;;      # 123.46
  $y = $x-&gt;copy()-&gt;fround(4),&quot;\n&quot;;      # A = 4: 123.4
  print &quot;$y, &quot;,$y-&gt;accuracy(),&quot;\n&quot;;     # 123.4, 4

  Math::BigFloat-&gt;accuracy(undef);      # A not important now
  Math::BigFloat-&gt;precision(2);         # P important
  print $x-&gt;copy()-&gt;bnorm(),&quot;\n&quot;;       # 123.46
  print $x-&gt;copy()-&gt;fround(),&quot;\n&quot;;      # 123.46
</pre>
<p class="Pp">Examples for converting:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  my $x = Math::BigInt-&gt;new('0b1'.'01' x 123);
  print &quot;bin: &quot;,$x-&gt;as_bin(),&quot; hex:&quot;,$x-&gt;as_hex(),&quot; dec: &quot;,$x,&quot;\n&quot;;
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="Autocreating_constants"><a class="permalink" href="#Autocreating_constants">Autocreating
  constants</a></h1>
After <span class="Li">&quot;use Math::BigInt ':constant'&quot;</span> all the
  <b>integer</b> decimal, hexadecimal and binary constants in the given scope
  are converted to <span class="Li">&quot;Math::BigInt&quot;</span>. This
  conversion happens at compile time.
<p class="Pp">In particular,</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  perl -MMath::BigInt=:constant -e 'print 2**100,&quot;\n&quot;'
</pre>
<p class="Pp">prints the integer value of
    <span class="Li">&quot;2**100&quot;</span>. Note that without conversion of
    constants the expression 2**100 will be calculated as perl scalar.</p>
<p class="Pp">Please note that strings and floating point constants are not
    affected, so that</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
        use Math::BigInt qw/:constant/;

        $x = 1234567890123456789012345678901234567890
                + 123456789123456789;
        $y = '1234567890123456789012345678901234567890'
                + '123456789123456789';
</pre>
<p class="Pp">do not work. You need an explicit Math::BigInt-&gt;<i>new()</i>
    around one of the operands. You should also quote large constants to protect
    loss of precision:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
        use Math::BigInt;

        $x = Math::BigInt-&gt;new('1234567889123456789123456789123456789');
</pre>
<p class="Pp">Without the quotes Perl would convert the large number to a
    floating point constant at compile time and then hand the result to BigInt,
    which results in an truncated result or a NaN.</p>
<p class="Pp">This also applies to integers that look like floating point
    constants:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
        use Math::BigInt ':constant';

        print ref(123e2),&quot;\n&quot;;
        print ref(123.2e2),&quot;\n&quot;;
</pre>
<p class="Pp">will print nothing but newlines. Use either bignum or
    Math::BigFloat to get this to work.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="PERFORMANCE"><a class="permalink" href="#PERFORMANCE">PERFORMANCE</a></h1>
Using the form <span class="Li">$x</span> += <span class="Li">$y</span>; etc
  over <span class="Li">$x</span> = <span class="Li">$x</span> +
  <span class="Li">$y</span> is faster, since a copy of
  <span class="Li">$x</span> must be made in the second case. For long numbers,
  the copy can eat up to 20% of the work (in the case of addition/subtraction,
  less for multiplication/division). If <span class="Li">$y</span> is very small
  compared to <span class="Li">$x</span>, the form <span class="Li">$x</span> +=
  <span class="Li">$y</span> is MUCH faster than <span class="Li">$x</span> =
  <span class="Li">$x</span> + <span class="Li">$y</span> since making the copy
  of <span class="Li">$x</span> takes more time then the actual addition.
<p class="Pp">With a technique called copy-on-write, the cost of copying with
    overload could be minimized or even completely avoided. A test
    implementation of COW did show performance gains for overloaded math, but
    introduced a performance loss due to a constant overhead for all other
    operations. So Math::BigInt does currently not COW.</p>
<p class="Pp">The rewritten version of this module (vs. v0.01) is slower on
    certain operations, like <span class="Li">&quot;new()&quot;</span>,
    <span class="Li">&quot;bstr()&quot;</span> and
    <span class="Li">&quot;numify()&quot;</span>. The reason are that it does
    now more work and handles much more cases. The time spent in these
    operations is usually gained in the other math operations so that code on
    the average should get (much) faster. If they don't, please contact the
    author.</p>
<p class="Pp">Some operations may be slower for small numbers, but are
    significantly faster for big numbers. Other operations are now constant
    (O(1), like <span class="Li">&quot;bneg()&quot;</span>,
    <span class="Li">&quot;babs()&quot;</span> etc), instead of O(N) and thus
    nearly always take much less time. These optimizations were done on
  purpose.</p>
<p class="Pp">If you find the Calc module to slow, try to install any of the
    replacement modules and see if they help you.</p>
<section class="Ss">
<h2 class="Ss" id="Alternative_math_libraries"><a class="permalink" href="#Alternative_math_libraries">Alternative
  math libraries</a></h2>
You can use an alternative library to drive Math::BigInt. See the section
  &quot;MATH LIBRARY&quot; for more information.
<p class="Pp">For more benchmark results see
    &lt;http://bloodgate.com/perl/benchmarks.html&gt;.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="SUBCLASSING"><a class="permalink" href="#SUBCLASSING">SUBCLASSING</a></h1>
<section class="Ss">
<h2 class="Ss" id="Subclassing_Math::BigInt"><a class="permalink" href="#Subclassing_Math::BigInt">Subclassing
  Math::BigInt</a></h2>
The basic design of Math::BigInt allows simple subclasses with very little work,
  as long as a few simple rules are followed:
<ul class="Bl-bullet">
  <li>The public API must remain consistent, i.e. if a sub-class is overloading
      addition, the sub-class must use the same name, in this case
      <i>badd()</i>. The reason for this is that Math::BigInt is optimized to
      call the object methods directly.</li>
  <li>The private object hash keys like
      <span class="Li">&quot;$x-&gt;{sign}&quot;</span> may not be changed, but
      additional keys can be added, like
      <span class="Li">&quot;$x-&gt;{_custom}&quot;</span>.</li>
  <li>Accessor functions are available for all existing object hash keys and
      should be used instead of directly accessing the internal hash keys. The
      reason for this is that Math::BigInt itself has a pluggable interface
      which permits it to support different storage methods.</li>
</ul>
<p class="Pp">More complex sub-classes may have to replicate more of the logic
    internal of Math::BigInt if they need to change more basic behaviors. A
    subclass that needs to merely change the output only needs to overload
    <span class="Li">&quot;bstr()&quot;</span>.</p>
<p class="Pp">All other object methods and overloaded functions can be directly
    inherited from the parent class.</p>
<p class="Pp">At the very minimum, any subclass will need to provide its own
    <span class="Li">&quot;new()&quot;</span> and can store additional hash keys
    in the object. There are also some package globals that must be defined,
    e.g.:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  # Globals
  $accuracy = undef;
  $precision = -2;       # round to 2 decimal places
  $round_mode = 'even';
  $div_scale = 40;
</pre>
<p class="Pp">Additionally, you might want to provide the following two globals
    to allow auto-upgrading and auto-downgrading to work correctly:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  $upgrade = undef;
  $downgrade = undef;
</pre>
<p class="Pp">This allows Math::BigInt to correctly retrieve package globals
    from the subclass, like <span class="Li">$SubClass::precision</span>. See
    t/Math/BigInt/Subclass.pm or t/Math/BigFloat/SubClass.pm completely
    functional subclass examples.</p>
<p class="Pp">Don't forget to</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
        use overload;
</pre>
<p class="Pp">in your subclass to automatically inherit the overloading from the
    parent. If you like, you can change part of the overloading, look at
    Math::String for an example.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="UPGRADING"><a class="permalink" href="#UPGRADING">UPGRADING</a></h1>
When used like this:
<p class="Pp"><span class="Li"></span></p>
<pre>
        use Math::BigInt upgrade =&gt; 'Foo::Bar';
</pre>
<p class="Pp">certain operations will 'upgrade' their calculation and thus the
    result to the class Foo::Bar. Usually this is used in conjunction with
    Math::BigFloat:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
        use Math::BigInt upgrade =&gt; 'Math::BigFloat';
</pre>
<p class="Pp">As a shortcut, you can use the module
    <span class="Li">&quot;bignum&quot;</span>:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
        use bignum;
</pre>
<p class="Pp">Also good for one-liners:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
        perl -Mbignum -le 'print 2 ** 255'
</pre>
<p class="Pp">This makes it possible to mix arguments of different classes (as
    in 2.5 + 2) as well es preserve accuracy (as in <i>sqrt</i>(3)).</p>
<p class="Pp">Beware: This feature is not fully implemented yet.</p>
<section class="Ss">
<h2 class="Ss" id="Auto-upgrade"><a class="permalink" href="#Auto-upgrade">Auto-upgrade</a></h2>
The following methods upgrade themselves unconditionally; that is if upgrade is
  in effect, they will always hand up their work:
<dl class="Bl-tag">
  <dt><i>bsqrt()</i></dt>
  <dd></dd>
  <dt><i>div()</i></dt>
  <dd></dd>
  <dt><i>blog()</i></dt>
  <dd></dd>
  <dt><i>bexp()</i></dt>
  <dd></dd>
</dl>
<p class="Pp">Beware: This list is not complete.</p>
<p class="Pp">All other methods upgrade themselves only when one (or all) of
    their arguments are of the class mentioned in
    <span class="Li">$upgrade</span> (This might change in later versions to a
    more sophisticated scheme):</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="EXPORTS"><a class="permalink" href="#EXPORTS">EXPORTS</a></h1>
<span class="Li">&quot;Math::BigInt&quot;</span> exports nothing by default, but
  can export the following methods:
<p class="Pp"><span class="Li"></span></p>
<pre>
        bgcd
        blcm
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="CAVEATS"><a class="permalink" href="#CAVEATS">CAVEATS</a></h1>
Some things might not work as you expect them. Below is documented what is known
  to be troublesome:
<dl class="Bl-tag">
  <dt><i>bstr()</i>, <i>bsstr()</i> and 'cmp'</dt>
  <dd>Both <span class="Li">&quot;bstr()&quot;</span> and
      <span class="Li">&quot;bsstr()&quot;</span> as well as automated stringify
      via overload now drop the leading '+'. The old code would return '+3', the
      new returns '3'. This is to be consistent with Perl and to make
      <span class="Li">&quot;cmp&quot;</span> (especially with overloading) to
      work as you expect. It also solves problems with
      <span class="Li">&quot;Test.pm&quot;</span>, because its
      <span class="Li">&quot;ok()&quot;</span> uses 'eq' internally.
    <p class="Pp">Mark Biggar said, when asked about to drop the '+' altogether,
        or make only <span class="Li">&quot;cmp&quot;</span> work:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        I agree (with the first alternative), don't add the '+' on positive
        numbers.  It's not as important anymore with the new internal 
        form for numbers.  It made doing things like abs and neg easier,
        but those have to be done differently now anyway.
    </pre>
    <p class="Pp">So, the following examples will now work all as expected:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        use Test;
        BEGIN { plan tests =&gt; 1 }
        use Math::BigInt;

        my $x = new Math::BigInt 3*3;
        my $y = new Math::BigInt 3*3;

        ok ($x,3*3);
        print &quot;$x eq 9&quot; if $x eq $y;
        print &quot;$x eq 9&quot; if $x eq '9';
        print &quot;$x eq 9&quot; if $x eq 3*3;
    </pre>
    <p class="Pp">Additionally, the following still works:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        print &quot;$x == 9&quot; if $x == $y;
        print &quot;$x == 9&quot; if $x == 9;
        print &quot;$x == 9&quot; if $x == 3*3;
    </pre>
    <p class="Pp">There is now a <span class="Li">&quot;bsstr()&quot;</span>
        method to get the string in scientific notation aka
        <span class="Li">1e+2</span> instead of <span class="Li">100</span>. Be
        advised that overloaded 'eq' always uses <i>bstr()</i> for comparison,
        but Perl will represent some numbers as 100 and others as 1e+308. If in
        doubt, convert both arguments to Math::BigInt before comparing them as
        strings:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        use Test;
        BEGIN { plan tests =&gt; 3 }
        use Math::BigInt;

        $x = Math::BigInt-&gt;new('1e56'); $y = 1e56;
        ok ($x,$y);                     # will fail
        ok ($x-&gt;bsstr(),$y);            # okay
        $y = Math::BigInt-&gt;new($y);
        ok ($x,$y);                     # okay
    </pre>
    <p class="Pp">Alternatively, simple use
        <span class="Li">&quot;&lt;=&gt;&quot;</span> for comparisons, this will
        get it always right. There is not yet a way to get a number
        automatically represented as a string that matches exactly the way Perl
        represents it.</p>
    <p class="Pp">See also the section about &quot;Infinity and Not a
        Number&quot; for problems in comparing NaNs.</p>
  </dd>
  <dt><i>int()</i></dt>
  <dd><span class="Li">&quot;int()&quot;</span> will return (at least for Perl
      v5.7.1 and up) another BigInt, not a Perl scalar:
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        $x = Math::BigInt-&gt;new(123);
        $y = int($x);                           # BigInt 123
        $x = Math::BigFloat-&gt;new(123.45);
        $y = int($x);                           # BigInt 123
    </pre>
    <p class="Pp">In all Perl versions you can use
        <span class="Li">&quot;as_number()&quot;</span> or
        <span class="Li">&quot;as_int&quot;</span> for the same effect:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        $x = Math::BigFloat-&gt;new(123.45);
        $y = $x-&gt;as_number();                   # BigInt 123
        $y = $x-&gt;as_int();                      # ditto
    </pre>
    <p class="Pp">This also works for other subclasses, like Math::String.</p>
    <p class="Pp">If you want a real Perl scalar, use
        <span class="Li">&quot;numify()&quot;</span>:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        $y = $x-&gt;numify();                      # 123 as scalar
    </pre>
    <p class="Pp">This is seldom necessary, though, because this is done
        automatically, like when you access an array:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        $z = $array[$x];                        # does work automatically
    </pre>
  </dd>
  <dt>length</dt>
  <dd>The following will probably not do what you expect:
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        $c = Math::BigInt-&gt;new(123);
        print $c-&gt;length(),&quot;\n&quot;;                # prints 30
    </pre>
    <p class="Pp">It prints both the number of digits in the number and in the
        fraction part since print calls
        <span class="Li">&quot;length()&quot;</span> in list context. Use
        something like:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        print scalar $c-&gt;length(),&quot;\n&quot;;         # prints 3
    </pre>
  </dd>
  <dt>bdiv</dt>
  <dd>The following will probably not do what you expect:
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        print $c-&gt;bdiv(10000),&quot;\n&quot;;
    </pre>
    <p class="Pp">It prints both quotient and remainder since print calls
        <span class="Li">&quot;bdiv()&quot;</span> in list context. Also,
        <span class="Li">&quot;bdiv()&quot;</span> will modify
        <span class="Li">$c</span>, so be careful. You probably want to use</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        print $c / 10000,&quot;\n&quot;;
        print scalar $c-&gt;bdiv(10000),&quot;\n&quot;;  # or if you want to modify $c
    </pre>
    <p class="Pp">instead.</p>
    <p class="Pp">The quotient is always the greatest integer less than or equal
        to the real-valued quotient of the two operands, and the remainder (when
        it is non-zero) always has the same sign as the second operand; so, for
        example,</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
          1 / 4  =&gt; ( 0, 1)
          1 / -4 =&gt; (-1,-3)
         -3 / 4  =&gt; (-1, 1)
         -3 / -4 =&gt; ( 0,-3)
        -11 / 2  =&gt; (-5,1)
         11 /-2  =&gt; (-5,-1)
    </pre>
    <p class="Pp">As a consequence, the behavior of the operator % agrees with
        the behavior of Perl's built-in % operator (as documented in the perlop
        manpage), and the equation</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        $x == ($x / $y) * $y + ($x % $y)
    </pre>
    <p class="Pp">holds true for any <span class="Li">$x</span> and
        <span class="Li">$y</span>, which justifies calling the two return
        values of <i>bdiv()</i> the quotient and remainder. The only exception
        to this rule are when <span class="Li">$y</span> == 0 and
        <span class="Li">$x</span> is negative, then the remainder will also be
        negative. See below under &quot;infinity handling&quot; for the
        reasoning behind this.</p>
    <p class="Pp">Perl's 'use integer;' changes the behaviour of % and / for
        scalars, but will not change BigInt's way to do things. This is because
        under 'use integer' Perl will do what the underlying C thinks is right
        and this is different for each system. If you need BigInt's behaving
        exactly like Perl's 'use integer', bug the author to implement it ;)</p>
  </dd>
  <dt>infinity handling</dt>
  <dd>Here are some examples that explain the reasons why certain results occur
      while handling infinity:
    <p class="Pp">The following table shows the result of the division and the
        remainder, so that the equation above holds true. Some
        &quot;ordinary&quot; cases are strewn in to show more clearly the
        reasoning:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        A /  B  =   C,     R so that C *    B +    R =    A
     =========================================================
        5 /   8 =   0,     5         0 *    8 +    5 =    5
        0 /   8 =   0,     0         0 *    8 +    0 =    0
        0 / inf =   0,     0         0 *  inf +    0 =    0
        0 /-inf =   0,     0         0 * -inf +    0 =    0
        5 / inf =   0,     5         0 *  inf +    5 =    5
        5 /-inf =   0,     5         0 * -inf +    5 =    5
        -5/ inf =   0,    -5         0 *  inf +   -5 =   -5
        -5/-inf =   0,    -5         0 * -inf +   -5 =   -5
       inf/   5 =  inf,    0       inf *    5 +    0 =  inf
      -inf/   5 = -inf,    0      -inf *    5 +    0 = -inf
       inf/  -5 = -inf,    0      -inf *   -5 +    0 =  inf
      -inf/  -5 =  inf,    0       inf *   -5 +    0 = -inf
         5/   5 =    1,    0         1 *    5 +    0 =    5
        -5/  -5 =    1,    0         1 *   -5 +    0 =   -5
       inf/ inf =    1,    0         1 *  inf +    0 =  inf
      -inf/-inf =    1,    0         1 * -inf +    0 = -inf
       inf/-inf =   -1,    0        -1 * -inf +    0 =  inf
      -inf/ inf =   -1,    0         1 * -inf +    0 = -inf
         8/   0 =  inf,    8       inf *    0 +    8 =    8
       inf/   0 =  inf,  inf       inf *    0 +  inf =  inf
         0/   0 =  NaN
    </pre>
    <p class="Pp">These cases below violate the &quot;remainder has the sign of
        the second of the two arguments&quot;, since they wouldn't match up
        otherwise.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        A /  B  =   C,     R so that C *    B +    R =    A
     ========================================================
      -inf/   0 = -inf, -inf      -inf *    0 +  inf = -inf
        -8/   0 = -inf,   -8      -inf *    0 +    8 = -8
    </pre>
  </dd>
  <dt>Modifying and =</dt>
  <dd>Beware of:
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        $x = Math::BigFloat-&gt;new(5);
        $y = $x;
    </pre>
    <p class="Pp">It will not do what you think, e.g. making a copy of
        <span class="Li">$x</span>. Instead it just makes a second reference to
        the <b>same</b> object and stores it in <span class="Li">$y</span>. Thus
        anything that modifies <span class="Li">$x</span> (except overloaded
        operators) will modify <span class="Li">$y</span>, and vice versa. Or in
        other words, <span class="Li">&quot;=&quot;</span> is only safe if you
        modify your BigInts only via overloaded math. As soon as you use a
        method call it breaks:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        $x-&gt;bmul(2);
        print &quot;$x, $y\n&quot;;       # prints '10, 10'
    </pre>
    <p class="Pp">If you want a true copy of <span class="Li">$x</span>,
      use:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        $y = $x-&gt;copy();
    </pre>
    <p class="Pp">You can also chain the calls like this, this will make first a
        copy and then multiply it by 2:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        $y = $x-&gt;copy()-&gt;bmul(2);
    </pre>
    <p class="Pp">See also the documentation for overload.pm regarding
        <span class="Li">&quot;=&quot;</span>.</p>
  </dd>
  <dt>bpow</dt>
  <dd><span class="Li">&quot;bpow()&quot;</span> (and the rounding functions)
      now modifies the first argument and returns it, unlike the old code which
      left it alone and only returned the result. This is to be consistent with
      <span class="Li">&quot;badd()&quot;</span> etc. The first three will
      modify <span class="Li">$x</span>, the last one won't:
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        print bpow($x,$i),&quot;\n&quot;;         # modify $x
        print $x-&gt;bpow($i),&quot;\n&quot;;        # ditto
        print $x **= $i,&quot;\n&quot;;           # the same
        print $x ** $i,&quot;\n&quot;;            # leave $x alone
    </pre>
    <p class="Pp">The form <span class="Li">&quot;$x **= $y&quot;</span> is
        faster than <span class="Li">&quot;$x = $x ** $y;&quot;</span>,
      though.</p>
  </dd>
  <dt>Overloading -$x</dt>
  <dd>The following:
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        $x = -$x;
    </pre>
    <p class="Pp">is slower than</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        $x-&gt;bneg();
    </pre>
    <p class="Pp">since overload calls
        <span class="Li">&quot;sub($x,0,1);&quot;</span> instead of
        <span class="Li">&quot;neg($x)&quot;</span>. The first variant needs to
        preserve <span class="Li">$x</span> since it does not know that it later
        will get overwritten. This makes a copy of <span class="Li">$x</span>
        and takes O(N), but <span class="Li">$x</span>-&gt;<i>bneg()</i> is
        O(1).</p>
  </dd>
  <dt>Mixing different object types</dt>
  <dd>In Perl you will get a floating point value if you do one of the
      following:
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        $float = 5.0 + 2;
        $float = 2 + 5.0;
        $float = 5 / 2;
    </pre>
    <p class="Pp">With overloaded math, only the first two variants will result
        in a BigFloat:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        use Math::BigInt;
        use Math::BigFloat;

        $mbf = Math::BigFloat-&gt;new(5);
        $mbi2 = Math::BigInteger-&gt;new(5);
        $mbi = Math::BigInteger-&gt;new(2);

                                        # what actually gets called:
        $float = $mbf + $mbi;           # $mbf-&gt;badd()
        $float = $mbf / $mbi;           # $mbf-&gt;bdiv()
        $integer = $mbi + $mbf;         # $mbi-&gt;badd()
        $integer = $mbi2 / $mbi;        # $mbi2-&gt;bdiv()
        $integer = $mbi2 / $mbf;        # $mbi2-&gt;bdiv()
    </pre>
    <p class="Pp">This is because math with overloaded operators follows the
        first (dominating) operand, and the operation of that is called and
        returns thus the result. So, <i>Math::BigInt::bdiv()</i> will always
        return a Math::BigInt, regardless whether the result should be a
        Math::BigFloat or the second operant is one.</p>
    <p class="Pp">To get a Math::BigFloat you either need to call the operation
        manually, make sure the operands are already of the proper type or
        casted to that type via Math::BigFloat-&gt;<i>new()</i>:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        $float = Math::BigFloat-&gt;new($mbi2) / $mbi;     # = 2.5
    </pre>
    <p class="Pp">Beware of simple &quot;casting&quot; the entire expression,
        this would only convert the already computed result:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        $float = Math::BigFloat-&gt;new($mbi2 / $mbi);     # = 2.0 thus wrong!
    </pre>
    <p class="Pp">Beware also of the order of more complicated expressions
      like:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        $integer = ($mbi2 + $mbi) / $mbf;               # int / float =&gt; int
        $integer = $mbi2 / Math::BigFloat-&gt;new($mbi);   # ditto
    </pre>
    <p class="Pp">If in doubt, break the expression into simpler terms, or cast
        all operands to the desired resulting type.</p>
    <p class="Pp">Scalar values are a bit different, since:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        $float = 2 + $mbf;
        $float = $mbf + 2;
    </pre>
    <p class="Pp">will both result in the proper type due to the way the
        overloaded math works.</p>
    <p class="Pp">This section also applies to other overloaded math packages,
        like Math::String.</p>
    <p class="Pp">One solution to you problem might be autoupgrading|upgrading.
        See the pragmas bignum, bigint and bigrat for an easy way to do
      this.</p>
  </dd>
  <dt><i>bsqrt()</i></dt>
  <dd><span class="Li">&quot;bsqrt()&quot;</span> works only good if the result
      is a big integer, e.g. the square root of 144 is 12, but from 12 the
      square root is 3, regardless of rounding mode. The reason is that the
      result is always truncated to an integer.
    <p class="Pp">If you want a better approximation of the square root, then
        use:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        $x = Math::BigFloat-&gt;new(12);
        Math::BigFloat-&gt;precision(0);
        Math::BigFloat-&gt;round_mode('even');
        print $x-&gt;copy-&gt;bsqrt(),&quot;\n&quot;;           # 4

        Math::BigFloat-&gt;precision(2);
        print $x-&gt;bsqrt(),&quot;\n&quot;;                 # 3.46
        print $x-&gt;bsqrt(3),&quot;\n&quot;;                # 3.464
    </pre>
  </dd>
  <dt><i>brsft()</i></dt>
  <dd>For negative numbers in base see also brsft.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="LICENSE"><a class="permalink" href="#LICENSE">LICENSE</a></h1>
This program is free software; you may redistribute it and/or modify it under
  the same terms as Perl itself.
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
Math::BigFloat, Math::BigRat and Math::Big as well as Math::BigInt::Pari and
  Math::BigInt::GMP.
<p class="Pp">The pragmas bignum, bigint and bigrat also might be of interest
    because they solve the autoupgrading/downgrading issue, at least partly.</p>
<p class="Pp">The package at
    &lt;http://search.cpan.org/search?mode=module&amp;query=Math%3A%3ABigInt&gt;
    contains more documentation including a full version history, testcases,
    empty subclass files and benchmarks.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHORS"><a class="permalink" href="#AUTHORS">AUTHORS</a></h1>
Original code by Mark Biggar, overloaded interface by Ilya Zakharevich.
  Completely rewritten by Tels http://bloodgate.com in late 2000, 2001 - 2006
  and still at it in 2007.
<p class="Pp">Many people contributed in one or more ways to the final beast,
    see the file CREDITS for an (incomplete) list. If you miss your name, please
    drop me a mail. Thank you!</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2014-09-30</td>
    <td class="foot-os">perl v5.18.4</td>
  </tr>
</table>
</body>
</html>
