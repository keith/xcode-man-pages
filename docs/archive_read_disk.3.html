<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Copyright (c) 2003-2009 Tim Kientzle
   All rights reserved.
  
   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions
   are met:
   1. Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
   2. Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
  
   THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
   ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
   ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
   FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
   DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
   OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
   HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
   LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
   OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
   SUCH DAMAGE.
  
   $FreeBSD$
   -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    .Nd, .Bf, .Op { display: inline; }
    .Pa, .Ad { font-style: italic; }
    .Ms { font-weight: bold; }
    .Bl-diag > dt { font-weight: bold; }
    code.Nm, .Fl, .Cm, .Ic, code.In, .Fd, .Fn, .Cd { font-weight: bold;
      font-family: inherit; }
  </style>
  <title>ARCHIVE_READ_DISK(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">ARCHIVE_READ_DISK(3)</td>
    <td class="head-vol">Library Functions Manual</td>
    <td class="head-rtitle">ARCHIVE_READ_DISK(3)</td>
  </tr>
</table>
<div class="manual-text">
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp"><code class="Nm">archive_read_disk_new</code>,
    <code class="Nm">archive_read_disk_set_behavior</code>,
    <code class="Nm">archive_read_disk_set_symlink_logical</code>,
    <code class="Nm">archive_read_disk_set_symlink_physical</code>,
    <code class="Nm">archive_read_disk_set_symlink_hybrid</code>,
    <code class="Nm">archive_read_disk_entry_from_file</code>,
    <code class="Nm">archive_read_disk_gname</code>,
    <code class="Nm">archive_read_disk_uname</code>,
    <code class="Nm">archive_read_disk_set_uname_lookup</code>,
    <code class="Nm">archive_read_disk_set_gname_lookup</code>,
    <code class="Nm">archive_read_disk_set_standard_lookup</code> &#x2014;
    <span class="Nd">functions for reading objects from disk</span></p>
</section>
<section class="Sh">
<h1 class="Sh" id="LIBRARY"><a class="permalink" href="#LIBRARY">LIBRARY</a></h1>
<p class="Pp">Streaming Archive Library (libarchive, -larchive)</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<p class="Pp"><code class="In">#include
    &lt;<a class="In">archive.h</a>&gt;</code></p>
<p class="Pp"><var class="Ft">struct archive *</var>
  <br/>
  <code class="Fn">archive_read_disk_new</code>(<var class="Fa" style="white-space: nowrap;">void</var>);</p>
<p class="Pp"><var class="Ft">int</var>
  <br/>
  <code class="Fn">archive_read_disk_set_behavior</code>(<var class="Fa" style="white-space: nowrap;">struct
    archive *</var>,
  <var class="Fa" style="white-space: nowrap;">int</var>);</p>
<p class="Pp"><var class="Ft">int</var>
  <br/>
  <code class="Fn">archive_read_disk_set_symlink_logical</code>(<var class="Fa" style="white-space: nowrap;">struct
    archive *</var>);</p>
<p class="Pp"><var class="Ft">int</var>
  <br/>
  <code class="Fn">archive_read_disk_set_symlink_physical</code>(<var class="Fa" style="white-space: nowrap;">struct
    archive *</var>);</p>
<p class="Pp"><var class="Ft">int</var>
  <br/>
  <code class="Fn">archive_read_disk_set_symlink_hybrid</code>(<var class="Fa" style="white-space: nowrap;">struct
    archive *</var>);</p>
<p class="Pp"><var class="Ft">const char *</var>
  <br/>
  <code class="Fn">archive_read_disk_gname</code>(<var class="Fa" style="white-space: nowrap;">struct
    archive *</var>,
  <var class="Fa" style="white-space: nowrap;">gid_t</var>);</p>
<p class="Pp"><var class="Ft">const char *</var>
  <br/>
  <code class="Fn">archive_read_disk_uname</code>(<var class="Fa" style="white-space: nowrap;">struct
    archive *</var>,
  <var class="Fa" style="white-space: nowrap;">uid_t</var>);</p>
<p class="Pp"><var class="Ft">int</var>
  <br/>
  <code class="Fn">archive_read_disk_set_gname_lookup</code>(<var class="Fa">struct
    archive *</var>, <var class="Fa">void *</var>, <var class="Fa">const char
    *(*lookup)(void *, gid_t)</var>, <var class="Fa">void (*cleanup)(void
    *)</var>);</p>
<p class="Pp"><var class="Ft">int</var>
  <br/>
  <code class="Fn">archive_read_disk_set_uname_lookup</code>(<var class="Fa">struct
    archive *</var>, <var class="Fa">void *</var>, <var class="Fa">const char
    *(*lookup)(void *, uid_t)</var>, <var class="Fa">void (*cleanup)(void
    *)</var>);</p>
<p class="Pp"><var class="Ft">int</var>
  <br/>
  <code class="Fn">archive_read_disk_set_standard_lookup</code>(<var class="Fa" style="white-space: nowrap;">struct
    archive *</var>);</p>
<p class="Pp"><var class="Ft">int</var>
  <br/>
  <code class="Fn">archive_read_disk_entry_from_file</code>(<var class="Fa">struct
    archive *</var>, <var class="Fa">struct archive_entry *</var>,
    <var class="Fa">int fd</var>, <var class="Fa">const struct stat
  *</var>);</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">These functions provide an API for reading information about
    objects on disk. In particular, they provide an interface for populating
    struct archive_entry objects.</p>
<dl class="Bl-tag">
  <dt id="archive_read_disk_new"><a class="permalink" href="#archive_read_disk_new"><code class="Fn">archive_read_disk_new</code></a>()</dt>
  <dd>Allocates and initializes a struct archive object suitable for reading
      object information from disk.</dd>
  <dt id="archive_read_disk_set_behavior"><a class="permalink" href="#archive_read_disk_set_behavior"><code class="Fn">archive_read_disk_set_behavior</code></a>()</dt>
  <dd>Configures various behavior options when reading entries from disk. The
      flags field consists of a bitwise OR of one or more of the following
      values:
    <dl class="Bl-tag Bl-compact">
      <dt id="ARCHIVE_READDISK_HONOR_NODUMP"><a class="permalink" href="#ARCHIVE_READDISK_HONOR_NODUMP"><code class="Cm">ARCHIVE_READDISK_HONOR_NODUMP</code></a></dt>
      <dd>Skip files and directories with the nodump file attribute (file flag)
          set. By default, the nodump file attribute is ignored.</dd>
      <dt id="ARCHIVE_READDISK_MAC_COPYFILE"><a class="permalink" href="#ARCHIVE_READDISK_MAC_COPYFILE"><code class="Cm">ARCHIVE_READDISK_MAC_COPYFILE</code></a></dt>
      <dd>Mac OS X specific. Read metadata (ACLs and extended attributes) with
          <a class="Xr">copyfile(3)</a>. By default, metadata is read using
          <a class="Xr">copyfile(3)</a>.</dd>
      <dt id="ARCHIVE_READDISK_NO_ACL"><a class="permalink" href="#ARCHIVE_READDISK_NO_ACL"><code class="Cm">ARCHIVE_READDISK_NO_ACL</code></a></dt>
      <dd>Do not read Access Control Lists. By default, ACLs are read from
        disk.</dd>
      <dt id="ARCHIVE_READDISK_NO_FFLAGS"><a class="permalink" href="#ARCHIVE_READDISK_NO_FFLAGS"><code class="Cm">ARCHIVE_READDISK_NO_FFLAGS</code></a></dt>
      <dd>Do not read file attributes (file flags). By default, file attributes
          are read from disk. See <a class="Xr">chattr(1)</a> (Linux) or
          <a class="Xr">chflags(1)</a> (FreeBSD, Mac OS X) for more information
          on file attributes.</dd>
      <dt id="ARCHIVE_READDISK_NO_TRAVERSE_MOUNTS"><a class="permalink" href="#ARCHIVE_READDISK_NO_TRAVERSE_MOUNTS"><code class="Cm">ARCHIVE_READDISK_NO_TRAVERSE_MOUNTS</code></a></dt>
      <dd>Do not traverse mount points. By default, mount points are
        traversed.</dd>
      <dt id="ARCHIVE_READDISK_NO_XATTR"><a class="permalink" href="#ARCHIVE_READDISK_NO_XATTR"><code class="Cm">ARCHIVE_READDISK_NO_XATTR</code></a></dt>
      <dd>Do not read extended file attributes (xattrs). By default, extended
          file attributes are read from disk. See <a class="Xr">xattr(7)</a>
          (Linux), <a class="Xr">xattr(2)</a> (Mac OS X), or
          <a class="Xr">getextattr(8)</a> (FreeBSD) for more information on
          extended file attributes.</dd>
      <dt id="ARCHIVE_READDISK_RESTORE_ATIME"><a class="permalink" href="#ARCHIVE_READDISK_RESTORE_ATIME"><code class="Cm">ARCHIVE_READDISK_RESTORE_ATIME</code></a></dt>
      <dd>Restore access time of traversed files. By default, access time of
          traversed files is not restored.</dd>
    </dl>
  </dd>
  <dt id="archive_read_disk_set_symlink_logical"><a class="permalink" href="#archive_read_disk_set_symlink_logical"><code class="Fn">archive_read_disk_set_symlink_logical</code></a>(),
    <a class="permalink" href="#archive_read_disk_set_symlink_physical"><code class="Fn" id="archive_read_disk_set_symlink_physical">archive_read_disk_set_symlink_physical</code></a>(),
    <a class="permalink" href="#archive_read_disk_set_symlink_hybrid"><code class="Fn" id="archive_read_disk_set_symlink_hybrid">archive_read_disk_set_symlink_hybrid</code></a>()</dt>
  <dd>This sets the mode used for handling symbolic links. The
      &#x201C;logical&#x201D; mode follows all symbolic links. The
      &#x201C;physical&#x201D; mode does not follow any symbolic links. The
      &#x201C;hybrid&#x201D; mode currently behaves identically to the
      &#x201C;logical&#x201D; mode.</dd>
  <dt id="archive_read_disk_gname"><a class="permalink" href="#archive_read_disk_gname"><code class="Fn">archive_read_disk_gname</code></a>(),
    <a class="permalink" href="#archive_read_disk_uname"><code class="Fn" id="archive_read_disk_uname">archive_read_disk_uname</code></a>()</dt>
  <dd>Returns a user or group name given a gid or uid value. By default, these
      always return a NULL string.</dd>
  <dt id="archive_read_disk_set_gname_lookup"><a class="permalink" href="#archive_read_disk_set_gname_lookup"><code class="Fn">archive_read_disk_set_gname_lookup</code></a>(),
    <a class="permalink" href="#archive_read_disk_set_uname_lookup"><code class="Fn" id="archive_read_disk_set_uname_lookup">archive_read_disk_set_uname_lookup</code></a>()</dt>
  <dd>These allow you to override the functions used for user and group name
      lookups. You may also provide a void * pointer to a private data structure
      and a cleanup function for that data. The cleanup function will be invoked
      when the struct archive object is destroyed or when new lookup functions
      are registered.</dd>
  <dt id="archive_read_disk_set_standard_lookup"><a class="permalink" href="#archive_read_disk_set_standard_lookup"><code class="Fn">archive_read_disk_set_standard_lookup</code></a>()</dt>
  <dd>This convenience function installs a standard set of user and group name
      lookup functions. These functions use <a class="Xr">getpwuid(3)</a> and
      <a class="Xr">getgrgid(3)</a> to convert ids to names, defaulting to NULL
      if the names cannot be looked up. These functions also implement a simple
      memory cache to reduce the number of calls to
      <a class="Xr">getpwuid(3)</a> and <a class="Xr">getgrgid(3)</a>.</dd>
  <dt id="archive_read_disk_entry_from_file"><a class="permalink" href="#archive_read_disk_entry_from_file"><code class="Fn">archive_read_disk_entry_from_file</code></a>()</dt>
  <dd>Populates a struct archive_entry object with information about a
      particular file. The archive_entry object must have already been created
      with <a class="Xr">archive_entry_new(3)</a> and at least one of the source
      path or path fields must already be set. (If both are set, the source path
      will be used.)
    <p class="Pp">Information is read from disk using the path name from the
        struct archive_entry object. If a file descriptor is provided, some
        information will be obtained using that file descriptor, on platforms
        that support the appropriate system calls.</p>
    <p class="Pp">If a pointer to a struct stat is provided, information from
        that structure will be used instead of reading from the disk where
        appropriate. This can provide performance benefits in scenarios where
        struct stat information has already been read from the disk as a side
        effect of some other operation. (For example, directory traversal
        libraries often provide this information.)</p>
    <p class="Pp">Where necessary, user and group ids are converted to user and
        group names using the currently-registered lookup functions above. This
        affects the file ownership fields and ACL values in the struct
        archive_entry object.</p>
  </dd>
</dl>
More information about the <var class="Va">struct archive</var> object and the
  overall design of the library can be found in the
  <a class="Xr">libarchive(3)</a> overview.
</section>
<section class="Sh">
<h1 class="Sh" id="EXAMPLES"><a class="permalink" href="#EXAMPLES">EXAMPLES</a></h1>
<p class="Pp">The following illustrates basic usage of the library by showing
    how to use it to copy an item on disk into an archive.</p>
<div class="Bd Pp Bd-indent Li">
<pre>void
file_to_archive(struct archive *a, const char *name)
{
  char buff[8192];
  size_t bytes_read;
  struct archive *ard;
  struct archive_entry *entry;
  int fd;

  ard = archive_read_disk_new();
  archive_read_disk_set_standard_lookup(ard);
  entry = archive_entry_new();
  fd = open(name, O_RDONLY);
  if (fd &lt; 0)
     return;
  archive_entry_copy_pathname(entry, name);
  archive_read_disk_entry_from_file(ard, entry, fd, NULL);
  archive_write_header(a, entry);
  while ((bytes_read = read(fd, buff, sizeof(buff))) &gt; 0)
    archive_write_data(a, buff, bytes_read);
  archive_write_finish_entry(a);
  archive_read_free(ard);
  archive_entry_free(entry);
}</pre>
</div>
</section>
<section class="Sh">
<h1 class="Sh" id="RETURN_VALUES"><a class="permalink" href="#RETURN_VALUES">RETURN
  VALUES</a></h1>
<p class="Pp">Most functions return <code class="Cm">ARCHIVE_OK</code> (zero) on
    success, or one of several negative error codes for errors. Specific error
    codes include: <code class="Cm">ARCHIVE_RETRY</code> for operations that
    might succeed if retried, <code class="Cm">ARCHIVE_WARN</code> for unusual
    conditions that do not prevent further operations, and
    <code class="Cm">ARCHIVE_FATAL</code> for serious errors that make remaining
    operations impossible.</p>
<p class="Pp"><code class="Fn">archive_read_disk_new</code>() returns a pointer
    to a newly-allocated struct archive object or NULL if the allocation failed
    for any reason.</p>
<p class="Pp"><code class="Fn">archive_read_disk_gname</code>() and
    <code class="Fn">archive_read_disk_uname</code>() return const char *
    pointers to the textual name or NULL if the lookup failed for any reason.
    The returned pointer points to internal storage that may be reused on the
    next call to either of these functions; callers should copy the string if
    they need to continue accessing it.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="ERRORS"><a class="permalink" href="#ERRORS">ERRORS</a></h1>
<p class="Pp">Detailed error codes and textual descriptions are available from
    the <code class="Fn">archive_errno</code>() and
    <code class="Fn">archive_error_string</code>() functions.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp"><a class="Xr">tar(1)</a>, <a class="Xr">archive_read(3)</a>,
    <a class="Xr">archive_util(3)</a>, <a class="Xr">archive_write(3)</a>,
    <a class="Xr">archive_write_disk(3)</a>, <a class="Xr">libarchive(3)</a></p>
</section>
<section class="Sh">
<h1 class="Sh" id="HISTORY"><a class="permalink" href="#HISTORY">HISTORY</a></h1>
<p class="Pp">The <code class="Nm">libarchive</code> library first appeared in
    <span class="Ux">FreeBSD 5.3</span>. The
    <code class="Nm">archive_read_disk</code> interface was added to
    <code class="Nm">libarchive 2.6</code> and first appeared in
    <span class="Ux">FreeBSD 8.0</span>.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHORS"><a class="permalink" href="#AUTHORS">AUTHORS</a></h1>
<p class="Pp">The <code class="Nm">libarchive</code> library was written by
    <span class="An">Tim Kientzle</span>
  &#x27E8;kientzle@FreeBSD.org&#x27E9;.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="BUGS"><a class="permalink" href="#BUGS">BUGS</a></h1>
<p class="Pp">The &#x201C;standard&#x201D; user name and group name lookup
    functions are not the defaults because <a class="Xr">getgrgid(3)</a> and
    <a class="Xr">getpwuid(3)</a> are sometimes too large for particular
    applications. The current design allows the application author to use a more
    compact implementation when appropriate.</p>
<p class="Pp">The full list of metadata read from disk by
    <code class="Fn">archive_read_disk_entry_from_file</code>() is necessarily
    system-dependent.</p>
<p class="Pp">The <code class="Fn">archive_read_disk_entry_from_file</code>()
    function reads as much information as it can from disk. Some method should
    be provided to limit this so that clients who do not need ACLs, for
    instance, can avoid the extra work needed to look up such information.</p>
<p class="Pp">This API should provide a set of methods for walking a directory
    tree. That would make it a direct parallel of the
    <a class="Xr">archive_read(3)</a> API. When such methods are implemented,
    the &#x201C;hybrid&#x201D; symbolic link mode will make sense.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">April 3, 2017</td>
    <td class="foot-os">Mac OS X 12</td>
  </tr>
</table>
</body>
</html>
