<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    .Nd, .Bf, .Op { display: inline; }
    .Pa, .Ad { font-style: italic; }
    .Ms { font-weight: bold; }
    .Bl-diag > dt { font-weight: bold; }
    code.Nm, .Fl, .Cm, .Ic, code.In, .Fd, .Fn, .Cd { font-weight: bold;
      font-family: inherit; }
  </style>
  <title>Math::Trig(3pm)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Math::Trig(3pm)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">Math::Trig(3pm)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Math::Trig - trigonometric functions</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>    use Math::Trig;
    $x = tan(0.9);
    $y = acos(3.7);
    $z = asin(2.4);
    $halfpi = pi/2;
    $rad = deg2rad(120);
    # Import constants pi2, pip2, pip4 (2*pi, pi/2, pi/4).
    use Math::Trig ':pi';
    # Import the conversions between cartesian/spherical/cylindrical.
    use Math::Trig ':radial';
        # Import the great circle formulas.
    use Math::Trig ':great_circle';
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp"><span class="Li">&quot;Math::Trig&quot;</span> defines many
    trigonometric functions not defined by the core Perl which defines only the
    <span class="Li">&quot;sin()&quot;</span> and
    <span class="Li">&quot;cos()&quot;</span>. The constant <b>pi</b> is also
    defined as are a few convenience functions for angle conversions, and
    <i>great circle formulas</i> for spherical movement.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="TRIGONOMETRIC_FUNCTIONS"><a class="permalink" href="#TRIGONOMETRIC_FUNCTIONS">TRIGONOMETRIC
  FUNCTIONS</a></h1>
<p class="Pp">The tangent</p>
<dl class="Bl-tag">
  <dt id="tan"><a class="permalink" href="#tan"><b>tan</b></a></dt>
  <dd></dd>
</dl>
<p class="Pp">The cofunctions of the sine, cosine, and tangent (cosec/csc and
    cotan/cot are aliases)</p>
<p class="Pp"><b>csc</b>, <b>cosec</b>, <b>sec</b>, <b>sec</b>, <b>cot</b>,
    <b>cotan</b></p>
<p class="Pp">The arcus (also known as the inverse) functions of the sine,
    cosine, and tangent</p>
<p class="Pp"><b>asin</b>, <b>acos</b>, <b>atan</b></p>
<p class="Pp">The principal value of the arc tangent of y/x</p>
<p class="Pp"><b>atan2</b>(y, x)</p>
<p class="Pp">The arcus cofunctions of the sine, cosine, and tangent
    (acosec/acsc and acotan/acot are aliases). Note that atan2(0, 0) is not
    well-defined.</p>
<p class="Pp"><b>acsc</b>, <b>acosec</b>, <b>asec</b>, <b>acot</b>,
    <b>acotan</b></p>
<p class="Pp">The hyperbolic sine, cosine, and tangent</p>
<p class="Pp"><b>sinh</b>, <b>cosh</b>, <b>tanh</b></p>
<p class="Pp">The cofunctions of the hyperbolic sine, cosine, and tangent
    (cosech/csch and cotanh/coth are aliases)</p>
<p class="Pp"><b>csch</b>, <b>cosech</b>, <b>sech</b>, <b>coth</b>,
    <b>cotanh</b></p>
<p class="Pp">The area (also known as the inverse) functions of the hyperbolic
    sine, cosine, and tangent</p>
<p class="Pp"><b>asinh</b>, <b>acosh</b>, <b>atanh</b></p>
<p class="Pp">The area cofunctions of the hyperbolic sine, cosine, and tangent
    (acsch/acosech and acoth/acotanh are aliases)</p>
<p class="Pp"><b>acsch</b>, <b>acosech</b>, <b>asech</b>, <b>acoth</b>,
    <b>acotanh</b></p>
<p class="Pp">The trigonometric constant <b>pi</b> and some of handy multiples
    of it are also defined.</p>
<p class="Pp"><b>pi, pi2, pi4, pip2, pip4</b></p>
<section class="Ss">
<h2 class="Ss">ERRORS DUE TO DIVISION BY ZERO</h2>
<p class="Pp">The following functions</p>
<p class="Pp"></p>
<pre>    acoth
    acsc
    acsch
    asec
    asech
    atanh
    cot
    coth
    csc
    csch
    sec
    sech
    tan
    tanh
</pre>
<p class="Pp">cannot be computed for all arguments because that would mean
    dividing by zero or taking logarithm of zero. These situations cause fatal
    runtime errors looking like this</p>
<p class="Pp"></p>
<pre>    cot(0): Division by zero.
    (Because in the definition of cot(0), the divisor sin(0) is 0)
    Died at ...
</pre>
<p class="Pp">or</p>
<p class="Pp"></p>
<pre>    atanh(-1): Logarithm of zero.
    Died at...
</pre>
<p class="Pp">For the <span class="Li">&quot;csc&quot;</span>,
    <span class="Li">&quot;cot&quot;</span>,
    <span class="Li">&quot;asec&quot;</span>,
    <span class="Li">&quot;acsc&quot;</span>,
    <span class="Li">&quot;acot&quot;</span>,
    <span class="Li">&quot;csch&quot;</span>,
    <span class="Li">&quot;coth&quot;</span>,
    <span class="Li">&quot;asech&quot;</span>,
    <span class="Li">&quot;acsch&quot;</span>, the argument cannot be
    <span class="Li">0</span> (zero). For the
    <span class="Li">&quot;atanh&quot;</span>,
    <span class="Li">&quot;acoth&quot;</span>, the argument cannot be
    <span class="Li">1</span> (one). For the
    <span class="Li">&quot;atanh&quot;</span>,
    <span class="Li">&quot;acoth&quot;</span>, the argument cannot be
    <span class="Li">&quot;-1&quot;</span> (minus one). For the
    <span class="Li">&quot;tan&quot;</span>,
    <span class="Li">&quot;sec&quot;</span>,
    <span class="Li">&quot;tanh&quot;</span>,
    <span class="Li">&quot;sech&quot;</span>, the argument cannot be <i>pi/2 + k
    *</i> <i>pi</i>, where <i>k</i> is any integer.</p>
<p class="Pp">Note that atan2(0, 0) is not well-defined.</p>
</section>
<section class="Ss">
<h2 class="Ss">SIMPLE (REAL) ARGUMENTS, COMPLEX RESULTS</h2>
<p class="Pp">Please note that some of the trigonometric functions can break out
    from the <b>real axis</b> into the <b>complex plane</b>. For example
    <span class="Li">asin(2)</span> has no definition for plain real numbers but
    it has definition for complex numbers.</p>
<p class="Pp">In Perl terms this means that supplying the usual Perl numbers
    (also known as scalars, please see perldata) as input for the trigonometric
    functions might produce as output results that no more are simple real
    numbers: instead they are complex numbers.</p>
<p class="Pp">The <span class="Li">&quot;Math::Trig&quot;</span> handles this by
    using the <span class="Li">&quot;Math::Complex&quot;</span> package which
    knows how to handle complex numbers, please see Math::Complex for more
    information. In practice you need not to worry about getting complex numbers
    as results because the <span class="Li">&quot;Math::Complex&quot;</span>
    takes care of details like for example how to display complex numbers. For
    example:</p>
<p class="Pp"></p>
<pre>    print asin(2), &quot;\n&quot;;
</pre>
<p class="Pp">should produce something like this (take or leave few last
    decimals):</p>
<p class="Pp"></p>
<pre>    1.5707963267949-1.31695789692482i
</pre>
<p class="Pp">That is, a complex number with the real part of approximately
    <span class="Li">1.571</span> and the imaginary part of approximately
    <span class="Li">&quot;-1.317&quot;</span>.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="PLANE_ANGLE_CONVERSIONS"><a class="permalink" href="#PLANE_ANGLE_CONVERSIONS">PLANE
  ANGLE CONVERSIONS</a></h1>
<p class="Pp">(Plane, 2-dimensional) angles may be converted with the following
    functions.</p>
<dl class="Bl-tag">
  <dt id="deg2rad"><a class="permalink" href="#deg2rad">deg2rad</a></dt>
  <dd>
    <pre>    $radians  = deg2rad($degrees);
    </pre>
  </dd>
  <dt id="grad2rad"><a class="permalink" href="#grad2rad">grad2rad</a></dt>
  <dd>
    <pre>    $radians  = grad2rad($gradians);
    </pre>
  </dd>
  <dt id="rad2deg"><a class="permalink" href="#rad2deg">rad2deg</a></dt>
  <dd>
    <pre>    $degrees  = rad2deg($radians);
    </pre>
  </dd>
  <dt id="grad2deg"><a class="permalink" href="#grad2deg">grad2deg</a></dt>
  <dd>
    <pre>    $degrees  = grad2deg($gradians);
    </pre>
  </dd>
  <dt id="deg2grad"><a class="permalink" href="#deg2grad">deg2grad</a></dt>
  <dd>
    <pre>    $gradians = deg2grad($degrees);
    </pre>
  </dd>
  <dt id="rad2grad"><a class="permalink" href="#rad2grad">rad2grad</a></dt>
  <dd>
    <pre>    $gradians = rad2grad($radians);
    </pre>
  </dd>
</dl>
<p class="Pp">The full circle is 2 <i>pi</i> radians or <i>360</i> degrees or
    <i>400</i> gradians. The result is by default wrapped to be inside the [0,
    {2pi,360,400}[ circle. If you don't want this, supply a true second
    argument:</p>
<p class="Pp"></p>
<pre>    $zillions_of_radians  = deg2rad($zillions_of_degrees, 1);
    $negative_degrees     = rad2deg($negative_radians, 1);
</pre>
<p class="Pp">You can also do the wrapping explicitly by <b>rad2rad()</b>,
    <b>deg2deg()</b>, and <b>grad2grad()</b>.</p>
<dl class="Bl-tag">
  <dt id="rad2rad"><a class="permalink" href="#rad2rad">rad2rad</a></dt>
  <dd>
    <pre>    $radians_wrapped_by_2pi = rad2rad($radians);
    </pre>
  </dd>
  <dt id="deg2deg"><a class="permalink" href="#deg2deg">deg2deg</a></dt>
  <dd>
    <pre>    $degrees_wrapped_by_360 = deg2deg($degrees);
    </pre>
  </dd>
  <dt id="grad2grad"><a class="permalink" href="#grad2grad">grad2grad</a></dt>
  <dd>
    <pre>    $gradians_wrapped_by_400 = grad2grad($gradians);
    </pre>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="RADIAL_COORDINATE_CONVERSIONS"><a class="permalink" href="#RADIAL_COORDINATE_CONVERSIONS">RADIAL
  COORDINATE CONVERSIONS</a></h1>
<p class="Pp"><b>Radial coordinate systems</b> are the <b>spherical</b> and the
    <b>cylindrical</b> systems, explained shortly in more detail.</p>
<p class="Pp">You can import radial coordinate conversion functions by using the
    <span class="Li">&quot;:radial&quot;</span> tag:</p>
<p class="Pp"></p>
<pre>    use Math::Trig ':radial';
    ($rho, $theta, $z)     = cartesian_to_cylindrical($x, $y, $z);
    ($rho, $theta, $phi)   = cartesian_to_spherical($x, $y, $z);
    ($x, $y, $z)           = cylindrical_to_cartesian($rho, $theta, $z);
    ($rho_s, $theta, $phi) = cylindrical_to_spherical($rho_c, $theta, $z);
    ($x, $y, $z)           = spherical_to_cartesian($rho, $theta, $phi);
    ($rho_c, $theta, $z)   = spherical_to_cylindrical($rho_s, $theta, $phi);
</pre>
<p class="Pp"><b>All angles are in radians</b>.</p>
<section class="Ss">
<h2 class="Ss">COORDINATE SYSTEMS</h2>
<p class="Pp"><b>Cartesian</b> coordinates are the usual rectangular <i>(x, y,
    z)</i>-coordinates.</p>
<p class="Pp">Spherical coordinates, <i>(rho, theta, pi)</i>, are
    three-dimensional coordinates which define a point in three-dimensional
    space. They are based on a sphere surface. The radius of the sphere is
    <b>rho</b>, also known as the <i>radial</i> coordinate. The angle in the
    <i>xy</i>-plane (around the <i>z</i>-axis) is <b>theta</b>, also known as
    the <i>azimuthal</i> coordinate. The angle from the <i>z</i>-axis is
    <b>phi</b>, also known as the <i>polar</i> coordinate. The North Pole is
    therefore <i>0, 0, rho</i>, and the Gulf of Guinea (think of the missing big
    chunk of Africa) <i>0,</i> <i>pi/2, rho</i>. In geographical terms
    <i>phi</i> is latitude (northward positive, southward negative) and
    <i>theta</i> is longitude (eastward positive, westward negative).</p>
<p class="Pp"><b>BEWARE</b>: some texts define <i>theta</i> and <i>phi</i> the
    other way round, some texts define the <i>phi</i> to start from the
    horizontal plane, some texts use <i>r</i> in place of <i>rho</i>.</p>
<p class="Pp">Cylindrical coordinates, <i>(rho, theta, z)</i>, are
    three-dimensional coordinates which define a point in three-dimensional
    space. They are based on a cylinder surface. The radius of the cylinder is
    <b>rho</b>, also known as the <i>radial</i> coordinate. The angle in the
    <i>xy</i>-plane (around the <i>z</i>-axis) is <b>theta</b>, also known as
    the <i>azimuthal</i> coordinate. The third coordinate is the <i>z</i>,
    pointing up from the <b>theta</b>-plane.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="3"><a class="permalink" href="#3">3-D ANGLE
  CONVERSIONS</a></h2>
<p class="Pp">Conversions to and from spherical and cylindrical coordinates are
    available. Please notice that the conversions are not necessarily reversible
    because of the equalities like <i>pi</i> angles being equal to <i>-pi</i>
    angles.</p>
<dl class="Bl-tag">
  <dt id="cartesian_to_cylindrical"><a class="permalink" href="#cartesian_to_cylindrical">cartesian_to_cylindrical</a></dt>
  <dd>
    <pre>    ($rho, $theta, $z) = cartesian_to_cylindrical($x, $y, $z);
    </pre>
  </dd>
  <dt id="cartesian_to_spherical"><a class="permalink" href="#cartesian_to_spherical">cartesian_to_spherical</a></dt>
  <dd>
    <pre>    ($rho, $theta, $phi) = cartesian_to_spherical($x, $y, $z);
    </pre>
  </dd>
  <dt id="cylindrical_to_cartesian"><a class="permalink" href="#cylindrical_to_cartesian">cylindrical_to_cartesian</a></dt>
  <dd>
    <pre>    ($x, $y, $z) = cylindrical_to_cartesian($rho, $theta, $z);
    </pre>
  </dd>
  <dt id="cylindrical_to_spherical"><a class="permalink" href="#cylindrical_to_spherical">cylindrical_to_spherical</a></dt>
  <dd>
    <pre>    ($rho_s, $theta, $phi) = cylindrical_to_spherical($rho_c, $theta, $z);
    </pre>
    <p class="Pp">Notice that when <span class="Li">$z</span> is not 0
        <span class="Li">$rho_s</span> is not equal to
        <span class="Li">$rho_c</span>.</p>
  </dd>
  <dt id="spherical_to_cartesian"><a class="permalink" href="#spherical_to_cartesian">spherical_to_cartesian</a></dt>
  <dd>
    <pre>    ($x, $y, $z) = spherical_to_cartesian($rho, $theta, $phi);
    </pre>
  </dd>
  <dt id="spherical_to_cylindrical"><a class="permalink" href="#spherical_to_cylindrical">spherical_to_cylindrical</a></dt>
  <dd>
    <pre>    ($rho_c, $theta, $z) = spherical_to_cylindrical($rho_s, $theta, $phi);
    </pre>
    <p class="Pp">Notice that when <span class="Li">$z</span> is not 0
        <span class="Li">$rho_c</span> is not equal to
        <span class="Li">$rho_s</span>.</p>
  </dd>
</dl>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="GREAT_CIRCLE_DISTANCES_AND_DIRECTIONS"><a class="permalink" href="#GREAT_CIRCLE_DISTANCES_AND_DIRECTIONS">GREAT
  CIRCLE DISTANCES AND DIRECTIONS</a></h1>
<p class="Pp">A great circle is section of a circle that contains the circle
    diameter: the shortest distance between two (non-antipodal) points on the
    spherical surface goes along the great circle connecting those two
  points.</p>
<section class="Ss">
<h2 class="Ss" id="great_circle_distance"><a class="permalink" href="#great_circle_distance">great_circle_distance</a></h2>
<p class="Pp">You can compute spherical distances, called <b>great circle
    distances</b>, by importing the <b>great_circle_distance()</b> function:</p>
<p class="Pp"></p>
<pre>  use Math::Trig 'great_circle_distance';
  $distance = great_circle_distance($theta0, $phi0, $theta1, $phi1, [, $rho]);
</pre>
<p class="Pp">The <i>great circle distance</i> is the shortest distance between
    two points on a sphere. The distance is in <span class="Li">$rho</span>
    units. The <span class="Li">$rho</span> is optional, it defaults to 1 (the
    unit sphere), therefore the distance defaults to radians.</p>
<p class="Pp">If you think geographically the <i>theta</i> are longitudes: zero
    at the Greenwhich meridian, eastward positive, westward negative -- and the
    <i>phi</i> are latitudes: zero at the North Pole, northward positive,
    southward negative. <b>NOTE</b>: this formula thinks in mathematics, not
    geographically: the <i>phi</i> zero is at the North Pole, not at the Equator
    on the west coast of Africa (Bay of Guinea). You need to subtract your
    geographical coordinates from <i>pi/2</i> (also known as 90 degrees).</p>
<p class="Pp"></p>
<pre>  $distance = great_circle_distance($lon0, pi/2 - $lat0,
                                    $lon1, pi/2 - $lat1, $rho);
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="great_circle_direction"><a class="permalink" href="#great_circle_direction">great_circle_direction</a></h2>
<p class="Pp">The direction you must follow the great circle (also known as
    <i>bearing</i>) can be computed by the <b>great_circle_direction()</b>
    function:</p>
<p class="Pp"></p>
<pre>  use Math::Trig 'great_circle_direction';
  $direction = great_circle_direction($theta0, $phi0, $theta1, $phi1);
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="great_circle_bearing"><a class="permalink" href="#great_circle_bearing">great_circle_bearing</a></h2>
<p class="Pp">Alias 'great_circle_bearing' for 'great_circle_direction' is also
    available.</p>
<p class="Pp"></p>
<pre>  use Math::Trig 'great_circle_bearing';
  $direction = great_circle_bearing($theta0, $phi0, $theta1, $phi1);
</pre>
<p class="Pp">The result of great_circle_direction is in radians, zero
    indicating straight north, pi or -pi straight south, pi/2 straight west, and
    -pi/2 straight east.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="great_circle_destination"><a class="permalink" href="#great_circle_destination">great_circle_destination</a></h2>
<p class="Pp">You can inversely compute the destination if you know the starting
    point, direction, and distance:</p>
<p class="Pp"></p>
<pre>  use Math::Trig 'great_circle_destination';
  # $diro is the original direction,
  # for example from great_circle_bearing().
  # $distance is the angular distance in radians,
  # for example from great_circle_distance().
  # $thetad and $phid are the destination coordinates,
  # $dird is the final direction at the destination.
  ($thetad, $phid, $dird) =
    great_circle_destination($theta, $phi, $diro, $distance);
</pre>
<p class="Pp">or the midpoint if you know the end points:</p>
</section>
<section class="Ss">
<h2 class="Ss" id="great_circle_midpoint"><a class="permalink" href="#great_circle_midpoint">great_circle_midpoint</a></h2>
<pre>  use Math::Trig 'great_circle_midpoint';
  ($thetam, $phim) =
    great_circle_midpoint($theta0, $phi0, $theta1, $phi1);
</pre>
<p class="Pp">The <b>great_circle_midpoint()</b> is just a special case of</p>
</section>
<section class="Ss">
<h2 class="Ss" id="great_circle_waypoint"><a class="permalink" href="#great_circle_waypoint">great_circle_waypoint</a></h2>
<pre>  use Math::Trig 'great_circle_waypoint';
  ($thetai, $phii) =
    great_circle_waypoint($theta0, $phi0, $theta1, $phi1, $way);
</pre>
<p class="Pp">Where the <span class="Li">$way</span> is a value from zero
    ($theta0, <span class="Li">$phi0</span>) to one ($theta1,
    <span class="Li">$phi1</span>). Note that antipodal points (where their
    distance is <i>pi</i> radians) do not have waypoints between them (they
    would have an an &quot;equator&quot; between them), and therefore
    <span class="Li">&quot;undef&quot;</span> is returned for antipodal points.
    If the points are the same and the distance therefore zero and all waypoints
    therefore identical, the first point (either point) is returned.</p>
<p class="Pp">The thetas, phis, direction, and distance in the above are all in
    radians.</p>
<p class="Pp">You can import all the great circle formulas by</p>
<p class="Pp"></p>
<pre>  use Math::Trig ':great_circle';
</pre>
<p class="Pp">Notice that the resulting directions might be somewhat surprising
    if you are looking at a flat worldmap: in such map projections the great
    circles quite often do not look like the shortest routes -- but for example
    the shortest possible routes from Europe or North America to Asia do often
    cross the polar regions. (The common Mercator projection does <b>not</b>
    show great circles as straight lines: straight lines in the Mercator
    projection are lines of constant bearing.)</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="EXAMPLES"><a class="permalink" href="#EXAMPLES">EXAMPLES</a></h1>
<p class="Pp">To calculate the distance between London (51.3N 0.5W) and Tokyo
    (35.7N 139.8E) in kilometers:</p>
<p class="Pp"></p>
<pre>    use Math::Trig qw(great_circle_distance deg2rad);
    # Notice the 90 - latitude: phi zero is at the North Pole.
    sub NESW { deg2rad($_[0]), deg2rad(90 - $_[1]) }
    my @L = NESW( -0.5, 51.3);
    my @T = NESW(139.8, 35.7);
    my $km = great_circle_distance(@L, @T, 6378); # About 9600 km.
</pre>
<p class="Pp">The direction you would have to go from London to Tokyo (in
    radians, straight north being zero, straight east being pi/2).</p>
<p class="Pp"></p>
<pre>    use Math::Trig qw(great_circle_direction);
    my $rad = great_circle_direction(@L, @T); # About 0.547 or 0.174 pi.
</pre>
<p class="Pp">The midpoint between London and Tokyo being</p>
<p class="Pp"></p>
<pre>    use Math::Trig qw(great_circle_midpoint);
    my @M = great_circle_midpoint(@L, @T);
</pre>
<p class="Pp">or about 69 N 89 E, in the frozen wastes of Siberia.</p>
<p class="Pp"><b>NOTE</b>: you <b>cannot</b> get from A to B like this:</p>
<p class="Pp"></p>
<pre>   Dist = great_circle_distance(A, B)
   Dir  = great_circle_direction(A, B)
   C    = great_circle_destination(A, Dist, Dir)
</pre>
<p class="Pp">and expect C to be B, because the bearing constantly changes when
    going from A to B (except in some special case like the meridians or the
    circles of latitudes) and in <b>great_circle_destination()</b> one gives a
    <b>constant</b> bearing to follow.</p>
<section class="Ss">
<h2 class="Ss">CAVEAT FOR GREAT CIRCLE FORMULAS</h2>
<p class="Pp">The answers may be off by few percentages because of the irregular
    (slightly aspherical) form of the Earth. The errors are at worst about
    0.55%, but generally below 0.3%.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Real-valued_asin_and_acos"><a class="permalink" href="#Real-valued_asin_and_acos">Real-valued
  asin and acos</a></h2>
<p class="Pp">For small inputs <b>asin()</b> and <b>acos()</b> may return
    complex numbers even when real numbers would be enough and correct, this
    happens because of floating-point inaccuracies. You can see these
    inaccuracies for example by trying theses:</p>
<p class="Pp"></p>
<pre>  print cos(1e-6)**2+sin(1e-6)**2 - 1,&quot;\n&quot;;
  printf &quot;%.20f&quot;, cos(1e-6)**2+sin(1e-6)**2,&quot;\n&quot;;
</pre>
<p class="Pp">which will print something like this</p>
<p class="Pp"></p>
<pre>  -1.11022302462516e-16
  0.99999999999999988898
</pre>
<p class="Pp">even though the expected results are of course exactly zero and
    one. The formulas used to compute <b>asin()</b> and <b>acos()</b> are quite
    sensitive to this, and therefore they might accidentally slip into the
    complex plane even when they should not. To counter this there are two
    interfaces that are guaranteed to return a real-valued output.</p>
<dl class="Bl-tag">
  <dt id="asin_real"><a class="permalink" href="#asin_real">asin_real</a></dt>
  <dd>
    <pre>    use Math::Trig qw(asin_real);
    $real_angle = asin_real($input_sin);
    </pre>
    <p class="Pp">Return a real-valued arcus sine if the input is between [-1,
        1], <b>inclusive</b> the endpoints. For inputs greater than one, pi/2 is
        returned. For inputs less than minus one, -pi/2 is returned.</p>
  </dd>
  <dt id="acos_real"><a class="permalink" href="#acos_real">acos_real</a></dt>
  <dd>
    <pre>    use Math::Trig qw(acos_real);
    $real_angle = acos_real($input_cos);
    </pre>
    <p class="Pp">Return a real-valued arcus cosine if the input is between [-1,
        1], <b>inclusive</b> the endpoints. For inputs greater than one, zero is
        returned. For inputs less than minus one, pi is returned.</p>
  </dd>
</dl>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="BUGS"><a class="permalink" href="#BUGS">BUGS</a></h1>
<p class="Pp">Saying <span class="Li">&quot;use Math::Trig;&quot;</span> exports
    many mathematical routines in the caller environment and even overrides some
    (<span class="Li">&quot;sin&quot;</span>,
    <span class="Li">&quot;cos&quot;</span>). This is construed as a feature by
    the Authors, actually... ;-)</p>
<p class="Pp">The code is not optimized for speed, especially because we use
    <span class="Li">&quot;Math::Complex&quot;</span> and thus go quite near
    complex numbers while doing the computations even when the arguments are
    not. This, however, cannot be completely avoided if we want things like
    <span class="Li">asin(2)</span> to give an answer instead of giving a fatal
    runtime error.</p>
<p class="Pp">Do not attempt navigation using these formulas.</p>
<p class="Pp">Math::Complex</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHORS"><a class="permalink" href="#AUTHORS">AUTHORS</a></h1>
<p class="Pp">Jarkko Hietaniemi &lt;<i>jhi!at!iki.fi</i>&gt;, Raphael Manfredi
    &lt;<i>Raphael_Manfredi!at!pobox.com</i>&gt;, Zefram
  &lt;zefram@fysh.org&gt;</p>
</section>
<section class="Sh">
<h1 class="Sh" id="LICENSE"><a class="permalink" href="#LICENSE">LICENSE</a></h1>
<p class="Pp">This library is free software; you can redistribute it and/or
    modify it under the same terms as Perl itself.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2019-10-21</td>
    <td class="foot-os">perl v5.30.3</td>
  </tr>
</table>
</body>
</html>
