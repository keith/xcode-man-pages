<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    .Nd, .Bf, .Op { display: inline; }
    .Pa, .Ad { font-style: italic; }
    .Ms { font-weight: bold; }
    .Bl-diag > dt { font-weight: bold; }
    code.Nm, .Fl, .Cm, .Ic, code.In, .Fd, .Fn, .Cd { font-weight: bold;
      font-family: inherit; }
  </style>
  <title>DBIx::Class::Row(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">DBIx::Class::Row(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">DBIx::Class::Row(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">DBIx::Class::Row - Basic row methods</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">This class is responsible for defining and doing basic operations
    on rows derived from DBIx::Class::ResultSource objects.</p>
<p class="Pp">Result objects are returned from DBIx::Class::ResultSets using the
    create, find, next and all methods, as well as invocations of 'single' (
    belongs_to, has_one or might_have) relationship accessors of Result
  objects.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="NOTE"><a class="permalink" href="#NOTE">NOTE</a></h1>
<p class="Pp">All &quot;Row objects&quot; derived from a Schema-attached
    DBIx::Class::ResultSet object (such as a typical
    <span class="Li">&quot;search-&gt;</span> <span class="Li">next&quot;</span>
    call) are actually Result instances, based on your application's Result
    Class.</p>
<p class="Pp">DBIx::Class::Row implements most of the row-based communication
    with the underlying storage, but a Result class <b>should not inherit from
    it directly</b>. Usually, Result classes inherit from DBIx::Class::Core,
    which in turn combines the methods from several classes, one of them being
    DBIx::Class::Row. Therefore, while many of the methods available to a
    DBIx::Class::Core-derived Result class are described in the following
    documentation, it does not detail all of the methods available to Result
    objects. Refer to DBIx::Class::Manual::ResultClass for more info.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="METHODS"><a class="permalink" href="#METHODS">METHODS</a></h1>
<section class="Ss">
<h2 class="Ss" id="new"><a class="permalink" href="#new">new</a></h2>
<pre>  my $result = My::Class-&gt;new(\%attrs);
  my $result = $schema-&gt;resultset('MySource')-&gt;new(\%colsandvalues);
</pre>
<dl class="Bl-tag">
  <dt id="Arguments:"><a class="permalink" href="#Arguments:">Arguments: \%attrs
    or \%colsandvalues</a></dt>
  <dd></dd>
  <dt id="Return"><a class="permalink" href="#Return">Return Value:
    $result</a></dt>
  <dd></dd>
</dl>
<p class="Pp">While you can create a new result object by calling
    <span class="Li">&quot;new&quot;</span> directly on this class, you are
    better off calling it on a DBIx::Class::ResultSet object.</p>
<p class="Pp">When calling it directly, you will not get a complete, usable row
    object until you pass or set the
    <span class="Li">&quot;result_source&quot;</span> attribute, to a
    DBIx::Class::ResultSource instance that is attached to a DBIx::Class::Schema
    with a valid connection.</p>
<p class="Pp"><span class="Li">$attrs</span> is a hashref of column name, value
    data. It can also contain some other attributes such as the
    <span class="Li">&quot;result_source&quot;</span>.</p>
<p class="Pp">Passing an object, or an arrayref of objects as a value will call
    &quot;set_from_related&quot; in DBIx::Class::Relationship::Base for you.
    When passed a hashref or an arrayref of hashrefs as the value, these will be
    turned into objects via new_related, and treated as if you had passed
    objects.</p>
<p class="Pp">For a more involved explanation, see &quot;create&quot; in
    DBIx::Class::ResultSet.</p>
<p class="Pp">Please note that if a value is not passed to new, no value will be
    sent in the SQL INSERT call, and the column will therefore assume whatever
    default value was specified in your database. While DBIC will retrieve the
    value of autoincrement columns, it will never make an explicit database trip
    to retrieve default values assigned by the RDBMS. You can explicitly request
    that all values be fetched back from the database by calling
    &quot;discard_changes&quot;, or you can supply an explicit
    <span class="Li">&quot;undef&quot;</span> to columns with NULL as the
    default, and save yourself a SELECT.</p>
<p class="Pp"></p>
<pre> CAVEAT:
 The behavior described above will backfire if you use a foreign key column
 with a database-defined default. If you call the relationship accessor on
 an object that doesn't have a set value for the FK column, DBIC will throw
 an exception, as it has no way of knowing the PK of the related object (if
 there is one).
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="$column_accessor"><a class="permalink" href="#$column_accessor">$column_accessor</a></h2>
<pre>  # Each pair does the same thing
  # (un-inflated, regular column)
  my $val = $result-&gt;get_column('first_name');
  my $val = $result-&gt;first_name;
  $result-&gt;set_column('first_name' =&gt; $val);
  $result-&gt;first_name($val);
  # (inflated column via DBIx::Class::InflateColumn::DateTime)
  my $val = $result-&gt;get_inflated_column('last_modified');
  my $val = $result-&gt;last_modified;
  $result-&gt;set_inflated_column('last_modified' =&gt; $val);
  $result-&gt;last_modified($val);
</pre>
<dl class="Bl-tag">
  <dt id="Arguments:~2"><a class="permalink" href="#Arguments:~2">Arguments:
    $value?</a></dt>
  <dd></dd>
  <dt id="Return~2"><a class="permalink" href="#Return~2">Return Value:
    $value</a></dt>
  <dd></dd>
</dl>
<p class="Pp">A column accessor method is created for each column, which is used
    for getting/setting the value for that column.</p>
<p class="Pp">The actual method name is based on the accessor name given during
    the Result Class column definition . Like &quot;set_column&quot;, this will
    not store the data in the database until &quot;insert&quot; or
    &quot;update&quot; is called on the row.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="insert"><a class="permalink" href="#insert">insert</a></h2>
<pre>  $result-&gt;insert;
</pre>
<dl class="Bl-tag">
  <dt id="Arguments:~3"><a class="permalink" href="#Arguments:~3">Arguments:
    none</a></dt>
  <dd></dd>
  <dt id="Return~3"><a class="permalink" href="#Return~3">Return Value:
    $result</a></dt>
  <dd></dd>
</dl>
<p class="Pp">Inserts an object previously created by &quot;new&quot; into the
    database if it isn't already in there. Returns the object itself. To insert
    an entirely new row into the database, use &quot;create&quot; in
    DBIx::Class::ResultSet.</p>
<p class="Pp">To fetch an uninserted result object, call new_result on a
    resultset.</p>
<p class="Pp">This will also insert any uninserted, related objects held inside
    this one, see &quot;create&quot; in DBIx::Class::ResultSet for more
  details.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="in_storage"><a class="permalink" href="#in_storage">in_storage</a></h2>
<pre>  $result-&gt;in_storage; # Get value
  $result-&gt;in_storage(1); # Set value
</pre>
<dl class="Bl-tag">
  <dt id="Arguments:~4"><a class="permalink" href="#Arguments:~4">Arguments:
    none or 1|0</a></dt>
  <dd></dd>
  <dt id="Return~4"><a class="permalink" href="#Return~4">Return Value:
    1|0</a></dt>
  <dd></dd>
</dl>
<p class="Pp">Indicates whether the object exists as a row in the database or
    not. This is set to true when &quot;find&quot; in DBIx::Class::ResultSet,
    &quot;create&quot; in DBIx::Class::ResultSet or &quot;insert&quot; in
    DBIx::Class::Row are invoked.</p>
<p class="Pp">Creating a result object using &quot;new_result&quot; in
    DBIx::Class::ResultSet, or calling &quot;delete&quot; on one, sets it to
    false.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="update"><a class="permalink" href="#update">update</a></h2>
<pre>  $result-&gt;update(\%columns?)
</pre>
<dl class="Bl-tag">
  <dt id="Arguments:~5"><a class="permalink" href="#Arguments:~5">Arguments:
    none or a hashref</a></dt>
  <dd></dd>
  <dt id="Return~5"><a class="permalink" href="#Return~5">Return Value:
    $result</a></dt>
  <dd></dd>
</dl>
<p class="Pp">Throws an exception if the result object is not yet in the
    database, according to &quot;in_storage&quot;. Returns the object
  itself.</p>
<p class="Pp">This method issues an SQL UPDATE query to commit any changes to
    the object to the database if required (see &quot;get_dirty_columns&quot;).
    It throws an exception if a proper WHERE clause uniquely identifying the
    database row can not be constructed (see significance of primary keys for
    more details).</p>
<p class="Pp">Also takes an optional hashref of
    <span class="Li">&quot;column_name =&gt; value&quot;</span> pairs to update
    on the object first. Be aware that the hashref will be passed to
    <span class="Li">&quot;set_inflated_columns&quot;</span>, which might edit
    it in place, so don't rely on it being the same after a call to
    <span class="Li">&quot;update&quot;</span>. If you need to preserve the
    hashref, it is sufficient to pass a shallow copy to
    <span class="Li">&quot;update&quot;</span>, e.g. ( { %{
    <span class="Li">$href</span> } } )</p>
<p class="Pp">If the values passed or any of the column values set on the object
    contain scalar references, e.g.:</p>
<p class="Pp"></p>
<pre>  $result-&gt;last_modified(\'NOW()')-&gt;update();
  # OR
  $result-&gt;update({ last_modified =&gt; \'NOW()' });
</pre>
<p class="Pp">The update will pass the values verbatim into SQL. (See
    SQL::Abstract docs). The values in your Result object will NOT change as a
    result of the update call, if you want the object to be updated with the
    actual values from the database, call &quot;discard_changes&quot; after the
    update.</p>
<p class="Pp"></p>
<pre>  $result-&gt;update()-&gt;discard_changes();
</pre>
<p class="Pp">To determine before calling this method, which column values have
    changed and will be updated, call &quot;get_dirty_columns&quot;.</p>
<p class="Pp">To check if any columns will be updated, call
    &quot;is_changed&quot;.</p>
<p class="Pp">To force a column to be updated, call
    &quot;make_column_dirty&quot; before this method.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="delete"><a class="permalink" href="#delete">delete</a></h2>
<pre>  $result-&gt;delete
</pre>
<dl class="Bl-tag">
  <dt id="Arguments:~6"><a class="permalink" href="#Arguments:~6">Arguments:
    none</a></dt>
  <dd></dd>
  <dt id="Return~6"><a class="permalink" href="#Return~6">Return Value:
    $result</a></dt>
  <dd></dd>
</dl>
<p class="Pp">Throws an exception if the object is not in the database according
    to &quot;in_storage&quot;. Also throws an exception if a proper WHERE clause
    uniquely identifying the database row can not be constructed (see
    significance of primary keys for more details).</p>
<p class="Pp">The object is still perfectly usable, but &quot;in_storage&quot;
    will now return 0 and the object must be reinserted using &quot;insert&quot;
    before it can be used to &quot;update&quot; the row again.</p>
<p class="Pp">If you delete an object in a class with a
    <span class="Li">&quot;has_many&quot;</span> relationship, an attempt is
    made to delete all the related objects as well. To turn this behaviour off,
    pass <span class="Li">&quot;cascade_delete =&gt; 0&quot;</span> in the
    <span class="Li">$attr</span> hashref of the relationship, see
    DBIx::Class::Relationship. Any database-level cascade or restrict will take
    precedence over a DBIx-Class-based cascading delete, since DBIx-Class
    <b>deletes the</b> <b>main row first</b> and only then attempts to delete
    any remaining related rows.</p>
<p class="Pp">If you delete an object within a <b>txn_do()</b> (see
    &quot;txn_do&quot; in DBIx::Class::Storage) and the transaction subsequently
    fails, the result object will remain marked as not being in storage. If you
    know for a fact that the object is still in storage (i.e. by inspecting the
    cause of the transaction's failure), you can use
    <span class="Li">&quot;$obj-&gt;in_storage(1)&quot;</span> to restore
    consistency between the object and the database. This would allow a
    subsequent <span class="Li">&quot;$obj-&gt;delete&quot;</span> to work as
    expected.</p>
<p class="Pp">See also &quot;delete&quot; in DBIx::Class::ResultSet.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="get_column"><a class="permalink" href="#get_column">get_column</a></h2>
<pre>  my $val = $result-&gt;get_column($col);
</pre>
<dl class="Bl-tag">
  <dt id="Arguments:~7"><a class="permalink" href="#Arguments:~7">Arguments:
    $columnname</a></dt>
  <dd></dd>
  <dt id="Return~7"><a class="permalink" href="#Return~7">Return Value: The
    value of the column</a></dt>
  <dd></dd>
</dl>
<p class="Pp">Throws an exception if the column name given doesn't exist
    according to has_column.</p>
<p class="Pp">Returns a raw column value from the result object, if it has
    already been fetched from the database or set by an accessor.</p>
<p class="Pp">If an inflated value has been set, it will be deflated and
    returned.</p>
<p class="Pp">Note that if you used the
    <span class="Li">&quot;columns&quot;</span> or the
    <span class="Li">&quot;select/as&quot;</span> search attributes on the
    resultset from which <span class="Li">$result</span> was derived, and <b>did
    not include</b> <span class="Li">$columnname</span> in the list, this method
    will return <span class="Li">&quot;undef&quot;</span> even if the database
    contains some value.</p>
<p class="Pp">To retrieve all loaded column values as a hash, use
    &quot;get_columns&quot;.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="has_column_loaded"><a class="permalink" href="#has_column_loaded">has_column_loaded</a></h2>
<pre>  if ( $result-&gt;has_column_loaded($col) ) {
     print &quot;$col has been loaded from db&quot;;
  }
</pre>
<dl class="Bl-tag">
  <dt id="Arguments:~8"><a class="permalink" href="#Arguments:~8">Arguments:
    $columnname</a></dt>
  <dd></dd>
  <dt id="Return~8"><a class="permalink" href="#Return~8">Return Value:
    0|1</a></dt>
  <dd></dd>
</dl>
<p class="Pp">Returns a true value if the column value has been loaded from the
    database (or set locally).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="get_columns"><a class="permalink" href="#get_columns">get_columns</a></h2>
<pre>  my %data = $result-&gt;get_columns;
</pre>
<dl class="Bl-tag">
  <dt id="Arguments:~9"><a class="permalink" href="#Arguments:~9">Arguments:
    none</a></dt>
  <dd></dd>
  <dt id="Return~9"><a class="permalink" href="#Return~9">Return Value: A hash
    of columnname, value pairs.</a></dt>
  <dd></dd>
</dl>
<p class="Pp">Returns all loaded column data as a hash, containing raw values.
    To get just one value for a particular column, use
  &quot;get_column&quot;.</p>
<p class="Pp">See &quot;get_inflated_columns&quot; to get the inflated
  values.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="get_dirty_columns"><a class="permalink" href="#get_dirty_columns">get_dirty_columns</a></h2>
<pre>  my %data = $result-&gt;get_dirty_columns;
</pre>
<dl class="Bl-tag">
  <dt id="Arguments:~10"><a class="permalink" href="#Arguments:~10">Arguments:
    none</a></dt>
  <dd></dd>
  <dt id="Return~10"><a class="permalink" href="#Return~10">Return Value: A hash
    of column, value pairs</a></dt>
  <dd></dd>
</dl>
<p class="Pp">Only returns the column, value pairs for those columns that have
    been changed on this object since the last &quot;update&quot; or
    &quot;insert&quot; call.</p>
<p class="Pp">See &quot;get_columns&quot; to fetch all column/value pairs.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="make_column_dirty"><a class="permalink" href="#make_column_dirty">make_column_dirty</a></h2>
<pre>  $result-&gt;make_column_dirty($col)
</pre>
<dl class="Bl-tag">
  <dt id="Arguments:~11"><a class="permalink" href="#Arguments:~11">Arguments:
    $columnname</a></dt>
  <dd></dd>
  <dt id="Return~11"><a class="permalink" href="#Return~11">Return Value: not
    defined</a></dt>
  <dd></dd>
</dl>
<p class="Pp">Throws an exception if the column does not exist.</p>
<p class="Pp">Marks a column as having been changed regardless of whether it has
    really changed.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="get_inflated_columns"><a class="permalink" href="#get_inflated_columns">get_inflated_columns</a></h2>
<pre>  my %inflated_data = $obj-&gt;get_inflated_columns;
</pre>
<dl class="Bl-tag">
  <dt id="Arguments:~12"><a class="permalink" href="#Arguments:~12">Arguments:
    none</a></dt>
  <dd></dd>
  <dt id="Return~12"><a class="permalink" href="#Return~12">Return Value: A hash
    of column, object|value pairs</a></dt>
  <dd></dd>
</dl>
<p class="Pp">Returns a hash of all column keys and associated values. Values
    for any columns set to use inflation will be inflated and returns as
    objects.</p>
<p class="Pp">See &quot;get_columns&quot; to get the uninflated values.</p>
<p class="Pp">See DBIx::Class::InflateColumn for how to setup inflation.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="set_column"><a class="permalink" href="#set_column">set_column</a></h2>
<pre>  $result-&gt;set_column($col =&gt; $val);
</pre>
<dl class="Bl-tag">
  <dt id="Arguments:~13"><a class="permalink" href="#Arguments:~13">Arguments:
    $columnname, $value</a></dt>
  <dd></dd>
  <dt id="Return~13"><a class="permalink" href="#Return~13">Return Value:
    $value</a></dt>
  <dd></dd>
</dl>
<p class="Pp">Sets a raw column value. If the new value is different from the
    old one, the column is marked as dirty for when you next call
    &quot;update&quot;.</p>
<p class="Pp">If passed an object or reference as a value, this method will
    happily attempt to store it, and a later &quot;insert&quot; or
    &quot;update&quot; will try and stringify/numify as appropriate. To set an
    object to be deflated instead, see &quot;set_inflated_columns&quot;, or
    better yet, use &quot;$column_accessor&quot;.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="set_columns"><a class="permalink" href="#set_columns">set_columns</a></h2>
<pre>  $result-&gt;set_columns({ $col =&gt; $val, ... });
</pre>
<dl class="Bl-tag">
  <dt id="Arguments:~14"><a class="permalink" href="#Arguments:~14">Arguments:
    \%columndata</a></dt>
  <dd></dd>
  <dt id="Return~14"><a class="permalink" href="#Return~14">Return Value:
    $result</a></dt>
  <dd></dd>
</dl>
<p class="Pp">Sets multiple column, raw value pairs at once.</p>
<p class="Pp">Works as &quot;set_column&quot;.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="set_inflated_columns"><a class="permalink" href="#set_inflated_columns">set_inflated_columns</a></h2>
<pre>  $result-&gt;set_inflated_columns({ $col =&gt; $val, $rel_name =&gt; $obj, ... });
</pre>
<dl class="Bl-tag">
  <dt id="Arguments:~15"><a class="permalink" href="#Arguments:~15">Arguments:
    \%columndata</a></dt>
  <dd></dd>
  <dt id="Return~15"><a class="permalink" href="#Return~15">Return Value:
    $result</a></dt>
  <dd></dd>
</dl>
<p class="Pp">Sets more than one column value at once. Any inflated values are
    deflated and the raw values stored.</p>
<p class="Pp">Any related values passed as Result objects, using the relation
    name as a key, are reduced to the appropriate foreign key values and stored.
    If instead of related result objects, a hashref of column, value data is
    passed, will create the related object first then store.</p>
<p class="Pp">Will even accept arrayrefs of data as a value to a
    &quot;has_many&quot; in DBIx::Class::Relationship key, and create the
    related objects if necessary.</p>
<p class="Pp">Be aware that the input hashref might be edited in place, so don't
    rely on it being the same after a call to
    <span class="Li">&quot;set_inflated_columns&quot;</span>. If you need to
    preserve the hashref, it is sufficient to pass a shallow copy to
    <span class="Li">&quot;set_inflated_columns&quot;</span>, e.g. ( { %{
    <span class="Li">$href</span> } } )</p>
<p class="Pp">See also &quot;set_from_related&quot; in
    DBIx::Class::Relationship::Base.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="copy"><a class="permalink" href="#copy">copy</a></h2>
<pre>  my $copy = $orig-&gt;copy({ change =&gt; $to, ... });
</pre>
<dl class="Bl-tag">
  <dt id="Arguments:~16"><a class="permalink" href="#Arguments:~16">Arguments:
    \%replacementdata</a></dt>
  <dd></dd>
  <dt id="Return~16"><a class="permalink" href="#Return~16">Return Value:
    $result copy</a></dt>
  <dd></dd>
</dl>
<p class="Pp">Inserts a new row into the database, as a copy of the original
    object. If a hashref of replacement data is supplied, these will take
    precedence over data in the original. Also any columns which have the column
    info attribute <span class="Li">&quot;is_auto_increment =&gt; 1&quot;</span>
    are explicitly removed before the copy, so that the database can insert its
    own autoincremented values into the new object.</p>
<p class="Pp">Relationships will be followed by the copy procedure <b>only</b>
    if the relationship specifies a true value for its cascade_copy attribute.
    <span class="Li">&quot;cascade_copy&quot;</span> is set by default on
    <span class="Li">&quot;has_many&quot;</span> relationships and unset on all
    others.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="store_column"><a class="permalink" href="#store_column">store_column</a></h2>
<pre>  $result-&gt;store_column($col =&gt; $val);
</pre>
<dl class="Bl-tag">
  <dt id="Arguments:~17"><a class="permalink" href="#Arguments:~17">Arguments:
    $columnname, $value</a></dt>
  <dd></dd>
  <dt id="Return~17"><a class="permalink" href="#Return~17">Return Value: The
    value sent to storage</a></dt>
  <dd></dd>
</dl>
<p class="Pp">Set a raw value for a column without marking it as changed. This
    method is used internally by &quot;set_column&quot; which you should
    probably be using.</p>
<p class="Pp">This is the lowest level at which data is set on a result object,
    extend this method to catch all data setting methods.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="inflate_result"><a class="permalink" href="#inflate_result">inflate_result</a></h2>
<pre>  Class-&gt;inflate_result($result_source, \%me, \%prefetch?)
</pre>
<dl class="Bl-tag">
  <dt id="Arguments:~18"><a class="permalink" href="#Arguments:~18">Arguments:
    $result_source, \%columndata, \%prefetcheddata</a></dt>
  <dd></dd>
  <dt id="Return~18"><a class="permalink" href="#Return~18">Return Value:
    $result</a></dt>
  <dd></dd>
</dl>
<p class="Pp">All DBIx::Class::ResultSet methods that retrieve data from the
    database and turn it into result objects call this method.</p>
<p class="Pp">Extend this method in your Result classes to hook into this
    process, for example to rebless the result into a different class.</p>
<p class="Pp">Reblessing can also be done more easily by setting
    <span class="Li">&quot;result_class&quot;</span> in your Result class. See
    &quot;result_class&quot; in DBIx::Class::ResultSource.</p>
<p class="Pp">Different types of results can also be created from a particular
    DBIx::Class::ResultSet, see &quot;result_class&quot; in
    DBIx::Class::ResultSet.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="update_or_insert"><a class="permalink" href="#update_or_insert">update_or_insert</a></h2>
<pre>  $result-&gt;update_or_insert
</pre>
<dl class="Bl-tag">
  <dt id="Arguments:~19"><a class="permalink" href="#Arguments:~19">Arguments:
    none</a></dt>
  <dd></dd>
  <dt id="Return~19"><a class="permalink" href="#Return~19">Return Value: Result
    of update or insert operation</a></dt>
  <dd></dd>
</dl>
<p class="Pp">&quot;update&quot;s the object if it's already in the database,
    according to &quot;in_storage&quot;, else &quot;insert&quot;s it.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="insert_or_update"><a class="permalink" href="#insert_or_update">insert_or_update</a></h2>
<pre>  $obj-&gt;insert_or_update
</pre>
<p class="Pp">Alias for &quot;update_or_insert&quot;</p>
</section>
<section class="Ss">
<h2 class="Ss" id="is_changed"><a class="permalink" href="#is_changed">is_changed</a></h2>
<pre>  my @changed_col_names = $result-&gt;is_changed();
  if ($result-&gt;is_changed()) { ... }
</pre>
<dl class="Bl-tag">
  <dt id="Arguments:~20"><a class="permalink" href="#Arguments:~20">Arguments:
    none</a></dt>
  <dd></dd>
  <dt id="Return~20"><a class="permalink" href="#Return~20">Return Value: 0|1 or
    @columnnames</a></dt>
  <dd></dd>
</dl>
<p class="Pp">In list context returns a list of columns with uncommited changes,
    or in scalar context returns a true value if there are uncommitted
  changes.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="is_column_changed"><a class="permalink" href="#is_column_changed">is_column_changed</a></h2>
<pre>  if ($result-&gt;is_column_changed('col')) { ... }
</pre>
<dl class="Bl-tag">
  <dt id="Arguments:~21"><a class="permalink" href="#Arguments:~21">Arguments:
    $columname</a></dt>
  <dd></dd>
  <dt id="Return~21"><a class="permalink" href="#Return~21">Return Value:
    0|1</a></dt>
  <dd></dd>
</dl>
<p class="Pp">Returns a true value if the column has uncommitted changes.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="result_source"><a class="permalink" href="#result_source">result_source</a></h2>
<pre>  my $resultsource = $result-&gt;result_source;
</pre>
<dl class="Bl-tag">
  <dt id="Arguments:~22"><a class="permalink" href="#Arguments:~22">Arguments:
    $result_source?</a></dt>
  <dd></dd>
  <dt id="Return~22"><a class="permalink" href="#Return~22">Return Value:
    $result_source</a></dt>
  <dd></dd>
</dl>
<p class="Pp">Accessor to the DBIx::Class::ResultSource this object was created
    from.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="register_column"><a class="permalink" href="#register_column">register_column</a></h2>
<pre>  $column_info = { .... };
  $class-&gt;register_column($column_name, $column_info);
</pre>
<dl class="Bl-tag">
  <dt id="Arguments:~23"><a class="permalink" href="#Arguments:~23">Arguments:
    $columnname, \%columninfo</a></dt>
  <dd></dd>
  <dt id="Return~23"><a class="permalink" href="#Return~23">Return Value: not
    defined</a></dt>
  <dd></dd>
</dl>
<p class="Pp">Registers a column on the class. If the column_info has an
    'accessor' key, creates an accessor named after the value if defined; if
    there is no such key, creates an accessor with the same name as the
  column</p>
<p class="Pp">The column_info attributes are described in
    &quot;add_columns&quot; in DBIx::Class::ResultSource</p>
</section>
<section class="Ss">
<h2 class="Ss" id="get_from_storage"><a class="permalink" href="#get_from_storage">get_from_storage</a></h2>
<pre>  my $copy = $result-&gt;get_from_storage($attrs)
</pre>
<dl class="Bl-tag">
  <dt id="Arguments:~24"><a class="permalink" href="#Arguments:~24">Arguments:
    \%attrs</a></dt>
  <dd></dd>
  <dt id="Return~24"><a class="permalink" href="#Return~24">Return Value: A
    Result object</a></dt>
  <dd></dd>
</dl>
<p class="Pp">Fetches a fresh copy of the Result object from the database and
    returns it. Throws an exception if a proper WHERE clause identifying the
    database row can not be constructed (i.e. if the original object does not
    contain its entire
  <br/>
   primary key ). If passed the \%attrs argument, will first apply these
    attributes to the resultset used to find the row.</p>
<p class="Pp">This copy can then be used to compare to an existing result
    object, to determine if any changes have been made in the database since it
    was created.</p>
<p class="Pp">To just update your Result object with any latest changes from the
    database, use &quot;discard_changes&quot; instead.</p>
<p class="Pp">The \%attrs argument should be compatible with
    &quot;ATTRIBUTES&quot; in DBIx::Class::ResultSet.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="discard_changes"><a class="permalink" href="#discard_changes">discard_changes</a></h2>
<pre>  $result-&gt;discard_changes
</pre>
<dl class="Bl-tag">
  <dt id="Arguments:~25"><a class="permalink" href="#Arguments:~25">Arguments:
    none or $attrs</a></dt>
  <dd></dd>
  <dt id="Return~25"><a class="permalink" href="#Return~25">Return Value: self
    (updates object in-place)</a></dt>
  <dd></dd>
</dl>
<p class="Pp">Re-selects the row from the database, losing any changes that had
    been made. Throws an exception if a proper
    <span class="Li">&quot;WHERE&quot;</span> clause identifying the database
    row can not be constructed (i.e. if the original object does not contain its
    entire primary key).</p>
<p class="Pp">This method can also be used to refresh from storage, retrieving
    any changes made since the row was last read from storage.</p>
<p class="Pp"><span class="Li">$attrs</span>, if supplied, is expected to be a
    hashref of attributes suitable for passing as the second argument to
    <span class="Li">&quot;$resultset-&gt;search($cond,
  $attrs)&quot;</span>;</p>
<p class="Pp">Note: If you are using DBIx::Class::Storage::DBI::Replicated as
    your storage, a default of <span class="Li">&quot;{ force_pool =&gt;
    'master' }&quot;</span>
  <br/>
   is automatically set for you. Prior to <span class="Li">&quot;DBIx::Class
    0.08109&quot;</span> (before 2010) one would have been required to
    explicitly wrap the entire operation in a transaction to guarantee that
    up-to-date results are read from the master database.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="throw_exception"><a class="permalink" href="#throw_exception">throw_exception</a></h2>
<p class="Pp">See &quot;throw_exception&quot; in DBIx::Class::Schema.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="id"><a class="permalink" href="#id">id</a></h2>
<pre>  my @pk = $result-&gt;id;
</pre>
<dl class="Bl-tag">
  <dt id="Arguments:~26"><a class="permalink" href="#Arguments:~26">Arguments:
    none</a></dt>
  <dd></dd>
  <dt id="Returns:"><a class="permalink" href="#Returns:">Returns: A list of
    primary key values</a></dt>
  <dd></dd>
</dl>
<p class="Pp">Returns the primary key(s) for a row. Can't be called as a class
    method. Actually implemented in DBIx::Class::PK</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="FURTHER_QUESTIONS?"><a class="permalink" href="#FURTHER_QUESTIONS?">FURTHER
  QUESTIONS?</a></h1>
<p class="Pp">Check the list of additional DBIC resources.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT_AND_LICENSE"><a class="permalink" href="#COPYRIGHT_AND_LICENSE">COPYRIGHT
  AND LICENSE</a></h1>
<p class="Pp">This module is free software copyright by the DBIx::Class (DBIC)
    authors. You can redistribute it and/or modify it under the same terms as
    the DBIx::Class library.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2018-01-29</td>
    <td class="foot-os">perl v5.34.0</td>
  </tr>
</table>
</body>
</html>
