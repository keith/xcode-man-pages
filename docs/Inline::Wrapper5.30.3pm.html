<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>Inline::Wrapper(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Inline::Wrapper(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Inline::Wrapper(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
Inline::Wrapper - Convenient module wrapper/loader routines for Inline.pm
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
sample.pl:
<p class="Pp"><span class="Li"></span></p>
<pre>
 use Inline::Wrapper;

 my $inline = Inline::Wrapper-&gt;new(
    language    =&gt; 'C',
    base_dir    =&gt; '.',
 );

 my @symbols = $inline-&gt;load( 'answer' );

 my @retvals = $inline-&gt;run( 'answer', 'the_answer', 3, 56 );

 print &quot;The answer is: &quot;, $retvals[0], &quot;\n&quot;;

 exit(0);
</pre>
<p class="Pp">answer.c:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
 int the_answer( int arg1, int arg2 ) {
     return ( arg1 * arg2 ) &gt;&gt; 2;
 }
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<b>Inline::Wrapper</b> provides wrapper routines around Inline to make embedding
  functions from another language into a Perl application much more convenient.
<p class="Pp">Instead of having to include the external code in a Perl source
    file after the __END__ directive, <b>Inline::Wrapper</b> allows you to have
    separate, individually-configurable module repositories to more easily
    manage all of your external application code.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="FEATURES"><a class="permalink" href="#FEATURES">FEATURES</a></h1>
<b>Inline::Wrapper</b> provides the following features:
<ul class="Bl-bullet">
  <li>Support for all languages supported by Inline.</li>
  <li>A single, unified interface for loading and running module functions.</li>
  <li>Loading of files containing pure source code, only in their respective
      languages, so you can isolate maintenance and management of these
    modules.</li>
  <li>Individually-configurable module directories.</li>
  <li>Automatic, run-time module reloading upon file modification time
      detection.</li>
  <li>No more namespace pollution. All module symbols are loaded into their own
      individual, private namespaces, so they won't collide with your code or
      each other.</li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="CONSTRUCTOR"><a class="permalink" href="#CONSTRUCTOR">CONSTRUCTOR</a></h1>
<section class="Ss">
<h2 class="Ss" id="_fBnew()_fP"><a class="permalink" href="#_fBnew()_fP"><b>new()</b></a></h2>
<span class="Li"></span>
<pre>
    my $wrapper = Inline::Wrapper-&gt;new(
          language        =&gt; 'C',
          base_dir        =&gt; 'src/code/C',
          auto_reload     =&gt; 1,
    );
</pre>
<p class="Pp">Create a new <b>Inline::Wrapper</b> object, with the appropriate
    attributes (if specified).</p>
<p class="Pp"><b>ARGUMENTS:</b></p>
<p class="Pp">All arguments are of the hash form Var =&gt; Value.
    &quot;<b>new()</b>&quot; will complain and croak if they do not follow this
    form.</p>
<p class="Pp">The arguments to &quot;<b>new()</b>&quot; become the defaults used
    by &quot;<b>load()</b>&quot;. You can individually configure loaded modules
    using &quot;<b>load()</b>&quot;, as well.</p>
<dl class="Bl-tag">
  <dt><i>language</i> [ default: <b>'Lua'</b> ]</dt>
  <dd>Optional. Set to the default language for which you wish to load modules,
      if not explicitly specified via &quot;<b>load()</b>&quot;.
    <p class="Pp"><b>NOTE</b>: It defaults to Lua because that is what I wrote
        this module for. Just pass in the argument if you don't like that.</p>
    <p class="Pp"><b>ALSO NOTE:</b> Currently only a couple of &quot;known&quot;
        languages are hard-coded into this module. If you wish to use others,
        don't pass this argument, and use the &quot;<b>add_language()</b>&quot;
        method after the object has been instantiated.</p>
  </dd>
  <dt><i>auto_reload</i> [ default: <b>FALSE</b> ]</dt>
  <dd>Optional. Set to a TRUE value to default to automatically checking if
      modules have been changed since the last &quot;<b>load()</b>&quot;, and
      reload them if necessary.</dd>
  <dt><i>base_dir</i> [ default: <b>'.'</b> ]</dt>
  <dd>Optional. Set to the default base directory from which you wish to load
      all modules.</dd>
</dl>
<p class="Pp"><b>RETURNS</b>: blessed <span class="Li">$object</span>, or undef
    on failure.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="METHODS"><a class="permalink" href="#METHODS">METHODS</a></h1>
<section class="Ss">
<h2 class="Ss" id="_fBinitialize()_fP"><a class="permalink" href="#_fBinitialize()_fP"><b>initialize()</b></a></h2>
<span class="Li"></span>
<pre>
    $obj-&gt;initialize();
</pre>
<p class="Pp">Initialize arguments. If you are subclassing, overload this, not
    &quot;<b>new()</b>&quot;.</p>
<p class="Pp">Generally only called from within &quot;<b>new()</b>&quot;.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_fBload()_fP"><a class="permalink" href="#_fBload()_fP"><b>load()</b></a></h2>
<span class="Li"></span>
<pre>
    my @functions = $obj-&gt;load( $modname, %arguments );
</pre>
<p class="Pp">The workhorse. Loads the actual module referred to by
    <i></i><i>$modname</i><i></i>, imports its symbols into a private namespace,
    and makes them available to call via &quot;<b>run()</b>&quot;.</p>
<p class="Pp"><b>ARGUMENTS:</b></p>
<p class="Pp"><i></i><i>$modname</i><i></i> is REQUIRED. It corresponds to the
    base filename, without extension, loaded from the <i>base_dir</i>. See the
    &quot;Details of steps taken by <b>load()</b>&quot; section, Step 3, for
    clarification of how pathname resolution is done.
    <i></i><i>$modname</i><i></i> is also how you will refer to this particular
    module from your program, so keep track of it.</p>
<p class="Pp">This method accepts all of the same arguments as
    &quot;<b>new()</b>&quot;. Thus, you can set the defaults via
    &quot;<b>new()</b>&quot;, yet still individually configure module components
    differently from the defaults, if desired.</p>
<p class="Pp">Returns a list of <span class="Li">@functions</span> made
    available by loading <i></i><i>$modname</i><i></i>, or warns and returns an
    empty list if unsuccessful.</p>
<p class="Pp"><i>Details of steps taken by </i><b><i>load()</i></b><i></i></p>
<p class="Pp">Since this is the real guts of this module, here are the exact
    steps taken when loading the module, doing pathname resolution, etc.</p>
<dl class="Bl-tag">
  <dt>1. Checks to see if the specified module has already been loaded, and if
    so, returns the list of functions loaded and available in that module
    immediately.</dt>
  <dd></dd>
  <dt>2. Creates a new Inline::Wrapper::Module container object with any
    supplied %arguments, or the defaults you specified with
    &quot;<b>new()</b>&quot;.</dt>
  <dd></dd>
  <dt>3. Constructs a path to the specified $modname, roughly as follows:</dt>
  <dd><span class="Li"></span>
    <pre>
    join( $PATH_SEP, $base_dir , $modname . $lang_ext );
    </pre>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><i></i><i>$base_dir</i><i></i> is taken either from the default created
    with &quot;<b>new()</b>&quot;, or the explicitly supplied <i>base_dir</i>
    argument to &quot;<b>load()</b>&quot;.</dt>
  <dd></dd>
  <dt><i></i><i>$path_separator</i><i></i> is just the appropriate path
    separator for your OS.</dt>
  <dd></dd>
  <dt><i></i><i>$modname</i><i></i> is your supplied module name. Note that this
    means that you can supply your own subdirectories, as well; i.e.
    <i>'foo'</i> is just as valid as <i>'foo/bar/baz'</i>.</dt>
  <dd></dd>
  <dt><i></i><i>$lang_ext</i><i></i> is taken from a data structure that
    defaults to common filename extensions on a per-language basis. Any of these
    can be overridden via the &quot;<b>add_language()</b>&quot; method.</dt>
  <dd></dd>
</dl>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>4. Attempts to open the file at the path constructed above, and if
    successful, slurps in the entire source file.</dt>
  <dd></dd>
  <dt>5. Attempts to <b>bind()</b> (compile and set symbols) it with the
    Inline-&gt;<b>bind()</b> method into a private namespace.</dt>
  <dd></dd>
  <dt>6. If step 5 was successful, set the load time, and return the list of
    loaded, available functions provided by the module.</dt>
  <dd></dd>
  <dt>7. If step 5 failed, warn and return an empty list.</dt>
  <dd></dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="_fBunload()_fP"><a class="permalink" href="#_fBunload()_fP"><b>unload()</b></a></h2>
<span class="Li"></span>
<pre>
    $obj-&gt;unload( $modname );
</pre>
<p class="Pp">Completely unload the module identified by
    <i></i><i>$modname</i><i></i>, and render its functions uncallable.</p>
<p class="Pp">This will actually go destroy the Inline::Wrapper::Module object,
    as well as the code module's corresponding private namespace.</p>
<p class="Pp">Returns <i></i><i>$modname</i><i></i> (TRUE) upon success, carps
    and returns undef on failure.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_fBrun()_fP"><a class="permalink" href="#_fBrun()_fP"><b>run()</b></a></h2>
<span class="Li"></span>
<pre>
    my @retvals = $obj-&gt;run( $modname, $function, @arguments );
</pre>
<p class="Pp">Run the named <i></i><i>$function</i><i></i> that you loaded from
    <i></i><i>$modname</i><i></i>, with the specified
    <i></i><i>@arguments</i><i></i> (if any).</p>
<p class="Pp"><b>NOTE:</b> If the <i>auto_reload</i> option is TRUE,
    <b>run()</b> will also attempt to reload the source script from disk before
    running the function, if the ctime of the file has changed since the last
    run.</p>
<p class="Pp">Assuming a successful compilation (you are checking for errors,
    right?), this will execute the function provided by the loaded module. Call
    syntax and everything is up to the function provided. This simply executes
    the sub that Inline loaded as-is, but in its own private namespace to keep
    your app clean.</p>
<p class="Pp">Returns <i></i><i>@retvals</i><i></i>, consisting of the actual
    return values provided by the module function itself. Whatever the function
    returns, that's what you get.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_fBmodules()_fP"><a class="permalink" href="#_fBmodules()_fP"><b>modules()</b></a></h2>
<span class="Li"></span>
<pre>
    my @modules = $obj-&gt;modules();
</pre>
<p class="Pp">Returns a list of loaded module names, or the empty list if no
    modules have been (successfully) loaded.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_fBfunctions()_fP"><a class="permalink" href="#_fBfunctions()_fP"><b>functions()</b></a></h2>
<span class="Li"></span>
<pre>
    my @functions = $obj-&gt;functions( $modname );
</pre>
<p class="Pp">Returns a list of loaded <i></i><i>@functions</i><i></i>, which
    were made available by loading <i></i><i>$modname</i><i></i>.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="ACCESSORS"><a class="permalink" href="#ACCESSORS">ACCESSORS</a></h1>
Various accessors that allow you to inspect or change the default settings after
  creating the object.
<section class="Ss">
<h2 class="Ss" id="_fBbase_dir()_fP"><a class="permalink" href="#_fBbase_dir()_fP"><b>base_dir()</b></a></h2>
<span class="Li"></span>
<pre>
    my $base_dir = $obj-&gt;base_dir();
</pre>
<p class="Pp">Returns the default <i>base_dir</i> attribute from the object.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_fBset_base_dir()_fP"><a class="permalink" href="#_fBset_base_dir()_fP"><b>set_base_dir()</b></a></h2>
<span class="Li"></span>
<pre>
    $obj-&gt;set_base_dir( '/some/path' );
</pre>
<p class="Pp">Sets the default <i>base_dir</i> attribute of the object, and
    returns whatever it ended up being set to.</p>
<p class="Pp"><b>NOTE:</b> Only affects modules loaded <i>after</i> this setting
    was made.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_fBauto_reload()_fP"><a class="permalink" href="#_fBauto_reload()_fP"><b>auto_reload()</b></a></h2>
<span class="Li"></span>
<pre>
    my $bool = $obj-&gt;auto_reload();
</pre>
<p class="Pp">Returns a <span class="Li">$boolean</span> as to whether or not
    the default <i>auto_reload</i> setting is enabled for new modules.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_fBset_auto_reload()_fP"><a class="permalink" href="#_fBset_auto_reload()_fP"><b>set_auto_reload()</b></a></h2>
<span class="Li"></span>
<pre>
    $obj-&gt;set_auto_reload( 1 );
</pre>
<p class="Pp">Sets the default <i>auto_reload</i> attribute of the object, and
    returns whatever it ended up being set to.</p>
<p class="Pp"><b>NOTE:</b> Only affects modules loaded <i>after</i> this setting
    was made.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_fBlanguage()_fP"><a class="permalink" href="#_fBlanguage()_fP"><b>language()</b></a></h2>
<span class="Li"></span>
<pre>
    my $lang = $obj-&gt;language();
</pre>
<p class="Pp">Returns the default <i>language</i> attribute of the object.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_fBset_language()_fP"><a class="permalink" href="#_fBset_language()_fP"><b>set_language()</b></a></h2>
<span class="Li"></span>
<pre>
    $obj-&gt;set_language( 'C' );
</pre>
<p class="Pp">Sets the default <i>language</i> attribute of the object, and
    returns whatever it ended up being set to.</p>
<p class="Pp"><b>NOTE:</b> Only affects modules loaded <i>after</i> this setting
    was made.</p>
<p class="Pp"><b>ALSO NOTE:</b> This checks for &quot;valid&quot; languages via
    a pretty naive method. Currently only a couple are hard-coded. However, you
    can add your own languages via the &quot;<b>add_language()</b>&quot;
  method.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_fBadd_language()_fP"><a class="permalink" href="#_fBadd_language()_fP"><b>add_language()</b></a></h2>
<span class="Li"></span>
<pre>
    $obj-&gt;add_language( 'Lojban' =&gt; '.xkcd' );
</pre>
<p class="Pp">Adds a language to the &quot;known languages&quot; table, allowing
    you to later use &quot;<b>set_language()</b>&quot;.</p>
<p class="Pp">This can also be used to set a new file extension for an existing
    language.</p>
<p class="Pp">REQUIRES a <i></i><i>$language</i><i></i> name (e.g. 'Python') and
    a filename <i></i><i>$extension</i><i></i> (e.g. '.py'), which will be used
    in pathname resolution, as described under &quot;<b>load()</b>&quot;.</p>
<p class="Pp">Returns TRUE if successful, carps and returns FALSE otherwise.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
Inline::Wrapper::Module
<p class="Pp">The Inline documentation.</p>
<p class="Pp">The Inline-FAQ list.</p>
<p class="Pp">The examples/ directory of this module's distribution.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="ACKNOWLEDGEMENTS"><a class="permalink" href="#ACKNOWLEDGEMENTS">ACKNOWLEDGEMENTS</a></h1>
Thank you, kennethk and ikegami for your assistance on perlmonks.
<p class="Pp">&lt;http://perlmonks.org/index.pl?node_id=732598&gt;</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
Please kindly read through this documentation and the <b>examples/</b>
  thoroughly, before emailing me with questions. Your answer is likely in here.
<p class="Pp">Also, please make sure that your issue is actually with
    <b>Inline::Wrapper</b> and not with Inline itself.</p>
<p class="Pp">Jason McManus (INFIDEL) -- <span class="Li">&quot;infidel AT
    cpan.org&quot;</span></p>
</section>
<section class="Sh">
<h1 class="Sh" id="LICENSE"><a class="permalink" href="#LICENSE">LICENSE</a></h1>
Copyright (c) Jason McManus
<p class="Pp">This module may be used, modified, and distributed under the same
    terms as Perl itself. Please see the license that came with your Perl
    distribution for details.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2010-03-10</td>
    <td class="foot-os">perl v5.30.2</td>
  </tr>
</table>
</body>
</html>
