<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.10 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>Moose::Cookbook::Extending::ExtensionOverview(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Moose::Cookbook::Extending::ExtensionOverview(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Moose::Cookbook::Extending::ExtensionOverview(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
Moose::Cookbook::Extending::ExtensionOverview - Moose extension overview
</section>
<section class="Sh">
<h1 class="Sh" id="VERSION"><a class="permalink" href="#VERSION">VERSION</a></h1>
version 2.2012
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
Moose provides several ways in which extensions can hook into Moose and change
  its behavior. Moose also has a lot of behavior that can be changed. This
  recipe will provide an overview of each extension method and give you some
  recommendations on what tools to use.
<p class="Pp">If you haven't yet read the recipes on metaclasses, go read those
    first. You can't write Moose extensions without understanding the
    metaclasses, and those recipes also demonstrate some basic extension
    mechanisms, such as metaclass subclasses and traits.</p>
<section class="Ss">
<h2 class="Ss" id="Playing_Nice_With_Others"><a class="permalink" href="#Playing_Nice_With_Others">Playing
  Nice With Others</a></h2>
One of the goals of this overview is to help you build extensions that cooperate
  well with other extensions. This is especially important if you plan to
  release your extension to CPAN.
<p class="Pp">Moose comes with several modules that exist to help your write
    cooperative extensions. These are Moose::Exporter and Moose::Util::MetaRole.
    By using these two modules, you will ensure that your extension works with
    both the Moose core features and any other CPAN extension using those
    modules.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="PARTS_OF_Moose_YOU_CAN_EXTEND"><a class="permalink" href="#PARTS_OF_Moose_YOU_CAN_EXTEND">PARTS
  OF Moose YOU CAN EXTEND</a></h1>
The types of things you might want to do in Moose extensions fall into a few
  broad categories.
<section class="Ss">
<h2 class="Ss" id="Metaclass_Extensions"><a class="permalink" href="#Metaclass_Extensions">Metaclass
  Extensions</a></h2>
One way of extending Moose is by extending one or more Moose metaclasses. For
  example, in Moose::Cookbook::Meta::Table_MetaclassTrait we saw a metaclass
  role that added a <span class="Li">&quot;table&quot;</span> attribute to the
  metaclass. If you were writing an ORM, this would be a logical extension.
<p class="Pp">Many of the Moose extensions on CPAN work by providing an
    attribute metaclass role. For example, the MooseX::Aliases module provides
    an attribute metaclass trait that lets you specify aliases to install for
    methods and attribute accessors.</p>
<p class="Pp">A metaclass extension can be packaged as a role/trait or a
    subclass. If you can, we recommend using traits instead of subclasses, since
    it's much easier to combine disparate traits than it is to combine a bunch
    of subclasses.</p>
<p class="Pp">When your extensions are implemented as roles, you can apply them
    with the Moose::Util::MetaRole module.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Providing_Sugar_Functions"><a class="permalink" href="#Providing_Sugar_Functions">Providing
  Sugar Functions</a></h2>
As part of a metaclass extension, you may also want to provide some sugar
  functions, just like Moose.pm does. Moose provides a helper module called
  Moose::Exporter that makes this much simpler. We will be use Moose::Exporter
  in several of the extension recipes.
</section>
<section class="Ss">
<h2 class="Ss" id="Object_Class_Extensions"><a class="permalink" href="#Object_Class_Extensions">Object
  Class Extensions</a></h2>
Another common Moose extension technique is to change the default object class's
  behavior. As with metaclass extensions, this can be done with a role/trait or
  with a subclass. For example, MooseX::StrictConstructor extension applies a
  trait that makes the constructor reject arguments which don't match its
  attributes.
<p class="Pp">Object class extensions often include metaclass extensions as
    well. In particular, if you want your object extension to work when a class
    is made immutable, you may need to modify the behavior of some or all of the
    Moose::Meta::Instance, Moose::Meta::Method::Constructor, and
    Moose::Meta::Method::Destructor objects.</p>
<p class="Pp">The Moose::Util::MetaRole module lets you apply roles to the base
    object class, as well as the meta classes just mentioned.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Providing_a_Role"><a class="permalink" href="#Providing_a_Role">Providing
  a Role</a></h2>
Some extensions come in the form of a role for you to consume. The
  MooseX::Object::Pluggable extension is a great example of this. In fact,
  despite the <span class="Li">&quot;MooseX&quot;</span> name, it does not
  actually change anything about Moose's behavior. Instead, it is just a role
  that an object which wants to be pluggable can consume.
<p class="Pp">If you are implementing this sort of extension, you don't need to
    do anything special. You simply create a role and document that it should be
    used via the normal <span class="Li">&quot;with&quot;</span> sugar:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
   package MyApp::User;

   use Moose;

   with 'My::Role';
</pre>
<p class="Pp">Don't use &quot;MooseX&quot; in the name for such packages.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="New_Types"><a class="permalink" href="#New_Types">New
  Types</a></h2>
Another common Moose extension is a new type for the Moose type system. In this
  case, you simply create a type in your module. When people load your module,
  the type is created, and they can refer to it by name after that. The
  MooseX::Types::URI and MooseX::Types::DateTime distributions are two good
  examples of how this works. These both build on top of the MooseX::Types
  extension.
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="ROLES_VS_TRAITS_VS_SUBCLASSES"><a class="permalink" href="#ROLES_VS_TRAITS_VS_SUBCLASSES">ROLES
  VS TRAITS VS SUBCLASSES</a></h1>
It is important to understand that <b>roles and traits are the same thing</b>. A
  trait is simply a role applied to a instance. The only thing that may
  distinguish the two is that a trait can be packaged in a way that lets Moose
  resolve a short name to a class name. In other words, with a trait, the caller
  can refer to it by a short name like &quot;Big&quot;, and Moose will resolve
  it to a class like
  <span class="Li">&quot;MooseX::Embiggen::Meta::Attribute::Role::Big&quot;</span>.
<p class="Pp">See Moose::Cookbook::Meta::Labeled_AttributeTrait and
    Moose::Cookbook::Meta::Table_MetaclassTrait for examples of traits in
    action. In particular, both of these recipes demonstrate the trait
    resolution mechanism.</p>
<p class="Pp">Implementing an extension as a (set of) metaclass or base object
    role(s) will make your extension more cooperative. It is hard for an
    end-user to effectively combine together multiple metaclass subclasses, but
    it is very easy to combine roles.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="USING_YOUR_EXTENSION"><a class="permalink" href="#USING_YOUR_EXTENSION">USING
  YOUR EXTENSION</a></h1>
There are a number of ways in which an extension can be applied. In some cases
  you can provide multiple ways of consuming your extension.
<section class="Ss">
<h2 class="Ss" id="Extensions_as_Metaclass_Traits"><a class="permalink" href="#Extensions_as_Metaclass_Traits">Extensions
  as Metaclass Traits</a></h2>
If your extension is available as a trait, you can ask end users to simply
  specify it in a list of traits. Currently, this only works for (class)
  metaclass and attribute metaclass traits:
<p class="Pp"><span class="Li"></span></p>
<pre>
  use Moose -traits =&gt; [ 'Big', 'Blue' ];

  has 'animal' =&gt; (
      traits =&gt; [ 'Big', 'Blue' ],
      ...
  );
</pre>
<p class="Pp">If your extension applies to any other metaclass, or the object
    base class, you cannot use the trait mechanism.</p>
<p class="Pp">The benefit of the trait mechanism is that is very easy to see
    where a trait is applied in the code, and consumers have fine-grained
    control over what the trait applies to. This is especially true for
    attribute traits, where you can apply the trait to just one attribute in a
    class.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Extensions_as_Metaclass_(and_Base_Object)_Roles"><a class="permalink" href="#Extensions_as_Metaclass_(and_Base_Object)_Roles">Extensions
  as Metaclass (and Base Object) Roles</a></h2>
Implementing your extensions as metaclass roles makes your extensions easy to
  apply, and cooperative with other role-based extensions for metaclasses.
<p class="Pp">Just as with a subclass, you will probably want to package your
    extensions for consumption with a single module that uses Moose::Exporter.
    However, in this case, you will use Moose::Util::MetaRole to apply all of
    your roles. The advantage of using this module is that <i>it preserves any
    subclassing or roles</i> <i>already applied to the user's metaclasses</i>.
    This means that your extension is cooperative <i>by default</i>, and
    consumers of your extension can easily use it with other role-based
    extensions. Most uses of Moose::Util::MetaRole can be handled by
    Moose::Exporter directly; see the Moose::Exporter docs.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  package MooseX::Embiggen;

  use Moose::Exporter;

  use MooseX::Embiggen::Role::Meta::Class;
  use MooseX::Embiggen::Role::Meta::Attribute;
  use MooseX::Embiggen::Role::Meta::Method::Constructor;
  use MooseX::Embiggen::Role::Object;

  Moose::Exporter-&gt;setup_import_methods(
      class_metaroles =&gt; {
          class     =&gt; ['MooseX::Embiggen::Role::Meta::Class'],
          attribute =&gt; ['MooseX::Embiggen::Role::Meta::Attribute'],
          constructor =&gt;
              ['MooseX::Embiggen::Role::Meta::Method::Constructor'],
      },
      base_class_roles =&gt; ['MooseX::Embiggen::Role::Object'],
  );
</pre>
<p class="Pp">As you can see from this example, you can use
    Moose::Util::MetaRole to apply roles to any metaclass, as well as the base
    object class. If some other extension has already applied its own roles,
    they will be preserved when your extension applies its roles, and vice
    versa.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Providing_Sugar"><a class="permalink" href="#Providing_Sugar">Providing
  Sugar</a></h2>
With Moose::Exporter, you can also export your own sugar functions:
<p class="Pp"><span class="Li"></span></p>
<pre>
  package MooseX::Embiggen;

  use Moose::Exporter;

  Moose::Exporter-&gt;setup_import_methods(
      with_meta       =&gt; ['embiggen'],
      class_metaroles =&gt; {
          class =&gt; ['MooseX::Embiggen::Role::Meta::Class'],
      },
  );

  sub embiggen {
      my $meta = shift;
      $meta-&gt;embiggen(@_);
  }
</pre>
<p class="Pp">And then the consumer of your extension can use your
    <span class="Li">&quot;embiggen&quot;</span> sub:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  package Consumer;

  use Moose;
  use MooseX::Embiggen;

  extends 'Thing';

  embiggen ...;
</pre>
<p class="Pp">This can be combined with metaclass and base class roles quite
    easily.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="More_advanced_extensions"><a class="permalink" href="#More_advanced_extensions">More
  advanced extensions</a></h2>
Providing your extension simply as a set of traits that gets applied to the
  appropriate metaobjects is easy, but sometimes not sufficient. For instance,
  sometimes you need to supply not just a base object role, but an actual base
  object class (due to needing to interact with existing systems that only
  provide a base class). To write extensions like this, you will need to provide
  a custom <span class="Li">&quot;init_meta&quot;</span> method in your
  exporter. For instance:
<p class="Pp"><span class="Li"></span></p>
<pre>
  package MooseX::Embiggen;

  use Moose::Exporter;

  my ($import, $unimport, $init_meta) = Moose::Exporter-&gt;build_import_methods(
      install         =&gt; ['import', 'unimport'],
      with_meta       =&gt; ['embiggen'],
      class_metaroles =&gt; {
          class =&gt; ['MooseX::Embiggen::Role::Meta::Class'],
      },
  );

  sub embiggen {
      my $meta = shift;
      $meta-&gt;embiggen(@_);
  }

  sub init_meta {
      my $package = shift;
      my %options = @_;
      if (my $meta = Class::MOP::class_of($options{for_class})) {
          if ($meta-&gt;isa('Class::MOP::Class')) {
              my @supers = $meta-&gt;superclasses;
              $meta-&gt;superclasses('MooseX::Embiggen::Base::Class')
                  if @supers == 1 &amp;&amp; $supers[0] eq 'Moose::Object';
          }
      }
      $package-&gt;$init_meta(%options);
  }
</pre>
<p class="Pp">In the previous examples,
    <span class="Li">&quot;init_meta&quot;</span> was generated for you, but
    here you must override it in order to add additional functionality. Some
    differences to note:</p>
<dl class="Bl-tag">
  <dt>&quot;build_import_methods&quot; instead of
    &quot;setup_import_methods&quot;</dt>
  <dd><span class="Li">&quot;build_import_methods&quot;</span> simply returns
      the <span class="Li">&quot;import&quot;</span>,
      <span class="Li">&quot;unimport&quot;</span>, and
      <span class="Li">&quot;init_meta&quot;</span> methods, rather than
      installing them under the appropriate names. This way, you can write your
      own methods which wrap the functionality provided by Moose::Exporter. The
      <span class="Li">&quot;build_import_methods&quot;</span> sub also takes an
      additional <span class="Li">&quot;install&quot;</span> parameter, which
      tells it to just go ahead and install these methods (since we don't need
      to modify them).</dd>
  <dt>&quot;sub init_meta&quot;</dt>
  <dd>Next, we must write our <span class="Li">&quot;init_meta&quot;</span>
      wrapper. The important things to remember are that it is called as a
      method, and that <span class="Li">%options</span> needs to be passed
      through to the existing implementation. We call the base implementation by
      using the <span class="Li">$init_meta</span> subroutine reference that was
      returned by <span class="Li">&quot;build_import_methods&quot;</span>
      earlier.</dd>
  <dt>Additional implementation</dt>
  <dd>This extension sets a different default base object class. To do so, it
      first checks to see if it's being applied to a class, and then checks to
      see if Moose::Object is that class's only superclass, and if so, replaces
      that with the superclass that this extension requires.
    <p class="Pp">Note that two extensions that do this same thing will not work
        together properly (the second extension to be loaded won't see
        Moose::Object as the base object, since it has already been overridden).
        This is why using a base object role is recommended for the general
        case.</p>
    <p class="Pp">This <span class="Li">&quot;init_meta&quot;</span> also works
        defensively, by only applying its functionality if a metaclass already
        exists. This makes sure it doesn't break with legacy extensions which
        override the metaclass directly (and so must be the first extension to
        initialize the metaclass). This is likely not necessary, since almost no
        extensions work this way anymore, but just provides an additional level
        of protection. The common case of <span class="Li">&quot;use Moose; use
        MooseX::Embiggen;&quot;</span> is not affected regardless.</p>
  </dd>
</dl>
<p class="Pp">This is just one example of what can be done with a custom
    <span class="Li">&quot;init_meta&quot;</span> method. It can also be used
    for preventing an extension from being applied to a role, doing other kinds
    of validation on the class being applied to, or pretty much anything that
    would otherwise be done in an <span class="Li">&quot;import&quot;</span>
    method.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="LEGACY_EXTENSION_MECHANISMS"><a class="permalink" href="#LEGACY_EXTENSION_MECHANISMS">LEGACY
  EXTENSION MECHANISMS</a></h1>
Before the existence of Moose::Exporter and Moose::Util::MetaRole, there were a
  number of other ways to extend Moose. In general, these methods were less
  cooperative, and only worked well with a single extension.
<p class="Pp">These methods include metaclass.pm, Moose::Policy (which uses
    metaclass.pm under the hood), and various hacks to do what Moose::Exporter
    does. Please do not use these for your own extensions.</p>
<p class="Pp">Note that if you write a cooperative extension, it should
    cooperate with older extensions, though older extensions generally do not
    cooperate with each other.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="CONCLUSION"><a class="permalink" href="#CONCLUSION">CONCLUSION</a></h1>
If you can write your extension as one or more metaclass and base object roles,
  please consider doing so. Make sure to read the docs for Moose::Exporter and
  Moose::Util::MetaRole as well.
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHORS"><a class="permalink" href="#AUTHORS">AUTHORS</a></h1>
<ul class="Bl-bullet">
  <li>Stevan Little &lt;stevan.little@iinteractive.com&gt;</li>
  <li>Dave Rolsky &lt;autarch@urth.org&gt;</li>
  <li>Jesse Luehrs &lt;doy@tozt.net&gt;</li>
  <li>Shawn M Moore &lt;code@sartak.org&gt;</li>
  <li>&#x05D9;&#x05D5;&#x05D1;&#x05DC; &#x05E7;&#x05D5;&#x05D2;'&#x05DE;&#x05DF;
      (Yuval Kogman) &lt;nothingmuch@woobling.org&gt;</li>
  <li>Karen Etheridge &lt;ether@cpan.org&gt;</li>
  <li>Florian Ragwitz &lt;rafl@debian.org&gt;</li>
  <li>Hans Dieter Pearcey &lt;hdp@weftsoar.net&gt;</li>
  <li>Chris Prather &lt;chris@prather.org&gt;</li>
  <li>Matt S Trout &lt;mst@shadowcat.co.uk&gt;</li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT_AND_LICENSE"><a class="permalink" href="#COPYRIGHT_AND_LICENSE">COPYRIGHT
  AND LICENSE</a></h1>
This software is copyright (c) 2006 by Infinity Interactive, Inc.
<p class="Pp">This is free software; you can redistribute it and/or modify it
    under the same terms as the Perl 5 programming language system itself.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2019-11-22</td>
    <td class="foot-os">perl v5.28.2</td>
  </tr>
</table>
</body>
</html>
