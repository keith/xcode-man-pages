<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    .Nd, .Bf, .Op { display: inline; }
    .Pa, .Ad { font-style: italic; }
    .Ms { font-weight: bold; }
    .Bl-diag > dt { font-weight: bold; }
    code.Nm, .Fl, .Cm, .Ic, code.In, .Fd, .Fn, .Cd { font-weight: bold;
      font-family: inherit; }
  </style>
  <title>File::GlobMapper(3pm)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">File::GlobMapper(3pm)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">File::GlobMapper(3pm)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">File::GlobMapper - Extend File Glob to Allow Input and Output
    Files</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>    use File::GlobMapper qw( globmap );
    my $aref = globmap $input =&gt; $output
        or die $File::GlobMapper::Error ;
    my $gm = File::GlobMapper-&gt;new( $input =&gt; $output )
        or die $File::GlobMapper::Error ;
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">This module needs Perl5.005 or better.</p>
<p class="Pp">This module takes the existing
    <span class="Li">&quot;File::Glob&quot;</span> module as a starting point
    and extends it to allow new filenames to be derived from the files matched
    by <span class="Li">&quot;File::Glob&quot;</span>.</p>
<p class="Pp">This can be useful when carrying out batch operations on multiple
    files that have both an input filename and output filename and the output
    file can be derived from the input filename. Examples of operations where
    this can be useful include, file renaming, file copying and file
    compression.</p>
<section class="Ss">
<h2 class="Ss" id="Behind_The_Scenes"><a class="permalink" href="#Behind_The_Scenes">Behind
  The Scenes</a></h2>
<p class="Pp">To help explain what
    <span class="Li">&quot;File::GlobMapper&quot;</span> does, consider what
    code you would write if you wanted to rename all files in the current
    directory that ended in <span class="Li">&quot;.tar.gz&quot;</span> to
    <span class="Li">&quot;.tgz&quot;</span>. So say these files are in the
    current directory</p>
<p class="Pp"></p>
<pre>    alpha.tar.gz
    beta.tar.gz
    gamma.tar.gz
</pre>
<p class="Pp">and they need renamed to this</p>
<p class="Pp"></p>
<pre>    alpha.tgz
    beta.tgz
    gamma.tgz
</pre>
<p class="Pp">Below is a possible implementation of a script to carry out the
    rename (error cases have been omitted)</p>
<p class="Pp"></p>
<pre>    foreach my $old ( glob &quot;*.tar.gz&quot; )
    {
        my $new = $old;
        $new =~ s#(.*)\.tar\.gz$#$1.tgz# ;
        rename $old =&gt; $new
            or die &quot;Cannot rename '$old' to '$new': $!\n;
    }
</pre>
<p class="Pp">Notice that a file glob pattern
    <span class="Li">&quot;*.tar.gz&quot;</span> was used to match the
    <span class="Li">&quot;.tar.gz&quot;</span> files, then a fairly similar
    regular expression was used in the substitute to allow the new filename to
    be created.</p>
<p class="Pp">Given that the file glob is just a cut-down regular expression and
    that it has already done a lot of the hard work in pattern matching the
    filenames, wouldn't it be handy to be able to use the patterns in the
    fileglob to drive the new filename?</p>
<p class="Pp">Well, that's <i>exactly</i> what
    <span class="Li">&quot;File::GlobMapper&quot;</span> does.</p>
<p class="Pp">Here is same snippet of code rewritten using
    <span class="Li">&quot;globmap&quot;</span></p>
<p class="Pp"></p>
<pre>    for my $pair (globmap '&lt;*.tar.gz&gt;' =&gt; '&lt;#1.tgz&gt;' )
    {
        my ($from, $to) = @$pair;
        rename $from =&gt; $to
            or die &quot;Cannot rename '$old' to '$new': $!\n;
    }
</pre>
<p class="Pp">So how does it work?</p>
<p class="Pp">Behind the scenes the <span class="Li">&quot;globmap&quot;</span>
    function does a combination of a file glob to match existing filenames
    followed by a substitute to create the new filenames.</p>
<p class="Pp">Notice how both parameters to
    <span class="Li">&quot;globmap&quot;</span> are strings that are delimited
    by &lt;&gt;. This is done to make them look more like file globs - it is
    just syntactic sugar, but it can be handy when you want the strings to be
    visually distinctive. The enclosing &lt;&gt; are optional, so you don't have
    to use them - in fact the first thing globmap will do is remove these
    delimiters if they are present.</p>
<p class="Pp">The first parameter to
    <span class="Li">&quot;globmap&quot;</span>,
    <span class="Li">&quot;*.tar.gz&quot;</span>, is an <i>Input File Glob</i>.
    Once the enclosing &quot;&lt; ... &gt;&quot; is removed, this is passed
    (more or less) unchanged to <span class="Li">&quot;File::Glob&quot;</span>
    to carry out a file match.</p>
<p class="Pp">Next the fileglob <span class="Li">&quot;*.tar.gz&quot;</span> is
    transformed behind the scenes into a full Perl regular expression, with the
    additional step of wrapping each transformed wildcard metacharacter sequence
    in parenthesis.</p>
<p class="Pp">In this case the input fileglob
    <span class="Li">&quot;*.tar.gz&quot;</span> will be transformed into this
    Perl regular expression</p>
<p class="Pp"></p>
<pre>    ([^/]*)\.tar\.gz
</pre>
<p class="Pp">Wrapping with parenthesis allows the wildcard parts of the Input
    File Glob to be referenced by the second parameter to
    <span class="Li">&quot;globmap&quot;</span>,
    <span class="Li">&quot;#1.tgz&quot;</span>, the <i>Output File Glob</i>.
    This parameter operates just like the replacement part of a substitute
    command. The difference is that the <span class="Li">&quot;#1&quot;</span>
    syntax is used to reference sub-patterns matched in the input fileglob,
    rather than the <span class="Li">$1</span> syntax that is used with perl
    regular expressions. In this case <span class="Li">&quot;#1&quot;</span> is
    used to refer to the text matched by the
    <span class="Li">&quot;*&quot;</span> in the Input File Glob. This makes it
    easier to use this module where the parameters to
    <span class="Li">&quot;globmap&quot;</span> are typed at the command
  line.</p>
<p class="Pp">The final step involves passing each filename matched by the
    <span class="Li">&quot;*.tar.gz&quot;</span> file glob through the derived
    Perl regular expression in turn and expanding the output fileglob using
  it.</p>
<p class="Pp">The end result of all this is a list of pairs of filenames. By
    default that is what is returned by
    <span class="Li">&quot;globmap&quot;</span>. In this example the data
    structure returned will look like this</p>
<p class="Pp"></p>
<pre>     ( ['alpha.tar.gz' =&gt; 'alpha.tgz'],
       ['beta.tar.gz'  =&gt; 'beta.tgz' ],
       ['gamma.tar.gz' =&gt; 'gamma.tgz']
     )
</pre>
<p class="Pp">Each pair is an array reference with two elements - namely the
    <i>from</i> filename, that <span class="Li">&quot;File::Glob&quot;</span>
    has matched, and a <i>to</i> filename that is derived from the <i>from</i>
    filename.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Limitations"><a class="permalink" href="#Limitations">Limitations</a></h2>
<p class="Pp"><span class="Li">&quot;File::GlobMapper&quot;</span> has been kept
    simple deliberately, so it isn't intended to solve all filename mapping
    operations. Under the hood <span class="Li">&quot;File::Glob&quot;</span>
    (or for older versions of Perl,
    <span class="Li">&quot;File::BSDGlob&quot;</span>) is used to match the
    files, so you will never have the flexibility of full Perl regular
    expression.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Input_File_Glob"><a class="permalink" href="#Input_File_Glob">Input
  File Glob</a></h2>
<p class="Pp">The syntax for an Input FileGlob is identical to
    <span class="Li">&quot;File::Glob&quot;</span>, except for the following</p>
<dl class="Bl-tag">
  <dt>1.</dt>
  <dd>No nested {}</dd>
  <dt>2.</dt>
  <dd>Whitespace does not delimit fileglobs.</dd>
  <dt>3.</dt>
  <dd>The use of parenthesis can be used to capture parts of the input
    filename.</dd>
  <dt>4.</dt>
  <dd>If an Input glob matches the same file more than once, only the first will
      be used.</dd>
</dl>
<p class="Pp">The syntax</p>
<dl class="Bl-tag">
  <dt><b>~</b></dt>
  <dd></dd>
  <dt><b>~user</b></dt>
  <dd></dd>
  <dt><b>.</b></dt>
  <dd>Matches a literal '.'. Equivalent to the Perl regular expression
    <p class="Pp"></p>
    <pre>    \.
    </pre>
  </dd>
  <dt><b>*</b></dt>
  <dd>Matches zero or more characters, except '/'. Equivalent to the Perl
      regular expression
    <p class="Pp"></p>
    <pre>    [^/]*
    </pre>
  </dd>
  <dt><b>?</b></dt>
  <dd>Matches zero or one character, except '/'. Equivalent to the Perl regular
      expression
    <p class="Pp"></p>
    <pre>    [^/]?
    </pre>
  </dd>
  <dt><b>\</b></dt>
  <dd>Backslash is used, as usual, to escape the next character.</dd>
  <dt><b>[]</b></dt>
  <dd>Character class.</dd>
  <dt><b>{,}</b></dt>
  <dd>Alternation</dd>
  <dt><b>()</b></dt>
  <dd>Capturing parenthesis that work just like perl</dd>
</dl>
<p class="Pp">Any other character it taken literally.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Output_File_Glob"><a class="permalink" href="#Output_File_Glob">Output
  File Glob</a></h2>
<p class="Pp">The Output File Glob is a normal string, with 2 glob-like
    features.</p>
<p class="Pp">The first is the '*' metacharacter. This will be replaced by the
    complete filename matched by the input file glob. So</p>
<p class="Pp"></p>
<pre>    *.c *.Z
</pre>
<p class="Pp">The second is</p>
<p class="Pp">Output FileGlobs take the</p>
<dl class="Bl-tag">
  <dt>&quot;*&quot;</dt>
  <dd>The &quot;*&quot; character will be replaced with the complete input
      filename.</dd>
  <dt>#1</dt>
  <dd>Patterns of the form /#\d/ will be replaced with the</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Returned_Data"><a class="permalink" href="#Returned_Data">Returned
  Data</a></h2>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="EXAMPLES"><a class="permalink" href="#EXAMPLES">EXAMPLES</a></h1>
<section class="Ss">
<h2 class="Ss" id="A_Rename_script"><a class="permalink" href="#A_Rename_script">A
  Rename script</a></h2>
<p class="Pp">Below is a simple &quot;rename&quot; script that uses
    <span class="Li">&quot;globmap&quot;</span> to determine the source and
    destination filenames.</p>
<p class="Pp"></p>
<pre>    use File::GlobMapper qw(globmap) ;
    use File::Copy;
    die &quot;rename: Usage rename 'from' 'to'\n&quot;
        unless @ARGV == 2 ;
    my $fromGlob = shift @ARGV;
    my $toGlob   = shift @ARGV;
    my $pairs = globmap($fromGlob, $toGlob)
        or die $File::GlobMapper::Error;
    for my $pair (@$pairs)
    {
        my ($from, $to) = @$pair;
        move $from =&gt; $to ;
    }
</pre>
<p class="Pp">Here is an example that renames all c files to cpp.</p>
<p class="Pp"></p>
<pre>    $ rename '*.c' '#1.cpp'
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="A_few_example_globmaps"><a class="permalink" href="#A_few_example_globmaps">A
  few example globmaps</a></h2>
<p class="Pp">Below are a few examples of globmaps</p>
<p class="Pp">To copy all your .c file to a backup directory</p>
<p class="Pp"></p>
<pre>    '&lt;/my/home/*.c&gt;'    '&lt;/my/backup/#1.c&gt;'
</pre>
<p class="Pp">If you want to compress all</p>
<p class="Pp"></p>
<pre>    '&lt;/my/home/*.[ch]&gt;'    '&lt;*.gz&gt;'
</pre>
<p class="Pp">To uncompress</p>
<p class="Pp"></p>
<pre>    '&lt;/my/home/*.[ch].gz&gt;'    '&lt;/my/home/#1.#2&gt;'
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp">File::Glob</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">The <i>File::GlobMapper</i> module was written by Paul Marquess,
    <i>pmqs@cpan.org</i>.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT_AND_LICENSE"><a class="permalink" href="#COPYRIGHT_AND_LICENSE">COPYRIGHT
  AND LICENSE</a></h1>
<p class="Pp">Copyright (c) 2005 Paul Marquess. All rights reserved. This
    program is free software; you can redistribute it and/or modify it under the
    same terms as Perl itself.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2021-01-20</td>
    <td class="foot-os">perl v5.34.0</td>
  </tr>
</table>
</body>
</html>
