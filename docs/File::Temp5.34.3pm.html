<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    .Nd, .Bf, .Op { display: inline; }
    .Pa, .Ad { font-style: italic; }
    .Ms { font-weight: bold; }
    .Bl-diag > dt { font-weight: bold; }
    code.Nm, .Fl, .Cm, .Ic, code.In, .Fd, .Fn, .Cd { font-weight: bold;
      font-family: inherit; }
  </style>
  <title>File::Temp(3pm)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">File::Temp(3pm)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">File::Temp(3pm)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">File::Temp - return name and handle of a temporary file safely</p>
</section>
<section class="Sh">
<h1 class="Sh" id="VERSION"><a class="permalink" href="#VERSION">VERSION</a></h1>
<p class="Pp">version 0.2311</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>  use File::Temp qw/ tempfile tempdir /;
  $fh = tempfile();
  ($fh, $filename) = tempfile();
  ($fh, $filename) = tempfile( $template, DIR =&gt; $dir);
  ($fh, $filename) = tempfile( $template, SUFFIX =&gt; '.dat');
  ($fh, $filename) = tempfile( $template, TMPDIR =&gt; 1 );
  binmode( $fh, &quot;:utf8&quot; );
  $dir = tempdir( CLEANUP =&gt; 1 );
  ($fh, $filename) = tempfile( DIR =&gt; $dir );
</pre>
<p class="Pp">Object interface:</p>
<p class="Pp"></p>
<pre>  require File::Temp;
  use File::Temp ();
  use File::Temp qw/ :seekable /;
  $fh = File::Temp-&gt;new();
  $fname = $fh-&gt;filename;
  $fh = File::Temp-&gt;new(TEMPLATE =&gt; $template);
  $fname = $fh-&gt;filename;
  $tmp = File::Temp-&gt;new( UNLINK =&gt; 0, SUFFIX =&gt; '.dat' );
  print $tmp &quot;Some data\n&quot;;
  print &quot;Filename is $tmp\n&quot;;
  $tmp-&gt;seek( 0, SEEK_END );
  $dir = File::Temp-&gt;newdir(); # CLEANUP =&gt; 1 by default
</pre>
<p class="Pp">The following interfaces are provided for compatibility with
    existing APIs. They should not be used in new code.</p>
<p class="Pp">MkTemp family:</p>
<p class="Pp"></p>
<pre>  use File::Temp qw/ :mktemp  /;
  ($fh, $file) = mkstemp( &quot;tmpfileXXXXX&quot; );
  ($fh, $file) = mkstemps( &quot;tmpfileXXXXXX&quot;, $suffix);
  $tmpdir = mkdtemp( $template );
  $unopened_file = mktemp( $template );
</pre>
<p class="Pp">POSIX functions:</p>
<p class="Pp"></p>
<pre>  use File::Temp qw/ :POSIX /;
  $file = tmpnam();
  $fh = tmpfile();
  ($fh, $file) = tmpnam();
</pre>
<p class="Pp">Compatibility functions:</p>
<p class="Pp"></p>
<pre>  $unopened_file = File::Temp::tempnam( $dir, $pfx );
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp"><span class="Li">&quot;File::Temp&quot;</span> can be used to
    create and open temporary files in a safe way. There is both a function
    interface and an object-oriented interface. The File::Temp constructor or
    the <b>tempfile()</b> function can be used to return the name and the open
    filehandle of a temporary file. The <b>tempdir()</b> function can be used to
    create a temporary directory.</p>
<p class="Pp">The security aspect of temporary file creation is emphasized such
    that a filehandle and filename are returned together. This helps guarantee
    that a race condition can not occur where the temporary file is created by
    another process between checking for the existence of the file and its
    opening. Additional security levels are provided to check, for example, that
    the sticky bit is set on world writable directories. See
    &quot;safe_level&quot; for more information.</p>
<p class="Pp">For compatibility with popular C library functions, Perl
    implementations of the <b>mkstemp()</b> family of functions are provided.
    These are, <b>mkstemp()</b>, <b>mkstemps()</b>, <b>mkdtemp()</b> and
    <b>mktemp()</b>.</p>
<p class="Pp">Additionally, implementations of the standard POSIX
    <b>tmpnam()</b> and <b>tmpfile()</b> functions are provided if required.</p>
<p class="Pp">Implementations of <b>mktemp()</b>, <b>tmpnam()</b>, and
    <b>tempnam()</b> are provided, but should be used with caution since they
    return only a filename that was valid when function was called, so cannot
    guarantee that the file will not exist by the time the caller opens the
    filename.</p>
<p class="Pp">Filehandles returned by these functions support the seekable
    methods.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="OBJECT-ORIENTED_INTERFACE"><a class="permalink" href="#OBJECT-ORIENTED_INTERFACE">OBJECT-ORIENTED
  INTERFACE</a></h1>
<p class="Pp">This is the primary interface for interacting with
    <span class="Li">&quot;File::Temp&quot;</span>. Using the OO interface a
    temporary file can be created when the object is constructed and the file
    can be removed when the object is no longer required.</p>
<p class="Pp">Note that there is no method to obtain the filehandle from the
    <span class="Li">&quot;File::Temp&quot;</span> object. The object itself
    acts as a filehandle. The object isa
    <span class="Li">&quot;IO::Handle&quot;</span> and isa
    <span class="Li">&quot;IO::Seekable&quot;</span> so all those methods are
    available.</p>
<p class="Pp">Also, the object is configured such that it stringifies to the
    name of the temporary file and so can be compared to a filename directly. It
    numifies to the <span class="Li">&quot;refaddr&quot;</span> the same as
    other handles and so can be compared to other handles with
    <span class="Li">&quot;==&quot;</span>.</p>
<p class="Pp"></p>
<pre>    $fh eq $filename       # as a string
    $fh != \*STDOUT        # as a number
</pre>
<p class="Pp">Available since 0.14.</p>
<dl class="Bl-tag">
  <dt id="new"><a class="permalink" href="#new"><b>new</b></a></dt>
  <dd>Create a temporary file object.
    <p class="Pp"></p>
    <pre>  my $tmp = File::Temp-&gt;new();
    </pre>
    <p class="Pp">by default the object is constructed as if
        <span class="Li">&quot;tempfile&quot;</span> was called without options,
        but with the additional behaviour that the temporary file is removed by
        the object destructor if UNLINK is set to true (the default).</p>
    <p class="Pp">Supported arguments are the same as for
        <span class="Li">&quot;tempfile&quot;</span>: UNLINK (defaulting to
        true), DIR, EXLOCK, PERMS and SUFFIX. Additionally, the filename
        template is specified using the TEMPLATE option. The OPEN option is not
        supported (the file is always opened).</p>
    <p class="Pp"></p>
    <pre> $tmp = File::Temp-&gt;new( TEMPLATE =&gt; 'tempXXXXX',
                        DIR =&gt; 'mydir',
                        SUFFIX =&gt; '.dat');
    </pre>
    <p class="Pp">Arguments are case insensitive.</p>
    <p class="Pp">Can call <b>croak()</b> if an error occurs.</p>
    <p class="Pp">Available since 0.14.</p>
    <p class="Pp">TEMPLATE available since 0.23</p>
  </dd>
  <dt id="newdir"><a class="permalink" href="#newdir"><b>newdir</b></a></dt>
  <dd>Create a temporary directory using an object oriented interface.
    <p class="Pp"></p>
    <pre>  $dir = File::Temp-&gt;newdir();
    </pre>
    <p class="Pp">By default the directory is deleted when the object goes out
        of scope.</p>
    <p class="Pp">Supports the same options as the
        <span class="Li">&quot;tempdir&quot;</span> function. Note that
        directories created with this method default to CLEANUP =&gt; 1.</p>
    <p class="Pp"></p>
    <pre>  $dir = File::Temp-&gt;newdir( $template, %options );
    </pre>
    <p class="Pp">A template may be specified either with a leading template or
        with a TEMPLATE argument.</p>
    <p class="Pp">Available since 0.19.</p>
    <p class="Pp">TEMPLATE available since 0.23.</p>
  </dd>
  <dt id="filename"><a class="permalink" href="#filename"><b>filename</b></a></dt>
  <dd>Return the name of the temporary file associated with this object (if the
      object was created using the &quot;new&quot; constructor).
    <p class="Pp"></p>
    <pre>  $filename = $tmp-&gt;filename;
    </pre>
    <p class="Pp">This method is called automatically when the object is used as
        a string.</p>
    <p class="Pp">Current API available since 0.14</p>
  </dd>
  <dt id="dirname"><a class="permalink" href="#dirname"><b>dirname</b></a></dt>
  <dd>Return the name of the temporary directory associated with this object (if
      the object was created using the &quot;newdir&quot; constructor).
    <p class="Pp"></p>
    <pre>  $dirname = $tmpdir-&gt;dirname;
    </pre>
    <p class="Pp">This method is called automatically when the object is used in
        string context.</p>
  </dd>
  <dt id="unlink_on_destroy"><a class="permalink" href="#unlink_on_destroy"><b>unlink_on_destroy</b></a></dt>
  <dd>Control whether the file is unlinked when the object goes out of scope.
      The file is removed if this value is true and
      <span class="Li">$KEEP_ALL</span> is not.
    <p class="Pp"></p>
    <pre> $fh-&gt;unlink_on_destroy( 1 );
    </pre>
    <p class="Pp">Default is for the file to be removed.</p>
    <p class="Pp">Current API available since 0.15</p>
  </dd>
  <dt id="DESTROY"><a class="permalink" href="#DESTROY"><b>DESTROY</b></a></dt>
  <dd>When the object goes out of scope, the destructor is called. This
      destructor will attempt to unlink the file (using unlink1) if the
      constructor was called with UNLINK set to 1 (the default state if UNLINK
      is not specified).
    <p class="Pp">No error is given if the unlink fails.</p>
    <p class="Pp">If the object has been passed to a child process during a
        fork, the file will be deleted when the object goes out of scope in the
        parent.</p>
    <p class="Pp">For a temporary directory object the directory will be removed
        unless the CLEANUP argument was used in the constructor (and set to
        false) or <span class="Li">&quot;unlink_on_destroy&quot;</span> was
        modified after creation. Note that if a temp directory is your current
        directory, it cannot be removed - a warning will be given in this case.
        <span class="Li">&quot;chdir()&quot;</span> out of the directory before
        letting the object go out of scope.</p>
    <p class="Pp">If the global variable <span class="Li">$KEEP_ALL</span> is
        true, the file or directory will not be removed.</p>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="FUNCTIONS"><a class="permalink" href="#FUNCTIONS">FUNCTIONS</a></h1>
<p class="Pp">This section describes the recommended interface for generating
    temporary files and directories.</p>
<dl class="Bl-tag">
  <dt id="tempfile"><a class="permalink" href="#tempfile"><b>tempfile</b></a></dt>
  <dd>This is the basic function to generate temporary files. The behaviour of
      the file can be changed using various options:
    <p class="Pp"></p>
    <pre>  $fh = tempfile();
  ($fh, $filename) = tempfile();
    </pre>
    <p class="Pp">Create a temporary file in the directory specified for
        temporary files, as specified by the <b>tmpdir()</b> function in
        File::Spec.</p>
    <p class="Pp"></p>
    <pre>  ($fh, $filename) = tempfile($template);
    </pre>
    <p class="Pp">Create a temporary file in the current directory using the
        supplied template. Trailing `X' characters are replaced with random
        letters to generate the filename. At least four `X' characters must be
        present at the end of the template.</p>
    <p class="Pp"></p>
    <pre>  ($fh, $filename) = tempfile($template, SUFFIX =&gt; $suffix)
    </pre>
    <p class="Pp">Same as previously, except that a suffix is added to the
        template after the `X' translation. Useful for ensuring that a temporary
        filename has a particular extension when needed by other applications.
        But see the WARNING at the end.</p>
    <p class="Pp"></p>
    <pre>  ($fh, $filename) = tempfile($template, DIR =&gt; $dir);
    </pre>
    <p class="Pp">Translates the template as before except that a directory name
        is specified.</p>
    <p class="Pp"></p>
    <pre>  ($fh, $filename) = tempfile($template, TMPDIR =&gt; 1);
    </pre>
    <p class="Pp">Equivalent to specifying a DIR of
        &quot;File::Spec-&gt;tmpdir&quot;, writing the file into the same
        temporary directory as would be used if no template was specified at
        all.</p>
    <p class="Pp"></p>
    <pre>  ($fh, $filename) = tempfile($template, UNLINK =&gt; 1);
    </pre>
    <p class="Pp">Return the filename and filehandle as before except that the
        file is automatically removed when the program exits (dependent on
        <span class="Li">$KEEP_ALL</span>). Default is for the file to be
        removed if a file handle is requested and to be kept if the filename is
        requested. In a scalar context (where no filename is returned) the file
        is always deleted either (depending on the operating system) on exit or
        when it is closed (unless <span class="Li">$KEEP_ALL</span> is true when
        the temp file is created).</p>
    <p class="Pp">Use the object-oriented interface if fine-grained control of
        when a file is removed is required.</p>
    <p class="Pp">If the template is not specified, a template is always
        automatically generated. This temporary file is placed in
        <b>tmpdir()</b> (File::Spec) unless a directory is specified explicitly
        with the DIR option.</p>
    <p class="Pp"></p>
    <pre>  $fh = tempfile( DIR =&gt; $dir );
    </pre>
    <p class="Pp">If called in scalar context, only the filehandle is returned
        and the file will automatically be deleted when closed on operating
        systems that support this (see the description of <b>tmpfile()</b>
        elsewhere in this document). This is the preferred mode of operation, as
        if you only have a filehandle, you can never create a race condition by
        fumbling with the filename. On systems that can not unlink an open file
        or can not mark a file as temporary when it is opened (for example,
        Windows NT uses the <span class="Li">&quot;O_TEMPORARY&quot;</span>
        flag) the file is marked for deletion when the program ends (equivalent
        to setting UNLINK to 1). The <span class="Li">&quot;UNLINK&quot;</span>
        flag is ignored if present.</p>
    <p class="Pp"></p>
    <pre>  (undef, $filename) = tempfile($template, OPEN =&gt; 0);
    </pre>
    <p class="Pp">This will return the filename based on the template but will
        not open this file. Cannot be used in conjunction with UNLINK set to
        true. Default is to always open the file to protect from possible race
        conditions. A warning is issued if warnings are turned on. Consider
        using the <b>tmpnam()</b> and <b>mktemp()</b> functions described
        elsewhere in this document if opening the file is not required.</p>
    <p class="Pp">To open the temporary filehandle with O_EXLOCK (open with
        exclusive file lock) use
        <span class="Li">&quot;EXLOCK=&gt;1&quot;</span>. This is supported only
        by some operating systems (most notably BSD derived systems). By default
        EXLOCK will be false. Former
        <span class="Li">&quot;File::Temp&quot;</span> versions set EXLOCK to
        true, so to be sure to get an unlocked filehandle also with older
        versions, explicitly set
        <span class="Li">&quot;EXLOCK=&gt;0&quot;</span>.</p>
    <p class="Pp"></p>
    <pre>  ($fh, $filename) = tempfile($template, EXLOCK =&gt; 1);
    </pre>
    <p class="Pp">By default, the temp file is created with 0600 file
        permissions. Use <span class="Li">&quot;PERMS&quot;</span> to change
        this:</p>
    <p class="Pp"></p>
    <pre>  ($fh, $filename) = tempfile($template, PERMS =&gt; 0666);
    </pre>
    <p class="Pp">Options can be combined as required.</p>
    <p class="Pp">Will <b>croak()</b> if there is an error.</p>
    <p class="Pp">Available since 0.05.</p>
    <p class="Pp">UNLINK flag available since 0.10.</p>
    <p class="Pp">TMPDIR flag available since 0.19.</p>
    <p class="Pp">EXLOCK flag available since 0.19.</p>
    <p class="Pp">PERMS flag available since 0.2310.</p>
  </dd>
  <dt id="tempdir"><a class="permalink" href="#tempdir"><b>tempdir</b></a></dt>
  <dd>This is the recommended interface for creation of temporary directories.
      By default the directory will not be removed on exit (that is, it won't be
      temporary; this behaviour can not be changed because of issues with
      backwards compatibility). To enable removal either use the CLEANUP option
      which will trigger removal on program exit, or consider using the
      &quot;newdir&quot; method in the object interface which will allow the
      directory to be cleaned up when the object goes out of scope.
    <p class="Pp">The behaviour of the function depends on the arguments:</p>
    <p class="Pp"></p>
    <pre>  $tempdir = tempdir();
    </pre>
    <p class="Pp">Create a directory in <b>tmpdir()</b> (see File::Spec).</p>
    <p class="Pp"></p>
    <pre>  $tempdir = tempdir( $template );
    </pre>
    <p class="Pp">Create a directory from the supplied template. This template
        is similar to that described for <b>tempfile()</b>. `X' characters at
        the end of the template are replaced with random letters to construct
        the directory name. At least four `X' characters must be in the
        template.</p>
    <p class="Pp"></p>
    <pre>  $tempdir = tempdir ( DIR =&gt; $dir );
    </pre>
    <p class="Pp">Specifies the directory to use for the temporary directory.
        The temporary directory name is derived from an internal template.</p>
    <p class="Pp"></p>
    <pre>  $tempdir = tempdir ( $template, DIR =&gt; $dir );
    </pre>
    <p class="Pp">Prepend the supplied directory name to the template. The
        template should not include parent directory specifications itself. Any
        parent directory specifications are removed from the template before
        prepending the supplied directory.</p>
    <p class="Pp"></p>
    <pre>  $tempdir = tempdir ( $template, TMPDIR =&gt; 1 );
    </pre>
    <p class="Pp">Using the supplied template, create the temporary directory in
        a standard location for temporary files. Equivalent to doing</p>
    <p class="Pp"></p>
    <pre>  $tempdir = tempdir ( $template, DIR =&gt; File::Spec-&gt;tmpdir);
    </pre>
    <p class="Pp">but shorter. Parent directory specifications are stripped from
        the template itself. The <span class="Li">&quot;TMPDIR&quot;</span>
        option is ignored if <span class="Li">&quot;DIR&quot;</span> is set
        explicitly. Additionally, <span class="Li">&quot;TMPDIR&quot;</span> is
        implied if neither a template nor a directory are supplied.</p>
    <p class="Pp"></p>
    <pre>  $tempdir = tempdir( $template, CLEANUP =&gt; 1);
    </pre>
    <p class="Pp">Create a temporary directory using the supplied template, but
        attempt to remove it (and all files inside it) when the program exits.
        Note that an attempt will be made to remove all files from the directory
        even if they were not created by this module (otherwise why ask to clean
        it up?). The directory removal is made with the <b>rmtree()</b> function
        from the File::Path module. Of course, if the template is not specified,
        the temporary directory will be created in <b>tmpdir()</b> and will also
        be removed at program exit.</p>
    <p class="Pp">Will <b>croak()</b> if there is an error.</p>
    <p class="Pp">Current API available since 0.05.</p>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="MKTEMP_FUNCTIONS"><a class="permalink" href="#MKTEMP_FUNCTIONS">MKTEMP
  FUNCTIONS</a></h1>
<p class="Pp">The following functions are Perl implementations of the
    <b>mktemp()</b> family of temp file generation system calls.</p>
<dl class="Bl-tag">
  <dt id="mkstemp"><a class="permalink" href="#mkstemp"><b>mkstemp</b></a></dt>
  <dd>Given a template, returns a filehandle to the temporary file and the name
      of the file.
    <p class="Pp"></p>
    <pre>  ($fh, $name) = mkstemp( $template );
    </pre>
    <p class="Pp">In scalar context, just the filehandle is returned.</p>
    <p class="Pp">The template may be any filename with some number of X's
        appended to it, for example <i>/tmp/temp.XXXX</i>. The trailing X's are
        replaced with unique alphanumeric combinations.</p>
    <p class="Pp">Will <b>croak()</b> if there is an error.</p>
    <p class="Pp">Current API available since 0.05.</p>
  </dd>
  <dt id="mkstemps"><a class="permalink" href="#mkstemps"><b>mkstemps</b></a></dt>
  <dd>Similar to <b>mkstemp()</b>, except that an extra argument can be supplied
      with a suffix to be appended to the template.
    <p class="Pp"></p>
    <pre>  ($fh, $name) = mkstemps( $template, $suffix );
    </pre>
    <p class="Pp">For example a template of
        <span class="Li">&quot;testXXXXXX&quot;</span> and suffix of
        <span class="Li">&quot;.dat&quot;</span> would generate a file similar
        to <i>testhGji_w.dat</i>.</p>
    <p class="Pp">Returns just the filehandle alone when called in scalar
        context.</p>
    <p class="Pp">Will <b>croak()</b> if there is an error.</p>
    <p class="Pp">Current API available since 0.05.</p>
  </dd>
  <dt id="mkdtemp"><a class="permalink" href="#mkdtemp"><b>mkdtemp</b></a></dt>
  <dd>Create a directory from a template. The template must end in X's that are
      replaced by the routine.
    <p class="Pp"></p>
    <pre>  $tmpdir_name = mkdtemp($template);
    </pre>
    <p class="Pp">Returns the name of the temporary directory created.</p>
    <p class="Pp">Directory must be removed by the caller.</p>
    <p class="Pp">Will <b>croak()</b> if there is an error.</p>
    <p class="Pp">Current API available since 0.05.</p>
  </dd>
  <dt id="mktemp"><a class="permalink" href="#mktemp"><b>mktemp</b></a></dt>
  <dd>Returns a valid temporary filename but does not guarantee that the file
      will not be opened by someone else.
    <p class="Pp"></p>
    <pre>  $unopened_file = mktemp($template);
    </pre>
    <p class="Pp">Template is the same as that required by <b>mkstemp()</b>.</p>
    <p class="Pp">Will <b>croak()</b> if there is an error.</p>
    <p class="Pp">Current API available since 0.05.</p>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="POSIX_FUNCTIONS"><a class="permalink" href="#POSIX_FUNCTIONS">POSIX
  FUNCTIONS</a></h1>
<p class="Pp">This section describes the re-implementation of the
    <b>tmpnam()</b> and <b>tmpfile()</b> functions described in POSIX using the
    <b>mkstemp()</b> from this module.</p>
<p class="Pp">Unlike the POSIX implementations, the directory used for the
    temporary file is not specified in a system include file
    (<span class="Li">&quot;P_tmpdir&quot;</span>) but simply depends on the
    choice of <b>tmpdir()</b> returned by File::Spec. On some implementations
    this location can be set using the
    <span class="Li">&quot;TMPDIR&quot;</span> environment variable, which may
    not be secure. If this is a problem, simply use <b>mkstemp()</b> and specify
    a template.</p>
<dl class="Bl-tag">
  <dt id="tmpnam"><a class="permalink" href="#tmpnam"><b>tmpnam</b></a></dt>
  <dd>When called in scalar context, returns the full name (including path) of a
      temporary file (uses <b>mktemp()</b>). The only check is that the file
      does not already exist, but there is no guarantee that that condition will
      continue to apply.
    <p class="Pp"></p>
    <pre>  $file = tmpnam();
    </pre>
    <p class="Pp">When called in list context, a filehandle to the open file and
        a filename are returned. This is achieved by calling <b>mkstemp()</b>
        after constructing a suitable template.</p>
    <p class="Pp"></p>
    <pre>  ($fh, $file) = tmpnam();
    </pre>
    <p class="Pp">If possible, this form should be used to prevent possible race
        conditions.</p>
    <p class="Pp">See &quot;tmpdir&quot; in File::Spec for information on the
        choice of temporary directory for a particular operating system.</p>
    <p class="Pp">Will <b>croak()</b> if there is an error.</p>
    <p class="Pp">Current API available since 0.05.</p>
  </dd>
  <dt id="tmpfile"><a class="permalink" href="#tmpfile"><b>tmpfile</b></a></dt>
  <dd>Returns the filehandle of a temporary file.
    <p class="Pp"></p>
    <pre>  $fh = tmpfile();
    </pre>
    <p class="Pp">The file is removed when the filehandle is closed or when the
        program exits. No access to the filename is provided.</p>
    <p class="Pp">If the temporary file can not be created undef is returned.
        Currently this command will probably not work when the temporary
        directory is on an NFS file system.</p>
    <p class="Pp">Will <b>croak()</b> if there is an error.</p>
    <p class="Pp">Available since 0.05.</p>
    <p class="Pp">Returning undef if unable to create file added in 0.12.</p>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="ADDITIONAL_FUNCTIONS"><a class="permalink" href="#ADDITIONAL_FUNCTIONS">ADDITIONAL
  FUNCTIONS</a></h1>
<p class="Pp">These functions are provided for backwards compatibility with
    common tempfile generation C library functions.</p>
<p class="Pp">They are not exported and must be addressed using the full package
    name.</p>
<dl class="Bl-tag">
  <dt id="tempnam"><a class="permalink" href="#tempnam"><b>tempnam</b></a></dt>
  <dd>Return the name of a temporary file in the specified directory using a
      prefix. The file is guaranteed not to exist at the time the function was
      called, but such guarantees are good for one clock tick only. Always use
      the proper form of <span class="Li">&quot;sysopen&quot;</span> with
      <span class="Li">&quot;O_CREAT | O_EXCL&quot;</span> if you must open such
      a filename.
    <p class="Pp"></p>
    <pre>  $filename = File::Temp::tempnam( $dir, $prefix );
    </pre>
    <p class="Pp">Equivalent to running <b>mktemp()</b> with
        <span class="Li">$dir</span>/$prefixXXXXXXXX (using unix file convention
        as an example)</p>
    <p class="Pp">Because this function uses <b>mktemp()</b>, it can suffer from
        race conditions.</p>
    <p class="Pp">Will <b>croak()</b> if there is an error.</p>
    <p class="Pp">Current API available since 0.05.</p>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="UTILITY_FUNCTIONS"><a class="permalink" href="#UTILITY_FUNCTIONS">UTILITY
  FUNCTIONS</a></h1>
<p class="Pp">Useful functions for dealing with the filehandle and filename.</p>
<dl class="Bl-tag">
  <dt id="unlink0"><a class="permalink" href="#unlink0"><b>unlink0</b></a></dt>
  <dd>Given an open filehandle and the associated filename, make a safe unlink.
      This is achieved by first checking that the filename and filehandle
      initially point to the same file and that the number of links to the file
      is 1 (all fields returned by <b>stat()</b> are compared). Then the
      filename is unlinked and the filehandle checked once again to verify that
      the number of links on that file is now 0. This is the closest you can
      come to making sure that the filename unlinked was the same as the file
      whose descriptor you hold.
    <p class="Pp"></p>
    <pre>  unlink0($fh, $path)
     or die &quot;Error unlinking file $path safely&quot;;
    </pre>
    <p class="Pp">Returns false on error but <b>croaks()</b> if there is a
        security anomaly. The filehandle is not closed since on some occasions
        this is not required.</p>
    <p class="Pp">On some platforms, for example Windows NT, it is not possible
        to unlink an open file (the file must be closed first). On those
        platforms, the actual unlinking is deferred until the program ends and
        good status is returned. A check is still performed to make sure that
        the filehandle and filename are pointing to the same thing (but not at
        the time the end block is executed since the deferred removal may not
        have access to the filehandle).</p>
    <p class="Pp">Additionally, on Windows NT not all the fields returned by
        <b>stat()</b> can be compared. For example, the
        <span class="Li">&quot;dev&quot;</span> and
        <span class="Li">&quot;rdev&quot;</span> fields seem to be different.
        Also, it seems that the size of the file returned by <b>stat()</b> does
        not always agree, with <span class="Li">&quot;stat(FH)&quot;</span>
        being more accurate than
        <span class="Li">&quot;stat(filename)&quot;</span>, presumably because
        of caching issues even when using autoflush (this is usually overcome by
        waiting a while after writing to the tempfile before attempting to
        <span class="Li">&quot;unlink0&quot;</span> it).</p>
    <p class="Pp">Finally, on NFS file systems the link count of the file handle
        does not always go to zero immediately after unlinking. Currently, this
        command is expected to fail on NFS disks.</p>
    <p class="Pp">This function is disabled if the global variable
        <span class="Li">$KEEP_ALL</span> is true and an unlink on open file is
        supported. If the unlink is to be deferred to the END block, the file is
        still registered for removal.</p>
    <p class="Pp">This function should not be called if you are using the object
        oriented interface since the it will interfere with the object
        destructor deleting the file.</p>
    <p class="Pp">Available Since 0.05.</p>
    <p class="Pp">If can not unlink open file, defer removal until later
        available since 0.06.</p>
  </dd>
  <dt id="cmpstat"><a class="permalink" href="#cmpstat"><b>cmpstat</b></a></dt>
  <dd>Compare <span class="Li">&quot;stat&quot;</span> of filehandle with
      <span class="Li">&quot;stat&quot;</span> of provided filename. This can be
      used to check that the filename and filehandle initially point to the same
      file and that the number of links to the file is 1 (all fields returned by
      <b>stat()</b> are compared).
    <p class="Pp"></p>
    <pre>  cmpstat($fh, $path)
     or die &quot;Error comparing handle with file&quot;;
    </pre>
    <p class="Pp">Returns false if the stat information differs or if the link
        count is greater than 1. Calls croak if there is a security anomaly.</p>
    <p class="Pp">On certain platforms, for example Windows, not all the fields
        returned by <b>stat()</b> can be compared. For example, the
        <span class="Li">&quot;dev&quot;</span> and
        <span class="Li">&quot;rdev&quot;</span> fields seem to be different in
        Windows. Also, it seems that the size of the file returned by
        <b>stat()</b> does not always agree, with
        <span class="Li">&quot;stat(FH)&quot;</span> being more accurate than
        <span class="Li">&quot;stat(filename)&quot;</span>, presumably because
        of caching issues even when using autoflush (this is usually overcome by
        waiting a while after writing to the tempfile before attempting to
        <span class="Li">&quot;unlink0&quot;</span> it).</p>
    <p class="Pp">Not exported by default.</p>
    <p class="Pp">Current API available since 0.14.</p>
  </dd>
  <dt id="unlink1"><a class="permalink" href="#unlink1"><b>unlink1</b></a></dt>
  <dd>Similar to <span class="Li">&quot;unlink0&quot;</span> except after file
      comparison using cmpstat, the filehandle is closed prior to attempting to
      unlink the file. This allows the file to be removed without using an END
      block, but does mean that the post-unlink comparison of the filehandle
      state provided by <span class="Li">&quot;unlink0&quot;</span> is not
      available.
    <p class="Pp"></p>
    <pre>  unlink1($fh, $path)
     or die &quot;Error closing and unlinking file&quot;;
    </pre>
    <p class="Pp">Usually called from the object destructor when using the OO
        interface.</p>
    <p class="Pp">Not exported by default.</p>
    <p class="Pp">This function is disabled if the global variable
        <span class="Li">$KEEP_ALL</span> is true.</p>
    <p class="Pp">Can call <b>croak()</b> if there is a security anomaly during
        the <b>stat()</b> comparison.</p>
    <p class="Pp">Current API available since 0.14.</p>
  </dd>
  <dt id="cleanup"><a class="permalink" href="#cleanup"><b>cleanup</b></a></dt>
  <dd>Calling this function will cause any temp files or temp directories that
      are registered for removal to be removed. This happens automatically when
      the process exits but can be triggered manually if the caller is sure that
      none of the temp files are required. This method can be registered as an
      Apache callback.
    <p class="Pp">Note that if a temp directory is your current directory, it
        cannot be removed. <span class="Li">&quot;chdir()&quot;</span> out of
        the directory first before calling
        <span class="Li">&quot;cleanup()&quot;</span>. (For the cleanup at
        program exit when the CLEANUP flag is set, this happens
      automatically.)</p>
    <p class="Pp">On OSes where temp files are automatically removed when the
        temp file is closed, calling this function will have no effect other
        than to remove temporary directories (which may include temporary
        files).</p>
    <p class="Pp"></p>
    <pre>  File::Temp::cleanup();
    </pre>
    <p class="Pp">Not exported by default.</p>
    <p class="Pp">Current API available since 0.15.</p>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="PACKAGE_VARIABLES"><a class="permalink" href="#PACKAGE_VARIABLES">PACKAGE
  VARIABLES</a></h1>
<p class="Pp">These functions control the global state of the package.</p>
<dl class="Bl-tag">
  <dt id="safe_level"><a class="permalink" href="#safe_level"><b>safe_level</b></a></dt>
  <dd>Controls the lengths to which the module will go to check the safety of
      the temporary file or directory before proceeding. Options are:</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="STANDARD"><a class="permalink" href="#STANDARD">STANDARD</a></dt>
  <dd>Do the basic security measures to ensure the directory exists and is
      writable, that temporary files are opened only if they do not already
      exist, and that possible race conditions are avoided. Finally the unlink0
      function is used to remove files safely.</dd>
  <dt id="MEDIUM"><a class="permalink" href="#MEDIUM">MEDIUM</a></dt>
  <dd>In addition to the STANDARD security, the output directory is checked to
      make sure that it is owned either by root or the user running the program.
      If the directory is writable by group or by other, it is then checked to
      make sure that the sticky bit is set.
    <p class="Pp">Will not work on platforms that do not support the
        <span class="Li">&quot;-k&quot;</span> test for sticky bit.</p>
  </dd>
  <dt id="HIGH"><a class="permalink" href="#HIGH">HIGH</a></dt>
  <dd>In addition to the MEDIUM security checks, also check for the possibility
      of ``<b>chown()</b> giveaway'' using the POSIX <b>sysconf()</b> function.
      If this is a possibility, each directory in the path is checked in turn
      for safeness, recursively walking back to the root directory.
    <p class="Pp">For platforms that do not support the POSIX
        <span class="Li">&quot;_PC_CHOWN_RESTRICTED&quot;</span> symbol (for
        example, Windows NT) it is assumed that ``<b>chown()</b> giveaway'' is
        possible and the recursive test is performed.</p>
  </dd>
</dl>
</div>
<div class="Bd-indent">
<p class="Pp">The level can be changed as follows:</p>
<p class="Pp"></p>
<pre>  File::Temp-&gt;safe_level( File::Temp::HIGH );
</pre>
<p class="Pp">The level constants are not exported by the module.</p>
<p class="Pp">Currently, you must be running at least perl v5.6.0 in order to
    run with MEDIUM or HIGH security. This is simply because the safety tests
    use functions from Fcntl that are not available in older versions of perl.
    The problem is that the version number for Fcntl is the same in perl 5.6.0
    and in 5.005_03 even though they are different versions.</p>
<p class="Pp">On systems that do not support the HIGH or MEDIUM safety levels
    (for example Win NT or OS/2) any attempt to change the level will be
    ignored. The decision to ignore rather than raise an exception allows
    portable programs to be written with high security in mind for the systems
    that can support this without those programs failing on systems where the
    extra tests are irrelevant.</p>
<p class="Pp">If you really need to see whether the change has been accepted
    simply examine the return value of
    <span class="Li">&quot;safe_level&quot;</span>.</p>
<p class="Pp"></p>
<pre>  $newlevel = File::Temp-&gt;safe_level( File::Temp::HIGH );
  die &quot;Could not change to high security&quot;
      if $newlevel != File::Temp::HIGH;
</pre>
<p class="Pp">Available since 0.05.</p>
</div>
<dl class="Bl-tag">
  <dt id="TopSystemUID"><a class="permalink" href="#TopSystemUID">TopSystemUID</a></dt>
  <dd>This is the highest UID on the current system that refers to a root UID.
      This is used to make sure that the temporary directory is owned by a
      system UID (<span class="Li">&quot;root&quot;</span>,
      <span class="Li">&quot;bin&quot;</span>,
      <span class="Li">&quot;sys&quot;</span> etc) rather than simply by root.
    <p class="Pp">This is required since on many unix systems
        <span class="Li">&quot;/tmp&quot;</span> is not owned by root.</p>
    <p class="Pp">Default is to assume that any UID less than or equal to 10 is
        a root UID.</p>
    <p class="Pp"></p>
    <pre>  File::Temp-&gt;top_system_uid(10);
  my $topid = File::Temp-&gt;top_system_uid;
    </pre>
    <p class="Pp">This value can be adjusted to reduce security checking if
        required. The value is only relevant when
        <span class="Li">&quot;safe_level&quot;</span> is set to MEDIUM or
        higher.</p>
    <p class="Pp">Available since 0.05.</p>
  </dd>
  <dt><b></b><span class="Li"><b>$KEEP_ALL</b></span><b></b></dt>
  <dd>Controls whether temporary files and directories should be retained
      regardless of any instructions in the program to remove them
      automatically. This is useful for debugging but should not be used in
      production code.
    <p class="Pp"></p>
    <pre>  $File::Temp::KEEP_ALL = 1;
    </pre>
    <p class="Pp">Default is for files to be removed as requested by the
      caller.</p>
    <p class="Pp">In some cases, files will only be retained if this variable is
        true when the file is created. This means that you can not create a
        temporary file, set this variable and expect the temp file to still be
        around when the program exits.</p>
  </dd>
  <dt><b></b><span class="Li"><b>$DEBUG</b></span><b></b></dt>
  <dd>Controls whether debugging messages should be enabled.
    <p class="Pp"></p>
    <pre>  $File::Temp::DEBUG = 1;
    </pre>
    <p class="Pp">Default is for debugging mode to be disabled.</p>
    <p class="Pp">Available since 0.15.</p>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="WARNING"><a class="permalink" href="#WARNING">WARNING</a></h1>
<p class="Pp">For maximum security, endeavour always to avoid ever looking at,
    touching, or even imputing the existence of the filename. You do not know
    that that filename is connected to the same file as the handle you have, and
    attempts to check this can only trigger more race conditions. It's far more
    secure to use the filehandle alone and dispense with the filename
    altogether.</p>
<p class="Pp">If you need to pass the handle to something that expects a
    filename then on a unix system you can use
    <span class="Li">&quot;&quot;/dev/fd/&quot; . fileno($fh)&quot;</span> for
    arbitrary programs. Perl code that uses the 2-argument version of
    <span class="Li">&quot;open&quot;</span> can be passed
    <span class="Li">&quot;&quot;+&lt;=&amp;&quot; . fileno($fh)&quot;</span>.
    Otherwise you will need to pass the filename. You will have to clear the
    close-on-exec bit on that file descriptor before passing it to another
    process.</p>
<p class="Pp"></p>
<pre>    use Fcntl qw/F_SETFD F_GETFD/;
    fcntl($tmpfh, F_SETFD, 0)
        or die &quot;Can't clear close-on-exec flag on temp fh: $!\n&quot;;
</pre>
<section class="Ss">
<h2 class="Ss" id="Temporary_files_and_"><a class="permalink" href="#Temporary_files_and_">Temporary
  files and NFS</a></h2>
<p class="Pp">Some problems are associated with using temporary files that
    reside on NFS file systems and it is recommended that a local filesystem is
    used whenever possible. Some of the security tests will most probably fail
    when the temp file is not local. Additionally, be aware that the performance
    of I/O operations over NFS will not be as good as for a local disk.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Forking"><a class="permalink" href="#Forking">Forking</a></h2>
<p class="Pp">In some cases files created by File::Temp are removed from within
    an END block. Since END blocks are triggered when a child process exits
    (unless <span class="Li">&quot;POSIX::_exit()&quot;</span> is used by the
    child) File::Temp takes care to only remove those temp files created by a
    particular process ID. This means that a child will not attempt to remove
    temp files created by the parent process.</p>
<p class="Pp">If you are forking many processes in parallel that are all
    creating temporary files, you may need to reset the random number seed using
    srand(EXPR) in each child else all the children will attempt to walk through
    the same set of random file names and may well cause themselves to give up
    if they exceed the number of retry attempts.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Directory_removal"><a class="permalink" href="#Directory_removal">Directory
  removal</a></h2>
<p class="Pp">Note that if you have chdir'ed into the temporary directory and it
    is subsequently cleaned up (either in the END block or as part of object
    destruction), then you will get a warning from
  <b>File::Path::rmtree()</b>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Taint_mode"><a class="permalink" href="#Taint_mode">Taint
  mode</a></h2>
<p class="Pp">If you need to run code under taint mode, updating to the latest
    File::Spec is highly recommended. On Windows, if the directory given by
    File::Spec::tmpdir isn't writable, File::Temp will attempt to fallback to
    the user's local application data directory or croak with an error.</p>
</section>
<section class="Ss">
<h2 class="Ss">BINMODE</h2>
<p class="Pp">The file returned by File::Temp will have been opened in binary
    mode if such a mode is available. If that is not correct, use the
    <span class="Li">&quot;binmode()&quot;</span> function to change the mode of
    the filehandle.</p>
<p class="Pp">Note that you can modify the encoding of a file opened by
    File::Temp also by using <span class="Li">&quot;binmode()&quot;</span>.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="HISTORY"><a class="permalink" href="#HISTORY">HISTORY</a></h1>
<p class="Pp">Originally began life in May 1999 as an XS interface to the system
    <b>mkstemp()</b> function. In March 2000, the OpenBSD <b>mkstemp()</b> code
    was translated to Perl for total control of the code's security checking, to
    ensure the presence of the function regardless of operating system and to
    help with portability. The module was shipped as a standard part of perl
    from v5.6.1.</p>
<p class="Pp">Thanks to Tom Christiansen for suggesting that this module should
    be written and providing ideas for code improvements and security
    enhancements.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp">&quot;tmpnam&quot; in POSIX, &quot;tmpfile&quot; in POSIX,
    File::Spec, File::Path</p>
<p class="Pp">See IO::File and File::MkTemp, Apache::TempFile for different
    implementations of temporary file handling.</p>
<p class="Pp">See File::Tempdir for an alternative object-oriented wrapper for
    the <span class="Li">&quot;tempdir&quot;</span> function.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SUPPORT"><a class="permalink" href="#SUPPORT">SUPPORT</a></h1>
<p class="Pp">Bugs may be submitted through the RT bug tracker
    &lt;https://rt.cpan.org/Public/Dist/Display.html?Name=File-Temp&gt; (or
    bug-File-Temp@rt.cpan.org &lt;mailto:bug-File-Temp@rt.cpan.org&gt;).</p>
<p class="Pp">There is also a mailing list available for users of this
    distribution, at &lt;http://lists.perl.org/list/cpan-workers.html&gt;.</p>
<p class="Pp">There is also an irc channel available for users of this
    distribution, at <span class="Li">&quot;#toolchain&quot;</span> on
    <span class="Li">&quot;irc.perl.org&quot;</span>
    &lt;irc://irc.perl.org/#toolchain&gt;.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">Tim Jenness &lt;tjenness@cpan.org&gt;</p>
</section>
<section class="Sh">
<h1 class="Sh" id="CONTRIBUTORS"><a class="permalink" href="#CONTRIBUTORS">CONTRIBUTORS</a></h1>
<ul class="Bl-bullet">
  <li>Tim Jenness &lt;t.jenness@jach.hawaii.edu&gt;</li>
  <li>Karen Etheridge &lt;ether@cpan.org&gt;</li>
  <li>David Golden &lt;dagolden@cpan.org&gt;</li>
  <li>Slaven Rezic &lt;srezic@cpan.org&gt;</li>
  <li>mohawk2 &lt;mohawk2@users.noreply.github.com&gt;</li>
  <li>Roy Ivy III &lt;rivy.dev@gmail.com&gt;</li>
  <li>Peter Rabbitson &lt;ribasushi@cpan.org&gt;</li>
  <li>Olivier Mengue &lt;dolmen@cpan.org&gt;</li>
  <li>Peter John Acklam &lt;pjacklam@online.no&gt;</li>
  <li>Tim Gim Yee &lt;tim.gim.yee@gmail.com&gt;</li>
  <li>Nicolas R &lt;atoomic@cpan.org&gt;</li>
  <li>Brian Mowrey &lt;brian@drlabs.org&gt;</li>
  <li>Dagfinn Ilmari Mannsaaker &lt;ilmari@ilmari.org&gt;</li>
  <li>David Steinbrunner &lt;dsteinbrunner@pobox.com&gt;</li>
  <li>Ed Avis &lt;eda@linux01.wcl.local&gt;</li>
  <li>Guillem Jover &lt;guillem@hadrons.org&gt;</li>
  <li>James E. Keenan &lt;jkeen@verizon.net&gt;</li>
  <li>Kevin Ryde &lt;user42@zip.com.au&gt;</li>
  <li>Ben Tilly &lt;btilly@gmail.com&gt;</li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT_AND_LICENSE"><a class="permalink" href="#COPYRIGHT_AND_LICENSE">COPYRIGHT
  AND LICENSE</a></h1>
<p class="Pp">This software is copyright (c) 2020 by Tim Jenness and the UK
    Particle Physics and Astronomy Research Council.</p>
<p class="Pp">This is free software; you can redistribute it and/or modify it
    under the same terms as the Perl 5 programming language system itself.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2022-02-19</td>
    <td class="foot-os">perl v5.34.1</td>
  </tr>
</table>
</body>
</html>
