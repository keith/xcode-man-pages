<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>Parse::Eyapp::defaultactionsintro(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Parse::Eyapp::defaultactionsintro(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Parse::Eyapp::defaultactionsintro(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
Parse::Eyapp::defaultactionsintro - Introduction to Default Actions and Grammar
  Reuse
</section>
<section class="Sh">
<h1 class="Sh" id="Introduction"><a class="permalink" href="#Introduction">Introduction</a></h1>
The examples used in this tutorial can be found in the directory
  <span class="Li">&quot;examples/recycle&quot;</span> accompanying this
  distribution
</section>
<section class="Sh">
<h1 class="Sh" id="Default_Actions"><a class="permalink" href="#Default_Actions">Default
  Actions</a></h1>
<section class="Ss">
<h2 class="Ss" id="Default_actions"><a class="permalink" href="#Default_actions">Default
  actions</a></h2>
When no action is specified both <span class="Li">&quot;yapp&quot;</span> and
  <span class="Li">&quot;eyapp&quot;</span> implicitly insert the semantic
  action <span class="Li">&quot;{ $_[1] }&quot;</span>. In
  <span class="Li">&quot;Parse::Eyapp&quot;</span> you can modify such behavior
  using the <span class="Li">&quot;%defaultaction { Perl code }&quot;</span>
  directive. The <span class="Li">&quot;{ Perl code }&quot;</span> clause that
  follows the <span class="Li">%defaultaction</span> directive is executed when
  reducing by any production for which no explicit action was specified.
<p class="Pp"><i>Translator from Infix to Postfix</i></p>
<p class="Pp">See the example in
    <span class="Li">&quot;examples/eyapplanguageref/Postfix.eyp&quot;</span>
    that translates an infix expression like
    <span class="Li">&quot;a=b*-3&quot;</span> into a postfix expression like
    <span class="Li">&quot;a b 3 NEG * = &quot;</span>:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  Parse-Eyapp/examples/eyapplanguageref$ cat -n Postfix.eyp
     1  # File Postfix.eyp
     2  %right  '='
     3  %left   '-' '+'
     4  %left   '*' '/'
     5  %left   NEG
     6
     7  %defaultaction { return  &quot;$left $right $op&quot;; }
     8
     9  %%
    10  line: $exp  { print &quot;$exp\n&quot; }
    11  ;
    12
    13  exp:        $NUM  { $NUM }
    14          |   $VAR  { $VAR }
    15          |   VAR.left '='.op exp.right
    16          |   exp.left '+'.op exp.right
    17          |   exp.left '-'.op exp.right
    18          |   exp.left '*'.op exp.right
    19          |   exp.left '/'.op exp.right
    20          |   '-' $exp %prec NEG { &quot;$exp NEG&quot; }
    21          |   '(' $exp ')' { $exp }
    22  ;
    23
    24  %%
    25
    26  sub _Error {
    27    my($token)=$_[0]-&gt;YYCurval;
    28    my($what)= $token ? &quot;input: '$token'&quot; : &quot;end of input&quot;;
    29    my @expected = $_[0]-&gt;YYExpect();
    30
    31    local $&quot; = ', ';
    32    die &quot;Syntax error near $what. Expected one of these tokens: @expected\n&quot;;
    33  }
    34
    35  my $x;
    36
    37  sub _Lexer {
    38    my($parser)=shift;
    39
    40    for ($x) {
    41      s/^\s+//;
    42      $_ eq '' and return('',undef);
    43
    44      s/^([0-9]+(?:\.[0-9]+)?)//   and return('NUM',$1);
    45      s/^([A-Za-z][A-Za-z0-9_]*)// and return('VAR',$1);
    46      s/^(.)//s                    and return($1,$1);
    47    }
    48  }
    49
    50  sub Run {
    51    my($self)=shift;
    52    my $debug = shift @ARGV;
    53    $debug = 0x1F if $debug;
    54    print &quot;Infix to postfix translator. Write an arithmetic expression: &quot;;
    55    $x = &lt;STDIN&gt;;
    56    $self-&gt;YYParse(
    57      yylex =&gt; \&amp;_Lexer,
    58      yyerror =&gt; \&amp;_Error,
    59      yydebug =&gt; $debug,
    60    );
    61  }
    62
    63   # Modulino
    64   __PACKAGE__-&gt;new()-&gt;Run unless caller();
</pre>
<p class="Pp">The file containing the <span class="Li">&quot;Eyapp&quot;</span>
    program must be compiled with <span class="Li">&quot;eyapp&quot;</span>:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
 Parse-Eyapp/examples/eyapplanguageref$ eyapp Postfix.eyp
</pre>
<p class="Pp">Next, you have to write a client program:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  Parse-Eyapp/examples/eyapplanguageref$ cat -n usepostfix.pl
     1  #!/usr/bin/perl -w
     2  use strict;
     3  use Postfix;
     4
     5  my $parser = new Postfix();
     6  $parser-&gt;Run;
</pre>
<p class="Pp">Now we can run the client program:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
 Parse-Eyapp/examples/eyapplanguageref$ usepostfix.pl
 Infix to postfix translator. Write an arithmetic expression: -(2*a-b*-3)
 2 a * b 3 NEG * - NEG
</pre>
<p class="Pp">An alternative is to use the generated module as a modulino,
    compiling the grammar using option
  <span class="Li">&quot;-b&quot;</span>:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  Parse-Eyapp/examples/eyapplanguageref$ eyapp -b '' Postfix.eyp
</pre>
<p class="Pp">This way, we can directly use the modulo as a script:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  Parse-Eyapp/examples/eyapplanguageref$ ./Postfix.pm
  Infix to postfix translator. Write an arithmetic expression: 2*3+b
  2 3 * b +
</pre>
<p class="Pp"><i>Default Actions, </i><i>%name</i><i> and
    </i><i>&quot;YYName&quot;</i><i></i></p>
<p class="Pp">In <span class="Li">&quot;eyapp&quot;</span> each production rule
    has a name. The name of a rule can be explicitly given by the programmer
    using the <span class="Li">%name</span> directive. For example, in the piece
    of code that follows the name <span class="Li">&quot;ASSIGN&quot;</span> is
    given to the rule <span class="Li">&quot;exp: VAR '=' exp&quot;</span>.</p>
<p class="Pp">When no explicit name is given the rule has an implicit name. The
    implicit name of a rule is shaped by concatenating the name of the syntactic
    variable on its left, an underscore and the ordinal number of the production
    rule <span class="Li">&quot;Lhs_#&quot;</span> as it appears in the
    <span class="Li">&quot;.output&quot;</span> file. Avoid giving names
    matching such pattern to production rules. The patterns
    <span class="Li">&quot;/${lhs}_\d+$/&quot;</span> where
    <span class="Li">&quot;${lhs}&quot;</span> is the name of the syntactic
    variable are reserved for internal use by
    <span class="Li">&quot;eyapp&quot;</span>.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  pl@nereida:~/LEyapp/examples$ cat -n Lhs.eyp
   1  # Lhs.eyp
   2
   3  %right  '='
   4  %left   '-' '+'
   5  %left   '*' '/'
   6  %left   NEG
   7
   8  %defaultaction {
   9    my $self = shift;
  10    my $name = $self-&gt;YYName();
  11    bless { children =&gt; [ grep {ref($_)} @_] }, $name;
  12  }
  13
  14  %%
  15  input:
  16              /* empty */
  17                { [] }
  18          |   input line
  19                {
  20                  push @{$_[1]}, $_[2] if defined($_[2]);
  21                  $_[1]
  22                }
  23  ;
  24
  25  line:     '\n'       { }
  26          | exp '\n'   {  $_[1] }
  27  ;
  28
  29  exp:
  30              NUM   { $_[1] }
  31          |   VAR   { $_[1] }
  32          |   %name ASSIGN
  33              VAR '=' exp
  34          |   %name PLUS
  35              exp '+' exp
  36          |   %name MINUS
  37              exp '-' exp
  38          |   %name TIMES
  39              exp '*' exp
  40          |   %name DIV
  41              exp '/' exp
  42          |   %name UMINUS
  43              '-' exp %prec NEG
  44          |  '(' exp ')'  { $_[2] }
  45  ;
</pre>
<p class="Pp">Inside a semantic action the name of the current rule can be
    recovered using the method <span class="Li">&quot;YYName&quot;</span> of the
    parser object.</p>
<p class="Pp">The default action (lines 8-12) computes as attribute of the left
    hand side a reference to an object blessed in the name of the rule. The
    object has an attribute <span class="Li">&quot;children&quot;</span> which
    is a reference to the list of children of the node. The call to
    <span class="Li">&quot;grep&quot;</span></p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  11    bless { children =&gt; [ grep {ref($_)} @_] }, $name;
</pre>
<p class="Pp">excludes children that aren't references. Notice that the lexical
    analyzer only returns references for the
    <span class="Li">&quot;NUM&quot;</span> and
    <span class="Li">&quot;VAR&quot;</span> terminals:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  59  sub _Lexer {
  60      my($parser)=shift;
  61
  62      for ($parser-&gt;YYData-&gt;{INPUT}) {
  63          s/^[ \t]+//;
  64          return('',undef) unless $_;
  65          s/^([0-9]+(?:\.[0-9]+)?)//
  66                  and return('NUM', bless { attr =&gt; $1}, 'NUM');
  67          s/^([A-Za-z][A-Za-z0-9_]*)//
  68                  and return('VAR',bless {attr =&gt; $1}, 'VAR');
  69          s/^(.)//s
  70                  and return($1, $1);
  71      }
  72      return('',undef);
  73  }
</pre>
<p class="Pp">follows the client program:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  pl@nereida:~/LEyapp/examples$ cat -n uselhs.pl
       1  #!/usr/bin/perl -w
       2  use Lhs;
       3  use Data::Dumper;
       4
       5  $parser = new Lhs();
       6  my $tree = $parser-&gt;Run;
       7  $Data::Dumper::Indent = 1;
       8  if (defined($tree)) { print Dumper($tree); }
       9  else { print &quot;Cadena no valida\n&quot;; }
</pre>
<p class="Pp">When executed with input
    <span class="Li">&quot;a=(2+3)*b&quot;</span> the parser produces the
    following tree:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  ASSIGN(TIMES(PLUS(NUM[2],NUM[3]), VAR[b]))
</pre>
<p class="Pp">See the result of an execution:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  pl@nereida:~/LEyapp/examples$ uselhs.pl
  a=(2+3)*b
  $VAR1 = [
    bless( {
      'children' =&gt; [
        bless( { 'attr' =&gt; 'a' }, 'VAR' ),
        bless( {
          'children' =&gt; [
            bless( {
              'children' =&gt; [
                bless( { 'attr' =&gt; '2' }, 'NUM' ),
                bless( { 'attr' =&gt; '3' }, 'NUM' )
              ]
            }, 'PLUS' ),
            bless( { 'attr' =&gt; 'b' }, 'VAR' )
          ]
        }, 'TIMES' )
      ]
    }, 'ASSIGN' )
  ];
</pre>
<p class="Pp">The name of a production rule can be changed at execution time.
    See the following example:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  29  exp:
  30              NUM   { $_[1] }
  31          |   VAR   { $_[1] }
  32          |   %name ASSIGN
  33              VAR '=' exp
  34          |   %name PLUS
  35              exp '+' exp
  36          |   %name MINUS
  37              exp '-' exp
  38                {
  39                  my $self = shift;
  40                  $self-&gt;YYName('SUBTRACT'); # rename it
  41                  $self-&gt;YYBuildAST(@_); # build the node
  42                }
  43          |   %name TIMES
  44              exp '*' exp
  45          |   %name DIV
  46              exp '/' exp
  47          |   %name UMINUS
  48              '-' exp %prec NEG
  49          |  '(' exp ')'  { $_[2] }
  50  ;
</pre>
<p class="Pp">When the client program is executed we can see the presence of the
    <span class="Li">&quot;SUBTRACT&quot;</span> nodes:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  pl@nereida:~/LEyapp/examples$ useyynamedynamic.pl
  2-b
  $VAR1 = [
    bless( {
      'children' =&gt; [
        bless( {
          'attr' =&gt; '2'
        }, 'NUM' ),
        bless( {
          'attr' =&gt; 'b'
        }, 'VAR' )
      ]
    }, 'SUBTRACT' )
  ];
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="Grammar_Reuse"><a class="permalink" href="#Grammar_Reuse">Grammar
  Reuse</a></h1>
Terence Parr in his talk &quot;Reuse of Grammars with Embedded Semantic
  Actions&quot; (see &lt;http://www.cs.vu.nl/icpc2008/docs/Parr.pdf&gt;)
  explains the problem:
<p class="Pp"><span class="Li"></span></p>
<pre>
 &quot;Because many applications deal with the same language, the reuse of a common
syntax specification with different semantics provides a number of advantages.
While the advantages are obvious, the mechanism for grammar reuse is not so
clear.  To go beyond syntax checking, grammars must have some way to specify
the translation or interpretation logic (the semantics). Unfortunately, the act
of specifying the semantics can lock a grammar into one specific application
since the grammar is often modified to suit (e.g., programmers often want to
embed unrestricted semantic actions).&quot;
</pre>
<p class="Pp">The incoming sections deal with different solutions to the
    problem.</p>
<section class="Ss">
<h2 class="Ss" id="An_Action_Method_for_each_Production"><a class="permalink" href="#An_Action_Method_for_each_Production">An
  Action Method for each Production</a></h2>
Default actions provide a way to write reusable grammars. Here is one solution:
<p class="Pp"><span class="Li"></span></p>
<pre>
  pl@europa:~/LEyapp/examples/recycle$ cat -n Noactions.eyp
     1  %left   '+'
     2  %left   '*'
     3
     4  %defaultaction {
     5    my $self = shift;
     6
     7    my $class = $self-&gt;YYPrefix;
     8    $class .=  $self-&gt;YYName;
     9
    10    $class-&gt;action(@_);
    11  }
    12
    13  %%
    14  exp:        %name NUM
    15                NUM
    16          |   %name PLUS
    17                exp '+' exp
    18          |   %name TIMES
    19                exp '*' exp
    20          |   '(' exp ')'
    21                { $_[2] }
    22  ;
    23
    24  %%
    25
    26  sub _Error {
    27    my($token)=$_[0]-&gt;YYCurval;
    28    my($what)= $token ? &quot;input: '$token'&quot; : &quot;end of input&quot;;
    29    my @expected = $_[0]-&gt;YYExpect();
    30
    31    local $&quot; = ', ';
    32    die &quot;Syntax error near $what. Expected one of these tokens: @expected\n&quot;;
    33  }
    34
    35
    36  my $x = '';
    37
    38  sub _Lexer {
    39    my($parser)=shift;
    40
    41    for ($x) {
    42      s/^\s+//;
    43      $_ eq '' and return('',undef);
    44
    45      s/^([0-9]+(?:\.[0-9]+)?)//   and return('NUM',$1);
    46      s/^([A-Za-z][A-Za-z0-9_]*)// and return('VAR',$1);
    47      s/^(.)//s                    and return($1,$1);
    48    }
    49  }
    50
    51  sub Run {
    52    my($self)=shift;
    53    $x = shift;
    54    my $debug = shift;
    55
    56    $self-&gt;YYParse(
    57      yylex    =&gt; \&amp;_Lexer,
    58      yyerror  =&gt; \&amp;_Error,
    59      yydebug  =&gt; $debug,
    60    );
    61  }
</pre>
<p class="Pp">This grammar is reused by the following program to implement a
    calculator: and a translator from infix to postfix:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  pl@europa:~/LEyapp/examples/recycle$ cat -n calcu_and_post.pl
     1  #!/usr/bin/perl
     2  use warnings;
     3  use Noactions;
     4
     5  sub Calc::NUM::action {
     6    return $_[1];
     7  }
     8
     9  sub Calc::PLUS::action {
    10    $_[1]+$_[3];
    11  }
    12
    13  sub Calc::TIMES::action {
    14    $_[1]*$_[3];
    15  }
    16
    17  sub Post::NUM::action {
    18    return $_[1];
    19  }
    20
    21  sub Post::PLUS::action {
    22    &quot;$_[1] $_[3] +&quot;;
    23  }
    24
    25  sub Post::TIMES::action {
    26    &quot;$_[1] $_[3] *&quot;;
    27  }
    28
    29  my $debug = shift || 0;
    30  my $pparser = Noactions-&gt;new( yyprefix =&gt; 'Post::');
    31  print &quot;Write an expression: &quot;;
    32  my $x = &lt;STDIN&gt;;
    33  my $t = $pparser-&gt;Run($x, $debug);
    34
    35  print &quot;$t\n&quot;;
    36
    37  my $cparser = Noactions-&gt;new(yyprefix =&gt; 'Calc::');
    38  my $e = $cparser-&gt;Run($x, $debug);
    39
    40  print &quot;$e\n&quot;;
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Reusing_Grammars_Using_Inheritance"><a class="permalink" href="#Reusing_Grammars_Using_Inheritance">Reusing
  Grammars Using Inheritance</a></h2>
An method to reuse a grammar is via inheritance. The client inherits the
  generated parser module and expands it with methods that inherit or overwrite
  the actions. Here is an example. Initially we have this Eyapp grammar:
<p class="Pp"><span class="Li"></span></p>
<pre>
  pl@europa:~/LEyapp/examples/recycle$ cat -n NoacInh.eyp
     1  %left   '+'
     2  %left   '*'
     3
     4  %defaultaction {
     5    my $self = shift;
     6
     7    my $action = $self-&gt;YYName;
     8
     9    $self-&gt;$action(@_);
    10  }
    11
    12  %%
    13  exp:        %name NUM
    14                NUM
    15          |   %name PLUS
    16                exp '+' exp
    17          |   %name TIMES
    18                exp '*' exp
    19          |   '(' exp ')'
    20                { $_[2] }
    21  ;
    22
    23  %%
    24
    25  sub _Error {
    26    my($token)=$_[0]-&gt;YYCurval;
    27    my($what)= $token ? &quot;input: '$token'&quot; : &quot;end of input&quot;;
    28    my @expected = $_[0]-&gt;YYExpect();
    29
    30    local $&quot; = ', ';
    31    die &quot;Syntax error near $what. Expected one of these tokens: @expected\n&quot;;
    32  }
    33
    34
    35  my $x = '';
    36
    37  sub _Lexer {
    38    my($parser)=shift;
    39
    40    for ($x) {
    41      s/^\s+//;
    42      $_ eq '' and return('',undef);
    43
    44      s/^([0-9]+(?:\.[0-9]+)?)//   and return('NUM',$1);
    45      s/^([A-Za-z][A-Za-z0-9_]*)// and return('VAR',$1);
    46      s/^(.)//s                    and return($1,$1);
    47    }
    48  }
    49
    50  sub Run {
    51    my($self)=shift;
    52    $x = shift;
    53    my $debug = shift;
    54
    55    $self-&gt;YYParse(
    56      yylex =&gt; \&amp;_Lexer,
    57      yyerror =&gt; \&amp;_Error,
    58      yydebug =&gt; $debug,
    59    );
    60  }
</pre>
<p class="Pp">The following program defines two classes:
    <span class="Li">&quot;CalcActions&quot;</span> that implements the actions
    for the calculator and package
    <span class="Li">&quot;PostActions&quot;</span> that implements the actions
    for the infix to postfix translation. This way we have an example that
    reuses the former grammar twice:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  pl@europa:~/LEyapp/examples/recycle$ cat -n icalcu_and_ipost.pl
     1  #!/usr/bin/perl -w
     2  package CalcActions;
     3  use strict;
     4  use base qw{NoacInh};
     5
     6  sub NUM {
     7    return $_[1];
     8  }
     9
    10  sub PLUS {
    11    $_[1]+$_[3];
    12  }
    13
    14  sub TIMES {
    15    $_[1]*$_[3];
    16  }
    17
    18  package PostActions;
    19  use strict;
    20  use base qw{NoacInh};
    21
    22  sub NUM {
    23    return $_[1];
    24  }
    25
    26  sub PLUS {
    27    &quot;$_[1] $_[3] +&quot;;
    28  }
    29
    30  sub TIMES {
    31    &quot;$_[1] $_[3] *&quot;;
    32  }
    33
    34  package main;
    35  use strict;
    36
    37  my $calcparser = CalcActions-&gt;new();
    38  print &quot;Write an expression: &quot;;
    39  my $x = &lt;STDIN&gt;;
    40  my $e = $calcparser-&gt;Run($x);
    41
    42  print &quot;$e\n&quot;;
    43
    44  my $postparser = PostActions-&gt;new();
    45  my $p = $postparser-&gt;Run($x);
    46
    47  print &quot;$p\n&quot;;
</pre>
<p class="Pp">The subroutine used as default action in
    <span class="Li">&quot;NoacInh.eyp&quot;</span> is so useful that is packed
    as the Parse::Eyapp::Driver method
    <span class="Li">&quot;YYDelegateaction&quot;</span>.</p>
<p class="Pp">See files
    <span class="Li">&quot;examples/recycle/NoacYYDelegateaction.eyp&quot;</span>
    and
    <span class="Li">&quot;examples/recycle/icalcu_and_ipost_yydel.pl&quot;</span>
    for an example of use of
    <span class="Li">&quot;YYDelegateaction&quot;</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Reusing_Grammars_by_Dynamic_Substitution_of_Semantic_Actions"><a class="permalink" href="#Reusing_Grammars_by_Dynamic_Substitution_of_Semantic_Actions">Reusing
  Grammars by Dynamic Substitution of Semantic Actions</a></h2>
The methods <span class="Li">&quot;YYSetaction&quot;</span> and
  <span class="Li">&quot;YYAction&quot;</span> of the parser object provide a
  way to selectively substitute some actions of a given grammar. Let us consider
  once more a postfix to infix translator:
<p class="Pp"><span class="Li"></span></p>
<pre>
  pl@europa:~/LEyapp/examples/recycle$ cat -n PostfixWithActions.eyp
     1  # File PostfixWithActions.eyp
     2  %right  '='
     3  %left   '-' '+'
     4  %left   '*' '/'
     5  %left   NEG
     6
     7  %%
     8  line: $exp  { print &quot;$exp\n&quot; }
     9  ;
    10
    11  exp:        $NUM
    12                  { $NUM }
    13          |   $VAR
    14                  { $VAR }
    15          |   %name ASSIGN
    16                VAR.left '='exp.right
    17                  { &quot;$_[3] &amp;$_[1] ASSIGN&quot;; }
    18          |   %name PLUS
    19                exp.left '+'exp.right
    20                  { &quot;$_[1] $_[3] PLUS&quot;; }
    21          |   %name MINUS
    22                exp.left '-'exp.right
    23                  { &quot;$_[1] $_[3] MINUS&quot;; }
    24          |   %name TIMES
    25                exp.left '*'exp.right
    26                  { &quot;$_[1] $_[3] TIMES&quot;; }
    27          |   %name DIV
    28                exp.left '/'exp.right
    29                  { &quot;$_[1] $_[3] DIV&quot;; }
    30          |   %name NEG '-' $exp %prec NEG
    31                  { &quot;$exp NEG&quot; }
    32          |   '(' $exp ')'
    33                  { $exp }
    34  ;
    35
    36  %%
    37
    38  sub _Error {
    39    my($token)=$_[0]-&gt;YYCurval;
    40    my($what)= $token ? &quot;input: '$token'&quot; : &quot;end of input&quot;;
    41    my @expected = $_[0]-&gt;YYExpect();
    42
    43    local $&quot; = ', ';
    44    die &quot;Syntax error near $what. Expected one of these tokens: @expected\n&quot;;
    45  }
    46
    47  my $x;
    48
    49  sub _Lexer {
    50    my($parser)=shift;
    51
    52    for ($x) {
    53      s/^\s+//;
    54      $_ eq '' and return('',undef);
    55
    56      s/^([0-9]+(?:\.[0-9]+)?)//   and return('NUM',$1);
    57      s/^([A-Za-z][A-Za-z0-9_]*)// and return('VAR',$1);
    58      s/^(.)//s                    and return($1,$1);
    59    }
    60  }
    61
    62  sub Run {
    63    my($self)=shift;
    64    $x = shift;
    65    $self-&gt;YYParse( yylex =&gt; \&amp;_Lexer, yyerror =&gt; \&amp;_Error,
    66      #yydebug =&gt; 0xFF
    67    );
    68  }
</pre>
<p class="Pp">The program
    <span class="Li">&quot;rewritepostfixwithactions.pl&quot;</span> uses the
    former grammar to translate infix expressions to postfix expressions. It
    also implements a calculator reusing the grammar in
    <span class="Li">&quot;PostfixWithActions.eyp&quot;</span>. It does so using
    the <span class="Li">&quot;YYSetaction&quot;</span> method. The semantic
    actions for the productions named</p>
<ul class="Bl-bullet">
  <li>ASSIGN</li>
  <li>PLUS</li>
  <li>TIMES</li>
  <li>DIV</li>
  <li>NEG</li>
</ul>
<p class="Pp">are selectively substituted by the appropriate actions, while the
    other semantic actions remain unchanged:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  pl@europa:~/LEyapp/examples/recycle$ cat -n rewritepostfixwithactions.pl
     1  #!/usr/bin/perl
     2  use warnings;
     3  use PostfixWithActions;
     4
     5  my $debug = shift || 0;
     6  my $pparser = PostfixWithActions-&gt;new();
     7  print &quot;Write an expression: &quot;;
     8  my $x = &lt;STDIN&gt;;
     9
    10  # First, trasnlate to postfix ...
    11  $pparser-&gt;Run($x, $debug);
    12
    13  # And then selectively substitute
    14  # some semantic actions
    15  # to obtain an infix calculator ...
    16  my %s;            # symbol table
    17  $pparser-&gt;YYSetaction(
    18    ASSIGN =&gt; sub { $s{$_[1]} = $_[3] },
    19    PLUS   =&gt; sub { $_[1] + $_[3] },
    20    TIMES  =&gt; sub { $_[1] * $_[3] },
    21    DIV    =&gt; sub { $_[1] / $_[3] },
    22    NEG    =&gt; sub { -$_[2] },
    23  );
    24
    25  $pparser-&gt;Run($x, $debug);
</pre>
<p class="Pp">When running this program the output is:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  examples/recycle$ ./rewritepostfixwithactions.pl
  Write an expression: 2*3+4
  2 3 TIMES 4 PLUS
  10
  examples/recycle$ rewritepostfixwithactions.pl
  Write an expression: a = 2*(b = 3+5)
  2 3 5 PLUS &amp;b ASSIGN TIMES &amp;a ASSIGN
  16
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<ul class="Bl-bullet">
  <li>The project home is at &lt;http://code.google.com/p/parse-eyapp/&gt;. Use
      a subversion client to anonymously check out the latest project source
      code:
    <p class="Pp"><span class="Li"></span></p>
    <pre>
   svn checkout http://parse-eyapp.googlecode.com/svn/trunk/ parse-eyapp-read-only
    </pre>
  </li>
  <li>The tutorial <i>Parsing Strings and Trees with</i>
      <span class="Li">&quot;Parse::Eyapp&quot;</span> (An Introduction to
      Compiler Construction in seven pages) in
      &lt;http://nereida.deioc.ull.es/~pl/eyapsimple/&gt;</li>
  <li>Parse::Eyapp, Parse::Eyapp::eyapplanguageref, Parse::Eyapp::debuggingtut,
      Parse::Eyapp::defaultactionsintro, Parse::Eyapp::translationschemestut,
      Parse::Eyapp::Driver, Parse::Eyapp::Node, Parse::Eyapp::YATW,
      Parse::Eyapp::Treeregexp, Parse::Eyapp::Scope, Parse::Eyapp::Base,
      Parse::Eyapp::datagenerationtut</li>
  <li>The pdf file in
      &lt;http://nereida.deioc.ull.es/~pl/perlexamples/languageintro.pdf&gt;</li>
  <li>The pdf file in
      &lt;http://nereida.deioc.ull.es/~pl/perlexamples/debuggingtut.pdf&gt;</li>
  <li>The pdf file in
      &lt;http://nereida.deioc.ull.es/~pl/perlexamples/eyapplanguageref.pdf&gt;</li>
  <li>The pdf file in
      &lt;http://nereida.deioc.ull.es/~pl/perlexamples/Treeregexp.pdf&gt;</li>
  <li>The pdf file in
      &lt;http://nereida.deioc.ull.es/~pl/perlexamples/Node.pdf&gt;</li>
  <li>The pdf file in
      &lt;http://nereida.deioc.ull.es/~pl/perlexamples/YATW.pdf&gt;</li>
  <li>The pdf file in
      &lt;http://nereida.deioc.ull.es/~pl/perlexamples/Eyapp.pdf&gt;</li>
  <li>The pdf file in
      &lt;http://nereida.deioc.ull.es/~pl/perlexamples/Base.pdf&gt;</li>
  <li>The pdf file in
      &lt;http://nereida.deioc.ull.es/~pl/perlexamples/translationschemestut.pdf&gt;</li>
  <li>The pdf file in
      &lt;http://nereida.deioc.ull.es/~pl/perlexamples/treematchingtut.pdf&gt;</li>
  <li>perldoc eyapp,</li>
  <li>perldoc treereg,</li>
  <li>perldoc vgg,</li>
  <li>The Syntax Highlight file for vim at
      &lt;http://www.vim.org/scripts/script.php?script_id=2453&gt; and
      &lt;http://nereida.deioc.ull.es/~vim/&gt;</li>
  <li><i>Analisis Lexico y Sintactico</i>, (Notes for a course in compiler
      construction) by Casiano Rodriguez-Leon. Available at
      &lt;http://nereida.deioc.ull.es/~pl/perlexamples/&gt; Is the more complete
      and reliable source for Parse::Eyapp. However is in Spanish.</li>
  <li>Parse::Yapp,</li>
  <li>Man pages of <i>yacc</i>(1) and <i>bison</i>(1),
      &lt;http://www.delorie.com/gnu/docs/bison/bison.html&gt;</li>
  <li>Language::AttributeGrammar</li>
  <li>Parse::RecDescent.</li>
  <li>HOP::Parser</li>
  <li>HOP::Lexer</li>
  <li>ocamlyacc tutorial at
      &lt;http://plus.kaist.ac.kr/~shoh/ocaml/ocamllex-ocamlyacc/ocamlyacc-tutorial/ocamlyacc-tutorial.html&gt;</li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="REFERENCES"><a class="permalink" href="#REFERENCES">REFERENCES</a></h1>
<ul class="Bl-bullet">
  <li>The classic Dragon's book <i>Compilers: Principles, Techniques, and
      Tools</i> by Alfred V. Aho, Ravi Sethi and Jeffrey D. Ullman
      (Addison-Wesley 1986)</li>
  <li><i>CS2121: The Implementation and Power of Programming Languages</i> (See
      &lt;http://www.cs.man.ac.uk/~pjj&gt;,
      &lt;http://www.cs.man.ac.uk/~pjj/complang/g2lr.html&gt; and
      &lt;http://www.cs.man.ac.uk/~pjj/cs2121/ho/ho.html&gt;) by Pete Jinks</li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="CONTRIBUTORS"><a class="permalink" href="#CONTRIBUTORS">CONTRIBUTORS</a></h1>
<ul class="Bl-bullet">
  <li>Hal Finkel &lt;http://www.halssoftware.com/&gt;</li>
  <li>G. Williams &lt;http://kasei.us/&gt;</li>
  <li>Thomas L. Shinnick &lt;http://search.cpan.org/~tshinnic/&gt;</li>
  <li>Frank Leray</li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
Casiano Rodriguez-Leon (casiano@ull.es)
</section>
<section class="Sh">
<h1 class="Sh" id="ACKNOWLEDGMENTS"><a class="permalink" href="#ACKNOWLEDGMENTS">ACKNOWLEDGMENTS</a></h1>
This work has been supported by CEE (FEDER) and the Spanish Ministry of
  <i>Educacion y Ciencia</i> through <i>Plan Nacional I+D+I</i> number
  TIN2005-08818-C04-04 (ULL::OPLINK project &lt;http://www.oplink.ull.es/&gt;).
  Support from Gobierno de Canarias was through GC02210601 (<i>Grupos
  Consolidados</i>). The University of La Laguna has also supported my work in
  many ways and for many years.
<p class="Pp">A large percentage of code is verbatim taken from Parse::Yapp
    1.05. The author of Parse::Yapp is Francois Desarmenien.</p>
<p class="Pp">I wish to thank Francois Desarmenien for his Parse::Yapp module,
    to my students at La Laguna and to the Perl Community. Thanks to the people
    who have contributed to improve the module (see &quot;CONTRIBUTORS&quot; in
    Parse::Eyapp). Thanks to Larry Wall for giving us Perl. Special thanks to
    Juana.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="LICENCE_AND_COPYRIGHT"><a class="permalink" href="#LICENCE_AND_COPYRIGHT">LICENCE
  AND COPYRIGHT</a></h1>
Copyright (c) 2006-2008 Casiano Rodriguez-Leon (casiano@ull.es). All rights
  reserved.
<p class="Pp">Parse::Yapp copyright is of Francois Desarmenien, all rights
    reserved. 1998-2001</p>
<p class="Pp">These modules are free software; you can redistribute it and/or
    modify it under the same terms as Perl itself. See perlartistic.</p>
<p class="Pp">This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. </p>
</section>
<section class="Sh">
<h1 class="Sh" id="POD_ERRORS"><a class="permalink" href="#POD_ERRORS">POD
  ERRORS</a></h1>
Hey! <b>The above document had some coding errors, which are explained
  below:</b>
<dl class="Bl-tag">
  <dt>Around line 232:</dt>
  <dd>Non-ASCII character seen before =encoding in 'valida\n&quot;;'. Assuming
      UTF-8</dd>
</dl>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2012-03-23</td>
    <td class="foot-os">perl v5.18.4</td>
  </tr>
</table>
</body>
</html>
