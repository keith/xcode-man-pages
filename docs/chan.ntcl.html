<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Copyright (c) 2005-2006 Donal K. Fellows
  
   See the file "license.terms" for information on usage and redistribution
   of this file, and for a DISCLAIMER OF ALL WARRANTIES.
  
   RCS: @(#) $Id: chan.n,v 1.17 2007/12/13 15:22:32 dgp Exp $
   The -*- nroff -*- definitions below are for supplemental macros used
   in Tcl/Tk manual entries.
  
   .AP type name in/out ?indent?
  	Start paragraph describing an argument to a library procedure.
  	type is type of argument (int, etc.), in/out is either "in", "out",
  	or "in/out" to describe whether procedure reads or modifies arg,
  	and indent is equivalent to second arg of .IP (shouldn't ever be
  	needed;  use .AS below instead)
  
   .AS ?type? ?name?
  	Give maximum sizes of arguments for setting tab stops.  Type and
  	name are examples of largest possible arguments that will be passed
  	to .AP later.  If args are omitted, default tab stops are used.
  
   .BS
  	Start box enclosure.  From here until next .BE, everything will be
  	enclosed in one large box.
  
   .BE
  	End of box enclosure.
  
   .CS
  	Begin code excerpt.
  
   .CE
  	End code excerpt.
  
   .VS ?version? ?br?
  	Begin vertical sidebar, for use in marking newly-changed parts
  	of man pages.  The first argument is ignored and used for recording
  	the version when the .VS was added, so that the sidebars can be
  	found and removed when they reach a certain age.  If another argument
  	is present, then a line break is forced before starting the sidebar.
  
   .VE
  	End of vertical sidebar.
  
   .DS
  	Begin an indented unfilled display.
  
   .DE
  	End of indented unfilled display.
  
   .SO ?manpage?
  	Start of list of standard options for a Tk widget. The manpage
  	argument defines where to look up the standard options; if
  	omitted, defaults to "options". The options follow on successive
  	lines, in three columns separated by tabs.
  
   .SE
  	End of list of standard options for a Tk widget.
  
   .OP cmdName dbName dbClass
  	Start of description of a specific option.  cmdName gives the
  	option's name as specified in the class command, dbName gives
  	the option's name in the option database, and dbClass gives
  	the option's class in the option database.
  
   .UL arg1 arg2
  	Print arg1 underlined, then print arg2 normally.
  
   .QW arg1 ?arg2?
  	Print arg1 in quotes, then arg2 normally (for trailing punctuation).
  
   .PQ arg1 ?arg2?
  	Print an open parenthesis, arg1 in quotes, then arg2 normally
  	(for trailing punctuation) and then a closing parenthesis.
  
   RCS: @(#) $Id: man.macros,v 1.9 2008/01/29 15:32:33 dkf Exp $
  
  	# Set up traps and other miscellaneous stuff for Tcl/Tk man pages.
  	# Start an argument description
  .b
  	# define tabbing values for .AP
  
  	# BS - start boxed text
  	# ^y = starting y location
  	# ^b = 1
  	# BE - end boxed text (draw box now)
  	Draw four-sided box normally, but don't draw top of
  	box if the box started on an earlier page.
  	# VS - start vertical sidebar
  	# ^Y = starting y location
  	# ^v = 1 (for troff;  for nroff this doesn't matter)
  	# VE - end of vertical sidebar
  	# Special macro to handle page bottom:  finish off current
  	# box/sidebar if in box/sidebar mode, then invoked standard
  	# page bottom macro.
  	Draw three-sided box if this is the box's first page,
  	draw two sides but no top otherwise.
  	# DS - begin display
  	# DE - end display
  	# SO - start of list of standard options
  	# SE - end of list of standard options
  	# OP - start of full description for a single option
  	# CS - begin code excerpt
  	# CE - end code excerpt
  	# UL - underline word
  	# QW - apply quotation marks to word
  " fix emacs highlighting
  	# PQ - apply parens and quotation marks to word
  " fix emacs highlighting
  	# QR - quoted range
  " fix emacs highlighting
  	# MT - "empty" string
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>chan(n)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">chan(n)</td>
    <td class="head-vol">Tcl Built-In Commands</td>
    <td class="head-rtitle">chan(n)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<pre>

</pre>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
chan - Read, write and manipulate channels
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<b>chan </b><i>option</i> ?<i>arg arg ...</i>?
<pre>

</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
This command provides several operations for reading from, writing to and
  otherwise manipulating open channels (such as have been created with the
  <b>open</b> and <b>socket</b> commands, or the default named channels
  <b>stdin</b>, <b>stdout</b> or <b>stderr</b> which correspond to the process's
  standard input, output and error streams respectively). <i>Option</i>
  indicates what to do with the channel; any unique abbreviation for
  <i>option</i> is acceptable. Valid options are:
<dl class="Bl-tag">
  <dt><b>chan blocked </b><i>channelId</i></dt>
  <dd>This tests whether the last input operation on the channel called
      <i>channelId</i> failed because it would have otherwise caused the process
      to block, and returns 1 if that was the case. It returns 0 otherwise. Note
      that this only ever returns 1 when the channel has been configured to be
      non-blocking; all Tcl channels have blocking turned on by default.</dd>
  <dt><b>chan close </b><i>channelId</i></dt>
  <dd>Close and destroy the channel called <i>channelId</i>. Note that this
      deletes all existing file-events registered on the channel.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp">As part of closing the channel, all buffered output is flushed to
    the channel's output device, any buffered input is discarded, the underlying
    operating system resource is closed and <i>channelId</i> becomes unavailable
    for future use.</p>
<p class="Pp">If the channel is blocking, the command does not return until all
    output is flushed. If the channel is nonblocking and there is unflushed
    output, the channel remains open and the command returns immediately; output
    will be flushed in the background and the channel will be closed when all
    the flushing is complete.</p>
<p class="Pp">If <i>channelId</i> is a blocking channel for a command pipeline
    then <b>chan close</b> waits for the child processes to complete.</p>
<p class="Pp">If the channel is shared between interpreters, then <b>chan
    close</b> makes <i>channelId</i> unavailable in the invoking interpreter but
    has no other effect until all of the sharing interpreters have closed the
    channel. When the last interpreter in which the channel is registered
    invokes <b>chan close</b> (or <b>close</b>), the cleanup actions described
    above occur. See the <b>interp</b> command for a description of channel
    sharing.</p>
<p class="Pp">Channels are automatically closed when an interpreter is destroyed
    and when the process exits. Channels are switched to blocking mode, to
    ensure that all output is correctly flushed before the process exits.</p>
<p class="Pp">The command returns an empty string, and may generate an error if
    an error occurs while flushing output. If a command in a command pipeline
    created with <b>open</b> returns an error, <b>chan close</b> generates an
    error (similar to the <b>exec</b> command.)</p>
</div>
<dl class="Bl-tag">
  <dt><b>chan configure </b><i>channelId</i> ?<i>optionName</i>? ?<i>value</i>?
    ?<i>optionName value</i>?...</dt>
  <dd>Query or set the configuration options of the channel named
      <i>channelId</i>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp">If no <i>optionName</i> or <i>value</i> arguments are supplied,
    the command returns a list containing alternating option names and values
    for the channel. If <i>optionName</i> is supplied but no <i>value</i> then
    the command returns the current value of the given option. If one or more
    pairs of <i>optionName</i> and <i>value</i> are supplied, the command sets
    each of the named options to the corresponding <i>value</i>; in this case
    the return value is an empty string.</p>
<p class="Pp">The options described below are supported for all channels. In
    addition, each channel type may add options that only it supports. See the
    manual entry for the command that creates each type of channels for the
    options that that specific type of channel supports. For example, see the
    manual entry for the <b>socket</b> command for its additional options.</p>
<dl class="Bl-tag">
  <dt><b>-blocking</b> <i>boolean</i></dt>
  <dd>The <b>-blocking</b> option determines whether I/O operations on the
      channel can cause the process to block indefinitely. The value of the
      option must be a proper boolean value. Channels are normally in blocking
      mode; if a channel is placed into nonblocking mode it will affect the
      operation of the <b>chan gets</b>, <b>chan read</b>, <b>chan</b>
      <b>puts</b>, <b>chan flush</b>, and <b>chan close</b> commands; see the
      documentation for those commands for details. For nonblocking mode to work
      correctly, the application must be using the Tcl event loop (e.g. by
      calling <b>Tcl_DoOneEvent</b> or invoking the <b>vwait</b> command).</dd>
  <dt><b>-buffering</b> <i>newValue</i></dt>
  <dd>If <i>newValue</i> is <b>full</b> then the I/O system will buffer output
      until its internal buffer is full or until the <b>chan flush</b> command
      is invoked. If <i>newValue</i> is <b>line</b>, then the I/O system will
      automatically flush output for the channel whenever a newline character is
      output. If <i>newValue</i> is <b>none</b>, the I/O system will flush
      automatically after every output operation. The default is for
      <b>-buffering</b> to be set to <b>full</b> except for channels that
      connect to terminal-like devices; for these channels the initial setting
      is <b>line</b>. Additionally, <b>stdin</b> and <b>stdout</b> are initially
      set to <b>line</b>, and <b>stderr</b> is set to <b>none</b>.</dd>
  <dt><b>-buffersize</b> <i>newSize</i></dt>
  <dd><i>Newvalue</i> must be an integer; its value is used to set the size of
      buffers, in bytes, subsequently allocated for this channel to store input
      or output. <i>Newvalue</i> must be a number of no more than one million,
      allowing buffers of up to one million bytes in size.</dd>
  <dt><b>-encoding</b> <i>name</i></dt>
  <dd>This option is used to specify the encoding of the channel as one of the
      named encodings returned by <b>encoding names</b> or the special value
      <b>binary</b>, so that the data can be converted to and from Unicode for
      use in Tcl. For instance, in order for Tcl to read characters from a
      Japanese file in <b>shiftjis</b> and properly process and display the
      contents, the encoding would be set to <b>shiftjis</b>. Thereafter, when
      reading from the channel, the bytes in the Japanese file would be
      converted to Unicode as they are read. Writing is also supported - as Tcl
      strings are written to the channel they will automatically be converted to
      the specified encoding on output.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp">If a file contains pure binary data (for instance, a JPEG image),
    the encoding for the channel should be configured to be <b>binary</b>. Tcl
    will then assign no interpretation to the data in the file and simply read
    or write raw bytes. The Tcl <b>binary</b> command can be used to manipulate
    this byte-oriented data. It is usually better to set the <b>-translation</b>
    option to <b>binary</b> when you want to transfer binary data, as this turns
    off the other automatic interpretations of the bytes in the stream as
  well.</p>
<p class="Pp">The default encoding for newly opened channels is the same
    platform- and locale-dependent system encoding used for interfacing with the
    operating system, as returned by <b>encoding system</b>.</p>
</div>
<dl class="Bl-tag">
  <dt><b>-eofchar</b> <i>char</i></dt>
  <dd></dd>
  <dt><b>-eofchar</b> <b>{</b><i>inChar outChar</i><b>}</b></dt>
  <dd>This option supports DOS file systems that use Control-z (\x1a) as an end
      of file marker. If <i>char</i> is not an empty string, then this character
      signals end-of-file when it is encountered during input. For output, the
      end-of-file character is output when the channel is closed. If <i>char</i>
      is the empty string, then there is no special end of file character
      marker. For read-write channels, a two-element list specifies the end of
      file marker for input and output, respectively. As a convenience, when
      setting the end-of-file character for a read-write channel you can specify
      a single value that will apply to both reading and writing. When querying
      the end-of-file character of a read-write channel, a two-element list will
      always be returned. The default value for <b>-eofchar</b> is the empty
      string in all cases except for files under Windows. In that case the
      <b>-eofchar</b> is Control-z (\x1a) for reading and the empty string for
      writing. The acceptable range for <b>-eofchar</b> values is \x01 - \x7f;
      attempting to set <b>-eofchar</b> to a value outside of this range will
      generate an error.</dd>
  <dt><b>-translation</b> <i>mode</i></dt>
  <dd></dd>
  <dt><b>-translation</b> <b>{</b><i>inMode outMode</i><b>}</b></dt>
  <dd>In Tcl scripts the end of a line is always represented using a single
      newline character (\n). However, in actual files and devices the end of a
      line may be represented differently on different platforms, or even for
      different devices on the same platform. For example, under UNIX newlines
      are used in files, whereas carriage-return-linefeed sequences are normally
      used in network connections. On input (i.e., with <b>chan gets</b> and
      <b>chan read</b>) the Tcl I/O system automatically translates the external
      end-of-line representation into newline characters. Upon output (i.e.,
      with <b>chan puts</b>), the I/O system translates newlines to the external
      end-of-line representation. The default translation mode, <b>auto</b>,
      handles all the common cases automatically, but the <b>-translation</b>
      option provides explicit control over the end of line translations.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp">The value associated with <b>-translation</b> is a single item for
    read-only and write-only channels. The value is a two-element list for
    read-write channels; the read translation mode is the first element of the
    list, and the write translation mode is the second element. As a
    convenience, when setting the translation mode for a read-write channel you
    can specify a single value that will apply to both reading and writing. When
    querying the translation mode of a read-write channel, a two-element list
    will always be returned. The following values are currently supported:</p>
<dl class="Bl-tag">
  <dt><b>auto</b></dt>
  <dd>As the input translation mode, <b>auto</b> treats any of newline
      (<b>lf</b>), carriage return (<b>cr</b>), or carriage return followed by a
      newline (<b>crlf</b>) as the end of line representation. The end of line
      representation can even change from line-to-line, and all cases are
      translated to a newline. As the output translation mode, <b>auto</b>
      chooses a platform specific representation; for sockets on all platforms
      Tcl chooses <b>crlf</b>, for all Unix flavors, it chooses <b>lf</b>, and
      for the various flavors of Windows it chooses <b>crlf</b>. The default
      setting for <b>-translation</b> is <b>auto</b> for both input and
    output.</dd>
  <dt><b>binary</b></dt>
  <dd>No end-of-line translations are performed. This is nearly identical to
      <b>lf</b> mode, except that in addition <b>binary</b> mode also sets the
      end-of-file character to the empty string (which disables it) and sets the
      encoding to <b>binary</b> (which disables encoding filtering). See the
      description of <b>-eofchar</b> and <b>-encoding</b> for more
    information.</dd>
  <dt><b>cr</b></dt>
  <dd>The end of a line in the underlying file or device is represented by a
      single carriage return character. As the input translation mode, <b>cr</b>
      mode converts carriage returns to newline characters. As the output
      translation mode, <b>cr</b> mode translates newline characters to carriage
      returns.</dd>
  <dt><b>crlf</b></dt>
  <dd>The end of a line in the underlying file or device is represented by a
      carriage return character followed by a linefeed character. As the input
      translation mode, <b>crlf</b> mode converts carriage-return-linefeed
      sequences to newline characters. As the output translation mode,
      <b>crlf</b> mode translates newline characters to carriage-return-linefeed
      sequences. This mode is typically used on Windows platforms and for
      network connections.</dd>
  <dt><b>lf</b></dt>
  <dd>The end of a line in the underlying file or device is represented by a
      single newline (linefeed) character. In this mode no translations occur
      during either input or output. This mode is typically used on UNIX
      platforms.</dd>
</dl>
</div>
</div>
<dl class="Bl-tag">
  <dt><b>chan copy </b><i>inputChan outputChan</i> ?<b>-size </b><i>size</i>?
    ?<b>-command </b><i>callback</i>?</dt>
  <dd>Copy data from the channel <i>inputChan</i>, which must have been opened
      for reading, to the channel <i>outputChan</i>, which must have been opened
      for writing. The <b>chan copy</b> command leverages the buffering in the
      Tcl I/O system to avoid extra copies and to avoid buffering too much data
      in main memory when copying large files to slow destinations like network
      sockets.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp">The <b>chan copy</b> command transfers data from <i>inputChan</i>
    until end of file or <i>size</i> bytes have been transferred. If no
    <b>-size</b> argument is given, then the copy goes until end of file. All
    the data read from <i>inputChan</i> is copied to <i>outputChan</i>. Without
    the <b>-command</b> option, <b>chan copy</b> blocks until the copy is
    complete and returns the number of bytes written to <i>outputChan</i>.</p>
<p class="Pp">The <b>-command</b> argument makes <b>chan copy</b> work in the
    background. In this case it returns immediately and the <i>callback</i> is
    invoked later when the copy completes. The <i>callback</i> is called with
    one or two additional arguments that indicates how many bytes were written
    to <i>outputChan</i>. If an error occurred during the background copy, the
    second argument is the error string associated with the error. With a
    background copy, it is not necessary to put <i>inputChan</i> or
    <i>outputChan</i> into non-blocking mode; the <b>chan copy</b> command takes
    care of that automatically. However, it is necessary to enter the event loop
    by using the <b>vwait</b> command or by using Tk.</p>
<p class="Pp">You are not allowed to do other I/O operations with
    <i>inputChan</i> or <i>outputChan</i> during a background <b>chan copy</b>.
    If either <i>inputChan</i> or <i>outputChan</i> get closed while the copy is
    in progress, the current copy is stopped and the command callback is
    <i>not</i> made. If <i>inputChan</i> is closed, then all data already queued
    for <i>outputChan</i> is written out.</p>
<p class="Pp">Note that <i>inputChan</i> can become readable during a background
    copy. You should turn off any <b>chan event</b> or <b>fileevent</b> handlers
    during a background copy so those handlers do not interfere with the copy.
    Any I/O attempted by a <b>chan event</b> or <b>fileevent</b> handler will
    get a &#x201C;channel busy&#x201D; error.</p>
<p class="Pp"><b>Chan copy</b> translates end-of-line sequences in
    <i>inputChan</i> and <i>outputChan</i> according to the <b>-translation</b>
    option for these channels (see <b>chan configure</b> above). The
    translations mean that the number of bytes read from <i>inputChan</i> can be
    different than the number of bytes written to <i>outputChan</i>. Only the
    number of bytes written to <i>outputChan</i> is reported, either as the
    return value of a synchronous <b>chan copy</b> or as the argument to the
    callback for an asynchronous <b>chan copy</b>.</p>
<p class="Pp"><b>Chan copy</b> obeys the encodings and character translations
    configured for the channels. This means that the incoming characters are
    converted internally first UTF-8 and then into the encoding of the channel
    <b>chan copy</b> writes to (see <b>chan configure</b> above for details on
    the <b>-encoding</b> and <b>-translation</b> options). No conversion is done
    if both channels are set to encoding <b>binary</b> and have matching
    translations. If only the output channel is set to encoding <b>binary</b>
    the system will write the internal UTF-8 representation of the incoming
    characters. If only the input channel is set to encoding <b>binary</b> the
    system will assume that the incoming bytes are valid UTF-8 characters and
    convert them according to the output encoding. The behaviour of the system
    for bytes which are not valid UTF-8 characters is undefined in this
  case.</p>
</div>
<dl class="Bl-tag">
  <dt><b>chan create </b><i>mode cmdPrefix</i></dt>
  <dd>This subcommand creates a new script level channel using the command
      prefix <i>cmdPrefix</i> as its handler. Any such channel is called a
      <b>reflected</b> channel. The specified command prefix, <b>cmdPrefix</b>,
      must be a non-empty list, and should provide the API described in the
      <b>reflectedchan</b> manual page. The handle of the new channel is
      returned as the result of the <b>chan create</b> command, and the channel
      is open. Use either <b>close</b> or <b>chan close</b> to remove the
      channel.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp">The argument <i>mode</i> specifies if the new channel is opened
    for reading, writing, or both. It has to be a list containing any of the
    strings &#x201C;<b>read</b>&#x201D; or &#x201C;<b>write</b>&#x201D;. The
    list must have at least one element, as a channel you can neither write to
    nor read from makes no sense. The handler command for the new channel must
    support the chosen mode, or an error is thrown.</p>
<p class="Pp">The command prefix is executed in the global namespace, at the top
    of call stack, following the appending of arguments as described in the
    <b>reflectedchan</b> manual page. Command resolution happens at the time of
    the call. Renaming the command, or destroying it means that the next call of
    a handler method may fail, causing the channel command invoking the handler
    to fail as well. Depending on the subcommand being invoked, the error
    message may not be able to explain the reason for that failure.</p>
<p class="Pp">Every channel created with this subcommand knows which interpreter
    it was created in, and only ever executes its handler command in that
    interpreter, even if the channel was shared with and/or was moved into a
    different interpreter. Each reflected channel also knows the thread it was
    created in, and executes its handler command only in that thread, even if
    the channel was moved into a different thread. To this end all invocations
    of the handler are forwarded to the original thread by posting special
    events to it. This means that the original thread (i.e. the thread that
    executed the <b>chan create</b> command) must have an active event loop,
    i.e. it must be able to process such events. Otherwise the thread sending
    them will <i>block</i> <i>indefinitely</i>. Deadlock may occur.</p>
<p class="Pp">Note that this permits the creation of a channel whose two
    endpoints live in two different threads, providing a stream-oriented bridge
    between these threads. In other words, we can provide a way for regular
    stream communication between threads instead of having to send commands.</p>
<p class="Pp">When a thread or interpreter is deleted, all channels created with
    this subcommand and using this thread/interpreter as their computing base
    are deleted as well, in all interpreters they have been shared with or moved
    into, and in whatever thread they have been transfered to. While this pulls
    the rug out under the other thread(s) and/or interpreter(s), this cannot be
    avoided. Trying to use such a channel will cause the generation of a regular
    error about unknown channel handles.</p>
<p class="Pp">This subcommand is <b>safe</b> and made accessible to safe
    interpreters. While it arranges for the execution of arbitrary Tcl code the
    system also makes sure that the code is always executed within the safe
    interpreter.</p>
</div>
<dl class="Bl-tag">
  <dt><b>chan eof </b><i>channelId</i></dt>
  <dd>Test whether the last input operation on the channel called
      <i>channelId</i> failed because the end of the data stream was reached,
      returning 1 if end-of-file was reached, and 0 otherwise.</dd>
  <dt><b>chan event </b><i>channelId event</i> ?<i>script</i>?</dt>
  <dd>Arrange for the Tcl script <i>script</i> to be installed as a <i>file</i>
      <i>event handler</i> to be called whenever the channel called
      <i>channelId</i> enters the state described by <i>event</i> (which must be
      either <b>readable</b> or <b>writable</b>); only one such handler may be
      installed per event per channel at a time. If <i>script</i> is the empty
      string, the current handler is deleted (this also happens if the channel
      is closed or the interpreter deleted). If <i>script</i> is omitted, the
      currently installed script is returned (or an empty string if no such
      handler is installed). The callback is only performed if the event loop is
      being serviced (e.g. via <b>vwait</b> or <b>update</b>).</dd>
</dl>
<div class="Bd-indent">
<p class="Pp">A file event handler is a binding between a channel and a script,
    such that the script is evaluated whenever the channel becomes readable or
    writable. File event handlers are most commonly used to allow data to be
    received from another process on an event-driven basis, so that the receiver
    can continue to interact with the user or with other channels while waiting
    for the data to arrive. If an application invokes <b>chan gets</b> or
    <b>chan read</b> on a blocking channel when there is no input data
    available, the process will block; until the input data arrives, it will not
    be able to service other events, so it will appear to the user to
    &#x201C;freeze up&#x201D;. With <b>chan event</b>, the process can tell when
    data is present and only invoke <b>chan gets</b> or <b>chan read</b> when
    they will not block.</p>
<p class="Pp">A channel is considered to be readable if there is unread data
    available on the underlying device. A channel is also considered to be
    readable if there is unread data in an input buffer, except in the special
    case where the most recent attempt to read from the channel was a <b>chan
    gets</b> call that could not find a complete line in the input buffer. This
    feature allows a file to be read a line at a time in nonblocking mode using
    events. A channel is also considered to be readable if an end of file or
    error condition is present on the underlying file or device. It is important
    for <i>script</i> to check for these conditions and handle them
    appropriately; for example, if there is no special check for end of file, an
    infinite loop may occur where <i>script</i> reads no data, returns, and is
    immediately invoked again.</p>
<p class="Pp">A channel is considered to be writable if at least one byte of
    data can be written to the underlying file or device without blocking, or if
    an error condition is present on the underlying file or device. Note that
    client sockets opened in asynchronous mode become writable when they become
    connected or if the connection fails.</p>
<p class="Pp">Event-driven I/O works best for channels that have been placed
    into nonblocking mode with the <b>chan configure</b> command. In blocking
    mode, a <b>chan puts</b> command may block if you give it more data than the
    underlying file or device can accept, and a <b>chan gets</b> or <b>chan
    read</b> command will block if you attempt to read more data than is ready;
    no events will be processed while the commands block. In nonblocking mode
    <b>chan puts</b>, <b>chan read</b>, and <b>chan</b> <b>gets</b> never
  block.</p>
<p class="Pp">The script for a file event is executed at global level (outside
    the context of any Tcl procedure) in the interpreter in which the
    <b>chan</b> <b>event</b> command was invoked. If an error occurs while
    executing the script then the command registered with <b>interp bgerror</b>
    is used to report the error. In addition, the file event handler is deleted
    if it ever returns an error; this is done in order to prevent infinite loops
    due to buggy handlers.</p>
</div>
<dl class="Bl-tag">
  <dt><b>chan flush </b><i>channelId</i></dt>
  <dd>Ensures that all pending output for the channel called <i>channelId</i> is
      written.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp">If the channel is in blocking mode the command does not return
    until all the buffered output has been flushed to the channel. If the
    channel is in nonblocking mode, the command may return before all buffered
    output has been flushed; the remainder will be flushed in the background as
    fast as the underlying file or device is able to absorb it.</p>
</div>
<dl class="Bl-tag">
  <dt><b>chan gets </b><i>channelId</i> ?<i>varName</i>?</dt>
  <dd>Reads the next line from the channel called <i>channelId</i>. If
      <i>varName</i> is not specified, the result of the command will be the
      line that has been read (without a trailing newline character) or an empty
      string upon end-of-file or, in non-blocking mode, if the data available is
      exhausted. If <i>varName</i> is specified, the line that has been read
      will be written to the variable called <i>varName</i> and result will be
      the number of characters that have been read or -1 if end-of-file was
      reached or, in non-blocking mode, if the data available is exhausted.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp">If an end-of-file occurs while part way through reading a line,
    the partial line will be returned (or written into <i>varName</i>). When
    <i>varName</i> is not specified, the end-of-file case can be distinguished
    from an empty line using the <b>chan eof</b> command, and the
    partial-line-but-nonblocking case can be distinguished with the <b>chan
    blocked</b> command.</p>
</div>
<dl class="Bl-tag">
  <dt><b>chan names</b> ?<i>pattern</i>?</dt>
  <dd>Produces a list of all channel names. If <i>pattern</i> is specified, only
      those channel names that match it (according to the rules of <b>string
      match</b>) will be returned.</dd>
  <dt><b>chan pending </b><i>mode channelId</i></dt>
  <dd>Depending on whether <i>mode</i> is <b>input</b> or <b>output</b>, returns
      the number of bytes of input or output (respectively) currently buffered
      internally for <i>channelId</i> (especially useful in a readable event
      callback to impose application-specific limits on input line lengths to
      avoid a potential denial-of-service attack where a hostile user crafts an
      extremely long line that exceeds the available memory to buffer it).
      Returns -1 if the channel was not opened for the mode in question.</dd>
  <dt><b>chan postevent </b><i>channelId eventSpec</i></dt>
  <dd>This subcommand is used by command handlers specified with <b>chan</b>
      <b>create</b>. It notifies the channel represented by the handle
      <i>channelId</i> that the event(s) listed in the <i>eventSpec</i> have
      occurred. The argument has to be a list containing any of the strings
      <b>read</b> and <b>write</b>. The list must contain at least one element
      as it does not make sense to invoke the command if there are no events to
      post.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp">Note that this subcommand can only be used with channel handles
    that were created/opened by <b>chan create</b>. All other channels will
    cause this subcommand to report an error.</p>
<p class="Pp">As only the Tcl level of a channel, i.e. its command handler,
    should post events to it we also restrict the usage of this command to the
    interpreter that created the channel. In other words, posting events to a
    reflected channel from an interpreter that does not contain it's
    implementation is not allowed. Attempting to post an event from any other
    interpreter will cause this subcommand to report an error.</p>
<p class="Pp">Another restriction is that it is not possible to post events that
    the I/O core has not registered an interest in. Trying to do so will cause
    the method to throw an error. See the command handler method <b>watch</b>
    described in <b>reflectedchan</b>, the document specifying the API of
    command handlers for reflected channels.</p>
<p class="Pp">This command is <b>safe</b> and made accessible to safe
    interpreters. It can trigger the execution of <b>chan event</b> handlers,
    whether in the current interpreter or in other interpreters or other
    threads, even where the event is posted from a safe interpreter and listened
    for by a trusted interpreter. <b>Chan event</b> handlers are <i>always</i>
    executed in the interpreter that set them up.</p>
</div>
<dl class="Bl-tag">
  <dt><b>chan puts</b> ?<b>-nonewline</b>? ?<i>channelId</i>? <i>string</i></dt>
  <dd>Writes <i>string</i> to the channel named <i>channelId</i> followed by a
      newline character. A trailing newline character is written unless the
      optional flag <b>-nonewline</b> is given. If <i>channelId</i> is omitted,
      the string is written to the standard output channel, <b>stdout</b>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp">Newline characters in the output are translated by <b>chan
    puts</b> to platform-specific end-of-line sequences according to the
    currently configured value of the <b>-translation</b> option for the channel
    (for example, on PCs newlines are normally replaced with
    carriage-return-linefeed sequences; see <b>chan configure</b> above for
    details).</p>
<p class="Pp">Tcl buffers output internally, so characters written with
    <b>chan</b> <b>puts</b> may not appear immediately on the output file or
    device; Tcl will normally delay output until the buffer is full or the
    channel is closed. You can force output to appear immediately with the
    <b>chan</b> <b>flush</b> command.</p>
<p class="Pp">When the output buffer fills up, the <b>chan puts</b> command will
    normally block until all the buffered data has been accepted for output by
    the operating system. If <i>channelId</i> is in nonblocking mode then the
    <b>chan puts</b> command will not block even if the operating system cannot
    accept the data. Instead, Tcl continues to buffer the data and writes it in
    the background as fast as the underlying file or device can accept it. The
    application must use the Tcl event loop for nonblocking output to work;
    otherwise Tcl never finds out that the file or device is ready for more
    output data. It is possible for an arbitrarily large amount of data to be
    buffered for a channel in nonblocking mode, which could consume a large
    amount of memory. To avoid wasting memory, nonblocking I/O should normally
    be used in an event-driven fashion with the <b>chan event</b> command (do
    not invoke <b>chan puts</b> unless you have recently been notified via a
    file event that the channel is ready for more output data).</p>
</div>
<dl class="Bl-tag">
  <dt><b>chan read </b><i>channelId</i> ?<i>numChars</i>?</dt>
  <dd></dd>
  <dt><b>chan read </b>?<b>-nonewline</b>? <i>channelId</i></dt>
  <dd>In the first form, the result will be the next <i>numChars</i> characters
      read from the channel named <i>channelId</i>; if <i>numChars</i> is
      omitted, all characters up to the point when the channel would signal a
      failure (whether an end-of-file, blocked or other error condition) are
      read. In the second form (i.e. when <i>numChars</i> has been omitted) the
      flag <b>-nonewline</b> may be given to indicate that any trailing newline
      in the string that has been read should be trimmed.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp">If <i>channelId</i> is in nonblocking mode, <b>chan read</b> may
    not read as many characters as requested: once all available input has been
    read, the command will return the data that is available rather than
    blocking for more input. If the channel is configured to use a multi-byte
    encoding, then there may actually be some bytes remaining in the internal
    buffers that do not form a complete character. These bytes will not be
    returned until a complete character is available or end-of-file is reached.
    The <b>-nonewline</b> switch is ignored if the command returns before
    reaching the end of the file.</p>
<p class="Pp"><b>Chan read</b> translates end-of-line sequences in the input
    into newline characters according to the <b>-translation</b> option for the
    channel (see <b>chan configure</b> above for a discussion on the ways in
    which <b>chan configure</b> will alter input).</p>
<p class="Pp">When reading from a serial port, most applications should
    configure the serial port channel to be nonblocking, like this:</p>
<div class="Bd-indent">
<pre>
<b>chan configure </b><i>channelId </i><b>-blocking </b><i>0</i>.
</pre>
</div>
Then <b>chan read</b> behaves much like described above. Note that most serial
  ports are comparatively slow; it is entirely possible to get a <b>readable</b>
  event for each character read from them. Care must be taken when using <b>chan
  read</b> on blocking serial ports:
<dl class="Bl-tag">
  <dt><b>chan read </b><i>channelId numChars</i></dt>
  <dd>In this form <b>chan read</b> blocks until <i>numChars</i> have been
      received from the serial port.</dd>
  <dt><b>chan read </b><i>channelId</i></dt>
  <dd>In this form <b>chan read</b> blocks until the reception of the
      end-of-file character, see <b>chan configure -eofchar</b>. If there no
      end-of-file character has been configured for the channel, then <b>chan
      read</b> will block forever.</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt><b>chan seek </b><i>channelId offset</i> ?<i>origin</i>?</dt>
  <dd>Sets the current access position within the underlying data stream for the
      channel named <i>channelId</i> to be <i>offset</i> bytes relative to
      <i>origin</i>. <i>Offset</i> must be an integer (which may be negative)
      and <i>origin</i> must be one of the following:</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>start</b></dt>
  <dd>The new access position will be <i>offset</i> bytes from the start of the
      underlying file or device.</dd>
  <dt><b>current</b></dt>
  <dd>The new access position will be <i>offset</i> bytes from the current
      access position; a negative <i>offset</i> moves the access position
      backwards in the underlying file or device.</dd>
  <dt><b>end</b></dt>
  <dd>The new access position will be <i>offset</i> bytes from the end of the
      file or device. A negative <i>offset</i> places the access position before
      the end of file, and a positive <i>offset</i> places the access position
      after the end of file.</dd>
</dl>
<p class="Pp">The <i>origin</i> argument defaults to <b>start</b>.</p>
<p class="Pp"><b>Chan seek</b> flushes all buffered output for the channel
    before the command returns, even if the channel is in nonblocking mode. It
    also discards any buffered and unread input. This command returns an empty
    string. An error occurs if this command is applied to channels whose
    underlying file or device does not support seeking.</p>
<p class="Pp">Note that <i>offset</i> values are byte offsets, not character
    offsets. Both <b>chan seek</b> and <b>chan tell</b> operate in terms of
    bytes, not characters, unlike <b>chan read</b>.</p>
</div>
<dl class="Bl-tag">
  <dt><b>chan tell </b><i>channelId</i></dt>
  <dd>Returns a number giving the current access position within the underlying
      data stream for the channel named <i>channelId</i>. This value returned is
      a byte offset that can be passed to <b>chan seek</b> in order to set the
      channel to a particular position. Note that this value is in terms of
      bytes, not characters like <b>chan read</b>. The value returned is -1 for
      channels that do not support seeking.</dd>
  <dt><b>chan truncate </b><i>channelId</i> ?<i>length</i>?</dt>
  <dd>Sets the byte length of the underlying data stream for the channel named
      <i>channelId</i> to be <i>length</i> (or to the current byte offset within
      the underlying data stream if <i>length</i> is omitted). The channel is
      flushed before truncation.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="EXAMPLE"><a class="permalink" href="#EXAMPLE">EXAMPLE</a></h1>
This opens a file using a known encoding (CP1252, a very common encoding on
  Windows), searches for a string, rewrites that part, and truncates the file
  after a further two lines.
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
set f [open somefile.txt r+]
<b>chan configure</b> $f -encoding cp1252
set offset 0
<i># Search for string &quot;FOOBAR&quot; in the file</i>
while {[<b>chan gets</b> $f line] &gt;= 0} {
   set idx [string first FOOBAR $line]
   if {$idx &gt; -1} {
      <i># Found it; rewrite line</i>
      <b>chan seek</b> $f [expr {$offset + $idx}]
      <b>chan puts</b> -nonewline $f BARFOO
      <i># Skip to end of following line, and truncate</i>
      <b>chan gets</b> $f
      <b>chan gets</b> $f
      <b>chan truncate</b> $f
      <i># Stop searching the file now</i>
      break
   }
   <i># Save offset of start of next line for later</i>
   set offset [<b>chan tell</b> $f]
}
<b>chan close</b> $f
</pre>
</div>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
close(n), eof(n), fblocked(n), fconfigure(n), fcopy(n), file(n), fileevent(n),
  flush(n), gets(n), open(n), puts(n), read(n), seek(n), socket(n), tell(n),
  refchan(n)
</section>
<section class="Sh">
<h1 class="Sh" id="KEYWORDS"><a class="permalink" href="#KEYWORDS">KEYWORDS</a></h1>
channel, input, output, events, offset
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">8.5</td>
    <td class="foot-os">Tcl</td>
  </tr>
</table>
</body>
</html>
