<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    .Nd, .Bf, .Op { display: inline; }
    .Pa, .Ad { font-style: italic; }
    .Ms { font-weight: bold; }
    .Bl-diag > dt { font-weight: bold; }
    code.Nm, .Fl, .Cm, .Ic, code.In, .Fd, .Fn, .Cd { font-weight: bold;
      font-family: inherit; }
  </style>
  <title>Inline::Struct(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Inline::Struct(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Inline::Struct(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Inline::Struct -- Manipulate C structures directly from Perl.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>  use Inline C =&gt; 'DATA', structs =&gt; ['Foo'];
  my $obj = Inline::Struct::Foo-&gt;new;
  $obj-&gt;num(10);
  $obj-&gt;str(&quot;Hello&quot;);
  print myfunc($obj), &quot;\n&quot;;
  __END__
  __C__
  struct Foo {
    int num;
    char *str;
  };
  typedef struct Foo Foo;
  SV *myfunc(Foo *f) {
    return newSVpvf(&quot;myfunc: num=%i, str='%s'&quot;, f-&gt;num, f-&gt;str);
  }
</pre>
<p class="Pp">This complete program prints:</p>
<p class="Pp"></p>
<pre>  myfunc: num=10, str='Hello'
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">Inline::Struct is not a new language. It's a language extension
    designed to be used by Inline::C. It parses struct definitions and creates
    typemaps and XS code which bind each struct into a Perl class. This code is
    passed to Inline::C, which compiles it in the normal way.</p>
<p class="Pp">NOTE: Inline::Struct parses only C-style structs. It doesn't know
    about any C++ extensions to structs like scopes, constructors or methods. If
    you want such functionality you should use Inline::CPP to parse your
    structs.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="Using_Inline::Struct"><a class="permalink" href="#Using_Inline::Struct">Using
  Inline::Struct</a></h1>
<p class="Pp">Inline::Struct has a Parse::RecDescent grammar to parse C structs.
    If a struct is recognized, it can be bound to Perl. If the struct's
    definition is not recognized (usually because it has a member with no
    typemap), it will not be bound to Perl, but will be available from other
    functions in C or C++.</p>
<p class="Pp">The following example shows how a simple struct might look to a
    Perl programmer.</p>
<p class="Pp">Example 1:</p>
<p class="Pp"></p>
<pre>  use Inline C =&gt; &lt;&lt;'END', enable =&gt; 'structs';
  struct Fraction {
    long numer;
    long denom;
  };
  END
  my $o = Inline::Struct::Fraction-&gt;new(4, 3);
  print $o-&gt;numer, $o-&gt;denom, &quot;\n&quot;;
  $o-&gt;numer(4)-&gt;denom(7);
</pre>
<p class="Pp">After the code above has been compiled, Perl's namespace looks a
    lot like the following:</p>
<p class="Pp"></p>
<pre>  package Inline::Struct::Fraction;
  sub new { }
  sub DESTROY { }
  sub _KEYS { }
  sub _VALUES { }
  sub _HASH { }
  sub numer { }
  sub denom { }
</pre>
<p class="Pp">Note that these are actually XS subs written in C, not Perl subs.
    But that's what it looks like.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="The_Struct_Interface"><a class="permalink" href="#The_Struct_Interface">The
  Struct Interface</a></h1>
<p class="Pp">The following sections define the interface of each subroutine.
    <b>Note: this</b> <b>interface is likely to change in future versions of
    Inline::Struct</b>. Please don't rely on Inline::Struct in production code
    quite yet.</p>
<p class="Pp">When a struct is bound by Inline::Struct, a new namespace is
    created underneath Inline::Struct. So if you have a struct named 'Foo', the
    package of the Perl class will be 'Inline::Struct::Foo'.</p>
<section class="Ss">
<h2 class="Ss" id="new"><a class="permalink" href="#new">new</a></h2>
<p class="Pp">If no arguments are provided, all fields are zeroed out. If you
    provide values, they should be appropriate for the field type, and in the
    same order as they are defined in the struct.</p>
</section>
<section class="Ss">
<h2 class="Ss">DESTROY</h2>
<p class="Pp">The destructor. Should never be called by the programmer -- this
    is called automatically when the Perl variable holding the struct is
    destroyed. Frees the memory associated with the struct. If the struct holds
    pointers to malloc'd memory, they will not be freed. If you run into such a
    situation, consider using C++ and Inline::CPP instead.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_KEYS"><a class="permalink" href="#_KEYS">_KEYS</a></h2>
<p class="Pp">A read-only method, this returns a reference to an array
    containing the names of the fields in the struct. The fields are in the
    order they appear in the C source code.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_VALUES"><a class="permalink" href="#_VALUES">_VALUES</a></h2>
<p class="Pp">A read-only method, this returns a reference to an array
    containing the values of the fields in the struct. The values are returned
    in the same order as the fields.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_HASH"><a class="permalink" href="#_HASH">_HASH</a></h2>
<p class="Pp">A read-only method, this returns a reference to a hash, mapping
    field names to field values.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Accessors"><a class="permalink" href="#Accessors">Accessors</a></h2>
<p class="Pp">For each field in the struct, an accessor method will be created
    which lets you get or set the value in the struct. If no arguments are
    provided, the method returns the value of that field. If any arguments are
    provided, the field is set to the first argument, and the modified structure
    is returned. This makes setting multiple fields easy:</p>
<p class="Pp"></p>
<pre>   $o-&gt;field1(something)-&gt;field2(somethingelse);
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="C_and_C"><a class="permalink" href="#C_and_C">C and C++
  Configuration Options</a></h1>
<p class="Pp">Inline::Struct has no configuration options of its own, but it
    does provide a new configuration option for C or C++.</p>
<section class="Ss">
<h2 class="Ss" id="structs"><a class="permalink" href="#structs">structs</a></h2>
<p class="Pp">Specifies that structs are to be bound to Perl. There are several
    meanings to this option, so I'll explain with an example:</p>
<p class="Pp"></p>
<pre>   use Inline C =&gt; config =&gt; structs =&gt; 'Foo';
</pre>
<p class="Pp">Adds 'Foo' to the list of structs to bind to Perl.</p>
<p class="Pp"></p>
<pre>   use Inline C =&gt; config =&gt; structs =&gt; ['Foo', 'Bar'];
</pre>
<p class="Pp">Adds 'Foo' and 'Bar' to the list of structs to bind to Perl.</p>
<p class="Pp"></p>
<pre>   use Inline C =&gt; config =&gt; structs =&gt; undef;
</pre>
<p class="Pp">Clears the list of structs to bind to Perl.</p>
<p class="Pp"></p>
<pre>   use Inline C =&gt; config =&gt; enable =&gt; 'structs';
or
   use Inline C =&gt; config =&gt; structs =&gt; 1;
</pre>
<p class="Pp">Enable binding structs to Perl, without specifying any structs to
    search for. As shown, this would bind all structs to Perl.</p>
<p class="Pp"></p>
<pre>   use Inline C =&gt; config =&gt; disable =&gt; 'structs';
</pre>
<p class="Pp">or</p>
<p class="Pp"></p>
<pre>   use Inline C =&gt; config =&gt; structs =&gt; 0;
</pre>
<p class="Pp">Disable binding structs to Perl.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="PERFORMANCE_OF_STRUCTS_AGAINST_PERL_DATA_STRUCTURES"><a class="permalink" href="#PERFORMANCE_OF_STRUCTS_AGAINST_PERL_DATA_STRUCTURES">PERFORMANCE
  OF STRUCTS AGAINST PERL DATA STRUCTURES</a></h1>
<section class="Ss">
<h2 class="Ss" id="Time"><a class="permalink" href="#Time">Time</a></h2>
<p class="Pp">A script, <i>benchmark</i>, that benchmarks a simple C
    <span class="Li">&quot;struct&quot;</span> against a pure-Perl data
    structure, is supplied. It should be run a couple of times to get everything
    cached. A typical results run is as follows:</p>
<p class="Pp"></p>
<pre>  Faster type          % faster
  ISF dnum read        24%
  PP dnum write        247%
  ISF inum read        39%
  PP inum write        231%
  ISF str read         18%
  PP str write         264%
</pre>
<p class="Pp">This shows that reading the struct is faster than a simple object
    implemented as a hash-ref, while writing to a struct in the current
    implementation is several times slower. If the Perl object is instead
    implemented as an array-ref, in the class
    <span class="Li">&quot;PP::Foo::Array&quot;</span>, the numbers do not
    change significantly.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Memory"><a class="permalink" href="#Memory">Memory</a></h2>
<p class="Pp">The same script also compares memory usage. A typical results
  run:</p>
<p class="Pp"></p>
<pre>  Memory usage
  10000 x bless [ 7, &quot;string&quot; ], &quot;main&quot;: 34592
  10000 x Inline::Struct::Foo-&gt;new: 45648
  100000 x bless [ 7, &quot;string&quot; ], &quot;main&quot;: 139344
  100000 x Inline::Struct::Foo-&gt;new: 248080
  1000000 x bless [ 7, &quot;string&quot; ], &quot;main&quot;: 1187024
  1000000 x Inline::Struct::Foo-&gt;new: 2257968
</pre>
<p class="Pp">The memory usage of the struct is around twice as large.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp">For more information about using C from Perl, see Inline::C. For
    more information about using C++ from Perl, see Inline::CPP.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">Neil Watkiss (NEILW@cpan.org)</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT"><a class="permalink" href="#COPYRIGHT">COPYRIGHT</a></h1>
<p class="Pp">Copyright (C) 2001, Neil Watkiss.</p>
<p class="Pp">This module is free software. It may be used, redistributed and/or
    modified under the same terms as Perl itself.</p>
<p class="Pp">See &lt;http://dev.perl.org/licenses/&gt;</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2019-01-18</td>
    <td class="foot-os">perl v5.30.2</td>
  </tr>
</table>
</body>
</html>
