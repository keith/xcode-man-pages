<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   generated by cd2nroff 0.1 from curl_formadd.md
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    .Nd, .Bf, .Op { display: inline; }
    .Pa, .Ad { font-style: italic; }
    .Ms { font-weight: bold; }
    .Bl-diag > dt { font-weight: bold; }
    code.Nm, .Fl, .Cm, .Ic, code.In, .Fd, .Fn, .Cd { font-weight: bold;
      font-family: inherit; }
  </style>
  <title>curl_formadd(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">curl_formadd(3)</td>
    <td class="head-vol">Library Functions Manual</td>
    <td class="head-rtitle">curl_formadd(3)</td>
  </tr>
</table>
<div class="manual-text">
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">curl_formadd - add a section to a multipart form POST</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>#include &lt;curl/curl.h&gt;
CURLFORMcode curl_formadd(struct curl_httppost **firstitem,
<br/>
                          struct curl_httppost **lastitem, ...);</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp"><b>This function is deprecated.</b> Use <i>curl_mime_init(3)</i>
    instead.</p>
<p class="Pp">curl_formadd() is used to append sections when building a
    multipart form post. Append one section at a time until you have added all
    the sections you want included and then you pass the <i>firstitem</i>
    pointer as parameter to <i>CURLOPT_HTTPPOST(3)</i>. <i>lastitem</i> is set
    after each <i>curl_formadd(3)</i> call and on repeated invokes it should be
    left as set to allow repeated invokes to find the end of the list
  faster.</p>
<p class="Pp">After the <i>lastitem</i> pointer follow the real arguments.</p>
<p class="Pp">The pointers <i>firstitem</i> and <i>lastitem</i> should both be
    pointing to NULL in the first call to this function. All list-data is
    allocated by the function itself. You must call <i>curl_formfree(3)</i> on
    the <i>firstitem</i> after the form post has been done to free the
    resources.</p>
<p class="Pp">Using POST with HTTP 1.1 implies the use of a &quot;Expect:
    100-continue&quot; header. You can disable this header with
    <i>CURLOPT_HTTPHEADER(3)</i> as usual.</p>
<p class="Pp">First, there are some basics you need to understand about
    multipart form posts. Each part consists of at least a NAME and a CONTENTS
    part. If the part is made for file upload, there are also a stored
    CONTENT-TYPE and a FILENAME. Below, we discuss what options you use to set
    these properties in the parts you want to add to your post.</p>
<p class="Pp">The options listed first are for making normal parts. The options
    from <i>CURLFORM_FILE</i> through <i>CURLFORM_BUFFERLENGTH</i> are for file
    upload parts.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="OPTIONS"><a class="permalink" href="#OPTIONS">OPTIONS</a></h1>
<dl class="Bl-tag">
  <dt id="CURLFORM_COPYNAME"><a class="permalink" href="#CURLFORM_COPYNAME">CURLFORM_COPYNAME</a></dt>
  <dd>followed by a string which provides the <i>name</i> of this part. libcurl
      copies the string so your application does not need to keep it around
      after this function call. If the name is not null-terminated, you must set
      its length with <b>CURLFORM_NAMELENGTH</b>. The <i>name</i> is not allowed
      to contain zero-valued bytes. The copied data is freed by
      <i>curl_formfree(3)</i>.</dd>
  <dt id="CURLFORM_PTRNAME"><a class="permalink" href="#CURLFORM_PTRNAME">CURLFORM_PTRNAME</a></dt>
  <dd>followed by a string which provides the <i>name</i> of this part. libcurl
      uses the pointer and refer to the data in your application, so you must
      make sure it remains until curl no longer needs it. If the name is not
      null-terminated, you must set its length with <b>CURLFORM_NAMELENGTH</b>.
      The <i>name</i> is not allowed to contain zero-valued bytes.</dd>
  <dt id="CURLFORM_COPYCONTENTS"><a class="permalink" href="#CURLFORM_COPYCONTENTS">CURLFORM_COPYCONTENTS</a></dt>
  <dd>followed by a pointer to the contents of this part, the actual data to
      send away. libcurl copies the provided data, so your application does not
      need to keep it around after this function call. If the data is not null
      terminated, or if you would like it to contain zero bytes, you must set
      the length of the name with <b>CURLFORM_CONTENTSLENGTH</b>. The copied
      data is freed by <i>curl_formfree(3)</i>.</dd>
  <dt id="CURLFORM_PTRCONTENTS"><a class="permalink" href="#CURLFORM_PTRCONTENTS">CURLFORM_PTRCONTENTS</a></dt>
  <dd>followed by a pointer to the contents of this part, the actual data to
      send away. libcurl uses the pointer and refer to the data in your
      application, so you must make sure it remains until curl no longer needs
      it. If the data is not null-terminated, or if you would like it to contain
      zero bytes, you must set its length with
    <b>CURLFORM_CONTENTSLENGTH</b>.</dd>
  <dt id="CURLFORM_CONTENTLEN"><a class="permalink" href="#CURLFORM_CONTENTLEN">CURLFORM_CONTENTLEN</a></dt>
  <dd>followed by a curl_off_t value giving the length of the contents. Note
      that for <i>CURLFORM_STREAM</i> contents, this option is mandatory.
    <p class="Pp">If you pass a 0 (zero) for this option, libcurl calls strlen()
        on the contents to figure out the size. If you really want to send a
        zero byte content then you must make sure strlen() on the data pointer
        returns zero.</p>
    <p class="Pp">(Option added in 7.46.0)</p>
  </dd>
  <dt id="CURLFORM_CONTENTSLENGTH"><a class="permalink" href="#CURLFORM_CONTENTSLENGTH">CURLFORM_CONTENTSLENGTH</a></dt>
  <dd>(This option is deprecated. Use <i>CURLFORM_CONTENTLEN</i> instead!)
    <p class="Pp">followed by a long giving the length of the contents. Note
        that for <i>CURLFORM_STREAM</i> contents, this option is mandatory.</p>
    <p class="Pp">If you pass a 0 (zero) for this option, libcurl calls strlen()
        on the contents to figure out the size. If you really want to send a
        zero byte content then you must make sure strlen() on the data pointer
        returns zero.</p>
  </dd>
  <dt id="CURLFORM_FILECONTENT"><a class="permalink" href="#CURLFORM_FILECONTENT">CURLFORM_FILECONTENT</a></dt>
  <dd>followed by a filename, causes that file to be read and its contents used
      as data in this part. This part does <i>not</i> automatically become a
      file upload part simply because its data was read from a file.
    <p class="Pp">The specified file needs to kept around until the associated
        transfer is done.</p>
  </dd>
  <dt id="CURLFORM_FILE"><a class="permalink" href="#CURLFORM_FILE">CURLFORM_FILE</a></dt>
  <dd>followed by a filename, makes this part a file upload part. It sets the
      <i>filename</i> field to the basename of the provided filename, it reads
      the contents of the file and passes them as data and sets the content-type
      if the given file match one of the internally known file extensions. For
      <b>CURLFORM_FILE</b> the user may send one or more files in one part by
      providing multiple <b>CURLFORM_FILE</b> arguments each followed by the
      filename (and each <i>CURLFORM_FILE</i> is allowed to have a
      <i>CURLFORM_CONTENTTYPE</i>).
    <p class="Pp">The given upload file has to exist in its full in the file
        system already when the upload starts, as libcurl needs to read the
        correct file size beforehand.</p>
    <p class="Pp">The specified file needs to kept around until the associated
        transfer is done.</p>
  </dd>
  <dt id="CURLFORM_CONTENTTYPE"><a class="permalink" href="#CURLFORM_CONTENTTYPE">CURLFORM_CONTENTTYPE</a></dt>
  <dd>is used in combination with <i>CURLFORM_FILE</i>. Followed by a pointer to
      a string which provides the content-type for this part, possibly instead
      of an internally chosen one.</dd>
  <dt id="CURLFORM_FILENAME"><a class="permalink" href="#CURLFORM_FILENAME">CURLFORM_FILENAME</a></dt>
  <dd>is used in combination with <i>CURLFORM_FILE</i>. Followed by a pointer to
      a string, it tells libcurl to use the given string as the <i>filename</i>
      in the file upload part instead of the actual filename.</dd>
  <dt id="CURLFORM_BUFFER"><a class="permalink" href="#CURLFORM_BUFFER">CURLFORM_BUFFER</a></dt>
  <dd>is used for custom file upload parts without use of <i>CURLFORM_FILE</i>.
      It tells libcurl that the file contents are already present in a buffer.
      The parameter is a string which provides the <i>filename</i> field in the
      content header.</dd>
  <dt id="CURLFORM_BUFFERPTR"><a class="permalink" href="#CURLFORM_BUFFERPTR">CURLFORM_BUFFERPTR</a></dt>
  <dd>is used in combination with <i>CURLFORM_BUFFER</i>. The parameter is a
      pointer to the buffer to be uploaded. This buffer must not be freed until
      after <i>curl_easy_cleanup(3)</i> is called. You must also use
      <i>CURLFORM_BUFFERLENGTH</i> to set the number of bytes in the
    buffer.</dd>
  <dt id="CURLFORM_BUFFERLENGTH"><a class="permalink" href="#CURLFORM_BUFFERLENGTH">CURLFORM_BUFFERLENGTH</a></dt>
  <dd>is used in combination with <i>CURLFORM_BUFFER</i>. The parameter is a
      long which gives the length of the buffer.</dd>
  <dt id="CURLFORM_STREAM"><a class="permalink" href="#CURLFORM_STREAM">CURLFORM_STREAM</a></dt>
  <dd>Tells libcurl to use the <i>CURLOPT_READFUNCTION(3)</i> callback to get
      data. The parameter you pass to <i>CURLFORM_STREAM</i> is the pointer
      passed on to the read callback's fourth argument. If you want the part to
      look like a file upload one, set the <i>CURLFORM_FILENAME</i> parameter as
      well. Note that when using <i>CURLFORM_STREAM</i>,
      <i>CURLFORM_CONTENTSLENGTH</i> must also be set with the total expected
      length of the part unless the formpost is sent chunked encoded. (Option
      added in libcurl 7.18.2)</dd>
  <dt id="CURLFORM_ARRAY"><a class="permalink" href="#CURLFORM_ARRAY">CURLFORM_ARRAY</a></dt>
  <dd>Another possibility to send options to curl_formadd() is the
      <b>CURLFORM_ARRAY</b> option, that passes a struct curl_forms array
      pointer as its value. Each curl_forms structure element has a
      <i>CURLformoption</i> and a char pointer. The final element in the array
      must be a CURLFORM_END. All available options can be used in an array,
      except the CURLFORM_ARRAY option itself. The last argument in such an
      array must always be <b>CURLFORM_END</b>.</dd>
  <dt id="CURLFORM_CONTENTHEADER"><a class="permalink" href="#CURLFORM_CONTENTHEADER">CURLFORM_CONTENTHEADER</a></dt>
  <dd>specifies extra headers for the form POST section. This takes a curl_slist
      prepared in the usual way using <b>curl_slist_append</b> and appends the
      list of headers to those libcurl automatically generates. The list must
      exist while the POST occurs, if you free it before the post completes you
      may experience problems.
    <p class="Pp">When you have passed the <i>struct curl_httppost</i> pointer
        to <i>curl_easy_setopt(3)</i> (using the <i>CURLOPT_HTTPPOST(3)</i>
        option), you must not free the list until after you have called
        <i>curl_easy_cleanup(3)</i> for the curl handle.</p>
    <p class="Pp">See example below.</p>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="EXAMPLE"><a class="permalink" href="#EXAMPLE">EXAMPLE</a></h1>
<pre>#include &lt;string.h&gt; /* for strlen */
static const char record[]=&quot;data in a buffer&quot;;
int main(void)
{
<br/>
  CURL *curl = curl_easy_init();
<br/>
  if(curl) {
<br/>
    struct curl_httppost *post = NULL;
<br/>
    struct curl_httppost *last = NULL;
<br/>
    char namebuffer[] = &quot;name buffer&quot;;
<br/>
    long namelength = strlen(namebuffer);
<br/>
    char buffer[] = &quot;test buffer&quot;;
<br/>
    char htmlbuffer[] = &quot;&lt;HTML&gt;test buffer&lt;/HTML&gt;&quot;;
<br/>
    long htmlbufferlength = strlen(htmlbuffer);
<br/>
    struct curl_forms forms[3];
<br/>
    char file1[] = &quot;my-face.jpg&quot;;
<br/>
    char file2[] = &quot;your-face.jpg&quot;;
<br/>
    /* add null character into htmlbuffer, to demonstrate that
<br/>
       transfers of buffers containing null characters actually work
<br/>
    */
<br/>
    htmlbuffer[8] = '\0';
<br/>
    /* Add simple name/content section */
<br/>
    curl_formadd(&amp;post, &amp;last, CURLFORM_COPYNAME, &quot;name&quot;,
<br/>
                 CURLFORM_COPYCONTENTS, &quot;content&quot;, CURLFORM_END);
<br/>
    /* Add simple name/content/contenttype section */
<br/>
    curl_formadd(&amp;post, &amp;last, CURLFORM_COPYNAME, &quot;htmlcode&quot;,
<br/>
                 CURLFORM_COPYCONTENTS, &quot;&lt;HTML&gt;&lt;/HTML&gt;&quot;,
<br/>
                 CURLFORM_CONTENTTYPE, &quot;text/html&quot;, CURLFORM_END);
<br/>
    /* Add name/ptrcontent section */
<br/>
    curl_formadd(&amp;post, &amp;last, CURLFORM_COPYNAME, &quot;name_for_ptrcontent&quot;,
<br/>
                 CURLFORM_PTRCONTENTS, buffer, CURLFORM_END);
<br/>
    /* Add ptrname/ptrcontent section */
<br/>
    curl_formadd(&amp;post, &amp;last, CURLFORM_PTRNAME, namebuffer,
<br/>
                 CURLFORM_PTRCONTENTS, buffer, CURLFORM_NAMELENGTH,
<br/>
                 namelength, CURLFORM_END);
<br/>
    /* Add name/ptrcontent/contenttype section */
<br/>
    curl_formadd(&amp;post, &amp;last, CURLFORM_COPYNAME, &quot;html_code_with_hole&quot;,
<br/>
                 CURLFORM_PTRCONTENTS, htmlbuffer,
<br/>
                 CURLFORM_CONTENTSLENGTH, htmlbufferlength,
<br/>
                 CURLFORM_CONTENTTYPE, &quot;text/html&quot;, CURLFORM_END);
<br/>
    /* Add simple file section */
<br/>
    curl_formadd(&amp;post, &amp;last, CURLFORM_COPYNAME, &quot;picture&quot;,
<br/>
                 CURLFORM_FILE, &quot;my-face.jpg&quot;, CURLFORM_END);
<br/>
    /* Add file/contenttype section */
<br/>
    curl_formadd(&amp;post, &amp;last, CURLFORM_COPYNAME, &quot;picture&quot;,
<br/>
                 CURLFORM_FILE, &quot;my-face.jpg&quot;,
<br/>
                 CURLFORM_CONTENTTYPE, &quot;image/jpeg&quot;, CURLFORM_END);
<br/>
    /* Add two file section */
<br/>
    curl_formadd(&amp;post, &amp;last, CURLFORM_COPYNAME, &quot;pictures&quot;,
<br/>
                 CURLFORM_FILE, &quot;my-face.jpg&quot;,
<br/>
                 CURLFORM_FILE, &quot;your-face.jpg&quot;, CURLFORM_END);
<br/>
    /* Add two file section using CURLFORM_ARRAY */
<br/>
    forms[0].option = CURLFORM_FILE;
<br/>
    forms[0].value  = file1;
<br/>
    forms[1].option = CURLFORM_FILE;
<br/>
    forms[1].value  = file2;
<br/>
    forms[2].option  = CURLFORM_END;
<br/>
    /* Add a buffer to upload */
<br/>
    curl_formadd(&amp;post, &amp;last,
<br/>
                 CURLFORM_COPYNAME, &quot;name&quot;,
<br/>
                 CURLFORM_BUFFER, &quot;data&quot;,
<br/>
                 CURLFORM_BUFFERPTR, record,
<br/>
                 CURLFORM_BUFFERLENGTH, sizeof(record),
<br/>
                 CURLFORM_END);
<br/>
    /* no option needed for the end marker */
<br/>
    curl_formadd(&amp;post, &amp;last, CURLFORM_COPYNAME, &quot;pictures&quot;,
<br/>
                 CURLFORM_ARRAY, forms, CURLFORM_END);
<br/>
    /* Add the content of a file as a normal post text value */
<br/>
    curl_formadd(&amp;post, &amp;last, CURLFORM_COPYNAME, &quot;filecontent&quot;,
<br/>
                 CURLFORM_FILECONTENT, &quot;.bashrc&quot;, CURLFORM_END);
<br/>
    /* Set the form info */
<br/>
    curl_easy_setopt(curl, CURLOPT_HTTPPOST, post);
<br/>
    curl_easy_perform(curl);
<br/>
    curl_easy_cleanup(curl);
<br/>
    curl_formfree(post);
<br/>
  }
}</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="AVAILABILITY"><a class="permalink" href="#AVAILABILITY">AVAILABILITY</a></h1>
<p class="Pp">Deprecated in 7.56.0. Before this release, field names were
    allowed to contain zero-valued bytes. The pseudo-filename &quot;-&quot; to
    read stdin is discouraged although still supported, but data is not read
    before being actually sent: the effective data size can then not be
    automatically determined, resulting in a chunked encoding transfer.
    Backslashes and double quotes in field and file names are now escaped before
    transmission.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="RETURN_VALUE"><a class="permalink" href="#RETURN_VALUE">RETURN
  VALUE</a></h1>
<p class="Pp">0 means everything was OK, non-zero means an error occurred
    corresponding to a CURL_FORMADD_* constant defined in
    <i>&lt;curl/curl.h&gt;</i></p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp"><b>curl_easy_setopt</b>(3), <b>curl_formfree</b>(3),
    <b>curl_mime_init</b>(3)</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">November 4, 2020</td>
    <td class="foot-os">libcurl 7.77.0</td>
  </tr>
</table>
</body>
</html>
