<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   generated by cd2nroff 0.1 from curl_multi_perform.md
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    .Nd, .Bf, .Op { display: inline; }
    .Pa, .Ad { font-style: italic; }
    .Ms { font-weight: bold; }
    .Bl-diag > dt { font-weight: bold; }
    code.Nm, .Fl, .Cm, .Ic, code.In, .Fd, .Fn, .Cd { font-weight: bold;
      font-family: inherit; }
  </style>
  <title>curl_multi_perform(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">curl_multi_perform(3)</td>
    <td class="head-vol">Library Functions Manual</td>
    <td class="head-rtitle">curl_multi_perform(3)</td>
  </tr>
</table>
<div class="manual-text">
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">curl_multi_perform - reads/writes available data from easy
  handles</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>#include &lt;curl/curl.h&gt;
CURLMcode curl_multi_perform(CURLM *multi_handle, int *running_handles);</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">This function performs transfers on all the added handles that
    need attention in a non-blocking fashion. The easy handles have previously
    been added to the multi handle with <i>curl_multi_add_handle(3)</i>.</p>
<p class="Pp">When an application has found out there is data available for the
    multi_handle or a timeout has elapsed, the application should call this
    function to read/write whatever there is to read or write right now etc.
    <i>curl_multi_perform(3)</i> returns as soon as the reads/writes are done.
    This function does not require that there actually is any data available for
    reading or that data can be written, it can be called just in case. It
    stores the number of handles that still transfer data in the second
    argument's integer-pointer.</p>
<p class="Pp">If the amount of <i>running_handles</i> is changed from the
    previous call (or is less than the amount of easy handles you have added to
    the multi handle), you know that there is one or more transfers less
    &quot;running&quot;. You can then call <i>curl_multi_info_read(3)</i> to get
    information about each individual completed transfer, and that returned info
    includes CURLcode and more. If an added handle fails quickly, it may never
    be counted as a running_handle. You could use <i>curl_multi_info_read(3)</i>
    to track actual status of the added handles in that case.</p>
<p class="Pp">When <i>running_handles</i> is set to zero (0) on the return of
    this function, there is no longer any transfers in progress.</p>
<p class="Pp">When this function returns error, the state of all transfers are
    uncertain and they cannot be continued. <i>curl_multi_perform(3)</i> should
    not be called again on the same multi handle after an error has been
    returned, unless first removing all the handles and adding new ones.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="EXAMPLE"><a class="permalink" href="#EXAMPLE">EXAMPLE</a></h1>
<pre>int main(void)
{
<br/>
  int still_running;
<br/>
  CURL *multi = curl_multi_init();
<br/>
  CURL *curl = curl_easy_init();
<br/>
  if(curl) {
<br/>
    curl_multi_add_handle(multi, curl);
<br/>
    do {
<br/>
      CURLMcode mc = curl_multi_perform(multi, &amp;still_running);
<br/>
      if(!mc &amp;&amp; still_running)
<br/>
        /* wait for activity, timeout or &quot;nothing&quot; */
<br/>
        mc = curl_multi_poll(multi, NULL, 0, 1000, NULL);
<br/>
      if(mc) {
<br/>
        fprintf(stderr, &quot;curl_multi_poll() failed, code %d.\n&quot;, (int)mc);
<br/>
        break;
<br/>
      }
<br/>
    /* if there are still transfers, loop! */
<br/>
    } while(still_running);
<br/>
  }
}</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="AVAILABILITY"><a class="permalink" href="#AVAILABILITY">AVAILABILITY</a></h1>
<p class="Pp">Added in 7.9.6</p>
</section>
<section class="Sh">
<h1 class="Sh" id="RETURN_VALUE"><a class="permalink" href="#RETURN_VALUE">RETURN
  VALUE</a></h1>
<p class="Pp">CURLMcode type, general libcurl multi interface error code.</p>
<p class="Pp">This function returns errors regarding the whole multi stack.
    Problems on individual transfers may have occurred even when this function
    returns <i>CURLM_OK</i>. Use <i>curl_multi_info_read(3)</i> to figure out
    how individual transfers did.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="TYPICAL_USAGE"><a class="permalink" href="#TYPICAL_USAGE">TYPICAL
  USAGE</a></h1>
<p class="Pp">Most applications use <i>curl_multi_poll(3)</i> to make libcurl
    wait for activity on any of the ongoing transfers. As soon as one or more
    file descriptor has activity or the function times out, the application
    calls <i>curl_multi_perform(3)</i>.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp"><b>curl_multi_add_handle</b>(3), <b>curl_multi_cleanup</b>(3),
    <b>curl_multi_fdset</b>(3), <b>curl_multi_info_read</b>(3),
    <b>curl_multi_init</b>(3), <b>curl_multi_wait</b>(3),
    <b>libcurl-errors</b>(3)</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">September 26, 2023</td>
    <td class="foot-os">libcurl 8.4.0</td>
  </tr>
</table>
</body>
</html>
