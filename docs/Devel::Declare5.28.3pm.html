<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.10 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>Devel::Declare(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Devel::Declare(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Devel::Declare(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
Devel::Declare - (DEPRECATED) Adding keywords to perl, in perl
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<span class="Li"></span>
<pre>
  use Method::Signatures;
  # or ...
  use MooseX::Declare;
  # etc.

  # Use some new and exciting syntax like:
  method hello (Str :$who, Int :$age where { $_ &gt; 0 }) {
    $self-&gt;say(&quot;Hello ${who}, I am ${age} years old!&quot;);
  }
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
Devel::Declare can install subroutines called declarators which locally take
  over Perl's parser, allowing the creation of new syntax.
<p class="Pp">This document describes how to create a simple declarator.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="WARNING"><a class="permalink" href="#WARNING">WARNING</a></h1>
<b>Warning:</b> Devel::Declare is a giant bag of crack originally implemented by
  mst with the goal of upsetting the perl core developers so much by its very
  existence that they implemented proper keyword handling in the core.
<p class="Pp">As of perl5 version 14, this goal has been achieved, and modules
    such as Devel::CallParser, Function::Parameters, and Keyword::Simple provide
    mechanisms to mangle perl syntax that don't require hallucinogenic drugs to
    interpret the error messages they produce.</p>
<p class="Pp">If you are using something that uses Devel::Declare, please for
    the love of kittens use something else:</p>
<ul class="Bl-bullet">
  <li>Instead of TryCatch, use Try::Tiny</li>
  <li>Instead of Method::Signatures, use real subroutine signatures (requires
      perl 5.22) or Moops</li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="USAGE"><a class="permalink" href="#USAGE">USAGE</a></h1>
We'll demonstrate the usage of
  <span class="Li">&quot;Devel::Declare&quot;</span> with a motivating example:
  a new <span class="Li">&quot;method&quot;</span> keyword, which acts like the
  builtin <span class="Li">&quot;sub&quot;</span>, but automatically unpacks
  <span class="Li">$self</span> and the other arguments.
<p class="Pp"><span class="Li"></span></p>
<pre>
  package My::Methods;
  use Devel::Declare;
</pre>
<section class="Ss">
<h2 class="Ss" id="Creating_a_declarator_with__setup_for_"><a class="permalink" href="#Creating_a_declarator_with__setup_for_">Creating
  a declarator with &quot;setup_for&quot;</a></h2>
You will typically create
<p class="Pp"><span class="Li"></span></p>
<pre>
  sub import {
    my $class = shift;
    my $caller = caller;

    Devel::Declare-&gt;setup_for(
        $caller,
        { method =&gt; { const =&gt; \&amp;parser } }
    );
    no strict 'refs';
    *{$caller.'::method'} = sub (&amp;) {};
  }
</pre>
<p class="Pp">Starting from the end of this import routine, you'll see that
    we're creating a subroutine called
    <span class="Li">&quot;method&quot;</span> in the caller's namespace. Yes,
    that's just a normal subroutine, and it does nothing at all (yet!) Note the
    prototype <span class="Li">&quot;(&amp;)&quot;</span> which means that the
    caller would call it like so:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    method {
        my ($self, $arg1, $arg2) = @_;
        ...
    }
</pre>
<p class="Pp">However we want to be able to call it like this</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    method foo ($arg1, $arg2) {
        ...
    }
</pre>
<p class="Pp">That's why we call <span class="Li">&quot;setup_for&quot;</span>
    above, to register the declarator 'method' with a custom parser, as per the
    next section. It acts on an optype, usually <span class="Li">'const'</span>
    as above. (Other valid values are <span class="Li">'check'</span> and
    <span class="Li">'rv2cv'</span>).</p>
<p class="Pp">For a simpler way to install new methods, see also
    Devel::Declare::MethodInstaller::Simple</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Writing_a_parser_subroutine"><a class="permalink" href="#Writing_a_parser_subroutine">Writing
  a parser subroutine</a></h2>
This subroutine is called at <i>compilation</i> time, and allows you to read the
  custom syntaxes that we want (in a syntax that may or may not be valid core
  Perl 5) and munge it so that the result will be parsed by the
  <span class="Li">&quot;perl&quot;</span> compiler.
<p class="Pp">For this example, we're defining some globals for convenience:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    our ($Declarator, $Offset);
</pre>
<p class="Pp">Then we define a parser subroutine to handle our declarator. We'll
    look at this in a few chunks.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    sub parser {
      local ($Declarator, $Offset) = @_;
</pre>
<p class="Pp"><span class="Li">&quot;Devel::Declare&quot;</span> provides some
    very low level utility methods to parse character strings. We'll define some
    useful higher level routines below for convenience, and we can use these to
    parse the various elements in our new syntax.</p>
<p class="Pp">Notice how our parser subroutine is invoked at compile time, when
    the <span class="Li">&quot;perl&quot;</span> parser is pointed just
    <i>before</i> the declarator name.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
      skip_declarator;          # step past 'method'
      my $name = strip_name;    # strip out the name 'foo', if present
      my $proto = strip_proto;  # strip out the prototype '($arg1, $arg2)', if present
</pre>
<p class="Pp">Now we can prepare some code to 'inject' into the new subroutine.
    For example we might want the method as above to have
    <span class="Li">&quot;my ($self, $arg1, $arg2) = @_&quot;</span> injected
    at the beginning of it. We also do some clever stuff with scopes that we'll
    look at shortly.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
      my $inject = make_proto_unwrap($proto);
      if (defined $name) {
        $inject = scope_injector_call().$inject;
      }
      inject_if_block($inject);
</pre>
<p class="Pp">We've now managed to change <span class="Li">&quot;method ($arg1,
    $arg2) { ... }&quot;</span> into <span class="Li">&quot;method {</span>
    <span class="Li">injected_code; ... }&quot;</span>. This will compile... but
    we've lost the name of the method!</p>
<p class="Pp">In a cute (or horrifying, depending on your perspective) trick, we
    temporarily change the definition of the subroutine
    <span class="Li">&quot;method&quot;</span> itself, to specialise it with the
    <span class="Li">$name</span> we stripped, so that it assigns the code block
    to that name.</p>
<p class="Pp">Even though the <i>next</i> time
    <span class="Li">&quot;method&quot;</span> is compiled, it will be redefined
    again, <span class="Li">&quot;perl&quot;</span> caches these definitions in
    its parse tree, so we'll always get the right one!</p>
<p class="Pp">Note that we also handle the case where there was no name,
    allowing an anonymous method analogous to an anonymous subroutine.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
      if (defined $name) {
        $name = join('::', Devel::Declare::get_curstash_name(), $name)
          unless ($name =~ /::/);
        shadow(sub (&amp;) { no strict 'refs'; *{$name} = shift; });
      } else {
        shadow(sub (&amp;) { shift });
      }
    }
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Parser_utilities_in_detail"><a class="permalink" href="#Parser_utilities_in_detail">Parser
  utilities in detail</a></h2>
For simplicity, we're using global variables like
  <span class="Li">$Offset</span> in these examples. You may prefer to look at
  Devel::Declare::Context::Simple, which encapsulates the context much more
  cleanly.
<p class="Pp"><i></i><i>&quot;skip_declarator&quot;</i><i></i></p>
<p class="Pp">This simple parser just moves across a 'token'. The common case is
    to skip the declarator, i.e. to move to the end of the string 'method' and
    before the prototype and code block.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    sub skip_declarator {
      $Offset += Devel::Declare::toke_move_past_token($Offset);
    }
</pre>
<p class="Pp"><span class="Li">&quot;toke_move_past_token&quot;</span></p>
<p class="Pp">This builtin parser simply moves past a 'token' (matching
    <span class="Li">&quot;/[a-zA-Z_]\w*/&quot;</span>) It takes an offset into
    the source document, and skips past the token. It returns the number of
    characters skipped.</p>
<p class="Pp"><i></i><i>&quot;strip_name&quot;</i><i></i></p>
<p class="Pp">This parser skips any whitespace, then scans the next word (again
    matching a 'token'). We can then analyse the current line, and manipulate it
    (using pure Perl). In this case we take the name of the method out, and
    return it.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    sub strip_name {
      skipspace;
      if (my $len = Devel::Declare::toke_scan_word($Offset, 1)) {
        my $linestr = Devel::Declare::get_linestr();
        my $name = substr($linestr, $Offset, $len);
        substr($linestr, $Offset, $len) = '';
        Devel::Declare::set_linestr($linestr);
        return $name;
      }
      return;
    }
</pre>
<p class="Pp"><span class="Li">&quot;toke_scan_word&quot;</span></p>
<p class="Pp">This builtin parser, given an offset into the source document,
    matches a 'token' as above but does not skip. It returns the length of the
    token matched, if any.</p>
<p class="Pp"><span class="Li">&quot;get_linestr&quot;</span></p>
<p class="Pp">This builtin returns the full text of the current line of the
    source document.</p>
<p class="Pp"><span class="Li">&quot;set_linestr&quot;</span></p>
<p class="Pp">This builtin sets the full text of the current line of the source
    document. Beware that injecting a newline into the middle of the line is
    likely to fail in surprising ways. Generally, Perl's parser can rely on the
    `current line' actually being only a single line. Use other kinds of
    whitespace instead, in the code that you inject.</p>
<p class="Pp"><i></i><i>&quot;skipspace&quot;</i><i></i></p>
<p class="Pp">This parser skips whitsepace.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    sub skipspace {
      $Offset += Devel::Declare::toke_skipspace($Offset);
    }
</pre>
<p class="Pp"><span class="Li">&quot;toke_skipspace&quot;</span></p>
<p class="Pp">This builtin parser, given an offset into the source document,
    skips over any whitespace, and returns the number of characters skipped.</p>
<p class="Pp"><i></i><i>&quot;strip_proto&quot;</i><i></i></p>
<p class="Pp">This is a more complex parser that checks if it's found something
    that starts with <span class="Li">'('</span> and returns everything till the
    matching <span class="Li">')'</span>.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    sub strip_proto {
      skipspace;

      my $linestr = Devel::Declare::get_linestr();
      if (substr($linestr, $Offset, 1) eq '(') {
        my $length = Devel::Declare::toke_scan_str($Offset);
        my $proto = Devel::Declare::get_lex_stuff();
        Devel::Declare::clear_lex_stuff();
        $linestr = Devel::Declare::get_linestr();
        substr($linestr, $Offset, $length) = '';
        Devel::Declare::set_linestr($linestr);
        return $proto;
      }
      return;
    }
</pre>
<p class="Pp"><span class="Li">&quot;toke_scan_str&quot;</span></p>
<p class="Pp">This builtin parser uses Perl's own parsing routines to match a
    &quot;stringlike&quot; expression. Handily, this includes bracketed
    expressions (just think about things like <span class="Li">&quot;q(this is a
    quote)&quot;</span>).</p>
<p class="Pp">Also it Does The Right Thing with nested delimiters (like
    <span class="Li">&quot;q(this (is (a) quote))&quot;</span>).</p>
<p class="Pp">It returns the effective length of the expression matched. Really,
    what it returns is the difference in position between where the string
    started, within the buffer, and where it finished. If the string extended
    across multiple lines then the contents of the buffer may have been
    completely replaced by the new lines, so this position difference is not the
    same thing as the actual length of the expression matched. However, because
    moving backward in the buffer causes problems, the function arranges for the
    effective length to always be positive, padding the start of the buffer if
    necessary.</p>
<p class="Pp">Use <span class="Li">&quot;get_lex_stuff&quot;</span> to get the
    actual matched text, the content of the string. Because of the behaviour
    around multiline strings, you can't reliably get this from the buffer. In
    fact, after the function returns, you can't rely on any content of the
    buffer preceding the end of the string.</p>
<p class="Pp">If the string being scanned is not well formed (has no closing
    delimiter), <span class="Li">&quot;toke_scan_str&quot;</span> returns
    <span class="Li">&quot;undef&quot;</span>. In this case you cannot rely on
    the contents of the buffer.</p>
<p class="Pp"><span class="Li">&quot;get_lex_stuff&quot;</span></p>
<p class="Pp">This builtin returns what was matched by
    <span class="Li">&quot;toke_scan_str&quot;</span>. To avoid segfaults, you
    should call <span class="Li">&quot;clear_lex_stuff&quot;</span> immediately
    afterwards.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Munging_the_subroutine"><a class="permalink" href="#Munging_the_subroutine">Munging
  the subroutine</a></h2>
Let's look at what we need to do in detail.
<p class="Pp"><i></i><i>&quot;make_proto_unwrap&quot;</i><i></i></p>
<p class="Pp">We may have defined our method in different ways, which will
    result in a different value for our prototype, as parsed above. For
  example:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    method foo         {  # undefined
    method foo ()      {  # ''
    method foo ($arg1) {  # '$arg1'
</pre>
<p class="Pp">We deal with them as follows, and return the appropriate
    <span class="Li">&quot;my ($self, ...) = @_;&quot;</span> string.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    sub make_proto_unwrap {
      my ($proto) = @_;
      my $inject = 'my ($self';
      if (defined $proto) {
        $inject .= &quot;, $proto&quot; if length($proto);
        $inject .= ') = @_; ';
      } else {
        $inject .= ') = shift;';
      }
      return $inject;
    }
</pre>
<p class="Pp"><i></i><i>&quot;inject_if_block&quot;</i><i></i></p>
<p class="Pp">Now we need to inject it after the opening
    <span class="Li">'{'</span> of the method body. We can do this with the
    building blocks we defined above like
    <span class="Li">&quot;skipspace&quot;</span> and
    <span class="Li">&quot;get_linestr&quot;</span>.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    sub inject_if_block {
      my $inject = shift;
      skipspace;
      my $linestr = Devel::Declare::get_linestr;
      if (substr($linestr, $Offset, 1) eq '{') {
        substr($linestr, $Offset+1, 0) = $inject;
        Devel::Declare::set_linestr($linestr);
      }
    }
</pre>
<p class="Pp"><i></i><i>&quot;scope_injector_call&quot;</i><i></i></p>
<p class="Pp">We want to be able to handle both named and anonymous methods.
    i.e.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    method foo () { ... }
    my $meth = method () { ... };
</pre>
<p class="Pp">These will then get rewritten as</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    method { ... }
    my $meth = method { ... };
</pre>
<p class="Pp">where 'method' is a subroutine that takes a code block. Spot the
    problem? The first one doesn't have a semicolon at the end of it! Unlike
    'sub' which is a builtin, this is just a normal statement, so we need to
    terminate it. Luckily, using
    <span class="Li">&quot;B::Hooks::EndOfScope&quot;</span>, we can do
  this!</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  use B::Hooks::EndOfScope;
</pre>
<p class="Pp">We'll add this to what gets 'injected' at the beginning of the
    method source.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  sub scope_injector_call {
    return ' BEGIN { MethodHandlers::inject_scope }; ';
  }
</pre>
<p class="Pp">So at the beginning of every method, we are passing a callback
    that will get invoked at the <i>end</i> of the method's compilation... i.e.
    exactly then the closing <span class="Li">'}'</span> is compiled.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  sub inject_scope {
    on_scope_end {
      my $linestr = Devel::Declare::get_linestr;
      my $offset = Devel::Declare::get_linestr_offset;
      substr($linestr, $offset, 0) = ';';
      Devel::Declare::set_linestr($linestr);
    };
  }
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Shadowing_each_method."><a class="permalink" href="#Shadowing_each_method.">Shadowing
  each method.</a></h2>
<i></i><i>&quot;shadow&quot;</i><i></i>
<p class="Pp">We override the current definition of 'method' using
    <span class="Li">&quot;shadow&quot;</span>.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    sub shadow {
      my $pack = Devel::Declare::get_curstash_name;
      Devel::Declare::shadow_sub(&quot;${pack}::${Declarator}&quot;, $_[0]);
    }
</pre>
<p class="Pp">For a named method we invoked like this:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    shadow(sub (&amp;) { no strict 'refs'; *{$name} = shift; });
</pre>
<p class="Pp">So in the case of a <span class="Li">&quot;method foo { ...
    }&quot;</span>, this call would redefine
    <span class="Li">&quot;method&quot;</span> to be a subroutine that exports
    'sub foo' as the (munged) contents of
    <span class="Li">&quot;{...}&quot;</span>.</p>
<p class="Pp">The case of an anonymous method is also cute:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    shadow(sub (&amp;) { shift });
</pre>
<p class="Pp">This means that</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    my $meth = method () { ... };
</pre>
<p class="Pp">is rewritten with <span class="Li">&quot;method&quot;</span>
    taking the codeblock, and returning it as is to become the value of
    <span class="Li">$meth</span>.</p>
<p class="Pp"><span class="Li">&quot;get_curstash_name&quot;</span></p>
<p class="Pp">This returns the package name <i>currently being compiled</i>.</p>
<p class="Pp"><span class="Li">&quot;shadow_sub&quot;</span></p>
<p class="Pp">Handles the details of redefining the subroutine.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
One of the best ways to learn <span class="Li">&quot;Devel::Declare&quot;</span>
  is still to look at modules that use it:
<p class="Pp">&lt;http://cpants.perl.org/dist/used_by/Devel-Declare&gt;.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHORS"><a class="permalink" href="#AUTHORS">AUTHORS</a></h1>
Matt S Trout - &lt;mst@shadowcat.co.uk&gt; - original author
<p class="Pp">Company: http://www.shadowcat.co.uk/ Blog:
    http://chainsawblues.vox.com/</p>
<p class="Pp">Florian Ragwitz &lt;rafl@debian.org&gt; - maintainer</p>
<p class="Pp">osfameron &lt;osfameron@cpan.org&gt; - first draft of
    documentation</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT_AND_LICENSE"><a class="permalink" href="#COPYRIGHT_AND_LICENSE">COPYRIGHT
  AND LICENSE</a></h1>
This library is free software under the same terms as perl itself
<p class="Pp">Copyright (c) 2007, 2008, 2009 Matt S Trout</p>
<p class="Pp">Copyright (c) 2008, 2009 Florian Ragwitz</p>
<p class="Pp">stolen_chunk_of_toke.c based on toke.c from the perl core, which
    is</p>
<p class="Pp">Copyright (C) 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
    1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, by Larry Wall and others</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2020-04-26</td>
    <td class="foot-os">perl v5.28.2</td>
  </tr>
</table>
</body>
</html>
