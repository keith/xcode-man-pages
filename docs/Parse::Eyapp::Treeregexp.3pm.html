<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>Parse::Eyapp::Treeregexp(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Parse::Eyapp::Treeregexp(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Parse::Eyapp::Treeregexp(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
Parse::Eyapp::Treeregexp - Tree transformations
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<span class="Li"></span>
<pre>
  use strict;
  use Parse::Eyapp;
  use Parse::Eyapp::Treeregexp;

  my $grammar = q{
    %right  '='
    %left   '-' '+'
    %left   '*' '/'
    %left   NEG
    %tree
    %{
    use Tail2;  # See file examples/Tail2.pm in the distribution
    %}

    %%
    block:  exp &lt;%name BLOCK + ';'&gt; { $_[1] }
    ;

    exp:      %name NUM
                NUM
            | %name WHILE
                'while'   exp  '{' block '}'
            | %name VAR
                VAR
            | %name ASSIGN
                VAR '=' exp
            | %name PLUS
                exp '+' exp
            | %name MINUS
                exp '-' exp
            | %name TIMES
                exp '*' exp
            | %name DIV
                exp '/' exp
            | %name UMINUS
                '-' exp %prec NEG
            |   '(' exp ')'  { $_[2] } /* Let us simplify a bit the tree */
    ;

    %%
  }; # end grammar

  sub TERMINAL::info { $_[0]{attr} }
  $Parse::Eyapp::Node::INDENT = 2;

  our (@all,$moveinvariant, $condition, $assign, $before, $after);

  Parse::Eyapp-&gt;new_grammar(
    input=&gt;$grammar,
    classname=&gt;'Rule6',
    firstline=&gt;7,
  );
  my $parser = Rule6-&gt;new();
  my $program = &quot;a =1000; c = 1; while (a) { c = c*a; b = 5; a = a-1 }\n&quot;;
  my $t = $parser-&gt;Run(\$program);
  my @output = split /\n/, $t-&gt;str;

  my $p = Parse::Eyapp::Treeregexp-&gt;new( STRING =&gt; q{
    moveinvariant: BLOCK(
                     @prests,
                     WHILE(VAR($b), BLOCK(@a, ASSIGN($x, NUM($e)), @c)),
                     @possts
                   )
      =&gt; {
           my $assign = $ASSIGN;
           $BLOCK[1]-&gt;delete($ASSIGN);
           $BLOCK[0]-&gt;insert_before($WHILE, $assign);
         }
    },
  );
  $p-&gt;generate();
  $moveinvariant-&gt;s($t);
  my @output2 = split /\n/, $t-&gt;str;

  my ($node1, $node2);
  format STDOUT_TOP =
                          PROGRAM
  -------------------------------------------------------
  @||||||||||||||||||||||||||||||||||||||||||||||||||||||
  $program
  -------------------------------------------------------
  Before                     |    After
  ---------------------------|---------------------------
  .

  format STDOUT =
  @&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;@|@&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;
  $node1,                    '|',$node2
  .

  for (1..$#output) {
    $node1 = $output[$_];
    $node2 = $output2[$_];
    write;
  }
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="Introduction"><a class="permalink" href="#Introduction">Introduction</a></h1>
The example in the SYNOPSIS section uses
  <span class="Li">&quot;Parse::Eyapp&quot;</span> to build an abstract syntax
  tree for the program
<p class="Pp"><span class="Li"></span></p>
<pre>
  my $program = &quot;a =1000; c = 1; while (a) { c = c*a; b = 5; a = a-1 }\n&quot;;
</pre>
<p class="Pp">The tree is transformed using the transformation
    <span class="Li">&quot;moveinvariant&quot;</span>:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  my $p = Parse::Eyapp::Treeregexp-&gt;new( STRING =&gt; q{
    moveinvariant: BLOCK(
                     @prests,
                     WHILE(VAR($b), BLOCK(@a, ASSIGN($x, NUM($e)), @c)),
                     @possts
                   )
      =&gt; {
           my $assign = $ASSIGN;
           $BLOCK[1]-&gt;delete($ASSIGN);
           $BLOCK[0]-&gt;insert_before($WHILE, $assign);
         }
    },
  );
</pre>
<p class="Pp">The output shows the original tree versus the transformed
  tree:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  pl@nereida:~/LEyapp/examples$ moveinvariantoutofloopcomplexformula.pl
                          PROGRAM
  -------------------------------------------------------

  -------------------------------------------------------
  Before                     |    After
  ---------------------------|---------------------------
  BLOCK(                     | BLOCK(
    ASSIGN(                  |   ASSIGN(
      TERMINAL[a],           |     TERMINAL[a],
      NUM(                   |     NUM(
        TERMINAL[1000]       |       TERMINAL[1000]
      )                      |     )
    ) # ASSIGN,              |   ) # ASSIGN,
    ASSIGN(                  |   ASSIGN(
      TERMINAL[c],           |     TERMINAL[c],
      NUM(                   |     NUM(
        TERMINAL[1]          |       TERMINAL[1]
      )                      |     )
    ) # ASSIGN,              |   ) # ASSIGN,
    WHILE(                   |   ASSIGN(
      VAR(                   |     TERMINAL[b],
        TERMINAL[a]          |     NUM(
      ),                     |       TERMINAL[5]
      BLOCK(                 |     )
        ASSIGN(              |   ) # ASSIGN,
          TERMINAL[c],       |   WHILE(
          TIMES(             |     VAR(
            VAR(             |       TERMINAL[a]
              TERMINAL[c]    |     ),
            ),               |     BLOCK(
            VAR(             |       ASSIGN(
              TERMINAL[a]    |         TERMINAL[c],
            )                |         TIMES(
          ) # TIMES          |           VAR(
        ) # ASSIGN,          |             TERMINAL[c]
        ASSIGN(              |           ),
          TERMINAL[b],       |           VAR(
          NUM(               |             TERMINAL[a]
            TERMINAL[5]      |           )
          )                  |         ) # TIMES
        ) # ASSIGN,          |       ) # ASSIGN,
        ASSIGN(              |       ASSIGN(
          TERMINAL[a],       |         TERMINAL[a],
          MINUS(             |         MINUS(
            VAR(             |           VAR(
              TERMINAL[a]    |             TERMINAL[a]
            ),               |           ),
            NUM(             |           NUM(
              TERMINAL[1]    |             TERMINAL[1]
            )                |           )
          ) # MINUS          |         ) # MINUS
        ) # ASSIGN           |       ) # ASSIGN
      ) # BLOCK              |     ) # BLOCK
    ) # WHILE                |   ) # WHILE
  ) # BLOCK                  | ) # BLOCK
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="The_Treeregexp_Language"><a class="permalink" href="#The_Treeregexp_Language">The
  Treeregexp Language</a></h1>
A Treeregexp program is made of the repetition of three kind of primitives: The
  treeregexp transformations, supporting Perl code and Transformation Families.
<p class="Pp"><span class="Li"></span></p>
<pre>
  treeregexplist:  treeregexp* 

  treeregexp: 
      IDENT ':' treereg ('=&gt;' CODE)?  # Treeregexp 
    | CODE                            # Auxiliar code
    | IDENT '=' IDENT + ';'           # Transformation families
</pre>
<p class="Pp">Treeregexp themselves follow the rule:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
                  IDENT ':' treereg ('=&gt;' CODE)?
</pre>
<p class="Pp">Several instances of this rule can be seen in the example in the
    &quot;SYNOPSIS&quot; section. The identifier
    <span class="Li">&quot;IDENT&quot;</span> gives the name to the rule. At the
    time of this writing (2006) there are the following kinds of
  treeregexes:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  treereg: 
        /* tree patterns with children */
      IDENT '(' childlist ')' ('and' CODE)? 
    | REGEXP (':' IDENT)? '(' childlist ')' ('and' CODE)? 
    | SCALAR '(' childlist ')' ('and' CODE)?  
    | '.' '(' childlist ')' ('and' CODE)? 
          /* leaf tree patterns */
    | IDENT ('and' CODE)? 
    | REGEXP (':' IDENT)? ('and' CODE)? 
    | '.' ('and' CODE)? 
    | SCALAR ('and' CODE)? 
    | ARRAY 
    | '*'
</pre>
<section class="Ss">
<h2 class="Ss" id="Treeregexp_rules"><a class="permalink" href="#Treeregexp_rules">Treeregexp
  rules</a></h2>
When seen a rule like
<p class="Pp"><span class="Li"></span></p>
<pre>
    zero_times: TIMES(NUM($x), ., .) and { $x-&gt;{attr} == 0 } =&gt; { $_[0] = $NUM }
</pre>
<p class="Pp">The Treeregexp translator creates a
    <span class="Li">&quot;Parse::Eyapp:YATW&quot;</span> object that can be
    later referenced in the user code by the package variable
    <span class="Li">$zero_times</span>.</p>
<p class="Pp"><i>The treeregexp</i></p>
<p class="Pp">The first part of the rule <span class="Li">&quot;TIMES(NUM($x),
    ., .)&quot;</span> indicates that for a matching to succeed the node being
    visited must be of <span class="Li">&quot;type&quot;</span>
    <span class="Li">&quot;TIMES&quot;</span>, have a left child of
    <span class="Li">&quot;type&quot;</span>
    <span class="Li">&quot;NUM&quot;</span> and two more children.</p>
<p class="Pp">If the first part succeeded then the following part takes the
    control to see if the <i>semantic conditions</i> are satisfied.</p>
<p class="Pp"><i>Semantic condition</i></p>
<p class="Pp">The second part is optional and must be prefixed by the reserved
    word <span class="Li">&quot;and&quot;</span> followed by a Perl code
    manifesting the semantic conditions that must be hold by the node to
    succeed. Thus, in the example:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  zero_times: TIMES(NUM($x), ., .) and { $x-&gt;{attr} == 0 } =&gt; { $_[0] = $NUM }
</pre>
<p class="Pp">the semantic condition <span class="Li">&quot;$x-&gt;{attr} ==
    0&quot;</span> states that the value of the number stored in the
    <span class="Li">&quot;TERMINAL&quot;</span> node referenced by
    <span class="Li">$x</span> must be zero.</p>
<p class="Pp"><i>Referencing the matching nodes</i></p>
<p class="Pp">The node being visited can be referenced/modified inside the
    semantic actions using <span class="Li">$_[0]</span>.</p>
<p class="Pp">The Treeregexp translator automatically creates a set of lexical
    variables for us. The scope of these variables is limited to the semantic
    condition and the transformation code.</p>
<p class="Pp">Thus, in the example</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  zero_times: TIMES(NUM($x), ., .) and { $x-&gt;{attr} == 0 } =&gt; { $_[0] = $NUM }
</pre>
<p class="Pp">the node being visited <span class="Li">$_[0]</span> can be also
    referenced using the lexical variable <span class="Li">$TIMES</span> which
    is created by he Treeregexp compiler. In the same way a reference to the
    left child <span class="Li">&quot;NUM&quot;</span> will be stored in the
    lexical variable <span class="Li">$NUM</span> and a reference to the child
    of <span class="Li">$NUM</span> will be stored in
    <span class="Li">$x</span>. The semantic condition states that the attribute
    of the node associated with <span class="Li">$x</span> must be zero.</p>
<p class="Pp">When the same type of node appears several times inside the
    treeregexp part the associated lexical variable is declared by the
    Treeregexp compiler as an array. This is the case in the
    <span class="Li">&quot;constantfold&quot;</span> transformation in the
    &quot;SYNOPSIS&quot; example, where there are two nodes of type
    <span class="Li">&quot;NUM&quot;</span>:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  constantfold: /TIMES|PLUS|DIV|MINUS/(NUM($x), ., NUM($y))
     =&gt; {
    $x-&gt;{attr} = eval  &quot;$x-&gt;{attr} $W-&gt;{attr} $y-&gt;{attr}&quot;;
    $_[0] = $NUM[0];
  }
</pre>
<p class="Pp">Thus variable <span class="Li">$NUM[0]</span> references the node
    that matches the first <span class="Li">&quot;NUM&quot;</span> term in the
    formula and <span class="Li">$NUM[1]</span> the one that matches the
  second.</p>
<p class="Pp"><i>Transformation code</i></p>
<p class="Pp">The third part of the rule is also optional and comes prefixed by
    the big arrow <span class="Li">&quot;=&gt;&quot;</span>. The Perl code in
    this section usually transforms the matching tree. To achieve the
    modification of the tree, the Treeregexp programmer <b>must use
    </b><b>$_[0]</b> <b></b> and not the lexical variables provided by the
    translator. Remember that in Perl <span class="Li">$_[0]</span> is an alias
    of the actual parameter. The
    <span class="Li">&quot;constantfold&quot;</span> example above <b>will not
    work</b> if we rewrite the code <span class="Li">$_[0] = $NUM[0]</span>
  as</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
                            { $TIMES = $NUM }
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Regexp_Treeregexes"><a class="permalink" href="#Regexp_Treeregexes">Regexp
  Treeregexes</a></h2>
The previous <span class="Li">&quot;constantfold&quot;</span> example used a
  classic Perl linear regexp to explicit that the root node of the matching
  subtree must match the Perl regexp. The general syntax for
  <span class="Li">&quot;REGEXP&quot;</span> treeregexes patterns is:
<p class="Pp"><span class="Li"></span></p>
<pre>
      treereg: REGEXP (':' IDENT)? '(' childlist ')' ('and' CODE)?
</pre>
<p class="Pp">The <span class="Li">&quot;REGEXP&quot;</span> must be specified
    between slashes (other delimiters as <span class="Li">&quot;{}&quot;</span>
    are not accepted). It is legal to specify options after the second slash
    (like <span class="Li">&quot;e&quot;</span>,
    <span class="Li">&quot;i&quot;</span>, etc.).</p>
<p class="Pp">The operation of string oriented regexps is slightly modified when
    they are used inside a treeregexp: <b>by default the option</b>
    <span class="Li">&quot;x&quot;</span> <b>will be assumed</b>. The treeregexp
    compiler will automatically insert it. Use the new option
    <span class="Li">&quot;X&quot;</span> (upper case X) if you want to suppress
    such behavior. <b>There is no need also to insert</b>
    <span class="Li">&quot;\b&quot;</span> <b>word anchors</b> to delimit
    identifiers: all the identifiers in a regexp treeregexp are automatically
    surrounded by <span class="Li">&quot;\b&quot;</span>. Use the option
    <span class="Li">&quot;B&quot;</span> (upper case B) to suppress this
    behavior.</p>
<p class="Pp">The optional identifier after the
    <span class="Li">&quot;REGEXP&quot;</span> indicates the name of the lexical
    variable that will be held a reference to the node whose type matches
    <span class="Li">&quot;REGEXP&quot;</span>. Variable
    <span class="Li">$W</span> (or <span class="Li">@W</span> if there are more
    than one REGEXP and or dot treeregexes) will be used instead if no
    identifier is specified.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Scalar_Treeregexes"><a class="permalink" href="#Scalar_Treeregexes">Scalar
  Treeregexes</a></h2>
A scalar treeregxp is defined writing a Perl scalar inside the treeregexp, like
  <span class="Li">$x</span> in <span class="Li">&quot;NUM($x)&quot;</span>. A
  scalar treeregxp immediately matches any node that exists and stores a
  reference to such node inside the Perl lexical scalar variable. The scope of
  the variable is limited to the semantic parts of the Treeregexp. Is illegal to
  use <span class="Li">$W</span> or <span class="Li">&quot;$W_#num&quot;</span>
  as variable names for scalar treeregexes.
</section>
<section class="Ss">
<h2 class="Ss" id="Dot_Treeregexes"><a class="permalink" href="#Dot_Treeregexes">Dot
  Treeregexes</a></h2>
A dot matches any node. It can be seen as an abbreviation for scalar
  treeregexes. The reference to the matching node is stored in the lexical
  variable <span class="Li">$W</span>. The variable <span class="Li">@W</span>
  will be used instead if there are more than one REGEXP and or dot treeregexes
</section>
<section class="Ss">
<h2 class="Ss" id="Array_Treeregexp_Expressions"><a class="permalink" href="#Array_Treeregexp_Expressions">Array
  Treeregexp Expressions</a></h2>
The Treeregexp language permits expressions like:
<p class="Pp"><span class="Li"></span></p>
<pre>
                   A(@a,B($x),@c)
</pre>
<p class="Pp">After the matching variable <span class="Li">@A</span> contains
    the shortest prefix of <span class="Li">&quot;$A-&gt;children&quot;</span>
    that does not match <span class="Li">&quot;B($x)&quot;</span>. The variable
    <span class="Li">@c</span> contains the remaining suffix of
   <span class="Li">&quot;$A-&gt;children&quot;</span>.</p>
<p class="Pp">The following example uses array treereg expressions to move the
    assignment <span class="Li">&quot;b = 5&quot;</span> out of the
    <span class="Li">&quot;while&quot;</span> loop:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  ..  ......................................................................
  93  my $program = &quot;a =1000; c = 1; while (a) { c = c*a; b = 5; a = a-1 }\n&quot;;
  94  $parser-&gt;YYData-&gt;{INPUT} = $program;
  95  my $t = $parser-&gt;Run;
  96  my @output = split /\n/, $t-&gt;str;
  97
  98  my $p = Parse::Eyapp::Treeregexp-&gt;new( STRING =&gt; q{
  99    moveinvariant: BLOCK(
 100                     @prests,
 101                     WHILE(VAR($b), BLOCK(@a, ASSIGN($x, NUM($e)), @c)),
 102                     @possts
 103                   )
 104      =&gt; {
 105           my $assign = $ASSIGN;
 106           $BLOCK[1]-&gt;delete($ASSIGN);
 107           $BLOCK[0]-&gt;insert_before($WHILE, $assign);
 108         }
 109    },
 110    FIRSTLINE =&gt; 99,
 111  );
 112  $p-&gt;generate();
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Star_Treeregexp"><a class="permalink" href="#Star_Treeregexp">Star
  Treeregexp</a></h2>
Deprecated. Don't use it. Is still there but not to endure.
</section>
<section class="Ss">
<h2 class="Ss" id="Transformation_Families"><a class="permalink" href="#Transformation_Families">Transformation
  Families</a></h2>
Transformations created by
  <span class="Li">&quot;Parse::Eyapp::Treeregexp&quot;</span> can be grouped in
  families. That is the function of the rule:
<p class="Pp"><span class="Li"></span></p>
<pre>
                    treeregexp: IDENT '=' IDENT + ';'
</pre>
<p class="Pp">The next example (file
    <span class="Li">&quot;examples/TSwithtreetransformations3.eyp&quot;</span>)
    defines the family</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
     algebraic_transformations = constantfold zero_times times_zero comasocfold;
</pre>
<p class="Pp">Follows the code:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
     my $transform = Parse::Eyapp::Treeregexp-&gt;new( STRING =&gt; q{

      uminus: UMINUS(., NUM($x), .) =&gt; { $x-&gt;{attr} = -$x-&gt;{attr}; $_[0] = $NUM }
      constantfold: /TIMES|PLUS|DIV|MINUS/:bin(NUM($z), ., NUM($y))
         =&gt; {
        $z-&gt;{attr} = eval  &quot;$z-&gt;{attr} $W-&gt;{attr} $y-&gt;{attr}&quot;;
        $_[0] = $NUM[0];
      }
      commutative_add: PLUS($x, ., $y, .)
        =&gt; { my $t = $x; $_[0]-&gt;child(0, $y); $_[0]-&gt;child(2, $t)}
      comasocfold: TIMES(DIV(NUM($x), ., $b), ., NUM($y))
         =&gt; {
        $x-&gt;{attr} = $x-&gt;{attr} * $y-&gt;{attr};
        $_[0] = $DIV;
      }
      zero_times: TIMES(NUM($x), ., .) and { $x-&gt;{attr} == 0 } =&gt; { $_[0] = $NUM }
      times_zero: TIMES(., ., NUM($x)) and { $x-&gt;{attr} == 0 } =&gt; { $_[0] = $NUM }
      algebraic_transformations = constantfold zero_times times_zero comasocfold;
    },
    );

    $transform-&gt;generate();
    our ($uminus);
    $uminus-&gt;s($tree);
</pre>
<p class="Pp">The transformations belonging to a family are usually applied
    together:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
                $tree-&gt;s(@algebraic_transformations);
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Code_Support"><a class="permalink" href="#Code_Support">Code
  Support</a></h2>
In between Treeregexp rules and family assignments the programmer can insert
  Perl code between curly brackets. That code usually gives support to the
  semantic conditions and transformations inside the rules. See for example test
  14 in the <span class="Li">&quot;t/&quot;</span> directory of the Parse::Eyapp
  distribution.
<p class="Pp"><span class="Li"></span></p>
<pre>
  {
    sub not_semantic {
      my $self = shift;
      return  1 if $self-&gt;{token} eq $self-&gt;{attr};
      return 0;
    }
  }

  delete_tokens : TERMINAL and { not_semantic($TERMINAL) } 
                           =&gt; { $delete_tokens-&gt;delete() }
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<ul class="Bl-bullet">
  <li>The project home is at &lt;http://code.google.com/p/parse-eyapp/&gt;. Use
      a subversion client to anonymously check out the latest project source
      code:
    <p class="Pp"><span class="Li"></span></p>
    <pre>
   svn checkout http://parse-eyapp.googlecode.com/svn/trunk/ parse-eyapp-read-only
    </pre>
  </li>
  <li>The tutorial <i>Parsing Strings and Trees with</i>
      <span class="Li">&quot;Parse::Eyapp&quot;</span> (An Introduction to
      Compiler Construction in seven pages) in
      &lt;http://nereida.deioc.ull.es/~pl/eyapsimple/&gt;</li>
  <li>Parse::Eyapp, Parse::Eyapp::eyapplanguageref, Parse::Eyapp::debuggingtut,
      Parse::Eyapp::defaultactionsintro, Parse::Eyapp::translationschemestut,
      Parse::Eyapp::Driver, Parse::Eyapp::Node, Parse::Eyapp::YATW,
      Parse::Eyapp::Treeregexp, Parse::Eyapp::Scope, Parse::Eyapp::Base,
      Parse::Eyapp::datagenerationtut</li>
  <li>The pdf file in
      &lt;http://nereida.deioc.ull.es/~pl/perlexamples/languageintro.pdf&gt;</li>
  <li>The pdf file in
      &lt;http://nereida.deioc.ull.es/~pl/perlexamples/debuggingtut.pdf&gt;</li>
  <li>The pdf file in
      &lt;http://nereida.deioc.ull.es/~pl/perlexamples/eyapplanguageref.pdf&gt;</li>
  <li>The pdf file in
      &lt;http://nereida.deioc.ull.es/~pl/perlexamples/Treeregexp.pdf&gt;</li>
  <li>The pdf file in
      &lt;http://nereida.deioc.ull.es/~pl/perlexamples/Node.pdf&gt;</li>
  <li>The pdf file in
      &lt;http://nereida.deioc.ull.es/~pl/perlexamples/YATW.pdf&gt;</li>
  <li>The pdf file in
      &lt;http://nereida.deioc.ull.es/~pl/perlexamples/Eyapp.pdf&gt;</li>
  <li>The pdf file in
      &lt;http://nereida.deioc.ull.es/~pl/perlexamples/Base.pdf&gt;</li>
  <li>The pdf file in
      &lt;http://nereida.deioc.ull.es/~pl/perlexamples/translationschemestut.pdf&gt;</li>
  <li>The pdf file in
      &lt;http://nereida.deioc.ull.es/~pl/perlexamples/treematchingtut.pdf&gt;</li>
  <li>perldoc eyapp,</li>
  <li>perldoc treereg,</li>
  <li>perldoc vgg,</li>
  <li>The Syntax Highlight file for vim at
      &lt;http://www.vim.org/scripts/script.php?script_id=2453&gt; and
      &lt;http://nereida.deioc.ull.es/~vim/&gt;</li>
  <li><i>Analisis Lexico y Sintactico</i>, (Notes for a course in compiler
      construction) by Casiano Rodriguez-Leon. Available at
      &lt;http://nereida.deioc.ull.es/~pl/perlexamples/&gt; Is the more complete
      and reliable source for Parse::Eyapp. However is in Spanish.</li>
  <li>Parse::Yapp,</li>
  <li>Man pages of <i>yacc</i>(1) and <i>bison</i>(1),
      &lt;http://www.delorie.com/gnu/docs/bison/bison.html&gt;</li>
  <li>Language::AttributeGrammar</li>
  <li>Parse::RecDescent.</li>
  <li>HOP::Parser</li>
  <li>HOP::Lexer</li>
  <li>ocamlyacc tutorial at
      &lt;http://plus.kaist.ac.kr/~shoh/ocaml/ocamllex-ocamlyacc/ocamlyacc-tutorial/ocamlyacc-tutorial.html&gt;</li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="REFERENCES"><a class="permalink" href="#REFERENCES">REFERENCES</a></h1>
<ul class="Bl-bullet">
  <li>The classic Dragon's book <i>Compilers: Principles, Techniques, and
      Tools</i> by Alfred V. Aho, Ravi Sethi and Jeffrey D. Ullman
      (Addison-Wesley 1986)</li>
  <li><i>CS2121: The Implementation and Power of Programming Languages</i> (See
      &lt;http://www.cs.man.ac.uk/~pjj&gt;,
      &lt;http://www.cs.man.ac.uk/~pjj/complang/g2lr.html&gt; and
      &lt;http://www.cs.man.ac.uk/~pjj/cs2121/ho/ho.html&gt;) by Pete Jinks</li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="CONTRIBUTORS"><a class="permalink" href="#CONTRIBUTORS">CONTRIBUTORS</a></h1>
<ul class="Bl-bullet">
  <li>Hal Finkel &lt;http://www.halssoftware.com/&gt;</li>
  <li>G. Williams &lt;http://kasei.us/&gt;</li>
  <li>Thomas L. Shinnick &lt;http://search.cpan.org/~tshinnic/&gt;</li>
  <li>Frank Leray</li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
Casiano Rodriguez-Leon (casiano@ull.es)
</section>
<section class="Sh">
<h1 class="Sh" id="ACKNOWLEDGMENTS"><a class="permalink" href="#ACKNOWLEDGMENTS">ACKNOWLEDGMENTS</a></h1>
This work has been supported by CEE (FEDER) and the Spanish Ministry of
  <i>Educacion y Ciencia</i> through <i>Plan Nacional I+D+I</i> number
  TIN2005-08818-C04-04 (ULL::OPLINK project &lt;http://www.oplink.ull.es/&gt;).
  Support from Gobierno de Canarias was through GC02210601 (<i>Grupos
  Consolidados</i>). The University of La Laguna has also supported my work in
  many ways and for many years.
<p class="Pp">A large percentage of code is verbatim taken from Parse::Yapp
    1.05. The author of Parse::Yapp is Francois Desarmenien.</p>
<p class="Pp">I wish to thank Francois Desarmenien for his Parse::Yapp module,
    to my students at La Laguna and to the Perl Community. Thanks to the people
    who have contributed to improve the module (see &quot;CONTRIBUTORS&quot; in
    Parse::Eyapp). Thanks to Larry Wall for giving us Perl. Special thanks to
    Juana.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="LICENCE_AND_COPYRIGHT"><a class="permalink" href="#LICENCE_AND_COPYRIGHT">LICENCE
  AND COPYRIGHT</a></h1>
Copyright (c) 2006-2008 Casiano Rodriguez-Leon (casiano@ull.es). All rights
  reserved.
<p class="Pp">Parse::Yapp copyright is of Francois Desarmenien, all rights
    reserved. 1998-2001</p>
<p class="Pp">These modules are free software; you can redistribute it and/or
    modify it under the same terms as Perl itself. See perlartistic.</p>
<p class="Pp">This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. </p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2012-03-23</td>
    <td class="foot-os">perl v5.18.4</td>
  </tr>
</table>
</body>
</html>
