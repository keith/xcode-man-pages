<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    .Nd, .Bf, .Op { display: inline; }
    .Pa, .Ad { font-style: italic; }
    .Ms { font-weight: bold; }
    .Bl-diag > dt { font-weight: bold; }
    code.Nm, .Fl, .Cm, .Ic, code.In, .Fd, .Fn, .Cd { font-weight: bold;
      font-family: inherit; }
  </style>
  <title>HTTP::Request::Common(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">HTTP::Request::Common(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">HTTP::Request::Common(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">HTTP::Request::Common - Construct common HTTP::Request objects</p>
</section>
<section class="Sh">
<h1 class="Sh" id="VERSION"><a class="permalink" href="#VERSION">VERSION</a></h1>
<p class="Pp">version 6.22</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>  use HTTP::Request::Common;
  $ua = LWP::UserAgent-&gt;new;
  $ua-&gt;request(GET 'http://www.sn.no/');
  $ua-&gt;request(POST 'http://somewhere/foo', [foo =&gt; bar, bar =&gt; foo]);
  $ua-&gt;request(PATCH 'http://somewhere/foo', [foo =&gt; bar, bar =&gt; foo]);
  $ua-&gt;request(PUT 'http://somewhere/foo', [foo =&gt; bar, bar =&gt; foo]);
  $ua-&gt;request(OPTIONS 'http://somewhere/foo', [foo =&gt; bar, bar =&gt; foo]);
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">This module provides functions that return newly created
    <span class="Li">&quot;HTTP::Request&quot;</span> objects. These functions
    are usually more convenient to use than the standard
    <span class="Li">&quot;HTTP::Request&quot;</span> constructor for the most
    common requests.</p>
<p class="Pp">Note that LWP::UserAgent has several convenience methods,
    including <span class="Li">&quot;get&quot;</span>,
    <span class="Li">&quot;head&quot;</span>,
    <span class="Li">&quot;delete&quot;</span>,
    <span class="Li">&quot;post&quot;</span> and
    <span class="Li">&quot;put&quot;</span>.</p>
<p class="Pp">The following functions are provided:</p>
<dl class="Bl-tag">
  <dt id="GET"><a class="permalink" href="#GET">GET $url</a></dt>
  <dd></dd>
  <dt id="GET~2"><a class="permalink" href="#GET~2">GET $url, Header =&gt;
    Value,...</a></dt>
  <dd>The <span class="Li">&quot;GET&quot;</span> function returns an
      HTTP::Request object initialized with the &quot;GET&quot; method and the
      specified URL. It is roughly equivalent to the following call
    <p class="Pp"></p>
    <pre>  HTTP::Request-&gt;new(
     GET =&gt; $url,
     HTTP::Headers-&gt;new(Header =&gt; Value,...),
  )
    </pre>
    <p class="Pp">but is less cluttered. What is different is that a header
        named <span class="Li">&quot;Content&quot;</span> will initialize the
        content part of the request instead of setting a header field. Note that
        GET requests should normally not have a content, so this hack makes more
        sense for the <span class="Li">&quot;PUT&quot;</span>,
        <span class="Li">&quot;PATCH&quot;</span>
      <br/>
       and <span class="Li">&quot;POST&quot;</span> functions described
      below.</p>
    <p class="Pp">The <span class="Li">&quot;get(...)&quot;</span> method of
        LWP::UserAgent exists as a shortcut for
        <span class="Li">&quot;$ua-&gt;request(GET ...)&quot;</span>.</p>
  </dd>
  <dt id="HEAD"><a class="permalink" href="#HEAD">HEAD $url</a></dt>
  <dd></dd>
  <dt id="HEAD~2"><a class="permalink" href="#HEAD~2">HEAD $url, Header =&gt;
    Value,...</a></dt>
  <dd>Like <b>GET()</b> but the method in the request is &quot;HEAD&quot;.
    <p class="Pp">The <span class="Li">&quot;head(...)&quot;</span> method of
        LWP::UserAgent exists as a shortcut for
        <span class="Li">&quot;$ua-&gt;request(HEAD ...)&quot;</span>.</p>
  </dd>
  <dt id="DELETE"><a class="permalink" href="#DELETE">DELETE $url</a></dt>
  <dd></dd>
  <dt id="DELETE~2"><a class="permalink" href="#DELETE~2">DELETE $url, Header
    =&gt; Value,...</a></dt>
  <dd>Like <span class="Li">&quot;GET&quot;</span> but the method in the request
      is <span class="Li">&quot;DELETE&quot;</span>. This function is not
      exported by default.</dd>
  <dt id="PATCH"><a class="permalink" href="#PATCH">PATCH $url</a></dt>
  <dd></dd>
  <dt id="PATCH~2"><a class="permalink" href="#PATCH~2">PATCH $url, Header =&gt;
    Value,...</a></dt>
  <dd></dd>
  <dt id="PATCH~3"><a class="permalink" href="#PATCH~3">PATCH $url, $form_ref,
    Header =&gt; Value,...</a></dt>
  <dd></dd>
  <dt id="PATCH~4"><a class="permalink" href="#PATCH~4">PATCH $url, Header =&gt;
    Value,..., Content =&gt; $form_ref</a></dt>
  <dd></dd>
  <dt id="PATCH~5"><a class="permalink" href="#PATCH~5">PATCH $url, Header =&gt;
    Value,..., Content =&gt; $content</a></dt>
  <dd>The same as <span class="Li">&quot;POST&quot;</span> below, but the method
      in the request is <span class="Li">&quot;PATCH&quot;</span>.</dd>
  <dt id="PUT"><a class="permalink" href="#PUT">PUT $url</a></dt>
  <dd></dd>
  <dt id="PUT~2"><a class="permalink" href="#PUT~2">PUT $url, Header =&gt;
    Value,...</a></dt>
  <dd></dd>
  <dt id="PUT~3"><a class="permalink" href="#PUT~3">PUT $url, $form_ref, Header
    =&gt; Value,...</a></dt>
  <dd></dd>
  <dt id="PUT~4"><a class="permalink" href="#PUT~4">PUT $url, Header =&gt;
    Value,..., Content =&gt; $form_ref</a></dt>
  <dd></dd>
  <dt id="PUT~5"><a class="permalink" href="#PUT~5">PUT $url, Header =&gt;
    Value,..., Content =&gt; $content</a></dt>
  <dd>The same as <span class="Li">&quot;POST&quot;</span> below, but the method
      in the request is <span class="Li">&quot;PUT&quot;</span></dd>
  <dt id="OPTIONS"><a class="permalink" href="#OPTIONS">OPTIONS $url</a></dt>
  <dd></dd>
  <dt id="OPTIONS~2"><a class="permalink" href="#OPTIONS~2">OPTIONS $url, Header
    =&gt; Value,...</a></dt>
  <dd></dd>
  <dt id="OPTIONS~3"><a class="permalink" href="#OPTIONS~3">OPTIONS $url,
    $form_ref, Header =&gt; Value,...</a></dt>
  <dd></dd>
  <dt id="OPTIONS~4"><a class="permalink" href="#OPTIONS~4">OPTIONS $url, Header
    =&gt; Value,..., Content =&gt; $form_ref</a></dt>
  <dd></dd>
  <dt id="OPTIONS~5"><a class="permalink" href="#OPTIONS~5">OPTIONS $url, Header
    =&gt; Value,..., Content =&gt; $content</a></dt>
  <dd>The same as <span class="Li">&quot;POST&quot;</span> below, but the method
      in the request is <span class="Li">&quot;OPTIONS&quot;</span></dd>
  <dt id="POST"><a class="permalink" href="#POST">POST $url</a></dt>
  <dd></dd>
  <dt id="POST~2"><a class="permalink" href="#POST~2">POST $url, Header =&gt;
    Value,...</a></dt>
  <dd></dd>
  <dt id="POST~3"><a class="permalink" href="#POST~3">POST $url, $form_ref,
    Header =&gt; Value,...</a></dt>
  <dd></dd>
  <dt id="POST~4"><a class="permalink" href="#POST~4">POST $url, Header =&gt;
    Value,..., Content =&gt; $form_ref</a></dt>
  <dd></dd>
  <dt id="POST~5"><a class="permalink" href="#POST~5">POST $url, Header =&gt;
    Value,..., Content =&gt; $content</a></dt>
  <dd><span class="Li">&quot;POST&quot;</span>,
      <span class="Li">&quot;PATCH&quot;</span> and
      <span class="Li">&quot;PUT&quot;</span> all work with the same parameters.
    <p class="Pp"></p>
    <pre>  %data = ( title =&gt; 'something', body =&gt; something else' );
  $ua = LWP::UserAgent-&gt;new();
  $request = HTTP::Request::Common::POST( $url, [ %data ] );
  $response = $ua-&gt;request($request);
    </pre>
    <p class="Pp">They take a second optional array or hash reference parameter
        <span class="Li">$form_ref</span>. The content can also be specified
        directly using the <span class="Li">&quot;Content&quot;</span>
        pseudo-header, and you may also provide the
        <span class="Li">$form_ref</span> this way.</p>
    <p class="Pp">The <span class="Li">&quot;Content&quot;</span> pseudo-header
        steals a bit of the header field namespace as there is no way to
        directly specify a header that is actually called &quot;Content&quot;.
        If you really need this you must update the request returned in a
        separate statement.</p>
    <p class="Pp">The <span class="Li">$form_ref</span> argument can be used to
        pass key/value pairs for the form content. By default we will initialize
        a request using the
        <span class="Li">&quot;application/x-www-form-urlencoded&quot;</span>
        content type. This means that you can emulate an HTML &lt;form&gt;
        POSTing like this:</p>
    <p class="Pp"></p>
    <pre>  POST 'http://www.perl.org/survey.cgi',
       [ name   =&gt; 'Gisle Aas',
         email  =&gt; 'gisle@aas.no',
         gender =&gt; 'M',
         born   =&gt; '1964',
         perc   =&gt; '3%',
       ];
    </pre>
    <p class="Pp">This will create an HTTP::Request object that looks like
      this:</p>
    <p class="Pp"></p>
    <pre>  POST http://www.perl.org/survey.cgi
  Content-Length: 66
  Content-Type: application/x-www-form-urlencoded
  name=Gisle%20Aas&amp;email=gisle%40aas.no&amp;gender=M&amp;born=1964&amp;perc=3%25
    </pre>
    <p class="Pp">Multivalued form fields can be specified by either repeating
        the field name or by passing the value as an array reference.</p>
    <p class="Pp">The POST method also supports the
        <span class="Li">&quot;multipart/form-data&quot;</span> content used for
        <i>Form-based File Upload</i> as specified in RFC 1867. You trigger this
        content format by specifying a content type of
        <span class="Li">'form-data'</span> as one of the request headers. If
        one of the values in the <span class="Li">$form_ref</span> is an array
        reference, then it is treated as a file part specification with the
        following interpretation:</p>
    <p class="Pp"></p>
    <pre>  [ $file, $filename, Header =&gt; Value... ]
  [ undef, $filename, Header =&gt; Value,..., Content =&gt; $content ]
    </pre>
    <p class="Pp">The first value in the array ($file) is the name of a file to
        open. This file will be read and its content placed in the request. The
        routine will croak if the file can't be opened. Use an
        <span class="Li">&quot;undef&quot;</span> as
        <span class="Li">$file</span> value if you want to specify the content
        directly with a <span class="Li">&quot;Content&quot;</span> header. The
        <span class="Li">$filename</span> is the filename to report in the
        request. If this value is undefined, then the basename of the
        <span class="Li">$file</span> will be used. You can specify an empty
        string as <span class="Li">$filename</span> if you want to suppress
        sending the filename when you provide a <span class="Li">$file</span>
        value.</p>
    <p class="Pp">If a <span class="Li">$file</span> is provided by no
        <span class="Li">&quot;Content-Type&quot;</span> header, then
        <span class="Li">&quot;Content-Type&quot;</span> and
        <span class="Li">&quot;Content-Encoding&quot;</span> will be filled in
        automatically with the values returned by
        <span class="Li">&quot;LWP::MediaTypes::guess_media_type()&quot;</span></p>
    <p class="Pp">Sending my <i>~/.profile</i> to the survey used as example
        above can be achieved by this:</p>
    <p class="Pp"></p>
    <pre>  POST 'http://www.perl.org/survey.cgi',
       Content_Type =&gt; 'form-data',
       Content      =&gt; [ name  =&gt; 'Gisle Aas',
                         email =&gt; 'gisle@aas.no',
                         gender =&gt; 'M',
                         born   =&gt; '1964',
                         init   =&gt; [&quot;$ENV{HOME}/.profile&quot;],
                       ]
    </pre>
    <p class="Pp">This will create an HTTP::Request object that almost looks
        this (the boundary and the content of your <i>~/.profile</i> is likely
        to be different):</p>
    <p class="Pp"></p>
    <pre>  POST http://www.perl.org/survey.cgi
  Content-Length: 388
  Content-Type: multipart/form-data; boundary=&quot;6G+f&quot;
  --6G+f
  Content-Disposition: form-data; name=&quot;name&quot;
  Gisle Aas
  --6G+f
  Content-Disposition: form-data; name=&quot;email&quot;
  gisle@aas.no
  --6G+f
  Content-Disposition: form-data; name=&quot;gender&quot;
  M
  --6G+f
  Content-Disposition: form-data; name=&quot;born&quot;
  1964
  --6G+f
  Content-Disposition: form-data; name=&quot;init&quot;; filename=&quot;.profile&quot;
  Content-Type: text/plain
  PATH=/local/perl/bin:$PATH
  export PATH
  --6G+f--
    </pre>
    <p class="Pp">If you set the <span class="Li">$DYNAMIC_FILE_UPLOAD</span>
        variable (exportable) to some TRUE value, then you get back a request
        object with a subroutine closure as the content attribute. This
        subroutine will read the content of any files on demand and return it in
        suitable chunks. This allow you to upload arbitrary big files without
        using lots of memory. You can even upload infinite files like
        <i>/dev/audio</i> if you wish; however, if the file is not a plain file,
        there will be no <span class="Li">&quot;Content-Length&quot;</span>
        header defined for the request. Not all servers (or server applications)
        like this. Also, if the file(s) change in size between the time the
        <span class="Li">&quot;Content-Length&quot;</span> is calculated and the
        time that the last chunk is delivered, the subroutine will
        <span class="Li">&quot;Croak&quot;</span>.</p>
    <p class="Pp">The <span class="Li">&quot;post(...)&quot;</span> method of
        LWP::UserAgent exists as a shortcut for
        <span class="Li">&quot;$ua-&gt;request(POST ...)&quot;</span>.</p>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp">HTTP::Request, LWP::UserAgent</p>
<p class="Pp">Also, there are some examples in &quot;EXAMPLES&quot; in
    HTTP::Request that you might find useful. For example, batch requests are
    explained there.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">Gisle Aas &lt;gisle@activestate.com&gt;</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT_AND_LICENSE"><a class="permalink" href="#COPYRIGHT_AND_LICENSE">COPYRIGHT
  AND LICENSE</a></h1>
<p class="Pp">This software is copyright (c) 1994-2017 by Gisle Aas.</p>
<p class="Pp">This is free software; you can redistribute it and/or modify it
    under the same terms as the Perl 5 programming language system itself.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2020-02-24</td>
    <td class="foot-os">perl v5.34.0</td>
  </tr>
</table>
</body>
</html>
