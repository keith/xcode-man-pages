<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
  	$FreeBSD: src/share/man/man4/inet6.4,v 1.4.2.8 2001/12/17 11:30:12 ru Exp $
  	$KAME: inet6.4,v 1.21 2001/04/05 01:00:18 itojun Exp $
  
   Copyright (C) 1995, 1996, 1997, and 1998 WIDE Project.
   All rights reserved.
  
   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions
   are met:
   1. Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
   2. Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
   3. Neither the name of the project nor the names of its contributors
      may be used to endorse or promote products derived from this software
      without specific prior written permission.
  
   THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
   ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
   ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
   FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
   DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
   OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
   HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
   LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
   OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
   SUCH DAMAGE.
   -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>INET6(4)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">INET6(4)</td>
    <td class="head-vol">Device Drivers Manual</td>
    <td class="head-rtitle">INET6(4)</td>
  </tr>
</table>
<div class="manual-text">
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<code class="Nm">inet6</code> &#x2014;
<div class="Nd">Internet protocol version 6 family</div>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<code class="In">#include &lt;<a class="In">sys/types.h</a>&gt;</code>
<br/>
<code class="In">#include &lt;<a class="In">netinet/in.h</a>&gt;</code>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
The <code class="Nm">inet6</code> family is an updated version of
  <a class="Xr">inet(4)</a> family. While <a class="Xr">inet(4)</a> implements
  Internet Protocol version 4, <code class="Nm">inet6</code> implements Internet
  Protocol version 6.
<p class="Pp"><code class="Nm">inet6</code> is a collection of protocols layered
    atop the <i class="Em">Internet Protocol version 6</i> (IPv6) transport
    layer, and utilizing the IPv6 address format. The
    <code class="Nm">inet6</code> family provides protocol support for the
    <code class="Dv">SOCK_STREAM</code>, <code class="Dv">SOCK_DGRAM</code>, and
    <code class="Dv">SOCK_RAW</code> socket types; the
    <code class="Dv">SOCK_RAW</code> interface provides access to the IPv6
    protocol.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="ADDRESSING"><a class="permalink" href="#ADDRESSING">ADDRESSING</a></h1>
IPv6 addresses are 16 byte quantities, stored in network standard byteorder. The
  include file &#x27E8;<span class="Pa">netinet/in.h</span>&#x27E9; defines this
  address as a discriminated union.
<p class="Pp">Sockets bound to the <code class="Nm">inet6</code> family utilize
    the following addressing structure:</p>
<div class="Bd Pp Bd-indent">
<pre>
struct sockaddr_in6 {
	u_int8_t	sin6_len;
	u_int8_t	sin6_family;
	u_int16_t	sin6_port;
	u_int32_t	sin6_flowinfo;
	struct in6_addr	sin6_addr;
	u_int32_t	sin6_scope_id;
};
</pre>
</div>
<p class="Pp">Sockets may be created with the local address
    &#x201C;<code class="Dv">::</code>&#x201D; (which is equal to IPv6 address
    <code class="Dv">0:0:0:0:0:0:0:0</code>) to affect &#x201C;wildcard&#x201D;
    matching on incoming messages.</p>
<p class="Pp">The IPv6 specification defines scoped addresses, like link-local
    or site-local addresses. A scoped address is ambiguous to the kernel, if it
    is specified without a scope identifier. To manipulate scoped addresses
    properly from the userland, programs must use the advanced API defined in
    RFC2292. A compact description of the advanced API is available in
    <a class="Xr">ip6(4)</a>. If a scoped address is specified without an
    explicit scope, the kernel may raise an error. Note that scoped addresses
    are not for daily use at this moment, both from a specification and an
    implementation point of view.</p>
<p class="Pp">The KAME implementation supports an extended numeric IPv6 address
    notation for link-local addresses, like
    &#x201C;<code class="Li">fe80::1%de0</code>&#x201D; to specify
    &#x201C;<code class="Li">fe80::1</code> on <code class="Li">de0</code>
    interface&#x201D;. This notation is supported by
    <a class="Xr">getaddrinfo(3)</a> and <a class="Xr">getnameinfo(3)</a>. Some
    of normal userland programs, such as <a class="Xr">telnet(1)</a> or
    <a class="Xr">ftp(1)</a>, are able to use this notation. With special
    programs like <a class="Xr">ping6(8)</a>, you can specify the outgoing
    interface by an extra command line option to disambiguate scoped
  addresses.</p>
<p class="Pp">Scoped addresses are handled specially in the kernel. In kernel
    structures like routing tables or interface structures, a scoped address
    will have its interface index embedded into the address. Therefore, the
    address in some kernel structures is not the same as that on the wire. The
    embedded index will become visible through a
    <code class="Dv">PF_ROUTE</code> socket, kernel memory accesses via
    <a class="Xr">kvm(3)</a> and on some other occasions. HOWEVER, users should
    never use the embedded form. For details please consult
    <span class="Pa">IMPLEMENTATION</span> supplied with KAME kit.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="PROTOCOLS"><a class="permalink" href="#PROTOCOLS">PROTOCOLS</a></h1>
The <code class="Nm">inet6</code> family is comprised of the IPv6 network
  protocol, Internet Control Message Protocol version 6 (ICMPv6), Transmission
  Control Protocol (TCP), and User Datagram Protocol (UDP). TCP is used to
  support the <code class="Dv">SOCK_STREAM</code> abstraction while UDP is used
  to support the <code class="Dv">SOCK_DGRAM</code> abstraction. Note that TCP
  and UDP are common to <a class="Xr">inet(4)</a> and
  <code class="Nm">inet6</code>. A raw interface to IPv6 is available by
  creating an Internet socket of type <code class="Dv">SOCK_RAW</code>. The
  ICMPv6 message protocol is accessible from a raw socket.
<section class="Ss">
<h2 class="Ss" id="MIB_Variables"><a class="permalink" href="#MIB_Variables">MIB
  Variables</a></h2>
A number of variables are implemented in the net.inet6 branch of the
  <a class="Xr">sysctl(3)</a> MIB. In addition to the variables supported by the
  transport protocols (for which the respective manual pages may be consulted),
  the following general variables are defined:
<dl class="Bl-tag">
  <dt><a class="permalink" href="#IPV6CTL_FORWARDING"><code class="Dv" id="IPV6CTL_FORWARDING">IPV6CTL_FORWARDING</code></a></dt>
  <dd>(ip6.forwarding) Boolean: enable/disable forwarding of IPv6 packets. Also,
      identify if the node is acting as a router. Defaults to off.</dd>
  <dt><a class="permalink" href="#IPV6CTL_SENDREDIRECTS"><code class="Dv" id="IPV6CTL_SENDREDIRECTS">IPV6CTL_SENDREDIRECTS</code></a></dt>
  <dd>(ip6.redirect) Boolean: enable/disable sending of ICMPv6 redirects in
      response to unforwardable IPv6 packets. This option is ignored unless the
      node is routing IPv6 packets, and should normally be enabled on all
      systems. Defaults to on.</dd>
  <dt><a class="permalink" href="#IPV6CTL_DEFHLIM"><code class="Dv" id="IPV6CTL_DEFHLIM">IPV6CTL_DEFHLIM</code></a></dt>
  <dd>(ip6.hlim) Integer: default hop limit value to use for outgoing IPv6
      packets. This value applies to all the transport protocols on top of IPv6.
      There are APIs to override the value.</dd>
  <dt><a class="permalink" href="#IPV6CTL_MAXFRAGPACKETS"><code class="Dv" id="IPV6CTL_MAXFRAGPACKETS">IPV6CTL_MAXFRAGPACKETS</code></a></dt>
  <dd>(ip6.maxfragpackets) Integer: default maximum number of fragmented packets
      the node will accept. 0 means that the node will not accept any fragmented
      packets. -1 means that the node will accept as many fragmented packets as
      it receives. The flag is provided basically for avoiding possible DoS
      attacks.</dd>
  <dt><a class="permalink" href="#IPV6CTL_ACCEPT_RTADV"><code class="Dv" id="IPV6CTL_ACCEPT_RTADV">IPV6CTL_ACCEPT_RTADV</code></a></dt>
  <dd>(ip6.accept_rtadv) Boolean: enable/disable receiving of ICMPv6 router
      advertisement packets, and autoconfiguration of address prefixes and
      default routers. The node must be a host (not a router) for the option to
      be meaningful. Defaults to off.</dd>
  <dt><a class="permalink" href="#IPV6CTL_LOG_INTERVAL"><code class="Dv" id="IPV6CTL_LOG_INTERVAL">IPV6CTL_LOG_INTERVAL</code></a></dt>
  <dd>(ip6.log_interval) Integer: default interval between IPv6 packet
      forwarding engine log output (in seconds).</dd>
  <dt><a class="permalink" href="#IPV6CTL_HDRNESTLIMIT"><code class="Dv" id="IPV6CTL_HDRNESTLIMIT">IPV6CTL_HDRNESTLIMIT</code></a></dt>
  <dd>(ip6.hdrnestlimit) Integer: default number of the maximum IPv6 extension
      headers permitted on incoming IPv6 packets. If set to 0, the node will
      accept as many extension headers as possible.</dd>
  <dt><a class="permalink" href="#IPV6CTL_DAD_COUNT"><code class="Dv" id="IPV6CTL_DAD_COUNT">IPV6CTL_DAD_COUNT</code></a></dt>
  <dd>(ip6.dad_count) Integer: default number of IPv6 DAD (duplicated address
      detection) probe packets. The packets will be generated when IPv6
      interface addresses are configured.</dd>
  <dt><a class="permalink" href="#IPV6CTL_AUTO_FLOWLABEL"><code class="Dv" id="IPV6CTL_AUTO_FLOWLABEL">IPV6CTL_AUTO_FLOWLABEL</code></a></dt>
  <dd>(ip6.auto_flowlabel) Boolean: enable/disable automatic filling of IPv6
      flowlabel field, for outstanding connected transport protocol packets. The
      field might be used by intermediate routers to identify packet flows.
      Defaults to on.</dd>
  <dt><a class="permalink" href="#IPV6CTL_DEFMCASTHLIM"><code class="Dv" id="IPV6CTL_DEFMCASTHLIM">IPV6CTL_DEFMCASTHLIM</code></a></dt>
  <dd>(ip6.defmcasthlim) Integer: default hop limit value for an IPv6 multicast
      packet sourced by the node. This value applies to all the transport
      protocols on top of IPv6. There are APIs to override the value as
      documented in <a class="Xr">ip6(4)</a>.</dd>
  <dt><a class="permalink" href="#IPV6CTL_GIF_HLIM"><code class="Dv" id="IPV6CTL_GIF_HLIM">IPV6CTL_GIF_HLIM</code></a></dt>
  <dd>(ip6.gifhlim) Integer: default maximum hop limit value for an IPv6 packet
      generated by <a class="Xr">gif(4)</a> tunnel interface.</dd>
  <dt><a class="permalink" href="#IPV6CTL_KAME_VERSION"><code class="Dv" id="IPV6CTL_KAME_VERSION">IPV6CTL_KAME_VERSION</code></a></dt>
  <dd>(ip6.kame_version) String: identifies the version of KAME IPv6 stack
      implemented in the kernel.</dd>
  <dt><a class="permalink" href="#IPV6CTL_USE_DEPRECATED"><code class="Dv" id="IPV6CTL_USE_DEPRECATED">IPV6CTL_USE_DEPRECATED</code></a></dt>
  <dd>(ip6.use_deprecated) Boolean: enable/disable use of deprecated address,
      specified in RFC2462 5.5.4. Defaults to on.</dd>
  <dt><a class="permalink" href="#IPV6CTL_RR_PRUNE"><code class="Dv" id="IPV6CTL_RR_PRUNE">IPV6CTL_RR_PRUNE</code></a></dt>
  <dd>(ip6.rr_prune) Integer: default interval between IPv6 router renumbering
      prefix babysitting, in seconds.</dd>
  <dt><a class="permalink" href="#IPV6CTL_MAPPED_ADDR"><code class="Dv" id="IPV6CTL_MAPPED_ADDR">IPV6CTL_MAPPED_ADDR</code></a></dt>
  <dd>(ip6.mapped_addr) Boolean: enable/disable use of IPv4 mapped address on
      <code class="Dv">AF_INET6</code> sockets. Defaults to on.</dd>
  <dt><a class="permalink" href="#IPV6CTL_RTEXPIRE"><code class="Dv" id="IPV6CTL_RTEXPIRE">IPV6CTL_RTEXPIRE</code></a></dt>
  <dd>(ip6.rtexpire) Integer: lifetime in seconds of protocol-cloned IP routes
      after the last reference drops (default one hour).</dd>
  <dt><a class="permalink" href="#IPV6CTL_RTMINEXPIRE"><code class="Dv" id="IPV6CTL_RTMINEXPIRE">IPV6CTL_RTMINEXPIRE</code></a></dt>
  <dd>(ip6.rtminexpire) Integer: minimum value of ip.rtexpire (default ten
      seconds).</dd>
  <dt><a class="permalink" href="#IPV6CTL_RTMAXCACHE"><code class="Dv" id="IPV6CTL_RTMAXCACHE">IPV6CTL_RTMAXCACHE</code></a></dt>
  <dd>(ip6.rtmaxcache) Integer: trigger level of cached, unreferenced,
      protocol-cloned routes which initiates dynamic adaptation (default
    128).</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Interaction_between_IPv4/v6_sockets"><a class="permalink" href="#Interaction_between_IPv4/v6_sockets">Interaction
  between IPv4/v6 sockets</a></h2>
The behavior of <code class="Dv">AF_INET6</code> TCP/UDP socket is documented in
  RFC2553. Basically, it says this:
<ul class="Bl-bullet Bl-compact">
  <li>A specific bind on an <code class="Dv">AF_INET6</code> socket
      (<a class="Xr">bind(2)</a> with an address specified) should accept IPv6
      traffic to that address only.</li>
  <li>If you perform a wildcard bind on an <code class="Dv">AF_INET6</code>
      socket (<a class="Xr">bind(2)</a> to IPv6 address
      <code class="Li">::</code>), and there is no wildcard bind
      <code class="Dv">AF_INET</code> socket on that TCP/UDP port, IPv6 traffic
      as well as IPv4 traffic should be routed to that
      <code class="Dv">AF_INET6</code> socket. IPv4 traffic should be seen as if
      it came from an IPv6 address like <code class="Li">::ffff:10.1.1.1</code>.
      This is called an IPv4 mapped address.</li>
  <li>If there are both a wildcard bind <code class="Dv">AF_INET</code> socket
      and a wildcard bind <code class="Dv">AF_INET6</code> socket on one TCP/UDP
      port, they should behave separately. IPv4 traffic should be routed to the
      <code class="Dv">AF_INET</code> socket and IPv6 should be routed to the
      <code class="Dv">AF_INET6</code> socket.</li>
</ul>
<p class="Pp">However, RFC2553 does not define the ordering constraint between
    calls to <a class="Xr">bind(2)</a>, nor how IPv4 TCP/UDP port numbers and
    IPv6 TCP/UDP port numbers relate to each other (should they be integrated or
    separated). Implemented behavior is very different from kernel to kernel.
    Therefore, it is unwise to rely too much upon the behavior of
    <code class="Dv">AF_INET6</code> wildcard bind sockets. It is recommended to
    listen to two sockets, one for <code class="Dv">AF_INET</code> and another
    for <code class="Dv">AF_INET6</code>, when you would like to accept both
    IPv4 and IPv6 traffic.</p>
<p class="Pp">It should also be noted that malicious parties can take advantage
    of the complexity presented above, and are able to bypass access control, if
    the target node routes IPv4 traffic to <code class="Dv">AF_INET6</code>
    socket. Users are advised to take care handling connections from IPv4 mapped
    address to <code class="Dv">AF_INET6</code> sockets.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<a class="Xr">ioctl(2)</a>, <a class="Xr">socket(2)</a>,
  <a class="Xr">sysctl(3)</a>, <a class="Xr">icmp6(4)</a>,
  <a class="Xr">intro(4)</a>, <a class="Xr">ip6(4)</a>,
  <a class="Xr">tcp(4)</a>, <a class="Xr">udp(4)</a>
</section>
<section class="Sh">
<h1 class="Sh" id="STANDARDS"><a class="permalink" href="#STANDARDS">STANDARDS</a></h1>
<cite class="Rs"><span class="RsA">Tatsuya Jinmei</span> and
  <span class="RsA">Atsushi Onoe</span>, <span class="RsT">An Extension of
  Format for IPv6 Scoped Addresses</span>, <span class="RsR">internet
  draft</span>,
  <span class="RsN">draft-ietf-ipngwg-scopedaddr-format-02.txt</span>,
  <span class="RsD">June 2000</span>, <span class="RsO">work in progress
  material</span>.</cite>
</section>
<section class="Sh">
<h1 class="Sh" id="HISTORY"><a class="permalink" href="#HISTORY">HISTORY</a></h1>
The <code class="Nm">inet6</code> protocol interfaces are defined in RFC2553 and
  RFC2292. The implementation described herein appeared in the WIDE/KAME
  project.
</section>
<section class="Sh">
<h1 class="Sh" id="BUGS"><a class="permalink" href="#BUGS">BUGS</a></h1>
The IPv6 support is subject to change as the Internet protocols develop. Users
  should not depend on details of the current implementation, but rather the
  services exported.
<p class="Pp">Users are suggested to implement &#x201C;version
    independent&#x201D; code as much as possible, as you will need to support
    both <a class="Xr">inet(4)</a> and <code class="Nm">inet6</code>.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">January 29, 1999</td>
    <td class="foot-os">Mac OS X 11.0</td>
  </tr>
</table>
</body>
</html>
