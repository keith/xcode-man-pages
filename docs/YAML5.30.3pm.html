<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    .Nd, .Bf, .Op { display: inline; }
    .Pa, .Ad { font-style: italic; }
    .Ms { font-weight: bold; }
    .Bl-diag > dt { font-weight: bold; }
    code.Nm, .Fl, .Cm, .Ic, code.In, .Fd, .Fn, .Cd { font-weight: bold;
      font-family: inherit; }
  </style>
  <title>YAML(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">YAML(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">YAML(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">YAML - YAML Ain't Markup Language&#x2122;</p>
</section>
<section class="Sh">
<h1 class="Sh" id="VERSION"><a class="permalink" href="#VERSION">VERSION</a></h1>
<p class="Pp">This document describes YAML version <b>1.30</b>.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="NOTE"><a class="permalink" href="#NOTE">NOTE</a></h1>
<p class="Pp">This module has been released to CPAN as YAML::Old, and soon
    YAML.pm will be changed to just be a frontend interface module for all the
    various Perl YAML implementation modules, including YAML::Old.</p>
<p class="Pp">If you want robust and fast YAML processing using the normal
    Dump/Load API, please consider switching to YAML::XS. It is by far the best
    Perl module for YAML at this time. It requires that you have a C compiler,
    since it is written in C.</p>
<p class="Pp">If you really need to use this version of YAML.pm it will always
    be available as YAML::Old.</p>
<p class="Pp">The rest of this documentation is left unchanged, until YAML.pm is
    switched over to the new UI-only version.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>    use YAML;
    # Load a YAML stream of 3 YAML documents into Perl data structures.
    my ($hashref, $arrayref, $string) = Load(&lt;&lt;'...');
    ---
    name: ingy       # A Mapping
    age: old
    weight: heavy
    # I should comment that I also like pink, but don't tell anybody.
    favorite colors:
      - red
      - green
      - blue
    ---
    - Clark Evans    # A Sequence
    - Oren Ben-Kiki
    - Ingy d&#x00F6;t Net
    --- &gt;            # A Block Scalar
    You probably think YAML stands for &quot;Yet Another Markup Language&quot;. It
    ain't! YAML is really a data serialization language. But if you want
    to think of it as a markup, that's OK with me. A lot of people try
    to use XML as a serialization format.
    &quot;YAML&quot; is catchy and fun to say. Try it. &quot;YAML, YAML, YAML!!!&quot;
    ...
    # Dump the Perl data structures back into YAML.
    print Dump($string, $arrayref, $hashref);
    # YAML::Dump is used the same way you'd use Data::Dumper::Dumper
    use Data::Dumper;
    print Dumper($string, $arrayref, $hashref);
    Since version 1.25 YAML.pm supports trailing comments.
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">The YAML.pm module implements a YAML Loader and Dumper based on
    the YAML 1.0 specification. &lt;http://www.yaml.org/spec/&gt;</p>
<p class="Pp">YAML is a generic data serialization language that is optimized
    for human readability. It can be used to express the data structures of most
    modern programming languages. (Including Perl!!!)</p>
<p class="Pp">For information on the YAML syntax, please refer to the YAML
    specification.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="WHY_YAML_IS_COOL"><a class="permalink" href="#WHY_YAML_IS_COOL">WHY
  YAML IS COOL</a></h1>
<dl class="Bl-tag">
  <dt id="YAML"><a class="permalink" href="#YAML">YAML is readable for
    people.</a></dt>
  <dd>It makes clear sense out of complex data structures. You should find that
      YAML is an exceptional data dumping tool. Structure is shown through
      indentation, YAML supports recursive data, and hash keys are sorted by
      default. In addition, YAML supports several styles of scalar formatting
      for different types of data.</dd>
  <dt id="YAML~2"><a class="permalink" href="#YAML~2">YAML is editable.</a></dt>
  <dd>YAML was designed from the ground up to be an excellent syntax for
      configuration files. Almost all programs need configuration files, so why
      invent a new syntax for each one? And why subject users to the
      complexities of XML or native Perl code?</dd>
  <dt id="YAML~3"><a class="permalink" href="#YAML~3">YAML is
    multilingual.</a></dt>
  <dd>Yes, YAML supports Unicode. But I'm actually referring to programming
      languages. YAML was designed to meet the serialization needs of Perl,
      Python, Ruby, Tcl, PHP, Javascript and Java. It was also designed to be
      interoperable between those languages. That means YAML serializations
      produced by Perl can be processed by Python.</dd>
  <dt id="YAML~4"><a class="permalink" href="#YAML~4">YAML is taint
    safe.</a></dt>
  <dd>Using modules like Data::Dumper for serialization is fine as long as you
      can be sure that nobody can tamper with your data files or transmissions.
      That's because you need to use Perl's
      <span class="Li">&quot;eval()&quot;</span> built-in to deserialize the
      data. Somebody could add a snippet of Perl to erase your files.
    <p class="Pp">YAML's parser does not need to eval anything.</p>
  </dd>
  <dt id="YAML~5"><a class="permalink" href="#YAML~5">YAML is full
    featured.</a></dt>
  <dd>YAML can accurately serialize all of the common Perl data structures and
      deserialize them again without losing data relationships. Although it is
      not 100% perfect (no serializer is or can be perfect), it fares as well as
      the popular current modules: Data::Dumper, Storable, XML::Dumper and
      Data::Denter.
    <p class="Pp">YAML.pm also has the ability to handle code (subroutine)
        references and typeglobs. (Still experimental) These features are not
        found in Perl's other serialization modules.</p>
  </dd>
  <dt id="YAML~6"><a class="permalink" href="#YAML~6">YAML is
    extensible.</a></dt>
  <dd>The YAML language has been designed to be flexible enough to solve it's
      own problems. The markup itself has 3 basic construct which resemble
      Perl's hash, array and scalar. By default, these map to their Perl
      equivalents. But each YAML node also supports a tagging mechanism (type
      system) which can cause that node to be interpreted in a completely
      different manner. That's how YAML can support object serialization and
      oddball structures like Perl's typeglob.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="YAML_IMPLEMENTATIONS_IN_PERL"><a class="permalink" href="#YAML_IMPLEMENTATIONS_IN_PERL">YAML
  IMPLEMENTATIONS IN PERL</a></h1>
<p class="Pp">This module, YAML.pm, is really just the interface module for YAML
    modules written in Perl. The basic interface for YAML consists of two
    functions: <span class="Li">&quot;Dump&quot;</span> and
    <span class="Li">&quot;Load&quot;</span>. The real work is done by the
    modules YAML::Dumper and YAML::Loader.</p>
<p class="Pp">Different YAML module distributions can be created by subclassing
    YAML.pm and YAML::Loader and YAML::Dumper. For example, YAML-Simple consists
    of YAML::Simple YAML::Dumper::Simple and YAML::Loader::Simple.</p>
<p class="Pp">Why would there be more than one implementation of YAML? Well,
    despite YAML's offering of being a simple data format, YAML is actually very
    deep and complex. Implementing the entirety of the YAML specification is a
    daunting task.</p>
<p class="Pp">For this reason I am currently working on 3 different YAML
    implementations.</p>
<dl class="Bl-tag">
  <dt id="YAML~7"><a class="permalink" href="#YAML~7">YAML</a></dt>
  <dd>The main YAML distribution will keeping evolving to support the entire
      YAML specification in pure Perl. This may not be the fastest or most
      stable module though. Currently, YAML.pm has lots of known bugs. It is
      mostly a great tool for dumping Perl data structures to a readable
    form.</dd>
  <dt id="YAML::Tiny"><a class="permalink" href="#YAML::Tiny">YAML::Tiny</a></dt>
  <dd>The point of YAML::Tiny is to strip YAML down to the 90% that people use
      most and offer that in a small, fast, stable, pure Perl form. YAML::Tiny
      will simply die when it is asked to do something it can't.</dd>
  <dt id="YAML::Syck"><a class="permalink" href="#YAML::Syck">YAML::Syck</a></dt>
  <dd><span class="Li">&quot;libsyck&quot;</span> is the C based YAML processing
      library used by the Ruby programming language (and also Python, PHP and
      Pugs). YAML::Syck is the Perl binding to
      <span class="Li">&quot;libsyck&quot;</span>. It should be very fast, but
      may have problems of its own. It will also require C compilation.
    <p class="Pp">NOTE: Audrey Tang has actually completed this module and it
        works great and is
      <br/>
       10 times faster than YAML.pm.</p>
  </dd>
</dl>
<p class="Pp">In the future, there will likely be even more YAML modules.
    Remember, people other than Ingy are allowed to write YAML modules!</p>
</section>
<section class="Sh">
<h1 class="Sh" id="FUNCTIONAL_USAGE"><a class="permalink" href="#FUNCTIONAL_USAGE">FUNCTIONAL
  USAGE</a></h1>
<p class="Pp">YAML is completely OO under the hood. Still it exports a few
    useful top level functions so that it is dead simple to use. These functions
    just do the OO stuff for you. If you want direct access to the OO API see
    the documentation for YAML::Dumper and YAML::Loader.</p>
<section class="Ss">
<h2 class="Ss" id="Exported_Functions"><a class="permalink" href="#Exported_Functions">Exported
  Functions</a></h2>
<p class="Pp">The following functions are exported by YAML.pm by default. The
    reason they are exported is so that YAML works much like Data::Dumper. If
    you don't want functions to be imported, just use YAML with an empty import
    list:</p>
<p class="Pp"></p>
<pre>    use YAML ();
</pre>
<dl class="Bl-tag">
  <dt id="Dump(list"><a class="permalink" href="#Dump(list">Dump(list-of-Perl-data-structures)</a></dt>
  <dd>Turn Perl data into YAML. This function works very much like
      <b>Data::Dumper::Dumper()</b>. It takes a list of Perl data structures and
      dumps them into a serialized form. It returns a string containing the YAML
      stream. The structures can be references or plain scalars.</dd>
  <dt id="Load(string"><a class="permalink" href="#Load(string">Load(string-containing-a-YAML-stream)</a></dt>
  <dd>Turn YAML into Perl data. This is the opposite of Dump. Just like
      Storable's <b>thaw()</b> function or the <b>eval()</b> function in
      relation to Data::Dumper. It parses a string containing a valid YAML
      stream into a list of Perl data structures.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Exportable_Functions"><a class="permalink" href="#Exportable_Functions">Exportable
  Functions</a></h2>
<p class="Pp">These functions are not exported by default but you can request
    them in an import list like this:</p>
<p class="Pp"></p>
<pre>    use YAML qw'freeze thaw Bless';
</pre>
<dl class="Bl-tag">
  <dt id="freeze()"><a class="permalink" href="#freeze()"><b>freeze()</b> and
    <b>thaw()</b></a></dt>
  <dd>Aliases to <b>Dump()</b> and <b>Load()</b> for Storable fans. This will
      also allow YAML.pm to be plugged directly into modules like POE.pm, that
      use the freeze/thaw API for internal serialization.</dd>
  <dt id="DumpFile(filepath,"><a class="permalink" href="#DumpFile(filepath,">DumpFile(filepath,
    list)</a></dt>
  <dd>Writes the YAML stream to a file instead of just returning a string.</dd>
  <dt id="LoadFile(filepath)"><a class="permalink" href="#LoadFile(filepath)">LoadFile(filepath)</a></dt>
  <dd>Reads the YAML stream from a file instead of a string.</dd>
  <dt id="Bless(perl"><a class="permalink" href="#Bless(perl">Bless(perl-node,
    [yaml-node | class-name])</a></dt>
  <dd>Associate a normal Perl node, with a yaml node. A yaml node is an object
      tied to the YAML::Node class. The second argument is either a yaml node
      that you've already created or a class (package) name that supports a
      <span class="Li">&quot;yaml_dump()&quot;</span> function. A
      <span class="Li">&quot;yaml_dump()&quot;</span> function should take a
      perl node and return a yaml node. If no second argument is provided, Bless
      will create a yaml node. This node is not returned, but can be retrieved
      with the <b>Blessed()</b> function.
    <p class="Pp">Here's an example of how to use Bless. Say you have a hash
        containing three keys, but you only want to dump two of them.
        Furthermore the keys must be dumped in a certain order. Here's how you
        do that:</p>
    <p class="Pp"></p>
    <pre>    use YAML qw(Dump Bless);
    $hash = {apple =&gt; 'good', banana =&gt; 'bad', cauliflower =&gt; 'ugly'};
    print Dump $hash;
    Bless($hash)-&gt;keys(['banana', 'apple']);
    print Dump $hash;
    </pre>
    <p class="Pp">produces:</p>
    <p class="Pp"></p>
    <pre>    ---
    apple: good
    banana: bad
    cauliflower: ugly
    ---
    banana: bad
    apple: good
    </pre>
    <p class="Pp">Bless returns the tied part of a yaml-node, so that you can
        call the YAML::Node methods. This is the same thing that
        <b>YAML::Node::ynode()</b> returns. So another way to do the above
        example is:</p>
    <p class="Pp"></p>
    <pre>    use YAML qw(Dump Bless);
    use YAML::Node;
    $hash = {apple =&gt; 'good', banana =&gt; 'bad', cauliflower =&gt; 'ugly'};
    print Dump $hash;
    Bless($hash);
    $ynode = ynode(Blessed($hash));
    $ynode-&gt;keys(['banana', 'apple']);
    print Dump $hash;
    </pre>
    <p class="Pp">Note that Blessing a Perl data structure does not change it
        anyway. The extra information is stored separately and looked up by the
        Blessed node's memory address.</p>
  </dd>
  <dt id="Blessed(perl"><a class="permalink" href="#Blessed(perl">Blessed(perl-node)</a></dt>
  <dd>Returns the yaml node that a particular perl node is associated with (see
      above). Returns undef if the node is not (YAML) Blessed.</dd>
</dl>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="GLOBAL_OPTIONS"><a class="permalink" href="#GLOBAL_OPTIONS">GLOBAL
  OPTIONS</a></h1>
<p class="Pp">YAML options are set using a group of global variables in the YAML
    namespace. This is similar to how Data::Dumper works.</p>
<p class="Pp">For example, to change the indentation width, do something
  like:</p>
<p class="Pp"></p>
<pre>    local $YAML::Indent = 3;
</pre>
<p class="Pp">The current options are:</p>
<dl class="Bl-tag">
  <dt id="DumperClass"><a class="permalink" href="#DumperClass">DumperClass</a></dt>
  <dd>You can override which module/class YAML uses for Dumping data.</dd>
  <dt id="LoadBlessed"><a class="permalink" href="#LoadBlessed">LoadBlessed
    (since 1.25)</a></dt>
  <dd>Default is undef (false)
    <p class="Pp">The default was changed in version 1.30.</p>
    <p class="Pp">When set to true, YAML nodes with special tags will be
        automatocally blessed into objects:</p>
    <p class="Pp"></p>
    <pre>    - !perl/hash:Foo::Bar
        foo: 42
    </pre>
    <p class="Pp">When loading untrusted YAML, you should disable this option by
        setting it to <span class="Li">0</span>. This will also disable setting
        typeglobs when loading them.</p>
    <p class="Pp">You can create any kind of object with YAML. The creation
        itself is not the critical part. If the class has a
        <span class="Li">&quot;DESTROY&quot;</span> method, it will be called
        once the object is deleted. An example with File::Temp removing files
        can be found at
        &lt;https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=862373&gt;</p>
  </dd>
  <dt id="LoaderClass"><a class="permalink" href="#LoaderClass">LoaderClass</a></dt>
  <dd>You can override which module/class YAML uses for Loading data.</dd>
  <dt id="Indent"><a class="permalink" href="#Indent">Indent</a></dt>
  <dd>This is the number of space characters to use for each indentation level
      when doing a <b>Dump()</b>. The default is 2.
    <p class="Pp">By the way, YAML can use any number of characters for
        indentation at any level. So if you are editing YAML by hand feel free
        to do it anyway that looks pleasing to you; just be consistent for a
        given level.</p>
  </dd>
  <dt id="SortKeys"><a class="permalink" href="#SortKeys">SortKeys</a></dt>
  <dd>Default is 1. (true)
    <p class="Pp">Tells YAML.pm whether or not to sort hash keys when storing a
        document.</p>
    <p class="Pp">YAML::Node objects can have their own sort order, which is
        usually what you want. To override the YAML::Node order and sort the
        keys anyway, set SortKeys to 2.</p>
  </dd>
  <dt id="Stringify"><a class="permalink" href="#Stringify">Stringify</a></dt>
  <dd>Default is 0. (false)
    <p class="Pp">Objects with string overloading should honor the overloading
        and dump the stringification of themselves, rather than the actual
        object's guts.</p>
  </dd>
  <dt id="Numify"><a class="permalink" href="#Numify">Numify</a></dt>
  <dd>Default is 0. (false)
    <p class="Pp">Values that look like numbers (integers, floats) will be
        numified when loaded.</p>
  </dd>
  <dt id="UseHeader"><a class="permalink" href="#UseHeader">UseHeader</a></dt>
  <dd>Default is 1. (true)
    <p class="Pp">This tells YAML.pm whether to use a separator string for a
        Dump operation. This only applies to the first document in a stream.
        Subsequent documents must have a YAML header by definition.</p>
  </dd>
  <dt id="UseVersion"><a class="permalink" href="#UseVersion">UseVersion</a></dt>
  <dd>Default is 0. (false)
    <p class="Pp">Tells YAML.pm whether to include the YAML version on the
        separator/header.</p>
    <p class="Pp"></p>
    <pre>    --- %YAML:1.0
    </pre>
  </dd>
  <dt id="AnchorPrefix"><a class="permalink" href="#AnchorPrefix">AnchorPrefix</a></dt>
  <dd>Default is ''.
    <p class="Pp">Anchor names are normally numeric. YAML.pm simply starts with
        '1' and increases by one for each new anchor. This option allows you to
        specify a string to be prepended to each anchor number.</p>
  </dd>
  <dt id="UseCode"><a class="permalink" href="#UseCode">UseCode</a></dt>
  <dd>Setting the UseCode option is a shortcut to set both the DumpCode and
      LoadCode options at once. Setting UseCode to '1' tells YAML.pm to dump
      Perl code references as Perl (using B::Deparse) and to load them back into
      memory using <b>eval()</b>. The reason this has to be an option is that
      using <b>eval()</b> to parse untrusted code is, well, untrustworthy.</dd>
  <dt id="DumpCode"><a class="permalink" href="#DumpCode">DumpCode</a></dt>
  <dd>Determines if and how YAML.pm should serialize Perl code references. By
      default YAML.pm will dump code references as dummy placeholders (much like
      Data::Dumper). If DumpCode is set to '1' or 'deparse', code references
      will be dumped as actual Perl code.</dd>
  <dt id="LoadCode"><a class="permalink" href="#LoadCode">LoadCode</a></dt>
  <dd>LoadCode is the opposite of DumpCode. It tells YAML if and how to
      deserialize code references. When set to '1' or 'deparse' it will use
      <span class="Li">&quot;eval()&quot;</span>. Since this is potentially
      risky, only use this option if you know where your YAML has been.
    <p class="Pp">LoadCode must be enabled also to use the feature of evaluating
        typeglobs (because with the typeglob feature you would be able to set
        the variable <span class="Li">$YAML::LoadCode</span> from a YAML
      file).</p>
  </dd>
  <dt id="Preserve"><a class="permalink" href="#Preserve">Preserve</a></dt>
  <dd>When set to true, this option tells the Loader to load hashes into
      YAML::Node objects. These are tied hashes. This has the effect of
      remembering the key order, thus it will be preserved when the hash is
      dumped again. See YAML::Node for more information.</dd>
  <dt id="UseBlock"><a class="permalink" href="#UseBlock">UseBlock</a></dt>
  <dd>YAML.pm uses heuristics to guess which scalar style is best for a given
      node. Sometimes you'll want all multiline scalars to use the 'block'
      style. If so, set this option to 1.
    <p class="Pp">NOTE: YAML's block style is akin to Perl's here-document.</p>
  </dd>
  <dt id="UseFold"><a class="permalink" href="#UseFold">UseFold (Not supported
    anymore since v0.60)</a></dt>
  <dd>If you want to force YAML to use the 'folded' style for all multiline
      scalars, then set <span class="Li">$UseFold</span> to 1.
    <p class="Pp">NOTE: YAML's folded style is akin to the way HTML folds text,
        except smarter.</p>
  </dd>
  <dt id="UseAliases"><a class="permalink" href="#UseAliases">UseAliases</a></dt>
  <dd>YAML has an alias mechanism such that any given structure in memory gets
      serialized once. Any other references to that structure are serialized
      only as alias markers. This is how YAML can serialize duplicate and
      recursive structures.
    <p class="Pp">Sometimes, when you KNOW that your data is nonrecursive in
        nature, you may want to serialize such that every node is expressed in
        full. (ie as a copy of the original). Setting
        <span class="Li">$YAML::UseAliases</span> to 0 will allow you to do
        this. This also may result in faster processing because the lookup
        overhead is by bypassed.</p>
    <p class="Pp">THIS OPTION CAN BE DANGEROUS. <b>If</b> your data is
        recursive, this option <b>will</b> cause <b>Dump()</b> to run in an
        endless loop, chewing up your computers memory. You have been
      warned.</p>
  </dd>
  <dt id="CompressSeries"><a class="permalink" href="#CompressSeries">CompressSeries</a></dt>
  <dd>Default is 1.
    <p class="Pp">Compresses the formatting of arrays of hashes:</p>
    <p class="Pp"></p>
    <pre>    -
      foo: bar
    -
      bar: foo
    </pre>
    <p class="Pp">becomes:</p>
    <p class="Pp"></p>
    <pre>    - foo: bar
    - bar: foo
    </pre>
    <p class="Pp">Since this output is usually more desirable, this option is
        turned on by default.</p>
  </dd>
  <dt id="QuoteNumericStrings"><a class="permalink" href="#QuoteNumericStrings">QuoteNumericStrings</a></dt>
  <dd>Default is 0. (false)
    <p class="Pp">Adds detection mechanisms to encode strings that resemble
        numbers with mandatory quoting.</p>
    <p class="Pp">This ensures leading that things like leading/trailing zeros
        and other formatting are preserved.</p>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="YAML_TERMINOLOGY"><a class="permalink" href="#YAML_TERMINOLOGY">YAML
  TERMINOLOGY</a></h1>
<p class="Pp">YAML is a full featured data serialization language, and thus has
    its own terminology.</p>
<p class="Pp">It is important to remember that although YAML is heavily
    influenced by Perl and Python, it is a language in its own right, not merely
    just a representation of Perl structures.</p>
<p class="Pp">YAML has three constructs that are conspicuously similar to Perl's
    hash, array, and scalar. They are called mapping, sequence, and string
    respectively. By default, they do what you would expect. But each instance
    may have an explicit or implicit tag (type) that makes it behave
    differently. In this manner, YAML can be extended to represent Perl's Glob
    or Python's tuple, or Ruby's Bigint.</p>
<dl class="Bl-tag">
  <dt id="stream"><a class="permalink" href="#stream">stream</a></dt>
  <dd>
    <pre>    A YAML stream is the full sequence of Unicode characters that a YAML
    parser would read or a YAML emitter would write. A stream may contain
    one or more YAML documents separated by YAML headers.
    ---
    a: mapping
    foo: bar
    ---
    - a
    - sequence
    </pre>
  </dd>
  <dt id="document"><a class="permalink" href="#document">document</a></dt>
  <dd>A YAML document is an independent data structure representation within a
      stream. It is a top level node. Each document in a YAML stream must begin
      with a YAML header line. Actually the header is optional on the first
      document.
    <p class="Pp"></p>
    <pre>    ---
    This: top level mapping
    is:
        - a
        - YAML
        - document
    </pre>
  </dd>
  <dt id="header"><a class="permalink" href="#header">header</a></dt>
  <dd>A YAML header is a line that begins a YAML document. It consists of three
      dashes, possibly followed by more info. Another purpose of the header line
      is that it serves as a place to put top level tag and anchor information.
    <p class="Pp"></p>
    <pre>    --- !recursive-sequence &amp;001
    - * 001
    - * 001
    </pre>
  </dd>
  <dt id="node"><a class="permalink" href="#node">node</a></dt>
  <dd>A YAML node is the representation of a particular data structure. Nodes
      may contain other nodes. (In Perl terms, nodes are like scalars. Strings,
      arrayrefs and hashrefs. But this refers to the serialized format, not the
      in- memory structure.)</dd>
  <dt id="tag"><a class="permalink" href="#tag">tag</a></dt>
  <dd>This is similar to a type. It indicates how a particular YAML node
      serialization should be transferred into or out of memory. For instance a
      Foo::Bar object would use the tag 'perl/Foo::Bar':
    <p class="Pp"></p>
    <pre>    - !perl/Foo::Bar
        foo: 42
        bar: stool
    </pre>
  </dd>
  <dt id="collection"><a class="permalink" href="#collection">collection</a></dt>
  <dd>A collection is the generic term for a YAML data grouping. YAML has two
      types of collections: mappings and sequences. (Similar to hashes and
      arrays)</dd>
  <dt id="mapping"><a class="permalink" href="#mapping">mapping</a></dt>
  <dd>A mapping is a YAML collection defined by unordered key/value pairs with
      unique keys. By default YAML mappings are loaded into Perl hashes.
    <p class="Pp"></p>
    <pre>    a mapping:
        foo: bar
        two: times two is 4
    </pre>
  </dd>
  <dt id="sequence"><a class="permalink" href="#sequence">sequence</a></dt>
  <dd>A sequence is a YAML collection defined by an ordered list of elements. By
      default YAML sequences are loaded into Perl arrays.
    <p class="Pp"></p>
    <pre>    a sequence:
        - one bourbon
        - one scotch
        - one beer
    </pre>
  </dd>
  <dt id="scalar"><a class="permalink" href="#scalar">scalar</a></dt>
  <dd>A scalar is a YAML node that is a single value. By default YAML scalars
      are loaded into Perl scalars.
    <p class="Pp"></p>
    <pre>    a scalar key: a scalar value
    </pre>
    <p class="Pp">YAML has many styles for representing scalars. This is
        important because varying data will have varying formatting requirements
        to retain the optimum human readability.</p>
  </dd>
  <dt id="plain"><a class="permalink" href="#plain">plain scalar</a></dt>
  <dd>A plain scalar is unquoted. All plain scalars are automatic candidates for
      &quot;implicit tagging&quot;. This means that their tag may be determined
      automatically by examination. The typical uses for this are plain alpha
      strings, integers, real numbers, dates, times and currency.
    <p class="Pp"></p>
    <pre>    - a plain string
    - -42
    - 3.1415
    - 12:34
    - 123 this is an error
    </pre>
  </dd>
  <dt id="single"><a class="permalink" href="#single">single quoted
    scalar</a></dt>
  <dd>This is similar to Perl's use of single quotes. It means no escaping
      except for single quotes which are escaped by using two adjacent single
      quotes.
    <p class="Pp"></p>
    <pre>    - 'When I say ''\n'' I mean &quot;backslash en&quot;'
    </pre>
  </dd>
  <dt id="double"><a class="permalink" href="#double">double quoted
    scalar</a></dt>
  <dd>This is similar to Perl's use of double quotes. Character escaping can be
      used.
    <p class="Pp"></p>
    <pre>    - &quot;This scalar\nhas two lines, and a bell --&gt;\a&quot;
    </pre>
  </dd>
  <dt id="folded"><a class="permalink" href="#folded">folded scalar</a></dt>
  <dd>This is a multiline scalar which begins on the next line. It is indicated
      by a single right angle bracket. It is unescaped like the single quoted
      scalar. Line folding is also performed.
    <p class="Pp"></p>
    <pre>    - &gt;
     This is a multiline scalar which begins on
     the next line. It is indicated by a single
     carat. It is unescaped like the single
     quoted scalar. Line folding is also
     performed.
    </pre>
  </dd>
  <dt id="block"><a class="permalink" href="#block">block scalar</a></dt>
  <dd>This final multiline form is akin to Perl's here-document except that (as
      in all YAML data) scope is indicated by indentation. Therefore, no ending
      marker is required. The data is verbatim. No line folding.
    <p class="Pp"></p>
    <pre>    - |
        QTY  DESC          PRICE  TOTAL
        ---  ----          -----  -----
          1  Foo Fighters  $19.95 $19.95
          2  Bar Belles    $29.95 $59.90
    </pre>
  </dd>
  <dt id="parser"><a class="permalink" href="#parser">parser</a></dt>
  <dd>A YAML processor has four stages: parse, load, dump, emit.
    <p class="Pp">A parser parses a YAML stream. YAML.pm's <b>Load()</b>
        function contains a parser.</p>
  </dd>
  <dt id="loader"><a class="permalink" href="#loader">loader</a></dt>
  <dd>The other half of the <b>Load()</b> function is a loader. This takes the
      information from the parser and loads it into a Perl data structure.</dd>
  <dt id="dumper"><a class="permalink" href="#dumper">dumper</a></dt>
  <dd>The <b>Dump()</b> function consists of a dumper and an emitter. The dumper
      walks through each Perl data structure and gives info to the emitter.</dd>
  <dt id="emitter"><a class="permalink" href="#emitter">emitter</a></dt>
  <dd>The emitter takes info from the dumper and turns it into a YAML stream.
    <p class="Pp">NOTE: In YAML.pm the parser<i>loader and the dumper</i>emitter
        code are currently
      <br/>
       very closely tied together. In the future they may be broken into
      <br/>
       separate stages.</p>
  </dd>
</dl>
<p class="Pp">For more information please refer to the immensely helpful YAML
    specification available at &lt;http://www.yaml.org/spec/&gt;.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="YSH_"><a class="permalink" href="#YSH_">YSH - THE YAML
  SHELL</a></h1>
<p class="Pp">The YAML::Shell distribution provides script called 'ysh', the
    YAML shell. ysh provides a simple, interactive way to play with YAML. If you
    type in Perl code, it displays the result in YAML. If you type in YAML it
    turns it into Perl code.</p>
<p class="Pp">To run ysh, (assuming you installed it along with YAML.pm) simply
    type:</p>
<p class="Pp"></p>
<pre>    ysh [options]
</pre>
<p class="Pp">Please read the <span class="Li">&quot;ysh&quot;</span>
    documentation for the full details. There are lots of options.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="BUGS_&amp;_DEFICIENCIES"><a class="permalink" href="#BUGS_&amp;_DEFICIENCIES">BUGS
  &amp; DEFICIENCIES</a></h1>
<p class="Pp">If you find a bug in YAML, please try to recreate it in the YAML
    Shell with logging turned on ('ysh -L'). When you have successfully
    reproduced the bug, please mail the LOG file to the author
  (ingy@cpan.org).</p>
<p class="Pp">WARNING: This is still <b>ALPHA</b> code. Well, most of this code
    has been around for years...</p>
<p class="Pp">BIGGER WARNING: YAML.pm has been slow in the making, but I am
    committed to having top notch YAML tools in the Perl world. The YAML team is
    close to finalizing the YAML 1.1 spec. This version of YAML.pm is based off
    of a very old pre 1.0 spec. In actuality there isn't a ton of difference,
    and this YAML.pm is still fairly useful. Things will get much better in the
    future.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="RESOURCES"><a class="permalink" href="#RESOURCES">RESOURCES</a></h1>
<p class="Pp">&lt;http://lists.sourceforge.net/lists/listinfo/yaml-core&gt; is
    the mailing list. This is where the language is discussed and designed.</p>
<p class="Pp">&lt;http://www.yaml.org&gt; is the official YAML website.</p>
<p class="Pp">&lt;http://www.yaml.org/spec/&gt; is the YAML 1.2
  specification.</p>
<p class="Pp">&lt;http://yaml.kwiki.org&gt; is the official YAML wiki.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<dl class="Bl-tag">
  <dt>&#x2022;</dt>
  <dd>YAML::XS</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">Ingy d&#x00F6;t Net &lt;ingy@cpan.org&gt;</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT_AND_LICENSE"><a class="permalink" href="#COPYRIGHT_AND_LICENSE">COPYRIGHT
  AND LICENSE</a></h1>
<p class="Pp">Copyright 2001-2020. Ingy d&#x00F6;t Net.</p>
<p class="Pp">This program is free software; you can redistribute it and/or
    modify it under the same terms as Perl itself.</p>
<p class="Pp">See &lt;http://www.perl.com/perl/misc/Artistic.html&gt;</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2020-01-27</td>
    <td class="foot-os">perl v5.30.2</td>
  </tr>
</table>
</body>
</html>
