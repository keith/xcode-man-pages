<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Generated from file '/Library/Caches/com.apple.xbs/Sources/tcl/tcl-129/tcl_ext/tcllib/tcllib/modules/snit/snit.man' by tcllib/doctools with format 'nroff'
   Copyright (c) 2003-2009, by William H. Duquette
  
   The definitions below are for supplemental macros used in Tcl/Tk
   manual entries.
  
   .AP type name in/out ?indent?
  	Start paragraph describing an argument to a library procedure.
  	type is type of argument (int, etc.), in/out is either "in", "out",
  	or "in/out" to describe whether procedure reads or modifies arg,
  	and indent is equivalent to second arg of .IP (shouldn't ever be
  	needed;  use .AS below instead)
  
   .AS ?type? ?name?
  	Give maximum sizes of arguments for setting tab stops.  Type and
  	name are examples of largest possible arguments that will be passed
  	to .AP later.  If args are omitted, default tab stops are used.
  
   .BS
  	Start box enclosure.  From here until next .BE, everything will be
  	enclosed in one large box.
  
   .BE
  	End of box enclosure.
  
   .CS
  	Begin code excerpt.
  
   .CE
  	End code excerpt.
  
   .VS ?version? ?br?
  	Begin vertical sidebar, for use in marking newly-changed parts
  	of man pages.  The first argument is ignored and used for recording
  	the version when the .VS was added, so that the sidebars can be
  	found and removed when they reach a certain age.  If another argument
  	is present, then a line break is forced before starting the sidebar.
  
   .VE
  	End of vertical sidebar.
  
   .DS
  	Begin an indented unfilled display.
  
   .DE
  	End of indented unfilled display.
  
   .SO
  	Start of list of standard options for a Tk widget.  The
  	options follow on successive lines, in four columns separated
  	by tabs.
  
   .SE
  	End of list of standard options for a Tk widget.
  
   .OP cmdName dbName dbClass
  	Start of description of a specific option.  cmdName gives the
  	option's name as specified in the class command, dbName gives
  	the option's name in the option database, and dbClass gives
  	the option's class in the option database.
  
   .UL arg1 arg2
  	Print arg1 underlined, then print arg2 normally.
  
   RCS: @(#) $Id: man.macros,v 1.1 2009/01/30 04:56:47 andreas_kupries Exp $
  
  	# Set up traps and other miscellaneous stuff for Tcl/Tk man pages.
  	# Start an argument description
  .b
  	# define tabbing values for .AP
  
  	# BS - start boxed text
  	# ^y = starting y location
  	# ^b = 1
  	# BE - end boxed text (draw box now)
  	Draw four-sided box normally, but don't draw top of
  	box if the box started on an earlier page.
  	# VS - start vertical sidebar
  	# ^Y = starting y location
  	# ^v = 1 (for troff;  for nroff this doesn't matter)
  	# VE - end of vertical sidebar
  	# Special macro to handle page bottom:  finish off current
  	# box/sidebar if in box/sidebar mode, then invoked standard
  	# page bottom macro.
  	Draw three-sided box if this is the box's first page,
  	draw two sides but no top otherwise.
  	# DS - begin display
  	# DE - end display
  	# SO - start of list of standard options
  	# SE - end of list of standard options
  	# OP - start of full description for a single option
  	# CS - begin code excerpt
  	# CE - end code excerpt
 -->
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>snit(n)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">snit(n)</td>
    <td class="head-vol">Snit's Not Incr Tcl, OO system</td>
    <td class="head-rtitle">snit(n)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<pre>

</pre>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
snit - Snit's Not Incr Tcl
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
package require <b>Tcl 8.5</b>
<p class="Pp">package require <b>snit ?2.3.2?</b></p>
<p class="Pp"><b>snit::type</b> <i>name</i> <i>definition</i></p>
<p class="Pp"><b>typevariable</b> <i>name</i> ?<b>-array</b>? ?<i>value</i>?</p>
<p class="Pp"><b>typemethod</b> <i>name</i> <i>arglist</i> <i>body</i></p>
<p class="Pp"><b>typeconstructor</b> <i>body</i></p>
<p class="Pp"><b>variable</b> <i>name</i> ?<b>-array</b>? ?<i>value</i>?</p>
<p class="Pp"><b>method</b> <i>name</i> <i>arglist</i> <i>body</i></p>
<p class="Pp"><b>option</b> <i>namespec</i> ?<i>defaultValue</i>?</p>
<p class="Pp"><b>option</b> <i>namespec</i> ?<i>options...</i>?</p>
<p class="Pp"><b>constructor</b> <i>arglist</i> <i>body</i></p>
<p class="Pp"><b>destructor</b> <i>body</i></p>
<p class="Pp"><b>proc</b> <i>name</i> <i>args</i> <i>body</i></p>
<p class="Pp"><b>delegate</b> <b>method</b> <i>name</i> <b>to</b> <i>comp</i>
    ?<b>as</b> <i>target</i>?</p>
<p class="Pp"><b>delegate</b> <b>method</b> <i>name</i> ?<b>to</b> <i>comp</i>?
    <b>using</b> <i>pattern</i></p>
<p class="Pp"><b>delegate</b> <b>method</b> <b>*</b> ?<b>to</b> <i>comp</i>?
    ?<b>using</b> <i>pattern</i>? ?<b>except</b> <i>exceptions</i>?</p>
<p class="Pp"><b>delegate</b> <b>option</b> <i>namespec</i> <b>to</b>
    <i>comp</i></p>
<p class="Pp"><b>delegate</b> <b>option</b> <i>namespec</i> <b>to</b>
    <i>comp</i> <b>as</b> <i>target</i></p>
<p class="Pp"><b>delegate</b> <b>option</b> <b>*</b> <b>to</b> <i>comp</i></p>
<p class="Pp"><b>delegate</b> <b>option</b> <b>*</b> <b>to</b> <i>comp</i>
    <b>except</b> <i>exceptions</i></p>
<p class="Pp"><b>component</b> <i>comp</i> ?<b>-public</b> <i>method</i>?
    ?<b>-inherit</b> <i>flag</i>?</p>
<p class="Pp"><b>delegate</b> <b>typemethod</b> <i>name</i> <b>to</b>
    <i>comp</i> ?<b>as</b> <i>target</i>?</p>
<p class="Pp"><b>delegate</b> <b>typemethod</b> <i>name</i> ?<b>to</b>
    <i>comp</i>? <b>using</b> <i>pattern</i></p>
<p class="Pp"><b>delegate</b> <b>typemethod</b> <b>*</b> ?<b>to</b> <i>comp</i>?
    ?<b>using</b> <i>pattern</i>? ?<b>except</b> <i>exceptions</i>?</p>
<p class="Pp"><b>typecomponent</b> <i>comp</i> ?<b>-public</b>
    <i>typemethod</i>? ?<b>-inherit</b> <i>flag</i>?</p>
<p class="Pp"><b>pragma</b> ?<i>options...</i>?</p>
<p class="Pp"><b>expose</b> <i>comp</i></p>
<p class="Pp"><b>expose</b> <i>comp</i> <b>as</b> <i>method</i></p>
<p class="Pp"><b>onconfigure</b> <i>name</i> <i>arglist</i> <i>body</i></p>
<p class="Pp"><b>oncget</b> <i>name</i> <i>body</i></p>
<p class="Pp"><b>snit::widget</b> <i>name</i> <i>definition</i></p>
<p class="Pp"><b>widgetclass</b> <i>name</i></p>
<p class="Pp"><b>hulltype</b> <i>type</i></p>
<p class="Pp"><b>snit::widgetadaptor</b> <i>name</i> <i>definition</i></p>
<p class="Pp"><b>snit::typemethod</b> <i>type</i> <i>name</i> <i>arglist</i>
    <i>body</i></p>
<p class="Pp"><b>snit::method</b> <i>type</i> <i>name</i> <i>arglist</i>
    <i>body</i></p>
<p class="Pp"><b>snit::macro</b> <i>name</i> <i>arglist</i> <i>body</i></p>
<p class="Pp"><b>snit::compile</b> <i>which</i> <i>type</i> <i>body</i></p>
<p class="Pp"><b>$type</b> <i>typemethod</i> <i>args</i>...</p>
<p class="Pp"><b>$type</b> <b>create</b> <i>name</i> ?<i>option</i> <i>value</i>
    ...?</p>
<p class="Pp"><b>$type</b> <b>info typevars</b> ?<i>pattern</i>?</p>
<p class="Pp"><b>$type</b> <b>info typemethods</b> ?<i>pattern</i>?</p>
<p class="Pp"><b>$type</b> <b>info args</b> <i>method</i></p>
<p class="Pp"><b>$type</b> <b>info body</b> <i>method</i></p>
<p class="Pp"><b>$type</b> <b>info default</b> <i>method</i> <i>aname</i>
    <i>varname</i></p>
<p class="Pp"><b>$type</b> <b>info instances</b> ?<i>pattern</i>?</p>
<p class="Pp"><b>$type</b> <b>destroy</b></p>
<p class="Pp"><b>$object</b> <i>method</i> <i>args...</i></p>
<p class="Pp"><b>$object</b> <b>configure</b> ?<i>option</i>? ?<i>value</i>?
  ...</p>
<p class="Pp"><b>$object</b> <b>configurelist</b> <i>optionlist</i></p>
<p class="Pp"><b>$object</b> <b>cget</b> <i>option</i></p>
<p class="Pp"><b>$object</b> <b>destroy</b></p>
<p class="Pp"><b>$object</b> <b>info type</b></p>
<p class="Pp"><b>$object</b> <b>info vars</b> ?<i>pattern</i>?</p>
<p class="Pp"><b>$object</b> <b>info typevars</b> ?<i>pattern</i>?</p>
<p class="Pp"><b>$object</b> <b>info typemethods</b> ?<i>pattern</i>?</p>
<p class="Pp"><b>$object</b> <b>info options</b> ?<i>pattern</i>?</p>
<p class="Pp"><b>$object</b> <b>info methods</b> ?<i>pattern</i>?</p>
<p class="Pp"><b>$object</b> <b>info args</b> <i>method</i></p>
<p class="Pp"><b>$object</b> <b>info body</b> <i>method</i></p>
<p class="Pp"><b>$object</b> <b>info default</b> <i>method</i> <i>aname</i>
    <i>varname</i></p>
<p class="Pp"><b>mymethod</b> <i>name</i> ?<i>args...</i>?</p>
<p class="Pp"><b>mytypemethod</b> <i>name</i> ?<i>args...</i>?</p>
<p class="Pp"><b>myproc</b> <i>name</i> ?<i>args...</i>?</p>
<p class="Pp"><b>myvar</b> <i>name</i></p>
<p class="Pp"><b>mytypevar</b> <i>name</i></p>
<p class="Pp"><b>from</b> <i>argvName</i> <i>option</i> ?<i>defvalue</i>?</p>
<p class="Pp"><b>install</b> <i>compName</i> <b>using</b> <i>objType</i>
    <i>objName</i> <i>args...</i></p>
<p class="Pp"><b>installhull</b> <b>using</b> <i>widgetType</i>
  <i>args...</i></p>
<p class="Pp"><b>installhull</b> <i>name</i></p>
<p class="Pp"><b>variable</b> <i>name</i></p>
<p class="Pp"><b>typevariable</b> <i>name</i></p>
<p class="Pp"><b>varname</b> <i>name</i></p>
<p class="Pp"><b>typevarname</b> <i>name</i></p>
<p class="Pp"><b>codename</b> <i>name</i></p>
<p class="Pp"><b>snit::boolean</b> <b>validate</b> ?<i>value</i>?</p>
<p class="Pp"><b>snit::boolean</b> <i>name</i></p>
<p class="Pp"><b>snit::double</b> <b>validate</b> ?<i>value</i>?</p>
<p class="Pp"><b>snit::double</b> <i>name</i> ?<i>option</i>
  <i>value</i>...?</p>
<p class="Pp"><b>snit::enum</b> <b>validate</b> ?<i>value</i>?</p>
<p class="Pp"><b>snit::enum</b> <i>name</i> ?<i>option</i> <i>value</i>...?</p>
<p class="Pp"><b>snit::fpixels</b> <b>validate</b> ?<i>value</i>?</p>
<p class="Pp"><b>snit::fpixels</b> <i>name</i> ?<i>option</i>
  <i>value</i>...?</p>
<p class="Pp"><b>snit::integer</b> <b>validate</b> ?<i>value</i>?</p>
<p class="Pp"><b>snit::integer</b> <i>name</i> ?<i>option</i>
  <i>value</i>...?</p>
<p class="Pp"><b>snit::listtype</b> <b>validate</b> ?<i>value</i>?</p>
<p class="Pp"><b>snit::listtype</b> <i>name</i> ?<i>option</i>
  <i>value</i>...?</p>
<p class="Pp"><b>snit::pixels</b> <b>validate</b> ?<i>value</i>?</p>
<p class="Pp"><b>snit::pixels</b> <i>name</i> ?<i>option</i>
  <i>value</i>...?</p>
<p class="Pp"><b>snit::stringtype</b> <b>validate</b> ?<i>value</i>?</p>
<p class="Pp"><b>snit::stringtype</b> <i>name</i> ?<i>option</i>
    <i>value</i>...?</p>
<p class="Pp"><b>snit::window</b> <b>validate</b> ?<i>value</i>?</p>
<p class="Pp"><b>snit::window</b> <i>name</i></p>
<p class="Pp"></p>
<pre>

</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
Snit is a pure Tcl object and megawidget system. It's unique among Tcl object
  systems in that it's based not on inheritance but on delegation. Object
  systems based on inheritance only allow you to inherit from classes defined
  using the same system, which is limiting. In Tcl, an object is anything that
  acts like an object; it shouldn't matter how the object was implemented. Snit
  is intended to help you build applications out of the materials at hand; thus,
  Snit is designed to be able to incorporate and build on any object, whether
  it's a hand-coded object, a <b>Tk</b> widget, an <b>Incr Tcl</b> object, a
  <b>BWidget</b> or almost anything else.
<p class="Pp">This man page is intended to be a reference only; see the
    accompanying <b>snitfaq</b> for a gentler, more tutorial introduction to
    Snit concepts.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SNIT_VERSIONS"><a class="permalink" href="#SNIT_VERSIONS">SNIT
  VERSIONS</a></h1>
This man page covers both Snit 2.2 and Snit 1.3. The primary difference between
  the two versions is simply that Snit 2.2 contains speed optimizations based on
  new features of Tcl 8.5; Snit 1.3 supports all of Tcl 8.3, 8.4 and Tcl 8.5.
  There are a few minor inconsistencies; they are flagged in the body of the man
  page with the label &quot;Snit 1.x Incompatibility&quot;; they are also
  discussed in the <b>snitfaq</b>.
</section>
<section class="Sh">
<h1 class="Sh" id="REFERENCE"><a class="permalink" href="#REFERENCE">REFERENCE</a></h1>
<section class="Ss">
<h2 class="Ss" id="TYPE_AND_WIDGET_DEFINITIONS"><a class="permalink" href="#TYPE_AND_WIDGET_DEFINITIONS">TYPE
  AND WIDGET DEFINITIONS</a></h2>
Snit provides the following commands for defining new types:
<dl class="Bl-tag">
  <dt><b>snit::type</b> <i>name</i> <i>definition</i></dt>
  <dd>Defines a new abstract data type called <i>name</i>. If <i>name</i> is not
      a fully qualified command name, it is assumed to be a name in the
      namespace in which the <b>snit::type</b> command was called (usually the
      global namespace). It returns the fully qualified name of the new type.
    <p class="Pp">The type name is then a command that is used to create objects
        of the new type, along with other activities.</p>
    <p class="Pp">The <b>snit::type</b> <i>definition</i> block is a script that
        may contain the following definitions:</p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>typevariable</b> <i>name</i> ?<b>-array</b>? ?<i>value</i>?</dt>
  <dd>Defines a type variable with the specified <i>name</i>, and optionally the
      specified <i>value</i>. Type variables are shared by all instances of the
      type. If the <b>-array</b> option is included, then <i>value</i> should be
      a dictionary; it will be assigned to the variable using <b>array
    set</b>.</dd>
  <dt><b>typemethod</b> <i>name</i> <i>arglist</i> <i>body</i></dt>
  <dd>Defines a type method, a subcommand of the new type command, with the
      specified name, argument list, and body. The <i>arglist</i> is a normal
      Tcl argument list and may contain default arguments and the <b>args</b>
      argument; however, it may not contain the argument names <b>type</b>,
      <b>self</b>, <b>selfns</b>, or <b>win</b>.
    <p class="Pp">The variable <b>type</b> is automatically defined in the
        <i>body</i> to the type's fully-qualified name. In addition, type
        variables are automatically visible in the <i>body</i> of every type
        method.</p>
    <p class="Pp">If the <i>name</i> consists of two or more tokens, Snit
        handles it specially:</p>
    <pre>
    typemethod {a b} {arg} { puts &quot;Got $arg&quot; }
    </pre>
    This statement implicitly defines a type method called <b>a</b> which has a
      subcommand <b>b</b>. <b>b</b> is called like this:
    <pre>
    $type a b &quot;Hello, world!&quot;
    </pre>
    <b>a</b> may have any number of subcommands. This makes it possible to
      define a hierarchical command structure; see <b>method</b>, below, for
      more examples.
    <p class="Pp">Type methods can call commands from the namespace in which the
        type is defined without importing them, e.g., if the type name is
        <b>::parentns::typename</b>, then the type's type methods can call
        <b>::parentns::someproc</b> just as <b>someproc</b>. <i>Snit 1.x
        Incompatibility:</i> This does not work in Snit 1.x, as it depends on
        <b>namespace path</b>, a new command in Tcl 8.5.</p>
    <p class="Pp"><i>Snit 1.x Incompatibility:</i> In Snit 1.x, the following
        following two calls to this type method are equivalent:</p>
    <pre>
    $type a b &quot;Hello, world!&quot;
    $type {a b} &quot;Hello, world!&quot;
    </pre>
    In Snit 2.2, the second form is invalid.</dd>
  <dt><b>typeconstructor</b> <i>body</i></dt>
  <dd>The type constructor's <i>body</i> is executed once when the type is first
      defined; it is typically used to initialize array-valued type variables
      and to add entries to <b>The Tk Option Database</b>.
    <p class="Pp">The variable <b>type</b> is automatically defined in the
        <i>body</i>, and contains the type's fully-qualified name. In addition,
        type variables are automatically visible in the <i>body</i> of the type
        constructor.</p>
    <p class="Pp">A type may define at most one type constructor.</p>
    <p class="Pp">The type constructor can call commands from the namespace in
        which the type is defined without importing them, e.g., if the type name
        is <b>::parentns::typename</b>, then the type constructor can call
        <b>::parentns::someproc</b> just as <b>someproc</b>. <i>Snit 1.x
        Incompatibility:</i> This does not work in Snit 1.x, as it depends on
        <b>namespace path</b>, a new command in Tcl 8.5.</p>
  </dd>
  <dt><b>variable</b> <i>name</i> ?<b>-array</b>? ?<i>value</i>?</dt>
  <dd>Defines an instance variable, a private variable associated with each
      instance of this type, and optionally its initial value. If the
      <b>-array</b> option is included, then <i>value</i> should be a
      dictionary; it will be assigned to the variable using <b>array
    set</b>.</dd>
  <dt><b>method</b> <i>name</i> <i>arglist</i> <i>body</i></dt>
  <dd>Defines an instance method, a subcommand of each instance of this type,
      with the specified name, argument list and body. The <i>arglist</i> is a
      normal Tcl argument list and may contain default arguments and the
      <b>args</b> argument.
    <p class="Pp">The method is implicitly passed the following arguments as
        well: <b>type</b>, which contains the fully-qualified type name;
        <b>self</b>, which contains the current instance command name;
        <b>selfns</b>, which contains the name of the instance's private
        namespace; and <b>win</b>, which contains the original instance name.
        Consequently, the <i>arglist</i> may not contain the argument names
        <b>type</b>, <b>self</b>, <b>selfns</b>, or <b>win</b>.</p>
    <p class="Pp">An instance method defined in this way is said to be
        <i>locally defined</i>.</p>
    <p class="Pp">Type and instance variables are automatically visible in all
        instance methods. If the type has locally defined options, the
        <b>options</b> array is also visible.</p>
    <p class="Pp">If the <i>name</i> consists of two or more tokens, Snit
        handles it specially:</p>
    <pre>
    method {a b} {} { ... }
    </pre>
    This statement implicitly defines a method called <b>a</b> which has a
      subcommand <b>b</b>. <b>b</b> is called like this:
    <pre>
    $self a b &quot;Hello, world!&quot;
    </pre>
    <b>a</b> may have any number of subcommands. This makes it possible to
      define a hierarchical command structure:
    <pre>
% snit::type dog {
    method {tail wag}   {} {return &quot;Wag, wag&quot;}
    method {tail droop} {} {return &quot;Droop, droop&quot;}
}
::dog
% dog spot
::spot
% spot tail wag
Wag, wag
% spot tail droop
Droop, droop
%
    </pre>
    What we've done is implicitly defined a &quot;tail&quot; method with
      subcommands &quot;wag&quot; and &quot;droop&quot;. Consequently, it's an
      error to define &quot;tail&quot; explicitly.
    <p class="Pp">Methods can call commands from the namespace in which the type
        is defined without importing them, e.g., if the type name is
        <b>::parentns::typename</b>, then the type's methods can call
        <b>::parentns::someproc</b> just as <b>someproc</b>. <i>Snit 1.x
        Incompatibility:</i> This does not work in Snit 1.x, as it depends on
        <b>namespace path</b>, a new command in Tcl 8.5.</p>
    <p class="Pp"><i>Snit 1.x Incompatibility:</i> In Snit 1.x, the following
        following two calls to this method are equivalent:</p>
    <pre>
    $self a b &quot;Hello, world!&quot;
    $self {a b} &quot;Hello, world!&quot;
    </pre>
    In Snit 2.2, the second form is invalid.</dd>
  <dt><b>option</b> <i>namespec</i> ?<i>defaultValue</i>?</dt>
  <dd></dd>
  <dt><b>option</b> <i>namespec</i> ?<i>options...</i>?</dt>
  <dd>Defines an option for instances of this type, and optionally gives it an
      initial value. The initial value defaults to the empty string if no
      <i>defaultValue</i> is specified.
    <p class="Pp">An option defined in this way is said to be <i>locally
        defined</i>.</p>
    <p class="Pp">The <i>namespec</i> is a list defining the option's name,
        resource name, and class name, e.g.:</p>
    <pre>
    option {-font font Font} {Courier 12}
    </pre>
    The option name must begin with a hyphen, and must not contain any upper
      case letters. The resource name and class name are optional; if not
      specified, the resource name defaults to the option name, minus the
      hyphen, and the class name defaults to the resource name with the first
      letter capitalized. Thus, the following statement is equivalent to the
      previous example:
    <pre>
    option -font {Courier 12}
    </pre>
    See <b>The Tk Option Database</b> for more information about resource and
      class names.
    <p class="Pp">Options are normally set and retrieved using the standard
        instance methods <b>configure</b> and <b>cget</b>; within instance code
        (method bodies, etc.), option values are available through the
        <b>options</b> array:</p>
    <pre>
    set myfont $options(-font)
    </pre>
    If the type defines any option handlers (e.g., <b>-configuremethod</b>),
      then it should probably use <b>configure</b> and <b>cget</b> to access its
      options to avoid subtle errors.
    <p class="Pp">The <b>option</b> statement may include the following
      options:</p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>-default</b> <i>defvalue</i></dt>
  <dd>Defines the option's default value; the option's default value will be
      &quot;&quot; otherwise.</dd>
  <dt><b>-readonly</b> <i>flag</i></dt>
  <dd>The <i>flag</i> can be any Boolean value recognized by Tcl. If <i>flag</i>
      is true, then the option is read-only--it can only be set using
      <b>configure</b> or <b>configurelist</b> at creation time, i.e., in the
      type's constructor.</dd>
  <dt><b>-type</b> <i>type</i></dt>
  <dd>Every locally-defined option may define its validation type, which may be
      either the name of a validation type or a specification for a validation
      subtype
    <p class="Pp">For example, an option may declare that its value must be an
        integer by specifying <b>snit::integer</b> as its validation type:</p>
    <pre>
    option -number -type snit::integer
    </pre>
    It may also declare that its value is an integer between 1 and 10 by
      specifying a validation subtype:
    <pre>
    option -number -type {snit::integer -min 1 -max 10}
    </pre>
    If a validation type or subtype is defined for an option, then it will be
      used to validate the option's value whenever it is changed by the object's
      <b>configure</b> or <b>configurelist</b> methods. In addition, all such
      options will have their values validated automatically immediately after
      the constructor executes.
    <p class="Pp">Snit defines a family of validation types and subtypes, and
        it's quite simple to define new ones. See <b>Validation Types</b> for
        the complete list, and <b>Defining Validation Types</b> for an
        explanation of how to define your own.</p>
  </dd>
  <dt><b>-cgetmethod</b> <i>methodName</i></dt>
  <dd>Every locally-defined option may define a <b>-cgetmethod</b>; it is called
      when the option's value is retrieved using the <b>cget</b> method.
      Whatever the method's <i>body</i> returns will be the return value of the
      call to <b>cget</b>.
    <p class="Pp">The named method must take one argument, the option name. For
        example, this code is equivalent to (though slower than) Snit's default
        handling of <b>cget</b>:</p>
    <pre>
    option -font -cgetmethod GetOption
    method GetOption {option} {
        return $options($option)
    }
    </pre>
    Note that it's possible for any number of options to share a
      <b>-cgetmethod</b>.</dd>
  <dt><b>-configuremethod</b> <i>methodName</i></dt>
  <dd>Every locally-defined option may define a <b>-configuremethod</b>; it is
      called when the option's value is set using the <b>configure</b> or
      <b>configurelist</b> methods. It is the named method's responsibility to
      save the option's value; in other words, the value will not be saved to
      the <b>options()</b> array unless the method saves it there.
    <p class="Pp">The named method must take two arguments, the option name and
        its new value. For example, this code is equivalent to (though slower
        than) Snit's default handling of <b>configure</b>:</p>
    <pre>
    option -font -configuremethod SetOption
    method SetOption {option value} {
        set options($option) $value
    }
    </pre>
    Note that it's possible for any number of options to share a single
      <b>-configuremethod</b>.</dd>
  <dt><b>-validatemethod</b> <i>methodName</i></dt>
  <dd>Every locally-defined option may define a <b>-validatemethod</b>; it is
      called when the option's value is set using the <b>configure</b> or
      <b>configurelist</b> methods, just before the <b>-configuremethod</b> (if
      any). It is the named method's responsibility to validate the option's new
      value, and to throw an error if the value is invalid.
    <p class="Pp">The named method must take two arguments, the option name and
        its new value. For example, this code verifies that <b>-flag</b>'s value
        is a valid Boolean value:</p>
    <pre>
    option -font -validatemethod CheckBoolean
    method CheckBoolean {option value} {
        if {![string is boolean -strict $value]} {
            error &quot;option $option must have a boolean value.&quot;
        }
    }
    </pre>
    Note that it's possible for any number of options to share a single
      <b>-validatemethod</b>.</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt><b>constructor</b> <i>arglist</i> <i>body</i></dt>
  <dd>The constructor definition specifies a <i>body</i> of code to be executed
      when a new instance is created. The <i>arglist</i> is a normal Tcl
      argument list and may contain default arguments and the <b>args</b>
      argument.
    <p class="Pp">As with methods, the arguments <b>type</b>, <b>self</b>,
        <b>selfns</b>, and <b>win</b> are defined implicitly, and all type and
        instance variables are automatically visible in its <i>body</i>.</p>
    <p class="Pp">If the <i>definition</i> doesn't explicitly define the
        constructor, Snit defines one implicitly. If the type declares at least
        one option (whether locally or by delegation), the default constructor
        will be defined as follows:</p>
    <pre>
    constructor {args} {
        $self configurelist $args
    }
    </pre>
    For standard Tk widget behavior, the argument list should be the single name
      <b>args</b>, as shown.
    <p class="Pp">If the <i>definition</i> defines neither a constructor nor any
        options, the default constructor is defined as follows:</p>
    <pre>
    constructor {} {}
    </pre>
    As with methods, the constructor can call commands from the namespace in
      which the type is defined without importing them, e.g., if the type name
      is <b>::parentns::typename</b>, then the constructor can call
      <b>::parentns::someproc</b> just as <b>someproc</b>. <i>Snit 1.x
      Incompatibility:</i> This does not work in Snit 1.x, as it depends on
      <b>namespace path</b>, a new command in Tcl 8.5.</dd>
  <dt><b>destructor</b> <i>body</i></dt>
  <dd>The destructor is used to code any actions that must take place when an
      instance of the type is destroyed: typically, the destruction of anything
      created in the constructor.
    <p class="Pp">The destructor takes no explicit arguments; as with methods,
        the arguments <b>type</b>, <b>self</b>, <b>selfns</b>, and <b>win</b>,
        are defined implicitly, and all type and instance variables are
        automatically visible in its <i>body</i>. As with methods, the
        destructor can call commands from the namespace in which the type is
        defined without importing them, e.g., if the type name is
        <b>::parentns::typename</b>, then the destructor can call
        <b>::parentns::someproc</b> just as <b>someproc</b>. <i>Snit 1.x
        Incompatibility:</i> This does not work in Snit 1.x, as it depends on
        <b>namespace path</b>, a new command in Tcl 8.5.</p>
  </dd>
  <dt><b>proc</b> <i>name</i> <i>args</i> <i>body</i></dt>
  <dd>Defines a new Tcl procedure in the type's namespace.
    <p class="Pp">The defined proc differs from a normal Tcl proc in that all
        type variables are automatically visible. The proc can access instance
        variables as well, provided that it is passed <b>selfns</b> (with
        precisely that name) as one of its arguments.</p>
    <p class="Pp">Although they are not implicitly defined for procs, the
        argument names <b>type</b>, <b>self</b>, and <b>win</b> should be
        avoided.</p>
    <p class="Pp">As with methods and typemethods, procs can call commands from
        the namespace in which the type is defined without importing them, e.g.,
        if the type name is <b>::parentns::typename</b>, then the proc can call
        <b>::parentns::someproc</b> just as <b>someproc</b>. <i>Snit 1.x
        Incompatibility:</i> This does not work in Snit 1.x, as it depends on
        <b>namespace path</b>, a new command in Tcl 8.5.</p>
  </dd>
  <dt><b>delegate</b> <b>method</b> <i>name</i> <b>to</b> <i>comp</i> ?<b>as</b>
    <i>target</i>?</dt>
  <dd>Delegates method <i>name</i> to component <i>comp</i>. That is, when
      method <i>name</i> is called on an instance of this type, the method and
      its arguments will be passed to the named component's command instead.
      That is, the following statement
    <pre>
    delegate method wag to tail
    </pre>
    is roughly equivalent to this explicitly defined method:
    <pre>
    method wag {args} {
        uplevel $tail wag $args
    }
    </pre>
    As with methods, the <i>name</i> may have multiple tokens; in this case, the
      last token of the name is assumed to be the name of the component's
      method.
    <p class="Pp">The optional <b>as</b> clause allows you to specify the
        delegated method name and possibly add some arguments:</p>
    <pre>
    delegate method wagtail to tail as &quot;wag briskly&quot;
    </pre>
    <p class="Pp">A method cannot be both locally defined and delegated.</p>
    <p class="Pp"><b>Note:</b> All forms of <b>delegate method</b> can delegate
        to both instance components and type components.</p>
  </dd>
  <dt><b>delegate</b> <b>method</b> <i>name</i> ?<b>to</b> <i>comp</i>?
    <b>using</b> <i>pattern</i></dt>
  <dd>In this form of the <b>delegate</b> statement, the <b>using</b> clause is
      used to specify the precise form of the command to which method
      <i>name</i> name is delegated. In this form, the <b>to</b> clause is
      optional, since the chosen command might not involve any particular
      component.
    <p class="Pp">The value of the <b>using</b> clause is a list that may
        contain any or all of the following substitution codes; these codes are
        substituted with the described value to build the delegated command
        prefix. Note that the following two statements are equivalent:</p>
    <pre>
    delegate method wag to tail
    delegate method wag to tail using &quot;%c %m&quot;
    </pre>
    Each element of the list becomes a single element of the delegated
      command--it is never reparsed as a string.
    <p class="Pp">Substitutions:</p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>%%</b></dt>
  <dd>This is replaced with a single &quot;%&quot;. Thus, to pass the string
      &quot;%c&quot; to the command as an argument, you'd write
    &quot;%%c&quot;.</dd>
  <dt><b>%c</b></dt>
  <dd>This is replaced with the named component's command.</dd>
  <dt><b>%m</b></dt>
  <dd>This is replaced with the final token of the method <i>name</i>; if the
      method <i>name</i> has one token, this is identical to <b>%M</b>.</dd>
  <dt><b>%M</b></dt>
  <dd>This is replaced by the method <i>name</i>; if the <i>name</i> consists of
      multiple tokens, they are joined by space characters.</dd>
  <dt><b>%j</b></dt>
  <dd>This is replaced by the method <i>name</i>; if the <i>name</i> consists of
      multiple tokens, they are joined by underscores (&quot;_&quot;).</dd>
  <dt><b>%t</b></dt>
  <dd>This is replaced with the fully qualified type name.</dd>
  <dt><b>%n</b></dt>
  <dd>This is replaced with the name of the instance's private namespace.</dd>
  <dt><b>%s</b></dt>
  <dd>This is replaced with the name of the instance command.</dd>
  <dt><b>%w</b></dt>
  <dd>This is replaced with the original name of the instance command; for Snit
      widgets and widget adaptors, it will be the Tk window name. It remains
      constant, even if the instance command is renamed.</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt><b>delegate</b> <b>method</b> <b>*</b> ?<b>to</b> <i>comp</i>?
    ?<b>using</b> <i>pattern</i>? ?<b>except</b> <i>exceptions</i>?</dt>
  <dd>The form <b>delegate method *</b> delegates all unknown method names to
      the specified <i>comp</i>onent. The <b>except</b> clause can be used to
      specify a list of <i>exceptions</i>, i.e., method names that will not be
      so delegated. The <b>using</b> clause is defined as given above. In this
      form, the statement must contain the <b>to</b> clause, the <b>using</b>
      clause, or both.
    <p class="Pp">In fact, the &quot;*&quot; can be a list of two or more tokens
        whose last element is &quot;*&quot;, as in the following example:</p>
    <pre>
    delegate method {tail *} to tail
    </pre>
    This implicitly defines the method <b>tail</b> whose subcommands will be
      delegated to the <b>tail</b> component.</dd>
  <dt><b>delegate</b> <b>option</b> <i>namespec</i> <b>to</b> <i>comp</i></dt>
  <dd></dd>
  <dt><b>delegate</b> <b>option</b> <i>namespec</i> <b>to</b> <i>comp</i>
    <b>as</b> <i>target</i></dt>
  <dd></dd>
  <dt><b>delegate</b> <b>option</b> <b>*</b> <b>to</b> <i>comp</i></dt>
  <dd></dd>
  <dt><b>delegate</b> <b>option</b> <b>*</b> <b>to</b> <i>comp</i> <b>except</b>
    <i>exceptions</i></dt>
  <dd>Defines a delegated option; the <i>namespec</i> is defined as for the
      <b>option</b> statement. When the <b>configure</b>, <b>configurelist</b>,
      or <b>cget</b> instance method is used to set or retrieve the option's
      value, the equivalent <b>configure</b> or <b>cget</b> command will be
      applied to the component as though the option was defined with the
      following <b>-configuremethod</b> and <b>-cgetmethod</b>:
    <pre>
    method ConfigureMethod {option value} {
        $comp configure $option $value
    }
    method CgetMethod {option} {
        return [$comp cget $option]
    }
    </pre>
    Note that delegated options never appear in the <b>options</b> array.
    <p class="Pp">If the <b>as</b> clause is specified, then the <i>target</i>
        option name is used in place of <i>name</i>.</p>
    <p class="Pp">The form <b>delegate option *</b> delegates all unknown
        options to the specified <i>comp</i>onent. The <b>except</b> clause can
        be used to specify a list of <i>exceptions</i>, i.e., option names that
        will not be so delegated.</p>
    <p class="Pp">Warning: options can only be delegated to a component if it
        supports the <b>configure</b> and <b>cget</b> instance methods.</p>
    <p class="Pp">An option cannot be both locally defined and delegated. TBD:
        Continue from here.</p>
  </dd>
  <dt><b>component</b> <i>comp</i> ?<b>-public</b> <i>method</i>?
    ?<b>-inherit</b> <i>flag</i>?</dt>
  <dd>Explicitly declares a component called <i>comp</i>, and automatically
      defines the component's instance variable.
    <p class="Pp">If the <b>-public</b> option is specified, then the option is
        made public by defining a <i>method</i> whose subcommands are delegated
        to the component e.g., specifying <b>-public mycomp</b> is equivalent to
        the following:</p>
    <pre>
    component mycomp
    delegate method {mymethod *} to mycomp
    </pre>
    If the <b>-inherit</b> option is specified, then <i>flag</i> must be a
      Boolean value; if <i>flag</i> is true then all unknown methods and options
      will be delegated to this component. The name <b>-inherit</b> implies that
      instances of this new type inherit, in a sense, the methods and options of
      the component. That is, <b>-inherit yes</b> is equivalent to:
    <pre>
    component mycomp
    delegate option * to mycomp
    delegate method * to mycomp
    </pre>
  </dd>
  <dt><b>delegate</b> <b>typemethod</b> <i>name</i> <b>to</b> <i>comp</i>
    ?<b>as</b> <i>target</i>?</dt>
  <dd>Delegates type method <i>name</i> to type component <i>comp</i>. That is,
      when type method <i>name</i> is called on this type, the type method and
      its arguments will be passed to the named type component's command
      instead. That is, the following statement
    <pre>
    delegate typemethod lostdogs to pound
    </pre>
    is roughly equivalent to this explicitly defined method:
    <pre>
    typemethod lostdogs {args} {
        uplevel $pound lostdogs $args
    }
    </pre>
    As with type methods, the <i>name</i> may have multiple tokens; in this
      case, the last token of the name is assumed to be the name of the
      component's method.
    <p class="Pp">The optional <b>as</b> clause allows you to specify the
        delegated method name and possibly add some arguments:</p>
    <pre>
    delegate typemethod lostdogs to pound as &quot;get lostdogs&quot;
    </pre>
    <p class="Pp">A type method cannot be both locally defined and
      delegated.</p>
  </dd>
  <dt><b>delegate</b> <b>typemethod</b> <i>name</i> ?<b>to</b> <i>comp</i>?
    <b>using</b> <i>pattern</i></dt>
  <dd>In this form of the <b>delegate</b> statement, the <b>using</b> clause is
      used to specify the precise form of the command to which type method
      <i>name</i> name is delegated. In this form, the <b>to</b> clause is
      optional, since the chosen command might not involve any particular type
      component.
    <p class="Pp">The value of the <b>using</b> clause is a list that may
        contain any or all of the following substitution codes; these codes are
        substituted with the described value to build the delegated command
        prefix. Note that the following two statements are equivalent:</p>
    <pre>
    delegate typemethod lostdogs to pound
    delegate typemethod lostdogs to pound using &quot;%c %m&quot;
    </pre>
    Each element of the list becomes a single element of the delegated
      command--it is never reparsed as a string.
    <p class="Pp">Substitutions:</p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>%%</b></dt>
  <dd>This is replaced with a single &quot;%&quot;. Thus, to pass the string
      &quot;%c&quot; to the command as an argument, you'd write
    &quot;%%c&quot;.</dd>
  <dt><b>%c</b></dt>
  <dd>This is replaced with the named type component's command.</dd>
  <dt><b>%m</b></dt>
  <dd>This is replaced with the final token of the type method <i>name</i>; if
      the type method <i>name</i> has one token, this is identical to
    <b>%M</b>.</dd>
  <dt><b>%M</b></dt>
  <dd>This is replaced by the type method <i>name</i>; if the <i>name</i>
      consists of multiple tokens, they are joined by space characters.</dd>
  <dt><b>%j</b></dt>
  <dd>This is replaced by the type method <i>name</i>; if the <i>name</i>
      consists of multiple tokens, they are joined by underscores
      (&quot;_&quot;).</dd>
  <dt><b>%t</b></dt>
  <dd>This is replaced with the fully qualified type name.</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt><b>delegate</b> <b>typemethod</b> <b>*</b> ?<b>to</b> <i>comp</i>?
    ?<b>using</b> <i>pattern</i>? ?<b>except</b> <i>exceptions</i>?</dt>
  <dd>The form <b>delegate typemethod *</b> delegates all unknown type method
      names to the specified type component. The <b>except</b> clause can be
      used to specify a list of <i>exceptions</i>, i.e., type method names that
      will not be so delegated. The <b>using</b> clause is defined as given
      above. In this form, the statement must contain the <b>to</b> clause, the
      <b>using</b> clause, or both.
    <p class="Pp"><b>Note:</b> By default, Snit interprets <b>$type foo</b>,
        where <b>foo</b> is not a defined type method, as equivalent to <b>$type
        create foo</b>, where <b>foo</b> is the name of a new instance of the
        type. If you use <b>delegate typemethod *</b>, then the <b>create</b>
        type method must always be used explicitly.</p>
    <p class="Pp">The &quot;*&quot; can be a list of two or more tokens whose
        last element is &quot;*&quot;, as in the following example:</p>
    <pre>
    delegate typemethod {tail *} to tail
    </pre>
    This implicitly defines the type method <b>tail</b> whose subcommands will
      be delegated to the <b>tail</b> type component.</dd>
  <dt><b>typecomponent</b> <i>comp</i> ?<b>-public</b> <i>typemethod</i>?
    ?<b>-inherit</b> <i>flag</i>?</dt>
  <dd>Explicitly declares a type component called <i>comp</i>, and automatically
      defines the component's type variable. A type component is an arbitrary
      command to which type methods and instance methods can be delegated; the
      command's name is stored in a type variable.
    <p class="Pp">If the <b>-public</b> option is specified, then the type
        component is made public by defining a <i>typemethod</i> whose
        subcommands are delegated to the type component, e.g., specifying
        <b>-public mytypemethod</b> is equivalent to the following:</p>
    <pre>
    typecomponent mycomp
    delegate typemethod {mytypemethod *} to mycomp
    </pre>
    If the <b>-inherit</b> option is specified, then <i>flag</i> must be a
      Boolean value; if <i>flag</i> is true then all unknown type methods will
      be delegated to this type component. (See the note on &quot;delegate
      typemethod *&quot;, above.) The name <b>-inherit</b> implies that this
      type inherits, in a sense, the behavior of the type component. That is,
      <b>-inherit yes</b> is equivalent to:
    <pre>
    typecomponent mycomp
    delegate typemethod * to mycomp
    </pre>
  </dd>
  <dt><b>pragma</b> ?<i>options...</i>?</dt>
  <dd>The <b>pragma</b> statement provides control over how Snit generates a
      type. It takes the following options; in each case, <i>flag</i> must be a
      Boolean value recognized by Tcl, e.g., <b>0</b>, <b>1</b>, <b>yes</b>,
      <b>no</b>, and so on.
    <p class="Pp">By setting the <b>-hastypeinfo</b>, <b>-hastypedestroy</b>,
        and <b>-hasinstances</b> pragmas to false and defining appropriate type
        methods, you can create an ensemble command without any extraneous
        behavior.</p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>-canreplace</b> <i>flag</i></dt>
  <dd>If false (the default) Snit will not create an instance of a
      <b>snit::type</b> that has the same name as an existing command; this
      prevents subtle errors. Setting this pragma to true restores the behavior
      of Snit V0.93 and earlier versions.</dd>
  <dt><b>-hastypeinfo</b> <i>flag</i></dt>
  <dd>If true (the default), the generated type will have a type method called
      <b>info</b> that is used for type introspection; the <b>info</b> type
      method is documented below. If false, it will not.</dd>
  <dt><b>-hastypedestroy</b> <i>flag</i></dt>
  <dd>If true (the default), the generated type will have a type method called
      <b>destroy</b> that is used to destroy the type and all of its instances.
      The <b>destroy</b> type method is documented below. If false, it will
    not.</dd>
  <dt><b>-hastypemethods</b> <i>flag</i></dt>
  <dd>If true (the default), the generated type's type command will have
      subcommands (type methods) as usual. If false, the type command will serve
      only to create instances of the type; the first argument is the instance
      name.
    <p class="Pp">This pragma and <b>-hasinstances</b> cannot both be set
      false.</p>
  </dd>
  <dt><b>-hasinstances</b> <i>flag</i></dt>
  <dd>If true (the default), the generated type will have a type method called
      <b>create</b> that is used to create instances of the type, along with a
      variety of instance-related features. If false, it will not.
    <p class="Pp">This pragma and <b>-hastypemethods</b> cannot both be set
        false.</p>
  </dd>
  <dt><b>-hasinfo</b> <i>flag</i></dt>
  <dd>If true (the default), instances of the generated type will have an
      instance method called <b>info</b> that is used for instance
      introspection; the <b>info</b> method is documented below. If false, it
      will not.</dd>
  <dt><b>-simpledispatch</b> <i>flag</i></dt>
  <dd>This pragma is intended to make simple, heavily-used abstract data types
      (e.g., stacks and queues) more efficient.
    <p class="Pp">If false (the default), instance methods are dispatched
        normally. If true, a faster dispatching scheme is used instead. The
        speed comes at a price; with <b>-simpledispatch yes</b> you get the
        following limitations:</p>
  </dd>
</dl>
<div class="Bd-indent">
<ul class="Bl-bullet">
  <li>Methods cannot be delegated.</li>
  <li><b>uplevel</b> and <b>upvar</b> do not work as expected: the caller's
      scope is two levels up rather than one.</li>
  <li>The option-handling methods (<b>cget</b>, <b>configure</b>, and
      <b>configurelist</b>) are very slightly slower.</li>
</ul>
</div>
</div>
<dl class="Bl-tag">
  <dt><b>expose</b> <i>comp</i></dt>
  <dd></dd>
  <dt><b>expose</b> <i>comp</i> <b>as</b> <i>method</i></dt>
  <dd><b>Deprecated.</b> To expose component <i>comp</i> publicly, use
      <b>component</b>'s <b>-public</b> option.</dd>
  <dt><b>onconfigure</b> <i>name</i> <i>arglist</i> <i>body</i></dt>
  <dd><b>Deprecated.</b> Define <b>option</b>'s <b>-configuremethod</b> option
      instead.
    <p class="Pp">As of version 0.95, the following definitions,</p>
    <pre>
    option -myoption
    onconfigure -myoption {value} {
        # Code to save the option's value
    }
    </pre>
    are implemented as follows:
    <pre>
    option -myoption -configuremethod _configure-myoption
    method _configure-myoption {_option value} {
        # Code to save the option's value
    }
    </pre>
  </dd>
  <dt><b>oncget</b> <i>name</i> <i>body</i></dt>
  <dd><b>Deprecated.</b> Define <b>option</b>'s <b>-cgetmethod</b> option
      instead.
    <p class="Pp">As of version 0.95, the following definitions,</p>
    <pre>
    option -myoption
    oncget -myoption {
        # Code to return the option's value
    }
    </pre>
    are implemented as follows:
    <pre>
    option -myoption -cgetmethod _cget-myoption
    method _cget-myoption {_option} {
        # Code to return the option's value
    }
    </pre>
  </dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt><b>snit::widget</b> <i>name</i> <i>definition</i></dt>
  <dd>This command defines a Snit megawidget type with the specified
      <i>name</i>. The <i>definition</i> is defined as for <b>snit::type</b>. A
      <b>snit::widget</b> differs from a <b>snit::type</b> in these ways:</dd>
</dl>
<div class="Bd-indent">
<ul class="Bl-bullet">
  <li>Every instance of a <b>snit::widget</b> has an automatically-created
      component called <b>hull</b>, which is normally a Tk frame widget. Other
      widgets created as part of the megawidget will be created within this
      widget.
    <p class="Pp">The hull component is initially created with the requested
        widget name; then Snit does some magic, renaming the hull component and
        installing its own instance command in its place. The hull component's
        new name is saved in an instance variable called <b>hull</b>.</p>
  </li>
  <li>The name of an instance must be valid Tk window name, and the parent
      window must exist.</li>
</ul>
</div>
A <b>snit::widget</b> definition can include any of statements allowed in a
  <b>snit::type</b> definition, and may also include the following:
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>widgetclass</b> <i>name</i></dt>
  <dd>Sets the <b>snit::widget</b>'s widget class to <i>name</i>, overriding the
      default. See <b>The Tk Option Database</b> for more information.</dd>
  <dt><b>hulltype</b> <i>type</i></dt>
  <dd>Determines the kind of widget used as the <b>snit::widget</b>'s hull. The
      <i>type</i> may be <b>frame</b> (the default), <b>toplevel</b>,
      <b>labelframe</b>; the qualified equivalents of these, <b>tk::frame</b>,
      <b>tk::toplevel</b>, and <b>tk::labelframe</b>; or, if available, the
      equivalent Tile widgets: <b>ttk::frame</b>, <b>ttk::toplevel</b>, and
      <b>ttk::labelframe</b>. In practice, any widget that supports the
      <b>-class</b> option can be used as a hull widget by <b>lappend</b>'ing
      its name to the variable <b>snit::hulltypes</b>.</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt><b>snit::widgetadaptor</b> <i>name</i> <i>definition</i></dt>
  <dd>This command defines a Snit megawidget type with the specified name. It
      differs from <b>snit::widget</b> in that the instance's <b>hull</b>
      component is not created automatically, but is created in the constructor
      and installed using the <b>installhull</b> command. Once the hull is
      installed, its instance command is renamed and replaced as with normal
      <b>snit::widget</b>s. The original command is again accessible in the
      instance variable <b>hull</b>.
    <p class="Pp">Note that in general it is not possible to change the
        <i>widget class</i> of a <b>snit::widgetadaptor</b>'s hull widget.</p>
    <p class="Pp">See <b>The Tk Option Database</b> for information on how
        <b>snit::widgetadaptor</b>s interact with the option database.</p>
  </dd>
  <dt><b>snit::typemethod</b> <i>type</i> <i>name</i> <i>arglist</i>
    <i>body</i></dt>
  <dd>Defines a new type method (or redefines an existing type method) for a
      previously existing <i>type</i>.</dd>
  <dt><b>snit::method</b> <i>type</i> <i>name</i> <i>arglist</i>
    <i>body</i></dt>
  <dd>Defines a new instance method (or redefines an existing instance method)
      for a previously existing <i>type</i>. Note that delegated instance
      methods can't be redefined.</dd>
  <dt><b>snit::macro</b> <i>name</i> <i>arglist</i> <i>body</i></dt>
  <dd>Defines a Snit macro with the specified <i>name</i>, <i>arglist</i>, and
      <i>body</i>. Macros are used to define new type and widget definition
      statements in terms of the statements defined in this man page.
    <p class="Pp">A macro is simply a Tcl proc that is defined in the slave
        interpreter used to compile type and widget definitions. Thus, macros
        have access to all of the type and widget definition statements. See
        <b>Macros and Meta-programming</b> for more details.</p>
    <p class="Pp">The macro <i>name</i> cannot be the same as any standard Tcl
        command, or any Snit type or widget definition statement, e.g., you
        can't redefine the <b>method</b> or <b>delegate</b> statements, or the
        standard <b>set</b>, <b>list</b>, or <b>string</b> commands.</p>
  </dd>
  <dt><b>snit::compile</b> <i>which</i> <i>type</i> <i>body</i></dt>
  <dd>Snit defines a type, widget, or widgetadaptor by &quot;compiling&quot; the
      definition into a Tcl script; this script is then evaluated in the Tcl
      interpreter, which actually defines the new type.
    <p class="Pp">This command exposes the &quot;compiler&quot;. Given a
        definition <i>body</i> for the named <i>type</i>, where <i>which</i> is
        <b>type</b>, <b>widget</b>, or <b>widgetadaptor</b>,
        <b>snit::compile</b> returns a list of two elements. The first element
        is the fully qualified type name; the second element is the definition
        script.</p>
    <p class="Pp"><b>snit::compile</b> is useful when additional processing must
        be done on the Snit-generated code--if it must be instrumented, for
        example, or run through the TclDevKit compiler. In addition, the
        returned script could be saved in a &quot;.tcl&quot; file and used to
        define the type as part of an application or library, thus saving the
        compilation overhead at application start-up. Note that the same version
        of Snit must be used at run-time as at compile-time.</p>
  </dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="THE_TYPE_COMMAND"><a class="permalink" href="#THE_TYPE_COMMAND">THE
  TYPE COMMAND</a></h2>
A type or widget definition creates a type command, which is used to create
  instances of the type. The type command has this form:
<dl class="Bl-tag">
  <dt><b>$type</b> <i>typemethod</i> <i>args</i>...</dt>
  <dd>The <i>typemethod</i> can be any of the <b>Standard Type Methods</b>
      (e.g., <b>create</b>), or any type method defined in the type definition.
      The subsequent <i>args</i> depend on the specific <i>typemethod</i>
      chosen.
    <p class="Pp">The type command is most often used to create new instances of
        the type; hence, the <b>create</b> method is assumed if the first
        argument to the type command doesn't name a valid type method, unless
        the type definition includes <b>delegate typemethod *</b> or the
        <b>-hasinstances</b> pragma is set to false.</p>
    <p class="Pp">Furthermore, if the <b>-hastypemethods</b> pragma is false,
        then Snit type commands can be called with no arguments at all; in this
        case, the type command creates an instance with an automatically
        generated name. In other words, provided that the <b>-hastypemethods</b>
        pragma is false and the type has instances, the following commands are
        equivalent:</p>
    <pre>
snit::type dog { ... }
set mydog [dog create %AUTO%]
set mydog [dog %AUTO%]
set mydog [dog]
    </pre>
    This doesn't work for Snit widgets, for obvious reasons.
    <p class="Pp"><i>Snit 1.x Incompatibility:</i> In Snit 1.x, the above
        behavior is available whether <b>-hastypemethods</b> is true (the
        default) or false.</p>
  </dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="STANDARD_TYPE_METHODS"><a class="permalink" href="#STANDARD_TYPE_METHODS">STANDARD
  TYPE METHODS</a></h2>
In addition to any type methods in the type's definition, all type and widget
  commands will usually have at least the following subcommands:
<dl class="Bl-tag">
  <dt><b>$type</b> <b>create</b> <i>name</i> ?<i>option</i> <i>value</i>
    ...?</dt>
  <dd>Creates a new instance of the type, giving it the specified <i>name</i>
      and calling the type's constructor.
    <p class="Pp">For <b>snit::type</b>s, if <i>name</i> is not a
        fully-qualified command name, it is assumed to be a name in the
        namespace in which the call to <b>snit::type</b> appears. The method
        returns the fully-qualified instance name.</p>
    <p class="Pp">For <b>snit::widget</b>s and <b>snit::widgetadaptor</b>s,
        <i>name</i> must be a valid widget name; the method returns the widget
        name.</p>
    <p class="Pp">So long as <i>name</i> does not conflict with any defined type
        method name the <b>create</b> keyword may be omitted, unless the type
        definition includes <b>delegate typemethod *</b> or the
        <b>-hasinstances</b> pragma is set to false.</p>
    <p class="Pp">If the <i>name</i> includes the string <b>%AUTO%</b>, it will
        be replaced with the string <b>$type$counter</b> where <b>$type</b> is
        the type name and <b>$counter</b> is a counter that increments each time
        <b>%AUTO%</b> is used for this type.</p>
    <p class="Pp">By default, any arguments following the <i>name</i> will be a
        list of <i>option</i> names and their <i>value</i>s; however, a type's
        constructor can specify a different argument list.</p>
    <p class="Pp">As of Snit V0.95, <b>create</b> will throw an error if the
        <i>name</i> is the same as any existing command--note that this was
        always true for <b>snit::widget</b>s and <b>snit::widgetadaptor</b>s.
        You can restore the previous behavior using the <b>-canreplace</b>
        pragma.</p>
  </dd>
  <dt><b>$type</b> <b>info typevars</b> ?<i>pattern</i>?</dt>
  <dd>Returns a list of the type's type variables (excluding Snit internal
      variables); all variable names are fully-qualified.
    <p class="Pp">If <i>pattern</i> is given, it's used as a <b>string match</b>
        pattern; only names that match the pattern are returned.</p>
  </dd>
  <dt><b>$type</b> <b>info typemethods</b> ?<i>pattern</i>?</dt>
  <dd>Returns a list of the names of the type's type methods. If the type has
      hierarchical type methods, whether locally-defined or delegated, only the
      first word of each will be included in the list.
    <p class="Pp">If the type definition includes <b>delegate typemethod *</b>,
        the list will include only the names of those implicitly delegated type
        methods that have been called at least once and are still in the type
        method cache.</p>
    <p class="Pp">If <i>pattern</i> is given, it's used as a <b>string match</b>
        pattern; only names that match the pattern are returned.</p>
  </dd>
  <dt><b>$type</b> <b>info args</b> <i>method</i></dt>
  <dd>Returns a list containing the names of the arguments to the type's
      <i>method</i>, in order. This method cannot be applied to delegated type
      methods.</dd>
  <dt><b>$type</b> <b>info body</b> <i>method</i></dt>
  <dd>Returns the body of typemethod <i>method</i>. This method cannot be
      applied to delegated type methods.</dd>
  <dt><b>$type</b> <b>info default</b> <i>method</i> <i>aname</i>
    <i>varname</i></dt>
  <dd>Returns a boolean value indicating whether the argument <i>aname</i> of
      the type's <i>method</i> has a default value (<b>true</b>) or not
      (<b>false</b>). If the argument has a default its value is placed into the
      variable <i>varname</i>.</dd>
  <dt><b>$type</b> <b>info instances</b> ?<i>pattern</i>?</dt>
  <dd>Returns a list of the type's instances. For <b>snit::type</b>s, it will be
      a list of fully-qualified instance names; for <b>snit::widget</b>s, it
      will be a list of Tk widget names.
    <p class="Pp">If <i>pattern</i> is given, it's used as a <b>string match</b>
        pattern; only names that match the pattern are returned.</p>
    <p class="Pp"><i>Snit 1.x Incompatibility:</i> In Snit 1.x, the full
        multi-word names of hierarchical type methods are included in the return
        value.</p>
  </dd>
  <dt><b>$type</b> <b>destroy</b></dt>
  <dd>Destroys the type's instances, the type's namespace, and the type command
      itself.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="THE_INSTANCE_COMMAND"><a class="permalink" href="#THE_INSTANCE_COMMAND">THE
  INSTANCE COMMAND</a></h2>
A Snit type or widget's <b>create</b> type method creates objects of the type;
  each object has a unique name that is also a Tcl command. This command is used
  to access the object's methods and data, and has this form:
<dl class="Bl-tag">
  <dt><b>$object</b> <i>method</i> <i>args...</i></dt>
  <dd>The <i>method</i> can be any of the <b>Standard Instance Methods</b>, or
      any instance method defined in the type definition. The subsequent
      <i>args</i> depend on the specific <i>method</i> chosen.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="STANDARD_INSTANCE_METHODS"><a class="permalink" href="#STANDARD_INSTANCE_METHODS">STANDARD
  INSTANCE METHODS</a></h2>
In addition to any delegated or locally-defined instance methods in the type's
  definition, all Snit objects will have at least the following subcommands:
<dl class="Bl-tag">
  <dt><b>$object</b> <b>configure</b> ?<i>option</i>? ?<i>value</i>? ...</dt>
  <dd>Assigns new values to one or more options. If called with one argument, an
      <i>option</i> name, returns a list describing the option, as Tk widgets
      do; if called with no arguments, returns a list of lists describing all
      options, as Tk widgets do.
    <p class="Pp">Warning: This information will be available for delegated
        options only if the component to which they are delegated has a
        <b>configure</b> method that returns this same kind of information.</p>
    <p class="Pp">Note: Snit defines this method only if the type has at least
        one option.</p>
  </dd>
  <dt><b>$object</b> <b>configurelist</b> <i>optionlist</i></dt>
  <dd>Like <b>configure</b>, but takes one argument, a list of options and their
      values. It's mostly useful in the type constructor, but can be used
      anywhere.
    <p class="Pp">Note: Snit defines this method only if the type has at least
        one option.</p>
  </dd>
  <dt><b>$object</b> <b>cget</b> <i>option</i></dt>
  <dd>Returns the option's value.
    <p class="Pp">Note: Snit defines this method only if the type has at least
        one option.</p>
  </dd>
  <dt><b>$object</b> <b>destroy</b></dt>
  <dd>Destroys the object, calling the <b>destructor</b> and freeing all related
      memory.
    <p class="Pp"><i>Note:</i> The <b>destroy</b> method isn't defined for
        <b>snit::widget</b> or <b>snit::widgetadaptor</b> objects; instances of
        these are destroyed by calling <b>Tk</b>'s <b>destroy</b> command, just
        as normal widgets are.</p>
  </dd>
  <dt><b>$object</b> <b>info type</b></dt>
  <dd>Returns the instance's type.</dd>
  <dt><b>$object</b> <b>info vars</b> ?<i>pattern</i>?</dt>
  <dd>Returns a list of the object's instance variables (excluding Snit internal
      variables). The names are fully qualified.
    <p class="Pp">If <i>pattern</i> is given, it's used as a <b>string match</b>
        pattern; only names that match the pattern are returned.</p>
  </dd>
  <dt><b>$object</b> <b>info typevars</b> ?<i>pattern</i>?</dt>
  <dd>Returns a list of the object's type's type variables (excluding Snit
      internal variables). The names are fully qualified.
    <p class="Pp">If <i>pattern</i> is given, it's used as a <b>string match</b>
        pattern; only names that match the pattern are returned.</p>
  </dd>
  <dt><b>$object</b> <b>info typemethods</b> ?<i>pattern</i>?</dt>
  <dd>Returns a list of the names of the type's type methods. If the type has
      hierarchical type methods, whether locally-defined or delegated, only the
      first word of each will be included in the list.
    <p class="Pp">If the type definition includes <b>delegate typemethod *</b>,
        the list will include only the names of those implicitly delegated type
        methods that have been called at least once and are still in the type
        method cache.</p>
    <p class="Pp">If <i>pattern</i> is given, it's used as a <b>string match</b>
        pattern; only names that match the pattern are returned.</p>
    <p class="Pp"><i>Snit 1.x Incompatibility:</i> In Snit 1.x, the full
        multi-word names of hierarchical type methods are included in the return
        value.</p>
  </dd>
  <dt><b>$object</b> <b>info options</b> ?<i>pattern</i>?</dt>
  <dd>Returns a list of the object's option names. This always includes local
      options and explicitly delegated options. If unknown options are delegated
      as well, and if the component to which they are delegated responds to
      <b>$object configure</b> like Tk widgets do, then the result will include
      all possible unknown options that can be delegated to the component.
    <p class="Pp">If <i>pattern</i> is given, it's used as a <b>string match</b>
        pattern; only names that match the pattern are returned.</p>
    <p class="Pp">Note that the return value might be different for different
        instances of the same type, if component object types can vary from one
        instance to another.</p>
  </dd>
  <dt><b>$object</b> <b>info methods</b> ?<i>pattern</i>?</dt>
  <dd>Returns a list of the names of the instance's methods. If the type has
      hierarchical methods, whether locally-defined or delegated, only the first
      word of each will be included in the list.
    <p class="Pp">If the type definition includes <b>delegate method *</b>, the
        list will include only the names of those implicitly delegated methods
        that have been called at least once and are still in the method
      cache.</p>
    <p class="Pp">If <i>pattern</i> is given, it's used as a <b>string match</b>
        pattern; only names that match the pattern are returned.</p>
    <p class="Pp"><i>Snit 1.x Incompatibility:</i> In Snit 1.x, the full
        multi-word names of hierarchical type methods are included in the return
        value.</p>
  </dd>
  <dt><b>$object</b> <b>info args</b> <i>method</i></dt>
  <dd>Returns a list containing the names of the arguments to the instance's
      <i>method</i>, in order. This method cannot be applied to delegated
      methods.</dd>
  <dt><b>$object</b> <b>info body</b> <i>method</i></dt>
  <dd>Returns the body of the instance's method <i>method</i>. This method
      cannot be applied to delegated methods.</dd>
  <dt><b>$object</b> <b>info default</b> <i>method</i> <i>aname</i>
    <i>varname</i></dt>
  <dd>Returns a boolean value indicating whether the argument <i>aname</i> of
      the instance's <i>method</i> has a default value (<b>true</b>) or not
      (<b>false</b>). If the argument has a default its value is placed into the
      variable <i>varname</i>.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="COMMANDS_FOR_USE_IN_OBJECT_CODE"><a class="permalink" href="#COMMANDS_FOR_USE_IN_OBJECT_CODE">COMMANDS
  FOR USE IN OBJECT CODE</a></h2>
Snit defines the following commands for use in your object code: that is, for
  use in type methods, instance methods, constructors, destructors, onconfigure
  handlers, oncget handlers, and procs. They do not reside in the ::snit::
  namespace; instead, they are created with the type, and can be used without
  qualification.
<dl class="Bl-tag">
  <dt><b>mymethod</b> <i>name</i> ?<i>args...</i>?</dt>
  <dd>The <b>mymethod</b> command is used for formatting callback commands to be
      passed to other objects. It returns a command that when called will invoke
      method <i>name</i> with the specified arguments, plus of course any
      arguments added by the caller. In other words, both of the following
      commands will cause the object's <b>dosomething</b> method to be called
      when the <b>$button</b> is pressed:
    <pre>
    $button configure -command [list $self dosomething myargument]
    $button configure -command [mymethod dosomething myargument]
    </pre>
    The chief distinction between the two is that the latter form will not break
      if the object's command is renamed.</dd>
  <dt><b>mytypemethod</b> <i>name</i> ?<i>args...</i>?</dt>
  <dd>The <b>mytypemethod</b> command is used for formatting callback commands
      to be passed to other objects. It returns a command that when called will
      invoke type method <i>name</i> with the specified arguments, plus of
      course any arguments added by the caller. In other words, both of the
      following commands will cause the object's <b>dosomething</b> type method
      to be called when <b>$button</b> is pressed:
    <pre>
    $button configure -command [list $type dosomething myargument]
    $button configure -command [mytypemethod dosomething myargument]
    </pre>
    Type commands cannot be renamed, so in practice there's little difference
      between the two forms. <b>mytypemethod</b> is provided for parallelism
      with <b>mymethod</b>.</dd>
  <dt><b>myproc</b> <i>name</i> ?<i>args...</i>?</dt>
  <dd>The <b>myproc</b> command is used for formatting callback commands to be
      passed to other objects. It returns a command that when called will invoke
      the type proc <i>name</i> with the specified arguments, plus of course any
      arguments added by the caller. In other words, both of the following
      commands will cause the object's <b>dosomething</b> proc to be called when
      <b>$button</b> is pressed:
    <pre>
    $button configure -command [list ${type}::dosomething myargument]
    $button configure -command [myproc dosomething myargument]
    </pre>
  </dd>
  <dt><b>myvar</b> <i>name</i></dt>
  <dd>Given an instance variable name, returns the fully qualified name. Use
      this if you're passing the variable to some other object, e.g., as a
      <b>-textvariable</b> to a Tk label widget.</dd>
  <dt><b>mytypevar</b> <i>name</i></dt>
  <dd>Given an type variable name, returns the fully qualified name. Use this if
      you're passing the variable to some other object, e.g., as a
      <b>-textvariable</b> to a Tk label widget.</dd>
  <dt><b>from</b> <i>argvName</i> <i>option</i> ?<i>defvalue</i>?</dt>
  <dd>The <b>from</b> command plucks an option value from a list of options and
      their values, such as is passed into a type's <b>constructor</b>.
      <i>argvName</i> must be the name of a variable containing such a list;
      <i>option</i> is the name of the specific option.
    <p class="Pp"><b>from</b> looks for <i>option</i> in the option list. If it
        is found, it and its value are removed from the list, and the value is
        returned. If <i>option</i> doesn't appear in the list, then the
        <i>defvalue</i> is returned. If the option is locally-defined option,
        and <i>defvalue</i> is not specified, then the option's default value as
        specified in the type definition will be returned instead.</p>
  </dd>
  <dt><b>install</b> <i>compName</i> <b>using</b> <i>objType</i> <i>objName</i>
    <i>args...</i></dt>
  <dd>Creates a new object of type <i>objType</i> called <i>objName</i> and
      installs it as component <i>compName</i>, as described in <b>Components
      and Delegation</b>. Any additional <i>args...</i> are passed along with
      the name to the <i>objType</i> command. If this is a <b>snit::type</b>,
      then the following two commands are equivalent:
    <pre>
    install myComp using myObjType $self.myComp args...
    set myComp [myObjType $self.myComp args...]
    </pre>
    Note that whichever method is used, <i>compName</i> must still be declared
      in the type definition using <b>component</b>, or must be referenced in at
      least one <b>delegate</b> statement.
    <p class="Pp">If this is a <b>snit::widget</b> or
        <b>snit::widgetadaptor</b>, and if options have been delegated to
        component <i>compName</i>, then those options will receive default
        values from the Tk option database. Note that it doesn't matter whether
        the component to be installed is a widget or not. See <b>The Tk Option
        Database</b> for more information.</p>
    <p class="Pp"><b>install</b> cannot be used to install type components; just
        assign the type component's command name to the type component's
        variable instead.</p>
  </dd>
  <dt><b>installhull</b> <b>using</b> <i>widgetType</i> <i>args...</i></dt>
  <dd></dd>
  <dt><b>installhull</b> <i>name</i></dt>
  <dd>The constructor of a <b>snit::widgetadaptor</b> must create a widget to be
      the object's hull component; the widget is installed as the hull component
      using this command. Note that the installed widget's name must be
      <b>$win</b>. This command has two forms.
    <p class="Pp">The first form specifies the <i>widgetType</i> and the
        <i>args...</i> (that is, the hardcoded option list) to use in creating
        the hull. Given this form, <b>installhull</b> creates the hull widget,
        and initializes any options delegated to the hull from the Tk option
        database.</p>
    <p class="Pp">In the second form, the hull widget has already been created;
        note that its name must be &quot;$win&quot;. In this case, the Tk option
        database is <i>not</i> queried for any options delegated to the hull.
        The longer form is preferred; however, the shorter form allows the
        programmer to adapt a widget created elsewhere, which is sometimes
        useful. For example, it can be used to adapt a &quot;page&quot; widget
        created by a <b>BWidgets</b> tabbed notebook or pages manager
      widget.</p>
    <p class="Pp">See <b>The Tk Option Database</b> for more information about
        <b>snit::widgetadaptor</b>s and the option database.</p>
  </dd>
  <dt><b>variable</b> <i>name</i></dt>
  <dd>Normally, instance variables are defined in the type definition along with
      the options, methods, and so forth; such instance variables are
      automatically visible in all instance code (e.g., method bodies). However,
      instance code can use the <b>variable</b> command to declare instance
      variables that don't appear in the type definition, and also to bring
      variables from other namespaces into scope in the usual way.
    <p class="Pp">It's generally clearest to define all instance variables in
        the type definition, and omit declaring them in methods and so
      forth.</p>
    <p class="Pp">Note that this is an instance-specific version of the standard
        Tcl <b>::variable</b> command.</p>
  </dd>
  <dt><b>typevariable</b> <i>name</i></dt>
  <dd>Normally, type variables are defined in the type definition, along with
      the instance variables; such type variables are automatically visible in
      all of the type's code. However, type methods, instance methods and so
      forth can use <b>typevariable</b> to declare type variables that don't
      appear in the type definition.
    <p class="Pp">It's generally clearest to declare all type variables in the
        type definition, and omit declaring them in methods, type methods,
      etc.</p>
  </dd>
  <dt><b>varname</b> <i>name</i></dt>
  <dd><b>Deprecated.</b> Use <b>myvar</b> instead.
    <p class="Pp">Given an instance variable name, returns the fully qualified
        name. Use this if you're passing the variable to some other object,
        e.g., as a <b>-textvariable</b> to a Tk label widget.</p>
  </dd>
  <dt><b>typevarname</b> <i>name</i></dt>
  <dd><b>Deprecated.</b> Use <b>mytypevar</b> instead.
    <p class="Pp">Given a type variable name, returns the fully qualified name.
        Use this if you're passing the type variable to some other object, e.g.,
        as a <b>-textvariable</b> to a Tk label widget.</p>
  </dd>
  <dt><b>codename</b> <i>name</i></dt>
  <dd><b>Deprecated.</b> Use <b>myproc</b> instead. Given the name of a proc
      (but not a type or instance method), returns the fully-qualified command
      name, suitable for passing as a callback.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="COMPONENTS_AND_DELEGATION"><a class="permalink" href="#COMPONENTS_AND_DELEGATION">COMPONENTS
  AND DELEGATION</a></h2>
When an object includes other objects, as when a toolbar contains buttons or a
  GUI object contains an object that references a database, the included object
  is called a component. The standard way to handle component objects owned by a
  Snit object is to declare them using <b>component</b>, which creates a
  component instance variable. In the following example, a <b>dog</b> object has
  a <b>tail</b> object:
<p class="Pp"></p>
<pre>
    snit::type dog {
        component mytail
        constructor {args} {
            set mytail [tail %AUTO% -partof $self]
            $self configurelist $args
        }
        method wag {} {
            $mytail wag
        }
    }
    snit::type tail {
        option -length 5
        option -partof
        method wag {} { return &quot;Wag, wag, wag.&quot;}
    }
</pre>
<p class="Pp">Because the <b>tail</b> object's name is stored in an instance
    variable, it's easily accessible in any method.</p>
<p class="Pp">The <b>install</b> command provides an alternate way to create and
    install the component:</p>
<p class="Pp"></p>
<pre>
    snit::type dog {
        component mytail
        constructor {args} {
            install mytail using tail %AUTO% -partof $self
            $self configurelist $args
        }
        method wag {} {
            $mytail wag
        }
    }
</pre>
<p class="Pp">For <b>snit::type</b>s, the two methods are equivalent; for
    <b>snit::widget</b>s and <b>snit::widgetadaptor</b>s, the <b>install</b>
    command properly initializes the widget's options by querying <b>The Tk
    Option Database</b>.</p>
<p class="Pp">In the above examples, the <b>dog</b> object's <b>wag</b> method
    simply calls the <b>tail</b> component's <b>wag</b> method. In OO jargon,
    this is called delegation. Snit provides an easier way to do this:</p>
<p class="Pp"></p>
<pre>
    snit::type dog {
        delegate method wag to mytail
        constructor {args} {
            install mytail using tail %AUTO% -partof $self
            $self configurelist $args
        }
    }
</pre>
<p class="Pp">The <b>delegate</b> statement in the type definition implicitly
    defines the instance variable <b>mytail</b> to hold the component's name
    (though it's good form to use <b>component</b> to declare it explicitly); it
    also defines the <b>dog</b> object's <b>wag</b> method, delegating it to the
    <b>mytail</b> component.</p>
<p class="Pp">If desired, all otherwise unknown methods can be delegated to a
    specific component:</p>
<p class="Pp"></p>
<pre>
    snit::type dog {
	delegate method * to mytail
	constructor {args} {
	    set mytail [tail %AUTO% -partof $self]
	    $self configurelist $args
	}
	method bark { return &quot;Bark, bark, bark!&quot; }
    }
</pre>
<p class="Pp">In this case, a <b>dog</b> object will handle its own <b>bark</b>
    method; but <b>wag</b> will be passed along to <b>mytail</b>. Any other
    method, being recognized by neither <b>dog</b> nor <b>tail</b>, will simply
    raise an error.</p>
<p class="Pp">Option delegation is similar to method delegation, except for the
    interactions with the Tk option database; this is described in <b>The Tk
    Option Database</b>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="TYPE_COMPONENTS_AND_DELEGATION"><a class="permalink" href="#TYPE_COMPONENTS_AND_DELEGATION">TYPE
  COMPONENTS AND DELEGATION</a></h2>
The relationship between type components and instance components is identical to
  that between type variables and instance variables, and that between type
  methods and instance methods. Just as an instance component is an instance
  variable that holds the name of a command, so a type component is a type
  variable that holds the name of a command. In essence, a type component is a
  component that's shared by every instance of the type.
<p class="Pp">Just as <b>delegate method</b> can be used to delegate methods to
    instance components, as described in <b>Components and Delegation</b>, so
    <b>delegate typemethod</b> can be used to delegate type methods to type
    components.</p>
<p class="Pp">Note also that as of Snit 0.95 <b>delegate method</b> can delegate
    methods to both instance components and type components.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="THE_TK_OPTION_DATABASE"><a class="permalink" href="#THE_TK_OPTION_DATABASE">THE
  TK OPTION DATABASE</a></h2>
This section describes how Snit interacts with the Tk option database, and
  assumes the reader has a working knowledge of the option database and its
  uses. The book <i>Practical Programming in Tcl and Tk</i> by Welch et al has a
  good introduction to the option database, as does <i>Effective Tcl/Tk
  Programming</i>.
<p class="Pp">Snit is implemented so that most of the time it will simply do the
    right thing with respect to the option database, provided that the widget
    developer does the right thing by Snit. The body of this section goes into
    great deal about what Snit requires. The following is a brief statement of
    the requirements, for reference.</p>
<ul class="Bl-bullet">
  <li>If the <b>snit::widget</b>'s default widget class is not what is desired,
      set it explicitly using <b>widgetclass</b> in the widget definition.</li>
  <li>When defining or delegating options, specify the resource and class names
      explicitly when if the defaults aren't what you want.</li>
  <li>Use <b>installhull using</b> to install the hull for
      <b>snit::widgetadaptor</b>s.</li>
  <li>Use <b>install</b> to install all other components.</li>
</ul>
<p class="Pp">The interaction of Tk widgets with the option database is a
    complex thing; the interaction of Snit with the option database is even more
    so, and repays attention to detail.</p>
<p class="Pp"><b>Setting the widget class:</b> Every Tk widget has a widget
    class. For Tk widgets, the widget class name is the just the widget type
    name with an initial capital letter, e.g., the widget class for
    <b>button</b> widgets is &quot;Button&quot;.</p>
<p class="Pp">Similarly, the widget class of a <b>snit::widget</b> defaults to
    the unqualified type name with the first letter capitalized. For example,
    the widget class of</p>
<p class="Pp"></p>
<pre>
    snit::widget ::mylibrary::scrolledText { ... }
</pre>
<p class="Pp">is &quot;ScrolledText&quot;. The widget class can also be set
    explicitly using the <b>widgetclass</b> statement within the
    <b>snit::widget</b> definition.</p>
<p class="Pp">Any widget can be used as the <b>hulltype</b> provided that it
    supports the <b>-class</b> option for changing its widget class name. See
    the discussion of the <b>hulltype</b> command, above. The user may pass
    <b>-class</b> to the widget at instantion.</p>
<p class="Pp">The widget class of a <b>snit::widgetadaptor</b> is just the
    widget class of its hull widget; this cannot be changed unless the hull
    widget supports <b>-class</b>, in which case it will usually make more sense
    to use <b>snit::widget</b> rather than <b>snit::widgetadaptor</b>.</p>
<p class="Pp"><b>Setting option resource names and classes:</b> In Tk, every
    option has three names: the option name, the resource name, and the class
    name. The option name begins with a hyphen and is all lowercase; it's used
    when creating widgets, and with the <b>configure</b> and <b>cget</b>
    commands.</p>
<p class="Pp">The resource and class names are used to initialize option default
    values by querying the Tk option database. The resource name is usually just
    the option name minus the hyphen, but may contain uppercase letters at word
    boundaries; the class name is usually just the resource name with an initial
    capital, but not always. For example, here are the option, resource, and
    class names for several <b>text</b> widget options:</p>
<p class="Pp"></p>
<pre>
    -background         background         Background
    -borderwidth        borderWidth        BorderWidth
    -insertborderwidth  insertBorderWidth  BorderWidth
    -padx               padX               Pad
</pre>
<p class="Pp">As is easily seen, sometimes the resource and class names can be
    inferred from the option name, but not always.</p>
<p class="Pp">Snit options also have a resource name and a class name. By
    default, these names follow the rule given above: the resource name is the
    option name without the hyphen, and the class name is the resource name with
    an initial capital. This is true for both locally-defined options and
    explicitly delegated options:</p>
<p class="Pp"></p>
<pre>
    snit::widget mywidget {
        option -background
        delegate option -borderwidth to hull
        delegate option * to text
	# ...
    }
</pre>
<p class="Pp">In this case, the widget class name is &quot;Mywidget&quot;. The
    widget has the following options: <b>-background</b>, which is locally
    defined, and <b>-borderwidth</b>, which is explicitly delegated; all other
    widgets are delegated to a component called &quot;text&quot;, which is
    probably a Tk <b>text</b> widget. If so, <b>mywidget</b> has all the same
    options as a <b>text</b> widget. The option, resource, and class names are
    as follows:</p>
<p class="Pp"></p>
<pre>
    -background  background  Background
    -borderwidth borderwidth Borderwidth
    -padx        padX        Pad
</pre>
<p class="Pp">Note that the locally defined option, <b>-background</b>, happens
    to have the same three names as the standard Tk <b>-background</b> option;
    and <b>-pad</b>, which is delegated implicitly to the <b>text</b> component,
    has the same three names for <b>mywidget</b> as it does for the <b>text</b>
    widget. <b>-borderwidth</b>, on the other hand, has different resource and
    class names than usual, because the internal word &quot;width&quot; isn't
    capitalized. For consistency, it should be; this is done as follows:</p>
<p class="Pp"></p>
<pre>
    snit::widget mywidget {
	option -background
	delegate option {-borderwidth borderWidth} to hull
	delegate option * to text
	# ...
    }
</pre>
<p class="Pp">The class name will default to &quot;BorderWidth&quot;, as
    expected.</p>
<p class="Pp">Suppose, however, that <b>mywidget</b> also delegated <b>-padx</b>
    and <b>-pady</b> to the hull. In this case, both the resource name and the
    class name must be specified explicitly:</p>
<p class="Pp"></p>
<pre>
    snit::widget mywidget {
	option -background
	delegate option {-borderwidth borderWidth} to hull
	delegate option {-padx padX Pad} to hull
	delegate option {-pady padY Pad} to hull
	delegate option * to text
	# ...
    }
</pre>
<p class="Pp"><b>Querying the option database:</b> If you set your widgetclass
    and option names as described above, Snit will query the option database
    when each instance is created, and will generally do the right thing when it
    comes to querying the option database. The remainder of this section goes
    into the gory details.</p>
<p class="Pp"><b>Initializing locally defined options:</b> When an instance of a
    snit::widget is created, its locally defined options are initialized as
    follows: each option's resource and class names are used to query the Tk
    option database. If the result is non-empty, it is used as the option's
    default; otherwise, the default hardcoded in the type definition is used. In
    either case, the default can be overridden by the caller. For example,</p>
<p class="Pp"></p>
<pre>
    option add *Mywidget.texture pebbled
    snit::widget mywidget {
	option -texture smooth
	# ...
    }
    mywidget .mywidget -texture greasy
</pre>
<p class="Pp">Here, <b>-texture</b> would normally default to
    &quot;smooth&quot;, but because of the entry added to the option database it
    defaults to &quot;pebbled&quot;. However, the caller has explicitly
    overridden the default, and so the new widget will be
  &quot;greasy&quot;.</p>
<p class="Pp"><b>Initializing options delegated to the hull:</b> A
    <b>snit::widget</b>'s hull is a widget, and given that its class has been
    set it is expected to query the option database for itself. The only
    exception concerns options that are delegated to it with a different name.
    Consider the following code:</p>
<p class="Pp"></p>
<pre>
    option add *Mywidget.borderWidth 5
    option add *Mywidget.relief sunken
    option add *Mywidget.hullbackground red
    option add *Mywidget.background green
    snit::widget mywidget {
	delegate option -borderwidth to hull
	delegate option -hullbackground to hull as -background
	delegate option * to hull
	# ...
    }
    mywidget .mywidget
    set A [.mywidget cget -relief]
    set B [.mywidget cget -hullbackground]
    set C [.mywidget cget -background]
    set D [.mywidget cget -borderwidth]
</pre>
<p class="Pp">The question is, what are the values of variables A, B, C and
  D?</p>
<p class="Pp">The value of A is &quot;sunken&quot;. The hull is a Tk frame that
    has been given the widget class &quot;Mywidget&quot;; it will automatically
    query the option database and pick up this value. Since the <b>-relief</b>
    option is implicitly delegated to the hull, Snit takes no action.</p>
<p class="Pp">The value of B is &quot;red&quot;. The hull will automatically
    pick up the value &quot;green&quot; for its <b>-background</b> option, just
    as it picked up the <b>-relief</b> value. However, Snit knows that
    <b>-hullbackground</b> is mapped to the hull's <b>-background</b> option;
    hence, it queries the option database for <b>-hullbackground</b> and gets
    &quot;red&quot; and updates the hull accordingly.</p>
<p class="Pp">The value of C is also &quot;red&quot;, because <b>-background</b>
    is implicitly delegated to the hull; thus, retrieving it is the same as
    retrieving <b>-hullbackground</b>. Note that this case is unusual; in
    practice, <b>-background</b> would probably be explicitly delegated to some
    other component.</p>
<p class="Pp">The value of D is &quot;5&quot;, but not for the reason you think.
    Note that as it is defined above, the resource name for <b>-borderwidth</b>
    defaults to &quot;borderwidth&quot;, whereas the option database entry is
    &quot;borderWidth&quot;. As with <b>-relief</b>, the hull picks up its own
    <b>-borderwidth</b> option before Snit does anything. Because the option is
    delegated under its own name, Snit assumes that the correct thing has
    happened, and doesn't worry about it any further.</p>
<p class="Pp">For <b>snit::widgetadaptor</b>s, the case is somewhat altered.
    Widget adaptors retain the widget class of their hull, and the hull is not
    created automatically by Snit. Instead, the <b>snit::widgetadaptor</b> must
    call <b>installhull</b> in its constructor. The normal way to do this is as
    follows:</p>
<p class="Pp"></p>
<pre>
    snit::widgetadaptor mywidget {
	# ...
	constructor {args} {
	    # ...
	    installhull using text -foreground white
	    #
	}
	#...
    }
</pre>
<p class="Pp">In this case, the <b>installhull</b> command will create the hull
    using a command like this:</p>
<p class="Pp"></p>
<pre>
    set hull [text $win -foreground white]
</pre>
<p class="Pp">The hull is a <b>text</b> widget, so its widget class is
    &quot;Text&quot;. Just as with <b>snit::widget</b> hulls, Snit assumes that
    it will pick up all of its normal option values automatically; options
    delegated from a different name are initialized from the option database in
    the same way.</p>
<p class="Pp"><b>Initializing options delegated to other components:</b>
    Non-hull components are matched against the option database in two ways.
    First, a component widget remains a widget still, and therefore is
    initialized from the option database in the usual way. Second, the option
    database is queried for all options delegated to the component, and the
    component is initialized accordingly--provided that the <b>install</b>
    command is used to create it.</p>
<p class="Pp">Before option database support was added to Snit, the usual way to
    create a component was to simply create it in the constructor and assign its
    command name to the component variable:</p>
<p class="Pp"></p>
<pre>
    snit::widget mywidget {
	delegate option -background to myComp
	constructor {args} {
	    set myComp [text $win.text -foreground black]
	}
    }
</pre>
<p class="Pp">The drawback of this method is that Snit has no opportunity to
    initialize the component properly. Hence, the following approach is now
    used:</p>
<p class="Pp"></p>
<pre>
    snit::widget mywidget {
	delegate option -background to myComp
	constructor {args} {
	    install myComp using text $win.text -foreground black
	}
    }
</pre>
<p class="Pp">The <b>install</b> command does the following:</p>
<ul class="Bl-bullet">
  <li>Builds a list of the options explicitly included in the <b>install</b>
      command -- in this case, <b>-foreground</b>.</li>
  <li>Queries the option database for all options delegated explicitly to the
      named component.</li>
  <li>Creates the component using the specified command, after inserting into it
      a list of options and values read from the option database. Thus, the
      explicitly included options (<b>-foreground</b>) will override anything
      read from the option database.</li>
  <li>If the widget definition implicitly delegated options to the component
      using <b>delegate option *</b>, then Snit calls the newly created
      component's <b>configure</b> method to receive a list of all of the
      component's options. From this Snit builds a list of options implicitly
      delegated to the component that were not explicitly included in the
      <b>install</b> command. For all such options, Snit queries the option
      database and configures the component accordingly.</li>
</ul>
<p class="Pp"><b>Non-widget components:</b> The option database is never queried
    for <b>snit::type</b>s, since it can only be queried given a Tk widget name.
    However, <b>snit::widget</b>s can have non-widget components. And if options
    are delegated to those components, and if the <b>install</b> command is used
    to install those components, then they will be initialized from the option
    database just as widget components are.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="MACROS_AND_META-PROGRAMMING"><a class="permalink" href="#MACROS_AND_META-PROGRAMMING">MACROS
  AND META-PROGRAMMING</a></h2>
The <b>snit::macro</b> command enables a certain amount of meta-programming with
  Snit classes. For example, suppose you like to define properties: instance
  variables that have set/get methods. Your code might look like this:
<pre>
    snit::type dog {
        variable mood happy
        method getmood {} {
            return $mood
        }
        method setmood {newmood} {
            set mood $newmood
        }
    }
</pre>
That's nine lines of text per property. Or, you could define the following
  <b>snit::macro</b>:
<pre>
    snit::macro property {name initValue} {
        variable $name $initValue
        method get$name {} &quot;return $name&quot;
        method set$name {value} &quot;set $name \$value&quot;
    }
</pre>
Note that a <b>snit::macro</b> is just a normal Tcl proc defined in the slave
  interpreter used to compile type and widget definitions; as a result, it has
  access to all the commands used to define types and widgets.
<p class="Pp">Given this new macro, you can define a property in one line of
    code:</p>
<pre>
    snit::type dog {
        property mood happy
    }
</pre>
Within a macro, the commands <b>variable</b> and <b>proc</b> refer to the Snit
  type-definition commands, not the standard Tcl commands. To get the standard
  Tcl commands, use <b>_variable</b> and <b>_proc</b>.
<p class="Pp">Because a single slave interpreter is used for compiling all Snit
    types and widgets in the application, there's the possibility of macro name
    collisions. If you're writing a reuseable package using Snit, and you use
    some <b>snit::macro</b>s, define them in your package namespace:</p>
<pre>
    snit::macro mypkg::property {name initValue} { ... }
    snit::type dog {
        mypkg::property mood happy
    }
</pre>
This leaves the global namespace open for application authors.
</section>
<section class="Ss">
<h2 class="Ss" id="VALIDATION_TYPES"><a class="permalink" href="#VALIDATION_TYPES">VALIDATION
  TYPES</a></h2>
A validation type is an object that can be used to validate Tcl values of a
  particular kind. For example, <b>snit::integer</b> is used to validate that a
  Tcl value is an integer.
<p class="Pp">Every validation type has a <b>validate</b> method which is used
    to do the validation. This method must take a single argument, the value to
    be validated; further, it must do nothing if the value is valid, but throw
    an error if the value is invalid:</p>
<pre>
    snit::integer validate 5     ;# Does nothing
    snit::integer validate 5.0   ;# Throws an error (not an integer!)
</pre>
<p class="Pp">The <b>validate</b> method will always return the validated value
    on success, and throw the <b>-errorcode</b> INVALID on error.</p>
<p class="Pp">Snit defines a family of validation types, all of which are
    implemented as <b>snit::type</b>'s. They can be used as is; in addition,
    their instances serve as parameterized subtypes. For example, a probability
    is a number between 0.0 and 1.0 inclusive:</p>
<pre>
    snit::double probability -min 0.0 -max 1.0
</pre>
The example above creates an instance of <b>snit::double</b>--a validation
  subtype--called <b>probability</b>, which can be used to validate probability
  values:
<pre>
    probability validate 0.5   ;# Does nothing
    probability validate 7.9   ;# Throws an error
</pre>
Validation subtypes can be defined explicitly, as in the above example; when a
  locally-defined option's <b>-type</b> is specified, they may also be created
  on the fly:
<pre>
    snit::enum ::dog::breed -values {mutt retriever sheepdog}
    snit::type dog {
        # Define subtypes on the fly...
        option -breed -type {
            snit::enum -values {mutt retriever sheepdog}
        }
        # Or use predefined subtypes...
        option -breed -type ::dog::breed
    }
</pre>
<p class="Pp">Any object that has a <b>validate</b> method with the semantics
    described above can be used as a validation type; see <b>Defining Validation
    Types</b> for information on how to define new ones.</p>
<p class="Pp">Snit defines the following validation types:</p>
<dl class="Bl-tag">
  <dt><b>snit::boolean</b> <b>validate</b> ?<i>value</i>?</dt>
  <dd></dd>
  <dt><b>snit::boolean</b> <i>name</i></dt>
  <dd>Validates Tcl boolean values: 1, 0, <b>on</b>, <b>off</b>, <b>yes</b>,
      <b>no</b>, <b>true</b>, <b>false</b>. It's possible to define
      subtypes--that is, instances--of <b>snit::boolean</b>, but as it has no
      options there's no reason to do so.</dd>
  <dt><b>snit::double</b> <b>validate</b> ?<i>value</i>?</dt>
  <dd></dd>
  <dt><b>snit::double</b> <i>name</i> ?<i>option</i> <i>value</i>...?</dt>
  <dd>Validates floating-point values. Subtypes may be created with the
      following options:</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>-min</b> <i>min</i></dt>
  <dd>Specifies a floating-point minimum bound; a value is invalid if it is
      strictly less than <i>min</i>.</dd>
  <dt><b>-max</b> <i>max</i></dt>
  <dd>Specifies a floating-point maximum bound; a value is invalid if it is
      strictly greater than <i>max</i>.</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt><b>snit::enum</b> <b>validate</b> ?<i>value</i>?</dt>
  <dd></dd>
  <dt><b>snit::enum</b> <i>name</i> ?<i>option</i> <i>value</i>...?</dt>
  <dd>Validates that a value comes from an enumerated list. The base type is of
      little use by itself, as only subtypes actually have an enumerated list to
      validate against. Subtypes may be created with the following options:</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>-values</b> <i>list</i></dt>
  <dd>Specifies a list of valid values. A value is valid if and only if it's
      included in the list.</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt><b>snit::fpixels</b> <b>validate</b> ?<i>value</i>?</dt>
  <dd></dd>
  <dt><b>snit::fpixels</b> <i>name</i> ?<i>option</i> <i>value</i>...?</dt>
  <dd><i>Tk programs only.</i> Validates screen distances, in any of the forms
      accepted by <b>winfo fpixels</b>. Subtypes may be created with the
      following options:</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>-min</b> <i>min</i></dt>
  <dd>Specifies a minimum bound; a value is invalid if it is strictly less than
      <i>min</i>. The bound may be expressed in any of the forms accepted by
      <b>winfo fpixels</b>.</dd>
  <dt><b>-max</b> <i>max</i></dt>
  <dd>Specifies a maximum bound; a value is invalid if it is strictly greater
      than <i>max</i>. The bound may be expressed in any of the forms accepted
      by <b>winfo fpixels</b>.</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt><b>snit::integer</b> <b>validate</b> ?<i>value</i>?</dt>
  <dd></dd>
  <dt><b>snit::integer</b> <i>name</i> ?<i>option</i> <i>value</i>...?</dt>
  <dd>Validates integer values. Subtypes may be created with the following
      options:</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>-min</b> <i>min</i></dt>
  <dd>Specifies an integer minimum bound; a value is invalid if it is strictly
      less than <i>min</i>.</dd>
  <dt><b>-max</b> <i>max</i></dt>
  <dd>Specifies an integer maximum bound; a value is invalid if it is strictly
      greater than <i>max</i>.</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt><b>snit::listtype</b> <b>validate</b> ?<i>value</i>?</dt>
  <dd></dd>
  <dt><b>snit::listtype</b> <i>name</i> ?<i>option</i> <i>value</i>...?</dt>
  <dd>Validates Tcl lists. Subtypes may be created with the following
    options:</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>-minlen</b> <i>min</i></dt>
  <dd>Specifies a minimum list length; the value is invalid if it has fewer than
      <i>min</i> elements. Defaults to 0.</dd>
  <dt><b>-maxlen</b> <i>max</i></dt>
  <dd>Specifies a maximum list length; the value is invalid if it more than
      <i>max</i> elements.</dd>
  <dt><b>-type</b> <i>type</i></dt>
  <dd>Specifies the type of the list elements; <i>type</i> must be the name of a
      validation type or subtype. In the following example, the value of
      <b>-numbers</b> must be a list of integers.
    <pre>
    option -numbers -type {snit::listtype -type snit::integer}
    </pre>
    Note that this option doesn't support defining new validation subtypes on
      the fly; that is, the following code will not work (yet, anyway):
    <pre>
    option -numbers -type {
        snit::listtype -type {snit::integer -min 5}
    }
    </pre>
    Instead, define the subtype explicitly:
    <pre>
    snit::integer gt4 -min 5
    snit::type mytype {
        option -numbers -type {snit::listtype -type gt4}
    }
    </pre>
  </dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt><b>snit::pixels</b> <b>validate</b> ?<i>value</i>?</dt>
  <dd></dd>
  <dt><b>snit::pixels</b> <i>name</i> ?<i>option</i> <i>value</i>...?</dt>
  <dd><i>Tk programs only.</i> Validates screen distances, in any of the forms
      accepted by <b>winfo pixels</b>. Subtypes may be created with the
      following options:</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>-min</b> <i>min</i></dt>
  <dd>Specifies a minimum bound; a value is invalid if it is strictly less than
      <i>min</i>. The bound may be expressed in any of the forms accepted by
      <b>winfo pixels</b>.</dd>
  <dt><b>-max</b> <i>max</i></dt>
  <dd>Specifies a maximum bound; a value is invalid if it is strictly greater
      than <i>max</i>. The bound may be expressed in any of the forms accepted
      by <b>winfo pixels</b>.</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt><b>snit::stringtype</b> <b>validate</b> ?<i>value</i>?</dt>
  <dd></dd>
  <dt><b>snit::stringtype</b> <i>name</i> ?<i>option</i> <i>value</i>...?</dt>
  <dd>Validates Tcl strings. The base type is of little use by itself, since
      very Tcl value is also a valid string. Subtypes may be created with the
      following options:</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>-minlen</b> <i>min</i></dt>
  <dd>Specifies a minimum string length; the value is invalid if it has fewer
      than <i>min</i> characters. Defaults to 0.</dd>
  <dt><b>-maxlen</b> <i>max</i></dt>
  <dd>Specifies a maximum string length; the value is invalid if it has more
      than <i>max</i> characters.</dd>
  <dt><b>-glob</b> <i>pattern</i></dt>
  <dd>Specifies a <b>string match</b> pattern; the value is invalid if it
      doesn't match the pattern.</dd>
  <dt><b>-regexp</b> <i>regexp</i></dt>
  <dd>Specifies a regular expression; the value is invalid if it doesn't match
      the regular expression.</dd>
  <dt><b>-nocase</b> <i>flag</i></dt>
  <dd>By default, both <b>-glob</b> and <b>-regexp</b> matches are
      case-sensitive. If <b>-nocase</b> is set to true, then both <b>-glob</b>
      and <b>-regexp</b> matches are case-insensitive.</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt><b>snit::window</b> <b>validate</b> ?<i>value</i>?</dt>
  <dd></dd>
  <dt><b>snit::window</b> <i>name</i></dt>
  <dd><i>Tk programs only.</i> Validates Tk window names. The value must cause
      <b>winfo exists</b> to return true; otherwise, the value is invalid. It's
      possible to define subtypes--that is, instances--of <b>snit::window</b>,
      but as it has no options at present there's no reason to do so.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="DEFINING_VALIDATION_TYPES"><a class="permalink" href="#DEFINING_VALIDATION_TYPES">DEFINING
  VALIDATION TYPES</a></h2>
There are three ways to define a new validation type: as a subtype of one of
  Snit's validation types, as a validation type command, and as a full-fledged
  validation type similar to those provided by Snit. Defining subtypes of Snit's
  validation types is described above, under <b>Validation Types</b>.
<p class="Pp">The next simplest way to create a new validation type is as a
    validation type command. A validation type is simply an object that has a
    <b>validate</b> method; the <b>validate</b> method must take one argument, a
    value, return the value if it is valid, and throw an error with
    <b>-errorcode</b> INVALID if the value is invalid. This can be done with a
    simple <b>proc</b>. For example, the <b>snit::boolean</b> validate type
    could have been implemented like this:</p>
<pre>
    proc ::snit::boolean {&quot;validate&quot; value} {
        if {![string is boolean -strict $value]} {
            return -code error -errorcode INVALID \
                &quot;invalid boolean \&quot;$value\&quot;, should be one of: 1, 0, ...&quot;
        }
        return $value
    }
</pre>
A validation type defined in this way cannot be subtyped, of course; but for
  many applications this will be sufficient.
<p class="Pp">Finally, one can define a full-fledged, subtype-able validation
    type as a <b>snit::type</b>. Here's a skeleton to get you started:</p>
<pre>
    snit::type myinteger {
        # First, define any options you'd like to use to define
        # subtypes.  Give them defaults such that they won't take
        # effect if they aren't used, and marked them &quot;read-only&quot;.
        # After all, you shouldn't be changing their values after
        # a subtype is defined.
        #
        # For example:
        option -min -default &quot;&quot; -readonly 1
        option -max -default &quot;&quot; -readonly 1
        # Next, define a &quot;validate&quot; type method which should do the
        # validation in the basic case.  This will allow the
        # type command to be used as a validation type.
        typemethod validate {value} {
            if {![string is integer -strict $value]} {
                return -code error -errorcode INVALID \
                    &quot;invalid value \&quot;$value\&quot;, expected integer&quot;
            }
            return $value
        }
        # Next, the constructor should validate the subtype options,
        # if any.  Since they are all readonly, we don't need to worry
        # about validating the options on change.
        constructor {args} {
            # FIRST, get the options
            $self configurelist $args
            # NEXT, validate them.
            # I'll leave this to your imagination.
        }
        # Next, define a &quot;validate&quot; instance method; its job is to
        # validate values for subtypes.
        method validate {value} {
            # First, call the type method to do the basic validation.
            $type validate $value
            # Now we know it's a valid integer.
            if {(&quot;&quot; != $options(-min) &amp;&amp; $value &lt; $options(-min))  ||
                (&quot;&quot; != $options(-max) &amp;&amp; $value &gt; $options(-max))} {
                # It's out of range; format a detailed message about
                # the error, and throw it.
                set msg &quot;....&quot;
                return -code error -errorcode INVALID $msg
            }
            # Otherwise, if it's valid just return it.
            return $valid
        }
    }
</pre>
And now you have a type that can be subtyped.
<p class="Pp">The file &quot;validate.tcl&quot; in the Snit distribution defines
    all of Snit's validation types; you can find the complete implementation for
    <b>snit::integer</b> and the other types there, to use as examples for your
    own types.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="CAVEATS"><a class="permalink" href="#CAVEATS">CAVEATS</a></h1>
If you have problems, find bugs, or new ideas you are hereby cordially invited
  to submit a report of your problem, bug, or idea at the SourceForge trackers
  for tcllib, which can be found at
  <i>http://sourceforge.net/projects/tcllib/</i>. The relevant category is
  <i>snit</i>.
<p class="Pp">Additionally, you might wish to join the Snit mailing list; see
    <i>http://www.wjduquette.com/snit</i> for details.</p>
<p class="Pp">One particular area to watch is using <b>snit::widgetadaptor</b>
    to adapt megawidgets created by other megawidget packages; correct widget
    destruction depends on the order of the &lt;Destroy&gt; bindings. The wisest
    course is simply not to do this.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="KNOWN_BUGS"><a class="permalink" href="#KNOWN_BUGS">KNOWN
  BUGS</a></h1>
<ul class="Bl-bullet">
  <li>Error stack traces returned by Snit 1.x are extremely ugly and typically
      contain far too much information about Snit internals. The error messages
      are much improved in Snit 2.2.</li>
  <li>Also see the SourceForge Trackers at
      <i>http://sourceforge.net/projects/tcllib/</i>, category <i>snit</i>.</li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="HISTORY"><a class="permalink" href="#HISTORY">HISTORY</a></h1>
During the course of developing Notebook (See
  <i>http://www.wjduquette.com/notebook</i>), my Tcl-based personal notebook
  application, I found I was writing it as a collection of objects. I wasn't
  using any particular object-oriented framework; I was just writing objects in
  pure Tcl following the guidelines in my Guide to Object Commands (see
  <i>http://www.wjduquette.com/tcl/objects.html</i>), along with a few other
  tricks I'd picked up since. And though it was working well, it quickly became
  tiresome because of the amount of boilerplate code associated with each new
  object type.
<p class="Pp">So that was one thing--tedium is a powerful motivator. But the
    other thing I noticed is that I wasn't using inheritance at all, and I
    wasn't missing it. Instead, I was using delegation: objects that created
    other objects and delegated methods to them.</p>
<p class="Pp">And I said to myself, &quot;This is getting tedious...there has
    got to be a better way.&quot; And one afternoon, on a whim, I started
    working on Snit, an object system that works the way Tcl works. Snit doesn't
    support inheritance, but it's great at delegation, and it makes creating
    megawidgets easy.</p>
<p class="Pp">If you have any comments or suggestions (or bug reports!) don't
    hesitate to send me e-mail at <i>will@wjduquette.com</i>. In addition,
    there's a Snit mailing list; you can find out more about it at the Snit home
    page (see <i>http://www.wjduquette.com/snit</i>).</p>
</section>
<section class="Sh">
<h1 class="Sh" id="CREDITS"><a class="permalink" href="#CREDITS">CREDITS</a></h1>
Snit has been designed and implemented from the very beginning by William H.
  Duquette. However, much credit belongs to the following people for using Snit
  and providing me with valuable feedback: Rolf Ade, Colin McCormack, Jose
  Nazario, Jeff Godfrey, Maurice Diamanti, Egon Pasztor, David S. Cargo, Tom
  Krehbiel, Michael Cleverly, Andreas Kupries, Marty Backe, Andy Goth, Jeff
  Hobbs, Brian Griffin, Donal Fellows, Miguel Sofer, Kenneth Green, and Anton
  Kovalenko. If I've forgotten anyone, my apologies; let me know and I'll add
  your name to the list.
</section>
<section class="Sh">
<h1 class="Sh" id="BUGS,_IDEAS,_FEEDBACK"><a class="permalink" href="#BUGS,_IDEAS,_FEEDBACK">BUGS,
  IDEAS, FEEDBACK</a></h1>
This document, and the package it describes, will undoubtedly contain bugs and
  other problems. Please report such in the category <i>snit</i> of the
  <i>Tcllib SF Trackers</i> [http://sourceforge.net/tracker/?group_id=12883].
  Please also report any ideas for enhancements you may have for either package
  and/or documentation.
</section>
<section class="Sh">
<h1 class="Sh" id="KEYWORDS"><a class="permalink" href="#KEYWORDS">KEYWORDS</a></h1>
BWidget, C++, Incr Tcl, Snit, adaptors, class, mega widget, object, object
  oriented, type, widget, widget adaptors
</section>
<section class="Sh">
<h1 class="Sh" id="CATEGORY"><a class="permalink" href="#CATEGORY">CATEGORY</a></h1>
Programming tools
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT"><a class="permalink" href="#COPYRIGHT">COPYRIGHT</a></h1>
<pre>
Copyright (c) 2003-2009, by William H. Duquette
</pre>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2.3.2</td>
    <td class="foot-os">snit</td>
  </tr>
</table>
</body>
</html>
