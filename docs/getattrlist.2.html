<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Copyright (c) 2003 Apple Computer, Inc. All rights reserved.
  
   The contents of this file constitute Original Code as defined in and
   are subject to the Apple Public Source License Version 1.1 (the
   "License").  You may not use this file except in compliance with the
   License.  Please obtain a copy of the License at
   http://www.apple.com/publicsource and read it before using this file.
  
   This Original Code and all software distributed under the License are
   distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
   EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
   INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
   FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
   License for the specific language governing rights and limitations
   under the License.
  
       @(#)getattrlist.2
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    .Nd, .Bf, .Op { display: inline; }
    .Pa, .Ad { font-style: italic; }
    .Ms { font-weight: bold; }
    .Bl-diag > dt { font-weight: bold; }
    code.Nm, .Fl, .Cm, .Ic, code.In, .Fd, .Fn, .Cd { font-weight: bold;
      font-family: inherit; }
  </style>
  <title>GETATTRLIST(2)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">GETATTRLIST(2)</td>
    <td class="head-vol">System Calls Manual</td>
    <td class="head-rtitle">GETATTRLIST(2)</td>
  </tr>
</table>
<div class="manual-text">
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp"><code class="Nm">getattrlist</code>,
    <code class="Nm">fgetattrlist</code>, <code class="Nm">getattrlistat</code>
    &#x2014; <span class="Nd">get file system attributes</span></p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<p class="Pp"><code class="In">#include
    <a class="In">&lt;sys/attr.h&gt;</a></code>
  <br/>
  <code class="In">#include <a class="In">&lt;unistd.h&gt;</a></code></p>
<p class="Pp"><var class="Ft">int</var>
  <br/>
  <code class="Fn">getattrlist</code>(<var class="Fa" style="white-space: nowrap;">const
    char* path</var>, <var class="Fa" style="white-space: nowrap;">struct
    attrlist * attrList</var>, <var class="Fa" style="white-space: nowrap;">void
    * attrBuf</var>, <var class="Fa" style="white-space: nowrap;">size_t
    attrBufSize</var>, <var class="Fa" style="white-space: nowrap;">unsigned
    long options</var>);</p>
<p class="Pp"><var class="Ft">int</var>
  <br/>
  <code class="Fn">fgetattrlist</code>(<var class="Fa" style="white-space: nowrap;">int
    fd</var>, <var class="Fa" style="white-space: nowrap;">struct attrlist *
    attrList</var>, <var class="Fa" style="white-space: nowrap;">void *
    attrBuf</var>, <var class="Fa" style="white-space: nowrap;">size_t
    attrBufSize</var>, <var class="Fa" style="white-space: nowrap;">unsigned
    long options</var>);</p>
<p class="Pp"><var class="Ft">int</var>
  <br/>
  <code class="Fn">getattrlistat</code>(<var class="Fa">int fd</var>,
    <var class="Fa">const char *path</var>, <var class="Fa">struct attrlist *
    attrList</var>, <var class="Fa">void * attrBuf</var>, <var class="Fa">size_t
    attrBufSize</var>, <var class="Fa">unsigned long options</var>);</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">The
    <a class="permalink" href="#getattrlist"><code class="Fn" id="getattrlist">getattrlist</code></a>()
    function returns attributes (that is, metadata) of file system objects.
    <code class="Fn">getattrlist</code>() works on the file system object named
    by <var class="Fa">path</var>, while
    <a class="permalink" href="#fgetattrlist"><code class="Fn" id="fgetattrlist">fgetattrlist</code></a>()
    works on the provided file descriptor <var class="Fa">fd</var>.</p>
<p class="Pp" id="getattrlistat">The
    <a class="permalink" href="#getattrlistat"><code class="Fn">getattrlistat</code></a>()
    system call is equivalent to <code class="Fn">getattrlist</code>() except in
    the case where <var class="Fa">path</var> specifies a relative path. In this
    case the attributes are returned for the file system object named by path
    relative to the directory associated with the file descriptor
    <var class="Fa">fd</var> instead of the current working directory. If
    <code class="Fn">getattrlistat</code>() is passed the special value
    <code class="Dv">AT_FDCWD</code> in the <var class="Fa">fd</var> parameter,
    the current working directory is used and the behavior is identical to a
    call to <code class="Fn">getattrlist</code>().</p>
<p class="Pp" id="getattrlist~2">You can think of
    <a class="permalink" href="#getattrlist~2"><code class="Fn">getattrlist</code></a>()
    as a seriously enhanced version of <a class="Xr">stat(2)</a>. The functions
    return attributes about the specified file system object into the buffer
    specified by <var class="Fa">attrBuf</var> and
    <var class="Fa">attrBufSize</var>. The <var class="Fa">attrList</var>
    parameter determines what attributes are returned. The
    <var class="Fa">options</var> parameter lets you control specific aspects of
    the function's behavior.</p>
<p class="Pp">Not all volumes support all attributes. See the discussion of
    <code class="Dv">ATTR_VOL_ATTRIBUTES</code> for a discussion of how to
    determine whether a particular volume supports a particular attribute.</p>
<p class="Pp">Furthermore, you should only request the attributes that you need.
    Some attributes are expensive to calculate on some volume formats. For
    example, <code class="Dv">ATTR_DIR_ENTRYCOUNT</code> is usually expensive to
    calculate on non-HFS [Plus] volumes. If you don't need a particular
    attribute, you should not ask for it.</p>
<p class="Pp">The <var class="Fa">path</var> parameter must reference a valid
    file system object. Read, write or execute permission of the object itself
    is not required, but all directories listed in the path name leading to the
    object must be searchable.</p>
<p class="Pp">The <var class="Fa">attrList</var> parameter is a pointer to an
    <var class="Vt">attrlist</var> structure, as defined by
    &#x27E8;<span class="Pa">sys/attr.h</span>&#x27E9; (shown below). It
    determines what attributes are returned by the function. You are responsible
    for filling out all fields of this structure before calling the
  function.</p>
<div class="Bd Pp Li">
<pre>typedef u_int32_t attrgroup_t;

struct attrlist {
    u_short     bitmapcount; /* number of attr. bit sets in list */
    u_int16_t   reserved;    /* (to maintain 4-byte alignment) */
    attrgroup_t commonattr;  /* common attribute group */
    attrgroup_t volattr;     /* volume attribute group */
    attrgroup_t dirattr;     /* directory attribute group */
    attrgroup_t fileattr;    /* file attribute group */
    attrgroup_t forkattr;    /* fork attribute group */
};
#define ATTR_BIT_MAP_COUNT 5</pre>
</div>
<p class="Pp">The fields of the <var class="Vt">attrlist</var> structure are
    defined as follows.</p>
<dl class="Bl-tag">
  <dt>bitmapcount</dt>
  <dd>Number of attribute bit sets in the structure. In current systems you must
      set this to <code class="Dv">ATTR_BIT_MAP_COUNT</code>.</dd>
  <dt>reserved</dt>
  <dd>Reserved. You must set this to 0.</dd>
  <dt>commonattr</dt>
  <dd>A bit set that specifies the common attributes that you require. Common
      attributes relate to all types of file system objects. See below for a
      description of these attributes.</dd>
  <dt>volattr</dt>
  <dd>A bit set that specifies the volume attributes that you require. Volume
      attributes relate to volumes (that is, mounted file systems). See below
      for a description of these attributes. If you request volume attributes,
      <var class="Fa">path</var> must reference the root of a volume. You must
      set ATTR_VOL_INFO in the volattr field if you request any other volume
      attributes. In addition, you can't request volume attributes if you also
      request file, directory, fork or extended common attributes. In addition,
      you can't request volume attributes if you also request the common
      attributes ATTR_CMN_EXTENDED_SECURITY, ATTR_CMN_UUID, ATTR_CMN_GRPUUID,
      ATTR_CMN_FILEID, or ATTR_CMN_PARENTID.</dd>
  <dt>dirattr</dt>
  <dd>A bit set that specifies the directory attributes that you require. See
      below for a description of these attributes.</dd>
  <dt>fileattr</dt>
  <dd>A bit set that specifies the file attributes that you require. See below
      for a description of these attributes.</dd>
  <dt>forkattr</dt>
  <dd>A bit set that specifies the fork attributes that you require. Fork
      attributes relate to the actual data in the file, which can be held in
      multiple named contiguous ranges, or forks. See below for a description of
      these attributes. If the FSOPT_ATTR_CMN_EXTENDED option is given, this bit
      set is reinterpreted as extended common attributes attributes, also
      described below.</dd>
</dl>
<p class="Pp">Unless otherwise noted in the lists below, attributes are
    read-only. Attributes labelled as read/write can be set using
    <a class="Xr">setattrlist(2)</a>.</p>
<p class="Pp">The <var class="Fa">attrBuf</var> and
    <var class="Fa">attrBufSize</var> parameters specify a buffer into which the
    function places attribute values. The format of this buffer is sufficiently
    complex that its description requires a separate section (see below). The
    initial contents of this buffer are ignored.</p>
<p class="Pp">The <var class="Fa">options</var> parameter is a bit set that
    controls the behaviour of the functions. The following option bits are
    defined.</p>
<dl class="Bl-tag">
  <dt id="getattrlist~3">FSOPT_NOFOLLOW</dt>
  <dd>If this bit is set,
      <a class="permalink" href="#getattrlist~3"><code class="Fn">getattrlist</code></a>()
      will not follow a symlink if it occurs as the last component of
      <var class="Fa">path</var>.</dd>
  <dt>FSOPT_NOFOLLOW_ANY</dt>
  <dd>If this bit is set, <code class="Fn">getattrlist</code>() will not follow
      a symlink if it occurs as the last component of
      <var class="Fa">path</var>. In addition an error is returned if a symlink
      is encountered before the last component of
    <var class="Fa">path</var>.</dd>
  <dt>FSOPT_REPORT_FULLSIZE</dt>
  <dd>The size of the attributes reported (in the first
      <var class="Vt">u_int32_t</var> field in the attribute buffer) will be the
      size needed to hold all the requested attributes; if not set, only the
      attributes actually returned will be reported. This allows the caller to
      determine if any truncation occurred.</dd>
  <dt>FSOPT_PACK_INVAL_ATTRS</dt>
  <dd>If this is bit is set, then all requested attributes, even ones that are
      not supported by the object or file system, will be returned. Default
      values will be used for the invalid ones. Requires that
      <code class="Dv">ATTR_CMN_RETURNED_ATTRS</code> be requested.</dd>
  <dt>FSOPT_ATTR_CMN_EXTENDED</dt>
  <dd>If this is bit is set, then <code class="Dv">ATTR_CMN_GEN_COUNT</code> and
      <code class="Dv">ATTR_CMN_DOCUMENT_ID</code> can be requested. When this
      option is used, forkattrs are reinterpreted as a set of extended common
      attributes.</dd>
  <dt>FSOPT_RETURN_REALDEV</dt>
  <dd>If this is bit is set, then ATTR_CMN_DEVID and ATTR_CMN_FSID will return
      the values corresponding to the physical volume they are on. When a
      filesystem supports VOL_CAP_INT_VOLUME_GROUPS, it is possible that the
      filesystem may return a common logical value for these attributes
      otherwise.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="ATTRIBUTE_BUFFER"><a class="permalink" href="#ATTRIBUTE_BUFFER">ATTRIBUTE
  BUFFER</a></h1>
<p class="Pp">The data returned in the buffer described by
    <var class="Fa">attrBuf</var> and <var class="Fa">attrBufSize</var> is
    formatted as follows.</p>
<ol class="Bl-enum">
  <li>The first element of the buffer is a <var class="Vt">u_int32_t</var> that
      contains the overall length, in bytes, of the attributes returned. This
      size includes the length field itself.</li>
  <li>Following the length field is a list of attributes. Each attribute is
      represented by a field of its type, where the type is given as part of the
      attribute description (below).</li>
  <li>The attributes are placed into the attribute buffer in the order that they
      are described below.</li>
  <li>Each attribute is aligned to a 4-byte boundary (including 64-bit data
      types).</li>
</ol>
<p class="Pp">If the attribute is of variable length, it is represented in the
    list by an <var class="Vt">attrreference</var> structure, as defined by
    &#x27E8;<span class="Pa">sys/attr.h</span>&#x27E9; (shown below).</p>
<div class="Bd Pp Li">
<pre>typedef struct attrreference {
    int32_t        attr_dataoffset;
    u_int32_t      attr_length;
} attrreference_t;</pre>
</div>
<p class="Pp">This structure contains a 'pointer' to the variable length
    attribute data. The <var class="Fa">attr_length</var> field is the length of
    the attribute data (in bytes). The <var class="Fa">attr_dataoffset</var>
    field is the offset in bytes from the <var class="Vt">attrreference</var>
    structure to the attribute data. This offset will always be a multiple of
    sizeof(u_int32_t) bytes, so you can safely access common data types without
    fear of alignment exceptions.</p>
<p class="Pp" id="getattrlist~4">The
    <a class="permalink" href="#getattrlist~4"><code class="Fn">getattrlist</code></a>()
    function will silently truncate attribute data if
    <var class="Fa">attrBufSize</var> is too small. The length field at the
    front of the attribute list always represents the length of the data
    actually copied into the attribute buffer. If the data is truncated, there
    is no easy way to determine the buffer size that's required to get all of
    the requested attributes. You should always pass an
    <var class="Fa">attrBufSize</var> that is large enough to accommodate the
    known size of the attributes in the attribute list (including the leading
    length field).</p>
<p class="Pp" id="getattrlist~5">Because the returned attributes are simply
    truncated if the buffer is too small, it's possible for a variable length
    attribute to reference data beyond the end of the attribute buffer. That is,
    it's possible for the attribute data to start beyond the end of the
    attribute buffer (that is, if <var class="Fa">attrRef</var> is a pointer to
    the <var class="Vt">attrreference_t</var>, ( ( (char *)
    <var class="Fa">attrRef</var> ) + <var class="Fa">attr_dataoffset</var> )
    &gt; ( ( (char *) <var class="Fa">attrBuf</var> ) +
    <var class="Fa">attrSize</var> ) ) or, indeed, for the attribute data to
    extend beyond the end of the attribute buffer (that is, ( ( (char *)
    <var class="Fa">attrRef</var> ) + <var class="Fa">attr_dataoffset</var> +
    <var class="Fa">attr_datalength</var> ) &gt; ( ( (char *)
    <var class="Fa">attrBuf</var> ) + <var class="Fa">attrSize</var> ) ). If
    this happens you must increase the size of the buffer and call
    <a class="permalink" href="#getattrlist~5"><code class="Fn">getattrlist</code></a>()
    to get an accurate copy of the attribute.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COMMON_ATTRIBUTES"><a class="permalink" href="#COMMON_ATTRIBUTES">COMMON
  ATTRIBUTES</a></h1>
<p class="Pp">Common attributes relate to all types of file system objects. The
    following common attributes are defined.</p>
<dl class="Bl-tag">
  <dt>ATTR_CMN_RETURNED_ATTRS</dt>
  <dd>An <var class="Vt">attribute_set_t</var> structure which is used to report
      which of the requested attributes were actually returned. This attribute,
      when requested, will always be the first attribute returned. By default,
      unsupported attributes will be skipped (i.e. not packed into the output
      buffer). This behavior can be over-ridden using the FSOPT_PACK_INVAL_ATTRS
      option flag. Both <a class="Xr">getattrlist(2)</a> and
      <a class="Xr">getatttrlistbulk(2)</a> support this attribute while
      <a class="Xr">searchfs(2)</a> does not.</dd>
  <dt>ATTR_CMN_NAME</dt>
  <dd>An <var class="Vt">attrreference</var> structure containing the name of
      the file system object as UTF-8 encoded, null terminated C string. The
      attribute data length will not be greater than
      <code class="Dv">NAME_MAX</code> + 1 characters, which is
      <code class="Dv">NAME_MAX</code> * 3 + 1 bytes (as one UTF-8-encoded
      character may take up to three bytes).</dd>
  <dt>ATTR_CMN_DEVID</dt>
  <dd>A <var class="Vt">dev_t</var> containing the device number of the device
      on which this file system object's volume is mounted. Equivalent to the
      <var class="Fa">st_dev</var> field of the <var class="Vt">stat</var>
      structure returned by <a class="Xr">stat(2)</a>.</dd>
  <dt>ATTR_CMN_FSID</dt>
  <dd>An <var class="Vt">fsid_t</var> structure containing the file system
      identifier for the volume on which the file system object resides.
      Equivalent to the <var class="Fa">f_fsid</var> field of the
      <var class="Vt">statfs</var> structure returned by
      <a class="Xr">statfs(2)</a>.</dd>
  <dt>ATTR_CMN_OBJTYPE</dt>
  <dd>An <var class="Vt">fsobj_type_t</var> that identifies the type of file
      system object. The values are taken from <var class="Vt">enum vtype</var>
      in &#x27E8;<span class="Pa">sys/vnode.h</span>&#x27E9;.</dd>
  <dt>ATTR_CMN_OBJTAG</dt>
  <dd>An <var class="Vt">fsobj_tag_t</var> that identifies the type of file
      system containing the object. The values are taken from
      <var class="Vt">enum vtagtype</var> in
      &#x27E8;<span class="Pa">sys/vnode.h</span>&#x27E9;.</dd>
  <dt>ATTR_CMN_OBJID</dt>
  <dd>An <var class="Vt">fsobj_id_t</var> structure that uniquely identifies the
      file system object within a mounted volume for the duration of its mount;
      this identifier is not guaranteed to be persistent for the volume and may
      change every time the volume is mounted.
    <p class="Pp">On HFS+ volumes, the ATTR_CMN_OBJID of a file system object is
        distinct from the ATTR_CMN_OBJID of any hard link to that file system
        object. Although the ATTR_CMN_OBJID of a file system object may appear
        similar (in whole or in part) to it's ATTR_CMN_FILEID (see description
        of ATTR_CMN_FILEID below), <b>no relation between the two attributes
        should ever be implied.</b></p>
    <p class="Pp" id="getLinkIDInfo">ATTR_CMN_OBJID is deprecated sarting with
        macOS 10.13, iOS 11.0, watchOS 4.0 and tvOS 11.0 and ATTR_CMNEXT_LINKID
        should be used in its place. ATTR_CMN_OBJID can only be used on older
        operating systems only if the file system doesn't 64 bit IDs. See the
        <a class="permalink" href="#getLinkIDInfo"><code class="Fn">getLinkIDInfo</code></a>()
        function in the EXAMPLES section.</p>
  </dd>
  <dt>ATTR_CMN_OBJPERMANENTID</dt>
  <dd>An <var class="Vt">fsobj_id_t</var> structure that uniquely and
      persistently identifies the file system object within its volume;
      persistence implies that this attribute is unaffected by mount/unmount
      operations on the volume.
    <p class="Pp">Some file systems can not return this attribute when the
        volume is mounted read-only and will fail the request with error
        <code class="Dv">EROFS.</code>
      <br/>
      (e.g. original HFS modifies on disk structures to generate persistent
        identifiers, and hence cannot do so if the volume is mounted read
      only.)</p>
  </dd>
  <dt>ATTR_CMN_PAROBJID</dt>
  <dd>An <var class="Vt">fsobj_id_t</var> structure that uniquely identifies the
      parent directory of the file system object within a mounted volume, for
      the duration of the volume mount; this identifier is not guaranteed to be
      persistent for the volume and may change every time the volume is mounted.
    <p class="Pp">If a file system object is hard linked from multiple
        directories, the parent directory returned for this attribute is non
        deterministic; it can be any one of the parent directories of this
        object. For some volume formats the computing cost for this attribute is
        significant; developers are advised to request this attribute
      sparingly.</p>
  </dd>
  <dt>ATTR_CMN_SCRIPT</dt>
  <dd>(read/write) A <var class="Vt">text_encoding_t</var> containing a text
      encoding hint for the file system object's name. It is included to
      facilitate the lossless round trip conversion of names between Unicode and
      traditional Mac OS script encodings. File systems that do not have an
      appropriate text encoding value should return
    kTextEncodingMacUnicode.</dd>
  <dt>ATTR_CMN_CRTIME</dt>
  <dd>(read/write) A <var class="Vt">timespec</var> structure containing the
      time that the file system object was created.</dd>
  <dt>ATTR_CMN_MODTIME</dt>
  <dd>(read/write) A <var class="Vt">timespec</var> structure containing the
      time that the file system object was last modified. Equivalent to the
      <var class="Fa">st_mtimespec</var> field of the <var class="Vt">stat</var>
      structure returned by <a class="Xr">stat(2)</a>.</dd>
  <dt>ATTR_CMN_CHGTIME</dt>
  <dd>A <var class="Vt">timespec</var> structure containing the time that the
      file system object's attributes were last modified. Equivalent to the
      <var class="Fa">st_ctimespec</var> field of the <var class="Vt">stat</var>
      structure returned by <a class="Xr">stat(2)</a>.</dd>
  <dt>ATTR_CMN_ACCTIME</dt>
  <dd>(read/write) A <var class="Vt">timespec</var> structure containing the
      time that the file system object was last accessed. Equivalent to the
      <var class="Fa">st_atimespec</var> field of the <var class="Vt">stat</var>
      structure returned by <a class="Xr">stat(2)</a>.</dd>
  <dt>ATTR_CMN_BKUPTIME</dt>
  <dd>(read/write) A <var class="Vt">timespec</var> structure containing the
      time that the file system object was last backed up. This value is for use
      by backup utilities. The file system stores but does not interpret the
      value.</dd>
  <dt>ATTR_CMN_FNDRINFO</dt>
  <dd>(read/write) 32 bytes of data for use by the Finder. Equivalent to the
      concatenation of a <var class="Vt">FileInfo</var> structure and an
      <var class="Vt">ExtendedFileInfo</var> structure (or, for directories, a
      <var class="Vt">FolderInfo</var> structure and an
      <var class="Vt">ExtendedFolderInfo</var> structure).
    <p class="Pp">This attribute is not byte swapped by the file system. The
        value of multibyte fields on disk is always big endian. When running on
        a little endian system (such as Darwin on x86), you must byte swap any
        multibyte fields.</p>
  </dd>
  <dt>ATTR_CMN_OWNERID</dt>
  <dd>(read/write) A <var class="Vt">uid_t</var> containing the owner of the
      file system object. Equivalent to the <var class="Fa">st_uid</var> field
      of the <var class="Vt">stat</var> structure returned by
      <a class="Xr">stat(2)</a>.</dd>
  <dt>ATTR_CMN_GRPID</dt>
  <dd>(read/write) A <var class="Vt">gid_t</var> containing the group of the
      file system object. Equivalent to the <var class="Fa">st_gid</var> field
      of the <var class="Vt">stat</var> structure returned by
      <a class="Xr">stat(2)</a>.</dd>
  <dt>ATTR_CMN_ACCESSMASK</dt>
  <dd>(read/write) A <var class="Vt">u_int32_t</var> containing the access
      permissions of the file system object. Equivalent to the
      <var class="Fa">st_mode</var> field of the <var class="Vt">stat</var>
      structure returned by <a class="Xr">stat(2)</a>. Only the permission bits
      of <var class="Fa">st_mode</var> are valid; other bits should be ignored,
      e.g., by masking with <code class="Dv">~S_IFMT</code>.</dd>
  <dt>ATTR_CMN_FLAGS</dt>
  <dd>(read/write) A <var class="Vt">u_int32_t</var> containing file flags.
      Equivalent to the <var class="Fa">st_flags</var> field of the
      <var class="Vt">stat</var> structure returned by
      <a class="Xr">stat(2)</a>. For more information about these flags, see
      <a class="Xr">chflags(2)</a>.</dd>
  <dt>ATTR_CMN_GEN_COUNT</dt>
  <dd>A <var class="Vt">u_int32_t</var> containing a non zero monotonically
      increasing generation count for this file system object. The generation
      count tracks the number of times the data in a file system object has been
      modified. No meaning can be implied from its value. The value of the
      generation count for a file system object can be compared against a
      previous value of the same file system object for equality; i.e. an
      unchanged generation count indicates identical data. Requesting this
      attribute requires the FSOPT_ATTR_CMN_EXTENDED option flag.
    <p class="Pp">A generation count value of 0 is invalid and cannot be used to
        determine data change.</p>
    <p class="Pp">The generation count is invalid while a file is mmap'ed. An
        invalid generation count value of 0 will be returned for mmap'ed
      files.</p>
  </dd>
  <dt>ATTR_CMN_DOCUMENT_ID</dt>
  <dd>A <var class="Vt">u_int32_t</var> containing the document id. The document
      id is a value assigned by the kernel to a document (which can be a file or
      directory) and is used to track the data regardless of where it gets
      moved. The document id survives safe saves; i.e it is sticky to the path
      it was assigned to. Requesting this attribute requires the
      FSOPT_ATTR_CMN_EXTENDED option flag.
    <p class="Pp">A document id of 0 is invalid.</p>
  </dd>
  <dt>ATTR_CMN_USERACCESS</dt>
  <dd>A <var class="Vt">u_int32_t</var> containing the effective permissions of
      the current user (the calling process's effective UID) for this file
      system object. You can test for read, write, and execute permission using
      <code class="Dv">R_OK</code>, <code class="Dv">W_OK</code>, and
      <code class="Dv">X_OK</code>, respectively. See
      <a class="Xr">access(2)</a> for more details.</dd>
  <dt>ATTR_CMN_EXTENDED_SECURITY</dt>
  <dd>A variable-length object (thus an <var class="Vt">attrreference</var>
      structure) containing a <var class="Vt">kauth_filesec</var> structure, of
      which only the ACL entry is used.</dd>
  <dt>ATTR_CMN_UUID</dt>
  <dd>A <var class="Vt">guid_t</var> of the owner of the file system object.
      Analoguous to <code class="Dv">ATTR_CMN_OWNERID</code>.</dd>
  <dt>ATTR_CMN_GRPUUID</dt>
  <dd>A <var class="Vt">guid_t</var> of the group to which the file system
      object belongs. Analoguous to <code class="Dv">ATTR_CMN_GRPID</code>.</dd>
  <dt>ATTR_CMN_FILEID</dt>
  <dd>A <var class="Vt">u_int64_t</var> that uniquely identifies the file system
      object within its mounted volume. Equivalent to
      <var class="Fa">st_ino</var> field of the <var class="Vt">stat</var>
      structure returned by <a class="Xr">stat(2)</a>.</dd>
  <dt>ATTR_CMN_PARENTID</dt>
  <dd>A <var class="Vt">u_int64_t</var> that identifies the parent directory of
      the file system object.</dd>
  <dt>ATTR_CMN_FULLPATH</dt>
  <dd>An <var class="Vt">attrreference</var> structure containing the full path
      (resolving all symlinks) to the file system object as a UTF-8 encoded,
      null terminated C string. The attribute data length will not be greater
      than <code class="Dv">PATH_MAX.</code> Inconsistent behavior may be
      observed when this attribute is requested on hard-linked items,
      particularly when the file system does not support ATTR_CMN_PARENTID
      natively. Callers should be aware of this when requesting the full path of
      a hard-linked item.</dd>
  <dt>ATTR_CMN_ADDEDTIME</dt>
  <dd>A <var class="Vt">timespec</var> that contains the time that the file
      system object was created or renamed into its containing directory. Note
      that inconsistent behavior may be observed when this attribute is
      requested on hard-linked items.</dd>
  <dt>ATTR_CMN_DATA_PROTECT_FLAGS</dt>
  <dd>A <var class="Vt">u_int32_t</var> that contains the file or directory's
      data protection class.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="VOLUME_ATTRIBUTES"><a class="permalink" href="#VOLUME_ATTRIBUTES">VOLUME
  ATTRIBUTES</a></h1>
<p class="Pp">Volume attributes relate to volumes (that is, mounted file
    systems). The following volume attributes are defined.</p>
<dl class="Bl-tag">
  <dt>ATTR_VOL_INFO</dt>
  <dd>For historical reasons you must set <code class="Dv">ATTR_VOL_INFO</code>
      in the <var class="Fa">volattr</var> field if you request any other volume
      attributes.</dd>
  <dt>ATTR_VOL_FSTYPE</dt>
  <dd>A <var class="Vt">u_int32_t</var> containing the file system type.
      Equivalent to the <var class="Fa">f_type</var> field of the
      <var class="Vt">statfs</var> structure returned by
      <a class="Xr">statfs(2)</a>. Generally not a useful value.</dd>
  <dt>ATTR_VOL_SIGNATURE</dt>
  <dd>A <var class="Vt">u_int32_t</var> containing the volume signature word.
      This value is unique within a given file system type and lets you
      distinguish between different volume formats handled by the same file
      system.</dd>
  <dt>ATTR_VOL_SIZE</dt>
  <dd>An <var class="Vt">off_t</var> containing the total size of the volume in
      bytes.</dd>
  <dt>ATTR_VOL_SPACEFREE</dt>
  <dd>An <var class="Vt">off_t</var> containing the free space on the volume in
      bytes.</dd>
  <dt>ATTR_VOL_SPACEAVAIL</dt>
  <dd>An <var class="Vt">off_t</var> containing the space, in bytes, on the
      volume available to non-privileged processes. This is the free space minus
      the amount of space reserved by the system to prevent critical disk
      exhaustion errors. Non-privileged programs, like a disk management tool,
      should use this value to display the space available to the user.
    <p class="Pp"><code class="Dv">ATTR_VOL_SPACEAVAIL</code> is to
        <code class="Dv">ATTR_VOL_SPACEFREE</code> as
        <var class="Fa">f_bavail</var> is to <var class="Fa">f_bfree</var> in
        <a class="Xr">statfs(2)</a>.</p>
  </dd>
  <dt>ATTR_VOL_SPACEUSED</dt>
  <dd>An <var class="Vt">off_t</var> containing the total space used on the
      volume in bytes. On space sharing volumes, this value may not be identical
      to the difference between the volume's size and its free space.</dd>
  <dt>ATTR_VOL_MINALLOCATION</dt>
  <dd>An <var class="Vt">off_t</var> containing the minimum allocation size on
      the volume in bytes. If you create a file containing one byte, it will
      consume this much space.</dd>
  <dt>ATTR_VOL_ALLOCATIONCLUMP</dt>
  <dd>An <var class="Vt">off_t</var> containing the allocation clump size on the
      volume, in bytes. As a file is extended, the file system will attempt to
      allocate this much space each time in order to reduce fragmentation.</dd>
  <dt>ATTR_VOL_IOBLOCKSIZE</dt>
  <dd>A <var class="Vt">u_int32_t</var> containing the optimal block size when
      reading or writing data. Equivalent to the <var class="Fa">f_iosize</var>
      field of the <var class="Vt">statfs</var> structure returned by
      <a class="Xr">statfs(2)</a>.</dd>
  <dt>ATTR_VOL_OBJCOUNT</dt>
  <dd>A <var class="Vt">u_int32_t</var> containing the number of file system
      objects on the volume.</dd>
  <dt>ATTR_VOL_FILECOUNT</dt>
  <dd>A <var class="Vt">u_int32_t</var> containing the number of files on the
      volume.</dd>
  <dt>ATTR_VOL_DIRCOUNT</dt>
  <dd>A <var class="Vt">u_int32_t</var> containing the number of directories on
      the volume.</dd>
  <dt>ATTR_VOL_MAXOBJCOUNT</dt>
  <dd>A <var class="Vt">u_int32_t</var> containing the maximum number of file
      system objects that can be stored on the volume.</dd>
  <dt>ATTR_VOL_MOUNTPOINT</dt>
  <dd>An <var class="Vt">attrreference</var> structure containing the path to
      the volume's mount point as a UTF-8 encoded, null terminated C string. The
      attribute data length will not be greater than
      <code class="Dv">MAXPATHLEN</code>. Equivalent to the
      <var class="Fa">f_mntonname</var> field of the
      <var class="Vt">statfs</var> structure returned by
      <a class="Xr">statfs(2)</a>.</dd>
  <dt>ATTR_VOL_NAME</dt>
  <dd>(read/write) An <var class="Vt">attrreference</var> structure containing
      the name of the volume as a UTF-8 encoded, null terminated C string. The
      attribute data length will not be greater than <code class="Dv">NAME_MAX
      +</code> 1.
    <p class="Pp">This attribute is only read/write if the
        <code class="Dv">VOL_CAP_INT_VOL_RENAME</code> bit is set in the volume
        capabilities (see below).</p>
  </dd>
  <dt>ATTR_VOL_MOUNTFLAGS</dt>
  <dd>A <var class="Vt">u_int32_t</var> containing the volume mount flags. This
      is a copy of the value passed to the <var class="Fa">flags</var> parameter
      of <a class="Xr">mount(2)</a> when the volume was mounted. Equivalent to
      the <var class="Fa">f_flags</var> field of the
      <var class="Vt">statfs</var> structure returned by
      <a class="Xr">statfs(2)</a>.</dd>
  <dt>ATTR_VOL_MOUNTEDDEVICE</dt>
  <dd>An <var class="Vt">attrreference</var> structure that returns the same
      value as the <var class="Fa">f_mntfromname</var> field of the
      <var class="Vt">statfs</var> structure returned by
      <a class="Xr">statfs(2)</a>. For local volumes this is the path to the
      device on which the volume is mounted as a UTF-8 encoded, null terminated
      C string. For network volumes, this is a unique string that identifies the
      mount. The attribute data length will not be greater than
      <code class="Dv">MAXPATHLEN</code>.</dd>
  <dt>ATTR_VOL_ENCODINGSUSED</dt>
  <dd>An <var class="Vt">unsigned long long</var> containing a bitmap of the
      text encodings used on this volume. For more information about this, see
      the discussion of <var class="Fa">encodingsBitmap</var> in DTS Technote
      1150 &quot;HFS Plus Volume Format&quot;.</dd>
  <dt>ATTR_VOL_CAPABILITIES</dt>
  <dd>A <var class="Vt">vol_capabilities_attr_t</var> structure describing the
      optional features supported by this volume. See below for a discussion of
      volume capabilities.</dd>
  <dt>ATTR_VOL_UUID</dt>
  <dd>A <var class="Vt">uuid_t</var> containing the file system UUID. Typically
      this will be a version 5 UUID.</dd>
  <dt>ATTR_VOL_QUOTA_SIZE</dt>
  <dd>An <var class="Vt">off_t</var> containing the maximum size of the volume
      in bytes.</dd>
  <dt>ATTR_VOL_RESERVED_SIZE</dt>
  <dd>An <var class="Vt">off_t</var> containing the minimum size of the volume
      in bytes.</dd>
  <dt>ATTR_VOL_ATTRIBUTES</dt>
  <dd>A <var class="Vt">vol_attributes_attr_t</var> structure describing the
      attributes supported by this volume. This structure is discussed below,
      along with volume capabilities.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="DIRECTORY_ATTRIBUTES"><a class="permalink" href="#DIRECTORY_ATTRIBUTES">DIRECTORY
  ATTRIBUTES</a></h1>
<p class="Pp">The following directory attributes are defined.</p>
<dl class="Bl-tag">
  <dt>ATTR_DIR_LINKCOUNT</dt>
  <dd>A <var class="Vt">u_int32_t</var> containing the number of hard links to
      the directory; this does not include the historical &quot;.&quot; and
      &quot;..&quot; entries. For file systems that do not support hard links to
      directories, this value will be 1.</dd>
  <dt>ATTR_DIR_ENTRYCOUNT</dt>
  <dd>A <var class="Vt">u_int32_t</var> containing the number of file system
      objects in the directory, not including any synthetic items. The
      historical &quot;.&quot; and &quot;..&quot; entries are also excluded from
      this count.</dd>
  <dt>ATTR_DIR_MOUNTSTATUS</dt>
  <dd>A <var class="Vt">u_int32_t</var> containing flags describing what's
      mounted on the directory. Currently the only flag defined is
      <code class="Dv">DIR_MNTSTATUS_MNTPOINT,</code> which indicates that there
      is a file system mounted on this directory.</dd>
  <dt>ATTR_DIR_ALLOCSIZE</dt>
  <dd>An <var class="Vt">off_t</var> containing the number of bytes on disk used
      by the directory (the physical size).</dd>
  <dt>ATTR_DIR_IOBLOCKSIZE</dt>
  <dd>A <var class="Vt">u_int32_t</var> containing the optimal block size when
      reading or writing data.</dd>
  <dt>ATTR_DIR_DATALENGTH</dt>
  <dd>An <var class="Vt">off_t</var> containing the length of the directory in
      bytes (the logical size).</dd>
</dl>
<p class="Pp">Requested directory attributes are not returned for file system
    objects that are not directories.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="FILE_ATTRIBUTES"><a class="permalink" href="#FILE_ATTRIBUTES">FILE
  ATTRIBUTES</a></h1>
<p class="Pp">The following file attributes are defined.</p>
<dl class="Bl-tag">
  <dt>ATTR_FILE_LINKCOUNT</dt>
  <dd>A <var class="Vt">u_int32_t</var> containing the number of hard links to
      this file. Equivalent to the <var class="Fa">st_nlink</var> field of the
      <var class="Vt">stat</var> structure returned by
      <a class="Xr">stat(2)</a>.</dd>
  <dt>ATTR_FILE_TOTALSIZE</dt>
  <dd>An <var class="Vt">off_t</var> containing the total number of bytes in all
      forks of the file (the logical size).</dd>
  <dt>ATTR_FILE_ALLOCSIZE</dt>
  <dd>An <var class="Vt">off_t</var> containing a count of the bytes on disk
      used by all of the file's forks (the physical size).</dd>
  <dt>ATTR_FILE_IOBLOCKSIZE</dt>
  <dd>A <var class="Vt">u_int32_t</var> containing the optimal block size when
      reading or writing this file's data.</dd>
  <dt>ATTR_FILE_CLUMPSIZE</dt>
  <dd>A <var class="Vt">u_int32_t</var> containing the allocation clump size for
      this file, in bytes. As the file is extended, the file system will attempt
      to allocate this much space each time in order to reduce fragmentation.
      This value applies to the data fork.</dd>
  <dt>ATTR_FILE_DEVTYPE</dt>
  <dd>(read/write) A <var class="Vt">u_int32_t</var> containing the device type
      for a special device file. Equivalent to the <var class="Fa">st_rdev</var>
      field of the <var class="Vt">stat</var> structure returned by
      <a class="Xr">stat(2)</a>.</dd>
  <dt>ATTR_FILE_FILETYPE</dt>
  <dd>A <var class="Vt">u_int32_t</var> that whose value is reserved. Clients
      should ignore its value. New volume format implementations should not
      support this attribute.</dd>
  <dt>ATTR_FILE_FORKCOUNT</dt>
  <dd>A <var class="Vt">u_int32_t</var> containing the number of forks in the
      file. No built-in file systems on Mac OS X currently support forks other
      than the data and resource fork.</dd>
  <dt>ATTR_FILE_FORKLIST</dt>
  <dd>An <var class="Vt">attrreference</var> structure containing a list of
      named forks of the file. No built-in file systems on Mac OS X currently
      support forks other than the data and resource fork. Because of this, the
      structure of this attribute's value is not yet defined.</dd>
  <dt>ATTR_FILE_DATALENGTH</dt>
  <dd>An <var class="Vt">off_t</var> containing the length of the data fork in
      bytes (the logical size).</dd>
  <dt>ATTR_FILE_DATAALLOCSIZE</dt>
  <dd>An <var class="Vt">off_t</var> containing a count of the bytes on disk
      used by the data fork (the physical size).</dd>
  <dt>ATTR_FILE_DATAEXTENTS</dt>
  <dd>An <var class="Vt">extentrecord</var> array for the data fork. The array
      contains eight <var class="Vt">diskextent</var> structures which represent
      the first eight extents of the fork.
    <p class="Pp">This attributes exists for compatibility reasons. New clients
        should not use this attribute. Rather, they should use the
        <code class="Dv">F_LOG2PHYS</code> command in
        <a class="Xr">fcntl(2)</a>.</p>
    <p class="Pp">In current implementations the value may not be entirely
        accurate for a variety of reasons.</p>
  </dd>
  <dt>ATTR_FILE_RSRCLENGTH</dt>
  <dd>An <var class="Vt">off_t</var> containing the length of the resource fork
      in bytes (the logical size).</dd>
  <dt>ATTR_FILE_RSRCALLOCSIZE</dt>
  <dd>An <var class="Vt">off_t</var> containing a count of the bytes on disk
      used by the resource fork (the physical size).</dd>
  <dt>ATTR_FILE_RSRCEXTENTS</dt>
  <dd>An <var class="Vt">extentrecord</var> array for the resource fork. The
      array contains eight <var class="Vt">diskextent</var> structures which
      represent the first eight extents of the fork.
    <p class="Pp">See also <code class="Dv">ATTR_FILE_DATAEXTENTS</code>.</p>
  </dd>
</dl>
<p class="Pp">File attributes are used for any file system object that is not a
    directory, not just ordinary files. Requested file attributes are not
    returned for file system objects that are directories.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="FORK_ATTRIBUTES"><a class="permalink" href="#FORK_ATTRIBUTES">FORK
  ATTRIBUTES</a></h1>
<p class="Pp">Fork attributes relate to the actual data in the file, which can
    be held in multiple named contiguous ranges, or forks. These cannot be used
    if the FSOPT_ATTR_CMN_EXTENDED is given. The following fork attributes are
    defined.</p>
<dl class="Bl-tag">
  <dt>ATTR_FORK_TOTALSIZE</dt>
  <dd>Deprecated. An <var class="Vt">off_t</var> containing the length of the
      fork in bytes (the logical size).</dd>
  <dt>ATTR_FORK_ALLOCSIZE</dt>
  <dd>Deprecated. An <var class="Vt">off_t</var> containing a count of the bytes
      on disk used by the fork (the physical size).</dd>
  <dt>ATTR_FORK_RESERVED</dt>
  <dd>Reserved. You must set this to 0.</dd>
</dl>
<p class="Pp">Fork attributes are deprecated and all bits are reserved. They are
    not properly implemented by any current Mac OS X volume format
    implementation. We strongly recommend that client programs do not request
    fork attributes. If you are implementing a volume format, you should not
    support these attributes.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COMMON_EXTENDED_ATTRIBUTES"><a class="permalink" href="#COMMON_EXTENDED_ATTRIBUTES">COMMON
  EXTENDED ATTRIBUTES</a></h1>
<p class="Pp">Common extended attributes are like common attributes except that
    they are set in the forkattr field and can only be used if the
    FSOPT_ATTR_CMN_EXTENDED option is given. Use of these attributes is mutually
    exclusive with the above fork attributes.</p>
<dl class="Bl-tag">
  <dt>ATTR_CMNEXT_RELPATH</dt>
  <dd>An <var class="Vt">attrreference</var> structure containing the
      mount-relative path of the file system object as a UTF-8 encoded, null
      terminated C string. The attribute data length will not be greater than
      <code class="Dv">PATH_MAX.</code> Inconsistent behavior may be observed
      when this attribute is requested on hard-linked items, particularly when
      the file system does not support ATTR_CMN_PARENTID natively. Callers
      should be aware of this when requesting the relative path of a hard-linked
      item.</dd>
  <dt>ATTR_CMNEXT_PRIVATESIZE</dt>
  <dd>An <var class="Vt">off_t</var> containing the number of bytes that are
      <b>not</b> trapped inside a clone or snapshot, and which would be freed
      immediately if the file were deleted.</dd>
  <dt>ATTR_CMNEXT_LINKID</dt>
  <dd>A <var class="Vt">u_int64_t</var> that uniquely identifies the file system
      object within a mounted volume for the duration of its mount.
    <p class="Pp">On HFS+ and APFS volumes, the ATTR_CMNEXT_LINKID of a file
        system object is distinct from the ATTR_CMNEXT_LINKID of any hard link
        to that file system object. Although the ATTR_CMNEXT_LINKID of a file
        system object may appear similar (in whole or in part) to its
        ATTR_CMN_FILEID (see description of ATTR_CMN_FILEID above), <b>no
        relation between the two attributes should ever be implied.</b></p>
  </dd>
  <dt>ATTR_CMNEXT_NOFIRMLINKPATH</dt>
  <dd>An <var class="Vt">attrreference</var> structure containing a path that
      does not have firmlinks of the file system object as a UTF-8 encoded, null
      terminated C string. The attribute data length will not be greater than
      <code class="Dv">PATH_MAX.</code> Inconsistent behavior may be observed
      when this attribute is requested on hard-linked items, particularly when
      the file system does not support ATTR_CMN_PARENTID natively. Callers
      should be aware of this when requesting the canonical path of a
      hard-linked item.</dd>
  <dt>ATTR_CMNEXT_REALDEVID</dt>
  <dd>A <var class="Vt">dev_t</var> containing the real device number of the
      device on which this file system object's volume is mounted. Equivalent to
      the <var class="Fa">st_dev</var> field of the <var class="Vt">stat</var>
      structure returned by <a class="Xr">stat(2)</a>.</dd>
  <dt>ATTR_CMNEXT_REALFSID</dt>
  <dd>An <var class="Vt">fsid_t</var> structure containing the real file system
      identifier for the volume on which the file system object resides.
      Equivalent to the <var class="Fa">f_fsid</var> field of the
      <var class="Vt">statfs</var> structure returned by
      <a class="Xr">statfs(2)</a>.</dd>
  <dt>ATTR_CMNEXT_CLONEID</dt>
  <dd>A <var class="Vt">u_int64_t</var> that uniquely identifies the data stream
      associated with the file system object. Useful for finding which files are
      pure clones of each other (as they will have the same clone-id).</dd>
  <dt>ATTR_CMNEXT_EXT_FLAGS</dt>
  <dd>A <var class="Vt">u_int64_t</var> that contains additional flags with
      information about the file. The flags are:
    <dl class="Bl-tag">
      <dt>EF_MAY_SHARE_BLOCKS</dt>
      <dd>If this bit is set then the file may share blocks with another file
          (i.e. it is a clone of another file).</dd>
      <dt>EF_NO_XATTRS</dt>
      <dd>If this bit is set then the file has no extended attributes. Useful
          for avoiding a call to listxattr().</dd>
      <dt>EF_IS_SYNC_ROOT</dt>
      <dd>If this bit is set the directory is a &quot;sync root&quot;. This bit
          will never be set for regular files.</dd>
      <dt>EF_IS_PURGEABLE</dt>
      <dd>If this bit is set the item is a &quot;purgeable&quot; item that can
          be deleted by the file system when asked to free space.</dd>
      <dt>EF_IS_SPARSE</dt>
      <dd>If this bit is set the item has sparse regions.</dd>
      <dt>EF_IS_SYNTHETIC</dt>
      <dd>If this bit is set the item is a synthetic directory/symlink.</dd>
    </dl>
  </dd>
  <dt>ATTR_CMNEXT_RECURSIVE_GENCOUNT</dt>
  <dd>A <var class="Vt">u_int64_t</var> that represents the recursive generation
      count of a directory that has been marked as maintain-dir-stats in an apfs
      file system. This gencount is updated any time any child is modified (as
      part of the contract that a maintain-dir-stats directory manages). If the
      directory is not marked maintain-dir-stats, a zero is returned.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="VOLUME_CAPABILITIES"><a class="permalink" href="#VOLUME_CAPABILITIES">VOLUME
  CAPABILITIES</a></h1>
<p class="Pp">Not all volumes support all features. The
    <code class="Dv">ATTR_VOL_CAPABILITIES</code> attribute returns a
    <var class="Vt">vol_capabilities_attr_t</var> structure (shown below) that
    indicates which features are supported by the volume.</p>
<div class="Bd Pp Li">
<pre>typedef u_int32_t vol_capabilities_set_t[4];

#define VOL_CAPABILITIES_FORMAT     0
#define VOL_CAPABILITIES_INTERFACES 1
#define VOL_CAPABILITIES_RESERVED1  2
#define VOL_CAPABILITIES_RESERVED2  3

typedef struct vol_capabilities_attr {
    vol_capabilities_set_t capabilities;
    vol_capabilities_set_t valid;
} vol_capabilities_attr_t;</pre>
</div>
<p class="Pp">The structure contains two fields,
    <var class="Fa">capabilities</var> and <var class="Fa">valid</var>. Each
    consists of an array of four elements. The arrays are indexed by the
    following values.</p>
<dl class="Bl-tag">
  <dt>VOL_CAPABILITIES_FORMAT</dt>
  <dd>This element contains information about the volume format. See
      <code class="Dv">VOL_CAP_FMT_PERSISTENTOBJECTIDS</code> and so on,
    below.</dd>
  <dt>VOL_CAPABILITIES_INTERFACES</dt>
  <dd>This element contains information about which optional functions are
      supported by the volume format implementation. See
      <code class="Dv">VOL_CAP_INT_SEARCHFS</code> and so on, below.</dd>
  <dt>VOL_CAPABILITIES_RESERVED1</dt>
  <dd>Reserved. A file system implementation should set this element to zero. A
      client program should ignore this element.</dd>
  <dt>VOL_CAPABILITIES_RESERVED2</dt>
  <dd>Reserved. A file system implementation should set this element to zero. A
      client program should ignore this element.</dd>
</dl>
<p class="Pp">The <var class="Fa">valid</var> field contains bit sets that
    indicate which flags are known to the volume format implementation. Each bit
    indicates whether the contents of the corresponding bit in the
    <var class="Fa">capabilities</var> field is valid.</p>
<p class="Pp">The <var class="Fa">capabilities</var> field contains bit sets
    that indicate whether a particular feature is implemented by this volume
    format.</p>
<p class="Pp">The following bits are defined in the first element (indexed by
    <code class="Dv">VOL_CAPABILITIES_FORMAT</code>) of the
    <var class="Fa">capabilities</var> and <var class="Fa">valid</var> fields of
    the <var class="Vt">vol_capabilities_attr_t</var> structure.</p>
<dl class="Bl-tag">
  <dt>VOL_CAP_FMT_PERSISTENTOBJECTIDS</dt>
  <dd>If this bit is set the volume format supports persistent object
      identifiers and can look up file system objects by their IDs. See
      <code class="Dv">ATTR_CMN_OBJPERMANENTID</code> for details about how to
      obtain these identifiers.</dd>
  <dt>VOL_CAP_FMT_SYMBOLICLINKS</dt>
  <dd>If this bit is set the volume format supports symbolic links.</dd>
  <dt>VOL_CAP_FMT_HARDLINKS</dt>
  <dd>If this bit is set the volume format supports hard links.</dd>
  <dt>VOL_CAP_FMT_JOURNAL</dt>
  <dd>If this bit is set the volume format supports a journal used to speed
      recovery in case of unplanned restart (such as a power outage or crash).
      This does not necessarily mean the volume is actively using a journal.
    <p class="Pp">Introduced with Darwin 7.0 (Mac OS X version 10.3).</p>
  </dd>
  <dt>VOL_CAP_FMT_JOURNAL_ACTIVE</dt>
  <dd>If this bit is set the volume is currently using a journal for speedy
      recovery after an unplanned restart. This bit can be set only if
      <code class="Dv">VOL_CAP_FMT_JOURNAL</code> is also set.
    <p class="Pp">Introduced with Darwin 7.0 (Mac OS X version 10.3).</p>
  </dd>
  <dt>VOL_CAP_FMT_NO_ROOT_TIMES</dt>
  <dd>If this bit is set the volume format does not store reliable times for the
      root directory, so you should not depend on them to detect changes,
      identify volumes across unmount/mount, and so on.
    <p class="Pp">Introduced with Darwin 7.0 (Mac OS X version 10.3).</p>
  </dd>
  <dt>VOL_CAP_FMT_SPARSE_FILES</dt>
  <dd>If this bit is set the volume format supports sparse files, that is, files
      which can have 'holes' that have never been written to, and thus do not
      consume space on disk. A sparse file may have an allocated size on disk
      that is less than its logical length (that is,
      <code class="Dv">ATTR_FILE_ALLOCSIZE</code> &lt;
      <code class="Dv">ATTR_FILE_TOTALSIZE ).</code>
    <p class="Pp">Introduced with Darwin 7.0 (Mac OS X version 10.3).</p>
  </dd>
  <dt>VOL_CAP_FMT_ZERO_RUNS</dt>
  <dd>For security reasons, parts of a file (runs) that have never been written
      to must appear to contain zeroes. When this bit is set, the volume keeps
      track of allocated but unwritten runs of a file so that it can substitute
      zeroes without actually writing zeroes to the media. This provides
      performance similar to sparse files, but not the space savings.
    <p class="Pp">Introduced with Darwin 7.0 (Mac OS X version 10.3).</p>
  </dd>
  <dt>VOL_CAP_FMT_CASE_SENSITIVE</dt>
  <dd>If this bit is set the volume format treats upper and lower case
      characters in file and directory names as different. Otherwise an upper
      case character is equivalent to a lower case character, and you can't have
      two names that differ solely in the case of the characters.
    <p class="Pp">Introduced with Darwin 7.0 (Mac OS X version 10.3).</p>
  </dd>
  <dt>VOL_CAP_FMT_CASE_PRESERVING</dt>
  <dd>If this bit is set the volume format preserves the case of file and
      directory names. Otherwise the volume may change the case of some
      characters (typically making them all upper or all lower case). A volume
      that sets <code class="Dv">VOL_CAP_FMT_CASE_SENSITIVE</code> must also set
      <code class="Dv">VOL_CAP_FMT_CASE_PRESERVING</code>.
    <p class="Pp">Introduced with Darwin 7.0 (Mac OS X version 10.3).</p>
  </dd>
  <dt>VOL_CAP_FMT_FAST_STATFS</dt>
  <dd>This bit is used as a hint to upper layers to indicate that
      <a class="Xr">statfs(2)</a> is fast enough that its results need not be
      cached by the caller. A volume format implementation that caches the
      <a class="Xr">statfs(2)</a> information in memory should set this bit. An
      implementation that must always read from disk or always perform a network
      transaction to satisfy <a class="Xr">statfs(2)</a> should not set this
      bit.
    <p class="Pp">Introduced with Darwin 7.0 (Mac OS X version 10.3).</p>
  </dd>
  <dt>VOL_CAP_FMT_2TB_FILESIZE</dt>
  <dd>If this bit is set the volume format supports file sizes larger than 4GB,
      and potentially up to 2TB; it does not indicate whether the file system
      supports files larger than that.
    <p class="Pp">Introduced with Darwin 8.0 (Mac OS X version 10.4).</p>
  </dd>
  <dt>VOL_CAP_FMT_OPENDENYMODES</dt>
  <dd>If this bit is set, the volume format supports open deny modes (e.g.,
      &quot;open for read write, deny write&quot;).</dd>
  <dt>VOL_CAP_FMT_HIDDEN_FILES</dt>
  <dd>If this bit is set, the volume format supports the
      <code class="Dv">UF_HIDDEN</code> file flag, and the
      <code class="Dv">UF_HIDDEN</code> flag is mapped to that volume's native
      &quot;hidden&quot; or &quot;invisible&quot; bit (e.g., the invisible bit
      from the Finder Info extended attribute).</dd>
  <dt>VOL_CAP_FMT_PATH_FROM_ID</dt>
  <dd>If this bit is set, the volume format supports the ability to derive a
      pathname to the root of the file system given only the ID of an object.
      This also implies that object IDs on this file system are persistent and
      not recycled. Most file systems will not support this capability.</dd>
  <dt>VOL_CAP_FMT_NO_VOLUME_SIZES</dt>
  <dd>If this bit is set the volume format does not support determining values
      for total data blocks, available blocks, or free blocks, as in
      <var class="Fa">f_blocks,</var> <var class="Fa">f_bavail,</var> and
      <var class="Fa">f_bfree</var> in the <var class="Fa">struct statfs</var>
      returned by <a class="Xr">statfs(2)</a>. Historically, those values were
      set to 0xFFFFFFFF for volumes that did not support them.
    <p class="Pp">Introduced with Darwin 10.0 (Mac OS X version 10.6).</p>
  </dd>
  <dt>VOL_CAP_FMT_64BIT_OBJECT_IDS</dt>
  <dd>If this bit is set, the volume format uses object IDs that are 64-bit.
      This means that ATTR_CMN_FILEID and ATTR_CMN_PARENTID are the primary
      means of obtaining object IDs from this volume. The values returned by
      ATTR_CMN_OBJID, ATTR_CMN_OBJPERMANENTID, and ATTR_CMN_PAROBJID can be
      interpreted as 64-bit object IDs instead of fsobj_id_t.</dd>
  <dt>VOL_CAP_FMT_NO_IMMUTABLE_FILES</dt>
  <dd>If this bit is set, the volume format does not support setting the
      UF_IMMUTABLE flag. See ATTR_CMN_FLAGS for more details.</dd>
  <dt>VOL_CAP_FMT_NO_PERMISSIONS</dt>
  <dd>If this bit is set, the volume format does not support setting file
      permissions. See ATTR_CMN_USERACCESS for more details.</dd>
  <dt>VOL_CAP_FMT_SHARED_SPACE</dt>
  <dd>If this bit is set, the volume format supports having multiple logical
      filesystems in a single &quot;partition&quot; which share space.</dd>
  <dt>VOL_CAP_FMT_VOL_GROUPS</dt>
  <dd>If this bit is set, the volume format supports having multiple logical
      filesystems which may be mounted and unmounted together and may present
      common filesystem identifier information.</dd>
  <dt>VOL_CAP_FMT_SEALED</dt>
  <dd>If this bit is set, the volume is cryptographically sealed and any
      modifications may render the volume unusable.</dd>
</dl>
<p class="Pp">The following bits are defined in the second element (indexed by
    <code class="Dv">VOL_CAPABILITIES_INTERFACES</code>) of the
    <var class="Fa">capabilities</var> and <var class="Fa">valid</var> fields of
    the <var class="Vt">vol_capabilities_attr_t</var> structure.</p>
<dl class="Bl-tag">
  <dt>VOL_CAP_INT_SEARCHFS</dt>
  <dd>If this bit is set the volume format implementation supports
      <a class="Xr">searchfs(2)</a>.</dd>
  <dt id="getattrlist~6">VOL_CAP_INT_ATTRLIST</dt>
  <dd>If this bit is set the volume format implementation supports
      <a class="permalink" href="#getattrlist~6"><code class="Fn">getattrlist</code></a>()
      and <a class="Xr">setattrlist(2)</a>.</dd>
  <dt>VOL_CAP_INT_NFSEXPORT</dt>
  <dd>If this bit is set the volume format implementation allows this volume to
      be exported via NFS.</dd>
  <dt>VOL_CAP_INT_READDIRATTR</dt>
  <dd>If this bit is set the volume format implementation supports
      <a class="Xr">getdirentriesattr(2)</a>.</dd>
  <dt>VOL_CAP_INT_EXCHANGEDATA</dt>
  <dd>If this bit is set the volume format implementation supports
      <a class="Xr">exchangedata(2)</a>.
    <p class="Pp">Introduced with Darwin 7.0 (Mac OS X version 10.3).</p>
  </dd>
  <dt>VOL_CAP_INT_COPYFILE</dt>
  <dd>If this bit is set the volume format implementation supports the (private
      and undocumented) copyfile() function. (This is not the
      <a class="Xr">copyfile(3)</a> function.)
    <p class="Pp">Introduced with Darwin 7.0 (Mac OS X version 10.3).</p>
  </dd>
  <dt>VOL_CAP_INT_ALLOCATE</dt>
  <dd>If this bit is set the volume format implementation supports the
      <code class="Dv">F_PREALLOCATE</code> selector of
      <a class="Xr">fcntl(2)</a>.
    <p class="Pp">Introduced with Darwin 7.0 (Mac OS X version 10.3).</p>
  </dd>
  <dt>VOL_CAP_INT_VOL_RENAME</dt>
  <dd>If this bit is set the volume format implementation allows you to modify
      the volume name using <a class="Xr">setattrlist(2)</a>.
    <p class="Pp">Introduced with Darwin 7.0 (Mac OS X version 10.3).</p>
  </dd>
  <dt>VOL_CAP_INT_ADVLOCK</dt>
  <dd>If this bit is set the volume format implementation supports advisory
      locking, that is, the <code class="Dv">F_GETLK</code>,
      <code class="Dv">F_SETLK</code>, and <code class="Dv">F_SETLKW</code>
      selectors to <a class="Xr">fcntl(2)</a>.
    <p class="Pp">Introduced with Darwin 7.0 (Mac OS X version 10.3).</p>
  </dd>
  <dt>VOL_CAP_INT_FLOCK</dt>
  <dd>If this bit is set the volume format implementation supports whole file
      locks. This includes <a class="Xr">flock(2)</a> and the
      <code class="Dv">O_EXLOCK</code> and <code class="Dv">O_SHLOCK</code>
      flags to <a class="Xr">open(2)</a>.
    <p class="Pp">Introduced with Darwin 7.0 (Mac OS X version 10.3).</p>
  </dd>
  <dt>VOL_CAP_INT_EXTENDED_SECURITY</dt>
  <dd>If this bit is set the volume format implementation supports extended
      security controls (ACLs).
    <p class="Pp">Introduced with Darwin 8.0 (Mac OS X version 10.4).</p>
  </dd>
  <dt>VOL_CAP_INT_USERACCESS</dt>
  <dd>If this bit is set the volume format implementation supports the
      ATTR_CMN_USERACCESS attribute.
    <p class="Pp">Introduced with Darwin 8.0 (Mac OS X version 10.4).</p>
  </dd>
  <dt>VOL_CAP_INT_MANLOCK</dt>
  <dd>If this bit is set, the volume format implementation supports AFP-style
      mandatory byte range locks via <a class="Xr">ioctl(2)</a>.</dd>
  <dt>VOL_CAP_INT_EXTENDED_ATTR</dt>
  <dd>If this bit is set, the volume format implementation supports native
      extended attributes (see <a class="Xr">setxattr(2)</a>).</dd>
  <dt>VOL_CAP_INT_CLONE</dt>
  <dd>If this bit is set, the file system supports cloning files and
      directories. See <a class="Xr">clonefileat(2)</a> for more details.</dd>
  <dt>VOL_CAP_INT_SNAPSHOT</dt>
  <dd>If this bit is set, the file system supports snapshots. See
      <a class="Xr">fs_snapshot_create(2)</a> for more details.</dd>
  <dt>VOL_CAP_INT_NAMEDSTREAMS</dt>
  <dd>If this bit is set, the volume format implementation supports native named
      streams.</dd>
  <dt>VOL_CAP_INT_RENAME_SWAP</dt>
  <dd>If this bit is set, the file system supports swapping file system objects.
      See <a class="Xr">rename(2)</a> for more details.</dd>
  <dt>VOL_CAP_INT_RENAME_EXCL</dt>
  <dd>If this bit is set, the file system supports an exclusive rename
      operation. See <a class="Xr">rename(2)</a> for more details.</dd>
  <dt>VOL_CAP_INT_RENAME_OPENFAIL</dt>
  <dd>If this bit is set, the file system may fail a rename operation of a
      directory if one of its descendents is open. See
      <a class="Xr">rename(2)</a> for more details.</dd>
</dl>
<p class="Pp">A volume can also report which attributes it supports. This
    information is returned by the <code class="Dv">ATTR_VOL_ATTRIBUTES</code>
    attribute, which returns a <var class="Vt">vol_attributes_attr_t</var>
    structure (shown below).</p>
<div class="Bd Pp Li">
<pre>typedef struct attribute_set {
    attrgroup_t commonattr; /* common attribute group */
    attrgroup_t volattr;    /* volume attribute group */
    attrgroup_t dirattr;    /* directory attribute group */
    attrgroup_t fileattr;   /* file attribute group */
    attrgroup_t forkattr;   /* fork attribute group */
} attribute_set_t;

typedef struct vol_attributes_attr {
    attribute_set_t validattr;
    attribute_set_t nativeattr;
} vol_attributes_attr_t;</pre>
</div>
<p class="Pp">The <var class="Fa">validattr</var> field consists of a number of
    bit sets that indicate whether an attribute is supported by the volume
    format implementation. The <var class="Fa">nativeattr</var> is similar
    except that the bit sets indicate whether an attribute is supported natively
    by the volume format. An attribute is supported natively if the volume
    format implementation does not have to do any complex conversions to access
    the attribute. For example, a volume format might support persistent object
    identifiers, but doing so requires a complex table lookup that is not part
    of the core volume format. In that case, the
    <code class="Dv">ATTR_VOL_ATTRIBUTES</code> attribute would return
    <code class="Dv">ATTR_CMN_OBJPERMANENTID</code> set in the
    <var class="Fa">validattr</var> field of the
    <var class="Vt">vol_attributes_attr_t</var>, but not in the
    <var class="Fa">nativeattr</var> field.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="RETURN_VALUES"><a class="permalink" href="#RETURN_VALUES">RETURN
  VALUES</a></h1>
<p class="Pp">Upon successful completion a value of 0 is returned. Otherwise, a
    value of -1 is returned and <var class="Va">errno</var> is set to indicate
    the error.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COMPATIBILITY"><a class="permalink" href="#COMPATIBILITY">COMPATIBILITY</a></h1>
<p class="Pp">Not all volumes support <code class="Fn">getattrlist</code>(). The
    best way to test whether a volume supports this function is to simply call
    it and check the error result. <code class="Fn">getattrlist</code>() will
    return <code class="Dv">ENOTSUP</code> if it is not supported on a
    particular volume.</p>
<p class="Pp">The <code class="Fn">getattrlist</code>() function has been
    undocumented for more than two years. In that time a number of volume format
    implementations have been created without a proper specification for the
    behaviour of this routine. You may encounter volume format implementations
    with slightly different behaviour than what is described here. Your program
    is expected to be tolerant of this variant behaviour.</p>
<p class="Pp">If you're implementing a volume format that supports
    <code class="Fn">getattrlist</code>(), you should be careful to support the
    behaviour specified by this document.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="ERRORS"><a class="permalink" href="#ERRORS">ERRORS</a></h1>
<p class="Pp"><code class="Fn">getattrlist</code>() and
    <code class="Fn">fgetattrlist</code>() will fail if:</p>
<dl class="Bl-tag">
  <dt id="ENOTSUP">[<a class="permalink" href="#ENOTSUP"><code class="Er">ENOTSUP</code></a>]</dt>
  <dd>The volume does not support the query.</dd>
  <dt id="ENOTDIR">[<a class="permalink" href="#ENOTDIR"><code class="Er">ENOTDIR</code></a>]</dt>
  <dd>A component of the path prefix for <code class="Fn">getattrlist</code>()
      is not a directory.</dd>
  <dt id="ENAMETOOLONG">[<a class="permalink" href="#ENAMETOOLONG"><code class="Er">ENAMETOOLONG</code></a>]</dt>
  <dd>A component of a path name for <code class="Fn">getattrlist</code>()
      exceeded <code class="Dv">NAME_MAX</code> characters, or an entire path
      name exceeded <code class="Dv">PATH_MAX</code> characters.</dd>
  <dt id="ENOENT">[<a class="permalink" href="#ENOENT"><code class="Er">ENOENT</code></a>]</dt>
  <dd>The file system object for <code class="Fn">getattrlist</code>() does not
      exist.</dd>
  <dt id="EBADF">[<a class="permalink" href="#EBADF"><code class="Er">EBADF</code></a>]</dt>
  <dd>The file descriptor argument for <code class="Fn">fgetattrlist</code>() is
      not a valid file descriptor.</dd>
  <dt id="EACCES">[<a class="permalink" href="#EACCES"><code class="Er">EACCES</code></a>]</dt>
  <dd>Search permission is denied for a component of the path prefix for
      <code class="Fn">getattrlist</code>().</dd>
  <dt id="ELOOP">[<a class="permalink" href="#ELOOP"><code class="Er">ELOOP</code></a>]</dt>
  <dd>Too many symbolic links were encountered in translating the pathname for
      <code class="Fn">getattrlist</code>().</dd>
  <dt id="ELOOP~2">[<a class="permalink" href="#ELOOP~2"><code class="Er">ELOOP</code></a>]</dt>
  <dd>FSOPT_NOFOLLOW_ANY was passed and a symbolic link was encountered in
      translating the pathname for <code class="Fn">getattrlist</code>().</dd>
  <dt id="EFAULT">[<a class="permalink" href="#EFAULT"><code class="Er">EFAULT</code></a>]</dt>
  <dd><var class="Fa">path</var>, <var class="Fa">attrList</var> or
      <a class="permalink" href="#attrBuf"><i class="Em" id="attrBuf">attrBuf</i></a>
      points to an invalid address.</dd>
  <dt id="ERANGE">[<a class="permalink" href="#ERANGE"><code class="Er">ERANGE</code></a>]</dt>
  <dd><var class="Fa">attrBufSize</var> is too small to hold a u_int32_t.</dd>
  <dt id="EINVAL">[<a class="permalink" href="#EINVAL"><code class="Er">EINVAL</code></a>]</dt>
  <dd>The <var class="Fa">bitmapcount</var> field of
      <var class="Fa">attrList</var> is not
      <code class="Dv">ATTR_BIT_MAP_COUNT</code>.</dd>
  <dt id="EINVAL~2">[<a class="permalink" href="#EINVAL~2"><code class="Er">EINVAL</code></a>]</dt>
  <dd>You requested an invalid attribute.</dd>
  <dt id="EINVAL~3">[<a class="permalink" href="#EINVAL~3"><code class="Er">EINVAL</code></a>]</dt>
  <dd>You requested an attribute that is not supported for this file system
      object.</dd>
  <dt id="EINVAL~4">[<a class="permalink" href="#EINVAL~4"><code class="Er">EINVAL</code></a>]</dt>
  <dd>You requested volume attributes and directory or file attributes.</dd>
  <dt id="EINVAL~5">[<a class="permalink" href="#EINVAL~5"><code class="Er">EINVAL</code></a>]</dt>
  <dd>You requested volume attributes but <var class="Fa">path</var> does not
      reference the root of the volume.</dd>
  <dt id="EROFS">[<a class="permalink" href="#EROFS"><code class="Er">EROFS</code></a>]</dt>
  <dd>The volume is read-only but must be modified in order to return this
      attribute.</dd>
  <dt id="EIO">[<a class="permalink" href="#EIO"><code class="Er">EIO</code></a>]</dt>
  <dd>An I/O error occurred while reading from or writing to the file
    system.</dd>
</dl>
<p class="Pp">In addition to the errors returned by the
    <code class="Fn">getattrlist</code>(), the
    <code class="Fn">getattrlistat</code>() function may fail if:</p>
<dl class="Bl-tag">
  <dt id="EBADF~2">[<a class="permalink" href="#EBADF~2"><code class="Er">EBADF</code></a>]</dt>
  <dd>The <var class="Fa">path</var> argument does not specify an absolute path
      and the <var class="Fa">fd</var> argument is neither
      <code class="Dv">AT_FDCWD</code> nor a valid file descriptor open for
      searching.</dd>
  <dt id="ENOTDIR~2">[<a class="permalink" href="#ENOTDIR~2"><code class="Er">ENOTDIR</code></a>]</dt>
  <dd>The <var class="Fa">path</var> argument is not an absolute path and
      <var class="Fa">fd</var> is neither <code class="Dv">AT_FDCWD</code> nor a
      file descriptor associated with a directory.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="CAVEATS"><a class="permalink" href="#CAVEATS">CAVEATS</a></h1>
<p class="Pp">If you request any volume attributes, you must set
    <code class="Dv">ATTR_VOL_INFO</code> in the <var class="Fa">volattr</var>
    field, even though it generates no result in the attribute buffer.</p>
<p class="Pp">The order that attributes are stored in the attribute buffer
    almost invariably matches the order of attribute mask bit values. For
    example, <code class="Dv">ATTR_CMN_NAME</code> (0x00000001) comes before
    <code class="Dv">ATTR_CMN_DEVID</code> (0x00000002) because its value is
    smaller. When ordering attributes, you should always use the order in which
    they are described above.</p>
<p class="Pp">The <var class="Vt">timespec</var> structure is 64-bits (two
    32-bit elements) in 32-bit code, and 128-bits (two 64-bit elements) in
    64-bit code; however, it is aligned on a 4-byte (32-bit) boundary, even in
    64-bit code.</p>
<p class="Pp">If you use a structure for the attribute data, it must be
    correctly packed and aligned (see examples).</p>
<p class="Pp">Inconsistent behavior may be observed when the ATTR_CMN_FULLPATH
    attribute is requested on hard-linked items, particularly when the file
    system does not support ATTR_CMN_PARENTID natively. Callers should be aware
    of this when requesting the full path of a hard-linked item, especially if
    the full path crosses mount points.</p>
<p class="Pp">For more caveats, see also the compatibility notes above.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="EXAMPLES"><a class="permalink" href="#EXAMPLES">EXAMPLES</a></h1>
<p class="Pp">The following code prints the file type and creator of a file,
    assuming that the volume supports the required attributes.</p>
<div class="Bd Pp Li">
<pre>#include &lt;assert.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/attr.h&gt;
#include &lt;sys/errno.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/vnode.h&gt;

typedef struct attrlist attrlist_t;

struct FInfoAttrBuf {
    u_int32_t       length;
    fsobj_type_t    objType;
    char            finderInfo[32];
}  __attribute__((aligned(4), packed));
typedef struct FInfoAttrBuf FInfoAttrBuf;

static int FInfoDemo(const char *path)
{
    int             err;
    attrlist_t      attrList;
    FInfoAttrBuf    attrBuf;

    memset(&amp;attrList, 0, sizeof(attrList));
    attrList.bitmapcount = ATTR_BIT_MAP_COUNT;
    attrList.commonattr  = ATTR_CMN_OBJTYPE | ATTR_CMN_FNDRINFO;


    err = getattrlist(path, &amp;attrList, &amp;attrBuf, sizeof(attrBuf), 0);
    if (err != 0) {
        err = errno;
    }


    if (err == 0) {
        assert(attrBuf.length == sizeof(attrBuf));


        printf(&quot;Finder information for %s:\n&quot;, path);
        switch (attrBuf.objType) {
            case VREG:
                printf(&quot;file type    = '%.4s'\n&quot;, &amp;attrBuf.finderInfo[0]);
                printf(&quot;file creator = '%.4s'\n&quot;, &amp;attrBuf.finderInfo[4]);
                break;
            case VDIR:
                printf(&quot;directory\n&quot;);
                break;
            default:
                printf(&quot;other object type, %d\n&quot;, attrBuf.objType);
                break;
        }
    }

    return err;
}</pre>
</div>
<p class="Pp">The following code is an alternative implementation that uses
    nested structures to group the related attributes.</p>
<div class="Bd Pp Li">
<pre>#include &lt;assert.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stddef.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/attr.h&gt;
#include &lt;sys/errno.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/vnode.h&gt;

typedef struct attrlist attrlist_t;

struct FInfo2CommonAttrBuf {
    fsobj_type_t    objType;
    char            finderInfo[32];
} __attribute__((aligned(4), packed));
typedef struct FInfo2CommonAttrBuf FInfo2CommonAttrBuf;

struct FInfo2AttrBuf {
    u_int32_t           length;
    FInfo2CommonAttrBuf common;
} __attribute__((aligned(4), packed));;
typedef struct FInfo2AttrBuf FInfo2AttrBuf;

static int FInfo2Demo(const char *path)
{
    int             err;
    attrlist_t      attrList;
    FInfo2AttrBuf   attrBuf;

    memset(&amp;attrList, 0, sizeof(attrList));
    attrList.bitmapcount = ATTR_BIT_MAP_COUNT;
    attrList.commonattr  = ATTR_CMN_OBJTYPE | ATTR_CMN_FNDRINFO;

    err = getattrlist(path, &amp;attrList, &amp;attrBuf, sizeof(attrBuf), 0);
    if (err != 0) {
        err = errno;
    }

    if (err == 0) {
        assert(attrBuf.length == sizeof(attrBuf));

        printf(&quot;Finder information for %s:\n&quot;, path);
        switch (attrBuf.common.objType) {
            case VREG:
                printf(
                    &quot;file type    = '%.4s'\n&quot;,
                    &amp;attrBuf.common.finderInfo[0]
                );
                printf(
                    &quot;file creator = '%.4s'\n&quot;,
                    &amp;attrBuf.common.finderInfo[4]
                );
                break;
            case VDIR:
                printf(&quot;directory\n&quot;);
                break;
            default:
                printf(
                    &quot;other object type, %d\n&quot;,
                    attrBuf.common.objType
                );
                break;
        }
    }

    return err;
}</pre>
</div>
<p class="Pp">The following example shows how to deal with variable length
    attributes. It assumes that the volume specified by
    <var class="Fa">path</var> supports the necessary attributes.</p>
<div class="Bd Pp Li">
<pre>#include &lt;assert.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stddef.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/attr.h&gt;
#include &lt;sys/errno.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/vnode.h&gt;

typedef struct attrlist attrlist_t;

struct VolAttrBuf {
    u_int32_t       length;
    u_int32_t       fileCount;
    u_int32_t       dirCount;
    attrreference_t mountPointRef;
    attrreference_t volNameRef;
    char            mountPointSpace[MAXPATHLEN];
    char            volNameSpace[MAXPATHLEN];
} __attribute__((aligned(4), packed));
typedef struct VolAttrBuf VolAttrBuf;

static int VolDemo(const char *path)
{
    int             err;
    attrlist_t      attrList;
    VolAttrBuf      attrBuf;

    memset(&amp;attrList, 0, sizeof(attrList));
    attrList.bitmapcount = ATTR_BIT_MAP_COUNT;
    attrList.volattr     =   ATTR_VOL_INFO
                           | ATTR_VOL_FILECOUNT
                           | ATTR_VOL_DIRCOUNT
                           | ATTR_VOL_MOUNTPOINT
                           | ATTR_VOL_NAME;


    err = getattrlist(path, &amp;attrList, &amp;attrBuf, sizeof(attrBuf), 0);
    if (err != 0) {
        err = errno;
    }


    if (err == 0) {
        assert(attrBuf.length &gt;  offsetof(VolAttrBuf, mountPointSpace));
        assert(attrBuf.length &lt;= sizeof(attrBuf));


        printf(&quot;Volume information for %s:\n&quot;, path);
        printf(&quot;ATTR_VOL_FILECOUNT:  %u\n&quot;, attrBuf.fileCount);
        printf(&quot;ATTR_VOL_DIRCOUNT:   %u\n&quot;, attrBuf.dirCount);
        printf(
            &quot;ATTR_VOL_MOUNTPOINT: %.*s\n&quot;,
            (int) attrBuf.mountPointRef.attr_length,
            ( ((char *) &amp;attrBuf.mountPointRef)
              + attrBuf.mountPointRef.attr_dataoffset )
        );
        printf(
            &quot;ATTR_VOL_NAME:       %.*s\n&quot;,
            (int) attrBuf.volNameRef.attr_length,
            ( ((char *) &amp;attrBuf.volNameRef)
              + attrBuf.volNameRef.attr_dataoffset )
        );
    }

    return err;
}</pre>
</div>
<p class="Pp">The following sample demonstrates the need to use packing and
    alignment controls; without the attribute, in 64-bit code, the fields of the
    structure are not placed at the locations that the kernel expects.</p>
<div class="Bd Pp Li">
<pre>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;string.h&gt;
#include &lt;err.h&gt;
#include &lt;time.h&gt;
#include &lt;sys/attr.h&gt;

/* The alignment and packing attribute is necessary in 64-bit code */
struct AttrListTimes {
	u_int32_t       length;
	struct timespec st_crtime;
	struct timespec st_modtime;
} __attribute__((aligned(4), packed));

main(int argc, char **argv)
{
	int             rv;
	int             i;

	for (i = 1; i &lt; argc; i++) {
		struct attrlist attrList;
		struct AttrListTimes myStat = {0};
		char           *path = argv[i];

		memset(&amp;attrList, 0, sizeof(attrList));
		attrList.bitmapcount = ATTR_BIT_MAP_COUNT;
		attrList.commonattr = ATTR_CMN_CRTIME |
			ATTR_CMN_MODTIME;

		rv = getattrlist(path, &amp;attrList, &amp;myStat, sizeof(myStat), 0);

		if (rv == -1) {
			warn(&quot;getattrlist(%s)&quot;, path);
			continue;
		}
		printf(&quot;%s:  Modification time = %s&quot;, argv[i], ctime(&amp;myStat.st_modtime.tv_sec));
	}
	return 0;
}</pre>
</div>
<p class="Pp">
  <br/>
   The getLinkIDInfo() function determines if ATTR_CMNEXT_LINKID and
    ATTR_CMN_OBJID
  <br/>
   are valid to use on the file system specified by path.</p>
<div class="Bd Pp Li">
<pre>int getLinkIDInfo(const char *path, bool *cmnExtLinkIDValid, bool *cmnObjIDValid)
{
    int result;
    struct statfs statfsBuf;
    struct attrlist attrList;
    struct volAttrsBuf {
        u_int32_t length;
        vol_capabilities_attr_t capabilities;
        vol_attributes_attr_t attributes;
    } __attribute__((aligned(4), packed));
    struct volAttrsBuf volAttrs;

    memset(&amp;attrList, 0, sizeof(attrList));
    attrList.bitmapcount = ATTR_BIT_MAP_COUNT;
    attrList.volattr = ATTR_VOL_INFO | ATTR_VOL_CAPABILITIES | ATTR_VOL_ATTRIBUTES;
    // get the file system's mount point path for the input path
    result = statfs(path, &amp;statfsBuf);
    if ( result == 0 ) {
        // get the supported capabilities and attributes
        result = getattrlist(statfsBuf.f_mntonname, &amp;attrList, &amp;volAttrs, sizeof(volAttrs), FSOPT_ATTR_CMN_EXTENDED);
        if ( result == 0 ) {
            if ( volAttrs.attributes.validattr.forkattr &amp; ATTR_CMNEXT_LINKID ) {
                // ATTR_CMNEXT_LINKID is available; do not use ATTR_CMN_OBJID
                *cmnExtLinkIDValid = true;
                *cmnObjIDValid = false;
            }
            else {
                // ATTR_CMNEXT_LINKID is not available
                cmnExtLinkIDValid = false;
                // ATTR_CMN_OBJID can only be used if the file system does not use 64-bit object IDs
                if ( (volAttrs.capabilities.capabilities[VOL_CAPABILITIES_FORMAT] &amp; VOL_CAP_FMT_64BIT_OBJECT_IDS) &amp;&amp; (volAttrs.capabilities.valid[VOL_CAPABILITIES_FORMAT] &amp; VOL_CAP_FMT_64BIT_OBJECT_IDS) ) {
                    *cmnObjIDValid = false;
                }
                else {
                    *cmnObjIDValid = true;
                }
            }
        }
    }
    if ( result != 0 ) {
        *cmnExtLinkIDValid = *cmnObjIDValid = false;
    }
    return result;
}</pre>
</div>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp"><a class="Xr">access(2)</a>, <a class="Xr">chflags(2)</a>,
    <a class="Xr">exchangedata(2)</a>, <a class="Xr">fcntl(2)</a>,
    <a class="Xr">getattrlistbulk(2)</a>, <a class="Xr">mount(2)</a>,
    <a class="Xr">searchfs(2)</a>, <a class="Xr">setattrlist(2)</a>,
    <a class="Xr">stat(2)</a>, <a class="Xr">statfs(2)</a></p>
</section>
<section class="Sh">
<h1 class="Sh" id="HISTORY"><a class="permalink" href="#HISTORY">HISTORY</a></h1>
<p class="Pp">A <code class="Fn">getattrlist</code>() function call appeared in
    Darwin 1.3.1 (Mac OS X version 10.0). The
    <code class="Fn">getattrlistat</code>() function call appeared in OS X 10.10
    .</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">February 11, 2020</td>
    <td class="foot-os">Darwin</td>
  </tr>
</table>
</body>
</html>
