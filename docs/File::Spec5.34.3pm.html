<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    .Nd, .Bf, .Op { display: inline; }
    .Pa, .Ad { font-style: italic; }
    .Ms { font-weight: bold; }
    .Bl-diag > dt { font-weight: bold; }
    code.Nm, .Fl, .Cm, .Ic, code.In, .Fd, .Fn, .Cd { font-weight: bold;
      font-family: inherit; }
  </style>
  <title>File::Spec(3pm)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">File::Spec(3pm)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">File::Spec(3pm)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">File::Spec - portably perform operations on file names</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>        use File::Spec;
        $x=File::Spec-&gt;catfile('a', 'b', 'c');
</pre>
<p class="Pp">which returns 'a/b/c' under Unix. Or:</p>
<p class="Pp"></p>
<pre>        use File::Spec::Functions;
        $x = catfile('a', 'b', 'c');
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">This module is designed to support operations commonly performed
    on file specifications (usually called &quot;file names&quot;, but not to be
    confused with the contents of a file, or Perl's file handles), such as
    concatenating several directory and file names into a single path, or
    determining whether a path is rooted. It is based on code directly taken
    from MakeMaker 5.17, code written by Andreas Koenig, Andy Dougherty, Charles
    Bailey, Ilya Zakharevich, Paul Schinder, and others.</p>
<p class="Pp">Since these functions are different for most operating systems,
    each set of OS specific routines is available in a separate module,
    including:</p>
<p class="Pp"></p>
<pre>        File::Spec::Unix
        File::Spec::Mac
        File::Spec::OS2
        File::Spec::Win32
        File::Spec::VMS
</pre>
<p class="Pp">The module appropriate for the current OS is automatically loaded
    by File::Spec. Since some modules (like VMS) make use of facilities
    available only under that OS, it may not be possible to load all modules
    under all operating systems.</p>
<p class="Pp">Since File::Spec is object oriented, subroutines should not be
    called directly, as in:</p>
<p class="Pp"></p>
<pre>        File::Spec::catfile('a','b');
</pre>
<p class="Pp">but rather as class methods:</p>
<p class="Pp"></p>
<pre>        File::Spec-&gt;catfile('a','b');
</pre>
<p class="Pp">For simple uses, File::Spec::Functions provides convenient
    functional forms of these methods.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="METHODS"><a class="permalink" href="#METHODS">METHODS</a></h1>
<dl class="Bl-tag">
  <dt id="canonpath"><a class="permalink" href="#canonpath">canonpath</a></dt>
  <dd>No physical check on the filesystem, but a logical cleanup of a path.
    <p class="Pp"></p>
    <pre>    $cpath = File::Spec-&gt;canonpath( $path ) ;
    </pre>
    <p class="Pp">Note that this does *not* collapse <i>x/../y</i> sections into
        <i>y</i>. This is by design. If <i>/foo</i> on your system is a symlink
        to <i>/bar/baz</i>, then <i>/foo/../quux</i> is actually
        <i>/bar/quux</i>, not <i>/quux</i> as a naive <i>../</i>-removal would
        give you. If you want to do this kind of processing, you probably want
        <span class="Li">&quot;Cwd&quot;</span>'s
        <span class="Li">&quot;realpath()&quot;</span> function to actually
        traverse the filesystem cleaning up paths like this.</p>
  </dd>
  <dt id="catdir"><a class="permalink" href="#catdir">catdir</a></dt>
  <dd>Concatenate two or more directory names to form a complete path ending
      with a directory. But remove the trailing slash from the resulting string,
      because it doesn't look good, isn't necessary and confuses OS/2. Of
      course, if this is the root directory, don't cut off the trailing slash
      :-)
    <p class="Pp"></p>
    <pre>    $path = File::Spec-&gt;catdir( @directories );
    </pre>
  </dd>
  <dt id="catfile"><a class="permalink" href="#catfile">catfile</a></dt>
  <dd>Concatenate one or more directory names and a filename to form a complete
      path ending with a filename
    <p class="Pp"></p>
    <pre>    $path = File::Spec-&gt;catfile( @directories, $filename );
    </pre>
  </dd>
  <dt id="curdir"><a class="permalink" href="#curdir">curdir</a></dt>
  <dd>Returns a string representation of the current directory.
    <p class="Pp"></p>
    <pre>    $curdir = File::Spec-&gt;curdir();
    </pre>
  </dd>
  <dt id="devnull"><a class="permalink" href="#devnull">devnull</a></dt>
  <dd>Returns a string representation of the null device.
    <p class="Pp"></p>
    <pre>    $devnull = File::Spec-&gt;devnull();
    </pre>
  </dd>
  <dt id="rootdir"><a class="permalink" href="#rootdir">rootdir</a></dt>
  <dd>Returns a string representation of the root directory.
    <p class="Pp"></p>
    <pre>    $rootdir = File::Spec-&gt;rootdir();
    </pre>
  </dd>
  <dt id="tmpdir"><a class="permalink" href="#tmpdir">tmpdir</a></dt>
  <dd>Returns a string representation of the first writable directory from a
      list of possible temporary directories. Returns the current directory if
      no writable temporary directories are found. The list of directories
      checked depends on the platform; e.g. File::Spec::Unix checks
      <span class="Li">$ENV{TMPDIR}</span> (unless taint is on) and <i>/tmp</i>.
    <p class="Pp"></p>
    <pre>    $tmpdir = File::Spec-&gt;tmpdir();
    </pre>
  </dd>
  <dt id="updir"><a class="permalink" href="#updir">updir</a></dt>
  <dd>Returns a string representation of the parent directory.
    <p class="Pp"></p>
    <pre>    $updir = File::Spec-&gt;updir();
    </pre>
  </dd>
  <dt id="no_upwards"><a class="permalink" href="#no_upwards">no_upwards</a></dt>
  <dd>Given a list of files in a directory (such as from
      <span class="Li">&quot;readdir()&quot;</span>), strip out
      <span class="Li">'.'</span> and <span class="Li">'..'</span>.
    <p class="Pp"><b>SECURITY NOTE:</b> This does NOT filter paths containing
        <span class="Li">'..'</span>, like
        <span class="Li">'../../../../etc/passwd'</span>, only literal matches
        to <span class="Li">'.'</span> and <span class="Li">'..'</span>.</p>
    <p class="Pp"></p>
    <pre>    @paths = File::Spec-&gt;no_upwards( readdir $dirhandle );
    </pre>
  </dd>
  <dt id="case_tolerant"><a class="permalink" href="#case_tolerant">case_tolerant</a></dt>
  <dd>Returns a true or false value indicating, respectively, that alphabetic
      case is not or is significant when comparing file specifications. Cygwin
      and Win32 accept an optional drive argument.
    <p class="Pp"></p>
    <pre>    $is_case_tolerant = File::Spec-&gt;case_tolerant();
    </pre>
  </dd>
  <dt id="file_name_is_absolute"><a class="permalink" href="#file_name_is_absolute">file_name_is_absolute</a></dt>
  <dd>Takes as its argument a path, and returns true if it is an absolute path.
    <p class="Pp"></p>
    <pre>    $is_absolute = File::Spec-&gt;file_name_is_absolute( $path );
    </pre>
    <p class="Pp">This does not consult the local filesystem on Unix, Win32,
        OS/2, or Mac OS (Classic). It does consult the working environment for
        VMS (see &quot;file_name_is_absolute&quot; in File::Spec::VMS).</p>
  </dd>
  <dt id="path"><a class="permalink" href="#path">path</a></dt>
  <dd>Takes no argument. Returns the environment variable
      <span class="Li">&quot;PATH&quot;</span> (or the local platform's
      equivalent) as a list.
    <p class="Pp"></p>
    <pre>    @PATH = File::Spec-&gt;path();
    </pre>
  </dd>
  <dt id="join"><a class="permalink" href="#join">join</a></dt>
  <dd>join is the same as catfile.</dd>
  <dt id="splitpath"><a class="permalink" href="#splitpath">splitpath</a></dt>
  <dd>Splits a path in to volume, directory, and filename portions. On systems
      with no concept of volume, returns '' for volume.
    <p class="Pp"></p>
    <pre>    ($volume,$directories,$file) =
                       File::Spec-&gt;splitpath( $path );
    ($volume,$directories,$file) =
                       File::Spec-&gt;splitpath( $path, $no_file );
    </pre>
    <p class="Pp">For systems with no syntax differentiating filenames from
        directories, assumes that the last file is a path unless
        <span class="Li">$no_file</span> is true or a trailing separator or
        <i>/.</i> or <i>/..</i> is present. On Unix, this means that
        <span class="Li">$no_file</span> true makes this return ( '',
        <span class="Li">$path</span>, '' ).</p>
    <p class="Pp">The directory portion may or may not be returned with a
        trailing '/'.</p>
    <p class="Pp">The results can be passed to &quot;<b>catpath()</b>&quot; to
        get back a path equivalent to (usually identical to) the original
      path.</p>
  </dd>
  <dt id="splitdir"><a class="permalink" href="#splitdir">splitdir</a></dt>
  <dd>The opposite of &quot;catdir&quot;.
    <p class="Pp"></p>
    <pre>    @dirs = File::Spec-&gt;splitdir( $directories );
    </pre>
    <p class="Pp"><span class="Li">$directories</span> must be only the
        directory portion of the path on systems that have the concept of a
        volume or that have path syntax that differentiates files from
        directories.</p>
    <p class="Pp">Unlike just splitting the directories on the separator, empty
        directory names (<span class="Li">''</span>) can be returned, because
        these are significant on some OSes.</p>
  </dd>
  <dt id="catpath()"><a class="permalink" href="#catpath()"><b>catpath()</b></a></dt>
  <dd>Takes volume, directory and file portions and returns an entire path.
      Under Unix, <span class="Li">$volume</span> is ignored, and directory and
      file are concatenated. A '/' is inserted if need be. On other OSes,
      <span class="Li">$volume</span> is significant.
    <p class="Pp"></p>
    <pre>    $full_path = File::Spec-&gt;catpath( $volume, $directory, $file );
    </pre>
  </dd>
  <dt id="abs2rel"><a class="permalink" href="#abs2rel">abs2rel</a></dt>
  <dd>Takes a destination path and an optional base path returns a relative path
      from the base path to the destination path:
    <p class="Pp"></p>
    <pre>    $rel_path = File::Spec-&gt;abs2rel( $path ) ;
    $rel_path = File::Spec-&gt;abs2rel( $path, $base ) ;
    </pre>
    <p class="Pp">If <span class="Li">$base</span> is not present or '', then
        <b>Cwd::cwd()</b> is used. If <span class="Li">$base</span> is relative,
        then it is converted to absolute form using
        &quot;<b>rel2abs()</b>&quot;. This means that it is taken to be relative
        to <b>Cwd::cwd()</b>.</p>
    <p class="Pp">On systems with the concept of volume, if
        <span class="Li">$path</span> and <span class="Li">$base</span> appear
        to be on two different volumes, we will not attempt to resolve the two
        paths, and we will instead simply return <span class="Li">$path</span>.
        Note that previous versions of this module ignored the volume of
        <span class="Li">$base</span>, which resulted in garbage results part of
        the time.</p>
    <p class="Pp">On systems that have a grammar that indicates filenames, this
        ignores the <span class="Li">$base</span> filename as well. Otherwise
        all path components are assumed to be directories.</p>
    <p class="Pp">If <span class="Li">$path</span> is relative, it is converted
        to absolute form using &quot;<b>rel2abs()</b>&quot;. This means that it
        is taken to be relative to <b>Cwd::cwd()</b>.</p>
    <p class="Pp">No checks against the filesystem are made. On VMS, there is
        interaction with the working environment, as logicals and macros are
        expanded.</p>
    <p class="Pp">Based on code written by Shigio Yamaguchi.</p>
  </dd>
  <dt id="rel2abs()"><a class="permalink" href="#rel2abs()"><b>rel2abs()</b></a></dt>
  <dd>Converts a relative path to an absolute path.
    <p class="Pp"></p>
    <pre>    $abs_path = File::Spec-&gt;rel2abs( $path ) ;
    $abs_path = File::Spec-&gt;rel2abs( $path, $base ) ;
    </pre>
    <p class="Pp">If <span class="Li">$base</span> is not present or '', then
        <b>Cwd::cwd()</b> is used. If <span class="Li">$base</span> is relative,
        then it is converted to absolute form using
        &quot;<b>rel2abs()</b>&quot;. This means that it is taken to be relative
        to <b>Cwd::cwd()</b>.</p>
    <p class="Pp">On systems with the concept of volume, if
        <span class="Li">$path</span> and <span class="Li">$base</span> appear
        to be on two different volumes, we will not attempt to resolve the two
        paths, and we will instead simply return <span class="Li">$path</span>.
        Note that previous versions of this module ignored the volume of
        <span class="Li">$base</span>, which resulted in garbage results part of
        the time.</p>
    <p class="Pp">On systems that have a grammar that indicates filenames, this
        ignores the <span class="Li">$base</span> filename as well. Otherwise
        all path components are assumed to be directories.</p>
    <p class="Pp">If <span class="Li">$path</span> is absolute, it is cleaned up
        and returned using &quot;canonpath&quot;.</p>
    <p class="Pp">No checks against the filesystem are made. On VMS, there is
        interaction with the working environment, as logicals and macros are
        expanded.</p>
    <p class="Pp">Based on code written by Shigio Yamaguchi.</p>
  </dd>
</dl>
<p class="Pp">For further information, please see File::Spec::Unix,
    File::Spec::Mac, File::Spec::OS2, File::Spec::Win32, or File::Spec::VMS.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp">File::Spec::Unix, File::Spec::Mac, File::Spec::OS2,
    File::Spec::Win32, File::Spec::VMS, File::Spec::Functions,
    ExtUtils::MakeMaker</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">Currently maintained by Ken Williams
    <span class="Li">&quot;&lt;KWILLIAMS@cpan.org&gt;&quot;</span>.</p>
<p class="Pp">The vast majority of the code was written by Kenneth Albanowski
    <span class="Li">&quot;&lt;kjahds@kjahds.com&gt;&quot;</span>, Andy
    Dougherty
    <span class="Li">&quot;&lt;doughera@lafayette.edu&gt;&quot;</span>, Andreas
    Koenig
    <span class="Li">&quot;&lt;A.Koenig@franz.ww.TU-Berlin.DE&gt;&quot;</span>,
    Tim Bunce <span class="Li">&quot;&lt;Tim.Bunce@ig.co.uk&gt;&quot;</span>.
    VMS support by Charles Bailey
    <span class="Li">&quot;&lt;bailey@newman.upenn.edu&gt;&quot;</span>. OS/2
    support by Ilya Zakharevich
    <span class="Li">&quot;&lt;ilya@math.ohio-state.edu&gt;&quot;</span>. Mac
    support by Paul Schinder
    <span class="Li">&quot;&lt;schinder@pobox.com&gt;&quot;</span>, and Thomas
    Wegner <span class="Li">&quot;&lt;wegner_thomas@yahoo.com&gt;&quot;</span>.
    <b>abs2rel()</b> and <b>rel2abs()</b> written by Shigio Yamaguchi
    <span class="Li">&quot;&lt;shigio@tamacom.com&gt;&quot;</span>, modified by
    Barrie Slaymaker
    <span class="Li">&quot;&lt;barries@slaysys.com&gt;&quot;</span>.
    <b>splitpath()</b>, <b>splitdir()</b>, <b>catpath()</b> and <b>catdir()</b>
    by Barrie Slaymaker.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT"><a class="permalink" href="#COPYRIGHT">COPYRIGHT</a></h1>
<p class="Pp">Copyright (c) 2004-2013 by the Perl 5 Porters. All rights
    reserved.</p>
<p class="Pp">This program is free software; you can redistribute it and/or
    modify it under the same terms as Perl itself.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2021-01-20</td>
    <td class="foot-os">perl v5.34.0</td>
  </tr>
</table>
</body>
</html>
