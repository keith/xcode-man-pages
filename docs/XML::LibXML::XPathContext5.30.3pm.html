<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    .Nd, .Bf, .Op { display: inline; }
    .Pa, .Ad { font-style: italic; }
    .Ms { font-weight: bold; }
    .Bl-diag > dt { font-weight: bold; }
    code.Nm, .Fl, .Cm, .Ic, code.In, .Fd, .Fn, .Cd { font-weight: bold;
      font-family: inherit; }
  </style>
  <title>XML::LibXML::XPathContext(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">XML::LibXML::XPathContext(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">XML::LibXML::XPathContext(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">XML::LibXML::XPathContext - XPath Evaluation</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>  my $xpc = XML::LibXML::XPathContext-&gt;new();
  my $xpc = XML::LibXML::XPathContext-&gt;new($node);
  $xpc-&gt;registerNs($prefix, $namespace_uri)
  $xpc-&gt;unregisterNs($prefix)
  $uri = $xpc-&gt;lookupNs($prefix)
  $xpc-&gt;registerVarLookupFunc($callback, $data)
  $data = $xpc-&gt;getVarLookupData();
  $callback = $xpc-&gt;getVarLookupFunc();
  $xpc-&gt;unregisterVarLookupFunc($name);
  $xpc-&gt;registerFunctionNS($name, $uri, $callback)
  $xpc-&gt;unregisterFunctionNS($name, $uri)
  $xpc-&gt;registerFunction($name, $callback)
  $xpc-&gt;unregisterFunction($name)
  @nodes = $xpc-&gt;findnodes($xpath)
  @nodes = $xpc-&gt;findnodes($xpath, $context_node )
  $nodelist = $xpc-&gt;findnodes($xpath, $context_node )
  $object = $xpc-&gt;find($xpath )
  $object = $xpc-&gt;find($xpath, $context_node )
  $value = $xpc-&gt;findvalue($xpath )
  $value = $xpc-&gt;findvalue($xpath, $context_node )
  $bool = $xpc-&gt;exists( $xpath_expression, $context_node );
  $xpc-&gt;setContextNode($node)
  my $node = $xpc-&gt;getContextNode;
  $xpc-&gt;setContextPosition($position)
  my $position = $xpc-&gt;getContextPosition;
  $xpc-&gt;setContextSize($size)
  my $size = $xpc-&gt;getContextSize;
  $xpc-&gt;setContextNode($node)
The XML::LibXML::XPathContext class provides an almost complete interface to
libxml2's XPath implementation. With XML::LibXML::XPathContext, it is possible
to evaluate XPath expressions in the context of arbitrary node, context size,
and context position, with a user-defined namespace-prefix mapping, custom
XPath functions written in Perl, and even a custom XPath variable resolver.
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="EXAMPLES"><a class="permalink" href="#EXAMPLES">EXAMPLES</a></h1>
<section class="Ss">
<h2 class="Ss" id="Namespaces"><a class="permalink" href="#Namespaces">Namespaces</a></h2>
<p class="Pp">This example demonstrates
    <span class="Li">&quot;registerNs()&quot;</span> method. It finds all
    paragraph nodes in an XHTML document.</p>
<p class="Pp"></p>
<pre>  my $xc = XML::LibXML::XPathContext-&gt;new($xhtml_doc);
  $xc-&gt;registerNs('xhtml', 'http://www.w3.org/1999/xhtml');
  my @nodes = $xc-&gt;findnodes('//xhtml:p');
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Custom_XPath_functions"><a class="permalink" href="#Custom_XPath_functions">Custom
  XPath functions</a></h2>
<p class="Pp">This example demonstrates
    <span class="Li">&quot;registerFunction()&quot;</span> method by defining a
    function filtering nodes based on a Perl regular expression:</p>
<p class="Pp"></p>
<pre>  sub grep_nodes {
    my ($nodelist,$regexp) =  @_;
    my $result = XML::LibXML::NodeList-&gt;new;
    for my $node ($nodelist-&gt;get_nodelist()) {
      $result-&gt;push($node) if $node-&gt;textContent =~ $regexp;
    }
    return $result;
  };
  my $xc = XML::LibXML::XPathContext-&gt;new($node);
  $xc-&gt;registerFunction('grep_nodes', \&amp;grep_nodes);
  my @nodes = $xc-&gt;findnodes('//section[grep_nodes(para,&quot;\bsearch(ing|es)?\b&quot;)]');
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Variables"><a class="permalink" href="#Variables">Variables</a></h2>
<p class="Pp">This example demonstrates
    <span class="Li">&quot;registerVarLookup()&quot;</span> method. We use XPath
    variables to recycle results of previous evaluations:</p>
<p class="Pp"></p>
<pre>  sub var_lookup {
    my ($varname,$ns,$data)=@_;
    return $data-&gt;{$varname};
  }
  my $areas = XML::LibXML-&gt;new-&gt;parse_file('areas.xml');
  my $empl = XML::LibXML-&gt;new-&gt;parse_file('employees.xml');
  my $xc = XML::LibXML::XPathContext-&gt;new($empl);
  my %variables = (
    A =&gt; $xc-&gt;find('/employees/employee[@salary&gt;10000]'),
    B =&gt; $areas-&gt;find('/areas/area[district='Brooklyn']/street'),
  );
  # get names of employees from $A working in an area listed in $B
  $xc-&gt;registerVarLookupFunc(\&amp;var_lookup, \%variables);
  my @nodes = $xc-&gt;findnodes('$A[work_area/street = $B]/name');
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="METHODS"><a class="permalink" href="#METHODS">METHODS</a></h1>
<dl class="Bl-tag">
  <dt id="new"><a class="permalink" href="#new">new</a></dt>
  <dd>
    <pre>  my $xpc = XML::LibXML::XPathContext-&gt;new();
    </pre>
    <p class="Pp">Creates a new XML::LibXML::XPathContext object without a
        context node.</p>
    <p class="Pp"></p>
    <pre>  my $xpc = XML::LibXML::XPathContext-&gt;new($node);
    </pre>
    <p class="Pp">Creates a new XML::LibXML::XPathContext object with the
        context node set to <span class="Li">$node</span>.</p>
  </dd>
  <dt id="registerNs"><a class="permalink" href="#registerNs">registerNs</a></dt>
  <dd>
    <pre>  $xpc-&gt;registerNs($prefix, $namespace_uri)
    </pre>
    <p class="Pp">Registers namespace <span class="Li">$prefix</span> to
        <span class="Li">$namespace_uri</span>.</p>
  </dd>
  <dt id="unregisterNs"><a class="permalink" href="#unregisterNs">unregisterNs</a></dt>
  <dd>
    <pre>  $xpc-&gt;unregisterNs($prefix)
    </pre>
    <p class="Pp">Unregisters namespace <span class="Li">$prefix</span>.</p>
  </dd>
  <dt id="lookupNs"><a class="permalink" href="#lookupNs">lookupNs</a></dt>
  <dd>
    <pre>  $uri = $xpc-&gt;lookupNs($prefix)
    </pre>
    <p class="Pp">Returns namespace URI registered with
        <span class="Li">$prefix</span>. If <span class="Li">$prefix</span> is
        not registered to any namespace URI returns
        <span class="Li">&quot;undef&quot;</span>.</p>
  </dd>
  <dt id="registerVarLookupFunc"><a class="permalink" href="#registerVarLookupFunc">registerVarLookupFunc</a></dt>
  <dd>
    <pre>  $xpc-&gt;registerVarLookupFunc($callback, $data)
    </pre>
    <p class="Pp">Registers variable lookup function
        <span class="Li">$prefix</span>. The registered function is executed by
        the XPath engine each time an XPath variable is evaluated. It takes
        three arguments: <span class="Li">$data</span>, variable name, and
        variable ns-URI and must return one value: a number or string or any
        <span class="Li">&quot;XML::LibXML::&quot;</span> object that can be a
        result of findnodes: Boolean, Literal, Number, Node (e.g. Document,
        Element, etc.), or NodeList. For convenience, simple (non-blessed) array
        references containing only XML::LibXML::Node objects can be used instead
        of an XML::LibXML::NodeList.</p>
  </dd>
  <dt id="getVarLookupData"><a class="permalink" href="#getVarLookupData">getVarLookupData</a></dt>
  <dd>
    <pre>  $data = $xpc-&gt;getVarLookupData();
    </pre>
    <p class="Pp">Returns the data that have been associated with a variable
        lookup function during a previous call to
        <span class="Li">&quot;registerVarLookupFunc&quot;</span>.</p>
  </dd>
  <dt id="getVarLookupFunc"><a class="permalink" href="#getVarLookupFunc">getVarLookupFunc</a></dt>
  <dd>
    <pre>  $callback = $xpc-&gt;getVarLookupFunc();
    </pre>
    <p class="Pp">Returns the variable lookup function previously registered
        with <span class="Li">&quot;registerVarLookupFunc&quot;</span>.</p>
  </dd>
  <dt id="unregisterVarLookupFunc"><a class="permalink" href="#unregisterVarLookupFunc">unregisterVarLookupFunc</a></dt>
  <dd>
    <pre>  $xpc-&gt;unregisterVarLookupFunc($name);
    </pre>
    <p class="Pp">Unregisters variable lookup function and the associated lookup
        data.</p>
  </dd>
  <dt id="registerFunctionNS"><a class="permalink" href="#registerFunctionNS">registerFunctionNS</a></dt>
  <dd>
    <pre>  $xpc-&gt;registerFunctionNS($name, $uri, $callback)
    </pre>
    <p class="Pp">Registers an extension function <span class="Li">$name</span>
        in <span class="Li">$uri</span> namespace.
        <span class="Li">$callback</span> must be a CODE reference. The
        arguments of the callback function are either simple scalars or
        <span class="Li">&quot;XML::LibXML::*&quot;</span> objects depending on
        the XPath argument types. The function is responsible for checking the
        argument number and types. Result of the callback code must be a single
        value of the following types: a simple scalar (number, string) or an
        arbitrary <span class="Li">&quot;XML::LibXML::*&quot;</span> object that
        can be a result of findnodes: Boolean, Literal, Number, Node (e.g.
        Document, Element, etc.), or NodeList. For convenience, simple
        (non-blessed) array references containing only XML::LibXML::Node objects
        can be used instead of a XML::LibXML::NodeList.</p>
  </dd>
  <dt id="unregisterFunctionNS"><a class="permalink" href="#unregisterFunctionNS">unregisterFunctionNS</a></dt>
  <dd>
    <pre>  $xpc-&gt;unregisterFunctionNS($name, $uri)
    </pre>
    <p class="Pp">Unregisters extension function <span class="Li">$name</span>
        in <span class="Li">$uri</span> namespace. Has the same effect as
        passing <span class="Li">&quot;undef&quot;</span> as
        <span class="Li">$callback</span> to registerFunctionNS.</p>
  </dd>
  <dt id="registerFunction"><a class="permalink" href="#registerFunction">registerFunction</a></dt>
  <dd>
    <pre>  $xpc-&gt;registerFunction($name, $callback)
    </pre>
    <p class="Pp">Same as <span class="Li">&quot;registerFunctionNS&quot;</span>
        but without a namespace.</p>
  </dd>
  <dt id="unregisterFunction"><a class="permalink" href="#unregisterFunction">unregisterFunction</a></dt>
  <dd>
    <pre>  $xpc-&gt;unregisterFunction($name)
    </pre>
    <p class="Pp">Same as
        <span class="Li">&quot;unregisterFunctionNS&quot;</span> but without a
        namespace.</p>
  </dd>
  <dt id="findnodes"><a class="permalink" href="#findnodes">findnodes</a></dt>
  <dd>
    <pre>  @nodes = $xpc-&gt;findnodes($xpath)
  @nodes = $xpc-&gt;findnodes($xpath, $context_node )
  $nodelist = $xpc-&gt;findnodes($xpath, $context_node )
    </pre>
    <p class="Pp">Performs the xpath statement on the current node and returns
        the result as an array. In scalar context, returns an
        XML::LibXML::NodeList object. Optionally, a node may be passed as a
        second argument to set the context node for the query.</p>
    <p class="Pp">The xpath expression can be passed either as a string, or as a
        XML::LibXML::XPathExpression object.</p>
  </dd>
  <dt id="find"><a class="permalink" href="#find">find</a></dt>
  <dd>
    <pre>  $object = $xpc-&gt;find($xpath )
  $object = $xpc-&gt;find($xpath, $context_node )
    </pre>
    <p class="Pp">Performs the xpath expression using the current node as the
        context of the expression, and returns the result depending on what type
        of result the XPath expression had. For example, the XPath
        <span class="Li">&quot;1 * 3 + 	 52&quot;</span> results in an
        XML::LibXML::Number object being returned. Other expressions might
        return a XML::LibXML::Boolean object, or a XML::LibXML::Literal object
        (a string). Each of those objects uses Perl's overload feature to ``do
        the right thing'' in different contexts. Optionally, a node may be
        passed as a second argument to set the context node for the query.</p>
    <p class="Pp">The xpath expression can be passed either as a string, or as a
        XML::LibXML::XPathExpression object.</p>
  </dd>
  <dt id="findvalue"><a class="permalink" href="#findvalue">findvalue</a></dt>
  <dd>
    <pre>  $value = $xpc-&gt;findvalue($xpath )
  $value = $xpc-&gt;findvalue($xpath, $context_node )
    </pre>
    <p class="Pp">Is exactly equivalent to:</p>
    <p class="Pp"></p>
    <pre>  $xpc-&gt;find( $xpath, $context_node )-&gt;to_literal;
    </pre>
    <p class="Pp">That is, it returns the literal value of the results. This
        enables you to ensure that you get a string back from your search,
        allowing certain shortcuts. This could be used as the equivalent of
        &lt;xsl:value-of select=``some_xpath''/&gt;. Optionally, a node may be
        passed in the second argument to set the context node for the query.</p>
    <p class="Pp">The xpath expression can be passed either as a string, or as a
        XML::LibXML::XPathExpression object.</p>
  </dd>
  <dt id="exists"><a class="permalink" href="#exists">exists</a></dt>
  <dd>
    <pre>  $bool = $xpc-&gt;exists( $xpath_expression, $context_node );
    </pre>
    <p class="Pp">This method behaves like <i>findnodes</i>, except that it only
        returns a boolean value (1 if the expression matches a node, 0
        otherwise) and may be faster than <i>findnodes</i>, because the XPath
        evaluation may stop early on the first match (this is true for libxml2
        &gt;= 2.6.27).</p>
    <p class="Pp">For XPath expressions that do not return node-set, the method
        returns true if the returned value is a non-zero number or a non-empty
        string.</p>
  </dd>
  <dt id="setContextNode"><a class="permalink" href="#setContextNode">setContextNode</a></dt>
  <dd>
    <pre>  $xpc-&gt;setContextNode($node)
    </pre>
    <p class="Pp">Set the current context node.</p>
  </dd>
  <dt id="getContextNode"><a class="permalink" href="#getContextNode">getContextNode</a></dt>
  <dd>
    <pre>  my $node = $xpc-&gt;getContextNode;
    </pre>
    <p class="Pp">Get the current context node.</p>
  </dd>
  <dt id="setContextPosition"><a class="permalink" href="#setContextPosition">setContextPosition</a></dt>
  <dd>
    <pre>  $xpc-&gt;setContextPosition($position)
    </pre>
    <p class="Pp">Set the current context position. By default, this value is -1
        (and evaluating XPath function
        <span class="Li">&quot;position()&quot;</span> in the initial context
        raises an XPath error), but can be set to any value up to context size.
        This usually only serves to cheat the XPath engine to return given
        position when <span class="Li">&quot;position()&quot;</span> XPath
        function is called. Setting this value to -1 restores the default
        behavior.</p>
  </dd>
  <dt id="getContextPosition"><a class="permalink" href="#getContextPosition">getContextPosition</a></dt>
  <dd>
    <pre>  my $position = $xpc-&gt;getContextPosition;
    </pre>
    <p class="Pp">Get the current context position.</p>
  </dd>
  <dt id="setContextSize"><a class="permalink" href="#setContextSize">setContextSize</a></dt>
  <dd>
    <pre>  $xpc-&gt;setContextSize($size)
    </pre>
    <p class="Pp">Set the current context size. By default, this value is -1
        (and evaluating XPath function
        <span class="Li">&quot;last()&quot;</span> in the initial context raises
        an XPath error), but can be set to any non-negative value. This usually
        only serves to cheat the XPath engine to return the given value when
        <span class="Li">&quot;last()&quot;</span> XPath function is called. If
        context size is set to 0, position is automatically also set to 0. If
        context size is positive, position is automatically set to 1. Setting
        context size to -1 restores the default behavior.</p>
  </dd>
  <dt id="getContextSize"><a class="permalink" href="#getContextSize">getContextSize</a></dt>
  <dd>
    <pre>  my $size = $xpc-&gt;getContextSize;
    </pre>
    <p class="Pp">Get the current context size.</p>
  </dd>
  <dt id="setContextNode~2"><a class="permalink" href="#setContextNode~2">setContextNode</a></dt>
  <dd>
    <pre>  $xpc-&gt;setContextNode($node)
    </pre>
    <p class="Pp">Set the current context node.</p>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="BUGS_AND_CAVEATS"><a class="permalink" href="#BUGS_AND_CAVEATS">BUGS
  AND CAVEATS</a></h1>
<p class="Pp">XML::LibXML::XPathContext objects <i>are</i> reentrant, meaning
    that you can call methods of an XML::LibXML::XPathContext even from XPath
    extension functions registered with the same object or from a variable
    lookup function. On the other hand, you should rather avoid registering new
    extension functions, namespaces and a variable lookup function from within
    extension functions and a variable lookup function, unless you want to
    experience untested behavior.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHORS"><a class="permalink" href="#AUTHORS">AUTHORS</a></h1>
<p class="Pp">Ilya Martynov and Petr Pajas, based on XML::LibXML and
    XML::LibXSLT code by Matt Sergeant and Christian Glahn.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="HISTORICAL_REMARK"><a class="permalink" href="#HISTORICAL_REMARK">HISTORICAL
  REMARK</a></h1>
<p class="Pp">Prior to XML::LibXML 1.61 this module was distributed separately
    for maintenance reasons.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHORS~2"><a class="permalink" href="#AUTHORS~2">AUTHORS</a></h1>
<p class="Pp">Matt Sergeant, Christian Glahn, Petr Pajas</p>
</section>
<section class="Sh">
<h1 class="Sh" id="VERSION"><a class="permalink" href="#VERSION">VERSION</a></h1>
<p class="Pp">2.0110</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT"><a class="permalink" href="#COPYRIGHT">COPYRIGHT</a></h1>
<p class="Pp">2001-2007, AxKit.com Ltd.</p>
<p class="Pp">2002-2006, Christian Glahn.</p>
<p class="Pp">2006-2009, Petr Pajas.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="LICENSE"><a class="permalink" href="#LICENSE">LICENSE</a></h1>
<p class="Pp">This program is free software; you can redistribute it and/or
    modify it under the same terms as Perl itself.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2014-02-01</td>
    <td class="foot-os">perl v5.30.2</td>
  </tr>
</table>
</body>
</html>
