<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>TNEF(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">TNEF(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">TNEF(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<span class="Li"></span>
<pre>
 Convert::TNEF - Perl module to read TNEF files
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<span class="Li"></span>
<pre>
 use Convert::TNEF;

 $tnef = Convert::TNEF-&gt;read($iohandle, \%parms)
  or die Convert::TNEF::errstr;

 $tnef = Convert::TNEF-&gt;read_in($filename, \%parms)
  or die Convert::TNEF::errstr;

 $tnef = Convert::TNEF-&gt;read_ent($mime_entity, \%parms)
  or die Convert::TNEF::errstr;

 $tnef-&gt;purge;

 $message = $tnef-&gt;message;

 @attachments = $tnef-&gt;attachments;

 $attribute_value      = $attachments[$i]-&gt;data($att_attribute_name);
 $attribute_value_size = $attachments[$i]-&gt;size($att_attribute_name);
 $attachment_name = $attachments[$i]-&gt;name;
 $long_attachment_name = $attachments[$i]-&gt;longname;

 $datahandle = $attachments[$i]-&gt;datahandle($att_attribute_name);
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<span class="Li"></span>
<pre>
 TNEF stands for Transport Neutral Encapsulation Format, and if you've
 ever been unfortunate enough to receive one of these files as an email
 attachment, you may want to use this module.

 read() takes as its first argument any file handle open
 for reading. The optional second argument is a hash reference
 which contains one or more of the following keys:
</pre>
<section class="Ss">
<h2 class="Ss">
</h2>
<span class="Li"></span>
<pre>
 output_dir - Path for storing TNEF attribute data kept in files
 (default: current directory).

 output_prefix - File prefix for TNEF attribute data kept in files
 (default: 'tnef').

 output_to_core - TNEF attribute data will be saved in core memory unless
 it is greater than this many bytes (default: 4096). May also be set to
 'NONE' to keep all data in files, or 'ALL' to keep all data in core.

 buffer_size - Buffer size for reading in the TNEF file (default: 1024).

 debug - If true, outputs all sorts of info about what the read() function
 is reading, including the raw ascii data along with the data converted
 to hex (default: false).

 display_after_err - If debug is true and an error is encountered,
 reads and displays this many bytes of data following the error
 (default: 32).

 debug_max_display - If debug is true then read and display at most
 this many bytes of data for each TNEF attribute (default: 1024).

 debug_max_line_size - If debug is true then at most this many bytes of
 data will be displayed on each line for each TNEF attribute
 (default: 64).

 ignore_checksum - If true, will ignore checksum errors while parsing
 data (default: false).

 read() returns an object containing the TNEF 'attributes' read from the
 file and the data for those attributes. If all you want are the
 attachments, then this is mostly garbage, but if you're interested then
 you can see all the garbage by turning on debugging. If the garbage
 proves useful to you, then let me know how I can maybe make it more
 useful.

 If an error is encountered, an undefined value is returned and the
 package variable $errstr is set to some helpful message.

 read_in() is a convienient front end for read() which takes a filename
 instead of a handle.

 read_ent() is another convient front end for read() which can take a
 MIME::Entity object (or any object with like methods, specifically
 open(&quot;r&quot;), read($buff,$num_bytes), and close ).

 purge() deletes any on-disk data that may be in the attachments of
 the TNEF object.

 message() returns the message portion of the tnef object, if any.
 The thing it returns is like an attachment, but its not an attachment.
 For instance, it more than likely does not have a name or any
 attachment data.

 attachments() returns a list of the attachments that the given TNEF
 object contains. Returns a list ref if not called in array context.

 data() takes a TNEF attribute name, and returns a string value for that 
 attribute for that attachment. Its your own problem if the string is too
 big for memory. If no argument is given, then the 'AttachData' attribute
 is assumed, which is probably the attachment data you're looking for.

 name() is the same as data(), except the attribute 'AttachTitle' is
 the default, which returns the 8 character + 3 character extension name
 of the attachment.

 longname() returns the long filename and extension of an attachment. This
 is embedded within a MAPI property of the 'Attachment' attribute data, so
 we attempt to extract the name out of that.

 size() takes an TNEF attribute name, and returns the size in bytes for
 the data for that attachment attribute.

 datahandle() is a method for attachments which takes a TNEF attribute
 name, and returns the data for that attribute as a handle which is
 the same as a MIME::Body handle.  See MIME::Body for all the applicable
 methods. If no argument is given, then 'AttachData' is assumed.
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="EXAMPLES"><a class="permalink" href="#EXAMPLES">EXAMPLES</a></h1>
<span class="Li"></span>
<pre>
 # Here's a rather long example where mail is retrieved
 # from a POP3 server based on header information, then
 # it is MIME parsed, and then the TNEF contents
 # are extracted and converted.

 use strict;
 use Net::POP3;
 use MIME::Parser;
 use Convert::TNEF;

 my $mail_dir = &quot;mailout&quot;;
 my $mail_prefix = &quot;mail&quot;;

 my $pop = new Net::POP3 ( &quot;pop3server_name&quot; );
 my $num_msgs = $pop-&gt;login(&quot;user_name&quot;,&quot;password&quot;);
 die &quot;Can't login: $!&quot; unless defined $num_msgs;

 # Get mail by sender and subject
 my $mail_out_idx = 0;
 MESSAGE: for ( my $i=1; $i&lt;= $num_msgs;  $i++ ) {
  my $header = join &quot;&quot;, @{$pop-&gt;top($i)};

  for ($header) {
   next MESSAGE unless
    /^from:.*someone\@somewhere.net/im &amp;&amp;
    /^subject:\s*important stuff/im
  }

  my $fname = $mail_prefix.&quot;-&quot;.$$.++$mail_out_idx.&quot;.doc&quot;;
  open (MAILOUT, &quot;&gt;$mail_dir/$fname&quot;)
   or die &quot;Can't open $mail_dir/$fname: $!&quot;;
  # If the get() complains, you need the new libnet bundle
  $pop-&gt;get($i, \*MAILOUT) or die &quot;Can't read mail&quot;;
  close MAILOUT or die &quot;Error closing $mail_dir/$fname&quot;;
  # If you want to delete the mail on the server
  # $pop-&gt;delete($i);
 }

 close MAILOUT;
 $pop-&gt;quit();

 # Parse the mail message into separate mime entities
 my $parser=new MIME::Parser;
 $parser-&gt;output_dir(&quot;mimemail&quot;);

 opendir(DIR, $mail_dir) or die &quot;Can't open directory $mail_dir: $!&quot;;
 my @files = map { $mail_dir.&quot;/&quot;.$_ } sort
  grep { -f &quot;$mail_dir/$_&quot; and /$mail_prefix-$$-/o } readdir DIR;
 closedir DIR;

 for my $file ( @files ) {
  my $entity=$parser-&gt;parse_in($file) or die &quot;Couldn't parse mail&quot;;
  print_tnef_parts($entity);
  # If you want to delete the working files
  # $entity-&gt;purge;
 }

 sub print_tnef_parts {
  my $ent = shift;

  if ( $ent-&gt;parts ) {
   for my $sub_ent ( $ent-&gt;parts ) {
    print_tnef_parts($sub_ent);
   }
  } elsif ( $ent-&gt;mime_type =~ /ms-tnef/i ) {

   # Create a tnef object
   my $tnef = Convert::TNEF-&gt;read_ent($ent,{output_dir=&gt;&quot;tnefmail&quot;})
    or die $Convert::TNEF::errstr;
   for ($tnef-&gt;attachments) {
    print &quot;Title:&quot;,$_-&gt;name,&quot;\n&quot;;
    print &quot;Data:\n&quot;,$_-&gt;data,&quot;\n&quot;;
   }

   # If you want to delete the working files
   # $tnef-&gt;purge;
  }
 }
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<b>perl</b>(1), <b>IO::Wrap</b>(3), <b>MIME::Parser</b>(3),
  <b>MIME::Entity</b>(3), <b>MIME::Body</b>(3)
</section>
<section class="Sh">
<h1 class="Sh" id="CAVEATS"><a class="permalink" href="#CAVEATS">CAVEATS</a></h1>
<span class="Li"></span>
<pre>
 The parsing may depend on the endianness (see perlport) and width of
 integers on the system where the TNEF file was created. If this proves
 to be the case (check the debug output), I'll see what I can do
 about it.
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<span class="Li"></span>
<pre>
 Douglas Wilson, dougw@cpan.org
</pre>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2012-07-23</td>
    <td class="foot-os">perl v5.30.2</td>
  </tr>
</table>
</body>
</html>
