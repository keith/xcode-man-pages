<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>Archive::Tar(3pm)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Archive::Tar(3pm)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">Archive::Tar(3pm)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
Archive::Tar - module for manipulations of tar archives
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<span class="Li"></span>
<pre>
    use Archive::Tar;
    my $tar = Archive::Tar-&gt;new;

    $tar-&gt;read('origin.tgz');
    $tar-&gt;extract();

    $tar-&gt;add_files('file/foo.pl', 'docs/README');
    $tar-&gt;add_data('file/baz.txt', 'This is the contents now');

    $tar-&gt;rename('oldname', 'new/file/name');
    $tar-&gt;chown('/', 'root');
    $tar-&gt;chown('/', 'root:root');
    $tar-&gt;chmod('/tmp', '1777');

    $tar-&gt;write('files.tar');                   # plain tar
    $tar-&gt;write('files.tgz', COMPRESS_GZIP);    # gzip compressed
    $tar-&gt;write('files.tbz', COMPRESS_BZIP);    # bzip2 compressed
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
Archive::Tar provides an object oriented mechanism for handling tar files. It
  provides class methods for quick and easy files handling while also allowing
  for the creation of tar file objects for custom manipulation. If you have the
  IO::Zlib module installed, Archive::Tar will also support compressed or
  gzipped tar files.
<p class="Pp">An object of class Archive::Tar represents a .tar(.gz) archive
    full of files and things.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="Object_Methods"><a class="permalink" href="#Object_Methods">Object
  Methods</a></h1>
<section class="Ss">
<h2 class="Ss" id="Archive::Tar_-_new(__$file,_$compressed__)"><a class="permalink" href="#Archive::Tar_-_new(__$file,_$compressed__)">Archive::Tar-&gt;new(
  [$file, $compressed] )</a></h2>
Returns a new Tar object. If given any arguments,
  <span class="Li">&quot;new()&quot;</span> calls the
  <span class="Li">&quot;read()&quot;</span> method automatically, passing on
  the arguments provided to the <span class="Li">&quot;read()&quot;</span>
  method.
<p class="Pp">If <span class="Li">&quot;new()&quot;</span> is invoked with
    arguments and the <span class="Li">&quot;read()&quot;</span> method fails
    for any reason, <span class="Li">&quot;new()&quot;</span> returns undef.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="$tar_-_read_(_$filename_$handle,__$compressed,__opt_=__'val'___)"><a class="permalink" href="#$tar_-_read_(_$filename_$handle,__$compressed,__opt_=__'val'___)">$tar-&gt;read
  ( $filename|$handle, [$compressed, {opt =&gt; 'val'}] )</a></h2>
Read the given tar file into memory. The first argument can either be the name
  of a file or a reference to an already open filehandle (or an IO::Zlib object
  if it's compressed)
<p class="Pp">The <span class="Li">&quot;read&quot;</span> will <i>replace</i>
    any previous content in <span class="Li">$tar</span>!</p>
<p class="Pp">The second argument may be considered optional, but remains for
    backwards compatibility. Archive::Tar now looks at the file magic to
    determine what class should be used to open the file and will transparently
    Do The Right Thing.</p>
<p class="Pp">Archive::Tar will warn if you try to pass a bzip2 compressed file
    and the IO::Zlib / IO::Uncompress::Bunzip2 modules are not available and
    simply return.</p>
<p class="Pp">Note that you can currently <b>not</b> pass a
    <span class="Li">&quot;gzip&quot;</span> compressed filehandle, which is not
    opened with <span class="Li">&quot;IO::Zlib&quot;</span>, a
    <span class="Li">&quot;bzip2&quot;</span> compressed filehandle, which is
    not opened with <span class="Li">&quot;IO::Uncompress::Bunzip2&quot;</span>,
    nor a string containing the full archive information (either compressed or
    uncompressed). These are worth while features, but not currently
    implemented. See the <span class="Li">&quot;TODO&quot;</span> section.</p>
<p class="Pp">The third argument can be a hash reference with options. Note that
    all options are case-sensitive.</p>
<dl class="Bl-tag">
  <dt>limit</dt>
  <dd>Do not read more than <span class="Li">&quot;limit&quot;</span> files.
      This is useful if you have very big archives, and are only interested in
      the first few files.</dd>
  <dt>filter</dt>
  <dd>Can be set to a regular expression. Only files with names that match the
      expression will be read.</dd>
  <dt>md5</dt>
  <dd>Set to 1 and the md5sum of files will be returned (instead of file data)
     my <span class="Li">$iter</span> = Archive::Tar-&gt;iter(
      <span class="Li">$file</span>, 1, {md5 =&gt; 1} );
     while( my <span class="Li">$f</span> = <span class="Li">$iter</span>-&gt;()
      ) {
     print <span class="Li">$f</span>-&gt;data . &quot;\t&quot; .
      <span class="Li">$f</span>-&gt;full_path . $/;
     }</dd>
  <dt>extract</dt>
  <dd>If set to true, immediately extract entries when reading them. This gives
      you the same memory break as the
      <span class="Li">&quot;extract_archive&quot;</span> function. Note however
      that entries will not be read into memory, but written straight to disk.
      This means no <span class="Li">&quot;Archive::Tar::File&quot;</span>
      objects are created for you to inspect.</dd>
</dl>
<p class="Pp">All files are stored internally as
    <span class="Li">&quot;Archive::Tar::File&quot;</span> objects. Please
    consult the Archive::Tar::File documentation for details.</p>
<p class="Pp">Returns the number of files read in scalar context, and a list of
    <span class="Li">&quot;Archive::Tar::File&quot;</span> objects in list
    context.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="$tar_-_contains_file(_$filename_)"><a class="permalink" href="#$tar_-_contains_file(_$filename_)">$tar-&gt;contains_file(
  $filename )</a></h2>
Check if the archive contains a certain file. It will return true if the file is
  in the archive, false otherwise.
<p class="Pp">Note however, that this function does an exact match using
    <span class="Li">&quot;eq&quot;</span> on the full path. So it cannot
    compensate for case-insensitive file- systems or compare 2 paths to see if
    they would point to the same underlying file.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="$tar_-_extract(__@filenames__)"><a class="permalink" href="#$tar_-_extract(__@filenames__)">$tar-&gt;extract(
  [@filenames] )</a></h2>
Write files whose names are equivalent to any of the names in
  <span class="Li">@filenames</span> to disk, creating subdirectories as
  necessary. This might not work too well under VMS. Under MacPerl, the file's
  modification time will be converted to the MacOS zero of time, and appropriate
  conversions will be done to the path. However, the length of each element of
  the path is not inspected to see whether it's longer than MacOS currently
  allows (32 characters).
<p class="Pp">If <span class="Li">&quot;extract&quot;</span> is called without a
    list of file names, the entire contents of the archive are extracted.</p>
<p class="Pp">Returns a list of filenames extracted.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="$tar_-_extract_file(_$file,__$extract_path__)"><a class="permalink" href="#$tar_-_extract_file(_$file,__$extract_path__)">$tar-&gt;extract_file(
  $file, [$extract_path] )</a></h2>
Write an entry, whose name is equivalent to the file name provided to disk.
  Optionally takes a second parameter, which is the full native path (including
  filename) the entry will be written to.
<p class="Pp">For example:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    $tar-&gt;extract_file( 'name/in/archive', 'name/i/want/to/give/it' );

    $tar-&gt;extract_file( $at_file_object,   'name/i/want/to/give/it' );
</pre>
<p class="Pp">Returns true on success, false on failure.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="$tar_-_list_files(___e@properties__)"><a class="permalink" href="#$tar_-_list_files(___e@properties__)">$tar-&gt;list_files(
  [\@properties] )</a></h2>
Returns a list of the names of all the files in the archive.
<p class="Pp">If <span class="Li">&quot;list_files()&quot;</span> is passed an
    array reference as its first argument it returns a list of hash references
    containing the requested properties of each file. The following list of
    properties is supported: name, size, mtime (last modified date), mode, uid,
    gid, linkname, uname, gname, devmajor, devminor, prefix.</p>
<p class="Pp">Passing an array reference containing only one element, 'name', is
    special cased to return a list of names rather than a list of hash
    references, making it equivalent to calling
    <span class="Li">&quot;list_files&quot;</span> without arguments.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="$tar_-_get_files(__@filenames__)"><a class="permalink" href="#$tar_-_get_files(__@filenames__)">$tar-&gt;get_files(
  [@filenames] )</a></h2>
Returns the <span class="Li">&quot;Archive::Tar::File&quot;</span> objects
  matching the filenames provided. If no filename list was passed, all
  <span class="Li">&quot;Archive::Tar::File&quot;</span> objects in the current
  Tar object are returned.
<p class="Pp">Please refer to the
    <span class="Li">&quot;Archive::Tar::File&quot;</span> documentation on how
    to handle these objects.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="$tar_-_get_content(_$file_)"><a class="permalink" href="#$tar_-_get_content(_$file_)">$tar-&gt;get_content(
  $file )</a></h2>
Return the content of the named file.
</section>
<section class="Ss">
<h2 class="Ss" id="$tar_-_replace_content(_$file,_$content_)"><a class="permalink" href="#$tar_-_replace_content(_$file,_$content_)">$tar-&gt;replace_content(
  $file, $content )</a></h2>
Make the string <span class="Li">$content</span> be the content for the file
  named <span class="Li">$file</span>.
</section>
<section class="Ss">
<h2 class="Ss" id="$tar_-_rename(_$file,_$new_name_)"><a class="permalink" href="#$tar_-_rename(_$file,_$new_name_)">$tar-&gt;rename(
  $file, $new_name )</a></h2>
Rename the file of the in-memory archive to <span class="Li">$new_name</span>.
<p class="Pp">Note that you must specify a Unix path for
    <span class="Li">$new_name</span>, since per tar standard, all files in the
    archive must be Unix paths.</p>
<p class="Pp">Returns true on success and false on failure.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="$tar_-_chmod(_$file,_$mode_)"><a class="permalink" href="#$tar_-_chmod(_$file,_$mode_)">$tar-&gt;chmod(
  $file, $mode )</a></h2>
Change mode of <span class="Li">$file</span> to <span class="Li">$mode</span>.
<p class="Pp">Returns true on success and false on failure.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="$tar_-_chown(_$file,_$uname__,_$gname__)"><a class="permalink" href="#$tar_-_chown(_$file,_$uname__,_$gname__)">$tar-&gt;chown(
  $file, $uname [, $gname] )</a></h2>
Change owner <span class="Li">$file</span> to <span class="Li">$uname</span> and
  <span class="Li">$gname</span>.
<p class="Pp">Returns true on success and false on failure.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="$tar_-_remove_(@filenamelist)"><a class="permalink" href="#$tar_-_remove_(@filenamelist)">$tar-&gt;remove
  (@filenamelist)</a></h2>
Removes any entries with names matching any of the given filenames from the
  in-memory archive. Returns a list of
  <span class="Li">&quot;Archive::Tar::File&quot;</span> objects that remain.
</section>
<section class="Ss">
<h2 class="Ss" id="$tar_-_clear"><a class="permalink" href="#$tar_-_clear">$tar-&gt;clear</a></h2>
<span class="Li">&quot;clear&quot;</span> clears the current in-memory archive.
  This effectively gives you a 'blank' object, ready to be filled again. Note
  that <span class="Li">&quot;clear&quot;</span> only has effect on the object,
  not the underlying tarfile.
</section>
<section class="Ss">
<h2 class="Ss" id="$tar_-_write_(__$file,_$compressed,_$prefix__)"><a class="permalink" href="#$tar_-_write_(__$file,_$compressed,_$prefix__)">$tar-&gt;write
  ( [$file, $compressed, $prefix] )</a></h2>
Write the in-memory archive to disk. The first argument can either be the name
  of a file or a reference to an already open filehandle (a GLOB reference).
<p class="Pp">The second argument is used to indicate compression. You can
    either compress using <span class="Li">&quot;gzip&quot;</span> or
    <span class="Li">&quot;bzip2&quot;</span>. If you pass a digit, it's assumed
    to be the <span class="Li">&quot;gzip&quot;</span> compression level
    (between 1 and 9), but the use of constants is preferred:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  # write a gzip compressed file
  $tar-&gt;write( 'out.tgz', COMPRESS_GZIP );

  # write a bzip compressed file
  $tar-&gt;write( 'out.tbz', COMPRESS_BZIP );
</pre>
<p class="Pp">Note that when you pass in a filehandle, the compression argument
    is ignored, as all files are printed verbatim to your filehandle. If you
    wish to enable compression with filehandles, use an
    <span class="Li">&quot;IO::Zlib&quot;</span> or
    <span class="Li">&quot;IO::Compress::Bzip2&quot;</span> filehandle
  instead.</p>
<p class="Pp">The third argument is an optional prefix. All files will be tucked
    away in the directory you specify as prefix. So if you have files 'a' and
    'b' in your archive, and you specify 'foo' as prefix, they will be written
    to the archive as 'foo/a' and 'foo/b'.</p>
<p class="Pp">If no arguments are given,
    <span class="Li">&quot;write&quot;</span> returns the entire formatted
    archive as a string, which could be useful if you'd like to stuff the
    archive into a socket or a pipe to gzip or something.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="$tar_-_add_files(_@filenamelist_)"><a class="permalink" href="#$tar_-_add_files(_@filenamelist_)">$tar-&gt;add_files(
  @filenamelist )</a></h2>
Takes a list of filenames and adds them to the in-memory archive.
<p class="Pp">The path to the file is automatically converted to a Unix like
    equivalent for use in the archive, and, if on MacOS, the file's modification
    time is converted from the MacOS epoch to the Unix epoch. So tar archives
    created on MacOS with <b>Archive::Tar</b> can be read both with <i>tar</i>
    on Unix and applications like <i>suntar</i> or <i>Stuffit Expander</i> on
    MacOS.</p>
<p class="Pp">Be aware that the file's type/creator and resource fork will be
    lost, which is usually what you want in cross-platform archives.</p>
<p class="Pp">Instead of a filename, you can also pass it an existing
    <span class="Li">&quot;Archive::Tar::File&quot;</span> object from, for
    example, another archive. The object will be clone, and effectively be a
    copy of the original, not an alias.</p>
<p class="Pp">Returns a list of
    <span class="Li">&quot;Archive::Tar::File&quot;</span> objects that were
    just added.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="$tar_-_add_data_(_$filename,_$data,__$opthashref__)"><a class="permalink" href="#$tar_-_add_data_(_$filename,_$data,__$opthashref__)">$tar-&gt;add_data
  ( $filename, $data, [$opthashref] )</a></h2>
Takes a filename, a scalar full of data and optionally a reference to a hash
  with specific options.
<p class="Pp">Will add a file to the in-memory archive, with name
    <span class="Li">$filename</span> and content <span class="Li">$data</span>.
    Specific properties can be set using <span class="Li">$opthashref</span>.
    The following list of properties is supported: name, size, mtime (last
    modified date), mode, uid, gid, linkname, uname, gname, devmajor, devminor,
    prefix, type. (On MacOS, the file's path and modification times are
    converted to Unix equivalents.)</p>
<p class="Pp">Valid values for the file type are the following constants defined
    by Archive::Tar::Constant:</p>
<dl class="Bl-tag">
  <dt>FILE</dt>
  <dd>Regular file.</dd>
  <dt>HARDLINK</dt>
  <dd></dd>
  <dt>SYMLINK</dt>
  <dd>Hard and symbolic (&quot;soft&quot;) links; linkname should specify
      target.</dd>
  <dt>CHARDEV</dt>
  <dd></dd>
  <dt>BLOCKDEV</dt>
  <dd>Character and block devices. devmajor and devminor should specify the
      major and minor device numbers.</dd>
  <dt>DIR</dt>
  <dd>Directory.</dd>
  <dt>FIFO</dt>
  <dd>FIFO (named pipe).</dd>
  <dt>SOCKET</dt>
  <dd>Socket.</dd>
</dl>
<p class="Pp">Returns the <span class="Li">&quot;Archive::Tar::File&quot;</span>
    object that was just added, or <span class="Li">&quot;undef&quot;</span> on
    failure.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="$tar_-_error(__$BOOL__)"><a class="permalink" href="#$tar_-_error(__$BOOL__)">$tar-&gt;error(
  [$BOOL] )</a></h2>
Returns the current errorstring (usually, the last error reported). If a true
  value was specified, it will give the
  <span class="Li">&quot;Carp::longmess&quot;</span> equivalent of the error, in
  effect giving you a stacktrace.
<p class="Pp">For backwards compatibility, this error is also available as
    <span class="Li">$Archive::Tar::error</span> although it is much recommended
    you use the method call instead.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="$tar_-_setcwd(_$cwd_);"><a class="permalink" href="#$tar_-_setcwd(_$cwd_);">$tar-&gt;setcwd(
  $cwd );</a></h2>
<span class="Li">&quot;Archive::Tar&quot;</span> needs to know the current
  directory, and it will run <span class="Li">&quot;Cwd::cwd()&quot;</span>
  <i>every</i> time it extracts a <i>relative</i> entry from the tarfile and
  saves it in the file system. (As of version 1.30, however,
  <span class="Li">&quot;Archive::Tar&quot;</span> will use the speed
  optimization described below automatically, so it's only relevant if you're
  using <span class="Li">&quot;extract_file()&quot;</span>).
<p class="Pp">Since <span class="Li">&quot;Archive::Tar&quot;</span> doesn't
    change the current directory internally while it is extracting the items in
    a tarball, all calls to <span class="Li">&quot;Cwd::cwd()&quot;</span> can
    be avoided if we can guarantee that the current directory doesn't get
    changed externally.</p>
<p class="Pp">To use this performance boost, set the current directory via</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    use Cwd;
    $tar-&gt;setcwd( cwd() );
</pre>
<p class="Pp">once before calling a function like
    <span class="Li">&quot;extract_file&quot;</span> and
    <span class="Li">&quot;Archive::Tar&quot;</span> will use the current
    directory setting from then on and won't call
    <span class="Li">&quot;Cwd::cwd()&quot;</span> internally.</p>
<p class="Pp">To switch back to the default behaviour, use</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    $tar-&gt;setcwd( undef );
</pre>
<p class="Pp">and <span class="Li">&quot;Archive::Tar&quot;</span> will call
    <span class="Li">&quot;Cwd::cwd()&quot;</span> internally again.</p>
<p class="Pp">If you're using <span class="Li">&quot;Archive::Tar&quot;</span>'s
    <span class="Li">&quot;extract()&quot;</span> method,
    <span class="Li">&quot;setcwd()&quot;</span> will be called for you.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="Class_Methods"><a class="permalink" href="#Class_Methods">Class
  Methods</a></h1>
<section class="Ss">
<h2 class="Ss" id="Archive::Tar_-_create_archive($file,_$compressed,_@filelist)"><a class="permalink" href="#Archive::Tar_-_create_archive($file,_$compressed,_@filelist)">Archive::Tar-&gt;create_archive($file,
  $compressed, @filelist)</a></h2>
Creates a tar file from the list of files provided. The first argument can
  either be the name of the tar file to create or a reference to an open file
  handle (e.g. a GLOB reference).
<p class="Pp">The second argument is used to indicate compression. You can
    either compress using <span class="Li">&quot;gzip&quot;</span> or
    <span class="Li">&quot;bzip2&quot;</span>. If you pass a digit, it's assumed
    to be the <span class="Li">&quot;gzip&quot;</span> compression level
    (between 1 and 9), but the use of constants is preferred:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  # write a gzip compressed file
  Archive::Tar-&gt;create_archive( 'out.tgz', COMPRESS_GZIP, @filelist );

  # write a bzip compressed file
  Archive::Tar-&gt;create_archive( 'out.tbz', COMPRESS_BZIP, @filelist );
</pre>
<p class="Pp">Note that when you pass in a filehandle, the compression argument
    is ignored, as all files are printed verbatim to your filehandle. If you
    wish to enable compression with filehandles, use an
    <span class="Li">&quot;IO::Zlib&quot;</span> or
    <span class="Li">&quot;IO::Compress::Bzip2&quot;</span> filehandle
  instead.</p>
<p class="Pp">The remaining arguments list the files to be included in the tar
    file. These files must all exist. Any files which don't exist or can't be
    read are silently ignored.</p>
<p class="Pp">If the archive creation fails for any reason,
    <span class="Li">&quot;create_archive&quot;</span> will return false. Please
    use the <span class="Li">&quot;error&quot;</span> method to find the cause
    of the failure.</p>
<p class="Pp">Note that this method does not write <span class="Li">&quot;on the
    fly&quot;</span> as it were; it still reads all the files into memory before
    writing out the archive. Consult the FAQ below if this is a problem.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Archive::Tar_-_iter(_$filename,___$compressed,__opt_=__$val____)"><a class="permalink" href="#Archive::Tar_-_iter(_$filename,___$compressed,__opt_=__$val____)">Archive::Tar-&gt;iter(
  $filename, [ $compressed, {opt =&gt; $val} ] )</a></h2>
Returns an iterator function that reads the tar file without loading it all in
  memory. Each time the function is called it will return the next file in the
  tarball. The files are returned as
  <span class="Li">&quot;Archive::Tar::File&quot;</span> objects. The iterator
  function returns the empty list once it has exhausted the files contained.
<p class="Pp">The second argument can be a hash reference with options, which
    are identical to the arguments passed to
    <span class="Li">&quot;read()&quot;</span>.</p>
<p class="Pp">Example usage:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    my $next = Archive::Tar-&gt;iter( &quot;example.tar.gz&quot;, 1, {filter =&gt; qr/\.pm$/} );

    while( my $f = $next-&gt;() ) {
        print $f-&gt;name, &quot;\n&quot;;

        $f-&gt;extract or warn &quot;Extraction failed&quot;;

        # ....
    }
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Archive::Tar_-_list_archive($file,_$compressed,___e@properties_)"><a class="permalink" href="#Archive::Tar_-_list_archive($file,_$compressed,___e@properties_)">Archive::Tar-&gt;list_archive($file,
  $compressed, [\@properties])</a></h2>
Returns a list of the names of all the files in the archive. The first argument
  can either be the name of the tar file to list or a reference to an open file
  handle (e.g. a GLOB reference).
<p class="Pp">If <span class="Li">&quot;list_archive()&quot;</span> is passed an
    array reference as its third argument it returns a list of hash references
    containing the requested properties of each file. The following list of
    properties is supported: full_path, name, size, mtime (last modified date),
    mode, uid, gid, linkname, uname, gname, devmajor, devminor, prefix,
  type.</p>
<p class="Pp">See <span class="Li">&quot;Archive::Tar::File&quot;</span> for
    details about supported properties.</p>
<p class="Pp">Passing an array reference containing only one element, 'name', is
    special cased to return a list of names rather than a list of hash
    references.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Archive::Tar_-_extract_archive($file,_$compressed)"><a class="permalink" href="#Archive::Tar_-_extract_archive($file,_$compressed)">Archive::Tar-&gt;extract_archive($file,
  $compressed)</a></h2>
Extracts the contents of the tar file. The first argument can either be the name
  of the tar file to create or a reference to an open file handle (e.g. a GLOB
  reference). All relative paths in the tar file will be created underneath the
  current working directory.
<p class="Pp"><span class="Li">&quot;extract_archive&quot;</span> will return a
    list of files it extracted. If the archive extraction fails for any reason,
    <span class="Li">&quot;extract_archive&quot;</span> will return false.
    Please use the <span class="Li">&quot;error&quot;</span> method to find the
    cause of the failure.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="$bool_=_Archive::Tar_-_has_io_string"><a class="permalink" href="#$bool_=_Archive::Tar_-_has_io_string">$bool
  = Archive::Tar-&gt;has_io_string</a></h2>
Returns true if we currently have <span class="Li">&quot;IO::String&quot;</span>
  support loaded.
<p class="Pp">Either <span class="Li">&quot;IO::String&quot;</span> or
    <span class="Li">&quot;perlio&quot;</span> support is needed to support
    writing stringified archives. Currently,
    <span class="Li">&quot;perlio&quot;</span> is the preferred method, if
    available.</p>
<p class="Pp">See the <span class="Li">&quot;GLOBAL VARIABLES&quot;</span>
    section to see how to change this preference.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="$bool_=_Archive::Tar_-_has_perlio"><a class="permalink" href="#$bool_=_Archive::Tar_-_has_perlio">$bool
  = Archive::Tar-&gt;has_perlio</a></h2>
Returns true if we currently have <span class="Li">&quot;perlio&quot;</span>
  support loaded.
<p class="Pp">This requires <span class="Li">&quot;perl-5.8&quot;</span> or
    higher, compiled with <span class="Li">&quot;perlio&quot;</span></p>
<p class="Pp">Either <span class="Li">&quot;IO::String&quot;</span> or
    <span class="Li">&quot;perlio&quot;</span> support is needed to support
    writing stringified archives. Currently,
    <span class="Li">&quot;perlio&quot;</span> is the preferred method, if
    available.</p>
<p class="Pp">See the <span class="Li">&quot;GLOBAL VARIABLES&quot;</span>
    section to see how to change this preference.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="$bool_=_Archive::Tar_-_has_zlib_support"><a class="permalink" href="#$bool_=_Archive::Tar_-_has_zlib_support">$bool
  = Archive::Tar-&gt;has_zlib_support</a></h2>
Returns true if <span class="Li">&quot;Archive::Tar&quot;</span> can extract
  <span class="Li">&quot;zlib&quot;</span> compressed archives
</section>
<section class="Ss">
<h2 class="Ss" id="$bool_=_Archive::Tar_-_has_bzip2_support"><a class="permalink" href="#$bool_=_Archive::Tar_-_has_bzip2_support">$bool
  = Archive::Tar-&gt;has_bzip2_support</a></h2>
Returns true if <span class="Li">&quot;Archive::Tar&quot;</span> can extract
  <span class="Li">&quot;bzip2&quot;</span> compressed archives
</section>
<section class="Ss">
<h2 class="Ss" id="Archive::Tar_-_can_handle_compressed_files"><a class="permalink" href="#Archive::Tar_-_can_handle_compressed_files">Archive::Tar-&gt;can_handle_compressed_files</a></h2>
A simple checking routine, which will return true if
  <span class="Li">&quot;Archive::Tar&quot;</span> is able to uncompress
  compressed archives on the fly with
  <span class="Li">&quot;IO::Zlib&quot;</span> and
  <span class="Li">&quot;IO::Compress::Bzip2&quot;</span> or false if not both
  are installed.
<p class="Pp">You can use this as a shortcut to determine whether
    <span class="Li">&quot;Archive::Tar&quot;</span> will do what you think
    before passing compressed archives to its
    <span class="Li">&quot;read&quot;</span> method.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="GLOBAL_VARIABLES"><a class="permalink" href="#GLOBAL_VARIABLES">GLOBAL
  VARIABLES</a></h1>
<section class="Ss">
<h2 class="Ss" id="$Archive::Tar::FOLLOW_SYMLINK"><a class="permalink" href="#$Archive::Tar::FOLLOW_SYMLINK">$Archive::Tar::FOLLOW_SYMLINK</a></h2>
Set this variable to <span class="Li">1</span> to make
  <span class="Li">&quot;Archive::Tar&quot;</span> effectively make a copy of
  the file when extracting. Default is <span class="Li">0</span>, which means
  the symlink stays intact. Of course, you will have to pack the file linked to
  as well.
<p class="Pp">This option is checked when you write out the tarfile using
    <span class="Li">&quot;write&quot;</span> or
    <span class="Li">&quot;create_archive&quot;</span>.</p>
<p class="Pp">This works just like
    <span class="Li">&quot;/bin/tar&quot;</span>'s
    <span class="Li">&quot;-h&quot;</span> option.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="$Archive::Tar::CHOWN"><a class="permalink" href="#$Archive::Tar::CHOWN">$Archive::Tar::CHOWN</a></h2>
By default, <span class="Li">&quot;Archive::Tar&quot;</span> will try to
  <span class="Li">&quot;chown&quot;</span> your files if it is able to. In some
  cases, this may not be desired. In that case, set this variable to
  <span class="Li">0</span> to disable
  <span class="Li">&quot;chown&quot;</span>-ing, even if it were possible.
<p class="Pp">The default is <span class="Li">1</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="$Archive::Tar::CHMOD"><a class="permalink" href="#$Archive::Tar::CHMOD">$Archive::Tar::CHMOD</a></h2>
By default, <span class="Li">&quot;Archive::Tar&quot;</span> will try to
  <span class="Li">&quot;chmod&quot;</span> your files to whatever mode was
  specified for the particular file in the archive. In some cases, this may not
  be desired. In that case, set this variable to <span class="Li">0</span> to
  disable <span class="Li">&quot;chmod&quot;</span>-ing.
<p class="Pp">The default is <span class="Li">1</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="$Archive::Tar::SAME_PERMISSIONS"><a class="permalink" href="#$Archive::Tar::SAME_PERMISSIONS">$Archive::Tar::SAME_PERMISSIONS</a></h2>
When, <span class="Li">$Archive::Tar::CHMOD</span> is enabled, this setting
  controls whether the permissions on files from the archive are used without
  modification of if they are filtered by removing any setid bits and applying
  the current umask.
<p class="Pp">The default is <span class="Li">1</span> for the root user and
    <span class="Li">0</span> for normal users.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="$Archive::Tar::DO_NOT_USE_PREFIX"><a class="permalink" href="#$Archive::Tar::DO_NOT_USE_PREFIX">$Archive::Tar::DO_NOT_USE_PREFIX</a></h2>
By default, <span class="Li">&quot;Archive::Tar&quot;</span> will try to put
  paths that are over 100 characters in the
  <span class="Li">&quot;prefix&quot;</span> field of your tar header, as
  defined per POSIX-standard. However, some (older) tar programs do not
  implement this spec. To retain compatibility with these older or non-POSIX
  compliant versions, you can set the <span class="Li">$DO_NOT_USE_PREFIX</span>
  variable to a true value, and <span class="Li">&quot;Archive::Tar&quot;</span>
  will use an alternate way of dealing with paths over 100 characters by using
  the <span class="Li">&quot;GNU Extended Header&quot;</span> feature.
<p class="Pp">Note that clients who do not support the
    <span class="Li">&quot;GNU Extended Header&quot;</span> feature will not be
    able to read these archives. Such clients include tars on
    <span class="Li">&quot;Solaris&quot;</span>,
    <span class="Li">&quot;Irix&quot;</span> and
    <span class="Li">&quot;AIX&quot;</span>.</p>
<p class="Pp">The default is <span class="Li">0</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="$Archive::Tar::DEBUG"><a class="permalink" href="#$Archive::Tar::DEBUG">$Archive::Tar::DEBUG</a></h2>
Set this variable to <span class="Li">1</span> to always get the
  <span class="Li">&quot;Carp::longmess&quot;</span> output of the warnings,
  instead of the regular <span class="Li">&quot;carp&quot;</span>. This is the
  same message you would get by doing:
<p class="Pp"><span class="Li"></span></p>
<pre>
    $tar-&gt;error(1);
</pre>
<p class="Pp">Defaults to <span class="Li">0</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="$Archive::Tar::WARN"><a class="permalink" href="#$Archive::Tar::WARN">$Archive::Tar::WARN</a></h2>
Set this variable to <span class="Li">0</span> if you do not want any warnings
  printed. Personally I recommend against doing this, but people asked for the
  option. Also, be advised that this is of course not threadsafe.
<p class="Pp">Defaults to <span class="Li">1</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="$Archive::Tar::error"><a class="permalink" href="#$Archive::Tar::error">$Archive::Tar::error</a></h2>
Holds the last reported error. Kept for historical reasons, but its use is very
  much discouraged. Use the <span class="Li">&quot;error()&quot;</span> method
  instead:
<p class="Pp"><span class="Li"></span></p>
<pre>
    warn $tar-&gt;error unless $tar-&gt;extract;
</pre>
<p class="Pp">Note that in older versions of this module, the
    <span class="Li">&quot;error()&quot;</span> method would return an
    effectively global value even when called an instance method as above. This
    has since been fixed, and multiple instances of
    <span class="Li">&quot;Archive::Tar&quot;</span> now have separate error
    strings.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="$Archive::Tar::INSECURE_EXTRACT_MODE"><a class="permalink" href="#$Archive::Tar::INSECURE_EXTRACT_MODE">$Archive::Tar::INSECURE_EXTRACT_MODE</a></h2>
This variable indicates whether <span class="Li">&quot;Archive::Tar&quot;</span>
  should allow files to be extracted outside their current working directory.
<p class="Pp">Allowing this could have security implications, as a malicious tar
    archive could alter or replace any file the extracting user has permissions
    to. Therefor, the default is to not allow insecure extractions.</p>
<p class="Pp">If you trust the archive, or have other reasons to allow the
    archive to write files outside your current working directory, set this
    variable to <span class="Li">&quot;true&quot;</span>.</p>
<p class="Pp">Note that this is a backwards incompatible change from version
    <span class="Li">1.36</span> and before.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="$Archive::Tar::HAS_PERLIO"><a class="permalink" href="#$Archive::Tar::HAS_PERLIO">$Archive::Tar::HAS_PERLIO</a></h2>
This variable holds a boolean indicating if we currently have
  <span class="Li">&quot;perlio&quot;</span> support loaded. This will be
  enabled for any perl greater than <span class="Li">5.8</span> compiled with
  <span class="Li">&quot;perlio&quot;</span>.
<p class="Pp">If you feel strongly about disabling it, set this variable to
    <span class="Li">&quot;false&quot;</span>. Note that you will then need
    <span class="Li">&quot;IO::String&quot;</span> installed to support writing
    stringified archives.</p>
<p class="Pp">Don't change this variable unless you <b>really</b> know what
    you're doing.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="$Archive::Tar::HAS_IO_STRING"><a class="permalink" href="#$Archive::Tar::HAS_IO_STRING">$Archive::Tar::HAS_IO_STRING</a></h2>
This variable holds a boolean indicating if we currently have
  <span class="Li">&quot;IO::String&quot;</span> support loaded. This will be
  enabled for any perl that has a loadable
  <span class="Li">&quot;IO::String&quot;</span> module.
<p class="Pp">If you feel strongly about disabling it, set this variable to
    <span class="Li">&quot;false&quot;</span>. Note that you will then need
    <span class="Li">&quot;perlio&quot;</span> support from your perl to be able
    to write stringified archives.</p>
<p class="Pp">Don't change this variable unless you <b>really</b> know what
    you're doing.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="$Archive::Tar::ZERO_PAD_NUMBERS"><a class="permalink" href="#$Archive::Tar::ZERO_PAD_NUMBERS">$Archive::Tar::ZERO_PAD_NUMBERS</a></h2>
This variable holds a boolean indicating if we will create zero padded numbers
  for <span class="Li">&quot;size&quot;</span>,
  <span class="Li">&quot;mtime&quot;</span> and
  <span class="Li">&quot;checksum&quot;</span>. The default is
  <span class="Li">0</span>, indicating that we will create space padded
  numbers. Added for compatibility with
  <span class="Li">&quot;busybox&quot;</span> implementations.
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="FAQ"><a class="permalink" href="#FAQ">FAQ</a></h1>
<dl class="Bl-tag">
  <dt>What's the minimum perl version required to run Archive::Tar?</dt>
  <dd>You will need perl version 5.005_03 or newer.</dd>
  <dt>Isn't Archive::Tar slow?</dt>
  <dd>Yes it is. It's pure perl, so it's a lot slower then your
      <span class="Li">&quot;/bin/tar&quot;</span> However, it's very portable.
      If speed is an issue, consider using
      <span class="Li">&quot;/bin/tar&quot;</span> instead.</dd>
  <dt>Isn't Archive::Tar heavier on memory than /bin/tar?</dt>
  <dd>Yes it is, see previous answer. Since
      <span class="Li">&quot;Compress::Zlib&quot;</span> and therefore
      <span class="Li">&quot;IO::Zlib&quot;</span> doesn't support
      <span class="Li">&quot;seek&quot;</span> on their filehandles, there is
      little choice but to read the archive into memory. This is ok if you want
      to do in-memory manipulation of the archive.
    <p class="Pp">If you just want to extract, use the
        <span class="Li">&quot;extract_archive&quot;</span> class method
        instead. It will optimize and write to disk immediately.</p>
    <p class="Pp">Another option is to use the
        <span class="Li">&quot;iter&quot;</span> class method to iterate over
        the files in the tarball without reading them all in memory at once.</p>
  </dd>
  <dt>Can you lazy-load data instead?</dt>
  <dd>In some cases, yes. You can use the
      <span class="Li">&quot;iter&quot;</span> class method to iterate over the
      files in the tarball without reading them all in memory at once.</dd>
  <dt>How much memory will an X kb tar file need?</dt>
  <dd>Probably more than X kb, since it will all be read into memory. If this is
      a problem, and you don't need to do in memory manipulation of the archive,
      consider using the <span class="Li">&quot;iter&quot;</span> class method,
      or <span class="Li">&quot;/bin/tar&quot;</span> instead.</dd>
  <dt>What do you do with unsupported filetypes in an archive?</dt>
  <dd><span class="Li">&quot;Unix&quot;</span> has a few filetypes that aren't
      supported on other platforms, like
      <span class="Li">&quot;Win32&quot;</span>. If we encounter a
      <span class="Li">&quot;hardlink&quot;</span> or
      <span class="Li">&quot;symlink&quot;</span> we'll just try to make a copy
      of the original file, rather than throwing an error.
    <p class="Pp">This does require you to read the entire archive in to memory
        first, since otherwise we wouldn't know what data to fill the copy with.
        (This means that you cannot use the class methods, including
        <span class="Li">&quot;iter&quot;</span> on archives that have
        incompatible filetypes and still expect things to work).</p>
    <p class="Pp">For other filetypes, like
        <span class="Li">&quot;chardevs&quot;</span> and
        <span class="Li">&quot;blockdevs&quot;</span> we'll warn that the
        extraction of this particular item didn't work.</p>
  </dd>
  <dt>I'm using WinZip, or some other non-POSIX client, and files are not being
    extracted properly!</dt>
  <dd>By default, <span class="Li">&quot;Archive::Tar&quot;</span> is in a
      completely POSIX-compatible mode, which uses the POSIX-specification of
      <span class="Li">&quot;tar&quot;</span> to store files. For paths greater
      than 100 characters, this is done using the <span class="Li">&quot;POSIX
      header prefix&quot;</span>. Non-POSIX-compatible clients may not support
      this part of the specification, and may only support the
      <span class="Li">&quot;GNU Extended</span>
      <span class="Li">Header&quot;</span> functionality. To facilitate those
      clients, you can set the
      <span class="Li">$Archive::Tar::DO_NOT_USE_PREFIX</span> variable to
      <span class="Li">&quot;true&quot;</span>. See the
      <span class="Li">&quot;GLOBAL VARIABLES&quot;</span> section for details
      on this variable.
    <p class="Pp">Note that GNU tar earlier than version 1.14 does not cope well
        with the <span class="Li">&quot;POSIX header prefix&quot;</span>. If you
        use such a version, consider setting the
        <span class="Li">$Archive::Tar::DO_NOT_USE_PREFIX</span> variable to
        <span class="Li">&quot;true&quot;</span>.</p>
  </dd>
  <dt>How do I extract only files that have property X from an archive?</dt>
  <dd>Sometimes, you might not wish to extract a complete archive, just the
      files that are relevant to you, based on some criteria.
    <p class="Pp">You can do this by filtering a list of
        <span class="Li">&quot;Archive::Tar::File&quot;</span> objects based on
        your criteria. For example, to extract only files that have the string
        <span class="Li">&quot;foo&quot;</span> in their title, you would
      use:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    $tar-&gt;extract(
        grep { $_-&gt;full_path =~ /foo/ } $tar-&gt;get_files
    );
    </pre>
    <p class="Pp">This way, you can filter on any attribute of the files in the
        archive. Consult the
        <span class="Li">&quot;Archive::Tar::File&quot;</span> documentation on
        how to use these objects.</p>
  </dd>
  <dt>How do I access .tar.Z files?</dt>
  <dd>The <span class="Li">&quot;Archive::Tar&quot;</span> module can optionally
      use <span class="Li">&quot;Compress::Zlib&quot;</span> (via the
      <span class="Li">&quot;IO::Zlib&quot;</span> module) to access tar files
      that have been compressed with <span class="Li">&quot;gzip&quot;</span>.
      Unfortunately tar files compressed with the Unix
      <span class="Li">&quot;compress&quot;</span> utility cannot be read by
      <span class="Li">&quot;Compress::Zlib&quot;</span> and so cannot be
      directly accesses by <span class="Li">&quot;Archive::Tar&quot;</span>.
    <p class="Pp">If the <span class="Li">&quot;uncompress&quot;</span> or
        <span class="Li">&quot;gunzip&quot;</span> programs are available, you
        can use one of these workarounds to read
        <span class="Li">&quot;.tar.Z&quot;</span> files from
        <span class="Li">&quot;Archive::Tar&quot;</span></p>
    <p class="Pp">Firstly with
      <span class="Li">&quot;uncompress&quot;</span></p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    use Archive::Tar;

    open F, &quot;uncompress -c $filename |&quot;;
    my $tar = Archive::Tar-&gt;new(*F);
    ...
    </pre>
    <p class="Pp">and this with <span class="Li">&quot;gunzip&quot;</span></p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    use Archive::Tar;

    open F, &quot;gunzip -c $filename |&quot;;
    my $tar = Archive::Tar-&gt;new(*F);
    ...
    </pre>
    <p class="Pp">Similarly, if the <span class="Li">&quot;compress&quot;</span>
        program is available, you can use this to write a
        <span class="Li">&quot;.tar.Z&quot;</span> file</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    use Archive::Tar;
    use IO::File;

    my $fh = new IO::File &quot;| compress -c &gt;$filename&quot;;
    my $tar = Archive::Tar-&gt;new();
    ...
    $tar-&gt;write($fh);
    $fh-&gt;close ;
    </pre>
  </dd>
  <dt>How do I handle Unicode strings?</dt>
  <dd><span class="Li">&quot;Archive::Tar&quot;</span> uses byte semantics for
      any files it reads from or writes to disk. This is not a problem if you
      only deal with files and never look at their content or work solely with
      byte strings. But if you use Unicode strings with character semantics,
      some additional steps need to be taken.
    <p class="Pp">For example, if you add a Unicode string like</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    # Problem
    $tar-&gt;add_data('file.txt', &quot;Euro: \x{20AC}&quot;);
    </pre>
    <p class="Pp">then there will be a problem later when the tarfile gets
        written out to disk via
        <span class="Li">&quot;$tar-&quot;</span><i>write()</i>&gt;:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    Wide character in print at .../Archive/Tar.pm line 1014.
    </pre>
    <p class="Pp">The data was added as a Unicode string and when writing it out
        to disk, the <span class="Li">&quot;:utf8&quot;</span> line discipline
        wasn't set by <span class="Li">&quot;Archive::Tar&quot;</span>, so Perl
        tried to convert the string to ISO-8859 and failed. The written file now
        contains garbage.</p>
    <p class="Pp">For this reason, Unicode strings need to be converted to
        UTF-8-encoded bytestrings before they are handed off to
        <span class="Li">&quot;add_data()&quot;</span>:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    use Encode;
    my $data = &quot;Accented character: \x{20AC}&quot;;
    $data = encode('utf8', $data);

    $tar-&gt;add_data('file.txt', $data);
    </pre>
    <p class="Pp">A opposite problem occurs if you extract a UTF8-encoded file
        from a tarball. Using <span class="Li">&quot;get_content()&quot;</span>
        on the <span class="Li">&quot;Archive::Tar::File&quot;</span> object
        will return its content as a bytestring, not as a Unicode string.</p>
    <p class="Pp">If you want it to be a Unicode string (because you want
        character semantics with operations like regular expression matching),
        you need to decode the UTF8-encoded content and have Perl convert it
        into a Unicode string:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    use Encode;
    my $data = $tar-&gt;get_content();

    # Make it a Unicode string
    $data = decode('utf8', $data);
    </pre>
    <p class="Pp">There is no easy way to provide this functionality in
        <span class="Li">&quot;Archive::Tar&quot;</span>, because a tarball can
        contain many files, and each of which could be encoded in a different
        way.</p>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="CAVEATS"><a class="permalink" href="#CAVEATS">CAVEATS</a></h1>
The AIX tar does not fill all unused space in the tar archive with 0x00. This
  sometimes leads to warning messages from
  <span class="Li">&quot;Archive::Tar&quot;</span>.
<p class="Pp"><span class="Li"></span></p>
<pre>
  Invalid header block at offset nnn
</pre>
<p class="Pp">A fix for that problem is scheduled to be released in the
    following levels of AIX, all of which should be coming out in the 4th
    quarter of 2009:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
 AIX 5.3 TL7 SP10
 AIX 5.3 TL8 SP8
 AIX 5.3 TL9 SP5
 AIX 5.3 TL10 SP2

 AIX 6.1 TL0 SP11
 AIX 6.1 TL1 SP7
 AIX 6.1 TL2 SP6
 AIX 6.1 TL3 SP3
</pre>
<p class="Pp">The IBM APAR number for this problem is IZ50240 (Reported
    component ID: 5765G0300 / AIX 5.3). It is possible to get an ifix for that
    problem. If you need an ifix please contact your local IBM AIX support.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="TODO"><a class="permalink" href="#TODO">TODO</a></h1>
<dl class="Bl-tag">
  <dt>Check if passed in handles are open for read/write</dt>
  <dd>Currently I don't know of any portable pure perl way to do this.
      Suggestions welcome.</dd>
  <dt>Allow archives to be passed in as string</dt>
  <dd>Currently, we only allow opened filehandles or filenames, but not strings.
      The internals would need some reworking to facilitate stringified
      archives.</dd>
  <dt>Facilitate processing an opened filehandle of a compressed archive</dt>
  <dd>Currently, we only support this if the filehandle is an IO::Zlib object.
      Environments, like apache, will present you with an opened filehandle to
      an uploaded file, which might be a compressed archive.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<dl class="Bl-tag">
  <dt>The GNU tar specification</dt>
  <dd><span class="Li">&quot;http://www.gnu.org/software/tar/manual/tar.html&quot;</span></dd>
  <dt>The PAX format specification</dt>
  <dd>The specification which tar derives from; <span class="Li">&quot;
      http://www.opengroup.org/onlinepubs/007904975/utilities/pax.html&quot;</span></dd>
  <dt>A comparison of GNU and POSIX tar standards;
    &quot;http://www.delorie.com/gnu/docs/tar/tar_114.html&quot;</dt>
  <dd></dd>
  <dt>GNU tar intends to switch to POSIX compatibility</dt>
  <dd>GNU Tar authors have expressed their intention to become completely
      POSIX-compatible;
      <span class="Li">&quot;http://www.gnu.org/software/tar/manual/html_node/Formats.html&quot;</span></dd>
  <dt>A Comparison between various tar implementations</dt>
  <dd>Lists known issues and incompatibilities;
      <span class="Li">&quot;http://gd.tuwien.ac.at/utils/archivers/star/README.otherbugs&quot;</span></dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
This module by Jos Boumans &lt;kane@cpan.org&gt;.
<p class="Pp">Please reports bugs to &lt;bug-archive-tar@rt.cpan.org&gt;.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="ACKNOWLEDGEMENTS"><a class="permalink" href="#ACKNOWLEDGEMENTS">ACKNOWLEDGEMENTS</a></h1>
Thanks to Sean Burke, Chris Nandor, Chip Salzenberg, Tim Heaney, Gisle Aas,
  Rainer Tammer and especially Andrew Savige for their help and suggestions.
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT"><a class="permalink" href="#COPYRIGHT">COPYRIGHT</a></h1>
This module is copyright (c) 2002 - 2009 Jos Boumans &lt;kane@cpan.org&gt;. All
  rights reserved.
<p class="Pp">This library is free software; you may redistribute and/or modify
    it under the same terms as Perl itself.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2020-06-06</td>
    <td class="foot-os">perl v5.18.4</td>
  </tr>
</table>
</body>
</html>
