<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    .Nd, .Bf, .Op { display: inline; }
    .Pa, .Ad { font-style: italic; }
    .Ms { font-weight: bold; }
    .Bl-diag > dt { font-weight: bold; }
    code.Nm, .Fl, .Cm, .Ic, code.In, .Fd, .Fn, .Cd { font-weight: bold;
      font-family: inherit; }
  </style>
  <title>IO::Socket(3pm)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">IO::Socket(3pm)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">IO::Socket(3pm)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">IO::Socket - Object interface to socket communications</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>    use strict;
    use warnings;
    use IO::Socket qw(AF_INET AF_UNIX);
    # create a new AF_INET socket
    my $sock = IO::Socket-&gt;new(Domain =&gt; AF_INET);
    # which is the same as
    $sock = IO::Socket::INET-&gt;new();
    # create a new AF_UNIX socket
    $sock = IO::Socket-&gt;new(Domain =&gt; AF_UNIX);
    # which is the same as
    $sock = IO::Socket::UNIX-&gt;new();
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp"><span class="Li">&quot;IO::Socket&quot;</span> provides an
    object-oriented, IO::Handle-based interface to creating and using sockets
    via Socket, which provides a near one-to-one interface to the C socket
    library.</p>
<p class="Pp"><span class="Li">&quot;IO::Socket&quot;</span> is a base class
    that really only defines methods for those operations which are common to
    all types of sockets. Operations which are specific to a particular socket
    domain have methods defined in subclasses of
    <span class="Li">&quot;IO::Socket&quot;</span>. See IO::Socket::INET,
    IO::Socket::UNIX, and IO::Socket::IP for examples of such a subclass.</p>
<p class="Pp"><span class="Li">&quot;IO::Socket&quot;</span> will export all
    functions (and constants) defined by Socket.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="CONSTRUCTOR_ARGUMENTS"><a class="permalink" href="#CONSTRUCTOR_ARGUMENTS">CONSTRUCTOR
  ARGUMENTS</a></h1>
<p class="Pp">Given that <span class="Li">&quot;IO::Socket&quot;</span> doesn't
    have attributes in the traditional sense, the following arguments, rather
    than attributes, can be passed into the constructor.</p>
<p class="Pp">Constructor arguments should be passed in
    <span class="Li">&quot;Key =&gt; 'Value'&quot;</span> pairs.</p>
<p class="Pp">The only required argument is &quot;Domain&quot; in
  IO::Socket.</p>
<section class="Ss">
<h2 class="Ss" id="Blocking"><a class="permalink" href="#Blocking">Blocking</a></h2>
<pre>    my $sock = IO::Socket-&gt;new(..., Blocking =&gt; 1);
    $sock = IO::Socket-&gt;new(..., Blocking =&gt; 0);
</pre>
<p class="Pp">If defined but false, the socket will be set to non-blocking mode.
    If not specified it defaults to <span class="Li">1</span> (blocking
  mode).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Domain"><a class="permalink" href="#Domain">Domain</a></h2>
<pre>    my $sock = IO::Socket-&gt;new(Domain =&gt; IO::Socket::AF_INET);
    $sock = IO::Socket-&gt;new(Domain =&gt; IO::Socket::AF_UNIX);
</pre>
<p class="Pp">The socket domain will define which subclass of
    <span class="Li">&quot;IO::Socket&quot;</span> to use. The two options
    available along with this distribution are
    <span class="Li">&quot;AF_INET&quot;</span> and
    <span class="Li">&quot;AF_UNIX&quot;</span>.</p>
<p class="Pp"><span class="Li">&quot;AF_INET&quot;</span> is for the internet
    address family of sockets and is handled via IO::Socket::INET.
    <span class="Li">&quot;AF_INET&quot;</span> sockets are bound to an internet
    address and port.</p>
<p class="Pp"><span class="Li">&quot;AF_UNIX&quot;</span> is for the unix domain
    socket and is handled via IO::Socket::UNIX.
    <span class="Li">&quot;AF_UNIX&quot;</span> sockets are bound to the file
    system as their address name space.</p>
<p class="Pp">This argument is <b>required</b>. All other arguments are
    optional.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Listen"><a class="permalink" href="#Listen">Listen</a></h2>
<pre>    my $sock = IO::Socket-&gt;new(..., Listen =&gt; 5);
</pre>
<p class="Pp">Listen should be an integer value or left unset.</p>
<p class="Pp">If provided, this argument will place the socket into listening
    mode. New connections can then be accepted using the &quot;accept&quot; in
    IO::Socket method. The value given is used as the
    <span class="Li">listen(2)</span> queue size.</p>
<p class="Pp">If the <span class="Li">&quot;Listen&quot;</span> argument is
    given, but false, the queue size will be set to 5.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Timeout"><a class="permalink" href="#Timeout">Timeout</a></h2>
<pre>    my $sock = IO::Socket-&gt;new(..., Timeout =&gt; 5);
</pre>
<p class="Pp">The timeout value, in seconds, for this socket connection. How
    exactly this value is utilized is defined in the socket domain subclasses
    that make use of the value.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Type"><a class="permalink" href="#Type">Type</a></h2>
<pre>    my $sock = IO::Socket-&gt;new(..., Type =&gt; IO::Socket::SOCK_STREAM);
</pre>
<p class="Pp">The socket type that will be used. These are usually
    <span class="Li">&quot;SOCK_STREAM&quot;</span>,
    <span class="Li">&quot;SOCK_DGRAM&quot;</span>, or
    <span class="Li">&quot;SOCK_RAW&quot;</span>. If this argument is left
    undefined an attempt will be made to infer the type from the service
  name.</p>
<p class="Pp">For example, you'll usually use
    <span class="Li">&quot;SOCK_STREAM&quot;</span> with a
    <span class="Li">&quot;tcp&quot;</span> connection and
    <span class="Li">&quot;SOCK_DGRAM&quot;</span> with a
    <span class="Li">&quot;udp&quot;</span> connection.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="CONSTRUCTORS"><a class="permalink" href="#CONSTRUCTORS">CONSTRUCTORS</a></h1>
<p class="Pp"><span class="Li">&quot;IO::Socket&quot;</span> extends the
    IO::Handle constructor.</p>
<section class="Ss">
<h2 class="Ss" id="new"><a class="permalink" href="#new">new</a></h2>
<pre>    my $sock = IO::Socket-&gt;new();
    # get a new IO::Socket::INET instance
    $sock = IO::Socket-&gt;new(Domain =&gt; IO::Socket::AF_INET);
    # get a new IO::Socket::UNIX instance
    $sock = IO::Socket-&gt;new(Domain =&gt; IO::Socket::AF_UNIX);
    # Domain is the only required argument
    $sock = IO::Socket-&gt;new(
        Domain =&gt; IO::Socket::AF_INET, # AF_INET, AF_UNIX
        Type =&gt; IO::Socket::SOCK_STREAM, # SOCK_STREAM, SOCK_DGRAM, ...
        Proto =&gt; 'tcp', # 'tcp', 'udp', IPPROTO_TCP, IPPROTO_UDP
        # and so on...
    );
</pre>
<p class="Pp">Creates an <span class="Li">&quot;IO::Socket&quot;</span>, which
    is a reference to a newly created symbol (see the Symbol package).
    <span class="Li">&quot;new&quot;</span> optionally takes arguments, these
    arguments are defined in &quot;CONSTRUCTOR ARGUMENTS&quot; in
  IO::Socket.</p>
<p class="Pp">Any of the &quot;CONSTRUCTOR ARGUMENTS&quot; in IO::Socket may be
    passed to the constructor, but if any arguments are provided, then one of
    them must be the &quot;Domain&quot; in IO::Socket argument. The
    &quot;Domain&quot; in IO::Socket argument can, by default, be either
    <span class="Li">&quot;AF_INET&quot;</span> or
    <span class="Li">&quot;AF_UNIX&quot;</span>. Other domains can be used if a
    proper subclass for the domain family is registered. All other arguments
    will be passed to the <span class="Li">&quot;configuration&quot;</span>
    method of the package for that domain.</p>
<p class="Pp">If the constructor fails it will return
    <span class="Li">&quot;undef&quot;</span> and set the
    <span class="Li">$errstr</span> package variable to contain an error
    message.</p>
<p class="Pp"></p>
<pre>    $sock = IO::Socket-&gt;new(...)
        or die &quot;Cannot create socket - $IO::Socket::errstr\n&quot;;
</pre>
<p class="Pp">For legacy reasons the error message is also set into the global
    <span class="Li">$@</span> variable, and you may still find older code which
    looks here instead.</p>
<p class="Pp"></p>
<pre>    $sock = IO::Socket-&gt;new(...)
        or die &quot;Cannot create socket - $@\n&quot;;
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="METHODS"><a class="permalink" href="#METHODS">METHODS</a></h1>
<p class="Pp"><span class="Li">&quot;IO::Socket&quot;</span> inherits all
    methods from IO::Handle and implements the following new ones.</p>
<section class="Ss">
<h2 class="Ss" id="accept"><a class="permalink" href="#accept">accept</a></h2>
<pre>    my $client_sock = $sock-&gt;accept();
    my $inet_sock = $sock-&gt;accept('IO::Socket::INET');
</pre>
<p class="Pp">The accept method will perform the system call
    <span class="Li">&quot;accept&quot;</span> on the socket and return a new
    object. The new object will be created in the same class as the listen
    socket, unless a specific package name is specified. This object can be used
    to communicate with the client that was trying to connect.</p>
<p class="Pp">This differs slightly from the
    <span class="Li">&quot;accept&quot;</span> function in perlfunc.</p>
<p class="Pp">In a scalar context the new socket is returned, or
    <span class="Li">&quot;undef&quot;</span> upon failure. In a list context a
    two-element array is returned containing the new socket and the peer
    address; the list will be empty upon failure.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="atmark"><a class="permalink" href="#atmark">atmark</a></h2>
<pre>    my $integer = $sock-&gt;atmark();
    # read in some data on a given socket
    my $data;
    $sock-&gt;read($data, 1024) until $sock-&gt;atmark;
    # or, export the function to use:
    use IO::Socket 'sockatmark';
    $sock-&gt;read($data, 1024) until sockatmark($sock);
</pre>
<p class="Pp">True if the socket is currently positioned at the urgent data
    mark, false otherwise. If your system doesn't yet implement
    <span class="Li">&quot;sockatmark&quot;</span> this will throw an
  exception.</p>
<p class="Pp">If your system does not support
    <span class="Li">&quot;sockatmark&quot;</span>, the
    <span class="Li">&quot;use&quot;</span> declaration will fail at compile
    time.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="autoflush"><a class="permalink" href="#autoflush">autoflush</a></h2>
<pre>    # by default, autoflush will be turned on when referenced
    $sock-&gt;autoflush(); # turns on autoflush
    # turn off autoflush
    $sock-&gt;autoflush(0);
    # turn on autoflush
    $sock-&gt;autoflush(1);
</pre>
<p class="Pp">This attribute isn't overridden from IO::Handle's implementation.
    However, since we turn it on by default, it's worth mentioning here.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="bind"><a class="permalink" href="#bind">bind</a></h2>
<pre>    use Socket qw(pack_sockaddr_in);
    my $port = 3000;
    my $ip_address = '0.0.0.0';
    my $packed_addr = pack_sockaddr_in($port, $ip_address);
    $sock-&gt;bind($packed_addr);
</pre>
<p class="Pp">Binds a network address to a socket, just as
    <span class="Li">bind(2)</span> does. Returns true if it succeeded, false
    otherwise. You should provide a packed address of the appropriate type for
    the socket.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="connected"><a class="permalink" href="#connected">connected</a></h2>
<pre>    my $peer_addr = $sock-&gt;connected();
    if ($peer_addr) {
        say &quot;We're connected to $peer_addr&quot;;
    }
</pre>
<p class="Pp">If the socket is in a connected state, the peer address is
    returned. If the socket is not in a connected state,
    <span class="Li">&quot;undef&quot;</span> is returned.</p>
<p class="Pp">Note that this method considers a half-open TCP socket to be
    &quot;in a connected state&quot;. Specifically, it does not distinguish
    between the <b>ESTABLISHED</b> and <b>CLOSE-WAIT</b> TCP states; it returns
    the peer address, rather than <span class="Li">&quot;undef&quot;</span>, in
    either case. Thus, in general, it cannot be used to reliably learn whether
    the peer has initiated a graceful shutdown because in most cases (see below)
    the local TCP state machine remains in <b>CLOSE-WAIT</b> until the local
    application calls &quot;shutdown&quot; in IO::Socket or
    <span class="Li">&quot;close&quot;</span>. Only at that point does this
    function return <span class="Li">&quot;undef&quot;</span>.</p>
<p class="Pp">The &quot;in most cases&quot; hedge is because local TCP state
    machine behavior may depend on the peer's socket options. In particular, if
    the peer socket has <span class="Li">&quot;SO_LINGER&quot;</span> enabled
    with a zero timeout, then the peer's
    <span class="Li">&quot;close&quot;</span> will generate a
    <span class="Li">&quot;RST&quot;</span> segment. Upon receipt of that
    segment, the local TCP transitions immediately to <b>CLOSED</b>, and in that
    state, this method <i>will</i> return
    <span class="Li">&quot;undef&quot;</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="getsockopt"><a class="permalink" href="#getsockopt">getsockopt</a></h2>
<pre>    my $value = $sock-&gt;getsockopt(SOL_SOCKET, SO_REUSEADDR);
    my $buf = $socket-&gt;getsockopt(SOL_SOCKET, SO_RCVBUF);
    say &quot;Receive buffer is $buf bytes&quot;;
</pre>
<p class="Pp">Get an option associated with the socket. Levels other than
    <span class="Li">&quot;SOL_SOCKET&quot;</span> may be specified here. As a
    convenience, this method will unpack a byte buffer of the correct size back
    into a number.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="listen"><a class="permalink" href="#listen">listen</a></h2>
<pre>    $sock-&gt;listen(5);
</pre>
<p class="Pp">Does the same thing that the <span class="Li">listen(2)</span>
    system call does. Returns true if it succeeded, false otherwise. Listens to
    a socket with a given queue size.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="peername"><a class="permalink" href="#peername">peername</a></h2>
<pre>    my $sockaddr_in = $sock-&gt;peername();
</pre>
<p class="Pp">Returns the packed <span class="Li">&quot;sockaddr&quot;</span>
    address of the other end of the socket connection. It calls
    <span class="Li">&quot;getpeername&quot;</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="protocol"><a class="permalink" href="#protocol">protocol</a></h2>
<pre>    my $proto = $sock-&gt;protocol();
</pre>
<p class="Pp">Returns the number for the protocol being used on the socket, if
    known. If the protocol is unknown, as with an
    <span class="Li">&quot;AF_UNIX&quot;</span> socket, zero is returned.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="recv"><a class="permalink" href="#recv">recv</a></h2>
<pre>    my $buffer = &quot;&quot;;
    my $length = 1024;
    my $flags = 0; # default. optional
    $sock-&gt;recv($buffer, $length);
    $sock-&gt;recv($buffer, $length, $flags);
</pre>
<p class="Pp">Similar in functionality to &quot;recv&quot; in perlfunc.</p>
<p class="Pp">Receives a message on a socket. Attempts to receive
    <span class="Li">$length</span> characters of data into
    <span class="Li">$buffer</span> from the specified socket.
    <span class="Li">$buffer</span> will be grown or shrunk to the length
    actually read. Takes the same flags as the system call of the same name.
    Returns the address of the sender if socket's protocol supports this;
    returns an empty string otherwise. If there's an error, returns
    <span class="Li">&quot;undef&quot;</span>. This call is actually implemented
    in terms of the <span class="Li">recvfrom(2)</span> system call.</p>
<p class="Pp">Flags are ORed together values, such as
    <span class="Li">&quot;MSG_BCAST&quot;</span>,
    <span class="Li">&quot;MSG_OOB&quot;</span>,
    <span class="Li">&quot;MSG_TRUNC&quot;</span>. The default value for the
    flags is <span class="Li">0</span>.</p>
<p class="Pp">The cached value of &quot;peername&quot; in IO::Socket is updated
    with the result of <span class="Li">&quot;recv&quot;</span>.</p>
<p class="Pp"><b>Note:</b> In Perl v5.30 and newer, if the socket has been
    marked as <span class="Li">&quot;:utf8&quot;</span>,
    <span class="Li">&quot;recv&quot;</span> will throw an exception. The
    <span class="Li">&quot;:encoding(...)&quot;</span> layer implicitly
    introduces the <span class="Li">&quot;:utf8&quot;</span> layer. See
    &quot;binmode&quot; in perlfunc.</p>
<p class="Pp"><b>Note:</b> In Perl versions older than v5.30, depending on the
    status of the socket, either (8-bit) bytes or characters are received. By
    default all sockets operate on bytes, but for example if the socket has been
    changed using &quot;binmode&quot; in perlfunc to operate with the
    <span class="Li">&quot;:encoding(UTF-8)&quot;</span> I/O layer (see the
    &quot;open&quot; in perlfunc pragma), the I/O will operate on UTF8-encoded
    Unicode characters, not bytes. Similarly for the
    <span class="Li">&quot;:encoding&quot;</span> layer: in that case pretty
    much any characters can be read.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="send"><a class="permalink" href="#send">send</a></h2>
<pre>    my $message = &quot;Hello, world!&quot;;
    my $flags = 0; # defaults to zero
    my $to = '0.0.0.0'; # optional destination
    my $sent = $sock-&gt;send($message);
    $sent = $sock-&gt;send($message, $flags);
    $sent = $sock-&gt;send($message, $flags, $to);
</pre>
<p class="Pp">Similar in functionality to &quot;send&quot; in perlfunc.</p>
<p class="Pp">Sends a message on a socket. Attempts to send the scalar message
    to the socket. Takes the same flags as the system call of the same name. On
    unconnected sockets, you must specify a destination to send to, in which
    case it does a <span class="Li">sendto(2)</span> syscall. Returns the number
    of characters sent, or <span class="Li">&quot;undef&quot;</span> on error.
    The <span class="Li">sendmsg(2)</span> syscall is currently
  unimplemented.</p>
<p class="Pp">The <span class="Li">&quot;flags&quot;</span> option is optional
    and defaults to <span class="Li">0</span>.</p>
<p class="Pp">After a successful send with <span class="Li">$to</span>, further
    calls to <span class="Li">&quot;send&quot;</span> on an unconnected socket
    without <span class="Li">$to</span> will send to the same address, and
    <span class="Li">$to</span> will be used as the result of
    &quot;peername&quot; in IO::Socket.</p>
<p class="Pp"><b>Note:</b> In Perl v5.30 and newer, if the socket has been
    marked as <span class="Li">&quot;:utf8&quot;</span>,
    <span class="Li">&quot;send&quot;</span> will throw an exception. The
    <span class="Li">&quot;:encoding(...)&quot;</span> layer implicitly
    introduces the <span class="Li">&quot;:utf8&quot;</span> layer. See
    &quot;binmode&quot; in perlfunc.</p>
<p class="Pp"><b>Note:</b> In Perl versions older than v5.30, depending on the
    status of the socket, either (8-bit) bytes or characters are sent. By
    default all sockets operate on bytes, but for example if the socket has been
    changed using &quot;binmode&quot; in perlfunc to operate with the
    <span class="Li">&quot;:encoding(UTF-8)&quot;</span> I/O layer (see the
    &quot;open&quot; in perlfunc pragma), the I/O will operate on UTF8-encoded
    Unicode characters, not bytes. Similarly for the
    <span class="Li">&quot;:encoding&quot;</span> layer: in that case pretty
    much any characters can be sent.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="setsockopt"><a class="permalink" href="#setsockopt">setsockopt</a></h2>
<pre>    $sock-&gt;setsockopt(SOL_SOCKET, SO_REUSEADDR, 1);
    $sock-&gt;setsockopt(SOL_SOCKET, SO_RCVBUF, 64*1024);
</pre>
<p class="Pp">Set option associated with the socket. Levels other than
    <span class="Li">&quot;SOL_SOCKET&quot;</span> may be specified here. As a
    convenience, this method will convert a number into a packed byte
  buffer.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="shutdown"><a class="permalink" href="#shutdown">shutdown</a></h2>
<pre>    $sock-&gt;shutdown(SHUT_RD); # we stopped reading data
    $sock-&gt;shutdown(SHUT_WR); # we stopped writing data
    $sock-&gt;shutdown(SHUT_RDWR); # we stopped using this socket
</pre>
<p class="Pp">Shuts down a socket connection in the manner indicated by the
    value passed in, which has the same interpretation as in the syscall of the
    same name.</p>
<p class="Pp">This is useful with sockets when you want to tell the other side
    you're done writing but not done reading, or vice versa. It's also a more
    insistent form of <span class="Li">&quot;close&quot;</span> because it also
    disables the file descriptor in any forked copies in other processes.</p>
<p class="Pp">Returns <span class="Li">1</span> for success; on error, returns
    <span class="Li">&quot;undef&quot;</span> if the socket is not a valid
    filehandle, or returns <span class="Li">0</span> and sets
    <span class="Li">$!</span> for any other failure.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="sockdomain"><a class="permalink" href="#sockdomain">sockdomain</a></h2>
<pre>    my $domain = $sock-&gt;sockdomain();
</pre>
<p class="Pp">Returns the number for the socket domain type. For example, for an
    <span class="Li">&quot;AF_INET&quot;</span> socket the value of
    <span class="Li">&amp;AF_INET</span> will be returned.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="socket"><a class="permalink" href="#socket">socket</a></h2>
<pre>    my $sock = IO::Socket-&gt;new(); # no values given
    # now let's actually get a socket with the socket method
    # domain, type, and protocol are required
    $sock = $sock-&gt;socket(AF_INET, SOCK_STREAM, 'tcp');
</pre>
<p class="Pp">Opens a socket of the specified kind and returns it. Domain, type,
    and protocol are specified the same as for the syscall of the same name.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="socketpair"><a class="permalink" href="#socketpair">socketpair</a></h2>
<pre>    my ($r, $w) = $sock-&gt;socketpair(AF_UNIX, SOCK_STREAM, PF_UNSPEC);
    ($r, $w) = IO::Socket::UNIX
        -&gt;socketpair(AF_UNIX, SOCK_STREAM, PF_UNSPEC);
</pre>
<p class="Pp">Will return a list of two sockets created (read and write), or an
    empty list on failure.</p>
<p class="Pp">Differs slightly from
    <span class="Li">&quot;socketpair&quot;</span> in perlfunc in that the
    argument list is a bit simpler.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="sockname"><a class="permalink" href="#sockname">sockname</a></h2>
<pre>    my $packed_addr = $sock-&gt;sockname();
</pre>
<p class="Pp">Returns the packed <span class="Li">&quot;sockaddr&quot;</span>
    address of this end of the connection. It's the same as
    <span class="Li">getsockname(2)</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="sockopt"><a class="permalink" href="#sockopt">sockopt</a></h2>
<pre>    my $value = $sock-&gt;sockopt(SO_REUSEADDR);
    $sock-&gt;sockopt(SO_REUSEADDR, 1);
</pre>
<p class="Pp">Unified method to both set and get options in the
    <span class="Li">&quot;SOL_SOCKET&quot;</span> level. If called with one
    argument then &quot;getsockopt&quot; in IO::Socket is called, otherwise
    &quot;setsockopt&quot; in IO::Socket is called.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="socktype"><a class="permalink" href="#socktype">socktype</a></h2>
<pre>    my $type = $sock-&gt;socktype();
</pre>
<p class="Pp">Returns the number for the socket type. For example, for a
    <span class="Li">&quot;SOCK_STREAM&quot;</span> socket the value of
    <span class="Li">&amp;SOCK_STREAM</span> will be returned.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="timeout"><a class="permalink" href="#timeout">timeout</a></h2>
<pre>    my $seconds = $sock-&gt;timeout();
    my $old_val = $sock-&gt;timeout(5); # set new and return old value
</pre>
<p class="Pp">Set or get the timeout value (in seconds) associated with this
    socket. If called without any arguments then the current setting is
    returned. If called with an argument the current setting is changed and the
    previous value returned.</p>
<p class="Pp">This method is available to all
    <span class="Li">&quot;IO::Socket&quot;</span> implementations but may or
    may not be used by the individual domain subclasses.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="EXAMPLES"><a class="permalink" href="#EXAMPLES">EXAMPLES</a></h1>
<p class="Pp">Let's create a TCP server on
    <span class="Li">&quot;localhost:3333&quot;</span>.</p>
<p class="Pp"></p>
<pre>    use strict;
    use warnings;
    use feature 'say';
    use IO::Socket qw(AF_INET AF_UNIX SOCK_STREAM SHUT_WR);
    my $server = IO::Socket-&gt;new(
        Domain =&gt; AF_INET,
        Type =&gt; SOCK_STREAM,
        Proto =&gt; 'tcp',
        LocalHost =&gt; '0.0.0.0',
        LocalPort =&gt; 3333,
        ReusePort =&gt; 1,
        Listen =&gt; 5,
    ) || die &quot;Can't open socket: $IO::Socket::errstr&quot;;
    say &quot;Waiting on 3333&quot;;
    while (1) {
        # waiting for a new client connection
        my $client = $server-&gt;accept();
        # get information about a newly connected client
        my $client_address = $client-&gt;peerhost();
        my $client_port = $client-&gt;peerport();
        say &quot;Connection from $client_address:$client_port&quot;;
        # read up to 1024 characters from the connected client
        my $data = &quot;&quot;;
        $client-&gt;recv($data, 1024);
        say &quot;received data: $data&quot;;
        # write response data to the connected client
        $data = &quot;ok&quot;;
        $client-&gt;send($data);
        # notify client that response has been sent
        $client-&gt;shutdown(SHUT_WR);
    }
    $server-&gt;close();
</pre>
<p class="Pp">A client for such a server could be</p>
<p class="Pp"></p>
<pre>    use strict;
    use warnings;
    use feature 'say';
    use IO::Socket qw(AF_INET AF_UNIX SOCK_STREAM SHUT_WR);
    my $client = IO::Socket-&gt;new(
        Domain =&gt; AF_INET,
        Type =&gt; SOCK_STREAM,
        proto =&gt; 'tcp',
        PeerPort =&gt; 3333,
        PeerHost =&gt; '0.0.0.0',
    ) || die &quot;Can't open socket: $IO::Socket::errstr&quot;;
    say &quot;Sending Hello World!&quot;;
    my $size = $client-&gt;send(&quot;Hello World!&quot;);
    say &quot;Sent data of length: $size&quot;;
    $client-&gt;shutdown(SHUT_WR);
    my $buffer;
    $client-&gt;recv($buffer, 1024);
    say &quot;Got back $buffer&quot;;
    $client-&gt;close();
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="LIMITATIONS"><a class="permalink" href="#LIMITATIONS">LIMITATIONS</a></h1>
<p class="Pp">On some systems, for an IO::Socket object created with
    <span class="Li">&quot;new_from_fd&quot;</span>, or created with
    &quot;accept&quot; in IO::Socket from such an object, the
    &quot;protocol&quot; in IO::Socket, &quot;sockdomain&quot; in IO::Socket and
    &quot;socktype&quot; in IO::Socket methods may return
    <span class="Li">&quot;undef&quot;</span>.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp">Socket, IO::Handle, IO::Socket::INET, IO::Socket::UNIX,
    IO::Socket::IP</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">Graham Barr. <b>atmark()</b> by Lincoln Stein. Currently
    maintained by the Perl Porters. Please report all bugs to
    &lt;perlbug@perl.org&gt;.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT"><a class="permalink" href="#COPYRIGHT">COPYRIGHT</a></h1>
<p class="Pp">Copyright (c) 1997-8 Graham Barr &lt;gbarr@pobox.com&gt;. All
    rights reserved. This program is free software; you can redistribute it
    and/or modify it under the same terms as Perl itself.</p>
<p class="Pp">The <b>atmark()</b> implementation: Copyright 2001, Lincoln Stein
    &lt;lstein@cshl.org&gt;. This module is distributed under the same terms as
    Perl itself. Feel free to use, modify and redistribute it as long as you
    retain the correct attribution.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2022-02-19</td>
    <td class="foot-os">perl v5.34.1</td>
  </tr>
</table>
</body>
</html>
