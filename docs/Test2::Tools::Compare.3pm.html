<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    .Nd, .Bf, .Op { display: inline; }
    .Pa, .Ad { font-style: italic; }
    .Ms { font-weight: bold; }
    .Bl-diag > dt { font-weight: bold; }
    code.Nm, .Fl, .Cm, .Ic, code.In, .Fd, .Fn, .Cd { font-weight: bold;
      font-family: inherit; }
  </style>
  <title>Test2::Tools::Compare(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Test2::Tools::Compare(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Test2::Tools::Compare(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Test2::Tools::Compare - Tools for comparing deep data
  structures.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">Test::More had <span class="Li">&quot;is_deeply()&quot;</span>.
    This library is the Test2 version that can be used to compare data
    structures, but goes a step further in that it provides tools for building a
    data structure specification against which you can verify your data. There
    are both 'strict' and 'relaxed' versions of the tools.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>    use Test2::Tools::Compare;
    # Hash for demonstration purposes
    my $some_hash = {a =&gt; 1, b =&gt; 2, c =&gt; 3};
    # Strict checking, everything must match
    is(
        $some_hash,
        {a =&gt; 1, b =&gt; 2, c =&gt; 3},
        &quot;The hash we got matches our expectations&quot;
    );
    # Relaxed Checking, only fields we care about are checked, and we can use a
    # regex to approximate a field.
    like(
        $some_hash,
        {a =&gt; 1, b =&gt; qr/[0-9]+/},
        &quot;'a' is 1, 'b' is an integer, we don't care about 'c'.&quot;
    );
</pre>
<section class="Ss">
<h2 class="Ss">ADVANCED</h2>
<p class="Pp">Declarative hash, array, and objects builders are available that
    allow you to generate specifications. These are more verbose than simply
    providing a hash, but have the advantage that every component you specify
    has a line number associated. This is helpful for debugging as the failure
    output will tell you not only which fields was incorrect, but also the line
    on which you declared the field.</p>
<p class="Pp"></p>
<pre>    use Test2::Tools::Compare qw{
        is like isnt unlike
        match mismatch validator
        hash array bag object meta number float rounded within string subset bool
        in_set not_in_set check_set
        item field call call_list call_hash prop check all_items all_keys all_vals all_values
        etc end filter_items
        T F D DNE FDNE E
        event fail_events
        exact_ref
    };
    is(
        $some_hash,
        hash {
            field a =&gt; 1;
            field b =&gt; 2;
            field c =&gt; 3;
        },
        &quot;Hash matches spec&quot;
    );
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="COMPARISON_TOOLS"><a class="permalink" href="#COMPARISON_TOOLS">COMPARISON
  TOOLS</a></h1>
<dl class="Bl-tag">
  <dt>$bool = is($got, $expect)</dt>
  <dd></dd>
  <dt>$bool = is($got, $expect, $name)</dt>
  <dd></dd>
  <dt>$bool = is($got, $expect, $name, @diag)</dt>
  <dd><span class="Li">$got</span> is the data structure you want to check.
      <span class="Li">$expect</span> is what you want
      <span class="Li">$got</span> to look like. <span class="Li">$name</span>
      is an optional name for the test. <span class="Li">@diag</span> is
      optional diagnostics messages that will be printed to STDERR in event of
      failure, they will not be displayed when the comparison is successful. The
      boolean true/false result of the comparison is returned.
    <p class="Pp">This is the strict checker. The strict checker requires a
        perfect match between <span class="Li">$got</span> and
        <span class="Li">$expect</span>. All hash fields must be specified, all
        array items must be present, etc. All non-scalar/hash/array/regex
        references must be identical (same memory address). Scalar, hash and
        array references will be traversed and compared. Regex references will
        be compared to see if they have the same pattern.</p>
    <p class="Pp"></p>
    <pre>    is(
        $some_hash,
        {a =&gt; 1, b =&gt; 2, c =&gt; 3},
        &quot;The hash we got matches our expectations&quot;
    );
    </pre>
    <p class="Pp">The only exception to strictness is when it is given an
        <span class="Li">$expect</span> object that was built from a
        specification, in which case the specification determines the
        strictness. Strictness only applies to literal values/references that
        are provided and converted to a specification for you.</p>
    <p class="Pp"></p>
    <pre>    is(
        $some_hash,
        hash {    # Note: the hash function is not exported by default
            field a =&gt; 1;
            field b =&gt; match(qr/[0-9]+/);    # Note: The match function is not exported by default
            # Don't care about other fields.
        },
        &quot;The hash comparison is not strict&quot;
    );
    </pre>
    <p class="Pp">This works for both deep and shallow structures. For instance
        you can use this to compare two strings:</p>
    <p class="Pp"></p>
    <pre>    is('foo', 'foo', &quot;strings match&quot;);
    </pre>
    <p class="Pp"><b>Note</b>: This is not the tool to use if you want to check
        if two references are the same exact reference, use
        <span class="Li">&quot;ref_is()&quot;</span> from the Test2::Tools::Ref
        plugin instead. <i>Most</i> of the time this will work as well, however
        there are problems if your reference contains a cycle and refers back to
        itself at some point. If this happens, an exception will be thrown to
        break an otherwise infinite recursion.</p>
    <p class="Pp"><b>Note</b>: Non-reference values will be compared as strings
        using <span class="Li">&quot;eq&quot;</span>, so that means '2.0' and
        '2' will match.</p>
  </dd>
  <dt>$bool = isnt($got, $expect)</dt>
  <dd></dd>
  <dt>$bool = isnt($got, $expect, $name)</dt>
  <dd></dd>
  <dt>$bool = isnt($got, $expect, $name, @diag)</dt>
  <dd>Opposite of <span class="Li">&quot;is()&quot;</span>. Does all the same
      checks, but passes when there is a mismatch.</dd>
  <dt>$bool = like($got, $expect)</dt>
  <dd></dd>
  <dt>$bool = like($got, $expect, $name)</dt>
  <dd></dd>
  <dt>$bool = like($got, $expect, $name, @diag)</dt>
  <dd><span class="Li">$got</span> is the data structure you want to check.
      <span class="Li">$expect</span> is what you want
      <span class="Li">$got</span> to look like. <span class="Li">$name</span>
      is an optional name for the test. <span class="Li">@diag</span> is
      optional diagnostics messages that will be printed to STDERR in event of
      failure, they will not be displayed when the comparison is successful. The
      boolean true/false result of the comparison is returned.
    <p class="Pp">This is the relaxed checker. This will ignore hash keys or
        array indexes that you do not actually specify in your
        <span class="Li">$expect</span> structure. In addition regex and sub
        references will be used as validators. If you provide a regex using
        <span class="Li">&quot;qr/.../&quot;</span>, the regex itself will be
        used to validate the corresponding value in the
        <span class="Li">$got</span> structure. The same is true for coderefs,
        the value is passed in as the first argument (and in
        <span class="Li">$_</span>) and the sub should return a boolean value.
        In this tool regexes will stringify the thing they are checking.</p>
    <p class="Pp"></p>
    <pre>    like(
        $some_hash,
        {a =&gt; 1, b =&gt; qr/[0-9]+/},
        &quot;'a' is 1, 'b' is an integer, we don't care about other fields&quot;
    );
    </pre>
    <p class="Pp">This works for both deep and shallow structures. For instance
        you can use this to compare two strings:</p>
    <p class="Pp"></p>
    <pre>    like('foo bar', qr/^foo/, &quot;string matches the pattern&quot;);
    </pre>
  </dd>
  <dt>$bool = unlike($got, $expect)</dt>
  <dd></dd>
  <dt>$bool = unlike($got, $expect, $name)</dt>
  <dd></dd>
  <dt>$bool = unlike($got, $expect, $name, @diag)</dt>
  <dd>Opposite of <span class="Li">&quot;like()&quot;</span>. Does all the same
      checks, but passes when there is a mismatch.</dd>
</dl>
<section class="Ss">
<h2 class="Ss">QUICK CHECKS</h2>
<p class="Pp"><b>Note: None of these are exported by default. You need to
    request them.</b></p>
<p class="Pp">Quick checks are a way to quickly generate a common value
    specification. These can be used in structures passed into
    <span class="Li">&quot;is&quot;</span> and
    <span class="Li">&quot;like&quot;</span> through the
    <span class="Li">$expect</span> argument.</p>
<p class="Pp">Example:</p>
<p class="Pp"></p>
<pre>    is($foo, T(), '$foo has a true value');
</pre>
<dl class="Bl-tag">
  <dt>$check = T()</dt>
  <dd>This verifies that the value in the corresponding
      <span class="Li">$got</span> structure is true, any true value will do.
    <p class="Pp"></p>
    <pre>    is($foo, T(), '$foo has a true value');
    is(
        { a =&gt; 'xxx' },
        { a =&gt; T() },
        &quot;The 'a' key is true&quot;
    );
    </pre>
  </dd>
  <dt>$check = F()</dt>
  <dd>This verifies that the value in the corresponding
      <span class="Li">$got</span> structure is false, any false value will do,
      <b>but the value must exist</b>.
    <p class="Pp"></p>
    <pre>    is($foo, F(), '$foo has a false value');
    is(
        { a =&gt; 0 },
        { a =&gt; F() },
        &quot;The 'a' key is false&quot;
    );
    </pre>
    <p class="Pp">It is important to note that a nonexistent value does not
        count as false. This check will generate a failing test result:</p>
    <p class="Pp"></p>
    <pre>    is(
        { a =&gt; 1 },
        { a =&gt; 1, b =&gt; F() },
        &quot;The 'b' key is false&quot;
    );
    </pre>
    <p class="Pp">This will produce the following output:</p>
    <p class="Pp"></p>
    <pre>    not ok 1 - The b key is false
    # Failed test &quot;The 'b' key is false&quot;
    # at some_file.t line 10.
    # +------+------------------+-------+---------+
    # | PATH | GOT              | OP    | CHECK   |
    # +------+------------------+-------+---------+
    # | {b}  | &lt;DOES NOT EXIST&gt; | FALSE | FALSE() |
    # +------+------------------+-------+---------+
    </pre>
    <p class="Pp">In Perl, you can have behavior that is different for a missing
        key vs. a false key, so it was decided not to count a completely absent
        value as false. See the <span class="Li">&quot;DNE()&quot;</span>
        shortcut below for checking that a field is missing.</p>
    <p class="Pp">If you want to check for false and/or DNE use the
        <span class="Li">&quot;FDNE()&quot;</span> check.</p>
  </dd>
  <dt>$check = D()</dt>
  <dd>This is to verify that the value in the <span class="Li">$got</span>
      structure is defined. Any value other than
      <span class="Li">&quot;undef&quot;</span> will pass.
    <p class="Pp">This will pass:</p>
    <p class="Pp"></p>
    <pre>    is('foo', D(), 'foo is defined');
    </pre>
    <p class="Pp">This will fail:</p>
    <p class="Pp"></p>
    <pre>    is(undef, D(), 'foo is defined');
    </pre>
  </dd>
  <dt>$check = U()</dt>
  <dd>This is to verify that the value in the <span class="Li">$got</span>
      structure is undefined.
    <p class="Pp">This will pass:</p>
    <p class="Pp"></p>
    <pre>    is(undef, U(), 'not defined');
    </pre>
    <p class="Pp">This will fail:</p>
    <p class="Pp"></p>
    <pre>    is('foo', U(), 'not defined');
    </pre>
  </dd>
  <dt>$check = <b>DF()</b></dt>
  <dd>This is to verify that the value in the <span class="Li">$got</span>
      structure is defined but false. Any false value other than
      <span class="Li">&quot;undef&quot;</span> will pass.
    <p class="Pp">This will pass:</p>
    <p class="Pp"></p>
    <pre>    is(0, DF(), 'foo is defined but false');
    </pre>
    <p class="Pp">These will fail:</p>
    <p class="Pp"></p>
    <pre>    is(undef, DF(), 'foo is defined but false');
    is(1, DF(), 'foo is defined but false');
    </pre>
  </dd>
  <dt>$check = E()</dt>
  <dd>This can be used to check that a value exists. This is useful to check
      that an array has more values, or to check that a key exists in a hash,
      even if the value is undefined.
    <p class="Pp">These pass:</p>
    <p class="Pp"></p>
    <pre>    is(['a', 'b', undef], ['a', 'b', E()], &quot;There is a third item in the array&quot;);
    is({a =&gt; 1, b =&gt; 2}, {a =&gt; 1, b =&gt; E()}, &quot;The 'b' key exists in the hash&quot;);
    </pre>
    <p class="Pp">These will fail:</p>
    <p class="Pp"></p>
    <pre>    is(['a', 'b'], ['a', 'b', E()], &quot;Third item exists&quot;);
    is({a =&gt; 1}, {a =&gt; 1, b =&gt; E()}, &quot;'b' key exists&quot;);
    </pre>
  </dd>
  <dt>$check = <b>DNE()</b></dt>
  <dd>This can be used to check that no value exists. This is useful to check
      the end bound of an array, or to check that a key does not exist in a
      hash.
    <p class="Pp">These pass:</p>
    <p class="Pp"></p>
    <pre>    is(['a', 'b'], ['a', 'b', DNE()], &quot;There is no third item in the array&quot;);
    is({a =&gt; 1}, {a =&gt; 1, b =&gt; DNE()}, &quot;The 'b' key does not exist in the hash&quot;);
    </pre>
    <p class="Pp">These will fail:</p>
    <p class="Pp"></p>
    <pre>    is(['a', 'b', 'c'], ['a', 'b', DNE()], &quot;No third item&quot;);
    is({a =&gt; 1, b =&gt; 2}, {a =&gt; 1, b =&gt; DNE()}, &quot;No 'b' key&quot;);
    </pre>
  </dd>
  <dt>$check = <b>FDNE()</b></dt>
  <dd>This is a combination of <span class="Li">&quot;F()&quot;</span> and
      <span class="Li">&quot;DNE()&quot;</span>. This will pass for a false
      value, or a nonexistent value.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss">VALUE SPECIFICATIONS</h2>
<p class="Pp"><b>Note: None of these are exported by default. You need to
    request them.</b></p>
<dl class="Bl-tag">
  <dt>$check = string &quot;...&quot;</dt>
  <dd>Verify that the value matches the given string using the
      <span class="Li">&quot;eq&quot;</span> operator.</dd>
  <dt>$check = !string &quot;...&quot;</dt>
  <dd>Verify that the value does not match the given string using the
      <span class="Li">&quot;ne&quot;</span> operator.</dd>
  <dt>$check = number ...;</dt>
  <dd>Verify that the value matches the given number using the
      <span class="Li">&quot;==&quot;</span> operator.</dd>
  <dt>$check = !number ...;</dt>
  <dd>Verify that the value does not match the given number using the
      <span class="Li">&quot;!=&quot;</span> operator.</dd>
  <dt>$check = float ...;</dt>
  <dd>Verify that the value is approximately equal to the given number.
    <p class="Pp">If a 'precision' parameter is specified, both operands will be
        rounded to 'precision' number of fractional decimal digits and compared
        with <span class="Li">&quot;eq&quot;</span>.</p>
    <p class="Pp"></p>
    <pre>  is($near_val, float($val, precision =&gt; 4), &quot;Near 4 decimal digits&quot;);
    </pre>
    <p class="Pp">Otherwise, the check will be made within a range of +/-
        'tolerance', with a default 'tolerance' of 1e-08.</p>
    <p class="Pp"></p>
    <pre>  is( $near_val, float($val, tolerance =&gt; 0.01), &quot;Almost there...&quot;);
    </pre>
    <p class="Pp">See also <span class="Li">&quot;within&quot;</span> and
        <span class="Li">&quot;rounded&quot;</span>.</p>
  </dd>
  <dt>$check = !float ...;</dt>
  <dd>Verify that the value is not approximately equal to the given number.
    <p class="Pp">If a 'precision' parameter is specified, both operands will be
        rounded to 'precision' number of fractional decimal digits and compared
        with <span class="Li">&quot;eq&quot;</span>.</p>
    <p class="Pp">Otherwise, the check will be made within a range of +/-
        'tolerance', with a default 'tolerance' of 1e-08.</p>
    <p class="Pp">See also <span class="Li">&quot;!within&quot;</span> and
        <span class="Li">&quot;!rounded&quot;</span>.</p>
  </dd>
  <dt>$check = within($num, $tolerance);</dt>
  <dd>Verify that the value approximately matches the given number, within a
      range of +/- <span class="Li">$tolerance</span>. Compared using the
      <span class="Li">&quot;==&quot;</span> operator.
    <p class="Pp"><span class="Li">$tolerance</span> is optional and defaults to
        1e-08.</p>
  </dd>
  <dt>$check = !within($num, $tolerance);</dt>
  <dd>Verify that the value does not approximately match the given number within
      a range of +/- <span class="Li">$tolerance</span>. Compared using the
      <span class="Li">&quot;!=&quot;</span> operator.
    <p class="Pp"><span class="Li">$tolerance</span> is optional and defaults to
        1e-08.</p>
  </dd>
  <dt>$check = rounded($num, $precision);</dt>
  <dd>Verify that the value approximately matches the given number, when both
      are rounded to <span class="Li">$precision</span> number of fractional
      digits. Compared using the <span class="Li">&quot;eq&quot;</span>
      operator.</dd>
  <dt>$check = !rounded($num, $precision);</dt>
  <dd>Verify that the value does not approximately match the given number, when
      both are rounded to <span class="Li">$precision</span> number of
      fractional digits. Compared using the
      <span class="Li">&quot;ne&quot;</span> operator.</dd>
  <dt>$check = bool ...;</dt>
  <dd>Verify the value has the same boolean value as the given argument
    (XNOR).</dd>
  <dt>$check = !bool ...;</dt>
  <dd>Verify the value has a different boolean value from the given argument
      (XOR).</dd>
  <dt>$check = match qr/.../</dt>
  <dd></dd>
  <dt>$check = !mismatch qr/.../</dt>
  <dd>Verify that the value matches the regex pattern. This form of pattern
      check will <b>NOT</b> stringify references being checked.
    <p class="Pp"><b>Note:</b> <span class="Li">&quot;!mismatch()&quot;</span>
        is documented for completion, please do not use it.</p>
  </dd>
  <dt>$check = !match qr/.../</dt>
  <dd></dd>
  <dt>$check = mismatch qr/.../</dt>
  <dd>Verify that the value does not match the regex pattern. This form of
      pattern check will <b>NOT</b> stringify references being checked.
    <p class="Pp"><b>Note:</b> <span class="Li">&quot;mismatch()&quot;</span>
        was created before overloading of <span class="Li">&quot;!&quot;</span>
        for <span class="Li">&quot;match()&quot;</span> was a thing.</p>
  </dd>
  <dt>$check = validator(sub{ ... })</dt>
  <dd></dd>
  <dt>$check = validator($NAME =&gt; sub{ ... })</dt>
  <dd></dd>
  <dt>$check = validator($OP, $NAME, sub{ ... })</dt>
  <dd>The coderef is the only required argument. The coderef should check that
      the value is what you expect and return a boolean true or false.
      Optionally, you can specify a name and operator that are used in
      diagnostics. They are also provided to the sub itself as named parameters.
    <p class="Pp">Check the value using this sub. The sub gets the value in
        <span class="Li">$_</span>, and it receives the value and several other
        items as named parameters.</p>
    <p class="Pp"></p>
    <pre>    my $check = validator(sub {
        my %params = @_;
        # These both work:
        my $got = $_;
        my $got = $params{got};
        # Check if a value exists at all
        my $exists = $params{exists}
        # What $OP (if any) did we specify when creating the validator
        my $operator = $params{operator};
        # What name (if any) did we specify when creating the validator
        my $name = $params{name};
        ...
        return $bool;
    }
    </pre>
  </dd>
  <dt>$check = exact_ref($ref)</dt>
  <dd>Check that the value is exactly the same reference as the one
    provided.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss">SET BUILDERS</h2>
<p class="Pp"><b>Note: None of these are exported by default. You need to
    request them.</b></p>
<dl class="Bl-tag">
  <dt id="my"><a class="permalink" href="#my">my $check = check_set($check1,
    $check2, ...)</a></dt>
  <dd>Check that the value matches ALL of the specified checks.</dd>
  <dt id="my~2"><a class="permalink" href="#my~2">my $check = in_set($check1,
    $check2, ...)</a></dt>
  <dd>Check that the value matches ONE OR MORE of the specified checks.</dd>
  <dt id="not_in_set($check1,"><a class="permalink" href="#not_in_set($check1,">not_in_set($check1,
    $check2, ...)</a></dt>
  <dd>Check that the value DOES NOT match ANY of the specified checks.</dd>
  <dt id="check"><a class="permalink" href="#check">check $thing</a></dt>
  <dd>Check that the value matches the specified thing.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss">HASH BUILDER</h2>
<p class="Pp"><b>Note: None of these are exported by default. You need to
    request them.</b></p>
<p class="Pp"></p>
<pre>    $check = hash {
        field foo =&gt; 1;
        field bar =&gt; 2;
        # Ensure the 'baz' keys does not even exist in the hash.
        field baz =&gt; DNE();
        # Ensure the key exists, but is set to undef
        field bat =&gt; undef;
        # Any check can be used
        field boo =&gt; $check;
        # Set checks that apply to all keys or values. Can be done multiple
        # times, and each call can define multiple checks, all will be run.
        all_vals match qr/a/, match qr/b/;    # All values must have an 'a' and a 'b'
        all_keys match qr/x/;                 # All keys must have an 'x'
        ...
        end(); # optional, enforces that no other keys are present.
    };
</pre>
<dl class="Bl-tag">
  <dt>$check = hash { ... }</dt>
  <dd>This is used to define a hash check.</dd>
  <dt id="field"><a class="permalink" href="#field">field $NAME =&gt;
    $VAL</a></dt>
  <dd></dd>
  <dt id="field~2"><a class="permalink" href="#field~2">field $NAME =&gt;
    $CHECK</a></dt>
  <dd>Specify a field check. This will check the hash key specified by
      <span class="Li">$NAME</span> and ensure it matches the value in
      <span class="Li">$VAL</span>. You can put any valid check in
      <span class="Li">$VAL</span>, such as the result of another call to
      <span class="Li">&quot;array { ... }&quot;</span>,
      <span class="Li">&quot;DNE()&quot;</span>, etc.
    <p class="Pp"><b>Note:</b> This function can only be used inside a hash
        builder sub, and must be called in void context.</p>
  </dd>
  <dt id="all_keys($CHECK1,"><a class="permalink" href="#all_keys($CHECK1,">all_keys($CHECK1,
    $CHECK2, ...)</a></dt>
  <dd>Add checks that apply to all keys. You can put this anywhere in the hash
      block, and can call it any number of times with any number of
    arguments.</dd>
  <dt id="all_vals($CHECK1,"><a class="permalink" href="#all_vals($CHECK1,">all_vals($CHECK1,
    $CHECK2, ...)</a></dt>
  <dd></dd>
  <dt id="all_values($CHECK1,"><a class="permalink" href="#all_values($CHECK1,">all_values($CHECK1,
    $CHECK2, ...)</a></dt>
  <dd>Add checks that apply to all values. You can put this anywhere in the hash
      block, and can call it any number of times with any number of
    arguments.</dd>
  <dt id="end()"><a class="permalink" href="#end()"><b>end()</b></a></dt>
  <dd>Enforce that no keys are found in the hash other than those specified.
      This is essentially the <span class="Li">&quot;use strict&quot;</span> of
      a hash check. This can be used anywhere in the hash builder, though
      typically it is placed at the end.</dd>
  <dt id="etc()"><a class="permalink" href="#etc()"><b>etc()</b></a></dt>
  <dd>Ignore any extra keys found in the hash. This is the opposite of
      <span class="Li">&quot;end()&quot;</span>. This can be used anywhere in
      the hash builder, though typically it is placed at the end.</dd>
  <dt id="DNE"><a class="permalink" href="#DNE"><b>DNE()</b></a></dt>
  <dd>This is a handy check that can be used with
      <span class="Li">&quot;field()&quot;</span> to ensure that a field (D)oes
      (N)ot (E)xist.
    <p class="Pp"></p>
    <pre>    field foo =&gt; DNE();
    </pre>
  </dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss">ARRAY BUILDER</h2>
<p class="Pp"><b>Note: None of these are exported by default. You need to
    request them.</b></p>
<p class="Pp"></p>
<pre>    $check = array {
        # Uses the next index, in this case index 0;
        item 'a';
        # Gets index 1 automatically
        item 'b';
        # Specify the index
        item 2 =&gt; 'c';
        # We skipped index 3, which means we don't care what it is.
        item 4 =&gt; 'e';
        # Gets index 5.
        item 'f';
        # Remove any REMAINING items that contain 0-9.
        filter_items { grep {!m/[0-9]/} @_ };
        # Set checks that apply to all items. Can be done multiple times, and
        # each call can define multiple checks, all will be run.
        all_items match qr/a/, match qr/b/;
        all_items match qr/x/;
        # Of the remaining items (after the filter is applied) the next one
        # (which is now index 6) should be 'g'.
        item 6 =&gt; 'g';
        item 7 =&gt; DNE; # Ensure index 7 does not exist.
        end(); # Ensure no other indexes exist.
    };
</pre>
<dl class="Bl-tag">
  <dt>$check = array { ... }</dt>
  <dd></dd>
  <dt id="item"><a class="permalink" href="#item">item $VAL</a></dt>
  <dd></dd>
  <dt id="item~2"><a class="permalink" href="#item~2">item $CHECK</a></dt>
  <dd></dd>
  <dt id="item~3"><a class="permalink" href="#item~3">item $IDX, $VAL</a></dt>
  <dd></dd>
  <dt id="item~4"><a class="permalink" href="#item~4">item $IDX, $CHECK</a></dt>
  <dd>Add an expected item to the array. If <span class="Li">$IDX</span> is not
      specified it will automatically calculate it based on the last item added.
      You can skip indexes, which means you do not want them to be checked.
    <p class="Pp">You can provide any value to check in
        <span class="Li">$VAL</span>, or you can provide any valid check
      object.</p>
    <p class="Pp"><b>Note:</b> Items MUST be added in order.</p>
    <p class="Pp"><b>Note:</b> This function can only be used inside an array,
        bag or subset builder sub, and must be called in void context.</p>
  </dd>
  <dt id="filter_items"><a class="permalink" href="#filter_items">filter_items {
    my @remaining = @_; ...; return @filtered }</a></dt>
  <dd>This function adds a filter, all items remaining in the array from the
      point the filter is reached will be passed into the filter sub as
      arguments, the sub should return only the items that should be checked.
    <p class="Pp"><b>Note:</b> This function can only be used inside an array
        builder sub, and must be called in void context.</p>
  </dd>
  <dt id="all_items($CHECK1,"><a class="permalink" href="#all_items($CHECK1,">all_items($CHECK1,
    $CHECK2, ...)</a></dt>
  <dd>Add checks that apply to all items. You can put this anywhere in the array
      block, and can call it any number of times with any number of
    arguments.</dd>
  <dt id="end()~2"><a class="permalink" href="#end()~2"><b>end()</b></a></dt>
  <dd>Enforce that there are no indexes after the last one specified. This will
      not force checking of skipped indexes.</dd>
  <dt id="etc()~2"><a class="permalink" href="#etc()~2"><b>etc()</b></a></dt>
  <dd>Ignore any extra items found in the array. This is the opposite of
      <span class="Li">&quot;end()&quot;</span>. This can be used anywhere in
      the array builder, though typically it is placed at the end.</dd>
  <dt id="DNE~2"><a class="permalink" href="#DNE~2"><b>DNE()</b></a></dt>
  <dd>This is a handy check that can be used with
      <span class="Li">&quot;item()&quot;</span> to ensure that an index (D)oes
      (N)ot (E)xist.
    <p class="Pp"></p>
    <pre>    item 5 =&gt; DNE();
    </pre>
  </dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss">BAG BUILDER</h2>
<p class="Pp"><b>Note: None of these are exported by default. You need to
    request them.</b></p>
<p class="Pp"></p>
<pre>    $check = bag {
        item 'a';
        item 'b';
        end(); # Ensure no other elements exist.
    };
</pre>
<p class="Pp">A bag is like an array, but we don't care about the order of the
    items. In the example, <span class="Li">$check</span> would match both
    <span class="Li">&quot;['a','b']&quot;</span> and
    <span class="Li">&quot;['b','a']&quot;</span>.</p>
<dl class="Bl-tag">
  <dt>$check = bag { ... }</dt>
  <dd></dd>
  <dt id="item~5"><a class="permalink" href="#item~5">item $VAL</a></dt>
  <dd></dd>
  <dt id="item~6"><a class="permalink" href="#item~6">item $CHECK</a></dt>
  <dd>Add an expected item to the bag.
    <p class="Pp">You can provide any value to check in
        <span class="Li">$VAL</span>, or you can provide any valid check
      object.</p>
    <p class="Pp"><b>Note:</b> This function can only be used inside an array,
        bag or subset builder sub, and must be called in void context.</p>
  </dd>
  <dt id="all_items($CHECK1,~2"><a class="permalink" href="#all_items($CHECK1,~2">all_items($CHECK1,
    $CHECK2, ...)</a></dt>
  <dd>Add checks that apply to all items. You can put this anywhere in the bag
      block, and can call it any number of times with any number of
    arguments.</dd>
  <dt id="end()~3"><a class="permalink" href="#end()~3"><b>end()</b></a></dt>
  <dd>Enforce that there are no more items after the last one specified.</dd>
  <dt id="etc()~3"><a class="permalink" href="#etc()~3"><b>etc()</b></a></dt>
  <dd>Ignore any extra items found in the array. This is the opposite of
      <span class="Li">&quot;end()&quot;</span>. This can be used anywhere in
      the bag builder, though typically it is placed at the end.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss">ORDERED SUBSET BUILDER</h2>
<p class="Pp"><b>Note: None of these are exported by default. You need to
    request them.</b></p>
<p class="Pp"></p>
<pre>    $check = subset {
        item 'a';
        item 'b';
        item 'c';
        # Doesn't matter if the array has 'd', the check will skip past any
        # unknown items until it finds the next one in our subset.
        item 'e';
        item 'f';
    };
</pre>
<dl class="Bl-tag">
  <dt>$check = subset { ... }</dt>
  <dd></dd>
  <dt id="item~7"><a class="permalink" href="#item~7">item $VAL</a></dt>
  <dd></dd>
  <dt id="item~8"><a class="permalink" href="#item~8">item $CHECK</a></dt>
  <dd>Add an expected item to the subset.
    <p class="Pp">You can provide any value to check in
        <span class="Li">$VAL</span>, or you can provide any valid check
      object.</p>
    <p class="Pp"><b>Note:</b> Items MUST be added in order.</p>
    <p class="Pp"><b>Note:</b> This function can only be used inside an array,
        bag or subset builder sub, and must be called in void context.</p>
  </dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss">META BUILDER</h2>
<p class="Pp"><b>Note: None of these are exported by default. You need to
    request them.</b></p>
<p class="Pp"></p>
<pre>    my $check = meta {
        prop blessed =&gt; 'My::Module'; # Ensure value is blessed as our package
        prop reftype =&gt; 'HASH';       # Ensure value is a blessed hash
        prop size    =&gt; 4;            # Check the number of hash keys
        prop this    =&gt; ...;          # Check the item itself
    };
</pre>
<dl class="Bl-tag">
  <dt id="meta"><a class="permalink" href="#meta">meta { ... }</a></dt>
  <dd></dd>
  <dt id="meta_check"><a class="permalink" href="#meta_check">meta_check { ...
    }</a></dt>
  <dd>Build a meta check. If you are using Moose then the
      <span class="Li">&quot;meta()&quot;</span> function would conflict with
      the one exported by Moose, in such cases
      <span class="Li">&quot;meta_check()&quot;</span> is available. Neither is
      exported by default.</dd>
  <dt id="prop"><a class="permalink" href="#prop">prop $NAME =&gt; $VAL</a></dt>
  <dd></dd>
  <dt id="prop~2"><a class="permalink" href="#prop~2">prop $NAME =&gt;
    $CHECK</a></dt>
  <dd>Check the property specified by <span class="Li">$name</span> against the
      value or check.
    <p class="Pp">Valid properties are:</p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>'blessed'</dt>
  <dd>What package (if any) the thing is blessed as.</dd>
  <dt>'reftype'</dt>
  <dd>Reference type (if any) the thing is.</dd>
  <dt>'this'</dt>
  <dd>The thing itself.</dd>
  <dt>'size'</dt>
  <dd>For array references this returns the number of elements. For hashes this
      returns the number of keys. For everything else this returns undef.</dd>
</dl>
</div>
<div class="Bd-indent"></div>
</section>
<section class="Ss">
<h2 class="Ss">OBJECT BUILDER</h2>
<p class="Pp"><b>Note: None of these are exported by default. You need to
    request them.</b></p>
<p class="Pp"></p>
<pre>    my $check = object {
        call foo =&gt; 1; # Call the 'foo' method, check the result.
        # Call the specified sub-ref as a method on the object, check the
        # result. This is useful for wrapping methods that return multiple
        # values.
        call sub { [ shift-&gt;get_list ] } =&gt; [...];
        # This can be used to ensure a method does not exist.
        call nope =&gt; DNE();
        # Check the hash key 'foo' of the underlying reference, this only works
        # on blessed hashes.
        field foo =&gt; 1;
        # Check the value of index 4 on the underlying reference, this only
        # works on blessed arrays.
        item 4 =&gt; 'foo';
        # Check the meta-property 'blessed' of the object.
        prop blessed =&gt; 'My::Module';
        # Ensure only the specified hash keys or array indexes are present in
        # the underlying hash. Has no effect on meta-property checks or method
        # checks.
        end();
    };
</pre>
<dl class="Bl-tag">
  <dt>$check = object { ... }</dt>
  <dd>Specify an object check for use in comparisons.</dd>
  <dt id="call"><a class="permalink" href="#call">call $METHOD_NAME =&gt;
    $RESULT</a></dt>
  <dd></dd>
  <dt id="call~2"><a class="permalink" href="#call~2">call $METHOD_NAME =&gt;
    $CHECK</a></dt>
  <dd></dd>
  <dt id="call~3"><a class="permalink" href="#call~3">call [$METHOD_NAME,
    @METHOD_ARGS] =&gt; $RESULT</a></dt>
  <dd></dd>
  <dt id="call~4"><a class="permalink" href="#call~4">call [$METHOD_NAME,
    @METHOD_ARGS] =&gt; $CHECK</a></dt>
  <dd></dd>
  <dt id="call~5"><a class="permalink" href="#call~5">call sub { ... },
    $RESULT</a></dt>
  <dd></dd>
  <dt id="call~6"><a class="permalink" href="#call~6">call sub { ... },
    $CHECK</a></dt>
  <dd>Call the specified method (or coderef) and verify the result. If you pass
      an arrayref, the first element must be the method name, the others are the
      arguments it will be called with.
    <p class="Pp">The coderef form is useful if you need to do something more
        complex.</p>
    <p class="Pp"></p>
    <pre>    my $ref = sub {
      local $SOME::GLOBAL::THING = 3;
      return [shift-&gt;get_values_for('thing')];
    };
    call $ref =&gt; ...;
    </pre>
  </dd>
  <dt id="call_list"><a class="permalink" href="#call_list">call_list
    $METHOD_NAME =&gt; $RESULT</a></dt>
  <dd></dd>
  <dt id="call_list~2"><a class="permalink" href="#call_list~2">call_list
    $METHOD_NAME =&gt; $CHECK</a></dt>
  <dd></dd>
  <dt id="call_list~3"><a class="permalink" href="#call_list~3">call_list
    [$METHOD_NAME, @METHOD_ARGS] =&gt; $RESULT</a></dt>
  <dd></dd>
  <dt id="call_list~4"><a class="permalink" href="#call_list~4">call_list
    [$METHOD_NAME, @METHOD_ARGS] =&gt; $CHECK</a></dt>
  <dd></dd>
  <dt id="call_list~5"><a class="permalink" href="#call_list~5">call_list sub {
    ... }, $RESULT</a></dt>
  <dd></dd>
  <dt id="call_list~6"><a class="permalink" href="#call_list~6">call_list sub {
    ... }, $CHECK</a></dt>
  <dd>Same as <span class="Li">&quot;call&quot;</span>, but the method is
      invoked in list context, and the result is always an arrayref.
    <p class="Pp"></p>
    <pre>    call_list get_items =&gt; [ ... ];
    </pre>
  </dd>
  <dt id="call_hash"><a class="permalink" href="#call_hash">call_hash
    $METHOD_NAME =&gt; $RESULT</a></dt>
  <dd></dd>
  <dt id="call_hash~2"><a class="permalink" href="#call_hash~2">call_hash
    $METHOD_NAME =&gt; $CHECK</a></dt>
  <dd></dd>
  <dt id="call_hash~3"><a class="permalink" href="#call_hash~3">call_hash
    [$METHOD_NAME, @METHOD_ARGS] =&gt; $RESULT</a></dt>
  <dd></dd>
  <dt id="call_hash~4"><a class="permalink" href="#call_hash~4">call_hash
    [$METHOD_NAME, @METHOD_ARGS] =&gt; $CHECK</a></dt>
  <dd></dd>
  <dt id="call_hash~5"><a class="permalink" href="#call_hash~5">call_hash sub {
    ... }, $RESULT</a></dt>
  <dd></dd>
  <dt id="call_hash~6"><a class="permalink" href="#call_hash~6">call_hash sub {
    ... }, $CHECK</a></dt>
  <dd>Same as <span class="Li">&quot;call&quot;</span>, but the method is
      invoked in list context, and the result is always a hashref. This will
      warn if the method returns an odd number of values.
    <p class="Pp"></p>
    <pre>    call_hash get_items =&gt; { ... };
    </pre>
  </dd>
  <dt id="field~3"><a class="permalink" href="#field~3">field $NAME =&gt;
    $VAL</a></dt>
  <dd>Works just like it does for hash checks.</dd>
  <dt id="item~9"><a class="permalink" href="#item~9">item $VAL</a></dt>
  <dd></dd>
  <dt id="item~10"><a class="permalink" href="#item~10">item $IDX, $VAL</a></dt>
  <dd>Works just like it does for array checks.</dd>
  <dt id="prop~3"><a class="permalink" href="#prop~3">prop $NAME =&gt;
    $VAL</a></dt>
  <dd></dd>
  <dt id="prop~4"><a class="permalink" href="#prop~4">prop $NAME =&gt;
    $CHECK</a></dt>
  <dd>Check the property specified by <span class="Li">$name</span> against the
      value or check.
    <p class="Pp">Valid properties are:</p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>'blessed'</dt>
  <dd>What package (if any) the thing is blessed as.</dd>
  <dt>'reftype'</dt>
  <dd>Reference type (if any) the thing is.</dd>
  <dt>'this'</dt>
  <dd>The thing itself.</dd>
  <dt>'size'</dt>
  <dd>For array references this returns the number of elements. For hashes this
      returns the number of keys. For everything else this returns undef.</dd>
</dl>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt id="DNE~3"><a class="permalink" href="#DNE~3"><b>DNE()</b></a></dt>
  <dd>Can be used with <span class="Li">&quot;item&quot;</span>, or
      <span class="Li">&quot;field&quot;</span> to ensure the hash field or
      array index does not exist. Can also be used with
      <span class="Li">&quot;call&quot;</span> to ensure a method does not
      exist.</dd>
  <dt id="end()~4"><a class="permalink" href="#end()~4"><b>end()</b></a></dt>
  <dd>Turn on strict array/hash checking, ensuring that no extra keys/indexes
      are present.</dd>
  <dt id="etc()~4"><a class="permalink" href="#etc()~4"><b>etc()</b></a></dt>
  <dd>Ignore any extra items found in the hash/array. This is the opposite of
      <span class="Li">&quot;end()&quot;</span>. This can be used anywhere in
      the builder, though typically it is placed at the end.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss">EVENT BUILDERS</h2>
<p class="Pp"><b>Note: None of these are exported by default. You need to
    request them.</b></p>
<p class="Pp">Check that we got an event of a specified type:</p>
<p class="Pp"></p>
<pre>    my $check = event 'Ok';
</pre>
<p class="Pp">Check for details about the event:</p>
<p class="Pp"></p>
<pre>    my $check = event Ok =&gt; sub {
        # Check for a failure
        call pass =&gt; 0;
        # Effective pass after TODO/SKIP are accounted for.
        call effective_pass =&gt; 1;
        # Check the diagnostics
        call diag =&gt; [ match qr/Failed test foo/ ];
        # Check the file the event reports to
        prop file =&gt; 'foo.t';
        # Check the line number the event reports o
        prop line =&gt; '42';
        # You can check the todo/skip values as well:
        prop skip =&gt; 'broken';
        prop todo =&gt; 'fixme';
        # Thread-id and process-id where event was generated
        prop tid =&gt; 123;
        prop pid =&gt; 123;
    };
</pre>
<p class="Pp">You can also provide a fully qualified event package with the '+'
    prefix:</p>
<p class="Pp"></p>
<pre>    my $check = event '+My::Event' =&gt; sub { ... }
</pre>
<p class="Pp">You can also provide a hashref instead of a sub to directly check
    hash values of the event:</p>
<p class="Pp"></p>
<pre>    my $check = event Ok =&gt; { pass =&gt; 1, ... };
</pre>
<p class="Pp"><i>USE IN OTHER BUILDERS</i></p>
<p class="Pp">You can use these all in other builders, simply use them in void
    context to have their value(s) appended to the build.</p>
<p class="Pp"></p>
<pre>    my $check = array {
        event Ok =&gt; { ... };
        event Note =&gt; { ... };
        fail_events Ok =&gt; { pass =&gt; 0 };
        # Get a Diag for free.
    };
</pre>
<p class="Pp"><i>SPECIFICS</i></p>
<dl class="Bl-tag">
  <dt>$check = event $TYPE;</dt>
  <dd></dd>
  <dt>$check = event $TYPE =&gt; sub { ... };</dt>
  <dd></dd>
  <dt>$check = event $TYPE =&gt; { ... };</dt>
  <dd>This works just like an object builder. In addition to supporting
      everything the object check supports, you also have to specify the event
      type, and many extra meta-properties are available.
    <p class="Pp">Extra properties are:</p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>'file'</dt>
  <dd>File name to which the event reports (for use in diagnostics).</dd>
  <dt>'line'</dt>
  <dd>Line number to which the event reports (for use in diagnostics).</dd>
  <dt>'package'</dt>
  <dd>Package to which the event reports (for use in diagnostics).</dd>
  <dt>'subname'</dt>
  <dd>Sub that was called to generate the event (example:
      <span class="Li">&quot;ok()&quot;</span>).</dd>
  <dt>'skip'</dt>
  <dd>Set to the skip value if the result was generated by skipping tests.</dd>
  <dt>'todo'</dt>
  <dd>Set to the todo value if TODO was set when the event was generated.</dd>
  <dt>'trace'</dt>
  <dd>The <span class="Li">&quot;at file foo.t line 42&quot;</span> string that
      will be used in diagnostics.</dd>
  <dt>'tid'</dt>
  <dd>Thread ID in which the event was generated.</dd>
  <dt>'pid'</dt>
  <dd>Process ID in which the event was generated.</dd>
</dl>
</div>
<div class="Bd-indent">
<p class="Pp"><b>NOTE</b>: Event checks have an implicit
    <span class="Li">&quot;etc()&quot;</span> added. This means you need to use
    <span class="Li">&quot;end()&quot;</span> if you want to fail on unexpected
    hash keys or array indexes. This implicit
    <span class="Li">&quot;etc()&quot;</span> extends to all forms, including
    builder, hashref, and no argument.</p>
</div>
<dl class="Bl-tag">
  <dt>@checks = fail_events $TYPE;</dt>
  <dd></dd>
  <dt>@checks = fail_events $TYPE =&gt; sub { ... };</dt>
  <dd></dd>
  <dt>@checks = fail_events $TYPE =&gt; { ... };</dt>
  <dd>Just like <span class="Li">&quot;event()&quot;</span> documented above.
      The difference is that this produces two events, the one you specify, and
      a <span class="Li">&quot;Diag&quot;</span> after it. There are no extra
      checks in the Diag.
    <p class="Pp">Use this to validate a simple failure where you do not want to
        be bothered with the default diagnostics. It only adds a single Diag
        check, so if your failure has custom diagnostics you will need to add
        checks for them.</p>
  </dd>
</dl>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="SOURCE"><a class="permalink" href="#SOURCE">SOURCE</a></h1>
<p class="Pp">The source code repository for Test2-Suite can be found at
    <i>https://github.com/Test-More/Test2-Suite/</i>.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="MAINTAINERS"><a class="permalink" href="#MAINTAINERS">MAINTAINERS</a></h1>
<dl class="Bl-tag">
  <dt id="Chad"><a class="permalink" href="#Chad">Chad Granum
    &lt;exodist@cpan.org&gt;</a></dt>
  <dd></dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHORS"><a class="permalink" href="#AUTHORS">AUTHORS</a></h1>
<dl class="Bl-tag">
  <dt id="Chad~2"><a class="permalink" href="#Chad~2">Chad Granum
    &lt;exodist@cpan.org&gt;</a></dt>
  <dd></dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT"><a class="permalink" href="#COPYRIGHT">COPYRIGHT</a></h1>
<p class="Pp">Copyright 2018 Chad Granum &lt;exodist@cpan.org&gt;.</p>
<p class="Pp">This program is free software; you can redistribute it and/or
    modify it under the same terms as Perl itself.</p>
<p class="Pp">See <i>http://dev.perl.org/licenses/</i></p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2020-10-22</td>
    <td class="foot-os">perl v5.30.2</td>
  </tr>
</table>
</body>
</html>
