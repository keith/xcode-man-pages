<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Generated from file '/Library/Caches/com.apple.xbs/Sources/tcl/tcl-129.100.1/tcl_ext/tcllib/tcllib/modules/fileutil/fileutil.man' by tcllib/doctools with format 'nroff'
  
   The definitions below are for supplemental macros used in Tcl/Tk
   manual entries.
  
   .AP type name in/out ?indent?
  	Start paragraph describing an argument to a library procedure.
  	type is type of argument (int, etc.), in/out is either "in", "out",
  	or "in/out" to describe whether procedure reads or modifies arg,
  	and indent is equivalent to second arg of .IP (shouldn't ever be
  	needed;  use .AS below instead)
  
   .AS ?type? ?name?
  	Give maximum sizes of arguments for setting tab stops.  Type and
  	name are examples of largest possible arguments that will be passed
  	to .AP later.  If args are omitted, default tab stops are used.
  
   .BS
  	Start box enclosure.  From here until next .BE, everything will be
  	enclosed in one large box.
  
   .BE
  	End of box enclosure.
  
   .CS
  	Begin code excerpt.
  
   .CE
  	End code excerpt.
  
   .VS ?version? ?br?
  	Begin vertical sidebar, for use in marking newly-changed parts
  	of man pages.  The first argument is ignored and used for recording
  	the version when the .VS was added, so that the sidebars can be
  	found and removed when they reach a certain age.  If another argument
  	is present, then a line break is forced before starting the sidebar.
  
   .VE
  	End of vertical sidebar.
  
   .DS
  	Begin an indented unfilled display.
  
   .DE
  	End of indented unfilled display.
  
   .SO
  	Start of list of standard options for a Tk widget.  The
  	options follow on successive lines, in four columns separated
  	by tabs.
  
   .SE
  	End of list of standard options for a Tk widget.
  
   .OP cmdName dbName dbClass
  	Start of description of a specific option.  cmdName gives the
  	option's name as specified in the class command, dbName gives
  	the option's name in the option database, and dbClass gives
  	the option's class in the option database.
  
   .UL arg1 arg2
  	Print arg1 underlined, then print arg2 normally.
  
   RCS: @(#) $Id: man.macros,v 1.1 2009/01/30 04:56:47 andreas_kupries Exp $
  
  	# Set up traps and other miscellaneous stuff for Tcl/Tk man pages.
  	# Start an argument description
  .b
  	# define tabbing values for .AP
  
  	# BS - start boxed text
  	# ^y = starting y location
  	# ^b = 1
  	# BE - end boxed text (draw box now)
  	Draw four-sided box normally, but don't draw top of
  	box if the box started on an earlier page.
  	# VS - start vertical sidebar
  	# ^Y = starting y location
  	# ^v = 1 (for troff;  for nroff this doesn't matter)
  	# VE - end of vertical sidebar
  	# Special macro to handle page bottom:  finish off current
  	# box/sidebar if in box/sidebar mode, then invoked standard
  	# page bottom macro.
  	Draw three-sided box if this is the box's first page,
  	draw two sides but no top otherwise.
  	# DS - begin display
  	# DE - end display
  	# SO - start of list of standard options
  	# SE - end of list of standard options
  	# OP - start of full description for a single option
  	# CS - begin code excerpt
  	# CE - end code excerpt
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>fileutil(n)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">fileutil(n)</td>
    <td class="head-vol">file utilities</td>
    <td class="head-rtitle">fileutil(n)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<pre>

</pre>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
fileutil - Procedures implementing some file utilities
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
package require <b>Tcl 8</b>
<p class="Pp">package require <b>fileutil ?1.14.4?</b></p>
<p class="Pp"><b>::fileutil::lexnormalize</b> <i>path</i></p>
<p class="Pp"><b>::fileutil::fullnormalize</b> <i>path</i></p>
<p class="Pp"><b>::fileutil::test</b> <i>path</i> <i>codes</i> ?<i>msgvar</i>?
    ?<i>label</i>?</p>
<p class="Pp"><b>::fileutil::cat</b> (?<i>options</i>? <i>file</i>)...</p>
<p class="Pp"><b>::fileutil::writeFile</b> ?<i>options</i>? <i>file</i>
    <i>data</i></p>
<p class="Pp"><b>::fileutil::appendToFile</b> ?<i>options</i>? <i>file</i>
    <i>data</i></p>
<p class="Pp"><b>::fileutil::insertIntoFile</b> ?<i>options</i>? <i>file</i>
    <i>at</i> <i>data</i></p>
<p class="Pp"><b>::fileutil::removeFromFile</b> ?<i>options</i>? <i>file</i>
    <i>at</i> <i>n</i></p>
<p class="Pp"><b>::fileutil::replaceInFile</b> ?<i>options</i>? <i>file</i>
    <i>at</i> <i>n</i> <i>data</i></p>
<p class="Pp"><b>::fileutil::updateInPlace</b> ?<i>options</i>? <i>file</i>
    <i>cmd</i></p>
<p class="Pp"><b>::fileutil::fileType</b> <i>filename</i></p>
<p class="Pp"><b>::fileutil::find</b> ?<i>basedir</i> ?<i>filtercmd</i>??</p>
<p class="Pp"><b>::fileutil::findByPattern</b> <i>basedir</i>
    ?<b>-regexp</b>|<b>-glob</b>? ?<b>--</b>? <i>patterns</i></p>
<p class="Pp"><b>::fileutil::foreachLine</b> <i>var filename cmd</i></p>
<p class="Pp"><b>::fileutil::grep</b> <i>pattern</i> ?<i>files</i>?</p>
<p class="Pp"><b>::fileutil::install</b> ?<b>-m</b> <i>mode</i>? <i>source</i>
    <i>destination</i></p>
<p class="Pp"><b>::fileutil::stripN</b> <i>path</i> <i>n</i></p>
<p class="Pp"><b>::fileutil::stripPwd</b> <i>path</i></p>
<p class="Pp"><b>::fileutil::stripPath</b> <i>prefix</i> <i>path</i></p>
<p class="Pp"><b>::fileutil::jail</b> <i>jail</i> <i>path</i></p>
<p class="Pp"><b>::fileutil::touch</b> ?<b>-a</b>? ?<b>-c</b>? ?<b>-m</b>?
    ?<b>-r</b> <i>ref_file</i>? ?<b>-t</b> <i>time</i>? <i>filename</i>
    ?<i>...</i>?</p>
<p class="Pp"><b>::fileutil::tempdir</b></p>
<p class="Pp"><b>::fileutil::tempdir</b> <i>path</i></p>
<p class="Pp"><b>::fileutil::tempdirReset</b></p>
<p class="Pp"><b>::fileutil::tempfile</b> ?<i>prefix</i>?</p>
<p class="Pp"><b>::fileutil::relative</b> <i>base</i> <i>dst</i></p>
<p class="Pp"><b>::fileutil::relativeUrl</b> <i>base</i> <i>dst</i></p>
<p class="Pp"></p>
<pre>

</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
This package provides implementations of standard unix utilities.
<dl class="Bl-tag">
  <dt><b>::fileutil::lexnormalize</b> <i>path</i></dt>
  <dd>This command performs purely lexical normalization on the <i>path</i> and
      returns the changed path as its result. Symbolic links in the path are
      <i>not</i> resolved.
    <p class="Pp">Examples:</p>
    <pre>
    fileutil::lexnormalize /foo/./bar
    =&gt; /foo/bar
    fileutil::lexnormalize /foo/../bar
    =&gt; /bar
    </pre>
  </dd>
  <dt><b>::fileutil::fullnormalize</b> <i>path</i></dt>
  <dd>This command resolves all symbolic links in the <i>path</i> and returns
      the changed path as its result. In contrast to the builtin <b>file
      normalize</b> this command resolves a symbolic link in the last element of
      the path as well.</dd>
  <dt><b>::fileutil::test</b> <i>path</i> <i>codes</i> ?<i>msgvar</i>?
    ?<i>label</i>?</dt>
  <dd>A command for the testing of several properties of a <i>path</i>. The
      properties to test for are specified in <i>codes</i>, either as a list of
      keywords describing the properties, or as a string where each letter is a
      shorthand for a property to test. The recognized keywords, shorthands, and
      associated properties are shown in the list below. The tests are executed
      in the order given to the command.
    <p class="Pp">The result of the command is a boolean value. It will be true
        if and only if the <i>path</i> passes all the specified tests. In the
        case of the <i>path</i> not passing one or more test the first failing
        test will leave a message in the variable referenced by <i>msgvar</i>,
        if such is specified. The message will be prefixed with <i>label</i>, if
        it is specified. <i>Note</i> that the variabled referenced by
        <i>msgvar</i> is not touched at all if all the tests pass.</p>
    <p class="Pp"></p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><i>r</i>ead</dt>
  <dd><b>file readable</b></dd>
  <dt><i>w</i>rite</dt>
  <dd><b>file writable</b></dd>
  <dt><i>e</i>xists</dt>
  <dd><b>file exists</b></dd>
  <dt>e<i>x</i>ec</dt>
  <dd><b>file executable</b></dd>
  <dt><i>f</i>ile</dt>
  <dd><b>file isfile</b></dd>
  <dt><i>d</i>ir</dt>
  <dd><b>file isdirectory</b></dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt><b>::fileutil::cat</b> (?<i>options</i>? <i>file</i>)...</dt>
  <dd>A tcl implementation of the UNIX <b>cat</b> command. Returns the contents
      of the specified file(s). The arguments are files to read, with
      interspersed options configuring the process. If there are problems
      reading any of the files, an error will occur, and no data will be
      returned.
    <p class="Pp">The options accepted are <b>-encoding</b>,
        <b>-translation</b>, <b>-eofchar</b>, and <b>--</b>. With the exception
        of the last all options take a single value as argument, as specified by
        the tcl builtin command <b>fconfigure</b>. The <b>--</b> has to be used
        to terminate option processing before a file if that file's name begins
        with a dash.</p>
    <p class="Pp">Each file can have its own set of options coming before it,
        and for anything not specified directly the defaults are inherited from
        the options of the previous file. The first file inherits the system
        default for unspecified options.</p>
  </dd>
  <dt><b>::fileutil::writeFile</b> ?<i>options</i>? <i>file</i> <i>data</i></dt>
  <dd>The command replaces the current contents of the specified <i>file</i>
      with <i>data</i>, with the process configured by the options. The command
      accepts the same options as <b>::fileutil::cat</b>. The specification of a
      non-existent file is legal and causes the command to create the file (and
      all required but missing directories).</dd>
  <dt><b>::fileutil::appendToFile</b> ?<i>options</i>? <i>file</i>
    <i>data</i></dt>
  <dd>This command is like <b>::fileutil::writeFile</b>, except that the
      previous contents of <i>file</i> are not replaced, but appended to. The
      command accepts the same options as <b>::fileutil::cat</b></dd>
  <dt><b>::fileutil::insertIntoFile</b> ?<i>options</i>? <i>file</i> <i>at</i>
    <i>data</i></dt>
  <dd>This comment is similar to <b>::fileutil::appendToFile</b>, except that
      the new data is not appended at the end, but inserted at a specified
      location within the file. In further contrast this command has to be given
      the path to an existing file. It will not create a missing file, but throw
      an error instead.
    <p class="Pp">The specified location <i>at</i> has to be an integer number
        in the range <b>0</b> ... [file size <i>file</i>]. <b>0</b> will cause
        insertion of the new data before the first character of the existing
        content, whereas [file size <i>file</i>] causes insertion after the last
        character of the existing content, i.e. appending.</p>
    <p class="Pp">The command accepts the same options as
        <b>::fileutil::cat</b>.</p>
  </dd>
  <dt><b>::fileutil::removeFromFile</b> ?<i>options</i>? <i>file</i> <i>at</i>
    <i>n</i></dt>
  <dd>This command is the complement to <b>::fileutil::insertIntoFile</b>,
      removing <i>n</i> characters from the <i>file</i>, starting at location
      <i>at</i>. The specified location <i>at</i> has to be an integer number in
      the range <b>0</b> ... [file size <i>file</i>] - <i>n</i>. <b>0</b> will
      cause the removal of the new data to start with the first character of the
      existing content, whereas [file size <i>file</i>] - <i>n</i> causes the
      removal of the tail of the existing content, i.e. the truncation of the
      file.
    <p class="Pp">The command accepts the same options as
        <b>::fileutil::cat</b>.</p>
  </dd>
  <dt><b>::fileutil::replaceInFile</b> ?<i>options</i>? <i>file</i> <i>at</i>
    <i>n</i> <i>data</i></dt>
  <dd>This command is a combination of <b>::fileutil::removeFromFile</b> and
      <b>::fileutil::insertIntoFile</b>. It first removes the part of the
      contents specified by the arguments <i>at</i> and <i>n</i>, and then
      inserts <i>data</i> at the given location, effectively replacing the
      removed by content with <i>data</i>. All constraints imposed on <i>at</i>
      and <i>n</i> by <b>::fileutil::removeFromFile</b> and
      <b>::fileutil::insertIntoFile</b> are obeyed.
    <p class="Pp">The command accepts the same options as
        <b>::fileutil::cat</b>.</p>
  </dd>
  <dt><b>::fileutil::updateInPlace</b> ?<i>options</i>? <i>file</i>
    <i>cmd</i></dt>
  <dd>This command can be seen as the generic core functionality of
      <b>::fileutil::replaceInFile</b>. It first reads the contents of the
      specified <i>file</i>, then runs the command prefix <i>cmd</i> with that
      data appended to it, and at last writes the result of that invokation back
      as the new contents of the file.
    <p class="Pp">If the executed command throws an error the <i>file</i> is not
        changed.</p>
    <p class="Pp">The command accepts the same options as
        <b>::fileutil::cat</b>.</p>
  </dd>
  <dt><b>::fileutil::fileType</b> <i>filename</i></dt>
  <dd>An implementation of the UNIX <b>file</b> command, which uses various
      heuristics to guess the type of a file. Returns a list specifying as much
      type information as can be determined about the file, from most general
      (eg, &quot;binary&quot; or &quot;text&quot;) to most specific (eg,
      &quot;gif&quot;). For example, the return value for a GIF file would be
      &quot;binary graphic gif&quot;. The command will detect the following
      types of files: directory, empty, binary, text, script (with interpreter),
      executable elf, executable dos, executable ne, executable pe, graphic gif,
      graphic jpeg, graphic png, graphic tiff, graphic bitmap, html, xml (with
      doctype if available), message pgp, binary pdf, text ps, text eps, binary
      gravity_wave_data_frame, compressed bzip, compressed gzip, compressed zip,
      compressed tar, audio wave, audio mpeg, and link. It further detects
      doctools, doctoc, and docidx documentation files, and tklib diagrams.</dd>
  <dt><b>::fileutil::find</b> ?<i>basedir</i> ?<i>filtercmd</i>??</dt>
  <dd>An implementation of the unix command <b>find</b>. Adapted from the
      Tcler's Wiki. Takes at most two arguments, the path to the directory to
      start searching from and a command to use to evaluate interest in each
      file. The path defaults to &quot;<i>.</i>&quot;, i.e. the current
      directory. The command defaults to the empty string, which means that all
      files are of interest. The command takes care <i>not</i> to lose itself in
      infinite loops upon encountering circular link structures. The result of
      the command is a list containing the paths to the interesting files.
    <p class="Pp">The <i>filtercmd</i>, if specified, is interpreted as a
        command prefix and one argument is added to it, the name of the file or
        directory find is currently looking at. Note that this name is
        <i>not</i> fully qualified. It has to be joined it with the result of
        <b>pwd</b> to get an absolute filename.</p>
    <p class="Pp">The result of <i>filtercmd</i> is a boolean value that
        indicates if the current file should be included in the list of
        interesting files.</p>
    <p class="Pp">Example:</p>
    <p class="Pp"></p>
    <pre>
    # find .tcl files
    package require fileutil
    proc is_tcl {name} {return [string match *.tcl $name]}
    set tcl_files [fileutil::find . is_tcl]
    </pre>
  </dd>
  <dt><b>::fileutil::findByPattern</b> <i>basedir</i>
    ?<b>-regexp</b>|<b>-glob</b>? ?<b>--</b>? <i>patterns</i></dt>
  <dd>This command is based upon the <b>TclX</b> command <b>recursive_glob</b>,
      except that it doesn't allow recursion over more than one directory at a
      time. It uses <b>::fileutil::find</b> internally and is thus able to and
      does follow symbolic links, something the <b>TclX</b> command does not do.
      First argument is the directory to start the search in, second argument is
      a list of <i>patterns</i>. The command returns a list of all files
      reachable through <i>basedir</i> whose names match at least one of the
      patterns. The options before the pattern-list determine the style of
      matching, either regexp or glob. glob-style matching is the default if no
      options are given. Usage of the option <b>--</b> stops option processing.
      This allows the use of a leading '-' in the patterns.</dd>
  <dt><b>::fileutil::foreachLine</b> <i>var filename cmd</i></dt>
  <dd>The command reads the file <i>filename</i> and executes the script
      <i>cmd</i> for every line in the file. During the execution of the script
      the variable <i>var</i> is set to the contents of the current line. The
      return value of this command is the result of the last invocation of the
      script <i>cmd</i> or the empty string if the file was empty.</dd>
  <dt><b>::fileutil::grep</b> <i>pattern</i> ?<i>files</i>?</dt>
  <dd>Implementation of <b>grep</b>. Adapted from the Tcler's Wiki. The first
      argument defines the <i>pattern</i> to search for. This is followed by a
      list of <i>files</i> to search through. The list is optional and
      <b>stdin</b> will be used if it is missing. The result of the procedures
      is a list containing the matches. Each match is a single element of the
      list and contains filename, number and contents of the matching line,
      separated by a colons.</dd>
  <dt><b>::fileutil::install</b> ?<b>-m</b> <i>mode</i>? <i>source</i>
    <i>destination</i></dt>
  <dd>The <b>install</b> command is similar in functionality to the
      <b>install</b> command found on many unix systems, or the shell script
      distributed with many source distributions (unix/install-sh in the Tcl
      sources, for example). It copies <i>source</i>, which can be either a file
      or directory to <i>destination</i>, which should be a directory, unless
      <i>source</i> is also a single file. The ?-m? option lets the user specify
      a unix-style mode (either octal or symbolic - see <b>file
    attributes</b>.</dd>
  <dt><b>::fileutil::stripN</b> <i>path</i> <i>n</i></dt>
  <dd>Removes the first <i>n</i> elements from the specified <i>path</i> and
      returns the modified path. If <i>n</i> is greater than the number of
      components in <i>path</i> an empty string is returned. The number of
      components in a given path may be determined by performing <b>llength</b>
      on the list returned by <b>file split</b>.</dd>
  <dt><b>::fileutil::stripPwd</b> <i>path</i></dt>
  <dd>If, and only if the <i>path</i> is inside of the directory returned by
      [<b>pwd</b>] (or the current working directory itself) it is made relative
      to that directory. In other words, the current working directory is
      stripped from the <i>path</i>. The possibly modified path is returned as
      the result of the command. If the current working directory itself was
      specified for <i>path</i> the result is the string
    &quot;<b>.</b>&quot;.</dd>
  <dt><b>::fileutil::stripPath</b> <i>prefix</i> <i>path</i></dt>
  <dd>If, and only of the <i>path</i> is inside of the directory
      &quot;<i>prefix</i>&quot; (or the prefix directory itself) it is made
      relative to that directory. In other words, the prefix directory is
      stripped from the <i>path</i>. The possibly modified path is returned as
      the result of the command. If the prefix directory itself was specified
      for <i>path</i> the result is the string &quot;<b>.</b>&quot;.</dd>
  <dt><b>::fileutil::jail</b> <i>jail</i> <i>path</i></dt>
  <dd>This command ensures that the <i>path</i> is not escaping the directory
      <i>jail</i>. It always returns an absolute path derived from <i>path</i>
      which is within <i>jail</i>.
    <p class="Pp">If <i>path</i> is an absolute path and already within
        <i>jail</i> it is returned unmodified.</p>
    <p class="Pp">An absolute path outside of <i>jail</i> is stripped of its
        root element and then put into the <i>jail</i> by prefixing it with it.
        The same happens if <i>path</i> is relative, except that nothing is
        stripped of it. Before adding the <i>jail</i> prefix the <i>path</i> is
        lexically normalized to prevent the caller from using <b>..</b> segments
        in <i>path</i> to escape the jail.</p>
  </dd>
  <dt><b>::fileutil::touch</b> ?<b>-a</b>? ?<b>-c</b>? ?<b>-m</b>? ?<b>-r</b>
    <i>ref_file</i>? ?<b>-t</b> <i>time</i>? <i>filename</i> ?<i>...</i>?</dt>
  <dd>Implementation of <b>touch</b>. Alter the atime and mtime of the specified
      files. If <b>-c</b>, do not create files if they do not already exist. If
      <b>-r</b>, use the atime and mtime from <i>ref_file</i>. If <b>-t</b>, use
      the integer clock value <i>time</i>. It is illegal to specify both
      <b>-r</b> and <b>-t</b>. If <b>-a</b>, only change the atime. If
      <b>-m</b>, only change the mtime.
    <p class="Pp"><i>This command is not available for Tcl versions less than
        8.3.</i></p>
  </dd>
  <dt><b>::fileutil::tempdir</b></dt>
  <dd>The command returns the path of a directory where the caller can place
      temporary files, such as &quot;<i>/tmp</i>&quot; on Unix systems. The
      algorithm we use to find the correct directory is as follows:</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>[1]</dt>
  <dd>The directory set by an invokation of <b>::fileutil::tempdir</b> with an
      argument. If this is present it is tried exclusively and none of the
      following item are tried.</dd>
  <dt>[2]</dt>
  <dd>The directory named in the TMPDIR environment variable.</dd>
  <dt>[3]</dt>
  <dd>The directory named in the TEMP environment variable.</dd>
  <dt>[4]</dt>
  <dd>The directory named in the TMP environment variable.</dd>
  <dt>[5]</dt>
  <dd>A platform specific location:</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>Windows</dt>
  <dd>&quot;<i>C:\TEMP</i>&quot;, &quot;<i>C:\TMP</i>&quot;,
      &quot;<i>\TEMP</i>&quot;, and &quot;<i>\TMP</i>&quot; are tried in that
      order.</dd>
  <dt>(classic) Macintosh</dt>
  <dd>The TRASH_FOLDER environment variable is used. This is most likely not
      correct.</dd>
  <dt>Unix</dt>
  <dd>The directories &quot;<i>/tmp</i>&quot;, &quot;<i>/var/tmp</i>&quot;, and
      &quot;<i>/usr/tmp</i>&quot; are tried in that order.</dd>
</dl>
</div>
</div>
<p class="Pp">The algorithm utilized is mainly that used in the Python standard
    library. The exception is the first item, the ability to have the search
    overridden by a user-specified directory.</p>
<dl class="Bl-tag">
  <dt><b>::fileutil::tempdir</b> <i>path</i></dt>
  <dd>In this mode the command sets the <i>path</i> as the first and only
      directory to try as a temp. directory. See the previous item for the use
      of the set directory. The command returns the empty string.</dd>
  <dt><b>::fileutil::tempdirReset</b></dt>
  <dd>Invoking this command clears the information set by the last call of
      [<b>::fileutil::tempdir</b> <i>path</i>]. See the last item too.</dd>
  <dt><b>::fileutil::tempfile</b> ?<i>prefix</i>?</dt>
  <dd>The command generates a temporary file name suitable for writing to, and
      the associated file. The file name will be unique, and the file will be
      writable and contained in the appropriate system specific temp directory.
      The name of the file will be returned as the result of the command.
    <p class="Pp">The code was taken from <i>http://wiki.tcl.tk/772</i>,
        attributed to Igor Volobouev and anon.</p>
  </dd>
  <dt><b>::fileutil::relative</b> <i>base</i> <i>dst</i></dt>
  <dd>This command takes two directory paths, both either absolute or relative
      and computes the path of <i>dst</i> relative to <i>base</i>. This relative
      path is returned as the result of the command. As implied in the previous
      sentence, the command is not able to compute this relationship between the
      arguments if one of the paths is absolute and the other relative.
    <p class="Pp"><i>Note:</i> The processing done by this command is purely
        lexical. Symbolic links are <i>not</i> taken into account.</p>
  </dd>
  <dt><b>::fileutil::relativeUrl</b> <i>base</i> <i>dst</i></dt>
  <dd>This command takes two file paths, both either absolute or relative and
      computes the path of <i>dst</i> relative to <i>base</i>, as seen from
      inside of the <i>base</i>. This is the algorithm how a browser resolves a
      relative link found in the currently shown file.
    <p class="Pp">The computed relative path is returned as the result of the
        command. As implied in the previous sentence, the command is not able to
        compute this relationship between the arguments if one of the paths is
        absolute and the other relative.</p>
    <p class="Pp"><i>Note:</i> The processing done by this command is purely
        lexical. Symbolic links are <i>not</i> taken into account.</p>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="BUGS,_IDEAS,_FEEDBACK"><a class="permalink" href="#BUGS,_IDEAS,_FEEDBACK">BUGS,
  IDEAS, FEEDBACK</a></h1>
This document, and the package it describes, will undoubtedly contain bugs and
  other problems. Please report such in the category <i>fileutil</i> of the
  <i>Tcllib SF Trackers</i> [http://sourceforge.net/tracker/?group_id=12883].
  Please also report any ideas for enhancements you may have for either package
  and/or documentation.
</section>
<section class="Sh">
<h1 class="Sh" id="KEYWORDS"><a class="permalink" href="#KEYWORDS">KEYWORDS</a></h1>
cat, file utilities, grep, temp file, test, touch, type
</section>
<section class="Sh">
<h1 class="Sh" id="CATEGORY"><a class="permalink" href="#CATEGORY">CATEGORY</a></h1>
Programming tools
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">1.14.4</td>
    <td class="foot-os">fileutil</td>
  </tr>
</table>
</body>
</html>
