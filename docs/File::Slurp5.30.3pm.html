<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>File::Slurp(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">File::Slurp(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">File::Slurp(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
File::Slurp - Simple and Efficient Reading/Writing/Modifying of Complete Files
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<span class="Li"></span>
<pre>
  use File::Slurp;

  # read in a whole file into a scalar
  my $text = read_file('/path/file');

  # read in a whole file into an array of lines
  my @lines = read_file('/path/file');

  # write out a whole file from a scalar
  write_file('/path/file', $text);

  # write out a whole file from an array of lines
  write_file('/path/file', @lines);

  # Here is a simple and fast way to load and save a simple config file
  # made of key=value lines.
  my %conf = read_file('/path/file') =~ /^(\w+)=(.*)$/mg;
  write_file('/path/file', {atomic =&gt; 1}, map &quot;$_=$conf{$_}\n&quot;, keys %conf);

  # insert text at the beginning of a file
  prepend_file('/path/file', $text);

  # in-place edit to replace all 'foo' with 'bar' in file
  edit_file { s/foo/bar/g } '/path/file';

  # in-place edit to delete all lines with 'foo' from file
  edit_file_lines sub { $_ = '' if /foo/ }, '/path/file';

  # read in a whole directory of file names (skipping . and ..)
  my @files = read_dir('/path/to/dir');
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
This module provides subs that allow you to read or write entire files with one
  simple call. They are designed to be simple to use, have flexible ways to pass
  in or get the file contents and to be very efficient. There is also a sub to
  read in all the files in a directory.
<section class="Ss">
<h2 class="Ss" id="_s-1WARNING_s0__-__s-1PENDING_DOOM_s0"><a class="permalink" href="#_s-1WARNING_s0__-__s-1PENDING_DOOM_s0">WARNING
  - PENDING DOOM</a></h2>
Although you technically <i>can</i>, do NOT use this module to work on file
  handles, pipes, sockets, standard IO, or the
  <span class="Li">&quot;DATA&quot;</span> handle. These are features
  implemented long ago that just really shouldn't be abused here.
<p class="Pp">Be warned: this activity will lead to inaccurate encoding/decoding
    of data.</p>
<p class="Pp">All further mentions of actions on the above have been removed
    from this documentation and that feature set will likely be deprecated in
    the future.</p>
<p class="Pp">In other words, if you don't have a filename to pass, consider
    using the standard <span class="Li">&quot;do { local $/; &lt;$fh&gt;
    }&quot;</span>, or Data::Section/Data::Section::Simple for working with
    <span class="Li">&quot;__DATA__&quot;</span>.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="FUNCTIONS"><a class="permalink" href="#FUNCTIONS">FUNCTIONS</a></h1>
File::Slurp implements the following functions.
<section class="Ss">
<h2 class="Ss" id="append_file"><a class="permalink" href="#append_file">append_file</a></h2>
<span class="Li"></span>
<pre>
        use File::Slurp qw(append_file write_file);
        my $res = append_file('/path/file', &quot;Some text&quot;);
        # same as
        my $res = write_file('/path/file', {append =&gt; 1}, &quot;Some text&quot;);
</pre>
<p class="Pp">The <span class="Li">&quot;append_file&quot;</span> function is
    simply a synonym for the &quot;write_file&quot; in File::Slurp function, but
    ensures that the <span class="Li">&quot;append&quot;</span> option is
  set.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="edit_file"><a class="permalink" href="#edit_file">edit_file</a></h2>
<span class="Li"></span>
<pre>
        use File::Slurp qw(edit_file);
        # perl -0777 -pi -e 's/foo/bar/g' /path/file
        edit_file { s/foo/bar/g } '/path/file';
        edit_file sub { s/foo/bar/g }, '/path/file';
        sub replace_foo { s/foo/bar/g }
        edit_file \&amp;replace_foo, '/path/file';
</pre>
<p class="Pp">The <span class="Li">&quot;edit_file&quot;</span> function reads
    in a file into <span class="Li">$_</span>, executes a code block that should
    modify <span class="Li">$_</span>, and then writes
    <span class="Li">$_</span> back to the file. The
    <span class="Li">&quot;edit_file&quot;</span> function reads in the entire
    file and calls the code block one time. It is equivalent to the
    <span class="Li">&quot;-pi&quot;</span> command line options of Perl but you
    can call it from inside your program and not have to fork out a process.</p>
<p class="Pp">The first argument to
    <span class="Li">&quot;edit_file&quot;</span> is a code block or a code
    reference. The code block is not followed by a comma (as with
    <span class="Li">&quot;grep&quot;</span> and
    <span class="Li">&quot;map&quot;</span>) but a code reference is followed by
    a comma.</p>
<p class="Pp">The next argument is the filename.</p>
<p class="Pp">The next argument(s) is either a hash reference or a flattened
    hash, <span class="Li">&quot;key =&gt; value&quot;</span> pairs. The options
    are passed through to the &quot;write_file&quot; in File::Slurp function.
    All options are described there. Only the
    <span class="Li">&quot;binmode&quot;</span> and
    <span class="Li">&quot;err_mode&quot;</span> options are supported. The call
    to &quot;write_file&quot; in File::Slurp has the
    <span class="Li">&quot;atomic&quot;</span> option set so you will always
    have a consistent file.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="edit_file_lines"><a class="permalink" href="#edit_file_lines">edit_file_lines</a></h2>
<span class="Li"></span>
<pre>
        use File::Slurp qw(edit_file_lines);
        # perl -pi -e '$_ = &quot;&quot; if /foo/' /path/file
        edit_file_lines { $_ = '' if /foo/ } '/path/file';
        edit_file_lines sub { $_ = '' if /foo/ }, '/path/file';
        sub delete_foo { $_ = '' if /foo/ }
        edit_file \&amp;delete_foo, '/path/file';
</pre>
<p class="Pp">The <span class="Li">&quot;edit_file_lines&quot;</span> function
    reads each line of a file into <span class="Li">$_</span>, and executes a
    code block that should modify <span class="Li">$_</span>. It will then write
    <span class="Li">$_</span> back to the file. It is equivalent to the
    <span class="Li">&quot;-pi&quot;</span> command line options of Perl but you
    can call it from inside your program and not have to fork out a process.</p>
<p class="Pp">The first argument to
    <span class="Li">&quot;edit_file_lines&quot;</span> is a code block or a
    code reference. The code block is not followed by a comma (as with
    <span class="Li">&quot;grep&quot;</span> and
    <span class="Li">&quot;map&quot;</span>) but a code reference is followed by
    a comma.</p>
<p class="Pp">The next argument is the filename.</p>
<p class="Pp">The next argument(s) is either a hash reference or a flattened
    hash, <span class="Li">&quot;key =&gt; value&quot;</span> pairs. The options
    are passed through to the &quot;write_file&quot; in File::Slurp function.
    All options are described there. Only the
    <span class="Li">&quot;binmode&quot;</span> and
    <span class="Li">&quot;err_mode&quot;</span> options are supported. The call
    to &quot;write_file&quot; in File::Slurp has the
    <span class="Li">&quot;atomic&quot;</span> option set so you will always
    have a consistent file.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="ef"><a class="permalink" href="#ef">ef</a></h2>
<span class="Li"></span>
<pre>
        use File::Slurp qw(ef);
        # perl -0777 -pi -e 's/foo/bar/g' /path/file
        ef { s/foo/bar/g } '/path/file';
        ef sub { s/foo/bar/g }, '/path/file';
        sub replace_foo { s/foo/bar/g }
        ef \&amp;replace_foo, '/path/file';
</pre>
<p class="Pp">The <span class="Li">&quot;ef&quot;</span> function is simply a
    synonym for the &quot;edit_file&quot; in File::Slurp function.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="efl"><a class="permalink" href="#efl">efl</a></h2>
<span class="Li"></span>
<pre>
        use File::Slurp qw(efl);
        # perl -pi -e '$_ = &quot;&quot; if /foo/' /path/file
        efl { $_ = '' if /foo/ } '/path/file';
        efl sub { $_ = '' if /foo/ }, '/path/file';
        sub delete_foo { $_ = '' if /foo/ }
        efl \&amp;delete_foo, '/path/file';
</pre>
<p class="Pp">The <span class="Li">&quot;efl&quot;</span> function is simply a
    synonym for the &quot;edit_file_lines&quot; in File::Slurp function.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="overwrite_file"><a class="permalink" href="#overwrite_file">overwrite_file</a></h2>
<span class="Li"></span>
<pre>
        use File::Slurp qw(overwrite_file);
        my $res = overwrite_file('/path/file', &quot;Some text&quot;);
</pre>
<p class="Pp">The <span class="Li">&quot;overwrite_file&quot;</span> function is
    simply a synonym for the &quot;write_file&quot; in File::Slurp function.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="prepend_file"><a class="permalink" href="#prepend_file">prepend_file</a></h2>
<span class="Li"></span>
<pre>
        use File::Slurp qw(prepend_file);
        prepend_file('/path/file', $header);
        prepend_file('/path/file', \@lines);
        prepend_file('/path/file', { binmode =&gt; ':raw'}, $bin_data);

        # equivalent to:
        use File::Slurp qw(read_file write_file);
        my $content = read_file('/path/file');
        my $new_content = &quot;hahahaha&quot;;
        write_file('/path/file', $new_content . $content);
</pre>
<p class="Pp">The <span class="Li">&quot;prepend_file&quot;</span> function is
    the opposite of &quot;append_file&quot; in File::Slurp as it writes new
    contents to the beginning of the file instead of the end. It is a
    combination of &quot;read_file&quot; in File::Slurp and
    &quot;write_file&quot; in File::Slurp. It works by first using
    <span class="Li">&quot;read_file&quot;</span> to slurp in the file and then
    calling <span class="Li">&quot;write_file&quot;</span> with the new data and
    the existing file data.</p>
<p class="Pp">The first argument to
    <span class="Li">&quot;prepend_file&quot;</span> is the filename.</p>
<p class="Pp">The next argument(s) is either a hash reference or a flattened
    hash, <span class="Li">&quot;key =&gt; value&quot;</span> pairs. The options
    are passed through to the &quot;write_file&quot; in File::Slurp function.
    All options are described there.</p>
<p class="Pp">Only the <span class="Li">&quot;binmode&quot;</span> and
    <span class="Li">&quot;err_mode&quot;</span> options are supported. The
    <span class="Li">&quot;write_file&quot;</span> call has the
    <span class="Li">&quot;atomic&quot;</span> option set so you will always
    have a consistent file.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="read_dir"><a class="permalink" href="#read_dir">read_dir</a></h2>
<span class="Li"></span>
<pre>
        use File::Slurp qw(read_dir);
        my @files = read_dir('/path/to/dir');
        # all files, even the dots
        my @files = read_dir('/path/to/dir', keep_dot_dot =&gt; 1);
        # keep the full file path
        my @paths = read_dir('/path/to/dir', prefix =&gt; 1);
        # scalar context
        my $files_ref = read_dir('/path/to/dir');
</pre>
<p class="Pp">This function returns a list of the filenames in the supplied
    directory. In list context, an array is returned, in scalar context, an
    array reference is returned.</p>
<p class="Pp">The first argument is the path to the directory to read.</p>
<p class="Pp">The next argument(s) is either a hash reference or a flattened
    hash, <span class="Li">&quot;key =&gt; value&quot;</span> pairs. The
    following options are available:</p>
<ul class="Bl-bullet">
  <li>err_mode
    <p class="Pp">The <span class="Li">&quot;err_mode&quot;</span> option has
        three possible values: <span class="Li">&quot;quiet&quot;</span>,
        <span class="Li">&quot;carp&quot;</span>, or the default,
        <span class="Li">&quot;croak&quot;</span>. In
        <span class="Li">&quot;quiet&quot;</span> mode, all errors will be
        silent. In <span class="Li">&quot;carp&quot;</span> mode, all errors
        will be emitted as warnings. And, in
        <span class="Li">&quot;croak&quot;</span> mode, all errors will be
        emitted as exceptions. Take a look at Try::Tiny or Syntax::Keyword::Try
        to see how to catch exceptions.</p>
  </li>
  <li>keep_dot_dot
    <p class="Pp">The <span class="Li">&quot;keep_dot_dot&quot;</span> option is
        a boolean option, defaulted to false (<span class="Li">0</span>).
        Setting this option to true (<span class="Li">1</span>) will also return
        the <span class="Li">&quot;.&quot;</span> and
        <span class="Li">&quot;..&quot;</span> files that are removed from the
        file list by default.</p>
  </li>
  <li>prefix
    <p class="Pp">The <span class="Li">&quot;prefix&quot;</span> option is a
        boolean option, defaulted to false (<span class="Li">0</span>). Setting
        this option to true (<span class="Li">1</span>) add the directory as a
        prefix to the file. The directory and the filename are joined using
        <span class="Li">&quot;File::Spec-&gt;catfile()&quot;</span> to ensure
        the proper directory separator is used for your OS. See File::Spec.</p>
  </li>
</ul>
</section>
<section class="Ss">
<h2 class="Ss" id="read_file"><a class="permalink" href="#read_file">read_file</a></h2>
<span class="Li"></span>
<pre>
        use File::Slurp qw(read_file);
        my $text = read_file('/path/file');
        my $bin = read_file('/path/file', { binmode =&gt; ':raw' });
        my @lines = read_file('/path/file');
        my $lines_ref = read_file('/path/file', array_ref =&gt; 1);
        my $lines_ref = [ read_file('/path/file') ];

        # or we can read into a buffer:
        my $buffer;
        read_file('/path/file', buf_ref =&gt; \$buffer);

        # or we can set the block size for the read
        my $text_ref = read_file('/path/file', blk_size =&gt; 10_000_000, array_ref =&gt; 1);

        # or we can get a scalar reference
        my $text_ref = read_file('/path/file', scalar_ref =&gt; 1);
</pre>
<p class="Pp">This function reads in an entire file and returns its contents to
    the caller. In scalar context it returns the entire file as a single scalar.
    In list context it will return a list of lines (using the current value of
    <span class="Li">$/</span> as the separator, including support for paragraph
    mode when it is set to <span class="Li">''</span>).</p>
<p class="Pp">The first argument is the path to the file to be slurped in.</p>
<p class="Pp">The next argument(s) is either a hash reference or a flattened
    hash, <span class="Li">&quot;key =&gt; value&quot;</span> pairs. The
    following options are available:</p>
<ul class="Bl-bullet">
  <li>array_ref
    <p class="Pp">The <span class="Li">&quot;array_ref&quot;</span> option is a
        boolean option, defaulted to false (<span class="Li">0</span>). Setting
        this option to true (<span class="Li">1</span>) will only have relevance
        if the <span class="Li">&quot;read_file&quot;</span> function is called
        in scalar context. When true, the
        <span class="Li">&quot;read_file&quot;</span> function will return a
        reference to an array of the lines in the file.</p>
  </li>
  <li>binmode
    <p class="Pp">The <span class="Li">&quot;binmode&quot;</span> option is a
        string option, defaulted to empty (<span class="Li">''</span>). If you
        set the <span class="Li">&quot;binmode&quot;</span> option, then its
        value is passed to a call to <span class="Li">&quot;binmode&quot;</span>
        on the opened handle. You can use this to set the file to be read in
        binary mode, utf8, etc. See <span class="Li">&quot;perldoc -f
        binmode&quot;</span> for more.</p>
  </li>
  <li>blk_size
    <p class="Pp">You can use this option to set the block size used when
        slurping from an already open handle (like
        <span class="Li">&quot;\*STDIN&quot;</span>). It defaults to 1MB.</p>
  </li>
  <li>buf_ref
    <p class="Pp">The <span class="Li">&quot;buf_ref&quot;</span> option can be
        used in conjunction with any of the other options. You can use this
        option to pass in a scalar reference and the slurped file contents will
        be stored in the scalar. This saves an extra copy of the slurped file
        and can lower RAM usage vs returning the file. It is usually the fastest
        way to read a file into a scalar.</p>
  </li>
  <li>chomp
    <p class="Pp">The <span class="Li">&quot;chomp&quot;</span> option is a
        boolean option, defaulted to false (<span class="Li">0</span>). Setting
        this option to true (<span class="Li">1</span>) will cause each line to
        have its contents <span class="Li">&quot;chomp&quot;</span>ed. This
        option works in list context or in scalar context with the
        <span class="Li">&quot;array_ref&quot;</span> option.</p>
  </li>
  <li>err_mode
    <p class="Pp">The <span class="Li">&quot;err_mode&quot;</span> option has
        three possible values: <span class="Li">&quot;quiet&quot;</span>,
        <span class="Li">&quot;carp&quot;</span>, or the default,
        <span class="Li">&quot;croak&quot;</span>. In
        <span class="Li">&quot;quiet&quot;</span> mode, all errors will be
        silent. In <span class="Li">&quot;carp&quot;</span> mode, all errors
        will be emitted as warnings. And, in
        <span class="Li">&quot;croak&quot;</span> mode, all errors will be
        emitted as exceptions. Take a look at Try::Tiny or Syntax::Keyword::Try
        to see how to catch exceptions.</p>
  </li>
  <li>scalar_ref
    <p class="Pp">The <span class="Li">&quot;scalar_ref&quot;</span> option is a
        boolean option, defaulted to false (<span class="Li">0</span>). It only
        has meaning in scalar context. The return value will be a scalar
        reference to a string which is the contents of the slurped file. This
        will usually be faster than returning the plain scalar. It will also
        save memory as it will not make a copy of the file to return.</p>
  </li>
</ul>
</section>
<section class="Ss">
<h2 class="Ss" id="rf"><a class="permalink" href="#rf">rf</a></h2>
<span class="Li"></span>
<pre>
        use File::Slurp qw(rf);
        my $text = rf('/path/file');
</pre>
<p class="Pp">The <span class="Li">&quot;rf&quot;</span> function is simply a
    synonym for the &quot;read_file&quot; in File::Slurp function.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="slurp"><a class="permalink" href="#slurp">slurp</a></h2>
<span class="Li"></span>
<pre>
        use File::Slurp qw(slurp);
        my $text = slurp('/path/file');
</pre>
<p class="Pp">The <span class="Li">&quot;slurp&quot;</span> function is simply a
    synonym for the &quot;read_file&quot; in File::Slurp function.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="wf"><a class="permalink" href="#wf">wf</a></h2>
<span class="Li"></span>
<pre>
        use File::Slurp qw(wf);
        my $res = wf('/path/file', &quot;Some text&quot;);
</pre>
<p class="Pp">The <span class="Li">&quot;wf&quot;</span> function is simply a
    synonym for the &quot;write_file&quot; in File::Slurp function.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="write_file"><a class="permalink" href="#write_file">write_file</a></h2>
<span class="Li"></span>
<pre>
        use File::Slurp qw(write_file);
        write_file('/path/file', @data);
        write_file('/path/file', {append =&gt; 1}, @data);
        write_file('/path/file', {binmode =&gt; ':raw'}, $buffer);
        write_file('/path/file', \$buffer);
        write_file('/path/file', $buffer);
        write_file('/path/file', \@lines);
        write_file('/path/file', @lines);

        # binmode
        write_file('/path/file', {binmode =&gt; ':raw'}, @data);
        write_file('/path/file', {binmode =&gt; ':utf8'}, $utf_text);

        # buffered
        write_file('/path/file', {buf_ref =&gt; \$buffer});
        write_file('/path/file', \$buffer);
        write_file('/path/file', $buffer);

        # append
        write_file('/path/file', {append =&gt; 1}, @data);

        # no clobbering
        write_file('/path/file', {no_clobber =&gt; 1}, @data);
</pre>
<p class="Pp">This function writes out an entire file in one call. By default
    <span class="Li">&quot;write_file&quot;</span> returns
    <span class="Li">1</span> upon successfully writing the file or
    <span class="Li">&quot;undef&quot;</span> if it encountered an error. You
    can change how errors are handled with the
    <span class="Li">&quot;err_mode&quot;</span> option.</p>
<p class="Pp">The first argument to
    <span class="Li">&quot;write_file&quot;</span> is the filename.</p>
<p class="Pp">The next argument(s) is either a hash reference or a flattened
    hash, <span class="Li">&quot;key =&gt; value&quot;</span> pairs. The
    following options are available:</p>
<ul class="Bl-bullet">
  <li>append
    <p class="Pp">The <span class="Li">&quot;append&quot;</span> option is a
        boolean option, defaulted to false (<span class="Li">0</span>). Setting
        this option to true (<span class="Li">1</span>) will cause the data to
        be be written at the end of the current file. Internally this sets the
        <span class="Li">&quot;sysopen&quot;</span> mode flag
        <span class="Li">&quot;O_APPEND&quot;</span>.</p>
    <p class="Pp">The &quot;append_file&quot; in File::Slurp function sets this
        option by default.</p>
  </li>
  <li>atomic
    <p class="Pp">The <span class="Li">&quot;atomic&quot;</span> option is a
        boolean option, defaulted to false (<span class="Li">0</span>). Setting
        this option to true (<span class="Li">1</span>) will cause the file to
        be be written to in an atomic fashion. A temporary file name is created
        using &quot;tempfile&quot; in File::Temp. After the file is closed it is
        renamed to the original file name (and
        <span class="Li">&quot;rename&quot;</span> is an atomic operation on
        most OSes). If the program using this were to crash in the middle of
        this, then the temporary file could be left behind.</p>
  </li>
  <li>binmode
    <p class="Pp">The <span class="Li">&quot;binmode&quot;</span> option is a
        string option, defaulted to empty (<span class="Li">''</span>). If you
        set the <span class="Li">&quot;binmode&quot;</span> option, then its
        value is passed to a call to <span class="Li">&quot;binmode&quot;</span>
        on the opened handle. You can use this to set the file to be read in
        binary mode, utf8, etc. See <span class="Li">&quot;perldoc -f
        binmode&quot;</span> for more.</p>
  </li>
  <li>buf_ref
    <p class="Pp">The <span class="Li">&quot;buf_ref&quot;</span> option is used
        to pass in a scalar reference which has the data to be written. If this
        is set then any data arguments (including the scalar reference shortcut)
        in <span class="Li">@_</span> will be ignored.</p>
  </li>
  <li>err_mode
    <p class="Pp">The <span class="Li">&quot;err_mode&quot;</span> option has
        three possible values: <span class="Li">&quot;quiet&quot;</span>,
        <span class="Li">&quot;carp&quot;</span>, or the default,
        <span class="Li">&quot;croak&quot;</span>. In
        <span class="Li">&quot;quiet&quot;</span> mode, all errors will be
        silent. In <span class="Li">&quot;carp&quot;</span> mode, all errors
        will be emitted as warnings. And, in
        <span class="Li">&quot;croak&quot;</span> mode, all errors will be
        emitted as exceptions. Take a look at Try::Tiny or Syntax::Keyword::Try
        to see how to catch exceptions.</p>
  </li>
  <li>no_clobber
    <p class="Pp">The <span class="Li">&quot;no_clobber&quot;</span> option is a
        boolean option, defaulted to false (<span class="Li">0</span>). Setting
        this option to true (<span class="Li">1</span>) will ensure an that
        existing file will not be overwritten.</p>
  </li>
  <li>perms
    <p class="Pp">The <span class="Li">&quot;perms&quot;</span> option sets the
        permissions of newly-created files. This value is modified by your
        process's <span class="Li">&quot;umask&quot;</span> and defaults to
        <span class="Li">0666</span> (same as
        <span class="Li">&quot;sysopen&quot;</span>).</p>
    <p class="Pp">NOTE: this option is new as of File::Slurp version
      9999.14.</p>
  </li>
</ul>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="EXPORT"><a class="permalink" href="#EXPORT">EXPORT</a></h1>
These are exported by default or with
<p class="Pp"><span class="Li"></span></p>
<pre>
        use File::Slurp qw(:std);
        # read_file write_file overwrite_file append_file read_dir
</pre>
<p class="Pp">These are exported with</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
        use File::Slurp qw(:edit);
        # edit_file edit_file_lines
</pre>
<p class="Pp">You can get all subs in the module exported with</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
        use File::Slurp qw(:all);
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
Uri Guttman, &lt;<i>uri@stemsystems.com</i>&gt;
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT_&amp;_LICENSE"><a class="permalink" href="#COPYRIGHT_&amp;_LICENSE">COPYRIGHT
  &amp; LICENSE</a></h1>
Copyright (c) 2003 Uri Guttman. All rights reserved.
<p class="Pp">This program is free software; you can redistribute it and/or
    modify it under the same terms as Perl itself.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2020-03-09</td>
    <td class="foot-os">perl v5.30.2</td>
  </tr>
</table>
</body>
</html>
