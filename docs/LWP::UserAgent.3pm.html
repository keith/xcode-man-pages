<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.10 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>LWP::UserAgent(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">LWP::UserAgent(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">LWP::UserAgent(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
LWP::UserAgent - Web user agent class
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<span class="Li"></span>
<pre>
    use strict;
    use warnings;

    use LWP::UserAgent ();

    my $ua = LWP::UserAgent-&gt;new(timeout =&gt; 10);
    $ua-&gt;env_proxy;

    my $response = $ua-&gt;get('http://example.com');

    if ($response-&gt;is_success) {
        print $response-&gt;decoded_content;
    }
    else {
        die $response-&gt;status_line;
    }
</pre>
<p class="Pp">Extra layers of security (note the
    <span class="Li">&quot;cookie_jar&quot;</span> and
    <span class="Li">&quot;protocols_allowed&quot;</span>):</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    use strict;
    use warnings;

    use HTTP::CookieJar::LWP ();
    use LWP::UserAgent       ();

    my $jar = HTTP::CookieJar::LWP-&gt;new;
    my $ua  = LWP::UserAgent-&gt;new(
        cookie_jar        =&gt; $jar,
        protocols_allowed =&gt; ['http', 'https'],
        timeout           =&gt; 10,
    );

    $ua-&gt;env_proxy;

    my $response = $ua-&gt;get('http://example.com');

    if ($response-&gt;is_success) {
        print $response-&gt;decoded_content;
    }
    else {
        die $response-&gt;status_line;
    }
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
The LWP::UserAgent is a class implementing a web user agent. LWP::UserAgent
  objects can be used to dispatch web requests.
<p class="Pp">In normal use the application creates an LWP::UserAgent object,
    and then configures it with values for timeouts, proxies, name, etc. It then
    creates an instance of HTTP::Request for the request that needs to be
    performed. This request is then passed to one of the request method the
    UserAgent, which dispatches it using the relevant protocol, and returns a
    HTTP::Response object. There are convenience methods for sending the most
    common request types: &quot;get&quot; in LWP::UserAgent, &quot;head&quot; in
    LWP::UserAgent, &quot;post&quot; in LWP::UserAgent, &quot;put&quot; in
    LWP::UserAgent and &quot;delete&quot; in LWP::UserAgent. When using these
    methods, the creation of the request object is hidden as shown in the
    synopsis above.</p>
<p class="Pp">The basic approach of the library is to use HTTP-style
    communication for all protocol schemes. This means that you will construct
    HTTP::Request objects and receive HTTP::Response objects even for non-HTTP
    resources like <i>gopher</i> and <i>ftp</i>. In order to achieve even more
    similarity to HTTP-style communications, <i>gopher</i> menus and file
    directories are converted to HTML documents.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="CONSTRUCTOR_METHODS"><a class="permalink" href="#CONSTRUCTOR_METHODS">CONSTRUCTOR
  METHODS</a></h1>
The following constructor methods are available:
<section class="Ss">
<h2 class="Ss" id="clone"><a class="permalink" href="#clone">clone</a></h2>
<span class="Li"></span>
<pre>
    my $ua2 = $ua-&gt;clone;
</pre>
<p class="Pp">Returns a copy of the LWP::UserAgent object.</p>
<p class="Pp"><b>CAVEAT</b>: Please be aware that the clone method does not copy
    or clone your <span class="Li">&quot;cookie_jar&quot;</span> attribute. Due
    to the limited restrictions on what can be used for your cookie jar, there
    is no way to clone the attribute. The
    <span class="Li">&quot;cookie_jar&quot;</span> attribute will be
    <span class="Li">&quot;undef&quot;</span> in the new object instance.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="new"><a class="permalink" href="#new">new</a></h2>
<span class="Li"></span>
<pre>
    my $ua = LWP::UserAgent-&gt;new( %options )
</pre>
<p class="Pp">This method constructs a new LWP::UserAgent object and returns it.
    Key/value pair arguments may be provided to set up the initial state. The
    following options correspond to attribute methods described below:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
   KEY                     DEFAULT
   -----------             --------------------
   agent                   &quot;libwww-perl/#.###&quot;
   from                    undef
   conn_cache              undef
   cookie_jar              undef
   default_headers         HTTP::Headers-&gt;new
   local_address           undef
   ssl_opts                { verify_hostname =&gt; 1 }
   max_size                undef
   max_redirect            7
   parse_head              1
   protocols_allowed       undef
   protocols_forbidden     undef
   requests_redirectable   ['GET', 'HEAD']
   timeout                 180
   proxy                   undef
   no_proxy                []
</pre>
<p class="Pp">The following additional options are also accepted: If the
    <span class="Li">&quot;env_proxy&quot;</span> option is passed in with a
    true value, then proxy settings are read from environment variables (see
    &quot;env_proxy&quot; in LWP::UserAgent). If
    <span class="Li">&quot;env_proxy&quot;</span> isn't provided, the
    <span class="Li">&quot;PERL_LWP_ENV_PROXY&quot;</span> environment variable
    controls if &quot;env_proxy&quot; in LWP::UserAgent is called during
    initialization. If the <span class="Li">&quot;keep_alive&quot;</span> option
    value is defined and non-zero, then an
    <span class="Li">&quot;LWP::ConnCache&quot;</span> is set up (see
    &quot;conn_cache&quot; in LWP::UserAgent). The
    <span class="Li">&quot;keep_alive&quot;</span> value is passed on as the
    <span class="Li">&quot;total_capacity&quot;</span> for the connection
  cache.</p>
<p class="Pp"><span class="Li">&quot;proxy&quot;</span> must be set as an
    arrayref of key/value pairs. <span class="Li">&quot;no_proxy&quot;</span>
    takes an arrayref of domains.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="ATTRIBUTES"><a class="permalink" href="#ATTRIBUTES">ATTRIBUTES</a></h1>
The settings of the configuration attributes modify the behaviour of the
  LWP::UserAgent when it dispatches requests. Most of these can also be
  initialized by options passed to the constructor method.
<p class="Pp">The following attribute methods are provided. The attribute value
    is left unchanged if no argument is given. The return value from each method
    is the old attribute value.</p>
<section class="Ss">
<h2 class="Ss" id="agent"><a class="permalink" href="#agent">agent</a></h2>
<span class="Li"></span>
<pre>
    my $agent = $ua-&gt;agent;
    $ua-&gt;agent('Checkbot/0.4 ');    # append the default to the end
    $ua-&gt;agent('Mozilla/5.0');
    $ua-&gt;agent(&quot;&quot;);                 # don't identify
</pre>
<p class="Pp">Get/set the product token that is used to identify the user agent
    on the network. The agent value is sent as the
    <span class="Li">&quot;User-Agent&quot;</span> header in the requests.</p>
<p class="Pp">The default is a string of the form
    <span class="Li">&quot;libwww-perl/#.###&quot;</span>, where
    <span class="Li">&quot;#.###&quot;</span> is substituted with the version
    number of this library.</p>
<p class="Pp">If the provided string ends with space, the default
    <span class="Li">&quot;libwww-perl/#.###&quot;</span> string is appended to
    it.</p>
<p class="Pp">The user agent string should be one or more simple product
    identifiers with an optional version number separated by the
    <span class="Li">&quot;/&quot;</span> character.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="conn_cache"><a class="permalink" href="#conn_cache">conn_cache</a></h2>
<span class="Li"></span>
<pre>
    my $cache_obj = $ua-&gt;conn_cache;
    $ua-&gt;conn_cache( $cache_obj );
</pre>
<p class="Pp">Get/set the LWP::ConnCache object to use. See LWP::ConnCache for
    details.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="cookie_jar"><a class="permalink" href="#cookie_jar">cookie_jar</a></h2>
<span class="Li"></span>
<pre>
    my $jar = $ua-&gt;cookie_jar;
    $ua-&gt;cookie_jar( $cookie_jar_obj );
</pre>
<p class="Pp">Get/set the cookie jar object to use. The only requirement is that
    the cookie jar object must implement the
    <span class="Li">&quot;extract_cookies($response)&quot;</span> and
    <span class="Li">&quot;add_cookie_header($request)&quot;</span> methods.
    These methods will then be invoked by the user agent as requests are sent
    and responses are received. Normally this will be a HTTP::Cookies object or
    some subclass. You are, however, encouraged to use HTTP::CookieJar::LWP
    instead. See &quot;BEST PRACTICES&quot; for more information.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    use HTTP::CookieJar::LWP ();

    my $jar = HTTP::CookieJar::LWP-&gt;new;
    my $ua = LWP::UserAgent-&gt;new( cookie_jar =&gt; $jar );

    # or after object creation
    $ua-&gt;cookie_jar( $cookie_jar );
</pre>
<p class="Pp">The default is to have no cookie jar, i.e. never automatically add
    <span class="Li">&quot;Cookie&quot;</span> headers to the requests.</p>
<p class="Pp">Shortcut: If a reference to a plain hash is passed in, it is
    replaced with an instance of HTTP::Cookies that is initialized based on the
    hash. This form also automatically loads the HTTP::Cookies module. It means
    that:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  $ua-&gt;cookie_jar({ file =&gt; &quot;$ENV{HOME}/.cookies.txt&quot; });
</pre>
<p class="Pp">is really just a shortcut for:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  require HTTP::Cookies;
  $ua-&gt;cookie_jar(HTTP::Cookies-&gt;new(file =&gt; &quot;$ENV{HOME}/.cookies.txt&quot;));
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="credentials"><a class="permalink" href="#credentials">credentials</a></h2>
<span class="Li"></span>
<pre>
    my $creds = $ua-&gt;credentials();
    $ua-&gt;credentials( $netloc, $realm );
    $ua-&gt;credentials( $netloc, $realm, $uname, $pass );
    $ua-&gt;credentials(&quot;www.example.com:80&quot;, &quot;Some Realm&quot;, &quot;foo&quot;, &quot;secret&quot;);
</pre>
<p class="Pp">Get/set the user name and password to be used for a realm.</p>
<p class="Pp">The <span class="Li">$netloc</span> is a string of the form
    <span class="Li">&quot;&lt;host&gt;:&lt;port&gt;&quot;</span>. The username
    and password will only be passed to this server.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="default_header"><a class="permalink" href="#default_header">default_header</a></h2>
<span class="Li"></span>
<pre>
    $ua-&gt;default_header( $field );
    $ua-&gt;default_header( $field =&gt; $value );
    $ua-&gt;default_header('Accept-Encoding' =&gt; scalar HTTP::Message::decodable());
    $ua-&gt;default_header('Accept-Language' =&gt; &quot;no, en&quot;);
</pre>
<p class="Pp">This is just a shortcut for
    <span class="Li">&quot;$ua-&gt;default_headers-&gt;header( $field =&gt;
    $value )&quot;</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="default_headers"><a class="permalink" href="#default_headers">default_headers</a></h2>
<span class="Li"></span>
<pre>
    my $headers = $ua-&gt;default_headers;
    $ua-&gt;default_headers( $headers_obj );
</pre>
<p class="Pp">Get/set the headers object that will provide default header values
    for any requests sent. By default this will be an empty HTTP::Headers
    object.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="from"><a class="permalink" href="#from">from</a></h2>
<span class="Li"></span>
<pre>
    my $from = $ua-&gt;from;
    $ua-&gt;from('foo@bar.com');
</pre>
<p class="Pp">Get/set the email address for the human user who controls the
    requesting user agent. The address should be machine-usable, as defined in
    RFC2822 &lt;https://tools.ietf.org/html/rfc2822&gt;. The
    <span class="Li">&quot;from&quot;</span> value is sent as the
    <span class="Li">&quot;From&quot;</span> header in the requests.</p>
<p class="Pp">The default is to not send a
    <span class="Li">&quot;From&quot;</span> header. See
    &quot;default_headers&quot; in LWP::UserAgent for the more general interface
    that allow any header to be defaulted.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="local_address"><a class="permalink" href="#local_address">local_address</a></h2>
<span class="Li"></span>
<pre>
    my $address = $ua-&gt;local_address;
    $ua-&gt;local_address( $address );
</pre>
<p class="Pp">Get/set the local interface to bind to for network connections.
    The interface can be specified as a hostname or an IP address. This value is
    passed as the <span class="Li">&quot;LocalAddr&quot;</span> argument to
    IO::Socket::INET.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="max_redirect"><a class="permalink" href="#max_redirect">max_redirect</a></h2>
<span class="Li"></span>
<pre>
    my $max = $ua-&gt;max_redirect;
    $ua-&gt;max_redirect( $n );
</pre>
<p class="Pp">This reads or sets the object's limit of how many times it will
    obey redirection responses in a given request cycle.</p>
<p class="Pp">By default, the value is <span class="Li">7</span>. This means
    that if you call &quot;request&quot; in LWP::UserAgent and the response is a
    redirect elsewhere which is in turn a redirect, and so on seven times, then
    LWP gives up after that seventh request.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="max_size"><a class="permalink" href="#max_size">max_size</a></h2>
<span class="Li"></span>
<pre>
    my $size = $ua-&gt;max_size;
    $ua-&gt;max_size( $bytes );
</pre>
<p class="Pp">Get/set the size limit for response content. The default is
    <span class="Li">&quot;undef&quot;</span>, which means that there is no
    limit. If the returned response content is only partial, because the size
    limit was exceeded, then a
    <span class="Li">&quot;Client-Aborted&quot;</span> header will be added to
    the response. The content might end up longer than
    <span class="Li">&quot;max_size&quot;</span> as we abort once appending a
    chunk of data makes the length exceed the limit. The
    <span class="Li">&quot;Content-Length&quot;</span> header, if present, will
    indicate the length of the full content and will normally not be the same as
    <span class="Li">&quot;length($res-&gt;content)&quot;</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="parse_head"><a class="permalink" href="#parse_head">parse_head</a></h2>
<span class="Li"></span>
<pre>
    my $bool = $ua-&gt;parse_head;
    $ua-&gt;parse_head( $boolean );
</pre>
<p class="Pp">Get/set a value indicating whether we should initialize response
    headers from the &lt;head&gt; section of HTML documents. The default is
    true. <i>Do not turn this off</i> unless you know what you are doing.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="protocols_allowed"><a class="permalink" href="#protocols_allowed">protocols_allowed</a></h2>
<span class="Li"></span>
<pre>
    my $aref = $ua-&gt;protocols_allowed;      # get allowed protocols
    $ua-&gt;protocols_allowed( \@protocols );  # allow ONLY these
    $ua-&gt;protocols_allowed(undef);          # delete the list
    $ua-&gt;protocols_allowed(['http',]);      # ONLY allow http
</pre>
<p class="Pp">By default, an object has neither a
    <span class="Li">&quot;protocols_allowed&quot;</span> list, nor a
    &quot;protocols_forbidden&quot; in LWP::UserAgent list.</p>
<p class="Pp">This reads (or sets) this user agent's list of protocols that the
    request methods will exclusively allow. The protocol names are case
    insensitive.</p>
<p class="Pp">For example: <span class="Li">&quot;$ua-&gt;protocols_allowed( [
    'http', 'https'] );&quot;</span> means that this user agent will <i>allow
    only</i> those protocols, and attempts to use this user agent to access URLs
    with any other schemes (like <span class="Li">&quot;ftp://...&quot;</span>)
    will result in a 500 error.</p>
<p class="Pp">Note that having a
    <span class="Li">&quot;protocols_allowed&quot;</span> list causes any
    &quot;protocols_forbidden&quot; in LWP::UserAgent list to be ignored.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="protocols_forbidden"><a class="permalink" href="#protocols_forbidden">protocols_forbidden</a></h2>
<span class="Li"></span>
<pre>
    my $aref = $ua-&gt;protocols_forbidden;    # get the forbidden list
    $ua-&gt;protocols_forbidden(\@protocols);  # do not allow these
    $ua-&gt;protocols_forbidden(['http',]);    # All http reqs get a 500
    $ua-&gt;protocols_forbidden(undef);        # delete the list
</pre>
<p class="Pp">This reads (or sets) this user agent's list of protocols that the
    request method will <i>not</i> allow. The protocol names are case
    insensitive.</p>
<p class="Pp">For example: <span class="Li">&quot;$ua-&gt;protocols_forbidden( [
    'file', 'mailto'] );&quot;</span> means that this user agent will <i>not</i>
    allow those protocols, and attempts to use this user agent to access URLs
    with those schemes will result in a 500 error.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="requests_redirectable"><a class="permalink" href="#requests_redirectable">requests_redirectable</a></h2>
<span class="Li"></span>
<pre>
    my $aref = $ua-&gt;requests_redirectable;
    $ua-&gt;requests_redirectable( \@requests );
    $ua-&gt;requests_redirectable(['GET', 'HEAD',]); # the default
</pre>
<p class="Pp">This reads or sets the object's list of request names that
    &quot;redirect_ok&quot; in LWP::UserAgent will allow redirection for. By
    default, this is <span class="Li">&quot;['GET', 'HEAD']&quot;</span>, as per
    RFC 2616 &lt;https://tools.ietf.org/html/rfc2616&gt;. To change to include
    <span class="Li">&quot;POST&quot;</span>, consider:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
   push @{ $ua-&gt;requests_redirectable }, 'POST';
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="send_te"><a class="permalink" href="#send_te">send_te</a></h2>
<span class="Li"></span>
<pre>
    my $bool = $ua-&gt;send_te;
    $ua-&gt;send_te( $boolean );
</pre>
<p class="Pp">If true, will send a <span class="Li">&quot;TE&quot;</span> header
    along with the request. The default is true. Set it to false to disable the
    <span class="Li">&quot;TE&quot;</span> header for systems who can't handle
    it.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="show_progress"><a class="permalink" href="#show_progress">show_progress</a></h2>
<span class="Li"></span>
<pre>
    my $bool = $ua-&gt;show_progress;
    $ua-&gt;show_progress( $boolean );
</pre>
<p class="Pp">Get/set a value indicating whether a progress bar should be
    displayed on the terminal as requests are processed. The default is
  false.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="ssl_opts"><a class="permalink" href="#ssl_opts">ssl_opts</a></h2>
<span class="Li"></span>
<pre>
    my @keys = $ua-&gt;ssl_opts;
    my $val = $ua-&gt;ssl_opts( $key );
    $ua-&gt;ssl_opts( $key =&gt; $value );
</pre>
<p class="Pp">Get/set the options for SSL connections. Without argument return
    the list of options keys currently set. With a single argument return the
    current value for the given option. With 2 arguments set the option value
    and return the old. Setting an option to the value
    <span class="Li">&quot;undef&quot;</span> removes this option.</p>
<p class="Pp">The options that LWP relates to are:</p>
<dl class="Bl-tag">
  <dt>&quot;verify_hostname&quot; =&gt; $bool</dt>
  <dd>When TRUE LWP will for secure protocol schemes ensure it connects to
      servers that have a valid certificate matching the expected hostname. If
      FALSE no checks are made and you can't be sure that you communicate with
      the expected peer. The no checks behaviour was the default for
      libwww-perl-5.837 and earlier releases.
    <p class="Pp">This option is initialized from the
        <span class="Li">&quot;PERL_LWP_SSL_VERIFY_HOSTNAME&quot;</span>
        environment variable. If this environment variable isn't set; then
        <span class="Li">&quot;verify_hostname&quot;</span> defaults to 1.</p>
  </dd>
  <dt>&quot;SSL_ca_file&quot; =&gt; $path</dt>
  <dd>The path to a file containing Certificate Authority certificates. A
      default setting for this option is provided by checking the environment
      variables <span class="Li">&quot;PERL_LWP_SSL_CA_FILE&quot;</span> and
      <span class="Li">&quot;HTTPS_CA_FILE&quot;</span> in order.</dd>
  <dt>&quot;SSL_ca_path&quot; =&gt; $path</dt>
  <dd>The path to a directory containing files containing Certificate Authority
      certificates. A default setting for this option is provided by checking
      the environment variables
      <span class="Li">&quot;PERL_LWP_SSL_CA_PATH&quot;</span> and
      <span class="Li">&quot;HTTPS_CA_DIR&quot;</span> in order.</dd>
</dl>
<p class="Pp">Other options can be set and are processed directly by the SSL
    Socket implementation in use. See IO::Socket::SSL or Net::SSL for
  details.</p>
<p class="Pp">The libwww-perl core no longer bundles protocol plugins for SSL.
    You will need to install LWP::Protocol::https separately to enable support
    for processing https-URLs.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="timeout"><a class="permalink" href="#timeout">timeout</a></h2>
<span class="Li"></span>
<pre>
    my $secs = $ua-&gt;timeout;
    $ua-&gt;timeout( $secs );
</pre>
<p class="Pp">Get/set the timeout value in seconds. The default value is 180
    seconds, i.e. 3 minutes.</p>
<p class="Pp">The request is aborted if no activity on the connection to the
    server is observed for <span class="Li">&quot;timeout&quot;</span> seconds.
    This means that the time it takes for the complete transaction and the
    &quot;request&quot; in LWP::UserAgent method to actually return might be
    longer.</p>
<p class="Pp">When a request times out, a response object is still returned. The
    response will have a standard HTTP Status Code (500). This response will
    have the &quot;Client-Warning&quot; header set to the value of
    &quot;Internal response&quot;. See the &quot;get&quot; in LWP::UserAgent
    method description below for further details.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="PROXY_ATTRIBUTES"><a class="permalink" href="#PROXY_ATTRIBUTES">PROXY
  ATTRIBUTES</a></h1>
The following methods set up when requests should be passed via a proxy server.
<section class="Ss">
<h2 class="Ss" id="env_proxy"><a class="permalink" href="#env_proxy">env_proxy</a></h2>
<span class="Li"></span>
<pre>
    $ua-&gt;env_proxy;
</pre>
<p class="Pp">Load proxy settings from <span class="Li">*_proxy</span>
    environment variables. You might specify proxies like this (sh-syntax):</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  gopher_proxy=http://proxy.my.place/
  wais_proxy=http://proxy.my.place/
  no_proxy=&quot;localhost,example.com&quot;
  export gopher_proxy wais_proxy no_proxy
</pre>
<p class="Pp">csh or tcsh users should use the
    <span class="Li">&quot;setenv&quot;</span> command to define these
    environment variables.</p>
<p class="Pp">On systems with case insensitive environment variables there
    exists a name clash between the CGI environment variables and the
    <span class="Li">&quot;HTTP_PROXY&quot;</span> environment variable normally
    picked up by <span class="Li">&quot;env_proxy&quot;</span>. Because of this
    <span class="Li">&quot;HTTP_PROXY&quot;</span> is not honored for CGI
    scripts. The <span class="Li">&quot;CGI_HTTP_PROXY&quot;</span> environment
    variable can be used instead.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="no_proxy"><a class="permalink" href="#no_proxy">no_proxy</a></h2>
<span class="Li"></span>
<pre>
    $ua-&gt;no_proxy( @domains );
    $ua-&gt;no_proxy('localhost', 'example.com');
    $ua-&gt;no_proxy(); # clear the list
</pre>
<p class="Pp">Do not proxy requests to the given domains. Calling
    <span class="Li">&quot;no_proxy&quot;</span> without any domains clears the
    list of domains.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="proxy"><a class="permalink" href="#proxy">proxy</a></h2>
<span class="Li"></span>
<pre>
    $ua-&gt;proxy(\@schemes, $proxy_url)
    $ua-&gt;proxy(['http', 'ftp'], 'http://proxy.sn.no:8001/');

    # For a single scheme:
    $ua-&gt;proxy($scheme, $proxy_url)
    $ua-&gt;proxy('gopher', 'http://proxy.sn.no:8001/');

    # To set multiple proxies at once:
    $ua-&gt;proxy([
        ftp =&gt; 'http://ftp.example.com:8001/',
        [ 'http', 'https' ] =&gt; 'http://http.example.com:8001/',
    ]);
</pre>
<p class="Pp">Set/retrieve proxy URL for a scheme.</p>
<p class="Pp">The first form specifies that the URL is to be used as a proxy for
    access methods listed in the list in the first method argument, i.e.
    <span class="Li">&quot;http&quot;</span> and
    <span class="Li">&quot;ftp&quot;</span>.</p>
<p class="Pp">The second form shows a shorthand form for specifying proxy URL
    for a single access scheme.</p>
<p class="Pp">The third form demonstrates setting multiple proxies at once. This
    is also the only form accepted by the constructor.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="HANDLERS"><a class="permalink" href="#HANDLERS">HANDLERS</a></h1>
Handlers are code that injected at various phases during the processing of
  requests. The following methods are provided to manage the active handlers:
<section class="Ss">
<h2 class="Ss" id="add_handler"><a class="permalink" href="#add_handler">add_handler</a></h2>
<span class="Li"></span>
<pre>
    $ua-&gt;add_handler( $phase =&gt; \&amp;cb, %matchspec )
</pre>
<p class="Pp">Add handler to be invoked in the given processing phase. For how
    to specify <span class="Li">%matchspec</span> see &quot;Matching&quot; in
    HTTP::Config.</p>
<p class="Pp">The possible values <span class="Li">$phase</span> and the
    corresponding callback signatures are as follows. Note that the handlers are
    documented in the order in which they will be run, which is:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    request_preprepare
    request_prepare
    request_send
    response_header
    response_data
    response_done
    response_redirect
</pre>
<dl class="Bl-tag">
  <dt>request_preprepare =&gt; sub { my($request, $ua, $handler) = @_; ...
    }</dt>
  <dd>The handler is called before the
      <span class="Li">&quot;request_prepare&quot;</span> and other standard
      initialization of the request. This can be used to set up headers and
      attributes that the <span class="Li">&quot;request_prepare&quot;</span>
      handler depends on. Proxy initialization should take place here; but in
      general don't register handlers for this phase.</dd>
  <dt>request_prepare =&gt; sub { my($request, $ua, $handler) = @_; ... }</dt>
  <dd>The handler is called before the request is sent and can modify the
      request any way it see fit. This can for instance be used to add certain
      headers to specific requests.
    <p class="Pp">The method can assign a new request object to
        <span class="Li">$_[0]</span> to replace the request that is sent
      fully.</p>
    <p class="Pp">The return value from the callback is ignored. If an exception
        is raised it will abort the request and make the request method return a
        &quot;400 Bad request&quot; response.</p>
  </dd>
  <dt>request_send =&gt; sub { my($request, $ua, $handler) = @_; ... }</dt>
  <dd>This handler gets a chance of handling requests before they're sent to the
      protocol handlers. It should return an HTTP::Response object if it wishes
      to terminate the processing; otherwise it should return nothing.
    <p class="Pp">The <span class="Li">&quot;response_header&quot;</span> and
        <span class="Li">&quot;response_data&quot;</span> handlers will not be
        invoked for this response, but the
        <span class="Li">&quot;response_done&quot;</span> will be.</p>
  </dd>
  <dt>response_header =&gt; sub { my($response, $ua, $handler) = @_; ... }</dt>
  <dd>This handler is called right after the response headers have been
      received, but before any content data. The handler might set up handlers
      for data and might croak to abort the request.
    <p class="Pp">The handler might set the
        <span class="Li">&quot;$response-&gt;{default_add_content}&quot;</span>
        value to control if any received data should be added to the response
        object directly. This will initially be false if the
        <span class="Li">&quot;$ua-&gt;request()&quot;</span> method was called
        with a <span class="Li">$content_file</span> or
        <span class="Li">&quot;$content_cb argument&quot;</span>; otherwise
        true.</p>
  </dd>
  <dt>response_data =&gt; sub { my($response, $ua, $handler, $data) = @_; ...
    }</dt>
  <dd>This handler is called for each chunk of data received for the response.
      The handler might croak to abort the request.
    <p class="Pp">This handler needs to return a TRUE value to be called again
        for subsequent chunks for the same request.</p>
  </dd>
  <dt>response_done =&gt; sub { my($response, $ua, $handler) = @_; ... }</dt>
  <dd>The handler is called after the response has been fully received, but
      before any redirect handling is attempted. The handler can be used to
      extract information or modify the response.</dd>
  <dt>response_redirect =&gt; sub { my($response, $ua, $handler) = @_; ...
    }</dt>
  <dd>The handler is called in
      <span class="Li">&quot;$ua-&gt;request&quot;</span> after
      <span class="Li">&quot;response_done&quot;</span>. If the handler returns
      an HTTP::Request object we'll start over with processing this request
      instead.</dd>
</dl>
<p class="Pp">For all of these, <span class="Li">$handler</span> is a code
    reference to the handler that is currently being run.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="get_my_handler"><a class="permalink" href="#get_my_handler">get_my_handler</a></h2>
<span class="Li"></span>
<pre>
    $ua-&gt;get_my_handler( $phase, %matchspec );
    $ua-&gt;get_my_handler( $phase, %matchspec, $init );
</pre>
<p class="Pp">Will retrieve the matching handler as hash ref.</p>
<p class="Pp">If <span class="Li">$init</span> is passed as a true value, create
    and add the handler if it's not found. If <span class="Li">$init</span> is a
    subroutine reference, then it's called with the created handler hash as
    argument. This sub might populate the hash with extra fields; especially the
    callback. If <span class="Li">$init</span> is a hash reference, merge the
    hashes.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="handlers"><a class="permalink" href="#handlers">handlers</a></h2>
<span class="Li"></span>
<pre>
    $ua-&gt;handlers( $phase, $request )
    $ua-&gt;handlers( $phase, $response )
</pre>
<p class="Pp">Returns the handlers that apply to the given request or response
    at the given processing phase.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="remove_handler"><a class="permalink" href="#remove_handler">remove_handler</a></h2>
<span class="Li"></span>
<pre>
    $ua-&gt;remove_handler( undef, %matchspec );
    $ua-&gt;remove_handler( $phase, %matchspec );
    $ua-&gt;remove_handler(); # REMOVE ALL HANDLERS IN ALL PHASES
</pre>
<p class="Pp">Remove handlers that match the given
    <span class="Li">%matchspec</span>. If <span class="Li">$phase</span> is not
    provided, remove handlers from all phases.</p>
<p class="Pp">Be careful as calling this function with
    <span class="Li">%matchspec</span> that is not specific enough can remove
    handlers not owned by you. It's probably better to use the
    &quot;set_my_handler&quot; in LWP::UserAgent method instead.</p>
<p class="Pp">The removed handlers are returned.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="set_my_handler"><a class="permalink" href="#set_my_handler">set_my_handler</a></h2>
<span class="Li"></span>
<pre>
    $ua-&gt;set_my_handler( $phase, $cb, %matchspec );
    $ua-&gt;set_my_handler($phase, undef); # remove handler for phase
</pre>
<p class="Pp">Set handlers private to the executing subroutine. Works by
    defaulting an <span class="Li">&quot;owner&quot;</span> field to the
    <span class="Li">%matchspec</span> that holds the name of the called
    subroutine. You might pass an explicit
    <span class="Li">&quot;owner&quot;</span> to override this.</p>
<p class="Pp">If <span class="Li">$cb</span> is passed as
    <span class="Li">&quot;undef&quot;</span>, remove the handler.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="REQUEST_METHODS"><a class="permalink" href="#REQUEST_METHODS">REQUEST
  METHODS</a></h1>
The methods described in this section are used to dispatch requests via the user
  agent. The following request methods are provided:
<section class="Ss">
<h2 class="Ss" id="delete"><a class="permalink" href="#delete">delete</a></h2>
<span class="Li"></span>
<pre>
    my $res = $ua-&gt;delete( $url );
    my $res = $ua-&gt;delete( $url, $field_name =&gt; $value, ... );
</pre>
<p class="Pp">This method will dispatch a
    <span class="Li">&quot;DELETE&quot;</span> request on the given URL.
    Additional headers and content options are the same as for the
    &quot;get&quot; in LWP::UserAgent method.</p>
<p class="Pp">This method will use the <b>DELETE()</b> function from
    HTTP::Request::Common to build the request. See HTTP::Request::Common for a
    details on how to pass form content and other advanced features.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="get"><a class="permalink" href="#get">get</a></h2>
<span class="Li"></span>
<pre>
    my $res = $ua-&gt;get( $url );
    my $res = $ua-&gt;get( $url , $field_name =&gt; $value, ... );
</pre>
<p class="Pp">This method will dispatch a
    <span class="Li">&quot;GET&quot;</span> request on the given URL. Further
    arguments can be given to initialize the headers of the request. These are
    given as separate name/value pairs. The return value is a response object.
    See HTTP::Response for a description of the interface it provides.</p>
<p class="Pp">There will still be a response object returned when LWP can't
    connect to the server specified in the URL or when other failures in
    protocol handlers occur. These internal responses use the standard HTTP
    status codes, so the responses can't be differentiated by testing the
    response status code alone. Error responses that LWP generates internally
    will have the &quot;Client-Warning&quot; header set to the value
    &quot;Internal response&quot;. If you need to differentiate these internal
    responses from responses that a remote server actually generates, you need
    to test this header value.</p>
<p class="Pp">Fields names that start with &quot;:&quot; are special. These will
    not initialize headers of the request but will determine how the response
    content is treated. The following special field names are recognized:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    ':content_file'   =&gt; $filename
    ':content_cb'     =&gt; \&amp;callback
    ':read_size_hint' =&gt; $bytes
</pre>
<p class="Pp">If a <span class="Li">$filename</span> is provided with the
    <span class="Li">&quot;:content_file&quot;</span> option, then the response
    content will be saved here instead of in the response object. If a callback
    is provided with the <span class="Li">&quot;:content_cb&quot;</span> option
    then this function will be called for each chunk of the response content as
    it is received from the server. If neither of these options are given, then
    the response content will accumulate in the response object itself. This
    might not be suitable for very large response bodies. Only one of
    <span class="Li">&quot;:content_file&quot;</span> or
    <span class="Li">&quot;:content_cb&quot;</span> can be specified. The
    content of unsuccessful responses will always accumulate in the response
    object itself, regardless of the
    <span class="Li">&quot;:content_file&quot;</span> or
    <span class="Li">&quot;:content_cb&quot;</span> options passed in. Note that
    errors writing to the content file (for example due to permission denied or
    the filesystem being full) will be reported via the
    <span class="Li">&quot;Client-Aborted&quot;</span> or
    <span class="Li">&quot;X-Died&quot;</span> response headers, and not the
    <span class="Li">&quot;is_success&quot;</span> method.</p>
<p class="Pp">The <span class="Li">&quot;:read_size_hint&quot;</span> option is
    passed to the protocol module which will try to read data from the server in
    chunks of this size. A smaller value for the
    <span class="Li">&quot;:read_size_hint&quot;</span> will result in a higher
    number of callback invocations.</p>
<p class="Pp">The callback function is called with 3 arguments: a chunk of data,
    a reference to the response object, and a reference to the protocol object.
    The callback can abort the request by invoking <b>die()</b>. The exception
    message will show up as the &quot;X-Died&quot; header field in the response
    returned by the <b>get()</b> function.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="head"><a class="permalink" href="#head">head</a></h2>
<span class="Li"></span>
<pre>
    my $res = $ua-&gt;head( $url );
    my $res = $ua-&gt;head( $url , $field_name =&gt; $value, ... );
</pre>
<p class="Pp">This method will dispatch a
    <span class="Li">&quot;HEAD&quot;</span> request on the given URL. Otherwise
    it works like the &quot;get&quot; in LWP::UserAgent method described
  above.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="is_protocol_supported"><a class="permalink" href="#is_protocol_supported">is_protocol_supported</a></h2>
<span class="Li"></span>
<pre>
    my $bool = $ua-&gt;is_protocol_supported( $scheme );
</pre>
<p class="Pp">You can use this method to test whether this user agent object
    supports the specified <span class="Li">&quot;scheme&quot;</span>. (The
    <span class="Li">&quot;scheme&quot;</span> might be a string (like
    <span class="Li">&quot;http&quot;</span> or
    <span class="Li">&quot;ftp&quot;</span>) or it might be an URI object
    reference.)</p>
<p class="Pp">Whether a scheme is supported is determined by the user agent's
    <span class="Li">&quot;protocols_allowed&quot;</span> or
    <span class="Li">&quot;protocols_forbidden&quot;</span> lists (if any), and
    by the capabilities of LWP. I.e., this will return true only if LWP supports
    this protocol <i>and</i> it's permitted for this particular object.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="is_online"><a class="permalink" href="#is_online">is_online</a></h2>
<span class="Li"></span>
<pre>
    my $bool = $ua-&gt;is_online;
</pre>
<p class="Pp">Tries to determine if you have access to the Internet. Returns
    <span class="Li">1</span> (true) if the built-in heuristics determine that
    the user agent is able to access the Internet (over HTTP) or
    <span class="Li">0</span> (false).</p>
<p class="Pp">See also LWP::Online.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="mirror"><a class="permalink" href="#mirror">mirror</a></h2>
<span class="Li"></span>
<pre>
    my $res = $ua-&gt;mirror( $url, $filename );
</pre>
<p class="Pp">This method will get the document identified by URL and store it
    in file called <span class="Li">$filename</span>. If the file already
    exists, then the request will contain an
    <span class="Li">&quot;If-Modified-Since&quot;</span> header matching the
    modification time of the file. If the document on the server has not changed
    since this time, then nothing happens. If the document has been updated, it
    will be downloaded again. The modification time of the file will be forced
    to match that of the server.</p>
<p class="Pp">The return value is an HTTP::Response object.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="patch"><a class="permalink" href="#patch">patch</a></h2>
<span class="Li"></span>
<pre>
    # Any version of HTTP::Message works with this form:
    my $res = $ua-&gt;patch( $url, $field_name =&gt; $value, Content =&gt; $content );

    # Using hash or array references requires HTTP::Message &gt;= 6.12
    use HTTP::Request 6.12;
    my $res = $ua-&gt;patch( $url, \%form );
    my $res = $ua-&gt;patch( $url, \@form );
    my $res = $ua-&gt;patch( $url, \%form, $field_name =&gt; $value, ... );
    my $res = $ua-&gt;patch( $url, $field_name =&gt; $value, Content =&gt; \%form );
    my $res = $ua-&gt;patch( $url, $field_name =&gt; $value, Content =&gt; \@form );
</pre>
<p class="Pp">This method will dispatch a
    <span class="Li">&quot;PATCH&quot;</span> request on the given URL, with
    <span class="Li">%form</span> or <span class="Li">@form</span> providing the
    key/value pairs for the fill-in form content. Additional headers and content
    options are the same as for the &quot;get&quot; in LWP::UserAgent
  method.</p>
<p class="Pp">CAVEAT:</p>
<p class="Pp">This method can only accept content that is in key-value pairs
    when using HTTP::Request::Common prior to version
    <span class="Li">6.12</span>. Any use of hash or array references will
    result in an error prior to version <span class="Li">6.12</span>.</p>
<p class="Pp">This method will use the <span class="Li">&quot;PATCH&quot;</span>
    function from HTTP::Request::Common to build the request. See
    HTTP::Request::Common for a details on how to pass form content and other
    advanced features.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="post"><a class="permalink" href="#post">post</a></h2>
<span class="Li"></span>
<pre>
    my $res = $ua-&gt;post( $url, \%form );
    my $res = $ua-&gt;post( $url, \@form );
    my $res = $ua-&gt;post( $url, \%form, $field_name =&gt; $value, ... );
    my $res = $ua-&gt;post( $url, $field_name =&gt; $value, Content =&gt; \%form );
    my $res = $ua-&gt;post( $url, $field_name =&gt; $value, Content =&gt; \@form );
    my $res = $ua-&gt;post( $url, $field_name =&gt; $value, Content =&gt; $content );
</pre>
<p class="Pp">This method will dispatch a
    <span class="Li">&quot;POST&quot;</span> request on the given URL, with
    <span class="Li">%form</span> or <span class="Li">@form</span> providing the
    key/value pairs for the fill-in form content. Additional headers and content
    options are the same as for the &quot;get&quot; in LWP::UserAgent
  method.</p>
<p class="Pp">This method will use the <span class="Li">&quot;POST&quot;</span>
    function from HTTP::Request::Common to build the request. See
    HTTP::Request::Common for a details on how to pass form content and other
    advanced features.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="put"><a class="permalink" href="#put">put</a></h2>
<span class="Li"></span>
<pre>
    # Any version of HTTP::Message works with this form:
    my $res = $ua-&gt;put( $url, $field_name =&gt; $value, Content =&gt; $content );

    # Using hash or array references requires HTTP::Message &gt;= 6.07
    use HTTP::Request 6.07;
    my $res = $ua-&gt;put( $url, \%form );
    my $res = $ua-&gt;put( $url, \@form );
    my $res = $ua-&gt;put( $url, \%form, $field_name =&gt; $value, ... );
    my $res = $ua-&gt;put( $url, $field_name =&gt; $value, Content =&gt; \%form );
    my $res = $ua-&gt;put( $url, $field_name =&gt; $value, Content =&gt; \@form );
</pre>
<p class="Pp">This method will dispatch a
    <span class="Li">&quot;PUT&quot;</span> request on the given URL, with
    <span class="Li">%form</span> or <span class="Li">@form</span> providing the
    key/value pairs for the fill-in form content. Additional headers and content
    options are the same as for the &quot;get&quot; in LWP::UserAgent
  method.</p>
<p class="Pp">CAVEAT:</p>
<p class="Pp">This method can only accept content that is in key-value pairs
    when using HTTP::Request::Common prior to version
    <span class="Li">6.07</span>. Any use of hash or array references will
    result in an error prior to version <span class="Li">6.07</span>.</p>
<p class="Pp">This method will use the <span class="Li">&quot;PUT&quot;</span>
    function from HTTP::Request::Common to build the request. See
    HTTP::Request::Common for a details on how to pass form content and other
    advanced features.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="request"><a class="permalink" href="#request">request</a></h2>
<span class="Li"></span>
<pre>
    my $res = $ua-&gt;request( $request );
    my $res = $ua-&gt;request( $request, $content_file );
    my $res = $ua-&gt;request( $request, $content_cb );
    my $res = $ua-&gt;request( $request, $content_cb, $read_size_hint );
</pre>
<p class="Pp">This method will dispatch the given
    <span class="Li">$request</span> object. Normally this will be an instance
    of the HTTP::Request class, but any object with a similar interface will do.
    The return value is an HTTP::Response object.</p>
<p class="Pp">The <span class="Li">&quot;request&quot;</span> method will
    process redirects and authentication responses transparently. This means
    that it may actually send several simple requests via the
    &quot;simple_request&quot; in LWP::UserAgent method described below.</p>
<p class="Pp">The request methods described above; &quot;get&quot; in
    LWP::UserAgent, &quot;head&quot; in LWP::UserAgent, &quot;post&quot; in
    LWP::UserAgent and &quot;mirror&quot; in LWP::UserAgent will all dispatch
    the request they build via this method. They are convenience methods that
    simply hide the creation of the request object for you.</p>
<p class="Pp">The <span class="Li">$content_file</span>,
    <span class="Li">$content_cb</span> and
    <span class="Li">$read_size_hint</span> all correspond to options described
    with the &quot;get&quot; in LWP::UserAgent method above. Note that errors
    writing to the content file (for example due to permission denied or the
    filesystem being full) will be reported via the
    <span class="Li">&quot;Client-Aborted&quot;</span> or
    <span class="Li">&quot;X-Died&quot;</span> response headers, and not the
    <span class="Li">&quot;is_success&quot;</span> method.</p>
<p class="Pp">You are allowed to use a CODE reference as
    <span class="Li">&quot;content&quot;</span> in the request object passed in.
    The <span class="Li">&quot;content&quot;</span> function should return the
    content when called. The content can be returned in chunks. The content
    function will be invoked repeatedly until it return an empty string to
    signal that there is no more content.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="simple_request"><a class="permalink" href="#simple_request">simple_request</a></h2>
<span class="Li"></span>
<pre>
    my $request = HTTP::Request-&gt;new( ... );
    my $res = $ua-&gt;simple_request( $request );
    my $res = $ua-&gt;simple_request( $request, $content_file );
    my $res = $ua-&gt;simple_request( $request, $content_cb );
    my $res = $ua-&gt;simple_request( $request, $content_cb, $read_size_hint );
</pre>
<p class="Pp">This method dispatches a single request and returns the response
    received. Arguments are the same as for the &quot;request&quot; in
    LWP::UserAgent described above.</p>
<p class="Pp">The difference from &quot;request&quot; in LWP::UserAgent is that
    <span class="Li">&quot;simple_request&quot;</span> will not try to handle
    redirects or authentication responses. The &quot;request&quot; in
    LWP::UserAgent method will, in fact, invoke this method for each simple
    request it sends.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="CALLBACK_METHODS"><a class="permalink" href="#CALLBACK_METHODS">CALLBACK
  METHODS</a></h1>
The following methods will be invoked as requests are processed. These methods
  are documented here because subclasses of LWP::UserAgent might want to
  override their behaviour.
<section class="Ss">
<h2 class="Ss" id="get_basic_credentials"><a class="permalink" href="#get_basic_credentials">get_basic_credentials</a></h2>
<span class="Li"></span>
<pre>
    # This checks wantarray and can either return an array:
    my ($user, $pass) = $ua-&gt;get_basic_credentials( $realm, $uri, $isproxy );
    # or a string that looks like &quot;user:pass&quot;
    my $creds = $ua-&gt;get_basic_credentials($realm, $uri, $isproxy);
</pre>
<p class="Pp">This is called by &quot;request&quot; in LWP::UserAgent to
    retrieve credentials for documents protected by Basic or Digest
    Authentication. The arguments passed in is the
    <span class="Li">$realm</span> provided by the server, the
    <span class="Li">$uri</span> requested and a <span class="Li">&quot;boolean
    flag&quot;</span> to indicate if this is authentication against a proxy
    server.</p>
<p class="Pp">The method should return a username and password. It should return
    an empty list to abort the authentication resolution attempt. Subclasses can
    override this method to prompt the user for the information. An example of
    this can be found in <span class="Li">&quot;lwp-request&quot;</span> program
    distributed with this library.</p>
<p class="Pp">The base implementation simply checks a set of pre-stored member
    variables, set up with the &quot;credentials&quot; in LWP::UserAgent
  method.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="prepare_request"><a class="permalink" href="#prepare_request">prepare_request</a></h2>
<span class="Li"></span>
<pre>
    $request = $ua-&gt;prepare_request( $request );
</pre>
<p class="Pp">This method is invoked by &quot;simple_request&quot; in
    LWP::UserAgent. Its task is to modify the given
    <span class="Li">$request</span> object by setting up various headers based
    on the attributes of the user agent. The return value should normally be the
    <span class="Li">$request</span> object passed in. If a different request
    object is returned it will be the one actually processed.</p>
<p class="Pp">The headers affected by the base implementation are;
    <span class="Li">&quot;User-Agent&quot;</span>,
    <span class="Li">&quot;From&quot;</span>,
    <span class="Li">&quot;Range&quot;</span> and
    <span class="Li">&quot;Cookie&quot;</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="progress"><a class="permalink" href="#progress">progress</a></h2>
<span class="Li"></span>
<pre>
    my $prog = $ua-&gt;progress( $status, $request_or_response );
</pre>
<p class="Pp">This is called frequently as the response is received regardless
    of how the content is processed. The method is called with
    <span class="Li">$status</span> &quot;begin&quot; at the start of processing
    the request and with <span class="Li">$state</span> &quot;end&quot; before
    the request method returns. In between these <span class="Li">$status</span>
    will be the fraction of the response currently received or the string
    &quot;tick&quot; if the fraction can't be calculated.</p>
<p class="Pp">When <span class="Li">$status</span> is &quot;begin&quot; the
    second argument is the HTTP::Request object, otherwise it is the
    HTTP::Response object.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="redirect_ok"><a class="permalink" href="#redirect_ok">redirect_ok</a></h2>
<span class="Li"></span>
<pre>
    my $bool = $ua-&gt;redirect_ok( $prospective_request, $response );
</pre>
<p class="Pp">This method is called by &quot;request&quot; in LWP::UserAgent
    before it tries to follow a redirection to the request in
    <span class="Li">$response</span>. This should return a true value if this
    redirection is permissible. The <span class="Li">$prospective_request</span>
    will be the request to be sent if this method returns true.</p>
<p class="Pp">The base implementation will return false unless the method is in
    the object's <span class="Li">&quot;requests_redirectable&quot;</span> list,
    false if the proposed redirection is to a
    <span class="Li">&quot;file://...&quot;</span> URL, and true otherwise.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="BEST_PRACTICES"><a class="permalink" href="#BEST_PRACTICES">BEST
  PRACTICES</a></h1>
The default settings can get you up and running quickly, but there are settings
  you can change in order to make your life easier.
<section class="Ss">
<h2 class="Ss" id="Handling_Cookies"><a class="permalink" href="#Handling_Cookies">Handling
  Cookies</a></h2>
You are encouraged to install Mozilla::PublicSuffix and use HTTP::CookieJar::LWP
  as your cookie jar. HTTP::CookieJar::LWP provides a better security model
  matching that of current Web browsers when Mozilla::PublicSuffix is installed.
<p class="Pp"><span class="Li"></span></p>
<pre>
    use HTTP::CookieJar::LWP ();

    my $jar = HTTP::CookieJar::LWP-&gt;new;
    my $ua = LWP::UserAgent-&gt;new( cookie_jar =&gt; $jar );
</pre>
<p class="Pp">See &quot;cookie_jar&quot; for more information.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Managing_Protocols"><a class="permalink" href="#Managing_Protocols">Managing
  Protocols</a></h2>
<span class="Li">&quot;protocols_allowed&quot;</span> gives you the ability to
  whitelist the protocols you're willing to allow.
<p class="Pp"><span class="Li"></span></p>
<pre>
    my $ua = LWP::UserAgent-&gt;new(
        protocols_allowed =&gt; [ 'http', 'https' ]
    );
</pre>
<p class="Pp">This will prevent you from inadvertently following URLs like
    <span class="Li">&quot;file:///etc/passwd&quot;</span>. See
    &quot;protocols_allowed&quot;.</p>
<p class="Pp"><span class="Li">&quot;protocols_forbidden&quot;</span> gives you
    the ability to blacklist the protocols you're unwilling to allow.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    my $ua = LWP::UserAgent-&gt;new(
        protocols_forbidden =&gt; [ 'file', 'mailto', 'ssh', ]
    );
</pre>
<p class="Pp">This can also prevent you from inadvertently following URLs like
    <span class="Li">&quot;file:///etc/passwd&quot;</span>. See
    &quot;protocols_forbidden&quot;.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
See LWP for a complete overview of libwww-perl5. See lwpcook and the scripts
  <i>lwp-request</i> and <i>lwp-download</i> for examples of usage.
<p class="Pp">See HTTP::Request and HTTP::Response for a description of the
    message objects dispatched and received. See HTTP::Request::Common and
    HTML::Form for other ways to build request objects.</p>
<p class="Pp">See WWW::Mechanize and WWW::Search for examples of more
    specialized user agents based on LWP::UserAgent.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT_AND_LICENSE"><a class="permalink" href="#COPYRIGHT_AND_LICENSE">COPYRIGHT
  AND LICENSE</a></h1>
Copyright 1995-2009 Gisle Aas.
<p class="Pp">This library is free software; you can redistribute it and/or
    modify it under the same terms as Perl itself.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2020-04-14</td>
    <td class="foot-os">perl v5.28.2</td>
  </tr>
</table>
</body>
</html>
