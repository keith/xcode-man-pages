<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>PERLREQUICK(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">PERLREQUICK(1)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">PERLREQUICK(1)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
perlrequick - Perl regular expressions quick start
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
This page covers the very basics of understanding, creating and using regular
  expressions ('regexes') in Perl.
</section>
<section class="Sh">
<h1 class="Sh" id="The_Guide"><a class="permalink" href="#The_Guide">The
  Guide</a></h1>
This page assumes you already know things, like what a &quot;pattern&quot; is,
  and the basic syntax of using them. If you don't, see perlretut.
<section class="Ss">
<h2 class="Ss" id="Simple_word_matching"><a class="permalink" href="#Simple_word_matching">Simple
  word matching</a></h2>
The simplest regex is simply a word, or more generally, a string of characters.
  A regex consisting of a word matches any string that contains that word:
<p class="Pp"><span class="Li"></span></p>
<pre>
    &quot;Hello World&quot; =~ /World/;  # matches
</pre>
<p class="Pp">In this statement, <span class="Li">&quot;World&quot;</span> is a
    regex and the <span class="Li">&quot;//&quot;</span> enclosing
    <span class="Li">&quot;/World/&quot;</span> tells Perl to search a string
    for a match. The operator <span class="Li">&quot;=~&quot;</span> associates
    the string with the regex match and produces a true value if the regex
    matched, or false if the regex did not match. In our case,
    <span class="Li">&quot;World&quot;</span> matches the second word in
    <span class="Li">&quot;Hello World&quot;</span>, so the expression is true.
    This idea has several variations.</p>
<p class="Pp">Expressions like this are useful in conditionals:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    print &quot;It matches\n&quot; if &quot;Hello World&quot; =~ /World/;
</pre>
<p class="Pp">The sense of the match can be reversed by using
    <span class="Li">&quot;!~&quot;</span> operator:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    print &quot;It doesn't match\n&quot; if &quot;Hello World&quot; !~ /World/;
</pre>
<p class="Pp">The literal string in the regex can be replaced by a variable:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    $greeting = &quot;World&quot;;
    print &quot;It matches\n&quot; if &quot;Hello World&quot; =~ /$greeting/;
</pre>
<p class="Pp">If you're matching against <span class="Li">$_</span>, the
    <span class="Li">&quot;$_ =~&quot;</span> part can be omitted:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    $_ = &quot;Hello World&quot;;
    print &quot;It matches\n&quot; if /World/;
</pre>
<p class="Pp">Finally, the <span class="Li">&quot;//&quot;</span> default
    delimiters for a match can be changed to arbitrary delimiters by putting an
    <span class="Li">'m'</span> out front:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    &quot;Hello World&quot; =~ m!World!;   # matches, delimited by '!'
    &quot;Hello World&quot; =~ m{World};   # matches, note the matching '{}'
    &quot;/usr/bin/perl&quot; =~ m&quot;/perl&quot;; # matches after '/usr/bin',
                                 # '/' becomes an ordinary char
</pre>
<p class="Pp">Regexes must match a part of the string <i>exactly</i> in order
    for the statement to be true:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    &quot;Hello World&quot; =~ /world/;  # doesn't match, case sensitive
    &quot;Hello World&quot; =~ /o W/;    # matches, ' ' is an ordinary char
    &quot;Hello World&quot; =~ /World /; # doesn't match, no ' ' at end
</pre>
<p class="Pp">Perl will always match at the earliest possible point in the
    string:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    &quot;Hello World&quot; =~ /o/;       # matches 'o' in 'Hello'
    &quot;That hat is red&quot; =~ /hat/; # matches 'hat' in 'That'
</pre>
<p class="Pp">Not all characters can be used 'as is' in a match. Some
    characters, called <b>metacharacters</b>, are considered special, and
    reserved for use in regex notation. The metacharacters are</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    {}[]()^$.|*+?\
</pre>
<p class="Pp">A metacharacter can be matched literally by putting a backslash
    before it:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    &quot;2+2=4&quot; =~ /2+2/;    # doesn't match, + is a metacharacter
    &quot;2+2=4&quot; =~ /2\+2/;   # matches, \+ is treated like an ordinary +
    'C:\WIN32' =~ /C:\\WIN/;                       # matches
    &quot;/usr/bin/perl&quot; =~ /\/usr\/bin\/perl/;  # matches
</pre>
<p class="Pp">In the last regex, the forward slash <span class="Li">'/'</span>
    is also backslashed, because it is used to delimit the regex.</p>
<p class="Pp">Most of the metacharacters aren't always special, and other
    characters (such as the ones delimitting the pattern) become special under
    various circumstances. This can be confusing and lead to unexpected results.
    <span class="Li">&quot;use&#x00A0;re&#x00A0;'strict'&quot;</span> can notify
    you of potential pitfalls.</p>
<p class="Pp">Non-printable ASCII characters are represented by <b>escape
    sequences</b>. Common examples are <span class="Li">&quot;\t&quot;</span>
    for a tab, <span class="Li">&quot;\n&quot;</span> for a newline, and
    <span class="Li">&quot;\r&quot;</span> for a carriage return. Arbitrary
    bytes are represented by octal escape sequences, e.g.,
    <span class="Li">&quot;\033&quot;</span>, or hexadecimal escape sequences,
    e.g., <span class="Li">&quot;\x1B&quot;</span>:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    &quot;1000\t2000&quot; =~ m(0\t2)  # matches
    &quot;cat&quot; =~ /\143\x61\x74/  # matches in ASCII, but
                             # a weird way to spell cat
</pre>
<p class="Pp">Regexes are treated mostly as double-quoted strings, so variable
    substitution works:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    $foo = 'house';
    'cathouse' =~ /cat$foo/;   # matches
    'housecat' =~ /${foo}cat/; # matches
</pre>
<p class="Pp">With all of the regexes above, if the regex matched anywhere in
    the string, it was considered a match. To specify <i>where</i> it should
    match, we would use the <b>anchor</b> metacharacters
    <span class="Li">&quot;^&quot;</span> and
    <span class="Li">&quot;$&quot;</span>. The anchor
    <span class="Li">&quot;^&quot;</span> means match at the beginning of the
    string and the anchor <span class="Li">&quot;$&quot;</span> means match at
    the end of the string, or before a newline at the end of the string. Some
    examples:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    &quot;housekeeper&quot; =~ /keeper/;         # matches
    &quot;housekeeper&quot; =~ /^keeper/;        # doesn't match
    &quot;housekeeper&quot; =~ /keeper$/;        # matches
    &quot;housekeeper\n&quot; =~ /keeper$/;      # matches
    &quot;housekeeper&quot; =~ /^housekeeper$/;  # matches
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Using_character_classes"><a class="permalink" href="#Using_character_classes">Using
  character classes</a></h2>
A <b>character class</b> allows a set of possible characters, rather than just a
  single character, to match at a particular point in a regex. There are a
  number of different types of character classes, but usually when people use
  this term, they are referring to the type described in this section, which are
  technically called &quot;Bracketed character classes&quot;, because they are
  denoted by brackets <span class="Li">&quot;[...]&quot;</span>, with the set of
  characters to be possibly matched inside. But we'll drop the
  &quot;bracketed&quot; below to correspond with common usage. Here are some
  examples of (bracketed) character classes:
<p class="Pp"><span class="Li"></span></p>
<pre>
    /cat/;            # matches 'cat'
    /[bcr]at/;        # matches 'bat', 'cat', or 'rat'
    &quot;abc&quot; =~ /[cab]/; # matches 'a'
</pre>
<p class="Pp">In the last statement, even though <span class="Li">'c'</span> is
    the first character in the class, the earliest point at which the regex can
    match is <span class="Li">'a'</span>.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    /[yY][eE][sS]/; # match 'yes' in a case-insensitive way
                    # 'yes', 'Yes', 'YES', etc.
    /yes/i;         # also match 'yes' in a case-insensitive way
</pre>
<p class="Pp">The last example shows a match with an <span class="Li">'i'</span>
    <b>modifier</b>, which makes the match case-insensitive.</p>
<p class="Pp">Character classes also have ordinary and special characters, but
    the sets of ordinary and special characters inside a character class are
    different than those outside a character class. The special characters for a
    character class are <span class="Li">&quot;-]\^$&quot;</span> and are
    matched using an escape:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
   /[\]c]def/; # matches ']def' or 'cdef'
   $x = 'bcr';
   /[$x]at/;   # matches 'bat, 'cat', or 'rat'
   /[\$x]at/;  # matches '$at' or 'xat'
   /[\\$x]at/; # matches '\at', 'bat, 'cat', or 'rat'
</pre>
<p class="Pp">The special character <span class="Li">'-'</span> acts as a range
    operator within character classes, so that the unwieldy
    <span class="Li">&quot;[0123456789]&quot;</span> and
    <span class="Li">&quot;[abc...xyz]&quot;</span> become the svelte
    <span class="Li">&quot;[0-9]&quot;</span> and
    <span class="Li">&quot;[a-z]&quot;</span>:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    /item[0-9]/;  # matches 'item0' or ... or 'item9'
    /[0-9a-fA-F]/;  # matches a hexadecimal digit
</pre>
<p class="Pp">If <span class="Li">'-'</span> is the first or last character in a
    character class, it is treated as an ordinary character.</p>
<p class="Pp">The special character <span class="Li">&quot;^&quot;</span> in the
    first position of a character class denotes a <b>negated character
    class</b>, which matches any character but those in the brackets. Both
    <span class="Li">&quot;[...]&quot;</span> and
    <span class="Li">&quot;[^...]&quot;</span> must match a character, or the
    match fails. Then</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    /[^a]at/;  # doesn't match 'aat' or 'at', but matches
               # all other 'bat', 'cat, '0at', '%at', etc.
    /[^0-9]/;  # matches a non-numeric character
    /[a^]at/;  # matches 'aat' or '^at'; here '^' is ordinary
</pre>
<p class="Pp">Perl has several abbreviations for common character classes.
    (These definitions are those that Perl uses in ASCII-safe mode with the
    <span class="Li">&quot;/a&quot;</span> modifier. Otherwise they could match
    many more non-ASCII Unicode characters as well. See &quot;Backslash
    sequences&quot; in perlrecharclass for details.)</p>
<ul class="Bl-bullet">
  <li>\d is a digit and represents
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    [0-9]
    </pre>
  </li>
  <li>\s is a whitespace character and represents
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    [\ \t\r\n\f]
    </pre>
  </li>
  <li>\w is a word character (alphanumeric or _) and represents
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    [0-9a-zA-Z_]
    </pre>
  </li>
  <li>\D is a negated \d; it represents any character but a digit
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    [^0-9]
    </pre>
  </li>
  <li>\S is a negated \s; it represents any non-whitespace character
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    [^\s]
    </pre>
  </li>
  <li>\W is a negated \w; it represents any non-word character
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    [^\w]
    </pre>
  </li>
  <li>The period '.' matches any character but &quot;\n&quot;</li>
</ul>
<p class="Pp">The <span class="Li">&quot;\d\s\w\D\S\W&quot;</span> abbreviations
    can be used both inside and outside of character classes. Here are some in
    use:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    /\d\d:\d\d:\d\d/; # matches a hh:mm:ss time format
    /[\d\s]/;         # matches any digit or whitespace character
    /\w\W\w/;         # matches a word char, followed by a
                      # non-word char, followed by a word char
    /..rt/;           # matches any two chars, followed by 'rt'
    /end\./;          # matches 'end.'
    /end[.]/;         # same thing, matches 'end.'
</pre>
<p class="Pp">The <b>word&#x00A0;anchor</b>&#x00A0;
    <span class="Li">&quot;\b&quot;</span> matches a boundary between a word
    character and a non-word character <span class="Li">&quot;\w\W&quot;</span>
    or <span class="Li">&quot;\W\w&quot;</span>:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    $x = &quot;Housecat catenates house and cat&quot;;
    $x =~ /\bcat/;  # matches cat in 'catenates'
    $x =~ /cat\b/;  # matches cat in 'housecat'
    $x =~ /\bcat\b/;  # matches 'cat' at end of string
</pre>
<p class="Pp">In the last example, the end of the string is considered a word
    boundary.</p>
<p class="Pp">For natural language processing (so that, for example, apostrophes
    are included in words), use instead
    <span class="Li">&quot;\b{wb}&quot;</span></p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    &quot;don't&quot; =~ / .+? \b{wb} /x;  # matches the whole string
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Matching_this_or_that"><a class="permalink" href="#Matching_this_or_that">Matching
  this or that</a></h2>
We can match different character strings with the <b>alternation</b>
  metacharacter <span class="Li">'|'</span>. To match
  <span class="Li">&quot;dog&quot;</span> or
  <span class="Li">&quot;cat&quot;</span>, we form the regex
  <span class="Li">&quot;dog|cat&quot;</span>. As before, Perl will try to match
  the regex at the earliest possible point in the string. At each character
  position, Perl will first try to match the first alternative,
  <span class="Li">&quot;dog&quot;</span>. If
  <span class="Li">&quot;dog&quot;</span> doesn't match, Perl will then try the
  next alternative, <span class="Li">&quot;cat&quot;</span>. If
  <span class="Li">&quot;cat&quot;</span> doesn't match either, then the match
  fails and Perl moves to the next position in the string. Some examples:
<p class="Pp"><span class="Li"></span></p>
<pre>
    &quot;cats and dogs&quot; =~ /cat|dog|bird/;  # matches &quot;cat&quot;
    &quot;cats and dogs&quot; =~ /dog|cat|bird/;  # matches &quot;cat&quot;
</pre>
<p class="Pp">Even though <span class="Li">&quot;dog&quot;</span> is the first
    alternative in the second regex, <span class="Li">&quot;cat&quot;</span> is
    able to match earlier in the string.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    &quot;cats&quot;          =~ /c|ca|cat|cats/; # matches &quot;c&quot;
    &quot;cats&quot;          =~ /cats|cat|ca|c/; # matches &quot;cats&quot;
</pre>
<p class="Pp">At a given character position, the first alternative that allows
    the regex match to succeed will be the one that matches. Here, all the
    alternatives match at the first string position, so the first matches.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Grouping_things_and_hierarchical_matching"><a class="permalink" href="#Grouping_things_and_hierarchical_matching">Grouping
  things and hierarchical matching</a></h2>
The <b>grouping</b> metacharacters <span class="Li">&quot;()&quot;</span> allow
  a part of a regex to be treated as a single unit. Parts of a regex are grouped
  by enclosing them in parentheses. The regex
  <span class="Li">&quot;house(cat|keeper)&quot;</span> means match
  <span class="Li">&quot;house&quot;</span> followed by either
  <span class="Li">&quot;cat&quot;</span> or
  <span class="Li">&quot;keeper&quot;</span>. Some more examples are
<p class="Pp"><span class="Li"></span></p>
<pre>
    /(a|b)b/;    # matches 'ab' or 'bb'
    /(^a|b)c/;   # matches 'ac' at start of string or 'bc' anywhere

    /house(cat|)/;  # matches either 'housecat' or 'house'
    /house(cat(s|)|)/;  # matches either 'housecats' or 'housecat' or
                        # 'house'.  Note groups can be nested.

    &quot;20&quot; =~ /(19|20|)\d\d/;  # matches the null alternative '()\d\d',
                             # because '20\d\d' can't match
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Extracting_matches"><a class="permalink" href="#Extracting_matches">Extracting
  matches</a></h2>
The grouping metacharacters <span class="Li">&quot;()&quot;</span> also allow
  the extraction of the parts of a string that matched. For each grouping, the
  part that matched inside goes into the special variables
  <span class="Li">$1</span>, <span class="Li">$2</span>, etc. They can be used
  just as ordinary variables:
<p class="Pp"><span class="Li"></span></p>
<pre>
    # extract hours, minutes, seconds
    $time =~ /(\d\d):(\d\d):(\d\d)/;  # match hh:mm:ss format
    $hours = $1;
    $minutes = $2;
    $seconds = $3;
</pre>
<p class="Pp">In list context, a match
    <span class="Li">&quot;/regex/&quot;</span> with groupings will return the
    list of matched values <span class="Li">&quot;($1,$2,...)&quot;</span>. So
    we could rewrite it as</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    ($hours, $minutes, $second) = ($time =~ /(\d\d):(\d\d):(\d\d)/);
</pre>
<p class="Pp">If the groupings in a regex are nested, <span class="Li">$1</span>
    gets the group with the leftmost opening parenthesis,
    <span class="Li">$2</span> the next opening parenthesis, etc. For example,
    here is a complex regex and the matching variables indicated below it:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    /(ab(cd|ef)((gi)|j))/;
     1  2      34
</pre>
<p class="Pp">Associated with the matching variables <span class="Li">$1</span>,
    <span class="Li">$2</span>, ... are the <b>backreferences</b>
    <span class="Li">&quot;\g1&quot;</span>,
    <span class="Li">&quot;\g2&quot;</span>, ... Backreferences are matching
    variables that can be used <i>inside</i> a regex:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    /(\w\w\w)\s\g1/; # find sequences like 'the the' in string
</pre>
<p class="Pp"><span class="Li">$1</span>, <span class="Li">$2</span>, ... should
    only be used outside of a regex, and
    <span class="Li">&quot;\g1&quot;</span>,
    <span class="Li">&quot;\g2&quot;</span>, ... only inside a regex.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Matching_repetitions"><a class="permalink" href="#Matching_repetitions">Matching
  repetitions</a></h2>
The <b>quantifier</b> metacharacters <span class="Li">&quot;?&quot;</span>,
  <span class="Li">&quot;*&quot;</span>, <span class="Li">&quot;+&quot;</span>,
  and <span class="Li">&quot;{}&quot;</span> allow us to determine the number of
  repeats of a portion of a regex we consider to be a match. Quantifiers are put
  immediately after the character, character class, or grouping that we want to
  specify. They have the following meanings:
<ul class="Bl-bullet">
  <li><span class="Li">&quot;a?&quot;</span> = match 'a' 1 or 0 times</li>
  <li><span class="Li">&quot;a*&quot;</span> = match 'a' 0 or more times, i.e.,
      any number of times</li>
  <li><span class="Li">&quot;a+&quot;</span> = match 'a' 1 or more times, i.e.,
      at least once</li>
  <li><span class="Li">&quot;a{n,m}&quot;</span> = match at least
      <span class="Li">&quot;n&quot;</span> times, but not more than
      <span class="Li">&quot;m&quot;</span> times.</li>
  <li><span class="Li">&quot;a{n,}&quot;</span> = match at least
      <span class="Li">&quot;n&quot;</span> or more times</li>
  <li><span class="Li">&quot;a{n}&quot;</span> = match exactly
      <span class="Li">&quot;n&quot;</span> times</li>
</ul>
<p class="Pp">Here are some examples:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    /[a-z]+\s+\d*/;  # match a lowercase word, at least some space, and
                     # any number of digits
    /(\w+)\s+\g1/;    # match doubled words of arbitrary length
    $year =~ /^\d{2,4}$/;  # make sure year is at least 2 but not more
                           # than 4 digits
    $year =~ /^\d{4}$|^\d{2}$/; # better match; throw out 3 digit dates
</pre>
<p class="Pp">These quantifiers will try to match as much of the string as
    possible, while still allowing the regex to match. So we have</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    $x = 'the cat in the hat';
    $x =~ /^(.*)(at)(.*)$/; # matches,
                            # $1 = 'the cat in the h'
                            # $2 = 'at'
                            # $3 = ''   (0 matches)
</pre>
<p class="Pp">The first quantifier <span class="Li">&quot;.*&quot;</span> grabs
    as much of the string as possible while still having the regex match. The
    second quantifier <span class="Li">&quot;.*&quot;</span> has no string left
    to it, so it matches 0 times.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="More_matching"><a class="permalink" href="#More_matching">More
  matching</a></h2>
There are a few more things you might want to know about matching operators. The
  global modifier <span class="Li">&quot;/g&quot;</span> allows the matching
  operator to match within a string as many times as possible. In scalar
  context, successive matches against a string will have
  <span class="Li">&quot;/g&quot;</span> jump from match to match, keeping track
  of position in the string as it goes along. You can get or set the position
  with the <span class="Li">&quot;pos()&quot;</span> function. For example,
<p class="Pp"><span class="Li"></span></p>
<pre>
    $x = &quot;cat dog house&quot;; # 3 words
    while ($x =~ /(\w+)/g) {
        print &quot;Word is $1, ends at position &quot;, pos $x, &quot;\n&quot;;
    }
</pre>
<p class="Pp">prints</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    Word is cat, ends at position 3
    Word is dog, ends at position 7
    Word is house, ends at position 13
</pre>
<p class="Pp">A failed match or changing the target string resets the position.
    If you don't want the position reset after failure to match, add the
    <span class="Li">&quot;/c&quot;</span>, as in
    <span class="Li">&quot;/regex/gc&quot;</span>.</p>
<p class="Pp">In list context, <span class="Li">&quot;/g&quot;</span> returns a
    list of matched groupings, or if there are no groupings, a list of matches
    to the whole regex. So</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    @words = ($x =~ /(\w+)/g);  # matches,
                                # $word[0] = 'cat'
                                # $word[1] = 'dog'
                                # $word[2] = 'house'
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Search_and_replace"><a class="permalink" href="#Search_and_replace">Search
  and replace</a></h2>
Search and replace is performed using
  <span class="Li">&quot;s/regex/replacement/modifiers&quot;</span>. The
  <span class="Li">&quot;replacement&quot;</span> is a Perl double-quoted string
  that replaces in the string whatever is matched with the
  <span class="Li">&quot;regex&quot;</span>. The operator
  <span class="Li">&quot;=~&quot;</span> is also used here to associate a string
  with <span class="Li">&quot;s///&quot;</span>. If matching against
  <span class="Li">$_</span>, the
  <span class="Li">&quot;$_&#x00A0;=~&quot;</span> can be dropped. If there is a
  match, <span class="Li">&quot;s///&quot;</span> returns the number of
  substitutions made; otherwise it returns false. Here are a few examples:
<p class="Pp"><span class="Li"></span></p>
<pre>
    $x = &quot;Time to feed the cat!&quot;;
    $x =~ s/cat/hacker/;   # $x contains &quot;Time to feed the hacker!&quot;
    $y = &quot;'quoted words'&quot;;
    $y =~ s/^'(.*)'$/$1/;  # strip single quotes,
                           # $y contains &quot;quoted words&quot;
</pre>
<p class="Pp">With the <span class="Li">&quot;s///&quot;</span> operator, the
    matched variables <span class="Li">$1</span>, <span class="Li">$2</span>,
    etc. are immediately available for use in the replacement expression. With
    the global modifier, <span class="Li">&quot;s///g&quot;</span> will search
    and replace all occurrences of the regex in the string:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    $x = &quot;I batted 4 for 4&quot;;
    $x =~ s/4/four/;   # $x contains &quot;I batted four for 4&quot;
    $x = &quot;I batted 4 for 4&quot;;
    $x =~ s/4/four/g;  # $x contains &quot;I batted four for four&quot;
</pre>
<p class="Pp">The non-destructive modifier
    <span class="Li">&quot;s///r&quot;</span> causes the result of the
    substitution to be returned instead of modifying <span class="Li">$_</span>
    (or whatever variable the substitute was bound to with
    <span class="Li">&quot;=~&quot;</span>):</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    $x = &quot;I like dogs.&quot;;
    $y = $x =~ s/dogs/cats/r;
    print &quot;$x $y\n&quot;; # prints &quot;I like dogs. I like cats.&quot;

    $x = &quot;Cats are great.&quot;;
    print $x =~ s/Cats/Dogs/r =~ s/Dogs/Frogs/r =~
        s/Frogs/Hedgehogs/r, &quot;\n&quot;;
    # prints &quot;Hedgehogs are great.&quot;

    @foo = map { s/[a-z]/X/r } qw(a b c 1 2 3);
    # @foo is now qw(X X X 1 2 3)
</pre>
<p class="Pp">The evaluation modifier <span class="Li">&quot;s///e&quot;</span>
    wraps an <span class="Li">&quot;eval{...}&quot;</span> around the
    replacement string and the evaluated result is substituted for the matched
    substring. Some examples:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    # reverse all the words in a string
    $x = &quot;the cat in the hat&quot;;
    $x =~ s/(\w+)/reverse $1/ge;   # $x contains &quot;eht tac ni eht tah&quot;

    # convert percentage to decimal
    $x = &quot;A 39% hit rate&quot;;
    $x =~ s!(\d+)%!$1/100!e;       # $x contains &quot;A 0.39 hit rate&quot;
</pre>
<p class="Pp">The last example shows that
    <span class="Li">&quot;s///&quot;</span> can use other delimiters, such as
    <span class="Li">&quot;s!!!&quot;</span> and
    <span class="Li">&quot;s{}{}&quot;</span>, and even
    <span class="Li">&quot;s{}//&quot;</span>. If single quotes are used
    <span class="Li">&quot;s'''&quot;</span>, then the regex and replacement are
    treated as single-quoted strings.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="The_split_operator"><a class="permalink" href="#The_split_operator">The
  split operator</a></h2>
<span class="Li">&quot;split /regex/, string&quot;</span> splits
  <span class="Li">&quot;string&quot;</span> into a list of substrings and
  returns that list. The regex determines the character sequence that
  <span class="Li">&quot;string&quot;</span> is split with respect to. For
  example, to split a string into words, use
<p class="Pp"><span class="Li"></span></p>
<pre>
    $x = &quot;Calvin and Hobbes&quot;;
    @word = split /\s+/, $x;  # $word[0] = 'Calvin'
                              # $word[1] = 'and'
                              # $word[2] = 'Hobbes'
</pre>
<p class="Pp">To extract a comma-delimited list of numbers, use</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    $x = &quot;1.618,2.718,   3.142&quot;;
    @const = split /,\s*/, $x;  # $const[0] = '1.618'
                                # $const[1] = '2.718'
                                # $const[2] = '3.142'
</pre>
<p class="Pp">If the empty regex <span class="Li">&quot;//&quot;</span> is used,
    the string is split into individual characters. If the regex has groupings,
    then the list produced contains the matched substrings from the groupings as
    well:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    $x = &quot;/usr/bin&quot;;
    @parts = split m!(/)!, $x;  # $parts[0] = ''
                                # $parts[1] = '/'
                                # $parts[2] = 'usr'
                                # $parts[3] = '/'
                                # $parts[4] = 'bin'
</pre>
<p class="Pp">Since the first character of <span class="Li">$x</span> matched
    the regex, <span class="Li">&quot;split&quot;</span> prepended an empty
    initial element to the list.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_use_re__(aqstrict_(aq_"><a class="permalink" href="#_use_re__(aqstrict_(aq_">&quot;use
  re 'strict'&quot;</a></h2>
New in v5.22, this applies stricter rules than otherwise when compiling regular
  expression patterns. It can find things that, while legal, may not be what you
  intended.
<p class="Pp">See 'strict' in re.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="BUGS"><a class="permalink" href="#BUGS">BUGS</a></h1>
None.
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
This is just a quick start guide. For a more in-depth tutorial on regexes, see
  perlretut and for the reference page, see perlre.
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR_AND_COPYRIGHT"><a class="permalink" href="#AUTHOR_AND_COPYRIGHT">AUTHOR
  AND COPYRIGHT</a></h1>
Copyright (c) 2000 Mark Kvale All rights reserved.
<p class="Pp">This document may be distributed under the same terms as Perl
    itself.</p>
<section class="Ss">
<h2 class="Ss" id="Acknowledgments"><a class="permalink" href="#Acknowledgments">Acknowledgments</a></h2>
The author would like to thank Mark-Jason Dominus, Tom Christiansen, Ilya
  Zakharevich, Brad Hughes, and Mike Giroux for all their helpful comments.
</section>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2019-10-24</td>
    <td class="foot-os">perl v5.30.2</td>
  </tr>
</table>
</body>
</html>
