<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    .Nd, .Bf, .Op { display: inline; }
    .Pa, .Ad { font-style: italic; }
    .Ms { font-weight: bold; }
    .Bl-diag > dt { font-weight: bold; }
    code.Nm, .Fl, .Cm, .Ic, code.In, .Fd, .Fn, .Cd { font-weight: bold;
      font-family: inherit; }
  </style>
  <title>PERLSEC(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">PERLSEC(1)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">PERLSEC(1)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">perlsec - Perl security</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">Perl is designed to make it easy to program securely even when
    running with extra privileges, like setuid or setgid programs. Unlike most
    command line shells, which are based on multiple substitution passes on each
    line of the script, Perl uses a more conventional evaluation scheme with
    fewer hidden snags. Additionally, because the language has more builtin
    functionality, it can rely less upon external (and possibly untrustworthy)
    programs to accomplish its purposes.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SECURITY_VULNERABILITY_CONTACT_INFORMATION"><a class="permalink" href="#SECURITY_VULNERABILITY_CONTACT_INFORMATION">SECURITY
  VULNERABILITY CONTACT INFORMATION</a></h1>
<p class="Pp">If you believe you have found a security vulnerability in the Perl
    interpreter or modules maintained in the core Perl codebase, email the
    details to perl-security@perl.org &lt;mailto:perl-security@perl.org&gt;.
    This address is a closed membership mailing list monitored by the Perl
    security team.</p>
<p class="Pp">See perlsecpolicy for additional information.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SECURITY_MECHANISMS_AND_CONCERNS"><a class="permalink" href="#SECURITY_MECHANISMS_AND_CONCERNS">SECURITY
  MECHANISMS AND CONCERNS</a></h1>
<section class="Ss">
<h2 class="Ss" id="Taint_mode"><a class="permalink" href="#Taint_mode">Taint
  mode</a></h2>
<p class="Pp">Perl automatically enables a set of special security checks,
    called <i>taint</i> <i>mode</i>, when it detects its program running with
    differing real and effective user or group IDs. The setuid bit in Unix
    permissions is mode 04000, the setgid bit mode 02000; either or both may be
    set. You can also enable taint mode explicitly by using the <b>-T</b>
    command line flag. This flag is <i>strongly</i> suggested for server
    programs and any program run on behalf of someone else, such as a CGI
    script. Once taint mode is on, it's on for the remainder of your script.</p>
<p class="Pp">While in this mode, Perl takes special precautions called
    <i>taint</i> <i>checks</i> to prevent both obvious and subtle traps. Some of
    these checks are reasonably simple, such as verifying that path directories
    aren't writable by others; careful programmers have always used checks like
    these. Other checks, however, are best supported by the language itself, and
    it is these checks especially that contribute to making a set-id Perl
    program more secure than the corresponding C program.</p>
<p class="Pp">You may not use data derived from outside your program to affect
    something else outside your program--at least, not by accident. All command
    line arguments, environment variables, locale information (see perllocale),
    results of certain system calls
    (<span class="Li">&quot;readdir()&quot;</span>,
    <span class="Li">&quot;readlink()&quot;</span>, the variable of
    <span class="Li">&quot;shmread()&quot;</span>, the messages returned by
    <span class="Li">&quot;msgrcv()&quot;</span>, the password, gcos and shell
    fields returned by the <span class="Li">&quot;getpwxxx()&quot;</span>
    calls), and all file input are marked as &quot;tainted&quot;. Tainted data
    may not be used directly or indirectly in any command that invokes a
    sub-shell, nor in any command that modifies files, directories, or
    processes, <b>with the following exceptions</b>:</p>
<ul class="Bl-bullet">
  <li>Arguments to <span class="Li">&quot;print&quot;</span> and
      <span class="Li">&quot;syswrite&quot;</span> are <b>not</b> checked for
      taintedness.</li>
  <li>Symbolic methods
    <p class="Pp"></p>
    <pre>    $obj-&gt;$method(@args);
    </pre>
    <p class="Pp">and symbolic sub references</p>
    <p class="Pp"></p>
    <pre>    &amp;{$foo}(@args);
    $foo-&gt;(@args);
    </pre>
    <p class="Pp">are not checked for taintedness. This requires extra
        carefulness unless you want external data to affect your control flow.
        Unless you carefully limit what these symbolic values are, people are
        able to call functions <b>outside</b> your Perl code, such as
        POSIX::system, in which case they are able to run arbitrary external
        code.</p>
  </li>
  <li>Hash keys are <b>never</b> tainted.</li>
</ul>
<p class="Pp">For efficiency reasons, Perl takes a conservative view of whether
    data is tainted. If an expression contains tainted data, any subexpression
    may be considered tainted, even if the value of the subexpression is not
    itself affected by the tainted data.</p>
<p class="Pp">Because taintedness is associated with each scalar value, some
    elements of an array or hash can be tainted and others not. The keys of a
    hash are <b>never</b> tainted.</p>
<p class="Pp">For example:</p>
<p class="Pp"></p>
<pre>    $arg = shift;               # $arg is tainted
    $hid = $arg . 'bar';        # $hid is also tainted
    $line = &lt;&gt;;                 # Tainted
    $line = &lt;STDIN&gt;;            # Also tainted
    open FOO, &quot;/home/me/bar&quot; or die $!;
    $line = &lt;FOO&gt;;              # Still tainted
    $path = $ENV{'PATH'};       # Tainted, but see below
    $data = 'abc';              # Not tainted
    system &quot;echo $arg&quot;;         # Insecure
    system &quot;/bin/echo&quot;, $arg;   # Considered insecure
                                # (Perl doesn't know about /bin/echo)
    system &quot;echo $hid&quot;;         # Insecure
    system &quot;echo $data&quot;;        # Insecure until PATH set
    $path = $ENV{'PATH'};       # $path now tainted
    $ENV{'PATH'} = '/bin:/usr/bin';
    delete @ENV{'IFS', 'CDPATH', 'ENV', 'BASH_ENV'};
    $path = $ENV{'PATH'};       # $path now NOT tainted
    system &quot;echo $data&quot;;        # Is secure now!
    open(FOO, &quot;&lt; $arg&quot;);        # OK - read-only file
    open(FOO, &quot;&gt; $arg&quot;);        # Not OK - trying to write
    open(FOO,&quot;echo $arg|&quot;);     # Not OK
    open(FOO,&quot;-|&quot;)
        or exec 'echo', $arg;   # Also not OK
    $shout = `echo $arg`;       # Insecure, $shout now tainted
    unlink $data, $arg;         # Insecure
    umask $arg;                 # Insecure
    exec &quot;echo $arg&quot;;           # Insecure
    exec &quot;echo&quot;, $arg;          # Insecure
    exec &quot;sh&quot;, '-c', $arg;      # Very insecure!
    @files = &lt;*.c&gt;;             # insecure (uses readdir() or similar)
    @files = glob('*.c');       # insecure (uses readdir() or similar)
    # In either case, the results of glob are tainted, since the list of
    # filenames comes from outside of the program.
    $bad = ($arg, 23);          # $bad will be tainted
    $arg, `true`;               # Insecure (although it isn't really)
</pre>
<p class="Pp">If you try to do something insecure, you will get a fatal error
    saying something like &quot;Insecure dependency&quot; or &quot;Insecure
    <span class="Li">$ENV</span>{PATH}&quot;.</p>
<p class="Pp">The exception to the principle of &quot;one tainted value taints
    the whole expression&quot; is with the ternary conditional operator
    <span class="Li">&quot;?:&quot;</span>. Since code with a ternary
    conditional</p>
<p class="Pp"></p>
<pre>    $result = $tainted_value ? &quot;Untainted&quot; : &quot;Also untainted&quot;;
</pre>
<p class="Pp">is effectively</p>
<p class="Pp"></p>
<pre>    if ( $tainted_value ) {
        $result = &quot;Untainted&quot;;
    } else {
        $result = &quot;Also untainted&quot;;
    }
</pre>
<p class="Pp">it doesn't make sense for <span class="Li">$result</span> to be
    tainted.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Laundering_and_Detecting_Tainted_Data"><a class="permalink" href="#Laundering_and_Detecting_Tainted_Data">Laundering
  and Detecting Tainted Data</a></h2>
<p class="Pp">To test whether a variable contains tainted data, and whose use
    would thus trigger an &quot;Insecure dependency&quot; message, you can use
    the <span class="Li">&quot;tainted()&quot;</span> function of the
    Scalar::Util module, available in your nearby CPAN mirror, and included in
    Perl starting from the release 5.8.0. Or you may be able to use the
    following <span class="Li">&quot;is_tainted()&quot;</span> function.</p>
<p class="Pp"></p>
<pre>    sub is_tainted {
        local $@;   # Don't pollute caller's value.
        return ! eval { eval(&quot;#&quot; . substr(join(&quot;&quot;, @_), 0, 0)); 1 };
    }
</pre>
<p class="Pp">This function makes use of the fact that the presence of tainted
    data anywhere within an expression renders the entire expression tainted. It
    would be inefficient for every operator to test every argument for
    taintedness. Instead, the slightly more efficient and conservative approach
    is used that if any tainted value has been accessed within the same
    expression, the whole expression is considered tainted.</p>
<p class="Pp">But testing for taintedness gets you only so far. Sometimes you
    have just to clear your data's taintedness. Values may be untainted by using
    them as keys in a hash; otherwise the only way to bypass the tainting
    mechanism is by referencing subpatterns from a regular expression match.
    Perl presumes that if you reference a substring using
    <span class="Li">$1</span>, <span class="Li">$2</span>, etc. in a
    non-tainting pattern, that you knew what you were doing when you wrote that
    pattern. That means using a bit of thought--don't just blindly untaint
    anything, or you defeat the entire mechanism. It's better to verify that the
    variable has only good characters (for certain values of &quot;good&quot;)
    rather than checking whether it has any bad characters. That's because it's
    far too easy to miss bad characters that you never thought of.</p>
<p class="Pp">Here's a test to make sure that the data contains nothing but
    &quot;word&quot; characters (alphabetics, numerics, and underscores), a
    hyphen, an at sign, or a dot.</p>
<p class="Pp"></p>
<pre>    if ($data =~ /^([-\@\w.]+)$/) {
        $data = $1;                     # $data now untainted
    } else {
        die &quot;Bad data in '$data'&quot;;      # log this somewhere
    }
</pre>
<p class="Pp">This is fairly secure because
    <span class="Li">&quot;/\w+/&quot;</span> doesn't normally match shell
    metacharacters, nor are dot, dash, or at going to mean something special to
    the shell. Use of <span class="Li">&quot;/.+/&quot;</span> would have been
    insecure in theory because it lets everything through, but Perl doesn't
    check for that. The lesson is that when untainting, you must be exceedingly
    careful with your patterns. Laundering data using regular expression is the
    <i>only</i> mechanism for untainting dirty data, unless you use the strategy
    detailed below to fork a child of lesser privilege.</p>
<p class="Pp">The example does not untaint <span class="Li">$data</span> if
    <span class="Li">&quot;use locale&quot;</span> is in effect, because the
    characters matched by <span class="Li">&quot;\w&quot;</span> are determined
    by the locale. Perl considers that locale definitions are untrustworthy
    because they contain data from outside the program. If you are writing a
    locale-aware program, and want to launder data with a regular expression
    containing <span class="Li">&quot;\w&quot;</span>, put
    <span class="Li">&quot;no locale&quot;</span> ahead of the expression in the
    same block. See &quot;SECURITY&quot; in perllocale for further discussion
    and examples.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Switches_On_the___!__Line"><a class="permalink" href="#Switches_On_the___!__Line">Switches
  On the &quot;#!&quot; Line</a></h2>
<p class="Pp">When you make a script executable, in order to make it usable as a
    command, the system will pass switches to perl from the script's #! line.
    Perl checks that any command line switches given to a setuid (or setgid)
    script actually match the ones set on the #! line. Some Unix and Unix-like
    environments impose a one-switch limit on the #! line, so you may need to
    use something like <span class="Li">&quot;-wU&quot;</span> instead of
    <span class="Li">&quot;-w -U&quot;</span> under such systems. (This issue
    should arise only in Unix or Unix-like environments that support #! and
    setuid or setgid scripts.)</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Taint_mode_and_@INC"><a class="permalink" href="#Taint_mode_and_@INC">Taint
  mode and @INC</a></h2>
<p class="Pp">When the taint mode (<span class="Li">&quot;-T&quot;</span>) is in
    effect, the environment variables
    <span class="Li">&quot;PERL5LIB&quot;</span> and
    <span class="Li">&quot;PERLLIB&quot;</span> are ignored by Perl. You can
    still adjust <span class="Li">@INC</span> from outside the program by using
    the <span class="Li">&quot;-I&quot;</span> command line option as explained
    in perlrun. The two environment variables are ignored because they are
    obscured, and a user running a program could be unaware that they are set,
    whereas the <span class="Li">&quot;-I&quot;</span> option is clearly visible
    and therefore permitted.</p>
<p class="Pp">Another way to modify <span class="Li">@INC</span> without
    modifying the program, is to use the <span class="Li">&quot;lib&quot;</span>
    pragma, e.g.:</p>
<p class="Pp"></p>
<pre>  perl -Mlib=/foo program
</pre>
<p class="Pp">The benefit of using
    <span class="Li">&quot;-Mlib=/foo&quot;</span> over
    <span class="Li">&quot;-I/foo&quot;</span>, is that the former will
    automagically remove any duplicated directories, while the latter will
  not.</p>
<p class="Pp">Note that if a tainted string is added to
    <span class="Li">@INC</span>, the following problem will be reported:</p>
<p class="Pp"></p>
<pre>  Insecure dependency in require while running with -T switch
</pre>
<p class="Pp">On versions of Perl before 5.26, activating taint mode will also
    remove the current directory (&quot;.&quot;) from the default value of
    <span class="Li">@INC</span>. Since version 5.26, the current directory
    isn't included in <span class="Li">@INC</span> by default.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Cleaning_Up_Your_Path"><a class="permalink" href="#Cleaning_Up_Your_Path">Cleaning
  Up Your Path</a></h2>
<p class="Pp">For &quot;Insecure <span class="Li">$ENV{PATH}</span>&quot;
    messages, you need to set <span class="Li">$ENV{'PATH'}</span> to a known
    value, and each directory in the path must be absolute and non-writable by
    others than its owner and group. You may be surprised to get this message
    even if the pathname to your executable is fully qualified. This is
    <i>not</i> generated because you didn't supply a full path to the program;
    instead, it's generated because you never set your PATH environment
    variable, or you didn't set it to something that was safe. Because Perl
    can't guarantee that the executable in question isn't itself going to turn
    around and execute some other program that is dependent on your PATH, it
    makes sure you set the PATH.</p>
<p class="Pp">The PATH isn't the only environment variable which can cause
    problems. Because some shells may use the variables IFS, CDPATH, ENV, and
    BASH_ENV, Perl checks that those are either empty or untainted when starting
    subprocesses. You may wish to add something like this to your setid and
    taint-checking scripts.</p>
<p class="Pp"></p>
<pre>    delete @ENV{qw(IFS CDPATH ENV BASH_ENV)};   # Make %ENV safer
</pre>
<p class="Pp">It's also possible to get into trouble with other operations that
    don't care whether they use tainted values. Make judicious use of the file
    tests in dealing with any user-supplied filenames. When possible, do opens
    and such <b>after</b> properly dropping any special user (or group!)
    privileges. Perl doesn't prevent you from opening tainted filenames for
    reading, so be careful what you print out. The tainting mechanism is
    intended to prevent stupid mistakes, not to remove the need for thought.</p>
<p class="Pp">Perl does not call the shell to expand wild cards when you pass
    <span class="Li">&quot;system&quot;</span> and
    <span class="Li">&quot;exec&quot;</span> explicit parameter lists instead of
    strings with possible shell wildcards in them. Unfortunately, the
    <span class="Li">&quot;open&quot;</span>,
    <span class="Li">&quot;glob&quot;</span>, and backtick functions provide no
    such alternate calling convention, so more subterfuge will be required.</p>
<p class="Pp">Perl provides a reasonably safe way to open a file or pipe from a
    setuid or setgid program: just create a child process with reduced privilege
    who does the dirty work for you. First, fork a child using the special
    <span class="Li">&quot;open&quot;</span> syntax that connects the parent and
    child by a pipe. Now the child resets its ID set and any other per-process
    attributes, like environment variables, umasks, current working directories,
    back to the originals or known safe values. Then the child process, which no
    longer has any special permissions, does the
    <span class="Li">&quot;open&quot;</span> or other system call. Finally, the
    child passes the data it managed to access back to the parent. Because the
    file or pipe was opened in the child while running under less privilege than
    the parent, it's not apt to be tricked into doing something it
  shouldn't.</p>
<p class="Pp">Here's a way to do backticks reasonably safely. Notice how the
    <span class="Li">&quot;exec&quot;</span> is not called with a string that
    the shell could expand. This is by far the best way to call something that
    might be subjected to shell escapes: just never call the shell at all.</p>
<p class="Pp"></p>
<pre>        use English;
        die &quot;Can't fork: $!&quot; unless defined($pid = open(KID, &quot;-|&quot;));
        if ($pid) {           # parent
            while (&lt;KID&gt;) {
                # do something
            }
            close KID;
        } else {
            my @temp     = ($EUID, $EGID);
            my $orig_uid = $UID;
            my $orig_gid = $GID;
            $EUID = $UID;
            $EGID = $GID;
            # Drop privileges
            $UID  = $orig_uid;
            $GID  = $orig_gid;
            # Make sure privs are really gone
            ($EUID, $EGID) = @temp;
            die &quot;Can't drop privileges&quot;
                unless $UID == $EUID  &amp;&amp; $GID eq $EGID;
            $ENV{PATH} = &quot;/bin:/usr/bin&quot;; # Minimal PATH.
            # Consider sanitizing the environment even more.
            exec 'myprog', 'arg1', 'arg2'
                or die &quot;can't exec myprog: $!&quot;;
        }
</pre>
<p class="Pp">A similar strategy would work for wildcard expansion via
    <span class="Li">&quot;glob&quot;</span>, although you can use
    <span class="Li">&quot;readdir&quot;</span> instead.</p>
<p class="Pp">Taint checking is most useful when although you trust yourself not
    to have written a program to give away the farm, you don't necessarily trust
    those who end up using it not to try to trick it into doing something bad.
    This is the kind of security checking that's useful for set-id programs and
    programs launched on someone else's behalf, like CGI programs.</p>
<p class="Pp">This is quite different, however, from not even trusting the
    writer of the code not to try to do something evil. That's the kind of trust
    needed when someone hands you a program you've never seen before and says,
    &quot;Here, run this.&quot; For that kind of safety, you might want to check
    out the Safe module, included standard in the Perl distribution. This module
    allows the programmer to set up special compartments in which all system
    operations are trapped and namespace access is carefully controlled. Safe
    should not be considered bullet-proof, though: it will not prevent the
    foreign code to set up infinite loops, allocate gigabytes of memory, or even
    abusing perl bugs to make the host interpreter crash or behave in
    unpredictable ways. In any case it's better avoided completely if you're
    really concerned about security.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Shebang_Race_Condition"><a class="permalink" href="#Shebang_Race_Condition">Shebang
  Race Condition</a></h2>
<p class="Pp">Beyond the obvious problems that stem from giving special
    privileges to systems as flexible as scripts, on many versions of Unix,
    set-id scripts are inherently insecure right from the start. The problem is
    a race condition in the kernel. Between the time the kernel opens the file
    to see which interpreter to run and when the (now-set-id) interpreter turns
    around and reopens the file to interpret it, the file in question may have
    changed, especially if you have symbolic links on your system.</p>
<p class="Pp">Some Unixes, especially more recent ones, are free of this
    inherent security bug. On such systems, when the kernel passes the name of
    the set-id script to open to the interpreter, rather than using a pathname
    subject to meddling, it instead passes <i>/dev/fd/3</i>. This is a special
    file already opened on the script, so that there can be no race condition
    for evil scripts to exploit. On these systems, Perl should be compiled with
    <span class="Li">&quot;-DSETUID_SCRIPTS_ARE_SECURE_NOW&quot;</span>. The
    <i>Configure</i> program that builds Perl tries to figure this out for
    itself, so you should never have to specify this yourself. Most modern
    releases of SysVr4 and BSD 4.4 use this approach to avoid the kernel race
    condition.</p>
<p class="Pp">If you don't have the safe version of set-id scripts, all is not
    lost. Sometimes this kernel &quot;feature&quot; can be disabled, so that the
    kernel either doesn't run set-id scripts with the set-id or doesn't run them
    at all. Either way avoids the exploitability of the race condition, but
    doesn't help in actually running scripts set-id.</p>
<p class="Pp">If the kernel set-id script feature isn't disabled, then any
    set-id script provides an exploitable vulnerability. Perl can't avoid being
    exploitable, but will point out vulnerable scripts where it can. If Perl
    detects that it is being applied to a set-id script then it will complain
    loudly that your set-id script is insecure, and won't run it. When Perl
    complains, you need to remove the set-id bit from the script to eliminate
    the vulnerability. Refusing to run the script doesn't in itself close the
    vulnerability; it is just Perl's way of encouraging you to do this.</p>
<p class="Pp">To actually run a script set-id, if you don't have the safe
    version of set-id scripts, you'll need to put a C wrapper around the script.
    A C wrapper is just a compiled program that does nothing except call your
    Perl program. Compiled programs are not subject to the kernel bug that
    plagues set-id scripts. Here's a simple wrapper, written in C:</p>
<p class="Pp"></p>
<pre>    #include &lt;unistd.h&gt;
    #include &lt;stdio.h&gt;
    #include &lt;string.h&gt;
    #include &lt;errno.h&gt;
    #define REAL_PATH &quot;/path/to/script&quot;
    int main(int argc, char **argv)
    {
        execv(REAL_PATH, argv);
        fprintf(stderr, &quot;%s: %s: %s\n&quot;,
                        argv[0], REAL_PATH, strerror(errno));
        return 127;
    }
</pre>
<p class="Pp">Compile this wrapper into a binary executable and then make
    <i>it</i> rather than your script setuid or setgid. Note that this wrapper
    isn't doing anything to sanitise the execution environment other than
    ensuring that a safe path to the script is used. It only avoids the shebang
    race condition. It relies on Perl's own features, and on the script itself
    being careful, to make it safe enough to run the script set-id.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Protecting_Your_Programs"><a class="permalink" href="#Protecting_Your_Programs">Protecting
  Your Programs</a></h2>
<p class="Pp">There are a number of ways to hide the source to your Perl
    programs, with varying levels of &quot;security&quot;.</p>
<p class="Pp">First of all, however, you <i>can't</i> take away read permission,
    because the source code has to be readable in order to be compiled and
    interpreted. (That doesn't mean that a CGI script's source is readable by
    people on the web, though.) So you have to leave the permissions at the
    socially friendly 0755 level. This lets people on your local system only see
    your source.</p>
<p class="Pp">Some people mistakenly regard this as a security problem. If your
    program does insecure things, and relies on people not knowing how to
    exploit those insecurities, it is not secure. It is often possible for
    someone to determine the insecure things and exploit them without viewing
    the source. Security through obscurity, the name for hiding your bugs
    instead of fixing them, is little security indeed.</p>
<p class="Pp">You can try using encryption via source filters (Filter::* from
    CPAN, or Filter::Util::Call and Filter::Simple since Perl 5.8). But crackers
    might be able to decrypt it. You can try using the byte code compiler and
    interpreter described below, but crackers might be able to de-compile it.
    You can try using the native-code compiler described below, but crackers
    might be able to disassemble it. These pose varying degrees of difficulty to
    people wanting to get at your code, but none can definitively conceal it
    (this is true of every language, not just Perl).</p>
<p class="Pp">If you're concerned about people profiting from your code, then
    the bottom line is that nothing but a restrictive license will give you
    legal security. License your software and pepper it with threatening
    statements like &quot;This is unpublished proprietary software of XYZ Corp.
    Your access to it does not give you permission to use it blah blah
    blah.&quot; You should see a lawyer to be sure your license's wording will
    stand up in court.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Unicode"><a class="permalink" href="#Unicode">Unicode</a></h2>
<p class="Pp">Unicode is a new and complex technology and one may easily
    overlook certain security pitfalls. See perluniintro for an overview and
    perlunicode for details, and &quot;Security Implications of Unicode&quot; in
    perlunicode for security implications in particular.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Algorithmic_Complexity_Attacks"><a class="permalink" href="#Algorithmic_Complexity_Attacks">Algorithmic
  Complexity Attacks</a></h2>
<p class="Pp">Certain internal algorithms used in the implementation of Perl can
    be attacked by choosing the input carefully to consume large amounts of
    either time or space or both. This can lead into the so-called <i>Denial of
    Service</i> (DoS) attacks.</p>
<dl class="Bl-tag">
  <dt>&#x2022;</dt>
  <dd>Hash Algorithm - Hash algorithms like the one used in Perl are well known
      to be vulnerable to collision attacks on their hash function. Such attacks
      involve constructing a set of keys which collide into the same bucket
      producing inefficient behavior. Such attacks often depend on discovering
      the seed of the hash function used to map the keys to buckets. That seed
      is then used to brute-force a key set which can be used to mount a denial
      of service attack. In Perl 5.8.1 changes were introduced to harden Perl to
      such attacks, and then later in Perl 5.18.0 these features were enhanced
      and additional protections added.
    <p class="Pp">At the time of this writing, Perl 5.18.0 is considered to be
        well-hardened against algorithmic complexity attacks on its hash
        implementation. This is largely owed to the following measures mitigate
        attacks:</p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Hash"><a class="permalink" href="#Hash">Hash Seed
    Randomization</a></dt>
  <dd>In order to make it impossible to know what seed to generate an attack key
      set for, this seed is randomly initialized at process start. This may be
      overridden by using the PERL_HASH_SEED environment variable, see
      &quot;PERL_HASH_SEED&quot; in perlrun. This environment variable controls
      how items are actually stored, not how they are presented via
      <span class="Li">&quot;keys&quot;</span>,
      <span class="Li">&quot;values&quot;</span> and
      <span class="Li">&quot;each&quot;</span>.</dd>
  <dt id="Hash~2"><a class="permalink" href="#Hash~2">Hash Traversal
    Randomization</a></dt>
  <dd>Independent of which seed is used in the hash function,
      <span class="Li">&quot;keys&quot;</span>,
      <span class="Li">&quot;values&quot;</span>, and
      <span class="Li">&quot;each&quot;</span> return items in a per-hash
      randomized order. Modifying a hash by insertion will change the iteration
      order of that hash. This behavior can be overridden by using
      <span class="Li">&quot;hash_traversal_mask()&quot;</span> from Hash::Util
      or by using the PERL_PERTURB_KEYS environment variable, see
      &quot;PERL_PERTURB_KEYS&quot; in perlrun. Note that this feature controls
      the &quot;visible&quot; order of the keys, and not the actual order they
      are stored in.</dd>
  <dt id="Bucket"><a class="permalink" href="#Bucket">Bucket Order
    Perturbance</a></dt>
  <dd>When items collide into a given hash bucket the order they are stored in
      the chain is no longer predictable in Perl 5.18. This has the intention to
      make it harder to observe a collision. This behavior can be overridden by
      using the PERL_PERTURB_KEYS environment variable, see
      &quot;PERL_PERTURB_KEYS&quot; in perlrun.</dd>
  <dt id="New"><a class="permalink" href="#New">New Default Hash
    Function</a></dt>
  <dd>The default hash function has been modified with the intention of making
      it harder to infer the hash seed.</dd>
  <dt id="Alternative"><a class="permalink" href="#Alternative">Alternative Hash
    Functions</a></dt>
  <dd>The source code includes multiple hash algorithms to choose from. While we
      believe that the default perl hash is robust to attack, we have included
      the hash function Siphash as a fall-back option. At the time of release of
      Perl 5.18.0 Siphash is believed to be of cryptographic strength. This is
      not the default as it is much slower than the default hash.</dd>
</dl>
</div>
<div class="Bd-indent">
<p class="Pp">Without compiling a special Perl, there is no way to get the exact
    same behavior of any versions prior to Perl 5.18.0. The closest one can get
    is by setting PERL_PERTURB_KEYS to 0 and setting the PERL_HASH_SEED to a
    known value. We do not advise those settings for production use due to the
    above security considerations.</p>
<p class="Pp"><b>Perl has never guaranteed any ordering of the hash keys</b>,
    and the ordering has already changed several times during the lifetime of
    Perl 5. Also, the ordering of hash keys has always been, and continues to
    be, affected by the insertion order and the history of changes made to the
    hash over its lifetime.</p>
<p class="Pp">Also note that while the order of the hash elements might be
    randomized, this &quot;pseudo-ordering&quot; should <b>not</b> be used for
    applications like shuffling a list randomly (use
    <span class="Li">&quot;List::Util::shuffle()&quot;</span> for that, see
    List::Util, a standard core module since Perl 5.8.0; or the CPAN module
    <span class="Li">&quot;Algorithm::Numerical::Shuffle&quot;</span>), or for
    generating permutations (use e.g. the CPAN modules
    <span class="Li">&quot;Algorithm::Permute&quot;</span> or
    <span class="Li">&quot;Algorithm::FastPermute&quot;</span>), or for any
    cryptographic applications.</p>
<p class="Pp">Tied hashes may have their own ordering and algorithmic complexity
    attacks.</p>
</div>
<ul class="Bl-bullet">
  <li>Regular expressions - Perl's regular expression engine is so called NFA
      (Non-deterministic Finite Automaton), which among other things means that
      it can rather easily consume large amounts of both time and space if the
      regular expression may match in several ways. Careful crafting of the
      regular expressions can help but quite often there really isn't much one
      can do (the book &quot;Mastering Regular Expressions&quot; is required
      reading, see perlfaq2). Running out of space manifests itself by Perl
      running out of memory.</li>
  <li>Sorting - the quicksort algorithm used in Perls before 5.8.0 to implement
      the <b>sort()</b> function was very easy to trick into misbehaving so that
      it consumes a lot of time. Starting from Perl 5.8.0 a different sorting
      algorithm, mergesort, is used by default. Mergesort cannot misbehave on
      any input.</li>
</ul>
<p class="Pp">See
    &lt;https://www.usenix.org/legacy/events/sec03/tech/full_papers/crosby/crosby.pdf&gt;
    for more information, and any computer science textbook on algorithmic
    complexity.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Using_Sudo"><a class="permalink" href="#Using_Sudo">Using
  Sudo</a></h2>
<p class="Pp">The popular tool <span class="Li">&quot;sudo&quot;</span> provides
    a controlled way for users to be able to run programs as other users. It
    sanitises the execution environment to some extent, and will avoid the
    shebang race condition. If you don't have the safe version of set-id
    scripts, then <span class="Li">&quot;sudo&quot;</span> may be a more
    convenient way of executing a script as another user than writing a C
    wrapper would be.</p>
<p class="Pp">However, <span class="Li">&quot;sudo&quot;</span> sets the real
    user or group ID to that of the target identity, not just the effective ID
    as set-id bits do. As a result, Perl can't detect that it is running under
    <span class="Li">&quot;sudo&quot;</span>, and so won't automatically take
    its own security precautions such as turning on taint mode. Where
    <span class="Li">&quot;sudo&quot;</span> configuration dictates exactly
    which command can be run, the approved command may include a
    <span class="Li">&quot;-T&quot;</span> option to perl to enable taint
  mode.</p>
<p class="Pp">In general, it is necessary to evaluate the suitability of a
    script to run under <span class="Li">&quot;sudo&quot;</span> specifically
    with that kind of execution environment in mind. It is neither necessary nor
    sufficient for the same script to be suitable to run in a traditional set-id
    arrangement, though many of the issues overlap.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp">&quot;ENVIRONMENT&quot; in perlrun for its description of cleaning
    up environment variables.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2020-10-24</td>
    <td class="foot-os">perl v5.34.0</td>
  </tr>
</table>
</body>
</html>
