<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>lwpcook(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">lwpcook(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">lwpcook(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
lwpcook - The libwww-perl cookbook
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
This document contain some examples that show typical usage of the libwww-perl
  library. You should consult the documentation for the individual modules for
  more detail.
<p class="Pp">All examples should be runnable programs. You can, in most cases,
    test the code sections by piping the program text directly to perl.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="GET"><a class="permalink" href="#GET">GET</a></h1>
It is very easy to use this library to just fetch documents from the net. The
  LWP::Simple module provides the <i>get()</i> function that return the document
  specified by its URL argument:
<p class="Pp"><span class="Li"></span></p>
<pre>
  use LWP::Simple;
  $doc = get 'http://search.cpan.org/dist/libwww-perl/';
</pre>
<p class="Pp">or, as a perl one-liner using the <i>getprint()</i> function:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  perl -MLWP::Simple -e 'getprint &quot;http://search.cpan.org/dist/libwww-perl/&quot;'
</pre>
<p class="Pp">or, how about fetching the latest perl by running this
  command:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  perl -MLWP::Simple -e '
    getstore &quot;ftp://ftp.sunet.se/pub/lang/perl/CPAN/src/latest.tar.gz&quot;,
             &quot;perl.tar.gz&quot;'
</pre>
<p class="Pp">You will probably first want to find a CPAN site closer to you by
    running something like the following command:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  perl -MLWP::Simple -e 'getprint &quot;http://www.cpan.org/SITES.html&quot;'
</pre>
<p class="Pp">Enough of this simple stuff! The LWP object oriented interface
    gives you more control over the request sent to the server. Using this
    interface you have full control over headers sent and how you want to handle
    the response returned.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  use LWP::UserAgent;
  $ua = LWP::UserAgent-&gt;new;
  $ua-&gt;agent(&quot;$0/0.1 &quot; . $ua-&gt;agent);
  # $ua-&gt;agent(&quot;Mozilla/8.0&quot;) # pretend we are very capable browser

  $req = HTTP::Request-&gt;new(
     GET =&gt; 'http://search.cpan.org/dist/libwww-perl/');
  $req-&gt;header('Accept' =&gt; 'text/html');

  # send request
  $res = $ua-&gt;request($req);

  # check the outcome
  if ($res-&gt;is_success) {
     print $res-&gt;decoded_content;
  }
  else {
     print &quot;Error: &quot; . $res-&gt;status_line . &quot;\n&quot;;
  }
</pre>
<p class="Pp">The lwp-request program (alias GET) that is distributed with the
    library can also be used to fetch documents from WWW servers.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="HEAD"><a class="permalink" href="#HEAD">HEAD</a></h1>
If you just want to check if a document is present (i.e. the URL is valid) try
  to run code that looks like this:
<p class="Pp"><span class="Li"></span></p>
<pre>
  use LWP::Simple;

  if (head($url)) {
     # ok document exists
  }
</pre>
<p class="Pp">The <i>head()</i> function really returns a list of
    meta-information about the document. The first three values of the list
    returned are the document type, the size of the document, and the age of the
    document.</p>
<p class="Pp">More control over the request or access to all header values
    returned require that you use the object oriented interface described for
    GET above. Just s/GET/HEAD/g.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="POST"><a class="permalink" href="#POST">POST</a></h1>
There is no simple procedural interface for posting data to a WWW server. You
  must use the object oriented interface for this. The most common POST
  operation is to access a WWW form application:
<p class="Pp"><span class="Li"></span></p>
<pre>
  use LWP::UserAgent;
  $ua = LWP::UserAgent-&gt;new;

  my $req = HTTP::Request-&gt;new(
      POST =&gt; 'http://rt.cpan.org/Public/Dist/Display.html');
  $req-&gt;content_type('application/x-www-form-urlencoded');
  $req-&gt;content('Status=Active&amp;Name=libwww-perl');

  my $res = $ua-&gt;request($req);
  print $res-&gt;as_string;
</pre>
<p class="Pp">Lazy people use the HTTP::Request::Common module to set up a
    suitable POST request message (it handles all the escaping issues) and has a
    suitable default for the content_type:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  use HTTP::Request::Common qw(POST);
  use LWP::UserAgent;
  $ua = LWP::UserAgent-&gt;new;

  my $req = POST 'http://rt.cpan.org/Public/Dist/Display.html',
                [ Status =&gt; 'Active', Name =&gt; 'libwww-perl' ];

  print $ua-&gt;request($req)-&gt;as_string;
</pre>
<p class="Pp">The lwp-request program (alias POST) that is distributed with the
    library can also be used for posting data.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="PROXIES"><a class="permalink" href="#PROXIES">PROXIES</a></h1>
Some sites use proxies to go through fire wall machines, or just as cache in
  order to improve performance. Proxies can also be used for accessing resources
  through protocols not supported directly (or supported badly :-) by the
  libwww-perl library.
<p class="Pp">You should initialize your proxy setting before you start sending
    requests:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  use LWP::UserAgent;
  $ua = LWP::UserAgent-&gt;new;
  $ua-&gt;env_proxy; # initialize from environment variables
  # or
  $ua-&gt;proxy(ftp  =&gt; 'http://proxy.myorg.com');
  $ua-&gt;proxy(wais =&gt; 'http://proxy.myorg.com');
  $ua-&gt;no_proxy(qw(no se fi));

  my $req = HTTP::Request-&gt;new(GET =&gt; 'wais://xxx.com/');
  print $ua-&gt;request($req)-&gt;as_string;
</pre>
<p class="Pp">The LWP::Simple interface will call <i>env_proxy()</i> for you
    automatically. Applications that use the
    <span class="Li">$ua</span>-&gt;<i>env_proxy()</i> method will normally not
    use the <span class="Li">$ua</span>-&gt;<i>proxy()</i> and
    <span class="Li">$ua</span>-&gt;<i>no_proxy()</i> methods.</p>
<p class="Pp">Some proxies also require that you send it a username/password in
    order to let requests through. You should be able to add the required
    header, with something like this:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
 use LWP::UserAgent;

 $ua = LWP::UserAgent-&gt;new;
 $ua-&gt;proxy(['http', 'ftp'] =&gt; 'http://username:password@proxy.myorg.com');

 $req = HTTP::Request-&gt;new('GET',&quot;http://www.perl.com&quot;);

 $res = $ua-&gt;request($req);
 print $res-&gt;decoded_content if $res-&gt;is_success;
</pre>
<p class="Pp">Replace <span class="Li">&quot;proxy.myorg.com&quot;</span>,
    <span class="Li">&quot;username&quot;</span> and
    <span class="Li">&quot;password&quot;</span> with something suitable for
    your site.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="ACCESS_TO_PROTECTED_DOCUMENTS"><a class="permalink" href="#ACCESS_TO_PROTECTED_DOCUMENTS">ACCESS
  TO PROTECTED DOCUMENTS</a></h1>
Documents protected by basic authorization can easily be accessed like this:
<p class="Pp"><span class="Li"></span></p>
<pre>
  use LWP::UserAgent;
  $ua = LWP::UserAgent-&gt;new;
  $req = HTTP::Request-&gt;new(GET =&gt; 'http://www.linpro.no/secret/');
  $req-&gt;authorization_basic('aas', 'mypassword');
  print $ua-&gt;request($req)-&gt;as_string;
</pre>
<p class="Pp">The other alternative is to provide a subclass of
    <i>LWP::UserAgent</i> that overrides the <i>get_basic_credentials()</i>
    method. Study the <i>lwp-request</i> program for an example of this.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COOKIES"><a class="permalink" href="#COOKIES">COOKIES</a></h1>
Some sites like to play games with cookies. By default LWP ignores cookies
  provided by the servers it visits. LWP will collect cookies and respond to
  cookie requests if you set up a cookie jar.
<p class="Pp"><span class="Li"></span></p>
<pre>
  use LWP::UserAgent;
  use HTTP::Cookies;

  $ua = LWP::UserAgent-&gt;new;
  $ua-&gt;cookie_jar(HTTP::Cookies-&gt;new(file =&gt; &quot;lwpcookies.txt&quot;,
                                     autosave =&gt; 1));

  # and then send requests just as you used to do
  $res = $ua-&gt;request(HTTP::Request-&gt;new(GET =&gt; &quot;http://no.yahoo.com/&quot;));
  print $res-&gt;status_line, &quot;\n&quot;;
</pre>
<p class="Pp">As you visit sites that send you cookies to keep, then the file
    <i>lwpcookies.txt&quot;</i> will grow.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="HTTPS"><a class="permalink" href="#HTTPS">HTTPS</a></h1>
URLs with https scheme are accessed in exactly the same way as with http scheme,
  provided that an SSL interface module for LWP has been properly installed (see
  the <i>README.SSL</i> file found in the libwww-perl distribution for more
  details). If no SSL interface is installed for LWP to use, then you will get
  &quot;501 Protocol scheme 'https' is not supported&quot; errors when accessing
  such URLs.
<p class="Pp">Here's an example of fetching and printing a WWW page using
  SSL:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  use LWP::UserAgent;

  my $ua = LWP::UserAgent-&gt;new;
  my $req = HTTP::Request-&gt;new(GET =&gt; 'https://www.helsinki.fi/');
  my $res = $ua-&gt;request($req);
  if ($res-&gt;is_success) {
      print $res-&gt;as_string;
  }
  else {
      print &quot;Failed: &quot;, $res-&gt;status_line, &quot;\n&quot;;
  }
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="MIRRORING"><a class="permalink" href="#MIRRORING">MIRRORING</a></h1>
If you want to mirror documents from a WWW server, then try to run code similar
  to this at regular intervals:
<p class="Pp"><span class="Li"></span></p>
<pre>
  use LWP::Simple;

  %mirrors = (
     'http://www.sn.no/'                       =&gt; 'sn.html',
     'http://www.perl.com/'                    =&gt; 'perl.html',
     'http://search.cpan.org/distlibwww-perl/' =&gt; 'lwp.html',
     'gopher://gopher.sn.no/'                  =&gt; 'gopher.html',
  );

  while (($url, $localfile) = each(%mirrors)) {
     mirror($url, $localfile);
  }
</pre>
<p class="Pp">Or, as a perl one-liner:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  perl -MLWP::Simple -e 'mirror(&quot;http://www.perl.com/&quot;, &quot;perl.html&quot;)';
</pre>
<p class="Pp">The document will not be transferred unless it has been
  updated.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="LARGE_DOCUMENTS"><a class="permalink" href="#LARGE_DOCUMENTS">LARGE
  DOCUMENTS</a></h1>
If the document you want to fetch is too large to be kept in memory, then you
  have two alternatives. You can instruct the library to write the document
  content to a file (second <span class="Li">$ua</span>-&gt;<i>request()</i>
  argument is a file name):
<p class="Pp"><span class="Li"></span></p>
<pre>
  use LWP::UserAgent;
  $ua = LWP::UserAgent-&gt;new;

  my $req = HTTP::Request-&gt;new(GET =&gt;
     'http://www.cpan.org/authors/Gisle_Aas/libwww-perl-6.02.tar.gz');
  $res = $ua-&gt;request($req, &quot;libwww-perl.tar.gz&quot;);
  if ($res-&gt;is_success) {
     print &quot;ok\n&quot;;
  }
  else {
     print $res-&gt;status_line, &quot;\n&quot;;
  }
</pre>
<p class="Pp">Or you can process the document as it arrives (second
    <span class="Li">$ua</span>-&gt;<i>request()</i> argument is a code
    reference):</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  use LWP::UserAgent;
  $ua = LWP::UserAgent-&gt;new;
  $URL = 'ftp://ftp.unit.no/pub/rfc/rfc-index.txt';

  my $expected_length;
  my $bytes_received = 0;
  my $res =
     $ua-&gt;request(HTTP::Request-&gt;new(GET =&gt; $URL),
               sub {
                   my($chunk, $res) = @_;
                   $bytes_received += length($chunk);
                   unless (defined $expected_length) {
                      $expected_length = $res-&gt;content_length || 0;
                   }
                   if ($expected_length) {
                        printf STDERR &quot;%d%% - &quot;,
                                  100 * $bytes_received / $expected_length;
                   }
                   print STDERR &quot;$bytes_received bytes received\n&quot;;

                   # XXX Should really do something with the chunk itself
                   # print $chunk;
               });
   print $res-&gt;status_line, &quot;\n&quot;;
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT"><a class="permalink" href="#COPYRIGHT">COPYRIGHT</a></h1>
Copyright 1996-2001, Gisle Aas
<p class="Pp">This library is free software; you can redistribute it and/or
    modify it under the same terms as Perl itself.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2012-02-11</td>
    <td class="foot-os">perl v5.18.4</td>
  </tr>
</table>
</body>
</html>
