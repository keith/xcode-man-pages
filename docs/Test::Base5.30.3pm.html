<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    .Nd, .Bf, .Op { display: inline; }
    .Pa, .Ad { font-style: italic; }
    .Ms { font-weight: bold; }
    .Bl-diag > dt { font-weight: bold; }
    code.Nm, .Fl, .Cm, .Ic, code.In, .Fd, .Fn, .Cd { font-weight: bold;
      font-family: inherit; }
  </style>
  <title>Test::Base(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Test::Base(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Test::Base(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Test::Base - A Data Driven Testing Framework</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<p class="Pp">A new test module:</p>
<p class="Pp"></p>
<pre>    # lib/MyProject/Test.pm
    package MyProject::Test;
    use Test::Base -Base;
    use MyProject;
    package MyProject::Test::Filter;
    use Test::Base::Filter -base;
    sub my_filter {
        return MyProject-&gt;do_something(shift);
    }
</pre>
<p class="Pp">A sample test:</p>
<p class="Pp"></p>
<pre>    # t/sample.t
    use MyProject::Test;
    plan tests =&gt; 1 * blocks;
    run_is input =&gt; 'expected';
    sub local_filter {
        s/my/your/;
    }
    __END__
    === Test one (the name of the test)
    --- input my_filter local_filter
    my
    input
    lines
    --- expected
    expected
    output
    === Test two
    This is an optional description
    of this particular test.
    --- input my_filter
    other
    input
    lines
    --- expected
    other expected
    output
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">Testing is usually the ugly part of Perl module authoring. Perl
    gives you a standard way to run tests with Test::Harness, and basic testing
    primitives with Test::More. After that you are pretty much on your own to
    develop a testing framework and philosophy. Test::More encourages you to
    make your own framework by subclassing Test::Builder, but that is not
    trivial.</p>
<p class="Pp">Test::Base gives you a way to write your own test framework base
    class that <i>is</i> trivial. In fact it is as simple as two lines:</p>
<p class="Pp"></p>
<pre>    package MyTestFramework;
    use Test::Base -Base;
</pre>
<p class="Pp">A module called
    <span class="Li">&quot;MyTestFramework.pm&quot;</span> containing those two
    lines, will give all the power of Test::More and all the power of Test::Base
    to every test file that uses it. As you build up the capabilities of
    <span class="Li">&quot;MyTestFramework&quot;</span>, your tests will have
    all of that power as well.</p>
<p class="Pp"><span class="Li">&quot;MyTestFramework&quot;</span> becomes a
    place for you to put all of your reusable testing bits. As you write tests,
    you will see patterns and duplication, and you can &quot;upstream&quot; them
    into <span class="Li">&quot;MyTestFramework&quot;</span>. Of course, you
    don't have to subclass Test::Base at all. You can use it directly in many
    applications, including everywhere you would use Test::More.</p>
<p class="Pp">Test::Base concentrates on offering reusable data driven patterns,
    so that you can write tests with a minimum of code. At the heart of all
    testing you have inputs, processes and expected outputs. Test::Base provides
    some clean ways for you to express your input and expected output data, so
    you can spend your</p>
<p class="Pp"></p>
<pre>      time focusing on that rather than your code scaffolding.
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="EXPORTED_FUNCTIONS"><a class="permalink" href="#EXPORTED_FUNCTIONS">EXPORTED
  FUNCTIONS</a></h1>
<p class="Pp">Test::Base extends Test::More and exports all of its functions. So
    you can basically write your tests the same as Test::More. Test::Base also
    exports many functions of its own:</p>
<dl class="Bl-tag">
  <dt>&quot;is(actual, expected, [test-name])&quot;</dt>
  <dd>This is the equivalent of Test::More's
      <span class="Li">&quot;is&quot;</span> function with one interesting
      twist. If your actual and expected results differ and the output is multi-
      line, this function will show you a unified diff format of output.
      Consider the benefit when looking for the one character that is different
      in hundreds of lines of output!
    <p class="Pp">Diff output requires the optional
        <span class="Li">&quot;Text::Diff&quot;</span> CPAN module. If you don't
        have this module, the <span class="Li">&quot;is()&quot;</span> function
        will simply give you normal Test::More output. To disable diffing
        altogether, set the
        <span class="Li">&quot;TEST_SHOW_NO_DIFFS&quot;</span> environment
        variable (or <span class="Li">$ENV{TEST_SHOW_NO_DIFFS}</span>) to a true
        value. You can also call the <span class="Li">&quot;no_diff&quot;</span>
        function as a shortcut.</p>
  </dd>
  <dt>&quot;blocks( [data-section-name] )&quot;</dt>
  <dd>The most important function is <span class="Li">&quot;blocks&quot;</span>.
      In list context it returns a list of
      <span class="Li">&quot;Test::Base::Block&quot;</span> objects that are
      generated from the test specification in the
      <span class="Li">&quot;DATA&quot;</span> section of your test file. In
      scalar context it returns the number of objects. This is useful to
      calculate your Test::More plan.
    <p class="Pp">Each Test::Base::Block object has methods that correspond to
        the names of that object's data sections. There is also a
        <span class="Li">&quot;name&quot;</span> and a
        <span class="Li">&quot;description&quot;</span> method for accessing
        those parts of the block if they were specified.</p>
    <p class="Pp">The <span class="Li">&quot;blocks&quot;</span> function can
        take an optional single argument, that indicates to only return the
        blocks that contain a particular named data section. Otherwise
        <span class="Li">&quot;blocks&quot;</span> returns all blocks.</p>
    <p class="Pp"></p>
    <pre>    my @all_of_my_blocks = blocks;
    my @just_the_foo_blocks = blocks('foo');
    </pre>
  </dd>
  <dt>&quot;next_block()&quot;</dt>
  <dd>You can use the next_block function to iterate over all the blocks.
    <p class="Pp"></p>
    <pre>    while (my $block = next_block) {
        ...
    }
    </pre>
    <p class="Pp">It returns undef after all blocks have been iterated over. It
        can then be called again to reiterate.</p>
  </dd>
  <dt>&quot;first_block()&quot;</dt>
  <dd>Returns the first block or undef if there are none. It resets the iterator
      to the <span class="Li">&quot;next_block&quot;</span> function.</dd>
  <dt>&quot;run(&amp;subroutine)&quot;</dt>
  <dd>There are many ways to write your tests. You can reference each block
      individually or you can loop over all the blocks and perform a common
      operation. The <span class="Li">&quot;run&quot;</span> function does the
      looping for you, so all you need to do is pass it a code block to execute
      for each block.
    <p class="Pp">The <span class="Li">&quot;run&quot;</span> function takes a
        subroutine as an argument, and calls the sub one time for each block in
        the specification. It passes the current block object to the
      subroutine.</p>
    <p class="Pp"></p>
    <pre>    run {
        my $block = shift;
        is(process($block-&gt;foo), $block-&gt;bar, $block-&gt;name);
    };
    </pre>
  </dd>
  <dt>&quot;run_is([data_name1, data_name2])&quot;</dt>
  <dd>Many times you simply want to see if two data sections are equivalent in
      every block, probably after having been run through one or more filters.
      With the <span class="Li">&quot;run_is&quot;</span> function, you can just
      pass the names of any two data sections that exist in every block, and it
      will loop over every block comparing the two sections.
    <p class="Pp"></p>
    <pre>    run_is 'foo', 'bar';
    </pre>
    <p class="Pp">If no data sections are given
        <span class="Li">&quot;run_is&quot;</span> will try to detect them
        automatically.</p>
    <p class="Pp">NOTE: Test::Base will silently ignore any blocks that don't
        contain
      <br/>
       both sections.</p>
  </dd>
  <dt>&quot;is_deep($data1, $data2, $test_name)&quot;</dt>
  <dd>Like Test::More's <span class="Li">&quot;is_deeply&quot;</span> but uses
      the more correct Test::Deep module.</dd>
  <dt>&quot;run_is_deeply([data_name1, data_name2])&quot;</dt>
  <dd>Like <span class="Li">&quot;run_is_deeply&quot;</span> but uses
      <span class="Li">&quot;is_deep&quot;</span> which uses the more correct
      Test::Deep.</dd>
  <dt>&quot;run_is_deeply([data_name1, data_name2])&quot;</dt>
  <dd>Like <span class="Li">&quot;run_is&quot;</span> but uses
      <span class="Li">&quot;is_deeply&quot;</span> for complex data structure
      comparison.</dd>
  <dt>&quot;run_is_deeply([data_name1, data_name2])&quot;</dt>
  <dd>Like <span class="Li">&quot;run_is_deeply&quot;</span> but uses
      <span class="Li">&quot;is_deep&quot;</span> which uses the more correct
      Test::Deep.</dd>
  <dt>&quot;run_like([data_name, regexp | data_name]);&quot;</dt>
  <dd>The <span class="Li">&quot;run_like&quot;</span> function is similar to
      <span class="Li">&quot;run_is&quot;</span> except the second argument is a
      regular expression. The regexp can either be a
      <span class="Li">&quot;qr{}&quot;</span> object or a data section that has
      been filtered into a regular expression.
    <p class="Pp"></p>
    <pre>    run_like 'foo', qr{&lt;html.*};
    run_like 'foo', 'match';
    </pre>
  </dd>
  <dt>&quot;run_unlike([data_name, regexp | data_name]);&quot;</dt>
  <dd>The <span class="Li">&quot;run_unlike&quot;</span> function is similar to
      <span class="Li">&quot;run_like&quot;</span>, except the opposite.
    <p class="Pp"></p>
    <pre>    run_unlike 'foo', qr{&lt;html.*};
    run_unlike 'foo', 'no_match';
    </pre>
  </dd>
  <dt>&quot;run_compare(data_name1, data_name2)&quot;</dt>
  <dd>The <span class="Li">&quot;run_compare&quot;</span> function is like the
      <span class="Li">&quot;run_is&quot;</span>,
      <span class="Li">&quot;run_is_deeply&quot;</span> and the
      <span class="Li">&quot;run_like&quot;</span> functions all rolled into
      one. It loops over each relevant block and determines what type of
      comparison to do.
    <p class="Pp">NOTE: If you do not specify either a plan, or run any tests,
        the
      <br/>
       <span class="Li">&quot;run_compare&quot;</span> function will
        automatically be run.</p>
  </dd>
  <dt>&quot;delimiters($block_delimiter, $data_delimiter)&quot;</dt>
  <dd>Override the default delimiters of <span class="Li">&quot;===&quot;</span>
      and <span class="Li">&quot;---&quot;</span>.</dd>
  <dt>&quot;spec_file($file_name)&quot;</dt>
  <dd>By default, Test::Base reads its input from the DATA section. This
      function tells it to get the spec from a file instead.</dd>
  <dt>&quot;spec_string($test_data)&quot;</dt>
  <dd>By default, Test::Base reads its input from the DATA section. This
      function tells it to get the spec from a string that has been prepared
      somehow.</dd>
  <dt>&quot;filters( @filters_list or $filters_hashref )&quot;</dt>
  <dd>Specify a list of additional filters to be applied to all blocks. See
      <span class="Li">&quot;FILTERS&quot;</span> below.
    <p class="Pp">You can also specify a hash ref that maps data section names
        to an array ref of filters for that data type.</p>
    <p class="Pp"></p>
    <pre>    filters {
        xxx =&gt; [qw(chomp lines)],
        yyy =&gt; ['yaml'],
        zzz =&gt; 'eval',
    };
    </pre>
    <p class="Pp">If a filters list has only one element, the array ref is
        optional.</p>
  </dd>
  <dt>&quot;filters_delay( [1 | 0] );&quot;</dt>
  <dd>By default Test::Base::Block objects are have all their filters run ahead
      of time. There are testing situations in which it is advantageous to delay
      the filtering. Calling this function with no arguments or a true value,
      causes the filtering to be delayed.
    <p class="Pp"></p>
    <pre>    use Test::Base;
    filters_delay;
    plan tests =&gt; 1 * blocks;
    for my $block (blocks) {
        ...
        $block-&gt;run_filters;
        ok($block-&gt;is_filtered);
        ...
    }
    </pre>
    <p class="Pp">In the code above, the filters are called manually, using the
        <span class="Li">&quot;run_filters&quot;</span> method of
        Test::Base::Block. In functions like
        <span class="Li">&quot;run_is&quot;</span>, where the tests are run
        automatically, filtering is delayed until right before the test.</p>
  </dd>
  <dt>&quot;filter_arguments()&quot;</dt>
  <dd>Return the arguments after the equals sign on a filter.
    <p class="Pp"></p>
    <pre>    sub my_filter {
        my $args = filter_arguments;
        # is($args, 'whazzup');
        ...
    }
    __DATA__
    === A test
    --- data my_filter=whazzup
    </pre>
  </dd>
  <dt>&quot;tie_output()&quot;</dt>
  <dd>You can capture STDOUT and STDERR for operations with this function:
    <p class="Pp"></p>
    <pre>    my $out = '';
    tie_output(*STDOUT, $out);
    print &quot;Hey!\n&quot;;
    print &quot;Che!\n&quot;;
    untie *STDOUT;
    is($out, &quot;Hey!\nChe!\n&quot;);
    </pre>
  </dd>
  <dt>&quot;no_diff()&quot;</dt>
  <dd>Turn off diff support for <b>is()</b> in a test file.</dd>
  <dt>&quot;default_object()&quot;</dt>
  <dd>Returns the default Test::Base object. This is useful if you feel the need
      to do an OO operation in otherwise functional test code. See OO
    below.</dd>
  <dt>&quot;WWW() XXX() YYY() ZZZ()&quot;</dt>
  <dd>These debugging functions are exported from the Spiffy.pm module. See
      Spiffy for more info.</dd>
  <dt>&quot;croak() carp() cluck() confess()&quot;</dt>
  <dd>You can use the functions from the Carp module without needing to import
      them. Test::Base does it for you by default.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="TEST_SPECIFICATION"><a class="permalink" href="#TEST_SPECIFICATION">TEST
  SPECIFICATION</a></h1>
<p class="Pp">Test::Base allows you to specify your test data in an external
    file, the DATA section of your program or from a scalar variable containing
    all the text input.</p>
<p class="Pp">A <i>test specification</i> is a series of text lines. Each test
    (or block) is separated by a line containing the block delimiter and an
    optional test <span class="Li">&quot;name&quot;</span>. Each block is
    further subdivided into named sections with a line containing the data
    delimiter and the data section name. A
    <span class="Li">&quot;description&quot;</span> of the test can go on lines
    after the block delimiter but before the first data section.</p>
<p class="Pp">Here is the basic layout of a specification:</p>
<p class="Pp"></p>
<pre>    === &lt;block name 1&gt;
    &lt;optional block description lines&gt;
    --- &lt;data section name 1&gt; &lt;filter-1&gt; &lt;filter-2&gt; &lt;filter-n&gt;
    &lt;test data lines&gt;
    --- &lt;data section name 2&gt; &lt;filter-1&gt; &lt;filter-2&gt; &lt;filter-n&gt;
    &lt;test data lines&gt;
    --- &lt;data section name n&gt; &lt;filter-1&gt; &lt;filter-2&gt; &lt;filter-n&gt;
    &lt;test data lines&gt;
    === &lt;block name 2&gt;
    &lt;optional block description lines&gt;
    --- &lt;data section name 1&gt; &lt;filter-1&gt; &lt;filter-2&gt; &lt;filter-n&gt;
    &lt;test data lines&gt;
    --- &lt;data section name 2&gt; &lt;filter-1&gt; &lt;filter-2&gt; &lt;filter-n&gt;
    &lt;test data lines&gt;
    --- &lt;data section name n&gt; &lt;filter-1&gt; &lt;filter-2&gt; &lt;filter-n&gt;
    &lt;test data lines&gt;
</pre>
<p class="Pp">Here is a code example:</p>
<p class="Pp"></p>
<pre>    use Test::Base;
    delimiters qw(### :::);
    # test code here
    __END__
    ### Test One
    We want to see if foo and bar
    are really the same...
    ::: foo
    a foo line
    another foo line
    ::: bar
    a bar line
    another bar line
    ### Test Two
    ::: foo
    some foo line
    some other foo line
    ::: bar
    some bar line
    some other bar line
    ::: baz
    some baz line
    some other baz line
</pre>
<p class="Pp">This example specifies two blocks. They both have foo and bar data
    sections. The second block has a baz component. The block delimiter is
    <span class="Li">&quot;###&quot;</span> and the data delimiter is
    <span class="Li">&quot;:::&quot;</span>.</p>
<p class="Pp">The default block delimiter is
    <span class="Li">&quot;===&quot;</span> and the default data delimiter is
    <span class="Li">&quot;---</span> <span class="Li">&quot;</span>.</p>
<p class="Pp">There are some special data section names used for control
    purposes:</p>
<p class="Pp"></p>
<pre>    --- SKIP
    --- ONLY
    --- LAST
</pre>
<p class="Pp">A block with a SKIP section causes that test to be ignored. This
    is useful to disable a test temporarily.</p>
<p class="Pp">A block with an ONLY section causes only that block to be used.
    This is useful when you are concentrating on getting a single test to pass.
    If there is more than one block with ONLY, the first one will be chosen.</p>
<p class="Pp">Because ONLY is very useful for debugging and sometimes you forgot
    to remove the ONLY flag before committing to the VCS or uploading to CPAN,
    Test::Base by default gives you a diag message saying <i>I found ONLY ...
    maybe you're</i> <i>debugging?</i>. If you don't like it, use
    <span class="Li">&quot;no_diag_on_only&quot;</span>.</p>
<p class="Pp">A block with a LAST section makes that block the last one in the
    specification. All following blocks will be ignored.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="FILTERS"><a class="permalink" href="#FILTERS">FILTERS</a></h1>
<p class="Pp">The real power in writing tests with Test::Base comes from its
    filtering capabilities. Test::Base comes with an ever growing set of useful
    generic filters than you can sequence and apply to various test blocks. That
    means you can specify the block serialization in the most readable format
    you can find, and let the filters translate it into what you really need for
    a test. It is easy to write your own filters as well.</p>
<p class="Pp">Test::Base allows you to specify a list of filters to each data
    section of each block. The default filters are
    <span class="Li">&quot;norm&quot;</span> and
    <span class="Li">&quot;trim&quot;</span>. These filters will be applied (in
    order) to the data after it has been parsed from the specification and
    before it is set into its Test::Base::Block object.</p>
<p class="Pp">You can add to the default filter list with the
    <span class="Li">&quot;filters&quot;</span> function. You can specify
    additional filters to a specific block by listing them after the section
    name on a data section delimiter line.</p>
<p class="Pp">Example:</p>
<p class="Pp"></p>
<pre>    use Test::Base;
    filters qw(foo bar);
    filters { perl =&gt; 'strict' };
    sub upper { uc(shift) }
    __END__
    === Test one
    --- foo trim chomp upper
    ...
    --- bar -norm
    ...
    --- perl eval dumper
    my @foo = map {
        - $_;
    } 1..10;
    \ @foo;
</pre>
<p class="Pp">Putting a <span class="Li">&quot;-&quot;</span> before a filter on
    a delimiter line, disables that filter.</p>
<section class="Ss">
<h2 class="Ss" id="Scalar_vs_List"><a class="permalink" href="#Scalar_vs_List">Scalar
  vs List</a></h2>
<p class="Pp">Each filter can take either a scalar or a list as input, and will
    return either a scalar or a list. Since filters are chained together, it is
    important to learn which filters expect which kind of input and return which
    kind of output.</p>
<p class="Pp">For example, consider the following filter list:</p>
<p class="Pp"></p>
<pre>    norm trim lines chomp array dumper eval
</pre>
<p class="Pp">The data always starts out as a single scalar string.
    <span class="Li">&quot;norm&quot;</span> takes a scalar and returns a
    scalar. <span class="Li">&quot;trim&quot;</span> takes a list and returns a
    list, but a scalar is a valid list.
    <span class="Li">&quot;lines&quot;</span> takes a scalar and returns a list.
    <span class="Li">&quot;chomp&quot;</span> takes a list and returns a list.
    <span class="Li">&quot;array&quot;</span> takes a list and returns a scalar
    (an anonymous array reference containing the list elements).
    <span class="Li">&quot;dumper&quot;</span> takes a list and returns a
    scalar. <span class="Li">&quot;eval&quot;</span> takes a scalar and creates
    a list.</p>
<p class="Pp">A list of exactly one element works fine as input to a filter
    requiring a scalar, but any other list will cause an exception. A scalar in
    list context is considered a list of one element.</p>
<p class="Pp">Data accessor methods for blocks will return a list of values when
    used in list context, and the first element of the list in scalar context.
    This is usually &quot;the right thing&quot;, but be aware.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="The_Stock_Filters"><a class="permalink" href="#The_Stock_Filters">The
  Stock Filters</a></h2>
<p class="Pp">Test::Base comes with large set of stock filters. They are in the
    <span class="Li">&quot;Test::Base::Filter&quot;</span> module. See
    Test::Base::Filter for a listing and description of these filters.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Rolling_Your_Own_Filters"><a class="permalink" href="#Rolling_Your_Own_Filters">Rolling
  Your Own Filters</a></h2>
<p class="Pp">Creating filter extensions is very simple. You can either write a
    <i>function</i> in the <span class="Li">&quot;main&quot;</span> namespace,
    or a <i>method</i> in the
    <span class="Li">&quot;Test::Base::Filter&quot;</span> namespace or a
    subclass of it. In either case the text and any extra arguments are passed
    in and you return whatever you want the new value to be.</p>
<p class="Pp">Here is a self explanatory example:</p>
<p class="Pp"></p>
<pre>    use Test::Base;
    filters 'foo', 'bar=xyz';
    sub foo {
        transform(shift);
    }
    sub Test::Base::Filter::bar {
        my $self = shift;       # The Test::Base::Filter object
        my $data = shift;
        my $args = $self-&gt;current_arguments;
        my $current_block_object = $self-&gt;block;
        # transform $data in a barish manner
        return $data;
    }
</pre>
<p class="Pp">If you use the method interface for a filter, you can access the
    block internals by calling the <span class="Li">&quot;block&quot;</span>
    method on the filter object.</p>
<p class="Pp">Normally you'll probably just use the functional interface,
    although all the builtin filters are methods.</p>
<p class="Pp">Note that filters defined in the
    <span class="Li">&quot;main&quot;</span> namespace can look like:</p>
<p class="Pp"></p>
<pre>    sub filter9 {
        s/foo/bar/;
    }
</pre>
<p class="Pp">since Test::Base automatically munges the input string into
    <span class="Li">$_</span> variable and checks the return value of the
    function to see if it looks like a number. If you must define a filter that
    returns just a single number, do it in a different namespace as a method.
    These filters don't allow the simplistic <span class="Li">$_</span>
  munging.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="OO"><a class="permalink" href="#OO">OO</a></h1>
<p class="Pp">Test::Base has a nice functional interface for simple usage. Under
    the hood everything is object oriented. A default Test::Base object is
    created and all the functions are really just method calls on it.</p>
<p class="Pp">This means if you need to get fancy, you can use all the object
    oriented stuff too. Just create new Test::Base objects and use the functions
    as methods.</p>
<p class="Pp"></p>
<pre>    use Test::Base;
    my $blocks1 = Test::Base-&gt;new;
    my $blocks2 = Test::Base-&gt;new;
    $blocks1-&gt;delimiters(qw(!!! @@@))-&gt;spec_file('test1.txt');
    $blocks2-&gt;delimiters(qw(### $$$))-&gt;spec_string($test_data);
    plan tests =&gt; $blocks1-&gt;blocks + $blocks2-&gt;blocks;
    # ... etc
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="THE__TEST::BASE::BLOCK__CLASS"><a class="permalink" href="#THE__TEST::BASE::BLOCK__CLASS">THE
  &quot;TEST::BASE::BLOCK&quot; CLASS</a></h1>
<p class="Pp">In Test::Base, blocks are exposed as Test::Base::Block objects.
    This section lists the methods that can be called on a Test::Base::Block
    object. Of course, each data section name is also available as a method.</p>
<dl class="Bl-tag">
  <dt>&quot;name()&quot;</dt>
  <dd>This is the optional short description of a block, that is specified on
      the block separator line.</dd>
  <dt>&quot;description()&quot;</dt>
  <dd>This is an optional long description of the block. It is the text taken
      from between the block separator and the first data section.</dd>
  <dt>&quot;seq_num()&quot;</dt>
  <dd>Returns a sequence number for this block. Sequence numbers begin with
    1.</dd>
  <dt>&quot;blocks_object()&quot;</dt>
  <dd>Returns the Test::Base object that owns this block.</dd>
  <dt>&quot;run_filters()&quot;</dt>
  <dd>Run the filters on the data sections of the blocks. You don't need to use
      this method unless you also used the
      <span class="Li">&quot;filters_delay&quot;</span> function.</dd>
  <dt>&quot;is_filtered()&quot;</dt>
  <dd>Returns true if filters have already been run for this block.</dd>
  <dt>&quot;original_values()&quot;</dt>
  <dd>Returns a hash of the original, unfiltered values of each data
    section.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="SUBCLASSING"><a class="permalink" href="#SUBCLASSING">SUBCLASSING</a></h1>
<p class="Pp">One of the nicest things about Test::Base is that it is easy to
    subclass. This is very important, because in your personal project, you will
    likely want to extend Test::Base with your own filters and other reusable
    pieces of your test framework.</p>
<p class="Pp">Here is an example of a subclass:</p>
<p class="Pp"></p>
<pre>    package MyTestStuff;
    use Test::Base -Base;
    our @EXPORT = qw(some_func);
    sub some_func {
        (my ($self), @_) = find_my_self(@_);
        ...
    }
    package MyTestStuff::Block;
    use base 'Test::Base::Block';
    sub desc {
        $self-&gt;description(@_);
    }
    package MyTestStuff::Filter;
    use base 'Test::Base::Filter';
    sub upper {
        $self-&gt;assert_scalar(@_);
        uc(shift);
    }
</pre>
<p class="Pp">Note that you don't have to re-Export all the functions from
    Test::Base. That happens automatically, due to the powers of Spiffy.</p>
<p class="Pp">The first line in <span class="Li">&quot;some_func&quot;</span>
    allows it to be called as either a function or a method in the test
  code.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DISTRIBUTION_SUPPORT"><a class="permalink" href="#DISTRIBUTION_SUPPORT">DISTRIBUTION
  SUPPORT</a></h1>
<p class="Pp">You might be thinking that you do not want to use Test::Base in
    you modules, because it adds an installation dependency. Fear not.
    Module::Install::TestBase takes care of that.</p>
<p class="Pp">Just write a Makefile.PL that looks something like this:</p>
<p class="Pp"></p>
<pre>    use inc::Module::Install;
    name            'Foo';
    all_from        'lib/Foo.pm';
    use_test_base;
    WriteAll;
</pre>
<p class="Pp">The line with <span class="Li">&quot;use_test_base&quot;</span>
    will automatically bundle all the code the user needs to run Test::Base
    based tests.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="OTHER_COOL_FEATURES"><a class="permalink" href="#OTHER_COOL_FEATURES">OTHER
  COOL FEATURES</a></h1>
<p class="Pp">Test::Base automatically adds:</p>
<p class="Pp"></p>
<pre>    use strict;
    use warnings;
</pre>
<p class="Pp">to all of your test scripts and Test::Base subclasses. A Spiffy
    feature indeed.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="HISTORY"><a class="permalink" href="#HISTORY">HISTORY</a></h1>
<p class="Pp">This module started its life with the horrible and ridicule
    inducing name <span class="Li">&quot;Test::Chunks&quot;</span>. It was
    renamed to <span class="Li">&quot;Test::Base&quot;</span> with the hope that
    it would be seen for the very useful module that it has become. If you are
    switching from <span class="Li">&quot;Test::Chunks&quot;</span> to
    <span class="Li">&quot;Test::Base&quot;</span>, simply substitute the
    concept and usage of <span class="Li">&quot;chunks&quot;</span> to
    <span class="Li">&quot;blocks&quot;</span>.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">Ingy d&#x00F6;t Net &lt;ingy@cpan.org&gt;</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT"><a class="permalink" href="#COPYRIGHT">COPYRIGHT</a></h1>
<p class="Pp">Copyright 2005-2018. Ingy d&#x00F6;t Net.</p>
<p class="Pp">This program is free software; you can redistribute it and/or
    modify it under the same terms as Perl itself.</p>
<p class="Pp">See &lt;http://www.perl.com/perl/misc/Artistic.html&gt;</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2018-04-19</td>
    <td class="foot-os">perl v5.30.2</td>
  </tr>
</table>
</body>
</html>
