<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.10 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>IPC::Cmd(3pm)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">IPC::Cmd(3pm)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">IPC::Cmd(3pm)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
IPC::Cmd - finding and running system commands made easy
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<span class="Li"></span>
<pre>
    use IPC::Cmd qw[can_run run run_forked];

    my $full_path = can_run('wget') or warn 'wget is not installed!';

    ### commands can be arrayrefs or strings ###
    my $cmd = &quot;$full_path -b theregister.co.uk&quot;;
    my $cmd = [$full_path, '-b', 'theregister.co.uk'];

    ### in scalar context ###
    my $buffer;
    if( scalar run( command =&gt; $cmd,
                    verbose =&gt; 0,
                    buffer  =&gt; \$buffer,
                    timeout =&gt; 20 )
    ) {
        print &quot;fetched webpage successfully: $buffer\n&quot;;
    }


    ### in list context ###
    my( $success, $error_message, $full_buf, $stdout_buf, $stderr_buf ) =
            run( command =&gt; $cmd, verbose =&gt; 0 );

    if( $success ) {
        print &quot;this is what the command printed:\n&quot;;
        print join &quot;&quot;, @$full_buf;
    }

    ### run_forked example ###
    my $result = run_forked(&quot;$full_path -q -O - theregister.co.uk&quot;, {'timeout' =&gt; 20});
    if ($result-&gt;{'exit_code'} eq 0 &amp;&amp; !$result-&gt;{'timeout'}) {
        print &quot;this is what wget returned:\n&quot;;
        print $result-&gt;{'stdout'};
    }

    ### check for features
    print &quot;IPC::Open3 available: &quot;  . IPC::Cmd-&gt;can_use_ipc_open3;
    print &quot;IPC::Run available: &quot;    . IPC::Cmd-&gt;can_use_ipc_run;
    print &quot;Can capture buffer: &quot;    . IPC::Cmd-&gt;can_capture_buffer;

    ### don't have IPC::Cmd be verbose, ie don't print to stdout or
    ### stderr when running commands -- default is '0'
    $IPC::Cmd::VERBOSE = 0;
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
IPC::Cmd allows you to run commands platform independently, interactively if
  desired, but have them still work.
<p class="Pp">The <span class="Li">&quot;can_run&quot;</span> function can tell
    you if a certain binary is installed and if so where, whereas the
    <span class="Li">&quot;run&quot;</span> function can actually execute any of
    the commands you give it and give you a clear return value, as well as
    adhere to your verbosity settings.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="CLASS_METHODS"><a class="permalink" href="#CLASS_METHODS">CLASS
  METHODS</a></h1>
<section class="Ss">
<h2 class="Ss" id="$ipc_run_version_=_IPC::Cmd_-_can_use_ipc_run(___s-1VERBOSE_s0__)"><a class="permalink" href="#$ipc_run_version_=_IPC::Cmd_-_can_use_ipc_run(___s-1VERBOSE_s0__)">$ipc_run_version
  = IPC::Cmd-&gt;can_use_ipc_run( [VERBOSE] )</a></h2>
Utility function that tells you if <span class="Li">&quot;IPC::Run&quot;</span>
  is available. If the <span class="Li">&quot;verbose&quot;</span> flag is
  passed, it will print diagnostic messages if IPC::Run can not be found or
  loaded.
</section>
<section class="Ss">
<h2 class="Ss" id="$ipc_open3_version_=_IPC::Cmd_-_can_use_ipc_open3(___s-1VERBOSE_s0__)"><a class="permalink" href="#$ipc_open3_version_=_IPC::Cmd_-_can_use_ipc_open3(___s-1VERBOSE_s0__)">$ipc_open3_version
  = IPC::Cmd-&gt;can_use_ipc_open3( [VERBOSE] )</a></h2>
Utility function that tells you if
  <span class="Li">&quot;IPC::Open3&quot;</span> is available. If the verbose
  flag is passed, it will print diagnostic messages if
  <span class="Li">&quot;IPC::Open3&quot;</span> can not be found or loaded.
</section>
<section class="Ss">
<h2 class="Ss" id="$bool_=_IPC::Cmd_-_can_capture_buffer"><a class="permalink" href="#$bool_=_IPC::Cmd_-_can_capture_buffer">$bool
  = IPC::Cmd-&gt;can_capture_buffer</a></h2>
Utility function that tells you if <span class="Li">&quot;IPC::Cmd&quot;</span>
  is capable of capturing buffers in it's current configuration.
</section>
<section class="Ss">
<h2 class="Ss" id="$bool_=_IPC::Cmd_-_can_use_run_forked"><a class="permalink" href="#$bool_=_IPC::Cmd_-_can_use_run_forked">$bool
  = IPC::Cmd-&gt;can_use_run_forked</a></h2>
Utility function that tells you if <span class="Li">&quot;IPC::Cmd&quot;</span>
  is capable of providing <span class="Li">&quot;run_forked&quot;</span> on the
  current platform.
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="FUNCTIONS"><a class="permalink" href="#FUNCTIONS">FUNCTIONS</a></h1>
<section class="Ss">
<h2 class="Ss" id="$path_=_can_run(__s-1PROGRAM_s0_);"><a class="permalink" href="#$path_=_can_run(__s-1PROGRAM_s0_);">$path
  = can_run( PROGRAM );</a></h2>
<span class="Li">&quot;can_run&quot;</span> takes only one argument: the name of
  a binary you wish to locate. <span class="Li">&quot;can_run&quot;</span> works
  much like the unix binary <span class="Li">&quot;which&quot;</span> or the
  bash command <span class="Li">&quot;type&quot;</span>, which scans through
  your path, looking for the requested binary.
<p class="Pp">Unlike <span class="Li">&quot;which&quot;</span> and
    <span class="Li">&quot;type&quot;</span>, this function is platform
    independent and will also work on, for example, Win32.</p>
<p class="Pp">If called in a scalar context it will return the full path to the
    binary you asked for if it was found, or
    <span class="Li">&quot;undef&quot;</span> if it was not.</p>
<p class="Pp">If called in a list context and the global variable
    <span class="Li">$INSTANCES</span> is a true value, it will return a list of
    the full paths to instances of the binary where found in
    <span class="Li">&quot;PATH&quot;</span>, or an empty list if it was not
    found.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="$ok___($ok,_$err,_$full_buf,_$stdout_buff,_$stderr_buff)_=_run(_command_=___s-1COMMAND,_s0__verbose_=___s-1BOOL,_s0_buffer_=___e$SCALAR,_timeout_=___s-1DIGIT_s0__);"><a class="permalink" href="#$ok___($ok,_$err,_$full_buf,_$stdout_buff,_$stderr_buff)_=_run(_command_=___s-1COMMAND,_s0__verbose_=___s-1BOOL,_s0_buffer_=___e$SCALAR,_timeout_=___s-1DIGIT_s0__);">$ok
  | ($ok, $err, $full_buf, $stdout_buff, $stderr_buff) = run( command =&gt;
  COMMAND, [verbose =&gt; BOOL, buffer =&gt; \$SCALAR, timeout =&gt; DIGIT]
  );</a></h2>
<span class="Li">&quot;run&quot;</span> takes 4 arguments:
<dl class="Bl-tag">
  <dt>command</dt>
  <dd>This is the command to execute. It may be either a string or an array
      reference. This is a required argument.
    <p class="Pp">See &quot;Caveats&quot; for remarks on how commands are parsed
        and their limitations.</p>
  </dd>
  <dt>verbose</dt>
  <dd>This controls whether all output of a command should also be printed to
      STDOUT/STDERR or should only be trapped in buffers (NOTE: buffers require
      IPC::Run to be installed, or your system able to work with IPC::Open3).
    <p class="Pp">It will default to the global setting of
        <span class="Li">$IPC::Cmd::VERBOSE</span>, which by default is 0.</p>
  </dd>
  <dt>buffer</dt>
  <dd>This will hold all the output of a command. It needs to be a reference to
      a scalar. Note that this will hold both the STDOUT and STDERR messages,
      and you have no way of telling which is which. If you require this
      distinction, run the <span class="Li">&quot;run&quot;</span> command in
      list context and inspect the individual buffers.
    <p class="Pp">Of course, this requires that the underlying call supports
        buffers. See the note on buffers above.</p>
  </dd>
  <dt>timeout</dt>
  <dd>Sets the maximum time the command is allowed to run before aborting, using
      the built-in <span class="Li">&quot;alarm()&quot;</span> call. If the
      timeout is triggered, the <span class="Li">&quot;errorcode&quot;</span> in
      the return value will be set to an object of the
      <span class="Li">&quot;IPC::Cmd::TimeOut&quot;</span> class. See the
      &quot;error message&quot; section below for details.
    <p class="Pp">Defaults to <span class="Li">0</span>, meaning no timeout is
        set.</p>
  </dd>
</dl>
<p class="Pp"><span class="Li">&quot;run&quot;</span> will return a simple
    <span class="Li">&quot;true&quot;</span> or
    <span class="Li">&quot;false&quot;</span> when called in scalar context. In
    list context, you will be returned a list of the following items:</p>
<dl class="Bl-tag">
  <dt>success</dt>
  <dd>A simple boolean indicating if the command executed without errors or
    not.</dd>
  <dt>error message</dt>
  <dd>If the first element of the return value
      (<span class="Li">&quot;success&quot;</span>) was 0, then some error
      occurred. This second element is the error message the command you
      requested exited with, if available. This is generally a pretty printed
      value of <span class="Li">$?</span> or <span class="Li">$@</span>. See
      <span class="Li">&quot;perldoc perlvar&quot;</span> for details on what
      they can contain. If the error was a timeout, the
      <span class="Li">&quot;error message&quot;</span> will be prefixed with
      the string <span class="Li">&quot;IPC::Cmd::TimeOut&quot;</span>, the
      timeout class.</dd>
  <dt>full_buffer</dt>
  <dd>This is an array reference containing all the output the command
      generated. Note that buffers are only available if you have IPC::Run
      installed, or if your system is able to work with IPC::Open3 -- see
      below). Otherwise, this element will be
      <span class="Li">&quot;undef&quot;</span>.</dd>
  <dt>out_buffer</dt>
  <dd>This is an array reference containing all the output sent to STDOUT the
      command generated. The notes from &quot;full_buffer&quot; apply.</dd>
  <dt>error_buffer</dt>
  <dd>This is an arrayreference containing all the output sent to STDERR the
      command generated. The notes from &quot;full_buffer&quot; apply.</dd>
</dl>
<p class="Pp">See the &quot;HOW IT WORKS&quot; section below to see how
    <span class="Li">&quot;IPC::Cmd&quot;</span> decides what modules or
    function calls to use when issuing a command.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="$hashref_=_run_forked(__s-1COMMAND,_s0___child_stdin_=___s-1SCALAR,_s0_timeout_=___s-1DIGIT,_s0_stdout_handler_=___s-1CODEREF,_s0_stderr_handler_=___s-1CODEREF_s0__);"><a class="permalink" href="#$hashref_=_run_forked(__s-1COMMAND,_s0___child_stdin_=___s-1SCALAR,_s0_timeout_=___s-1DIGIT,_s0_stdout_handler_=___s-1CODEREF,_s0_stderr_handler_=___s-1CODEREF_s0__);">$hashref
  = run_forked( COMMAND, { child_stdin =&gt; SCALAR, timeout =&gt; DIGIT,
  stdout_handler =&gt; CODEREF, stderr_handler =&gt; CODEREF} );</a></h2>
<span class="Li">&quot;run_forked&quot;</span> is used to execute some program
  or a coderef, optionally feed it with some input, get its return code and
  output (both stdout and stderr into separate buffers). In addition, it allows
  to terminate the program if it takes too long to finish.
<p class="Pp">The important and distinguishing feature of run_forked is
    execution timeout which at first seems to be quite a simple task but if you
    think that the program which you're spawning might spawn some children
    itself (which in their turn could do the same and so on) it turns out to be
    not a simple issue.</p>
<p class="Pp"><span class="Li">&quot;run_forked&quot;</span> is designed to
    survive and successfully terminate almost any long running task, even a fork
    bomb in case your system has the resources to survive during given
  timeout.</p>
<p class="Pp">This is achieved by creating separate watchdog process which
    spawns the specified program in a separate process session and supervises
    it: optionally feeds it with input, stores its exit code, stdout and stderr,
    terminates it in case it runs longer than specified.</p>
<p class="Pp">Invocation requires the command to be executed or a coderef and
    optionally a hashref of options:</p>
<dl class="Bl-tag">
  <dt>&quot;timeout&quot;</dt>
  <dd>Specify in seconds how long to run the command before it is killed with
      SIG_KILL (9), which effectively terminates it and all of its children
      (direct or indirect).</dd>
  <dt>&quot;child_stdin&quot;</dt>
  <dd>Specify some text that will be passed into the
      <span class="Li">&quot;STDIN&quot;</span> of the executed program.</dd>
  <dt>&quot;stdout_handler&quot;</dt>
  <dd>Coderef of a subroutine to call when a portion of data is received on
      STDOUT from the executing program.</dd>
  <dt>&quot;stderr_handler&quot;</dt>
  <dd>Coderef of a subroutine to call when a portion of data is received on
      STDERR from the executing program.</dd>
  <dt>&quot;wait_loop_callback&quot;</dt>
  <dd>Coderef of a subroutine to call inside of the main waiting loop (while
      <span class="Li">&quot;run_forked&quot;</span> waits for the external to
      finish or fail). It is useful to stop running external process before it
      ends by itself, e.g.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  my $r = run_forked(&quot;some external command&quot;, {
          'wait_loop_callback' =&gt; sub {
          if (condition) {
              kill(1, $$);
          }
          },
          'terminate_on_signal' =&gt; 'HUP',
          });
    </pre>
    <p class="Pp">Combined with
        <span class="Li">&quot;stdout_handler&quot;</span> and
        <span class="Li">&quot;stderr_handler&quot;</span> allows terminating
        external command based on its output. Could also be used as a timer
        without engaging with alarm (signals).</p>
    <p class="Pp">Remember that this code could be called every millisecond
        (depending on the output which external command generates), so try to
        make it as lightweight as possible.</p>
  </dd>
  <dt>&quot;discard_output&quot;</dt>
  <dd>Discards the buffering of the standard output and standard errors for
      return by <b>run_forked()</b>. With this option you have to use the
      std*_handlers to read what the command outputs. Useful for commands that
      send a lot of output.</dd>
  <dt>&quot;terminate_on_parent_sudden_death&quot;</dt>
  <dd>Enable this option if you wish all spawned processes to be killed if the
      initially spawned process (the parent) is killed or dies without waiting
      for child processes.</dd>
</dl>
<p class="Pp"><span class="Li">&quot;run_forked&quot;</span> will return a
    HASHREF with the following keys:</p>
<dl class="Bl-tag">
  <dt>&quot;exit_code&quot;</dt>
  <dd>The exit code of the executed program.</dd>
  <dt>&quot;timeout&quot;</dt>
  <dd>The number of seconds the program ran for before being terminated, or 0 if
      no timeout occurred.</dd>
  <dt>&quot;stdout&quot;</dt>
  <dd>Holds the standard output of the executed command (or empty string if
      there was no STDOUT output or if
      <span class="Li">&quot;discard_output&quot;</span> was used; it's always
      defined!)</dd>
  <dt>&quot;stderr&quot;</dt>
  <dd>Holds the standard error of the executed command (or empty string if there
      was no STDERR output or if
      <span class="Li">&quot;discard_output&quot;</span> was used; it's always
      defined!)</dd>
  <dt>&quot;merged&quot;</dt>
  <dd>Holds the standard output and error of the executed command merged into
      one stream (or empty string if there was no output at all or if
      <span class="Li">&quot;discard_output&quot;</span> was used; it's always
      defined!)</dd>
  <dt>&quot;err_msg&quot;</dt>
  <dd>Holds some explanation in the case of an error.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="$q_=__s-1QUOTE_s0"><a class="permalink" href="#$q_=__s-1QUOTE_s0">$q
  = QUOTE</a></h2>
Returns the character used for quoting strings on this platform. This is usually
  a <span class="Li">&quot;'&quot;</span> (single quote) on most systems, but
  some systems use different quotes. For example,
  <span class="Li">&quot;Win32&quot;</span> uses
  <span class="Li">&quot;&quot;&quot;</span> (double quote).
<p class="Pp">You can use it as follows:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  use IPC::Cmd qw[run QUOTE];
  my $cmd = q[echo ] . QUOTE . q[foo bar] . QUOTE;
</pre>
<p class="Pp">This makes sure that <span class="Li">&quot;foo bar&quot;</span>
    is treated as a string, rather than two separate arguments to the
    <span class="Li">&quot;echo&quot;</span> function.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="HOW_IT_WORKS"><a class="permalink" href="#HOW_IT_WORKS">HOW
  IT WORKS</a></h1>
<span class="Li">&quot;run&quot;</span> will try to execute your command using
  the following logic:
<ul class="Bl-bullet">
  <li>If you have <span class="Li">&quot;IPC::Run&quot;</span> installed, and
      the variable <span class="Li">$IPC::Cmd::USE_IPC_RUN</span> is set to true
      (See the &quot;Global Variables&quot; section) use that to execute the
      command. You will have the full output available in buffers, interactive
      commands are sure to work and you are guaranteed to have your verbosity
      settings honored cleanly.</li>
  <li>Otherwise, if the variable
      <span class="Li">$IPC::Cmd::USE_IPC_OPEN3</span> is set to true (See the
      &quot;Global Variables&quot; section), try to execute the command using
      IPC::Open3. Buffers will be available on all platforms, interactive
      commands will still execute cleanly, and also your verbosity settings will
      be adhered to nicely;</li>
  <li>Otherwise, if you have the <span class="Li">&quot;verbose&quot;</span>
      argument set to true, we fall back to a simple
      <span class="Li">&quot;system()&quot;</span> call. We cannot capture any
      buffers, but interactive commands will still work.</li>
  <li>Otherwise we will try and temporarily redirect STDERR and STDOUT, do a
      <span class="Li">&quot;system()&quot;</span> call with your command and
      then re-open STDERR and STDOUT. This is the method of last resort and will
      still allow you to execute your commands cleanly. However, no buffers will
      be available.</li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="Global_Variables"><a class="permalink" href="#Global_Variables">Global
  Variables</a></h1>
The behaviour of IPC::Cmd can be altered by changing the following global
  variables:
<section class="Ss">
<h2 class="Ss" id="$IPC::Cmd::VERBOSE"><a class="permalink" href="#$IPC::Cmd::VERBOSE">$IPC::Cmd::VERBOSE</a></h2>
This controls whether IPC::Cmd will print any output from the commands to the
  screen or not. The default is 0.
</section>
<section class="Ss">
<h2 class="Ss" id="$IPC::Cmd::USE_IPC_RUN"><a class="permalink" href="#$IPC::Cmd::USE_IPC_RUN">$IPC::Cmd::USE_IPC_RUN</a></h2>
This variable controls whether IPC::Cmd will try to use IPC::Run when available
  and suitable.
</section>
<section class="Ss">
<h2 class="Ss" id="$IPC::Cmd::USE_IPC_OPEN3"><a class="permalink" href="#$IPC::Cmd::USE_IPC_OPEN3">$IPC::Cmd::USE_IPC_OPEN3</a></h2>
This variable controls whether IPC::Cmd will try to use IPC::Open3 when
  available and suitable. Defaults to true.
</section>
<section class="Ss">
<h2 class="Ss" id="$IPC::Cmd::WARN"><a class="permalink" href="#$IPC::Cmd::WARN">$IPC::Cmd::WARN</a></h2>
This variable controls whether run-time warnings should be issued, like the
  failure to load an <span class="Li">&quot;IPC::*&quot;</span> module you
  explicitly requested.
<p class="Pp">Defaults to true. Turn this off at your own risk.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="$IPC::Cmd::INSTANCES"><a class="permalink" href="#$IPC::Cmd::INSTANCES">$IPC::Cmd::INSTANCES</a></h2>
This variable controls whether <span class="Li">&quot;can_run&quot;</span> will
  return all instances of the binary it finds in the
  <span class="Li">&quot;PATH&quot;</span> when called in a list context.
<p class="Pp">Defaults to false, set to true to enable the described
  behaviour.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="$IPC::Cmd::ALLOW_NULL_ARGS"><a class="permalink" href="#$IPC::Cmd::ALLOW_NULL_ARGS">$IPC::Cmd::ALLOW_NULL_ARGS</a></h2>
This variable controls whether <span class="Li">&quot;run&quot;</span> will
  remove any empty/null arguments it finds in command arguments.
<p class="Pp">Defaults to false, so it will remove null arguments. Set to true
    to allow them.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="Caveats"><a class="permalink" href="#Caveats">Caveats</a></h1>
<dl class="Bl-tag">
  <dt>Whitespace and IPC::Open3 / <b>system()</b></dt>
  <dd>When using <span class="Li">&quot;IPC::Open3&quot;</span> or
      <span class="Li">&quot;system&quot;</span>, if you provide a string as the
      <span class="Li">&quot;command&quot;</span> argument, it is assumed to be
      appropriately escaped. You can use the
      <span class="Li">&quot;QUOTE&quot;</span> constant to use as a portable
      quote character (see above). However, if you provide an array reference,
      special rules apply:
    <p class="Pp">If your command contains <b>special characters</b> (&lt; &gt;
        | &amp;), it will be internally stringified before executing the
        command, to avoid that these special characters are escaped and passed
        as arguments instead of retaining their special meaning.</p>
    <p class="Pp">However, if the command contained arguments that contained
        whitespace, stringifying the command would lose the significance of the
        whitespace. Therefore, <span class="Li">&quot;IPC::Cmd&quot;</span> will
        quote any arguments containing whitespace in your command if the command
        is passed as an arrayref and contains special characters.</p>
  </dd>
  <dt>Whitespace and IPC::Run</dt>
  <dd>When using <span class="Li">&quot;IPC::Run&quot;</span>, if you provide a
      string as the <span class="Li">&quot;command&quot;</span> argument, the
      string will be split on whitespace to determine the individual elements of
      your command. Although this will usually just Do What You Mean, it may
      break if you have files or commands with whitespace in them.
    <p class="Pp">If you do not wish this to happen, you should provide an array
        reference, where all parts of your command are already separated out.
        Note however, if there are extra or spurious whitespaces in these parts,
        the parser or underlying code may not interpret it correctly, and cause
        an error.</p>
    <p class="Pp">Example: The following code</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    gzip -cdf foo.tar.gz | tar -xf -
    </pre>
    <p class="Pp">should either be passed as</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    &quot;gzip -cdf foo.tar.gz | tar -xf -&quot;
    </pre>
    <p class="Pp">or as</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    ['gzip', '-cdf', 'foo.tar.gz', '|', 'tar', '-xf', '-']
    </pre>
    <p class="Pp">But take care not to pass it as, for example</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    ['gzip -cdf foo.tar.gz', '|', 'tar -xf -']
    </pre>
    <p class="Pp">Since this will lead to issues as described above.</p>
  </dd>
  <dt>IO Redirect</dt>
  <dd>Currently it is too complicated to parse your command for IO redirections.
      For capturing STDOUT or STDERR there is a work around however, since you
      can just inspect your buffers for the contents.</dd>
  <dt>Interleaving STDOUT/STDERR</dt>
  <dd>Neither IPC::Run nor IPC::Open3 can interleave STDOUT and STDERR. For
      short bursts of output from a program, e.g. this sample,
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    for ( 1..4 ) {
        $_ % 2 ? print STDOUT $_ : print STDERR $_;
    }
    </pre>
    <p class="Pp">IPC::[Run|Open3] will first read all of STDOUT, then all of
        STDERR, meaning the output looks like '13' on STDOUT and '24' on STDERR,
        instead of</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    1
    2
    3
    4
    </pre>
    <p class="Pp">This has been recorded in rt.cpan.org as bug #37532: Unable to
        interleave STDOUT and STDERR.</p>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="See_Also"><a class="permalink" href="#See_Also">See
  Also</a></h1>
IPC::Run, IPC::Open3
</section>
<section class="Sh">
<h1 class="Sh" id="ACKNOWLEDGEMENTS"><a class="permalink" href="#ACKNOWLEDGEMENTS">ACKNOWLEDGEMENTS</a></h1>
Thanks to James Mastros and Martijn van der Streek for their help in getting
  IPC::Open3 to behave nicely.
<p class="Pp">Thanks to Petya Kohts for the
    <span class="Li">&quot;run_forked&quot;</span> code.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="BUG_REPORTS"><a class="permalink" href="#BUG_REPORTS">BUG
  REPORTS</a></h1>
Please report bugs or other issues to &lt;bug-ipc-cmd@rt.cpan.org&gt;.
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
Original author: Jos Boumans &lt;kane@cpan.org&gt;. Current maintainer: Chris
  Williams &lt;bingos@cpan.org&gt;.
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT"><a class="permalink" href="#COPYRIGHT">COPYRIGHT</a></h1>
This library is free software; you may redistribute and/or modify it under the
  same terms as Perl itself.
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2018-11-01</td>
    <td class="foot-os">perl v5.28.2</td>
  </tr>
</table>
</body>
</html>
