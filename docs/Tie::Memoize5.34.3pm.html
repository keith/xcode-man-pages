<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    .Nd, .Bf, .Op { display: inline; }
    .Pa, .Ad { font-style: italic; }
    .Ms { font-weight: bold; }
    .Bl-diag > dt { font-weight: bold; }
    code.Nm, .Fl, .Cm, .Ic, code.In, .Fd, .Fn, .Cd { font-weight: bold;
      font-family: inherit; }
  </style>
  <title>Tie::Memoize(3pm)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Tie::Memoize(3pm)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">Tie::Memoize(3pm)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Tie::Memoize - add data to hash when needed</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>  require Tie::Memoize;
  tie %hash, 'Tie::Memoize',
      \&amp;fetch,                  # The rest is optional
      $DATA, \&amp;exists,
      {%ini_value}, {%ini_existence};
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">This package allows a tied hash to autoload its values on the
    first access, and to use the cached value on the following accesses.</p>
<p class="Pp">Only read-accesses (via fetching the value or
    <span class="Li">&quot;exists&quot;</span>) result in calls to the
    functions; the modify-accesses are performed as on a normal hash.</p>
<p class="Pp">The required arguments during
    <span class="Li">&quot;tie&quot;</span> are the hash, the package, and the
    reference to the <span class="Li">&quot;FETCH&quot;</span>ing function. The
    optional arguments are an arbitrary scalar <span class="Li">$data</span>,
    the reference to the <span class="Li">&quot;EXISTS&quot;</span> function,
    and initial values of the hash and of the existence cache.</p>
<p class="Pp">Both the <span class="Li">&quot;FETCH&quot;</span>ing function and
    the <span class="Li">&quot;EXISTS&quot;</span> functions have the same
    signature: the arguments are <span class="Li">&quot;$key,
    $data&quot;</span>; <span class="Li">$data</span> is the same value as given
    as argument during <b>tie()</b>ing. Both functions should return an empty
    list if the value does not exist. If
    <span class="Li">&quot;EXISTS&quot;</span> function is different from the
    <span class="Li">&quot;FETCH&quot;</span>ing function, it should return a
    TRUE value on success. The <span class="Li">&quot;FETCH&quot;</span>ing
    function should return the intended value if the key is valid.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="Inheriting_from_"><a class="permalink" href="#Inheriting_from_">Inheriting
  from <b>Tie::Memoize</b></a></h1>
<p class="Pp">The structure of the <b>tied()</b> data is an array reference with
    elements</p>
<p class="Pp"></p>
<pre>  0:  cache of known values
  1:  cache of known existence of keys
  2:  FETCH  function
  3:  EXISTS function
  4:  $data
</pre>
<p class="Pp">The rest is for internal usage of this package. In particular, if
    TIEHASH is overwritten, it should call SUPER::TIEHASH.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="EXAMPLE"><a class="permalink" href="#EXAMPLE">EXAMPLE</a></h1>
<pre>  sub slurp {
    my ($key, $dir) = shift;
    open my $h, '&lt;', &quot;$dir/$key&quot; or return;
    local $/; &lt;$h&gt;                      # slurp it all
  }
  sub exists { my ($key, $dir) = shift; return -f &quot;$dir/$key&quot; }
  tie %hash, 'Tie::Memoize', \&amp;slurp, $directory, \&amp;exists,
      { fake_file1 =&gt; $content1, fake_file2 =&gt; $content2 },
      { pretend_does_not_exists =&gt; 0, known_to_exist =&gt; 1 };
</pre>
<p class="Pp">This example treats the slightly modified contents of
    <span class="Li">$directory</span> as a hash. The modifications are that the
    keys <i>fake_file1</i> and <i>fake_file2</i> fetch values
    <span class="Li">$content1</span> and <span class="Li">$content2</span>, and
    <i>pretend_does_not_exists</i> will never be accessed. Additionally, the
    existence of <i>known_to_exist</i> is never checked (so if it does not
    exists when its content is needed, the user of <span class="Li">%hash</span>
    may be confused).</p>
</section>
<section class="Sh">
<h1 class="Sh" id="BUGS"><a class="permalink" href="#BUGS">BUGS</a></h1>
<p class="Pp">FIRSTKEY and NEXTKEY methods go through the keys which were
    already read, not all the possible keys of the hash.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">Ilya Zakharevich
    &lt;mailto:perl-module-hash-memoize@ilyaz.org&gt;.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2020-06-14</td>
    <td class="foot-os">perl v5.34.0</td>
  </tr>
</table>
</body>
</html>
