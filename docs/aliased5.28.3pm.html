<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>aliased(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">aliased(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">aliased(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
aliased - Use shorter versions of class names.
</section>
<section class="Sh">
<h1 class="Sh" id="VERSION"><a class="permalink" href="#VERSION">VERSION</a></h1>
0.31
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<span class="Li"></span>
<pre>
  # Class name interface
  use aliased 'My::Company::Namespace::Customer';
  my $cust = Customer-&gt;new;

  use aliased 'My::Company::Namespace::Preferred::Customer' =&gt; 'Preferred';
  my $pref = Preferred-&gt;new;


  # Variable interface
  use aliased;
  my $Customer  = alias &quot;My::Other::Namespace::Customer&quot;;
  my $cust      = $Customer-&gt;new;

  my $Preferred = alias &quot;My::Other::Namespace::Preferred::Customer&quot;;
  my $pref      = $Preferred-&gt;new;
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<span class="Li">&quot;aliased&quot;</span> is simple in concept but is a rather
  handy module. It loads the class you specify and exports into your namespace a
  subroutine that returns the class name. You can explicitly alias the class to
  another name or, if you prefer, you can do so implicitly. In the latter case,
  the name of the subroutine is the last part of the class name. Thus, it does
  something similar to the following:
<p class="Pp"><span class="Li"></span></p>
<pre>
  #use aliased 'Some::Annoyingly::Long::Module::Name::Customer';

  use Some::Annoyingly::Long::Module::Name::Customer;
  sub Customer {
    return 'Some::Annoyingly::Long::Module::Name::Customer';
  }
  my $cust = Customer-&gt;new;
</pre>
<p class="Pp">This module is useful if you prefer a shorter name for a class.
    It's also handy if a class has been renamed.</p>
<p class="Pp">(Some may object to the term &quot;aliasing&quot; because we're
    not aliasing one namespace to another, but it's a handy term. Just keep in
    mind that this is done with a subroutine and not with typeglobs and weird
    namespace munging.)</p>
<p class="Pp">Note that this is <b>only</b> for
    <span class="Li">&quot;use&quot;</span>ing OO modules. You cannot use this
    to load procedural modules. See the Why OO Only? section. Also, don't let
    the version number fool you. This code is ridiculously simple and is just
    fine for most use.</p>
<section class="Ss">
<h2 class="Ss" id="Implicit_Aliasing"><a class="permalink" href="#Implicit_Aliasing">Implicit
  Aliasing</a></h2>
The most common use of this module is:
<p class="Pp"><span class="Li"></span></p>
<pre>
  use aliased 'Some::Module::name';
</pre>
<p class="Pp"><span class="Li">&quot;aliased&quot;</span> will allow you to
    reference the class by the last part of the class name. Thus,
    <span class="Li">&quot;Really::Long::Name&quot;</span> becomes
    <span class="Li">&quot;Name&quot;</span>. It does this by exporting a
    subroutine into your namespace with the same name as the aliased name. This
    subroutine returns the original class name.</p>
<p class="Pp">For example:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  use aliased &quot;Acme::Company::Customer&quot;;
  my $cust = Customer-&gt;find($id);
</pre>
<p class="Pp">Note that any class method can be called on the shorter version of
    the class name, not just the constructor.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Explicit_Aliasing"><a class="permalink" href="#Explicit_Aliasing">Explicit
  Aliasing</a></h2>
Sometimes two class names can cause a conflict (they both end with
  <span class="Li">&quot;Customer&quot;</span> for example), or you already have
  a subroutine with the same name as the aliased name. In that case, you can
  make an explicit alias by stating the name you wish to alias to:
<p class="Pp"><span class="Li"></span></p>
<pre>
  use aliased 'Original::Module::Name' =&gt; 'NewName';
</pre>
<p class="Pp">Here's how we use <span class="Li">&quot;aliased&quot;</span> to
    avoid conflicts:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  use aliased &quot;Really::Long::Name&quot;;
  use aliased &quot;Another::Really::Long::Name&quot; =&gt; &quot;Aname&quot;;
  my $name  = Name-&gt;new;
  my $aname = Aname-&gt;new;
</pre>
<p class="Pp">You can even alias to a different package:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  use aliased &quot;Another::Really::Long::Name&quot; =&gt; &quot;Another::Name&quot;;
  my $aname = Another::Name-&gt;new;
</pre>
<p class="Pp">Messing around with different namespaces is a really bad idea and
    you probably don't want to do this. However, it might prove handy if the
    module you are using has been renamed. If the interface has not changed,
    this allows you to use the new module by only changing one line of code.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  use aliased &quot;New::Module::Name&quot; =&gt; &quot;Old::Module::Name&quot;;
  my $thing = Old::Module::Name-&gt;new;
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Import_Lists"><a class="permalink" href="#Import_Lists">Import
  Lists</a></h2>
Sometimes, even with an OO module, you need to specify extra arguments when
  using the module. When this happens, simply use &quot;Explicit Aliasing&quot;
  followed by the import list:
<p class="Pp">Snippet 1:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  use Some::Module::Name qw/foo bar/;
  my $o = Some::Module::Name-&gt;some_class_method;
</pre>
<p class="Pp">Snippet 2 (equivalent to snippet 1):</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  use aliased 'Some::Module::Name' =&gt; 'Name', qw/foo bar/;
  my $o = Name-&gt;some_class_method;
</pre>
<p class="Pp"><b>Note</b>: remember, you cannot use import lists with
    &quot;Implicit Aliasing&quot;. As a result, you may simply prefer to only
    use &quot;Explicit Aliasing&quot; as a matter of style.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_fIalias()_fP"><a class="permalink" href="#_fIalias()_fP"><i>alias()</i></a></h2>
This function is only exported if you specify <span class="Li">&quot;use
  aliased&quot;</span> with no import list.
<p class="Pp"><span class="Li"></span></p>
<pre>
    use aliased;
    my $alias = alias($class);
    my $alias = alias($class, @imports);
</pre>
<p class="Pp"><i>alias()</i> is an alternative to <span class="Li">&quot;use
    aliased ...&quot;</span> which uses less magic and avoids some of the
    ambiguities.</p>
<p class="Pp">Like <span class="Li">&quot;use aliased&quot;</span> it
    <span class="Li">&quot;use&quot;</span>s the <span class="Li">$class</span>
    (pass in <span class="Li">@imports</span>, if given) but instead of
    providing an <span class="Li">&quot;Alias&quot;</span> constant it simply
    returns a scalar set to the <span class="Li">$class</span> name.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    my $thing = alias(&quot;Some::Thing::With::A::Long::Name&quot;);

    # Just like Some::Thing::With::A::Long::Name-&gt;method
    $thing-&gt;method;
</pre>
<p class="Pp">The use of a scalar instead of a constant avoids any possible
    ambiguity when aliasing two similar names:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    # No ambiguity despite the fact that they both end with &quot;Name&quot;
    my $thing = alias(&quot;Some::Thing::With::A::Long::Name&quot;);
    my $other = alias(&quot;Some::Other::Thing::With::A::Long::Name&quot;);
</pre>
<p class="Pp">and there is no magic constant exported into your namespace.</p>
<p class="Pp">The only caveat is loading of the <span class="Li">$class</span>
    happens at run time. If <span class="Li">$class</span> exports anything you
    might want to ensure it is loaded at compile time with:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    my $thing;
    BEGIN { $thing = alias(&quot;Some::Thing&quot;); }
</pre>
<p class="Pp">However, since OO classes rarely export this should not be
    necessary.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_fIprefix()_fP_(experimental)"><a class="permalink" href="#_fIprefix()_fP_(experimental)"><i>prefix()</i>
  (experimental)</a></h2>
This function is only exported if you specify <span class="Li">&quot;use
  aliased&quot;</span> with no import list.
<p class="Pp"><span class="Li"></span></p>
<pre>
    use aliased;
</pre>
<p class="Pp">Sometimes you find you have a ton of packages in the same
    top-level namespace and you want to alias them, but only use them on demand.
    For example:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    # instead of:
    MailVerwaltung::Client::Exception::REST::Response-&gt;throw()

    my $error = prefix('MailVerwaltung::Client::Exception');
    $error-&gt;('REST::Response')-&gt;throw();   # same as above
    $error-&gt;()-&gt;throw; # same as MailVerwaltung::Client::Exception-&gt;throw
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Why__s-1OO_s0_Only?"><a class="permalink" href="#Why__s-1OO_s0_Only?">Why
  OO Only?</a></h2>
Some people have asked why this code only support object-oriented modules (OO).
  If I were to support normal subroutines, I would have to allow the following
  syntax:
<p class="Pp"><span class="Li"></span></p>
<pre>
  use aliased 'Some::Really::Long::Module::Name';
  my $data = Name::data();
</pre>
<p class="Pp">That causes a serious problem. The only (reasonable) way it can be
    done is to handle the aliasing via typeglobs. Thus, instead of a subroutine
    that provides the class name, we alias one package to another (as the
    namespace module does.) However, we really don't want to simply alias one
    package to another and wipe out namespaces willy-nilly. By merely exporting
    a single subroutine to a namespace, we minimize the issue.</p>
<p class="Pp">Fortunately, this doesn't seem to be that much of a problem.
    Non-OO modules generally support exporting of the functions you need and
    this eliminates the need for a module such as this.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="EXPORT"><a class="permalink" href="#EXPORT">EXPORT</a></h1>
This modules exports a subroutine with the same name as the &quot;aliased&quot;
  name.
</section>
<section class="Sh">
<h1 class="Sh" id="BUGS"><a class="permalink" href="#BUGS">BUGS</a></h1>
There are no known bugs in this module, but feel free to email me reports.
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
The namespace module.
</section>
<section class="Sh">
<h1 class="Sh" id="THANKS"><a class="permalink" href="#THANKS">THANKS</a></h1>
Many thanks to Rentrak, Inc. (http://www.rentrak.com/) for graciously allowing
  me to replicate the functionality of some of their internal code.
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
Curtis Poe, <span class="Li">&quot;ovid [at] cpan [dot] org&quot;</span>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT_AND_LICENSE"><a class="permalink" href="#COPYRIGHT_AND_LICENSE">COPYRIGHT
  AND LICENSE</a></h1>
Copyright (C) 2005 by Curtis &quot;Ovid&quot; Poe
<p class="Pp">This library is free software; you can redistribute it and/or
    modify it under the same terms as Perl itself, either Perl version 5.8.5 or,
    at your option, any later version of Perl 5 you may have available.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2020-02-09</td>
    <td class="foot-os">perl v5.18.2</td>
  </tr>
</table>
</body>
</html>
