<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.10 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>Context::Preserve(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Context::Preserve(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Context::Preserve(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
Context::Preserve - Run code after a subroutine call, preserving the context the
  subroutine would have seen if it were the last statement in the caller
</section>
<section class="Sh">
<h1 class="Sh" id="VERSION"><a class="permalink" href="#VERSION">VERSION</a></h1>
version 0.03
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
Have you ever written this?
<p class="Pp"><span class="Li"></span></p>
<pre>
    my ($result, @result);

    # run a sub in the correct context
    if(!defined wantarray){
        some::code();
    }
    elsif(wantarray){
        @result = some::code();
    }
    else {
        $result = some::code();
    }
  
    # do something after some::code
    $_ += 42 for (@result, $result);
  
    # finally return the correct value
    if(!defined wantarray){
        return;
    }
    elsif(wantarray){
        return @result;
    }
    else {
        return $result;
    }
</pre>
<p class="Pp">Now you can just write this instead:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  use Context::Preserve;

  return preserve_context { some::code() }
             after =&gt; sub { $_ += 42 for @_ };
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
Sometimes you need to call a function, get the results, act on the results, then
  return the result of the function. This is painful because of contexts; the
  original function can behave different if it's called in void, scalar, or list
  context. You can ignore the various cases and just pick one, but that's
  fragile. To do things right, you need to see which case you're being called
  in, and then call the function in that context. This results in 3 code paths,
  which is a pain to type in (and maintain).
<p class="Pp">This module automates the process. You provide a coderef that is
    the &quot;original function&quot;, and another coderef to run after the
    original runs. You can modify the return value (aliased to
    <span class="Li">@_</span>) here, and do whatever else you need to do.
    <span class="Li">&quot;wantarray&quot;</span> is correct inside both
    coderefs; in &quot;after&quot;, though, the return value is ignored and the
    value <span class="Li">&quot;wantarray&quot;</span> returns is related to
    the context that the original function was called in.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="EXPORT"><a class="permalink" href="#EXPORT">EXPORT</a></h1>
<span class="Li">&quot;preserve_context&quot;</span>
</section>
<section class="Sh">
<h1 class="Sh" id="FUNCTIONS"><a class="permalink" href="#FUNCTIONS">FUNCTIONS</a></h1>
<section class="Ss">
<h2 class="Ss" id="preserve_context___original____after_replace__=__sub___after__"><a class="permalink" href="#preserve_context___original____after_replace__=__sub___after__">preserve_context
  { original } [after|replace] =&gt; sub { after }</a></h2>
Invokes <span class="Li">&quot;original&quot;</span> in the same context as
  <span class="Li">&quot;preserve_context&quot;</span> was called in, save the
  results, runs <span class="Li">&quot;after&quot;</span> in the same context,
  then returns the result of <span class="Li">&quot;original&quot;</span> (or
  <span class="Li">&quot;after&quot;</span> if
  <span class="Li">&quot;replace&quot;</span> is used).
<p class="Pp">If the second argument is
    <span class="Li">&quot;after&quot;</span>, then you can modify
    <span class="Li">@_</span> to affect the return value.
    <span class="Li">&quot;after&quot;</span>'s return value is ignored.</p>
<p class="Pp">If the second argument is
    <span class="Li">&quot;replace&quot;</span>, then modifying
    <span class="Li">@_</span> doesn't do anything. The return value of
    <span class="Li">&quot;after&quot;</span> is returned from
    <span class="Li">&quot;preserve_context&quot;</span> instead.</p>
<p class="Pp">Run <span class="Li">&quot;preserve_context&quot;</span> like
    this:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  sub whatever {
      ...
      return preserve_context { orginal_function() }
                 after =&gt; sub { modify @_          };
  }

  or

  sub whatever {
      ...
      return preserve_context   { orginal_function() }
                 replace =&gt; sub { return @new_return };
  }
</pre>
<p class="Pp">Note that there's no comma between the first block and the
    <span class="Li">&quot;after</span> <span class="Li">=&gt;&quot;</span>
    part. This is how perl parses functions with the
    <span class="Li">&quot;(&amp;@)&quot;</span> prototype. The alternative is
    to say:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
      preserve_context(sub { original }, after =&gt; sub { after });
</pre>
<p class="Pp">You can pick the one you like, but I think the first version is
    much prettier.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="SUPPORT"><a class="permalink" href="#SUPPORT">SUPPORT</a></h1>
Bugs may be submitted through the RT bug tracker
  &lt;https://rt.cpan.org/Public/Dist/Display.html?Name=Context-Preserve&gt; (or
  bug-Context-Preserve@rt.cpan.org
  &lt;mailto:bug-Context-Preserve@rt.cpan.org&gt;).
<p class="Pp">I am also usually active on irc, as 'ether' at
    <span class="Li">&quot;irc.perl.org&quot;</span>.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
Jonathan Rockway &lt;jrockway@cpan.org&gt;
</section>
<section class="Sh">
<h1 class="Sh" id="CONTRIBUTORS"><a class="permalink" href="#CONTRIBUTORS">CONTRIBUTORS</a></h1>
<ul class="Bl-bullet">
  <li>Karen Etheridge &lt;ether@cpan.org&gt;</li>
  <li>Jonathan Rockway &lt;jon@jrock.us&gt;</li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT_AND_LICENCE"><a class="permalink" href="#COPYRIGHT_AND_LICENCE">COPYRIGHT
  AND LICENCE</a></h1>
This software is copyright (c) 2008 by Infinity Interactive.
<p class="Pp">This is free software; you can redistribute it and/or modify it
    under the same terms as the Perl 5 programming language system itself.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2017-11-03</td>
    <td class="foot-os">perl v5.28.2</td>
  </tr>
</table>
</body>
</html>
