<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    .Nd, .Bf, .Op { display: inline; }
    .Pa, .Ad { font-style: italic; }
    .Ms { font-weight: bold; }
    .Bl-diag > dt { font-weight: bold; }
    code.Nm, .Fl, .Cm, .Ic, code.In, .Fd, .Fn, .Cd { font-weight: bold;
      font-family: inherit; }
  </style>
  <title>PERLINTERN(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">PERLINTERN(1)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">PERLINTERN(1)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">perlintern - autogenerated documentation of purely internal Perl
    functions</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">This file is the autogenerated documentation of functions in the
    Perl interpreter that are documented using Perl's internal documentation
    format but are not marked as part of the Perl API. In other words, <b>they
    are not for use in extensions</b>!</p>
<p class="Pp">It has the same sections as perlapi, though some may be empty.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AV_Handling"><a class="permalink" href="#AV_Handling">AV
  Handling</a></h1>
<dl class="Bl-tag">
  <dt>&quot;AvFILLp&quot;</dt>
  <dd>If the array <span class="Li">&quot;av&quot;</span> is empty, this returns
      -1; otherwise it returns the maximum value of the indices of all the array
      elements which are currently defined in
      <span class="Li">&quot;av&quot;</span>. It does not handle magic, hence
      the <span class="Li">&quot;p&quot;</span> private indication in its
    name.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> SSize_t  AvFILLp(AV* av)
</pre>
</div>
<div class="Bd-indent"></div>
</section>
<section class="Sh">
<h1 class="Sh" id="Callback_Functions"><a class="permalink" href="#Callback_Functions">Callback
  Functions</a></h1>
<p class="Pp">There are only public API items currently in Callback
  Functions</p>
</section>
<section class="Sh">
<h1 class="Sh" id="Casting"><a class="permalink" href="#Casting">Casting</a></h1>
<p class="Pp">There are only public API items currently in Casting</p>
</section>
<section class="Sh">
<h1 class="Sh" id="Character_case_changing"><a class="permalink" href="#Character_case_changing">Character
  case changing</a></h1>
<p class="Pp">There are only public API items currently in Character case
    changing</p>
</section>
<section class="Sh">
<h1 class="Sh" id="Character_classification"><a class="permalink" href="#Character_classification">Character
  classification</a></h1>
<p class="Pp">There are only public API items currently in Character
    classification</p>
</section>
<section class="Sh">
<h1 class="Sh" id="Compiler_and_Preprocessor_information"><a class="permalink" href="#Compiler_and_Preprocessor_information">Compiler
  and Preprocessor information</a></h1>
<p class="Pp">There are only public API items currently in Compiler and
    Preprocessor information</p>
</section>
<section class="Sh">
<h1 class="Sh" id="Compiler_directives"><a class="permalink" href="#Compiler_directives">Compiler
  directives</a></h1>
<p class="Pp">There are only public API items currently in Compiler
  directives</p>
</section>
<section class="Sh">
<h1 class="Sh" id="Compile-time_scope_hooks"><a class="permalink" href="#Compile-time_scope_hooks">Compile-time
  scope hooks</a></h1>
<dl class="Bl-tag">
  <dt>&quot;BhkENTRY&quot;</dt>
  <dd>NOTE: <span class="Li">&quot;BhkENTRY&quot;</span> is <b>experimental</b>
      and may change or be removed without notice.
    <p class="Pp">Return an entry from the BHK structure.
        <span class="Li">&quot;which&quot;</span> is a preprocessor token
        indicating which entry to return. If the appropriate flag is not set
        this will return <span class="Li">&quot;NULL&quot;</span>. The type of
        the return value depends on which entry you ask for.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void *  BhkENTRY(BHK *hk, which)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;BhkFLAGS&quot;</dt>
  <dd>NOTE: <span class="Li">&quot;BhkFLAGS&quot;</span> is <b>experimental</b>
      and may change or be removed without notice.
    <p class="Pp">Return the BHK's flags.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> U32  BhkFLAGS(BHK *hk)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;CALL_BLOCK_HOOKS&quot;</dt>
  <dd>NOTE: <span class="Li">&quot;CALL_BLOCK_HOOKS&quot;</span> is
      <b>experimental</b> and may change or be removed without notice.
    <p class="Pp">Call all the registered block hooks for type
        <span class="Li">&quot;which&quot;</span>.
        <span class="Li">&quot;which&quot;</span> is a preprocessing token; the
        type of <span class="Li">&quot;arg&quot;</span> depends on
        <span class="Li">&quot;which&quot;</span>.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  CALL_BLOCK_HOOKS(which, arg)
</pre>
</div>
<div class="Bd-indent"></div>
</section>
<section class="Sh">
<h1 class="Sh" id="Concurrency"><a class="permalink" href="#Concurrency">Concurrency</a></h1>
<p class="Pp">There are only public API items currently in Concurrency</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COP_Hint_Hashes"><a class="permalink" href="#COP_Hint_Hashes">COP
  Hint Hashes</a></h1>
<p class="Pp">There are only public API items currently in COP Hint Hashes</p>
</section>
<section class="Sh">
<h1 class="Sh" id="Custom_Operators"><a class="permalink" href="#Custom_Operators">Custom
  Operators</a></h1>
<dl class="Bl-tag">
  <dt>&quot;core_prototype&quot;</dt>
  <dd>This function assigns the prototype of the named core function to
      <span class="Li">&quot;sv&quot;</span>, or to a new mortal SV if
      <span class="Li">&quot;sv&quot;</span> is
      <span class="Li">&quot;NULL&quot;</span>. It returns the modified
      <span class="Li">&quot;sv&quot;</span>, or
      <span class="Li">&quot;NULL&quot;</span> if the core function has no
      prototype. <span class="Li">&quot;code&quot;</span> is a code as returned
      by <span class="Li">&quot;keyword()&quot;</span>. It must not be equal to
      0.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> SV *  core_prototype(SV *sv, const char *name, const int code,
                      int * const opnum)
</pre>
</div>
<div class="Bd-indent"></div>
</section>
<section class="Sh">
<h1 class="Sh" id="CV_Handling"><a class="permalink" href="#CV_Handling">CV
  Handling</a></h1>
<dl class="Bl-tag">
  <dt>&quot;CvWEAKOUTSIDE&quot;</dt>
  <dd>Each CV has a pointer, <span class="Li">&quot;CvOUTSIDE()&quot;</span>, to
      its lexically enclosing CV (if any). Because pointers to anonymous sub
      prototypes are stored in <span class="Li">&quot;&amp;&quot;</span> pad
      slots, it is a possible to get a circular reference, with the parent
      pointing to the child and vice-versa. To avoid the ensuing memory leak, we
      do not increment the reference count of the CV pointed to by
      <span class="Li">&quot;CvOUTSIDE&quot;</span> in the <i>one specific
      instance</i> that the parent has a
      <span class="Li">&quot;&amp;&quot;</span> pad slot pointing back to us. In
      this case, we set the <span class="Li">&quot;CvWEAKOUTSIDE&quot;</span>
      flag in the child. This allows us to determine under what circumstances we
      should decrement the refcount of the parent when freeing the child.
    <p class="Pp">There is a further complication with non-closure anonymous
        subs (i.e. those that do not refer to any lexicals outside that sub). In
        this case, the anonymous prototype is shared rather than being cloned.
        This has the consequence that the parent may be freed while there are
        still active children, <i>e.g.</i>,</p>
    <p class="Pp"></p>
    <pre>    BEGIN { $a = sub { eval '$x' } }
    </pre>
    <p class="Pp">In this case, the BEGIN is freed immediately after execution
        since there are no active references to it: the anon sub prototype has
        <span class="Li">&quot;CvWEAKOUTSIDE&quot;</span> set since it's not a
        closure, and <span class="Li">$a</span> points to the same CV, so it
        doesn't contribute to BEGIN's refcount either. When
        <span class="Li">$a</span> is executed, the <span class="Li">&quot;eval
        '$x'&quot;</span> causes the chain of
        <span class="Li">&quot;CvOUTSIDE&quot;</span>s to be followed, and the
        freed BEGIN is accessed.</p>
    <p class="Pp">To avoid this, whenever a CV and its associated pad is freed,
        any <span class="Li">&quot;&amp;&quot;</span> entries in the pad are
        explicitly removed from the pad, and if the refcount of the pointed-to
        anon sub is still positive, then that child's
        <span class="Li">&quot;CvOUTSIDE&quot;</span> is set to point to its
        grandparent. This will only occur in the single specific case of a
        non-closure anon prototype having one or more active references (such as
        <span class="Li">$a</span> above).</p>
    <p class="Pp">One other thing to consider is that a CV may be merely
        undefined rather than freed, eg <span class="Li">&quot;undef
        &amp;foo&quot;</span>. In this case, its refcount may not have reached
        zero, but we still delete its pad and its
        <span class="Li">&quot;CvROOT&quot;</span> etc. Since various children
        may still have their <span class="Li">&quot;CvOUTSIDE&quot;</span>
        pointing at this undefined CV, we keep its own
        <span class="Li">&quot;CvOUTSIDE&quot;</span> for the time being, so
        that the chain of lexical scopes is unbroken. For example, the following
        should print 123:</p>
    <p class="Pp"></p>
    <pre>    my $x = 123;
    sub tmp { sub { eval '$x' } }
    my $a = tmp();
    undef &amp;tmp;
    print  $a-&gt;();
    </pre>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> bool  CvWEAKOUTSIDE(CV *cv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;docatch&quot;</dt>
  <dd>Check for the cases 0 or 3 of cur_env.je_ret, only used inside an eval
      context.
    <p class="Pp">0 is used as continue inside eval,</p>
    <p class="Pp">3 is used for a die caught by an inner eval - continue inner
        loop</p>
    <p class="Pp">See <i>cop.h</i>: je_mustcatch, when set at any runlevel to
        TRUE, means eval ops must establish a local jmpenv to handle exception
        traps.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> OP*  docatch(Perl_ppaddr_t firstpp)
</pre>
</div>
<div class="Bd-indent"></div>
</section>
<section class="Sh">
<h1 class="Sh" id="Debugging"><a class="permalink" href="#Debugging">Debugging</a></h1>
<dl class="Bl-tag">
  <dt>&quot;free_c_backtrace&quot;</dt>
  <dd>Deallocates a backtrace received from get_c_backtrace.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  free_c_backtrace(Perl_c_backtrace* bt)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;get_c_backtrace&quot;</dt>
  <dd>Collects the backtrace (aka &quot;stacktrace&quot;) into a single linear
      malloced buffer, which the caller <b>must</b>
      <span class="Li">&quot;Perl_free_c_backtrace()&quot;</span>.
    <p class="Pp">Scans the frames back by
        <span class="Li">&quot;depth&#x00A0;+&#x00A0;skip&quot;</span>, then
        drops the <span class="Li">&quot;skip&quot;</span> innermost, returning
        at most <span class="Li">&quot;depth&quot;</span> frames.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> Perl_c_backtrace*  get_c_backtrace(int max_depth, int skip)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;PL_DBsingle&quot;</dt>
  <dd>When Perl is run in debugging mode, with the <b>-d</b> switch, this SV is
      a boolean which indicates whether subs are being single-stepped.
      Single-stepping is automatically turned on after every step. This is the C
      variable which corresponds to Perl's <span class="Li">$DB::single</span>
      variable. See <span class="Li">&quot;PL_DBsub&quot;</span>.
    <p class="Pp">On threaded perls, each thread has an independent copy of this
        variable; each initialized at creation time with the current value of
        the creating thread's copy.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> SV *  PL_DBsingle
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;PL_DBsub&quot;</dt>
  <dd>When Perl is run in debugging mode, with the <b>-d</b> switch, this GV
      contains the SV which holds the name of the sub being debugged. This is
      the C variable which corresponds to Perl's
      <span class="Li">$DB::sub</span> variable. See
      <span class="Li">&quot;PL_DBsingle&quot;</span>.
    <p class="Pp">On threaded perls, each thread has an independent copy of this
        variable; each initialized at creation time with the current value of
        the creating thread's copy.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> GV *  PL_DBsub
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;PL_DBtrace&quot;</dt>
  <dd>Trace variable used when Perl is run in debugging mode, with the <b>-d</b>
      switch. This is the C variable which corresponds to Perl's
      <span class="Li">$DB::trace</span> variable. See
      <span class="Li">&quot;PL_DBsingle&quot;</span>.
    <p class="Pp">On threaded perls, each thread has an independent copy of this
        variable; each initialized at creation time with the current value of
        the creating thread's copy.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> SV *  PL_DBtrace
</pre>
</div>
<div class="Bd-indent"></div>
</section>
<section class="Sh">
<h1 class="Sh" id="Display_functions"><a class="permalink" href="#Display_functions">Display
  functions</a></h1>
<p class="Pp">There are only public API items currently in Display functions</p>
</section>
<section class="Sh">
<h1 class="Sh" id="Embedding_and_Interpreter_Cloning"><a class="permalink" href="#Embedding_and_Interpreter_Cloning">Embedding
  and Interpreter Cloning</a></h1>
<dl class="Bl-tag">
  <dt>&quot;cv_dump&quot;</dt>
  <dd>dump the contents of a CV</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  cv_dump(const CV *cv, const char *title)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;cv_forget_slab&quot;</dt>
  <dd>When a CV has a reference count on its slab
      (<span class="Li">&quot;CvSLABBED&quot;</span>), it is responsible for
      making sure it is freed. (Hence, no two CVs should ever have a reference
      count on the same slab.) The CV only needs to reference the slab during
      compilation. Once it is compiled and
      <span class="Li">&quot;CvROOT&quot;</span> attached, it has finished its
      job, so it can forget the slab.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  cv_forget_slab(CV *cv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;do_dump_pad&quot;</dt>
  <dd>Dump the contents of a padlist</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  do_dump_pad(I32 level, PerlIO *file, PADLIST *padlist,
                   int full)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;pad_alloc_name&quot;</dt>
  <dd>Allocates a place in the currently-compiling pad (via
      &quot;pad_alloc&quot; in perlapi) and then stores a name for that entry.
      <span class="Li">&quot;name&quot;</span> is adopted and becomes the name
      entry; it must already contain the name string.
      <span class="Li">&quot;typestash&quot;</span> and
      <span class="Li">&quot;ourstash&quot;</span> and the
      <span class="Li">&quot;padadd_STATE&quot;</span> flag get added to
      <span class="Li">&quot;name&quot;</span>. None of the other processing of
      &quot;pad_add_name_pvn&quot; in perlapi is done. Returns the offset of the
      allocated pad slot.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> PADOFFSET  pad_alloc_name(PADNAME *name, U32 flags, HV *typestash,
                           HV *ourstash)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;pad_block_start&quot;</dt>
  <dd>Update the pad compilation state variables on entry to a new block.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  pad_block_start(int full)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;pad_check_dup&quot;</dt>
  <dd>Check for duplicate declarations: report any of:
    <p class="Pp"></p>
    <pre>     * a 'my' in the current scope with the same name;
     * an 'our' (anywhere in the pad) with the same name and the
       same stash as 'ourstash'
    </pre>
    <p class="Pp"><span class="Li">&quot;is_our&quot;</span> indicates that the
        name to check is an <span class="Li">&quot;our&quot;</span>
      declaration.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  pad_check_dup(PADNAME *name, U32 flags, const HV *ourstash)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;pad_findlex&quot;</dt>
  <dd>Find a named lexical anywhere in a chain of nested pads. Add fake entries
      in the inner pads if it's found in an outer one.
    <p class="Pp">Returns the offset in the bottom pad of the lex or the fake
        lex. <span class="Li">&quot;cv&quot;</span> is the CV in which to start
        the search, and seq is the current
        <span class="Li">&quot;cop_seq&quot;</span> to match against. If
        <span class="Li">&quot;warn&quot;</span> is true, print appropriate
        warnings. The <span class="Li">&quot;out_&quot;</span>* vars return
        values, and so are pointers to where the returned values should be
        stored. <span class="Li">&quot;out_capture&quot;</span>, if non-null,
        requests that the innermost instance of the lexical is captured;
        <span class="Li">&quot;out_name&quot;</span> is set to the innermost
        matched pad name or fake pad name;
        <span class="Li">&quot;out_flags&quot;</span> returns the flags normally
        associated with the
        <span class="Li">&quot;PARENT_FAKELEX_FLAGS&quot;</span> field of a fake
        pad name.</p>
    <p class="Pp">Note that <span class="Li">&quot;pad_findlex()&quot;</span> is
        recursive; it recurses up the chain of CVs, then comes back down, adding
        fake entries as it goes. It has to be this way because fake names in
        anon prototypes have to store in
        <span class="Li">&quot;xpadn_low&quot;</span> the index into the parent
        pad.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> PADOFFSET  pad_findlex(const char *namepv, STRLEN namelen,
                        U32 flags, const CV* cv, U32 seq, int warn,
                        SV** out_capture, PADNAME** out_name,
                        int *out_flags)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;pad_fixup_inner_anons&quot;</dt>
  <dd>For any anon CVs in the pad, change
      <span class="Li">&quot;CvOUTSIDE&quot;</span> of that CV from
      <span class="Li">&quot;old_cv&quot;</span> to
      <span class="Li">&quot;new_cv&quot;</span> if necessary. Needed when a
      newly-compiled CV has to be moved to a pre-existing CV struct.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  pad_fixup_inner_anons(PADLIST *padlist, CV *old_cv,
                             CV *new_cv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;pad_free&quot;</dt>
  <dd>Free the SV at offset po in the current pad.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  pad_free(PADOFFSET po)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;pad_leavemy&quot;</dt>
  <dd>Cleanup at end of scope during compilation: set the max seq number for
      lexicals in this scope and warn of any lexicals that never got
    introduced.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> OP *  pad_leavemy()
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;padlist_dup&quot;</dt>
  <dd>Duplicates a pad.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> PADLIST *  padlist_dup(PADLIST *srcpad, CLONE_PARAMS *param)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;padname_dup&quot;</dt>
  <dd>Duplicates a pad name.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> PADNAME *  padname_dup(PADNAME *src, CLONE_PARAMS *param)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;padnamelist_dup&quot;</dt>
  <dd>Duplicates a pad name list.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> PADNAMELIST *  padnamelist_dup(PADNAMELIST *srcpad,
                                CLONE_PARAMS *param)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;pad_push&quot;</dt>
  <dd>Push a new pad frame onto the padlist, unless there's already a pad at
      this depth, in which case don't bother creating a new one. Then give the
      new pad an <span class="Li">@_</span> in slot zero.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  pad_push(PADLIST *padlist, int depth)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;pad_reset&quot;</dt>
  <dd>Mark all the current temporaries for reuse</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  pad_reset()
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;pad_setsv&quot;</dt>
  <dd>Set the value at offset <span class="Li">&quot;po&quot;</span> in the
      current (compiling or executing) pad. Use the macro
      <span class="Li">&quot;PAD_SETSV()&quot;</span> rather than calling this
      function directly.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  pad_setsv(PADOFFSET po, SV* sv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;pad_sv&quot;</dt>
  <dd>Get the value at offset <span class="Li">&quot;po&quot;</span> in the
      current (compiling or executing) pad. Use macro
      <span class="Li">&quot;PAD_SV&quot;</span> instead of calling this
      function directly.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> SV*  pad_sv(PADOFFSET po)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;pad_swipe&quot;</dt>
  <dd>Abandon the tmp in the current pad at offset
      <span class="Li">&quot;po&quot;</span> and replace with a new one.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  pad_swipe(PADOFFSET po, bool refadjust)
</pre>
</div>
<div class="Bd-indent"></div>
</section>
<section class="Sh">
<h1 class="Sh" id="Errno"><a class="permalink" href="#Errno">Errno</a></h1>
<dl class="Bl-tag">
  <dt>&quot;dSAVEDERRNO&quot;</dt>
  <dd>Declare variables needed to save <span class="Li">&quot;errno&quot;</span>
      and any operating system specific error number.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  dSAVEDERRNO
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;dSAVE_ERRNO&quot;</dt>
  <dd>Declare variables needed to save <span class="Li">&quot;errno&quot;</span>
      and any operating system specific error number, and save them for optional
      later restoration by
    <span class="Li">&quot;RESTORE_ERRNO&quot;</span>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  dSAVE_ERRNO
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;RESTORE_ERRNO&quot;</dt>
  <dd>Restore <span class="Li">&quot;errno&quot;</span> and any operating system
      specific error number that was saved by
      <span class="Li">&quot;dSAVE_ERRNO&quot;</span> or
      <span class="Li">&quot;RESTORE_ERRNO&quot;</span>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  RESTORE_ERRNO
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;SAVE_ERRNO&quot;</dt>
  <dd>Save <span class="Li">&quot;errno&quot;</span> and any operating system
      specific error number for optional later restoration by
      <span class="Li">&quot;RESTORE_ERRNO&quot;</span>. Requires
      <span class="Li">&quot;dSAVEDERRNO&quot;</span> or
      <span class="Li">&quot;dSAVE_ERRNO&quot;</span> in scope.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  SAVE_ERRNO
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;SETERRNO&quot;</dt>
  <dd>Set <span class="Li">&quot;errno&quot;</span>, and on VMS set
      <span class="Li">&quot;vaxc$errno&quot;</span>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  SETERRNO(int errcode, int vmserrcode)
</pre>
</div>
<div class="Bd-indent"></div>
</section>
<section class="Sh">
<h1 class="Sh" id="Exception_Handling_(simple)_Macros"><a class="permalink" href="#Exception_Handling_(simple)_Macros">Exception
  Handling (simple) Macros</a></h1>
<p class="Pp">There are only public API items currently in Exception Handling
    (simple) Macros</p>
</section>
<section class="Sh">
<h1 class="Sh" id="Filesystem_configuration_values"><a class="permalink" href="#Filesystem_configuration_values">Filesystem
  configuration values</a></h1>
<p class="Pp">There are only public API items currently in Filesystem
    configuration values</p>
</section>
<section class="Sh">
<h1 class="Sh" id="Floating_point_configuration_values"><a class="permalink" href="#Floating_point_configuration_values">Floating
  point configuration values</a></h1>
<p class="Pp">There are only public API items currently in Floating point
    configuration values</p>
</section>
<section class="Sh">
<h1 class="Sh" id="Formats"><a class="permalink" href="#Formats">Formats</a></h1>
<p class="Pp">There are only public API items currently in Formats</p>
</section>
<section class="Sh">
<h1 class="Sh" id="General_Configuration"><a class="permalink" href="#General_Configuration">General
  Configuration</a></h1>
<p class="Pp">There are only public API items currently in General
  Configuration</p>
</section>
<section class="Sh">
<h1 class="Sh" id="Global_Variables"><a class="permalink" href="#Global_Variables">Global
  Variables</a></h1>
<p class="Pp">There are only public API items currently in Global Variables</p>
</section>
<section class="Sh">
<h1 class="Sh" id="GV_Handling"><a class="permalink" href="#GV_Handling">GV
  Handling</a></h1>
<dl class="Bl-tag">
  <dt>&quot;gv_stashsvpvn_cached&quot;</dt>
  <dd>Returns a pointer to the stash for a specified package, possibly cached.
      Implements both
      &quot;<span class="Li">&quot;gv_stashpvn&quot;</span>&quot; in perlapi and
      &quot;<span class="Li">&quot;gv_stashsv&quot;</span>&quot; in perlapi.
    <p class="Pp">Requires one of either
        <span class="Li">&quot;namesv&quot;</span> or
        <span class="Li">&quot;namepv&quot;</span> to be non-null.</p>
    <p class="Pp">If the flag <span class="Li">&quot;GV_CACHE_ONLY&quot;</span>
        is set, return the stash only if found in the cache; see
        &quot;<span class="Li">&quot;gv_stashpvn&quot;</span>&quot; in perlapi
        for details on the other <span class="Li">&quot;flags&quot;</span>.</p>
    <p class="Pp">Note it is strongly preferred for
        <span class="Li">&quot;namesv&quot;</span> to be non-null, for
        performance reasons.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> HV*  gv_stashsvpvn_cached(SV *namesv, const char* name,
                           U32 namelen, I32 flags)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;gv_try_downgrade&quot;</dt>
  <dd>NOTE: <span class="Li">&quot;gv_try_downgrade&quot;</span> is
      <b>experimental</b> and may change or be removed without notice.
    <p class="Pp">If the typeglob <span class="Li">&quot;gv&quot;</span> can be
        expressed more succinctly, by having something other than a real GV in
        its place in the stash, replace it with the optimised form. Basic
        requirements for this are that <span class="Li">&quot;gv&quot;</span> is
        a real typeglob, is sufficiently ordinary, and is only referenced from
        its package. This function is meant to be used when a GV has been looked
        up in part to see what was there, causing upgrading, but based on what
        was found it turns out that the real GV isn't required after all.</p>
    <p class="Pp">If <span class="Li">&quot;gv&quot;</span> is a completely
        empty typeglob, it is deleted from the stash.</p>
    <p class="Pp">If <span class="Li">&quot;gv&quot;</span> is a typeglob
        containing only a sufficiently-ordinary constant sub, the typeglob is
        replaced with a scalar-reference placeholder that more compactly
        represents the same thing.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  gv_try_downgrade(GV* gv)
</pre>
</div>
<div class="Bd-indent"></div>
</section>
<section class="Sh">
<h1 class="Sh" id="Hook_manipulation"><a class="permalink" href="#Hook_manipulation">Hook
  manipulation</a></h1>
<p class="Pp">There are only public API items currently in Hook manipulation</p>
</section>
<section class="Sh">
<h1 class="Sh" id="HV_Handling"><a class="permalink" href="#HV_Handling">HV
  Handling</a></h1>
<dl class="Bl-tag">
  <dt>&quot;hv_ename_add&quot;</dt>
  <dd>Adds a name to a stash's internal list of effective names. See
      <span class="Li">&quot;hv_ename_delete&quot;</span>.
    <p class="Pp">This is called when a stash is assigned to a new location in
        the symbol table.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  hv_ename_add(HV *hv, const char *name, U32 len, U32 flags)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;hv_ename_delete&quot;</dt>
  <dd>Removes a name from a stash's internal list of effective names. If this is
      the name returned by <span class="Li">&quot;HvENAME&quot;</span>, then
      another name in the list will take its place
      (<span class="Li">&quot;HvENAME&quot;</span> will use it).
    <p class="Pp">This is called when a stash is deleted from the symbol
      table.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  hv_ename_delete(HV *hv, const char *name, U32 len,
                       U32 flags)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;refcounted_he_chain_2hv&quot;</dt>
  <dd>Generates and returns a <span class="Li">&quot;HV *&quot;</span>
      representing the content of a
      <span class="Li">&quot;refcounted_he&quot;</span> chain.
      <span class="Li">&quot;flags&quot;</span> is currently unused and must be
      zero.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> HV *  refcounted_he_chain_2hv(const struct refcounted_he *c,
                               U32 flags)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;refcounted_he_fetch_pv&quot;</dt>
  <dd>Like &quot;refcounted_he_fetch_pvn&quot;, but takes a nul-terminated
      string instead of a string/length pair.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> SV *  refcounted_he_fetch_pv(const struct refcounted_he *chain,
                              const char *key, U32 hash, U32 flags)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;refcounted_he_fetch_pvn&quot;</dt>
  <dd>Search along a <span class="Li">&quot;refcounted_he&quot;</span> chain for
      an entry with the key specified by
      <span class="Li">&quot;keypv&quot;</span> and
      <span class="Li">&quot;keylen&quot;</span>. If
      <span class="Li">&quot;flags&quot;</span> has the
      <span class="Li">&quot;REFCOUNTED_HE_KEY_UTF8&quot;</span> bit set, the
      key octets are interpreted as UTF-8, otherwise they are interpreted as
      Latin-1. <span class="Li">&quot;hash&quot;</span> is a precomputed hash of
      the key string, or zero if it has not been precomputed. Returns a mortal
      scalar representing the value associated with the key, or
      <span class="Li">&amp;PL_sv_placeholder</span> if there is no value
      associated with the key.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> SV *  refcounted_he_fetch_pvn(const struct refcounted_he *chain,
                               const char *keypv, STRLEN keylen,
                               U32 hash, U32 flags)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;refcounted_he_fetch_pvs&quot;</dt>
  <dd>Like &quot;refcounted_he_fetch_pvn&quot;, but takes a literal string
      instead of a string/length pair, and no precomputed hash.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> SV *  refcounted_he_fetch_pvs(const struct refcounted_he *chain,
                               &quot;key&quot;, U32 flags)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;refcounted_he_fetch_sv&quot;</dt>
  <dd>Like &quot;refcounted_he_fetch_pvn&quot;, but takes a Perl scalar instead
      of a string/length pair.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> SV *  refcounted_he_fetch_sv(const struct refcounted_he *chain,
                              SV *key, U32 hash, U32 flags)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;refcounted_he_free&quot;</dt>
  <dd>Decrements the reference count of a
      <span class="Li">&quot;refcounted_he&quot;</span> by one. If the reference
      count reaches zero the structure's memory is freed, which (recursively)
      causes a reduction of its parent
      <span class="Li">&quot;refcounted_he&quot;</span>'s reference count. It is
      safe to pass a null pointer to this function: no action occurs in this
      case.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  refcounted_he_free(struct refcounted_he *he)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;refcounted_he_inc&quot;</dt>
  <dd>Increment the reference count of a
      <span class="Li">&quot;refcounted_he&quot;</span>. The pointer to the
      <span class="Li">&quot;refcounted_he&quot;</span> is also returned. It is
      safe to pass a null pointer to this function: no action occurs and a null
      pointer is returned.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> struct refcounted_he *  refcounted_he_inc(
                                          struct refcounted_he *he)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;refcounted_he_new_pv&quot;</dt>
  <dd>Like &quot;refcounted_he_new_pvn&quot;, but takes a nul-terminated string
      instead of a string/length pair.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> struct refcounted_he *  refcounted_he_new_pv(
                                      struct refcounted_he *parent,
                                      const char *key, U32 hash,
                                      SV *value, U32 flags)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;refcounted_he_new_pvn&quot;</dt>
  <dd>Creates a new <span class="Li">&quot;refcounted_he&quot;</span>. This
      consists of a single key/value pair and a reference to an existing
      <span class="Li">&quot;refcounted_he&quot;</span> chain (which may be
      empty), and thus forms a longer chain. When using the longer chain, the
      new key/value pair takes precedence over any entry for the same key
      further along the chain.
    <p class="Pp">The new key is specified by
        <span class="Li">&quot;keypv&quot;</span> and
        <span class="Li">&quot;keylen&quot;</span>. If
        <span class="Li">&quot;flags&quot;</span> has the
        <span class="Li">&quot;REFCOUNTED_HE_KEY_UTF8&quot;</span> bit set, the
        key octets are interpreted as UTF-8, otherwise they are interpreted as
        Latin-1. <span class="Li">&quot;hash&quot;</span> is a precomputed hash
        of the key string, or zero if it has not been precomputed.</p>
    <p class="Pp"><span class="Li">&quot;value&quot;</span> is the scalar value
        to store for this key. <span class="Li">&quot;value&quot;</span> is
        copied by this function, which thus does not take ownership of any
        reference to it, and later changes to the scalar will not be reflected
        in the value visible in the
        <span class="Li">&quot;refcounted_he&quot;</span>. Complex types of
        scalar will not be stored with referential integrity, but will be
        coerced to strings. <span class="Li">&quot;value&quot;</span> may be
        either null or <span class="Li">&amp;PL_sv_placeholder</span> to
        indicate that no value is to be associated with the key; this, as with
        any non-null value, takes precedence over the existence of a value for
        the key further along the chain.</p>
    <p class="Pp"><span class="Li">&quot;parent&quot;</span> points to the rest
        of the <span class="Li">&quot;refcounted_he&quot;</span> chain to be
        attached to the new <span class="Li">&quot;refcounted_he&quot;</span>.
        This function takes ownership of one reference to
        <span class="Li">&quot;parent&quot;</span>, and returns one reference to
        the new <span class="Li">&quot;refcounted_he&quot;</span>.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> struct refcounted_he *  refcounted_he_new_pvn(
                                      struct refcounted_he *parent,
                                      const char *keypv,
                                      STRLEN keylen, U32 hash,
                                      SV *value, U32 flags)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;refcounted_he_new_pvs&quot;</dt>
  <dd>Like &quot;refcounted_he_new_pvn&quot;, but takes a literal string instead
      of a string/length pair, and no precomputed hash.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> struct refcounted_he *  refcounted_he_new_pvs(
                                      struct refcounted_he *parent,
                                      &quot;key&quot;, SV *value, U32 flags)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;refcounted_he_new_sv&quot;</dt>
  <dd>Like &quot;refcounted_he_new_pvn&quot;, but takes a Perl scalar instead of
      a string/length pair.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> struct refcounted_he *  refcounted_he_new_sv(
                                      struct refcounted_he *parent,
                                      SV *key, U32 hash, SV *value,
                                      U32 flags)
</pre>
</div>
<div class="Bd-indent"></div>
</section>
<section class="Sh">
<h1 class="Sh" id="Input/Output"><a class="permalink" href="#Input/Output">Input/Output</a></h1>
<dl class="Bl-tag">
  <dt>&quot;PL_last_in_gv&quot;</dt>
  <dd>The GV which was last used for a filehandle input operation.
      (<span class="Li">&quot;&lt;FH&gt;&quot;</span>)
    <p class="Pp">On threaded perls, each thread has an independent copy of this
        variable; each initialized at creation time with the current value of
        the creating thread's copy.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> GV*  PL_last_in_gv
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;PL_ofsgv&quot;</dt>
  <dd>The glob containing the output field separator -
      <span class="Li">&quot;*,&quot;</span> in Perl space.
    <p class="Pp">On threaded perls, each thread has an independent copy of this
        variable; each initialized at creation time with the current value of
        the creating thread's copy.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> GV*  PL_ofsgv
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;PL_rs&quot;</dt>
  <dd>The input record separator - <span class="Li">$/</span> in Perl space.
    <p class="Pp">On threaded perls, each thread has an independent copy of this
        variable; each initialized at creation time with the current value of
        the creating thread's copy.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> SV*  PL_rs
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;start_glob&quot;</dt>
  <dd>NOTE: <span class="Li">&quot;start_glob&quot;</span> is
      <b>experimental</b> and may change or be removed without notice.
    <p class="Pp">Function called by
        <span class="Li">&quot;do_readline&quot;</span> to spawn a glob (or do
        the glob inside perl on VMS). This code used to be inline, but now perl
        uses <span class="Li">&quot;File::Glob&quot;</span> this glob starter is
        only used by miniperl during the build process, or when
        PERL_EXTERNAL_GLOB is defined. Moving it away shrinks <i>pp_hot.c</i>;
        shrinking <i>pp_hot.c</i> helps speed perl up.</p>
    <p class="Pp">NOTE: <span class="Li">&quot;start_glob&quot;</span> must be
        explicitly called as <span class="Li">&quot;Perl_start_glob&quot;</span>
        with an <span class="Li">&quot;aTHX_&quot;</span> parameter.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> PerlIO*  Perl_start_glob(pTHX_ SV *tmpglob, IO *io)
</pre>
</div>
<div class="Bd-indent"></div>
</section>
<section class="Sh">
<h1 class="Sh" id="Integer_configuration_values"><a class="permalink" href="#Integer_configuration_values">Integer
  configuration values</a></h1>
<p class="Pp">There are only public API items currently in Integer configuration
    values</p>
</section>
<section class="Sh">
<h1 class="Sh" id="Lexer_interface"><a class="permalink" href="#Lexer_interface">Lexer
  interface</a></h1>
<dl class="Bl-tag">
  <dt>&quot;validate_proto&quot;</dt>
  <dd>NOTE: <span class="Li">&quot;validate_proto&quot;</span> is
      <b>experimental</b> and may change or be removed without notice.
    <p class="Pp">This function performs syntax checking on a prototype,
        <span class="Li">&quot;proto&quot;</span>. If
        <span class="Li">&quot;warn&quot;</span> is true, any illegal characters
        or mismatched brackets will trigger illegalproto warnings, declaring
        that they were detected in the prototype for
        <span class="Li">&quot;name&quot;</span>.</p>
    <p class="Pp">The return value is <span class="Li">&quot;true&quot;</span>
        if this is a valid prototype, and
        <span class="Li">&quot;false&quot;</span> if it is not, regardless of
        whether <span class="Li">&quot;warn&quot;</span> was
        <span class="Li">&quot;true&quot;</span> or
        <span class="Li">&quot;false&quot;</span>.</p>
    <p class="Pp">Note that <span class="Li">&quot;NULL&quot;</span> is a valid
        <span class="Li">&quot;proto&quot;</span> and will always return
        <span class="Li">&quot;true&quot;</span>.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> bool  validate_proto(SV *name, SV *proto, bool warn,
                      bool curstash)
</pre>
</div>
<div class="Bd-indent"></div>
</section>
<section class="Sh">
<h1 class="Sh" id="Locales"><a class="permalink" href="#Locales">Locales</a></h1>
<p class="Pp">There are only public API items currently in Locales</p>
</section>
<section class="Sh">
<h1 class="Sh" id="Magic"><a class="permalink" href="#Magic">Magic</a></h1>
<dl class="Bl-tag">
  <dt>&quot;magic_clearhint&quot;</dt>
  <dd>Triggered by a delete from <span class="Li">&quot;%^H&quot;</span>,
      records the key to
      <span class="Li">&quot;PL_compiling.cop_hints_hash&quot;</span>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> int  magic_clearhint(SV* sv, MAGIC* mg)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;magic_clearhints&quot;</dt>
  <dd>Triggered by clearing <span class="Li">&quot;%^H&quot;</span>, resets
      <span class="Li">&quot;PL_compiling.cop_hints_hash&quot;</span>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> int  magic_clearhints(SV* sv, MAGIC* mg)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;magic_methcall&quot;</dt>
  <dd>Invoke a magic method (like FETCH).
    <p class="Pp"><span class="Li">&quot;sv&quot;</span> and
        <span class="Li">&quot;mg&quot;</span> are the tied thingy and the tie
        magic.</p>
    <p class="Pp"><span class="Li">&quot;meth&quot;</span> is the name of the
        method to call.</p>
    <p class="Pp"><span class="Li">&quot;argc&quot;</span> is the number of args
        (in addition to <span class="Li">$self</span>) to pass to the
      method.</p>
    <p class="Pp">The <span class="Li">&quot;flags&quot;</span> can be:</p>
    <p class="Pp"></p>
    <pre>    G_DISCARD     invoke method with G_DISCARD flag and don't
                  return a value
    G_UNDEF_FILL  fill the stack with argc pointers to
                  PL_sv_undef
    </pre>
    <p class="Pp">The arguments themselves are any values following the
        <span class="Li">&quot;flags&quot;</span> argument.</p>
    <p class="Pp">Returns the SV (if any) returned by the method, or
        <span class="Li">&quot;NULL&quot;</span> on failure.</p>
    <p class="Pp">NOTE: <span class="Li">&quot;magic_methcall&quot;</span> must
        be explicitly called as
        <span class="Li">&quot;Perl_magic_methcall&quot;</span> with an
        <span class="Li">&quot;aTHX_&quot;</span> parameter.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> SV*  Perl_magic_methcall(pTHX_ SV *sv, const MAGIC *mg, SV *meth,
                          U32 flags, U32 argc, ...)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;magic_sethint&quot;</dt>
  <dd>Triggered by a store to <span class="Li">&quot;%^H&quot;</span>, records
      the key/value pair to
      <span class="Li">&quot;PL_compiling.cop_hints_hash&quot;</span>. It is
      assumed that hints aren't storing anything that would need a deep copy.
      Maybe we should warn if we find a reference.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> int  magic_sethint(SV* sv, MAGIC* mg)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;mg_localize&quot;</dt>
  <dd>Copy some of the magic from an existing SV to new localized version of
      that SV. Container magic (<i>e.g.</i>, <span class="Li">%ENV</span>,
      <span class="Li">$1</span>, <span class="Li">&quot;tie&quot;</span>) gets
      copied, value magic doesn't (<i>e.g.</i>,
      <span class="Li">&quot;taint&quot;</span>,
      <span class="Li">&quot;pos&quot;</span>).
    <p class="Pp">If <span class="Li">&quot;setmagic&quot;</span> is false then
        no set magic will be called on the new (empty) SV. This typically means
        that assignment will soon follow (e.g.
        <span class="Li">'local&#x00A0;$x&#x00A0;=&#x00A0;$y'</span>), and that
        will handle the magic.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  mg_localize(SV* sv, SV* nsv, bool setmagic)
</pre>
</div>
<div class="Bd-indent"></div>
</section>
<section class="Sh">
<h1 class="Sh" id="Memory_Management"><a class="permalink" href="#Memory_Management">Memory
  Management</a></h1>
<p class="Pp">There are only public API items currently in Memory Management</p>
</section>
<section class="Sh">
<h1 class="Sh" id="MRO"><a class="permalink" href="#MRO">MRO</a></h1>
<dl class="Bl-tag">
  <dt>&quot;mro_get_linear_isa_dfs&quot;</dt>
  <dd>Returns the Depth-First Search linearization of
      <span class="Li">@ISA</span> the given stash. The return value is a
      read-only AV*. <span class="Li">&quot;level&quot;</span> should be 0 (it
      is used internally in this function's recursion).
    <p class="Pp">You are responsible for
        <span class="Li">&quot;SvREFCNT_inc()&quot;</span> on the return value
        if you plan to store it anywhere semi-permanently (otherwise it might be
        deleted out from under you the next time the cache is invalidated).</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> AV*  mro_get_linear_isa_dfs(HV* stash, U32 level)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;mro_isa_changed_in&quot;</dt>
  <dd>Takes the necessary steps (cache invalidations, mostly) when the
      <span class="Li">@ISA</span> of the given package has changed. Invoked by
      the <span class="Li">&quot;setisa&quot;</span> magic, should not need to
      invoke directly.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  mro_isa_changed_in(HV* stash)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;mro_package_moved&quot;</dt>
  <dd>Call this function to signal to a stash that it has been assigned to
      another spot in the stash hierarchy.
      <span class="Li">&quot;stash&quot;</span> is the stash that has been
      assigned. <span class="Li">&quot;oldstash&quot;</span> is the stash it
      replaces, if any. <span class="Li">&quot;gv&quot;</span> is the glob that
      is actually being assigned to.
    <p class="Pp">This can also be called with a null first argument to indicate
        that <span class="Li">&quot;oldstash&quot;</span> has been deleted.</p>
    <p class="Pp">This function invalidates isa caches on the old stash, on all
        subpackages nested inside it, and on the subclasses of all those,
        including non-existent packages that have corresponding entries in
        <span class="Li">&quot;stash&quot;</span>.</p>
    <p class="Pp">It also sets the effective names
        (<span class="Li">&quot;HvENAME&quot;</span>) on all the stashes as
        appropriate.</p>
    <p class="Pp">If the <span class="Li">&quot;gv&quot;</span> is present and
        is not in the symbol table, then this function simply returns. This
        checked will be skipped if <span class="Li">&quot;flags &amp;
        1&quot;</span>.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  mro_package_moved(HV * const stash, HV * const oldstash,
                         const GV * const gv, U32 flags)
</pre>
</div>
<div class="Bd-indent"></div>
</section>
<section class="Sh">
<h1 class="Sh" id="Multicall_Functions"><a class="permalink" href="#Multicall_Functions">Multicall
  Functions</a></h1>
<p class="Pp">There are only public API items currently in Multicall
  Functions</p>
</section>
<section class="Sh">
<h1 class="Sh" id="Numeric_Functions"><a class="permalink" href="#Numeric_Functions">Numeric
  Functions</a></h1>
<dl class="Bl-tag">
  <dt>&quot;grok_atoUV&quot;</dt>
  <dd>parse a string, looking for a decimal unsigned integer.
    <p class="Pp">On entry, <span class="Li">&quot;pv&quot;</span> points to the
        beginning of the string; <span class="Li">&quot;valptr&quot;</span>
        points to a UV that will receive the converted value, if found;
        <span class="Li">&quot;endptr&quot;</span> is either NULL or points to a
        variable that points to one byte beyond the point in
        <span class="Li">&quot;pv&quot;</span> that this routine should examine.
        If <span class="Li">&quot;endptr&quot;</span> is NULL,
        <span class="Li">&quot;pv&quot;</span> is assumed to be
      NUL-terminated.</p>
    <p class="Pp">Returns FALSE if <span class="Li">&quot;pv&quot;</span>
        doesn't represent a valid unsigned integer value (with no leading
        zeros). Otherwise it returns TRUE, and sets
        <span class="Li">*valptr</span> to that value.</p>
    <p class="Pp">If you constrain the portion of
        <span class="Li">&quot;pv&quot;</span> that is looked at by this
        function (by passing a non-NULL
        <span class="Li">&quot;endptr&quot;</span>), and if the intial bytes of
        that portion form a valid value, it will return TRUE, setting
        <span class="Li">*endptr</span> to the byte following the final digit of
        the value. But if there is no constraint at what's looked at, all of
        <span class="Li">&quot;pv&quot;</span> must be valid in order for TRUE
        to be returned. <span class="Li">*endptr</span> is unchanged from its
        value on input if FALSE is returned;</p>
    <p class="Pp">The only characters this accepts are the decimal digits
        '0'..'9'.</p>
    <p class="Pp">As opposed to <b>atoi</b>(3) or <b>strtol</b>(3),
        <span class="Li">&quot;grok_atoUV&quot;</span> does NOT allow optional
        leading whitespace, nor negative inputs. If such features are required,
        the calling code needs to explicitly implement those.</p>
    <p class="Pp">Note that this function returns FALSE for inputs that would
        overflow a UV, or have leading zeros. Thus a single
        <span class="Li">0</span> is accepted, but not
        <span class="Li">00</span> nor <span class="Li">01</span>,
        <span class="Li">002</span>, <i>etc</i>.</p>
    <p class="Pp">Background: <span class="Li">&quot;atoi&quot;</span> has
        severe problems with illegal inputs, it cannot be used for incremental
        parsing, and therefore should be avoided
        <span class="Li">&quot;atoi&quot;</span> and
        <span class="Li">&quot;strtol&quot;</span> are also affected by locale
        settings, which can also be seen as a bug (global state controlled by
        user environment).</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> bool  grok_atoUV(const char* pv, UV* valptr, const char** endptr)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;isinfnansv&quot;</dt>
  <dd>Checks whether the argument would be either an infinity or
      <span class="Li">&quot;NaN&quot;</span> when used as a number, but is
      careful not to trigger non-numeric or uninitialized warnings. it assumes
      the caller has done <span class="Li">&quot;SvGETMAGIC(sv)&quot;</span>
      already.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> bool  isinfnansv(SV *sv)
</pre>
</div>
<div class="Bd-indent"></div>
</section>
<section class="Sh">
<h1 class="Sh" id="Optree_construction"><a class="permalink" href="#Optree_construction">Optree
  construction</a></h1>
<p class="Pp">There are only public API items currently in Optree
  construction</p>
</section>
<section class="Sh">
<h1 class="Sh" id="Optree_Manipulation_Functions"><a class="permalink" href="#Optree_Manipulation_Functions">Optree
  Manipulation Functions</a></h1>
<dl class="Bl-tag">
  <dt>&quot;finalize_optree&quot;</dt>
  <dd>This function finalizes the optree. Should be called directly after the
      complete optree is built. It does some additional checking which can't be
      done in the normal <span class="Li">&quot;ck_&quot;</span>xxx functions
      and makes the tree thread-safe.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  finalize_optree(OP* o)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;newATTRSUB_x&quot;</dt>
  <dd>Construct a Perl subroutine, also performing some surrounding jobs.
    <p class="Pp">This function is expected to be called in a Perl compilation
        context, and some aspects of the subroutine are taken from global
        variables associated with compilation. In particular,
        <span class="Li">&quot;PL_compcv&quot;</span> represents the subroutine
        that is currently being compiled. It must be non-null when this function
        is called, and some aspects of the subroutine being constructed are
        taken from it. The constructed subroutine may actually be a reuse of the
        <span class="Li">&quot;PL_compcv&quot;</span> object, but will not
        necessarily be so.</p>
    <p class="Pp">If <span class="Li">&quot;block&quot;</span> is null then the
        subroutine will have no body, and for the time being it will be an error
        to call it. This represents a forward subroutine declaration such as
        <span class="Li">&quot;sub&#x00A0;foo&#x00A0;($$);&quot;</span>. If
        <span class="Li">&quot;block&quot;</span> is non-null then it provides
        the Perl code of the subroutine body, which will be executed when the
        subroutine is called. This body includes any argument unwrapping code
        resulting from a subroutine signature or similar. The pad use of the
        code must correspond to the pad attached to
        <span class="Li">&quot;PL_compcv&quot;</span>. The code is not expected
        to include a <span class="Li">&quot;leavesub&quot;</span> or
        <span class="Li">&quot;leavesublv&quot;</span> op; this function will
        add such an op. <span class="Li">&quot;block&quot;</span> is consumed by
        this function and will become part of the constructed subroutine.</p>
    <p class="Pp"><span class="Li">&quot;proto&quot;</span> specifies the
        subroutine's prototype, unless one is supplied as an attribute (see
        below). If <span class="Li">&quot;proto&quot;</span> is null, then the
        subroutine will not have a prototype. If
        <span class="Li">&quot;proto&quot;</span> is non-null, it must point to
        a <span class="Li">&quot;const&quot;</span> op whose value is a string,
        and the subroutine will have that string as its prototype. If a
        prototype is supplied as an attribute, the attribute takes precedence
        over <span class="Li">&quot;proto&quot;</span>, but in that case
        <span class="Li">&quot;proto&quot;</span> should preferably be null. In
        any case, <span class="Li">&quot;proto&quot;</span> is consumed by this
        function.</p>
    <p class="Pp"><span class="Li">&quot;attrs&quot;</span> supplies attributes
        to be applied the subroutine. A handful of attributes take effect by
        built-in means, being applied to
        <span class="Li">&quot;PL_compcv&quot;</span> immediately when seen.
        Other attributes are collected up and attached to the subroutine by this
        route. <span class="Li">&quot;attrs&quot;</span> may be null to supply
        no attributes, or point to a <span class="Li">&quot;const&quot;</span>
        op for a single attribute, or point to a
        <span class="Li">&quot;list&quot;</span> op whose children apart from
        the <span class="Li">&quot;pushmark&quot;</span> are
        <span class="Li">&quot;const&quot;</span> ops for one or more
        attributes. Each <span class="Li">&quot;const&quot;</span> op must be a
        string, giving the attribute name optionally followed by parenthesised
        arguments, in the manner in which attributes appear in Perl source. The
        attributes will be applied to the sub by this function.
        <span class="Li">&quot;attrs&quot;</span> is consumed by this
      function.</p>
    <p class="Pp">If <span class="Li">&quot;o_is_gv&quot;</span> is false and
        <span class="Li">&quot;o&quot;</span> is null, then the subroutine will
        be anonymous. If <span class="Li">&quot;o_is_gv&quot;</span> is false
        and <span class="Li">&quot;o&quot;</span> is non-null, then
        <span class="Li">&quot;o&quot;</span> must point to a
        <span class="Li">&quot;const&quot;</span> OP, which will be consumed by
        this function, and its string value supplies a name for the subroutine.
        The name may be qualified or unqualified, and if it is unqualified then
        a default stash will be selected in some manner. If
        <span class="Li">&quot;o_is_gv&quot;</span> is true, then
        <span class="Li">&quot;o&quot;</span> doesn't point to an
        <span class="Li">&quot;OP&quot;</span> at all, but is instead a cast
        pointer to a <span class="Li">&quot;GV&quot;</span> by which the
        subroutine will be named.</p>
    <p class="Pp">If there is already a subroutine of the specified name, then
        the new sub will either replace the existing one in the glob or be
        merged with the existing one. A warning may be generated about
        redefinition.</p>
    <p class="Pp">If the subroutine has one of a few special names, such as
        <span class="Li">&quot;BEGIN&quot;</span> or
        <span class="Li">&quot;END&quot;</span>, then it will be claimed by the
        appropriate queue for automatic running of phase-related subroutines. In
        this case the relevant glob will be left not containing any subroutine,
        even if it did contain one before. In the case of
        <span class="Li">&quot;BEGIN&quot;</span>, the subroutine will be
        executed and the reference to it disposed of before this function
        returns.</p>
    <p class="Pp">The function returns a pointer to the constructed subroutine.
        If the sub is anonymous then ownership of one counted reference to the
        subroutine is transferred to the caller. If the sub is named then the
        caller does not get ownership of a reference. In most such cases, where
        the sub has a non-phase name, the sub will be alive at the point it is
        returned by virtue of being contained in the glob that names it. A
        phase-named subroutine will usually be alive by virtue of the reference
        owned by the phase's automatic run queue. But a
        <span class="Li">&quot;BEGIN&quot;</span> subroutine, having already
        been executed, will quite likely have been destroyed already by the time
        this function returns, making it erroneous for the caller to make any
        use of the returned pointer. It is the caller's responsibility to ensure
        that it knows which of these situations applies.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> CV*  newATTRSUB_x(I32 floor, OP *o, OP *proto, OP *attrs,
                   OP *block, bool o_is_gv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;newXS_len_flags&quot;</dt>
  <dd>Construct an XS subroutine, also performing some surrounding jobs.
    <p class="Pp">The subroutine will have the entry point
        <span class="Li">&quot;subaddr&quot;</span>. It will have the prototype
        specified by the nul-terminated string
        <span class="Li">&quot;proto&quot;</span>, or no prototype if
        <span class="Li">&quot;proto&quot;</span> is null. The prototype string
        is copied; the caller can mutate the supplied string afterwards. If
        <span class="Li">&quot;filename&quot;</span> is non-null, it must be a
        nul-terminated filename, and the subroutine will have its
        <span class="Li">&quot;CvFILE&quot;</span> set accordingly. By default
        <span class="Li">&quot;CvFILE&quot;</span> is set to point directly to
        the supplied string, which must be static. If
        <span class="Li">&quot;flags&quot;</span> has the
        <span class="Li">&quot;XS_DYNAMIC_FILENAME&quot;</span> bit set, then a
        copy of the string will be taken instead.</p>
    <p class="Pp">Other aspects of the subroutine will be left in their default
        state. If anything else needs to be done to the subroutine for it to
        function correctly, it is the caller's responsibility to do that after
        this function has constructed it. However, beware of the subroutine
        potentially being destroyed before this function returns, as described
        below.</p>
    <p class="Pp">If <span class="Li">&quot;name&quot;</span> is null then the
        subroutine will be anonymous, with its
        <span class="Li">&quot;CvGV&quot;</span> referring to an
        <span class="Li">&quot;__ANON__&quot;</span> glob. If
        <span class="Li">&quot;name&quot;</span> is non-null then the subroutine
        will be named accordingly, referenced by the appropriate glob.
        <span class="Li">&quot;name&quot;</span> is a string of length
        <span class="Li">&quot;len&quot;</span> bytes giving a sigilless symbol
        name, in UTF-8 if <span class="Li">&quot;flags&quot;</span> has the
        <span class="Li">&quot;SVf_UTF8&quot;</span> bit set and in Latin-1
        otherwise. The name may be either qualified or unqualified, with the
        stash defaulting in the same manner as for
        <span class="Li">&quot;gv_fetchpvn_flags&quot;</span>.
        <span class="Li">&quot;flags&quot;</span> may contain flag bits
        understood by <span class="Li">&quot;gv_fetchpvn_flags&quot;</span> with
        the same meaning as they have there, such as
        <span class="Li">&quot;GV_ADDWARN&quot;</span>. The symbol is always
        added to the stash if necessary, with
        <span class="Li">&quot;GV_ADDMULTI&quot;</span> semantics.</p>
    <p class="Pp">If there is already a subroutine of the specified name, then
        the new sub will replace the existing one in the glob. A warning may be
        generated about the redefinition. If the old subroutine was
        <span class="Li">&quot;CvCONST&quot;</span> then the decision about
        whether to warn is influenced by an expectation about whether the new
        subroutine will become a constant of similar value. That expectation is
        determined by <span class="Li">&quot;const_svp&quot;</span>. (Note that
        the call to this function doesn't make the new subroutine
        <span class="Li">&quot;CvCONST&quot;</span> in any case; that is left to
        the caller.) If <span class="Li">&quot;const_svp&quot;</span> is null
        then it indicates that the new subroutine will not become a constant. If
        <span class="Li">&quot;const_svp&quot;</span> is non-null then it
        indicates that the new subroutine will become a constant, and it points
        to an <span class="Li">&quot;SV*&quot;</span> that provides the constant
        value that the subroutine will have.</p>
    <p class="Pp">If the subroutine has one of a few special names, such as
        <span class="Li">&quot;BEGIN&quot;</span> or
        <span class="Li">&quot;END&quot;</span>, then it will be claimed by the
        appropriate queue for automatic running of phase-related subroutines. In
        this case the relevant glob will be left not containing any subroutine,
        even if it did contain one before. In the case of
        <span class="Li">&quot;BEGIN&quot;</span>, the subroutine will be
        executed and the reference to it disposed of before this function
        returns, and also before its prototype is set. If a
        <span class="Li">&quot;BEGIN&quot;</span> subroutine would not be
        sufficiently constructed by this function to be ready for execution then
        the caller must prevent this happening by giving the subroutine a
        different name.</p>
    <p class="Pp">The function returns a pointer to the constructed subroutine.
        If the sub is anonymous then ownership of one counted reference to the
        subroutine is transferred to the caller. If the sub is named then the
        caller does not get ownership of a reference. In most such cases, where
        the sub has a non-phase name, the sub will be alive at the point it is
        returned by virtue of being contained in the glob that names it. A
        phase-named subroutine will usually be alive by virtue of the reference
        owned by the phase's automatic run queue. But a
        <span class="Li">&quot;BEGIN&quot;</span> subroutine, having already
        been executed, will quite likely have been destroyed already by the time
        this function returns, making it erroneous for the caller to make any
        use of the returned pointer. It is the caller's responsibility to ensure
        that it knows which of these situations applies.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> CV *  newXS_len_flags(const char *name, STRLEN len,
                       XSUBADDR_t subaddr,
                       const char *const filename,
                       const char *const proto, SV **const_svp,
                       U32 flags)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;optimize_optree&quot;</dt>
  <dd>This function applies some optimisations to the optree in top-down order.
      It is called before the peephole optimizer, which processes ops in
      execution order. Note that <b>finalize_optree()</b> also does a top-down
      scan, but is called *after* the peephole optimizer.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  optimize_optree(OP* o)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;traverse_op_tree&quot;</dt>
  <dd>Return the next op in a depth-first traversal of the op tree, returning
      NULL when the traversal is complete.
    <p class="Pp">The initial call must supply the root of the tree as both top
        and o.</p>
    <p class="Pp">For now it's static, but it may be exposed to the API in the
        future.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> OP*  traverse_op_tree(OP* top, OP* o)
</pre>
</div>
<div class="Bd-indent"></div>
</section>
<section class="Sh">
<h1 class="Sh" id="Pack_and_Unpack"><a class="permalink" href="#Pack_and_Unpack">Pack
  and Unpack</a></h1>
<p class="Pp">There are only public API items currently in Pack and Unpack</p>
</section>
<section class="Sh">
<h1 class="Sh" id="Pad_Data_Structures"><a class="permalink" href="#Pad_Data_Structures">Pad
  Data Structures</a></h1>
<dl class="Bl-tag">
  <dt>&quot;CX_CURPAD_SAVE&quot;</dt>
  <dd>Save the current pad in the given context block structure.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  CX_CURPAD_SAVE(struct context)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;CX_CURPAD_SV&quot;</dt>
  <dd>Access the SV at offset <span class="Li">&quot;po&quot;</span> in the
      saved current pad in the given context block structure (can be used as an
      lvalue).</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> SV *  CX_CURPAD_SV(struct context, PADOFFSET po)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;PAD_BASE_SV&quot;</dt>
  <dd>Get the value from slot <span class="Li">&quot;po&quot;</span> in the base
      (DEPTH=1) pad of a padlist</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> SV *  PAD_BASE_SV(PADLIST padlist, PADOFFSET po)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;PAD_CLONE_VARS&quot;</dt>
  <dd>Clone the state variables associated with running and compiling pads.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  PAD_CLONE_VARS(PerlInterpreter *proto_perl,
                      CLONE_PARAMS* param)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;PAD_COMPNAME_FLAGS&quot;</dt>
  <dd>Return the flags for the current compiling pad name at offset
      <span class="Li">&quot;po&quot;</span>. Assumes a valid slot entry.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> U32  PAD_COMPNAME_FLAGS(PADOFFSET po)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;PAD_COMPNAME_GEN&quot;</dt>
  <dd>The generation number of the name at offset
      <span class="Li">&quot;po&quot;</span> in the current compiling pad
      (lvalue).</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> STRLEN  PAD_COMPNAME_GEN(PADOFFSET po)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;PAD_COMPNAME_GEN_set&quot;</dt>
  <dd>Sets the generation number of the name at offset
      <span class="Li">&quot;po&quot;</span> in the current ling pad (lvalue) to
      <span class="Li">&quot;gen&quot;</span>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> STRLEN  PAD_COMPNAME_GEN_set(PADOFFSET po, int gen)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;PAD_COMPNAME_OURSTASH&quot;</dt>
  <dd>Return the stash associated with an
      <span class="Li">&quot;our&quot;</span> variable. Assumes the slot entry
      is a valid <span class="Li">&quot;our&quot;</span> lexical.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> HV *  PAD_COMPNAME_OURSTASH(PADOFFSET po)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;PAD_COMPNAME_PV&quot;</dt>
  <dd>Return the name of the current compiling pad name at offset
      <span class="Li">&quot;po&quot;</span>. Assumes a valid slot entry.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> char *  PAD_COMPNAME_PV(PADOFFSET po)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;PAD_COMPNAME_TYPE&quot;</dt>
  <dd>Return the type (stash) of the current compiling pad name at offset
      <span class="Li">&quot;po&quot;</span>. Must be a valid name. Returns null
      if not typed.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> HV *  PAD_COMPNAME_TYPE(PADOFFSET po)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;PadnameIsOUR&quot;</dt>
  <dd>Whether this is an &quot;our&quot; variable.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> bool  PadnameIsOUR(PADNAME * pn)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;PadnameIsSTATE&quot;</dt>
  <dd>Whether this is a &quot;state&quot; variable.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> bool  PadnameIsSTATE(PADNAME * pn)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;PadnameOURSTASH&quot;</dt>
  <dd>The stash in which this &quot;our&quot; variable was declared.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> HV *  PadnameOURSTASH(PADNAME * pn)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;PadnameOUTER&quot;</dt>
  <dd>Whether this entry belongs to an outer pad. Entries for which this is true
      are often referred to as 'fake'.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> bool  PadnameOUTER(PADNAME * pn)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;PadnameTYPE&quot;</dt>
  <dd>The stash associated with a typed lexical. This returns the
      <span class="Li">%Foo::</span> hash for <span class="Li">&quot;my Foo
      $bar&quot;</span>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> HV *  PadnameTYPE(PADNAME * pn)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;PAD_RESTORE_LOCAL&quot;</dt>
  <dd>Restore the old pad saved into the local variable
      <span class="Li">&quot;opad&quot;</span> by
      <span class="Li">&quot;PAD_SAVE_LOCAL()&quot;</span></dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  PAD_RESTORE_LOCAL(PAD *opad)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;PAD_SAVE_LOCAL&quot;</dt>
  <dd>Save the current pad to the local variable
      <span class="Li">&quot;opad&quot;</span>, then make the current pad equal
      to <span class="Li">&quot;npad&quot;</span></dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  PAD_SAVE_LOCAL(PAD *opad, PAD *npad)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;PAD_SAVE_SETNULLPAD&quot;</dt>
  <dd>Save the current pad then set it to null.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  PAD_SAVE_SETNULLPAD()
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;PAD_SETSV&quot;</dt>
  <dd>Set the slot at offset <span class="Li">&quot;po&quot;</span> in the
      current pad to <span class="Li">&quot;sv&quot;</span></dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> SV *  PAD_SETSV(PADOFFSET po, SV* sv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;PAD_SET_CUR&quot;</dt>
  <dd>Set the current pad to be pad <span class="Li">&quot;n&quot;</span> in the
      padlist, saving the previous current pad. NB currently this macro expands
      to a string too long for some compilers, so it's best to replace it with
    <p class="Pp"></p>
    <pre>    SAVECOMPPAD();
    PAD_SET_CUR_NOSAVE(padlist,n);
    </pre>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  PAD_SET_CUR(PADLIST padlist, I32 n)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;PAD_SET_CUR_NOSAVE&quot;</dt>
  <dd>like PAD_SET_CUR, but without the save</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  PAD_SET_CUR_NOSAVE(PADLIST padlist, I32 n)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;PAD_SV&quot;</dt>
  <dd>Get the value at offset <span class="Li">&quot;po&quot;</span> in the
      current pad</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> SV *  PAD_SV(PADOFFSET po)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;PAD_SVl&quot;</dt>
  <dd>Lightweight and lvalue version of
      <span class="Li">&quot;PAD_SV&quot;</span>. Get or set the value at offset
      <span class="Li">&quot;po&quot;</span> in the current pad. Unlike
      <span class="Li">&quot;PAD_SV&quot;</span>, does not print diagnostics
      with -DX. For internal use only.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> SV *  PAD_SVl(PADOFFSET po)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;SAVECLEARSV&quot;</dt>
  <dd>Clear the pointed to pad value on scope exit. (i.e. the runtime action of
      <span class="Li">&quot;my&quot;</span>)</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  SAVECLEARSV(SV **svp)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;SAVECOMPPAD&quot;</dt>
  <dd>save <span class="Li">&quot;PL_comppad&quot;</span> and
      <span class="Li">&quot;PL_curpad&quot;</span></dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  SAVECOMPPAD()
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;SAVEPADSV&quot;</dt>
  <dd>Save a pad slot (used to restore after an iteration)</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  SAVEPADSV(PADOFFSET po)
</pre>
</div>
<div class="Bd-indent"></div>
</section>
<section class="Sh">
<h1 class="Sh" id="Password_and_Group_access"><a class="permalink" href="#Password_and_Group_access">Password
  and Group access</a></h1>
<p class="Pp">There are only public API items currently in Password and Group
    access</p>
</section>
<section class="Sh">
<h1 class="Sh" id="Paths_to_system_commands"><a class="permalink" href="#Paths_to_system_commands">Paths
  to system commands</a></h1>
<p class="Pp">There are only public API items currently in Paths to system
    commands</p>
</section>
<section class="Sh">
<h1 class="Sh" id="Prototype_information"><a class="permalink" href="#Prototype_information">Prototype
  information</a></h1>
<p class="Pp">There are only public API items currently in Prototype
  information</p>
</section>
<section class="Sh">
<h1 class="Sh" id="REGEXP_Functions"><a class="permalink" href="#REGEXP_Functions">REGEXP
  Functions</a></h1>
<p class="Pp">There are only public API items currently in REGEXP Functions</p>
</section>
<section class="Sh">
<h1 class="Sh" id="Signals"><a class="permalink" href="#Signals">Signals</a></h1>
<p class="Pp">There are only public API items currently in Signals</p>
</section>
<section class="Sh">
<h1 class="Sh" id="Site_configuration"><a class="permalink" href="#Site_configuration">Site
  configuration</a></h1>
<p class="Pp">There are only public API items currently in Site
  configuration</p>
</section>
<section class="Sh">
<h1 class="Sh" id="Sockets_configuration_values"><a class="permalink" href="#Sockets_configuration_values">Sockets
  configuration values</a></h1>
<p class="Pp">There are only public API items currently in Sockets configuration
    values</p>
</section>
<section class="Sh">
<h1 class="Sh" id="Source_Filters"><a class="permalink" href="#Source_Filters">Source
  Filters</a></h1>
<p class="Pp">There are only public API items currently in Source Filters</p>
</section>
<section class="Sh">
<h1 class="Sh" id="Stack_Manipulation_Macros"><a class="permalink" href="#Stack_Manipulation_Macros">Stack
  Manipulation Macros</a></h1>
<dl class="Bl-tag">
  <dt>&quot;djSP&quot;</dt>
  <dd>Declare Just <span class="Li">&quot;SP&quot;</span>. This is actually
      identical to <span class="Li">&quot;dSP&quot;</span>, and declares a local
      copy of perl's stack pointer, available via the
      <span class="Li">&quot;SP&quot;</span> macro. See
      <span class="Li">&quot;&quot;SP&quot; in perlapi&quot;</span>. (Available
      for backward source code compatibility with the old (Perl 5.005) thread
      model.)</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre>   djSP();
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;LVRET&quot;</dt>
  <dd>True if this op will be the return value of an lvalue subroutine</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="String_Handling"><a class="permalink" href="#String_Handling">String
  Handling</a></h1>
<dl class="Bl-tag">
  <dt>&quot;delimcpy_no_escape&quot;</dt>
  <dd>Copy a source buffer to a destination buffer, stopping at (but not
      including) the first occurrence in the source of the delimiter byte,
      <span class="Li">&quot;delim&quot;</span>. The source is the bytes between
      <span class="Li">&quot;from&quot;</span>&#x00A0;and&#x00A0;<span class="Li">&quot;from_end&quot;</span>&#x00A0;-&#x00A0;1.
      Similarly, the dest is <span class="Li">&quot;to&quot;</span> up to
      <span class="Li">&quot;to_end&quot;</span>.
    <p class="Pp">The number of bytes copied is written to
        <span class="Li">*retlen</span>.</p>
    <p class="Pp">Returns the position of
        <span class="Li">&quot;delim&quot;</span> in the
        <span class="Li">&quot;from&quot;</span> buffer, but if there is no such
        occurrence before <span class="Li">&quot;from_end&quot;</span>, then
        <span class="Li">&quot;from_end&quot;</span> is returned, and the entire
        buffer
        <span class="Li">&quot;from&quot;</span>&#x00A0;..&#x00A0;<span class="Li">&quot;from_end&quot;</span>&#x00A0;-&#x00A0;1
        is copied.</p>
    <p class="Pp">If there is room in the destination available after the copy,
        an extra terminating safety <span class="Li">&quot;NUL&quot;</span> byte
        is appended (not included in the returned length).</p>
    <p class="Pp">The error case is if the destination buffer is not large
        enough to accommodate everything that should be copied. In this
        situation, a value larger than
        <span class="Li">&quot;to_end&quot;</span>&#x00A0;-&#x00A0;<span class="Li">&quot;to&quot;</span>
        is written to <span class="Li">*retlen</span>, and as much of the source
        as fits will be written to the destination. Not having room for the
        safety <span class="Li">&quot;NUL&quot;</span> is not considered an
        error.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> char*  delimcpy_no_escape(char* to, const char* to_end,
                           const char* from, const char* from_end,
                           const int delim, I32* retlen)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;quadmath_format_needed&quot;</dt>
  <dd><span class="Li">&quot;quadmath_format_needed()&quot;</span> returns true
      if the <span class="Li">&quot;format&quot;</span> string seems to contain
      at least one non-Q-prefixed
      <span class="Li">&quot;%[efgaEFGA]&quot;</span> format specifier, or
      returns false otherwise.
    <p class="Pp">The format specifier detection is not complete printf-syntax
        detection, but it should catch most common cases.</p>
    <p class="Pp">If true is returned, those arguments <b>should</b> in theory
        be processed with
        <span class="Li">&quot;quadmath_snprintf()&quot;</span>, but in case
        there is more than one such format specifier (see
        &quot;quadmath_format_valid&quot;), and if there is anything else beyond
        that one (even just a single byte), they <b>cannot</b> be processed
        because <span class="Li">&quot;quadmath_snprintf()&quot;</span> is very
        strict, accepting only one format spec, and nothing else. In this case,
        the code should probably fail.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> bool  quadmath_format_needed(const char* format)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;quadmath_format_valid&quot;</dt>
  <dd><span class="Li">&quot;quadmath_snprintf()&quot;</span> is very strict
      about its <span class="Li">&quot;format&quot;</span> string and will fail,
      returning -1, if the format is invalid. It accepts exactly one format
      spec.
    <p class="Pp"><span class="Li">&quot;quadmath_format_valid()&quot;</span>
        checks that the intended single spec looks sane: begins with
        <span class="Li">&quot;%&quot;</span>, has only one
        <span class="Li">&quot;%&quot;</span>, ends with
        <span class="Li">&quot;[efgaEFGA]&quot;</span>, and has
        <span class="Li">&quot;Q&quot;</span> before it. This is not a full
        &quot;printf syntax check&quot;, just the basics.</p>
    <p class="Pp">Returns true if it is valid, false if not.</p>
    <p class="Pp">See also &quot;quadmath_format_needed&quot;.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> bool  quadmath_format_valid(const char* format)
</pre>
</div>
<div class="Bd-indent"></div>
</section>
<section class="Sh">
<h1 class="Sh" id="SV_Flags"><a class="permalink" href="#SV_Flags">SV
  Flags</a></h1>
<dl class="Bl-tag">
  <dt>&quot;SVt_INVLIST&quot;</dt>
  <dd>Type flag for scalars. See &quot;svtype&quot; in perlapi.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="SV_Handling"><a class="permalink" href="#SV_Handling">SV
  Handling</a></h1>
<dl class="Bl-tag">
  <dt>&quot;PL_Sv&quot;</dt>
  <dd>A scratch pad SV for whatever temporary use you need. Chiefly used as a
      fallback by macros on platforms where
      &quot;PERL_USE_GCC_BRACE_GROUPS&quot; in perlapi&gt; is unavailable, and
      which would otherwise evaluate their SV parameter more than once.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre>   PL_Sv
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;sv_2bool&quot;</dt>
  <dd>This macro is only used by <span class="Li">&quot;sv_true()&quot;</span>
      or its macro equivalent, and only if the latter's argument is neither
      <span class="Li">&quot;SvPOK&quot;</span>,
      <span class="Li">&quot;SvIOK&quot;</span> nor
      <span class="Li">&quot;SvNOK&quot;</span>. It calls
      <span class="Li">&quot;sv_2bool_flags&quot;</span> with the
      <span class="Li">&quot;SV_GMAGIC&quot;</span> flag.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> bool  sv_2bool(SV *const sv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;sv_2bool_flags&quot;</dt>
  <dd>This function is only used by
      <span class="Li">&quot;sv_true()&quot;</span> and friends, and only if the
      latter's argument is neither <span class="Li">&quot;SvPOK&quot;</span>,
      <span class="Li">&quot;SvIOK&quot;</span> nor
      <span class="Li">&quot;SvNOK&quot;</span>. If the flags contain
      <span class="Li">&quot;SV_GMAGIC&quot;</span>, then it does an
      <span class="Li">&quot;mg_get()&quot;</span> first.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> bool  sv_2bool_flags(SV *sv, I32 flags)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;sv_2num&quot;</dt>
  <dd>NOTE: <span class="Li">&quot;sv_2num&quot;</span> is <b>experimental</b>
      and may change or be removed without notice.
    <p class="Pp">Return an SV with the numeric value of the source SV, doing
        any necessary reference or overload conversion. The caller is expected
        to have handled get-magic already.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> SV*  sv_2num(SV *const sv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;sv_2pvbyte_nolen&quot;</dt>
  <dd>Return a pointer to the byte-encoded representation of the SV. May cause
      the SV to be downgraded from UTF-8 as a side-effect.
    <p class="Pp">Usually accessed via the
        <span class="Li">&quot;SvPVbyte_nolen&quot;</span> macro.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> char*  sv_2pvbyte_nolen(SV* sv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;sv_2pvutf8_nolen&quot;</dt>
  <dd>Return a pointer to the UTF-8-encoded representation of the SV. May cause
      the SV to be upgraded to UTF-8 as a side-effect.
    <p class="Pp">Usually accessed via the
        <span class="Li">&quot;SvPVutf8_nolen&quot;</span> macro.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> char*  sv_2pvutf8_nolen(SV* sv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;sv_2pv_flags&quot;</dt>
  <dd>Returns a pointer to the string value of an SV, and sets
      <span class="Li">*lp</span> to its length. If flags has the
      <span class="Li">&quot;SV_GMAGIC&quot;</span> bit set, does an
      <span class="Li">&quot;mg_get()&quot;</span> first. Coerces
      <span class="Li">&quot;sv&quot;</span> to a string if necessary. Normally
      invoked via the <span class="Li">&quot;SvPV_flags&quot;</span> macro.
      <span class="Li">&quot;sv_2pv()&quot;</span> and
      <span class="Li">&quot;sv_2pv_nomg&quot;</span> usually end up here
    too.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> char*  sv_2pv_flags(SV *const sv, STRLEN *const lp,
                     const U32 flags)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;sv_2pv_nolen&quot;</dt>
  <dd>Like <span class="Li">&quot;sv_2pv()&quot;</span>, but doesn't return the
      length too. You should usually use the macro wrapper
      <span class="Li">&quot;SvPV_nolen(sv)&quot;</span> instead.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> char*  sv_2pv_nolen(SV* sv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;sv_add_arena&quot;</dt>
  <dd>Given a chunk of memory, link it to the head of the list of arenas, and
      split it into a list of free SVs.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  sv_add_arena(char *const ptr, const U32 size,
                    const U32 flags)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;sv_clean_all&quot;</dt>
  <dd>Decrement the refcnt of each remaining SV, possibly triggering a cleanup.
      This function may have to be called multiple times to free SVs which are
      in complex self-referential hierarchies.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> I32  sv_clean_all()
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;sv_clean_objs&quot;</dt>
  <dd>Attempt to destroy all objects not yet freed.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  sv_clean_objs()
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;sv_free_arenas&quot;</dt>
  <dd>Deallocate the memory used by all arenas. Note that all the individual SV
      heads and bodies within the arenas must already have been freed.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  sv_free_arenas()
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;sv_grow&quot;</dt>
  <dd>Expands the character buffer in the SV. If necessary, uses
      <span class="Li">&quot;sv_unref&quot;</span> and upgrades the SV to
      <span class="Li">&quot;SVt_PV&quot;</span>. Returns a pointer to the
      character buffer. Use the <span class="Li">&quot;SvGROW&quot;</span>
      wrapper instead.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> char*  sv_grow(SV *const sv, STRLEN newlen)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;sv_iv&quot;</dt>
  <dd><span class="Li">&quot;</span><span class="Li"><b>DEPRECATED!</b></span><span class="Li">&quot;</span>
      It is planned to remove <span class="Li">&quot;sv_iv&quot;</span> from a
      future release of Perl. Do not use it for new code; remove it from
      existing code.
    <p class="Pp">A private implementation of the
        <span class="Li">&quot;SvIVx&quot;</span> macro for compilers which
        can't cope with complex macro expressions. Always use the macro
      instead.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> IV  sv_iv(SV* sv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;sv_newref&quot;</dt>
  <dd>Increment an SV's reference count. Use the
      <span class="Li">&quot;SvREFCNT_inc()&quot;</span> wrapper instead.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> SV*  sv_newref(SV *const sv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;sv_nv&quot;</dt>
  <dd><span class="Li">&quot;</span><span class="Li"><b>DEPRECATED!</b></span><span class="Li">&quot;</span>
      It is planned to remove <span class="Li">&quot;sv_nv&quot;</span> from a
      future release of Perl. Do not use it for new code; remove it from
      existing code.
    <p class="Pp">A private implementation of the
        <span class="Li">&quot;SvNVx&quot;</span> macro for compilers which
        can't cope with complex macro expressions. Always use the macro
      instead.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> NV  sv_nv(SV* sv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;sv_pv&quot;</dt>
  <dd>Use the <span class="Li">&quot;SvPV_nolen&quot;</span> macro instead</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> char*  sv_pv(SV *sv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;sv_pvbyte&quot;</dt>
  <dd>Use <span class="Li">&quot;SvPVbyte_nolen&quot;</span> instead.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> char*  sv_pvbyte(SV *sv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;sv_pvbyten&quot;</dt>
  <dd><span class="Li">&quot;</span><span class="Li"><b>DEPRECATED!</b></span><span class="Li">&quot;</span>
      It is planned to remove <span class="Li">&quot;sv_pvbyten&quot;</span>
      from a future release of Perl. Do not use it for new code; remove it from
      existing code.
    <p class="Pp">A private implementation of the
        <span class="Li">&quot;SvPVbyte&quot;</span> macro for compilers which
        can't cope with complex macro expressions. Always use the macro
      instead.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> char*  sv_pvbyten(SV *sv, STRLEN *lp)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;sv_pvbyten_force&quot;</dt>
  <dd>The backend for the <span class="Li">&quot;SvPVbytex_force&quot;</span>
      macro. Always use the macro instead. If the SV cannot be downgraded from
      UTF-8, this croaks.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> char*  sv_pvbyten_force(SV *const sv, STRLEN *const lp)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;sv_pvn&quot;</dt>
  <dd><span class="Li">&quot;</span><span class="Li"><b>DEPRECATED!</b></span><span class="Li">&quot;</span>
      It is planned to remove <span class="Li">&quot;sv_pvn&quot;</span> from a
      future release of Perl. Do not use it for new code; remove it from
      existing code.
    <p class="Pp">A private implementation of the
        <span class="Li">&quot;SvPV&quot;</span> macro for compilers which can't
        cope with complex macro expressions. Always use the macro instead.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> char*  sv_pvn(SV *sv, STRLEN *lp)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;sv_pvn_force&quot;</dt>
  <dd>Get a sensible string out of the SV somehow. A private implementation of
      the <span class="Li">&quot;SvPV_force&quot;</span> macro for compilers
      which can't cope with complex macro expressions. Always use the macro
      instead.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> char*  sv_pvn_force(SV* sv, STRLEN* lp)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;sv_pvutf8&quot;</dt>
  <dd>Use the <span class="Li">&quot;SvPVutf8_nolen&quot;</span> macro
    instead</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> char*  sv_pvutf8(SV *sv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;sv_pvutf8n&quot;</dt>
  <dd><span class="Li">&quot;</span><span class="Li"><b>DEPRECATED!</b></span><span class="Li">&quot;</span>
      It is planned to remove <span class="Li">&quot;sv_pvutf8n&quot;</span>
      from a future release of Perl. Do not use it for new code; remove it from
      existing code.
    <p class="Pp">A private implementation of the
        <span class="Li">&quot;SvPVutf8&quot;</span> macro for compilers which
        can't cope with complex macro expressions. Always use the macro
      instead.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> char*  sv_pvutf8n(SV *sv, STRLEN *lp)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;sv_pvutf8n_force&quot;</dt>
  <dd>The backend for the <span class="Li">&quot;SvPVutf8x_force&quot;</span>
      macro. Always use the macro instead.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> char*  sv_pvutf8n_force(SV *const sv, STRLEN *const lp)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;sv_taint&quot;</dt>
  <dd>Taint an SV. Use <span class="Li">&quot;SvTAINTED_on&quot;</span>
    instead.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  sv_taint(SV* sv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;sv_tainted&quot;</dt>
  <dd>Test an SV for taintedness. Use
      <span class="Li">&quot;SvTAINTED&quot;</span> instead.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> bool  sv_tainted(SV *const sv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;SvTHINKFIRST&quot;</dt>
  <dd>A quick flag check to see whether an
      <span class="Li">&quot;sv&quot;</span> should be passed to
      <span class="Li">&quot;sv_force_normal&quot;</span> to be
      &quot;downgraded&quot; before <span class="Li">&quot;SvIVX&quot;</span> or
      <span class="Li">&quot;SvPVX&quot;</span> can be modified directly.
    <p class="Pp">For example, if your scalar is a reference and you want to
        modify the <span class="Li">&quot;SvIVX&quot;</span> slot, you can't
        just do <span class="Li">&quot;SvROK_off&quot;</span>, as that will leak
        the referent.</p>
    <p class="Pp">This is used internally by various sv-modifying functions,
        such as <span class="Li">&quot;sv_setsv&quot;</span>,
        <span class="Li">&quot;sv_setiv&quot;</span> and
        <span class="Li">&quot;sv_pvn_force&quot;</span>.</p>
    <p class="Pp">One case that this does not handle is a gv without SvFAKE set.
        After</p>
    <p class="Pp"></p>
    <pre>    if (SvTHINKFIRST(gv)) sv_force_normal(gv);
    </pre>
    <p class="Pp">it will still be a gv.</p>
    <p class="Pp"><span class="Li">&quot;SvTHINKFIRST&quot;</span> sometimes
        produces false positives. In those cases
        <span class="Li">&quot;sv_force_normal&quot;</span> does nothing.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> U32  SvTHINKFIRST(SV *sv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;sv_true&quot;</dt>
  <dd>Returns true if the SV has a true value by Perl's rules. Use the
      <span class="Li">&quot;SvTRUE&quot;</span> macro instead, which may call
      <span class="Li">&quot;sv_true()&quot;</span> or may instead use an
      in-line version.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> I32  sv_true(SV *const sv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;sv_untaint&quot;</dt>
  <dd>Untaint an SV. Use <span class="Li">&quot;SvTAINTED_off&quot;</span>
      instead.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  sv_untaint(SV *const sv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;sv_uv&quot;</dt>
  <dd><span class="Li">&quot;</span><span class="Li"><b>DEPRECATED!</b></span><span class="Li">&quot;</span>
      It is planned to remove <span class="Li">&quot;sv_uv&quot;</span> from a
      future release of Perl. Do not use it for new code; remove it from
      existing code.
    <p class="Pp">A private implementation of the
        <span class="Li">&quot;SvUVx&quot;</span> macro for compilers which
        can't cope with complex macro expressions. Always use the macro
      instead.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> UV  sv_uv(SV* sv)
</pre>
</div>
<div class="Bd-indent"></div>
</section>
<section class="Sh">
<h1 class="Sh" id="Time"><a class="permalink" href="#Time">Time</a></h1>
<p class="Pp">There are only public API items currently in Time</p>
</section>
<section class="Sh">
<h1 class="Sh" id="Typedef_names"><a class="permalink" href="#Typedef_names">Typedef
  names</a></h1>
<p class="Pp">There are only public API items currently in Typedef names</p>
</section>
<section class="Sh">
<h1 class="Sh" id="Unicode_Support"><a class="permalink" href="#Unicode_Support">Unicode
  Support</a></h1>
<dl class="Bl-tag">
  <dt>&quot;bytes_from_utf8_loc&quot;</dt>
  <dd>NOTE: <span class="Li">&quot;bytes_from_utf8_loc&quot;</span> is
      <b>experimental</b> and may change or be removed without notice.
    <p class="Pp">Like <span class="Li">&quot;&quot;bytes_from_utf8&quot; in
        perlapi()&quot;</span>, but takes an extra parameter, a pointer to where
        to store the location of the first character in
        <span class="Li">&quot;s&quot;</span> that cannot be converted to
        non-UTF8.</p>
    <p class="Pp">If that parameter is <span class="Li">&quot;NULL&quot;</span>,
        this function behaves identically to
        <span class="Li">&quot;bytes_from_utf8&quot;</span>.</p>
    <p class="Pp">Otherwise if <span class="Li">*is_utf8p</span> is 0 on input,
        the function behaves identically to
        <span class="Li">&quot;bytes_from_utf8&quot;</span>, except it also sets
        <span class="Li">*first_non_downgradable</span> to
        <span class="Li">&quot;NULL&quot;</span>.</p>
    <p class="Pp">Otherwise, the function returns a newly created
        <span class="Li">&quot;NUL&quot;</span>-terminated string containing the
        non-UTF8 equivalent of the convertible first portion of
        <span class="Li">&quot;s&quot;</span>. <span class="Li">*lenp</span> is
        set to its length, not including the terminating
        <span class="Li">&quot;NUL&quot;</span>. If the entire input string was
        converted, <span class="Li">*is_utf8p</span> is set to a FALSE value,
        and <span class="Li">*first_non_downgradable</span> is set to
        <span class="Li">&quot;NULL&quot;</span>.</p>
    <p class="Pp">Otherwise, <span class="Li">*first_non_downgradable</span> is
        set to point to the first byte of the first character in the original
        string that wasn't converted. <span class="Li">*is_utf8p</span> is
        unchanged. Note that the new string may have length 0.</p>
    <p class="Pp">Another way to look at it is, if
        <span class="Li">*first_non_downgradable</span> is
        non-<span class="Li">&quot;NULL&quot;</span> and
        <span class="Li">*is_utf8p</span> is TRUE, this function starts at the
        beginning of <span class="Li">&quot;s&quot;</span> and converts as many
        characters in it as possible stopping at the first one it finds that
        can't be converted to non-UTF-8.
        <span class="Li">*first_non_downgradable</span> is set to point to that.
        The function returns the portion that could be converted in a newly
        created <span class="Li">&quot;NUL&quot;</span>-terminated string, and
        <span class="Li">*lenp</span> is set to its length, not including the
        terminating <span class="Li">&quot;NUL&quot;</span>. If the very first
        character in the original could not be converted,
        <span class="Li">*lenp</span> will be 0, and the new string will contain
        just a single <span class="Li">&quot;NUL&quot;</span>. If the entire
        input string was converted, <span class="Li">*is_utf8p</span> is set to
        FALSE and <span class="Li">*first_non_downgradable</span> is set to
        <span class="Li">&quot;NULL&quot;</span>.</p>
    <p class="Pp">Upon successful return, the number of variants in the
        converted portion of the string can be computed by having saved the
        value of <span class="Li">*lenp</span> before the call, and subtracting
        the after-call value of <span class="Li">*lenp</span> from it.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> U8*  bytes_from_utf8_loc(const U8 *s, STRLEN *lenp,
                          bool *is_utf8p,
                          const U8 ** first_unconverted)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;find_uninit_var&quot;</dt>
  <dd>NOTE: <span class="Li">&quot;find_uninit_var&quot;</span> is
      <b>experimental</b> and may change or be removed without notice.
    <p class="Pp">Find the name of the undefined variable (if any) that caused
        the operator to issue a &quot;Use of uninitialized value&quot; warning.
        If match is true, only return a name if its value matches
        <span class="Li">&quot;uninit_sv&quot;</span>. So roughly speaking, if a
        unary operator (such as <span class="Li">&quot;OP_COS&quot;</span>)
        generates a warning, then following the direct child of the op may yield
        an <span class="Li">&quot;OP_PADSV&quot;</span> or
        <span class="Li">&quot;OP_GV&quot;</span> that gives the name of the
        undefined variable. On the other hand, with
        <span class="Li">&quot;OP_ADD&quot;</span> there are two branches to
        follow, so we only print the variable name if we get an exact match.
        <span class="Li">&quot;desc_p&quot;</span> points to a string pointer
        holding the description of the op. This may be updated if needed.</p>
    <p class="Pp">The name is returned as a mortal SV.</p>
    <p class="Pp">Assumes that <span class="Li">&quot;PL_op&quot;</span> is the
        OP that originally triggered the error, and that
        <span class="Li">&quot;PL_comppad&quot;</span>/<span class="Li">&quot;PL_curpad&quot;</span>
        points to the currently executing pad.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> SV*  find_uninit_var(const OP *const obase,
                      const SV *const uninit_sv, bool match,
                      const char **desc_p)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;isSCRIPT_RUN&quot;</dt>
  <dd>Returns a bool as to whether or not the sequence of bytes from
      <span class="Li">&quot;s&quot;</span> up to but not including
      <span class="Li">&quot;send&quot;</span> form a &quot;script run&quot;.
      <span class="Li">&quot;utf8_target&quot;</span> is TRUE iff the sequence
      starting at <span class="Li">&quot;s&quot;</span> is to be treated as
      UTF-8. To be precise, except for two degenerate cases given below, this
      function returns TRUE iff all code points in it come from any combination
      of three &quot;scripts&quot; given by the Unicode &quot;Script
      Extensions&quot; property: Common, Inherited, and possibly one other.
      Additionally all decimal digits must come from the same consecutive
      sequence of 10.
    <p class="Pp">For example, if all the characters in the sequence are Greek,
        or Common, or Inherited, this function will return TRUE, provided any
        decimal digits in it are from the same block of digits in Common. (These
        are the ASCII digits &quot;0&quot;..&quot;9&quot; and additionally a
        block for full width forms of these, and several others used in
        mathematical notation.) For scripts (unlike Greek) that have their own
        digits defined this will accept either digits from that set or from one
        of the Common digit sets, but not a combination of the two. Some
        scripts, such as Arabic, have more than one set of digits. All digits
        must come from the same set for this function to return TRUE.</p>
    <p class="Pp"><span class="Li">*ret_script</span>, if
        <span class="Li">&quot;ret_script&quot;</span> is not NULL, will on
        return of TRUE contain the script found, using the
        <span class="Li">&quot;SCX_enum&quot;</span> typedef. Its value will be
        <span class="Li">&quot;SCX_INVALID&quot;</span> if the function returns
        FALSE.</p>
    <p class="Pp">If the sequence is empty, TRUE is returned, but
        <span class="Li">*ret_script</span> (if asked for) will be
        <span class="Li">&quot;SCX_INVALID&quot;</span>.</p>
    <p class="Pp">If the sequence contains a single code point which is
        unassigned to a character in the version of Unicode being used, the
        function will return TRUE, and the script will be
        <span class="Li">&quot;SCX_Unknown&quot;</span>. Any other combination
        of unassigned code points in the input sequence will result in the
        function treating the input as not being a script run.</p>
    <p class="Pp">The returned script will be
        <span class="Li">&quot;SCX_Inherited&quot;</span> iff all the code
        points in it are from the Inherited script.</p>
    <p class="Pp">Otherwise, the returned script will be
        <span class="Li">&quot;SCX_Common&quot;</span> iff all the code points
        in it are from the Inherited or Common scripts.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> bool  isSCRIPT_RUN(const U8 *s, const U8 *send,
                    const bool utf8_target)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;is_utf8_non_invariant_string&quot;</dt>
  <dd>Returns TRUE if &quot;is_utf8_invariant_string&quot; in perlapi returns
      FALSE for the first <span class="Li">&quot;len&quot;</span> bytes of the
      string <span class="Li">&quot;s&quot;</span>, but they are, nonetheless,
      legal Perl-extended UTF-8; otherwise returns FALSE.
    <p class="Pp">A TRUE return means that at least one code point represented
        by the sequence either is a wide character not representable as a single
        byte, or the representation differs depending on whether the sequence is
        encoded in UTF-8 or not.</p>
    <p class="Pp">See also
        <span class="Li">&quot;&quot;is_utf8_invariant_string&quot; in
        perlapi&quot;</span>, <span class="Li">&quot;&quot;is_utf8_string&quot;
        in perlapi&quot;</span></p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> bool  is_utf8_non_invariant_string(const U8* const s, STRLEN len)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;report_uninit&quot;</dt>
  <dd>Print appropriate &quot;Use of uninitialized variable&quot; warning.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> void  report_uninit(const SV *uninit_sv)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;utf8n_to_uvuni&quot;</dt>
  <dd><span class="Li">&quot;</span><span class="Li"><b>DEPRECATED!</b></span><span class="Li">&quot;</span>
      It is planned to remove <span class="Li">&quot;utf8n_to_uvuni&quot;</span>
      from a future release of Perl. Do not use it for new code; remove it from
      existing code.
    <p class="Pp">Instead use &quot;utf8_to_uvchr_buf&quot; in perlapi, or
        rarely, &quot;utf8n_to_uvchr&quot; in perlapi.</p>
    <p class="Pp">This function was useful for code that wanted to handle both
        EBCDIC and ASCII platforms with Unicode properties, but starting in Perl
        v5.20, the distinctions between the platforms have mostly been made
        invisible to most code, so this function is quite unlikely to be what
        you want. If you do need this precise functionality, use instead
        <span class="Li">&quot;NATIVE_TO_UNI(utf8_to_uvchr_buf(...))&quot;</span>
        or
        <span class="Li">&quot;NATIVE_TO_UNI(utf8n_to_uvchr(...))&quot;</span>.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> UV  utf8n_to_uvuni(const U8 *s, STRLEN curlen, STRLEN *retlen,
                    U32 flags)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;utf8_to_uvuni&quot;</dt>
  <dd><span class="Li">&quot;</span><span class="Li"><b>DEPRECATED!</b></span><span class="Li">&quot;</span>
      It is planned to remove <span class="Li">&quot;utf8_to_uvuni&quot;</span>
      from a future release of Perl. Do not use it for new code; remove it from
      existing code.
    <p class="Pp">Returns the Unicode code point of the first character in the
        string <span class="Li">&quot;s&quot;</span> which is assumed to be in
        UTF-8 encoding; <span class="Li">&quot;retlen&quot;</span> will be set
        to the length, in bytes, of that character.</p>
    <p class="Pp">Some, but not all, UTF-8 malformations are detected, and in
        fact, some malformed input could cause reading beyond the end of the
        input buffer, which is one reason why this function is deprecated. The
        other is that only in extremely limited circumstances should the Unicode
        versus native code point be of any interest to you. See
        &quot;utf8_to_uvuni_buf&quot; for alternatives.</p>
    <p class="Pp">If <span class="Li">&quot;s&quot;</span> points to one of the
        detected malformations, and UTF8 warnings are enabled, zero is returned
        and <span class="Li">*retlen</span> is set (if
        <span class="Li">&quot;retlen&quot;</span> doesn't point to NULL) to -1.
        If those warnings are off, the computed value if well-defined (or the
        Unicode REPLACEMENT CHARACTER, if not) is silently returned, and
        <span class="Li">*retlen</span> is set (if
        <span class="Li">&quot;retlen&quot;</span> isn't NULL) so that
        (<span class="Li">&quot;s&quot;</span>&#x00A0;+&#x00A0;<span class="Li">*retlen</span>)
        is the next possible position in <span class="Li">&quot;s&quot;</span>
        that could begin a non-malformed character. See
        &quot;utf8n_to_uvchr&quot; in perlapi for details on when the
        REPLACEMENT CHARACTER is returned.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> UV  utf8_to_uvuni(const U8 *s, STRLEN *retlen)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;utf8_to_uvuni_buf&quot;</dt>
  <dd><span class="Li">&quot;</span><span class="Li"><b>DEPRECATED!</b></span><span class="Li">&quot;</span>
      It is planned to remove
      <span class="Li">&quot;utf8_to_uvuni_buf&quot;</span> from a future
      release of Perl. Do not use it for new code; remove it from existing code.
    <p class="Pp">Only in very rare circumstances should code need to be dealing
        in Unicode (as opposed to native) code points. In those few cases, use
        <span class="Li">&quot;NATIVE_TO_UNI(utf8_to_uvchr_buf(...))&quot;</span>
        instead. If you are not absolutely sure this is one of those cases, then
        assume it isn't and use plain
        <span class="Li">&quot;utf8_to_uvchr_buf&quot;</span> instead.</p>
    <p class="Pp">Returns the Unicode (not-native) code point of the first
        character in the string <span class="Li">&quot;s&quot;</span> which is
        assumed to be in UTF-8 encoding;
        <span class="Li">&quot;send&quot;</span> points to 1 beyond the end of
        <span class="Li">&quot;s&quot;</span>.
        <span class="Li">&quot;retlen&quot;</span> will be set to the length, in
        bytes, of that character.</p>
    <p class="Pp">If <span class="Li">&quot;s&quot;</span> does not point to a
        well-formed UTF-8 character and UTF8 warnings are enabled, zero is
        returned and <span class="Li">*retlen</span> is set (if
        <span class="Li">&quot;retlen&quot;</span> isn't NULL) to -1. If those
        warnings are off, the computed value if well-defined (or the Unicode
        REPLACEMENT CHARACTER, if not) is silently returned, and
        <span class="Li">*retlen</span> is set (if
        <span class="Li">&quot;retlen&quot;</span> isn't NULL) so that
        (<span class="Li">&quot;s&quot;</span>&#x00A0;+&#x00A0;<span class="Li">*retlen</span>)
        is the next possible position in <span class="Li">&quot;s&quot;</span>
        that could begin a non-malformed character. See
        &quot;utf8n_to_uvchr&quot; in perlapi for details on when the
        REPLACEMENT CHARACTER is returned.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> UV  utf8_to_uvuni_buf(const U8 *s, const U8 *send, STRLEN *retlen)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;uvoffuni_to_utf8_flags&quot;</dt>
  <dd>THIS FUNCTION SHOULD BE USED IN ONLY VERY SPECIALIZED CIRCUMSTANCES.
      Instead, <b>Almost all code should use &quot;uvchr_to_utf8&quot; in
      perlapi or</b> <b>&quot;uvchr_to_utf8_flags&quot; in perlapi</b>.
    <p class="Pp">This function is like them, but the input is a strict Unicode
        (as opposed to native) code point. Only in very rare circumstances
        should code not be using the native code point.</p>
    <p class="Pp">For details, see the description for
        &quot;uvchr_to_utf8_flags&quot; in perlapi.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> U8*  uvoffuni_to_utf8_flags(U8 *d, UV uv, const UV flags)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;uvuni_to_utf8_flags&quot;</dt>
  <dd><span class="Li">&quot;</span><span class="Li"><b>DEPRECATED!</b></span><span class="Li">&quot;</span>
      It is planned to remove
      <span class="Li">&quot;uvuni_to_utf8_flags&quot;</span> from a future
      release of Perl. Do not use it for new code; remove it from existing code.
    <p class="Pp">Instead you almost certainly want to use
        &quot;uvchr_to_utf8&quot; in perlapi or &quot;uvchr_to_utf8_flags&quot;
        in perlapi.</p>
    <p class="Pp">This function is a deprecated synonym for
        &quot;uvoffuni_to_utf8_flags&quot;, which itself, while not deprecated,
        should be used only in isolated circumstances. These functions were
        useful for code that wanted to handle both EBCDIC and ASCII platforms
        with Unicode properties, but starting in Perl v5.20, the distinctions
        between the platforms have mostly been made invisible to most code, so
        this function is quite unlikely to be what you want.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> U8*  uvuni_to_utf8_flags(U8 *d, UV uv, UV flags)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;valid_utf8_to_uvchr&quot;</dt>
  <dd>Like <span class="Li">&quot;&quot;utf8_to_uvchr_buf&quot; in
      perlapi&quot;</span>, but should only be called when it is known that the
      next character in the input UTF-8 string
      <span class="Li">&quot;s&quot;</span> is well-formed (<i>e.g.</i>, it
      passes <span class="Li">&quot;&quot;isUTF8_CHAR&quot; in
      perlapi&quot;</span>. Surrogates, non-character code points, and
      non-Unicode code points are allowed.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> UV  valid_utf8_to_uvchr(const U8 *s, STRLEN *retlen)
</pre>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;variant_under_utf8_count&quot;</dt>
  <dd>This function looks at the sequence of bytes between
      <span class="Li">&quot;s&quot;</span> and
      <span class="Li">&quot;e&quot;</span>, which are assumed to be encoded in
      ASCII/Latin1, and returns how many of them would change should the string
      be translated into UTF-8. Due to the nature of UTF-8, each of these would
      occupy two bytes instead of the single one in the input string. Thus, this
      function returns the precise number of bytes the string would expand by
      when translated to UTF-8.
    <p class="Pp">Unlike most of the other functions that have
        <span class="Li">&quot;utf8&quot;</span> in their name, the input to
        this function is NOT a UTF-8-encoded string. The function name is
        slightly <i>odd</i> to emphasize this.</p>
    <p class="Pp">This function is internal to Perl because khw thinks that any
        XS code that would want this is probably operating too close to the
        internals. Presenting a valid use case could change that.</p>
    <p class="Pp">See also
        <span class="Li">&quot;&quot;is_utf8_invariant_string&quot; in
        perlapi&quot;</span> and
        <span class="Li">&quot;&quot;is_utf8_invariant_string_loc&quot; in
        perlapi&quot;</span>,</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> Size_t  variant_under_utf8_count(const U8* const s,
                                  const U8* const e)
</pre>
</div>
<div class="Bd-indent"></div>
</section>
<section class="Sh">
<h1 class="Sh" id="Utility_Functions"><a class="permalink" href="#Utility_Functions">Utility
  Functions</a></h1>
<p class="Pp">There are only public API items currently in Utility Functions</p>
</section>
<section class="Sh">
<h1 class="Sh" id="Versioning"><a class="permalink" href="#Versioning">Versioning</a></h1>
<p class="Pp">There are only public API items currently in Versioning</p>
</section>
<section class="Sh">
<h1 class="Sh" id="Warning_and_Dieing"><a class="permalink" href="#Warning_and_Dieing">Warning
  and Dieing</a></h1>
<dl class="Bl-tag">
  <dt>&quot;PL_dowarn&quot;</dt>
  <dd>The C variable that roughly corresponds to Perl's
      <span class="Li">$^W</span> warning variable. However,
      <span class="Li">$^W</span> is treated as a boolean, whereas
      <span class="Li">&quot;PL_dowarn&quot;</span> is a collection of flag
      bits.
    <p class="Pp">On threaded perls, each thread has an independent copy of this
        variable; each initialized at creation time with the current value of
        the creating thread's copy.</p>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<pre> U8  PL_dowarn
</pre>
</div>
<div class="Bd-indent"></div>
</section>
<section class="Sh">
<h1 class="Sh" id="XS"><a class="permalink" href="#XS">XS</a></h1>
<p class="Pp">There are only public API items currently in XS</p>
</section>
<section class="Sh">
<h1 class="Sh" id="Undocumented_elements"><a class="permalink" href="#Undocumented_elements">Undocumented
  elements</a></h1>
<p class="Pp">The following functions are currently undocumented. If you use one
    of them, you may wish to consider creating and submitting documentation for
    it.</p>
<p class="Pp"></p>
<p class="Pp"></p>
<pre> abort_execution
 add_cp_to_invlist
 _add_range_to_invlist
 alloc_LOGOP
 allocmy
 amagic_cmp
 amagic_cmp_desc
 amagic_cmp_locale
 amagic_cmp_locale_desc
 amagic_is_enabled
 amagic_i_ncmp
 amagic_i_ncmp_desc
 amagic_ncmp
 amagic_ncmp_desc
 append_utf8_from_native_byte
 apply
 ASCII_TO_NEED
 av_arylen_p
 av_extend_guts
 av_iter_p
 av_nonelem
 av_reify
 bind_match
 boot_core_mro
 boot_core_PerlIO
 boot_core_UNIVERSAL
 _byte_dump_string
 cando
 cast_i32
 cast_iv
 cast_ulong
 cast_uv
 check_utf8_print
 ck_anoncode
 ck_backtick
 ck_bitop
 ck_cmp
 ck_concat
 ck_defined
 ck_delete
 ck_each
 ck_entersub_args_core
 ck_eof
 ck_eval
 ck_exec
 ck_exists
 ck_ftst
 ck_fun
 ck_glob
 ck_grep
 ck_index
 ck_isa
 ck_join
 ck_length
 ck_lfun
 ck_listiob
 ck_match
 ck_method
 ck_null
 ck_open
 ck_prototype
 ck_readline
 ck_refassign
 ck_repeat
 ck_require
 ck_return
 ck_rfun
 ck_rvconst
 ck_sassign
 ck_select
 ck_shift
 ck_smartmatch
 ck_sort
 ck_spair
 ck_split
 ck_stringify
 ck_subr
 ck_substr
 ck_svconst
 ck_tell
 ck_trunc
 ck_trycatch
 ckwarn
 ckwarn_d
 closest_cop
 cmpchain_extend
 cmpchain_finish
 cmpchain_start
 cmp_desc
 cmp_locale_desc
 cntrl_to_mnemonic
 coresub_op
 create_eval_scope
 croak_caller
 croak_memory_wrap
 croak_no_mem
 croak_popstack
 csighandler
 csighandler1
 csighandler3
 current_re_engine
 custom_op_get_field
 cv_ckproto_len_flags
 cv_clone_into
 cv_const_sv_or_av
 cvgv_from_hek
 cvgv_set
 cvstash_set
 cv_undef_flags
 cx_dump
 cx_dup
 cxinc
 cx_popblock
 cx_popeval
 cx_popformat
 cx_popgiven
 cx_poploop
 cx_popsub
 cx_popsub_args
 cx_popsub_common
 cx_popwhen
 cx_pushblock
 cx_pusheval
 cx_pushformat
 cx_pushgiven
 cx_pushloop_for
 cx_pushloop_plain
 cx_pushsub
 cx_pushtry
 cx_pushwhen
 cx_topblock
 deb_stack_all
 defelem_target
 delete_eval_scope
 despatch_signals
 die_unwind
 do_aexec
 do_aexec5
 do_eof
 does_utf8_overflow
 do_exec
 do_exec3
 dofile
 do_gvgv_dump
 do_gv_dump
 do_hv_dump
 doing_taint
 do_ipcctl
 do_ipcget
 do_magic_dump
 do_msgrcv
 do_msgsnd
 do_ncmp
 do_open6
 do_open_raw
 do_op_dump
 do_pmop_dump
 do_print
 do_readline
 do_seek
 do_semop
 do_shmio
 do_sv_dump
 do_sysseek
 do_tell
 do_trans
 do_uniprop_match
 do_vecget
 do_vecset
 do_vop
 drand48_init_r
 drand48_r
 dtrace_probe_call
 dtrace_probe_load
 dtrace_probe_op
 dtrace_probe_phase
 dump_all_perl
 dump_indent
 dump_packsubs_perl
 dump_sub_perl
 dump_sv_child
 dump_vindent
 dup_warnings
 emulate_cop_io
 find_first_differing_byte_pos
 find_lexical_cv
 find_runcv_where
 find_script
 foldEQ_latin1
 foldEQ_latin1_s2_folded
 foldEQ_utf8_flags
 _force_out_malformed_utf8_message
 form_alien_digit_msg
 form_cp_too_large_msg
 free_tied_hv_pool
 free_tmps
 get_and_check_backslash_N_name
 get_db_sub
 get_debug_opts
 get_deprecated_property_msg
 getenv_len
 get_hash_seed
 get_invlist_iter_addr
 get_invlist_offset_addr
 get_invlist_previous_index_addr
 get_no_modify
 get_opargs
 get_prop_definition
 get_prop_values
 get_regclass_nonbitmap_data
 get_regex_charset_name
 get_re_arg
 get_re_gclass_nonbitmap_data
 gimme_V
 grok_bin_oct_hex
 grok_bslash_c
 grok_bslash_o
 grok_bslash_x
 gv_check
 gv_fetchmeth_internal
 gv_override
 gv_setref
 gv_stashpvn_internal
 hfree_next_entry
 hv_backreferences_p
 hv_common
 hv_common_key_len
 hv_kill_backrefs
 hv_placeholders_p
 hv_pushkv
 hv_undef_flags
 init_argv_symbols
 init_constants
 init_dbargs
 init_debugger
 init_i18nl10n
 init_i18nl14n
 init_named_cv
 init_uniprops
 _inverse_folds
 invert
 invlist_array
 invlist_clear
 invlist_clone
 invlist_contents
 _invlistEQ
 invlist_extend
 invlist_highest
 invlist_is_iterating
 invlist_iterfinish
 invlist_iterinit
 invlist_iternext
 invlist_lowest
 invlist_max
 invlist_previous_index
 invlist_set_len
 invlist_set_previous_index
 invlist_trim
 _invlist_array_init
 _invlist_contains_cp
 _invlist_dump
 _invlist_intersection
 _invlist_intersection_maybe_complement_2nd
 _invlist_invert
 _invlist_len
 _invlist_search
 _invlist_subtract
 _invlist_union
 _invlist_union_maybe_complement_2nd
 invmap_dump
 io_close
 isFF_OVERLONG
 is_grapheme
 is_invlist
 is_utf8_char_helper
 is_utf8_common
 is_utf8_overlong_given_start_byte_ok
 _is_cur_LC_category_utf8
 _is_in_locale_category
 _is_uni_FOO
 _is_uni_perl_idcont
 _is_uni_perl_idstart
 _is_utf8_FOO
 _is_utf8_perl_idcont
 _is_utf8_perl_idstart
 jmaybe
 keyword
 keyword_plugin_standard
 list
 load_charnames
 localize
 lossless_NV_to_IV
 magic_cleararylen_p
 magic_clearenv
 magic_clearisa
 magic_clearpack
 magic_clearsig
 magic_clear_all_env
 magic_copycallchecker
 magic_existspack
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHORS"><a class="permalink" href="#AUTHORS">AUTHORS</a></h1>
<p class="Pp">The autodocumentation system was originally added to the Perl core
    by Benjamin Stuhl. Documentation is by whoever was kind enough to document
    their functions.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp"><i>config.h</i>, perlapi, perlapio, perlcall, perlclib,
    perlfilter, perlguts, perlinterp, perliol, perlmroapi, perlreguts,
  perlxs</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2022-05-21</td>
    <td class="foot-os">perl v5.34.0</td>
  </tr>
</table>
</body>
</html>
