<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.10 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>PERLHACKTUT(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">PERLHACKTUT(1)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">PERLHACKTUT(1)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
perlhacktut - Walk through the creation of a simple C code patch
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
This document takes you through a simple patch example.
<p class="Pp">If you haven't read perlhack yet, go do that first! You might also
    want to read through perlsource too.</p>
<p class="Pp">Once you're done here, check out perlhacktips next.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="EXAMPLE_OF_A_SIMPLE_PATCH"><a class="permalink" href="#EXAMPLE_OF_A_SIMPLE_PATCH">EXAMPLE
  OF A SIMPLE PATCH</a></h1>
Let's take a simple patch from start to finish.
<p class="Pp">Here's something Larry suggested: if a
    <span class="Li">&quot;U&quot;</span> is the first active format during a
    <span class="Li">&quot;pack&quot;</span>, (for example,
    <span class="Li">&quot;pack &quot;U3C8&quot;, @stuff&quot;</span>) then the
    resulting string should be treated as UTF-8 encoded.</p>
<p class="Pp">If you are working with a git clone of the Perl repository, you
    will want to create a branch for your changes. This will make creating a
    proper patch much simpler. See the perlgit for details on how to do
  this.</p>
<section class="Ss">
<h2 class="Ss" id="Writing_the_patch"><a class="permalink" href="#Writing_the_patch">Writing
  the patch</a></h2>
How do we prepare to fix this up? First we locate the code in question - the
  <span class="Li">&quot;pack&quot;</span> happens at runtime, so it's going to
  be in one of the <i>pp</i> files. Sure enough,
  <span class="Li">&quot;pp_pack&quot;</span> is in <i>pp.c</i>. Since we're
  going to be altering this file, let's copy it to <i>pp.c~</i>.
<p class="Pp">[Well, it was in <i>pp.c</i> when this tutorial was written. It
    has now been split off with <span class="Li">&quot;pp_unpack&quot;</span> to
    its own file, <i>pp_pack.c</i>]</p>
<p class="Pp">Now let's look over <span class="Li">&quot;pp_pack&quot;</span>:
    we take a pattern into <span class="Li">&quot;pat&quot;</span>, and then
    loop over the pattern, taking each format character in turn into
    <span class="Li">&quot;datum_type&quot;</span>. Then for each possible
    format character, we swallow up the other arguments in the pattern (a field
    width, an asterisk, and so on) and convert the next chunk input into the
    specified format, adding it onto the output SV
    <span class="Li">&quot;cat&quot;</span>.</p>
<p class="Pp">How do we know if the <span class="Li">&quot;U&quot;</span> is the
    first format in the <span class="Li">&quot;pat&quot;</span>? Well, if we
    have a pointer to the start of <span class="Li">&quot;pat&quot;</span> then,
    if we see a <span class="Li">&quot;U&quot;</span> we can test whether we're
    still at the start of the string. So, here's where
    <span class="Li">&quot;pat&quot;</span> is set up:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    STRLEN fromlen;
    char *pat = SvPVx(*++MARK, fromlen);
    char *patend = pat + fromlen;
    I32 len;
    I32 datumtype;
    SV *fromstr;
</pre>
<p class="Pp">We'll have another string pointer in there:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    STRLEN fromlen;
    char *pat = SvPVx(*++MARK, fromlen);
    char *patend = pat + fromlen;
 +  char *patcopy;
    I32 len;
    I32 datumtype;
    SV *fromstr;
</pre>
<p class="Pp">And just before we start the loop, we'll set
    <span class="Li">&quot;patcopy&quot;</span> to be the start of
    <span class="Li">&quot;pat&quot;</span>:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    items = SP - MARK;
    MARK++;
    SvPVCLEAR(cat);
 +  patcopy = pat;
    while (pat &lt; patend) {
</pre>
<p class="Pp">Now if we see a <span class="Li">&quot;U&quot;</span> which was at
    the start of the string, we turn on the
    <span class="Li">&quot;UTF8&quot;</span> flag for the output SV,
    <span class="Li">&quot;cat&quot;</span>:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
 +  if (datumtype == 'U' &amp;&amp; pat==patcopy+1)
 +      SvUTF8_on(cat);
    if (datumtype == '#') {
        while (pat &lt; patend &amp;&amp; *pat != '\n')
            pat++;
</pre>
<p class="Pp">Remember that it has to be
    <span class="Li">&quot;patcopy+1&quot;</span> because the first character of
    the string is the <span class="Li">&quot;U&quot;</span> which has been
    swallowed into <span class="Li">&quot;datumtype!&quot;</span></p>
<p class="Pp">Oops, we forgot one thing: what if there are spaces at the start
    of the pattern? <span class="Li">&quot;pack(&quot; U*&quot;,
    @stuff)&quot;</span> will have <span class="Li">&quot;U&quot;</span> as the
    first active character, even though it's not the first thing in the pattern.
    In this case, we have to advance <span class="Li">&quot;patcopy&quot;</span>
    along with <span class="Li">&quot;pat&quot;</span> when we see spaces:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    if (isSPACE(datumtype))
        continue;
</pre>
<p class="Pp">needs to become</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    if (isSPACE(datumtype)) {
        patcopy++;
        continue;
    }
</pre>
<p class="Pp">OK. That's the C part done. Now we must do two additional things
    before this patch is ready to go: we've changed the behaviour of Perl, and
    so we must document that change. We must also provide some more regression
    tests to make sure our patch works and doesn't create a bug somewhere else
    along the line.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Testing_the_patch"><a class="permalink" href="#Testing_the_patch">Testing
  the patch</a></h2>
The regression tests for each operator live in <i>t/op/</i>, and so we make a
  copy of <i>t/op/pack.t</i> to <i>t/op/pack.t~</i>. Now we can add our tests to
  the end. First, we'll test that the <span class="Li">&quot;U&quot;</span> does
  indeed create Unicode strings.
<p class="Pp">t/op/pack.t has a sensible <b>ok()</b> function, but if it didn't
    we could use the one from t/test.pl.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
 require './test.pl';
 plan( tests =&gt; 159 );
</pre>
<p class="Pp">so instead of this:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
 print 'not ' unless &quot;1.20.300.4000&quot; eq sprintf &quot;%vd&quot;,
                                               pack(&quot;U*&quot;,1,20,300,4000);
 print &quot;ok $test\n&quot;; $test++;
</pre>
<p class="Pp">we can write the more sensible (see Test::More for a full
    explanation of <b>is()</b> and other testing functions).</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
 is( &quot;1.20.300.4000&quot;, sprintf &quot;%vd&quot;, pack(&quot;U*&quot;,1,20,300,4000),
                                       &quot;U* produces Unicode&quot; );
</pre>
<p class="Pp">Now we'll test that we got that space-at-the-beginning business
    right:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
 is( &quot;1.20.300.4000&quot;, sprintf &quot;%vd&quot;, pack(&quot;  U*&quot;,1,20,300,4000),
                                     &quot;  with spaces at the beginning&quot; );
</pre>
<p class="Pp">And finally we'll test that we don't make Unicode strings if
    <span class="Li">&quot;U&quot;</span> is <b>not</b> the first active
  format:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
 isnt( v1.20.300.4000, sprintf &quot;%vd&quot;, pack(&quot;C0U*&quot;,1,20,300,4000),
                                       &quot;U* not first isn't Unicode&quot; );
</pre>
<p class="Pp">Mustn't forget to change the number of tests which appears at the
    top, or else the automated tester will get confused. This will either look
    like this:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
 print &quot;1..156\n&quot;;
</pre>
<p class="Pp">or this:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
 plan( tests =&gt; 156 );
</pre>
<p class="Pp">We now compile up Perl, and run it through the test suite. Our new
    tests pass, hooray!</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Documenting_the_patch"><a class="permalink" href="#Documenting_the_patch">Documenting
  the patch</a></h2>
Finally, the documentation. The job is never done until the paperwork is over,
  so let's describe the change we've just made. The relevant place is
  <i>pod/perlfunc.pod</i>; again, we make a copy, and then we'll insert this
  text in the description of <span class="Li">&quot;pack&quot;</span>:
<p class="Pp"><span class="Li"></span></p>
<pre>
 =item *

 If the pattern begins with a C&lt;U&gt;, the resulting string will be treated
 as UTF-8-encoded Unicode. You can force UTF-8 encoding on in a string
 with an initial C&lt;U0&gt;, and the bytes that follow will be interpreted as
 Unicode characters. If you don't want this to happen, you can begin
 your pattern with C&lt;C0&gt; (or anything else) to force Perl not to UTF-8
 encode your string, and then follow this with a C&lt;U*&gt; somewhere in your
 pattern.
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Submit"><a class="permalink" href="#Submit">Submit</a></h2>
See perlhack for details on how to submit this patch.
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
This document was originally written by Nathan Torkington, and is maintained by
  the perl5-porters mailing list.
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2018-11-01</td>
    <td class="foot-os">perl v5.28.2</td>
  </tr>
</table>
</body>
</html>
