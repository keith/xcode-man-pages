<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>LibXML(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">LibXML(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">LibXML(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
XML::LibXML - Perl Binding for libxml2
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<span class="Li"></span>
<pre>
  use XML::LibXML;
  my $dom = XML::LibXML-&gt;load_xml(string =&gt; &lt;&lt;'EOT');
  &lt;some-xml/&gt;
  EOT

  $Version_String = XML::LibXML::LIBXML_DOTTED_VERSION;
  $Version_ID = XML::LibXML::LIBXML_VERSION;
  $DLL_Version = XML::LibXML::LIBXML_RUNTIME_VERSION;
  $libxmlnode = XML::LibXML-&gt;import_GDOME( $node, $deep );
  $gdomenode = XML::LibXML-&gt;export_GDOME( $node, $deep );
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
This module is an interface to libxml2, providing XML and HTML parsers with DOM,
  SAX and XMLReader interfaces, a large subset of DOM Layer 3 interface and a
  XML::XPath-like interface to XPath API of libxml2. The module is split into
  several packages which are not described in this section; unless stated
  otherwise, you only need to <span class="Li">&quot;use
  XML::LibXML;&quot;</span> in your programs.
<p class="Pp">For further information, please check the following
  documentation:</p>
<dl class="Bl-tag">
  <dt>XML::LibXML::Parser</dt>
  <dd>Parsing XML files with XML::LibXML</dd>
  <dt>XML::LibXML::DOM</dt>
  <dd>XML::LibXML Document Object Model (DOM) Implementation</dd>
  <dt>XML::LibXML::SAX</dt>
  <dd>XML::LibXML direct SAX parser</dd>
  <dt>XML::LibXML::Reader</dt>
  <dd>Reading XML with a pull-parser</dd>
  <dt>XML::LibXML::Dtd</dt>
  <dd>XML::LibXML frontend for DTD validation</dd>
  <dt>XML::LibXML::RelaxNG</dt>
  <dd>XML::LibXML frontend for RelaxNG schema validation</dd>
  <dt>XML::LibXML::Schema</dt>
  <dd>XML::LibXML frontend for W3C Schema schema validation</dd>
  <dt>XML::LibXML::XPathContext</dt>
  <dd>API for evaluating XPath expressions with enhanced support for the
      evaluation context</dd>
  <dt>XML::LibXML::InputCallback</dt>
  <dd>Implementing custom URI Resolver and input callbacks</dd>
  <dt>XML::LibXML::Common</dt>
  <dd>Common functions for XML::LibXML related Classes</dd>
</dl>
<p class="Pp">The nodes in the Document Object Model (DOM) are represented by
    the following classes (most of which &quot;inherit&quot; from
    XML::LibXML::Node):</p>
<dl class="Bl-tag">
  <dt>XML::LibXML::Document</dt>
  <dd>XML::LibXML class for DOM document nodes</dd>
  <dt>XML::LibXML::Node</dt>
  <dd>Abstract base class for XML::LibXML DOM nodes</dd>
  <dt>XML::LibXML::Element</dt>
  <dd>XML::LibXML class for DOM element nodes</dd>
  <dt>XML::LibXML::Text</dt>
  <dd>XML::LibXML class for DOM text nodes</dd>
  <dt>XML::LibXML::Comment</dt>
  <dd>XML::LibXML class for comment DOM nodes</dd>
  <dt>XML::LibXML::CDATASection</dt>
  <dd>XML::LibXML class for DOM CDATA sections</dd>
  <dt>XML::LibXML::Attr</dt>
  <dd>XML::LibXML DOM attribute class</dd>
  <dt>XML::LibXML::DocumentFragment</dt>
  <dd>XML::LibXML's DOM L2 Document Fragment implementation</dd>
  <dt>XML::LibXML::Namespace</dt>
  <dd>XML::LibXML DOM namespace nodes</dd>
  <dt>XML::LibXML::PI</dt>
  <dd>XML::LibXML DOM processing instruction nodes</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="ENCODINGS_SUPPORT_IN_XML::LIBXML"><a class="permalink" href="#ENCODINGS_SUPPORT_IN_XML::LIBXML">ENCODINGS
  SUPPORT IN XML::LIBXML</a></h1>
Recall that since version 5.6.1, Perl distinguishes between character strings
  (internally encoded in UTF-8) and so called binary data and, accordingly,
  applies either character or byte semantics to them. A scalar representing a
  character string is distinguished from a byte string by special flag (UTF8).
  Please refer to <i>perlunicode</i> for details.
<p class="Pp">XML::LibXML's API is designed to deal with many encodings of XML
    documents completely transparently, so that the application using
    XML::LibXML can be completely ignorant about the encoding of the XML
    documents it works with. On the other hand, functions like
    <span class="Li">&quot;XML::LibXML::Document-&gt;setEncoding&quot;</span>
    give the user control over the document encoding.</p>
<p class="Pp">To ensure the aforementioned transparency and uniformity, most
    functions of XML::LibXML that work with in-memory trees accept and return
    data as character strings (i.e. UTF-8 encoded with the UTF8 flag on)
    regardless of the original document encoding; however, the functions related
    to I/O operations (i.e. parsing and saving) operate with binary data (in the
    original document encoding) obeying the encoding declaration of the XML
    documents.</p>
<p class="Pp">Below we summarize basic rules and principles regarding
  encoding:</p>
<dl class="Bl-tag">
  <dt>1.</dt>
  <dd>Do NOT apply any encoding-related PerlIO layers
      (<span class="Li">&quot;:utf8&quot;</span> or
      <span class="Li">&quot;:encoding(...)&quot;</span>) to file handles that
      are an input for the parses or an output for a serializer of (full) XML
      documents. This is because the conversion of the data to/from the internal
      character representation is provided by libxml2 itself which must be able
      to enforce the encoding specified by the <span class="Li">&quot;&lt;?xml
      version=&quot;1.0&quot; encoding=&quot;...&quot;?&gt;&quot;</span>
      declaration. Here is an example to follow:
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  use XML::LibXML;
  # load
  open my $fh, '&lt;', 'file.xml';
  binmode $fh; # drop all PerlIO layers possibly created by a use open pragma
  $doc = XML::LibXML-&gt;load_xml(IO =&gt; $fh);

  # save
  open my $out, '&gt;', 'out.xml';
  binmode $out; # as above
  $doc-&gt;toFH($out);
  # or
  print {$out} $doc-&gt;toString();
    </pre>
  </dd>
  <dt>2.</dt>
  <dd>All functions working with DOM accept and return character strings (UTF-8
      encoded with UTF8 flag on). E.g.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  my $doc = XML::LibXML::Document-&gt;new('1.0',$some_encoding);
  my $element = $doc-&gt;createElement($name);
  $element-&gt;appendText($text);
  $xml_fragment = $element-&gt;toString(); # returns a character string
  $xml_document = $doc-&gt;toString(); # returns a byte string
    </pre>
    <p class="Pp">where <span class="Li">$some_encoding</span> is the document
        encoding that will be used when saving the document, and
        <span class="Li">$name</span> and <span class="Li">$text</span> contain
        character strings (UTF-8 encoded with UTF8 flag on). Note that the
        method <span class="Li">&quot;toString&quot;</span> returns XML as a
        character string if applied to other node than the Document node and a
        byte string containing the appropriate</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  &lt;?xml version=&quot;1.0&quot; encoding=&quot;...&quot;?&gt;
    </pre>
    <p class="Pp">declaration if applied to a XML::LibXML::Document.</p>
  </dd>
  <dt>3.</dt>
  <dd>DOM methods also accept binary strings in the original encoding of the
      document to which the node belongs (UTF-8 is assumed if the node is not
      attached to any document). Exploiting this feature is NOT RECOMMENDED
      since it is considered bad practice.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  my $doc = XML::LibXML::Document-&gt;new('1.0','iso-8859-2');
  my $text = $doc-&gt;createTextNode($some_latin2_encoded_byte_string);
  # WORKS, BUT NOT RECOMMENDED!
    </pre>
  </dd>
</dl>
<p class="Pp"><i>NOTE:</i> libxml2 support for many encodings is based on the
    iconv library. The actual list of supported encodings may vary from platform
    to platform. To test if your platform works correctly with your language
    encoding, build a simple document in the particular encoding and try to
    parse it with XML::LibXML to see if the parser produces any errors.
    Occasional crashes were reported on rare platforms that ship with a broken
    version of iconv.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="THREAD_SUPPORT"><a class="permalink" href="#THREAD_SUPPORT">THREAD
  SUPPORT</a></h1>
XML::LibXML since 1.67 partially supports Perl threads in Perl &gt;= 5.8.8.
  XML::LibXML can be used with threads in two ways:
<p class="Pp">By default, all XML::LibXML classes use CLONE_SKIP class method to
    prevent Perl from copying XML::LibXML::* objects when a new thread is spawn.
    In this mode, all XML::LibXML::* objects are thread specific. This is the
    safest way to work with XML::LibXML in threads.</p>
<p class="Pp">Alternatively, one may use</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  use threads;
  use XML::LibXML qw(:threads_shared);
</pre>
<p class="Pp">to indicate, that all XML::LibXML node and parser objects should
    be shared between the main thread and any thread spawn from there. For
    example, in</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  my $doc = XML::LibXML-&gt;load_xml(location =&gt; $filename);
  my $thr = threads-&gt;new(sub{
    # code working with $doc
    1;
  });
  $thr-&gt;join;
</pre>
<p class="Pp">the variable <span class="Li">$doc</span> refers to the exact same
    XML::LibXML::Document in the spawned thread as in the main thread.</p>
<p class="Pp">Without using mutex locks, parallel threads may read the same
    document (i.e. any node that belongs to the document), parse files, and
    modify different documents.</p>
<p class="Pp">However, if there is a chance that some of the threads will
    attempt to modify a document (or even create new nodes based on that
    document, e.g. with
    <span class="Li">&quot;$doc-&gt;createElement&quot;</span>) that other
    threads may be reading at the same time, the user is responsible for
    creating a mutex lock and using it in <i>both</i> in the thread that
    modifies and the thread that reads:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  my $doc = XML::LibXML-&gt;load_xml(location =&gt; $filename);
  my $mutex : shared;
  my $thr = threads-&gt;new(sub{
     lock $mutex;
     my $el = $doc-&gt;createElement('foo');
     # ...
    1;
  });
  {
    lock $mutex;
    my $root = $doc-&gt;documentElement;
    say $root-&gt;name;
  }
  $thr-&gt;join;
</pre>
<p class="Pp">Note that libxml2 uses dictionaries to store short strings and
    these dictionaries are kept on a document node. Without mutex locks, it
    could happen in the previous example that the thread modifies the dictionary
    while other threads attempt to read from it, which could easily lead to a
    crash.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="VERSION_INFORMATION"><a class="permalink" href="#VERSION_INFORMATION">VERSION
  INFORMATION</a></h1>
Sometimes it is useful to figure out, for which version XML::LibXML was compiled
  for. In most cases this is for debugging or to check if a given installation
  meets all functionality for the package. The functions
  XML::LibXML::LIBXML_DOTTED_VERSION and XML::LibXML::LIBXML_VERSION provide
  this version information. Both functions simply pass through the values of the
  similar named macros of libxml2. Similarly,
  XML::LibXML::LIBXML_RUNTIME_VERSION returns the version of the (usually
  dynamically) linked libxml2.
<dl class="Bl-tag">
  <dt>XML::LibXML::LIBXML_DOTTED_VERSION</dt>
  <dd><span class="Li"></span>
    <pre>
  $Version_String = XML::LibXML::LIBXML_DOTTED_VERSION;
    </pre>
    <p class="Pp">Returns the version string of the libxml2 version XML::LibXML
        was compiled for. This will be &quot;2.6.2&quot; for &quot;libxml2
        2.6.2&quot;.</p>
  </dd>
  <dt>XML::LibXML::LIBXML_VERSION</dt>
  <dd><span class="Li"></span>
    <pre>
  $Version_ID = XML::LibXML::LIBXML_VERSION;
    </pre>
    <p class="Pp">Returns the version id of the libxml2 version XML::LibXML was
        compiled for. This will be &quot;20602&quot; for &quot;libxml2
        2.6.2&quot;. Don't mix this version id with
        <span class="Li">$XML::LibXML::VERSION</span>. The latter contains the
        version of XML::LibXML itself while the first contains the version of
        libxml2 XML::LibXML was compiled for.</p>
  </dd>
  <dt>XML::LibXML::LIBXML_RUNTIME_VERSION</dt>
  <dd><span class="Li"></span>
    <pre>
  $DLL_Version = XML::LibXML::LIBXML_RUNTIME_VERSION;
    </pre>
    <p class="Pp">Returns a version string of the libxml2 which is (usually
        dynamically) linked by XML::LibXML. This will be &quot;20602&quot; for
        libxml2 released as &quot;2.6.2&quot; and something like
        &quot;20602-CVS2032&quot; for a CVS build of libxml2.</p>
    <p class="Pp">XML::LibXML issues a warning if the version of libxml2
        dynamically linked to it is less than the version of libxml2 which it
        was compiled against.</p>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="EXPORTS"><a class="permalink" href="#EXPORTS">EXPORTS</a></h1>
By default the module exports all constants and functions listed in the :all
  tag, described below.
</section>
<section class="Sh">
<h1 class="Sh" id="EXPORT_TAGS"><a class="permalink" href="#EXPORT_TAGS">EXPORT
  TAGS</a></h1>
<dl class="Bl-tag">
  <dt>&quot;:all&quot;</dt>
  <dd>Includes the tags <span class="Li">&quot;:libxml&quot;</span>,
      <span class="Li">&quot;:encoding&quot;</span>, and
      <span class="Li">&quot;:ns&quot;</span> described below.</dd>
  <dt>&quot;:libxml&quot;</dt>
  <dd>Exports integer constants for DOM node types.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  XML_ELEMENT_NODE            =&gt; 1
  XML_ATTRIBUTE_NODE          =&gt; 2
  XML_TEXT_NODE               =&gt; 3
  XML_CDATA_SECTION_NODE      =&gt; 4
  XML_ENTITY_REF_NODE         =&gt; 5
  XML_ENTITY_NODE             =&gt; 6
  XML_PI_NODE                 =&gt; 7
  XML_COMMENT_NODE            =&gt; 8
  XML_DOCUMENT_NODE           =&gt; 9
  XML_DOCUMENT_TYPE_NODE      =&gt; 10
  XML_DOCUMENT_FRAG_NODE      =&gt; 11
  XML_NOTATION_NODE           =&gt; 12
  XML_HTML_DOCUMENT_NODE      =&gt; 13
  XML_DTD_NODE                =&gt; 14
  XML_ELEMENT_DECL            =&gt; 15
  XML_ATTRIBUTE_DECL          =&gt; 16
  XML_ENTITY_DECL             =&gt; 17
  XML_NAMESPACE_DECL          =&gt; 18
  XML_XINCLUDE_START          =&gt; 19
  XML_XINCLUDE_END            =&gt; 20
    </pre>
  </dd>
  <dt>&quot;:encoding&quot;</dt>
  <dd>Exports two encoding conversion functions from XML::LibXML::Common.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  encodeToUTF8()
  decodeFromUTF8()
    </pre>
  </dd>
  <dt>&quot;:ns&quot;</dt>
  <dd>Exports two convenience constants: the implicit namespace of the reserved
      <span class="Li">&quot;xml:&quot;</span> prefix, and the implicit
      namespace for the reserved <span class="Li">&quot;xmlns:&quot;</span>
      prefix.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  XML_XML_NS    =&gt; 'http://www.w3.org/XML/1998/namespace'
  XML_XMLNS_NS  =&gt; 'http://www.w3.org/2000/xmlns/'
    </pre>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="RELATED_MODULES"><a class="permalink" href="#RELATED_MODULES">RELATED
  MODULES</a></h1>
The modules described in this section are not part of the XML::LibXML package
  itself. As they support some additional features, they are mentioned here.
<dl class="Bl-tag">
  <dt>XML::LibXSLT</dt>
  <dd>XSLT 1.0 Processor using libxslt and XML::LibXML</dd>
  <dt>XML::LibXML::Iterator</dt>
  <dd>XML::LibXML Implementation of the DOM Traversal Specification</dd>
  <dt>XML::CompactTree::XS</dt>
  <dd>Uses XML::LibXML::Reader to very efficiently to parse XML document or
      element into native Perl data structures, which are less flexible but
      significantly faster to process then DOM.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="XML::LIBXML_AND_XML::GDOME"><a class="permalink" href="#XML::LIBXML_AND_XML::GDOME">XML::LIBXML
  AND XML::GDOME</a></h1>
Note: <i>THE FUNCTIONS DESCRIBED HERE ARE STILL EXPERIMENTAL</i>
<p class="Pp">Although both modules make use of libxml2's XML capabilities, the
    DOM implementation of both modules are not compatible. But still it is
    possible to exchange nodes from one DOM to the other. The concept of this
    exchange is pretty similar to the function <i>cloneNode()</i>: The
    particular node is copied on the low-level to the opposite DOM
    implementation.</p>
<p class="Pp">Since the DOM implementations cannot coexist within one document,
    one is forced to copy each node that should be used. Because you are always
    keeping two nodes this may cause quite an impact on a machines memory
  usage.</p>
<p class="Pp">XML::LibXML provides two functions to export or import GDOME
    nodes: <i>import_GDOME()</i> and <i>export_GDOME()</i>. Both function have
    two parameters: the node and a flag for recursive import. The flag works as
    in <i>cloneNode()</i>.</p>
<p class="Pp">The two functions allow to export and import XML::GDOME nodes
    explicitly, however, XML::LibXML allows also the transparent import of
    XML::GDOME nodes in functions such as <i>appendChild()</i>,
    <i>insertAfter()</i> and so on. While native nodes are automatically adopted
    in most functions XML::GDOME nodes are always cloned in advance. Thus if the
    original node is modified after the operation, the node in the XML::LibXML
    document will not have this information.</p>
<dl class="Bl-tag">
  <dt>import_GDOME</dt>
  <dd><span class="Li"></span>
    <pre>
  $libxmlnode = XML::LibXML-&gt;import_GDOME( $node, $deep );
    </pre>
    <p class="Pp">This clones an XML::GDOME node to an XML::LibXML node
        explicitly.</p>
  </dd>
  <dt>export_GDOME</dt>
  <dd><span class="Li"></span>
    <pre>
  $gdomenode = XML::LibXML-&gt;export_GDOME( $node, $deep );
    </pre>
    <p class="Pp">Allows one to clone an XML::LibXML node into an XML::GDOME
        node.</p>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="CONTACTS"><a class="permalink" href="#CONTACTS">CONTACTS</a></h1>
For bug reports, please use the CPAN request tracker on
  http://rt.cpan.org/NoAuth/Bugs.html?Dist=XML-LibXML
<p class="Pp">For suggestions etc., and other issues related to XML::LibXML you
    may use the perl XML mailing list
    (<span class="Li">&quot;perl-xml@listserv.ActiveState.com&quot;</span>),
    where most XML-related Perl modules are discussed. In case of problems you
    should check the archives of that list first. Many problems are already
    discussed there. You can find the list's archives and subscription options
    at
  &lt;http://aspn.activestate.com/ASPN/Mail/Browse/Threaded/perl-xml&gt;.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHORS"><a class="permalink" href="#AUTHORS">AUTHORS</a></h1>
Matt Sergeant, Christian Glahn, Petr Pajas
</section>
<section class="Sh">
<h1 class="Sh" id="VERSION"><a class="permalink" href="#VERSION">VERSION</a></h1>
2.0110
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT"><a class="permalink" href="#COPYRIGHT">COPYRIGHT</a></h1>
2001-2007, AxKit.com Ltd.
<p class="Pp">2002-2006, Christian Glahn.</p>
<p class="Pp">2006-2009, Petr Pajas.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="LICENSE"><a class="permalink" href="#LICENSE">LICENSE</a></h1>
This program is free software; you can redistribute it and/or modify it under
  the same terms as Perl itself.
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2014-02-01</td>
    <td class="foot-os">perl v5.18.4</td>
  </tr>
</table>
</body>
</html>
