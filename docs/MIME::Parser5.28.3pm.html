<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>MIME::Parser(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">MIME::Parser(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">MIME::Parser(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
MIME::Parser - experimental class for parsing MIME streams
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
Before reading further, you should see MIME::Tools to make sure that you
  understand where this module fits into the grand scheme of things. Go on, do
  it now. I'll wait.
<p class="Pp">Ready? Ok...</p>
<section class="Ss">
<h2 class="Ss" id="Basic_usage_examples"><a class="permalink" href="#Basic_usage_examples">Basic
  usage examples</a></h2>
<span class="Li"></span>
<pre>
    ### Create a new parser object:
    my $parser = new MIME::Parser;

    ### Tell it where to put things:
    $parser-&gt;output_under(&quot;/tmp&quot;);

    ### Parse an input filehandle:
    $entity = $parser-&gt;parse(\*STDIN);

    ### Congratulations: you now have a (possibly multipart) MIME entity!
    $entity-&gt;dump_skeleton;          # for debugging
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Examples_of_input"><a class="permalink" href="#Examples_of_input">Examples
  of input</a></h2>
<span class="Li"></span>
<pre>
    ### Parse from filehandles:
    $entity = $parser-&gt;parse(\*STDIN);
    $entity = $parser-&gt;parse(IO::File-&gt;new(&quot;some command|&quot;);

    ### Parse from any object that supports getline() and read():
    $entity = $parser-&gt;parse($myHandle);

    ### Parse an in-core MIME message:
    $entity = $parser-&gt;parse_data($message);

    ### Parse an MIME message in a file:
    $entity = $parser-&gt;parse_open(&quot;/some/file.msg&quot;);

    ### Parse an MIME message out of a pipeline:
    $entity = $parser-&gt;parse_open(&quot;gunzip - &lt; file.msg.gz |&quot;);

    ### Parse already-split input (as &quot;deliver&quot; would give it to you):
    $entity = $parser-&gt;parse_two(&quot;msg.head&quot;, &quot;msg.body&quot;);
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Examples_of_output_control"><a class="permalink" href="#Examples_of_output_control">Examples
  of output control</a></h2>
<span class="Li"></span>
<pre>
    ### Keep parsed message bodies in core (default outputs to disk):
    $parser-&gt;output_to_core(1);

    ### Output each message body to a one-per-message directory:
    $parser-&gt;output_under(&quot;/tmp&quot;);

    ### Output each message body to the same directory:
    $parser-&gt;output_dir(&quot;/tmp&quot;);

    ### Change how nameless message-component files are named:
    $parser-&gt;output_prefix(&quot;msg&quot;);

    ### Put temporary files somewhere else
    $parser-&gt;tmp_dir(&quot;/var/tmp/mytmpdir&quot;);
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Examples_of_error_recovery"><a class="permalink" href="#Examples_of_error_recovery">Examples
  of error recovery</a></h2>
<span class="Li"></span>
<pre>
    ### Normal mechanism:
    eval { $entity = $parser-&gt;parse(\*STDIN) };
    if ($@) {
        $results  = $parser-&gt;results;
        $decapitated = $parser-&gt;last_head;  ### get last top-level head
    }

    ### Ultra-tolerant mechanism:
    $parser-&gt;ignore_errors(1);
    $entity = eval { $parser-&gt;parse(\*STDIN) };
    $error = ($@ || $parser-&gt;last_error);

    ### Cleanup all files created by the parse:
    eval { $entity = $parser-&gt;parse(\*STDIN) };
    ...
    $parser-&gt;filer-&gt;purge;
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Examples_of_parser_options"><a class="permalink" href="#Examples_of_parser_options">Examples
  of parser options</a></h2>
<span class="Li"></span>
<pre>
    ### Automatically attempt to RFC 2047-decode the MIME headers?
    $parser-&gt;decode_headers(1);             ### default is false

    ### Parse contained &quot;message/rfc822&quot; objects as nested MIME streams?
    $parser-&gt;extract_nested_messages(0);    ### default is true

    ### Look for uuencode in &quot;text&quot; messages, and extract it?
    $parser-&gt;extract_uuencode(1);           ### default is false

    ### Should we forgive normally-fatal errors?
    $parser-&gt;ignore_errors(0);              ### default is true
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Miscellaneous_examples"><a class="permalink" href="#Miscellaneous_examples">Miscellaneous
  examples</a></h2>
<span class="Li"></span>
<pre>
    ### Convert a Mail::Internet object to a MIME::Entity:
    my $data = join('', (@{$mail-&gt;header}, &quot;\n&quot;, @{$mail-&gt;body}));
    $entity = $parser-&gt;parse_data(\$data);
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
You can inherit from this class to create your own subclasses that parse MIME
  streams into MIME::Entity objects.
</section>
<section class="Sh">
<h1 class="Sh" id="PUBLIC_INTERFACE"><a class="permalink" href="#PUBLIC_INTERFACE">PUBLIC
  INTERFACE</a></h1>
<section class="Ss">
<h2 class="Ss" id="Construction"><a class="permalink" href="#Construction">Construction</a></h2>
<dl class="Bl-tag">
  <dt>new ARGS...</dt>
  <dd><i>Class method.</i> Create a new parser object. Once you do this, you can
      then set up various parameters before doing the actual parsing. For
      example:
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    my $parser = new MIME::Parser;
    $parser-&gt;output_dir(&quot;/tmp&quot;);
    $parser-&gt;output_prefix(&quot;msg1&quot;);
    my $entity = $parser-&gt;parse(\*STDIN);
    </pre>
    <p class="Pp">Any arguments are passed into
        <span class="Li">&quot;init()&quot;</span>. Don't override this in your
        subclasses; override <i>init()</i> instead.</p>
  </dd>
  <dt>init ARGS...</dt>
  <dd><i>Instance method.</i> Initiallize a new MIME::Parser object. This is
      automatically sent to a new object; you may want to override it. If you
      override this, be sure to invoke the inherited method.</dd>
  <dt>init_parse</dt>
  <dd><i>Instance method.</i> Invoked automatically whenever one of the
      top-level <i>parse()</i> methods is called, to reset the parser to a
      &quot;ready&quot; state.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Altering_how_messages_are_parsed"><a class="permalink" href="#Altering_how_messages_are_parsed">Altering
  how messages are parsed</a></h2>
<dl class="Bl-tag">
  <dt>decode_headers [YESNO]</dt>
  <dd><i>Instance method.</i> Controls whether the parser will attempt to decode
      all the MIME headers (as per RFC 2047) the moment it sees them. <b>This is
      not advisable</b> <b>for two very important reasons:</b></dd>
</dl>
<div class="Bd-indent">
<ul class="Bl-bullet">
  <li><b>It screws up the extraction of information from MIME fields.</b> If you
      fully decode the headers into bytes, you can inadvertently transform a
      parseable MIME header like this:
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    Content-type: text/plain; filename=&quot;=?ISO-8859-1?Q?Hi=22Ho?=&quot;
    </pre>
    <p class="Pp">into unparseable gobbledygook; in this case:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    Content-type: text/plain; filename=&quot;Hi&quot;Ho&quot;
    </pre>
  </li>
  <li><b>It is information-lossy.</b> An encoded string which contains both
      Latin-1 and Cyrillic characters will be turned into a binary mishmosh
      which simply can't be rendered.</li>
</ul>
</div>
<div class="Bd-indent">
<p class="Pp"><b>History.</b> This method was once the only out-of-the-box way
    to deal with attachments whose filenames had non-ASCII characters. However,
    since MIME-tools 5.4xx this is no longer necessary.</p>
<p class="Pp"><b>Parameters.</b> If YESNO is true, decoding is done. However,
    you will get a warning unless you use one of the special &quot;true&quot;
    values:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
   &quot;I_NEED_TO_FIX_THIS&quot;
          Just shut up and do it.  Not recommended.
          Provided only for those who need to keep old scripts functioning.

   &quot;I_KNOW_WHAT_I_AM_DOING&quot;
          Just shut up and do it.  Not recommended.
          Provided for those who REALLY know what they are doing.
</pre>
<p class="Pp">If YESNO is false (the default), no attempt at decoding will be
    done. With no argument, just returns the current setting. <b>Remember:</b>
    you can always decode the headers <i>after</i> the parsing has completed
    (see <i>MIME::Head::decode()</i>), or decode the words on demand (see
    MIME::Words).</p>
</div>
<dl class="Bl-tag">
  <dt>extract_nested_messages OPTION</dt>
  <dd><i>Instance method.</i> Some MIME messages will contain a part of type
      <span class="Li">&quot;message/rfc822&quot;</span>
      ,<span class="Li">&quot;message/partial&quot;</span> or
      <span class="Li">&quot;message/external-body&quot;</span>: literally, the
      text of an embedded mail/news/whatever message. This option controls
      whether (and how) we parse that embedded message.
    <p class="Pp">If the OPTION is false, we treat such a message just as if it
        were a <span class="Li">&quot;text/plain&quot;</span> document, without
        attempting to decode its contents.</p>
    <p class="Pp">If the OPTION is true (the default), the body of the
        <span class="Li">&quot;message/rfc822&quot;</span> or
        <span class="Li">&quot;message/partial&quot;</span> part is parsed by
        this parser, creating an entity object. What happens then is determined
        by the actual OPTION:</p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>NEST or 1</dt>
  <dd>The default setting. The contained message becomes the sole
      &quot;part&quot; of the <span class="Li">&quot;message/rfc822&quot;</span>
      entity (as if the containing message were a special kind of
      &quot;multipart&quot; message). You can recover the sub-entity by invoking
      the <i>parts()</i> method on the
      <span class="Li">&quot;message/rfc822&quot;</span> entity.</dd>
  <dt>REPLACE</dt>
  <dd>The contained message replaces the
      <span class="Li">&quot;message/rfc822&quot;</span> entity, as though the
      <span class="Li">&quot;message/rfc822&quot;</span> &quot;container&quot;
      never existed.
    <p class="Pp"><b>Warning:</b> notice that, with this option, all the header
        information in the <span class="Li">&quot;message/rfc822&quot;</span>
        header is lost. This might seriously bother you if you're dealing with a
        top-level message, and you've just lost the sender's address and the
        subject line. <span class="Li">&quot;:-/&quot;</span>.</p>
  </dd>
</dl>
</div>
<div class="Bd-indent">
<p class="Pp"><i>Thanks to Andreas Koenig for suggesting this method.</i></p>
</div>
<dl class="Bl-tag">
  <dt>extract_uuencode [YESNO]</dt>
  <dd><i>Instance method.</i> If set true, then whenever we are confronted with
      a message whose effective content-type is &quot;text/plain&quot; and whose
      encoding is 7bit/8bit/binary, we scan the encoded body to see if it
      contains uuencoded data (generally given away by a &quot;begin XXX&quot;
      line).
    <p class="Pp">If it does, we explode the uuencoded message into a multipart,
        where the text before the first &quot;begin XXX&quot; becomes the first
        part, and all &quot;begin...end&quot; sections following become the
        subsequent parts. The filename (if given) is accessible through the
        normal means.</p>
  </dd>
  <dt>ignore_errors [YESNO]</dt>
  <dd><i>Instance method.</i> Controls whether the parser will attempt to ignore
      normally-fatal errors, treating them as warnings and continuing with the
      parse.
    <p class="Pp">If YESNO is true (the default), many syntax errors are
        tolerated. If YESNO is false, fatal errors throw exceptions. With no
        argument, just returns the current setting.</p>
  </dd>
  <dt>decode_bodies [YESNO]</dt>
  <dd><i>Instance method.</i> Controls whether the parser should decode entity
      bodies or not. If this is set to a false value (default is true), all
      entity bodies will be kept as-is in the original content-transfer
      encoding.
    <p class="Pp">To prevent double encoding on the output side
        MIME::Body-&gt;is_encoded is set, which tells MIME::Body not to encode
        the data again, if encoded data was requested. This is in particular
        useful, when it's important that the content <b>must not</b> be
        modified, e.g. if you want to calculate OpenPGP signatures from it.</p>
    <p class="Pp"><b>WARNING</b>: the semantics change significantly if you
        parse MIME messages with this option set, because MIME::Entity resp.
        MIME::Body *always* see encoded data now, while the default behaviour is
        working with *decoded* data (and encoding it only if you request it).
        You need to decode the data yourself, if you want to have it
      decoded.</p>
    <p class="Pp">So use this option only if you exactly know, what you're
        doing, and that you're sure, that you really need it.</p>
  </dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Parsing_an_input_source"><a class="permalink" href="#Parsing_an_input_source">Parsing
  an input source</a></h2>
<dl class="Bl-tag">
  <dt>parse_data DATA</dt>
  <dd><i>Instance method.</i> Parse a MIME message that's already in core. This
      internally creates an &quot;in memory&quot; filehandle on a Perl scalar
      value using PerlIO
    <p class="Pp">You may supply the DATA in any of a number of ways...</p>
  </dd>
</dl>
<div class="Bd-indent">
<ul class="Bl-bullet">
  <li><b>A scalar</b> which holds the message. A reference to this scalar will
      be used internally.</li>
  <li><b>A ref to a scalar</b> which holds the message. This reference will be
      used internally.</li>
  <li><b>DEPRECATED</b>
    <p class="Pp"><b>A ref to an array of scalars.</b> The array is internally
        concatenated into a temporary string, and a reference to the new string
        is used internally.</p>
    <p class="Pp">It is much more efficient to pass in a scalar reference, so
        please consider refactoring your code to use that interface instead. If
        you absolutely MUST pass an array, you may be better off using
        IO::ScalarArray in the calling code to generate a filehandle, and
        passing that filehandle to <i></i><i>parse()</i><i></i></p>
  </li>
</ul>
</div>
<div class="Bd-indent">
<p class="Pp">Returns the parsed MIME::Entity on success.</p>
</div>
<dl class="Bl-tag">
  <dt>parse INSTREAM</dt>
  <dd><i>Instance method.</i> Takes a MIME-stream and splits it into its
      component entities.
    <p class="Pp">The INSTREAM can be given as an IO::File, a globref filehandle
        (like <span class="Li">&quot;\*STDIN&quot;</span>), or as <i>any</i>
        blessed object conforming to the IO:: interface (which minimally
        implements <i>getline()</i> and <i>read()</i>).</p>
    <p class="Pp">Returns the parsed MIME::Entity on success. Throws exception
        on failure. If the message contained too many parts (as set by
        <i>max_parts</i>), returns undef.</p>
  </dd>
  <dt>parse_open EXPR</dt>
  <dd><i>Instance method.</i> Convenience front-end onto
      <span class="Li">&quot;parse()&quot;</span>. Simply give this method any
      expression that may be sent as the second argument to <i>open()</i> to
      open a filehandle for reading.
    <p class="Pp">Returns the parsed MIME::Entity on success. Throws exception
        on failure.</p>
  </dd>
  <dt>parse_two HEADFILE, BODYFILE</dt>
  <dd><i>Instance method.</i> Convenience front-end onto
      <span class="Li">&quot;parse_open()&quot;</span>, intended for programs
      running under mail-handlers like <b>deliver</b>, which splits the incoming
      mail message into a header file and a body file. Simply give this method
      the paths to the respective files.
    <p class="Pp"><b>Warning:</b> it is assumed that, once the files are cat'ed
        together, there will be a blank line separating the head part and the
        body part.</p>
    <p class="Pp"><b>Warning:</b> new implementation slurps files into line
        array for portability, instead of using 'cat'. May be an issue if your
        messages are large.</p>
    <p class="Pp">Returns the parsed MIME::Entity on success. Throws exception
        on failure.</p>
  </dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Specifying_output_destination"><a class="permalink" href="#Specifying_output_destination">Specifying
  output destination</a></h2>
<b>Warning:</b> in 5.212 and before, this was done by methods of MIME::Parser.
  However, since many users have requested fine-tuned control over how this is
  done, the logic has been split off from the parser into its own class,
  MIME::Parser::Filer Every MIME::Parser maintains an instance of a
  MIME::Parser::Filer subclass to manage disk output (see MIME::Parser::Filer
  for details.)
<p class="Pp">The benefit to this is that the MIME::Parser code won't be
    confounded with a lot of garbage related to disk output. The drawback is
    that the way you override the default behavior will change.</p>
<p class="Pp">For now, all the normal public-interface methods are still
    provided, but many are only stubs which create or delegate to the underlying
    MIME::Parser::Filer object.</p>
<dl class="Bl-tag">
  <dt>filer [FILER]</dt>
  <dd><i>Instance method.</i> Get/set the FILER object used to manage the output
      of files to disk. This will be some subclass of MIME::Parser::Filer.</dd>
  <dt>output_dir DIRECTORY</dt>
  <dd><i>Instance method.</i> Causes messages to be filed directly into the
      given DIRECTORY. It does this by setting the underlying <i>filer()</i> to
      a new instance of MIME::Parser::FileInto, and passing the arguments into
      that class' <i>new()</i> method.
    <p class="Pp"><b>Note:</b> Since this method replaces the underlying filer,
        you must invoke it <i>before</i> doing changing any attributes of the
        filer, like the output prefix; otherwise those changes will be lost.</p>
  </dd>
  <dt>output_under BASEDIR, OPTS...</dt>
  <dd><i>Instance method.</i> Causes messages to be filed directly into
      subdirectories of the given BASEDIR, one subdirectory per message. It does
      this by setting the underlying <i>filer()</i> to a new instance of
      MIME::Parser::FileUnder, and passing the arguments into that class'
      <i>new()</i> method.
    <p class="Pp"><b>Note:</b> Since this method replaces the underlying filer,
        you must invoke it <i>before</i> doing changing any attributes of the
        filer, like the output prefix; otherwise those changes will be lost.</p>
  </dd>
  <dt>output_path HEAD</dt>
  <dd><i>Instance method, DEPRECATED.</i> Given a MIME head for a file to be
      extracted, come up with a good output pathname for the extracted file.
      Identical to the preferred form:
    <p class="Pp"><span class="Li"></span></p>
    <pre>
     $parser-&gt;filer-&gt;output_path(...args...);
    </pre>
    <p class="Pp">We just delegate this to the underlying <i>filer()</i>
      object.</p>
  </dd>
  <dt>output_prefix [PREFIX]</dt>
  <dd><i>Instance method, DEPRECATED.</i> Get/set the short string that all
      filenames for extracted body-parts will begin with (assuming that there is
      no better &quot;recommended filename&quot;). Identical to the preferred
      form:
    <p class="Pp"><span class="Li"></span></p>
    <pre>
     $parser-&gt;filer-&gt;output_prefix(...args...);
    </pre>
    <p class="Pp">We just delegate this to the underlying <i>filer()</i>
      object.</p>
  </dd>
  <dt>evil_filename NAME</dt>
  <dd><i>Instance method, DEPRECATED.</i> Identical to the preferred form:
    <p class="Pp"><span class="Li"></span></p>
    <pre>
     $parser-&gt;filer-&gt;evil_filename(...args...);
    </pre>
    <p class="Pp">We just delegate this to the underlying <i>filer()</i>
      object.</p>
  </dd>
  <dt>max_parts NUM</dt>
  <dd><i>Instance method.</i> Limits the number of MIME parts we will parse.
    <p class="Pp">Normally, instances of this class parse a message to the
        bitter end. Messages with many MIME parts can cause excessive memory
        consumption. If you invoke this method, parsing will abort with a
        <i>die()</i> if a message contains more than NUM parts.</p>
    <p class="Pp">If NUM is set to -1 (the default), then no maximum limit is
        enforced.</p>
    <p class="Pp">With no argument, returns the current setting as an
      integer</p>
  </dd>
  <dt>output_to_core YESNO</dt>
  <dd><i>Instance method.</i> Normally, instances of this class output all their
      decoded body data to disk files (via MIME::Body::File). However, you can
      change this behaviour by invoking this method before parsing:
    <p class="Pp">If YESNO is false (the default), then all body data goes to
        disk files.</p>
    <p class="Pp">If YESNO is true, then all body data goes to in-core data
        structures This is a little risky (what if someone emails you an MPEG or
        a tar file, hmmm?) but people seem to want this bit of noose-shaped
        rope, so I'm providing it. Note that setting this attribute true <i>does
        not</i> mean that parser-internal temporary files are avoided! Use
        <i>tmp_to_core()</i> for that.</p>
    <p class="Pp">With no argument, returns the current setting as a
      boolean.</p>
  </dd>
  <dt>tmp_recycling</dt>
  <dd><i>Instance method, DEPRECATED.</i>
    <p class="Pp">This method is a no-op to preserve the pre-5.421 API.</p>
    <p class="Pp">The <i>tmp_recycling()</i> feature was removed in 5.421
        because it had never actually worked. Please update your code to stop
        using it.</p>
  </dd>
  <dt>tmp_to_core [YESNO]</dt>
  <dd><i>Instance method.</i> Should <i>new_tmpfile()</i> create real temp
      files, or use fake in-core ones? Normally we allow the creation of
      temporary disk files, since this allows us to handle huge attachments even
      when core is limited.
    <p class="Pp">If YESNO is true, we implement <i>new_tmpfile()</i> via
        in-core handles. If YESNO is false (the default), we use real tmpfiles.
        With no argument, just returns the current setting.</p>
  </dd>
  <dt>use_inner_files [YESNO]</dt>
  <dd><i>REMOVED</i>.
    <p class="Pp"><i>Instance method.</i></p>
    <p class="Pp">MIME::Parser no longer supports IO::InnerFile, but this method
        is retained for backwards compatibility. It does nothing.</p>
    <p class="Pp">The original reasoning for IO::InnerFile was that inner files
        were faster than &quot;in-core&quot; temp files. At the time, the
        &quot;in-core&quot; tempfile support was implemented with IO::Scalar
        from the IO-Stringy distribution, which used the <i>tie()</i> interface
        to wrap a scalar with the appropriate IO::Handle operations. The penalty
        for this was fairly hefty, and IO::InnerFile actually was faster.</p>
    <p class="Pp">Nowadays, MIME::Parser uses Perl's built in ability to open a
        filehandle on an in-memory scalar variable via PerlIO. Benchmarking
        shows that IO::InnerFile is slightly slower than using in-memory
        temporary files, and is slightly faster than on-disk temporary files.
        Both measurements are within a few percent of each other. Since there's
        no real benefit, and since the IO::InnerFile abuse was fairly hairy and
        evil (&quot;writes&quot; to it were faked by extending the size of the
        inner file with the assumption that the only data you'd ever
        -&gt;<i>print()</i> to it would be the line from the &quot;outer&quot;
        file, for example) it's been removed.</p>
  </dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Specifying_classes_to_be_instantiated"><a class="permalink" href="#Specifying_classes_to_be_instantiated">Specifying
  classes to be instantiated</a></h2>
<dl class="Bl-tag">
  <dt>interface ROLE,[VALUE]</dt>
  <dd><i>Instance method.</i> During parsing, the parser normally creates
      instances of certain classes, like MIME::Entity. However, you may want to
      create a parser subclass that uses your own experimental head, entity,
      etc. classes (for example, your &quot;head&quot; class may provide some
      additional MIME-field-oriented methods).
    <p class="Pp">If so, then this is the method that your subclass should
        invoke during init. Use it like this:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    package MyParser;
    @ISA = qw(MIME::Parser);
    ...
    sub init {
        my $self = shift;
        $self-&gt;SUPER::init(@_);        ### do my parent's init
        $self-&gt;interface(ENTITY_CLASS =&gt; 'MIME::MyEntity');
        $self-&gt;interface(HEAD_CLASS   =&gt; 'MIME::MyHead');
        $self;                         ### return
    }
    </pre>
    <p class="Pp">With no VALUE, returns the VALUE currently associated with
        that ROLE.</p>
  </dd>
  <dt>new_body_for HEAD</dt>
  <dd><i>Instance method.</i> Based on the HEAD of a part we are parsing, return
      a new body object (any desirable subclass of MIME::Body) for receiving
      that part's data.
    <p class="Pp">If you set the
        <span class="Li">&quot;output_to_core&quot;</span> option to false
        before parsing (the default), then we call
        <span class="Li">&quot;output_path()&quot;</span> and create a new
        MIME::Body::File on that filename.</p>
    <p class="Pp">If you set the
        <span class="Li">&quot;output_to_core&quot;</span> option to true before
        parsing, then you get a MIME::Body::InCore instead.</p>
    <p class="Pp">If you want the parser to do something else entirely, you can
        override this method in a subclass.</p>
  </dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Temporary_File_Creation"><a class="permalink" href="#Temporary_File_Creation">Temporary
  File Creation</a></h2>
<dl class="Bl-tag">
  <dt>tmp_dir DIRECTORY</dt>
  <dd><i>Instance method.</i> Causes any temporary files created by this parser
      to be created in the given DIRECTORY.
    <p class="Pp">If called without arguments, returns current value.</p>
    <p class="Pp">The default value is undef, which will cause
        <i>new_tmpfile()</i> to use the system default temporary directory.</p>
  </dd>
  <dt>new_tmpfile</dt>
  <dd><i>Instance method.</i> Return an IO handle to be used to hold temporary
      data during a parse.
    <p class="Pp">The default uses <i>MIME::Tools::tmpopen()</i> to create a new
        temporary file, unless <i>tmp_to_core()</i> dictates otherwise, but you
        can override this. You shouldn't need to.</p>
    <p class="Pp">The location for temporary files can be changed on a
        per-parser basis with <i>tmp_dir()</i>.</p>
    <p class="Pp">If you do override this, make certain that the object you
        return is set for <i>binmode()</i>, and is able to handle the following
        methods:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    read(BUF, NBYTES)
    getline()
    getlines()
    print(@ARGS)
    flush()
    seek(0, 0)
    </pre>
    <p class="Pp">Fatal exception if the stream could not be established.</p>
  </dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Parse_results_and_error_recovery"><a class="permalink" href="#Parse_results_and_error_recovery">Parse
  results and error recovery</a></h2>
<dl class="Bl-tag">
  <dt>last_error</dt>
  <dd><i>Instance method.</i> Return the error (if any) that we ignored in the
      last parse.</dd>
  <dt>last_head</dt>
  <dd><i>Instance method.</i> Return the top-level MIME header of the last
      stream we attempted to parse. This is useful for replying to people who
      sent us bad MIME messages.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    ### Parse an input stream:
    eval { $entity = $parser-&gt;parse(\*STDIN) };
    if (!$entity) {    ### parse failed!
        my $decapitated = $parser-&gt;last_head;
        ...
    }
    </pre>
  </dd>
  <dt>results</dt>
  <dd><i>Instance method.</i> Return an object containing lots of info from the
      last entity parsed. This will be an instance of class
      MIME::Parser::Results.</dd>
</dl>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="OPTIMIZING_YOUR_PARSER"><a class="permalink" href="#OPTIMIZING_YOUR_PARSER">OPTIMIZING
  YOUR PARSER</a></h1>
<section class="Ss">
<h2 class="Ss" id="Maximizing_speed"><a class="permalink" href="#Maximizing_speed">Maximizing
  speed</a></h2>
Optimum input mechanisms:
<p class="Pp"><span class="Li"></span></p>
<pre>
    parse()                    YES (if you give it a globref or a
                                    subclass of IO::File)
    parse_open()               YES
    parse_data()               NO  (see below)
    parse_two()                NO  (see below)
</pre>
<p class="Pp">Optimum settings:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    decode_headers()           *** (no real difference; 0 is slightly faster)
    extract_nested_messages()  0   (may be slightly faster, but in
                                    general you want it set to 1)
    output_to_core()           0   (will be MUCH faster)
    tmp_to_core()              0   (will be MUCH faster)
</pre>
<p class="Pp"><b>Native I/O is much faster than object-oriented I/O.</b> It's
    much faster to use &lt;$foo&gt; than
    <span class="Li">$foo</span>-&gt;getline. For backwards compatibility, this
    module must continue to use object-oriented I/O in most places, but if you
    use <i>parse()</i> with a &quot;real&quot; filehandle (string, globref, or
    subclass of IO::File) then MIME::Parser is able to perform some crucial
    optimizations.</p>
<p class="Pp"><b>The </b><b><i>parse_two()</i></b><b> call is very
    inefficient.</b> Currently this is just a front-end onto
    <i>parse_data()</i>. If your OS supports it, you're <i>far</i> better off
    doing something like:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    $parser-&gt;parse_open(&quot;/bin/cat msg.head msg.body |&quot;);
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Minimizing_memory"><a class="permalink" href="#Minimizing_memory">Minimizing
  memory</a></h2>
Optimum input mechanisms:
<p class="Pp"><span class="Li"></span></p>
<pre>
    parse()                    YES
    parse_open()               YES
    parse_data()               NO  (in-core I/O will burn core)
    parse_two()                NO  (in-core I/O will burn core)
</pre>
<p class="Pp">Optimum settings:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    decode_headers()           *** (no real difference)
    extract_nested_messages()  *** (no real difference)
    output_to_core()           0   (will use MUCH less memory)
                                    tmp_to_core is 1)
    tmp_to_core()              0   (will use MUCH less memory)
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Maximizing_tolerance_of_bad__s-1MIME_s0"><a class="permalink" href="#Maximizing_tolerance_of_bad__s-1MIME_s0">Maximizing
  tolerance of bad MIME</a></h2>
Optimum input mechanisms:
<p class="Pp"><span class="Li"></span></p>
<pre>
    parse()                    *** (doesn't matter)
    parse_open()               *** (doesn't matter)
    parse_data()               *** (doesn't matter)
    parse_two()                *** (doesn't matter)
</pre>
<p class="Pp">Optimum settings:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    decode_headers()           0   (sidesteps problem of bad hdr encodings)
    extract_nested_messages()  0   (sidesteps problems of bad nested messages,
                                    but often you want it set to 1 anyway).
    output_to_core()           *** (doesn't matter)
    tmp_to_core()              *** (doesn't matter)
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Avoiding_disk-based_temporary_files"><a class="permalink" href="#Avoiding_disk-based_temporary_files">Avoiding
  disk-based temporary files</a></h2>
Optimum input mechanisms:
<p class="Pp"><span class="Li"></span></p>
<pre>
    parse()                    YES (if you give it a seekable handle)
    parse_open()               YES (becomes a seekable handle)
    parse_data()               NO  (unless you set tmp_to_core(1))
    parse_two()                NO  (unless you set tmp_to_core(1))
</pre>
<p class="Pp">Optimum settings:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    decode_headers()           *** (doesn't matter)
    extract_nested_messages()  *** (doesn't matter)
    output_to_core()           *** (doesn't matter)
    tmp_to_core()              1
</pre>
<p class="Pp"><b>You can veto tmpfiles entirely.</b> You can set
    <i>tmp_to_core()</i> true: this will always use in-core I/O for the
    buffering (<b>warning:</b> this will slow down the parsing of messages with
    large attachments).</p>
<p class="Pp"><b>Final resort.</b> You can always override <i>new_tmpfile()</i>
    in a subclass.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="WARNINGS"><a class="permalink" href="#WARNINGS">WARNINGS</a></h1>
<dl class="Bl-tag">
  <dt>Multipart messages are always read line-by-line</dt>
  <dd>Multipart document parts are read line-by-line, so that the encapsulation
      boundaries may easily be detected. However, bad MIME composition agents
      (for example, naive CGI scripts) might return multipart documents where
      the parts are, say, unencoded bitmap files... and, consequently, where
      such &quot;lines&quot; might be veeeeeeeeery long indeed.
    <p class="Pp">A better solution for this case would be to set up some form
        of state machine for input processing. This will be left for future
        versions.</p>
  </dd>
  <dt>Multipart parts read into temp files before decoding</dt>
  <dd>In my original implementation, the MIME::Decoder classes had to be aware
      of encapsulation boundaries in multipart MIME documents. While this
      decode-while-parsing approach obviated the need for temporary files, it
      resulted in inflexible and complex decoder implementations.
    <p class="Pp">The revised implementation uses a temporary file (a la
        <span class="Li">&quot;tmpfile()&quot;</span>) during parsing to hold
        the <i>encoded</i> portion of the current MIME document or part. This
        file is deleted automatically after the current part is decoded and the
        data is written to the &quot;body stream&quot; object; you'll never see
        it, and should never need to worry about it.</p>
    <p class="Pp">Some folks have asked for the ability to bypass this temp-file
        mechanism, I suppose because they assume it would slow down their
        application. I considered accommodating this wish, but the temp-file
        approach solves a lot of thorny problems in parsing, and it also
        protects against hidden bugs in user applications (what if you've
        directed the encoded part into a scalar, and someone unexpectedly sends
        you a 6 MB tar file?). Finally, I'm just not convinced that the
        temp-file use adds significant overhead.</p>
  </dd>
  <dt>Fuzzing of CRLF and newline on input</dt>
  <dd>RFC 2045 dictates that MIME streams have lines terminated by CRLF
      (<span class="Li">&quot;\r\n&quot;</span>). However, it is extremely
      likely that folks will want to parse MIME streams where each line ends in
      the local newline character <span class="Li">&quot;\n&quot;</span>
      instead.
    <p class="Pp">An attempt has been made to allow the parser to handle both
        CRLF and newline-terminated input.</p>
  </dd>
  <dt>Fuzzing of CRLF and newline on output</dt>
  <dd>The <span class="Li">&quot;7bit&quot;</span> and
      <span class="Li">&quot;8bit&quot;</span> decoders will decode both a
      <span class="Li">&quot;\n&quot;</span> and a
      <span class="Li">&quot;\r\n&quot;</span> end-of-line sequence into a
      <span class="Li">&quot;\n&quot;</span>.
    <p class="Pp">The <span class="Li">&quot;binary&quot;</span> decoder
        (default if no encoding specified) still outputs stuff verbatim... so a
        MIME message with CRLFs and no explicit encoding will be output as a
        text file that, on many systems, will have an annoying ^M at the end of
        each line... <i>but this is as it should be</i>.</p>
  </dd>
  <dt>Inability to handle multipart boundaries that contain newlines</dt>
  <dd>First, let's get something straight: <i>this is an evil, EVIL
      practice,</i> and is incompatible with RFC 2046... hence, it's not valid
      MIME.
    <p class="Pp">If your mailer creates multipart boundary strings that contain
        newlines <i>when they appear in the message body,</i> give it two weeks
        notice and find another one. If your mail robot receives MIME mail like
        this, regard it as syntactically incorrect MIME, which it is.</p>
    <p class="Pp">Why do I say that? Well, in RFC 2046, the syntax of a boundary
        is given quite clearly:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
      boundary := 0*69&lt;bchars&gt; bcharsnospace

      bchars := bcharsnospace / &quot; &quot;

      bcharsnospace :=    DIGIT / ALPHA / &quot;'&quot; / &quot;(&quot; / &quot;)&quot; / &quot;+&quot; /&quot;_&quot;
                   / &quot;,&quot; / &quot;-&quot; / &quot;.&quot; / &quot;/&quot; / &quot;:&quot; / &quot;=&quot; / &quot;?&quot;
    </pre>
    <p class="Pp">All of which means that a valid boundary string <i>cannot</i>
        have newlines in it, and any newlines in such a string in the message
        header are expected to be solely the result of <i>folding</i> the string
        (i.e., inserting to-be-removed newlines for readability and
        line-shortening <i>only</i>).</p>
    <p class="Pp">Yet, there is at least one brain-damaged user agent out there
        that composes mail like this:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
      MIME-Version: 1.0
      Content-type: multipart/mixed; boundary=&quot;----ABC-
       123----&quot;
      Subject: Hi... I'm a dork!

      This is a multipart MIME message (yeah, right...)

      ----ABC-
       123----

      Hi there!
    </pre>
    <p class="Pp">We have <i>got</i> to discourage practices like this (and the
        recent file upload idiocy where binary files that are part of a
        multipart MIME message aren't base64-encoded) if we want MIME to stay
        relatively simple, and MIME parsers to be relatively robust.</p>
    <p class="Pp"><i>Thanks to Andreas Koenig for bringing a baaaaaaaaad user
        agent to</i> <i>my attention.</i></p>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
MIME::Tools, MIME::Head, MIME::Body, MIME::Entity, MIME::Decoder
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
Eryq (<i>eryq@zeegee.com</i>), ZeeGee Software Inc
  (<i>http://www.zeegee.com</i>). Dianne Skoll (dfs@roaringpenguin.com)
  http://www.roaringpenguin.com
<p class="Pp">All rights reserved. This program is free software; you can
    redistribute it and/or modify it under the same terms as Perl itself.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2017-04-05</td>
    <td class="foot-os">perl v5.18.2</td>
  </tr>
</table>
</body>
</html>
