<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.10 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>Net::Server::PreFork(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Net::Server::PreFork(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Net::Server::PreFork(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
Net::Server::PreFork - Net::Server personality
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<span class="Li"></span>
<pre>
    use base qw(Net::Server::PreFork);

    sub process_request {
        #...code...
    }

    __PACKAGE__-&gt;run();
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
Please read the pod on Net::Server and Net::Server::PreForkSimple first. This
  module is a personality, or extension, or sub class, of the
  Net::Server::PreForkSimple class which is a sub class of Net::Server. See
  Net::Server::PreForkSimple.
<p class="Pp">This personality binds to one or more ports and then forks
    <span class="Li">&quot;min_servers&quot;</span> child process. The server
    will make sure that at any given time there are
    <span class="Li">&quot;min_spare_servers&quot;</span> available to receive a
    client request, up to <span class="Li">&quot;max_servers&quot;</span>. Each
    of these children will process up to
    <span class="Li">&quot;max_requests&quot;</span> client connections. This
    type is good for a heavily hit site, and should scale well for most
    applications. (Multi port accept is accomplished using flock to serialize
    the children).</p>
<p class="Pp">At this time, it does not appear that this module will pass tests
    on Win32 systems. Any ideas or patches for making the tests pass would be
    welcome.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SAMPLE_CODE"><a class="permalink" href="#SAMPLE_CODE">SAMPLE
  CODE</a></h1>
Please see the sample listed in Net::Server.
</section>
<section class="Sh">
<h1 class="Sh" id="COMMAND_LINE_ARGUMENTS"><a class="permalink" href="#COMMAND_LINE_ARGUMENTS">COMMAND
  LINE ARGUMENTS</a></h1>
In addition to the command line arguments of the Net::Server base class and the
  Net::Server::PreForkSimple parent class, Net::Server::PreFork contains several
  other configurable parameters. You really should also see
  Net::Server::PreForkSimple.
<p class="Pp"><span class="Li"></span></p>
<pre>
    Key                 Value                   Default
    min_servers         \d+                     5
    min_spare_servers   \d+                     2
    max_spare_servers   \d+                     10
    max_servers         \d+                     50
    max_requests        \d+                     1000

    serialize           (flock|semaphore
                         |pipe|none)            undef
    # serialize defaults to flock on multi_port or on Solaris
    lock_file           &quot;filename&quot;              File::Temp-&gt;new

    check_for_dead      \d+                     30
    check_for_waiting   \d+                     10

    max_dequeue         \d+                     undef
    check_for_dequeue   \d+                     undef

    child_communication 1                       undef
</pre>
<dl class="Bl-tag">
  <dt>min_servers</dt>
  <dd>The minimum number of servers to keep running.</dd>
  <dt>min_spare_servers</dt>
  <dd>The minimum number of servers to have waiting for requests. Minimum and
      maximum numbers should not be set to close to each other or the server
      will fork and kill children too often.</dd>
  <dt>max_spare_servers</dt>
  <dd>The maximum number of servers to have waiting for requests. See
      <i>min_spare_servers</i>.</dd>
  <dt>max_servers</dt>
  <dd>The maximum number of child servers to start. This does not apply to
      dequeue processes.</dd>
  <dt>check_for_waiting</dt>
  <dd>Seconds to wait before checking to see if we can kill off some waiting
      servers.</dd>
  <dt>check_for_spawn</dt>
  <dd>Seconds between checking to see if we need to spawn more children</dd>
  <dt>min_child_ttl</dt>
  <dd>Minimum number of seconds between starting children and killing a child
      process</dd>
  <dt>child_communication</dt>
  <dd>Enable child communication to parent via unix sockets. If set to true,
      will let children write to the socket contained in
      <span class="Li">$self</span>-&gt;{'server'}-&gt;{'parent_sock'}. The
      parent will be notified through child_is_talking_hook where the first
      argument is the socket to the child. The child's socket is stored in
      <span class="Li">$self</span>-&gt;{'server'}-&gt;{'children'}-&gt;{$child_pid}-&gt;{'sock'}.</dd>
  <dt>serialize</dt>
  <dd>See the documentation under Net::Server::PreForkSimple.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="CONFIGURATION_FILE"><a class="permalink" href="#CONFIGURATION_FILE">CONFIGURATION
  FILE</a></h1>
<span class="Li">&quot;Net::Server::PreFork&quot;</span> allows for the use of a
  configuration file to read in server parameters. The format of this conf file
  is simple key value pairs. Comments and white space are ignored.
<p class="Pp"><span class="Li"></span></p>
<pre>
    #-------------- file test.conf --------------

    ### server information
    min_servers   20
    max_servers   80
    min_spare_servers 10
    min_spare_servers 15

    max_requests  1000

    ### user and group to become
    user        somebody
    group       everybody

    ### logging ?
    log_file    /var/log/server.log
    log_level   3
    pid_file    /tmp/server.pid

    ### access control
    allow       .+\.(net|com)
    allow       domain\.com
    deny        a.+

    ### background the process?
    background  1

    ### ports to bind
    host        127.0.0.1
    port        localhost:20204
    port        20205

    ### reverse lookups ?
    # reverse_lookups on

    ### enable child communication ?
    # child_communication

    #-------------- file test.conf --------------
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="PROCESS_FLOW"><a class="permalink" href="#PROCESS_FLOW">PROCESS
  FLOW</a></h1>
Process flow follows Net::Server until the loop phase. At this point
  <span class="Li">&quot;min_servers&quot;</span> are forked and wait for
  connections. When a child accepts a connection, finishs processing a client,
  or exits, it relays that information to the parent, which keeps track and
  makes sure there are enough children to fulfill
  <span class="Li">&quot;min_servers&quot;</span>,
  <span class="Li">&quot;min_spare_servers&quot;</span>,
  <span class="Li">&quot;max_spare_servers&quot;</span>, and
  <span class="Li">&quot;max_servers&quot;</span>.
</section>
<section class="Sh">
<h1 class="Sh" id="HOOKS"><a class="permalink" href="#HOOKS">HOOKS</a></h1>
The PreFork server has the following hooks in addition to the hooks provided by
  PreForkSimple. See Net::Server::PreForkSimple.
<dl class="Bl-tag">
  <dt>&quot;$self-&gt;run_n_children_hook()&quot;</dt>
  <dd>This hook occurs at the top of run_n_children which is called each time
      the server goes to start more child processes. This gives the parent to do
      a little of its own accountting (as desired). Idea for this hook came from
      James FitzGibbon.</dd>
  <dt>&quot;$self-&gt;parent_read_hook()&quot;</dt>
  <dd>This hook occurs any time that the parent reads information from the
      child. The line from the child is sent as an argument.</dd>
  <dt>&quot;$self-&gt;child_is_talking_hook()&quot;</dt>
  <dd>This hook occurs if child_communication is true and the child has written
      to <span class="Li">$self</span>-&gt;{'server'}-&gt;{'parent_sock'}. The
      first argument will be the open socket to the child.</dd>
  <dt>&quot;$self-&gt;idle_loop_hook()&quot;</dt>
  <dd>This hook is called in every pass through the main process wait loop,
      every <span class="Li">&quot;check_for_waiting&quot;</span> seconds. The
      first argument is a reference to an array of file descriptors that can be
      read at the moment.</dd>
  <dt>&quot;$self-&gt;cleanup_dead_child_hook( $child )&quot;</dt>
  <dd>This hook is called when a dead child is detected. A child is considered
      dead when the pid does no longer exist. This hook could be used to cleanup
      possible temporary files or locks left over by a dead child. =back</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="HOT_DEPLOY"><a class="permalink" href="#HOT_DEPLOY">HOT
  DEPLOY</a></h1>
Since version 2.000, the PreFork server has accepted the TTIN and TTOU signals.
  When a TTIN is received, the min and max_servers are increased by 1. If a TTOU
  signal is received the min max_servers are decreased by 1. This allows for
  adjusting the number of handling processes without having to restart the
  server.
</section>
<section class="Sh">
<h1 class="Sh" id="BUGS"><a class="permalink" href="#BUGS">BUGS</a></h1>
Tests don't seem to work on Win32. Any ideas or patches would be welcome.
</section>
<section class="Sh">
<h1 class="Sh" id="TO_DO"><a class="permalink" href="#TO_DO">TO DO</a></h1>
See Net::Server
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
Paul T. Seamons paul@seamons.com
</section>
<section class="Sh">
<h1 class="Sh" id="THANKS"><a class="permalink" href="#THANKS">THANKS</a></h1>
See Net::Server
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
Please see also Net::Server::Fork, Net::Server::INET,
  Net::Server::PreForkSimple, Net::Server::MultiType, Net::Server::Single
  Net::Server::SIG Net::Server::Daemonize Net::Server::Proto
</section>
<section class="Sh">
<h1 class="Sh" id="POD_ERRORS"><a class="permalink" href="#POD_ERRORS">POD
  ERRORS</a></h1>
Hey! <b>The above document had some coding errors, which are explained
  below:</b>
<dl class="Bl-tag">
  <dt>Around line 683:</dt>
  <dd>You forgot a '=back' before '=head1'</dd>
</dl>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2017-08-10</td>
    <td class="foot-os">perl v5.28.2</td>
  </tr>
</table>
</body>
</html>
