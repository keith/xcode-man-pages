<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    .Nd, .Bf, .Op { display: inline; }
    .Pa, .Ad { font-style: italic; }
    .Ms { font-weight: bold; }
    .Bl-diag > dt { font-weight: bold; }
    code.Nm, .Fl, .Cm, .Ic, code.In, .Fd, .Fn, .Cd { font-weight: bold;
      font-family: inherit; }
  </style>
  <title>C-Cookbook(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">C-Cookbook(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">C-Cookbook(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Inline::C-Cookbook - A Cornucopia of Inline C Recipes</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">It's a lot easier for most of us to cook a meal from a recipe,
    rather than just throwing things into a pot until something edible forms. So
    it is with programming as well.
    <span class="Li">&quot;Inline.pm&quot;</span> makes C programming for Perl
    as easy as possible. Having a set of easy to understand samples, makes it
    simpler yet.</p>
<p class="Pp">This Cookbook is intended to be an evergrowing repository of small
    yet complete coding examples; each showing how to accomplish a particular
    task with Inline. Each example is followed by a short discussion, explaining
    in detail the particular features that are being demonstrated.</p>
<p class="Pp">Many of these recipes are apdapted from email discussions I have
    had with Inline users around the world. It has been my experience so far,
    that Inline provides an elegant solution to almost all problems involving
    Perl and C.</p>
<p class="Pp">Bon Appetit!</p>
</section>
<section class="Sh">
<h1 class="Sh" id="Appetizers"><a class="permalink" href="#Appetizers">Appetizers</a></h1>
<section class="Ss">
<h2 class="Ss" id="Hello,_world"><a class="permalink" href="#Hello,_world">Hello,
  world</a></h2>
<dl class="Bl-tag">
  <dt id="Problem"><a class="permalink" href="#Problem">Problem</a></dt>
  <dd>It seems that the first thing any programmer wants to do when he learns a
      new programming technique is to use it to greet the Earth. How can I do
      this using Inline?</dd>
  <dt id="Solution"><a class="permalink" href="#Solution">Solution</a></dt>
  <dd>
    <pre>    use Inline C =&gt; &lt;&lt;'END_C';
    void greet() {
        printf(&quot;Hello, world\n&quot;);
    }
    END_C
    greet;
    </pre>
  </dd>
  <dt id="Discussion"><a class="permalink" href="#Discussion">Discussion</a></dt>
  <dd>Nothing too fancy here. We define a single C function
      <span class="Li">&quot;greet()&quot;</span> which prints a message to
      STDOUT. One thing to note is that since the Inline code comes before the
      function call to <span class="Li">&quot;greet&quot;</span>, we can call it
      as a bareword (no parentheses).</dd>
  <dt id="See"><a class="permalink" href="#See">See Also</a></dt>
  <dd>See Inline and Inline::C for basic info about
      <span class="Li">&quot;Inline.pm&quot;</span>.</dd>
  <dt id="Credits"><a class="permalink" href="#Credits">Credits</a></dt>
  <dd>Brian Kernigan
    <p class="Pp">Dennis Ritchie</p>
  </dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="One_Liner"><a class="permalink" href="#One_Liner">One
  Liner</a></h2>
<dl class="Bl-tag">
  <dt id="Problem~2"><a class="permalink" href="#Problem~2">Problem</a></dt>
  <dd>A concept is valid in Perl only if it can be shown to work in one line.
      Can Inline reduce the complexities of Perl/C interaction to a
    one-liner?</dd>
  <dt id="Solution~2"><a class="permalink" href="#Solution~2">Solution</a></dt>
  <dd>
    <pre>    perl -e 'use Inline C=&gt;q{void greet(){printf(&quot;Hello, world\n&quot;);}};greet'
    </pre>
  </dd>
  <dt id="Discussion~2"><a class="permalink" href="#Discussion~2">Discussion</a></dt>
  <dd>Try doing that in XS :-)</dd>
  <dt id="See~2"><a class="permalink" href="#See~2">See Also</a></dt>
  <dd>My email signature of late is:
    <p class="Pp"></p>
    <pre>    perl -le 'use Inline C=&gt;q{SV*JAxH(char*x){return newSVpvf(&quot;Just Another %s Hacker&quot;,x);}};print JAxH+Perl'
    </pre>
    <p class="Pp">A bit fancier but a few bytes too long to qualify as a true
        one liner :-(</p>
  </dd>
  <dt id="Credits~2"><a class="permalink" href="#Credits~2">Credits</a></dt>
  <dd>&quot;Eli the Bearded&quot; &lt;elijah@workspot.net&gt; gave me the idea
      that I should have an Inline one-liner as a signature.</dd>
</dl>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="Meat_&amp;_Potatoes"><a class="permalink" href="#Meat_&amp;_Potatoes">Meat
  &amp; Potatoes</a></h1>
<section class="Ss">
<h2 class="Ss" id="Data_Types"><a class="permalink" href="#Data_Types">Data
  Types</a></h2>
<dl class="Bl-tag">
  <dt id="Problem~3"><a class="permalink" href="#Problem~3">Problem</a></dt>
  <dd>How do I pass different types of data to and from Inline C functions; like
      strings, numbers and integers?</dd>
  <dt id="Solution~3"><a class="permalink" href="#Solution~3">Solution</a></dt>
  <dd>
    <pre>    # vowels.pl
    use Inline C;
    $filename = $ARGV[0];
    die &quot;Usage: perl vowels.pl filename\n&quot; unless -f $filename;
    $text = join '', &lt;&gt;;           # slurp input file
    $vp = vowel_scan($text);       # call our function
    $vp = sprintf(&quot;%03.1f&quot;, $vp * 100);  # format for printing
    print &quot;The letters in $filename are $vp% vowels.\n&quot;;
    __END__
    __C__
    /* Find percentage of vowels to letters */
    double vowel_scan(char* str) {
        int letters = 0;
        int vowels = 0;
        int i = 0;
        char c;
        char normalize = 'a' ^ 'A';
        /* normalize forces lower case in ASCII; upper in EBCDIC */
        char A = normalize | 'a';
        char E = normalize | 'e';
        char I = normalize | 'i';
        char O = normalize | 'o';
        char U = normalize | 'u';
        char Z = normalize | 'z';
        while(c = str[i++]) {
            c |= normalize;
            if (c &gt;= A &amp;&amp; c &lt;= Z) {
                 letters++;
                 if (c == A || c == E || c == I || c == O || c == U)
                     vowels++;
            }
        }
        return letters ? ((double) vowels / letters) : 0.0;
    }
    </pre>
  </dd>
  <dt id="Discussion~3"><a class="permalink" href="#Discussion~3">Discussion</a></dt>
  <dd>This script takes a file name from the command line and prints the ratio
      of vowels to letters in that file.
      <span class="Li">&quot;vowels.pl&quot;</span> uses an Inline C function
      called <span class="Li">&quot;vowel_scan&quot;</span>, that takes a string
      argument, and returns the percentage of vowels as a floating point number
      between 0 and 1. It handles upper and lower case letters, and works with
      ASCII and EBCDIC. It is also quite fast.
    <p class="Pp">Running this script produces:</p>
    <p class="Pp"></p>
    <pre>    &gt; perl vowels.pl /usr/dict/words
    The letters in /usr/dict/words are 37.5% vowels.
    </pre>
  </dd>
  <dt id="See~3"><a class="permalink" href="#See~3">See Also</a></dt>
  <dd>The Perl Journal vol #19 has an article about Inline which uses this
      example.</dd>
  <dt id="Credits~3"><a class="permalink" href="#Credits~3">Credits</a></dt>
  <dd>This example was reprinted by permission of The Perl Journal. It was
      edited to work with Inline v0.30 and higher.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Variable_Argument_Lists"><a class="permalink" href="#Variable_Argument_Lists">Variable
  Argument Lists</a></h2>
<dl class="Bl-tag">
  <dt id="Problem~4"><a class="permalink" href="#Problem~4">Problem</a></dt>
  <dd>How do I pass a variable-sized list of arguments to an Inline C
    function?</dd>
  <dt id="Solution~4"><a class="permalink" href="#Solution~4">Solution</a></dt>
  <dd>
    <pre>    greet(qw(Sarathy Jan Sparky Murray Mike));
    use Inline C =&gt; &lt;&lt;'END_OF_C_CODE';
    void greet(SV* name1, ...) {
        Inline_Stack_Vars;
        int i;
        for (i = 0; i &lt; Inline_Stack_Items; i++)
            printf(&quot;Hello %s!\n&quot;, SvPV(Inline_Stack_Item(i), PL_na));
        Inline_Stack_Void;
    }
    END_OF_C_CODE
    </pre>
  </dd>
  <dt id="Discussion~4"><a class="permalink" href="#Discussion~4">Discussion</a></dt>
  <dd>This little program greets a group of people, such as my coworkers. We use
      the <span class="Li">&quot;C&quot;</span> ellipsis syntax:
      &quot;<span class="Li">&quot;...&quot;</span>&quot;, since the list can be
      of any size.
    <p class="Pp">Since there are no types or names associated with each
        argument, we can't expect XS to handle the conversions for us. We'll
        need to pop them off the <b>Stack</b> ourselves. Luckily there are two
        functions (macros) that make this a very easy task.</p>
    <p class="Pp">First, we need to begin our function with a
        &quot;<span class="Li">&quot;Inline_Stack_Vars&quot;</span>&quot;
        statement. This defines a few internal variables that we need to access
        the <b>Stack</b>. Now we can use
        &quot;<span class="Li">&quot;Inline_Stack_Items&quot;</span>&quot;,
        which returns an integer containing the number of arguments passed to us
        from Perl.</p>
    <p class="Pp"><b>NOTE:</b> It is important to <i>only</i> use
        &quot;<span class="Li">&quot;Inline_Stack_&quot;</span>&quot; macros
        when there is an ellipsis (<span class="Li">&quot;...&quot;</span>) in
        the argument list, <i>or</i> the function has a return type of void.</p>
    <p class="Pp">Second, we use the
        <span class="Li">Inline_Stack_Item(x)</span> function to access each
        argument where &quot;0 &lt;= x &lt; items&quot;.</p>
    <p class="Pp"><b>NOTE:</b> When using a variable length argument list, you
        have to specify at least one argument before the ellipsis. (On my
        compiler, anyway.) When XS does it's argument checking, it will complain
        if you pass in less than the number of <i>defined</i> arguments.
        Therefore, there is currently no way to pass an empty list when a
        variable length list is expected.</p>
  </dd>
  <dt id="See~4"><a class="permalink" href="#See~4">See Also</a></dt>
  <dd></dd>
  <dt id="Credits~4"><a class="permalink" href="#Credits~4">Credits</a></dt>
  <dd></dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Multiple_Return_Values"><a class="permalink" href="#Multiple_Return_Values">Multiple
  Return Values</a></h2>
<dl class="Bl-tag">
  <dt id="Problem~5"><a class="permalink" href="#Problem~5">Problem</a></dt>
  <dd>How do I return a list of values from a C function?</dd>
  <dt id="Solution~5"><a class="permalink" href="#Solution~5">Solution</a></dt>
  <dd>
    <pre>    print map {&quot;$_\n&quot;} get_localtime(time);
    use Inline C =&gt; &lt;&lt;'END_OF_C_CODE';
    #include &lt;time.h&gt;
    void get_localtime(int utc) {
      struct tm *ltime = localtime(&amp;utc);
      Inline_Stack_Vars;
      Inline_Stack_Reset;
      Inline_Stack_Push(sv_2mortal(newSViv(ltime-&gt;tm_year)));
      Inline_Stack_Push(sv_2mortal(newSViv(ltime-&gt;tm_mon)));
      Inline_Stack_Push(sv_2mortal(newSViv(ltime-&gt;tm_mday)));
      Inline_Stack_Push(sv_2mortal(newSViv(ltime-&gt;tm_hour)));
      Inline_Stack_Push(sv_2mortal(newSViv(ltime-&gt;tm_min)));
      Inline_Stack_Push(sv_2mortal(newSViv(ltime-&gt;tm_sec)));
      Inline_Stack_Push(sv_2mortal(newSViv(ltime-&gt;tm_isdst)));
      Inline_Stack_Done;
    }
    END_OF_C_CODE
    </pre>
  </dd>
  <dt id="Discussion~5"><a class="permalink" href="#Discussion~5">Discussion</a></dt>
  <dd>Perl is a language where it is common to return a list of values from a
      subroutine call instead of just a single value. C is not such a language.
      In order to accomplish this in C we need to manipulate the Perl call stack
      by hand. Luckily, Inline provides macros to make this easy.
    <p class="Pp">This example calls the system
        <span class="Li">&quot;localtime&quot;</span>, and returns each of the
        parts of the time struct; much like the perl builtin
        <span class="Li">&quot;localtime()&quot;</span>. On each stack push, we
        are creating a new Perl integer (SVIV) and mortalizing it. The
        <i>sv_2mortal()</i> call makes sure that the reference count is set
        properly. Without it, the program would leak memory.</p>
    <p class="Pp">NOTE: The <span class="Li">&quot;#include&quot;</span>
        statement is not really needed, because Inline automatically includes
        the Perl headers which include almost all standard system calls.</p>
  </dd>
  <dt id="See~5"><a class="permalink" href="#See~5">See Also</a></dt>
  <dd>For more information on the Inline stack macros, see Inline::C.</dd>
  <dt id="Credits~5"><a class="permalink" href="#Credits~5">Credits</a></dt>
  <dd>Richard Anderson &lt;starfire@zipcon.net&gt; contributed the original idea
      for this snippet.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Multiple_Return_Values_(Another_Way)"><a class="permalink" href="#Multiple_Return_Values_(Another_Way)">Multiple
  Return Values (Another Way)</a></h2>
<dl class="Bl-tag">
  <dt id="Problem~6"><a class="permalink" href="#Problem~6">Problem</a></dt>
  <dd>How can I pass back more than one value without using the Perl Stack?</dd>
  <dt id="Solution~6"><a class="permalink" href="#Solution~6">Solution</a></dt>
  <dd>
    <pre>    use Inline::Files;
    use Inline C;
    my ($foo, $bar);
    change($foo, $bar);
    print &quot;\$foo = $foo\n&quot;;
    print &quot;\$bar = $bar\n&quot;;
    __C__
    int change(SV* var1, SV* var2) {
        sv_setpvn(var1, &quot;Perl Rocks!&quot;, 11);
        sv_setpvn(var2, &quot;Inline Rules!&quot;, 13);
        return 1;
    }
    </pre>
  </dd>
  <dt id="Discussion~6"><a class="permalink" href="#Discussion~6">Discussion</a></dt>
  <dd>Most perl function interfaces return values as a list of one or more
      scalars. Very few like <span class="Li">&quot;chomp&quot;</span>, will
      modify an input scalar in place. On the other hand, in C you do this quite
      often. Values are passed in by reference and modified in place by the
      called function.
    <p class="Pp">It turns out that we can do that with Inline as well. The
        secret is to use a type of '<span class="Li">&quot;SV*&quot;</span>' for
        each argument that is to be modified. This ensures passing by reference,
        because no typemapping is needed.</p>
    <p class="Pp">The function can then use the Perl5 API to operate on that
        argument. When control returns to Perl, the argument will retain the
        value set by the C function. In this example we passed in 2 empty
        scalars and assigned values directly to them.</p>
  </dd>
  <dt id="See~6"><a class="permalink" href="#See~6">See Also</a></dt>
  <dd></dd>
  <dt id="Credits~6"><a class="permalink" href="#Credits~6">Credits</a></dt>
  <dd>Ned Konz &lt;ned@bike-nomad.com&gt; brought this behavior to my attention.
      He also pointed out that he is not the world famous computer cyclist Steve
      Roberts (http://www.microship.com), but he is close
      (http://bike-nomad.com). Thanks Ned.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Using_Memory"><a class="permalink" href="#Using_Memory">Using
  Memory</a></h2>
<dl class="Bl-tag">
  <dt id="Problem~7"><a class="permalink" href="#Problem~7">Problem</a></dt>
  <dd>How should I allocate buffers in my Inline C code?</dd>
  <dt id="Solution~7"><a class="permalink" href="#Solution~7">Solution</a></dt>
  <dd>
    <pre>    print greeting('Ingy');
    use Inline C =&gt; &lt;&lt;'END_OF_C_CODE';
    SV* greeting(SV* sv_name) {
        return (newSVpvf(&quot;Hello %s!\n&quot;, SvPV(sv_name, PL_na)));
    }
    END_OF_C_CODE
    </pre>
  </dd>
  <dt id="Discussion~7"><a class="permalink" href="#Discussion~7">Discussion</a></dt>
  <dd>In this example we will return the greeting to the caller, rather than
      printing it. This would seem mighty easy, except for the fact that we need
      to allocate a small buffer to create the greeting.
    <p class="Pp">I would urge you to stay away from
        <span class="Li">&quot;malloc&quot;</span>ing your own buffer. Just use
        Perl's built in memory management. In other words, just create a new
        Perl string scalar. The function
        <span class="Li">&quot;newSVpv&quot;</span> does just that. And
        <span class="Li">&quot;newSVpvf&quot;</span> includes
        <span class="Li">&quot;sprintf&quot;</span> functionality.</p>
    <p class="Pp">The other problem is getting rid of this new scalar. How will
        the ref count get decremented after we pass the scalar back? Perl also
        provides a function called
        <span class="Li">&quot;sv_2mortal&quot;</span>. Mortal variables die
        when the context goes out of scope. In other words, Perl will wait until
        the new scalar gets passed back and then decrement the ref count for
        you, thereby making it eligible for garbage collection. See
        <span class="Li">&quot;perldoc perlguts&quot;</span>.</p>
    <p class="Pp">In this example the
        <span class="Li">&quot;sv_2mortal&quot;</span> call gets done under the
        hood by XS, because we declared the return type to be
        <span class="Li">&quot;SV*&quot;</span>.</p>
    <p class="Pp">To view the generated XS code, run the command
        &quot;<span class="Li">&quot;perl</span>
        <span class="Li">-MInline=INFO,FORCE,NOCLEAN
        example004.pl&quot;</span>&quot;. This will leave the build directory
        intact and tell you where to find it.</p>
  </dd>
  <dt id="See~7"><a class="permalink" href="#See~7">See Also</a></dt>
  <dd></dd>
  <dt id="Credits~7"><a class="permalink" href="#Credits~7">Credits</a></dt>
  <dd></dd>
</dl>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="Fast_Food"><a class="permalink" href="#Fast_Food">Fast
  Food</a></h1>
<section class="Ss">
<h2 class="Ss" id="Inline_"><a class="permalink" href="#Inline_">Inline
  CGI</a></h2>
<dl class="Bl-tag">
  <dt id="Problem~8"><a class="permalink" href="#Problem~8">Problem</a></dt>
  <dd>How do I use Inline securely in a CGI environment?</dd>
  <dt id="Solution~8"><a class="permalink" href="#Solution~8">Solution</a></dt>
  <dd>
    <pre>    #!/usr/bin/perl
    use CGI qw(:standard);
    use Inline (Config =&gt;
                DIRECTORY =&gt; '/usr/local/apache/Inline',
               );
    print (header,
           start_html('Inline CGI Example'),
           h1(JAxH('Inline')),
           end_html
          );
    use Inline C =&gt; &lt;&lt;END;
    SV* JAxH(char* x) {
        return newSVpvf(&quot;Just Another %s Hacker&quot;, x);
    }
    END
    </pre>
  </dd>
  <dt id="Discussion~8"><a class="permalink" href="#Discussion~8">Discussion</a></dt>
  <dd>The problem with running Inline code from a CGI script is that Inline
      <b>writes</b> to a build area on your disk whenever it compiles code. Most
      CGI scripts don't (and shouldn't) be able to create a directory and write
      into it.
    <p class="Pp">The solution is to explicitly tell Inline which directory to
        use with the 'use Inline Config =&gt; DIRECTORY =&gt; ...' line. Then
        you need to give write access to that directory from the web server (CGI
        script).</p>
    <p class="Pp">If you see this as a security hole, then there is another
        option. Give write access to yourself, but read-only access to the CGI
        script. Then run the script once by hand (from the command line). This
        will cause Inline to precompile the C code. That way the CGI will only
        need read access to the build directory (to load in the shared library
        from there).</p>
    <p class="Pp">Just remember that whenever you change the C code, you need to
        precompile it again.</p>
  </dd>
  <dt id="See~8"><a class="permalink" href="#See~8">See Also</a></dt>
  <dd>See CGI for more information on using the
      <span class="Li">&quot;CGI.pm&quot;</span> module.</dd>
  <dt id="Credits~8"><a class="permalink" href="#Credits~8">Credits</a></dt>
  <dd></dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="mod_perl"><a class="permalink" href="#mod_perl">mod_perl</a></h2>
<dl class="Bl-tag">
  <dt id="Problem~9"><a class="permalink" href="#Problem~9">Problem</a></dt>
  <dd>How do I use Inline with mod_perl?</dd>
  <dt id="Solution~9"><a class="permalink" href="#Solution~9">Solution</a></dt>
  <dd>
    <pre>    package Factorial;
    use strict;
    use Inline Config =&gt;
               DIRECTORY =&gt; '/usr/local/apache/Inline',
               ENABLE =&gt; 'UNTAINT';
    use Inline 'C';
    Inline-&gt;init;
    sub handler {
        my $r = shift;
        $r-&gt;send_http_header('text/plain');
        printf &quot;%3d! = %10d\n&quot;, $_, factorial($_) for 1..100;
        return Apache::Constants::OK;
    }
    1;
    __DATA__
    __C__
    double factorial(double x) {
        if (x &lt; 2)  return 1;
        return x * factorial(x - 1)
    }
    </pre>
  </dd>
  <dt id="Discussion~9"><a class="permalink" href="#Discussion~9">Discussion</a></dt>
  <dd>This is a fully functional mod_perl handler that prints out the factorial
      values for the numbers 1 to 100. Since we are using Inline under mod_perl,
      there are a few considerations to , um, consider.
    <p class="Pp">First, mod_perl handlers are usually run with
        <span class="Li">&quot;-T&quot;</span> taint detection. Therefore, we
        need to enable the UNTAINT option. The next thing to deal with is the
        fact that this handler will most likely be loaded after Perl's compile
        time. Since we are using the DATA section, we need to use the special
        <span class="Li">&quot;init()&quot;</span> call. And of course we need
        to specify a DIRECTORY that mod_perl can compile into. <i>See the above
        CGI example</i> <i>for more info.</i></p>
    <p class="Pp">Other than that, this is a pretty straightforward mod_perl
        handler, tuned for even more speed!</p>
  </dd>
  <dt id="See~9"><a class="permalink" href="#See~9">See Also</a></dt>
  <dd>See Stas Bekman's upcoming O'Reilly book on mod_perl to which this example
      was contributed.</dd>
  <dt id="Credits~9"><a class="permalink" href="#Credits~9">Credits</a></dt>
  <dd></dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Object_Oriented_Inline"><a class="permalink" href="#Object_Oriented_Inline">Object
  Oriented Inline</a></h2>
<dl class="Bl-tag">
  <dt id="Problem~10"><a class="permalink" href="#Problem~10">Problem</a></dt>
  <dd>How do I implement Object Oriented programming in Perl using C
    objects?</dd>
  <dt id="Solution~10"><a class="permalink" href="#Solution~10">Solution</a></dt>
  <dd>
    <pre>    my $obj1 = Soldier-&gt;new('Benjamin', 'Private', 11111);
    my $obj2 = Soldier-&gt;new('Sanders', 'Colonel', 22222);
    my $obj3 = Soldier-&gt;new('Matt', 'Sergeant', 33333);
    for my $obj ($obj1, $obj2, $obj3) {
        print  $obj-&gt;get_serial, &quot;) &quot;,
               $obj-&gt;get_name, &quot; is a &quot;,
               $obj-&gt;get_rank, &quot;\n&quot;;
    }
    #---------------------------------------------------------
    package Soldier;
    use Inline C =&gt; &lt;&lt;'END';
    typedef struct {
      char* name;
      char* rank;
      long  serial;
      } Soldier;
    SV* new(char* class, char* name, char* rank, long serial) {
        Soldier* soldier;
        SV*      obj_ref = newSViv(0);
        SV*      obj = newSVrv(obj_ref, class);
        New(42, soldier, 1, Soldier);
        soldier-&gt;name = savepv(name);
        soldier-&gt;rank = savepv(rank);
        soldier-&gt;serial = serial;
        sv_setiv(obj, (IV)soldier);
        SvREADONLY_on(obj);
        return obj_ref;
     }
     char* get_name(SV* obj) {
           return ((Soldier*)SvIV(SvRV(obj)))-&gt;name;
     }
     char* get_rank(SV* obj) {
           return ((Soldier*)SvIV(SvRV(obj)))-&gt;rank;
     }
     long get_serial(SV* obj) {
          return ((Soldier*)SvIV(SvRV(obj)))-&gt;serial;
     }
     void DESTROY(SV* obj) {
          Soldier* soldier = (Soldier*)SvIV(SvRV(obj));
          Safefree(soldier-&gt;name);
          Safefree(soldier-&gt;rank);
          Safefree(soldier);
    }
    END
    </pre>
  </dd>
  <dt id="Discussion~10"><a class="permalink" href="#Discussion~10">Discussion</a></dt>
  <dd>Damian Conway has given us myriad ways of implementing OOP in Perl. This
      is one he might not have thought of.
    <p class="Pp">The interesting thing about this example is that it uses Perl
        for all the OO bindings while using C for the attributes and
      methods.</p>
    <p class="Pp">If you examine the Perl code everything looks exactly like a
        regular OO example. There is a <span class="Li">&quot;new&quot;</span>
        method and several accessor methods. The familiar 'arrow syntax' is used
        to invoke them.</p>
    <p class="Pp">In the class definition (second part) the Perl
        <span class="Li">&quot;package&quot;</span> statement is used to name
        the object class or namespace. But that's where the similarities end
        Inline takes over.</p>
    <p class="Pp">The idea is that we call a C subroutine called
        <span class="Li">&quot;new()&quot;</span> which returns a blessed
        scalar. The scalar contains a readonly integer which is a C pointer to a
        Soldier struct. This is our object.</p>
    <p class="Pp">The <span class="Li">&quot;new()&quot;</span> function needs
        to malloc the memory for the struct and then copy the initial values
        into it using <span class="Li">&quot;savepv()&quot;</span>. This also
        allocates more memory (which we have to keep track of).</p>
    <p class="Pp">Note that <span class="Li">&quot;newSVrv()&quot;</span>
        doesn't create a reference, but returns a new SV ('obj') and makes
        'obj_ref' a reference to it. Ultimately, 'obj_ref' (which is the SV that
        <span class="Li">&quot;new()&quot;</span> returns) holds a reference to
        the blessed scalar in 'obj', which in turn contains an integer that
        corresponds to the memory address of the C object.</p>
    <p class="Pp">The accessor methods are pretty straightforward. They return
        the current value of their attribute.</p>
    <p class="Pp">The last method <span class="Li">&quot;DESTROY()&quot;</span>
        is called automatically by Perl whenever an object goes out of scope.
        This is where we can free all the memory used by the object.</p>
    <p class="Pp">That's it. It's a very simplistic example. It doesn't show off
        any advanced OO features, but it is pretty cool to see how easy the
        implementation can be. The important Perl call is
        <span class="Li">&quot;newSVrv()&quot;</span> which creates a blessed
        scalar.</p>
  </dd>
  <dt id="See~10"><a class="permalink" href="#See~10">See Also</a></dt>
  <dd>Read &quot;Object Oriented Perl&quot; by Damian Conway, for more useful
      ways of doing OOP in Perl.
    <p class="Pp">You can learn more Perl calls in perlapi. If you don't have
        Perl 5.6.0 or higher, visit
        http://www.perldoc.com/perl5.6/pod/perlapi.html</p>
  </dd>
  <dt id="Credits~10"><a class="permalink" href="#Credits~10">Credits</a></dt>
  <dd></dd>
</dl>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="The_Main_Course"><a class="permalink" href="#The_Main_Course">The
  Main Course</a></h1>
<section class="Ss">
<h2 class="Ss" id="Exposing_Shared_Libraries"><a class="permalink" href="#Exposing_Shared_Libraries">Exposing
  Shared Libraries</a></h2>
<dl class="Bl-tag">
  <dt id="Problem~11"><a class="permalink" href="#Problem~11">Problem</a></dt>
  <dd>You have this great C library and you want to be able to access parts of
      it with Perl.</dd>
  <dt id="Solution~11"><a class="permalink" href="#Solution~11">Solution</a></dt>
  <dd>
    <pre>    print get('http://www.axkit.org');
    use Inline C =&gt; Config =&gt;
               LIBS =&gt; '-lghttp';
    use Inline C =&gt; &lt;&lt;'END_OF_C_CODE';
    #include &lt;ghttp.h&gt;
    char *get(SV* uri) {
       SV* buffer;
       ghttp_request* request;
       buffer = NEWSV(0,0);
       request = ghttp_request_new();
       ghttp_set_uri(request, SvPV(uri, PL_na));
       ghttp_set_header(request, http_hdr_Connection, &quot;close&quot;);
       ghttp_prepare(request);
       ghttp_process(request);
       sv_catpv(buffer, ghttp_get_body(request));
       ghttp_request_destroy(request);
       return SvPV(buffer, PL_na);
    }
    END_OF_C_CODE
    </pre>
  </dd>
  <dt id="Discussion~11"><a class="permalink" href="#Discussion~11">Discussion</a></dt>
  <dd>This example fetches and prints the HTML from http://www.axkit.org It
      requires the GNOME http libraries. http://www.gnome.org
    <p class="Pp">One of the most common questions I get is &quot;How can I use
        Inline to make use of some shared library?&quot;. Although it has always
        been possible to do so, the configuration was ugly, and there were no
        specific examples.</p>
    <p class="Pp">With version 0.30 and higher, you can specify the use of
        shared libraries easily with something like this:</p>
    <p class="Pp"></p>
    <pre>    use Inline C =&gt; Config =&gt; LIBS =&gt; '-lghttp';
    use Inline C =&gt; &quot;code ...&quot;;
    </pre>
    <p class="Pp">or</p>
    <p class="Pp"></p>
    <pre>    use Inline C =&gt; &quot;code ...&quot;, LIBS =&gt; '-lghttp';
    </pre>
    <p class="Pp">To specify a specific library path, use:</p>
    <p class="Pp"></p>
    <pre>    use Inline C =&gt; &quot;code ...&quot;, LIBS =&gt; '-L/your/lib/path -lyourlib';
    </pre>
    <p class="Pp">To specify an include path use:</p>
    <p class="Pp"></p>
    <pre>    use Inline C =&gt; &quot;code ...&quot;,
               LIBS =&gt; '-lghttp',
               INC =&gt; '-I/your/inc/path';
    </pre>
  </dd>
  <dt id="See~11"><a class="permalink" href="#See~11">See Also</a></dt>
  <dd>The <span class="Li">&quot;LIBS&quot;</span> and
      <span class="Li">&quot;INC&quot;</span> configuration options are
      formatted and passed into MakeMaker. For more info see
      ExtUtils::MakeMaker. For more options see Inline::C.</dd>
  <dt id="Credits~11"><a class="permalink" href="#Credits~11">Credits</a></dt>
  <dd>This code was written by Matt Sergeant &lt;matt@sergeant.org&gt;, author
      of many CPAN modules. The configuration syntax has been modified for use
      with Inline v0.30.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Automatic_Function_Wrappers"><a class="permalink" href="#Automatic_Function_Wrappers">Automatic
  Function Wrappers</a></h2>
<dl class="Bl-tag">
  <dt id="Problem~12"><a class="permalink" href="#Problem~12">Problem</a></dt>
  <dd>You have some functions in a C library that you want to access from Perl
      exactly as you would from C.</dd>
  <dt id="Solution~12"><a class="permalink" href="#Solution~12">Solution</a></dt>
  <dd>The error function <span class="Li">&quot;erf()&quot;</span> is probably
      defined in your standard math library. Annoyingly, Perl does not let you
      access it. To print out a small table of its values, just say:
    <p class="Pp"></p>
    <pre>    perl -le 'use Inline C =&gt; q{ double erf(double); }, ENABLE =&gt; &quot;AUTOWRAP&quot;; print &quot;$_ @{[erf($_)]}&quot; for (0..10)'
    </pre>
    <p class="Pp">The excellent
        <span class="Li">&quot;Term::ReadLine::Gnu&quot;</span> implements
        Term::ReadLine using the GNU ReadLine library. Here is an easy way to
        access just <span class="Li">&quot;readline()&quot;</span> from that
        library:</p>
    <p class="Pp"></p>
    <pre>    package MyTerm;
    use Inline C =&gt; Config =&gt;
               ENABLE =&gt; AUTOWRAP =&gt;
               LIBS =&gt; &quot;-lreadline -lncurses -lterminfo -ltermcap &quot;;
    use Inline C =&gt; q{ char * readline(char *); };
    package main;
    my $x = MyTerm::readline(&quot;xyz: &quot;);
    </pre>
    <p class="Pp">Note however that it fails to
        <span class="Li">&quot;free()&quot;</span> the memory returned by
        readline, and that
        <span class="Li">&quot;Term::ReadLine::Gnu&quot;</span> offers a much
        richer interface.</p>
  </dd>
  <dt id="Discussion~12"><a class="permalink" href="#Discussion~12">Discussion</a></dt>
  <dd>We access existing functions by merely showing Inline their declarations,
      rather than a full definition. Of course the function declared must exist,
      either in a library already linked to Perl or in a library specified using
      the <span class="Li">&quot;LIBS&quot;</span> option.
    <p class="Pp">The first example wraps a function from the standard math
        library, so Inline requires no additional
        <span class="Li">&quot;LIBS&quot;</span> directive. The second uses the
        Config option to specify the libraries that contain the actual compiled
        C code.</p>
    <p class="Pp">This behavior is always disabled by default. You must enable
        the <span class="Li">&quot;AUTOWRAP&quot;</span> option to make it
      work.</p>
  </dd>
  <dt id="See~12"><a class="permalink" href="#See~12">See Also</a></dt>
  <dd><span class="Li">&quot;readline&quot;</span>,
      <span class="Li">&quot;Term::ReadLine::Gnu&quot;</span></dd>
  <dt id="Credits~12"><a class="permalink" href="#Credits~12">Credits</a></dt>
  <dd>GNU ReadLine was written by Brian Fox &lt;bfox@ai.mit.edu&gt; and Chet
      Ramey &lt;chet@ins.cwru.edu&gt;. Term::ReadLine::Gnu was written by Hiroo
      Hayashi &lt;hiroo.hayashi@computer.org&gt;. Both are far richer than the
      slim interface given here!
    <p class="Pp">The idea of producing wrapper code given only a function
        declaration is taken from Swig by David M. Beazley
        &lt;beazley@cs.uchicago.edu&gt;.</p>
    <p class="Pp">Ingy's inline editorial insight:</p>
    <p class="Pp">This entire entry was contributed by Ariel Scolnicov
        &lt;ariels@compugen.co.il&gt;. Ariel also first suggested the idea for
        Inline to support function declaration processing.</p>
  </dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Complex_Data"><a class="permalink" href="#Complex_Data">Complex
  Data</a></h2>
<dl class="Bl-tag">
  <dt id="Problem~13"><a class="permalink" href="#Problem~13">Problem</a></dt>
  <dd>How do I deal with complex data types like hashes in Inline C?</dd>
  <dt id="Solution~13"><a class="permalink" href="#Solution~13">Solution</a></dt>
  <dd>
    <pre>    use Inline C =&gt; &lt;&lt;'END_OF_C_CODE';
    void dump_hash(SV* hash_ref) {
        HV* hash;
        HE* hash_entry;
        int num_keys, i;
        SV* sv_key;
        SV* sv_val;
        if (! SvROK(hash_ref))
            croak(&quot;hash_ref is not a reference&quot;);
        hash = (HV*)SvRV(hash_ref);
        num_keys = hv_iterinit(hash);
        for (i = 0; i &lt; num_keys; i++) {
            hash_entry = hv_iternext(hash);
            sv_key = hv_iterkeysv(hash_entry);
            sv_val = hv_iterval(hash, hash_entry);
            printf(&quot;%s =&gt; %s\n&quot;, SvPV(sv_key, PL_na), SvPV(sv_val, PL_na));
        }
        return;
    }
    END_OF_C_CODE
    my %hash = (
                Author =&gt; &quot;Brian Ingerson&quot;,
                Nickname =&gt; &quot;INGY&quot;,
                Module =&gt; &quot;Inline.pm&quot;,
                Version =&gt; &quot;0.30&quot;,
                Language =&gt; &quot;C&quot;,
               );
    dump_hash(\%hash);
    </pre>
  </dd>
  <dt id="Discussion~13"><a class="permalink" href="#Discussion~13">Discussion</a></dt>
  <dd>The world is not made of scalars alone, although they are definitely the
      easiest creatures to deal with, when doing Inline stuff. Sometimes we need
      to deal with arrays, hashes, and code references, among other things.
    <p class="Pp">Since Perl subroutine calls only pass scalars as arguments,
        we'll need to use the argument type
        <span class="Li">&quot;SV*&quot;</span> and pass references to more
        complex types.</p>
    <p class="Pp">The above program dumps the key/value pairs of a hash. To
        figure it out, just curl up with perlapi for a couple hours. Actually,
        its fairly straight forward once you are familiar with the calls.</p>
    <p class="Pp">Note the <span class="Li">&quot;croak&quot;</span> function
        call. This is the proper way to die from your C extensions.</p>
  </dd>
  <dt id="See~13"><a class="permalink" href="#See~13">See Also</a></dt>
  <dd>See perlapi for information about the Perl5 internal API.</dd>
  <dt id="Credits~13"><a class="permalink" href="#Credits~13">Credits</a></dt>
  <dd></dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Hash_of_Lists"><a class="permalink" href="#Hash_of_Lists">Hash
  of Lists</a></h2>
<dl class="Bl-tag">
  <dt id="Problem~14"><a class="permalink" href="#Problem~14">Problem</a></dt>
  <dd>How do I create a Hash of Lists from C?</dd>
  <dt id="Solution~14"><a class="permalink" href="#Solution~14">Solution</a></dt>
  <dd>
    <pre>    use Inline C;
    use Data::Dumper;
    $hash_ref = load_data(&quot;./cartoon.txt&quot;);
    print Dumper $hash_ref;
    __END__
    __C__
    static int next_word(char**, char*);
    SV* load_data(char* file_name) {
        char buffer[100], word[100], * pos;
        AV* array;
        HV* hash = newHV();
        FILE* fh = fopen(file_name, &quot;r&quot;);
        while (fgets(pos = buffer, sizeof(buffer), fh)) {
            if (next_word(&amp;pos, word)) {
                hv_store(hash, word, strlen(word),
                        newRV_noinc((SV*)array = newAV()), 0);
                while (next_word(&amp;pos, word))
                    av_push(array, newSVpvf(&quot;%s&quot;, word));
            }
        }
        fclose(fh);
        return newRV_noinc((SV*) hash);
    }
    static int next_word(char** text_ptr, char* word) {
        char* text = *text_ptr;
        while(*text != '\0' &amp;&amp;
              *text &lt;= ' ')
            text++;
        if (*text &lt;= ' ')
            return 0;
        while(*text != '\0' &amp;&amp;
              *text &gt; ' ') {
            *word++ = *text++;
        }
        *word = '\0';
        *text_ptr = text;
        return 1;
    }
    </pre>
  </dd>
  <dt id="Discussion~14"><a class="permalink" href="#Discussion~14">Discussion</a></dt>
  <dd>This is one of the larger recipes. But when you consider the number of
      calories it has, it's not so bad. The function
      <span class="Li">&quot;load_data&quot;</span> takes the name of a file as
      it's input. The file <span class="Li">&quot;cartoon.text&quot;</span>
      might look like:
    <p class="Pp"></p>
    <pre>    flintstones fred barney
    jetsons     george jane elroy
    simpsons    homer marge bart
    </pre>
    <p class="Pp">The function will read the file, parsing each line into words.
        Then it will create a new hash, whereby the first word in a line becomes
        a hash key and the remaining words are put into an array whose reference
        becomes the hash value. The output looks like this:</p>
    <p class="Pp"></p>
    <pre>    $VAR1 = {
              'flintstones' =&gt; [
                                 'fred',
                                 'barney'
                               ],
              'simpsons' =&gt; [
                              'homer',
                              'marge',
                              'bart'
                            ],
              'jetsons' =&gt; [
                             'george',
                             'jane',
                             'elroy'
                           ]
            };
    </pre>
  </dd>
  <dt id="See~14"><a class="permalink" href="#See~14">See Also</a></dt>
  <dd>See perlapi for information about the Perl5 internal API.</dd>
  <dt id="Credits~14"><a class="permalink" href="#Credits~14">Credits</a></dt>
  <dd>Al Danial &lt;alnd@pacbell.net&gt; requested a solution to this on
      comp.lang.perl.misc. He borrowed the idea from the &quot;Hash of
      Lists&quot; example in the Camel book.</dd>
</dl>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="Just_Desserts"><a class="permalink" href="#Just_Desserts">Just
  Desserts</a></h1>
<section class="Ss">
<h2 class="Ss" id="Win32"><a class="permalink" href="#Win32">Win32</a></h2>
<dl class="Bl-tag">
  <dt id="Problem~15"><a class="permalink" href="#Problem~15">Problem</a></dt>
  <dd>How do I access Win32 DLL-s using Inline?</dd>
  <dt id="Solution~15"><a class="permalink" href="#Solution~15">Solution</a></dt>
  <dd>
    <pre>    use Inline C =&gt; DATA =&gt;
               LIBS =&gt; '-luser32';
    $text = &quot;@ARGV&quot; || 'Inline.pm works with MSWin32. Scary...';
    WinBox('Inline Text Box', $text);
    __END__
    __C__
    #include &lt;windows.h&gt;
    int WinBox(char* Caption, char* Text) {
      return MessageBoxA(0, Text, Caption, 0);
    }
    </pre>
  </dd>
  <dt id="Discussion~15"><a class="permalink" href="#Discussion~15">Discussion</a></dt>
  <dd>This example runs on MS Windows. It makes a text box appear on the screen
      which contains a message of your choice.
    <p class="Pp">The important thing is that its proof that you can use Inline
        to interact with Windows DLL-s. Very scary indeed. 8-o</p>
    <p class="Pp">To use Inline on Windows with ActivePerl (
        http://www.ActiveState.com ) you'll need MS Visual Studio. You can also
        use the Cygwin environment, available at http://www.cygwin.com .</p>
  </dd>
  <dt id="See~15"><a class="permalink" href="#See~15">See Also</a></dt>
  <dd>See Inline-Support for more info on MSWin32 programming with Inline.</dd>
  <dt id="Credits~15"><a class="permalink" href="#Credits~15">Credits</a></dt>
  <dd>This example was adapted from some sample code written by Garrett Goebel
      &lt;garrett@scriptpro.com&gt;</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Embedding_Perl_in_C"><a class="permalink" href="#Embedding_Perl_in_C">Embedding
  Perl in C</a></h2>
<dl class="Bl-tag">
  <dt id="Problem~16"><a class="permalink" href="#Problem~16">Problem</a></dt>
  <dd>How do I use Perl from a regular C program?</dd>
  <dt id="Solution~16"><a class="permalink" href="#Solution~16">Solution</a></dt>
  <dd>
    <pre>    #!/usr/bin/cpr
    int main(void) {
        printf(&quot;Using Perl version %s from a C program!\n\n&quot;,
               CPR_eval(&quot;use Config; $Config{version};&quot;));
        CPR_eval(&quot;use Data::Dumper;&quot;);
        CPR_eval(&quot;print Dumper \\%INC;&quot;);
        return 0;
    }
    </pre>
  </dd>
  <dt id="Discussion~16"><a class="permalink" href="#Discussion~16">Discussion</a></dt>
  <dd>By using CPR. (C Perl Run)
    <p class="Pp">This example uses another Inline module,
        <span class="Li">&quot;Inline::CPR&quot;</span>, available separately on
        CPAN. When you install this module it also installs a binary interpreter
        called <span class="Li">&quot;/usr/bin/cpr&quot;</span>. (The path may
        be different on your system)</p>
    <p class="Pp">When you feed a C program to the CPR interpreter, it
        automatically compiles and runs your code using Inline. This gives you
        full access to the Perl internals. CPR also provides a set of easy to
        use C macros for calling Perl internals.</p>
    <p class="Pp">This means that you can effectively &quot;run&quot; C source
        code by putting a CPR hashbang as the first line of your C program.</p>
  </dd>
  <dt id="See~16"><a class="permalink" href="#See~16">See Also</a></dt>
  <dd>See Inline::CPR for more information on using CPR.
    <p class="Pp"><span class="Li">&quot;Inline::CPR&quot;</span> can be
        obtained from http://search.cpan.org/search?dist=Inline-CPR</p>
  </dd>
  <dt id="Credits~16"><a class="permalink" href="#Credits~16">Credits</a></dt>
  <dd>Randal Schwartz &lt;merlyn@stonehenge.com&gt;, Randolph Bentson
      &lt;bentson@grieg.holmsjoen.com&gt;, Richard Anderson
      &lt;starfire@zipcon.net&gt;, and Tim Maher &lt;tim@consultix-inc.com&gt;
      helped me figure out how to write a program that would work as a
    hashbang.</dd>
</dl>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="Entertaining_Guests"><a class="permalink" href="#Entertaining_Guests">Entertaining
  Guests</a></h1>
<p class="Pp">As of version 0.30, Inline has the ability to work in cooperation
    with other modules that want to expose a C API of their own. The general
    syntax for doing this is:</p>
<p class="Pp"></p>
<pre>    use Inline with =&gt; 'Module';
    use Inline C =&gt; ... ;
</pre>
<p class="Pp">This tells <span class="Li">&quot;Module&quot;</span> to pass
    configuration options to Inline. Options like typemaps, include paths, and
    external libraries, are all resolved automatically so you can just
    concentrate on writing the functions.</p>
<section class="Ss">
<h2 class="Ss" id="Event_handling_with_Event.pm"><a class="permalink" href="#Event_handling_with_Event.pm">Event
  handling with Event.pm</a></h2>
<dl class="Bl-tag">
  <dt id="Problem~17"><a class="permalink" href="#Problem~17">Problem</a></dt>
  <dd>You need to write a C callback for the
      <span class="Li">&quot;Event.pm&quot;</span> module. Can this be done more
      easily with Inline?</dd>
  <dt id="Solution~17"><a class="permalink" href="#Solution~17">Solution</a></dt>
  <dd>
    <pre>    use Inline with =&gt; 'Event';
    Event-&gt;timer(desc     =&gt; 'Timer #1',
                 interval =&gt; 2,
                 cb       =&gt; \&amp;my_callback,
                );
    Event-&gt;timer(desc     =&gt; 'Timer #2',
                 interval =&gt; 3,
                 cb       =&gt; \&amp;my_callback,
                );
    print &quot;Starting...\n&quot;;
    Event::loop;
    use Inline C =&gt; &lt;&lt;'END';
    void my_callback(pe_event* event) {
        pe_timer * watcher = event-&gt;up;
        printf(&quot;%s\n\tEvent priority = %d\n\tWatcher priority = %d\n\n&quot;,
               SvPVX(watcher-&gt;base.desc),
               event-&gt;prio,
               watcher-&gt;base.prio
              );
    }
    END
    </pre>
  </dd>
  <dt id="Discussion~17"><a class="permalink" href="#Discussion~17">Discussion</a></dt>
  <dd>The first line tells Inline to load the
      <span class="Li">&quot;Event.pm&quot;</span> module. Inline then queries
      <span class="Li">&quot;Event&quot;</span> for configuration information.
      It gets the name and location of Event's header files, typemaps and shared
      objects. The parameters that <span class="Li">&quot;Event&quot;</span>
      returns look like:
    <p class="Pp"></p>
    <pre>    INC =&gt; &quot;-I $path/Event&quot;,
    TYPEMAPS =&gt; &quot;$path/Event/typemap&quot;,
    MYEXTLIB =&gt; &quot;$path/auto/Event/Event.$so&quot;,
    AUTO_INCLUDE =&gt; '#include &quot;EventAPI.h&quot;',
    BOOT =&gt; 'I_EVENT_API(&quot;Inline&quot;);',
    </pre>
    <p class="Pp">Doing all of this automatically allows you, the programmer, to
        simply write a function that receives a pointer of type
        <span class="Li">'pe_event*'</span>. This gives you access to the
        <span class="Li">&quot;Event&quot;</span> structure that was passed to
        you.</p>
    <p class="Pp">In this example, I simply print values out of the structure.
        The Perl code defines 2 timer events which each invoke the same
        callback. The first one, every two seconds, and the second one, every
        three seconds.</p>
    <p class="Pp">As of this writing,
        <span class="Li">&quot;Event.pm&quot;</span> is the only CPAN module
        that works in cooperation with Inline.</p>
  </dd>
  <dt id="See~17"><a class="permalink" href="#See~17">See Also</a></dt>
  <dd>Read the <span class="Li">&quot;Event.pm&quot;</span> documentation for
      more information. It contains a tutorial showing several examples of using
      Inline with <span class="Li">&quot;Event&quot;</span>.</dd>
  <dt id="Credits~17"><a class="permalink" href="#Credits~17">Credits</a></dt>
  <dd>Jochen Stenzel &lt;perl@jochen-stenzel.de&gt; originally came up with the
      idea of mixing Inline and <span class="Li">&quot;Event&quot;</span>. He
      also authored the <span class="Li">&quot;Event&quot;</span> tutorial.
    <p class="Pp">Joshua Pritikin &lt;joshua.pritikin@db.com&gt; is the author
        of <span class="Li">&quot;Event.pm&quot;</span>.</p>
  </dd>
</dl>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="Food_for_Thought"><a class="permalink" href="#Food_for_Thought">Food
  for Thought</a></h1>
<section class="Ss">
<h2 class="Ss" id="Calling_C_from_both_Perl_and_C"><a class="permalink" href="#Calling_C_from_both_Perl_and_C">Calling
  C from both Perl and C</a></h2>
<dl class="Bl-tag">
  <dt id="Problem~18"><a class="permalink" href="#Problem~18">Problem</a></dt>
  <dd>I'd like to be able to call the same C function from both Perl and C. Also
      I like to define a C function that <b>doesn't</b> get bound to Perl. How
      do I do that?</dd>
  <dt id="Solution~18"><a class="permalink" href="#Solution~18">Solution</a></dt>
  <dd>
    <pre>    print &quot;9 + 5 = &quot;, add(9, 5), &quot;\n&quot;;
    print &quot;SQRT(9^2 + 5^2) = &quot;, pyth(9, 5), &quot;\n&quot;;
    print &quot;9 * 5 = &quot;, mult(9, 5), &quot;\n&quot;;
    use Inline C =&gt; &lt;&lt;'END_C';
    int add(int x, int y) {
        return x + y;
    }
    static int mult(int x, int y) {
        return x * y;
    }
    double pyth(int x, int y) {
        return sqrt(add(mult(x, x), mult(y, y)));
    }
    END_C
    </pre>
  </dd>
  <dt id="Discussion~18"><a class="permalink" href="#Discussion~18">Discussion</a></dt>
  <dd>The program produces:
    <p class="Pp"></p>
    <pre>    9 + 5 = 14
    SQRT(9^2 + 5^2) = 10.295630140987
    Can't locate auto/main/mult.al in @INC ...
    </pre>
    <p class="Pp">Every Inline function that is bound to Perl is also callable
        by C. You don't have to do anything special. Inline arranges it so that
        all the typemap code gets done by XS and is out of sight. By the time
        the C function receives control, everything has been converted from Perl
        to C.</p>
    <p class="Pp">Of course if your function manipulates the Perl Stack, you
        probably don't want to call it from C (unless you <i>really</i> know
        what you're doing).</p>
    <p class="Pp">If you declare a function as
        <span class="Li">&quot;static&quot;</span>, Inline won't bind it to
        Perl. That's why we were able to call
        <span class="Li">&quot;mult()&quot;</span> from C but the call failed
        from Perl.</p>
  </dd>
  <dt id="See~18"><a class="permalink" href="#See~18">See Also</a></dt>
  <dd></dd>
  <dt id="Credits~18"><a class="permalink" href="#Credits~18">Credits</a></dt>
  <dd></dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Calling_Perl_from_C"><a class="permalink" href="#Calling_Perl_from_C">Calling
  Perl from C</a></h2>
<dl class="Bl-tag">
  <dt id="Problem~19"><a class="permalink" href="#Problem~19">Problem</a></dt>
  <dd>So now that I can call C from Perl, how do I call a Perl subroutine from
      an Inline C function.</dd>
  <dt id="Solution~19"><a class="permalink" href="#Solution~19">Solution</a></dt>
  <dd>
    <pre>    use Inline C;
    for(1..5) {
       c_func_1('This is the first line');
       c_func_2('This is the second line');
       print &quot;\n&quot;;
    }
    sub perl_sub_1 {
        print map &quot;$_\n&quot;, @_;
    }
    __DATA__
    __C__
    void c_func_2(SV* text) {
         dSP;
         ENTER;
         SAVETMPS;
         XPUSHs(sv_2mortal(newSVpvf(&quot;Plus an extra line&quot;)));
         PUTBACK;
         call_pv(&quot;perl_sub_1&quot;, G_DISCARD);
         FREETMPS;
         LEAVE;
    }
    void c_func_1(SV* text) {
         c_func_2(text);
    }
    </pre>
  </dd>
  <dt id="Discussion~19"><a class="permalink" href="#Discussion~19">Discussion</a></dt>
  <dd>This demo previously made use of Inline Stack macros only - but that's not
      the correct way to do it. Instead, base the callbacks on the perlcall
      documentation (as we're now doing).
    <p class="Pp">Actually, this program demonstrates calling a C function which
        calls another C function which in turn calls a Perl subroutine.</p>
    <p class="Pp">The nice thing about Inline C functions is that you can call
        them from both Perl-space <b>and</b> C-space. That's because Inline
        creates a wrapper function around each C function. When you use Perl to
        call C you're actually calling that function's wrapper. The wrapper
        handles typemapping and Stack management, and then calls your C
        function.</p>
    <p class="Pp">The first time we call
        <span class="Li">&quot;c_func_1&quot;</span> which calls
        <span class="Li">&quot;c_func_2&quot;</span>. The second time we call
        <span class="Li">&quot;c_func_2&quot;</span> directly.
        <span class="Li">&quot;c_func_2&quot;</span> calls the Perl subroutine
        (<span class="Li">&quot;perl_sub_1&quot;</span>) using the internal
        <span class="Li">&quot;perl_call_pv&quot;</span> function. It has to put
        arguments on the stack by hand. Since there is already one argument on
        the stack when we enter the function, the
        <span class="Li">&quot;XPUSHs&quot;</span> ( which is equivalent to an
        <span class="Li">&quot;Inline_Stack_Push&quot;</span> ) adds a second
        argument.</p>
    <p class="Pp">We iterate through a 'for' loop 5 times just to demonstrate
        that things still work correctly when we do that. (This was where the
        previous rendition, making use solely of Inline Stack macros, fell
        down.)</p>
  </dd>
  <dt id="See~19"><a class="permalink" href="#See~19">See Also</a></dt>
  <dd>See Inline::C for more information about Stack macros.
    <p class="Pp">See perlapi for more information about the Perl5 internal
      API.</p>
  </dd>
  <dt id="Credits~19"><a class="permalink" href="#Credits~19">Credits</a></dt>
  <dd></dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Evaling_C"><a class="permalink" href="#Evaling_C">Evaling
  C</a></h2>
<dl class="Bl-tag">
  <dt id="Problem~20"><a class="permalink" href="#Problem~20">Problem</a></dt>
  <dd>I've totally lost my marbles and I want to generate C code at run time,
      and <span class="Li">&quot;eval&quot;</span> it into Perl. How do I do
      this?</dd>
  <dt id="Solution~20"><a class="permalink" href="#Solution~20">Solution</a></dt>
  <dd>
    <pre>    use Inline;
    use Code::Generator;
    my $c_code = generate('foo_function');
    Inline-&gt;bind(C =&gt; $c_code);
    foo_function(1, 2, 3);
    </pre>
  </dd>
  <dt id="Discussion~20"><a class="permalink" href="#Discussion~20">Discussion</a></dt>
  <dd>I can't think of a real life application where you would want to generate
      C code on the fly, but at least I know how I would do it. :)
    <p class="Pp">The <span class="Li">&quot;bind()&quot;</span> function of
        Inline let's you bind (compile/load/execute) C functions at run time. It
        takes all of the same arguments as 'use Inline C =&gt; ...'.</p>
    <p class="Pp">The nice thing is that once a particular snippet is compiled,
        it remains cached so that it doesn't need to be compiled again. I can
        imagine that someday a mad scientist will dream up a self generating
        modeling system that would run faster and faster over time.</p>
    <p class="Pp">If you know such a person, have them drop me a line.</p>
  </dd>
  <dt id="See~20"><a class="permalink" href="#See~20">See Also</a></dt>
  <dd></dd>
  <dt id="Credits~20"><a class="permalink" href="#Credits~20">Credits</a></dt>
  <dd></dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Providing_a_pure_perl_alternative"><a class="permalink" href="#Providing_a_pure_perl_alternative">Providing
  a pure perl alternative</a></h2>
<dl class="Bl-tag">
  <dt id="Problem~21"><a class="permalink" href="#Problem~21">Problem</a></dt>
  <dd>I want to write a script that will use a C subroutine if Inline::C is
      installed, but will otherwise use an equivalent pure perl subroutine if
      Inline::C is not already installed. How do I do this?</dd>
  <dt id="Solution~21"><a class="permalink" href="#Solution~21">Solution</a></dt>
  <dd>
    <pre>  use strict;
   use warnings;
  eval {
   require Inline;
   Inline-&gt;import (C =&gt; Config =&gt;
                   BUILD_NOISY =&gt; 1);
   Inline-&gt;import (C =&gt;&lt;&lt;'EOC');
   int foo() {
     warn(&quot;Using Inline\n&quot;);
     return 42;
   }
  EOC
  };
  if($@) {
    *foo =\&amp;bar;
  }
  sub bar {
    warn(&quot;Using Pure Perl Implementation\n&quot;);
    return 42;
  }
  my $x = foo();
  print &quot;$x\n&quot;;
    </pre>
  </dd>
  <dt id="Discussion~21"><a class="permalink" href="#Discussion~21">Discussion</a></dt>
  <dd>If Inline::C is installed and functioning properly, the C sub foo is
      called by the perl code. Otherwise, $@ gets set, and the equivalent pure
      perl function bar is instead called.
    <p class="Pp">Note, too, that the pure perl sub bar can still be explicitly
        called even if Inline::C is available.</p>
  </dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Accessing_Fortran_subs_using_Inline::C"><a class="permalink" href="#Accessing_Fortran_subs_using_Inline::C">Accessing
  Fortran subs using Inline::C</a></h2>
<dl class="Bl-tag">
  <dt id="Problem~22"><a class="permalink" href="#Problem~22">Problem</a></dt>
  <dd>I've been given a neat little sub written in fortran that takes, as its
      args, two integers and returns their product. And I would like to use that
      sub as is from Inline::C. By way of example, let's say that the fortran
      source file is named 'prod.f', and that it looks like this:
    <p class="Pp"></p>
    <pre>      integer function sqarea(r,s)
      integer r, s
      sqarea = r*s
      return
      end
    </pre>
  </dd>
  <dt id="Solution~22"><a class="permalink" href="#Solution~22">Solution</a></dt>
  <dd>We can't access that code directly, but we can compile it into a library
      which we *can* then access from Inline::C. Using gcc we could run:
    <p class="Pp"></p>
    <pre>  gfortran -c prod.f -o prod.o
  ar cru libprod.a prod.o
    </pre>
    <p class="Pp">The function is then accessible as follows:</p>
    <p class="Pp"></p>
    <pre>  use warnings;
  use Inline C =&gt; Config =&gt;
    LIBS =&gt;
     '-L/full/path/to/libprod_location -lprod -lgfortran';
  use Inline C =&gt; &lt;&lt;'  EOC';
  int wrap_sqarea(int a, int b) {
      return sqarea_(&amp;a, &amp;b);
  }
  EOC
  $x = 15;
  $y = $x + 3;
  $ret = wrap_sqarea($x, $y);
  print &quot;Product of $x and $y is $ret\n&quot;;
    </pre>
  </dd>
  <dt id="Discussion~22"><a class="permalink" href="#Discussion~22">Discussion</a></dt>
  <dd>Note firstly that, although the function is specified as 'sqarea' in the
      source file, gfortran appends an underscore to the name when the source is
      compiled. (I don't know if *all* fortran compilers do this.) Therefore
      Inline::C needs to call the function as 'sqarea_'.
    <p class="Pp">Secondly, because fortran subs pass args by reference, we need
        to pass the *addresses* of the two integer args to <i>sqarea()</i> when
        we call it from our Inline::C sub.</p>
    <p class="Pp">If using g77 instead of gfortran, the only necessary change is
        that we specify '-lg2c' instead of '-lgfortran' in our 'LIBS'
      setting.</p>
  </dd>
</dl>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp">For generic information about Inline, see Inline.</p>
<p class="Pp">For information about using Inline with C see Inline::C.</p>
<p class="Pp">For information on supported languages and platforms see
    Inline-Support.</p>
<p class="Pp">For information on writing your own Inline language support
    module, see Inline-API.</p>
<p class="Pp">Inline's mailing list is inline@perl.org</p>
<p class="Pp">To subscribe, send email to inline-subscribe@perl.org</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">Brian Ingerson &lt;INGY@cpan.org&gt;</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT"><a class="permalink" href="#COPYRIGHT">COPYRIGHT</a></h1>
<p class="Pp">Copyright (c) 2001, 2002. Brian Ingerson.</p>
<p class="Pp">Copyright (c) 2008, 2010-2013. Sisyphus.</p>
<p class="Pp">All Rights Reserved. This module is free software. It may be used,
    redistributed and/or modified under the terms of the Perl Artistic
  License.</p>
<p class="Pp">See http://www.perl.com/perl/misc/Artistic.html</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2013-03-06</td>
    <td class="foot-os">perl v5.18.4</td>
  </tr>
</table>
</body>
</html>
