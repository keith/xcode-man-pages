<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    .Nd, .Bf, .Op { display: inline; }
    .Pa, .Ad { font-style: italic; }
    .Ms { font-weight: bold; }
    .Bl-diag > dt { font-weight: bold; }
    code.Nm, .Fl, .Cm, .Ic, code.In, .Fd, .Fn, .Cd { font-weight: bold;
      font-family: inherit; }
  </style>
  <title>Inline::C(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Inline::C(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Inline::C(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Inline::C - C Language Support for Inline</p>
</section>
<section class="Sh">
<h1 class="Sh" id="VERSION"><a class="permalink" href="#VERSION">VERSION</a></h1>
<p class="Pp">This document describes Inline::C version <b>0.81</b>.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp"><span class="Li">&quot;Inline::C&quot;</span> is a module that
    allows you to write Perl subroutines in C. Since version 0.30 the Inline
    module supports multiple programming languages and each language has its own
    support module. This document describes how to use Inline with the C
    programming language. It also goes a bit into Perl C internals.</p>
<p class="Pp">If you want to start working with programming examples right away,
    check out Inline::C::Cookbook. For more information on Inline in general,
    see Inline.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="USAGE"><a class="permalink" href="#USAGE">USAGE</a></h1>
<p class="Pp">You never actually use
    <span class="Li">&quot;Inline::C&quot;</span> directly. It is just a support
    module for using <span class="Li">&quot;Inline.pm&quot;</span> with C. So
    the usage is always:</p>
<p class="Pp"></p>
<pre>    use Inline C =&gt; ...;
</pre>
<p class="Pp">or</p>
<p class="Pp"></p>
<pre>    bind Inline C =&gt; ...;
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="FUNCTION_DEFINITIONS"><a class="permalink" href="#FUNCTION_DEFINITIONS">FUNCTION
  DEFINITIONS</a></h1>
<p class="Pp">The Inline grammar for C recognizes certain function definitions
    (or signatures) in your C code. If a signature is recognized by Inline, then
    it will be available in Perl-space. That is, Inline will generate the
    &quot;glue&quot; necessary to call that function as if it were a Perl
    subroutine. If the signature is not recognized, Inline will simply ignore
    it, with no complaints. It will not be available from Perl-space, although
    it <i>will</i> be available from C-space.</p>
<p class="Pp">Inline looks for ANSI/prototype style function definitions. They
    must be of the form:</p>
<p class="Pp"></p>
<pre>    return-type function-name ( type-name-pairs ) { ... }
</pre>
<p class="Pp">The most common types are:
    <span class="Li">&quot;int&quot;</span>,
    <span class="Li">&quot;long&quot;</span>,
    <span class="Li">&quot;double&quot;</span>,
    <span class="Li">&quot;char*&quot;</span>, and
    <span class="Li">&quot;SV*&quot;</span>. But you can use any type for which
    Inline can find a typemap. Inline uses the
    <span class="Li">&quot;typemap&quot;</span> file distributed with Perl as
    the default. You can specify more typemaps with the
    <span class="Li">&quot;typemaps&quot;</span> configuration option.</p>
<p class="Pp">A return type of <span class="Li">&quot;void&quot;</span> may also
    be used. The following are examples of valid function definitions.</p>
<p class="Pp"></p>
<pre>    int Foo(double num, char* str) {
    void Foo(double num, char* str) {
    void Foo(SV*, ...) {
    long Foo(int i, int j, ...) {
    SV* Foo(void) { # 'void' arg invalid with the ParseRecDescent parser.
                    # Works only with the ParseRegExp parser.
                    # See the section on `using` (below).
    SV* Foo() {  # Alternative to specifying 'void' arg. Is valid with
                 # both the ParseRecDescent and ParseRegExp parsers.
</pre>
<p class="Pp">The following definitions would not be recognized:</p>
<p class="Pp"></p>
<pre>    Foo(int i) {               # no return type
    int Foo(float f) {         # no (default) typemap for float
    int Foo(num, str) double num; char* str; {
</pre>
<p class="Pp">Notice that Inline only looks for function <i>definitions</i>, not
    function <i>prototypes</i>. Definitions are the syntax directly preceding a
    function body. Also Inline does not scan external files, like headers. Only
    the code passed to Inline is used to create bindings; although other
    libraries can linked in, and called from C-space.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="C_CONFIGURATION_OPTIONS"><a class="permalink" href="#C_CONFIGURATION_OPTIONS">C
  CONFIGURATION OPTIONS</a></h1>
<p class="Pp">For information on how to specify Inline configuration options,
    see Inline. This section describes each of the configuration options
    available for C. Most of the options correspond either to MakeMaker or XS
    options of the same name. See ExtUtils::MakeMaker and perlxs.</p>
<dl class="Bl-tag">
  <dt>&quot;auto_include&quot;</dt>
  <dd>Specifies extra statements to automatically included. They will be added
      onto the defaults. A newline char will be automatically added.
    <p class="Pp"></p>
    <pre>    use Inline C =&gt; config =&gt; auto_include =&gt; '#include &quot;yourheader.h&quot;';
    </pre>
  </dd>
  <dt>&quot;autowrap&quot;</dt>
  <dd>If you <span class="Li">&quot;enable =&gt; autowrap&quot;</span>,
      Inline::C will parse function declarations (prototype statements) in your
      C code. For each declaration it can bind to, it will create a dummy
      wrapper that will call the real function which may be in an external
      library. This is a nice convenience for functions that would otherwise
      just require an empty wrapper function.
    <p class="Pp">This is similar to the base functionality you get from
        <span class="Li">&quot;h2xs&quot;</span>. It can be very useful for
        binding to external libraries.</p>
  </dd>
  <dt>&quot;boot&quot;</dt>
  <dd>Specifies C code to be executed in the XS
      <span class="Li">&quot;BOOT&quot;</span> section. Corresponds to the XS
      parameter.</dd>
  <dt>&quot;cc&quot;</dt>
  <dd>Specify which compiler to use.</dd>
  <dt>&quot;ccflags&quot;</dt>
  <dd>Specify compiler flags - same as ExtUtils::MakeMaker's
      <span class="Li">&quot;CCFLAGS&quot;</span> option. Whatever gets
      specified here replaces the default
      <span class="Li">$Config{ccflags}</span>. Often, you'll want to add an
      extra flag or two without clobbering the default flags in which case you
      could instead use <span class="Li">&quot;ccflagsex&quot;</span> (see
      below) or, if Config.pm has already been loaded:
    <p class="Pp"></p>
    <pre>    use Inline C =&gt; Config =&gt; ccflags =&gt; $Config{ccflags} . &quot; -DXTRA -DTOO&quot;;
    </pre>
  </dd>
  <dt>&quot;ccflagsex&quot;</dt>
  <dd>Extend compiler flags. Sets <span class="Li">&quot;CCFLAGS&quot;</span> to
      <span class="Li">$Config</span>{ccflags} followed by a space, followed by
      the specified value:
    <p class="Pp"></p>
    <pre>    use Inline C =&gt; config =&gt; ccflagsex =&gt; &quot;-DXTRA -DTOO&quot;;
    </pre>
  </dd>
  <dt>&quot;cppflags&quot;</dt>
  <dd></dd>
</dl>
<p class="Pp">Specify preprocessor flags. Passed to
    <span class="Li">&quot;cpp&quot;</span> C preprocessor by
    <span class="Li">&quot;Preprocess()&quot;</span> in Inline::Filters.</p>
<p class="Pp"></p>
<pre>    use Inline C =&gt; &lt;&lt;'END',
        CPPFLAGS =&gt; ' -DPREPROCESSOR_DEFINE',
        FILTERS =&gt; 'Preprocess';
    use Inline C =&gt; &lt;&lt;'END',
        CPPFLAGS =&gt; ' -DPREPROCESSOR_DEFINE=4321',
        FILTERS =&gt; 'Preprocess';
</pre>
<dl class="Bl-tag">
  <dt>&quot;filters&quot;</dt>
  <dd>Allows you to specify a list of source code filters. If more than one is
      requested, be sure to group them with an array ref. The filters can either
      be subroutine references or names of filters provided by the supplementary
      Inline::Filters module.
    <p class="Pp">Your source code will be filtered just before it is parsed by
        Inline. The MD5 fingerprint is generated before filtering. Source code
        filters can be used to do things like stripping out POD documentation,
        pre-expanding <span class="Li">&quot;#include&quot;</span> statements or
        whatever else you please. For example:</p>
    <p class="Pp"></p>
    <pre>    use Inline C =&gt; DATA =&gt;
               filters =&gt; [Strip_POD =&gt; \&amp;MyFilter =&gt; Preprocess ];
    </pre>
    <p class="Pp">Filters are invoked in the order specified. See
        Inline::Filters for more information.</p>
    <p class="Pp">If a filter is an array reference, it is assumed to be a usage
        of a filter plug- in named by the first element of that array reference.
        The rest of the elements of the array reference are used as arguments to
        the filter. For example, consider a
        <span class="Li">&quot;filters&quot;</span> parameter like this:</p>
    <p class="Pp"></p>
    <pre>    use Inline C =&gt; DATA =&gt; filters =&gt; [ [ Ragel =&gt; '-G2' ] ];
    </pre>
    <p class="Pp">In order for Inline::C to process this filter, it will attempt
        to require the module Inline::Filters::Ragel and will then call the
        <span class="Li">&quot;filter&quot;</span> function in that package with
        the argument <span class="Li">'-G2'</span>. This function will return
        the actual filtering function.</p>
  </dd>
  <dt>&quot;inc&quot;</dt>
  <dd>Specifies an include path to use. Corresponds to the MakeMaker parameter.
      Expects a fully qualified path.
    <p class="Pp"></p>
    <pre>    use Inline C =&gt; config =&gt; inc =&gt; '-I/inc/path';
    </pre>
  </dd>
  <dt>&quot;ld&quot;</dt>
  <dd>Specify which linker to use.</dd>
  <dt>&quot;lddlflags&quot;</dt>
  <dd>Specify which linker flags to use.
    <p class="Pp">NOTE: These flags will completely override the existing flags,
        instead of
      <br/>
       just adding to them. So if you need to use those too, you must
      <br/>
       respecify them here.</p>
  </dd>
  <dt>&quot;libs&quot;</dt>
  <dd>Specifies external libraries that should be linked into your code.
      Corresponds to the MakeMaker parameter. Provide a fully qualified path
      with the <span class="Li">&quot;-L&quot;</span> switch if the library is
      in a location where it won't be found automatically.
    <p class="Pp"></p>
    <pre>    use Inline C =&gt; config =&gt; libs =&gt; '-lyourlib';
    </pre>
    <p class="Pp">or</p>
    <p class="Pp"></p>
    <pre>    use Inline C =&gt; config =&gt; libs =&gt; '-L/your/path -lyourlib';
    </pre>
  </dd>
  <dt>&quot;make&quot;</dt>
  <dd>Specify the name of the 'make' utility to use.</dd>
  <dt>&quot;myextlib&quot;</dt>
  <dd>Specifies a user compiled object that should be linked in. Corresponds to
      the MakeMaker parameter. Expects a fully qualified path.
    <p class="Pp"></p>
    <pre>    use Inline C =&gt; config =&gt; myextlib =&gt; '/your/path/yourmodule.so';
    </pre>
  </dd>
  <dt>&quot;optimize&quot;</dt>
  <dd>This controls the MakeMaker <span class="Li">&quot;OPTIMIZE&quot;</span>
      setting. By setting this value to <span class="Li">'-g'</span>, you can
      turn on debugging support for your Inline extensions. This will allow you
      to be able to set breakpoints in your C code using a debugger like
    gdb.</dd>
  <dt>&quot;prefix&quot;</dt>
  <dd>Specifies a prefix that will be automatically stripped from C functions
      when they are bound to Perl. Useful for creating wrappers for shared
      library API-s, and binding to the original names in Perl. Also useful when
      names conflict with Perl internals. Corresponds to the XS parameter.
    <p class="Pp"></p>
    <pre>    use Inline C =&gt; config =&gt; prefix =&gt; 'ZLIB_';
    </pre>
  </dd>
  <dt>&quot;pre_head&quot;</dt>
  <dd>Specifies code that will precede the inclusion of all files specified in
      <span class="Li">&quot;auto_include&quot;</span> (ie
      <span class="Li">&quot;EXTERN.h&quot;</span>,
      <span class="Li">&quot;perl.h&quot;</span>,
      <span class="Li">&quot;XSUB.h&quot;</span>,
      <span class="Li">&quot;INLINE.h&quot;</span> and anything else that might
      have been added to <span class="Li">&quot;auto_include&quot;</span> by the
      user). If the specified value identifies a file, the contents of that file
      will be inserted, otherwise the specified value is inserted.
    <p class="Pp"></p>
    <pre>    use Inline C =&gt; config =&gt; pre_head =&gt; $code_or_filename;
    </pre>
  </dd>
  <dt>&quot;prototype&quot;</dt>
  <dd>Corresponds to the XS keyword 'PROTOTYPE'. See the perlxs documentation
      for both 'PROTOTYPES' and 'PROTOTYPE'. As an example, the following will
      set the PROTOTYPE of the 'foo' function to '$', and disable prototyping
      for the 'bar' function.
    <p class="Pp"></p>
    <pre>    use Inline C =&gt; config =&gt; prototype =&gt; {foo =&gt; '$', bar =&gt; 'DISABLE'}
    </pre>
  </dd>
  <dt>&quot;prototypes&quot;</dt>
  <dd>Corresponds to the XS keyword 'PROTOTYPES'. Can take only values of
      'ENABLE' or 'DISABLE'. (Contrary to XS, default value is 'DISABLE'). See
      the perlxs documentation for both 'PROTOTYPES' and 'PROTOTYPE'.
    <p class="Pp"></p>
    <pre>    use Inline C =&gt; config =&gt; prototypes =&gt; 'ENABLE';
    </pre>
  </dd>
  <dt>&quot;typemaps&quot;</dt>
  <dd>Specifies extra typemap files to use. These types will modify the
      behaviour of the C parsing. Corresponds to the MakeMaker parameter.
      Specify either a fully qualified path or a path relative to the cwd (ie
      relative to what the cwd is at the time the script is loaded).
    <p class="Pp"></p>
    <pre>    use Inline C =&gt; config =&gt; typemaps =&gt; '/your/path/typemap';
    </pre>
  </dd>
  <dt>&quot;using&quot;</dt>
  <dd>Specifies which parser to use. The default is
      Inline::C::Parser::RecDescent, which uses the Parse::RecDescent module.
    <p class="Pp">The other options are
        <span class="Li">&quot;::Parser::Pegex&quot;</span> and
        <span class="Li">&quot;::Parser::RegExp&quot;</span>, which uses the
        Inline::C::Parser::Pegex and Inline::C::Parser::RegExp modules that ship
        with Inline::C.</p>
    <p class="Pp"></p>
    <pre>    use Inline C =&gt; config =&gt; using =&gt; '::Parser::Pegex';
    </pre>
    <p class="Pp">Note that the following old options are deprecated, but still
        work at this time:</p>
  </dd>
</dl>
<div class="Bd-indent">
<ul class="Bl-bullet">
  <li><span class="Li">&quot;ParseRecDescent&quot;</span></li>
  <li><span class="Li">&quot;ParseRegExp&quot;</span></li>
  <li><span class="Li">&quot;ParsePegex&quot;</span></li>
</ul>
</div>
<div class="Bd-indent"></div>
</section>
<section class="Sh">
<h1 class="Sh" id="C"><a class="permalink" href="#C">C-PERL BINDINGS</a></h1>
<p class="Pp">This section describes how the
    <span class="Li">&quot;Perl&quot;</span> variables get mapped to
    <span class="Li">&quot;C&quot;</span> variables and back again.</p>
<p class="Pp">First, you need to know how
    <span class="Li">&quot;Perl&quot;</span> passes arguments back and forth to
    subroutines. Basically it uses a stack (also known as the <b>Stack</b>).
    When a sub is called, all of the parenthesized arguments get expanded into a
    list of scalars and pushed onto the <b>Stack</b>. The subroutine then pops
    all of its parameters off of the <b>Stack</b>. When the sub is done, it
    pushes all of its return values back onto the <b>Stack</b>.</p>
<p class="Pp">The <b>Stack</b> is an array of scalars known internally as
    <span class="Li">&quot;SV&quot;</span>'s. The <b>Stack</b> is actually an
    array of <b>pointers to SV</b> or <span class="Li">&quot;SV*&quot;</span>;
    therefore every element of the <b>Stack</b> is natively a
    <span class="Li">&quot;SV*&quot;</span>. For <i>FMTYEWTK</i> about this,
    read <span class="Li">&quot;perldoc perlguts&quot;</span>.</p>
<p class="Pp">So back to variable mapping. XS uses a thing known as
    &quot;typemaps&quot; to turn each <span class="Li">&quot;SV*&quot;</span>
    into a <span class="Li">&quot;C&quot;</span> type and back again. This is
    done through various XS macro calls, casts and the Perl API. See
    <span class="Li">&quot;perldoc perlapi&quot;</span>. XS allows you to define
    your own typemaps as well for fancier non-standard types such as
    <span class="Li">&quot;typedef&quot;</span>- ed structs.</p>
<p class="Pp">Inline uses the default Perl typemap file for its default types.
    This file is called
    <span class="Li">&quot;/usr/local/lib/perl5/5.6.1/ExtUtils/typemap&quot;</span>,
    or something similar, depending on your Perl installation. It has
    definitions for over 40 types, which are automatically used by Inline. (You
    should probably browse this file at least once, just to get an idea of the
    possibilities.)</p>
<p class="Pp">Inline parses your code for these types and generates the XS code
    to map them. The most commonly used types are:</p>
<ul class="Bl-bullet">
  <li><span class="Li">&quot;int&quot;</span></li>
  <li><span class="Li">&quot;long&quot;</span></li>
  <li><span class="Li">&quot;double&quot;</span></li>
  <li><span class="Li">&quot;char*&quot;</span></li>
  <li><span class="Li">&quot;void&quot;</span></li>
  <li><span class="Li">&quot;SV*&quot;</span></li>
</ul>
<p class="Pp">If you need to deal with a type that is not in the defaults, just
    use the generic <span class="Li">&quot;SV*&quot;</span> type in the function
    definition. Then inside your code, do the mapping yourself. Alternatively,
    you can create your own typemap files and specify them using the
    <span class="Li">&quot;typemaps&quot;</span> configuration option.</p>
<p class="Pp">A return type of <span class="Li">&quot;void&quot;</span> has a
    special meaning to Inline. It means that you plan to push the values back
    onto the <b>Stack</b> yourself. This is what you need to do to return a list
    of values. If you really don't want to return anything (the traditional
    meaning of <span class="Li">&quot;void&quot;</span>) then simply don't push
    anything back.</p>
<p class="Pp">If ellipsis or <span class="Li">&quot;...&quot;</span> is used at
    the end of an argument list, it means that any number of
    <span class="Li">&quot;SV*&quot;</span>s may follow. Again you will need to
    pop the values off of the <span class="Li">&quot;Stack&quot;</span>
    yourself.</p>
<p class="Pp">See &quot;EXAMPLES&quot; below.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="THE_INLINE_STACK_MACROS"><a class="permalink" href="#THE_INLINE_STACK_MACROS">THE
  INLINE STACK MACROS</a></h1>
<p class="Pp">When you write Inline C, the following lines are automatically
    prepended to your code (by default):</p>
<p class="Pp"></p>
<pre>    #include &quot;EXTERN.h&quot;
    #include &quot;perl.h&quot;
    #include &quot;XSUB.h&quot;
    #include &quot;INLINE.h&quot;
</pre>
<p class="Pp">The file <span class="Li">&quot;INLINE.h&quot;</span> defines a
    set of macros that are useful for handling the Perl Stack from your C
    functions.</p>
<dl class="Bl-tag">
  <dt>&quot;Inline_Stack_Vars&quot;</dt>
  <dd>You'll need to use this one, if you want to use the others. It sets up a
      few local variables: <span class="Li">&quot;sp&quot;</span>,
      <span class="Li">&quot;items&quot;</span>,
      <span class="Li">&quot;ax&quot;</span> and
      <span class="Li">&quot;mark&quot;</span>, for use by the other macros.
      It's not important to know what they do, but I mention them to avoid
      possible name conflicts.
    <p class="Pp">NOTE: Since this macro declares variables, you'll need to put
        it with your
      <br/>
       other variable declarations at the top of your function. It must
      <br/>
       come before any executable statements and before any other
      <br/>
       <span class="Li">&quot;Inline_Stack&quot;</span> macros.</p>
  </dd>
  <dt>&quot;Inline_Stack_Items&quot;</dt>
  <dd>Returns the number of arguments passed in on the Stack.</dd>
  <dt id="Inline_Stack_Item(i)"><a class="permalink" href="#Inline_Stack_Item(i)">Inline_Stack_Item(i)</a></dt>
  <dd>Refers to a particular <span class="Li">&quot;SV*&quot;</span> in the
      Stack, where <span class="Li">&quot;i&quot;</span> is an index number
      starting from zero. Can be used to get or set the value.</dd>
  <dt>&quot;Inline_Stack_Reset&quot;</dt>
  <dd>Use this before pushing anything back onto the Stack. It resets the
      internal Stack pointer to the beginning of the Stack.</dd>
  <dt>&quot;Inline_Stack_Push(sv)&quot;</dt>
  <dd>Push a return value back onto the Stack. The value must be of type
      <span class="Li">&quot;SV*&quot;</span>.</dd>
  <dt>&quot;Inline_Stack_Done&quot;</dt>
  <dd>After you have pushed all of your return values, you must call this
    macro.</dd>
  <dt id="Inline_Stack_Return(n)"><a class="permalink" href="#Inline_Stack_Return(n)">Inline_Stack_Return(n)</a></dt>
  <dd>Return <span class="Li">&quot;n&quot;</span> items on the Stack.</dd>
  <dt>&quot;Inline_Stack_Void&quot;</dt>
  <dd>A special macro to indicate that you really don't want to return anything.
      Same as:
    <p class="Pp"></p>
    <pre>    Inline_Stack_Return(0);
    </pre>
    <p class="Pp">Please note that this macro actually <b>returns</b> from your
        function.</p>
  </dd>
</dl>
<p class="Pp">Each of these macros is available in 3 different styles to suit
    your coding tastes. The following macros are equivalent.</p>
<p class="Pp"></p>
<pre>    Inline_Stack_Vars
    inline_stack_vars
    INLINE_STACK_VARS
</pre>
<p class="Pp">All of this functionality is available through XS macro calls as
    well. So why duplicate the functionality? There are a few reasons why I
    decided to offer this set of macros. First, as a convenient way to access
    the Stack. Second, for consistent, self documenting, non-cryptic coding.
    Third, for future compatibility. It occurred to me that if a lot of people
    started using XS macros for their C code, the interface might break under
    Perl6. By using this set, hopefully I will be able to insure future
    compatibility of argument handling.</p>
<p class="Pp">Of course, if you use the rest of the Perl API, your code will
    most likely break under Perl6. So this is not a 100% guarantee. But since
    argument handling is the most common interface you're likely to use, it
    seemed like a wise thing to do.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="WRITING_C_SUBROUTINES"><a class="permalink" href="#WRITING_C_SUBROUTINES">WRITING
  C SUBROUTINES</a></h1>
<p class="Pp">The definitions of your C functions will fall into one of the
    following four categories. For each category there are special
    considerations.</p>
<dl class="Bl-tag">
  <dt>&quot;int Foo(int arg1, char* arg2, SV* arg3) {&quot;</dt>
  <dd>This is the simplest case. You have a non
      <span class="Li">&quot;void&quot;</span> return type and a fixed length
      argument list. You don't need to worry about much. All the conversions
      will happen automatically.</dd>
  <dt>&quot;void Foo(int arg1, char* arg2, SV* arg3) {&quot;</dt>
  <dd>In this category you have a <span class="Li">&quot;void&quot;</span>
      return type. This means that either you want to return nothing, or that
      you want to return a list. In the latter case you'll need to push values
      onto the <b>Stack</b> yourself. There are a few Inline macros that make
      this easy. Code something like this:
    <p class="Pp"></p>
    <pre>    int i, max; SV* my_sv[10];
    Inline_Stack_Vars;
    Inline_Stack_Reset;
    for (i = 0; i &lt; max; i++)
      Inline_Stack_Push(my_sv[i]);
    Inline_Stack_Done;
    </pre>
    <p class="Pp">After resetting the Stack pointer, this code pushes a series
        of return values. At the end it uses
        <span class="Li">&quot;Inline_Stack_Done&quot;</span> to mark the end of
        the return stack.</p>
    <p class="Pp">If you really want to return nothing, then don't use the
        <span class="Li">&quot;Inline_Stack_&quot;</span> macros. If you must
        use them, then set use
        <span class="Li">&quot;Inline_Stack_Void&quot;</span> at the end of your
        function.</p>
  </dd>
  <dt>&quot;char* Foo(SV* arg1, ...) {&quot;</dt>
  <dd>In this category you have an unfixed number of arguments. This means that
      you'll have to pop values off the <b>Stack</b> yourself. Do it like this:
    <p class="Pp"></p>
    <pre>    int i;
    Inline_Stack_Vars;
    for (i = 0; i &lt; Inline_Stack_Items; i++)
      handle_sv(Inline_Stack_Item(i));
    </pre>
    <p class="Pp">The return type of
        <span class="Li">Inline_Stack_Item(i)</span> is
        <span class="Li">&quot;SV*&quot;</span>.</p>
  </dd>
  <dt>&quot;void* Foo(SV* arg1, ...) {&quot;</dt>
  <dd>In this category you have both a <span class="Li">&quot;void&quot;</span>
      return type and an unfixed number of arguments. Just combine the
      techniques from Categories 3 and 4.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="EXAMPLES"><a class="permalink" href="#EXAMPLES">EXAMPLES</a></h1>
<p class="Pp">Here are a few examples. Each one is a complete program that you
    can try running yourself. For many more examples see
  Inline::C::Cookbook.</p>
<section class="Ss">
<h2 class="Ss" id="Example__1_"><a class="permalink" href="#Example__1_">Example
  #1 - Greetings</a></h2>
<p class="Pp">This example will take one string argument (a name) and print a
    greeting. The function is called with a string and with a number. In the
    second case the number is forced to a string.</p>
<p class="Pp">Notice that you do not need to <span class="Li">&quot;#include
    &lt;stdio.h&quot;</span>&gt;. The <span class="Li">&quot;perl.h&quot;</span>
    header file which gets included by default, automatically loads the standard
    C header files for you.</p>
<p class="Pp"></p>
<pre>    use Inline 'C';
    greet('Ingy');
    greet(42);
    __END__
    __C__
    void greet(char* name) {
      printf(&quot;Hello %s!\n&quot;, name);
    }
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Example__2_"><a class="permalink" href="#Example__2_">Example
  #2 - and Salutations</a></h2>
<p class="Pp">This is similar to the last example except that the name is passed
    in as a <span class="Li">&quot;SV*&quot;</span> (pointer to Scalar Value)
    rather than a string (<span class="Li">&quot;char*&quot;</span>). That means
    we need to convert the <span class="Li">&quot;SV&quot;</span> to a string
    ourselves. This is accomplished using the
    <span class="Li">&quot;SvPVX&quot;</span> function which is part of the
    <span class="Li">&quot;Perl&quot;</span> internal API. See
    <span class="Li">&quot;perldoc</span> <span class="Li">perlapi&quot;</span>
    for more info.</p>
<p class="Pp">One problem is that <span class="Li">&quot;SvPVX&quot;</span>
    doesn't automatically convert strings to numbers, so we get a little
    surprise when we try to greet <span class="Li">42</span>. The program
    segfaults, a common occurrence when delving into the guts of Perl.</p>
<p class="Pp"></p>
<pre>    use Inline 'C';
    greet('Ingy');
    greet(42);
    __END__
    __C__
    void greet(SV* sv_name) {
      printf(&quot;Hello %s!\n&quot;, SvPVX(sv_name));
    }
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Example__3_"><a class="permalink" href="#Example__3_">Example
  #3 - Fixing the problem</a></h2>
<p class="Pp">We can fix the problem in Example #2 by using the
    <span class="Li">&quot;SvPV&quot;</span> function instead. This function
    will stringify the <span class="Li">&quot;SV&quot;</span> if it does not
    contain a string. <span class="Li">&quot;SvPV&quot;</span> returns the
    length of the string as it's second parameter. Since we don't care about the
    length, we can just put <span class="Li">&quot;PL_na&quot;</span> there,
    which is a special variable designed for that purpose.</p>
<p class="Pp"></p>
<pre>    use Inline 'C';
    greet('Ingy');
    greet(42);
    __END__
    __C__
    void greet(SV* sv_name) {
      printf(&quot;Hello %s!\n&quot;, SvPV(sv_name, PL_na));
    }
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp">For general information about Inline see Inline.</p>
<p class="Pp">For sample programs using Inline with C see
  Inline::C::Cookbook.</p>
<p class="Pp">For information on supported languages and platforms see
    Inline-Support.</p>
<p class="Pp">For information on writing your own Inline Language Support
    Module, see Inline-API.</p>
<p class="Pp">Inline's mailing list is inline@perl.org</p>
<p class="Pp">To subscribe, send email to inline-subscribe@perl.org</p>
</section>
<section class="Sh">
<h1 class="Sh" id="BUGS_AND_DEFICIENCIES"><a class="permalink" href="#BUGS_AND_DEFICIENCIES">BUGS
  AND DEFICIENCIES</a></h1>
<p class="Pp">If you use C function names that happen to be used internally by
    Perl, you will get a load error at run time. There is currently no
    functionality to prevent this or to warn you. For now, a list of Perl's
    internal symbols is packaged in the Inline module distribution under the
    filename <span class="Li">'symbols.perl'</span>. Avoid using these in your
    code.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHORS"><a class="permalink" href="#AUTHORS">AUTHORS</a></h1>
<p class="Pp">Ingy d&#x00F6;t Net &lt;ingy@cpan.org&gt;</p>
<p class="Pp">Sisyphus &lt;sisyphus@cpan.org&gt;</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT_AND_LICENSE"><a class="permalink" href="#COPYRIGHT_AND_LICENSE">COPYRIGHT
  AND LICENSE</a></h1>
<p class="Pp">Copyright 2000-2019. Ingy d&#x00F6;t Net.</p>
<p class="Pp">Copyright 2008, 2010-2014. Sisyphus.</p>
<p class="Pp">This program is free software; you can redistribute it and/or
    modify it under the same terms as Perl itself.</p>
<p class="Pp">See &lt;http://www.perl.com/perl/misc/Artistic.html&gt;</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2019-05-11</td>
    <td class="foot-os">perl v5.34.0</td>
  </tr>
</table>
</body>
</html>
