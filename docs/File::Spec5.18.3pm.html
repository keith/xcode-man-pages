<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>File::Spec(3pm)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">File::Spec(3pm)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">File::Spec(3pm)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
File::Spec - portably perform operations on file names
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<span class="Li"></span>
<pre>
        use File::Spec;

        $x=File::Spec-&gt;catfile('a', 'b', 'c');
</pre>
<p class="Pp">which returns 'a/b/c' under Unix. Or:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
        use File::Spec::Functions;

        $x = catfile('a', 'b', 'c');
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
This module is designed to support operations commonly performed on file
  specifications (usually called &quot;file names&quot;, but not to be confused
  with the contents of a file, or Perl's file handles), such as concatenating
  several directory and file names into a single path, or determining whether a
  path is rooted. It is based on code directly taken from MakeMaker 5.17, code
  written by Andreas Koenig, Andy Dougherty, Charles Bailey, Ilya Zakharevich,
  Paul Schinder, and others.
<p class="Pp">Since these functions are different for most operating systems,
    each set of OS specific routines is available in a separate module,
    including:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
        File::Spec::Unix
        File::Spec::Mac
        File::Spec::OS2
        File::Spec::Win32
        File::Spec::VMS
</pre>
<p class="Pp">The module appropriate for the current OS is automatically loaded
    by File::Spec. Since some modules (like VMS) make use of facilities
    available only under that OS, it may not be possible to load all modules
    under all operating systems.</p>
<p class="Pp">Since File::Spec is object oriented, subroutines should not be
    called directly, as in:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
        File::Spec::catfile('a','b');
</pre>
<p class="Pp">but rather as class methods:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
        File::Spec-&gt;catfile('a','b');
</pre>
<p class="Pp">For simple uses, File::Spec::Functions provides convenient
    functional forms of these methods.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="METHODS"><a class="permalink" href="#METHODS">METHODS</a></h1>
<dl class="Bl-tag">
  <dt>canonpath</dt>
  <dd>No physical check on the filesystem, but a logical cleanup of a path.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    $cpath = File::Spec-&gt;canonpath( $path ) ;
    </pre>
    <p class="Pp">Note that this does *not* collapse <i>x/../y</i> sections into
        <i>y</i>. This is by design. If <i>/foo</i> on your system is a symlink
        to <i>/bar/baz</i>, then <i>/foo/../quux</i> is actually
        <i>/bar/quux</i>, not <i>/quux</i> as a naive <i>../</i>-removal would
        give you. If you want to do this kind of processing, you probably want
        <span class="Li">&quot;Cwd&quot;</span>'s
        <span class="Li">&quot;realpath()&quot;</span> function to actually
        traverse the filesystem cleaning up paths like this.</p>
  </dd>
  <dt>catdir</dt>
  <dd>Concatenate two or more directory names to form a complete path ending
      with a directory. But remove the trailing slash from the resulting string,
      because it doesn't look good, isn't necessary and confuses OS/2. Of
      course, if this is the root directory, don't cut off the trailing slash
      :-)
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    $path = File::Spec-&gt;catdir( @directories );
    </pre>
  </dd>
  <dt>catfile</dt>
  <dd>Concatenate one or more directory names and a filename to form a complete
      path ending with a filename
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    $path = File::Spec-&gt;catfile( @directories, $filename );
    </pre>
  </dd>
  <dt>curdir</dt>
  <dd>Returns a string representation of the current directory.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    $curdir = File::Spec-&gt;curdir();
    </pre>
  </dd>
  <dt>devnull</dt>
  <dd>Returns a string representation of the null device.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    $devnull = File::Spec-&gt;devnull();
    </pre>
  </dd>
  <dt>rootdir</dt>
  <dd>Returns a string representation of the root directory.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    $rootdir = File::Spec-&gt;rootdir();
    </pre>
  </dd>
  <dt>tmpdir</dt>
  <dd>Returns a string representation of the first writable directory from a
      list of possible temporary directories. Returns the current directory if
      no writable temporary directories are found. The list of directories
      checked depends on the platform; e.g. File::Spec::Unix checks
      <span class="Li">$ENV{TMPDIR}</span> (unless taint is on) and <i>/tmp</i>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    $tmpdir = File::Spec-&gt;tmpdir();
    </pre>
  </dd>
  <dt>updir</dt>
  <dd>Returns a string representation of the parent directory.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    $updir = File::Spec-&gt;updir();
    </pre>
  </dd>
  <dt>no_upwards</dt>
  <dd>Given a list of file names, strip out those that refer to a parent
      directory. (Does not strip symlinks, only '.', '..', and equivalents.)
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    @paths = File::Spec-&gt;no_upwards( @paths );
    </pre>
  </dd>
  <dt>case_tolerant</dt>
  <dd>Returns a true or false value indicating, respectively, that alphabetic
      case is not or is significant when comparing file specifications. Cygwin
      and Win32 accept an optional drive argument.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    $is_case_tolerant = File::Spec-&gt;case_tolerant();
    </pre>
  </dd>
  <dt>file_name_is_absolute</dt>
  <dd>Takes as its argument a path, and returns true if it is an absolute path.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    $is_absolute = File::Spec-&gt;file_name_is_absolute( $path );
    </pre>
    <p class="Pp">This does not consult the local filesystem on Unix, Win32,
        OS/2, or Mac OS (Classic). It does consult the working environment for
        VMS (see &quot;file_name_is_absolute&quot; in File::Spec::VMS).</p>
  </dd>
  <dt>path</dt>
  <dd>Takes no argument. Returns the environment variable
      <span class="Li">&quot;PATH&quot;</span> (or the local platform's
      equivalent) as a list.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    @PATH = File::Spec-&gt;path();
    </pre>
  </dd>
  <dt>join</dt>
  <dd>join is the same as catfile.</dd>
  <dt>splitpath</dt>
  <dd>Splits a path in to volume, directory, and filename portions. On systems
      with no concept of volume, returns '' for volume.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    ($volume,$directories,$file) =
                       File::Spec-&gt;splitpath( $path );
    ($volume,$directories,$file) =
                       File::Spec-&gt;splitpath( $path, $no_file );
    </pre>
    <p class="Pp">For systems with no syntax differentiating filenames from
        directories, assumes that the last file is a path unless
        <span class="Li">$no_file</span> is true or a trailing separator or
        <i>/.</i> or <i>/..</i> is present. On Unix, this means that
        <span class="Li">$no_file</span> true makes this return ( '',
        <span class="Li">$path</span>, '' ).</p>
    <p class="Pp">The directory portion may or may not be returned with a
        trailing '/'.</p>
    <p class="Pp">The results can be passed to &quot;<i>catpath()</i>&quot; to
        get back a path equivalent to (usually identical to) the original
      path.</p>
  </dd>
  <dt>splitdir</dt>
  <dd>The opposite of &quot;catdir&quot;.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    @dirs = File::Spec-&gt;splitdir( $directories );
    </pre>
    <p class="Pp"><span class="Li">$directories</span> must be only the
        directory portion of the path on systems that have the concept of a
        volume or that have path syntax that differentiates files from
        directories.</p>
    <p class="Pp">Unlike just splitting the directories on the separator, empty
        directory names (<span class="Li">''</span>) can be returned, because
        these are significant on some OSes.</p>
  </dd>
  <dt><i>catpath()</i></dt>
  <dd>Takes volume, directory and file portions and returns an entire path.
      Under Unix, <span class="Li">$volume</span> is ignored, and directory and
      file are concatenated. A '/' is inserted if need be. On other OSes,
      <span class="Li">$volume</span> is significant.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    $full_path = File::Spec-&gt;catpath( $volume, $directory, $file );
    </pre>
  </dd>
  <dt>abs2rel</dt>
  <dd>Takes a destination path and an optional base path returns a relative path
      from the base path to the destination path:
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    $rel_path = File::Spec-&gt;abs2rel( $path ) ;
    $rel_path = File::Spec-&gt;abs2rel( $path, $base ) ;
    </pre>
    <p class="Pp">If <span class="Li">$base</span> is not present or '', then
        <i>Cwd::cwd()</i> is used. If <span class="Li">$base</span> is relative,
        then it is converted to absolute form using
        &quot;<i>rel2abs()</i>&quot;. This means that it is taken to be relative
        to <i>Cwd::cwd()</i>.</p>
    <p class="Pp">On systems with the concept of volume, if
        <span class="Li">$path</span> and <span class="Li">$base</span> appear
        to be on two different volumes, we will not attempt to resolve the two
        paths, and we will instead simply return <span class="Li">$path</span>.
        Note that previous versions of this module ignored the volume of
        <span class="Li">$base</span>, which resulted in garbage results part of
        the time.</p>
    <p class="Pp">On systems that have a grammar that indicates filenames, this
        ignores the <span class="Li">$base</span> filename as well. Otherwise
        all path components are assumed to be directories.</p>
    <p class="Pp">If <span class="Li">$path</span> is relative, it is converted
        to absolute form using &quot;<i>rel2abs()</i>&quot;. This means that it
        is taken to be relative to <i>Cwd::cwd()</i>.</p>
    <p class="Pp">No checks against the filesystem are made. On VMS, there is
        interaction with the working environment, as logicals and macros are
        expanded.</p>
    <p class="Pp">Based on code written by Shigio Yamaguchi.</p>
  </dd>
  <dt><i>rel2abs()</i></dt>
  <dd>Converts a relative path to an absolute path.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    $abs_path = File::Spec-&gt;rel2abs( $path ) ;
    $abs_path = File::Spec-&gt;rel2abs( $path, $base ) ;
    </pre>
    <p class="Pp">If <span class="Li">$base</span> is not present or '', then
        <i>Cwd::cwd()</i> is used. If <span class="Li">$base</span> is relative,
        then it is converted to absolute form using
        &quot;<i>rel2abs()</i>&quot;. This means that it is taken to be relative
        to <i>Cwd::cwd()</i>.</p>
    <p class="Pp">On systems with the concept of volume, if
        <span class="Li">$path</span> and <span class="Li">$base</span> appear
        to be on two different volumes, we will not attempt to resolve the two
        paths, and we will instead simply return <span class="Li">$path</span>.
        Note that previous versions of this module ignored the volume of
        <span class="Li">$base</span>, which resulted in garbage results part of
        the time.</p>
    <p class="Pp">On systems that have a grammar that indicates filenames, this
        ignores the <span class="Li">$base</span> filename as well. Otherwise
        all path components are assumed to be directories.</p>
    <p class="Pp">If <span class="Li">$path</span> is absolute, it is cleaned up
        and returned using &quot;canonpath&quot;.</p>
    <p class="Pp">No checks against the filesystem are made. On VMS, there is
        interaction with the working environment, as logicals and macros are
        expanded.</p>
    <p class="Pp">Based on code written by Shigio Yamaguchi.</p>
  </dd>
</dl>
<p class="Pp">For further information, please see File::Spec::Unix,
    File::Spec::Mac, File::Spec::OS2, File::Spec::Win32, or File::Spec::VMS.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
File::Spec::Unix, File::Spec::Mac, File::Spec::OS2, File::Spec::Win32,
  File::Spec::VMS, File::Spec::Functions, ExtUtils::MakeMaker
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
Currently maintained by Ken Williams
  <span class="Li">&quot;&lt;KWILLIAMS@cpan.org&gt;&quot;</span>.
<p class="Pp">The vast majority of the code was written by Kenneth Albanowski
    <span class="Li">&quot;&lt;kjahds@kjahds.com&gt;&quot;</span>, Andy
    Dougherty
    <span class="Li">&quot;&lt;doughera@lafayette.edu&gt;&quot;</span>, Andreas
    Koenig
    <span class="Li">&quot;&lt;A.Koenig@franz.ww.TU-Berlin.DE&gt;&quot;</span>,
    Tim Bunce <span class="Li">&quot;&lt;Tim.Bunce@ig.co.uk&gt;&quot;</span>.
    VMS support by Charles Bailey
    <span class="Li">&quot;&lt;bailey@newman.upenn.edu&gt;&quot;</span>. OS/2
    support by Ilya Zakharevich
    <span class="Li">&quot;&lt;ilya@math.ohio-state.edu&gt;&quot;</span>. Mac
    support by Paul Schinder
    <span class="Li">&quot;&lt;schinder@pobox.com&gt;&quot;</span>, and Thomas
    Wegner <span class="Li">&quot;&lt;wegner_thomas@yahoo.com&gt;&quot;</span>.
    <i>abs2rel()</i> and <i>rel2abs()</i> written by Shigio Yamaguchi
    <span class="Li">&quot;&lt;shigio@tamacom.com&gt;&quot;</span>, modified by
    Barrie Slaymaker
    <span class="Li">&quot;&lt;barries@slaysys.com&gt;&quot;</span>.
    <i>splitpath()</i>, <i>splitdir()</i>, <i>catpath()</i> and <i>catdir()</i>
    by Barrie Slaymaker.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT"><a class="permalink" href="#COPYRIGHT">COPYRIGHT</a></h1>
Copyright (c) 2004-2013 by the Perl 5 Porters. All rights reserved.
<p class="Pp">This program is free software; you can redistribute it and/or
    modify it under the same terms as Perl itself.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2014-09-30</td>
    <td class="foot-os">perl v5.18.4</td>
  </tr>
</table>
</body>
</html>
