<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    .Nd, .Bf, .Op { display: inline; }
    .Pa, .Ad { font-style: italic; }
    .Ms { font-weight: bold; }
    .Bl-diag > dt { font-weight: bold; }
    code.Nm, .Fl, .Cm, .Ic, code.In, .Fd, .Fn, .Cd { font-weight: bold;
      font-family: inherit; }
  </style>
  <title>Parse::RecDescent(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Parse::RecDescent(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Parse::RecDescent(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Parse::RecDescent - Generate Recursive-Descent Parsers</p>
</section>
<section class="Sh">
<h1 class="Sh" id="VERSION"><a class="permalink" href="#VERSION">VERSION</a></h1>
<p class="Pp">This document describes version 1.967015 of Parse::RecDescent
    released April 4th, 2017.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre> use Parse::RecDescent;
 # Generate a parser from the specification in $grammar:
     $parser = new Parse::RecDescent ($grammar);
 # Generate a parser from the specification in $othergrammar
     $anotherparser = new Parse::RecDescent ($othergrammar);
 # Parse $text using rule 'startrule' (which must be
 # defined in $grammar):
    $parser-&gt;startrule($text);
 # Parse $text using rule 'otherrule' (which must also
 # be defined in $grammar):
     $parser-&gt;otherrule($text);
 # Change the universal token prefix pattern
 # before building a grammar
 # (the default is: '\s*'):
    $Parse::RecDescent::skip = '[ \t]+';
 # Replace productions of existing rules (or create new ones)
 # with the productions defined in $newgrammar:
    $parser-&gt;Replace($newgrammar);
 # Extend existing rules (or create new ones)
 # by adding extra productions defined in $moregrammar:
    $parser-&gt;Extend($moregrammar);
 # Global flags (useful as command line arguments under -s):
    $::RD_ERRORS       # unless undefined, report fatal errors
    $::RD_WARN         # unless undefined, also report non-fatal problems
    $::RD_HINT         # if defined, also suggestion remedies
    $::RD_TRACE        # if defined, also trace parsers' behaviour
    $::RD_AUTOSTUB     # if defined, generates &quot;stubs&quot; for undefined rules
    $::RD_AUTOACTION   # if defined, appends specified action to productions
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<section class="Ss">
<h2 class="Ss" id="Overview"><a class="permalink" href="#Overview">Overview</a></h2>
<p class="Pp">Parse::RecDescent incrementally generates top-down
    recursive-descent text parsers from simple <i>yacc</i>-like grammar
    specifications. It provides:</p>
<ul class="Bl-bullet">
  <li>Regular expressions or literal strings as terminals (tokens),</li>
  <li>Multiple (non-contiguous) productions for any rule,</li>
  <li>Repeated and optional subrules within productions,</li>
  <li>Full access to Perl within actions specified as part of the grammar,</li>
  <li>Simple automated error reporting during parser generation and
    parsing,</li>
  <li>The ability to commit to, uncommit to, or reject particular productions
      during a parse,</li>
  <li>The ability to pass data up and down the parse tree (&quot;down&quot; via
      subrule argument lists, &quot;up&quot; via subrule return values)</li>
  <li>Incremental extension of the parsing grammar (even during a parse),</li>
  <li>Precompilation of parser objects,</li>
  <li>User-definable reduce-reduce conflict resolution via &quot;scoring&quot;
      of matching productions.</li>
</ul>
</section>
<section class="Ss">
<h2 class="Ss" id="Using__Parse::RecDescent_"><a class="permalink" href="#Using__Parse::RecDescent_">Using
  &quot;Parse::RecDescent&quot;</a></h2>
<p class="Pp">Parser objects are created by calling
    <span class="Li">&quot;Parse::RecDescent::new&quot;</span>, passing in a
    grammar specification (see the following subsections). If the grammar is
    correct, <span class="Li">&quot;new&quot;</span> returns a blessed reference
    which can then be used to initiate parsing through any rule specified in the
    original grammar. A typical sequence looks like this:</p>
<p class="Pp"></p>
<pre>    $grammar = q {
        # GRAMMAR SPECIFICATION HERE
         };
    $parser = new Parse::RecDescent ($grammar) or die &quot;Bad grammar!\n&quot;;
    # acquire $text
    defined $parser-&gt;startrule($text) or print &quot;Bad text!\n&quot;;
</pre>
<p class="Pp">The rule through which parsing is initiated must be explicitly
    defined in the grammar (i.e. for the above example, the grammar must include
    a rule of the form: &quot;startrule: &lt;subrules&gt;&quot;.</p>
<p class="Pp">If the starting rule succeeds, its value (see below) is returned.
    Failure to generate the original parser or failure to match a text is
    indicated by returning <span class="Li">&quot;undef&quot;</span>. Note that
    it's easy to set up grammars that can succeed, but which return a value of
    0, &quot;0&quot;, or &quot;&quot;. So don't be tempted to write:</p>
<p class="Pp"></p>
<pre>    $parser-&gt;startrule($text) or print &quot;Bad text!\n&quot;;
</pre>
<p class="Pp">Normally, the parser has no effect on the original text. So in the
    previous example the value of <span class="Li">$text</span> would be
    unchanged after having been parsed.</p>
<p class="Pp">If, however, the text to be matched is passed by reference:</p>
<p class="Pp"></p>
<pre>    $parser-&gt;startrule(\$text)
</pre>
<p class="Pp">then any text which was consumed during the match will be removed
    from the start of <span class="Li">$text</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Rules"><a class="permalink" href="#Rules">Rules</a></h2>
<p class="Pp">In the grammar from which the parser is built, rules are specified
    by giving an identifier (which must satisfy /[A-Za-z]\w*/), followed by a
    colon <i>on the same line</i>, followed by one or more productions,
    separated by single vertical bars. The layout of the productions is entirely
    free-format:</p>
<p class="Pp"></p>
<pre>    rule1:  production1
     |  production2 |
    production3 | production4
</pre>
<p class="Pp">At any point in the grammar previously defined rules may be
    extended with additional productions. This is achieved by redeclaring the
    rule with the new productions. Thus:</p>
<p class="Pp"></p>
<pre>    rule1: a | b | c
    rule2: d | e | f
    rule1: g | h
</pre>
<p class="Pp">is exactly equivalent to:</p>
<p class="Pp"></p>
<pre>    rule1: a | b | c | g | h
    rule2: d | e | f
</pre>
<p class="Pp">Each production in a rule consists of zero or more items, each of
    which may be either: the name of another rule to be matched (a
    &quot;subrule&quot;), a pattern or string literal to be matched directly (a
    &quot;token&quot;), a block of Perl code to be executed (an
    &quot;action&quot;), a special instruction to the parser (a
    &quot;directive&quot;), or a standard Perl comment (which is ignored).</p>
<p class="Pp">A rule matches a text if one of its productions matches. A
    production matches if each of its items match consecutive substrings of the
    text. The productions of a rule being matched are tried in the same order
    that they appear in the original grammar, and the first matching production
    terminates the match attempt (successfully). If all productions are tried
    and none matches, the match attempt fails.</p>
<p class="Pp">Note that this behaviour is quite different from the &quot;prefer
    the longer match&quot; behaviour of <i>yacc</i>. For example, if <i>yacc</i>
    were parsing the rule:</p>
<p class="Pp"></p>
<pre>    seq : 'A' 'B'
    | 'A' 'B' 'C'
</pre>
<p class="Pp">upon matching &quot;AB&quot; it would look ahead to see if a 'C'
    is next and, if so, will match the second production in preference to the
    first. In other words, <i>yacc</i> effectively tries all the productions of
    a rule breadth-first in parallel, and selects the &quot;best&quot; match,
    where &quot;best&quot; means longest (note that this is a gross
    simplification of the true behaviour of <i>yacc</i> but it will do for our
    purposes).</p>
<p class="Pp">In contrast, <span class="Li">&quot;Parse::RecDescent&quot;</span>
    tries each production depth-first in sequence, and selects the
    &quot;best&quot; match, where &quot;best&quot; means first. This is the
    fundamental difference between &quot;bottom-up&quot; and &quot;recursive
    descent&quot; parsing.</p>
<p class="Pp">Each successfully matched item in a production is assigned a
    value, which can be accessed in subsequent actions within the same
    production (or, in some cases, as the return value of a successful subrule
    call). Unsuccessful items don't have an associated value, since the failure
    of an item causes the entire surrounding production to immediately fail. The
    following sections describe the various types of items and their success
    values.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Subrules"><a class="permalink" href="#Subrules">Subrules</a></h2>
<p class="Pp">A subrule which appears in a production is an instruction to the
    parser to attempt to match the named rule at that point in the text being
    parsed. If the named subrule is not defined when requested the production
    containing it immediately fails (unless it was &quot;autostubbed&quot; - see
    Autostubbing).</p>
<p class="Pp">A rule may (recursively) call itself as a subrule, but <i>not</i>
    as the left-most item in any of its productions (since such recursions are
    usually non-terminating).</p>
<p class="Pp">The value associated with a subrule is the value associated with
    its <span class="Li">$return</span> variable (see &quot;Actions&quot;
    below), or with the last successfully matched item in the subrule match.</p>
<p class="Pp">Subrules may also be specified with a trailing repetition
    specifier, indicating that they are to be (greedily) matched the specified
    number of times. The available specifiers are:</p>
<p class="Pp"></p>
<pre>    subrule(?)  # Match one-or-zero times
    subrule(s)  # Match one-or-more times
    subrule(s?) # Match zero-or-more times
    subrule(N)  # Match exactly N times for integer N &gt; 0
    subrule(N..M)   # Match between N and M times
    subrule(..M)    # Match between 1 and M times
    subrule(N..)    # Match at least N times
</pre>
<p class="Pp">Repeated subrules keep matching until either the subrule fails to
    match, or it has matched the minimal number of times but fails to consume
    any of the parsed text (this second condition prevents the subrule matching
    forever in some cases).</p>
<p class="Pp">Since a repeated subrule may match many instances of the subrule
    itself, the value associated with it is not a simple scalar, but rather a
    reference to a list of scalars, each of which is the value associated with
    one of the individual subrule matches. In other words in the rule:</p>
<p class="Pp"></p>
<pre>    program: statement(s)
</pre>
<p class="Pp">the value associated with the repeated subrule
    &quot;statement(s)&quot; is a reference to an array containing the values
    matched by each call to the individual subrule &quot;statement&quot;.</p>
<p class="Pp">Repetition modifiers may include a separator pattern:</p>
<p class="Pp"></p>
<pre>    program: statement(s /;/)
</pre>
<p class="Pp">specifying some sequence of characters to be skipped between each
    repetition. This is really just a shorthand for the &lt;leftop:...&gt;
    directive (see below).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Tokens"><a class="permalink" href="#Tokens">Tokens</a></h2>
<p class="Pp">If a quote-delimited string or a Perl regex appears in a
    production, the parser attempts to match that string or pattern at that
    point in the text. For example:</p>
<p class="Pp"></p>
<pre>    typedef: &quot;typedef&quot; typename identifier ';'
    identifier: /[A-Za-z_][A-Za-z0-9_]*/
</pre>
<p class="Pp">As in regular Perl, a single quoted string is uninterpolated,
    whilst a double-quoted string or a pattern is interpolated (at the time of
    matching, <i>not</i> when the parser is constructed). Hence, it is possible
    to define rules in which tokens can be set at run-time:</p>
<p class="Pp"></p>
<pre>    typedef: &quot;$::typedefkeyword&quot; typename identifier ';'
    identifier: /$::identpat/
</pre>
<p class="Pp">Note that, since each rule is implemented inside a special
    namespace belonging to its parser, it is necessary to explicitly quantify
    variables from the main package.</p>
<p class="Pp">Regex tokens can be specified using just slashes as delimiters or
    with the explicit
    <span class="Li">&quot;m&lt;delimiter&gt;......&lt;delimiter&gt;&quot;</span>
    syntax:</p>
<p class="Pp"></p>
<pre>    typedef: &quot;typedef&quot; typename identifier ';'
    typename: /[A-Za-z_][A-Za-z0-9_]*/
    identifier: m{[A-Za-z_][A-Za-z0-9_]*}
</pre>
<p class="Pp">A regex of either type can also have any valid trailing
    parameter(s) (that is, any of [cgimsox]):</p>
<p class="Pp"></p>
<pre>    typedef: &quot;typedef&quot; typename identifier ';'
    identifier: / [a-z_]        # LEADING ALPHA OR UNDERSCORE
          [a-z0-9_]*    # THEN DIGITS ALSO ALLOWED
        /ix     # CASE/SPACE/COMMENT INSENSITIVE
</pre>
<p class="Pp">The value associated with any successfully matched token is a
    string containing the actual text which was matched by the token.</p>
<p class="Pp">It is important to remember that, since each grammar is specified
    in a Perl string, all instances of the universal escape character '\' within
    a grammar must be &quot;doubled&quot;, so that they interpolate to single
    '\'s when the string is compiled. For example, to use the grammar:</p>
<p class="Pp"></p>
<pre>    word:       /\S+/ | backslash
    line:       prefix word(s) &quot;\n&quot;
    backslash:  '\\'
</pre>
<p class="Pp">the following code is required:</p>
<p class="Pp"></p>
<pre>    $parser = new Parse::RecDescent (q{
        word:   /\\S+/ | backslash
        line:   prefix word(s) &quot;\\n&quot;
        backslash:  '\\\\'
    });
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Anonymous_subrules"><a class="permalink" href="#Anonymous_subrules">Anonymous
  subrules</a></h2>
<p class="Pp">Parentheses introduce a nested scope that is very like a call to
    an anonymous subrule. Hence they are useful for &quot;in-lining&quot;
    subroutine calls, and other kinds of grouping behaviour. For example,
    instead of:</p>
<p class="Pp"></p>
<pre>    word:       /\S+/ | backslash
    line:       prefix word(s) &quot;\n&quot;
</pre>
<p class="Pp">you could write:</p>
<p class="Pp"></p>
<pre>    line:       prefix ( /\S+/ | backslash )(s) &quot;\n&quot;
</pre>
<p class="Pp">and get exactly the same effects.</p>
<p class="Pp">Parentheses are also use for collecting unrepeated alternations
    within a single production.</p>
<p class="Pp"></p>
<pre>    secret_identity: &quot;Mr&quot; (&quot;Incredible&quot;|&quot;Fantastic&quot;|&quot;Sheen&quot;) &quot;, Esq.&quot;
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Terminal_Separators"><a class="permalink" href="#Terminal_Separators">Terminal
  Separators</a></h2>
<p class="Pp">For the purpose of matching, each terminal in a production is
    considered to be preceded by a &quot;prefix&quot; - a pattern which must be
    matched before a token match is attempted. By default, the prefix is
    optional whitespace (which always matches, at least trivially), but this
    default may be reset in any production.</p>
<p class="Pp">The variable <span class="Li">$Parse::RecDescent::skip</span>
    stores the universal prefix, which is the default for all terminal matches
    in all parsers built with
    <span class="Li">&quot;Parse::RecDescent&quot;</span>.</p>
<p class="Pp">If you want to change the universal prefix using
    <span class="Li">$Parse::RecDescent::skip</span>, be careful to set it
    <i>before</i> creating the grammar object, because it is applied statically
    (when a grammar is built) rather than dynamically (when the grammar is
    used). Alternatively you can provide a global
    <span class="Li">&quot;&lt;skip:...&gt;&quot;</span> directive in your
    grammar before any rules (described later).</p>
<p class="Pp">The prefix for an individual production can be altered by using
    the <span class="Li">&quot;&lt;skip:...&gt;&quot;</span> directive
    (described later). Setting this directive in the top-level rule is an
    alternative approach to setting
    <span class="Li">$Parse::RecDescent::skip</span> before creating the object,
    but in this case you don't get the intended skipping behaviour if you
    directly invoke methods different from the top-level rule.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Actions"><a class="permalink" href="#Actions">Actions</a></h2>
<p class="Pp">An action is a block of Perl code which is to be executed (as the
    block of a <span class="Li">&quot;do&quot;</span> statement) when the parser
    reaches that point in a production. The action executes within a special
    namespace belonging to the active parser, so care must be taken in correctly
    qualifying variable names (see also &quot;Start-up Actions&quot; below).</p>
<p class="Pp">The action is considered to succeed if the final value of the
    block is defined (that is, if the implied
    <span class="Li">&quot;do&quot;</span> statement evaluates to a defined
    value - <i>even one which would be treated as &quot;false&quot;</i>). Note
    that the value associated with a successful action is also the final value
    in the block.</p>
<p class="Pp">An action will <i>fail</i> if its last evaluated value is
    <span class="Li">&quot;undef&quot;</span>. This is surprisingly easy to
    accomplish by accident. For instance, here's an infuriating case of an
    action that makes its production fail, but only when debugging <i>isn't</i>
    activated:</p>
<p class="Pp"></p>
<pre>    description: name rank serial_number
        { print &quot;Got $item[2] $item[1] ($item[3])\n&quot;
        if $::debugging
        }
</pre>
<p class="Pp">If <span class="Li">$debugging</span> is false, no statement in
    the block is executed, so the final value is
    <span class="Li">&quot;undef&quot;</span>, and the entire production fails.
    The solution is:</p>
<p class="Pp"></p>
<pre>    description: name rank serial_number
        { print &quot;Got $item[2] $item[1] ($item[3])\n&quot;
        if $::debugging;
          1;
        }
</pre>
<p class="Pp">Within an action, a number of useful parse-time variables are
    available in the special parser namespace (there are other variables also
    accessible, but meddling with them will probably just break your parser. As
    a general rule, if you avoid referring to unqualified variables - especially
    those starting with an underscore - inside an action, things should be
    okay):</p>
<dl class="Bl-tag">
  <dt>@item and %item</dt>
  <dd>The array slice <span class="Li">@item[1..$#item]</span> stores the value
      associated with each item (that is, each subrule, token, or action) in the
      current production. The analogy is to <span class="Li">$1</span>,
      <span class="Li">$2</span>, etc. in a <i>yacc</i> grammar. Note that, for
      obvious reasons, <span class="Li">@item</span> only contains the values of
      items <i>before</i> the current point in the production.
    <p class="Pp">The first element (<span class="Li">$item[0]</span>) stores
        the name of the current rule being matched.</p>
    <p class="Pp"><span class="Li">@item</span> is a standard Perl array, so it
        can also be indexed with negative numbers, representing the number of
        items <i>back</i> from the current position in the parse:</p>
    <p class="Pp"></p>
    <pre>    stuff: /various/ bits 'and' pieces &quot;then&quot; data 'end'
        { print $item[-2] }  # PRINTS data
             # (EASIER THAN: $item[6])
    </pre>
    <p class="Pp">The <span class="Li">%item</span> hash complements the
        &lt;@item&gt; array, providing named access to the same item values:</p>
    <p class="Pp"></p>
    <pre>    stuff: /various/ bits 'and' pieces &quot;then&quot; data 'end'
        { print $item{data}  # PRINTS data
             # (EVEN EASIER THAN USING @item)
    </pre>
    <p class="Pp">The results of named subrules are stored in the hash under
        each subrule's name (including the repetition specifier, if any), whilst
        all other items are stored under a &quot;named positional&quot; key that
        indicates their ordinal position within their item type:
        __STRING<i>n</i>__, __PATTERN<i>n</i>__, __DIRECTIVE<i>n</i>__,
        __ACTION<i>n</i>__:</p>
    <p class="Pp"></p>
    <pre>    stuff: /various/ bits 'and' pieces &quot;then&quot; data 'end' { save }
        { print $item{__PATTERN1__}, # PRINTS 'various'
        $item{__STRING2__},  # PRINTS 'then'
        $item{__ACTION1__},  # PRINTS RETURN
                 # VALUE OF save
        }
    </pre>
    <p class="Pp">If you want proper <i>named</i> access to patterns or
        literals, you need to turn them into separate rules:</p>
    <p class="Pp"></p>
    <pre>    stuff: various bits 'and' pieces &quot;then&quot; data 'end'
        { print $item{various}  # PRINTS various
        }
    various: /various/
    </pre>
    <p class="Pp">The special entry <span class="Li">$item{__RULE__}</span>
        stores the name of the current rule (i.e. the same value as
        <span class="Li">$item[0]</span>.</p>
    <p class="Pp">The advantage of using <span class="Li">%item</span>, instead
        of <span class="Li">@items</span> is that it removes the need to track
        items positions that may change as a grammar evolves. For example,
        adding an interim <span class="Li">&quot;&lt;skip&gt;&quot;</span>
        directive of action can silently ruin a trailing action, by moving an
        <span class="Li">@item</span> element &quot;down&quot; the array one
        place. In contrast, the named entry of <span class="Li">%item</span> is
        unaffected by such an insertion.</p>
    <p class="Pp">A limitation of the <span class="Li">%item</span> hash is that
        it only records the <i>last</i> value of a particular subrule. For
        example:</p>
    <p class="Pp"></p>
    <pre>    range: '(' number '..' number )'
        { $return = $item{number} }
    </pre>
    <p class="Pp">will return only the value corresponding to the <i>second</i>
        match of the <span class="Li">&quot;number&quot;</span> subrule. In
        other words, successive calls to a subrule overwrite the corresponding
        entry in <span class="Li">%item</span>. Once again, the solution is to
        rename each subrule in its own rule:</p>
    <p class="Pp"></p>
    <pre>    range: '(' from_num '..' to_num ')'
        { $return = $item{from_num} }
    from_num: number
    to_num:   number
    </pre>
  </dd>
  <dt>@arg and %arg</dt>
  <dd>The array <span class="Li">@arg</span> and the hash
      <span class="Li">%arg</span> store any arguments passed to the rule from
      some other rule (see &quot;Subrule argument lists&quot;). Changes to the
      elements of either variable do not propagate back to the calling rule
      (data can be passed back from a subrule via the
      <span class="Li">$return</span> variable - see next item).</dd>
  <dt>$return</dt>
  <dd>If a value is assigned to <span class="Li">$return</span> within an
      action, that value is returned if the production containing the action
      eventually matches successfully. Note that setting
      <span class="Li">$return</span> <i>doesn't</i> cause the current
      production to succeed. It merely tells it what to return if it <i>does</i>
      succeed. Hence <span class="Li">$return</span> is analogous to
      <span class="Li">$$</span> in a <i>yacc</i> grammar.
    <p class="Pp">If <span class="Li">$return</span> is not assigned within a
        production, the value of the last component of the production (namely:
        <span class="Li">$item[$#item]</span>) is returned if the production
        succeeds.</p>
  </dd>
  <dt>$commit</dt>
  <dd>The current state of commitment to the current production (see
      &quot;Directives&quot; below).</dd>
  <dt>$skip</dt>
  <dd>The current terminal prefix (see &quot;Directives&quot; below).</dd>
  <dt>$text</dt>
  <dd>The remaining (unparsed) text. Changes to <span class="Li">$text</span>
      <i>do not</i> <i>propagate</i> out of unsuccessful productions, but
      <i>do</i> survive successful productions. Hence it is possible to
      dynamically alter the text being parsed - for example, to provide a
      <span class="Li">&quot;#include&quot;</span>-like facility:
    <p class="Pp"></p>
    <pre>    hash_include: '#include' filename
        { $text = ::loadfile($item[2]) . $text }
    filename: '&lt;' /[a-z0-9._-]+/i '&gt;'  { $return = $item[2] }
    | '&quot;' /[a-z0-9._-]+/i '&quot;'  { $return = $item[2] }
    </pre>
  </dd>
  <dt>$thisline and $prevline</dt>
  <dd><span class="Li">$thisline</span> stores the current line number within
      the current parse (starting from 1). <span class="Li">$prevline</span>
      stores the line number for the last character which was already
      successfully parsed (this will be different from
      <span class="Li">$thisline</span> at the end of each line).
    <p class="Pp">For efficiency, <span class="Li">$thisline</span> and
        <span class="Li">$prevline</span> are actually tied hashes, and only
        recompute the required line number when the variable's value is
      used.</p>
    <p class="Pp">Assignment to <span class="Li">$thisline</span> adjusts the
        line number calculator, so that it believes that the current line number
        is the value being assigned. Note that this adjustment will be reflected
        in all subsequent line numbers calculations.</p>
    <p class="Pp">Modifying the value of the variable
        <span class="Li">$text</span> (as in the previous
        <span class="Li">&quot;hash_include&quot;</span> example, for instance)
        will confuse the line counting mechanism. To prevent this, you should
        call
        <span class="Li">&quot;Parse::RecDescent::LineCounter::resync($thisline)&quot;</span>
        <i>immediately</i> after any assignment to the variable
        <span class="Li">$text</span> (or, at least, before the next attempt to
        use <span class="Li">$thisline</span>).</p>
    <p class="Pp">Note that if a production fails after assigning to or
        resync'ing <span class="Li">$thisline</span>, the parser's line counter
        mechanism will usually be corrupted.</p>
    <p class="Pp">Also see the entry for <span class="Li">@itempos</span>.</p>
    <p class="Pp">The line number can be set to values other than 1, by calling
        the start rule with a second argument. For example:</p>
    <p class="Pp"></p>
    <pre>    $parser = new Parse::RecDescent ($grammar);
    $parser-&gt;input($text, 10);  # START LINE NUMBERS AT 10
    </pre>
  </dd>
  <dt>$thiscolumn and $prevcolumn</dt>
  <dd><span class="Li">$thiscolumn</span> stores the current column number
      within the current line being parsed (starting from 1).
      <span class="Li">$prevcolumn</span> stores the column number of the last
      character which was actually successfully parsed. Usually
      <span class="Li">&quot;$prevcolumn == $thiscolumn-1&quot;</span>, but not
      at the end of lines.
    <p class="Pp">For efficiency, <span class="Li">$thiscolumn</span> and
        <span class="Li">$prevcolumn</span> are actually tied hashes, and only
        recompute the required column number when the variable's value is
      used.</p>
    <p class="Pp">Assignment to <span class="Li">$thiscolumn</span> or
        <span class="Li">$prevcolumn</span> is a fatal error.</p>
    <p class="Pp">Modifying the value of the variable
        <span class="Li">$text</span> (as in the previous
        <span class="Li">&quot;hash_include&quot;</span> example, for instance)
        may confuse the column counting mechanism.</p>
    <p class="Pp">Note that <span class="Li">$thiscolumn</span> reports the
        column number <i>before</i> any whitespace that might be skipped before
        reading a token. Hence if you wish to know where a token started (and
        ended) use something like this:</p>
    <p class="Pp"></p>
    <pre>    rule: token1 token2 startcol token3 endcol token4
        { print &quot;token3: columns $item[3] to $item[5]&quot;; }
    startcol: '' { $thiscolumn }    # NEED THE '' TO STEP PAST TOKEN SEP
    endcol:  { $prevcolumn }
    </pre>
    <p class="Pp">Also see the entry for <span class="Li">@itempos</span>.</p>
  </dd>
  <dt>$thisoffset and $prevoffset</dt>
  <dd><span class="Li">$thisoffset</span> stores the offset of the current
      parsing position within the complete text being parsed (starting from 0).
      <span class="Li">$prevoffset</span> stores the offset of the last
      character which was actually successfully parsed. In all cases
      <span class="Li">&quot;$prevoffset == $thisoffset-1&quot;</span>.
    <p class="Pp">For efficiency, <span class="Li">$thisoffset</span> and
        <span class="Li">$prevoffset</span> are actually tied hashes, and only
        recompute the required offset when the variable's value is used.</p>
    <p class="Pp">Assignment to <span class="Li">$thisoffset</span> or
        &lt;$prevoffset&gt; is a fatal error.</p>
    <p class="Pp">Modifying the value of the variable
        <span class="Li">$text</span> will <i>not</i> affect the offset counting
        mechanism.</p>
    <p class="Pp">Also see the entry for <span class="Li">@itempos</span>.</p>
  </dd>
  <dt>@itempos</dt>
  <dd>The array <span class="Li">@itempos</span> stores a hash reference
      corresponding to each element of <span class="Li">@item</span>. The
      elements of the hash provide the following:
    <p class="Pp"></p>
    <pre>    $itempos[$n]{offset}{from}  # VALUE OF $thisoffset BEFORE $item[$n]
    $itempos[$n]{offset}{to}    # VALUE OF $prevoffset AFTER $item[$n]
    $itempos[$n]{line}{from}    # VALUE OF $thisline BEFORE $item[$n]
    $itempos[$n]{line}{to}  # VALUE OF $prevline AFTER $item[$n]
    $itempos[$n]{column}{from}  # VALUE OF $thiscolumn BEFORE $item[$n]
    $itempos[$n]{column}{to}    # VALUE OF $prevcolumn AFTER $item[$n]
    </pre>
    <p class="Pp">Note that the various
        <span class="Li">&quot;$itempos[$n]...{from}&quot;</span> values record
        the appropriate value <i>after</i> any token prefix has been
      skipped.</p>
    <p class="Pp">Hence, instead of the somewhat tedious and error-prone:</p>
    <p class="Pp"></p>
    <pre>    rule: startcol token1 endcol
      startcol token2 endcol
      startcol token3 endcol
        { print &quot;token1: columns $item[1]
              to $item[3]
         token2: columns $item[4]
              to $item[6]
         token3: columns $item[7]
              to $item[9]&quot; }
    startcol: '' { $thiscolumn }    # NEED THE '' TO STEP PAST TOKEN SEP
    endcol:  { $prevcolumn }
    </pre>
    <p class="Pp">it is possible to write:</p>
    <p class="Pp"></p>
    <pre>    rule: token1 token2 token3
        { print &quot;token1: columns $itempos[1]{column}{from}
              to $itempos[1]{column}{to}
         token2: columns $itempos[2]{column}{from}
              to $itempos[2]{column}{to}
         token3: columns $itempos[3]{column}{from}
              to $itempos[3]{column}{to}&quot; }
    </pre>
    <p class="Pp">Note however that (in the current implementation) the use of
        <span class="Li">@itempos</span> anywhere in a grammar implies that item
        positioning information is collected <i>everywhere</i> during the parse.
        Depending on the grammar and the size of the text to be parsed, this may
        be prohibitively expensive and the explicit use of
        <span class="Li">$thisline</span>, <span class="Li">$thiscolumn</span>,
        etc. may be a better choice.</p>
  </dd>
  <dt>$thisparser</dt>
  <dd>A reference to the <span class="Li">&quot;Parse::RecDescent&quot;</span>
      object through which parsing was initiated.
    <p class="Pp">The value of <span class="Li">$thisparser</span> propagates
        down the subrules of a parse but not back up. Hence, you can invoke
        subrules from another parser for the scope of the current rule as
        follows:</p>
    <p class="Pp"></p>
    <pre>    rule: subrule1 subrule2
    | { $thisparser = $::otherparser } &lt;reject&gt;
    | subrule3 subrule4
    | subrule5
    </pre>
    <p class="Pp">The result is that the production calls &quot;subrule1&quot;
        and &quot;subrule2&quot; of the current parser, and the remaining
        productions call the named subrules from
        <span class="Li">$::otherparser</span>. Note, however that &quot;Bad
        Things&quot; will happen if
        <span class="Li">&quot;::otherparser&quot;</span> isn't a blessed
        reference and/or doesn't have methods with the same names as the
        required subrules!</p>
  </dd>
  <dt>$thisrule</dt>
  <dd>A reference to the
      <span class="Li">&quot;Parse::RecDescent::Rule&quot;</span> object
      corresponding to the rule currently being matched.</dd>
  <dt>$thisprod</dt>
  <dd>A reference to the
      <span class="Li">&quot;Parse::RecDescent::Production&quot;</span> object
      corresponding to the production currently being matched.</dd>
  <dt>$score and $score_return</dt>
  <dd><span class="Li">$score</span> stores the best production score to date,
      as specified by an earlier
      <span class="Li">&quot;&lt;score:...&gt;&quot;</span> directive.
      <span class="Li">$score_return</span> stores the corresponding return
      value for the successful production.
    <p class="Pp">See &quot;Scored productions&quot;.</p>
  </dd>
</dl>
<p class="Pp"><b>Warning:</b> the parser relies on the information in the
    various <span class="Li">&quot;this...&quot;</span> objects in some
    non-obvious ways. Tinkering with the other members of these objects will
    probably cause Bad Things to happen, unless you <i>really</i> know what
    you're doing. The only exception to this advice is that the use of
    <span class="Li">&quot;$this...-&gt;{local}&quot;</span> is always safe.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Start-up_Actions"><a class="permalink" href="#Start-up_Actions">Start-up
  Actions</a></h2>
<p class="Pp">Any actions which appear <i>before</i> the first rule definition
    in a grammar are treated as &quot;start-up&quot; actions. Each such action
    is stripped of its outermost brackets and then evaluated (in the parser's
    special namespace) just before the rules of the grammar are first
  compiled.</p>
<p class="Pp">The main use of start-up actions is to declare local variables
    within the parser's special namespace:</p>
<p class="Pp"></p>
<pre>    { my $lastitem = '???'; }
    list: item(s)   { $return = $lastitem }
    item: book  { $lastitem = 'book'; }
      bell  { $lastitem = 'bell'; }
      candle    { $lastitem = 'candle'; }
</pre>
<p class="Pp">but start-up actions can be used to execute <i>any</i> valid Perl
    code within a parser's special namespace.</p>
<p class="Pp">Start-up actions can appear within a grammar extension or
    replacement (that is, a partial grammar installed via
    <span class="Li">&quot;Parse::RecDescent::Extend()&quot;</span> or
    <span class="Li">&quot;Parse::RecDescent::Replace()&quot;</span> - see
    &quot;Incremental Parsing&quot;), and will be executed before the new
    grammar is installed. Note, however, that a particular start-up action is
    only ever executed once.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Autoactions"><a class="permalink" href="#Autoactions">Autoactions</a></h2>
<p class="Pp">It is sometimes desirable to be able to specify a default action
    to be taken at the end of every production (for example, in order to easily
    build a parse tree). If the variable
    <span class="Li">$::RD_AUTOACTION</span> is defined when
    <span class="Li">&quot;Parse::RecDescent::new()&quot;</span> is called, the
    contents of that variable are treated as a specification of an action which
    is to appended to each production in the corresponding grammar.</p>
<p class="Pp">Alternatively, you can hard-code the autoaction within a grammar,
    using the <span class="Li">&quot;&lt;autoaction:...&gt;&quot;</span>
    directive.</p>
<p class="Pp">So, for example, to construct a simple parse tree you could
  write:</p>
<p class="Pp"></p>
<pre>    $::RD_AUTOACTION = q { [@item] };
    parser = Parse::RecDescent-&gt;new(q{
    expression: and_expr '||' expression | and_expr
    and_expr:   not_expr '&amp;&amp;' and_expr   | not_expr
    not_expr:   '!' brack_expr       | brack_expr
    brack_expr: '(' expression ')'       | identifier
    identifier: /[a-z]+/i
    });
</pre>
<p class="Pp">or:</p>
<p class="Pp"></p>
<pre>    parser = Parse::RecDescent-&gt;new(q{
    &lt;autoaction: { [@item] } &gt;
    expression: and_expr '||' expression | and_expr
    and_expr:   not_expr '&amp;&amp;' and_expr   | not_expr
    not_expr:   '!' brack_expr       | brack_expr
    brack_expr: '(' expression ')'       | identifier
    identifier: /[a-z]+/i
    });
</pre>
<p class="Pp">Either of these is equivalent to:</p>
<p class="Pp"></p>
<pre>    parser = new Parse::RecDescent (q{
    expression: and_expr '||' expression
        { [@item] }
      | and_expr
        { [@item] }
    and_expr:   not_expr '&amp;&amp;' and_expr
        { [@item] }
    |   not_expr
        { [@item] }
    not_expr:   '!' brack_expr
        { [@item] }
    |   brack_expr
        { [@item] }
    brack_expr: '(' expression ')'
        { [@item] }
      | identifier
        { [@item] }
    identifier: /[a-z]+/i
        { [@item] }
    });
</pre>
<p class="Pp">Alternatively, we could take an object-oriented approach, use
    different classes for each node (and also eliminating redundant intermediate
    nodes):</p>
<p class="Pp"></p>
<pre>    $::RD_AUTOACTION = q
      { $#item==1 ? $item[1] : &quot;$item[0]_node&quot;-&gt;new(@item[1..$#item]) };
    parser = Parse::RecDescent-&gt;new(q{
        expression: and_expr '||' expression | and_expr
        and_expr:   not_expr '&amp;&amp;' and_expr   | not_expr
        not_expr:   '!' brack_expr           | brack_expr
        brack_expr: '(' expression ')'       | identifier
        identifier: /[a-z]+/i
    });
</pre>
<p class="Pp">or:</p>
<p class="Pp"></p>
<pre>    parser = Parse::RecDescent-&gt;new(q{
        &lt;autoaction:
          $#item==1 ? $item[1] : &quot;$item[0]_node&quot;-&gt;new(@item[1..$#item])
        &gt;
        expression: and_expr '||' expression | and_expr
        and_expr:   not_expr '&amp;&amp;' and_expr   | not_expr
        not_expr:   '!' brack_expr           | brack_expr
        brack_expr: '(' expression ')'       | identifier
        identifier: /[a-z]+/i
    });
</pre>
<p class="Pp">which are equivalent to:</p>
<p class="Pp"></p>
<pre>    parser = Parse::RecDescent-&gt;new(q{
        expression: and_expr '||' expression
            { &quot;expression_node&quot;-&gt;new(@item[1..3]) }
        | and_expr
        and_expr:   not_expr '&amp;&amp;' and_expr
            { &quot;and_expr_node&quot;-&gt;new(@item[1..3]) }
        |   not_expr
        not_expr:   '!' brack_expr
            { &quot;not_expr_node&quot;-&gt;new(@item[1..2]) }
        |   brack_expr
        brack_expr: '(' expression ')'
            { &quot;brack_expr_node&quot;-&gt;new(@item[1..3]) }
        | identifier
        identifier: /[a-z]+/i
            { &quot;identifer_node&quot;-&gt;new(@item[1]) }
    });
</pre>
<p class="Pp">Note that, if a production already ends in an action, no
    autoaction is appended to it. For example, in this version:</p>
<p class="Pp"></p>
<pre>    $::RD_AUTOACTION = q
      { $#item==1 ? $item[1] : &quot;$item[0]_node&quot;-&gt;new(@item[1..$#item]) };
    parser = Parse::RecDescent-&gt;new(q{
        expression: and_expr '&amp;&amp;' expression | and_expr
        and_expr:   not_expr '&amp;&amp;' and_expr   | not_expr
        not_expr:   '!' brack_expr           | brack_expr
        brack_expr: '(' expression ')'       | identifier
        identifier: /[a-z]+/i
            { 'terminal_node'-&gt;new($item[1]) }
    });
</pre>
<p class="Pp">each <span class="Li">&quot;identifier&quot;</span> match produces
    a <span class="Li">&quot;terminal_node&quot;</span> object, <i>not</i> an
    <span class="Li">&quot;identifier_node&quot;</span> object.</p>
<p class="Pp">A level 1 warning is issued each time an &quot;autoaction&quot; is
    added to some production.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Autotrees"><a class="permalink" href="#Autotrees">Autotrees</a></h2>
<p class="Pp">A commonly needed autoaction is one that builds a parse-tree. It
    is moderately tricky to set up such an action (which must treat terminals
    differently from non-terminals), so Parse::RecDescent simplifies the process
    by providing the <span class="Li">&quot;&lt;autotree&gt;&quot;</span>
    directive.</p>
<p class="Pp">If this directive appears at the start of grammar, it causes
    Parse::RecDescent to insert autoactions at the end of any rule except those
    which already end in an action. The action inserted depends on whether the
    production is an intermediate rule (two or more items), or a terminal of the
    grammar (i.e. a single pattern or string item).</p>
<p class="Pp">So, for example, the following grammar:</p>
<p class="Pp"></p>
<pre>    &lt;autotree&gt;
    file    : command(s)
    command : get | set | vet
    get : 'get' ident ';'
    set : 'set' ident 'to' value ';'
    vet : 'check' ident 'is' value ';'
    ident   : /\w+/
    value   : /\d+/
</pre>
<p class="Pp">is equivalent to:</p>
<p class="Pp"></p>
<pre>    file    : command(s)        { bless \%item, $item[0] }
    command : get       { bless \%item, $item[0] }
    | set           { bless \%item, $item[0] }
    | vet           { bless \%item, $item[0] }
    get : 'get' ident ';'   { bless \%item, $item[0] }
    set : 'set' ident 'to' value ';'    { bless \%item, $item[0] }
    vet : 'check' ident 'is' value ';'  { bless \%item, $item[0] }
    ident   : /\w+/  { bless {__VALUE__=&gt;$item[1]}, $item[0] }
    value   : /\d+/  { bless {__VALUE__=&gt;$item[1]}, $item[0] }
</pre>
<p class="Pp">Note that each node in the tree is blessed into a class of the
    same name as the rule itself. This makes it easy to build object-oriented
    processors for the parse-trees that the grammar produces. Note too that the
    last two rules produce special objects with the single attribute
    '__VALUE__'. This is because they consist solely of a single terminal.</p>
<p class="Pp">This autoaction-ed grammar would then produce a parse tree in a
    data structure like this:</p>
<p class="Pp"></p>
<pre>    {
      file =&gt; {
        command =&gt; {
         [ get =&gt; {
            identifier =&gt; { __VALUE__ =&gt; 'a' },
              },
           set =&gt; {
            identifier =&gt; { __VALUE__ =&gt; 'b' },
            value      =&gt; { __VALUE__ =&gt; '7' },
              },
           vet =&gt; {
            identifier =&gt; { __VALUE__ =&gt; 'b' },
            value      =&gt; { __VALUE__ =&gt; '7' },
              },
          ],
           },
      }
    }
</pre>
<p class="Pp">(except, of course, that each nested hash would also be blessed
    into the appropriate class).</p>
<p class="Pp">You can also specify a base class for the
    <span class="Li">&quot;&lt;autotree&gt;&quot;</span> directive. The supplied
    prefix will be prepended to the rule names when creating tree nodes. The
    following are equivalent:</p>
<p class="Pp"></p>
<pre>    &lt;autotree:MyBase::Class&gt;
    &lt;autotree:MyBase::Class::&gt;
</pre>
<p class="Pp">And will produce a root node blessed into the
    <span class="Li">&quot;MyBase::Class::file&quot;</span> package in the
    example above.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Autostubbing"><a class="permalink" href="#Autostubbing">Autostubbing</a></h2>
<p class="Pp">Normally, if a subrule appears in some production, but no rule of
    that name is ever defined in the grammar, the production which refers to the
    non-existent subrule fails immediately. This typically occurs as a result of
    misspellings, and is a sufficiently common occurrence that a warning is
    generated for such situations.</p>
<p class="Pp">However, when prototyping a grammar it is sometimes useful to be
    able to use subrules before a proper specification of them is really
    possible. For example, a grammar might include a section like:</p>
<p class="Pp"></p>
<pre>    function_call: identifier '(' arg(s?) ')'
    identifier: /[a-z]\w*/i
</pre>
<p class="Pp">where the possible format of an argument is sufficiently complex
    that it is not worth specifying in full until the general function call
    syntax has been debugged. In this situation it is convenient to leave the
    real rule <span class="Li">&quot;arg&quot;</span> undefined and just slip in
    a placeholder (or &quot;stub&quot;):</p>
<p class="Pp"></p>
<pre>    arg: 'arg'
</pre>
<p class="Pp">so that the function call syntax can be tested with dummy input
    such as:</p>
<p class="Pp"></p>
<pre>    f0()
    f1(arg)
    f2(arg arg)
    f3(arg arg arg)
</pre>
<p class="Pp">et cetera.</p>
<p class="Pp">Early in prototyping, many such &quot;stubs&quot; may be required,
    so <span class="Li">&quot;Parse::RecDescent&quot;</span> provides a means of
    automating their definition. If the variable
    <span class="Li">$::RD_AUTOSTUB</span> is defined when a parser is built, a
    subrule reference to any non-existent rule (say,
    <span class="Li">&quot;subrule&quot;</span>), will cause a &quot;stub&quot;
    rule to be automatically defined in the generated parser. If
    <span class="Li">&quot;$::RD_AUTOSTUB eq '1'&quot;</span> or is false, a
    stub rule of the form:</p>
<p class="Pp"></p>
<pre>    subrule: 'subrule'
</pre>
<p class="Pp">will be generated. The special-case for a value of
    <span class="Li">'1'</span> is to allow the use of the <b>perl -s</b> with
    <b>-RD_AUTOSTUB</b> without generating <span class="Li">&quot;subrule:
    '1'&quot;</span> per below. If <span class="Li">$::RD_AUTOSTUB</span> is
    true, a stub rule of the form:</p>
<p class="Pp"></p>
<pre>    subrule: $::RD_AUTOSTUB
</pre>
<p class="Pp">will be generated. <span class="Li">$::RD_AUTOSTUB</span> must
    contain a valid production item, no checking is performed. No lazy
    evaluation of <span class="Li">$::RD_AUTOSTUB</span> is performed, it is
    evaluated at the time the Parser is generated.</p>
<p class="Pp">Hence, with <span class="Li">$::RD_AUTOSTUB</span> defined, it is
    possible to only partially specify a grammar, and then &quot;fake&quot;
    matches of the unspecified (sub)rules by just typing in their name, or a
    literal value that was assigned to
  <span class="Li">$::RD_AUTOSTUB</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Look-ahead"><a class="permalink" href="#Look-ahead">Look-ahead</a></h2>
<p class="Pp">If a subrule, token, or action is prefixed by &quot;...&quot;,
    then it is treated as a &quot;look-ahead&quot; request. That means that the
    current production can (as usual) only succeed if the specified item is
    matched, but that the matching <i>does not consume any of the text being
    parsed</i>. This is very similar to the
    <span class="Li">&quot;/(?=...)/&quot;</span> look-ahead construct in Perl
    patterns. Thus, the rule:</p>
<p class="Pp"></p>
<pre>    inner_word: word ...word
</pre>
<p class="Pp">will match whatever the subrule &quot;word&quot; matches, provided
    that match is followed by some more text which subrule &quot;word&quot;
    would also match (although this second substring is not actually consumed by
    &quot;inner_word&quot;)</p>
<p class="Pp">Likewise, a &quot;...!&quot; prefix, causes the following item to
    succeed (without consuming any text) if and only if it would normally fail.
    Hence, a rule such as:</p>
<p class="Pp"></p>
<pre>    identifier: ...!keyword ...!'_' /[A-Za-z_]\w*/
</pre>
<p class="Pp">matches a string of characters which satisfies the pattern
    <span class="Li">&quot;/[A-Za-z_]\w*/&quot;</span>, but only if the same
    sequence of characters would not match either subrule &quot;keyword&quot; or
    the literal token '_'.</p>
<p class="Pp">Sequences of look-ahead prefixes accumulate, multiplying their
    positive and/or negative senses. Hence:</p>
<p class="Pp"></p>
<pre>    inner_word: word ...!......!word
</pre>
<p class="Pp">is exactly equivalent to the original example above (a warning is
    issued in cases like these, since they often indicate something left out, or
    misunderstood).</p>
<p class="Pp">Note that actions can also be treated as look-aheads. In such
    cases, the state of the parser text (in the local variable
    <span class="Li">$text</span>) <i>after</i> the look-ahead action is
    guaranteed to be identical to its state <i>before</i> the action, regardless
    of how it's changed <i>within</i> the action (unless you actually undefine
    <span class="Li">$text</span>, in which case you get the disaster you
    deserve :-).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Directives"><a class="permalink" href="#Directives">Directives</a></h2>
<p class="Pp">Directives are special pre-defined actions which may be used to
    alter the behaviour of the parser. There are currently twenty-three
    directives: <span class="Li">&quot;&lt;commit&gt;&quot;</span>,
    <span class="Li">&quot;&lt;uncommit&gt;&quot;</span>,
    <span class="Li">&quot;&lt;reject&gt;&quot;</span>,
    <span class="Li">&quot;&lt;score&gt;&quot;</span>,
    <span class="Li">&quot;&lt;autoscore&gt;&quot;</span>,
    <span class="Li">&quot;&lt;skip&gt;&quot;</span>,
    <span class="Li">&quot;&lt;resync&gt;&quot;</span>,
    <span class="Li">&quot;&lt;error&gt;&quot;</span>,
    <span class="Li">&quot;&lt;warn&gt;&quot;</span>,
    <span class="Li">&quot;&lt;hint&gt;&quot;</span>,
    <span class="Li">&quot;&lt;trace_build&gt;&quot;</span>,
    <span class="Li">&quot;&lt;trace_parse&gt;&quot;</span>,
    <span class="Li">&quot;&lt;nocheck&gt;&quot;</span>,
    <span class="Li">&quot;&lt;rulevar&gt;&quot;</span>,
    <span class="Li">&quot;&lt;matchrule&gt;&quot;</span>,
    <span class="Li">&quot;&lt;leftop&gt;&quot;</span>,
    <span class="Li">&quot;&lt;rightop&gt;&quot;</span>,
    <span class="Li">&quot;&lt;defer&gt;&quot;</span>,
    <span class="Li">&quot;&lt;nocheck&gt;&quot;</span>,
    <span class="Li">&quot;&lt;perl_quotelike&gt;&quot;</span>,
    <span class="Li">&quot;&lt;perl_codeblock&gt;&quot;</span>,
    <span class="Li">&quot;&lt;perl_variable&gt;&quot;</span>, and
    <span class="Li">&quot;&lt;token&gt;&quot;</span>.</p>
<dl class="Bl-tag">
  <dt id="Committing"><a class="permalink" href="#Committing">Committing and
    uncommitting</a></dt>
  <dd>The <span class="Li">&quot;&lt;commit&gt;&quot;</span> and
      <span class="Li">&quot;&lt;uncommit&gt;&quot;</span> directives permit the
      recursive descent of the parse tree to be pruned (or &quot;cut&quot;) for
      efficiency. Within a rule, a
      <span class="Li">&quot;&lt;commit&gt;&quot;</span> directive instructs the
      rule to ignore subsequent productions if the current production fails. For
      example:
    <p class="Pp"></p>
    <pre>    command: 'find' &lt;commit&gt; filename
       | 'open' &lt;commit&gt; filename
       | 'move' filename filename
    </pre>
    <p class="Pp">Clearly, if the leading token 'find' is matched in the first
        production but that production fails for some other reason, then the
        remaining productions cannot possibly match. The presence of the
        <span class="Li">&quot;&lt;commit&gt;&quot;</span> causes the
        &quot;command&quot; rule to fail immediately if an invalid
        &quot;find&quot; command is found, and likewise if an invalid
        &quot;open&quot; command is encountered.</p>
    <p class="Pp">It is also possible to revoke a previous commitment. For
        example:</p>
    <p class="Pp"></p>
    <pre>    if_statement: 'if' &lt;commit&gt; condition
        'then' block &lt;uncommit&gt;
        'else' block
        | 'if' &lt;commit&gt; condition
        'then' block
    </pre>
    <p class="Pp">In this case, a failure to find an &quot;else&quot; block in
        the first production shouldn't preclude trying the second production,
        but a failure to find a &quot;condition&quot; certainly should.</p>
    <p class="Pp">As a special case, any production in which the <i>first</i>
        item is an <span class="Li">&quot;&lt;uncommit&gt;&quot;</span>
        immediately revokes a preceding
        <span class="Li">&quot;&lt;commit&gt;&quot;</span> (even though the
        production would not otherwise have been tried). For example, in the
        rule:</p>
    <p class="Pp"></p>
    <pre>    request: 'explain' expression
           | 'explain' &lt;commit&gt; keyword
           | 'save'
           | 'quit'
           | &lt;uncommit&gt; term '?'
    </pre>
    <p class="Pp">if the text being matched was &quot;explain?&quot;, and the
        first two productions failed, then the
        <span class="Li">&quot;&lt;commit&gt;&quot;</span> in production two
        would cause productions three and four to be skipped, but the leading
        <span class="Li">&quot;&lt;uncommit&gt;&quot;</span> in the production
        five would allow that production to attempt a match.</p>
    <p class="Pp">Note in the preceding example, that the
        <span class="Li">&quot;&lt;commit&gt;&quot;</span> was only placed in
        production two. If production one had been:</p>
    <p class="Pp"></p>
    <pre>    request: 'explain' &lt;commit&gt; expression
    </pre>
    <p class="Pp">then production two would be (inappropriately) skipped if a
        leading &quot;explain...&quot; was encountered.</p>
    <p class="Pp">Both <span class="Li">&quot;&lt;commit&gt;&quot;</span> and
        <span class="Li">&quot;&lt;uncommit&gt;&quot;</span> directives always
        succeed, and their value is always 1.</p>
  </dd>
  <dt id="Rejecting"><a class="permalink" href="#Rejecting">Rejecting a
    production</a></dt>
  <dd>The <span class="Li">&quot;&lt;reject&gt;&quot;</span> directive
      immediately causes the current production to fail (it is exactly
      equivalent to, but more obvious than, the action
      <span class="Li">&quot;{undef}&quot;</span>). A
      <span class="Li">&quot;&lt;reject&gt;&quot;</span> is useful when it is
      desirable to get the side effects of the actions in one production,
      without prejudicing a match by some other production later in the rule.
      For example, to insert tracing code into the parse:
    <p class="Pp"></p>
    <pre>    complex_rule: { print &quot;In complex rule...\n&quot;; } &lt;reject&gt;
    complex_rule: simple_rule '+' 'i' '*' simple_rule
        | 'i' '*' simple_rule
        | simple_rule
    </pre>
    <p class="Pp">It is also possible to specify a conditional rejection, using
        the form
        <span class="Li">&quot;&lt;reject:</span><span class="Li"><i>condition</i></span><span class="Li">&gt;&quot;</span>,
        which only rejects if the specified condition is true. This form of
        rejection is exactly equivalent to the action
        <span class="Li">&quot;{(</span><span class="Li"><i>condition</i></span><span class="Li">)?undef:1}&gt;&quot;</span>.
        For example:</p>
    <p class="Pp"></p>
    <pre>    command: save_command
       | restore_command
       | &lt;reject: defined $::tolerant&gt; { exit }
       | &lt;error: Unknown command. Ignored.&gt;
    </pre>
    <p class="Pp">A <span class="Li">&quot;&lt;reject&gt;&quot;</span> directive
        never succeeds (and hence has no associated value). A conditional
        rejection may succeed (if its condition is not satisfied), in which case
        its value is 1.</p>
    <p class="Pp">As an extra optimization,
        <span class="Li">&quot;Parse::RecDescent&quot;</span> ignores any
        production which <i>begins</i> with an unconditional
        <span class="Li">&quot;&lt;reject&gt;&quot;</span> directive, since any
        such production can never successfully match or have any useful
        side-effects. A level 1 warning is issued in all such cases.</p>
    <p class="Pp">Note that productions beginning with conditional
        <span class="Li">&quot;&lt;reject:...&gt;&quot;</span> directives are
        <i>never</i> &quot;optimized away&quot; in this manner, even if they are
        always guaranteed to fail (for example:
        <span class="Li">&quot;&lt;reject:1&gt;&quot;</span>)</p>
    <p class="Pp">Due to the way grammars are parsed, there is a minor
        restriction on the condition of a conditional
        <span class="Li">&quot;&lt;reject:...&gt;&quot;</span>: it cannot
        contain any raw '&lt;' or '&gt;' characters. For example:</p>
    <p class="Pp"></p>
    <pre>    line: cmd &lt;reject: $thiscolumn &gt; max&gt; data
    </pre>
    <p class="Pp">results in an error when a parser is built from this grammar
        (since the grammar parser has no way of knowing whether the first &gt;
        is a &quot;less than&quot; or the end of the
        <span class="Li">&quot;&lt;reject:...&gt;&quot;</span>.</p>
    <p class="Pp">To overcome this problem, put the condition inside a do{}
        block:</p>
    <p class="Pp"></p>
    <pre>    line: cmd &lt;reject: do{$thiscolumn &gt; max}&gt; data
    </pre>
    <p class="Pp">Note that the same problem may occur in other directives that
        take arguments. The same solution will work in all cases.</p>
  </dd>
  <dt id="Skipping"><a class="permalink" href="#Skipping">Skipping between
    terminals</a></dt>
  <dd>The <span class="Li">&quot;&lt;skip&gt;&quot;</span> directive enables the
      terminal prefix used in a production to be changed. For example:
    <p class="Pp"></p>
    <pre>    OneLiner: Command &lt;skip:'[ \t]*'&gt; Arg(s) /;/
    </pre>
    <p class="Pp">causes only blanks and tabs to be skipped before terminals in
        the <span class="Li">&quot;Arg&quot;</span> subrule (and any of
        <i>its</i> subrules&gt;, and also before the final
        <span class="Li">&quot;/;/&quot;</span> terminal. Once the production is
        complete, the previous terminal prefix is reinstated. Note that this
        implies that distinct productions of a rule must reset their terminal
        prefixes individually.</p>
    <p class="Pp">The <span class="Li">&quot;&lt;skip&gt;&quot;</span> directive
        evaluates to the <i>previous</i> terminal prefix, so it's easy to
        reinstate a prefix later in a production:</p>
    <p class="Pp"></p>
    <pre>    Command: &lt;skip:&quot;,&quot;&gt; CSV(s) &lt;skip:$item[1]&gt; Modifier
    </pre>
    <p class="Pp">The value specified after the colon is interpolated into a
        pattern, so all of the following are equivalent (though their efficiency
        increases down the list):</p>
    <p class="Pp"></p>
    <pre>    &lt;skip: &quot;$colon|$comma&quot;&gt;   # ASSUMING THE VARS HOLD THE OBVIOUS VALUES
    &lt;skip: ':|,'&gt;
    &lt;skip: q{[:,]}&gt;
    &lt;skip: qr/[:,]/&gt;
    </pre>
    <p class="Pp">There is no way of directly setting the prefix for an entire
        rule, except as follows:</p>
    <p class="Pp"></p>
    <pre>    Rule: &lt;skip: '[ \t]*'&gt; Prod1
        | &lt;skip: '[ \t]*'&gt; Prod2a Prod2b
        | &lt;skip: '[ \t]*'&gt; Prod3
    </pre>
    <p class="Pp">or, better:</p>
    <p class="Pp"></p>
    <pre>    Rule: &lt;skip: '[ \t]*'&gt;
    (
        Prod1
      | Prod2a Prod2b
      | Prod3
    )
    </pre>
    <p class="Pp">The skip pattern is passed down to subrules, so setting the
        skip for the top-level rule as described above actually sets the prefix
        for the entire grammar (provided that you only call the method
        corresponding to the top-level rule itself). Alternatively, or if you
        have more than one top-level rule in your grammar, you can provide a
        global <span class="Li">&quot;&lt;skip&gt;&quot;</span> directive prior
        to defining any rules in the grammar. These are the preferred
        alternatives to setting
        <span class="Li">$Parse::RecDescent::skip</span>.</p>
    <p class="Pp">Additionally, using
        <span class="Li">&quot;&lt;skip&gt;&quot;</span> actually allows you to
        have a completely dynamic skipping behaviour. For example:</p>
    <p class="Pp"></p>
    <pre>   Rule_with_dynamic_skip: &lt;skip: $::skip_pattern&gt; Rule
    </pre>
    <p class="Pp">Then you can set <span class="Li">$::skip_pattern</span>
        before invoking
        <span class="Li">&quot;Rule_with_dynamic_skip&quot;</span> and have it
        skip whatever you specified.</p>
    <p class="Pp"><b>Note: Up to release 1.51 of Parse::RecDescent, an entirely
        different</b> <b>mechanism was used for specifying terminal prefixes.
        The current</b> <b>method is not backwards-compatible with that early
        approach. The</b> <b>current approach is stable and will not change
        again.</b></p>
    <p class="Pp"><b>Note: the global
        </b><span class="Li"><b>&quot;&lt;skip&gt;&quot;</b></span><b> directive
        added in 1.967_004 did</b> <b>not interpolate the pattern argument,
        instead the pattern was placed</b> <b>inside of single quotes and then
        interpolated. This behavior was</b> <b>changed in 1.967_010 so that all
        </b><span class="Li"><b>&quot;&lt;skip&gt;&quot;</b></span><b>
        directives behavior</b> <b>similarly.</b></p>
  </dd>
  <dt id="Resynchronization"><a class="permalink" href="#Resynchronization">Resynchronization</a></dt>
  <dd>The <span class="Li">&quot;&lt;resync&gt;&quot;</span> directive provides
      a visually distinctive means of consuming some of the text being parsed,
      usually to skip an erroneous input. In its simplest form
      <span class="Li">&quot;&lt;resync&gt;&quot;</span> simply consumes text up
      to and including the next newline (<span class="Li">&quot;\n&quot;</span>)
      character, succeeding only if the newline is found, in which case it
      causes its surrounding rule to return zero on success.
    <p class="Pp">In other words, a
        <span class="Li">&quot;&lt;resync&gt;&quot;</span> is exactly equivalent
        to the token <span class="Li">&quot;/[^\n]*\n/&quot;</span> followed by
        the action
        <span class="Li">&quot;{&#x00A0;$return&#x00A0;=&#x00A0;0&#x00A0;}&quot;</span>
        (except that productions beginning with a
        <span class="Li">&quot;&lt;resync&gt;&quot;</span> are ignored when
        generating error messages). A typical use might be:</p>
    <p class="Pp"></p>
    <pre>    script : command(s)
    command: save_command
       | restore_command
       | &lt;resync&gt; # TRY NEXT LINE, IF POSSIBLE
    </pre>
    <p class="Pp">It is also possible to explicitly specify a resynchronization
        pattern, using the
        <span class="Li">&quot;&lt;resync:</span><span class="Li"><i>pattern</i></span><span class="Li">&gt;&quot;</span>
        variant. This version succeeds only if the specified pattern matches
        (and consumes) the parsed text. In other words,
        <span class="Li">&quot;&lt;resync:</span><span class="Li"><i>pattern</i></span><span class="Li">&gt;&quot;</span>
        is exactly equivalent to the token
        <span class="Li">&quot;/</span><span class="Li"><i>pattern</i></span><span class="Li">/&quot;</span>
        (followed by a
        <span class="Li">&quot;{&#x00A0;$return&#x00A0;=&#x00A0;0&#x00A0;}&quot;</span>
        action). For example, if commands were terminated by newlines or
        semi-colons:</p>
    <p class="Pp"></p>
    <pre>    command: save_command
       | restore_command
       | &lt;resync:[^;\n]*[;\n]&gt;
    </pre>
    <p class="Pp">The value of a successfully matched
        <span class="Li">&quot;&lt;resync&gt;&quot;</span> directive (of either
        type) is the text that it consumed. Note, however, that since the
        directive also sets <span class="Li">$return</span>, a production
        consisting of a lone <span class="Li">&quot;&lt;resync&gt;&quot;</span>
        succeeds but returns the value zero (which a calling rule may find
        useful to distinguish between &quot;true&quot; matches and
        &quot;tolerant&quot; matches). Remember that returning a zero value
        indicates that the rule <i>succeeded</i> (since only an
        <span class="Li">&quot;undef&quot;</span> denotes failure within
        <span class="Li">&quot;Parse::RecDescent&quot;</span> parsers.</p>
  </dd>
  <dt id="Error"><a class="permalink" href="#Error">Error handling</a></dt>
  <dd>The <span class="Li">&quot;&lt;error&gt;&quot;</span> directive provides
      automatic or user-defined generation of error messages during a parse. In
      its simplest form <span class="Li">&quot;&lt;error&gt;&quot;</span>
      prepares an error message based on the mismatch between the last item
      expected and the text which cause it to fail. For example, given the rule:
    <p class="Pp"></p>
    <pre>    McCoy: curse ',' name ', I'm a doctor, not a' a_profession '!'
     | pronoun 'dead,' name '!'
     | &lt;error&gt;
    </pre>
    <p class="Pp">the following strings would produce the following
      messages:</p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>&quot;Amen, Jim!&quot;</dt>
  <dd>
    <pre>       ERROR (line 1): Invalid McCoy: Expected curse or pronoun
           not found
    </pre>
  </dd>
  <dt>&quot;Dammit, Jim, I'm a doctor!&quot;</dt>
  <dd>
    <pre>       ERROR (line 1): Invalid McCoy: Expected &quot;, I'm a doctor, not a&quot;
           but found &quot;, I'm a doctor!&quot; instead
    </pre>
  </dd>
  <dt>&quot;He's dead,\n&quot;</dt>
  <dd>
    <pre>       ERROR (line 2): Invalid McCoy: Expected name not found
    </pre>
  </dd>
  <dt>&quot;He's alive!&quot;</dt>
  <dd>
    <pre>       ERROR (line 1): Invalid McCoy: Expected 'dead,' but found
           &quot;alive!&quot; instead
    </pre>
  </dd>
  <dt>&quot;Dammit, Jim, I'm a doctor, not a pointy-eared Vulcan!&quot;</dt>
  <dd>
    <pre>       ERROR (line 1): Invalid McCoy: Expected a profession but found
           &quot;pointy-eared Vulcan!&quot; instead
    </pre>
  </dd>
</dl>
</div>
<div class="Bd-indent">
<p class="Pp">Note that, when autogenerating error messages, all underscores in
    any rule name used in a message are replaced by single spaces (for example
    &quot;a_production&quot; becomes &quot;a production&quot;). Judicious choice
    of rule names can therefore considerably improve the readability of
    automatic error messages (as well as the maintainability of the original
    grammar).</p>
<p class="Pp">If the automatically generated error is not sufficient, it is
    possible to provide an explicit message as part of the error directive. For
    example:</p>
<p class="Pp"></p>
<pre>    Spock: &quot;Fascinating ',' (name | 'Captain') '.'
     | &quot;Highly illogical, doctor.&quot;
     | &lt;error: He never said that!&gt;
</pre>
<p class="Pp">which would result in <i>all</i> failures to parse a
    &quot;Spock&quot; subrule printing the following message:</p>
<p class="Pp"></p>
<pre>       ERROR (line &lt;N&gt;): Invalid Spock:  He never said that!
</pre>
<p class="Pp">The error message is treated as a &quot;qq{...}&quot; string and
    interpolated when the error is generated (<i>not</i> when the directive is
    specified!). Hence:</p>
<p class="Pp"></p>
<pre>    &lt;error: Mystical error near &quot;$text&quot;&gt;
</pre>
<p class="Pp">would correctly insert the ambient text string which caused the
    error.</p>
<p class="Pp">There are two other forms of error directive:
    <span class="Li">&quot;&lt;error?&gt;&quot;</span> and
    <span class="Li">&quot;&lt;error?:&#x00A0;msg&gt;&quot;</span>. These behave
    just like <span class="Li">&quot;&lt;error&gt;&quot;</span> and
    <span class="Li">&quot;&lt;error:&#x00A0;msg&gt;&quot;</span> respectively,
    except that they are only triggered if the rule is &quot;committed&quot; at
    the time they are encountered. For example:</p>
<p class="Pp"></p>
<pre>    Scotty: &quot;Ya kenna change the Laws of Phusics,&quot; &lt;commit&gt; name
      | name &lt;commit&gt; ',' 'she's goanta blaw!'
      | &lt;error?&gt;
</pre>
<p class="Pp">will only generate an error for a string beginning with &quot;Ya
    kenna change the Laws o' Phusics,&quot; or a valid name, but which still
    fails to match the corresponding production. That is,
    <span class="Li">&quot;$parser-&gt;Scotty(&quot;Aye,
    Cap'ain&quot;)&quot;</span> will fail silently (since neither production
    will &quot;commit&quot; the rule on that input), whereas
    <span class="Li">&quot;$parser-&gt;Scotty(&quot;Mr&#x00A0;Spock,&#x00A0;ah&#x00A0;jest&#x00A0;kenna&#x00A0;do'ut!&quot;)&quot;</span>
    will fail with the error message:</p>
<p class="Pp"></p>
<pre>       ERROR (line 1): Invalid Scotty: expected 'she's goanta blaw!'
           but found 'I jest kenna do'ut!' instead.
</pre>
<p class="Pp">since in that case the second production would commit after
    matching the leading name.</p>
<p class="Pp">Note that to allow this behaviour, all
    <span class="Li">&quot;&lt;error&gt;&quot;</span> directives which are the
    first item in a production automatically uncommit the rule just long enough
    to allow their production to be attempted (that is, when their production
    fails, the commitment is reinstated so that subsequent productions are
    skipped).</p>
<p class="Pp">In order to <i>permanently</i> uncommit the rule before an error
    message, it is necessary to put an explicit
    <span class="Li">&quot;&lt;uncommit&gt;&quot;</span> before the
    <span class="Li">&quot;&lt;error&gt;&quot;</span>. For example:</p>
<p class="Pp"></p>
<pre>    line: 'Kirk:'  &lt;commit&gt; Kirk
    | 'Spock:' &lt;commit&gt; Spock
    | 'McCoy:' &lt;commit&gt; McCoy
    | &lt;uncommit&gt; &lt;error?&gt; &lt;reject&gt;
    | &lt;resync&gt;
</pre>
<p class="Pp">Error messages generated by the various
    <span class="Li">&quot;&lt;error...&gt;&quot;</span> directives are not
    displayed immediately. Instead, they are &quot;queued&quot; in a buffer and
    are only displayed once parsing ultimately fails. Moreover,
    <span class="Li">&quot;&lt;error...&gt;&quot;</span> directives that cause
    one production of a rule to fail are automatically removed from the message
    queue if another production subsequently causes the entire rule to succeed.
    This means that you can put
    <span class="Li">&quot;&lt;error...&gt;&quot;</span> directives wherever
    useful diagnosis can be done, and only those associated with actual parser
    failure will ever be displayed. Also see &quot;GOTCHAS&quot;.</p>
<p class="Pp">As a general rule, the most useful diagnostics are usually
    generated either at the very lowest level within the grammar, or at the very
    highest. A good rule of thumb is to identify those subrules which consist
    mainly (or entirely) of terminals, and then put an
    <span class="Li">&quot;&lt;error...&gt;&quot;</span> directive at the end of
    any other rule which calls one or more of those subrules.</p>
<p class="Pp">There is one other situation in which the output of the various
    types of error directive is suppressed; namely, when the rule containing
    them is being parsed as part of a &quot;look-ahead&quot; (see
    &quot;Look-ahead&quot;). In this case, the error directive will still cause
    the rule to fail, but will do so silently.</p>
<p class="Pp">An unconditional <span class="Li">&quot;&lt;error&gt;&quot;</span>
    directive always fails (and hence has no associated value). This means that
    encountering such a directive always causes the production containing it to
    fail. Hence an <span class="Li">&quot;&lt;error&gt;&quot;</span> directive
    will inevitably be the last (useful) item of a rule (a level 3 warning is
    issued if a production contains items after an unconditional
    <span class="Li">&quot;&lt;error&gt;&quot;</span> directive).</p>
<p class="Pp">An <span class="Li">&quot;&lt;error?&gt;&quot;</span> directive
    will <i>succeed</i> (that is: fail to fail :-), if the current rule is
    uncommitted when the directive is encountered. In that case the directive's
    associated value is zero. Hence, this type of error directive <i>can</i> be
    used before the end of a production. For example:</p>
<p class="Pp"></p>
<pre>    command: 'do' &lt;commit&gt; something
       | 'report' &lt;commit&gt; something
       | &lt;error?: Syntax error&gt; &lt;error: Unknown command&gt;
</pre>
<p class="Pp"><b>Warning:</b> The
    <span class="Li">&quot;&lt;error?&gt;&quot;</span> directive does <i>not</i>
    mean &quot;always fail (but do so silently unless committed)&quot;. It
    actually means &quot;only fail (and report) if committed, otherwise
    <i>succeed</i>&quot;. To achieve the &quot;fail silently if
    uncommitted&quot; semantics, it is necessary to use:</p>
<p class="Pp"></p>
<pre>    rule: item &lt;commit&gt; item(s)
    | &lt;error?&gt; &lt;reject&gt;  # FAIL SILENTLY UNLESS COMMITTED
</pre>
<p class="Pp">However, because people seem to expect a lone
    <span class="Li">&quot;&lt;error?&gt;&quot;</span> directive to work like
    this:</p>
<p class="Pp"></p>
<pre>    rule: item &lt;commit&gt; item(s)
    | &lt;error?: Error message if committed&gt;
    | &lt;error:  Error message if uncommitted&gt;
</pre>
<p class="Pp">Parse::RecDescent automatically appends a
    <span class="Li">&quot;&lt;reject&gt;&quot;</span> directive if the
    <span class="Li">&quot;&lt;error?&gt;&quot;</span> directive is the only
    item in a production. A level 2 warning (see below) is issued when this
    happens.</p>
<p class="Pp">The level of error reporting during both parser construction and
    parsing is controlled by the presence or absence of four global variables:
    <span class="Li">$::RD_ERRORS</span>, <span class="Li">$::RD_WARN</span>,
    <span class="Li">$::RD_HINT</span>, and &lt;$::RD_TRACE&gt;. If
    <span class="Li">$::RD_ERRORS</span> is defined (and, by default, it is)
    then fatal errors are reported.</p>
<p class="Pp">Whenever <span class="Li">$::RD_WARN</span> is defined, certain
    non-fatal problems are also reported.</p>
<p class="Pp">Warnings have an associated &quot;level&quot;: 1, 2, or 3. The
    higher the level, the more serious the warning. The value of the
    corresponding global variable (<span class="Li">$::RD_WARN</span>)
    determines the <i>lowest</i> level of warning to be displayed. Hence, to see
    <i>all</i> warnings, set <span class="Li">$::RD_WARN</span> to 1. To see
    only the most serious warnings set <span class="Li">$::RD_WARN</span> to 3.
    By default <span class="Li">$::RD_WARN</span> is initialized to 3, ensuring
    that serious but non-fatal errors are automatically reported.</p>
<p class="Pp">There is also a grammar directive to turn on warnings from within
    the grammar: <span class="Li">&quot;&lt;warn&gt;&quot;</span>. It takes an
    optional argument, which specifies the warning level:
    <span class="Li">&quot;&lt;warn: 2&gt;&quot;</span>.</p>
<p class="Pp">See <i>&quot;DIAGNOSTICS&quot;</i> for a list of the various error
    and warning messages that Parse::RecDescent generates when these two
    variables are defined.</p>
<p class="Pp">Defining any of the remaining variables (which are not defined by
    default) further increases the amount of information reported. Defining
    <span class="Li">$::RD_HINT</span> causes the parser generator to offer more
    detailed analyses and hints on both errors and warnings. Note that setting
    <span class="Li">$::RD_HINT</span> at any point automagically sets
    <span class="Li">$::RD_WARN</span> to 1. There is also a
    <span class="Li">&quot;&lt;hint&gt;&quot;</span> directive, which can be
    hard-coded into a grammar.</p>
<p class="Pp">Defining <span class="Li">$::RD_TRACE</span> causes the parser
    generator and the parser to report their progress to STDERR in excruciating
    detail (although, without hints unless <span class="Li">$::RD_HINT</span> is
    separately defined). This detail can be moderated in only one respect: if
    <span class="Li">$::RD_TRACE</span> has an integer value (<i>N</i>) greater
    than 1, only the <i>N</i> characters of the &quot;current parsing
    context&quot; (that is, where in the input string we are at any point in the
    parse) is reported at any time.</p>
<p class="Pp"><span class="Li">$::RD_TRACE</span> is mainly useful for debugging
    a grammar that isn't behaving as you expected it to. To this end, if
    <span class="Li">$::RD_TRACE</span> is defined when a parser is built, any
    actual parser code which is generated is also written to a file named
    &quot;RD_TRACE&quot; in the local directory.</p>
<p class="Pp">There are two directives associated with the
    <span class="Li">$::RD_TRACE</span> variable. If a grammar contains a
    <span class="Li">&quot;&lt;trace_build&gt;&quot;</span> directive anywhere
    in its specification, <span class="Li">$::RD_TRACE</span> is turned on
    during the parser construction phase. If a grammar contains a
    <span class="Li">&quot;&lt;trace_parse&gt;&quot;</span> directive anywhere
    in its specification, <span class="Li">$::RD_TRACE</span> is turned on
    during any parse the parser performs.</p>
<p class="Pp">Note that the four variables belong to the &quot;main&quot;
    package, which makes them easier to refer to in the code controlling the
    parser, and also makes it easy to turn them into command line flags
    (&quot;-RD_ERRORS&quot;, &quot;-RD_WARN&quot;, &quot;-RD_HINT&quot;,
    &quot;-RD_TRACE&quot;) under <b>perl -s</b>.</p>
<p class="Pp">The corresponding directives are useful to &quot;hardwire&quot;
    the various debugging features into a particular grammar (rather than having
    to set and reset external variables).</p>
</div>
<dl class="Bl-tag">
  <dt id="Redirecting"><a class="permalink" href="#Redirecting">Redirecting
    diagnostics</a></dt>
  <dd>The diagnostics provided by the tracing mechanism always go to STDERR. If
      you need them to go elsewhere, localize and reopen STDERR prior to the
      parse.
    <p class="Pp">For example:</p>
    <p class="Pp"></p>
    <pre>    {
        local *STDERR = IO::File-&gt;new(&quot;&gt;$filename&quot;) or die $!;
        my $result = $parser-&gt;startrule($text);
    }
    </pre>
  </dd>
  <dt id="Consistency"><a class="permalink" href="#Consistency">Consistency
    checks</a></dt>
  <dd>Whenever a parser is build, Parse::RecDescent carries out a number of
      (potentially expensive) consistency checks. These include: verifying that
      the grammar is not left-recursive and that no rules have been left
      undefined.
    <p class="Pp">These checks are important safeguards during development, but
        unnecessary overheads when the grammar is stable and ready to be
        deployed. So Parse::RecDescent provides a directive to disable them:
        <span class="Li">&quot;&lt;nocheck&gt;&quot;</span>.</p>
    <p class="Pp">If a grammar contains a
        <span class="Li">&quot;&lt;nocheck&gt;&quot;</span> directive anywhere
        in its specification, the extra compile-time checks are by-passed.</p>
  </dd>
  <dt id="Specifying"><a class="permalink" href="#Specifying">Specifying local
    variables</a></dt>
  <dd>It is occasionally convenient to specify variables which are local to a
      single rule. This may be achieved by including a
      <span class="Li">&quot;&lt;rulevar:...&gt;&quot;</span> directive anywhere
      in the rule. For example:
    <p class="Pp"></p>
    <pre>    markup: &lt;rulevar: $tag&gt;
    markup: tag {($tag=$item[1]) =~ s/^&lt;|&gt;$//g} body[$tag]
    </pre>
    <p class="Pp">The example <span class="Li">&quot;&lt;rulevar:
        $tag&gt;&quot;</span> directive causes a &quot;my&quot; variable named
        <span class="Li">$tag</span> to be declared at the start of the
        subroutine implementing the <span class="Li">&quot;markup&quot;</span>
        rule (that is, <i>before</i> the first production, regardless of where
        in the rule it is specified).</p>
    <p class="Pp">Specifically, any directive of the form:
        <span class="Li">&quot;&lt;rulevar:</span><span class="Li"><i>text</i></span><span class="Li">&gt;&quot;</span>
        causes a line of the form <span class="Li">&quot;my
        </span><span class="Li"><i>text</i></span><span class="Li">;&quot;</span>
        to be added at the beginning of the rule subroutine, immediately after
        the definitions of the following local variables:</p>
    <p class="Pp"></p>
    <pre>    $thisparser $commit
    $thisrule   @item
    $thisline   @arg
    $text   %arg
    </pre>
    <p class="Pp">This means that the following
        <span class="Li">&quot;&lt;rulevar&gt;&quot;</span> directives work as
        expected:</p>
    <p class="Pp"></p>
    <pre>    &lt;rulevar: $count = 0 &gt;
    &lt;rulevar: $firstarg = $arg[0] || '' &gt;
    &lt;rulevar: $myItems = \@item &gt;
    &lt;rulevar: @context = ( $thisline, $text, @arg ) &gt;
    &lt;rulevar: ($name,$age) = $arg{&quot;name&quot;,&quot;age&quot;} &gt;
    </pre>
    <p class="Pp">If a variable that is also visible to subrules is required, it
        needs to be <span class="Li">&quot;local&quot;</span>'d, not
        <span class="Li">&quot;my&quot;</span>'d.
        <span class="Li">&quot;rulevar&quot;</span> defaults to
        <span class="Li">&quot;my&quot;</span>, but if
        <span class="Li">&quot;local&quot;</span> is explicitly specified:</p>
    <p class="Pp"></p>
    <pre>    &lt;rulevar: local $count = 0 &gt;
    </pre>
    <p class="Pp">then a <span class="Li">&quot;local&quot;</span>-ized variable
        is declared instead, and will be available within subrules.</p>
    <p class="Pp">Note however that, because all such variables are
        &quot;my&quot; variables, their values <i>do not persist</i> between
        match attempts on a given rule. To preserve values between match
        attempts, values can be stored within the &quot;local&quot; member of
        the <span class="Li">$thisrule</span> object:</p>
    <p class="Pp"></p>
    <pre>    countedrule: { $thisrule-&gt;{&quot;local&quot;}{&quot;count&quot;}++ }
         &lt;reject&gt;
       | subrule1
       | subrule2
       | &lt;reject: $thisrule-&gt;{&quot;local&quot;}{&quot;count&quot;} == 1&gt;
         subrule3
    </pre>
    <p class="Pp">When matching a rule, each
        <span class="Li">&quot;&lt;rulevar&gt;&quot;</span> directive is matched
        as if it were an unconditional
        <span class="Li">&quot;&lt;reject&gt;&quot;</span> directive (that is,
        it causes any production in which it appears to immediately fail to
        match). For this reason (and to improve readability) it is usual to
        specify any <span class="Li">&quot;&lt;rulevar&gt;&quot;</span>
        directive in a separate production at the start of the rule (this has
        the added advantage that it enables
        <span class="Li">&quot;Parse::RecDescent&quot;</span> to optimize away
        such productions, just as it does for the
        <span class="Li">&quot;&lt;reject&gt;&quot;</span> directive).</p>
  </dd>
  <dt id="Dynamically"><a class="permalink" href="#Dynamically">Dynamically
    matched rules</a></dt>
  <dd>Because regexes and double-quoted strings are interpolated, it is
      relatively easy to specify productions with &quot;context sensitive&quot;
      tokens. For example:
    <p class="Pp"></p>
    <pre>    command:  keyword  body  &quot;end $item[1]&quot;
    </pre>
    <p class="Pp">which ensures that a command block is bounded by a
        &quot;<i>&lt;keyword&gt;</i>...end <i>&lt;same keyword&gt;</i>&quot;
        pair.</p>
    <p class="Pp">Building productions in which subrules are context sensitive
        is also possible, via the
        <span class="Li">&quot;&lt;matchrule:...&gt;&quot;</span> directive.
        This directive behaves identically to a subrule item, except that the
        rule which is invoked to match it is determined by the string specified
        after the colon. For example, we could rewrite the
        <span class="Li">&quot;command&quot;</span> rule like this:</p>
    <p class="Pp"></p>
    <pre>    command:  keyword  &lt;matchrule:body&gt;  &quot;end $item[1]&quot;
    </pre>
    <p class="Pp">Whatever appears after the colon in the directive is treated
        as an interpolated string (that is, as if it appeared in
        <span class="Li">&quot;qq{...}&quot;</span> operator) and the value of
        that interpolated string is the name of the subrule to be matched.</p>
    <p class="Pp">Of course, just putting a constant string like
        <span class="Li">&quot;body&quot;</span> in a
        <span class="Li">&quot;&lt;matchrule:...&gt;&quot;</span> directive is
        of little interest or benefit. The power of directive is seen when we
        use a string that interpolates to something interesting. For
      example:</p>
    <p class="Pp"></p>
    <pre>    command:    keyword &lt;matchrule:$item[1]_body&gt; &quot;end $item[1]&quot;
    keyword:    'while' | 'if' | 'function'
    while_body: condition block
    if_body:    condition block ('else' block)(?)
    function_body:  arglist block
    </pre>
    <p class="Pp">Now the <span class="Li">&quot;command&quot;</span> rule
        selects how to proceed on the basis of the keyword that is found. It is
        as if <span class="Li">&quot;command&quot;</span> were declared:</p>
    <p class="Pp"></p>
    <pre>    command:    'while'    while_body    &quot;end while&quot;
       |    'if'       if_body   &quot;end if&quot;
       |    'function' function_body &quot;end function&quot;
    </pre>
    <p class="Pp">When a
        <span class="Li">&quot;&lt;matchrule:...&gt;&quot;</span> directive is
        used as a repeated subrule, the rule name expression is
        &quot;late-bound&quot;. That is, the name of the rule to be called is
        re-evaluated <i>each time</i> a match attempt is made. Hence, the
        following grammar:</p>
    <p class="Pp"></p>
    <pre>    { $::species = 'dogs' }
    pair:   'two' &lt;matchrule:$::species&gt;(s)
    dogs:   /dogs/ { $::species = 'cats' }
    cats:   /cats/
    </pre>
    <p class="Pp">will match the string &quot;two dogs cats cats&quot;
        completely, whereas it will only match the string &quot;two dogs dogs
        dogs&quot; up to the eighth letter. If the rule name were &quot;early
        bound&quot; (that is, evaluated only the first time the directive is
        encountered in a production), the reverse behaviour would be
      expected.</p>
    <p class="Pp">Note that the <span class="Li">&quot;matchrule&quot;</span>
        directive takes a string that is to be treated as a rule name,
        <i>not</i> as a rule invocation. That is, it's like a Perl symbolic
        reference, not an <span class="Li">&quot;eval&quot;</span>. Just as you
        can say:</p>
    <p class="Pp"></p>
    <pre>    $subname = 'foo';
    # and later...
    &amp;{$foo}(@args);
    </pre>
    <p class="Pp">but not:</p>
    <p class="Pp"></p>
    <pre>    $subname = 'foo(@args)';
    # and later...
    &amp;{$foo};
    </pre>
    <p class="Pp">likewise you can say:</p>
    <p class="Pp"></p>
    <pre>    $rulename = 'foo';
    # and in the grammar...
    &lt;matchrule:$rulename&gt;[@args]
    </pre>
    <p class="Pp">but not:</p>
    <p class="Pp"></p>
    <pre>    $rulename = 'foo[@args]';
    # and in the grammar...
    &lt;matchrule:$rulename&gt;
    </pre>
  </dd>
  <dt id="Deferred"><a class="permalink" href="#Deferred">Deferred
    actions</a></dt>
  <dd>The <span class="Li">&quot;&lt;defer:...&gt;&quot;</span> directive is
      used to specify an action to be performed when (and only if!) the current
      production ultimately succeeds.
    <p class="Pp">Whenever a
        <span class="Li">&quot;&lt;defer:...&gt;&quot;</span> directive appears,
        the code it specifies is converted to a closure (an anonymous subroutine
        reference) which is queued within the active parser object. Note that,
        because the deferred code is converted to a closure, the values of any
        &quot;local&quot; variable (such as <span class="Li">$text</span>,
        &lt;@item&gt;, etc.) are preserved until the deferred code is actually
        executed.</p>
    <p class="Pp">If the parse ultimately succeeds <i>and</i> the production in
        which the <span class="Li">&quot;&lt;defer:...&gt;&quot;</span>
        directive was evaluated formed part of the successful parse, then the
        deferred code is executed immediately before the parse returns. If
        however the production which queued a deferred action fails, or one of
        the higher-level rules which called that production fails, then the
        deferred action is removed from the queue, and hence is never
      executed.</p>
    <p class="Pp">For example, given the grammar:</p>
    <p class="Pp"></p>
    <pre>    sentence: noun trans noun
    | noun intrans
    noun:     'the dog'
        { print &quot;$item[1]\t(noun)\n&quot; }
    |     'the meat'
        { print &quot;$item[1]\t(noun)\n&quot; }
    trans:    'ate'
        { print &quot;$item[1]\t(transitive)\n&quot; }
    intrans:  'ate'
        { print &quot;$item[1]\t(intransitive)\n&quot; }
       |  'barked'
        { print &quot;$item[1]\t(intransitive)\n&quot; }
    </pre>
    <p class="Pp">then parsing the sentence <span class="Li">&quot;the dog
        ate&quot;</span> would produce the output:</p>
    <p class="Pp"></p>
    <pre>    the dog  (noun)
    ate  (transitive)
    the dog  (noun)
    ate  (intransitive)
    </pre>
    <p class="Pp">This is because, even though the first production of
        <span class="Li">&quot;sentence&quot;</span> ultimately fails, its
        initial subrules <span class="Li">&quot;noun&quot;</span> and
        <span class="Li">&quot;trans&quot;</span> do match, and hence they
        execute their associated actions. Then the second production of
        <span class="Li">&quot;sentence&quot;</span> succeeds, causing the
        actions of the subrules <span class="Li">&quot;noun&quot;</span> and
        <span class="Li">&quot;intrans&quot;</span> to be executed as well.</p>
    <p class="Pp">On the other hand, if the actions were replaced by
        <span class="Li">&quot;&lt;defer:...&gt;&quot;</span> directives:</p>
    <p class="Pp"></p>
    <pre>    sentence: noun trans noun
    | noun intrans
    noun:     'the dog'
        &lt;defer: print &quot;$item[1]\t(noun)\n&quot; &gt;
    |     'the meat'
        &lt;defer: print &quot;$item[1]\t(noun)\n&quot; &gt;
    trans:    'ate'
        &lt;defer: print &quot;$item[1]\t(transitive)\n&quot; &gt;
    intrans:  'ate'
        &lt;defer: print &quot;$item[1]\t(intransitive)\n&quot; &gt;
       |  'barked'
        &lt;defer: print &quot;$item[1]\t(intransitive)\n&quot; &gt;
    </pre>
    <p class="Pp">the output would be:</p>
    <p class="Pp"></p>
    <pre>    the dog  (noun)
    ate  (intransitive)
    </pre>
    <p class="Pp">since deferred actions are only executed if they were
        evaluated in a production which ultimately contributes to the successful
        parse.</p>
    <p class="Pp">In this case, even though the first production of
        <span class="Li">&quot;sentence&quot;</span> caused the subrules
        <span class="Li">&quot;noun&quot;</span> and
        <span class="Li">&quot;trans&quot;</span> to match, that production
        ultimately failed and so the deferred actions queued by those subrules
        were subsequently discarded. The second production then succeeded,
        causing the entire parse to succeed, and so the deferred actions queued
        by the (second) match of the <span class="Li">&quot;noun&quot;</span>
        subrule and the subsequent match of
        <span class="Li">&quot;intrans&quot;</span> <i>are</i> preserved and
        eventually executed.</p>
    <p class="Pp">Deferred actions provide a means of improving the performance
        of a parser, by only executing those actions which are part of the final
        parse-tree for the input data.</p>
    <p class="Pp">Alternatively, deferred actions can be viewed as a mechanism
        for building (and executing) a customized subroutine corresponding to
        the given input data, much in the same way that autoactions (see
        &quot;Autoactions&quot;) can be used to build a customized data
        structure for specific input.</p>
    <p class="Pp">Whether or not the action it specifies is ever executed, a
        <span class="Li">&quot;&lt;defer:...&gt;&quot;</span> directive always
        succeeds, returning the number of deferred actions currently queued at
        that point.</p>
  </dd>
  <dt id="Parsing"><a class="permalink" href="#Parsing">Parsing Perl</a></dt>
  <dd>Parse::RecDescent provides limited support for parsing subsets of Perl,
      namely: quote-like operators, Perl variables, and complete code blocks.
    <p class="Pp">The <span class="Li">&quot;&lt;perl_quotelike&gt;&quot;</span>
        directive can be used to parse any Perl quote-like operator:
        <span class="Li">'a string'</span>, <span class="Li">&quot;m/a
        pattern/&quot;</span>,
        <span class="Li">&quot;tr{ans}{lation}&quot;</span>, etc. It does this
        by calling <b>Text::Balanced::quotelike()</b>.</p>
    <p class="Pp">If a quote-like operator is found, a reference to an array of
        eight elements is returned. Those elements are identical to the last
        eight elements returned by <b>Text::Balanced::extract_quotelike()</b> in
        an array context, namely:</p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>[0]</dt>
  <dd>the name of the quotelike operator -- 'q', 'qq', 'm', 's', 'tr' -- if the
      operator was named; otherwise
    <span class="Li">&quot;undef&quot;</span>,</dd>
  <dt>[1]</dt>
  <dd>the left delimiter of the first block of the operation,</dd>
  <dt>[2]</dt>
  <dd>the text of the first block of the operation (that is, the contents of a
      quote, the regex of a match, or substitution or the target list of a
      translation),</dd>
  <dt>[3]</dt>
  <dd>the right delimiter of the first block of the operation,</dd>
  <dt>[4]</dt>
  <dd>the left delimiter of the second block of the operation if there is one
      (that is, if it is a <span class="Li">&quot;s&quot;</span>,
      <span class="Li">&quot;tr&quot;</span>, or
      <span class="Li">&quot;y&quot;</span>); otherwise
      <span class="Li">&quot;undef&quot;</span>,</dd>
  <dt>[5]</dt>
  <dd>the text of the second block of the operation if there is one (that is,
      the replacement of a substitution or the translation list of a
      translation); otherwise <span class="Li">&quot;undef&quot;</span>,</dd>
  <dt>[6]</dt>
  <dd>the right delimiter of the second block of the operation (if any);
      otherwise <span class="Li">&quot;undef&quot;</span>,</dd>
  <dt>[7]</dt>
  <dd>the trailing modifiers on the operation (if any); otherwise
      <span class="Li">&quot;undef&quot;</span>.</dd>
</dl>
</div>
<div class="Bd-indent">
<p class="Pp">If a quote-like expression is not found, the directive fails with
    the usual <span class="Li">&quot;undef&quot;</span> value.</p>
<p class="Pp">The <span class="Li">&quot;&lt;perl_variable&gt;&quot;</span>
    directive can be used to parse any Perl variable:
    <span class="Li">$scalar</span>, <span class="Li">@array</span>,
    <span class="Li">%hash</span>,
    <span class="Li">$ref</span>-&gt;{field}[$index], etc. It does this by
    calling <b>Text::Balanced::extract_variable()</b>.</p>
<p class="Pp">If the directive matches text representing a valid Perl variable
    specification, it returns that text. Otherwise it fails with the usual
    <span class="Li">&quot;undef&quot;</span> value.</p>
<p class="Pp">The <span class="Li">&quot;&lt;perl_codeblock&gt;&quot;</span>
    directive can be used to parse curly-brace-delimited block of Perl code,
    such as: { <span class="Li">$a</span> = 1; f() =~ m/pat/; }. It does this by
    calling <b>Text::Balanced::extract_codeblock()</b>.</p>
<p class="Pp">If the directive matches text representing a valid Perl code
    block, it returns that text. Otherwise it fails with the usual
    <span class="Li">&quot;undef&quot;</span> value.</p>
<p class="Pp">You can also tell it what kind of brackets to use as the outermost
    delimiters. For example:</p>
<p class="Pp"></p>
<pre>    arglist: &lt;perl_codeblock ()&gt;
</pre>
<p class="Pp">causes an arglist to match a perl code block whose outermost
    delimiters are <span class="Li">&quot;(...)&quot;</span> (rather than the
    default <span class="Li">&quot;{...}&quot;</span>).</p>
</div>
<dl class="Bl-tag">
  <dt id="Constructing"><a class="permalink" href="#Constructing">Constructing
    tokens</a></dt>
  <dd>Eventually, Parse::RecDescent will be able to parse tokenized input, as
      well as ordinary strings. In preparation for this joyous day, the
      <span class="Li">&quot;&lt;token:...&gt;&quot;</span> directive has been
      provided. This directive creates a token which will be suitable for input
      to a Parse::RecDescent parser (when it eventually supports tokenized
      input).
    <p class="Pp">The text of the token is the value of the immediately
        preceding item in the production. A
        <span class="Li">&quot;&lt;token:...&gt;&quot;</span> directive always
        succeeds with a return value which is the hash reference that is the new
        token. It also sets the return value for the production to that hash
        ref.</p>
    <p class="Pp">The <span class="Li">&quot;&lt;token:...&gt;&quot;</span>
        directive makes it easy to build a Parse::RecDescent-compatible lexer in
        Parse::RecDescent:</p>
    <p class="Pp"></p>
    <pre>    my $lexer = new Parse::RecDescent q
    {
    lex:    token(s)
    token:  /a\b/          &lt;token:INDEF&gt;
         |  /the\b/        &lt;token:DEF&gt;
         |  /fly\b/        &lt;token:NOUN,VERB&gt;
         |  /[a-z]+/i { lc $item[1] }  &lt;token:ALPHA&gt;
         |  &lt;error: Unknown token&gt;
    };
    </pre>
    <p class="Pp">which will eventually be able to be used with a regular
        Parse::RecDescent grammar:</p>
    <p class="Pp"></p>
    <pre>    my $parser = new Parse::RecDescent q
    {
    startrule: subrule1 subrule 2
    # ETC...
    };
    </pre>
    <p class="Pp">either with a pre-lexing phase:</p>
    <p class="Pp"></p>
    <pre>    $parser-&gt;startrule( $lexer-&gt;lex($data) );
    </pre>
    <p class="Pp">or with a lex-on-demand approach:</p>
    <p class="Pp"></p>
    <pre>    $parser-&gt;startrule( sub{$lexer-&gt;token(\$data)} );
    </pre>
    <p class="Pp">But at present, only the
        <span class="Li">&quot;&lt;token:...&gt;&quot;</span> directive is
        actually implemented. The rest is vapourware.</p>
  </dd>
  <dt id="Specifying~2"><a class="permalink" href="#Specifying~2">Specifying
    operations</a></dt>
  <dd>One of the commonest requirements when building a parser is to specify
      binary operators. Unfortunately, in a normal grammar, the rules for such
      things are awkward:
    <p class="Pp"></p>
    <pre>    disjunction:    conjunction ('or' conjunction)(s?)
        { $return = [ $item[1], @{$item[2]} ] }
    conjunction:    atom ('and' atom)(s?)
        { $return = [ $item[1], @{$item[2]} ] }
    </pre>
    <p class="Pp">or inefficient:</p>
    <p class="Pp"></p>
    <pre>    disjunction:    conjunction 'or' disjunction
        { $return = [ $item[1], @{$item[2]} ] }
       |    conjunction
        { $return = [ $item[1] ] }
    conjunction:    atom 'and' conjunction
        { $return = [ $item[1], @{$item[2]} ] }
       |    atom
        { $return = [ $item[1] ] }
    </pre>
    <p class="Pp">and either way is ugly and hard to get right.</p>
    <p class="Pp">The <span class="Li">&quot;&lt;leftop:...&gt;&quot;</span> and
        <span class="Li">&quot;&lt;rightop:...&gt;&quot;</span> directives
        provide an easier way of specifying such operations. Using
        <span class="Li">&quot;&lt;leftop:...&gt;&quot;</span> the above
        examples become:</p>
    <p class="Pp"></p>
    <pre>    disjunction:    &lt;leftop: conjunction 'or' conjunction&gt;
    conjunction:    &lt;leftop: atom 'and' atom&gt;
    </pre>
    <p class="Pp">The <span class="Li">&quot;&lt;leftop:...&gt;&quot;</span>
        directive specifies a left-associative binary operator. It is specified
        around three other grammar elements (typically subrules or terminals),
        which match the left operand, the operator itself, and the right operand
        respectively.</p>
    <p class="Pp">A <span class="Li">&quot;&lt;leftop:...&gt;&quot;</span>
        directive such as:</p>
    <p class="Pp"></p>
    <pre>    disjunction:    &lt;leftop: conjunction 'or' conjunction&gt;
    </pre>
    <p class="Pp">is converted to the following:</p>
    <p class="Pp"></p>
    <pre>    disjunction:    ( conjunction ('or' conjunction)(s?)
        { $return = [ $item[1], @{$item[2]} ] } )
    </pre>
    <p class="Pp">In other words, a
        <span class="Li">&quot;&lt;leftop:...&gt;&quot;</span> directive matches
        the left operand followed by zero or more repetitions of both the
        operator and the right operand. It then flattens the matched items into
        an anonymous array which becomes the (single) value of the entire
        <span class="Li">&quot;&lt;leftop:...&gt;&quot;</span> directive.</p>
    <p class="Pp">For example, an
        <span class="Li">&quot;&lt;leftop:...&gt;&quot;</span> directive such
        as:</p>
    <p class="Pp"></p>
    <pre>    output:  &lt;leftop: ident '&lt;&lt;' expr &gt;
    </pre>
    <p class="Pp">when given a string such as:</p>
    <p class="Pp"></p>
    <pre>    cout &lt;&lt; var &lt;&lt; &quot;str&quot; &lt;&lt; 3
    </pre>
    <p class="Pp">would match, and <span class="Li">$item[1]</span> would be set
        to:</p>
    <p class="Pp"></p>
    <pre>    [ 'cout', 'var', '&quot;str&quot;', '3' ]
    </pre>
    <p class="Pp">In other words:</p>
    <p class="Pp"></p>
    <pre>    output:  &lt;leftop: ident '&lt;&lt;' expr &gt;
    </pre>
    <p class="Pp">is equivalent to a left-associative operator:</p>
    <p class="Pp"></p>
    <pre>    output:  ident          { $return = [$item[1]]   }
          |  ident '&lt;&lt;' expr        { $return = [@item[1,3]]     }
          |  ident '&lt;&lt;' expr '&lt;&lt;' expr      { $return = [@item[1,3,5]]   }
          |  ident '&lt;&lt;' expr '&lt;&lt;' expr '&lt;&lt;' expr    { $return = [@item[1,3,5,7]] }
          #  ...etc...
    </pre>
    <p class="Pp">Similarly, the
        <span class="Li">&quot;&lt;rightop:...&gt;&quot;</span> directive takes
        a left operand, an operator, and a right operand:</p>
    <p class="Pp"></p>
    <pre>    assign:  &lt;rightop: var '=' expr &gt;
    </pre>
    <p class="Pp">and converts them to:</p>
    <p class="Pp"></p>
    <pre>    assign:  ( (var '=' {$return=$item[1]})(s?) expr
        { $return = [ @{$item[1]}, $item[2] ] } )
    </pre>
    <p class="Pp">which is equivalent to a right-associative operator:</p>
    <p class="Pp"></p>
    <pre>    assign:  expr       { $return = [$item[1]]       }
          |  var '=' expr       { $return = [@item[1,3]]     }
          |  var '=' var '=' expr   { $return = [@item[1,3,5]]   }
          |  var '=' var '=' var '=' expr   { $return = [@item[1,3,5,7]] }
          #  ...etc...
    </pre>
    <p class="Pp">Note that for both the
        <span class="Li">&quot;&lt;leftop:...&gt;&quot;</span> and
        <span class="Li">&quot;&lt;rightop:...&gt;&quot;</span> directives, the
        directive does not normally return the operator itself, just a list of
        the operands involved. This is particularly handy for specifying
      lists:</p>
    <p class="Pp"></p>
    <pre>    list: '(' &lt;leftop: list_item ',' list_item&gt; ')'
        { $return = $item[2] }
    </pre>
    <p class="Pp">There is, however, a problem: sometimes the operator is itself
        significant. For example, in a Perl list a comma and a
        <span class="Li">&quot;=&gt;&quot;</span> are both valid separators, but
        the <span class="Li">&quot;=&gt;&quot;</span> has additional
        stringification semantics. Hence it's important to know which was used
        in each case.</p>
    <p class="Pp">To solve this problem the
        <span class="Li">&quot;&lt;leftop:...&gt;&quot;</span> and
        <span class="Li">&quot;&lt;rightop:...&gt;&quot;</span> directives
        <i>do</i> return the operator(s) as well, under two circumstances. The
        first case is where the operator is specified as a subrule. In that
        instance, whatever the operator matches is returned (on the assumption
        that if the operator is important enough to have its own subrule, then
        it's important enough to return).</p>
    <p class="Pp">The second case is where the operator is specified as a
        regular expression. In that case, if the first bracketed subpattern of
        the regular expression matches, that matching value is returned (this is
        analogous to the behaviour of the Perl
        <span class="Li">&quot;split&quot;</span> function, except that only the
        first subpattern is returned).</p>
    <p class="Pp">In other words, given the input:</p>
    <p class="Pp"></p>
    <pre>    ( a=&gt;1, b=&gt;2 )
    </pre>
    <p class="Pp">the specifications:</p>
    <p class="Pp"></p>
    <pre>    list:      '('  &lt;leftop: list_item separator list_item&gt;  ')'
    separator: ',' | '=&gt;'
    </pre>
    <p class="Pp">or:</p>
    <p class="Pp"></p>
    <pre>    list:      '('  &lt;leftop: list_item /(,|=&gt;)/ list_item&gt;  ')'
    </pre>
    <p class="Pp">cause the list separators to be interleaved with the operands
        in the anonymous array in <span class="Li">$item[2]</span>:</p>
    <p class="Pp"></p>
    <pre>    [ 'a', '=&gt;', '1', ',', 'b', '=&gt;', '2' ]
    </pre>
    <p class="Pp">But the following version:</p>
    <p class="Pp"></p>
    <pre>    list:      '('  &lt;leftop: list_item /,|=&gt;/ list_item&gt;  ')'
    </pre>
    <p class="Pp">returns only the operators:</p>
    <p class="Pp"></p>
    <pre>    [ 'a', '1', 'b', '2' ]
    </pre>
    <p class="Pp">Of course, none of the above specifications handle the case of
        an empty list, since the
        <span class="Li">&quot;&lt;leftop:...&gt;&quot;</span> and
        <span class="Li">&quot;&lt;rightop:...&gt;&quot;</span> directives
        require at least a single right or left operand to match. To specify
        that the operator can match &quot;trivially&quot;, it's necessary to add
        a <span class="Li">&quot;(s?)&quot;</span> qualifier to the
      directive:</p>
    <p class="Pp"></p>
    <pre>    list:      '('  &lt;leftop: list_item /(,|=&gt;)/ list_item&gt;(s?)  ')'
    </pre>
    <p class="Pp">Note that in almost all the above examples, the first and
        third arguments of the
        <span class="Li">&quot;&lt;leftop:...&gt;&quot;</span> directive were
        the same subrule. That is because
        <span class="Li">&quot;&lt;leftop:...&gt;&quot;</span>'s are frequently
        used to specify &quot;separated&quot; lists of the same type of item. To
        make such lists easier to specify, the following syntax:</p>
    <p class="Pp"></p>
    <pre>    list:   element(s /,/)
    </pre>
    <p class="Pp">is exactly equivalent to:</p>
    <p class="Pp"></p>
    <pre>    list:   &lt;leftop: element /,/ element&gt;
    </pre>
    <p class="Pp">Note that the separator must be specified as a raw pattern
        (i.e. not a string or subrule).</p>
  </dd>
  <dt id="Scored"><a class="permalink" href="#Scored">Scored
    productions</a></dt>
  <dd>By default, Parse::RecDescent grammar rules always accept the first
      production that matches the input. But if two or more productions may
      potentially match the same input, choosing the first that does so may not
      be optimal.
    <p class="Pp">For example, if you were parsing the sentence &quot;time flies
        like an arrow&quot;, you might use a rule like this:</p>
    <p class="Pp"></p>
    <pre>    sentence: verb noun preposition article noun { [@item] }
    | adjective noun verb article noun   { [@item] }
    | noun verb preposition article noun { [@item] }
    </pre>
    <p class="Pp">Each of these productions matches the sentence, but the third
        one is the most likely interpretation. However, if the sentence had been
        &quot;fruit flies like a banana&quot;, then the second production is
        probably the right match.</p>
    <p class="Pp">To cater for such situations, the
        <span class="Li">&quot;&lt;score:...&gt;&quot;</span> can be used. The
        directive is equivalent to an unconditional
        <span class="Li">&quot;&lt;reject&gt;&quot;</span>, except that it
        allows you to specify a &quot;score&quot; for the current production. If
        that score is numerically greater than the best score of any preceding
        production, the current production is cached for later consideration. If
        no later production matches, then the cached production is treated as
        having matched, and the value of the item immediately before its
        <span class="Li">&quot;&lt;score:...&gt;&quot;</span> directive is
        returned as the result.</p>
    <p class="Pp">In other words, by putting a
        <span class="Li">&quot;&lt;score:...&gt;&quot;</span> directive at the
        end of each production, you can select which production matches using
        criteria other than specification order. For example:</p>
    <p class="Pp"></p>
    <pre>    sentence: verb noun preposition article noun { [@item] } &lt;score: sensible(@item)&gt;
    | adjective noun verb article noun   { [@item] } &lt;score: sensible(@item)&gt;
    | noun verb preposition article noun { [@item] } &lt;score: sensible(@item)&gt;
    </pre>
    <p class="Pp">Now, when each production reaches its respective
        <span class="Li">&quot;&lt;score:...&gt;&quot;</span> directive, the
        subroutine <span class="Li">&quot;sensible&quot;</span> will be called
        to evaluate the matched items (somehow). Once all productions have been
        tried, the one which <span class="Li">&quot;sensible&quot;</span> scored
        most highly will be the one that is accepted as a match for the
      rule.</p>
    <p class="Pp">The variable <span class="Li">$score</span> always holds the
        current best score of any production, and the variable
        <span class="Li">$score_return</span> holds the corresponding return
        value.</p>
    <p class="Pp">As another example, the following grammar matches lines that
        may be separated by commas, colons, or semi-colons. This can be tricky
        if a colon-separated line also contains commas, or vice versa. The
        grammar resolves the ambiguity by selecting the rule that results in the
        fewest fields:</p>
    <p class="Pp"></p>
    <pre>    line: seplist[sep=&gt;',']  &lt;score: -@{$item[1]}&gt;
    | seplist[sep=&gt;':']  &lt;score: -@{$item[1]}&gt;
    | seplist[sep=&gt;&quot; &quot;]  &lt;score: -@{$item[1]}&gt;
    seplist: &lt;skip:&quot;&quot;&gt; &lt;leftop: /[^$arg{sep}]*/ &quot;$arg{sep}&quot; /[^$arg{sep}]*/&gt;
    </pre>
    <p class="Pp">Note the use of negation within the
        <span class="Li">&quot;&lt;score:...&gt;&quot;</span> directive to
        ensure that the seplist with the most items gets the lowest score.</p>
    <p class="Pp">As the above examples indicate, it is often the case that all
        productions in a rule use exactly the same
        <span class="Li">&quot;&lt;score:...&gt;&quot;</span> directive. It is
        tedious to have to repeat this identical directive in every production,
        so Parse::RecDescent also provides the
        <span class="Li">&quot;&lt;autoscore:...&gt;&quot;</span> directive.</p>
    <p class="Pp">If an
        <span class="Li">&quot;&lt;autoscore:...&gt;&quot;</span> directive
        appears in any production of a rule, the code it specifies is used as
        the scoring code for every production of that rule, except productions
        that already end with an explicit
        <span class="Li">&quot;&lt;score:...&gt;&quot;</span> directive. Thus
        the rules above could be rewritten:</p>
    <p class="Pp"></p>
    <pre>    line: &lt;autoscore: -@{$item[1]}&gt;
    line: seplist[sep=&gt;',']
    | seplist[sep=&gt;':']
    | seplist[sep=&gt;&quot; &quot;]
    sentence: &lt;autoscore: sensible(@item)&gt;
    | verb noun preposition article noun { [@item] }
    | adjective noun verb article noun   { [@item] }
    | noun verb preposition article noun { [@item] }
    </pre>
    <p class="Pp">Note that the
        <span class="Li">&quot;&lt;autoscore:...&gt;&quot;</span> directive
        itself acts as an unconditional
        <span class="Li">&quot;&lt;reject&gt;&quot;</span>, and (like the
        <span class="Li">&quot;&lt;rulevar:...&gt;&quot;</span> directive) is
        pruned at compile-time wherever possible.</p>
  </dd>
  <dt id="Dispensing"><a class="permalink" href="#Dispensing">Dispensing with
    grammar checks</a></dt>
  <dd>During the compilation phase of parser construction, Parse::RecDescent
      performs a small number of checks on the grammar it's given. Specifically
      it checks that the grammar is not left-recursive, that there are no
      &quot;insatiable&quot; constructs of the form:
    <p class="Pp"></p>
    <pre>    rule: subrule(s) subrule
    </pre>
    <p class="Pp">and that there are no rules missing (i.e. referred to, but
        never defined).</p>
    <p class="Pp">These checks are important during development, but can slow
        down parser construction in stable code. So Parse::RecDescent provides
        the &lt;nocheck&gt; directive to turn them off. The directive can only
        appear before the first rule definition, and switches off checking
        throughout the rest of the current grammar.</p>
    <p class="Pp">Typically, this directive would be added when a parser has
        been thoroughly tested and is ready for release.</p>
  </dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Subrule_argument_lists"><a class="permalink" href="#Subrule_argument_lists">Subrule
  argument lists</a></h2>
<p class="Pp">It is occasionally useful to pass data to a subrule which is being
    invoked. For example, consider the following grammar fragment:</p>
<p class="Pp"></p>
<pre>    classdecl: keyword decl
    keyword:   'struct' | 'class';
    decl:      # WHATEVER
</pre>
<p class="Pp">The <span class="Li">&quot;decl&quot;</span> rule might wish to
    know which of the two keywords was used (since it may affect some aspect of
    the way the subsequent declaration is interpreted).
    <span class="Li">&quot;Parse::RecDescent&quot;</span> allows the grammar
    designer to pass data into a rule, by placing that data in an <i>argument
    list</i> (that is, in square brackets) immediately after any subrule item in
    a production. Hence, we could pass the keyword to
    <span class="Li">&quot;decl&quot;</span> as follows:</p>
<p class="Pp"></p>
<pre>    classdecl: keyword decl[ $item[1] ]
    keyword:   'struct' | 'class';
    decl:      # WHATEVER
</pre>
<p class="Pp">The argument list can consist of any number (including zero!) of
    comma-separated Perl expressions. In other words, it looks exactly like a
    Perl anonymous array reference. For example, we could pass the keyword, the
    name of the surrounding rule, and the literal 'keyword' to
    <span class="Li">&quot;decl&quot;</span> like so:</p>
<p class="Pp"></p>
<pre>    classdecl: keyword decl[$item[1],$item[0],'keyword']
    keyword:   'struct' | 'class';
    decl:      # WHATEVER
</pre>
<p class="Pp">Within the rule to which the data is passed
    (<span class="Li">&quot;decl&quot;</span> in the above examples) that data
    is available as the elements of a local variable
    <span class="Li">@arg</span>. Hence <span class="Li">&quot;decl&quot;</span>
    might report its intentions as follows:</p>
<p class="Pp"></p>
<pre>    classdecl: keyword decl[$item[1],$item[0],'keyword']
    keyword:   'struct' | 'class';
    decl:      { print &quot;Declaring $arg[0] (a $arg[2])\n&quot;;
         print &quot;(this rule called by $arg[1])&quot; }
</pre>
<p class="Pp">Subrule argument lists can also be interpreted as hashes, simply
    by using the local variable <span class="Li">%arg</span> instead of
    <span class="Li">@arg</span>. Hence we could rewrite the previous
  example:</p>
<p class="Pp"></p>
<pre>    classdecl: keyword decl[keyword =&gt; $item[1],
        caller  =&gt; $item[0],
        type    =&gt; 'keyword']
    keyword:   'struct' | 'class';
    decl:      { print &quot;Declaring $arg{keyword} (a $arg{type})\n&quot;;
         print &quot;(this rule called by $arg{caller})&quot; }
</pre>
<p class="Pp">Both <span class="Li">@arg</span> and <span class="Li">%arg</span>
    are always available, so the grammar designer may choose whichever
    convention (or combination of conventions) suits best.</p>
<p class="Pp">Subrule argument lists are also useful for creating &quot;rule
    templates&quot; (especially when used in conjunction with the
    <span class="Li">&quot;&lt;matchrule:...&gt;&quot;</span> directive). For
    example, the subrule:</p>
<p class="Pp"></p>
<pre>    list:     &lt;matchrule:$arg{rule}&gt; /$arg{sep}/ list[%arg]
        { $return = [ $item[1], @{$item[3]} ] }
    |     &lt;matchrule:$arg{rule}&gt;
        { $return = [ $item[1]] }
</pre>
<p class="Pp">is a handy template for the common problem of matching a separated
    list. For example:</p>
<p class="Pp"></p>
<pre>    function: 'func' name '(' list[rule=&gt;'param',sep=&gt;';'] ')'
    param:    list[rule=&gt;'name',sep=&gt;','] ':' typename
    name:     /\w+/
    typename: name
</pre>
<p class="Pp">When a subrule argument list is used with a repeated subrule, the
    argument list goes <i>before</i> the repetition specifier:</p>
<p class="Pp"></p>
<pre>    list:   /some|many/ thing[ $item[1] ](s)
</pre>
<p class="Pp">The argument list is &quot;late bound&quot;. That is, it is
    re-evaluated for every repetition of the repeated subrule. This means that
    each repeated attempt to match the subrule may be passed a completely
    different set of arguments if the value of the expression in the argument
    list changes between attempts. So, for example, the grammar:</p>
<p class="Pp"></p>
<pre>    { $::species = 'dogs' }
    pair:   'two' animal[$::species](s)
    animal: /$arg[0]/ { $::species = 'cats' }
</pre>
<p class="Pp">will match the string &quot;two dogs cats cats&quot; completely,
    whereas it will only match the string &quot;two dogs dogs dogs&quot; up to
    the eighth letter. If the value of the argument list were &quot;early
    bound&quot; (that is, evaluated only the first time a repeated subrule match
    is attempted), one would expect the matching behaviours to be reversed.</p>
<p class="Pp">Of course, it is possible to effectively &quot;early bind&quot;
    such argument lists by passing them a value which does not change on each
    repetition. For example:</p>
<p class="Pp"></p>
<pre>    { $::species = 'dogs' }
    pair:   'two' { $::species } animal[$item[2]](s)
    animal: /$arg[0]/ { $::species = 'cats' }
</pre>
<p class="Pp">Arguments can also be passed to the start rule, simply by
    appending them to the argument list with which the start rule is called
    (<i>after</i> the &quot;line number&quot; parameter). For example,
  given:</p>
<p class="Pp"></p>
<pre>    $parser = new Parse::RecDescent ( $grammar );
    $parser-&gt;data($text, 1, &quot;str&quot;, 2, \@arr);
    #         ^^^^^  ^  ^^^^^^^^^^^^^^^
    #       |    |     |
    # TEXT TO BE PARSED  |     |
    # STARTING LINE NUMBER     |
    # ELEMENTS OF @arg WHICH IS PASSED TO RULE data
</pre>
<p class="Pp">then within the productions of the rule
    <span class="Li">&quot;data&quot;</span>, the array
    <span class="Li">@arg</span> will contain
    <span class="Li">&quot;(&quot;str&quot;, 2, \@arr)&quot;</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Alternations"><a class="permalink" href="#Alternations">Alternations</a></h2>
<p class="Pp">Alternations are implicit (unnamed) rules defined as part of a
    production. An alternation is defined as a series of '|'-separated
    productions inside a pair of round brackets. For example:</p>
<p class="Pp"></p>
<pre>    character: 'the' ( good | bad | ugly ) /dude/
</pre>
<p class="Pp">Every alternation implicitly defines a new subrule, whose
    automatically-generated name indicates its origin:
    &quot;_alternation_&lt;I&gt;_of_production_&lt;P&gt;_of_rule&lt;R&gt;&quot;
    for the appropriate values of &lt;I&gt;, &lt;P&gt;, and &lt;R&gt;. A call to
    this implicit subrule is then inserted in place of the brackets. Hence the
    above example is merely a convenient short-hand for:</p>
<p class="Pp"></p>
<pre>    character: 'the'
       _alternation_1_of_production_1_of_rule_character
       /dude/
    _alternation_1_of_production_1_of_rule_character:
       good | bad | ugly
</pre>
<p class="Pp">Since alternations are parsed by recursively calling the parser
    generator, any type(s) of item can appear in an alternation. For
  example:</p>
<p class="Pp"></p>
<pre>    character: 'the' ( 'high' &quot;plains&quot;  # Silent, with poncho
         | /no[- ]name/ # Silent, no poncho
         | vengeance_seeking    # Poncho-optional
         | &lt;error&gt;
         ) drifter
</pre>
<p class="Pp">In this case, if an error occurred, the automatically generated
    message would be:</p>
<p class="Pp"></p>
<pre>    ERROR (line &lt;N&gt;): Invalid implicit subrule: Expected
          'high' or /no[- ]name/ or generic,
          but found &quot;pacifist&quot; instead
</pre>
<p class="Pp">Since every alternation actually has a name, it's even possible to
    extend or replace them:</p>
<p class="Pp"></p>
<pre>    parser-&gt;Replace(
    &quot;_alternation_1_of_production_1_of_rule_character:
        'generic Eastwood'&quot;
        );
</pre>
<p class="Pp">More importantly, since alternations are a form of subrule, they
    can be given repetition specifiers:</p>
<p class="Pp"></p>
<pre>    character: 'the' ( good | bad | ugly )(?) /dude/
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Incremental_Parsing"><a class="permalink" href="#Incremental_Parsing">Incremental
  Parsing</a></h2>
<p class="Pp"><span class="Li">&quot;Parse::RecDescent&quot;</span> provides two
    methods - <span class="Li">&quot;Extend&quot;</span> and
    <span class="Li">&quot;Replace&quot;</span> - which can be used to alter the
    grammar matched by a parser. Both methods take the same argument as
    <span class="Li">&quot;Parse::RecDescent::new&quot;</span>, namely a grammar
    specification string</p>
<p class="Pp"><span class="Li">&quot;Parse::RecDescent::Extend&quot;</span>
    interprets the grammar specification and adds any productions it finds to
    the end of the rules for which they are specified. For example:</p>
<p class="Pp"></p>
<pre>    $add = &quot;name: 'Jimmy-Bob' | 'Bobby-Jim'\ndesc: colour /necks?/&quot;;
    parser-&gt;Extend($add);
</pre>
<p class="Pp">adds two productions to the rule &quot;name&quot; (creating it if
    necessary) and one production to the rule &quot;desc&quot;.</p>
<p class="Pp"><span class="Li">&quot;Parse::RecDescent::Replace&quot;</span> is
    identical, except that it first resets are rule specified in the additional
    grammar, removing any existing productions. Hence after:</p>
<p class="Pp"></p>
<pre>    $add = &quot;name: 'Jimmy-Bob' | 'Bobby-Jim'\ndesc: colour /necks?/&quot;;
    parser-&gt;Replace($add);
</pre>
<p class="Pp">there are <i>only</i> valid &quot;name&quot;s and the one possible
    description.</p>
<p class="Pp">A more interesting use of the
    <span class="Li">&quot;Extend&quot;</span> and
    <span class="Li">&quot;Replace&quot;</span> methods is to call them inside
    the action of an executing parser. For example:</p>
<p class="Pp"></p>
<pre>    typedef: 'typedef' type_name identifier ';'
           { $thisparser-&gt;Extend(&quot;type_name: '$item[3]'&quot;) }
       | &lt;error&gt;
    identifier: ...!type_name /[A-Za-z_]w*/
</pre>
<p class="Pp">which automatically prevents type names from being typedef'd,
  or:</p>
<p class="Pp"></p>
<pre>    command: 'map' key_name 'to' abort_key
           { $thisparser-&gt;Replace(&quot;abort_key: '$item[2]'&quot;) }
       | 'map' key_name 'to' key_name
           { map_key($item[2],$item[4]) }
       | abort_key
           { exit if confirm(&quot;abort?&quot;) }
    abort_key: 'q'
    key_name: ...!abort_key /[A-Za-z]/
</pre>
<p class="Pp">which allows the user to change the abort key binding, but not to
    unbind it.</p>
<p class="Pp">The careful use of such constructs makes it possible to
    reconfigure a a running parser, eliminating the need for semantic feedback
    by providing syntactic feedback instead. However, as currently implemented,
    <span class="Li">&quot;Replace()&quot;</span> and
    <span class="Li">&quot;Extend()&quot;</span> have to regenerate and
    re-<span class="Li">&quot;eval&quot;</span> the entire parser whenever they
    are called. This makes them quite slow for large grammars.</p>
<p class="Pp">In such cases, the judicious use of an interpolated regex is
    likely to be far more efficient:</p>
<p class="Pp"></p>
<pre>    typedef: 'typedef' type_name/ identifier ';'
           { $thisparser-&gt;{local}{type_name} .= &quot;|$item[3]&quot; }
       | &lt;error&gt;
    identifier: ...!type_name /[A-Za-z_]w*/
    type_name: /$thisparser-&gt;{local}{type_name}/
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Precompiling_parsers"><a class="permalink" href="#Precompiling_parsers">Precompiling
  parsers</a></h2>
<p class="Pp">Normally Parse::RecDescent builds a parser from a grammar at
    run-time. That approach simplifies the design and implementation of parsing
    code, but has the disadvantage that it slows the parsing process down - you
    have to wait for Parse::RecDescent to build the parser every time the
    program runs. Long or complex grammars can be particularly slow to build,
    leading to unacceptable delays at start-up.</p>
<p class="Pp">To overcome this, the module provides a way of
    &quot;pre-building&quot; a parser object and saving it in a separate module.
    That module can then be used to create clones of the original parser.</p>
<p class="Pp">A grammar may be precompiled using the
    <span class="Li">&quot;Precompile&quot;</span> class method. For example, to
    precompile a grammar stored in the scalar <span class="Li">$grammar</span>,
    and produce a class named PreGrammar in a module file named PreGrammar.pm,
    you could use:</p>
<p class="Pp"></p>
<pre>    use Parse::RecDescent;
    Parse::RecDescent-&gt;Precompile([$options_hashref], $grammar, &quot;PreGrammar&quot;, [&quot;RuntimeClass&quot;]);
</pre>
<p class="Pp">The first required argument is the grammar string, the second is
    the name of the class to be built. The name of the module file is generated
    automatically by appending &quot;.pm&quot; to the last element of the class
    name. Thus</p>
<p class="Pp"></p>
<pre>    Parse::RecDescent-&gt;Precompile($grammar, &quot;My::New::Parser&quot;);
</pre>
<p class="Pp">would produce a module file named Parser.pm.</p>
<p class="Pp">After the class name, you may specify the name of the
    runtime_class called by the Precompiled parser. See &quot;Precompiled
    runtimes&quot; for more details.</p>
<p class="Pp">An optional hash reference may be supplied as the first argument
    to <span class="Li">&quot;Precompile&quot;</span>. This argument is
    currently EXPERIMENTAL, and may change in a future release of
    Parse::RecDescent. The only supported option is currently
    <span class="Li">&quot;-standalone&quot;</span>, see &quot;Standalone
    precompiled parsers&quot;.</p>
<p class="Pp">It is somewhat tedious to have to write a small Perl program just
    to generate a precompiled grammar class, so Parse::RecDescent has some
    special magic that allows you to do the job directly from the
  command-line.</p>
<p class="Pp">If your grammar is specified in a file named <i>grammar</i>, you
    can generate a class named Yet::Another::Grammar like so:</p>
<p class="Pp"></p>
<pre>    &gt; perl -MParse::RecDescent - grammar Yet::Another::Grammar [Runtime::Class]
</pre>
<p class="Pp">This would produce a file named <i>Grammar.pm</i> containing the
    full definition of a class called Yet::Another::Grammar. Of course, to use
    that class, you would need to put the <i>Grammar.pm</i> file in a directory
    named <i>Yet/Another</i>, somewhere in your Perl include path.</p>
<p class="Pp">Having created the new class, it's very easy to use it to build a
    parser. You simply <span class="Li">&quot;use&quot;</span> the new module,
    and then call its <span class="Li">&quot;new&quot;</span> method to create a
    parser object. For example:</p>
<p class="Pp"></p>
<pre>    use Yet::Another::Grammar;
    my $parser = Yet::Another::Grammar-&gt;new();
</pre>
<p class="Pp">The effect of these two lines is exactly the same as:</p>
<p class="Pp"></p>
<pre>    use Parse::RecDescent;
    open GRAMMAR_FILE, &quot;grammar&quot; or die;
    local $/;
    my $grammar = &lt;GRAMMAR_FILE&gt;;
    my $parser = Parse::RecDescent-&gt;new($grammar);
</pre>
<p class="Pp">only considerably faster.</p>
<p class="Pp">Note however that the parsers produced by either approach are
    exactly the same, so whilst precompilation has an effect on <i>set-up</i>
    speed, it has no effect on <i>parsing</i> speed. RecDescent 2.0 will address
    that problem.</p>
<p class="Pp"><i>Standalone precompiled parsers</i></p>
<p class="Pp">Until version 1.967003 of Parse::RecDescent, parser modules built
    with <span class="Li">&quot;Precompile&quot;</span> were dependent on
    Parse::RecDescent. Future Parse::RecDescent releases with different internal
    implementations would break pre-existing precompiled parsers.</p>
<p class="Pp">Version 1.967_005 added the ability for Parse::RecDescent to
    include itself in the resulting .pm file if you pass the boolean option
    <span class="Li">&quot;-standalone&quot;</span> to
    <span class="Li">&quot;Precompile&quot;</span>:</p>
<p class="Pp"></p>
<pre>    Parse::RecDescent-&gt;Precompile({ -standalone =&gt; 1, },
        $grammar, &quot;My::New::Parser&quot;);
</pre>
<p class="Pp">Parse::RecDescent is included as
    <span class="Li">$class::_Runtime</span> in order to avoid conflicts between
    an installed version of Parse::RecDescent and other precompiled, standalone
    parser made with Parse::RecDescent. The name of this class may be changed
    with the <span class="Li">&quot;-runtime_class&quot;</span> option to
    Precompile. This renaming is experimental, and is subject to change in
    future versions.</p>
<p class="Pp">Precompiled parsers remain dependent on Parse::RecDescent by
    default, as this feature is still considered experimental. In the future,
    standalone parsers will become the default.</p>
<p class="Pp"><i>Precompiled runtimes</i></p>
<p class="Pp">Standalone precompiled parsers each include a copy of
    Parse::RecDescent. For users who have a family of related precompiled
    parsers, this is very inefficient.
    <span class="Li">&quot;Precompile&quot;</span> now supports an experimental
    <span class="Li">&quot;-runtime_class&quot;</span> option. To build a
    precompiled parser with a different runtime name, call:</p>
<p class="Pp"></p>
<pre>    Parse::RecDescent-&gt;Precompile({
            -standalone =&gt; 1,
            -runtime_class =&gt; &quot;My::Runtime&quot;,
        },
        $grammar, &quot;My::New::Parser&quot;);
</pre>
<p class="Pp">The resulting standalone parser will contain a copy of
    Parse::RecDescent, renamed to &quot;My::Runtime&quot;.</p>
<p class="Pp">To build a set of parsers that
    <span class="Li">&quot;use&quot;</span> a custom-named runtime, without
    including that runtime in the output, simply build those parsers with
    <span class="Li">&quot;-runtime_class&quot;</span> and without
    <span class="Li">&quot;-standalone&quot;</span>:</p>
<p class="Pp"></p>
<pre>    Parse::RecDescent-&gt;Precompile({
            -runtime_class =&gt; &quot;My::Runtime&quot;,
        },
        $grammar, &quot;My::New::Parser&quot;);
</pre>
<p class="Pp">The runtime itself must be generated as well, so that it may be
    <span class="Li">&quot;use&quot;</span>d by My::New::Parser. To generate the
    runtime file, use one of the two folling calls:</p>
<p class="Pp"></p>
<pre>    Parse::RecDescent-&gt;PrecompiledRuntime(&quot;My::Runtime&quot;);
    Parse::RecDescent-&gt;Precompile({
            -standalone =&gt; 1,
            -runtime_class =&gt; &quot;My::Runtime&quot;,
        },
        '', # empty grammar
        &quot;My::Runtime&quot;);
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="GOTCHAS"><a class="permalink" href="#GOTCHAS">GOTCHAS</a></h1>
<p class="Pp">This section describes common mistakes that grammar writers seem
    to make on a regular basis.</p>
<section class="Ss">
<h2 class="Ss" id="1._Expecting_an_error_to_always_invalidate_a_parse"><a class="permalink" href="#1._Expecting_an_error_to_always_invalidate_a_parse">1.
  Expecting an error to always invalidate a parse</a></h2>
<p class="Pp">A common mistake when using error messages is to write the grammar
    like this:</p>
<p class="Pp"></p>
<pre>    file: line(s)
    line: line_type_1
    | line_type_2
    | line_type_3
    | &lt;error&gt;
</pre>
<p class="Pp">The expectation seems to be that any line that is not of type 1, 2
    or 3 will invoke the <span class="Li">&quot;&lt;error&gt;&quot;</span>
    directive and thereby cause the parse to fail.</p>
<p class="Pp">Unfortunately, that only happens if the error occurs in the very
    first line. The first rule states that a
    <span class="Li">&quot;file&quot;</span> is matched by one or more lines, so
    if even a single line succeeds, the first rule is completely satisfied and
    the parse as a whole succeeds. That means that any error messages generated
    by subsequent failures in the <span class="Li">&quot;line&quot;</span> rule
    are quietly ignored.</p>
<p class="Pp">Typically what's really needed is this:</p>
<p class="Pp"></p>
<pre>    file: line(s) eofile    { $return = $item[1] }
    line: line_type_1
    | line_type_2
    | line_type_3
    | &lt;error&gt;
    eofile: /^\Z/
</pre>
<p class="Pp">The addition of the <span class="Li">&quot;eofile&quot;</span>
    subrule to the first production means that a file only matches a series of
    successful <span class="Li">&quot;line&quot;</span> matches <i>that consume
    the</i> <i>complete input text</i>. If any input text remains after the
    lines are matched, there must have been an error in the last
    <span class="Li">&quot;line&quot;</span>. In that case the
    <span class="Li">&quot;eofile&quot;</span> rule will fail, causing the
    entire <span class="Li">&quot;file&quot;</span> rule to fail too.</p>
<p class="Pp">Note too that <span class="Li">&quot;eofile&quot;</span> must
    match <span class="Li">&quot;/^\Z/&quot;</span> (end-of-text), <i>not</i>
    <span class="Li">&quot;/^\cZ/&quot;</span> or
    <span class="Li">&quot;/^\cD/&quot;</span> (end-of-file).</p>
<p class="Pp">And don't forget the action at the end of the production. If you
    just write:</p>
<p class="Pp"></p>
<pre>    file: line(s) eofile
</pre>
<p class="Pp">then the value returned by the
    <span class="Li">&quot;file&quot;</span> rule will be the value of its last
    item: <span class="Li">&quot;eofile&quot;</span>. Since
    <span class="Li">&quot;eofile&quot;</span> always returns an empty string on
    success, that will cause the <span class="Li">&quot;file&quot;</span> rule
    to return that empty string. Apart from returning the wrong value, returning
    an empty string will trip up code such as:</p>
<p class="Pp"></p>
<pre>    $parser-&gt;file($filetext) || die;
</pre>
<p class="Pp">(since &quot;&quot; is false).</p>
<p class="Pp">Remember that Parse::RecDescent returns undef on failure, so the
    only safe test for failure is:</p>
<p class="Pp"></p>
<pre>    defined($parser-&gt;file($filetext)) || die;
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="2._Using_a__return__in_an_action"><a class="permalink" href="#2._Using_a__return__in_an_action">2.
  Using a &quot;return&quot; in an action</a></h2>
<p class="Pp">An action is like a <span class="Li">&quot;do&quot;</span> block
    inside the subroutine implementing the surrounding rule. So if you put a
    <span class="Li">&quot;return&quot;</span> statement in an action:</p>
<p class="Pp"></p>
<pre>    range: '(' start '..' end )'
        { return $item{end} }
       /\s+/
</pre>
<p class="Pp">that subroutine will immediately return, without checking the rest
    of the items in the current production (e.g. the
    <span class="Li">&quot;/\s+/&quot;</span>) and without setting up the
    necessary data structures to tell the parser that the rule has
  succeeded.</p>
<p class="Pp">The correct way to set a return value in an action is to set the
    <span class="Li">$return</span> variable:</p>
<p class="Pp"></p>
<pre>    range: '(' start '..' end )'
                { $return = $item{end} }
           /\s+/
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="2._Setting_$Parse::RecDescent::skip_at_parse_time"><a class="permalink" href="#2._Setting_$Parse::RecDescent::skip_at_parse_time">2.
  Setting $Parse::RecDescent::skip at parse time</a></h2>
<p class="Pp">If you want to change the default skipping behaviour (see
    &quot;Terminal Separators&quot; and the
    <span class="Li">&quot;&lt;skip:...&gt;&quot;</span> directive) by setting
    <span class="Li">$Parse::RecDescent::skip</span> you have to remember to set
    this variable <i>before</i> creating the grammar object.</p>
<p class="Pp">For example, you might want to skip all Perl-like comments with
    this regular expression:</p>
<p class="Pp"></p>
<pre>   my $skip_spaces_and_comments = qr/
         (?mxs:
            \s+         # either spaces
            | \# .*?$   # or a dash and whatever up to the end of line
         )*             # repeated at will (in whatever order)
      /;
</pre>
<p class="Pp">And then:</p>
<p class="Pp"></p>
<pre>   my $parser1 = Parse::RecDescent-&gt;new($grammar);
   $Parse::RecDescent::skip = $skip_spaces_and_comments;
   my $parser2 = Parse::RecDescent-&gt;new($grammar);
   $parser1-&gt;parse($text); # this does not cope with comments
   $parser2-&gt;parse($text); # this skips comments correctly
</pre>
<p class="Pp">The two parsers behave differently, because any skipping behaviour
    specified via <span class="Li">$Parse::RecDescent::skip</span> is hard-coded
    when the grammar object is built, not at parse time.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="DIAGNOSTICS"><a class="permalink" href="#DIAGNOSTICS">DIAGNOSTICS</a></h1>
<p class="Pp">Diagnostics are intended to be self-explanatory (particularly if
    you use <b>-RD_HINT</b> (under <b>perl -s</b>) or define
    <span class="Li">$::RD_HINT</span> inside the program).</p>
<p class="Pp"><span class="Li">&quot;Parse::RecDescent&quot;</span> currently
    diagnoses the following:</p>
<ul class="Bl-bullet">
  <li>Invalid regular expressions used as pattern terminals (fatal error).</li>
  <li>Invalid Perl code in code blocks (fatal error).</li>
  <li>Lookahead used in the wrong place or in a nonsensical way (fatal
    error).</li>
  <li>&quot;Obvious&quot; cases of left-recursion (fatal error).</li>
  <li>Missing or extra components in a
      <span class="Li">&quot;&lt;leftop&gt;&quot;</span> or
      <span class="Li">&quot;&lt;rightop&gt;&quot;</span> directive.</li>
  <li>Unrecognisable components in the grammar specification (fatal error).</li>
  <li>&quot;Orphaned&quot; rule components specified before the first rule
      (fatal error) or after an
      <span class="Li">&quot;&lt;error&gt;&quot;</span> directive (level 3
      warning).</li>
  <li>Missing rule definitions (this only generates a level 3 warning, since you
      may be providing them later via
      <span class="Li">&quot;Parse::RecDescent::Extend()&quot;</span>).</li>
  <li>Instances where greedy repetition behaviour will almost certainly cause
      the failure of a production (a level 3 warning - see &quot;ON-GOING ISSUES
      AND FUTURE DIRECTIONS&quot; below).</li>
  <li>Attempts to define rules named 'Replace' or 'Extend', which cannot be
      called directly through the parser object because of the predefined
      meaning of <span class="Li">&quot;Parse::RecDescent::Replace&quot;</span>
      and <span class="Li">&quot;Parse::RecDescent::Extend&quot;</span>. (Only a
      level 2 warning is generated, since such rules <i>can</i> still be used as
      subrules).</li>
  <li>Productions which consist of a single
      <span class="Li">&quot;&lt;error?&gt;&quot;</span> directive, and which
      therefore may succeed unexpectedly (a level 2 warning, since this might
      conceivably be the desired effect).</li>
  <li>Multiple consecutive lookahead specifiers (a level 1 warning only, since
      their effects simply accumulate).</li>
  <li>Productions which start with a
      <span class="Li">&quot;&lt;reject&gt;&quot;</span> or
      <span class="Li">&quot;&lt;rulevar:...&gt;&quot;</span> directive. Such
      productions are optimized away (a level 1 warning).</li>
  <li>Rules which are autogenerated under <span class="Li">$::AUTOSTUB</span> (a
      level 1 warning).</li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">Damian Conway (damian@conway.org) Jeremy T. Braun
    (JTBRAUN@CPAN.org) [current maintainer]</p>
</section>
<section class="Sh">
<h1 class="Sh" id="BUGS_AND_IRRITATIONS"><a class="permalink" href="#BUGS_AND_IRRITATIONS">BUGS
  AND IRRITATIONS</a></h1>
<p class="Pp">There are undoubtedly serious bugs lurking somewhere in this much
    code :-) Bug reports, test cases and other feedback are most welcome.</p>
<p class="Pp">Ongoing annoyances include:</p>
<ul class="Bl-bullet">
  <li>There's no support for parsing directly from an input stream. If and when
      the Perl Gods give us regular expressions on streams, this should be
      trivial (ahem!) to implement.</li>
  <li>The parser generator can get confused if actions aren't properly closed or
      if they contain particularly nasty Perl syntax errors (especially
      unmatched curly brackets).</li>
  <li>The generator only detects the most obvious form of left recursion
      (potential recursion on the first subrule in a rule). More subtle forms of
      left recursion (for example, through the second item in a rule after a
      &quot;zero&quot; match of a preceding &quot;zero-or-more&quot; repetition,
      or after a match of a subrule with an empty production) are not
    found.</li>
  <li>Instead of complaining about left-recursion, the generator should silently
      transform the grammar to remove it. Don't expect this feature any time
      soon as it would require a more sophisticated approach to parser
      generation than is currently used.</li>
  <li>The generated parsers don't always run as fast as might be wished.</li>
  <li>The meta-parser should be bootstrapped using
      <span class="Li">&quot;Parse::RecDescent&quot;</span> :-)</li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="ON-GOING_ISSUES_AND_FUTURE_DIRECTIONS"><a class="permalink" href="#ON-GOING_ISSUES_AND_FUTURE_DIRECTIONS">ON-GOING
  ISSUES AND FUTURE DIRECTIONS</a></h1>
<dl class="Bl-tag">
  <dt>1.</dt>
  <dd>Repetitions are &quot;incorrigibly greedy&quot; in that they will eat
      everything they can and won't backtrack if that behaviour causes a
      production to fail needlessly. So, for example:
    <p class="Pp"></p>
    <pre>    rule: subrule(s) subrule
    </pre>
    <p class="Pp">will <i>never</i> succeed, because the repetition will eat all
        the subrules it finds, leaving none to match the second item. Such
        constructions are relatively rare (and
        <span class="Li">&quot;Parse::RecDescent::new&quot;</span> generates a
        warning whenever they occur) so this may not be a problem, especially
        since the insatiable behaviour can be overcome &quot;manually&quot; by
        writing:</p>
    <p class="Pp"></p>
    <pre>    rule: penultimate_subrule(s) subrule
    penultimate_subrule: subrule ...subrule
    </pre>
    <p class="Pp">The issue is that this construction is exactly twice as
        expensive as the original, whereas backtracking would add only
        1/<i>N</i> to the cost (for matching <i>N</i> repetitions of
        <span class="Li">&quot;subrule&quot;</span>). I would welcome feedback
        on the need for backtracking; particularly on cases where the lack of it
        makes parsing performance problematical.</p>
  </dd>
  <dt>2.</dt>
  <dd>Having opened that can of worms, it's also necessary to consider whether
      there is a need for non-greedy repetition specifiers. Again, it's possible
      (at some cost) to manually provide the required functionality:
    <p class="Pp"></p>
    <pre>    rule: nongreedy_subrule(s) othersubrule
    nongreedy_subrule: subrule ...!othersubrule
    </pre>
    <p class="Pp">Overall, the issue is whether the benefit of this extra
        functionality outweighs the drawbacks of further complicating the
        (currently minimalist) grammar specification syntax, and (worse)
        introducing more overhead into the generated parsers.</p>
  </dd>
  <dt>3.</dt>
  <dd>An <span class="Li">&quot;&lt;autocommit&gt;&quot;</span> directive would
      be nice. That is, it would be useful to be able to say:
    <p class="Pp"></p>
    <pre>    command: &lt;autocommit&gt;
    command: 'find' name
       | 'find' address
       | 'do' command 'at' time 'if' condition
       | 'do' command 'at' time
       | 'do' command
       | unusual_command
    </pre>
    <p class="Pp">and have the generator work out that this should be
        &quot;pruned&quot; thus:</p>
    <p class="Pp"></p>
    <pre>    command: 'find' name
       | 'find' &lt;commit&gt; address
       | 'do' &lt;commit&gt; command &lt;uncommit&gt;
        'at' time
        'if' &lt;commit&gt; condition
       | 'do' &lt;commit&gt; command &lt;uncommit&gt;
        'at' &lt;commit&gt; time
       | 'do' &lt;commit&gt; command
       | unusual_command
    </pre>
    <p class="Pp">There are several issues here. Firstly, should the
        <span class="Li">&quot;&lt;autocommit&gt;&quot;</span> automatically
        install an <span class="Li">&quot;&lt;uncommit&gt;&quot;</span> at the
        start of the last production (on the grounds that the
        &quot;command&quot; rule doesn't know whether an
        &quot;unusual_command&quot; might start with &quot;find&quot; or
        &quot;do&quot;) or should the &quot;unusual_command&quot; subgraph be
        analysed (to see if it <i>might</i> be viable after a &quot;find&quot;
        or &quot;do&quot;)?</p>
    <p class="Pp">The second issue is how regular expressions should be treated.
        The simplest approach would be simply to uncommit before them (on the
        grounds that they <i>might</i> match). Better efficiency would be
        obtained by analyzing all preceding literal tokens to determine whether
        the pattern would match them.</p>
    <p class="Pp">Overall, the issues are: can such automated
        &quot;pruning&quot; approach a hand-tuned version sufficiently closely
        to warrant the extra set-up expense, and (more importantly) is the
        problem important enough to even warrant the non-trivial effort of
        building an automated solution?</p>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="SUPPORT"><a class="permalink" href="#SUPPORT">SUPPORT</a></h1>
<section class="Ss">
<h2 class="Ss" id="Source_Code_Repository"><a class="permalink" href="#Source_Code_Repository">Source
  Code Repository</a></h2>
<p class="Pp">&lt;http://github.com/jtbraun/Parse-RecDescent&gt;</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Mailing_List"><a class="permalink" href="#Mailing_List">Mailing
  List</a></h2>
<p class="Pp">Visit
    &lt;http://www.perlfoundation.org/perl5/index.cgi?parse_recdescent&gt; to
    sign up for the mailing list.</p>
<p class="Pp">&lt;http://www.PerlMonks.org&gt; is also a good place to ask
    questions. Previous posts about Parse::RecDescent can typically be found
    with this search: &lt;http://perlmonks.org/index.pl?node=recdescent&gt;.</p>
</section>
<section class="Ss">
<h2 class="Ss">FAQ</h2>
<p class="Pp">Visit Parse::RecDescent::FAQ for answers to frequently (and not so
    frequently) asked questions about Parse::RecDescent.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="View/Report_Bugs"><a class="permalink" href="#View/Report_Bugs">View/Report
  Bugs</a></h2>
<p class="Pp">To view the current bug list or report a new issue visit
    &lt;https://rt.cpan.org/Public/Dist/Display.html?Name=Parse-RecDescent&gt;.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp">Regexp::Grammars provides Parse::RecDescent style parsing using
    native Perl 5.10 regular expressions.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="LICENCE_AND_COPYRIGHT"><a class="permalink" href="#LICENCE_AND_COPYRIGHT">LICENCE
  AND COPYRIGHT</a></h1>
<p class="Pp">Copyright (c) 1997-2007, Damian Conway
    <span class="Li">&quot;&lt;DCONWAY@CPAN.org&gt;&quot;</span>. All rights
    reserved.</p>
<p class="Pp">This module is free software; you can redistribute it and/or
    modify it under the same terms as Perl itself. See perlartistic.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DISCLAIMER_OF_WARRANTY"><a class="permalink" href="#DISCLAIMER_OF_WARRANTY">DISCLAIMER
  OF WARRANTY</a></h1>
<p class="Pp">BECAUSE THIS SOFTWARE IS LICENSED FREE OF CHARGE, THERE IS NO
    WARRANTY FOR THE SOFTWARE, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT
    WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
    PROVIDE THE SOFTWARE &quot;AS IS&quot; WITHOUT WARRANTY OF ANY KIND, EITHER
    EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
    OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE ENTIRE RISK AS
    TO THE QUALITY AND PERFORMANCE OF THE SOFTWARE IS WITH YOU. SHOULD THE
    SOFTWARE PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
    REPAIR, OR CORRECTION.</p>
<p class="Pp">IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN
    WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
    REDISTRIBUTE THE SOFTWARE AS PERMITTED BY THE ABOVE LICENCE, BE LIABLE TO
    YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL, OR
    CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE
    SOFTWARE (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING RENDERED
    INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A FAILURE OF THE
    SOFTWARE TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF SUCH HOLDER OR OTHER
    PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2023-05-20</td>
    <td class="foot-os">perl v5.34.0</td>
  </tr>
</table>
</body>
</html>
