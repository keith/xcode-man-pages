<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>autobox(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">autobox(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">autobox(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
autobox - call methods on native types
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<span class="Li"></span>
<pre>
    use autobox;

    # integers

        my $range = 10-&gt;to(1); # [ 10, 9, 8, 7, 6, 5, 4, 3, 2, 1 ]

    # floats

        my $error = 3.1415927-&gt;minus(22/7)-&gt;abs();

    # strings

        my @list = 'SELECT * FROM foo'-&gt;list();
        my $greeting = &quot;Hello, world!&quot;-&gt;upper(); # &quot;HELLO, WORLD!&quot;

        $greeting-&gt;for_each(\&amp;character_handler);

    # arrays and array refs

        my $schwartzian = @_-&gt;map(...)-&gt;sort(...)-&gt;map(...);
        my $hash = [ 'SELECT * FROM foo WHERE id IN (?, ?)', 1, 2 ]-&gt;hash();

    # hashes and hash refs

        { alpha =&gt; 'beta', gamma =&gt; 'vlissides' }-&gt;for_each(...);
        %hash-&gt;keys();

    # code refs

        my $plus_five = (\&amp;add)-&gt;curry()-&gt;(5);
        my $minus_three = sub { $_[0] - $_[1] }-&gt;reverse-&gt;curry-&gt;(3);

    # can, isa, VERSION, import and unimport can be accessed via autobox_class

        42-&gt;autobox_class-&gt;isa('MyNumber')
        say []-&gt;autobox_class-&gt;VERSION
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
The <span class="Li">&quot;autobox&quot;</span> pragma allows methods to be
  called on integers, floats, strings, arrays, hashes, and code references in
  exactly the same manner as blessed references.
<p class="Pp">Autoboxing is transparent: values are not blessed into their
    (user-defined) implementation class (unless the method elects to bestow such
    a blessing) - they simply use its methods as though they are.</p>
<p class="Pp">The classes (packages) into which the native types are boxed are
    fully configurable. By default, a method invoked on a non-object value is
    assumed to be defined in a class whose name corresponds to the
    <span class="Li">&quot;ref()&quot;</span> type of that value - or SCALAR if
    the value is a non-reference.</p>
<p class="Pp">This mapping can be overridden by passing key/value pairs to the
    <span class="Li">&quot;use autobox&quot;</span> statement, in which the keys
    represent native types, and the values their associated classes.</p>
<p class="Pp">As with regular objects, autoboxed values are passed as the first
    argument of the specified method. Consequently, given a vanilla
    <span class="Li">&quot;use autobox&quot;</span>:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    &quot;Hello, world!&quot;-&gt;upper()
</pre>
<p class="Pp">is invoked as:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    SCALAR::upper(&quot;hello, world!&quot;)
</pre>
<p class="Pp">while:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    [ 1 .. 10 ]-&gt;for_each(sub { ... })
</pre>
<p class="Pp">resolves to:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    ARRAY::for_each([ 1 .. 10 ], sub { ... })
</pre>
<p class="Pp">Values beginning with the array
    <span class="Li">&quot;@&quot;</span> and hash
    <span class="Li">&quot;%&quot;</span> sigils are passed by reference, i.e.
    under the default bindings:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    @array-&gt;join(', ')
    @{ ... }-&gt;length()
    %hash-&gt;keys()
    %$hash-&gt;values()
</pre>
<p class="Pp">are equivalent to:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    ARRAY::join(\@array, ', ')
    ARRAY::length(\@{ ... })
    HASH::keys(\%hash)
    HASH::values(\%$hash)
</pre>
<p class="Pp">Multiple <span class="Li">&quot;use autobox&quot;</span>
    statements can appear in the same scope. These are merged both
    &quot;horizontally&quot; (i.e. multiple classes can be associated with a
    particular type) and &quot;vertically&quot; (i.e. multiple classes can be
    associated with multiple types).</p>
<p class="Pp">Thus:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    use autobox SCALAR =&gt; 'Foo';
    use autobox SCALAR =&gt; 'Bar';
</pre>
<p class="Pp">- associates SCALAR types with a synthetic class whose
    <span class="Li">@ISA</span> includes both
    <span class="Li">&quot;Foo&quot;</span> and
    <span class="Li">&quot;Bar&quot;</span> (in that order).</p>
<p class="Pp">Likewise:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    use autobox SCALAR =&gt; 'Foo';
    use autobox SCALAR =&gt; 'Bar';
    use autobox ARRAY  =&gt; 'Baz';
</pre>
<p class="Pp">and</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    use autobox SCALAR =&gt; [ 'Foo', 'Bar' ];
    use autobox ARRAY  =&gt; 'Baz';
</pre>
<p class="Pp">- bind SCALAR types to the <span class="Li">&quot;Foo&quot;</span>
    and <span class="Li">&quot;Bar&quot;</span> classes and ARRAY types to
    <span class="Li">&quot;Baz&quot;</span>.</p>
<p class="Pp"><span class="Li">&quot;autobox&quot;</span> is lexically scoped,
    and bindings for an outer scope can be extended or countermanded in a nested
    scope:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    {
        use autobox; # default bindings: autobox all native types
        ...

        {
            # appends 'MyScalar' to the @ISA associated with SCALAR types
            use autobox SCALAR =&gt; 'MyScalar';
            ...
        }

        # back to the default (no MyScalar)
        ...
    }
</pre>
<p class="Pp">Autoboxing can be turned off entirely by using the
    <span class="Li">&quot;no&quot;</span> syntax:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    {
        use autobox;
        ...
        no autobox;
        ...
    }
</pre>
<p class="Pp">- or can be selectively disabled by passing arguments to the
    <span class="Li">&quot;no autobox&quot;</span> statement:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    use autobox; # default bindings

    no autobox qw(SCALAR);

    []-&gt;foo(); # OK: ARRAY::foo([])

    &quot;Hello, world!&quot;-&gt;bar(); # runtime error
</pre>
<p class="Pp">Autoboxing is not performed for barewords i.e.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    my $foo = Foo-&gt;new();
</pre>
<p class="Pp">and:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    my $foo = new Foo;
</pre>
<p class="Pp">behave as expected.</p>
<p class="Pp">Methods are called on native types by means of the arrow operator.
    As with regular objects, the right hand side of the operator can either be a
    bare method name or a variable containing a method name or subroutine
    reference. Thus the following are all valid:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    sub method1 { ... }
    my $method2 = 'some_method';
    my $method3 = sub { ... };
    my $method4 = \&amp;some_method;

    &quot; ... &quot;-&gt;method1();
    [ ... ]-&gt;$method2();
    { ... }-&gt;$method3();
    sub { ... }-&gt;$method4();
</pre>
<p class="Pp">A native type is only associated with a class if the type =&gt;
    class mapping is supplied in the <span class="Li">&quot;use
    autobox&quot;</span> statement. Thus the following will not work:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    use autobox SCALAR =&gt; 'MyScalar';

    @array-&gt;some_array_method();
</pre>
<p class="Pp">- as no class is specified for the ARRAY type. Note: the result of
    calling a method on a native type that is not associated with a class is the
    usual runtime error message:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    Can't call method &quot;some_array_method&quot; on unblessed reference at ...
</pre>
<p class="Pp">As a convenience, there is one exception to this rule. If
    <span class="Li">&quot;use autobox&quot;</span> is invoked with no arguments
    (ignoring the DEBUG option) the four main native types are associated with
    classes of the same name.</p>
<p class="Pp">Thus:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    use autobox;
</pre>
<p class="Pp">- is equivalent to:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    use autobox {
        SCALAR =&gt; 'SCALAR',
        ARRAY  =&gt; 'ARRAY',
        HASH   =&gt; 'HASH',
        CODE   =&gt; 'CODE',
    }
</pre>
<p class="Pp">This facilitates one-liners and prototypes:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    use autobox;

    sub SCALAR::split { [ split '', $_[0] ] }
    sub ARRAY::length { scalar @{$_[0]} }

    print &quot;Hello, world!&quot;-&gt;split-&gt;length();
</pre>
<p class="Pp">However, using these default bindings is not recommended as
    there's no guarantee that another piece of code won't trample over the same
    namespace/methods.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="OPTIONS"><a class="permalink" href="#OPTIONS">OPTIONS</a></h1>
A mapping from native types to their user-defined classes can be specified by
  passing a hashref or a list of key/value pairs to the
  <span class="Li">&quot;use autobox&quot;</span> statement.
<p class="Pp">The following example shows the range of valid arguments:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    use autobox {
        SCALAR    =&gt; 'MyScalar'                     # class name
        ARRAY     =&gt; 'MyNamespace::',               # class prefix (ending in '::')
        HASH      =&gt; [ 'MyHash', 'MyNamespace::' ], # one or more class names and/or prefixes
        CODE      =&gt; ...,                           # any of the 3 value types above
        INTEGER   =&gt; ...,                           # any of the 3 value types above
        FLOAT     =&gt; ...,                           # any of the 3 value types above
        NUMBER    =&gt; ...,                           # any of the 3 value types above
        STRING    =&gt; ...,                           # any of the 3 value types above
        UNDEF     =&gt; ...,                           # any of the 3 value types above
        UNIVERSAL =&gt; ...,                           # any of the 3 value types above
        DEFAULT   =&gt; ...,                           # any of the 3 value types above
        DEBUG     =&gt; ...                            # boolean or coderef
    }
</pre>
<p class="Pp">The INTEGER, FLOAT, NUMBER, STRING, SCALAR, ARRAY, HASH, CODE,
    UNDEF, DEFAULT and UNIVERSAL options can take three different types of
    value:</p>
<ul class="Bl-bullet">
  <li>A class name e.g.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    use autobox INTEGER =&gt; 'MyInt';
    </pre>
    <p class="Pp">This binds the specified native type to the specified class.
        All methods invoked on values of type
        <span class="Li">&quot;key&quot;</span> will be dispatched as methods of
        the class specified in the corresponding
        <span class="Li">&quot;value&quot;</span>.</p>
  </li>
  <li>A namespace: this is a class prefix (up to and including the final '::')
      to which the specified type name (INTEGER, FLOAT, STRING &amp;c.) will be
      appended:
    <p class="Pp">Thus:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    use autobox ARRAY =&gt; 'Prelude::';
    </pre>
    <p class="Pp">is equivalent to:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    use autobox ARRAY =&gt; 'Prelude::ARRAY';
    </pre>
  </li>
  <li>A reference to an array of class names and/or namespaces. This associates
      multiple classes with the specified type.</li>
</ul>
<section class="Ss">
<h2 class="Ss" id="_s-1DEFAULT_s0"><a class="permalink" href="#_s-1DEFAULT_s0">DEFAULT</a></h2>
The <span class="Li">&quot;DEFAULT&quot;</span> option specifies bindings for
  any of the four default types (SCALAR, ARRAY, HASH and CODE) not supplied in
  the <span class="Li">&quot;use autobox&quot;</span> statement. As with the
  other options, the <span class="Li">&quot;value&quot;</span> corresponding to
  the <span class="Li">&quot;DEFAULT&quot;</span>
  <span class="Li">&quot;key&quot;</span> can be a class name, a namespace, or a
  reference to an array containing one or more class names and/or namespaces.
<p class="Pp">Thus:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    use autobox {
        STRING  =&gt; 'MyString',
        DEFAULT =&gt; 'MyDefault',
    }
</pre>
<p class="Pp">is equivalent to:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    use autobox {
        STRING  =&gt; 'MyString',
        SCALAR  =&gt; 'MyDefault',
        ARRAY   =&gt; 'MyDefault',
        HASH    =&gt; 'MyDefault',
        CODE    =&gt; 'MyDefault',
    }
</pre>
<p class="Pp">Which in turn is equivalent to:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    use autobox {
        INTEGER =&gt; 'MyDefault',
        FLOAT   =&gt; 'MyDefault',
        STRING  =&gt; [ 'MyString', 'MyDefault' ],
        ARRAY   =&gt; 'MyDefault',
        HASH    =&gt; 'MyDefault',
        CODE    =&gt; 'MyDefault',
    }
</pre>
<p class="Pp">Namespaces in DEFAULT values have the default type name appended,
    which, in the case of defaulted SCALAR types, is SCALAR rather than INTEGER,
    FLOAT &amp;c.</p>
<p class="Pp">Thus:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    use autobox {
        ARRAY   =&gt; 'MyArray',
        HASH    =&gt; 'MyHash',
        CODE    =&gt; 'MyCode',
        DEFAULT =&gt; 'MyNamespace::',
    }
</pre>
<p class="Pp">is equivalent to:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    use autobox {
        INTEGER =&gt; 'MyNamespace::SCALAR',
        FLOAT   =&gt; 'MyNamespace::SCALAR',
        STRING  =&gt; 'MyNamespace::SCALAR',
        ARRAY   =&gt; 'MyArray',
        HASH    =&gt; 'MyArray',
        CODE    =&gt; 'MyCode',
    }
</pre>
<p class="Pp">Any of the four default types can be exempted from defaulting to
    the DEFAULT value by supplying a value of undef:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    use autobox {
        HASH    =&gt; undef,
        DEFAULT =&gt; 'MyDefault',
    }

    42-&gt;foo # ok: MyDefault::foo
    []-&gt;bar # ok: MyDefault::bar

    %INC-&gt;baz # not ok: runtime error
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="_s-1UNDEF_s0"><a class="permalink" href="#_s-1UNDEF_s0">UNDEF</a></h2>
The pseudotype, UNDEF, can be used to autobox undefined values. These are not
  autoboxed by default.
<p class="Pp">This doesn't work:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    use autobox;

    undef-&gt;foo() # runtime error
</pre>
<p class="Pp">This works:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    use autobox UNDEF =&gt; 'MyUndef';

    undef-&gt;foo(); # ok
</pre>
<p class="Pp">So does this:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    use autobox UNDEF =&gt; 'MyNamespace::';

    undef-&gt;foo(); # ok
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="_s-1NUMBER,_SCALAR_s0_and__s-1UNIVERSAL_s0"><a class="permalink" href="#_s-1NUMBER,_SCALAR_s0_and__s-1UNIVERSAL_s0">NUMBER,
  SCALAR and UNIVERSAL</a></h2>
The virtual types NUMBER, SCALAR and UNIVERSAL function as macros or shortcuts
  which create bindings for their subtypes. The type hierarchy is as follows:
<p class="Pp"><span class="Li"></span></p>
<pre>
  UNIVERSAL -+
             |
             +- SCALAR -+
             |          |
             |          +- NUMBER -+
             |          |          |
             |          |          +- INTEGER
             |          |          |
             |          |          +- FLOAT
             |          |
             |          +- STRING
             |
             +- ARRAY
             |
             +- HASH
             |
             +- CODE
</pre>
<p class="Pp">Thus:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    use autobox NUMBER =&gt; 'MyNumber';
</pre>
<p class="Pp">is equivalent to:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    use autobox {
        INTEGER =&gt; 'MyNumber',
        FLOAT   =&gt; 'MyNumber',
    }
</pre>
<p class="Pp">And:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    use autobox SCALAR =&gt; 'MyScalar';
</pre>
<p class="Pp">is equivalent to:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    use autobox {
        INTEGER =&gt; 'MyScalar',
        FLOAT   =&gt; 'MyScalar',
        STRING  =&gt; 'MyScalar',
    }
</pre>
<p class="Pp">Virtual types can also be passed to
    <span class="Li">&quot;unimport&quot;</span> via the
    <span class="Li">&quot;no autobox&quot;</span> syntax. This disables
    autoboxing for the corresponding subtypes e.g.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    no autobox qw(NUMBER);
</pre>
<p class="Pp">is equivalent to:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    no autobox qw(INTEGER FLOAT);
</pre>
<p class="Pp">Virtual type bindings can be mixed with ordinary bindings to
    provide fine-grained control over inheritance and delegation. For
  instance:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    use autobox {
        INTEGER =&gt; 'MyInteger',
        NUMBER  =&gt; 'MyNumber',
        SCALAR  =&gt; 'MyScalar',
    }
</pre>
<p class="Pp">would result in the following bindings:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    42-&gt;foo             -&gt; [ MyInteger, MyNumber, MyScalar ]
    3.1415927-&gt;bar      -&gt; [ MyNumber, MyScalar ]
    &quot;Hello, world!-&gt;baz -&gt; [ MyScalar ]
</pre>
<p class="Pp">Note that DEFAULT bindings take precedence over virtual type
    bindings i.e.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    use autobox {
        UNIVERSAL =&gt; 'MyUniversal',
        DEFAULT   =&gt; 'MyDefault', # default SCALAR, ARRAY, HASH and CODE before UNIVERSAL
    }
</pre>
<p class="Pp">is equivalent to:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  use autobox {
      INTEGER =&gt; [ 'MyDefault', 'MyUniversal' ],
      FLOAT   =&gt; [ 'MyDefault', 'MyUniversal' ], # ... &amp;c.
  }
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="_s-1DEBUG_s0"><a class="permalink" href="#_s-1DEBUG_s0">DEBUG</a></h2>
<span class="Li">&quot;DEBUG&quot;</span> exposes the current bindings for the
  scope in which <span class="Li">&quot;use autobox&quot;</span> is called by
  means of a callback, or a static debugging function.
<p class="Pp">This allows the computed bindings to be seen in
    &quot;longhand&quot;.</p>
<p class="Pp">The option is ignored if the value corresponding to the
    <span class="Li">&quot;DEBUG&quot;</span> key is false.</p>
<p class="Pp">If the value is a CODE ref, then this sub is called with a
    reference to the hash containing the computed bindings for the current
    scope.</p>
<p class="Pp">Finally, if <span class="Li">&quot;DEBUG&quot;</span> is true but
    not a CODE ref, the bindings are dumped to STDERR.</p>
<p class="Pp">Thus:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    use autobox DEBUG =&gt; 1, ...
</pre>
<p class="Pp">or</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    use autobox DEBUG =&gt; sub { ... }, ...
</pre>
<p class="Pp">or</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    sub my_callback ($) {
        my $hashref = shift;
        ...
    }

    use autobox DEBUG =&gt; \&amp;my_callback, ...
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="METHODS"><a class="permalink" href="#METHODS">METHODS</a></h1>
<section class="Ss">
<h2 class="Ss" id="import"><a class="permalink" href="#import">import</a></h2>
This method sets up <span class="Li">&quot;autobox&quot;</span> bindings for the
  current lexical scope. It can be used to implement
  <span class="Li">&quot;autobox&quot;</span> extensions i.e. lexically-scoped
  modules that provide <span class="Li">&quot;autobox&quot;</span> bindings for
  one or more native types without requiring calling code to
  <span class="Li">&quot;use autobox&quot;</span>.
<p class="Pp">This is done by subclassing
    <span class="Li">&quot;autobox&quot;</span> and overriding
    <span class="Li">&quot;import&quot;</span>. This allows extensions to
    effectively translate <span class="Li">&quot;use MyModule&quot;</span> into
    a bespoke <span class="Li">&quot;use autobox&quot;</span> call. e.g.:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    package String::Trim;

    use base qw(autobox);

    sub import {
        my $class = shift;
        $class-&gt;SUPER::import(
            STRING =&gt; 'String::Trim::String'
        );
    }

    package String::Trim::String;

    sub trim {
        my $string = shift;
        $string =~ s/^\s+//;
        $string =~ s/\s+$//;
        $string;
    }

    1;
</pre>
<p class="Pp">Note that <span class="Li">&quot;trim&quot;</span> is defined in
    an auxiliary class rather than in
    <span class="Li">&quot;String::Trim&quot;</span> itself to prevent
    <span class="Li">&quot;String::Trim&quot;</span>'s own methods (i.e. the
    methods it inherits from <span class="Li">&quot;autobox&quot;</span>) being
    exposed to <span class="Li">&quot;STRING&quot;</span> types.</p>
<p class="Pp">This module can now be used without a <span class="Li">&quot;use
    autobox&quot;</span> statement to enable the
    <span class="Li">&quot;trim&quot;</span> method in the current lexical
    scope. e.g.:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    #!/usr/bin/env perl

    use String::Trim;

    print &quot;  Hello, world!  &quot;-&gt;trim();
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="UNIVERSAL_METHODS_FOR_AUTOBOXED_TYPES"><a class="permalink" href="#UNIVERSAL_METHODS_FOR_AUTOBOXED_TYPES">UNIVERSAL
  METHODS FOR AUTOBOXED TYPES</a></h1>
<section class="Ss">
<h2 class="Ss" id="autobox_class"><a class="permalink" href="#autobox_class">autobox_class</a></h2>
<span class="Li">&quot;autobox&quot;</span> adds a single method to all
  autoboxed types: <span class="Li">&quot;autobox_class&quot;</span>. This can
  be used to call <span class="Li">&quot;can&quot;</span>,
  <span class="Li">&quot;isa&quot;</span>,
  <span class="Li">&quot;VERSION&quot;</span>,
  <span class="Li">&quot;import&quot;</span> and
  <span class="Li">&quot;unimport&quot;</span>. e.g.
<p class="Pp"><span class="Li"></span></p>
<pre>
    if (sub { ... }-&gt;autobox_class-&gt;can('curry')) ...
    if (42-&gt;autobox_class-&gt;isa('SCALAR')) ...
</pre>
<p class="Pp">Note: <span class="Li">&quot;autobox_class&quot;</span> should
    <b>always</b> be used when calling these methods. The behaviour when these
    methods are called directly on the native type e.g.:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    42-&gt;can('foo')
    42-&gt;isa('Bar')
    42-&gt;VERSION
</pre>
<p class="Pp">- is undefined.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="EXPORTS"><a class="permalink" href="#EXPORTS">EXPORTS</a></h1>
<section class="Ss">
<h2 class="Ss" id="type"><a class="permalink" href="#type">type</a></h2>
<span class="Li">&quot;autobox&quot;</span> includes an additional module,
  <span class="Li">&quot;autobox::universal&quot;</span>, which exports a single
  subroutine, <span class="Li">&quot;type&quot;</span>.
<p class="Pp">This sub returns the type of its argument within
    <span class="Li">&quot;autobox&quot;</span> (which is essentially longhand
    for the type names used within perl). This value is used by
    <span class="Li">&quot;autobox&quot;</span> to associate a method invocant
    with its designated classes. e.g.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    use autobox::universal qw(type);

    type(&quot;42&quot;)  # STRING
    type(42)    # INTEGER
    type(42.0)  # FLOAT
    type(undef) # UNDEF
</pre>
<p class="Pp"><span class="Li">&quot;autobox::universal&quot;</span> is loaded
    automatically by <span class="Li">&quot;autobox&quot;</span>, and, as its
    name suggests, can be used to install a universal
    <span class="Li">&quot;type&quot;</span> method for autoboxed values
  e.g.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    use autobox UNIVERSAL =&gt; 'autobox::universal';

    42-&gt;type        # INTEGER
    3.1415927-&gt;type # FLOAT
    %ENV-&gt;type      # HASH
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="CAVEATS"><a class="permalink" href="#CAVEATS">CAVEATS</a></h1>
<section class="Ss">
<h2 class="Ss" id="Performance"><a class="permalink" href="#Performance">Performance</a></h2>
Calling
<p class="Pp"><span class="Li"></span></p>
<pre>
    &quot;Hello, world!&quot;-&gt;length()
</pre>
<p class="Pp">is slightly slower than the equivalent method call on a
    string-like object, and significantly slower than</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    length(&quot;Hello, world!&quot;)
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Gotchas"><a class="permalink" href="#Gotchas">Gotchas</a></h2>
<i>Precedence</i>
<p class="Pp">Due to Perl's precedence rules, some autoboxed literals may need
    to be parenthesized:</p>
<p class="Pp">For instance, while this works:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    my $curried = sub { ... }-&gt;curry();
</pre>
<p class="Pp">this doesn't:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    my $curried = \&amp;foo-&gt;curry();
</pre>
<p class="Pp">The solution is to wrap the reference in parentheses:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    my $curried = (\&amp;foo)-&gt;curry();
</pre>
<p class="Pp">The same applies for signed integer and float literals:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    # this works
    my $range = 10-&gt;to(1);

    # this doesn't work
    my $range = -10-&gt;to(10);

    # this works
    my $range = (-10)-&gt;to(10);
</pre>
<p class="Pp"><i>print BLOCK</i></p>
<p class="Pp">Perl's special-casing for the <span class="Li">&quot;print BLOCK
    ...&quot;</span> syntax (see perlsub) means that
    <span class="Li">&quot;print { expression() } ...&quot;</span> (where the
    curly brackets denote an anonymous HASH ref) may require some further
    disambiguation:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    # this works
    print { foo =&gt; 'bar' }-&gt;foo();

    # and this
    print { 'foo', 'bar' }-&gt;foo();

    # and even this
    print { 'foo', 'bar', @_ }-&gt;foo();

    # but this doesn't
    print { @_ }-&gt;foo() ? 1 : 0
</pre>
<p class="Pp">In the latter case, the solution is to supply something other than
    a HASH ref literal as the first argument to
    <span class="Li">&quot;print()&quot;</span>:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    # e.g.
    print STDOUT { @_ }-&gt;foo() ? 1 : 0;

    # or
    my $hashref = { @_ };
    print $hashref-&gt;foo() ? 1 : 0;

    # or
    print '', { @_ }-&gt;foo() ? 1 : 0;

    # or
    print '' . { @_ }-&gt;foo() ? 1 : 0;

    # or even
    { @_ }-&gt;print_if_foo(1, 0);
</pre>
<p class="Pp"><i>eval EXPR</i></p>
<p class="Pp">Like most pragmas, <span class="Li">&quot;autobox&quot;</span>
    performs operations at compile time, and, as a result, runtime string
    <span class="Li">&quot;eval&quot;</span>s are not executed within its scope
    i.e. this doesn't work:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    use autobox;

    eval &quot;42-&gt;foo&quot;;
</pre>
<p class="Pp">The workaround is to use
    <span class="Li">&quot;autobox&quot;</span> within the
    <span class="Li">&quot;eval&quot;</span> e.g.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    eval &lt;&lt;'EOS';
        use autobox;
        42-&gt;foo();
    EOS
</pre>
<p class="Pp">Note that the <span class="Li">&quot;eval BLOCK&quot;</span> form
    works as expected:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    use autobox;

    eval { 42-&gt;foo() }; # OK
</pre>
<p class="Pp"><i>Operator Overloading</i></p>
<p class="Pp">Operator overloading via the overload pragma doesn't
    (automatically) work. <span class="Li">&quot;autobox&quot;</span> works by
    lexically overriding the arrow operator. It doesn't bless native types into
    objects, so overloading - or any other kind of &quot;magic&quot; which
    depends on values being blessed - doesn't apply.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="VERSION"><a class="permalink" href="#VERSION">VERSION</a></h1>
2.86
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<ul class="Bl-bullet">
  <li>autobox::Core</li>
  <li>Moose::Autobox</li>
  <li>perl5i</li>
  <li>Scalar::Properties</li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
chocolateboy &lt;chocolate@cpan.org&gt;
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT_AND_LICENSE"><a class="permalink" href="#COPYRIGHT_AND_LICENSE">COPYRIGHT
  AND LICENSE</a></h1>
Copyright (c) 2003-2018 by chocolateboy.
<p class="Pp">This library is free software; you can redistribute it and/or
    modify it under the terms of the Artistic License 2.0
    &lt;http://www.opensource.org/licenses/artistic-license-2.0.php&gt;.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2018-04-20</td>
    <td class="foot-os">perl v5.18.4</td>
  </tr>
</table>
</body>
</html>
