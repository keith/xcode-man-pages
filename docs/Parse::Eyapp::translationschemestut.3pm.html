<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    .Nd, .Bf, .Op { display: inline; }
    .Pa, .Ad { font-style: italic; }
    .Ms { font-weight: bold; }
    .Bl-diag > dt { font-weight: bold; }
    code.Nm, .Fl, .Cm, .Ic, code.In, .Fd, .Fn, .Cd { font-weight: bold;
      font-family: inherit; }
  </style>
  <title>Parse::Eyapp::translationschemestut(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Parse::Eyapp::translationschemestut(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Parse::Eyapp::translationschemestut(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Parse::Eyapp::translationschemestut - Introduction to Translation
    Schemes in Eyapp</p>
</section>
<section class="Sh">
<h1 class="Sh" id="INTRODUCTION"><a class="permalink" href="#INTRODUCTION">INTRODUCTION</a></h1>
<p class="Pp">A <i>translation scheme</i> scheme is a context free grammar where
    the right hand sides of the productions have been augmented with semantic
    actions (i.e. with chunks of Perl code):</p>
<p class="Pp"></p>
<pre>                                A -&gt; alpha { action(@_) } beta
</pre>
<p class="Pp">The analyzer generated by
    <span class="Li">&quot;Parse::Eyapp&quot;</span> executes
    <span class="Li">&quot;action()&quot;</span> after all the semantic actions
    associated with <span class="Li">&quot;alpha&quot;</span> have been executed
    and before the execution of any of the semantic actions associated with
    <span class="Li">&quot;beta&quot;</span>.</p>
<p class="Pp">In a translation scheme the embedded actions modify the attributes
    associated with the symbols of the grammar.</p>
<p class="Pp"></p>
<pre>                                A -&gt; alpha { action(@_) } beta
</pre>
<p class="Pp"><i>each symbol on the right hand side</i> <i>of a production rule
    has an associated scalar attribute</i>. In ordinary
    <span class="Li">&quot;eyapp&quot;</span> programs the attributes of the
    symbol to the left of <span class="Li">&quot;action&quot;</span> are passed
    as arguments to <span class="Li">&quot;action&quot;</span> (in the example,
    those of <span class="Li">&quot;alpha&quot;</span>). These arguments are
    preceded by a reference to the syntax analyzer object. There is no way
    inside an ordinary <span class="Li">&quot;eyapp&quot;</span> program for an
    intermediate <span class="Li">&quot;action&quot;</span> to access the
    attributes of the symbols on its right, i.e. those associated with the
    symbols of <span class="Li">&quot;beta&quot;</span>. This restriction is
    lifted if you use the <span class="Li">%metatree</span> directive.</p>
<p class="Pp">Eyapp allows through the <span class="Li">%metatree</span>
    directive the creation of <i>Translation Schemes</i> where the actions have
    access to almost any node of the syntax tree.</p>
<p class="Pp">When using the <span class="Li">%metatree</span> directive
    semantic actions aren't immediately executed. Instead they are inserted as
    nodes of the syntax tree. The main difference with ordinary nodes being that
    the attribute of such a <span class="Li">&quot;CODE&quot;</span> node is a
    reference to the anonymous subroutine representing the semantic action. The
    tree is later traversed in depth-first order using the
    <span class="Li">&quot;$t-&gt;translation_scheme&quot;</span> method: each
    time a <span class="Li">&quot;CODE&quot;</span> node is visited the action
    is executed.</p>
<p class="Pp">The following example parses a tiny subset of a typical <i>typed
    language</i> and decorates the syntax tree with a new attribute
    <span class="Li">&quot;t&quot;</span> holding the type of each declared
    variable:</p>
<p class="Pp"></p>
<pre> use strict; # File examples/trans_scheme_simple_decls4.pl
 use Data::Dumper;
 use Parse::Eyapp;
 our %s; # symbol table
 my $ts = q{ 
   %token FLOAT INTEGER NAME
   %{
   our %s;
   %}
   %metatree
   %%
   Dl:  D &lt;* ';'&gt;
   ;
   D : $T { $L-&gt;{t} = $T-&gt;{t} } $L
   ;
   T : FLOAT    { $lhs-&gt;{t} = &quot;FLOAT&quot; }
     | INTEGER  { $lhs-&gt;{t} = &quot;INTEGER&quot; }
   ;
   L : $NAME
         { $NAME-&gt;{t} = $lhs-&gt;{t}; $s{$NAME-&gt;{attr}} = $NAME }
     | $NAME { $NAME-&gt;{t} = $lhs-&gt;{t}; $L-&gt;{t} = $lhs-&gt;{t} } ',' $L
         { $s{$NAME-&gt;{attr}} = $NAME }
   ;
   %%
 }; # end $ts
 sub Error { die &quot;Error sintactico\n&quot;; }
 { # Closure of $input, %reserved_words and $validchars
   my $input = &quot;&quot;;
   my %reserved_words = ();
   my $validchars = &quot;&quot;;
   sub parametrize__scanner {
     $input = shift;
     %reserved_words = %{shift()};
     $validchars = shift;
   }
   sub scanner {
     $input =~ m{\G\s+}gc;                     # skip whites
     if ($input =~ m{\G([a-z_A_Z]\w*)\b}gc) {
       my $w = uc($1);                 # upper case the word
       return ($w, $w) if exists $reserved_words{$w};
       return ('NAME', $1);            # not a reserved word
     }
     return ($1, $1) if ($input =~ m/\G([$validchars])/gc);
     die &quot;Not valid token: $1\n&quot; if ($input =~ m/\G(\S)/gc);
     return ('', undef); # end of file
   }
 } # end closure
 Parse::Eyapp-&gt;new_grammar(input=&gt;$ts,classname=&gt;'main',outputfile=&gt;'Types.pm');
 my $parser = main-&gt;new(yylex =&gt; \&amp;scanner, yyerror =&gt; \&amp;Error); 
 parametrize__scanner(
   &quot;float x,y;\ninteger a,b\n&quot;,
   { INTEGER =&gt; 'INTEGER', FLOAT =&gt; 'FLOAT'},
   &quot;,;&quot;
 );
 my $t = $parser-&gt;YYParse() or die &quot;Syntax Error analyzing input&quot;;
 $t-&gt;translation_scheme;
 $Data::Dumper::Indent = 1;
 $Data::Dumper::Terse = 1;
 $Data::Dumper::Deepcopy  = 1;
 $Data::Dumper::Deparse = 1;
 print Dumper($t);
 print Dumper(\%s);
</pre>
<p class="Pp">Inside a Translation Scheme the lexical variable
    <span class="Li">$lhs</span> refers to the attribute of the father.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="EXECUTION_STAGES_OF_A_TRANSLATION_SCHEME"><a class="permalink" href="#EXECUTION_STAGES_OF_A_TRANSLATION_SCHEME">EXECUTION
  STAGES OF A TRANSLATION SCHEME</a></h1>
<p class="Pp">The execution of a Translation Scheme can be divided in the
    following stages:</p>
<dl class="Bl-tag">
  <dt>1. During the first stage the grammar is analyzed and the parser is
    built:</dt>
  <dd>
    <pre> Parse::Eyapp-&gt;new_grammar(input=&gt;$ts,classname=&gt;'main',outputfile=&gt;'Types.pm');
    </pre>
    <p class="Pp">This stage is called <i>Class Construction Time</i></p>
  </dd>
  <dt>2. A parser conforming to the generated grammar is built</dt>
  <dd>
    <pre>  my $parser = main-&gt;new(yylex =&gt; \&amp;scanner, yyerror =&gt; \&amp;Error);
    </pre>
    <p class="Pp">This stage is called <i>Parser Construction Time</i></p>
  </dd>
  <dt>3. The next phase is <i>Tree construction time</i>. The input is set and
    the tree is built:</dt>
  <dd>
    <pre> parametrize__scanner(
    &quot;float x,y;\ninteger a,b\n&quot;,
    { INTEGER =&gt; 'INTEGER', FLOAT =&gt; 'FLOAT'},
    &quot;,;&quot;
  );
  my $t = $parser-&gt;YYParse() or die &quot;Syntax Error analyzing input&quot;;
    </pre>
  </dd>
  <dt>4. The last stage is <i>Execution Time</i>. The tree is traversed in depth
    first order and the &quot;CODE&quot; nodes are executed.</dt>
  <dd>
    <pre>                           $t-&gt;translation_scheme;
    </pre>
  </dd>
</dl>
<p class="Pp">This combination of bottom-up parsing with depth first traversing
    leads to a semantic behavior similar to recursive top-down parsers but with
    two advantages:</p>
<ul class="Bl-bullet">
  <li>The grammar can be left-recursive</li>
  <li>At the time of executing the action the syntax tree is already built,
      therefore we can refer to nodes on the right side of the action like in:
    <p class="Pp"></p>
    <pre>                      D : $T { $L-&gt;{t} = $T-&gt;{t} } $L
    </pre>
  </li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="THE__begin_DIRECTIVE"><a class="permalink" href="#THE__begin_DIRECTIVE">THE
  %begin DIRECTIVE</a></h1>
<p class="Pp">The <span class="Li">&quot;%begin { code }&quot;</span> directive
    can be used when building a translation scheme, i.e. when under the control
    of the <span class="Li">%metatree</span> directive. It indicates that such
    <span class="Li">&quot;{ code }&quot;</span> will be executed at <i>tree</i>
    <i>construction time</i>. Therefore the code receives as arguments the
    references to the nodes of the branch than is being built. Usually <i>begin
    code</i> assist in the construction of the tree. Line 39 of the following
    code shows an example. The action <span class="Li">&quot;{ $exp
    }&quot;</span> simplifies the syntax tree bypassing the parenthesis node.
    The example also illustrates the combined use of default actions and
    translation schemes.</p>
<p class="Pp"></p>
<pre>  pl@nereida:~/LEyapp/examples$ cat -n trans_scheme_default_action.pl
     1  #!/usr/bin/perl -w
     2  use strict;
     3  use Data::Dumper;
     4  use Parse::Eyapp;
     5  use IO::Interactive qw(is_interactive);
     6
     7  my $translationscheme = q{
     8  %{
     9  # head code is available at tree construction time
    10  use Data::Dumper;
    11  our %sym; # symbol table
    12  %}
    13
    14  %defaultaction {
    15     $lhs-&gt;{n} = eval &quot; $left-&gt;{n} $_[2]-&gt;{attr} $right-&gt;{n} &quot;
    16  }
    17
    18  %metatree
    19
    20  %right   '='
    21  %left   '-' '+'
    22  %left   '*' '/'
    23
    24  %%
    25  line:       %name EXP
    26                exp &lt;+ ';'&gt; /* Expressions separated by semicolons */
    27                  { $lhs-&gt;{n} = $_[1]-&gt;Last_child-&gt;{n} }
    28  ;
    29
    30  exp:
    31              %name PLUS
    32                exp.left '+' exp.right
    33          |   %name MINUS
    34                exp.left '-' exp.right
    35          |   %name TIMES
    36                exp.left '*' exp.right
    37          |   %name DIV
    38                exp.left '/' exp.right
    39          |   %name NUM
    40                $NUM
    41                  { $lhs-&gt;{n} = $NUM-&gt;{attr} }
    42          |   '(' $exp ')'  %begin { $exp }
    43          |   %name VAR
    44                $VAR
    45                  { $lhs-&gt;{n} = $sym{$VAR-&gt;{attr}}-&gt;{n} }
    46          |   %name ASSIGN
    47                $VAR '=' $exp
    48                  { $lhs-&gt;{n} = $sym{$VAR-&gt;{attr}}-&gt;{n} = $exp-&gt;{n} }
    49
    50  ;
    51
    52  %%
    53  # tail code is available at tree construction time
    54  sub _Error {
    55    die &quot;Syntax error.\n&quot;;
    56  }
    57
    58  sub _Lexer {
    59      my($parser)=shift;
    60
    61      for ($parser-&gt;YYData-&gt;{INPUT}) {
    62          s/^\s+//;
    63          $_ or  return('',undef);
    64          s/^([0-9]+(?:\.[0-9]+)?)// and return('NUM',$1);
    65          s/^([A-Za-z][A-Za-z0-9_]*)// and return('VAR',$1);
    66          s/^(.)// and return($1,$1);
    67      }
    68      return('',undef);
    69  }
    70
    71  sub Run {
    72      my($self)=shift;
    73      return $self-&gt;YYParse( yylex =&gt; \&amp;_Lexer, yyerror =&gt; \&amp;_Error );
    74  }
    75  }; # end translation scheme
    76
    77  sub TERMINAL::info { $_[0]-&gt;attr }
    78
    79  my $p = Parse::Eyapp-&gt;new_grammar(
    80    input=&gt;$translationscheme,
    81    classname=&gt;'main',
    82    firstline =&gt; 6,
    83    outputfile =&gt; 'main.pm');
    84  die $p-&gt;qtables() if $p-&gt;Warnings;
    85  my $parser = main-&gt;new();
    86  print &quot;Write a sequence of arithmetic expressions: &quot; if is_interactive();
    87  $parser-&gt;YYData-&gt;{INPUT} = &lt;&gt;;
    88  my $t = $parser-&gt;Run() or die &quot;Syntax Error analyzing input&quot;;
    89  $t-&gt;translation_scheme;
    90
    91  $Parse::Eyapp::Node::INDENT = 2;
    92  my $treestring = $t-&gt;str;
    93
    94  $Data::Dumper::Indent = 1;
    95  $Data::Dumper::Terse = 1;
    96  $Data::Dumper::Deepcopy  = 1;
    97  our %sym;
    98  my $symboltable = Dumper(\%sym);
    99
   100  print &lt;&lt;&quot;EOR&quot;;
   101  ***********Tree*************
   102  $treestring
   103  ******Symbol table**********
   104  $symboltable
   105  ************Result**********
   106  $t-&gt;{n}
   107
   108  EOR
</pre>
<p class="Pp">When executed with input
    <span class="Li">&quot;a=2*3;b=a*a&quot;</span> the program produces an
    output similar to this:</p>
<p class="Pp"></p>
<pre>  pl@nereida:~/LEyapp/examples$ trans_scheme_default_action.pl
  Write a sequence of arithmetic expressions: a=2*3;b=a*a
  ***********Tree*************
  EXP(
    _PLUS_LIST(
      ASSIGN(
        TERMINAL[a],
        TERMINAL[=],
        TIMES(
          NUM(TERMINAL[2], CODE),
          TERMINAL[*],
          NUM(TERMINAL[3], CODE),
          CODE
        ) # TIMES,
        CODE
      ) # ASSIGN,
      ASSIGN(
        TERMINAL[b],
        TERMINAL[=],
        TIMES(
          VAR(TERMINAL[a], CODE),
          TERMINAL[*],
          VAR(TERMINAL[a], CODE),
          CODE
        ) # TIMES,
        CODE
      ) # ASSIGN
    ) # _PLUS_LIST,
    CODE
  ) # EXP
  ******Symbol table**********
  {
    'a' =&gt; {
      'n' =&gt; 6
    },
    'b' =&gt; {
      'n' =&gt; 36
    }
  }
  ************Result**********
  36
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<ul class="Bl-bullet">
  <li>The project home is at &lt;http://code.google.com/p/parse-eyapp/&gt;. Use
      a subversion client to anonymously check out the latest project source
      code:
    <p class="Pp"></p>
    <pre>   svn checkout http://parse-eyapp.googlecode.com/svn/trunk/ parse-eyapp-read-only
    </pre>
  </li>
  <li>The tutorial <i>Parsing Strings and Trees with</i>
      <span class="Li">&quot;Parse::Eyapp&quot;</span> (An Introduction to
      Compiler Construction in seven pages) in
      &lt;http://nereida.deioc.ull.es/~pl/eyapsimple/&gt;</li>
  <li>Parse::Eyapp, Parse::Eyapp::eyapplanguageref, Parse::Eyapp::debuggingtut,
      Parse::Eyapp::defaultactionsintro, Parse::Eyapp::translationschemestut,
      Parse::Eyapp::Driver, Parse::Eyapp::Node, Parse::Eyapp::YATW,
      Parse::Eyapp::Treeregexp, Parse::Eyapp::Scope, Parse::Eyapp::Base,
      Parse::Eyapp::datagenerationtut</li>
  <li>The pdf file in
      &lt;http://nereida.deioc.ull.es/~pl/perlexamples/languageintro.pdf&gt;</li>
  <li>The pdf file in
      &lt;http://nereida.deioc.ull.es/~pl/perlexamples/debuggingtut.pdf&gt;</li>
  <li>The pdf file in
      &lt;http://nereida.deioc.ull.es/~pl/perlexamples/eyapplanguageref.pdf&gt;</li>
  <li>The pdf file in
      &lt;http://nereida.deioc.ull.es/~pl/perlexamples/Treeregexp.pdf&gt;</li>
  <li>The pdf file in
      &lt;http://nereida.deioc.ull.es/~pl/perlexamples/Node.pdf&gt;</li>
  <li>The pdf file in
      &lt;http://nereida.deioc.ull.es/~pl/perlexamples/YATW.pdf&gt;</li>
  <li>The pdf file in
      &lt;http://nereida.deioc.ull.es/~pl/perlexamples/Eyapp.pdf&gt;</li>
  <li>The pdf file in
      &lt;http://nereida.deioc.ull.es/~pl/perlexamples/Base.pdf&gt;</li>
  <li>The pdf file in
      &lt;http://nereida.deioc.ull.es/~pl/perlexamples/translationschemestut.pdf&gt;</li>
  <li>The pdf file in
      &lt;http://nereida.deioc.ull.es/~pl/perlexamples/treematchingtut.pdf&gt;</li>
  <li>perldoc eyapp,</li>
  <li>perldoc treereg,</li>
  <li>perldoc vgg,</li>
  <li>The Syntax Highlight file for vim at
      &lt;http://www.vim.org/scripts/script.php?script_id=2453&gt; and
      &lt;http://nereida.deioc.ull.es/~vim/&gt;</li>
  <li><i>Analisis Lexico y Sintactico</i>, (Notes for a course in compiler
      construction) by Casiano Rodriguez-Leon. Available at
      &lt;http://nereida.deioc.ull.es/~pl/perlexamples/&gt; Is the more complete
      and reliable source for Parse::Eyapp. However is in Spanish.</li>
  <li>Parse::Yapp,</li>
  <li>Man pages of <i>yacc</i>(1) and <i>bison</i>(1),
      &lt;http://www.delorie.com/gnu/docs/bison/bison.html&gt;</li>
  <li>Language::AttributeGrammar</li>
  <li>Parse::RecDescent.</li>
  <li>HOP::Parser</li>
  <li>HOP::Lexer</li>
  <li>ocamlyacc tutorial at
      &lt;http://plus.kaist.ac.kr/~shoh/ocaml/ocamllex-ocamlyacc/ocamlyacc-tutorial/ocamlyacc-tutorial.html&gt;</li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="REFERENCES"><a class="permalink" href="#REFERENCES">REFERENCES</a></h1>
<ul class="Bl-bullet">
  <li>The classic Dragon's book <i>Compilers: Principles, Techniques, and
      Tools</i> by Alfred V. Aho, Ravi Sethi and Jeffrey D. Ullman
      (Addison-Wesley 1986)</li>
  <li><i>CS2121: The Implementation and Power of Programming Languages</i> (See
      &lt;http://www.cs.man.ac.uk/~pjj&gt;,
      &lt;http://www.cs.man.ac.uk/~pjj/complang/g2lr.html&gt; and
      &lt;http://www.cs.man.ac.uk/~pjj/cs2121/ho/ho.html&gt;) by Pete Jinks</li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="CONTRIBUTORS"><a class="permalink" href="#CONTRIBUTORS">CONTRIBUTORS</a></h1>
<ul class="Bl-bullet">
  <li>Hal Finkel &lt;http://www.halssoftware.com/&gt;</li>
  <li>G. Williams &lt;http://kasei.us/&gt;</li>
  <li>Thomas L. Shinnick &lt;http://search.cpan.org/~tshinnic/&gt;</li>
  <li>Frank Leray</li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">Casiano Rodriguez-Leon (casiano@ull.es)</p>
</section>
<section class="Sh">
<h1 class="Sh" id="ACKNOWLEDGMENTS"><a class="permalink" href="#ACKNOWLEDGMENTS">ACKNOWLEDGMENTS</a></h1>
<p class="Pp">This work has been supported by CEE (FEDER) and the Spanish
    Ministry of <i>Educacion y Ciencia</i> through <i>Plan Nacional I+D+I</i>
    number TIN2005-08818-C04-04 (ULL::OPLINK project
    &lt;http://www.oplink.ull.es/&gt;). Support from Gobierno de Canarias was
    through GC02210601 (<i>Grupos Consolidados</i>). The University of La Laguna
    has also supported my work in many ways and for many years.</p>
<p class="Pp">A large percentage of code is verbatim taken from Parse::Yapp
    1.05. The author of Parse::Yapp is Francois Desarmenien.</p>
<p class="Pp">I wish to thank Francois Desarmenien for his Parse::Yapp module,
    to my students at La Laguna and to the Perl Community. Thanks to the people
    who have contributed to improve the module (see &quot;CONTRIBUTORS&quot; in
    Parse::Eyapp). Thanks to Larry Wall for giving us Perl. Special thanks to
    Juana.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="LICENCE_AND_COPYRIGHT"><a class="permalink" href="#LICENCE_AND_COPYRIGHT">LICENCE
  AND COPYRIGHT</a></h1>
<p class="Pp">Copyright (c) 2006-2008 Casiano Rodriguez-Leon (casiano@ull.es).
    All rights reserved.</p>
<p class="Pp">Parse::Yapp copyright is of Francois Desarmenien, all rights
    reserved. 1998-2001</p>
<p class="Pp">These modules are free software; you can redistribute it and/or
    modify it under the same terms as Perl itself. See perlartistic.</p>
<p class="Pp">This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. </p>
</section>
<section class="Sh">
<h1 class="Sh" id="POD_ERRORS"><a class="permalink" href="#POD_ERRORS">POD
  ERRORS</a></h1>
<p class="Pp">Hey! <b>The above document had some coding errors, which are
    explained below:</b></p>
<dl class="Bl-tag">
  <dt id="Around"><a class="permalink" href="#Around">Around line 81:</a></dt>
  <dd>Non-ASCII character seen before =encoding in 'sintactico\n&quot;;'.
      Assuming UTF-8</dd>
</dl>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2012-03-23</td>
    <td class="foot-os">perl v5.18.4</td>
  </tr>
</table>
</body>
</html>
