<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>Parse::Eyapp::Parse(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Parse::Eyapp::Parse(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Parse::Eyapp::Parse(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
Parse::Eyapp::Parse - The parser of Eyapp grammars
</section>
<section class="Sh">
<h1 class="Sh" id="THE_EYAPP_LANGUAGE"><a class="permalink" href="#THE_EYAPP_LANGUAGE">THE
  EYAPP LANGUAGE</a></h1>
The parser for the <span class="Li">&quot;Eyapp&quot;</span> language was
  written and generated using <span class="Li">&quot;Parse::Eyapp&quot;</span>
  and the <span class="Li">&quot;eyapp&quot;</span> compiler (actually the first
  version was bootstrapped using the yapp compiler). The Eyapp program parsing
  the <span class="Li">&quot;Eyapp&quot;</span> language is in the file
  <span class="Li">&quot;Parse/Eyapp/Parse.yp&quot;</span> in the
  <span class="Li">&quot;Parse::Eyapp&quot;</span> distribution. Therefore
  <span class="Li">&quot;Parse::Eyapp::Parse&quot;</span> objects have all the
  methods in <span class="Li">&quot;Parse::Eyapp::Driver&quot;</span>.
<p class="Pp">A <span class="Li">&quot;Parse::Eyapp::Parse&quot;</span> is
    nothing but a particular kind of
    <span class="Li">&quot;Parse::Eyapp&quot;</span> parser: <i>the one that
    parses</i> <span class="Li">&quot;Eyapp&quot;</span> <i>grammars</i>.</p>
<section class="Ss">
<h2 class="Ss" id="Eyapp_Grammar"><a class="permalink" href="#Eyapp_Grammar">Eyapp
  Grammar</a></h2>
This section describes the syntax of the Eyapp language using its own notation.
  The grammar extends yacc and yapp grammars. Semicolons have been omitted to
  save space. Between C-like comments you can find an (informal) explanation of
  the language associated with each token.
<p class="Pp"><span class="Li"></span></p>
<pre>
  %token ASSOC /* is %(left|right|nonassoc) */                                                                                                          
  %token BEGINCODE /* is %begin { Perl code ... } */                                                                                                    
  %token CODE /* is { Perl code ... } */                                                                                                                
  %token CONFLICT /* is %conflict */                                                                                                                    
  %token DEFAULTACTION /* is %defaultaction */                                                                                                          
  %token EXPECT /* is %expect */                                                                                                                        
  %token HEADCODE /* is %{ Perl code ... %} */                                                                                                          
  %token IDENT /* is [A-Za-z_][A-Za-z0-9_]* */                                                                                                          
  %token LABEL /* is :[A-Za-z0-9_]+ */                                                                                                                  
  %token LITERAL /* is a string literal like 'hello' */                                                                                                 
  %token METATREE /* is %metatree */                                                                                                                    
  %token NAME /* is %name */                                                                                                                            
  %token NAMINGSCHEME /* is %namingscheme */                                                                                                            
  %token NOCOMPACT /* is %nocompact */                                                                                                                  
  %token NUMBER /* is \d+ */                                                                                                                            
  %token OPTION /* is (%name\s*([A-Za-z_]\w*)\s*)?\? */                                                                                                 
  %token PLUS /* is (%name\s*([A-Za-z_]\w*)\s*)?\+ */                                                                                                   
  %token PREC /* is %prec */                                                                                                                            
  %token PREFIX /* is %prefix\s+([A-Za-z_][A-Za-z0-9_:]*::) */                                                                                          
  %token SEMANTIC /* is %semantic\s+token */                                                                                                            
  %token STAR /* is (%name\s*([A-Za-z_]\w*)\s*)?\* */                                                                                                   
  %token START /* is %start */                                                                                                                          
  %token STRICT /* is %strict */                                                                                                                        
  %token SYNTACTIC /* is %syntactic\s+token */                                                                                                          
  %token TAILCODE /* is { Perl code ... } */                                                                                                            
  %token TOKEN /* is %token */                                                                                                                          
  %token TREE /* is %tree */                                                                                                                            
  %token TYPE /* is %type */                                                                                                                            
  %token UNION /* is %union */                                                                                                                          
  %start eyapp                                                                                                                                          

  %%

  # Main rule
  eyapp:     
        head body tail 
  ;                    
  #Common rules:       
  symbol:              
        LITERAL        
      | ident #default action
  ;                          
  ident:                     
        IDENT                
  ;                          
  # Head section:            
  head:                      
        headsec '%%'         
  ;                          
  headsec:                   
        #empty  #default action
      | decls #default action  
  ;                            
  decls:                       
        decls decl #default action
      | decl #default action      
  ;                               
  decl:                           
        '\n' #default action      
      | SEMANTIC typedecl symlist '\n'
      | SYNTACTIC typedecl symlist '\n'
      | TOKEN typedecl toklist '\n'    
      | ASSOC typedecl symlist '\n'    
      | START ident '\n'               
      | PREFIX '\n'                    
      | WHITES CODE '\n'               
      | WHITES REGEXP '\n'             
      | WHITES '=' CODE '\n'           
      | WHITES '=' REGEXP '\n'         
      | NAMINGSCHEME CODE '\n'         
      | HEADCODE '\n'                  
      | UNION CODE '\n'  #ignore       
      | DEFAULTACTION CODE '\n'        
      | LEXER CODE '\n'                
      | TREE '\n'                      
      | METATREE '\n'                  
      | STRICT '\n'                    
      | NOCOMPACT '\n'                 
      | TYPE typedecl identlist '\n'   
      | CONFLICT ident CODE '\n'       
      | EXPECT NUMBER '\n'             
      | EXPECT NUMBER NUMBER '\n'      
      | EXPECTRR NUMBER '\n'           
      | error '\n'                     
  ;                                    
  typedecl:                            
        #empty                         
      | '&lt;' IDENT '&gt;'                  
  ;                                    
  symlist:                             
        symlist symbol                 
      | symbol                         
  ;                                    
  toklist:                             
        toklist tokendef               
      | tokendef                       
  ;                                    
  tokendef:                            
        symbol '=' REGEXP              
      | symbol '=' CODE                
      | symbol                         
  ;                                    
  identlist:                           
        identlist ident                
      | ident                          
  ;                                    
  # Rule section                       
  body:                                
        rulesec '%%'                   
      | '%%'                           
  ;                                    
  rulesec:                             
        rulesec rules #default action  
      | startrules #default action     
  ;                                    
  startrules:                          
        IDENT ':'  rhss ';'            
      | error ';'                      
  ;                                    
  rules:                               
        IDENT ':' rhss ';'             
      | error ';'                      
  ;                                    
  rhss:                                
        rhss '|' rule                  
      | rule                           
  ;                                    
  rule:                                
        optname rhs prec epscode       
      | optname rhs                    
  ;                                    
  rhs:                                 
        #empty      #default action (will return undef)
      | rhselts #default action                        
  ;                                                    
  rhselts:                                             
        rhselts rhseltwithid                           
      | rhseltwithid                                   
  ;                                                    
  rhseltwithid:                                        
        rhselt '.' IDENT
      | '$' rhselt
      | '$' error
      | rhselt
  ;
  rhselt:
        symbol
      | code
      | DPREC ident
      | '(' optname rhs ')'
      | rhselt STAR
      | rhselt '&lt;' STAR symbol '&gt;'
      | rhselt OPTION
      | rhselt '&lt;' PLUS symbol '&gt;'
      | rhselt PLUS
  ;
  optname:
        /* empty */
      | NAME IDENT
      | NAME IDENT LABEL
      | NAME LABEL
  ;
  prec:
        PREC symbol
  ;
  epscode:
      | code
  ;
  code:
        CODE
      | BEGINCODE
  ;
  # Tail section:
  tail:
        /*empty*/
      | TAILCODE
  ;

  %%
</pre>
<p class="Pp">The semantic of <span class="Li">&quot;Eyapp&quot;</span> agrees
    with the semantic of <span class="Li">&quot;yacc&quot;</span> and
    <span class="Li">&quot;yapp&quot;</span> for all the common
  constructions.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Comments"><a class="permalink" href="#Comments">Comments</a></h2>
Comments are either Perl style, from <span class="Li">&quot;#&quot;</span> up to
  the end of line, or C style, enclosed between
  <span class="Li">&quot;/*&quot;</span> and
  <span class="Li">&quot;*/&quot;</span>.
</section>
<section class="Ss">
<h2 class="Ss" id="Syntactic_Variables,_Symbolic_Tokens_and_String_Literals"><a class="permalink" href="#Syntactic_Variables,_Symbolic_Tokens_and_String_Literals">Syntactic
  Variables, Symbolic Tokens and String Literals</a></h2>
Two kind of symbols may appear inside a Parse::Eyapp program:
  <i>Non-terminal</i> symbols or <i>syntactic variables</i>, called also
  <i>left-hand-side</i> symbols and <i>Terminal</i> symbols, called also
  <i>Tokens</i>.
<p class="Pp">Tokens are the symbols the lexical analyzer function returns to
    the parser. There are two kinds of tokens: <i>symbolic tokens</i> and
    <i>string</i> <i>literals</i>.</p>
<p class="Pp"><i>Syntactic variables</i> and <i>symbolic tokens</i> identifiers
    must conform to the regular expression
    <span class="Li">&quot;[A-Za-z][A-Za-z0-9_]*&quot;</span>.</p>
<p class="Pp">When building the syntax tree (i.e. when running under the
    <span class="Li">%tree</span> directive) <i>symbolic tokens</i> will be
    considered <i>semantic tokens</i> (see section &quot;Syntactic and Semantic
    tokens&quot;). <i>Symbolic tokens</i> yield nodes in the Abstract Syntax
    Tree.</p>
<p class="Pp">String literals are enclosed in single quotes and can contain
    almost anything. They will be received by the parser as double-quoted
    strings. Any special character as <span class="Li">'&quot;'</span>,
    <span class="Li">'$'</span> and <span class="Li">'@'</span> is escaped. To
    have a single quote inside a literal, escape it with '\'.</p>
<p class="Pp">When building the syntax tree (i.e. when running under the
    <span class="Li">%tree</span> directive) <i>string literals</i> will be
    considered <i>syntactic tokens</i> (see section &quot;Syntactic and Semantic
    tokens&quot;). <i>Syntactic tokens</i> do not produce nodes in the Abstract
    Syntax Tree.</p>
<p class="Pp">The examples used along this document can be found in the
    directory <span class="Li">&quot;examples/eyapplanguageref&quot;</span>
    accompanying this distribution.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Parts_of_an__eyapp__Program"><a class="permalink" href="#Parts_of_an__eyapp__Program">Parts
  of an &quot;eyapp&quot; Program</a></h2>
An Eyapp program has three parts called head, body and tail:
<p class="Pp"><span class="Li"></span></p>
<pre>
                                 eyapp: head body tail ;
</pre>
<p class="Pp">Each part is separated from the former by the symbol
    <span class="Li">&quot;%%&quot;</span>:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
                                 head: headsec '%%'
                                 body: rulesec '%%'
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="THE_HEAD_SECTION"><a class="permalink" href="#THE_HEAD_SECTION">THE
  HEAD SECTION</a></h1>
The head section contains a list of declarations
<p class="Pp"><span class="Li"></span></p>
<pre>
                                 headsec:  decl *
</pre>
<p class="Pp">There are different kinds of declarations.</p>
<p class="Pp">This reference does not fully describes all the declarations that
    are shared with <span class="Li">&quot;yacc&quot;</span> and yapp.</p>
<section class="Ss">
<h2 class="Ss" id="Example_of_Head_Section"><a class="permalink" href="#Example_of_Head_Section">Example
  of Head Section</a></h2>
In this and the next sections we will describe the basics of the Eyapp language
  using the file
  <span class="Li">&quot;examples/eyapplanguageref/Calc.eyp&quot;</span> that
  accompanies this distribution. This file implements a trivial calculator. Here
  is the header section:
<p class="Pp"><span class="Li"></span></p>
<pre>
  pl@nereida:~/src/perl/eyapp/examples/eyapplanguageref$ sed -ne '1,/%%/p' Calc.eyp | cat -n
     1  # examples/eyapplanguageref/Calc.eyp
     2  %whites    =  /([ \t]*(?:#.*)?)/
     3  %token NUM =  /([0-9]+(?:\.[0-9]+)?)/
     4  %token VAR =  /([A-Za-z][A-Za-z0-9_]*)/
     5
     6  %right  '='
     7  %left   '-' '+'
     8  %left   '*' '/'
     9  %left   NEG
    10  %right  '^'
    11
    12  %{
    13  my %s; # symbol table
    14  %}
    15
    16  %%
</pre>
<p class="Pp">Eyapp produces a lexical generator from the descriptions given by
    the <span class="Li">%token</span> and <span class="Li">%whites</span>
    directives plus the tokens used inside the body section.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
       %whites    =  /([ \t]*(?:#.*)?)/
       %token NUM =  /([0-9]+(?:\.[0-9]+)?)/
       %token VAR =  /([A-Za-z][A-Za-z0-9_]*)/
</pre>
<p class="Pp">See section &quot;Automatic Generation of Lexical Analyzers&quot;
    for more details.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Declarations_and_Precedence"><a class="permalink" href="#Declarations_and_Precedence">Declarations
  and Precedence</a></h2>
Lines 2-5 declare several tokens. The usual way to declare tokens is through the
  <span class="Li">%token</span> directive. The declarations
  <span class="Li">%nonassoc</span>, <span class="Li">%left</span> and
  <span class="Li">%right</span> not only declare the tokens but also associate
  a <i>priority</i> with them. Tokens declared in the same line have the same
  precedence. Tokens declared with these directives in lines below have more
  precedence than those declared above. Thus, in the example above we are saying
  that <span class="Li">&quot;+&quot;</span> and
  <span class="Li">&quot;-&quot;</span> have the same precedence but higher
  precedence than =. The final effect of <span class="Li">&quot;-&quot;</span>
  having greater precedence than = will be that an expression like:
<p class="Pp"><span class="Li"></span></p>
<pre>
                        a = 4 - 5
</pre>
<p class="Pp">will be interpreted as</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
                        a = (4 - 5)
</pre>
<p class="Pp">and not as</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
                        (a = 4) - 5
</pre>
<p class="Pp">The use of the <span class="Li">%left</span> indicates that - in
    case of ambiguity and a match between precedences - the parser must build
    the tree corresponding to a left parenthesizing. Thus, the expression</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
                         4 - 5 - 9
</pre>
<p class="Pp">will be interpreted as</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
                         (4 - 5) - 9
</pre>
<p class="Pp">You can refer to the token end-of-input in the header section
    using the string <span class="Li">''</span> (for example to give it some
    priority, see the example in
    <span class="Li">&quot;examples/debuggingtut/typicalrrwithprec.eyp&quot;</span>).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Header_Code"><a class="permalink" href="#Header_Code">Header
  Code</a></h2>
Perl code surrounded by <span class="Li">&quot;%{&quot;</span> and
  <span class="Li">&quot;%}&quot;</span> can be inserted in the head section.
  Such code will be inserted in the module generated by
  <span class="Li">&quot;eyapp&quot;</span> near the beginning. Therefore,
  declarations like the one of the calculator symbol table
  <span class="Li">%s</span>
<p class="Pp"><span class="Li"></span></p>
<pre>
  7  %{
  8  my %s; # symbol table
  9  %}
</pre>
<p class="Pp">will be visible from almost any point in the file.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="The_Start_Symbol_of_the_Grammar"><a class="permalink" href="#The_Start_Symbol_of_the_Grammar">The
  Start Symbol of the Grammar</a></h2>
<span class="Li">&quot;%start program&quot;</span> declares
  <span class="Li">&quot;program&quot;</span> as the start symbol of the
  grammar. When <span class="Li">%start</span> is not used, the first rule in
  the body section will be used.
</section>
<section class="Ss">
<h2 class="Ss" id="Expect"><a class="permalink" href="#Expect">Expect</a></h2>
The <span class="Li">&quot;%expect #NUMBER&quot;</span> directive works as in
  <span class="Li">&quot;bison&quot;</span> and suppress warnings when the
  number of Shift/Reduce conflicts is exactly
  <span class="Li">&quot;#NUMBER&quot;</span>.
<p class="Pp">The directive has been extended to be called with two numbers:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  %expect NUMSHIFTRED NUMREDRED
</pre>
<p class="Pp">no warnings will be emitted if the number of shift-reduce
    conflicts is exactly <span class="Li">&quot;NUMSHIFTRED&quot;</span> and the
    number of reduce-reduce conflicts is
    <span class="Li">&quot;NUMREDRED&quot;</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Type_and_Union"><a class="permalink" href="#Type_and_Union">Type
  and Union</a></h2>
C oriented declarations like <span class="Li">%type</span> and
  <span class="Li">%union</span> are parsed but ignored.
</section>
<section class="Ss">
<h2 class="Ss" id="The__strict_Directive"><a class="permalink" href="#The__strict_Directive">The
  %strict Directive</a></h2>
By default, identifiers appearing in the rule section will be classified as
  terminal if they don't appear in the left hand side of any production rules.
<p class="Pp">The directive <span class="Li">%strict</span> forces the
    declaration of all tokens. The following
    <span class="Li">&quot;eyapp&quot;</span> program issues a warning:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  pl@nereida:~/LEyapp/examples/eyapplanguageref$ cat -n bugyapp2.eyp
       1  %strict
       2  %%
       3  expr: NUM;
       4  %%
  pl@nereida:~/LEyapp/examples/eyapplanguageref$ eyapp bugyapp2.eyp
  Warning! Non declared token NUM at line 3 of bugyapp2.eyp
</pre>
<p class="Pp">To keep silent the compiler declare all tokens using one of the
    token declaration directives (<span class="Li">%token</span>,
    <span class="Li">%left</span>, etc.)</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  pl@nereida:~/LEyapp/examples/eyapplanguageref$ cat -n bugyapp3.eyp
       1  %strict
       2  %token NUM
       3  %%
       4  expr: NUM;
       5  %%
  pl@nereida:~/LEyapp/examples/eyapplanguageref$ eyapp bugyapp3.eyp
  pl@nereida:~/LEyapp/examples/eyapplanguageref$ ls -ltr | tail -1
  -rw-r--r-- 1 pl users 2395 2008-10-02 09:41 bugyapp3.pm
</pre>
<p class="Pp">It is a good practice to use <span class="Li">%strict</span> at
    the beginning of your grammar.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="The__prefix_Directive"><a class="permalink" href="#The__prefix_Directive">The
  %prefix Directive</a></h2>
The <span class="Li">%prefix</span> directive is equivalent to the use of the
  <span class="Li">&quot;yyprefix&quot;</span>. The node classes are prefixed
  with the specified prefix
<p class="Pp"><span class="Li"></span></p>
<pre>
  %prefix Some::Prefix::
</pre>
<p class="Pp">See the example in
    <span class="Li">&quot;examples/eyapplanguageref/alias_and_yyprefix.pl&quot;</span>.
    See also section &quot;Grammar Reuse&quot; in
    Parse::Eyapp::defaultactionsintro for an example that does not involve the
    <span class="Li">%tree</span> directive.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Default_Action_Directive"><a class="permalink" href="#Default_Action_Directive">Default
  Action Directive</a></h2>
In <span class="Li">&quot;Parse::Eyapp&quot;</span> you can modify the default
  action using the <span class="Li">&quot;%defaultaction { Perl code
  }&quot;</span> directive. See section &quot;DEFAULT ACTIONS&quot;. The
  examples
  <span class="Li">&quot;examples/eyapplanguageref/Postfix.eyp&quot;</span> and
  <span class="Li">&quot;examples/eyapplanguageref/Lhs.eyp&quot;</span>
  illustrate the use of the directive.
</section>
<section class="Ss">
<h2 class="Ss" id="Tree_Construction_Directives"><a class="permalink" href="#Tree_Construction_Directives">Tree
  Construction Directives</a></h2>
<span class="Li">&quot;Parse::Eyapp&quot;</span> facilitates the construction of
  concrete syntax trees and abstract syntax trees (abbreviated AST from now on)
  through the <span class="Li">%tree</span> and
  <span class="Li">%metatree</span> directives. See sections &quot;ABSTRACT
  SYNTAX TREES: <span class="Li">%tree</span> AND
  <span class="Li">%name</span>&quot; and Parse::Eyapp::translationschemestut.
</section>
<section class="Ss">
<h2 class="Ss" id="Tokens_and_the_Abstract_Syntax_Tree"><a class="permalink" href="#Tokens_and_the_Abstract_Syntax_Tree">Tokens
  and the Abstract Syntax Tree</a></h2>
The new token declaration directives <span class="Li">&quot;%syntactic
  token&quot;</span> and <span class="Li">&quot;%semantic token&quot;</span> can
  change the way <span class="Li">&quot;eyapp&quot;</span> builds the abstract
  syntax tree. See section &quot;Syntactic and Semantic tokens&quot;.
</section>
<section class="Ss">
<h2 class="Ss" id="The__nocompact_directive"><a class="permalink" href="#The__nocompact_directive">The
  %nocompact directive</a></h2>
This directive influences the generation of the LALR tables. They will not be
  compacted and the tokens for the <span class="Li">&quot;DEFAULT&quot;</span>
  reduction will be explicitly set. It can be used to produce an
  <span class="Li">&quot;.output&quot;</span> file (option
  <span class="Li">&quot;-v&quot;</span>) with more information.
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="THE_BODY"><a class="permalink" href="#THE_BODY">THE
  BODY</a></h1>
The body section contains the rules describing the grammar:
<p class="Pp"><span class="Li"></span></p>
<pre>
                       body:   rules * '%%'
                       rules:  IDENT ':' rhss ';'  
                       rhss:   (optname rhs (prec epscode)?) &lt;+ '|'&gt;
</pre>
<section class="Ss">
<h2 class="Ss" id="Rules"><a class="permalink" href="#Rules">Rules</a></h2>
A rule is made of a left-hand-side symbol (the <i>syntactic variable</i>),
  followed by a <span class="Li">':'</span> and one or more
  <i>right-hand-sides</i> (or <i>productions</i>)
 separated by <span class="Li">'|'</span> and terminated by a
  <span class="Li">';'</span> like in:
<p class="Pp"><span class="Li"></span></p>
<pre>
                          exp: 
                               exp '+' exp
                            |  exp '-' exp
                            |  NUM
                          ;
</pre>
<p class="Pp">A <i>production</i> (<i>right hand side</i>) may be empty:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
                          input:   
                               /* empty */
                            |  input line
                          ;
</pre>
<p class="Pp">The former two productions can be abbreviated as</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
                          input: 
                               line *
                          ;
</pre>
<p class="Pp">The operators <span class="Li">&quot;*&quot;</span>,
    <span class="Li">&quot;+&quot;</span> and
    <span class="Li">&quot;?&quot;</span> are presented in section &quot;LISTS
    AND OPTIONALS&quot;.</p>
<p class="Pp">A <i>syntactic variable cannot appear more than once as</i> <i>a
    rule name</i> (This differs from <span class="Li">&quot;yacc&quot;</span>).
    So you can't write</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    thing: foo bar ;
    thing: foo baz ;
</pre>
<p class="Pp">instead, write:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    thing: 
           foo bar 
         | foo baz 
    ;
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Semantic_Values_and_Semantic_Actions"><a class="permalink" href="#Semantic_Values_and_Semantic_Actions">Semantic
  Values and Semantic Actions</a></h2>
In <span class="Li">&quot;Parse::Eyapp&quot;</span> a production rule
<p class="Pp"><span class="Li"></span></p>
<pre>
                          A -&gt; X_1 X_2 ... X_n
</pre>
<p class="Pp">can be followed by a <i>semantic action</i>:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
                    A -&gt; X_1 X_2 ... X_n { Perl Code }
</pre>
<p class="Pp">Such semantic action is nothing but Perl code that will be treated
    as an anonymous subroutine. The semantic action associated with production
    rule <span class="Li">&quot;A -&gt; X_1 X_2 ... X_n&quot;</span> is executed
    after any actions associated with the subtrees of
    <span class="Li">&quot;X_1&quot;</span>,
    <span class="Li">&quot;X_2&quot;</span>, ...,
    <span class="Li">&quot;X_n&quot;</span>.
    <span class="Li">&quot;Eyapp&quot;</span> parsers build the syntax tree
    using a left-right bottom-up traverse of the syntax tree. Each times the
    Parser visits the node associated with the production
    <span class="Li">&quot;A -&gt; X_1 X_2 ... X_n&quot;</span> the associated
    semantic action is called. Associated with each symbol of a Parse::Eyapp
    grammar there is a scalar <i>Semantic Value</i> or <i>Attribute</i>. The
    semantic values of terminals are provided by the lexical analyzer. In the
    calculator example (see file
    <span class="Li">&quot;examples/eyapplanguageref/Calc.yp&quot;</span> in the
    distribution), the semantic value associated with an expression is its
    numeric value. Thus in the rule:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
                       exp '+' exp { $_[1] + $_[3] }
</pre>
<p class="Pp"><span class="Li">$_[1]</span> refers to the attribute of the first
    <span class="Li">&quot;exp&quot;</span>, <span class="Li">$_[2]</span> is
    the attribute associated with <span class="Li">'+'</span>, which is the
    second component of the pair provided by the lexical analyzer and
    <span class="Li">$_[3]</span> refers to the attribute of the second
    <span class="Li">&quot;exp&quot;</span>.</p>
<p class="Pp">When the semantic action/anonymous subroutine is called, the
    arguments are as follows:</p>
<ul class="Bl-bullet">
  <li><span class="Li">$_[1]</span> to <span class="Li">$_[n]</span> are the
      attributes of the symbols <span class="Li">&quot;X_1&quot;</span>,
      <span class="Li">&quot;X_2&quot;</span>, ...,
      <span class="Li">&quot;X_n&quot;</span>. Just as
      <span class="Li">$1</span> to <span class="Li">$n</span> in
      <span class="Li">&quot;yacc&quot;</span>,</li>
  <li><span class="Li">$_[0]</span> is the parser object itself. Having
      <span class="Li">$_[0]</span> being the parser object itself allows you to
      call parser methods. Most <span class="Li">&quot;yacc&quot;</span> macros
      have been converted into parser methods. See section &quot;METHODS
      AVAILABLE IN THE GENERATED CLASS&quot; in Parse::Eyapp.</li>
</ul>
<p class="Pp">The returned value will be the attribute associated with the left
    hand side of the production.</p>
<p class="Pp">Names can be given to the attributes using the dot notation (see
    file
    <span class="Li">&quot;examples/eyapplanguageref/CalcSimple.eyp&quot;</span>):</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
                     exp.left '+' exp.right { $left + $right }
</pre>
<p class="Pp">See section &quot;NAMES FOR ATTRIBUTES&quot; for more details
    about the <i>dot</i> and <i>dollar</i> notations.</p>
<p class="Pp">If no action is specified and no
    <span class="Li">%defaultaction</span> is specified the default action</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
                               { $_[1] }
</pre>
<p class="Pp">will be executed instead. See section &quot;DEFAULT ACTIONS&quot;
    to know more.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Actions_in_Mid-Rule"><a class="permalink" href="#Actions_in_Mid-Rule">Actions
  in Mid-Rule</a></h2>
Actions can be inserted in the middle of a production like in:
<p class="Pp"><span class="Li"></span></p>
<pre>
 block: '{'.bracket { $ids-&gt;begin_scope(); } declaration*.decs statement*.sts '}' { ... }
</pre>
<p class="Pp">A middle production action is managed by inserting a new rule in
    the grammar and associating the semantic action with it:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
                     Temp: /* empty */ { $ids-&gt;begin_scope(); }
</pre>
<p class="Pp">Middle production actions can refer to the attributes on its left.
    They count as one of the components of the production. Thus the program:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  ~/LEyapp/examples/eyapplanguageref$ cat intermediateaction2.yp 
  %%
  S:  'a' { $_[1]x4 }.mid 'a' { print &quot;\n&lt;&lt;$_[2], $mid, $_[3]&gt;&gt;\n&quot;; }
  ;
  %%
</pre>
<p class="Pp">The auxiliar syntactic variables are named
    <span class="Li">&quot;@#position-#order&quot;</span> where
    <span class="Li">&quot;#position&quot;</span> is the position of the action
    in the rhs and <span class="Li">&quot;order&quot;</span> is an ordinal
    number. See the <span class="Li">&quot;.output&quot;</span> file for the
    former example:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  ~/LEyapp/examples/eyapplanguageref$ eyapp -v intermediateaction2.yp
  ~/LEyapp/examples/eyapplanguageref$ sed -ne '1,5p' intermediateaction2.output
  Rules:
  ------
  0:  $start -&gt; S $end
  1:  S -&gt; 'a' @1-1 'a'
  2:  @1-1 -&gt; /* empty */
</pre>
<p class="Pp">We can build an executable
    <span class="Li">&quot;ia.pl&quot;</span> from the former grammar using
    <span class="Li">&quot;eyapp&quot;</span> option
    <span class="Li">&quot;-C&quot;</span>:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  ~/LEyapp/examples/eyapplanguageref$ eyapp -C -o ia.pl intermediateaction2.yp
</pre>
<p class="Pp">The <span class="Li">&quot;main&quot;</span>, error and lexer
    methods are provided by <span class="Li">&quot;Parse::Eyapp&quot;</span>.
    When given input <span class="Li">&quot;aa&quot;</span> the execution will
    produce as output <span class="Li">&quot;aaaa, aaaa, a&quot;</span>. The
    option <span class="Li">&quot;-d&quot;</span> activates the debug mode, the
    option <span class="Li">&quot;-c&quot;</span> tells the program to get the
    input from the command line::</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  ~/LEyapp/examples/eyapplanguageref$ ./ia.pl -d -c 'aa'
  ----------------------------------------
  In state 0:
  Stack: 0
  Need token. Got &gt;a&lt;
  Shift and go to state 2.
  ----------------------------------------
  In state 2:
  Stack: 0-&gt;'a'-&gt;2
  Don't need token.
  Reduce using rule 2 (@1-1 --&gt; /* empty */): Back to state 2, then go to state 4.
  ----------------------------------------
  In state 4:
  Stack: 0-&gt;'a'-&gt;2-&gt;'@1-1'-&gt;4
  Need token. Got &gt;a&lt;
  Shift and go to state 5.
  ----------------------------------------
  In state 5:
  Stack: 0-&gt;'a'-&gt;2-&gt;'@1-1'-&gt;4-&gt;'a'-&gt;5
  Don't need token.
  Reduce using rule 1 (S --&gt; a @1-1 a): 
  &lt;&lt;aaaa, aaaa, a&gt;&gt;
  Back to state 0, then go to state 1.
  ----------------------------------------
  In state 1:
  Stack: 0-&gt;'S'-&gt;1
  Need token. Got &gt;&lt;
  Shift and go to state 3.
  ----------------------------------------
  In state 3:
  Stack: 0-&gt;'S'-&gt;1-&gt;''-&gt;3
  Don't need token.
  Accept.
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Example_of_Body_Section"><a class="permalink" href="#Example_of_Body_Section">Example
  of Body Section</a></h2>
Following with the calculator example, the body is:
<p class="Pp"><span class="Li"></span></p>
<pre>
  pl@nereida:~/src/perl/eyapp/examples/eyapplanguageref$ sed -ne '17,/%%/p' Calc.eyp | cat -n 
     1  start:                                                                              
     2      input { \%s }                                                                   
     3  ;
     4
     5  input: line *
     6  ;
     7
     8  line:
     9      '\n'       { undef }
    10    | exp '\n'   {
    11                    print &quot;$_[1]\n&quot; if defined($_[1]);
    12                    $_[1]
    13                 }
    14    | error  '\n'
    15        {
    16          $_[0]-&gt;YYErrok;
    17          undef
    18        }
    19  ;
    20
    21  exp:
    22      NUM
    23    | $VAR                   { $s{$VAR} }
    24    | $VAR '=' $exp          { $s{$VAR} = $exp }
    25    | exp.left '+' exp.right { $left + $right }
    26    | exp.left '-' exp.right { $left - $right }
    27    | exp.left '*' exp.right { $left * $right }
    28    | exp.left '/' exp.right
    29      {
    30         $_[3] and return($_[1] / $_[3]);
    31         $_[0]-&gt;YYData-&gt;{ERRMSG} = &quot;Illegal division by zero.\n&quot;;
    32         $_[0]-&gt;YYError;
    33         undef
    34      }
    35    | '-' $exp %prec NEG     { -$exp }
    36    | exp.left '^' exp.right { $left ** $right }
    37    | '(' $exp ')'           { $exp }
    38  ;
    39
    40  %%
</pre>
<p class="Pp">This body does not uses any of the Eyapp extensions (with the
    exception of the <span class="Li">&quot;*&quot;</span> operator at line 5)
    and the dot and dollar notations.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Solving_Ambiguities_and_Conflicts"><a class="permalink" href="#Solving_Ambiguities_and_Conflicts">Solving
  Ambiguities and Conflicts</a></h2>
When Eyapp analyzes a grammar like:
<p class="Pp"><span class="Li"></span></p>
<pre>
  examples/eyapplanguageref$ cat -n ambiguities.eyp
     1  %%
     2  exp:
     3      NUM
     4    | exp '-' exp
     5  ;
     6  %%
</pre>
<p class="Pp">it will produce a warning announcing the existence of
    <i>shift-reduce</i> conflicts:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  examples/eyapplanguageref$ eyapp ambiguities.eyp
  1 shift/reduce conflict (see .output file)
  State 5: reduce by rule 2: exp -&gt; exp '-' exp (default action)
  State 5: shifts:
    to state    3 with '-'
</pre>
<p class="Pp">when <span class="Li">&quot;eyapp&quot;</span> finds warnings
    automatically produces a <span class="Li">&quot;.output&quot;</span> file
    describing the conflict.</p>
<p class="Pp">What the warning is saying is that an expression like
    <span class="Li">&quot;exp '-' exp&quot;</span> (rule 2) followed by a minus
    <span class="Li">'-'</span> can be parsed in more than one way. If we have
    an input like <span class="Li">&quot;NUM - NUM - NUM&quot;</span> the
    activity of a <i>LALR</i>(1) parser (the family of parsers to which Eyapp
    belongs) consists of a sequence of <i>shift and reduce actions</i>. A
    <i>shift action</i> has as consequence the reading of the next token. A
    <i>reduce action</i> is finding a production rule that matches and
    substituting the rhs of the production by the lhs. For input
    <span class="Li">&quot;NUM - NUM - NUM&quot;</span> the activity will be as
    follows (the dot is used to indicate where the next input token is):</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
                           .NUM - NUM - NUM # shift
                            NUM.- NUM - NUM # reduce exp: NUM 
                            exp.- NUM - NUM # shift
                            exp -.NUM - NUM # shift
                            exp - NUM.- NUM # reduce exp: NUM
                            exp - exp.- NUM # shift/reduce conflict
</pre>
<p class="Pp">up this point two different decisions can be taken: the next
    description can be</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
                                  exp.- NUM # reduce by exp: exp '-' exp (rule 2)
</pre>
<p class="Pp">or:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
                            exp - exp -.NUM # shift '-' (to state 3)
</pre>
<p class="Pp">that is why it is called a <i>shift-reduce conflict</i>.</p>
<p class="Pp">That is also the reason for the precedence declarations in the
    head section. Another kind of conflicts are <i>reduce-reduce conflicts</i>.
    They arise when more that rhs can be applied for a reduction action.</p>
<p class="Pp">Eyapp solves the conflicts applying the following rules:</p>
<ul class="Bl-bullet">
  <li>In a shift/reduce conflict, the default is the shift.</li>
  <li>In a reduce/reduce conflict, the default is to reduce by the earlier
      grammar production (in the input sequence).</li>
  <li>Precedences and associativities can be given to tokens in the declarations
      section. This is made by a sequence of lines beginning with one of the
      directives: <span class="Li">%left</span>, <span class="Li">%right</span>,
      or <span class="Li">%nonassoc</span>, followed by a list of tokens. All
      the tokens on the same line have the same precedence and associativity;
      the lines are listed in order of increasing precedence.</li>
  <li>A precedence and associativity is associated with each grammar production;
      it is the precedence and associativity of the <i>last token</i> or
      <i>literal</i> in the right hand side of the production.</li>
  <li>The <span class="Li">%prec</span> directive can be used when a rhs is
      involved in a conflict and has no tokens inside or it has but the
      precedence of the last token leads to an incorrect interpretation. A rhs
      can be followed by an optional <span class="Li">&quot;%prec
      token&quot;</span> directive giving the production the precedence of the
      <span class="Li">&quot;token&quot;</span>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
                          exp:   '-' exp %prec NEG { -$_[1] }
    </pre>
  </li>
  <li>If there is a shift/reduce conflict, and both the grammar production and
      the input token have precedence and associativity associated with them,
      then the conflict is solved in favor of the action (shift or reduce)
      associated with the higher precedence. If the precedences are the same,
      then the associativity is used; left associative implies reduce, right
      associative implies shift, and non associative implies error. The last is
      used to describe operators, like the operator
      <span class="Li">&quot;.LT.&quot;</span> in FORTRAN, that may not
      associate with themselves. That is, because
    <p class="Pp"><span class="Li"></span></p>
    <pre>
                             A .LT. B .LT. C
    </pre>
    <p class="Pp">is invalid in FORTRAN,
        <span class="Li">&quot;.LT.&quot;</span> would be described with the
        keyword <span class="Li">%nonassoc</span> in eyapp.</p>
  </li>
</ul>
<p class="Pp">To solve a shift-reduce conflict between a production
    <span class="Li">&quot;A --&gt; SOMETHING&quot;</span> and a token
    <span class="Li">'a'</span> you can follow this procedure:</p>
<dl class="Bl-tag">
  <dt>1. Edit the &quot;.output&quot; file</dt>
  <dd></dd>
  <dt>2. Search for the state where the conflict between the production and the
    token is. In our example it looks like:</dt>
  <dd><span class="Li"></span>
    <pre>
 pl@nereida:~/src/perl/YappWithDefaultAction/examples$ sed -ne '56,65p' ambiguities.output
 State 5:

        exp -&gt; exp . '-' exp    (Rule 2)
        exp -&gt; exp '-' exp .    (Rule 2)

        '-'     shift, and go to state 3

        '-'     [reduce using rule 2 (exp)]
        $default        reduce using rule 2 (exp)
    </pre>
  </dd>
  <dt>3. Inside the state there has to be a production of the type &quot;A
    --&gt; SOMETHING.&quot; (with the dot at the end) indicating that a
    reduction must take place. There has to be also another production of the
    form &quot;A --&gt; prefix . suffix&quot;, where suffix can <i>start</i>
    with the involved token 'a'.</dt>
  <dd></dd>
  <dt>4. Decide what action shift or reduce matches the kind of trees you want.
    In this example we want &quot;NUM - NUM - NUM&quot; to produce a tree like
    &quot;MINUS(MINUS(NUM, NUM), NUM)&quot; and not &quot;MINUS(NUM, MINUS(NUM,
    NUM))&quot;. We want the conflict in &quot;exp - exp.- NUM&quot; to be
    solved in favor of the reduction by &quot;exp: exp '-' exp&quot;. This is
    achieved by declaring &quot;%left '-'&quot;.</dt>
  <dd></dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Error_Recovery"><a class="permalink" href="#Error_Recovery">Error
  Recovery</a></h2>
The token name <span class="Li">&quot;error&quot;</span> is reserved for error
  handling. This name can be used in grammar productions; it suggests places
  where errors are expected, and recovery can take place:
<p class="Pp"><span class="Li"></span></p>
<pre>
     line:
       '\n'         { undef }
       | exp '\n'   { print &quot;$_[1]\n&quot; if defined($_[1]); $_[1] }
       | error  '\n'
           {
             $_[0]-&gt;YYErrok;
             undef
           }
</pre>
<p class="Pp">The parser pops its stack until it enters a state where the token
    <span class="Li">&quot;error&quot;</span> is legal. It then shifts the token
    <span class="Li">&quot;error&quot;</span> and proceeds to discard tokens
    until finding one that is acceptable. In the example all the tokens until
    finding a <span class="Li">'\n'</span> will be skipped. If no special error
    productions have been specified, the processing will halt.</p>
<p class="Pp">In order to prevent a cascade of error messages, the parser, after
    detecting an error, remains in error state until three tokens have been
    successfully read and shifted. If an error is detected when the parser is
    already in error state, no message is given, and the input token is quietly
    deleted. The method <span class="Li">&quot;YYErrok&quot;</span> used in the
    example communicates to the parser that a satisfactory recovery has been
    reached and that it can safely emit new error messages.</p>
<p class="Pp">You cannot have a literal <i>'error'</i> in your grammar as it
    would confuse the driver with the <i>error</i> token. Use a symbolic token
    instead.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="THE_TAIL"><a class="permalink" href="#THE_TAIL">THE
  TAIL</a></h1>
The tail section contains Perl code. Usually it is empty, but you can if you
  want put here your own lexical analyzer and error management subroutines. An
  example of this is in files
  <span class="Li">&quot;examples/eyapplanguageref/List3_tree_d_sem.yp&quot;</span>
  (the grammar) and <span class="Li">&quot;use_list3_tree_d_dem.pl&quot;</span>
  (the client).
</section>
<section class="Sh">
<h1 class="Sh" id="THE_LEXICAL_ANALYZER"><a class="permalink" href="#THE_LEXICAL_ANALYZER">THE
  LEXICAL ANALYZER</a></h1>
The Lexical Analyzer is called each time the parser needs a new token. It is
  called with only one argument (the parser object) and returns a pair
  containing the next token and its associated attribute.
<p class="Pp">The fact that is a method of the parser object means that the
    parser methods are accessible inside the lexical analyzer.</p>
<p class="Pp">When the lexical analyzer reaches the end of input, it must return
    the pair <span class="Li">&quot;('', undef)&quot;</span></p>
<section class="Ss">
<h2 class="Ss" id="Automatic_Generation_of_Lexical_Analyzers"><a class="permalink" href="#Automatic_Generation_of_Lexical_Analyzers">Automatic
  Generation of Lexical Analyzers</a></h2>
By default a lexical analyzer is built. The
  <span class="Li">&quot;eyapp&quot;</span> option
  <span class="Li">&quot;-l&quot;</span> can be used to inhibit the generation
  of the default lexical analyzer. In such case, one must be explictly provided.
<p class="Pp"><i>No token Definitions</i></p>
<p class="Pp">When no token definitions are given in the head section, the
    default lexical analyzer simply assumes that the token is the string
    literal. See this example in file
    <span class="Li">&quot;examples/lexergeneration/simple.yp&quot;</span>:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  pl@nereida:~/LEyapp/examples/lexergeneration$ cat simple.yp
  %%
  A:    a
      | A d
  ;
  %%
</pre>
<p class="Pp">The grammar does not describes the lexical analyzer nor the error
    default subroutine. Eyapp will generate default lexical and error
    subroutines:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  pl@nereida:~/LEyapp/examples/lexergeneration$ eyapp -o simple.pl -TC simple.yp

  pl@nereida:~/LEyapp/examples/lexergeneration$ ls -ltr | tail -2
  -rw-r--r-- 1 pl pl   27 2010-06-29 10:28 simple.yp
  -rwxr-xr-x 1 pl pl 3245 2010-06-29 10:35 simple.pl
</pre>
<p class="Pp">The option <span class="Li">&quot;-T&quot;</span> is equivalent to
    insert the <span class="Li">%tree</span> directive in the head section.
    Since no names were explicitly given to the productions, the names of the
    productions are built using the pattern
    <span class="Li">&quot;Lhs_is_RHS&quot;</span>.</p>
<p class="Pp">Option <span class="Li">&quot;-C&quot;</span> instructs the
    <span class="Li">&quot;eyapp&quot;</span> compiler to produce an executable
    by setting the execution permits (see
    <span class="Li">&quot;simple.pl&quot;</span> permits above), inserting the
    appropriate she bang directive:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  pl@nereida:~/LEyapp/examples/lexergeneration$ head simple.pl | head -1
  #!/usr/bin/perl
</pre>
<p class="Pp">and inserting a call to the package
    <span class="Li">&quot;main&quot;</span> subroutine at the end of the
    generated parser:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  pl@nereida:~/LEyapp/examples/lexergeneration$ tail -6 simple.pl
  unless (caller) {
    exit !__PACKAGE__-&gt;main('');
  }
</pre>
<p class="Pp">If no <span class="Li">&quot;main&quot;</span> was provided,
    <span class="Li">&quot;eyapp&quot;</span> will provide one.</p>
<p class="Pp">Tokens <span class="Li">&quot;a&quot;</span> and
    <span class="Li">&quot;d&quot;</span> are assumed to represent strings
    <span class="Li">'a'</span> and <span class="Li">'d'</span>
  respectively.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  pl@nereida:~/LEyapp/examples/lexergeneration$ ./simple.pl -i -t -c 'a d d'
  A_is_A_d(A_is_A_d(A_is_a(TERMINAL[a]),TERMINAL[d]),TERMINAL[d])
</pre>
<p class="Pp">The <span class="Li">&quot;main&quot;</span> method provided by
    <span class="Li">&quot;eyapp&quot;</span> accepts several options in the
    command line:</p>
<ul class="Bl-bullet">
  <li><span class="Li">&quot;-t&quot;</span> Prints the abstract syntax
    tree</li>
  <li><span class="Li">&quot;-i&quot;</span> Shows the semantic value associated
      with each terminal</li>
  <li><span class="Li">&quot;-c string&quot;</span> Indicates that the input is
      given by the <span class="Li">&quot;string&quot;</span> that follows the
      option</li>
</ul>
<p class="Pp">You can get the set of available options using
    <span class="Li">&quot;--help&quot;</span>:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  pl@nereida:~/LEyapp/examples/lexergeneration$ ./simple.pl -h
  Available options:
    --debug                    sets yydebug on
    --nodebug                  sets yydebug off
    --file filepath            read input from filepath
    --commandinput string      read input from string
    --tree                     prints $tree-&gt;str
    --notree                   does not print $tree-&gt;str
    --info                     When printing $tree-&gt;str shows the value of TERMINALs
    --help                     shows this help
    --slurp                    read until EOF reached
    --noslurp                  read until CR is reached
    --argfile                  main() will take the input string from its @_
    --noargfile                main() will not take the input string from its @_
    --yaml                     dumps YAML for $tree: YAML module must be installed
    --margin=i                 controls the indentation of $tree-&gt;str (i.e. $Parse::Eyapp::Node::INDENT)
</pre>
<p class="Pp">If we try to feed it with an illegal input, an error message is
    emitted:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  pl@nereida:~/LEyapp/examples/lexergeneration$ ./simple.pl -i -t -c 'a e d'
  Error inside the lexical analyzer near 'e'. Line: 1. File: 'simple.yp'. No match found.
</pre>
<p class="Pp">In the example above we have taken advantage of the
    <span class="Li">&quot;main&quot;</span> method provided by Eyapp. If we
    want to keep in control of the parsing process, we can write a client
    program that makes use of the generated modulino:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  pl@nereida:~/LEyapp/examples/lexergeneration$ cat -n usesimple.pl
     1  #!/usr/bin/env perl
     2  use warnings;
     3  use strict;
     4
     5  use simple;
     6
     7  # build a parser object
     8  my $parser = simple-&gt;new();
     9
    10  # take the input from the command line arguments
    11  # or from STDIN
    12  my $input = join ' ',@ARGV;
    13  $input = &lt;&gt; unless $input;
    14
    15  # set the input
    16  $parser-&gt;input($input);
    17
    18  # parse the input and get the AST
    19  my $tree = $parser-&gt;YYParse();
    20
    21  print $tree-&gt;str().&quot;\n&quot;;
</pre>
<p class="Pp">Here is an example of execution:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  pl@nereida:~/LEyapp/examples/lexergeneration$ eyapp -T simple.yp
  pl@nereida:~/LEyapp/examples/lexergeneration$ ./usesimple.pl a d d
  A_is_A_d(A_is_A_d(A_is_a(TERMINAL),TERMINAL),TERMINAL)
</pre>
<p class="Pp"><i>Token Definitions: Regular Expressions</i></p>
<p class="Pp">Eyapp extends the <span class="Li">%token</span> directive with
    the syntax:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
     %token TOKENID = /regexp/
</pre>
<p class="Pp">If such definition is used, an entry with the shape:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
   /\G$regexp/gc and return ('TOKENID', $1);
</pre>
<p class="Pp">will be added to the generated lexical analyzer. Therefore the
    string associated with the first parenthesis in
    <span class="Li">&quot;/regexp/&quot;</span> will be used as semantic value
    for <span class="Li">&quot;TOKENID&quot;</span>. If
    <span class="Li">&quot;/regexp/&quot;</span> has no parenthesis
    <span class="Li">&quot;undef&quot;</span> will be the semantic value. See
    this example:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  pl@nereida:~/LEyapp/examples/lexergeneration$ cat -n numlist.eyp
     1  %token NUM = /(\d+)/
     2  %token ID  = /(\w+)/
     3
     4  %%
     5  A:
     6        B
     7      | A B
     8  ;
     9
    10  B:
    11        ID
    12      | a
    13      | NUM
    14  ;
    15  %%
</pre>
<p class="Pp">The order of the <span class="Li">%token</span> declarations is
    important. In the example the token <span class="Li">&quot;NUM&quot;</span>
    is a subset of the token <span class="Li">&quot;ID&quot;</span>. Since it
    appears first, it will be tried first:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
     /\G(\d+)/gc and return ('NUM', $1);
     /\G(\w+)/gc and return ('ID', $1);
</pre>
<p class="Pp">Also observe that token <span class="Li">'a'</span> (line 12) is
    contained in token <span class="Li">&quot;ID&quot;</span>. However, any
    implicit token like this that appears in the body section and was not
    declared using an explicit <span class="Li">%token</span> directive in the
    head section takes priority over the ones declared. See the behavior of the
    former program:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  pl@nereida:~/LEyapp/examples/lexergeneration$ eyapp -TC numlist
  pl@nereida:~/LEyapp/examples/lexergeneration$ ./numlist.pm -t -i -c '4 a b'
  A_is_A_B(A_is_A_B(A_is_B(B_is_NUM(TERMINAL[4])),B_is_a(TERMINAL[a])),B_is_ID(TERMINAL[b]))
</pre>
<p class="Pp">The lexical analyzer returned
    <span class="Li">&quot;NUM&quot;</span> and not
    <span class="Li">&quot;ID&quot;</span> when <span class="Li">4</span> was
    processed, also it returned <span class="Li">&quot;a&quot;</span> and not
    <span class="Li">&quot;ID&quot;</span> when <span class="Li">'a'</span> was
    processed.</p>
<p class="Pp">A <span class="Li">%token</span> declaration without assignment
    like in:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
   %token A B
</pre>
<p class="Pp">is equivalent to</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  %token A   = /(A)/
  %token B   = /(B)/
</pre>
<p class="Pp">(in that order).</p>
<p class="Pp"><i>Token Definitions via Code</i></p>
<p class="Pp">An alternative way to define a token is via Perl code:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
      %token TOKENID = { ... }
</pre>
<p class="Pp">in such case the code defining
    <span class="Li">&quot;TOKENID&quot;</span> will be inserted verbatim in the
    corresponding place of the generated lexical analyzer. When the code
    <span class="Li">&quot;{ ... }&quot;</span> is executed, the variable
    <span class="Li">$_</span> contains the input being parsed and the special
    variable <span class="Li">$self</span> refers to the parser object. The
    following example is equivalent to the one used in the previous section:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  pl@nereida:~/LEyapp/examples/lexergeneration$ cat -n tokensemdef.eyp
     1  %token NUM = /(\d+)/
     2  %token ID  = { /\G(\w+)/gc and return ('ID', $1); }
     3
     4  %%
     5  A:
     6        B
     7      | A B
     8  ;
     9
    10  B:
    11        ID
    12      | a
    13      | NUM
    14  ;
    15  %%
</pre>
<p class="Pp">Follows an example of compilation and execution:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  pl@nereida:~/LEyapp/examples/lexergeneration$ eyapp -TC tokensemdef.eyp
  pl@nereida:~/LEyapp/examples/lexergeneration$ ./tokensemdef.pm -t -i -nos
  4 a b
  A_is_A_B(A_is_A_B(A_is_B(B_is_NUM(TERMINAL[4])),B_is_a(TERMINAL[a])),B_is_ID(TERMINAL[b]))
</pre>
<p class="Pp"><i>Token Definitions: Controling whites</i></p>
<p class="Pp">By default, the generated lexical analyzer skips white spaces,
    defined as <span class="Li">&quot;/\s*/&quot;</span>. The programmer can
    change this behavior using the <span class="Li">%whites</span> directive.
    The following example permits Perl-like comments in the input:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  pl@nereida:~/LEyapp/examples/lexergeneration$ cat -n simplewithwhites.eyp
     1  %whites  /(\s*(?:#.*)?\s*)/
     2  %%
     3  A:    a
     4      | A d
     5  ;
     6  %%
</pre>
<p class="Pp">Follows an example of execution:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  pl@nereida:~/LEyapp/examples/lexergeneration$ cat -nA input
       1  a # 1$
       2  $
       3  d ^I#2$
  pl@nereida:~/LEyapp/examples/lexergeneration$ eyapp -TC simplewithwhites.eyp
  pl@nereida:~/LEyapp/examples/lexergeneration$ ./simplewithwhites.pm -t -i -f input
  A_is_A_d(A_is_a(TERMINAL[a]),TERMINAL[d])
</pre>
<p class="Pp">The <span class="Li">%white</span> directive can be followed by
    some Perl code defining the white spaces:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  pl@nereida:~/LEyapp/examples/lexergeneration$ cat -n simplewithwhitescode.eyp
     1  %whites  { /\G(\s*(?:#.*)?\s*)/gc and $self-&gt;tokenline($1 =~ tr{\n}{}) }
     2  %%
     3  A:    a
     4      | A d
     5  ;
     6  %%
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Reading_Input_from_File"><a class="permalink" href="#Reading_Input_from_File">Reading
  Input from File</a></h2>
You can use the method <span class="Li">&quot;YYSlurpFile&quot;</span> to read
  the input from a file and set the input for the parser to its contents. Yo can
  also use the <span class="Li">&quot;YYInput&quot;</span> method to set the
  input.
<p class="Pp">See the example below:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  pl@nereida:~/LEyapp/examples/lexergeneration$ cat -n usesimplefromfile.pl
     1  #!/usr/bin/env perl
     2  use warnings;
     3  use strict;
     4
     5  use simplewithwhites;
     6
     7  my $parser = simplewithwhites-&gt;new();
     8
     9  # take the input from the specified file
    10  my $fn = shift;
    11
    12  $parser-&gt;YYSlurpFile($fn);
    13
    14  # parse the input and get the AST
    15  my $tree = $parser-&gt;YYParse();
    16
    17  print $tree-&gt;str().&quot;\n&quot;;
</pre>
<p class="Pp">First, compile the grammar
    <span class="Li">&quot;simplewithwhites.eyp&quot;</span> presented
  above:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  pl@nereida:~/LEyapp/examples/lexergeneration$ eyapp -T simplewithwhites
</pre>
<p class="Pp">And then run it:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  pl@nereida:~/LEyapp/examples/lexergeneration$ cat -n  input
     1  a # 1
     2
     3  d       #2
  pl@nereida:~/LEyapp/examples/lexergeneration$ ./usesimplefromfile.pl input
  A_is_A_d(A_is_a(TERMINAL),TERMINAL)
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Huge_input_and_Incremental_Lexical_Analyzers"><a class="permalink" href="#Huge_input_and_Incremental_Lexical_Analyzers">Huge
  input and Incremental Lexical Analyzers</a></h2>
If your input is huge, try to make use of an incremental lexical analyzer. In an
  incremental lexer the input is read and parsed in chunks. Read up to a point
  where it is safe to parse. In the example below, the lexer reads a new line
  each time we reach the end of the input string
  <span class="Li">&quot;${$parser-&gt;YYInput}&quot;</span>. In the case of the
  arithmetic expressions grammar below, by reading up to
  <span class="Li">'\n'</span>, we are sure that the input is not broken in the
  middle of a token. Instead of having the whole huge input in memory, we only
  keep a small substring.
<p class="Pp"><span class="Li"></span></p>
<pre>
  pl@nereida:~/LEyapp/examples/lexergeneration$ cat -n Incremental.eyp                    
     1  %right  '='                                                                     
     2  %left   '-' '+'                                                                 
     3  %left   '*' '/'                                                                 
     4  %left   NEG                                                                     
     5                                                                                  
     6  %tree                                                                           
     7                                                                                  
     8  %%                                                                              
     9  input:                                                                          
    10          |   input $line  { print $line-&gt;str.&quot;\n&quot; }                              
    11  ;                                                                               
    12                                                                                  
    13  line:     '\n'                                                                  
    14          | exp '\n'
    15          | error '\n'
    16  ;
    17
    18  exp:        NUM
    19          |   VAR
    20          |   VAR '=' exp
    21          |   exp '+' exp
    22          |   exp '-' exp
    23          |   exp '*' exp
    24          |   exp '/' exp
    25          |   '-' exp %prec NEG
    26          |   '(' exp ')'
    27  ;
    28
    29  %%
    30
    31  sub _Lexer {
    32      my($parser)=shift;
    33
    34      if ($parser-&gt;YYEndOfInput) {
    35        my $input = &lt;STDIN&gt;;
    36        return('', undef) unless $input;
    37        $parser-&gt;input($input);
    38      };
    39
    40      for (${$parser-&gt;YYInput}) {
    41          m/\G[ \t]*/gc;
    42          m/\G([0-9]+(?:\.[0-9]+)?)/gc and return('NUM',$1);
    43          m/\G([A-Za-z][A-Za-z0-9_]*)/gc and return('VAR',$1);
    44          m/\G(.)/gcs and return($1,$1);
    45          return('', undef);
    46      }
    47  }
    48
    49  __PACKAGE__-&gt;lexer(\&amp;_Lexer);
</pre>
<p class="Pp">This approach has limitations. The code will get more tangled if
    some token can take more than one line. For example, if we extend this
    language to accept C-like comments <span class="Li">&quot;/* ...
    */&quot;</span> which expands over several lines.</p>
<p class="Pp">Here follows an example of execution. This is the client
  program:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  pl@nereida:~/LEyapp/examples/lexergeneration$ cat useincremental.pl
  #!/usr/bin/perl -w
  use Incremental;

  Incremental-&gt;new-&gt;YYParse;
</pre>
<p class="Pp">This is a small test input file:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  pl@nereida:~/LEyapp/examples/lexergeneration$ cat inputforincremental
  a = 2
  a+3
  b=4
  b*2+a
</pre>
<p class="Pp">Finally, see the results of the execution:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  pl@nereida:~/LEyapp/examples/lexergeneration$ ./useincremental.pl &lt; inputforincremental
  line_4(exp_8(TERMINAL,exp_6(TERMINAL)))
  line_4(exp_9(exp_7(TERMINAL),exp_6(TERMINAL)))
  line_4(exp_8(TERMINAL,exp_6(TERMINAL)))
  line_4(exp_9(exp_11(exp_7(TERMINAL),exp_6(TERMINAL)),exp_7(TERMINAL)))
</pre>
<p class="Pp">The numbers in the output refer to the production number:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  pl@nereida:~/LEyapp/examples/lexergeneration$ eyapp -v Incremental.eyp
  pl@nereida:~/LEyapp/examples/lexergeneration$ sed -ne '/Rules:/,/^$/p' Incremental.output
  Rules:
  ------
  0:      $start -&gt; input $end
  1:      input -&gt; /* empty */
  2:      input -&gt; input line
  3:      line -&gt; '\n'
  4:      line -&gt; exp '\n'
  5:      line -&gt; error '\n'
  6:      exp -&gt; NUM
  7:      exp -&gt; VAR
  8:      exp -&gt; VAR '=' exp
  9:      exp -&gt; exp '+' exp
  10:     exp -&gt; exp '-' exp
  11:     exp -&gt; exp '*' exp
  12:     exp -&gt; exp '/' exp
  13:     exp -&gt; '-' exp
  14:     exp -&gt; '(' exp ')'
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Using_Several_Lexical_Analyzers_for_the_Same_Parser"><a class="permalink" href="#Using_Several_Lexical_Analyzers_for_the_Same_Parser">Using
  Several Lexical Analyzers for the Same Parser</a></h2>
At any time during the parsing you can use the method
  <span class="Li">&quot;$parser-&gt;YYLexer&quot;</span> to set a new lexical
  analyzer.
<p class="Pp">The following grammar starts setting the lexer to sub
    <span class="Li">&quot;Lexer1&quot;</span> (line 44). It later changes the
    lexer to <span class="Li">&quot;Lexer2&quot;</span> (ine 24) after the token
    <span class="Li">'%%'</span> is seen. Inside
    <span class="Li">&quot;Lexer2&quot;</span> the token
    <span class="Li">&quot;A&quot;</span> represents a
    <span class="Li">'B'</span>. This capability allows the parsing of languages
    where different sections require different lexical analysis. For example, in
    <span class="Li">&quot;yacc&quot;</span>, carriage returns separates
    declarations in the header section but is considered a white space inside
    the body and tail sections. This feature has similar power to the
    <i>state</i> concept of the lexical analyzer generator
    <span class="Li">&quot;flex&quot;</span>.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  $ cat -n twolexers.eyp 
     1  %%
     2  s:  first '%%' second
     3  ;
     4  
     5  first:
     6      A first
     7    | A
     8  ;
     9  
    10  second:
    11      A second
    12    | A
    13  ;
    14  
    15  %%
    16  
    17  sub Lexer1 {
    18      my($parser)=shift;
    19  
    20      print &quot;In Lexer 1 \n&quot;;
    21      for (${$parser-&gt;YYInput}) {
    22          m/\G\s*/gc;
    23          m/\G(%%)/gc and do {
    24            $parser-&gt;YYLexer(\&amp;Lexer2);
    25            return ($1, undef);
    26          };
    27          m/\G(.)/gcs and return($1,$1);
    28          return('', undef);
    29      }
    30  }
    31  
    32  sub Lexer2 {
    33      my($parser)=shift;
    34  
    35      print &quot;In Lexer 2 \n&quot;;
    36      for (${$parser-&gt;YYInput}) {
    37          m/\G\s*/gc;
    38          m/\GB/gc    and return('A','B');
    39          m/\G(.)/gcs and die &quot;Error. Expected 'B', found $1\n&quot;;
    40      }
    41          return('', undef);
    42  }
    43  
    44  __PACKAGE__-&gt;lexer(\&amp;Lexer1);
</pre>
<p class="Pp">When executed, it behaves like this:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
        $ ./twolexers.pm -t -i -m 1 -c 'A A %% B B'
        In Lexer 1 
        In Lexer 1 
        In Lexer 1 
        In Lexer 2 
        In Lexer 2 
        In Lexer 2 

        s_is_first_second(
          first_is_A_first(
            TERMINAL[A],
            first_is_A(
              TERMINAL[A]
            )
          ),
          second_is_A_second(
            TERMINAL[B],
            second_is_A(
              TERMINAL[B]
            )
          )
        )
</pre>
<p class="Pp">The lexer can bechanged at any time. The following example starts
    using the default lexer generated by
    <span class="Li">&quot;eyapp&quot;</span>. It changes the lexer to
    <span class="Li">&quot;Lexer2&quot;</span>inside an intermediate semantic
    action (line 7). Inside <span class="Li">&quot;Lexer2&quot;</span> the token
    <span class="Li">&quot;A&quot;</span> is interpreted as a word
    <span class="Li">&quot;\w+&quot;</span>.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
   $ cat -n twolexers2.eyp 
     1  # Compile it with:
     2  # $ eyapp -TC twolexers2.eyp 
     3  # Run it with:
     4  # $ ./twolexers2.pm -t -i -c 'A A %% d3 c2'
     5  
     6  %%
     7  s:  first '%%' { $_[0]-&gt;YYLexer(\&amp;Lexer2) } second
     8  ;
     9  
    10  first:
    11      A first
    12    | A
    13  ;
    14  
    15  second:
    16      A second
    17    | A
    18  ;
    19  
    20  %%
    21  
    22  sub Lexer2 {
    23      my($parser)=shift;
    24  
    25      print &quot;In Lexer 2 \n&quot;;
    26      for (${$parser-&gt;YYInput}) {
    27          m/\G\s*/gc;
    28          m/\G(\w+)/gc    and return('A',$1);
    29          m/\G(.)/gcs and die &quot;Error. Expected a word,Found $1\n&quot;;
    30      }
    31      return('', undef);
    32  }
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="THE_ERROR_REPORT_SUBROUTINE"><a class="permalink" href="#THE_ERROR_REPORT_SUBROUTINE">THE
  ERROR REPORT SUBROUTINE</a></h1>
The Error Report subroutine is also a parser attribute, and must be defined. By
  default <span class="Li">&quot;Parse::Eyapp&quot;</span> provides a convenient
  error handler.
<p class="Pp">See the Parse::Yapp pages and elsewhere documentation on
    <span class="Li">&quot;yacc&quot;</span> and
    <span class="Li">&quot;bison&quot;</span> for more information.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="USING_AN_EYAPP_GRAMMAR"><a class="permalink" href="#USING_AN_EYAPP_GRAMMAR">USING
  AN EYAPP GRAMMAR</a></h1>
The following is an example of a program that uses the calculator explained in
  the two previous sections:
<p class="Pp"><span class="Li"></span></p>
<pre>
  pl@nereida:~/LEyapp/examples/eyapplanguageref$ cat -n usecalc.pl
     1  #!/usr/bin/perl -w
     2  use strict;
     3  use Calc;
     4
     5  my $parser = Calc-&gt;new();
     6  $parser-&gt;input(\&lt;&lt;'EOI'
     7  a = 2*3       # 1: 6
     8  d = 5/(a-6)   # 2: division by zero
     9  b = (a+1)/7   # 3: 1
    10  c=a*3+4)-5    # 4: syntax error
    11  a = a+1       # 5: 7
    12  EOI
    13  );
    14  my $t = $parser-&gt;Run();
    15  print &quot;========= Symbol Table ==============\n&quot;;
    16  print &quot;$_ = $t-&gt;{$_}\n&quot; for sort keys %$t;
</pre>
<p class="Pp">The output for this program is (the input for each output appear
    as a Perl comment on the right):</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  pl@nereida:~/src/perl/YappWithDefaultAction/examples$ eyapp Calc.eyp

  pl@nereida:~/LEyapp/examples/eyapplanguageref$ ./usecalc.pl
  6
  Illegal division by zero.
  1

  Syntax error near ')' (line number 4).
  Expected one of these terminals: '-' '/' '^' '*' '+' '
  '
  7
  ========= Symbol Table ==============
  a = 7
  b = 1
  c = 22
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="LISTS_AND_OPTIONALS"><a class="permalink" href="#LISTS_AND_OPTIONALS">LISTS
  AND OPTIONALS</a></h1>
The elements of the right hand side of a production (abbreviated <i>rhs</i>) can
  be one of these:
<p class="Pp"><span class="Li"></span></p>
<pre>
  rhselt:     
        symbol    
      | code    
      | '(' optname rhs ')' 
      | rhselt STAR               /* STAR   is (%name\s*([A-Za-z_]\w*)\s*)?\*  */
      | rhselt '&lt;' STAR symbol '&gt;' 
      | rhselt OPTION             /* OPTION is (%name\s*([A-Za-z_]\w*)\s*)?\?  */
      | rhselt '&lt;' PLUS symbol '&gt;'
      | rhselt PLUS               /* PLUS   is (%name\s*([A-Za-z_]\w*)\s*)?\+  */
</pre>
<p class="Pp">The <span class="Li">&quot;STAR&quot;</span>,
    <span class="Li">&quot;OPTION&quot;</span> and
    <span class="Li">&quot;PLUS&quot;</span> operators provide a simple
    mechanism to express lists:</p>
<ul class="Bl-bullet">
  <li>In Eyapp the <span class="Li">&quot;+&quot;</span> operator indicates one
      or more repetitions of the element to the left of
      <span class="Li">&quot;+&quot;</span>, thus a rule like:
    <p class="Pp"><span class="Li"></span></p>
    <pre>
                        decls:  decl +
    </pre>
    <p class="Pp">is the same as:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
                        decls:  decls decl 
                             |  decl
    </pre>
    <p class="Pp">An additional symbol may be included to indicate lists of
        elements separated by such symbol. Thus</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
                       rhss: rule &lt;+ '|'&gt;
    </pre>
    <p class="Pp">is equivalent to:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
                       rhss: rhss '|' rule 
                           | rule
    </pre>
  </li>
  <li>The operators <span class="Li">&quot;*&quot;</span> and
      <span class="Li">&quot;?&quot;</span> have their usual meaning: 0 or more
      for <span class="Li">&quot;*&quot;</span> and optionality for
      <span class="Li">&quot;?&quot;</span>. Is legal to parenthesize a
      <span class="Li">&quot;rhs&quot;</span> expression as in:
    <p class="Pp"><span class="Li"></span></p>
    <pre>
                       optname: (NAME IDENT)?
    </pre>
  </li>
</ul>
<section class="Ss">
<h2 class="Ss" id="The__+__operator"><a class="permalink" href="#The__+__operator">The
  &quot;+&quot; operator</a></h2>
The grammar:
<p class="Pp"><span class="Li"></span></p>
<pre>
  ~/LEyapp/examples/eyapplanguageref$ cat List3.yp 
  %semantic token 'c' 
  %{
  use Data::Dumper;
  $Data::Dumper::Indent = 1;
  %}
  %%
  S:      'c'+  'd'+ 
             { 
                print Dumper($_[1]);
                print Dumper($_[2]);
             } 
  ;
  %%
</pre>
<p class="Pp">Is equivalent to:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  ~/LEyapp/examples/eyapplanguageref$ eyapp -v List3.yp; head -9 List3.output
  Rules:
  ------
  0:  $start -&gt; S $end
  1:  PLUS-1 -&gt; PLUS-1 'c'
  2:  PLUS-1 -&gt; 'c'
  3:  PLUS-2 -&gt; PLUS-2 'd'
  4:  PLUS-2 -&gt; 'd'
  5:  S -&gt; PLUS-1 PLUS-2
</pre>
<p class="Pp">By default, the semantic action associated with a
    <span class="Li">&quot;+&quot;</span> returns the lists of attributes to
    which the <span class="Li">&quot;+&quot;</span> applies:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  pl@nereida:~/LEyapp/examples/eyapplanguageref$ ./use_list3.pl
  Try input 'ccdd': ccdd
  $VAR1 = [ 'c', 'c' ];
  $VAR1 = [ 'd', 'd' ];
</pre>
<p class="Pp">Observe that, in spite of <span class="Li">'d'</span> being a
    syntactic token the actions related with the
    <span class="Li">&quot;d+&quot;</span> element (i.e. the actions associated
    with the <span class="Li">&quot;PLUS-2&quot;</span> productions) create the
    list of <span class="Li">&quot;d&quot;</span>s.</p>
<p class="Pp">The semantic associated with a
    <span class="Li">&quot;+&quot;</span> changes when one of the tree creation
    directives is active (for instance <span class="Li">%tree</span> or
    <span class="Li">%metatree</span>) or it has been explicitly requested with
    a call to the <span class="Li">&quot;YYBuildingTree&quot;</span> method:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
                            $self-&gt;YYBuildingTree(1);
</pre>
<p class="Pp">Other ways to change the associated semantic are to use the
    <span class="Li">&quot;yybuildingtree&quot;</span> option of
    <span class="Li">&quot;YYParse&quot;</span>:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
         $self-&gt;YYParse( yylex =&gt; \&amp;_Lexer, yyerror =&gt; \&amp;_Error,
                           yybuildingtree =&gt; 1,
                         # yydebug =&gt; 0x1F
         );
</pre>
<p class="Pp">In such case the associated semantic action creates a node
    labelled</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
                     _PLUS_LIST
</pre>
<p class="Pp">whose children are the attributes associated with the items in the
    plus list. As it happens when using the <span class="Li">%tree</span>
    directive, <i>syntactic tokens</i> are skipped.</p>
<p class="Pp">When executing the example above but under the
    <span class="Li">%tree</span> directive the output changes. The
    <span class="Li">&quot;-T&quot;</span> option tells the
    <span class="Li">&quot;eyapp&quot;</span> compiler to introduce an implicit
    <span class="Li">%tree</span> directive&gt;:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  ~/LEyapp/examples/eyapplanguageref$ eyapp -T List3.yp
</pre>
<p class="Pp">If we now run the client program with input
    <span class="Li">&quot;ccdd&quot;</span> we get a couple of syntax
  trees:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  ~/LEyapp/examples/eyapplanguageref$ ./use_list3.pl
  Try input 'ccdd': ccdd
  $VAR1 = bless( {
    'children' =&gt; [
      bless( { 'children' =&gt; [], 'attr' =&gt; 'c', 'token' =&gt; 'c' }, 'TERMINAL' ),
      bless( { 'children' =&gt; [], 'attr' =&gt; 'c', 'token' =&gt; 'c' }, 'TERMINAL' )
    ]
  }, '_PLUS_LIST' );
  $VAR1 = bless( { 'children' =&gt; [] }, '_PLUS_LIST' );
</pre>
<p class="Pp">The node associated with the list of
    <span class="Li">&quot;d&quot;</span>s is empty since terminal
    <span class="Li">&quot;d&quot;</span> wasn't declared semantic.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="When_Nodes_Disappear_from_Lists"><a class="permalink" href="#When_Nodes_Disappear_from_Lists">When
  Nodes Disappear from Lists</a></h2>
When under the influence of the <span class="Li">%tree</span> directive the
  action associated with a list operator is to <i>flat</i> the children in a
  single list.
<p class="Pp">In the former example, the <span class="Li">&quot;d&quot;</span>
    nodes don't show up since <span class="Li">'d'</span> is a syntactic token.
    However, it may happen that changing the status of
    <span class="Li">'d'</span> to semantic will not suffice.</p>
<p class="Pp">When inserting the children, the tree
    (<span class="Li">%tree</span>) node construction method
    (<span class="Li">&quot;YYBuildAST&quot;</span>) omits any attribute that is
    not a reference. Therefore, when inserting explicit actions, it is necessary
    to guarantee that the returned value is a reference or a semantic token to
    assure the presence of the value in the lists of children of the node.
    Certainly you can use this property to prune parts of the tree. Consider the
    following example:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  ~/LEyapp/examples/eyapplanguageref$ cat ListWithRefs1.eyp 
  %semantic token 'c' 'd'
  %{
  use Data::Dumper;
  $Data::Dumper::Indent = 1;
  %}
  %%
  S:      'c'+  D+ 
             { 
                print Dumper($_[1]);
                print $_[1]-&gt;str.&quot;\n&quot;;
                print Dumper($_[2]);
                print $_[2]-&gt;str.&quot;\n&quot;;
             } 
  ;

  D: 'd'
  ;

  %%

  sub Run {
    my ($self) = shift;
    return $self-&gt;YYParse( yybuildingtree =&gt; 1 );
  }
</pre>
<p class="Pp">To activate the <i>tree semantic</i> for lists we use the
    <span class="Li">&quot;yybuildingtree&quot;</span> option of
    <span class="Li">&quot;YYParse&quot;</span> (line 26).</p>
<p class="Pp">The execution gives an output like this:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  pl@nereida:~/LEyapp/examples/eyapplanguageref$ eyapp ListWithRefs1.eyp; ./use_listwithrefs1.pl
  Try input 'ccdd': ccdd
  $VAR1 = bless( {
    'children' =&gt; [
      bless( { 'children' =&gt; [], 'attr' =&gt; 'c', 'token' =&gt; 'c' }, 'TERMINAL' ),
      bless( { 'children' =&gt; [], 'attr' =&gt; 'c', 'token' =&gt; 'c' }, 'TERMINAL' )
    ]
  }, '_PLUS_LIST' );
  _PLUS_LIST(TERMINAL,TERMINAL)
  $VAR1 = bless( { 'children' =&gt; [] }, '_PLUS_LIST' ); _PLUS_LIST
</pre>
<p class="Pp">Though <span class="Li">'d'</span> was declared semantic the
    default action associated with the production <span class="Li">&quot;D:
    'd'&quot;</span> in line 16 returns <span class="Li">$_[1]</span> (that is,
    the scalar <span class="Li">'d'</span>). Since it is not a reference it
    won't be inserted in the list of children of
    <span class="Li">&quot;_PLUS_LIST&quot;</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Recovering_the_Missing_Nodes"><a class="permalink" href="#Recovering_the_Missing_Nodes">Recovering
  the Missing Nodes</a></h2>
The solution is to be sure that the attribute is a reference:
<p class="Pp"><span class="Li"></span></p>
<pre>
  ~/LEyapp/examples/eyapplanguageref$ cat -n ListWithRefs.eyp
     1  %semantic token 'c' 
     2  %{
     3  use Data::Dumper;
     4  $Data::Dumper::Indent = 1;
     5  %}
     6  %%
     7  S:  'c'+  D+ 
     8        { 
     9           print Dumper($_[1]);
    10           print Dumper($_[2]);
    11        } 
    12  ;
    13  
    14  D: 'd'
    15       {
    16         bless { attr =&gt; $_[1], children =&gt;[]}, 'DES';
    17       }
    18  ;
    19  
    20  %%
    21  
    22  sub Run {
    23    my ($self) = shift;
    24    return $self-&gt;YYParse( yybuildingtree =&gt; 1 );
    25  }
</pre>
<p class="Pp">Now the attribute associated with
    <span class="Li">&quot;D&quot;</span> is a reference and appears in the list
    of children of <span class="Li">&quot;_PLUS_LIST&quot;</span>:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  ~/LEyapp/examples/eyapplanguageref$ eyapp ListWithRefs.eyp; ./use_listwithrefs.pl
  Try input 'ccdd': ccdd
  $VAR1 = bless( {
    'children' =&gt; [
      bless( { 'children' =&gt; [], 'attr' =&gt; 'c', 'token' =&gt; 'c' }, 'TERMINAL' ),
      bless( { 'children' =&gt; [], 'attr' =&gt; 'c', 'token' =&gt; 'c' }, 'TERMINAL' )
    ]
  }, '_PLUS_LIST' );
  $VAR1 = bless( {
    'children' =&gt; [
      bless( { 'children' =&gt; [], 'attr' =&gt; 'd' }, 'DES' ),
      bless( { 'children' =&gt; [], 'attr' =&gt; 'd' }, 'DES' )
    ]
  }, '_PLUS_LIST' );
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Building_a_Tree_with__Parse::Eyapp::Node_-_new_"><a class="permalink" href="#Building_a_Tree_with__Parse::Eyapp::Node_-_new_">Building
  a Tree with &quot;Parse::Eyapp::Node-&gt;new&quot;</a></h2>
The former solution consisting on writing <i>by hand</i> the code to build the
  node may suffice when dealing with a single node. Writing by hand the code to
  build a node is a cumbersome task. Even worst: though the node built in the
  former example looks like a <span class="Li">&quot;Parse::Eyapp&quot;</span>
  node actually isn't. <span class="Li">&quot;Parse::Eyapp&quot;</span> nodes
  always inherit from <span class="Li">&quot;Parse::Eyapp::Node&quot;</span> and
  consequently have access to the methods in such package. The following
  execution using the debugger illustrates the point:
<p class="Pp"><span class="Li"></span></p>
<pre>
  pl@nereida:~/LEyapp/examples$ perl -wd use_listwithrefs.pl

  Loading DB routines from perl5db.pl version 1.28
  Editor support available.

  Enter h or `h h' for help, or `man perldebug' for more help.

  main::(use_listwithrefs.pl:4):  $parser = new ListWithRefs();
    DB&lt;1&gt;  f ListWithRefs.eyp
  1       2       #line 3 &quot;ListWithRefs.eyp&quot;
  3
  4:      use Data::Dumper;
  5
  6       #line 7 &quot;ListWithRefs.eyp&quot;
  7       #line 8 &quot;ListWithRefs.eyp&quot;
  8
  9:                    print Dumper($_[1]);
  10:                   print $_[1]-&gt;str.&quot;\n&quot;;
</pre>
<p class="Pp">through the command <span class="Li">&quot;f
    ListWithRefs.eyp&quot;</span> we inform the debugger that subsequent
    commands will refer to such file. Next we execute the program up to the
    semantic action associated with the production rule
    <span class="Li">&quot;S: 'c'+ D+&quot;</span> (line 9)</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    DB&lt;2&gt; c 9     # Continue up to line 9 of ListWithRefs.eyp
  ccdd
  ListWithRefs::CODE(0x84ebe5c)(ListWithRefs.eyp:9):
  9:                    print Dumper($_[1]);
</pre>
<p class="Pp">Now we are in condition to look at the contents of the
  arguments:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    DB&lt;3&gt; x $_[2]-&gt;str
  0  '_PLUS_LIST_2(DES,DES)'
    DB&lt;4&gt; x $_[2]-&gt;child(0)
  0  DES=HASH(0x85c4568)
     'attr' =&gt; 'd'
     'children' =&gt; ARRAY(0x85c458c)
          empty array
</pre>
<p class="Pp">the <span class="Li">&quot;str&quot;</span> method works with the
    object <span class="Li">$_[2]</span> since
    <span class="Li">&quot;_PLUS_LIST_2&quot;</span> nodes inherit from
    <span class="Li">&quot;Parse::Eyapp::Node&quot;</span>. However, when we try
    with the <span class="Li">&quot;DES&quot;</span> node we get an error:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    DB&lt;6&gt; x $_[2]-&gt;child(0)-&gt;str
  Can't locate object method &quot;str&quot; via package &quot;DES&quot; at \
    (eval 11)[/usr/share/perl/5.8/perl5db.pl:628] line 2, &lt;STDIN&gt; line 1.
    DB&lt;7&gt;
</pre>
<p class="Pp">More robust than the former solution of building the node <i>by
    hand</i> is to use the constructor
    <span class="Li">&quot;Parse::Eyapp::Node-&gt;new&quot;</span>: The method
    <span class="Li">&quot;Parse::Eyapp::Node-&gt;new&quot;</span> is uset to
    build forests of syntactic trees.</p>
<p class="Pp">It receives a list of terms describing the trees and - optionally
    - a reference to a subroutine used to set up the attributes of the just
    created nodes. After the creation of the trees the sub is called by
    <span class="Li">&quot;Parse::Eyapp::Node-&gt;new&quot;</span> with
    arguments the list of references to the nodes (in the order in which they
    appear in the terms, from left to right).
    <span class="Li">&quot;Parse::Eyapp::Node-&gt;new&quot;</span> returns a
    list of references to the just created nodes. In a scalar context returns a
    reference to the first of such trees. See an example:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  ~/LEyapp/examples$ perl -MParse::Eyapp -MData::Dumper -wde 0
  main::(-e:1):   0
    DB&lt;1&gt; @t = Parse::Eyapp::Node-&gt;new('A(C,D) E(F)', sub { my $i = 0; $_-&gt;{n} = $i++ for @_ })
    DB&lt;2&gt; $Data::Dumper::Indent = 0
    DB&lt;3&gt; print Dumper($_).&quot;\n&quot; for @t
  $VAR1 = bless( {'n' =&gt; 0,'children' =&gt; [bless( {'n' =&gt; 1,'children' =&gt; []}, 'C' ),
                                          bless( {'n' =&gt; 2,'children' =&gt; []}, 'D' )
                                         ]
                 }, 'A' );
  $VAR1 = bless( {'n' =&gt; 1,'children' =&gt; []}, 'C' );
  $VAR1 = bless( {'n' =&gt; 2,'children' =&gt; []}, 'D' );
  $VAR1 = bless( {'n' =&gt; 3,'children' =&gt; [bless( {'n' =&gt; 4,'children' =&gt; []}, 'F' )]}, 'E' );
  $VAR1 = bless( {'n' =&gt; 4,'children' =&gt; []}, 'F' );
</pre>
<p class="Pp">See the following example in which the nodes associated with
    <span class="Li">'d'</span> are explicitly constructed:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  ~/LEyapp/examples/eyapplanguageref$ cat -n ListWithRefs2.eyp 
     1  %semantic token 'c' 
     2  %{
     3  use Data::Dumper;
     4  $Data::Dumper::Indent = 1;
     5  %}
     6  %%
     7  S:      'c'+  D+ 
     8             { 
     9                print Dumper($_[1]);
    10                print $_[1]-&gt;str.&quot;\n&quot;;
    11                print Dumper($_[2]);
    12                print $_[2]-&gt;str.&quot;\n&quot;;
    13             } 
    14  ;
    15  
    16  D: 'd'.d
    17       {
    18         Parse::Eyapp::Node-&gt;new(
    19           'DES(TERMINAL)', 
    20            sub { 
    21              my ($DES, $TERMINAL) = @_;
    22              $TERMINAL-&gt;{attr} = $d;
    23            }
    24         );
    25       }
    26  ;
    27  
    28  %%
    29  
    30  sub Run {
    31    my ($self) = shift;
    32    return $self-&gt;YYParse( yybuildingtree =&gt; 1 );
    33  }
</pre>
<p class="Pp">To know more about
    <span class="Li">&quot;Parse::Eyapp::Node-&gt;new&quot;</span> see the
    section for
  <span class="Li">&quot;Parse::Eyapp::Node-&gt;new&quot;</span></p>
<p class="Pp">When the former eyapp program is executed produces the following
    output:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  $ eyapp ListWithRefs2.eyp; use_listwithrefs2.pl
  ccdd
  $VAR1 = bless( {
    'children' =&gt; [
      bless( { 'children' =&gt; [], 'attr' =&gt; 'c', 'token' =&gt; 'c' }, 'TERMINAL' ),
      bless( { 'children' =&gt; [], 'attr' =&gt; 'c', 'token' =&gt; 'c' }, 'TERMINAL' )
    ]
  }, '_PLUS_LIST_1' );
  _PLUS_LIST_1(TERMINAL,TERMINAL)
  $VAR1 = bless( {
    'children' =&gt; [
      bless( {
        'children' =&gt; [
          bless( { 'children' =&gt; [], 'attr' =&gt; 'd' }, 'TERMINAL' )
        ]
      }, 'DES' ),
      bless( {
        'children' =&gt; [
          bless( { 'children' =&gt; [], 'attr' =&gt; 'd' }, 'TERMINAL' )
        ]
      }, 'DES' )
    ]
  }, '_PLUS_LIST_2' );
  _PLUS_LIST_2(DES(TERMINAL),DES(TERMINAL))
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="The__*__operator"><a class="permalink" href="#The__*__operator">The
  &quot;*&quot; operator</a></h2>
Any list operator operates on the factor to its left. A list in the right hand
  side of a production rule counts as a single symbol.
<p class="Pp">Both operators <span class="Li">&quot;*&quot;</span> and
    <span class="Li">&quot;+&quot;</span> can be used with the format
    <span class="Li">&quot;X &lt;* Separator&gt;&quot;</span>. In such case they
    describe lists of <span class="Li">&quot;X&quot;</span>s separated by
    <span class="Li">&quot;separator&quot;</span>. See an example:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  pl@nereida:~/LEyapp/examples$ head -25 CsBetweenCommansAndD.eyp | cat -n
   1  # CsBetweenCommansAndD.eyp
   2
   3  %semantic token 'c' 'd'
   4
   5  %{
   6  sub TERMINAL::info {
   7    $_[0]-&gt;attr;
   8  }
   9  %}
  10  %tree
  11  %%
  12  S:
  13      ('c' &lt;* ','&gt; 'd')*
  14        {
  15           print &quot;\nNode\n&quot;;
  16           print $_[1]-&gt;str.&quot;\n&quot;;
  17           print &quot;\nChild 0\n&quot;;
  18           print $_[1]-&gt;child(0)-&gt;str.&quot;\n&quot;;
  19           print &quot;\nChild 1\n&quot;;
  20           print $_[1]-&gt;child(1)-&gt;str.&quot;\n&quot;;
  21           $_[1]
  22        }
  23  ;
  24
  25  %%
</pre>
<p class="Pp">The rule</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
                            S: ('c' &lt;* ','&gt; 'd')*
</pre>
<p class="Pp">has only two items in its right hand side: the (separated by
    commas) list of <span class="Li">&quot;c&quot;</span>s and the list of
    <span class="Li">&quot;d&quot;</span>s. The production rule is equivalent
    to:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  pl@nereida:~/LEyapp/examples$ eyapp -v CsBetweenCommansAndD.eyp
  pl@nereida:~/LEyapp/examples$ head -11 CsBetweenCommansAndD.output | cat -n
   1  Rules:
   2  ------
   3  0:      $start -&gt; S $end
   4  1:      STAR-1 -&gt; STAR-1 ',' 'c'
   5  2:      STAR-1 -&gt; 'c'
   6  3:      STAR-2 -&gt; STAR-1
   7  4:      STAR-2 -&gt; /* empty */
   8  5:      PAREN-3 -&gt; STAR-2 'd'
   9  6:      STAR-4 -&gt; STAR-4 PAREN-3
  10  7:      STAR-4 -&gt; /* empty */
  11  8:      S -&gt; STAR-4
</pre>
<p class="Pp">The semantic action associated with
    <span class="Li">&quot;*&quot;</span> is to return a reference to a list
    with the attributes of the matching items.</p>
<p class="Pp">When working -as in the example - under a tree creation directive
    it returns a node belonging to a class named
    <span class="Li">&quot;_STAR_LIST_#number&quot;</span> whose children are
    the items in the list. The <span class="Li">&quot;#number&quot;</span> is
    the ordinal number of the production rule as it appears in the
    <span class="Li">&quot;.output&quot;</span> file. The attributes must be
    references or associated with semantic tokens to be included in the list.
    Notice -in the execution of the former example that follows - how the node
    for <span class="Li">&quot;PAREN-3&quot;</span> has been eliminated from the
    tree. Parenthesis nodes are - generally - obviated:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  pl@nereida:~/LEyapp/examples$ use_csbetweencommansandd.pl
  c,c,cd

  Node
  _STAR_LIST_4(_STAR_LIST_1(TERMINAL[c],TERMINAL[c],TERMINAL[c]),TERMINAL[d])

  Child 0
  _STAR_LIST_1(TERMINAL[c],TERMINAL[c],TERMINAL[c])

  Child 1
  TERMINAL[d]
</pre>
<p class="Pp">Notice that the comma (since it is a syntactic token) has also
    been suppressed.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Giving_Names_to_Lists"><a class="permalink" href="#Giving_Names_to_Lists">Giving
  Names to Lists</a></h2>
To set the name of the node associated with a list operator the
  <span class="Li">%name</span> directive must precede the operator as in the
  following example:
<p class="Pp"><span class="Li"></span></p>
<pre>
  pl@nereida:~/LEyapp/examples/eyapplanguageref$ sed -ne '1,27p' CsBetweenCommansAndDWithNames.eyp | cat -n
   1  # CsBetweenCommansAndDWithNames.eyp
   2
   3  %semantic token 'c' 'd'
   4
   5  %{
   6  sub TERMINAL::info {
   7    $_[0]-&gt;attr;
   8  }
   9  %}
  10  %tree
  11  %%
  12  Start: S
  13  ;
  14  S:
  15      ('c' &lt;%name Cs * ','&gt; 'd') %name Cs_and_d *
  16        {
  17           print &quot;\nNode\n&quot;;
  18           print $_[1]-&gt;str.&quot;\n&quot;;
  19           print &quot;\nChild 0\n&quot;;
  20           print $_[1]-&gt;child(0)-&gt;str.&quot;\n&quot;;
  21           print &quot;\nChild 1\n&quot;;
  22           print $_[1]-&gt;child(1)-&gt;str.&quot;\n&quot;;
  23           $_[1]
  24        }
  25  ;
  26
  27  %%
</pre>
<p class="Pp">The grammar describes the language of sequences</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
                  c,...,cd c,...,cd c,...,cd ....
</pre>
<p class="Pp">The right hand side of the production has only one term which is a
    list, but the factor to which the star applies is itself a list. We are
    naming the term with the name <span class="Li">&quot;Cs_and_d&quot;</span>
    and the factor with the name <span class="Li">&quot;Cs&quot;</span>.</p>
<p class="Pp">The execution shows the renamed nodes:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  pl@nereida:~/LEyapp/examples/eyapplanguageref$ use_csbetweencommansanddwithnames.pl
  c,c,c,cd

  Node
  Cs_and_d(Cs(TERMINAL[c],TERMINAL[c],TERMINAL[c],TERMINAL[c]),TERMINAL[d])

  Child 0
  Cs(TERMINAL[c],TERMINAL[c],TERMINAL[c],TERMINAL[c])

  Child 1
  TERMINAL[d]
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Optionals"><a class="permalink" href="#Optionals">Optionals</a></h2>
The <span class="Li">&quot;X?&quot;</span> operator stands for the presence or
  omission of <span class="Li">&quot;X&quot;</span>.
<p class="Pp">The grammar:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  pl@nereida:~/LEyapp/examples$ head -11 List5.yp | cat -n
       1  %semantic token 'c'
       2  %tree
       3  %%
       4  S: 'c' 'c'?
       5       {
       6         print $_[2]-&gt;str.&quot;\n&quot;;
       7         print $_[2]-&gt;child(0)-&gt;attr.&quot;\n&quot; if $_[2]-&gt;children;
       8      }
       9  ;
      10
      11  %%
</pre>
<p class="Pp">is equivalent to:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  pl@nereida:~/LEyapp/examples$ eyapp -v List5
  pl@nereida:~/LEyapp/examples$ head -7 List5.output
  Rules:
  ------
  0:      $start -&gt; S $end
  1:      OPTIONAL-1 -&gt; 'c'
  2:      OPTIONAL-1 -&gt; /* empty */
  3:      S -&gt; 'c' OPTIONAL-1
</pre>
<p class="Pp">When <span class="Li">&quot;yybuildingtree&quot;</span> is false
    the associated attribute is a list that will be empty if CX&gt; does not
    show up.</p>
<p class="Pp">Under the <span class="Li">%tree</span> directive the action
    creates an <span class="Li">&quot;_OPTIONAL&quot;</span> node:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  pl@nereida:~/LEyapp/examples$ use_list5.pl
  cc
  _OPTIONAL_1(TERMINAL)
  c
  pl@nereida:~/LEyapp/examples$ use_list5.pl
  c
  _OPTIONAL_1
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Parenthesis"><a class="permalink" href="#Parenthesis">Parenthesis</a></h2>
Any substring on the right hand side of a production rule can be grouped using a
  parenthesis. The introduction of a parenthesis implies the introduction of an
  additional syntactic variable whose only production is the sequence of symbols
  between the parenthesis. Thus the grammar:
<p class="Pp"><span class="Li"></span></p>
<pre>
  pl@nereida:~/LEyapp/examples$ head -6 Parenthesis.eyp | cat -n
     1  %%
     2  S:
     3        ('a' S ) 'b'  { shift; [ @_ ] }
     4      | 'c'
     5  ;
     6  %%
</pre>
<p class="Pp">is equivalent to:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  pl@nereida:~/LEyapp/examples$ eyapp -v Parenthesis.eyp; head -6 Parenthesis.output
  Rules:
  ------
  0:      $start -&gt; S $end
  1:      PAREN-1 -&gt; 'a' S
  2:      S -&gt; PAREN-1 'b'
  3:      S -&gt; 'c'
</pre>
<p class="Pp">By default the semantic rule associated with a parenthesis returns
    an anonymous list with the attributes of the symbols between the
    parenthesis:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  pl@nereida:~/LEyapp/examples$ cat -n use_parenthesis.pl
       1  #!/usr/bin/perl -w
       2  use Parenthesis;
       3  use Data::Dumper;
       4
       5  $Data::Dumper::Indent = 1;
       6  $parser = Parenthesis-&gt;new();
       7  print Dumper($parser-&gt;Run);
  pl@nereida:~/LEyapp/examples$ use_parenthesis.pl
  acb
  $VAR1 = [
    [ 'a', 'c' ], 'b'
  ];
  pl@nereida:~/LEyapp/examples$ use_parenthesis.pl
  aacbb
  $VAR1 = [
    [
      'a',
      [ [ 'a', 'c' ], 'b' ]
    ],
    'b'
  ];
</pre>
<p class="Pp">when working under a tree directive or when the attribute
    <span class="Li">&quot;buildingtree&quot;</span> is set via the
    <span class="Li">&quot;YYBuildingtree&quot;</span> method the semantic
    action returns a node with children the attributes of the symbols between
    parenthesis. As usual attributes which aren't references will be skipped
    from the list of children. See an example:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  pl@nereida:~/LEyapp/examples$ head -23 List2.yp | cat -n
   1  %{
   2  use Data::Dumper;
   3  %}
   4  %semantic token 'a' 'b' 'c'
   5  %tree
   6  %%
   7  S:
   8        (%name AS 'a' S )'b'
   9          {
  10            print &quot;S -&gt; ('a' S )'b'\n&quot;;
  11            print &quot;Attribute of the first symbol:\n&quot;.Dumper($_[1]);
  12            print &quot;Attribute of the second symbol: $_[2]\n&quot;;
  13            $_[0]-&gt;YYBuildAST(@_[1..$#_]);
  14          }
  15      | 'c'
  16          {
  17            print &quot;S -&gt; 'c'\n&quot;;
  18            my $r = Parse::Eyapp::Node-&gt;new(qw(C(TERMINAL)), sub { $_[1]-&gt;attr('c') }) ;
  19            print Dumper($r);
  20            $r;
  21          }
  22  ;
  23  %%
</pre>
<p class="Pp">The example shows (line 8) how to rename a
    <span class="Li">&quot;_PAREN&quot;</span> node. The
    <span class="Li">&quot;%name CLASSNAME&quot;</span> goes after the opening
    parenthesis.</p>
<p class="Pp">The call to <span class="Li">&quot;YYBuildAST&quot;</span> at line
    13 with argumetns the attributes of the symbols on the right hand side
    returns the node describing the current production rule. Notice that line 13
    can be rewritten as:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
                    goto &amp;Parse::Eyapp::Driver::YYBuildAST;
</pre>
<p class="Pp">At line 18 the node for the rule is explicitly created using
    <span class="Li">&quot;Parse::Eyapp::Node-&gt;new&quot;</span>. The handler
    passed as second argument is responsible for setting the value of the
    atribute <span class="Li">&quot;attr&quot;</span> of the just created
    <span class="Li">&quot;TERMINAL&quot;</span> node.</p>
<p class="Pp">Let us see an execution:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  pl@nereida:~/LEyapp/examples$ use_list2.pl
  aacbb
  S -&gt; 'c'
  $VAR1 = bless( {
    'children' =&gt; [
      bless( {
        'children' =&gt; [],
        'attr' =&gt; 'c'
      }, 'TERMINAL' )
    ]
  }, 'C' );
</pre>
<p class="Pp">the first reduction occurs by the non recursive rule. The
    execution shows the tree built by the call to
    <span class="Li">&quot;Parse::Eyapp::Node-&quot;</span>new&gt; at line
  18.</p>
<p class="Pp">The execution continues with the reduction or reverse derivation
    by the rule <span class="Li">&quot;S -&gt; ('a' S )'b'&quot;</span>. The
    action at lines 9-14 dumps the attribute associated with
    <span class="Li">&quot;('a' S)&quot;</span> - or, in other words, the
    attribute associated with the variable
    <span class="Li">&quot;PAREN-1&quot;</span>. It also dumps the attribute of
    <span class="Li">'b'</span>:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  S -&gt; ('a' S )'b'
  Attribute of the first symbol:
  $VAR1 = bless( {
      'children' =&gt; [
        bless( { 'children' =&gt; [], 'attr' =&gt; 'a', 'token' =&gt; 'a' }, 'TERMINAL' ),
        bless( { 'children' =&gt; [ bless( { 'children' =&gt; [], 'attr' =&gt; 'c' }, 'TERMINAL' )
       ]
     }, 'C' )
    ]
  }, 'AS' );
Attribute of the second symbol: b
</pre>
<p class="Pp">The last reduction shown is by the rule: <span class="Li">&quot;S
    -&gt; ('a' S )'b'&quot;</span>:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  S -&gt; ('a' S )'b'
  Attribute of the first symbol:
  $VAR1 = bless( {
    'children' =&gt; [
      bless( { 'children' =&gt; [], 'attr' =&gt; 'a', 'token' =&gt; 'a' }, 'TERMINAL' ),
      bless( {
        'children' =&gt; [
          bless( {
            'children' =&gt; [
              bless( { 'children' =&gt; [], 'attr' =&gt; 'a', 'token' =&gt; 'a' }, 'TERMINAL' ),
              bless( {
                'children' =&gt; [
                  bless( { 'children' =&gt; [], 'attr' =&gt; 'c' }, 'TERMINAL' )
                ]
              }, 'C' )
            ]
          }, 'AS' ),
          bless( { 'children' =&gt; [], 'attr' =&gt; 'b', 'token' =&gt; 'b' }, 'TERMINAL' )
        ]
      }, 'S_2' )
    ]
  }, 'AS' );
  Attribute of the second symbol: b
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Actions_Inside_Parenthesis"><a class="permalink" href="#Actions_Inside_Parenthesis">Actions
  Inside Parenthesis</a></h2>
Though is a practice to avoid, since it clutters the code, it is certainly
  permitted to introduce actions between the parenthesis, as in the example
  below:
<p class="Pp"><span class="Li"></span></p>
<pre>
  pl@nereida:~/LEyapp/examples$ head -16 ListAndAction.eyp | cat -n
   1  # ListAndAction.eyp
   2  %{
   3  my $num = 0;
   4  %}
   5
   6  %%
   7  S:      'c'
   8              {
   9                print &quot;S -&gt; c\n&quot;
  10              }
  11      |    ('a' {$num++; print &quot;Seen &lt;$num&gt; 'a's\n&quot;; $_[1] }) S 'b'
  12              {
  13                print &quot;S -&gt; (a ) S b\n&quot;
  14              }
  15  ;
  16  %%
</pre>
<p class="Pp">This is the output when executing this program with input
    <span class="Li">&quot;aaacbbb&quot;</span>:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  pl@nereida:~/LEyapp/examples$ use_listandaction.pl
  aaacbbb
  Seen &lt;1&gt; 'a's
  Seen &lt;2&gt; 'a's
  Seen &lt;3&gt; 'a's
  S -&gt; c
  S -&gt; (a ) S b
  S -&gt; (a ) S b
  S -&gt; (a ) S b
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="NAMES_FOR_ATTRIBUTES"><a class="permalink" href="#NAMES_FOR_ATTRIBUTES">NAMES
  FOR ATTRIBUTES</a></h1>
Attributes can be referenced by meaningful names using the <i>dot notation</i>
  instead of using the classic error-prone positional approach:
<p class="Pp"><span class="Li"></span></p>
<pre>
                        rhs:  rhseltwithid *
                        rhseltwithid : 
                              rhselt '.' IDENT 
                            | '$' rhselt  
                            | rhselt
</pre>
<p class="Pp">for example:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
              exp : exp.left '-' exp.right  { $left - $right }
</pre>
<p class="Pp">By qualifying the first appearance of the syntactic variable
    <span class="Li">&quot;exp&quot;</span> with the notation
    <span class="Li">&quot;exp.left&quot;</span> we can later refer inside the
    actions to the associated attribute using the lexical variable
    <span class="Li">$left</span>.</p>
<p class="Pp">The <i>dollar notation</i> <span class="Li">$A</span> can be used
    as an abbreviation of <span class="Li">&quot;A.A&quot;</span>.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DEFAULT_ACTIONS"><a class="permalink" href="#DEFAULT_ACTIONS">DEFAULT
  ACTIONS</a></h1>
When no action is specified both <span class="Li">&quot;yapp&quot;</span> and
  <span class="Li">&quot;eyapp&quot;</span> implicitly insert the semantic
  action <span class="Li">&quot;{ $_[1] }&quot;</span>. In
  <span class="Li">&quot;Parse::Eyapp&quot;</span> you can modify such behavior
  using the <span class="Li">&quot;%defaultaction { Perl code }&quot;</span>
  directive. The <span class="Li">&quot;{ Perl code }&quot;</span> clause that
  follows the <span class="Li">%defaultaction</span> directive is executed when
  reducing by any production for which no explicit action was specified.
<section class="Ss">
<h2 class="Ss" id="An_Example_of_Default_Action:_Translator_from_Infix_to_Postfix"><a class="permalink" href="#An_Example_of_Default_Action:_Translator_from_Infix_to_Postfix">An
  Example of Default Action: Translator from Infix to Postfix</a></h2>
See an example that translates an infix expression like
  <span class="Li">&quot;a=b*-3&quot;</span> into a postfix expression like
  <span class="Li">&quot;a b 3 NEG * = &quot;</span>:
<p class="Pp"><span class="Li"></span></p>
<pre>
 # File Postfix.eyp (See the examples/ directory)
 %right  '='
 %left   '-' '+'
 %left   '*' '/'
 %left   NEG

 %defaultaction { return  &quot;$left $right $op&quot;; }

 %%
 line: $exp  { print &quot;$exp\n&quot; }
 ;

 exp:        $NUM  { $NUM }
         |   $VAR  { $VAR }
         |   VAR.left '='.op exp.right
         |   exp.left '+'.op exp.right
         |   exp.left '-'.op exp.right
         |   exp.left '*'.op exp.right
         |   exp.left '/'.op exp.right
         |   '-' $exp %prec NEG { &quot;$exp NEG&quot; }
         |   '(' $exp ')' { $exp }
 ;

 %%

 # Support subroutines as in the Synopsis example
 ...
</pre>
<p class="Pp">The file containing the <span class="Li">&quot;Eyapp&quot;</span>
    program must be compiled with <span class="Li">&quot;eyapp&quot;</span>:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
 nereida:~/src/perl/YappWithDefaultAction/examples&gt; eyapp Postfix.eyp
</pre>
<p class="Pp">Next, you have to write a client program:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
 nereida:~/src/perl/YappWithDefaultAction/examples&gt; cat -n usepostfix.pl
      1  #!/usr/bin/perl -w
      2  use strict;
      3  use Postfix;
      4
      5  my $parser = new Postfix();
      6  $parser-&gt;Run;
</pre>
<p class="Pp">Now we can run the client program:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
 nereida:~/src/perl/YappWithDefaultAction/examples&gt; usepostfix.pl
 Write an expression: -(2*a-b*-3)
 2 a * b 3 NEG * - NEG
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Default_Actions,__name_and__YYName_"><a class="permalink" href="#Default_Actions,__name_and__YYName_">Default
  Actions, %name and &quot;YYName&quot;</a></h2>
In <span class="Li">&quot;eyapp&quot;</span> each production rule has a name.
  The name of a rule can be explicitly given by the programmer using the
  <span class="Li">%name</span> directive. For example, in the piece of code
  that follows the name <span class="Li">&quot;ASSIGN&quot;</span> is given to
  the rule <span class="Li">&quot;exp: VAR '=' exp&quot;</span>.
<p class="Pp">When no explicit name is given the rule has an implicit name. The
    implicit name of a rule is shaped by concatenating the name of the syntactic
    variable on its left, an underscore and the ordinal number of the production
    rule <span class="Li">&quot;Lhs_#&quot;</span> as it appears in the
    <span class="Li">&quot;.output&quot;</span> file. Avoid giving names
    matching such pattern to production rules. The patterns
    <span class="Li">&quot;/${lhs}_\d+$/&quot;</span> where
    <span class="Li">&quot;${lhs}&quot;</span> is the name of the syntactic
    variable are reserved for internal use by
    <span class="Li">&quot;eyapp&quot;</span>.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  pl@nereida:~/LEyapp/examples$ cat -n Lhs.eyp
   1  # Lhs.eyp
   2
   3  %right  '='
   4  %left   '-' '+'
   5  %left   '*' '/'
   6  %left   NEG
   7
   8  %defaultaction {
   9    my $self = shift;
  10    my $name = $self-&gt;YYName();
  11    bless { children =&gt; [ grep {ref($_)} @_] }, $name;
  12  }
  13
  14  %%
  15  input:
  16              /* empty */
  17                { [] }
  18          |   input line
  19                {
  20                  push @{$_[1]}, $_[2] if defined($_[2]);
  21                  $_[1]
  22                }
  23  ;
  24
  25  line:     '\n'       { }
  26          | exp '\n'   {  $_[1] }
  27  ;
  28
  29  exp:
  30              NUM   { $_[1] }
  31          |   VAR   { $_[1] }
  32          |   %name ASSIGN
  33              VAR '=' exp
  34          |   %name PLUS
  35              exp '+' exp
  36          |   %name MINUS
  37              exp '-' exp
  38          |   %name TIMES
  39              exp '*' exp
  40          |   %name DIV
  41              exp '/' exp
  42          |   %name UMINUS
  43              '-' exp %prec NEG
  44          |  '(' exp ')'  { $_[2] }
  45  ;
</pre>
<p class="Pp">Inside a semantic action the name of the current rule can be
    recovered using the method <span class="Li">&quot;YYName&quot;</span> of the
    parser object.</p>
<p class="Pp">The default action (lines 8-12) computes as attribute of the left
    hand side a reference to an object blessed in the name of the rule. The
    object has an attribute <span class="Li">&quot;children&quot;</span> which
    is a reference to the list of children of the node. The call to
    <span class="Li">&quot;grep&quot;</span></p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  11    bless { children =&gt; [ grep {ref($_)} @_] }, $name;
</pre>
<p class="Pp">excludes children that aren't references. Notice that the lexical
    analyzer only returns references for the
    <span class="Li">&quot;NUM&quot;</span> and
    <span class="Li">&quot;VAR&quot;</span> terminals:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  59  sub _Lexer {
  60      my($parser)=shift;
  61
  62      for ($parser-&gt;YYData-&gt;{INPUT}) {
  63          s/^[ \t]+//;
  64          return('',undef) unless $_;
  65          s/^([0-9]+(?:\.[0-9]+)?)//
  66                  and return('NUM', bless { attr =&gt; $1}, 'NUM');
  67          s/^([A-Za-z][A-Za-z0-9_]*)//
  68                  and return('VAR',bless {attr =&gt; $1}, 'VAR');
  69          s/^(.)//s
  70                  and return($1, $1);
  71      }
  72      return('',undef);
  73  }
</pre>
<p class="Pp">follows the client program:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  pl@nereida:~/LEyapp/examples$ cat -n uselhs.pl
       1  #!/usr/bin/perl -w
       2  use Lhs;
       3  use Data::Dumper;
       4
       5  $parser = new Lhs();
       6  my $tree = $parser-&gt;Run;
       7  $Data::Dumper::Indent = 1;
       8  if (defined($tree)) { print Dumper($tree); }
       9  else { print &quot;Cadena no valida\n&quot;; }
</pre>
<p class="Pp">When executed with input
    <span class="Li">&quot;a=(2+3)*b&quot;</span> the parser produces the
    following tree:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  ASSIGN(TIMES(PLUS(NUM[2],NUM[3]), VAR[b]))
</pre>
<p class="Pp">See the result of an execution:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  pl@nereida:~/LEyapp/examples$ uselhs.pl
  a=(2+3)*b
  $VAR1 = [
    bless( {
      'children' =&gt; [
        bless( { 'attr' =&gt; 'a' }, 'VAR' ),
        bless( {
          'children' =&gt; [
            bless( {
              'children' =&gt; [
                bless( { 'attr' =&gt; '2' }, 'NUM' ),
                bless( { 'attr' =&gt; '3' }, 'NUM' )
              ]
            }, 'PLUS' ),
            bless( { 'attr' =&gt; 'b' }, 'VAR' )
          ]
        }, 'TIMES' )
      ]
    }, 'ASSIGN' )
  ];
</pre>
<p class="Pp">The name of a production rule can be changed at execution time.
    See the following example:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  $ sed -n '29,50p' YYNameDynamic.eyp | cat -n
     1  exp:
     2              NUM   { $_[1] }
     3          |   VAR   { $_[1] }
     4          |   %name ASSIGN
     5              VAR '=' exp
     6          |   %name PLUS
     7              exp '+' exp
     8          |   %name MINUS
     9              exp '-' exp
    10                {
    11                  my $self = shift;
    12                  $self-&gt;YYName('SUBTRACT'); # rename it
    13                  $self-&gt;YYBuildAST(@_); # build the node
    14                }
    15          |   %name TIMES
    16              exp '*' exp
    17          |   %name DIV
    18              exp '/' exp
    19          |   %name UMINUS
    20              '-' exp %prec NEG
    21          |  '(' exp ')'  { $_[2] }
    22  ;
</pre>
<p class="Pp">When the client program is executed we can see the presence of the
    <span class="Li">&quot;SUBTRACT&quot;</span> nodes:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  pl@nereida:~/LEyapp/examples$ useyynamedynamic.pl
  2-b
  $VAR1 = [
    bless( {
      'children' =&gt; [
        bless( {
          'attr' =&gt; '2'
        }, 'NUM' ),
        bless( {
          'attr' =&gt; 'b'
        }, 'VAR' )
      ]
    }, 'SUBTRACT' )
  ];
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="GRAMMAR_REUSE"><a class="permalink" href="#GRAMMAR_REUSE">GRAMMAR
  REUSE</a></h1>
<section class="Ss">
<h2 class="Ss" id="Reusing_Grammars_Using_Inheritance"><a class="permalink" href="#Reusing_Grammars_Using_Inheritance">Reusing
  Grammars Using Inheritance</a></h2>
An method to reuse a grammar is via inheritance. The client inherits the
  generated parser module and expands it with methods that inherit or overwrite
  the actions. Here is an example. Initially we have this Eyapp grammar:
<p class="Pp"><span class="Li"></span></p>
<pre>
  pl@europa:~/LEyapp/examples/recycle$ cat -n NoacInh.eyp
     1  %left   '+'
     2  %left   '*'
     3
     4  %defaultaction {
     5    my $self = shift;
     6
     7    my $action = $self-&gt;YYName;
     8
     9    $self-&gt;$action(@_);
    10  }
    11
    12  %%
    13  exp:        %name NUM
    14                NUM
    15          |   %name PLUS
    16                exp '+' exp
    17          |   %name TIMES
    18                exp '*' exp
    19          |   '(' exp ')'
    20                { $_[2] }
    21  ;
    22
    23  %%
    24
    25  sub _Error {
    26    my($token)=$_[0]-&gt;YYCurval;
    27    my($what)= $token ? &quot;input: '$token'&quot; : &quot;end of input&quot;;
    28    my @expected = $_[0]-&gt;YYExpect();
    29
    30    local $&quot; = ', ';
    31    die &quot;Syntax error near $what. Expected one of these tokens: @expected\n&quot;;
    32  }
    33
    34
    35  my $x = '';
    36
    37  sub _Lexer {
    38    my($parser)=shift;
    39
    40    for ($x) {
    41      s/^\s+//;
    42      $_ eq '' and return('',undef);
    43
    44      s/^([0-9]+(?:\.[0-9]+)?)//   and return('NUM',$1);
    45      s/^([A-Za-z][A-Za-z0-9_]*)// and return('VAR',$1);
    46      s/^(.)//s                    and return($1,$1);
    47    }
    48  }
    49
    50  sub Run {
    51    my($self)=shift;
    52    $x = shift;
    53    my $debug = shift;
    54
    55    $self-&gt;YYParse(
    56      yylex =&gt; \&amp;_Lexer,
    57      yyerror =&gt; \&amp;_Error,
    58      yydebug =&gt; $debug,
    59    );
    60  }
</pre>
<p class="Pp">The following program defines two classes:
    <span class="Li">&quot;CalcActions&quot;</span> that implements the actions
    for the calculator and package
    <span class="Li">&quot;PostActions&quot;</span> that implements the actions
    for the infix to postfix translation. This way we have an example that
    reuses the former grammar twice:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  pl@europa:~/LEyapp/examples/recycle$ cat -n icalcu_and_ipost.pl
     1  #!/usr/bin/perl -w
     2  package CalcActions;
     3  use strict;
     4  use base qw{NoacInh};
     5
     6  sub NUM {
     7    return $_[1];
     8  }
     9
    10  sub PLUS {
    11    $_[1]+$_[3];
    12  }
    13
    14  sub TIMES {
    15    $_[1]*$_[3];
    16  }
    17
    18  package PostActions;
    19  use strict;
    20  use base qw{NoacInh};
    21
    22  sub NUM {
    23    return $_[1];
    24  }
    25
    26  sub PLUS {
    27    &quot;$_[1] $_[3] +&quot;;
    28  }
    29
    30  sub TIMES {
    31    &quot;$_[1] $_[3] *&quot;;
    32  }
    33
    34  package main;
    35  use strict;
    36
    37  my $calcparser = CalcActions-&gt;new();
    38  print &quot;Write an expression: &quot;;
    39  my $x = &lt;STDIN&gt;;
    40  my $e = $calcparser-&gt;Run($x);
    41
    42  print &quot;$e\n&quot;;
    43
    44  my $postparser = PostActions-&gt;new();
    45  my $p = $postparser-&gt;Run($x);
    46
    47  print &quot;$p\n&quot;;
</pre>
<p class="Pp">The subroutine used as default action in
    <span class="Li">&quot;NoacInh.eyp&quot;</span> is so useful that is packed
    as the Parse::Eyapp::Driver method
    <span class="Li">&quot;YYDelegateaction&quot;</span>.</p>
<p class="Pp">See files
    <span class="Li">&quot;examples/recycle/NoacYYDelegateaction.eyp&quot;</span>
    and
    <span class="Li">&quot;examples/recycle/icalcu_and_ipost_yydel.pl&quot;</span>
    for an example of use of
    <span class="Li">&quot;YYDelegateaction&quot;</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Reusing_Grammars_by_Dynamic_Substitution_of_Semantic_Actions"><a class="permalink" href="#Reusing_Grammars_by_Dynamic_Substitution_of_Semantic_Actions">Reusing
  Grammars by Dynamic Substitution of Semantic Actions</a></h2>
The methods <span class="Li">&quot;YYSetaction&quot;</span> and
  <span class="Li">&quot;YYAction&quot;</span> of the parser object provide a
  way to selectively substitute some actions of a given grammar. Let us consider
  once more a postfix to infix translator:
<p class="Pp"><span class="Li"></span></p>
<pre>
  pl@europa:~/LEyapp/examples/recycle$ cat -n PostfixWithActions.eyp
     1  # File PostfixWithActions.eyp
     2  %right  '='
     3  %left   '-' '+'
     4  %left   '*' '/'
     5  %left   NEG
     6
     7  %%
     8  line: $exp  { print &quot;$exp\n&quot; }
     9  ;
    10
    11  exp:        $NUM
    12                  { $NUM }
    13          |   $VAR
    14                  { $VAR }
    15          |   %name ASSIGN
    16                VAR.left '='exp.right
    17                  { &quot;$_[3] &amp;$_[1] ASSIGN&quot;; }
    18          |   %name PLUS
    19                exp.left '+'exp.right
    20                  { &quot;$_[1] $_[3] PLUS&quot;; }
    21          |   %name MINUS
    22                exp.left '-'exp.right
    23                  { &quot;$_[1] $_[3] MINUS&quot;; }
    24          |   %name TIMES
    25                exp.left '*'exp.right
    26                  { &quot;$_[1] $_[3] TIMES&quot;; }
    27          |   %name DIV
    28                exp.left '/'exp.right
    29                  { &quot;$_[1] $_[3] DIV&quot;; }
    30          |   %name NEG '-' $exp %prec NEG
    31                  { &quot;$exp NEG&quot; }
    32          |   '(' $exp ')'
    33                  { $exp }
    34  ;
    35
    36  %%
    37
    38  sub _Error {
    39    my($token)=$_[0]-&gt;YYCurval;
    40    my($what)= $token ? &quot;input: '$token'&quot; : &quot;end of input&quot;;
    41    my @expected = $_[0]-&gt;YYExpect();
    42
    43    local $&quot; = ', ';
    44    die &quot;Syntax error near $what. Expected one of these tokens: @expected\n&quot;;
    45  }
    46
    47  my $x;
    48
    49  sub _Lexer {
    50    my($parser)=shift;
    51
    52    for ($x) {
    53      s/^\s+//;
    54      $_ eq '' and return('',undef);
    55
    56      s/^([0-9]+(?:\.[0-9]+)?)//   and return('NUM',$1);
    57      s/^([A-Za-z][A-Za-z0-9_]*)// and return('VAR',$1);
    58      s/^(.)//s                    and return($1,$1);
    59    }
    60  }
    61
    62  sub Run {
    63    my($self)=shift;
    64    $x = shift;
    65    $self-&gt;YYParse( yylex =&gt; \&amp;_Lexer, yyerror =&gt; \&amp;_Error,
    66      #yydebug =&gt; 0xFF
    67    );
    68  }
</pre>
<p class="Pp">The program
    <span class="Li">&quot;rewritepostfixwithactions.pl&quot;</span> uses the
    former grammar to translate infix expressions to postfix expressions. It
    also implements a calculator reusing the grammar in
    <span class="Li">&quot;PostfixWithActions.eyp&quot;</span>. It does so using
    the <span class="Li">&quot;YYSetaction&quot;</span> method. The semantic
    actions for the productions named</p>
<ul class="Bl-bullet">
  <li>ASSIGN</li>
  <li>PLUS</li>
  <li>TIMES</li>
  <li>DIV</li>
  <li>NEG</li>
</ul>
<p class="Pp">are selectively substituted by the appropriate actions, while the
    other semantic actions remain unchanged:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  pl@europa:~/LEyapp/examples/recycle$ cat -n rewritepostfixwithactions.pl
     1  #!/usr/bin/perl
     2  use warnings;
     3  use PostfixWithActions;
     4
     5  my $debug = shift || 0;
     6  my $pparser = PostfixWithActions-&gt;new();
     7  print &quot;Write an expression: &quot;;
     8  my $x = &lt;STDIN&gt;;
     9
    10  # First, trasnlate to postfix ...
    11  $pparser-&gt;Run($x, $debug);
    12
    13  # And then selectively substitute
    14  # some semantic actions
    15  # to obtain an infix calculator ...
    16  my %s;            # symbol table
    17  $pparser-&gt;YYSetaction(
    18    ASSIGN =&gt; sub { $s{$_[1]} = $_[3] },
    19    PLUS   =&gt; sub { $_[1] + $_[3] },
    20    TIMES  =&gt; sub { $_[1] * $_[3] },
    21    DIV    =&gt; sub { $_[1] / $_[3] },
    22    NEG    =&gt; sub { -$_[2] },
    23  );
    24
    25  $pparser-&gt;Run($x, $debug);
</pre>
<p class="Pp">When running this program the output is:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  examples/recycle$ ./rewritepostfixwithactions.pl
  Write an expression: 2*3+4
  2 3 TIMES 4 PLUS
  10
  examples/recycle$ rewritepostfixwithactions.pl
  Write an expression: a = 2*(b = 3+5)
  2 3 5 PLUS &amp;b ASSIGN TIMES &amp;a ASSIGN
  16
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="ABSTRACT_SYNTAX_TREES:__tree_AND__name"><a class="permalink" href="#ABSTRACT_SYNTAX_TREES:__tree_AND__name">ABSTRACT
  SYNTAX TREES: %tree AND %name</a></h1>
<section class="Ss">
<h2 class="Ss" id="_tree_Default_Names"><a class="permalink" href="#_tree_Default_Names">%tree
  Default Names</a></h2>
<span class="Li">&quot;Parse::Eyapp&quot;</span> facilitates the construction of
  concrete syntax trees and abstract syntax trees (abbreviated AST from now on)
  through the <span class="Li">%tree</span> directive. Actually, the
  <span class="Li">%tree</span> directive is equivalent to a call to the
  <span class="Li">&quot;YYBuildAST&quot;</span> method of the parser object.
<p class="Pp">Any production production rule
    <span class="Li">&quot;A-&gt;XYZ&quot;</span> can be named using a directive
    <span class="Li">&quot;%name someclass&quot;</span>.</p>
<p class="Pp">When reducing by a production rule
    <span class="Li">&quot;A-&gt;XYZ&quot;</span> the
    <span class="Li">%tree</span> directive (i.e., the
    <span class="Li">&quot;YYBuildAST&quot;</span> method) builds an anonymous
    hash blessed in <span class="Li">&quot;someclass&quot;</span>. The hash has
    an attribute <span class="Li">&quot;children&quot;</span> containing the
    references to the AST trees associated with the symbols in the right hand
    side <span class="Li">&quot;X&quot;</span>, C&gt;Y&gt;, etc.</p>
<p class="Pp">If no explicit name was given to the production rule,
    <span class="Li">&quot;YYBuildAST&quot;</span> blesses the node in the class
    name resulting from the concatenation of the left hand side and the
    production number. The production number is the ordinal number of the
    production as they appear in the associated
    <span class="Li">&quot;.output&quot;</span> file (see option
    <span class="Li">&quot;-v&quot;</span> of eyapp). For example, given the
    grammar:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  pl@europa:~/LEyapp/examples/eyapplanguageref$ sed -ne '8,27p' treewithoutnames.pl
  my $grammar = q{
    %right  '='     # Lowest precedence
    %left   '-' '+' # + and - have more precedence than = Disambiguate a-b-c as (a-b)-c
    %left   '*' '/' # * and / have more precedence than + Disambiguate a/b/c as (a/b)/c
    %left   NEG     # Disambiguate -a-b as (-a)-b and not as -(a-b)
    %tree           # Let us build an abstract syntax tree ...

    %%
    line: exp &lt;+ ';'&gt;  { $_[1] } /* list of expressions separated by ';' */
    ;

    exp:
         NUM           |   VAR       | VAR '=' exp
      | exp '+' exp    | exp '-' exp |  exp '*' exp
      | exp '/' exp
      | '-' exp %prec NEG
      |   '(' exp ')'  { $_[2] }
    ;

    %%
</pre>
<p class="Pp">The tree produced by the parser when feed with input
    <span class="Li">&quot;a=2*b&quot;</span> is:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  pl@europa:~/LEyapp/examples/eyapplanguageref$ ./treewithoutnames.pl

  ************
  _PLUS_LIST(exp_6(TERMINAL[a],exp_9(exp_4(TERMINAL[2]),exp_5(TERMINAL[b]))))
  ************
</pre>
<p class="Pp">If we want to see the correspondence between names and rules we
    can generate and check the corresponding file
    <span class="Li">&quot;.output&quot;</span> setting the
    <span class="Li">&quot;outputfile&quot;</span> of
    <span class="Li">&quot;Parse::Eyapp&quot;</span>:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  Parse::Eyapp-&gt;new_grammar( # Create the parser package/class
    input=&gt;$grammar,
    classname=&gt;'Calc', # The name of the package containing the parser
    firstline=&gt;9,      # String $grammar starts at line 9 (for error diagnostics)
    outputfile=&gt;'treewithoutnames'
  );
</pre>
<p class="Pp">The grammar with the expanded rules appears in the
    <span class="Li">&quot;.output&quot;</span> file:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  lusasoft@LusaSoft:~/src/perl/Eyapp/examples/eyapplanguageref$ sed -ne '28,42p' treewithoutnames.output
  Rules:
  ------
  0:      $start -&gt; line $end
  1:      PLUS-1 -&gt; PLUS-1 ';' exp
  2:      PLUS-1 -&gt; exp
  3:      line -&gt; PLUS-1
  4:      exp -&gt; NUM
  5:      exp -&gt; VAR
  6:      exp -&gt; VAR '=' exp
  7:      exp -&gt; exp '+' exp
  8:      exp -&gt; exp '-' exp
  9:      exp -&gt; exp '*' exp
  10:     exp -&gt; exp '/' exp
  11:     exp -&gt; '-' exp
  12:     exp -&gt; '(' exp ')'
</pre>
<p class="Pp">We can see now that the node
    <span class="Li">&quot;exp_9&quot;</span> corresponds to the production
    <span class="Li">&quot;exp -&gt; exp '*' exp&quot;</span>. Observe also that
    the Eyapp production:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
                                line: exp &lt;+ ';'&gt;
actually produces the productions:

                        1:      PLUS-1 -&gt; PLUS-1 ';' exp
                        2:      PLUS-1 -&gt; exp
</pre>
<p class="Pp">and that the name of the class associated with the non empty list
    is <span class="Li">&quot;_PLUS_LIST&quot;</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_tree_Giving_Explicit_Names"><a class="permalink" href="#_tree_Giving_Explicit_Names">%tree
  Giving Explicit Names</a></h2>
A production rule can be <i>named</i> using the <span class="Li">&quot;%name
  IDENTIFIER&quot;</span> directive. For each production rule a
  namespace/package is created. <i>The</i>
  <span class="Li">&quot;IDENTIFIER&quot;</span> <i>is the name of the
  associated package</i>. Therefore, by modifying the former grammar with
  additional <span class="Li">%name</span> directives:
<p class="Pp"><span class="Li"></span></p>
<pre>
  lusasoft@LusaSoft:~/src/perl/Eyapp/examples/eyapplanguageref$ sed -ne '8,26p' treewithnames.pl
  my $grammar = q{
    %right  '='     # Lowest precedence
    %left   '-' '+' # + and - have more precedence than = Disambiguate a-b-c as (a-b)-c
    %left   '*' '/' # * and / have more precedence than + Disambiguate a/b/c as (a/b)/c
    %left   NEG     # Disambiguate -a-b as (-a)-b and not as -(a-b)
    %tree           # Let us build an abstract syntax tree ...

    %%
    line: exp &lt;%name EXPS + ';'&gt;  { $_[1] } /* list of expressions separated by ';' */
    ;

    exp:
        %name NUM    NUM           | %name VAR   VAR         | %name ASSIGN VAR '=' exp
      | %name PLUS   exp '+' exp   | %name MINUS exp '-' exp | %name TIMES  exp '*' exp
      | %name DIV    exp '/' exp
      | %name UMINUS '-' exp %prec NEG
      |   '(' exp ')'  { $_[2] }
    ;
</pre>
<p class="Pp">we are explicitly naming the productions. Thus, all the node
    instances corresponding to the production <span class="Li">&quot;exp: VAR
    '=' exp&quot;</span> will belong to the class
    <span class="Li">&quot;ASSIGN&quot;</span>. Now the tree for
    <span class="Li">&quot;a=2*b&quot;</span> becomes:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  lusasoft@LusaSoft:~/src/perl/Eyapp/examples/eyapplanguageref$ ./treewithnames.pl

  ************
  EXPS(ASSIGN(TERMINAL[a],TIMES(NUM(TERMINAL[2]),VAR(TERMINAL[b]))))
  ************
</pre>
<p class="Pp">Observe how the list has been named
    <span class="Li">&quot;EXPS&quot;</span>. The <span class="Li">%name</span>
    directive prefixes the list operator
    (<span class="Li">&quot;[+*?]&quot;</span>).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_s-1TERMINAL_s0_Nodes"><a class="permalink" href="#_s-1TERMINAL_s0_Nodes">TERMINAL
  Nodes</a></h2>
Nodes named <span class="Li">&quot;TERMINAL&quot;</span> are built from the
  tokens provided by the lexical analyzer.
  <span class="Li">&quot;Parse::Eyapp&quot;</span> follows the same protocol
  than Parse::Yapp for communication between the parser and the lexical
  analyzer: A couple <span class="Li">&quot;($token,</span>
  <span class="Li">$attribute)&quot;</span> is returned by the lexical analyzer.
  These values are stored under the keys
  <span class="Li">&quot;token&quot;</span> and
  <span class="Li">&quot;attr&quot;</span>.
  <span class="Li">&quot;TERMINAL&quot;</span> nodes as all
  <span class="Li">&quot;Parse::Eyapp::Node&quot;</span> nodes also have the
  attribute <span class="Li">&quot;children&quot;</span> but is - almost always
  - empty.
</section>
<section class="Ss">
<h2 class="Ss" id="Explicit_Actions_Inside__tree"><a class="permalink" href="#Explicit_Actions_Inside__tree">Explicit
  Actions Inside %tree</a></h2>
Explicit actions can be specified by the programmer like in this line from the
  Parse::Eyapp SYNOPSIS example:
<p class="Pp"><span class="Li"></span></p>
<pre>
      |   '(' exp ')'  { $_[2] }  /* Let us simplify a bit the tree */
</pre>
<p class="Pp">Explicit actions receive as arguments the references to the
    children nodes already built. The programmer can influence the shape of the
    tree by inserting these explicit actions. In this example the programmer has
    decided to simplify the syntax tree: the nodes associated with the
    parenthesis are discarded and the reference to the subtree containing the
    proper expression is returned. Such manoeuvre is called <i>bypassing</i>.
    See section &quot;The bypass clause and the <span class="Li">%no</span>
    bypass directive&quot; to know more about <i>automatic bypassing</i></p>
</section>
<section class="Ss">
<h2 class="Ss" id="Explicitly_Building_Nodes_With__YYBuildAST_"><a class="permalink" href="#Explicitly_Building_Nodes_With__YYBuildAST_">Explicitly
  Building Nodes With &quot;YYBuildAST&quot;</a></h2>
Sometimes the best time to decorate a node with some attributes is just after
  being built. In such cases the programmer can take <i>manual control</i>
  building the node with <span class="Li">&quot;YYBuildAST&quot;</span> to
  inmediately proceed to decorate it.
<p class="Pp">The following example illustrates the situation (see file
    <span class="Li">&quot;lib/Simple/Types.eyp&quot;</span> inside
    <span class="Li">&quot;examples/typechecking/Simple-Types-XXX.tar.gz&quot;</span>):</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  $ sed -n '397,408p' lib/Simple/Types.eyp
  Variable:
      %name VAR
      ID
    | %name  VARARRAY
      $ID ('[' binary ']') &lt;%name INDEXSPEC +&gt;
        {
          my $self = shift;
          my $node =  $self-&gt;YYBuildAST(@_);
          $node-&gt;{line} = $ID-&gt;[1];# $_[1]-&gt;[1]
          return $node;
        }
  ;
</pre>
<p class="Pp">This production rule defines the expression to access an array
    element as an identifier followed by a non empty list of binary expressions
    <span class="Li">&quot; Variable: ID ('[' binary ']')+&quot;</span>.
    Furthermore, the node corresponding to the list of indices has been named
    <span class="Li">&quot;INDEXSPEC&quot;</span>.</p>
<p class="Pp">When no explicit action is inserted a binary node will be built
    having as first child the node corresponding to the identifier
    <span class="Li">$ID</span> and as second child the reference to the list of
    binary expressions. The children corresponding to
    <span class="Li">'['</span> and <span class="Li">']'</span> are discarded
    since they are -by default- <i>syntactic tokens</i> (see section
    &quot;Syntactic and Semantic tokens&quot;). However, the programmer wants to
    decorate the node being built with a
    <span class="Li">&quot;line&quot;</span> attribute holding the line number
    in the source code where the identifier being used appears. The call to the
    <span class="Li">&quot;Parse::Eyapp::Driver&quot;</span> method
    <span class="Li">&quot;YYBuildAST&quot;</span> does the job of building the
    node. After that the node can be decorated and returned.</p>
<p class="Pp">Actually, the <span class="Li">%tree</span> directive is
    semantically equivalent to:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
                %default action { goto &amp;Parse::Eyapp::Driver::YYBuildAST }
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Returning_non_References_Under__tree"><a class="permalink" href="#Returning_non_References_Under__tree">Returning
  non References Under %tree</a></h2>
When a <i>explicit user action returns s.t. that is not a reference</i> <i>no
  node will be inserted</i>. This fact can be used to suppress nodes in the AST
  being built. See the following example (file
  <span class="Li">&quot;examples/returnnonode.yp&quot;</span>):
<p class="Pp"><span class="Li"></span></p>
<pre>
  $ sed -ne '1,17p' returnnonode.yp | cat -n
     1  %tree
     2  %semantic token 'a' 'b'
     3  %%
     4  S:    %name EMPTY
     5          /* empty */
     6      | %name AES
     7          S A
     8      | %name BES
     9          S B
    10  ;
    11  A : %name A
    12        'a'
    13  ;
    14  B : %name B
    15        'b' { }
    16  ;
    17  %%
</pre>
<p class="Pp">since the action at line 15 returns
    <span class="Li">&quot;undef&quot;</span> the <span class="Li">&quot;B :
    'b'&quot;</span> subtree will not be inserted in the AST:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  $ usereturnnonode.pl
  ababa
  AES(BES(AES(BES(AES(EMPTY,A(TERMINAL[a]))),A(TERMINAL[a]))),A(TERMINAL[a]))
</pre>
<p class="Pp">Observe the absence of <span class="Li">&quot;B&quot;</span>s and
    <span class="Li">'b'</span>s.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Intermediate_actions_and__tree"><a class="permalink" href="#Intermediate_actions_and__tree">Intermediate
  actions and %tree</a></h2>
Intermediate actions can be used to change the shape of the AST (prune it,
  decorate it, etc.) but the value returned by them is ignored. The grammar
  below has two intermediate actions. They modify the attributes of the node to
  its left and return a reference <span class="Li">$f</span> to such node (lines
  5 and 6):
<p class="Pp"><span class="Li"></span></p>
<pre>
  $ sed -ne '1,15p' intermediateactiontree.yp | cat -n
     1  %semantic token 'a' 'b'
     2  %tree bypass
     3  %%
     4  S:    %name EMPTY
     5         /* empty */
     6      | %name SA
     7         S A.f { $f-&gt;{attr} = &quot;A&quot;; $f; } A
     8      | %name SB
     9         S B.f { $f-&gt;{attr} = &quot;B&quot;; $f; } B
    10  ;
    11  A : %name A 'a'
    12  ;
    13  B : %name B 'b'
    14  ;
    15  %%
</pre>
<p class="Pp">See the client program:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
 nereida:~/src/perl/YappWithDefaultAction/examples&gt; cat -n useintermediateactiontree.pl
  1  #!/usr/bin/perl -w
  2  use strict;
  3  use Parse::Eyapp;
  4  use intermediateactiontree;
  5
  6  { no warnings;
  7  *A::info = *B::info = sub { $_[0]{attr} };
  8  }
  9
 10  my $parser = intermediateactiontree-&gt;new();
 11  my $t = $parser-&gt;Run;
 12  print $t-&gt;str,&quot;\n&quot;;
</pre>
<p class="Pp">When it runs produces this output:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  $ useintermediateactiontree.pl
  aabbaa
  SA(SB(SA(EMPTY,A[A],A[a]),B[B],B[b]),A[A],A[a])
</pre>
<p class="Pp">The attributes of left <span class="Li">&quot;A&quot;</span>s have
    been effectively changed by the intermediate actions from
    <span class="Li">'a'</span> to <span class="Li">'A'</span>. However no
    further children have been inserted.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Syntactic_and_Semantic_tokens"><a class="permalink" href="#Syntactic_and_Semantic_tokens">Syntactic
  and Semantic tokens</a></h2>
<span class="Li">&quot;Parse::Eyapp&quot;</span> differences between
  <span class="Li">&quot;syntactic tokens&quot;</span> and
  <span class="Li">&quot;semantic tokens&quot;</span>. By default all tokens
  declared using string notation (i.e. between quotes like
  <span class="Li">'+'</span>, <span class="Li">'='</span>) are considered
  <i>syntactic tokens</i>. Tokens declared by an identifier (like
  <span class="Li">&quot;NUM&quot;</span> or
  <span class="Li">&quot;VAR&quot;</span>) are by default considered <i>semantic
  tokens</i>. <b>Syntactic tokens do not yield to nodes in the</b> <b>syntactic
  tree</b>. Thus, the first print in the section Parse::Eyapp SYNOPSIS example:
<p class="Pp"><span class="Li"></span></p>
<pre>
  $ cat -n synopsis.pl
     1  #!/usr/bin/perl -w
     2  use strict;
     3  use Parse::Eyapp;
     4  use Parse::Eyapp::Treeregexp;
     5
     6  sub TERMINAL::info {
     7    $_[0]{attr}
     8  }
     9
    10  my $grammar = q{
    11    %right  '='     # Lowest precedence
    12    %left   '-' '+' # + and - have more precedence than = Disambiguate a-b-c as (a-b)-c
    13    %left   '*' '/' # * and / have more precedence than + Disambiguate a/b/c as (a/b)/c
    14    %left   NEG     # Disambiguate -a-b as (-a)-b and not as -(a-b)
    15    %tree           # Let us build an abstract syntax tree ...
    16
    17    %%
    18    line:
    19        exp &lt;%name EXPRESSION_LIST + ';'&gt;
    20          { $_[1] } /* list of expressions separated by ';' */
    21    ;
    22
    23    /* The %name directive defines the name of the class */
    24    exp:
    25        %name NUM
    26        NUM
    27      | %name VAR
    28        VAR
    29      | %name ASSIGN
    30        VAR '=' exp
    31      | %name PLUS
    32        exp '+' exp
    33      | %name MINUS
    34        exp '-' exp
    35      | %name TIMES
    36        exp '*' exp
    37      | %name DIV
    38        exp '/' exp
    39      | %name UMINUS
    40        '-' exp %prec NEG
    41      | '(' exp ')'
    42          { $_[2] }  /* Let us simplify a bit the tree */
    43    ;
    44
    45    %%
    46    sub _Error { die &quot;Syntax error near &quot;.($_[0]-&gt;YYCurval?$_[0]-&gt;YYCurval:&quot;end of file&quot;).&quot;\n&quot; }
    47
    48    sub _Lexer {
    49      my($parser)=shift; # The parser object
    50
    51      for ($parser-&gt;YYData-&gt;{INPUT}) { # Topicalize
    52        m{\G\s+}gc;
    53        $_ eq '' and return('',undef);
    54        m{\G([0-9]+(?:\.[0-9]+)?)}gc and return('NUM',$1);
    55        m{\G([A-Za-z][A-Za-z0-9_]*)}gc and return('VAR',$1);
    56        m{\G(.)}gcs and return($1,$1);
    57      }
    58      return('',undef);
    59    }
    60
    61    sub Run {
    62        my($self)=shift;
    63        $self-&gt;YYParse( yylex =&gt; \&amp;_Lexer, yyerror =&gt; \&amp;_Error, );
    64    }
    65  }; # end grammar
    66
    67  our (@all, $uminus);
    68
    69  Parse::Eyapp-&gt;new_grammar( # Create the parser package/class
    70    input=&gt;$grammar,
    71    classname=&gt;'Calc', # The name of the package containing the parser
    72    firstline=&gt;7       # String $grammar starts at line 7 (for error diagnostics)
    73  );
    74  my $parser = Calc-&gt;new();                # Create a parser
    75  $parser-&gt;YYData-&gt;{INPUT} = &quot;2*-3+b*0;--2\n&quot;; # Set the input
    76  my $t = $parser-&gt;Run;                    # Parse it!
    77  local $Parse::Eyapp::Node::INDENT=2;
    78  print &quot;Syntax Tree:&quot;,$t-&gt;str;
    79
    80  # Let us transform the tree. Define the tree-regular expressions ..
    81  my $p = Parse::Eyapp::Treeregexp-&gt;new( STRING =&gt; q{
    82      { #  Example of support code
    83        my %Op = (PLUS=&gt;'+', MINUS =&gt; '-', TIMES=&gt;'*', DIV =&gt; '/');
    84      }
    85      constantfold: /TIMES|PLUS|DIV|MINUS/:bin(NUM($x), NUM($y))
    86        =&gt; {
    87          my $op = $Op{ref($bin)};
    88          $x-&gt;{attr} = eval  &quot;$x-&gt;{attr} $op $y-&gt;{attr}&quot;;
    89          $_[0] = $NUM[0];
    90        }
    91      uminus: UMINUS(NUM($x)) =&gt; { $x-&gt;{attr} = -$x-&gt;{attr}; $_[0] = $NUM }
    92      zero_times_whatever: TIMES(NUM($x), .) and { $x-&gt;{attr} == 0 } =&gt; { $_[0] = $NUM }
    93      whatever_times_zero: TIMES(., NUM($x)) and { $x-&gt;{attr} == 0 } =&gt; { $_[0] = $NUM }
    94    },
    95    OUTPUTFILE=&gt; 'main.pm'
    96  );
    97  $p-&gt;generate(); # Create the tranformations
    98
    99  $t-&gt;s($uminus); # Transform UMINUS nodes
   100  $t-&gt;s(@all);    # constant folding and mult. by zero
   101
   102  local $Parse::Eyapp::Node::INDENT=0;
   103  print &quot;\nSyntax Tree after transformations:\n&quot;,$t-&gt;str,&quot;\n&quot;;
</pre>
<p class="Pp">gives as result the following output:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
 nereida:~/src/perl/YappWithDefaultAction/examples&gt; synopsis.pl
 Syntax Tree:
 EXPRESSION_LIST(
   PLUS(
     TIMES(
       NUM(
         TERMINAL[2]
       ),
       UMINUS(
         NUM(
           TERMINAL[3]
         )
       ) # UMINUS
     ) # TIMES,
     TIMES(
       VAR(
         TERMINAL[b]
       ),
       NUM(
         TERMINAL[0]
       )
     ) # TIMES
   ) # PLUS,
   UMINUS(
     UMINUS(
       NUM(
         TERMINAL[2]
       )
     ) # UMINUS
   ) # UMINUS
 ) # EXPRESSION_LIST
</pre>
<p class="Pp"><span class="Li">&quot;TERMINAL&quot;</span> nodes corresponding
    to tokens that were defined by strings like <span class="Li">'='</span>,
    <span class="Li">'-'</span>, <span class="Li">'+'</span>,
    <span class="Li">'/'</span>, <span class="Li">'*'</span>,
    <span class="Li">'('</span> and <span class="Li">')'</span> do not appear in
    the tree. <span class="Li">&quot;TERMINAL&quot;</span> nodes corresponding
    to tokens that were defined using an identifier, like
    <span class="Li">&quot;NUM&quot;</span> or
    <span class="Li">&quot;VAR&quot;</span> are, by default, <i>semantic
    tokens</i> and appear in the AST.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Changing_the_Status_of_a_Token"><a class="permalink" href="#Changing_the_Status_of_a_Token">Changing
  the Status of a Token</a></h2>
The new token declaration directives <span class="Li">&quot;%syntactic
  token&quot;</span> and <span class="Li">&quot;%semantic token&quot;</span> can
  change the status of a token. For example (file
  <span class="Li">&quot;15treewithsyntactictoken.pl&quot;</span> in the
  <span class="Li">&quot;examples/&quot;</span> directory), given the grammar:
<p class="Pp"><span class="Li"></span></p>
<pre>
   %syntactic token b
   %semantic token 'a' 'c'
   %tree

   %%

   S: %name ABC
        A B C
    | %name BC
        B C
   ;

   A: %name A
        'a'
   ;

   B: %name B
        b
   ;

   C: %name C
       'c'
   ;
   %%
</pre>
<p class="Pp">the tree build for input <span class="Li">&quot;abc&quot;</span>
    will be
    <span class="Li">&quot;ABC(A(TERMINAL[a]),B,C(TERMINAL[c]))&quot;</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Saving_the_Information_of_Syntactic_Tokens_in_their_Father"><a class="permalink" href="#Saving_the_Information_of_Syntactic_Tokens_in_their_Father">Saving
  the Information of Syntactic Tokens in their Father</a></h2>
The reason for the adjective <span class="Li">%syntactic</span> applied to a
  token is to state that the token influences the shape of the syntax tree but
  carries no other information. When the syntax tree is built the node
  corresponding to the token is discarded.
<p class="Pp">Sometimes the difference between syntactic and semantic tokens is
    blurred. For example the line number associated with an instance of the
    syntactic token <span class="Li">'+'</span> can be used later -say during
    type checking- to emit a more accurate error diagnostic. But if the node was
    discarded the information about that line number is no longer available.
    When building the syntax tree
    <span class="Li">&quot;Parse::Eyapp&quot;</span> (namely the method
    <span class="Li">&quot;Parse::Eyapp::YYBuildAST&quot;</span>) checks if the
    method <span class="Li">&quot;TERMINAL::save_attributes&quot;</span> exists
    and if so it will be called when dealing with a <i>syntactic token</i>. The
    method receives as argument - additionally to the reference to the attribute
    of the token as it is returned by the lexical analyzer - a reference to the
    node associated with the left hand side of the production. Here is an
    example (file <span class="Li">&quot;lib/Simple/Types.eyp&quot;</span> in
    <span class="Li">&quot;examples/typechecking/Simple-Types-XXX.tar.gz&quot;</span>)
    of use:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
              sub TERMINAL::save_attributes {
                # $_[0] is a syntactic terminal
                # $_[1] is the father.
                push @{$_[1]-&gt;{lines}}, $_[0]-&gt;[1]; # save the line number
              }
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="The___bypass__clause_and_the___no_bypass__directive"><a class="permalink" href="#The___bypass__clause_and_the___no_bypass__directive">The
  &quot;bypass&quot; clause and the &quot;%no bypass&quot; directive</a></h2>
The shape of the tree can be also modified using some
  <span class="Li">%tree</span> clauses as <span class="Li">&quot;%tree
  bypass&quot;</span> which will produce an automatic <i>bypass</i> of any node
  with only one child at tree-construction-time.
<p class="Pp">A <i>bypass operation</i> consists in <i>returning the only
    child</i> <i>of the node being visited to the father of the node and
    re-typing (re-blessing)</i> <i>the node in the name of the production</i>
    (if a name was provided).</p>
<p class="Pp">A node may have only one child at tree-construction-time for one
    of two reasons.</p>
<ul class="Bl-bullet">
  <li>The first occurs when the right hand side of the production was already
      unary like in:
    <p class="Pp"><span class="Li"></span></p>
    <pre>
                           exp:
                               %name NUM  NUM
    </pre>
    <p class="Pp">Here - if the <span class="Li">&quot;bypass&quot;</span>
        clause is used - the <span class="Li">&quot;NUM&quot;</span> node will
        be bypassed and the child <span class="Li">&quot;TERMINAL&quot;</span>
        built from the information provided by the lexical analyzer will be
        renamed/reblessed as <span class="Li">&quot;NUM&quot;</span>.</p>
  </li>
  <li>Another reason for a node to be <i>bypassed</i> is the fact that though
      the right hand side of the production may have more than one symbol, only
      one of them is not a syntactic token like in:
    <p class="Pp"><span class="Li"></span></p>
    <pre>
                           exp: '(' exp ')'
    </pre>
  </li>
</ul>
<p class="Pp">A consequence of the global scope application of
    <span class="Li">&quot;%tree bypass&quot;</span> is that undesired bypasses
    may occur like in</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
                           exp : %name UMINUS
                                 '-' $exp %prec NEG
</pre>
<p class="Pp">though the right hand side has two symbols, token
    <span class="Li">'-'</span> is a syntactic token and therefore only
    <span class="Li">&quot;exp&quot;</span> is left. The <i>bypass</i> operation
    will be applied when building this node. This <i>bypass</i> can be avoided
    applying the <span class="Li">&quot;no bypass ID&quot;</span> directive to
    the corresponding production:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
                           exp : %no bypass UMINUS
                                 '-' $exp %prec NEG
</pre>
<p class="Pp">The following example (file
    <span class="Li">&quot;examples/bypass.pl&quot;</span>) is the equivalent of
    the Parse::Eyapp SYNOPSIS example but using the
    <span class="Li">&quot;bypass&quot;</span> clause instead:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
 use Parse::Eyapp;
 use Parse::Eyapp::Treeregexp;

 sub TERMINAL::info { $_[0]{attr} }
 { no warnings; *VAR::info = *NUM::info = \&amp;TERMINAL::info; }

 my $grammar = q{
   %right  '='     # Lowest precedence
   %left   '-' '+' 
   %left   '*' '/' 
   %left   NEG     # Disambiguate -a-b as (-a)-b and not as -(a-b)
   %tree bypass    # Let us build an abstract syntax tree ...

   %%
   line: exp &lt;%name EXPRESSION_LIST + ';'&gt;  { $_[1] } 
   ;

   exp:
       %name NUM  NUM            | %name VAR   VAR         | %name ASSIGN VAR '=' exp
     | %name PLUS exp '+' exp    | %name MINUS exp '-' exp | %name TIMES  exp '*' exp
     | %name DIV     exp '/' exp
     | %no bypass UMINUS
       '-' $exp %prec NEG
     |   '(' exp ')'
   ;

   %%
   # sub _Error, _Lexer and Run like in the synopsis example
   # ...
 }; # end grammar

 our (@all, $uminus);

 Parse::Eyapp-&gt;new_grammar( # Create the parser package/class
   input=&gt;$grammar,
   classname=&gt;'Calc', # The name of the package containing the parser
   firstline=&gt;7       # String $grammar starts at line 7 (for error diagnostics)
 );
 my $parser = Calc-&gt;new();                # Create a parser
 $parser-&gt;YYData-&gt;{INPUT} = &quot;a=2*-3+b*0\n&quot;; # Set the input
 my $t = $parser-&gt;Run;                    # Parse it!

 print &quot;\n************\n&quot;.$t-&gt;str.&quot;\n************\n&quot;;

 # Let us transform the tree. Define the tree-regular expressions ..
 my $p = Parse::Eyapp::Treeregexp-&gt;new( STRING =&gt; q{
   { #  Example of support code
     my %Op = (PLUS=&gt;'+', MINUS =&gt; '-', TIMES=&gt;'*', DIV =&gt; '/');
   }
   constantfold: /TIMES|PLUS|DIV|MINUS/:bin(NUM, NUM)
     =&gt; {
       my $op = $Op{ref($_[0])};
       $NUM[0]-&gt;{attr} = eval  &quot;$NUM[0]-&gt;{attr} $op $NUM[1]-&gt;{attr}&quot;;
       $_[0] = $NUM[0];
     }
   zero_times_whatever: TIMES(NUM, .) and { $NUM-&gt;{attr} == 0 } =&gt; { $_[0] = $NUM }
   whatever_times_zero: TIMES(., NUM) and { $NUM-&gt;{attr} == 0 } =&gt; { $_[0] = $NUM }
   uminus: UMINUS(NUM) =&gt; { $NUM-&gt;{attr} = -$NUM-&gt;{attr}; $_[0] = $NUM }
   },
   OUTPUTFILE=&gt; 'main.pm'
 );
 $p-&gt;generate(); # Create the tranformations

 $t-&gt;s(@all);    # constant folding and mult. by zero

 print $t-&gt;str,&quot;\n&quot;;
</pre>
<p class="Pp">when running this example with input
    <span class="Li">&quot;a=2*-3+b*0\n&quot;</span> we obtain the following
    output:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
 nereida:~/src/perl/YappWithDefaultAction/examples&gt; bypass.pl

 ************
 EXPRESSION_LIST(ASSIGN(TERMINAL[a],PLUS(TIMES(NUM[2],UMINUS(NUM[3])),TIMES(VAR[b],NUM[0]))))
 ************
 EXPRESSION_LIST(ASSIGN(TERMINAL[a],NUM[-6]))
</pre>
<p class="Pp">As you can see the trees are more compact when using the
    <span class="Li">&quot;bypass&quot;</span> directive.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="The__alias__clause_of_the__tree_directive"><a class="permalink" href="#The__alias__clause_of_the__tree_directive">The
  &quot;alias&quot; clause of the %tree directive</a></h2>
Access to children in Parse::Eyapp is made through the
  <span class="Li">&quot;child&quot;</span> and
  <span class="Li">&quot;children&quot;</span> methods. There are occasions
  however where access by name to the children may be preferable. The use of the
  <span class="Li">&quot;alias&quot;</span> clause with the
  <span class="Li">%tree</span> directive creates accessors to the children with
  names specified by the programmer. The <i>dot and dollar notations</i> are
  used for this. When dealing with a production like:
<p class="Pp"><span class="Li"></span></p>
<pre>
                       A: 
                          %name A_Node
                          Node B.bum N.pum $Chip
</pre>
<p class="Pp">methods <span class="Li">&quot;bum&quot;</span>,
    <span class="Li">&quot;pum&quot;</span> and
    <span class="Li">&quot;Chip&quot;</span> will be created for the class
    <span class="Li">&quot;A_Node&quot;</span>. Those methods will provide
    access to the respective child (first, second and third in the example). The
    methods are build at compile-time and therefore later transformations of the
    AST modifying the order of the children may invalidate the use of these
    getter-setters.</p>
<p class="Pp">The <span class="Li">%prefix</span> directive used in line 7 of
    the following example is equivalent to the use of the
    <span class="Li">&quot;yyprefix&quot;</span>. The node classes are prefixed
    with the specified prefix: <span class="Li">&quot;R::S::&quot;</span> in
    this example.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
 cat -n alias_and_yyprefix.pl
     1  #!/usr/local/bin/perl
     2  use warnings;
     3  use strict;
     4  use Parse::Eyapp;
     5
     6  my $grammar = q{
     7    %prefix R::S::
     8
     9    %right  '='
    10    %left   '-' '+'
    11    %left   '*' '/'
    12    %left   NEG
    13    %tree bypass alias
    14
    15    %%
    16    line: $exp  { $_[1] }
    17    ;
    18
    19    exp:
    20        %name NUM
    21              $NUM
    22      | %name VAR
    23              $VAR
    24      | %name ASSIGN
    25              $VAR '=' $exp
    26      | %name PLUS
    27              exp.left '+' exp.right
    28      | %name MINUS
    29              exp.left '-' exp.right
    30      | %name TIMES
    31              exp.left '*' exp.right
    32      | %name DIV
    33              exp.left '/' exp.right
    34      | %no bypass UMINUS
    35              '-' $exp %prec NEG
    36      |   '(' exp ')'  { $_[2] } /* Let us simplify a bit the tree */
    37    ;
    38
    39    %%
    ..    ....
    76  }; # end grammar
    77
    78
    79  Parse::Eyapp-&gt;new_grammar(
    80    input=&gt;$grammar,
    81    classname=&gt;'Alias',
    82    firstline =&gt;7,
    83    outputfile =&gt; 'main',
    84  );
    85  my $parser = Alias-&gt;new();
    86  $parser-&gt;YYData-&gt;{INPUT} = &quot;a = -(2*3+5-1)\n&quot;;
    87  my $t = $parser-&gt;Run;
    88  $Parse::Eyapp::Node::INDENT=0;
    89  print $t-&gt;VAR-&gt;str.&quot;\n&quot;;             # a
    90  print &quot;***************\n&quot;;
    91  print $t-&gt;exp-&gt;exp-&gt;left-&gt;str.&quot;\n&quot;;  # 2*3+5
    92  print &quot;***************\n&quot;;
    93  print $t-&gt;exp-&gt;exp-&gt;right-&gt;str.&quot;\n&quot;; # 1
</pre>
<p class="Pp">The tree <span class="Li">$t</span> for the expression
    <span class="Li">&quot;a = -(2*3+5-1)\n&quot;</span> is:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  R::S::ASSIGN(
     R::S::TERMINAL,
     R::S::UMINUS(
       R::S::MINUS(
         R::S::PLUS(R::S::TIMES(R::S::NUM,R::S::NUM),R::S::NUM),
         R::S::NUM
       )
     )
  )
</pre>
<p class="Pp">The <span class="Li">&quot;R::S::ASSIGN&quot;</span> class has
    methods <span class="Li">&quot;VAR&quot;</span> (see line 89 above) and
    <span class="Li">&quot;exp&quot;</span> (see lines 91 and 93) to refer to
    its two children. The result of the execution is:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  $ alias_and_yyprefix.pl
  R::S::TERMINAL
  ***************
  R::S::PLUS(R::S::TIMES(R::S::NUM,R::S::NUM),R::S::NUM)
  ***************
  R::S::NUM
</pre>
<p class="Pp">As a second example of the use of <span class="Li">%alias</span>,
    the CPAN module Language::AttributeGrammar provides AST decorators from an
    attribute grammar specification of the AST. To work
    Language::AttributeGrammar requires named access to the children of the AST
    nodes. Follows an example (file
    <span class="Li">&quot;examples/CalcwithAttributeGrammar.pl&quot;</span>) of
    a small calculator:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  pl@nereida:~/LEyapp/examples$ cat -n CalcwithAttributeGrammar.pl
     1  #!/usr/bin/perl -w
     2  use strict;
     3  use Parse::Eyapp;
     4  use Data::Dumper;
     5  use Language::AttributeGrammar;
     6
     7  my $grammar = q{
     8  %{
     9  # use Data::Dumper;
    10  %}
    11  %right  '='
    12  %left   '-' '+'
    13  %left   '*' '/'
    14  %left   NEG
    15  %tree bypass alias
    16
    17  %%
    18  line: $exp  { $_[1] }
    19  ;
    20
    21  exp:
    22      %name NUM
    23            $NUM
    24          | %name VAR
    25            $VAR
    26          | %name ASSIGN
    27            $VAR '=' $exp
    28          | %name PLUS
    29            exp.left '+' exp.right
    30          | %name MINUS
    31            exp.left '-' exp.right
    32          | %name TIMES
    33            exp.left '*' exp.right
    34          | %name DIV
    35            exp.left '/' exp.right
    36          | %no bypass UMINUS
    37            '-' $exp %prec NEG
    38    |   '(' $exp ')'  { $_[2] } /* Let us simplify a bit the tree */
    39  ;
    40
    41  %%
    42
    43  sub _Error {
    44          exists $_[0]-&gt;YYData-&gt;{ERRMSG}
    45      and do {
    46          print $_[0]-&gt;YYData-&gt;{ERRMSG};
    47          delete $_[0]-&gt;YYData-&gt;{ERRMSG};
    48          return;
    49      };
    50      print &quot;Syntax error.\n&quot;;
    51  }
    52
    53  sub _Lexer {
    54      my($parser)=shift;
    55
    56          $parser-&gt;YYData-&gt;{INPUT}
    57      or  $parser-&gt;YYData-&gt;{INPUT} = &lt;STDIN&gt;
    58      or  return('',undef);
    59
    60      $parser-&gt;YYData-&gt;{INPUT}=~s/^\s+//;
    61
    62      for ($parser-&gt;YYData-&gt;{INPUT}) {
    63          s/^([0-9]+(?:\.[0-9]+)?)//
    64                  and return('NUM',$1);
    65          s/^([A-Za-z][A-Za-z0-9_]*)//
    66                  and return('VAR',$1);
    67          s/^(.)//s
    68                  and return($1,$1);
    69      }
    70  }
    71
    72  sub Run {
    73      my($self)=shift;
    74      $self-&gt;YYParse( yylex =&gt; \&amp;_Lexer, yyerror =&gt; \&amp;_Error,
    75                      #yydebug =&gt;0xFF
    76                    );
    77  }
    78  }; # end grammar
    79
    80
    81  $Data::Dumper::Indent = 1;
    82  Parse::Eyapp-&gt;new_grammar(
    83    input=&gt;$grammar,
    84    classname=&gt;'Rule6',
    85    firstline =&gt;7,
    86    outputfile =&gt; 'Calc.pm',
    87  );
    88  my $parser = Rule6-&gt;new();
    89  $parser-&gt;YYData-&gt;{INPUT} = &quot;a = -(2*3+5-1)\n&quot;;
    90  my $t = $parser-&gt;Run;
    91  print &quot;\n***** Before ******\n&quot;;
    92  print Dumper($t);
    93
    94  my $attgram = new Language::AttributeGrammar &lt;&lt;'EOG';
    95
    96  # Compute the expression
    97  NUM:    $/.val = { $&lt;attr&gt; }
    98  TIMES:  $/.val = { $&lt;left&gt;.val * $&lt;right&gt;.val }
    99  PLUS:   $/.val = { $&lt;left&gt;.val + $&lt;right&gt;.val }
   100  MINUS:  $/.val = { $&lt;left&gt;.val - $&lt;right&gt;.val }
   101  UMINUS: $/.val = { -$&lt;exp&gt;.val }
   102  ASSIGN: $/.val = { $&lt;exp&gt;.val }
   103  EOG
   104
   105  my $res = $attgram-&gt;apply($t, 'val');
   106
   107  $Data::Dumper::Indent = 1;
   108  print &quot;\n***** After ******\n&quot;;
   109  print Dumper($t);
   110  print Dumper($res);

 CalcwithAttributeGrammar.pl
</pre>
<p class="Pp">The program computes the tree for expression for expression
    <span class="Li">&quot;a = -(2*3+5-1)&quot;</span> which is:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  ASSIGN(TERMINAL,UMINUS(MINUS(PLUS(TIMES(NUM,NUM),NUM),NUM)))
</pre>
<p class="Pp">The children of the binary nodes can be accessed through the
    <span class="Li">&quot;left&quot;</span> and
    <span class="Li">&quot;right&quot;</span> methods.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="About_the_Encapsulation_of_Nodes"><a class="permalink" href="#About_the_Encapsulation_of_Nodes">About
  the Encapsulation of Nodes</a></h2>
There is no encapsulation of nodes. The user/client knows that they are hashes
  that can be decorated with new keys/attributes. All nodes in the AST created
  by <span class="Li">%tree</span> are
  <span class="Li">&quot;Parse::Eyapp::Node&quot;</span> nodes. The only
  reserved field is <span class="Li">&quot;children&quot;</span> which is a
  reference to the array of children. You can always create a
  <span class="Li">&quot;Node&quot;</span> class <i>by hand</i> by inheriting
  from <span class="Li">&quot;Parse::Eyapp::Node&quot;</span>.
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="SOLVING_CONFLICTS_WITH_THE__fIPOSTPONED_CONFLICT_fP_STRATEGY"><a class="permalink" href="#SOLVING_CONFLICTS_WITH_THE__fIPOSTPONED_CONFLICT_fP_STRATEGY">SOLVING
  CONFLICTS WITH THE <i>POSTPONED CONFLICT</i> STRATEGY</a></h1>
Yacc-like parser generators provide ways to solve shift-reduce mechanims based
  on token precedence. No mechanisms are provided for the resolution of
  reduce-reduce conflicts. The solution for such kind of conflicts is to modify
  the grammar. The strategy We present here provides a way to broach conflicts
  that can't be solved using static precedences.
<section class="Ss">
<h2 class="Ss" id="The__fIPostponed_Conflict_Resolution_fP_Strategy"><a class="permalink" href="#The__fIPostponed_Conflict_Resolution_fP_Strategy">The
  <i>Postponed Conflict Resolution</i> Strategy</a></h2>
The <i>postponed conflict strategy</i> presented here can be used whenever there
  is a shift-reduce or reduce-reduce conflict that can not be solved using
  static precedences.
</section>
<section class="Ss">
<h2 class="Ss" id="_fIPostponed_Conflict_Resolution_fP:_Reduce-Reduce_Conflicts"><a class="permalink" href="#_fIPostponed_Conflict_Resolution_fP:_Reduce-Reduce_Conflicts"><i>Postponed
  Conflict Resolution</i>: Reduce-Reduce Conflicts</a></h2>
Let us assume we have a reduce-reduce conflict between to productions
<p class="Pp"><span class="Li"></span></p>
<pre>
                      A -&gt; alpha .
                      B -&gt; beta .
</pre>
<p class="Pp">for some token <span class="Li">&quot;@&quot;</span>. Let also
    assume that production</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
                      A -&gt; alpha
</pre>
<p class="Pp">has name <span class="Li">&quot;ruleA&quot;</span> and
  production</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
                      B -&gt; beta
</pre>
<p class="Pp">has name <span class="Li">&quot;ruleB&quot;</span>.</p>
<p class="Pp">The postponed conflict resolution strategy consists in modifying
    the conflictive grammar by marking the points where the conflict occurs with
    the new <span class="Li">%PREC</span> directive. In this case at then end of
    the involved productions:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
                      A -&gt; alpha %PREC IsAorB 
                      B -&gt; beta  $PREC IsAorB
</pre>
<p class="Pp">The <span class="Li">&quot;IsAorB&quot;</span> identifier is
    called the <i>conflict name</i>.</p>
<p class="Pp">Inside the head section, the programmer associates with the
    conflict name a code whose mission is to solve the conflict by dynamically
    changing the parsing table like this:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
                     %conflict IsAorB {
                          my $self = shift;

                          if (looks_like_A($self)) {
                            $self-&gt;YYSetReduce('@', 'ruleA' );
                          }
                          else {
                            $self-&gt;YYSetReduce('@', 'ruleB' );
                          }
                       }
</pre>
<p class="Pp">The code associated with the <i>conflict name</i> receives the
    name of <i> conflict handler</i>. The code of
    <span class="Li">&quot;looks_like_A&quot;</span> stands for some form of
    nested parsing which will decide which production applies.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Solving_the_Enumerated_versus_Range_declarations_conflict_using_the_Posponed_Conflict_Resolution_Strategy"><a class="permalink" href="#Solving_the_Enumerated_versus_Range_declarations_conflict_using_the_Posponed_Conflict_Resolution_Strategy">Solving
  the Enumerated versus Range declarations conflict using the Posponed Conflict
  Resolution Strategy</a></h2>
In file
  <span class="Li">&quot;pascalenumeratedvsrangesolvedviadyn.eyp&quot;</span> we
  apply the postponed conflict resolution strategy to the reduce reduce conflict
  that arises in Extended Pascal between the declaration of ranges and the
  declaration of enumerated types (see section &quot;Reduce-Reduce conflict:
  Enumerated versus Range declarations in Extended Pascal&quot;). Here is the
  solution:
<p class="Pp"><span class="Li"></span></p>
<pre>
  ~/LEyapp/examples/debuggingtut$ cat -n pascalenumeratedvsrangesolvedviadyn.eyp
     1  %{
     2  =head1 SYNOPSIS
     3  
     4  See 
     5  
     6  =over 2
     7  
     8  =item * File pascalenumeratedvsrange.eyp in examples/debuggintut/
     9  
    10  =item * The Bison manual L&lt;http://www.gnu.org/software/bison/manual/html_mono/bison.html&gt;
    11  
    12  =back
    13  
    14  Compile it with:
    15  
    16              eyapp -b '' pascalenumeratedvsrangesolvedviadyn.eyp
    17  
    18  run it with this options:
    19  
    20              ./pascalenumeratedvsrangesolvedviadyn.pm -t
    21  
    22  Try these inputs:
    23  
    24                  type r = (x) ..  y ;
    25                  type r = (x+2)*3 ..  y/2 ;
    26                  type e = (x, y, z);
    27                  type e = (x);
    28  
    29  =cut
    30  
    31  use base q{DebugTail}; 
    32  
    33  my $ID = qr{[A-Za-z][A-Za-z0-9_]*};
    34               # Identifiers separated by commas
    35  my $IDLIST = qr{ \s*(?:\s*,\s* $ID)* \s* }x;
    36               # list followed by a closing par and a semicolon 
    37  my $RESTOFLIST = qr{$IDLIST \) \s* ; }x;
    38  %}
    39  
    40  %namingscheme {
    41    #Receives a Parse::Eyapp object describing the grammar
    42    my $self = shift;
    43  
    44    $self-&gt;tokennames(
    45      '(' =&gt; 'LP',
    46      '..' =&gt; 'DOTDOT',
    47      ',' =&gt; 'COMMA',
    48      ')' =&gt; 'RP',
    49      '+' =&gt; 'PLUS',
    50      '-' =&gt; 'MINUS',
    51      '*' =&gt; 'TIMES',
    52      '/' =&gt; 'DIV',
    53    );
    54  
    55    # returns the handler that will give names
    56    # to the right hand sides
    57    \&amp;give_rhs_name;
    58  }
    59  
    60  %strict
    61  
    62  %token ID NUM DOTDOT TYPE
    63  %left   '-' '+'
    64  %left   '*' '/'
    65  
    66  %tree
    67  
    68  %%
    69  
    70  type_decl : TYPE ID '=' type ';'
    71  ;
    72  
    73  type : 
    74        %name ENUM
    75        '(' id_list ')'
    76      | %name RANGE
    77        expr DOTDOT expr
    78  ;
    79  
    80  id_list : 
    81        %name EnumID
    82        ID rangeORenum
    83      | id_list ',' ID
    84  ;
    85  
    86  expr : '(' expr ')'
    87      | expr '+' expr
    88      | expr '-' expr
    89      | expr '*' expr
    90      | expr '/' expr
    91      | %name RangeID
    92        ID rangeORenum
    93      | NUM
    94  ;
    95  
    96  rangeORenum: /* empty: postponed conflict resolution */
    97        {
    98            my $parser = shift;
    99            if (${$parser-&gt;input()} =~ m{\G(?= $RESTOFLIST)}gcx) {
   100                $parser-&gt;YYSetReduce(')', 'EnumID' );
   101              }
   102              else {
   103                $parser-&gt;YYSetReduce(')', 'RangeID' );
   104              }
   105        }
   106  ;
   107  
   108  %%
   109  
   110  __PACKAGE__-&gt;lexer(
   111    sub {
   112      my $parser = shift;
   113  
   114      for (${$parser-&gt;input()}) {    # contextualize
   115        m{\G(\s*)}gc;
   116        $parser-&gt;tokenline($1 =~ tr{\n}{});
   117  
   118        m{\Gtype\b}gic                 and return ('TYPE', 'TYPE');
   119  
   120        m{\G($ID)}gc                   and return ('ID',  $1);
   121  
   122        m{\G([0-9]+)}gc                and return ('NUM', $1);
   123  
   124        m{\G\.\.}gc                    and return ('DOTDOT',  '..');
   125  
   126        m{\G(.)}gc                     and return ($1,    $1);
   127  
   128        return('',undef);
   129      }
   130    }
   131  );
   132  
   133  unless (caller()) {
   134    $Parse::Eyapp::Node::INDENT = 1;
   135    my $prompt = &lt;&lt; 'EOP';
   136  Try this input:
   137      type 
   138      r
   139      =
   140      (x)
   141      ..
   142      y
   143      ;
   144  
   145  Here other inputs you can try:
   146  
   147      type r = (x+2)*3 ..  y/2 ;
   148      type e = (x, y, z);
   149      type e = (x);
   150  
   151  Press CTRL-D (CTRL-W in windows) to produce the end-of-file
   152  EOP
   153    __PACKAGE__-&gt;main($prompt); 
   154  }
</pre>
<p class="Pp">This example also illustrates how to modify the default production
    naming schema. Follows the result of several executions:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  ~/LEyapp/examples/debuggingtut$ ./pascalenumeratedvsrangesolvedviadyn.pm -t
  Try this input:
      type 
      r
      =
      (x)
      ..
      y
      ;

  Here other inputs you can try:

      type r = (x+2)*3 ..  y/2 ;
      type e = (x, y, z);
      type e = (x);

  Press CTRL-D (CTRL-W in windows) to produce the end-of-file
  type r = (x+2)*3 ..  y/2 ;
  ^D
  type_decl_is_TYPE_ID_type(
    TERMINAL[TYPE],
    TERMINAL[r],
    RANGE(
      expr_is_expr_TIMES_expr(
        expr_is_LP_expr_RP(
          expr_is_expr_PLUS_expr(
            RangeID(
              TERMINAL[x]
            ),
            expr_is_NUM(
              TERMINAL[2]
            )
          )
        ),
        expr_is_NUM(
          TERMINAL[3]
        )
      ),
      TERMINAL[..],
      expr_is_expr_DIV_expr(
        RangeID(
          TERMINAL[y]
        ),
        expr_is_NUM(
          TERMINAL[2]
        )
      )
    )
  )
  ~/LEyapp/examples/debuggingtut$ ./pascalenumeratedvsrangesolvedviadyn.pm -t
  Try this input:
      type 
      r
      =
      (x)
      ..
      y
      ;

  Here other inputs you can try:

      type r = (x+2)*3 ..  y/2 ;
      type e = (x, y, z);
      type e = (x);

  Press CTRL-D (CTRL-W in windows) to produce the end-of-file
  type e = (x);
  ^D
  type_decl_is_TYPE_ID_type(
    TERMINAL[TYPE],
    TERMINAL[e],
    ENUM(
      EnumID(
        TERMINAL[x]
      )
    )
  )
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="_fIPostponed_Conflict_Resolution_fP:_Shift-Reduce_Conflicts"><a class="permalink" href="#_fIPostponed_Conflict_Resolution_fP:_Shift-Reduce_Conflicts"><i>Postponed
  Conflict Resolution</i>: Shift-Reduce Conflicts</a></h2>
The program in
  <span class="Li">&quot;examples/debuggingtut/DynamicallyChangingTheParser2.eyp&quot;</span>
  illustrates how the postponed conflict strategy is used for shift-reduce
  conflicts. This is an extension of the grammar in
  <span class="Li">&quot;examples/debuggingtut/Debug.eyp&quot;</span>. The
  generated language is constituted by sequences like:
<p class="Pp"><span class="Li"></span></p>
<pre>
    { D; D; S; S; S; } {D; S} { S }
</pre>
<p class="Pp">As you remember the conflict was:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  ~/LEyapp/examples/debuggingtut$ sed -ne '/^St.*13:/,/^St.*14/p' DynamicallyChangingTheParser.output  
  State 13:

      ds -&gt; D conflict . ';' ds   (Rule 6)
      ds -&gt; D conflict .  (Rule 7)

      ';' shift, and go to state 16

      ';' [reduce using rule 7 (ds)]

  State 14:
</pre>
<p class="Pp">The <span class="Li">&quot;conflict&quot;</span> handler below
    sets the LR action to reduce by the production with name
    <span class="Li">&quot;D1&quot;</span></p>
<p class="Pp"><span class="Li"></span></p>
<pre>
                 ds -&gt; D
</pre>
<p class="Pp">in the presence of token <span class="Li">';'</span> if indeed is
    the last <span class="Li">'D'</span>, that is, if:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
       ${$self-&gt;input()} =~ m{^\s*;\s*S}
</pre>
<p class="Pp">Otherwise we set the <span class="Li">&quot;shift&quot;</span>
    action via a call to the <span class="Li">&quot;YYSetShift&quot;</span>
    method.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  ~/LEyapp/examples/debuggingtut$ sed -ne '30,$p' DynamicallyChangingTheParser.eyp | cat -n
     1  %token D S
     2  
     3  %tree bypass
     4  
     5  # Expect just 1 shift-reduce conflict
     6  %expect 1 
     7  
     8  %%
     9  p: %name PROG
    10      block +
    11  ;
    12  
    13  block:
    14      %name BLOCK_DS
    15      '{' ds ';' ss '}' 
    16    | %name BLOCK_S
    17      '{' ss '}'
    18  ;
    19  
    20  ds:
    21      %name D2
    22      D conflict ';' ds    
    23    | %name D1
    24      D conflict        
    25  ;
    26  
    27  ss:
    28      %name S2
    29      S ';' ss      
    30    | %name S1
    31      S       
    32  ;
    33  
    34  conflict:
    35        /* empty. This action solves the conflict using dynamic precedence */
    36        {
    37          my $self = shift;
    38  
    39          if (${$self-&gt;input()} =~ m{^\s*;\s*S}) {
    40            $self-&gt;YYSetReduce(';', 'D1' )
    41          }
    42          else {
    43            $self-&gt;YYSetShift(';')
    44          }
    45  
    46          undef; # skip this node in the AST
    47        }
    48  ;
    49  
    50  %%
    51  
    52  my $prompt = 'Provide a statement like &quot;{D; S} {D; D; S}&quot; and press &lt;CR&gt;&lt;CTRL-D&gt;: ';
    53  __PACKAGE__-&gt;main($prompt) unless caller;
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="NAMING_SCHEMES"><a class="permalink" href="#NAMING_SCHEMES">NAMING
  SCHEMES</a></h1>
Explicit names can be given to grammar productions via the
  <span class="Li">%name</span> directive. An alternative to explicitly gave
  names to rules is to define a <i>naming scheme</i> via the Eyapp directive
  <span class="Li">%namingscheme</span>. This can be helpful when you inherit a
  large grammar and want to quickly build a parser. The ANSI C parser in
  <span class="Li">&quot;examples/languages/C/ansic.eyp&quot;</span> is a good
  example. Another example is the Pascal parser in
  <span class="Li">&quot;examples/languages/pascal/pascal.eyp&quot;</span>.
<p class="Pp">The Eyapp directive <span class="Li">%namingscheme</span> is
    followed by some Perl code. Such Perl code must return a reference to a
    subroutine that will be called each time a new production right hand side is
    parsed. The subroutine returns the name for the production.</p>
<p class="Pp">The Perl code defining the handler receives a
    <span class="Li">&quot;Parse::Eyapp&quot;</span> object that describes the
    grammar. The code after the <span class="Li">%namingscheme</span> directive
    is evaluated during the early phases of the compilation of the input
    grammar. As an example of how to set a naming scheme, see lines 22-38 below
    (you can find this example and others in the directory
    <span class="Li">&quot;examples/naming&quot;</span> of the accompanying
    distribution):</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  lusasoft@LusaSoft:~/src/perl/Eyapp/examples/naming$ cat -n GiveNamesToCalc.eyp
     1  # GiveNamesToCalc.eyp
     2  %right  '='
     3  %left   '-' '+'
     4  %left   '*' '/'
     5  %left   NEG
     6  %right  '^'
     7
     8  %tree bypass
     9
    10  %{
    11  use base q{Tail};
    12
    13  sub exp_is_NUM::info {
    14    my $self = shift;
    15
    16    $self-&gt;{attr}[0];
    17  }
    18
    19  *exp_is_VAR::info = *var_is_VAR::info = \&amp;exp_is_NUM::info;
    20  %}
    21
    22  %namingscheme {
    23    #Receives a Parse::Eyapp object describing the grammar
    24    my $self = shift;
    25
    26    $self-&gt;tokennames(
    27      '=' =&gt; 'ASSIGN',
    28      '+' =&gt; 'PLUS',
    29      '*' =&gt; 'TIMES',
    30      '-' =&gt; 'MINUS',
    31      '/' =&gt; 'DIV',
    32      '^' =&gt; 'EXP',
    33    );
    34
    35    # returns the handler that will give names
    36    # to the right hand sides
    37    \&amp;give_token_name;
    38  }
    39  %%
    40
    41  line:
    42      exp
    43  ;
    44
    45  exp:
    46      NUM
    47    | VAR
    48    | var '=' exp
    49    | exp '+' exp
    50    | exp '-' exp
    51    | exp '*' exp
    52    | exp '/' exp
    53    | %no bypass exp_is_NEG
    54       '-' exp %prec NEG
    55    | exp '^' exp
    56    | '(' exp ')'
    57  ;
    58
    59  var:
    60      VAR
    61  ;
    62  %%
    63
    64  unless (caller) {
    65    my $t = __PACKAGE__-&gt;main(@ARGV);
    66    print $t-&gt;str.&quot;\n&quot;;
    67  }
</pre>
<p class="Pp">The example uses a naming scheme that is provided by
    <span class="Li">&quot;Parse::Eyapp&quot;</span>:
    <span class="Li">&quot;Parse::Eyapp::Grammar::give_token_name&quot;</span>.
    The current provided naming schemes handlers are:</p>
<ul class="Bl-bullet">
  <li><span class="Li">&quot;give_default_name&quot;</span>: The name of the
      production is the name of the Left Hand Side of the Production Rule
      concatenated with an underscore and the index of the production</li>
  <li><span class="Li">&quot;give_lhs_name&quot;</span>: The name of the
      production is the name of the Left Hand Side of the Production Rule (this
      is the naming scheme used by the <span class="Li">%tree</span> directive
      when no explicit name was given)</li>
  <li><span class="Li">&quot;give_token_name&quot;</span>: The name of the
      production is the Left Hand Side of the Production Rule followed by the
      word <span class="Li">&quot;_is_&quot;</span> followed by the
      concatenation of the names of the tokens in the right and side (separated
      by underscores).</li>
</ul>
<p class="Pp">All of these handlers are implemented inside the class
    <span class="Li">&quot;Parse::Eyapp::Grammar&quot;</span>. There is no need
    at line 37 to explicit the class name prefix since the naming scheme code is
    evaluated inside such class:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    22  %namingscheme {
    23    #Receives a Parse::Eyapp object describing the grammar
    24    my $self = shift;
    25
    26    $self-&gt;tokennames(
    27      '=' =&gt; 'ASSIGN',
    28      '+' =&gt; 'PLUS',
    29      '*' =&gt; 'TIMES',
    30      '-' =&gt; 'MINUS',
    31      '/' =&gt; 'DIV',
    32      '^' =&gt; 'EXP',
    33    );
    34
    35    # returns the handler that will give names
    36    # to the right hand sides
    37    \&amp;give_token_name;
    38  }
</pre>
<p class="Pp">As it is illustrated in this example, the method
    <span class="Li">&quot;tokennames&quot;</span> of
    <span class="Li">&quot;Parse::Eyapp&quot;</span> objects provide a way to
    give identifier names to tokens that are defined by strings. When we execute
    the former module/program (modulino) with input
    <span class="Li">&quot;a=2*-3&quot;</span> we got the following output:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  lusasoft@LusaSoft:~/src/perl/Eyapp/examples/naming$ eyapp -b '' GiveNamesToCalc.eyp
  lusasoft@LusaSoft:~/src/perl/Eyapp/examples/naming$ ./GiveNamesToCalc.pm
  Expressions. Press CTRL-D (Unix) or CTRL-Z (Windows) to finish:
  a=2*-3
  line_is_exp(var_is_VAR[a],exp_is_TIMES(exp_is_NUM[2],exp_is_NEG(exp_is_NUM[3])))
</pre>
<p class="Pp">For each production rule the handler is called with arguments:</p>
<ul class="Bl-bullet">
  <li>the <span class="Li">&quot;Parse::Eyapp&quot;</span> object,</li>
  <li>the production index (inside the grammar),</li>
  <li>the left hand side symbol and a reference to a list with the symbols in
      the right hand side.</li>
</ul>
<p class="Pp">The following code of some version of
    <span class="Li">&quot;give_token_name&quot;</span> exemplifies how a naming
    scheme handler can be written:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  lusasoft@LusaSoft:~/src/perl/Eyapp$ sed -ne '101,132p' lib/Parse/Eyapp/Grammar.pm | cat -n
     1  sub give_token_name {
     2    my ($self, $index, $lhs, $rhs) = @_;
     3
     4    my @rhs = @$rhs;
     5    $rhs = '';
     6
     7    unless (@rhs) { # Empty RHS
     8      return $lhs.'_is_empty';
     9    }
    10
    11    my $names = $self-&gt;{GRAMMAR}{TOKENNAMES} || {};
    12    for (@rhs) {
    13      if ($self-&gt;is_token($_)) {
    14        s/^'(.*)'$/$1/;
    15        my $name = $names-&gt;{$_} || '';
    16        unless ($name) {
    17          $name = $_ if /^\w+$/;
    18        }
    19        $rhs .= &quot;_$name&quot; if $name;
    20      }
    21    }
    22
    23    unless ($rhs) { # no 'word' tokens in the RHS
    24      for (@rhs) {
    25        $rhs .= &quot;_$_&quot; if /^\w+$/;
    26      }
    27    }
    28
    29    # check if another production with such name exists?
    30    my $name = $lhs.'_is'.$rhs;
    31    return $name;
    32  }
</pre>
<ul class="Bl-bullet">
  <li>The project home is at &lt;http://code.google.com/p/parse-eyapp/&gt;. Use
      a subversion client to anonymously check out the latest project source
      code:
    <p class="Pp"><span class="Li"></span></p>
    <pre>
   svn checkout http://parse-eyapp.googlecode.com/svn/trunk/ parse-eyapp-read-only
    </pre>
  </li>
  <li>The tutorial <i>Parsing Strings and Trees with</i>
      <span class="Li">&quot;Parse::Eyapp&quot;</span> (An Introduction to
      Compiler Construction in seven pages) in
      &lt;http://nereida.deioc.ull.es/~pl/eyapsimple/&gt;</li>
  <li>Parse::Eyapp, Parse::Eyapp::eyapplanguageref, Parse::Eyapp::debuggingtut,
      Parse::Eyapp::defaultactionsintro, Parse::Eyapp::translationschemestut,
      Parse::Eyapp::Driver, Parse::Eyapp::Node, Parse::Eyapp::YATW,
      Parse::Eyapp::Treeregexp, Parse::Eyapp::Scope, Parse::Eyapp::Base,
      Parse::Eyapp::datagenerationtut</li>
  <li>The pdf file in
      &lt;http://nereida.deioc.ull.es/~pl/perlexamples/languageintro.pdf&gt;</li>
  <li>The pdf file in
      &lt;http://nereida.deioc.ull.es/~pl/perlexamples/debuggingtut.pdf&gt;</li>
  <li>The pdf file in
      &lt;http://nereida.deioc.ull.es/~pl/perlexamples/eyapplanguageref.pdf&gt;</li>
  <li>The pdf file in
      &lt;http://nereida.deioc.ull.es/~pl/perlexamples/Treeregexp.pdf&gt;</li>
  <li>The pdf file in
      &lt;http://nereida.deioc.ull.es/~pl/perlexamples/Node.pdf&gt;</li>
  <li>The pdf file in
      &lt;http://nereida.deioc.ull.es/~pl/perlexamples/YATW.pdf&gt;</li>
  <li>The pdf file in
      &lt;http://nereida.deioc.ull.es/~pl/perlexamples/Eyapp.pdf&gt;</li>
  <li>The pdf file in
      &lt;http://nereida.deioc.ull.es/~pl/perlexamples/Base.pdf&gt;</li>
  <li>The pdf file in
      &lt;http://nereida.deioc.ull.es/~pl/perlexamples/translationschemestut.pdf&gt;</li>
  <li>The pdf file in
      &lt;http://nereida.deioc.ull.es/~pl/perlexamples/treematchingtut.pdf&gt;</li>
  <li>perldoc eyapp,</li>
  <li>perldoc treereg,</li>
  <li>perldoc vgg,</li>
  <li>The Syntax Highlight file for vim at
      &lt;http://www.vim.org/scripts/script.php?script_id=2453&gt; and
      &lt;http://nereida.deioc.ull.es/~vim/&gt;</li>
  <li><i>Analisis Lexico y Sintactico</i>, (Notes for a course in compiler
      construction) by Casiano Rodriguez-Leon. Available at
      &lt;http://nereida.deioc.ull.es/~pl/perlexamples/&gt; Is the more complete
      and reliable source for Parse::Eyapp. However is in Spanish.</li>
  <li>Parse::Yapp,</li>
  <li>Man pages of <i>yacc</i>(1) and <i>bison</i>(1),
      &lt;http://www.delorie.com/gnu/docs/bison/bison.html&gt;</li>
  <li>Language::AttributeGrammar</li>
  <li>Parse::RecDescent.</li>
  <li>HOP::Parser</li>
  <li>HOP::Lexer</li>
  <li>ocamlyacc tutorial at
      &lt;http://plus.kaist.ac.kr/~shoh/ocaml/ocamllex-ocamlyacc/ocamlyacc-tutorial/ocamlyacc-tutorial.html&gt;</li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="REFERENCES"><a class="permalink" href="#REFERENCES">REFERENCES</a></h1>
<ul class="Bl-bullet">
  <li>The classic Dragon's book <i>Compilers: Principles, Techniques, and
      Tools</i> by Alfred V. Aho, Ravi Sethi and Jeffrey D. Ullman
      (Addison-Wesley 1986)</li>
  <li><i>CS2121: The Implementation and Power of Programming Languages</i> (See
      &lt;http://www.cs.man.ac.uk/~pjj&gt;,
      &lt;http://www.cs.man.ac.uk/~pjj/complang/g2lr.html&gt; and
      &lt;http://www.cs.man.ac.uk/~pjj/cs2121/ho/ho.html&gt;) by Pete Jinks</li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="CONTRIBUTORS"><a class="permalink" href="#CONTRIBUTORS">CONTRIBUTORS</a></h1>
<ul class="Bl-bullet">
  <li>Hal Finkel &lt;http://www.halssoftware.com/&gt;</li>
  <li>G. Williams &lt;http://kasei.us/&gt;</li>
  <li>Thomas L. Shinnick &lt;http://search.cpan.org/~tshinnic/&gt;</li>
  <li>Frank Leray</li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
Casiano Rodriguez-Leon (casiano@ull.es)
</section>
<section class="Sh">
<h1 class="Sh" id="ACKNOWLEDGMENTS"><a class="permalink" href="#ACKNOWLEDGMENTS">ACKNOWLEDGMENTS</a></h1>
This work has been supported by CEE (FEDER) and the Spanish Ministry of
  <i>Educacion y Ciencia</i> through <i>Plan Nacional I+D+I</i> number
  TIN2005-08818-C04-04 (ULL::OPLINK project &lt;http://www.oplink.ull.es/&gt;).
  Support from Gobierno de Canarias was through GC02210601 (<i>Grupos
  Consolidados</i>). The University of La Laguna has also supported my work in
  many ways and for many years.
<p class="Pp">A large percentage of code is verbatim taken from Parse::Yapp
    1.05. The author of Parse::Yapp is Francois Desarmenien.</p>
<p class="Pp">I wish to thank Francois Desarmenien for his Parse::Yapp module,
    to my students at La Laguna and to the Perl Community. Thanks to the people
    who have contributed to improve the module (see &quot;CONTRIBUTORS&quot; in
    Parse::Eyapp). Thanks to Larry Wall for giving us Perl. Special thanks to
    Juana.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="LICENCE_AND_COPYRIGHT"><a class="permalink" href="#LICENCE_AND_COPYRIGHT">LICENCE
  AND COPYRIGHT</a></h1>
Copyright (c) 2006-2008 Casiano Rodriguez-Leon (casiano@ull.es). All rights
  reserved.
<p class="Pp">Parse::Yapp copyright is of Francois Desarmenien, all rights
    reserved. 1998-2001</p>
<p class="Pp">These modules are free software; you can redistribute it and/or
    modify it under the same terms as Perl itself. See perlartistic.</p>
<p class="Pp">This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. </p>
</section>
<section class="Sh">
<h1 class="Sh" id="POD_ERRORS"><a class="permalink" href="#POD_ERRORS">POD
  ERRORS</a></h1>
Hey! <b>The above document had some coding errors, which are explained
  below:</b>
<dl class="Bl-tag">
  <dt>Around line 2546:</dt>
  <dd>Non-ASCII character seen before =encoding in 'valida\n&quot;;'. Assuming
      ISO8859-1</dd>
</dl>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2012-03-23</td>
    <td class="foot-os">perl v5.18.4</td>
  </tr>
</table>
</body>
</html>
