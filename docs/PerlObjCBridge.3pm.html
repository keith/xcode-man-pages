<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>PerlObjCBridge(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">PerlObjCBridge(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">PerlObjCBridge(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
PerlObjCBridge.pm - Bridges Perl and Objective-C runtimes
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<span class="Li"></span>
<pre>
    use Foundation;
    
    $s1 = NSString-&gt;stringWithCString_(&quot;Hello &quot;);
    $s2 = NSString-&gt;alloc()-&gt;initWithCString_(&quot;World&quot;);
    $s3 = $s1-&gt;stringByAppendingString_($s2);
    printf &quot;%s\n&quot;, $s3-&gt;cString();
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="SUMMARY"><a class="permalink" href="#SUMMARY">SUMMARY</a></h1>
The PerlObjCBridge module supports creating and messaging Objective-C objects
  from Perl programs, allowing Cocoa objects in Apple Computer's Mac OS X to be
  directly manipulated from Perl. In addition, Perl objects can be messaged from
  Objective-C, making it possible for Perl objects to function as Cocoa
  delegates and as targets of notifications and other Cocoa call-back messages.
  Perl programs can take advantage of Cocoa's Distributed Objects mechanism to
  support messaging between Perl objects and Objective-C objects (or other Perl
  objects) in different address spaces, possibly on different machines.
</section>
<section class="Sh">
<h1 class="Sh" id="LIMITATION"><a class="permalink" href="#LIMITATION">LIMITATION</a></h1>
This version of PerlObjCBridge does not directly support writing GUI Cocoa
  applications in Perl. Consult http://www.sourceforge.net/projects/camelbones
  for a freeware package that supports GUI Perl/Cocoa apps.
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
Using PerlObjCBridge, Perl programs can reference Objective-C objects in a
  manner similar to references to native Perl objects. The Objective-C objects
  must inherit from the NSObject root class in the Mac OS X Foundation framework
  (which is true for Cocoa objects). In Objective-C an object is accessed via an
  object identifier that is implemented as a pointer to a structure containing
  the object's instance data. PerlObjCBridge represents an Objective-C object as
  a Perl reference to a scalar value that contains the Objective-C ID. For
  example, if an Objective-C object has an ID with value 0x12345678, then
  PerlObjCBridge represents that object as a reference to a scalar with value
  0x12345678. The Perl reference is &quot;blessed&quot; into a Perl class that
  has the same name as the Objective-C class. The Perl inheritance mechanism is
  then used to route any messages sent to the object from Perl through the
  PerlObjCBridge extension module and ultimately to the Objective-C object. The
  return values of the Objective-C messages are similarly routed back through
  the bridge where they are converted into Perl return values.
<p class="Pp">It is also possible to use Perl objects in places where Cocoa
    methods normally take Objective-C arguments. For example, one can register
    Perl objects to receive NSNotifications, in which case the perl objects
    provide the notification handling methods that are asynchronously messaged
    by NSNotificationCenter when interesting events occur. As another example, a
    Perl object can be registered as a server object via NSConnection, after
    which Objective-C or Perl objects in other address spaces can send messages
    to the server object via the Distributed Objects mechanism. In these
    examples an Objective-C proxy object is created by PerlObjCBridge that gets
    passed to Objective-C methods, and that forwards messages from Objective-C
    to the Perl object.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="MESSAGING"><a class="permalink" href="#MESSAGING">MESSAGING</a></h1>
Ordinary Perl &quot;object-&gt;method(argument-list)&quot; syntax is used to
  send messages to Objective-C objects. The ':' character that delimits
  arguments in Objective-C is illegal in Perl method names, so underscores are
  used instead. An method that is invoked in Objective-C as:
<p class="Pp"><span class="Li"></span></p>
<pre>
    [anObject arg1:x arg2:y];
</pre>
<p class="Pp">can be invoked from Perl using something like:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    $anObject-&gt;arg1_arg2_($x, $y);
</pre>
<p class="Pp">Contrast the following Objective-C code fragment with its Perl
    analogue in the synopsis at the top of this man page:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    #import &lt;Foundation/Foundation.h&gt;

    NSString *s1 = [NSString stringWithCString:&quot;Hello &quot;];
    NSString *s2 = [[NSString alloc] initWithCString:&quot;World&quot;];
    NSString *s3 = [s1 stringByAppendingString:s2];
    printf(&quot;%s\n&quot;, [s3 cString]);
</pre>
<p class="Pp">To send a message to an Objective-C class, one uses the syntactic
    form ClassName-&gt;method(...args...). For example, one can send the
    &quot;defaultManager&quot; message to the NSFileManager class as
  follows:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    $defMgr = NSFileManager-&gt;defaultManager();
</pre>
<p class="Pp">An important special case of a class method is a
    &quot;factory&quot; method that constructs a new instance of a class:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    $array = NSMutableArray-&gt;array();
    
    $string = NSString-&gt;stringWithCString_(&quot;Hi there&quot;);
</pre>
<p class="Pp">The NSString factory method illustrates how PerlObjCBridge passes
    Perl strings to Objective-C as char *'s.</p>
<p class="Pp">To send a message to an Objective-C object, one uses the syntactic
    form <span class="Li">$object</span>-&gt;method(...args...). If
    <span class="Li">$array</span> is a reference to an NSMutableArray then one
    can add the NSString referenced by <span class="Li">$string</span> by
    sending <span class="Li">$array</span> the &quot;addObject:&quot;
  message:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    $array-&gt;addObject_($string);
</pre>
<p class="Pp">Message sends can be chained from left to right:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    $hostName = NSProcessInfo-&gt;processInfo()-&gt;hostName();
</pre>
<p class="Pp">In the above example, the object returned by
    NSProcessInfo-&gt;<i>processInfo()</i> is in turn sent the hostName
  message.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="USING_COCOA_FRAMEWORKS"><a class="permalink" href="#USING_COCOA_FRAMEWORKS">USING
  COCOA FRAMEWORKS</a></h1>
PerlObjCBridge automatically generates a bridge module for the Foundation
  framework that is included with the Cocoa environment in Mac OS X. This bridge
  module is created when PerlObjCBridge is built. The bridge module for a
  framework causes that framework to be dynamically loaded into the Perl
  program's address space. In addition Perl packages are created for each of the
  Objective-C classes in the framework so that the Objective-C classes exist in
  the Perl name space.
<p class="Pp">To access a framework from Perl &quot;use&quot; its bridge module.
    For example, to access Foundation objects do:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    use Foundation;
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DISTRIBUTED_MESSAGING"><a class="permalink" href="#DISTRIBUTED_MESSAGING">DISTRIBUTED
  MESSAGING</a></h1>
Perl objects can send messages to other objects (Perl or Cocoa) in different
  address spaces by using Cocoa's Distributed Objects (DO) mechanism. This makes
  it easy to create distributed systems (such as client/server systems) that mix
  Perl and Cocoa programs. It also makes it easy to create a pure Perl
  distributed system, where Perl objects in different address spaces communicate
  via Cocoa DO.
<p class="Pp">Here is a complete example of a distributed client/server system,
    where the client and server objects are written in Perl but communicate by
    means of DO. The system consists of a Perl client program, a Perl server
    program, and a Perl XSUB module that provides the glue between the Perl
    programs and DO. The XSUB module is initially created by running the
    following command:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    h2xs -A -n AddSystem
</pre>
<p class="Pp">An AddSystem directory is created with these files:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    ppport.h
    lib/AddSystem.pm
    AddSystem.xs
    Makefile.PL
    README
    t/AddSystem.t    
    Changes
    MANIFEST
</pre>
<p class="Pp">Edit the Makefile.PL to add the CCFLAGS entry with the '-x
    objective-c' flag:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    'CCFLAGS'        =&gt; '-x objective-c',
</pre>
<p class="Pp">Modify the contents of AddSystem.pm to contain:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    package AddSystem;

    @ISA = qw(Exporter DynaLoader);
    @EXPORT = qw( );
    $VERSION = '1.0';
    bootstrap AddSystem $VERSION;

    use Foundation;

    1;
</pre>
<p class="Pp">and modify AddSystem.xs to have the contents:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    #include &lt;mach-o/dyld.h&gt;
    #include &quot;EXTERN.h&quot;
    #include &quot;perl.h&quot;
    #include &quot;XSUB.h&quot;
    #ifdef Move
    #undef Move
    #endif Move
    #ifdef DEBUG
    #undef DEBUG
    #endif DEBUG
    #ifdef I_POLL
    #undef I_POLL
    #endif I_POLL
    #import &lt;Foundation/Foundation.h&gt;

    @interface AddClient : NSObject
    @end

    @implementation AddClient
    - (int)firstNumber { return 0; }
    - (int)secondNumber { return 0; }
    @end

    @interface AddServer: NSObject
    @end

    @implementation AddServer
    - (int)addNumbersForClient:(NSObject *)client { return 0; }
    @end

    MODULE = AddSystem          PACKAGE = AddSystem
</pre>
<p class="Pp">AddSystem.xs defines &quot;dummy&quot; AddClient and AddServer
    Objective-C classes that implement the methods that the Perl client and
    server will provide. These dummy Objective-C classes are needed in this case
    because there would otherwise not be enough information for the DO runtime
    system to determine the numbers, types, and sizes of the method arguments
    and return values. These dummy Objective-C implementations are usually only
    needed when DO is being used and the Perl program does not link against any
    libraries that contain objects that already implement the methods. The
    actual method bodies are irrelevant and can be trivially defined to return 0
    or NULL. In the case of methods that return void, the dummy methods can have
    empty bodies.</p>
<p class="Pp">After modifying Makefile.PL, AddSystem.pm, and AddSystem.xs,
    execute the following commands (as root or as an admin user):</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    perl Makefile.PL
    make install
</pre>
<p class="Pp">Now add two Perl programs to the AddSystem directory. The first
    program is addServer:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    #!/usr/bin/perl

    use AddSystem;

    package AddServer;
    @ISA = qw(PerlObjCBridge);
    @EXPORT = qw( );

    PerlObjCBridge::preloadSelectors('AddClient');

    sub new
    {
        my $class = shift;
        my $self = {};
        bless $self, $class;
        return $self;
    }

    sub addNumbersForClient_
    {
        my($self, $client) = @_;
        my $first = $client-&gt;firstNumber();
        my $second = $client-&gt;secondNumber();
        return int($first + $second);
    }

    $server = new AddServer;
    $connection = NSConnection-&gt;defaultConnection();
    $connection-&gt;setRootObject_($server);
    $connection-&gt;registerName_(NSString-&gt;stringWithCString_(&quot;AddServer&quot;));

    NSRunLoop-&gt;currentRunLoop()-&gt;run();
</pre>
<p class="Pp">Make sure that the line &quot;#!/usr/bin/perl&quot; does not
    contain leading whitespace.</p>
<p class="Pp">The line:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    use AddSystem;
</pre>
<p class="Pp">causes addServer to load the AddSystem XSUB module, which in turn
    loads the dummy AddClient and AddServer Objective-C classes, thus making
    them available to the DO runtime system. The lines:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    package AddServer;
    @ISA = qw(PerlObjCBridge);
    @EXPORT = qw( );
</pre>
<p class="Pp">cause the AddServer package to inherit from PerlObjCBridge. As a
    consequence, messages to and from AddServer objects will be routed through
    PerlObjCBridge.</p>
<p class="Pp">The line:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    PerlObjCBridge::preloadSelectors('AddClient');
</pre>
<p class="Pp">instructs PerlObjCBridge to pre-cache all method selectors for the
    Objective-C class AddClient. By doing this, PerlObjCBridge is
    &quot;primed&quot; with the information needed to send messages to objects
    of class AddClient.</p>
<p class="Pp">After a standard &quot;new&quot; constructor method, there is a
    addNumbersForClient_ method that provides the service vended by the
    AddServer class. The method name &quot;addNumbersForClient_&quot;
    corresponds to the Objective-C selector &quot;addNumbersForClient:&quot;,
    which has a dummy implementation in AddSystem.xs. In addition to the
    standard <span class="Li">$self</span> argument, addNumbersForClient_ takes
    a second argument <span class="Li">$client</span> which is a reference to
    the invoking client object. The client object is then sent the messages
    &quot;firstNumber&quot; and &quot;secondNumber&quot;, each of which returns
    an integer. The server adds the two numbers and returns the result.</p>
<p class="Pp">The lines:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    $server = new AddServer;
    $connection = NSConnection-&gt;defaultConnection();
    $connection-&gt;setRootObject_($server);
    $connection-&gt;registerName_(NSString-&gt;stringWithCString_(&quot;AddServer&quot;));
</pre>
<p class="Pp">create a new AddServer object and set it as the root object of a
    DO connection, registered with the name &quot;AddServer&quot;. Clients can
    then look up the name &quot;AddServer&quot; to connect to this object.</p>
<p class="Pp">The final line:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    NSRunLoop-&gt;currentRunLoop()-&gt;run();
</pre>
<p class="Pp">puts addServer into a event loop, waiting for incoming connections
    from clients.</p>
<p class="Pp">The second program, addClient, consists of:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    #!/usr/bin/perl

    use AddSystem;

    package AddClient;
    @ISA = qw(PerlObjCBridge);
    @EXPORT = qw( );

    PerlObjCBridge::preloadSelectors('AddServer');

    sub new
    {
        my $class = shift;
        my $self = {};
        bless $self, $class;
        $self{'firstNumber'} = shift;
        $self{'secondNumber'} = shift;
        return $self;
    }

    sub firstNumber
    {
        my($self) = @_;
        return $self{'firstNumber'};
    }

    sub secondNumber
    {
        my($self) = @_;
        return $self{'secondNumber'};
    }

    die &quot;usage: perlClient &lt;firstNumber&gt; &lt;secondNumber&gt;\n&quot; unless @ARGV == 2;

    # create client
    $client = new AddClient (@ARGV);
    
    # create connection to server
    $name = NSString-&gt;stringWithCString_(&quot;AddServer&quot;);
    $server = NSConnection-&gt;rootProxyForConnectionWithRegisteredName_host_($name, 0);
    if (!$server or !$$server) {
        print &quot;Can't get server\n&quot;;
        exit(1);
    }
    $server-&gt;retain();
    
    printf &quot;%d\n&quot;, $server-&gt;addNumbersForClient_($client);
</pre>
<p class="Pp">Make sure that the line &quot;#!/usr/bin/perl&quot; does not
    contain leading whitespace.</p>
<p class="Pp">The AddClient methods &quot;firstNumber&quot; and
    &quot;secondNumber&quot; implement the call-back methods invoked by the
    AddServer. The lines:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    $name = NSString-&gt;stringWithCString_(&quot;AddServer&quot;);
    $server = NSConnection-&gt;rootProxyForConnectionWithRegisteredName_host_($name, 0);
    if (!$server or !$$server) {
        print &quot;Can't get server\n&quot;;
        exit(1);
    }
    $server-&gt;retain();
</pre>
<p class="Pp">results in <span class="Li">$server</span> being assigned a DO
    &quot;proxy&quot; object for the AddServer object in the addServer program.
    Any messages sent by the client will by forwarded by the DO proxy to the
    actual AddServer object in the addServer address space.</p>
<p class="Pp">The final line:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    printf &quot;%d\n&quot;, $server-&gt;addNumbersForClient_($client);
</pre>
<p class="Pp">invokes the AddServer object with a reference to the client
    object. The control flow that results is:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    addClient sends &quot;addNumbersForClient:&quot; to addServer
    addServer sends &quot;firstNumber&quot; to addClient
    addClient returns first number
    addServer sends &quot;secondNumber&quot; to addClient
    addClient returns second number
    addServer returns sum of first and second number
</pre>
<p class="Pp">To execute these programs, first make sure addServer and addClient
    are executable:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    chmod +x addServer addClient
</pre>
<p class="Pp">Next run the server in one shell:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    addServer
</pre>
<p class="Pp">then the client in another shell:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    addClient 1 2
    3
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTOMATIC_STRING_CONVERSION"><a class="permalink" href="#AUTOMATIC_STRING_CONVERSION">AUTOMATIC
  STRING CONVERSION</a></h1>
For convenience, PerlObjCBridge automatically converts Perl strings into
  NSString Objective-C objects when an NSObject is expected as the argument to
  an Objective-C method. For example, suppose an Objective-C dictionary is
  created:
<p class="Pp"><span class="Li"></span></p>
<pre>
    $dict = NSMutableDictionary-&gt;dictionary();
</pre>
<p class="Pp">The dictionary method &quot;setObject:forKey:&quot; expects the
    key argument to be an NSString and the value argument to be any NSObject.
    The following automatically converts both &quot;aKey&quot; and
    &quot;aValue&quot; to NSStrings and then inserts the pair into the
    dictionary:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    $dict-&gt;setObject_forKey_(&quot;aValue&quot;, &quot;aKey&quot;);
</pre>
<p class="Pp">The value can be retrieved as follows, where &quot;aKey&quot; is
    again automatically converted to an NSString:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    $value = $dict-&gt;objectForKey_(&quot;aKey&quot;);
    printf &quot;value is %s\n&quot;, $value-&gt;cString();
</pre>
<p class="Pp">Note that the return value assigned to
    <span class="Li">$value</span> is a reference to an NSString and is not
    automatically converted to a Perl string. The automatic conversions occur
    only from Perl strings to NSStrings for Objective-C method arguments.
    NSStrings return values are not automatically converted to Perl strings.</p>
<p class="Pp">Automatic conversion also occurs when a Perl string is passed as
    an argument to a method that expects an Objective-C selector. For example,
    the &quot;performSelector:&quot; message can be sent to any NSObject. The
    argument to the &quot;performSelector:&quot; message must be an Objective-C
    selector. In Objective-C, one can copy an existing NSString
    &quot;origString&quot; by asking it to perform the &quot;copy&quot;
    selector:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    copy = [origString performSelector:@selector(copy)];
</pre>
<p class="Pp">This is equivalent to:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    copy = [origString copy];
</pre>
<p class="Pp">In Perl the selector form can be executed as:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    $copy = $origString-&gt;performSelector_(&quot;copy&quot;);
</pre>
<p class="Pp">In this case the Perl string &quot;copy&quot; is automatically
    converted to an Objective-C selector.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="NIL_ARGUMENTS_AND_RETURN_VALUES"><a class="permalink" href="#NIL_ARGUMENTS_AND_RETURN_VALUES">NIL
  ARGUMENTS AND RETURN VALUES</a></h1>
It is sometimes necessary to pass the Objective-C object ID &quot;nil&quot; (a
  null pointer) as an argument to an Objective-C method. Since PerlObjCBridge
  represents Objective-C ID's as Perl references, strictly speaking the Perl
  value 0 is not a legal representation for Objective-C's nil because it is a
  simple scalar, not a reference. However, for convenience, when an argument to
  an Objective-C method is expected to be an object ID and the value 0 is passed
  from Perl, PerlObjCBridge coerces the 0 value to a reference to a zero-valued
  scalar and the Objective-C method receives nil for that argument. In the
  following example, the Objective-c method &quot;arg1:optionalArg:&quot; would
  receive nil as its second argument.
<p class="Pp"><span class="Li"></span></p>
<pre>
    MyClass-&gt;arg1_optionalArg_($obj, 0);
</pre>
<p class="Pp">The special value &quot;undef&quot; can also be used:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    MyClass-&gt;arg1_optionalArg_($obj, undef);
</pre>
<p class="Pp">When an Objective-C method returns nil, the corresponding Perl
    return value is a reference to a zero-valued scalar. This return value can
    subsequently be passed as an argument to an Objective-C method. In the
    following example, if &quot;aMethod&quot; returns nil then
    &quot;arg1:optionalArg:&quot; would receive nil as its second argument:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    MyClass-&gt;arg1_optionalArg_($obj, YourClass-&gt;aMethod());
</pre>
<p class="Pp">To determine whether an Objective-C method returned nil one should
    test both the Perl reference and its referent. The referent will be
    zero-valued when the Objective-C method returned nil, but it is also
    possible for the reference itself to be undefined (for example, when the
    method raised an NSException, as discussed below). The following example
    illustrates the use of an Objective-C NSEnumerator object to print the
    elements of an NSArray. In Objective-C, the enumerator returns nil after the
    last object in the array has been enumerated. In the Perl loop, both the
    reference <span class="Li">$obj</span> and the referent $$obj are tested in
    the loop condition. Under normal circumstances looping ends when $$obj
    becomes zero-valued, indicating the enumerator returned nil.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    $enumerator = $array-&gt;objectEnumerator();
    while ($obj = $enumerator-&gt;nextObject() and $$obj) {
        printf &quot;%s\n&quot;, $obj-&gt;description()-&gt;cString();
    }
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="ARGUMENTS_THAT_RETURN_OBJECTS_BY_REFERENCE"><a class="permalink" href="#ARGUMENTS_THAT_RETURN_OBJECTS_BY_REFERENCE">ARGUMENTS
  THAT RETURN OBJECTS BY REFERENCE</a></h1>
Sometimes Objective-C methods return objects to the caller using
  return-by-reference arguments. For example, the following method defines an
  argument that returns an NSError object by reference.
<p class="Pp"><span class="Li"></span></p>
<pre>
    - (BOOL)doSomethingAndReturnError:(NSError **)error;
</pre>
<p class="Pp">When the doSomethingAndReturnError: method fails it returns a
    Boolean value of NO and (optionally) also returns a by-reference NSError
    argument. An Objective-C caller of this method will typically do something
    like the following.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    NSError *error = nil;

    BOOL result = [anObject doSomethingAndReturnError:&amp;error];
    if ( ! result ) {
        if ( error ) {
            NSLog(@&quot;error code is %d&quot;, [error code]);
        }
    }
</pre>
<p class="Pp">Return-by-reference arguments can be used from Perl as illustrated
    by the following example.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    my $errorVal;                   # declare $errorVal as an uninitialized scalar
    my $error = \$errorVal;         # initialize $error as a reference to $errorVal
    
    my $result = $anObject-&gt;doSomethingAndReturnError_($error);
    if ( ! $result ) {
        if ( $$error ) {
            printf &quot;error code is %d\n&quot;, $error-&gt;code( );
        }
    }
</pre>
<p class="Pp">Note: the following does not work.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    my $errorVal;
    my $result = $anObject-&gt;doSomethingAndReturnError_($errorVal);
</pre>
<p class="Pp">The following does not work either.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    my $errorVal;
    my $result = $anObject-&gt;doSomethingAndReturnError_(\$errorVal);
</pre>
<p class="Pp">Pass undef to avoid returning the Objective-C object:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    my $result = $anObject-&gt;doSomethingAndReturnError_(undef);
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="POINTERS_TO_BUFFERS"><a class="permalink" href="#POINTERS_TO_BUFFERS">POINTERS
  TO BUFFERS</a></h1>
For Objective-C methods such as -[NSData getBytes:length:] it is necessary to
  pass an argument that represents a pointer to a buffer of known length. This
  may be accomplished using the <i>pack()</i> and <i>unpack()</i> functions, as
  shown in the following example. The &quot;L!&quot; template forces the
  <i>unpack()</i> function to return a native-length unsigned long value, which
  is always the same size as a pointer in Mac OS X.
<p class="Pp">In this example, assume <span class="Li">$nsData</span> points to
    a valid NSData object:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    my $buffer;
    if ($nsData &amp;&amp; $$nsData) {
        my $length = $nsData-&gt;length();
        $buffer = '\0' x $length;
        my $pointerToBuffer = unpack(&quot;L!&quot;, pack(&quot;p&quot;, $buffer));
        $nsData-&gt;getBytes_length_($pointerToBuffer, $length);
    }
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="EXCEPTION_HANDLING"><a class="permalink" href="#EXCEPTION_HANDLING">EXCEPTION
  HANDLING</a></h1>
NSExceptions that are raised as a result of messages sent by Perl programs to
  Objective-C objects are dealt with as follows. PerlObjCBridge has a built-in
  NSException handler that writes the message selector, the class of the target
  object, and the NSException name, reason, and userInfo to standard error. By
  default, the built-in NSException handler then dies with a message. The
  function <i>PerlObjCBridge::setDieOnExceptions()</i> can be used to control
  the latter behavior. Invoking <i>setDieOnExceptions()</i> with an argument of
  0 will cause the built-in exception handler to issue a warning and return
  without dying, whereas a non-zero argument (or no argument) will cause the
  built-in exception handler to die. In the case where the built-in exception
  handler returns with a warning, the original message that caused the exception
  returns undef.
<p class="Pp">Alternatively, the Perl program can set its own exception handler
    by calling <i>PerlObjCBridge::setNSExceptionHandler()</i> with a single
    argument that must be a reference to a Perl function that acts as the
    exception handler. The Perl program can get a reference to the current
    exception handler by calling <i>PerlObjCBridge::getNSExceptionHandler()</i>.
    If a user-defined exception handler is set and an NSException is raised then
    the user-defined handler will be called with five string arguments: (1) the
    Objective-C selector for the message that induced the NSException, (2) the
    class name of the object to which the message was sent, and (3,4,5) the
    NSException name, reason, and userInfo (the latter represented as the string
    [userInfo description]). If the user-defined exception handler returns, then
    the original message returns undef. When a user-defined exception handler is
    set, it is up to the handler to decide whether the program exits or
    continues when NSExceptions are raised (i.e., when a user-defined exception
    handler is set the function <i>setDieOnExceptions()</i> has no effect).</p>
<p class="Pp">The example below stores the original exception handler, sets a
    new exception handler, provokes an NSException by attempting to set a
    dictionary entry with a nil key and a nil value, and then restores the
    original exception handler.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
   sub myHandler
   {
       my($sel, $pkg, $name, $reason, $userInfo) = @_;
       print &quot;NSException raised!\n&quot;;
       print &quot;selector:  $selector\n&quot;;
       print &quot;package:   $package\n&quot;;
       print &quot;name:      $name\n&quot;;
       print &quot;reason:    $reason\n&quot;;
       print &quot;userInfo:  $userInfo\n&quot;;
   }

   $oldHandler = PerlObjCBridge::getNSExceptionHandler();
   PerlObjCBridge::setNSExceptionHandler(\&amp;myHandler);
   $dict = NSMutableDictionary-&gt;dictionary();
   $dict-&gt;setObject_forKey_(0, 0);
   PerlObjCBridge::setNSExceptionHandler($oldHandler);
</pre>
<p class="Pp">This results in myHandler printing the output:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
   NSException raised!
   selector:     setObject:forKey:
   target class: NSCFDictionary 
   name:         NSInvalidArgumentException
   reason:       *** -[NSCFDictionary setObject:forKey:]: attempt to insert nil key
   userInfo:
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="LARGE_NUMERIC_VALUES"><a class="permalink" href="#LARGE_NUMERIC_VALUES">LARGE
  NUMERIC VALUES</a></h1>
PerlObjCBridge assumes no Perl support for 64-bit integers. When an Objective-C
  method has a 64-bit integer return type (i.e., long long or unsigned long
  long) and the result of invoking that method is a return value that is too
  large (i.e., &gt;= 2^^31) or too small (&lt;= -(2^^31)) to be represented in
  Perl as a signed integer then the value is returned as a Perl double.
  Similarly, when a parameter to an Objective-C method is a long long or
  unsigned long long then the type of the Perl argument value is examined. If
  the argument value is a Perl integer then its value is passed directly to the
  Objective-C method in long long or unsigned long long form (coercing in the
  unsigned case). Otherwise if the argument value is a Perl double then it is
  coerced to the appropriate long long or unsigned long long form before it is
  passed to the method.
<p class="Pp">Similar considerations apply to 32-bit unsigned longs and unsigned
    ints. When an Objective-C method has a 32-bit unsigned long or unsigned int
    return type and the result of invoking that method is a return value that is
    too large (&gt;= 2^^31) to be represented in Perl as a signed integer then
    the value is returned as a Perl double. When a parameter to an Objective-C
    method is a 32-bit unsigned long or unsigned int then the Perl int or float
    argument is simply coerced to the unsigned long or int. This can of course
    have unpleasant consequences if the Perl argument is negative or larger than
    2^^32.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="CONTROL_FUNCTIONS"><a class="permalink" href="#CONTROL_FUNCTIONS">CONTROL
  FUNCTIONS</a></h1>
Calling <i>PerlObjCBridge::setTracing()</i> with a non-zero argument (or no
  argument) will cause PerlObjCBridge to log diagnostic messages as it executes.
  Calling <i>setTracing()</i> with an argument of zero turns the diagnostics
  off.
<p class="Pp">Calling <i>PerlObjCBridge::setDieOnErrors()</i> with a non-zero
    argument (or no argument) will cause PerlObjCBridge to die with a warning
    message whenever there is an error during the sending of an Objective-C
    message (this is the default behavior). Calling <i>setDieOnErrors()</i> with
    an argument of zero allows the program to print a warning message but not
    die after such an error.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="BUGS_AND_LIMITATIONS"><a class="permalink" href="#BUGS_AND_LIMITATIONS">BUGS
  AND LIMITATIONS</a></h1>
PerlObjCBridge should take advantage of Perl support for 64-bit integers if
  available. Feel free to fix this.
<p class="Pp">When structs are passed by value, sometimes pointers embedded in
    the structs get mangled. It is better to pass structs by reference if they
    contain embedded pointers.</p>
<p class="Pp">Varargs-style messaging is not supported. This is unfortunate, but
    it's due to the lack of varargs support in NSInvocation and
    NSMethodSignature. Fix that and it should be easy to support varargs
    messaging in PerlObjCBridge.</p>
<p class="Pp">Access to functions, variables, and other non-object-oriented
    constructs exported by libraries containing Objective-C is not currently
    supported. It seems dubious that those things are exported as C-level
    constructs to begin with, when they could/should be Objective-C class
    methods. One possible workaround is to create an XSUB that provides
    Objective-C &quot;covers&quot; for these items. For example, if a library
    exports a variable:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    extern int GreatBigFoo;
</pre>
<p class="Pp">then an XSUB with a cover might define:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    @interface Covers: NSObject
    + (int)GreatBigFoo;
    @end
    
    @implementation Covers
    + (int)GreatBigFoo
    {
        return GreatBigFoo;
    }
    @end
</pre>
<p class="Pp">Then the value of the variable could be accessed in Perl:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    $gbf = Covers::GreatBigFoo();
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<i>perl</i>(1). Mac OS X: /Developer/Documentation/Cocoa/ObjectiveC Mac OS X:
  /Developer/Documentation/Cocoa/Reference/Foundation
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2019-05-17</td>
    <td class="foot-os">perl v5.18.4</td>
  </tr>
</table>
</body>
</html>
