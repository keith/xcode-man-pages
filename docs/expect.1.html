<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>EXPECT(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">EXPECT(1)</td>
    <td class="head-vol">General Commands Manual</td>
    <td class="head-rtitle">EXPECT(1)</td>
  </tr>
</table>
<div class="manual-text">
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
expect - programmed dialogue with interactive programs, Version 5
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<b>expect</b> [ <b>-dDinN</b> ] [ <b>-c</b> <i>cmds</i> ] [ [
  <b>-</b>[<b>f</b>|<b>b</b>] ] <i>cmdfile</i> ] [ <i>args</i> ]
</section>
<section class="Sh">
<h1 class="Sh" id="INTRODUCTION"><a class="permalink" href="#INTRODUCTION">INTRODUCTION</a></h1>
<b>Expect</b> is a program that &quot;talks&quot; to other interactive programs
  according to a script. Following the script, <b>Expect</b> knows what can be
  expected from a program and what the correct response should be. An
  interpreted language provides branching and high-level control structures to
  direct the dialogue. In addition, the user can take control and interact
  directly when desired, afterward returning control to the script.
<p class="Pp"><b>Expectk</b> is a mixture of <b>Expect</b> and <b>Tk</b>. It
    behaves just like <b>Expect</b> and <b>Tk</b>'s <b>wish</b>. <b>Expect</b>
    can also be used directly in C or C++ (that is, without Tcl). See
    libexpect(3).</p>
<p class="Pp">The name &quot;Expect&quot; comes from the idea of
    <i>send/expect</i> sequences popularized by uucp, kermit and other modem
    control programs. However unlike uucp, <b>Expect</b> is generalized so that
    it can be run as a user-level command with any program and task in mind.
    <b>Expect</b> can actually talk to several programs at the same time.</p>
<p class="Pp">For example, here are some things <b>Expect</b> can do:</p>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>&#x2022;</dt>
  <dd>Cause your computer to dial you back, so that you can login without paying
      for the call.</dd>
  <dt>&#x2022;</dt>
  <dd>Start a game (e.g., rogue) and if the optimal configuration doesn't
      appear, restart it (again and again) until it does, then hand over control
      to you.</dd>
  <dt>&#x2022;</dt>
  <dd>Run fsck, and in response to its questions, answer &quot;yes&quot;,
      &quot;no&quot; or give control back to you, based on predetermined
      criteria.</dd>
  <dt>&#x2022;</dt>
  <dd>Connect to another network or BBS (e.g., MCI Mail, CompuServe) and
      automatically retrieve your mail so that it appears as if it was
      originally sent to your local system.</dd>
  <dt>&#x2022;</dt>
  <dd>Carry environment variables, current directory, or any kind of information
      across rlogin, telnet, tip, su, chgrp, etc.</dd>
</dl>
</div>
<p class="Pp">There are a variety of reasons why the shell cannot perform these
    tasks. (Try, you'll see.) All are possible with <b>Expect</b>.</p>
<p class="Pp">In general, <b>Expect</b> is useful for running any program which
    requires interaction between the program and the user. All that is necessary
    is that the interaction can be characterized programmatically. <b>Expect</b>
    can also give the user back control (without halting the program being
    controlled) if desired. Similarly, the user can return control to the script
    at any time.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="USAGE"><a class="permalink" href="#USAGE">USAGE</a></h1>
<b>Expect</b> reads <i>cmdfile</i> for a list of commands to execute.
  <b>Expect</b> may also be invoked implicitly on systems which support the #!
  notation by marking the script executable, and making the first line in your
  script:
<p class="Pp">
   #!/usr/local/bin/expect -f</p>
<p class="Pp">Of course, the path must accurately describe where <b>Expect</b>
    lives. /usr/local/bin is just an example.</p>
<p class="Pp">The <b>-c</b> flag prefaces a command to be executed before any in
    the script. The command should be quoted to prevent being broken up by the
    shell. This option may be used multiple times. Multiple commands may be
    executed with a single <b>-c</b> by separating them with semicolons.
    Commands are executed in the order they appear. (When using Expectk, this
    option is specified as <b>-command</b>.)</p>
<p class="Pp">The <b>-d</b> flag enables some diagnostic output, which primarily
    reports internal activity of commands such as <b>expect</b> and
    <b>interact</b>. This flag has the same effect as &quot;exp_internal 1&quot;
    at the beginning of an Expect script, plus the version of <b>Expect</b> is
    printed. (The <b>strace</b> command is useful for tracing statements, and
    the <b>trace</b> command is useful for tracing variable assignments.) (When
    using Expectk, this option is specified as <b>-diag</b>.)</p>
<p class="Pp">The <b>-D</b> flag enables an interactive debugger. An integer
    value should follow. The debugger will take control before the next Tcl
    procedure if the value is non-zero or if a ^C is pressed (or a breakpoint is
    hit, or other appropriate debugger command appears in the script). See the
    README file or SEE ALSO (below) for more information on the debugger. (When
    using Expectk, this option is specified as <b>-Debug</b>.)</p>
<p class="Pp">The <b>-f</b> flag prefaces a file from which to read commands
    from. The flag itself is optional as it is only useful when using the #!
    notation (see above), so that other arguments may be supplied on the command
    line. (When using Expectk, this option is specified as <b>-file</b>.)</p>
<p class="Pp">By default, the command file is read into memory and executed in
    its entirety. It is occasionally desirable to read files one line at a time.
    For example, stdin is read this way. In order to force arbitrary files to be
    handled this way, use the <b>-b</b> flag. (When using Expectk, this option
    is specified as
    <b>-buffer</b>.)<b>Note</b>that<b>stdio-buffering</b>may<b>still</b>take<b>place</b>however<b>this</b>shouldn't<b>cause</b>problems<b>when</b>reading<b>from</b>a<b>fifo</b>or<b>stdin.</b></p>
<p class="Pp">If the string &quot;-&quot; is supplied as a filename, standard
    input is read instead. (Use &quot;./-&quot; to read from a file actually
    named &quot;-&quot;.)</p>
<p class="Pp">The <b>-i</b> flag causes <b>Expect</b> to interactively prompt
    for commands instead of reading them from a file. Prompting is terminated
    via the <b>exit</b> command or upon EOF. See <b>interpreter</b> (below) for
    more information. <b>-i</b> is assumed if neither a command file nor
    <b>-c</b> is used. (When using Expectk, this option is specified as
    <b>-interactive</b>.)</p>
<p class="Pp"><b>--</b> may be used to delimit the end of the options. This is
    useful if you want to pass an option-like argument to your script without it
    being interpreted by <b>Expect</b>. This can usefully be placed in the #!
    line to prevent any flag-like interpretation by Expect. For example, the
    following will leave the original arguments (including the script name) in
    the variable <i>argv</i>.</p>
<p class="Pp">
   #!/usr/local/bin/expect --</p>
<p class="Pp">Note that the usual getopt(3) and execve(2) conventions must be
    observed when adding arguments to the #! line.</p>
<p class="Pp">The file $exp_library/expect.rc is sourced automatically if
    present, unless the <b>-N</b> flag is used. (When using Expectk, this option
    is specified as <b>-NORC</b>.) Immediately after this, the file ~/.expect.rc
    is sourced automatically, unless the <b>-n</b> flag is used. If the
    environment variable DOTDIR is defined, it is treated as a directory and
    .expect.rc is read from there. (When using Expectk, this option is specified
    as <b>-norc</b>.) This sourcing occurs only after executing any <b>-c</b>
    flags.</p>
<p class="Pp"><b>-v</b> causes Expect to print its version number and exit. (The
    corresponding flag in Expectk, which uses long flag names, is -version.)</p>
<p class="Pp">Optional <i>args</i> are constructed into a list and stored in the
    variable named <i>argv</i>. <i>argc</i> is initialized to the length of
    argv.</p>
<p class="Pp"><i>argv0</i> is defined to be the name of the script (or binary if
    no script is used). For example, the following prints out the name of the
    script and the first three arguments:</p>
<pre>
    send_user &quot;$argv0 [lrange $argv 0 2]\n&quot;
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="COMMANDS"><a class="permalink" href="#COMMANDS">COMMANDS</a></h1>
<b>Expect</b> uses <i>Tcl</i> (Tool Command Language). Tcl provides control flow
  (e.g., if, for, break), expression evaluation and several other features such
  as recursion, procedure definition, etc. Commands used here but not defined
  (e.g., <b>set</b>, <b>if</b>, <b>exec</b>) are Tcl commands (see tcl(3)).
  <b>Expect</b> supports additional commands, described below. Unless otherwise
  specified, commands return the empty string.
<p class="Pp">Commands are listed alphabetically so that they can be quickly
    located. However, new users may find it easier to start by reading the
    descriptions of <b>spawn</b>, <b>send</b>, <b>expect</b>, and
    <b>interact</b>, in that order.</p>
<p class="Pp">Note that the best introduction to the language (both Expect and
    Tcl) is provided in the book &quot;Exploring Expect&quot; (see SEE ALSO
    below). Examples are included in this man page but they are very limited
    since this man page is meant primarily as reference material.</p>
<p class="Pp">Note that in the text of this man page, &quot;Expect&quot; with an
    uppercase &quot;E&quot; refers to the <b>Expect</b> program while
    &quot;expect&quot; with a lower-case &quot;e&quot; refers to the
    <b>expect</b> command within the <b>Expect</b> program.)</p>
<dl class="Bl-tag">
  <dt><b>close</b><i> [-slave] [-onexec 0|1] [-i spawn_id]</i></dt>
  <dd>closes the connection to the current process. Most interactive programs
      will detect EOF on their stdin and exit; thus <b>close</b> usually
      suffices to kill the process as well. The <b>-i</b> flag declares the
      process to close corresponding to the named spawn_id.
    <p class="Pp">Both <b>expect</b> and <b>interact</b> will detect when the
        current process exits and implicitly do a <b>close</b>. But if you kill
        the process by, say, &quot;exec kill $pid&quot;, you will need to
        explicitly call <b>close</b>.</p>
    <p class="Pp">The <b>-onexec</b> flag determines whether the spawn id will
        be closed in any new spawned processes or if the process is overlayed.
        To leave a spawn id open, use the value 0. A non-zero integer value will
        force the spawn closed (the default) in any new processes.</p>
    <p class="Pp">The <b>-slave</b> flag closes the slave associated with the
        spawn id. (See &quot;spawn -pty&quot;.) When the connection is closed,
        the slave is automatically closed as well if still open.</p>
    <p class="Pp">No matter whether the connection is closed implicitly or
        explicitly, you should call <b>wait</b> to clear up the corresponding
        kernel process slot. <b>close</b> does not call <b>wait</b> since there
        is no guarantee that closing a process connection will cause it to exit.
        See <b>wait</b> below for more info.</p>
  </dd>
  <dt><b>debug</b><i> [[-now] 0|1]</i></dt>
  <dd>controls a Tcl debugger allowing you to step through statements, set
      breakpoints, etc.
    <p class="Pp">With no arguments, a 1 is returned if the debugger is not
        running, otherwise a 0 is returned.</p>
    <p class="Pp">With a 1 argument, the debugger is started. With a 0 argument,
        the debugger is stopped. If a 1 argument is preceded by the <b>-now</b>
        flag, the debugger is started immediately (i.e., in the middle of the
        <b>debug</b> command itself). Otherwise, the debugger is started with
        the next Tcl statement.</p>
    <p class="Pp">The <b>debug</b> command does not change any traps. Compare
        this to starting Expect with the <b>-D</b> flag (see above).</p>
    <p class="Pp">See the README file or SEE ALSO (below) for more information
        on the debugger.</p>
  </dd>
  <dt><b>disconnect</b></dt>
  <dd>disconnects a forked process from the terminal. It continues running in
      the background. The process is given its own process group (if possible).
      Standard I/O is redirected to /dev/null.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>The following fragment uses <b>disconnect</b> to continue running the
      script in the background.
    <pre>
    if {[fork]!=0} exit
    disconnect
    . . .
    </pre>
    The following script reads a password, and then runs a program every hour
      that demands a password each time it is run. The script supplies the
      password so that you only have to type it once. (See the <b>stty</b>
      command which demonstrates how to turn off password echoing.)
    <pre>
    send_user &quot;password?\ &quot;
    expect_user -re &quot;(.*)\n&quot;
    for {} 1 {} {
        if {[fork]!=0} {sleep 3600;continue}
        disconnect
        spawn priv_prog
        expect Password:
        send &quot;$expect_out(1,string)\r&quot;
        . . .
        exit
    }
    </pre>
    An advantage to using <b>disconnect</b> over the shell asynchronous process
      feature (&amp;) is that <b>Expect</b> can save the terminal parameters
      prior to disconnection, and then later apply them to new ptys. With &amp;,
      <b>Expect</b> does not have a chance to read the terminal's parameters
      since the terminal is already disconnected by the time <b>Expect</b>
      receives control.</dd>
</dl>
<dl class="Bl-tag">
  <dt><b>exit</b><i> [-opts] [status]</i></dt>
  <dd>causes <b>Expect</b> to exit or otherwise prepare to do so.
    <p class="Pp">The <b>-onexit</b> flag causes the next argument to be used as
        an exit handler. Without an argument, the current exit handler is
        returned.</p>
    <p class="Pp">The <b>-noexit</b> flag causes <b>Expect</b> to prepare to
        exit but stop short of actually returning control to the operating
        system. The user-defined exit handler is run as well as Expect's own
        internal handlers. No further Expect commands should be executed. This
        is useful if you are running Expect with other Tcl extensions. The
        current interpreter (and main window if in the Tk environment) remain so
        that other Tcl extensions can clean up. If Expect's <b>exit</b> is
        called again (however this might occur), the handlers are not rerun.</p>
    <p class="Pp">Upon exiting, all connections to spawned processes are closed.
        Closure will be detected as an EOF by spawned processes. <b>exit</b>
        takes no other actions beyond what the normal _exit(2) procedure does.
        Thus, spawned processes that do not check for EOF may continue to run.
        (A variety of conditions are important to determining, for example, what
        signals a spawned process will be sent, but these are system-dependent,
        typically documented under exit(3).) Spawned processes that continue to
        run will be inherited by init.</p>
    <p class="Pp"><i>status</i> (or 0 if not specified) is returned as the exit
        status of <b>Expect</b>. <b>exit</b> is implicitly executed if the end
        of the script is reached.</p>
  </dd>
  <dt><b>exp_continue</b> [-continue_timer]</dt>
  <dd>The command <b>exp_continue</b> allows <b>expect</b> itself to continue
      executing rather than returning as it normally would. By default
      <b>exp_continue</b> resets the timeout timer. The <i>-continue_timer</i>
      flag prevents timer from being restarted. (See <b>expect</b> for more
      information.)</dd>
  <dt><b>exp_internal</b><i> [-f file] value</i></dt>
  <dd>causes further commands to send diagnostic information internal to
      <b>Expect</b> to stderr if <i>value</i> is non-zero. This output is
      disabled if <i>value</i> is 0. The diagnostic information includes every
      character received, and every attempt made to match the current output
      against the patterns.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>If the optional <i>file</i> is supplied, all normal and debugging output
      is written to that file (regardless of the value of <i>value</i>). Any
      previous diagnostic output file is closed.
    <p class="Pp">The <b>-info</b> flag causes exp_internal to return a
        description of the most recent non-info arguments given.</p>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt><b>exp_open</b><i> [args] [-i spawn_id]</i></dt>
  <dd>returns a Tcl file identifier that corresponds to the original spawn id.
      The file identifier can then be used as if it were opened by Tcl's
      <b>open</b> command. (The spawn id should no longer be used. A <b>wait</b>
      should not be executed.
    <p class="Pp">The <b>-leaveopen</b> flag leaves the spawn id open for access
        through Expect commands. A <b>wait</b> must be executed on the spawn
      id.</p>
  </dd>
  <dt><b>exp_pid</b><i> [-i spawn_id]</i></dt>
  <dd>returns the process id corresponding to the currently spawned process. If
      the <b>-i</b> flag is used, the pid returned corresponds to that of the
      given spawn id.</dd>
  <dt><b>exp_send</b></dt>
  <dd>is an alias for <b>send</b>.</dd>
  <dt><b>exp_send_error</b></dt>
  <dd>is an alias for <b>send_error</b>.</dd>
  <dt><b>exp_send_log</b></dt>
  <dd>is an alias for <b>send_log</b>.</dd>
  <dt><b>exp_send_tty</b></dt>
  <dd>is an alias for <b>send_tty</b>.</dd>
  <dt><b>exp_send_user</b></dt>
  <dd>is an alias for <b>send_user</b>.</dd>
  <dt><b>exp_version</b><i> [[-exit] version]</i></dt>
  <dd>is useful for assuring that the script is compatible with the current
      version of Expect.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>With no arguments, the current version of <b>Expect</b> is returned. This
      version may then be encoded in your script. If you actually know that you
      are not using features of recent versions, you can specify an earlier
      version.</dd>
  <dt></dt>
  <dd>Versions consist of three numbers separated by dots. First is the major
      number. Scripts written for versions of <b>Expect</b> with a different
      major number will almost certainly not work. <b>exp_version</b> returns an
      error if the major numbers do not match.</dd>
  <dt></dt>
  <dd>Second is the minor number. Scripts written for a version with a greater
      minor number than the current version may depend upon some new feature and
      might not run. <b>exp_version</b> returns an error if the major numbers
      match, but the script minor number is greater than that of the running
      <b>Expect</b>.</dd>
  <dt></dt>
  <dd>Third is a number that plays no part in the version comparison. However,
      it is incremented when the <b>Expect</b> software distribution is changed
      in any way, such as by additional documentation or optimization. It is
      reset to 0 upon each new minor version.</dd>
  <dt></dt>
  <dd>With the <b>-exit</b> flag, <b>Expect</b> prints an error and exits if the
      version is out of date.</dd>
</dl>
<dl class="Bl-tag">
  <dt><b>expect</b><i> [[-opts] pat1 body1] ... [-opts] patn [bodyn]</i></dt>
  <dd>waits until one of the patterns matches the output of a spawned process, a
      specified time period has passed, or an end-of-file is seen. If the final
      body is empty, it may be omitted.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>Patterns from the most recent <b>expect_before</b> command are implicitly
      used before any other patterns. Patterns from the most recent
      <b>expect_after</b> command are implicitly used after any other
    patterns.</dd>
  <dt></dt>
  <dd>If the arguments to the entire <b>expect</b> statement require more than
      one line, all the arguments may be &quot;braced&quot; into one so as to
      avoid terminating each line with a backslash. In this one case, the usual
      Tcl substitutions will occur despite the braces.</dd>
  <dt></dt>
  <dd>If a pattern is the keyword <b>eof</b>, the corresponding body is executed
      upon end-of-file. If a pattern is the keyword <b>timeout</b>, the
      corresponding body is executed upon timeout. If no timeout keyword is
      used, an implicit null action is executed upon timeout. The default
      timeout period is 10 seconds but may be set, for example to 30, by the
      command &quot;set timeout 30&quot;. An infinite timeout may be designated
      by the value -1. If a pattern is the keyword <b>default</b>, the
      corresponding body is executed upon either timeout or end-of-file.</dd>
  <dt></dt>
  <dd>If a pattern matches, then the corresponding body is executed.
      <b>expect</b> returns the result of the body (or the empty string if no
      pattern matched). In the event that multiple patterns match, the one
      appearing first is used to select a body.</dd>
  <dt></dt>
  <dd>Each time new output arrives, it is compared to each pattern in the order
      they are listed. Thus, you may test for absence of a match by making the
      last pattern something guaranteed to appear, such as a prompt. In
      situations where there is no prompt, you must use <b>timeout</b> (just
      like you would if you were interacting manually).</dd>
  <dt></dt>
  <dd>Patterns are specified in three ways. By default, patterns are specified
      as with Tcl's <b>string match</b> command. (Such patterns are also similar
      to C-shell regular expressions usually referred to as &quot;glob&quot;
      patterns). The <b>-gl</b> flag may may be used to protect patterns that
      might otherwise match <b>expect</b> flags from doing so. Any pattern
      beginning with a &quot;-&quot; should be protected this way. (All strings
      starting with &quot;-&quot; are reserved for future options.)
    <p class="Pp"></p>
  </dd>
  <dt></dt>
  <dd>For example, the following fragment looks for a successful login. (Note
      that <b>abort</b> is presumed to be a procedure defined elsewhere in the
      script.)
    <pre>
    expect {
        busy               {puts busy\n ; exp_continue}
        failed             abort
        &quot;invalid password&quot; abort
        timeout            abort
        connected
    }
    </pre>
    Quotes are necessary on the fourth pattern since it contains a space, which
      would otherwise separate the pattern from the action. Patterns with the
      same action (such as the 3rd and 4th) require listing the actions again.
      This can be avoid by using regexp-style patterns (see below). More
      information on forming glob-style patterns can be found in the Tcl
    manual.</dd>
  <dt></dt>
  <dd>Regexp-style patterns follow the syntax defined by Tcl's <b>regexp</b>
      (short for &quot;regular expression&quot;) command. regexp patterns are
      introduced with the flag <b>-re</b>. The previous example can be rewritten
      using a regexp as:
    <pre>
    expect {
        busy       {puts busy\n ; exp_continue}
        -re &quot;failed|invalid password&quot; abort
        timeout    abort
        connected
    }
    </pre>
    Both types of patterns are &quot;unanchored&quot;. This means that patterns
      do not have to match the entire string, but can begin and end the match
      anywhere in the string (as long as everything else matches). Use ^ to
      match the beginning of a string, and $ to match the end. Note that if you
      do not wait for the end of a string, your responses can easily end up in
      the middle of the string as they are echoed from the spawned process.
      While still producing correct results, the output can look unnatural.
      Thus, use of $ is encouraged if you can exactly describe the characters at
      the end of a string.
    <p class="Pp">Note that in many editors, the ^ and $ match the beginning and
        end of lines respectively. However, because expect is not line oriented,
        these characters match the beginning and end of the data (as opposed to
        lines) currently in the expect matching buffer. (Also, see the note
        below on &quot;system indigestion.&quot;)</p>
    <p class="Pp">The <b>-ex</b> flag causes the pattern to be matched as an
        &quot;exact&quot; string. No interpretation of *, ^, etc is made
        (although the usual Tcl conventions must still be observed). Exact
        patterns are always unanchored.</p>
    <p class="Pp"></p>
  </dd>
  <dt></dt>
  <dd>The <b>-nocase</b> flag causes uppercase characters of the output to
      compare as if they were lowercase characters. The pattern is not
    affected.</dd>
  <dt></dt>
  <dd>While reading output, more than 2000 bytes can force earlier bytes to be
      &quot;forgotten&quot;. This may be changed with the function
      <b>match_max</b>. (Note that excessively large values can slow down the
      pattern matcher.) If <i>patlist</i> is <b>full_buffer</b>, the
      corresponding body is executed if <i>match_max</i> bytes have been
      received and no other patterns have matched. Whether or not the
      <b>full_buffer</b> keyword is used, the forgotten characters are written
      to expect_out(buffer).
    <p class="Pp">If <i>patlist</i> is the keyword <b>null</b>, and nulls are
        allowed (via the <b>remove_nulls</b> command), the corresponding body is
        executed if a single ASCII 0 is matched. It is not possible to match 0
        bytes via glob or regexp patterns.</p>
    <p class="Pp">Upon matching a pattern (or eof or full_buffer), any matching
        and previously unmatched output is saved in the variable
        <i>expect_out(buffer)</i>. Up to 9 regexp substring matches are saved in
        the variables <i>expect_out(1,string)</i> through
        <i>expect_out(9,string)</i>. If the <b>-indices</b> flag is used before
        a pattern, the starting and ending indices (in a form suitable for
        <b>lrange</b>) of the 10 strings are stored in the variables
        <i>expect_out(X,start)</i> and <i>expect_out(X,end)</i> where X is a
        digit, corresponds to the substring position in the buffer. 0 refers to
        strings which matched the entire pattern and is generated for glob
        patterns as well as regexp patterns. For example, if a process has
        produced output of &quot;abcdefgh\n&quot;, the result of:</p>
    <pre>
    expect &quot;cd&quot;
    </pre>
    is as if the following statements had executed:
    <pre>
    set expect_out(0,string) cd
    set expect_out(buffer) abcd
    </pre>
    and &quot;efgh\n&quot; is left in the output buffer. If a process produced
      the output &quot;abbbcabkkkka\n&quot;, the result of:
    <pre>
    expect -indices -re &quot;b(b*).*(k+)&quot;
    </pre>
    is as if the following statements had executed:
    <pre>
    set expect_out(0,start) 1
    set expect_out(0,end) 10
    set expect_out(0,string) bbbcabkkkk
    set expect_out(1,start) 2
    set expect_out(1,end) 3
    set expect_out(1,string) bb
    set expect_out(2,start) 10
    set expect_out(2,end) 10
    set expect_out(2,string) k
    set expect_out(buffer) abbbcabkkkk
    </pre>
    and &quot;a\n&quot; is left in the output buffer. The pattern &quot;*&quot;
      (and -re &quot;.*&quot;) will flush the output buffer without reading any
      more output from the process.</dd>
  <dt></dt>
  <dd>Normally, the matched output is discarded from Expect's internal buffers.
      This may be prevented by prefixing a pattern with the <b>-notransfer</b>
      flag. This flag is especially useful in experimenting (and can be
      abbreviated to &quot;-not&quot; for convenience while experimenting).
    <p class="Pp">The spawn id associated with the matching output (or eof or
        full_buffer) is stored in <i>expect_out(spawn_id)</i>.</p>
    <p class="Pp">The <b>-timeout</b> flag causes the current expect command to
        use the following value as a timeout instead of using the value of the
        timeout variable.</p>
    <p class="Pp">By default, patterns are matched against output from the
        current process, however the <b>-i</b> flag declares the output from the
        named spawn_id list be matched against any following patterns (up to the
        next <b>-i</b>). The spawn_id list should either be a whitespace
        separated list of spawn_ids or a variable referring to such a list of
        spawn_ids.</p>
    <p class="Pp">For example, the following example waits for
        &quot;connected&quot; from the current process, or &quot;busy&quot;,
        &quot;failed&quot; or &quot;invalid password&quot; from the spawn_id
        named by $proc2.</p>
    <pre>
    expect {
        -i $proc2 busy {puts busy\n ; exp_continue}
        -re &quot;failed|invalid password&quot; abort
        timeout abort
        connected
    }
    </pre>
    The value of the global variable <i>any_spawn_id</i> may be used to match
      patterns to any spawn_ids that are named with all other <b>-i</b> flags in
      the current <b>expect</b> command. The spawn_id from a <b>-i</b> flag with
      no associated pattern (i.e., followed immediately by another <b>-i</b>) is
      made available to any other patterns in the same <b>expect</b> command
      associated with <i>any_spawn_id.</i>
    <p class="Pp">The <b>-i</b> flag may also name a global variable in which
        case the variable is read for a list of spawn ids. The variable is
        reread whenever it changes. This provides a way of changing the I/O
        source while the command is in execution. Spawn ids provided this way
        are called &quot;indirect&quot; spawn ids.</p>
    <p class="Pp">Actions such as <b>break</b> and <b>continue</b> cause control
        structures (i.e., <b>for</b>, <b>proc</b>) to behave in the usual way.
        The command <b>exp_continue</b> allows <b>expect</b> itself to continue
        executing rather than returning as it normally would.</p>
  </dd>
  <dt></dt>
  <dd>This is useful for avoiding explicit loops or repeated expect statements.
      The following example is part of a fragment to automate rlogin. The
      <b>exp_continue</b> avoids having to write a second <b>expect</b>
      statement (to look for the prompt again) if the rlogin prompts for a
      password.
    <pre>
    expect {
        Password: {
            stty -echo
            send_user &quot;password (for $user) on $host: &quot;
            expect_user -re &quot;(.*)\n&quot;
            send_user &quot;\n&quot;
            send &quot;$expect_out(1,string)\r&quot;
            stty echo
            exp_continue
        } incorrect {
            send_user &quot;invalid password or account\n&quot;
            exit
        } timeout {
            send_user &quot;connection to $host timed out\n&quot;
            exit
        } eof {
            send_user \
                &quot;connection to host failed: $expect_out(buffer)&quot;
            exit
        } -re $prompt
    }
    </pre>
    For example, the following fragment might help a user guide an interaction
      that is already totally automated. In this case, the terminal is put into
      raw mode. If the user presses &quot;+&quot;, a variable is incremented. If
      &quot;p&quot; is pressed, several returns are sent to the process, perhaps
      to poke it in some way, and &quot;i&quot; lets the user interact with the
      process, effectively stealing away control from the script. In each case,
      the <b>exp_continue</b> allows the current <b>expect</b> to continue
      pattern matching after executing the current action.
    <pre>
    stty raw -echo
    expect_after {
        -i $user_spawn_id
        &quot;p&quot; {send &quot;\r\r\r&quot;; exp_continue}
        &quot;+&quot; {incr foo; exp_continue}
        &quot;i&quot; {interact; exp_continue}
        &quot;quit&quot; exit
    }
    </pre>
  </dd>
  <dt></dt>
  <dd>By default, <b>exp_continue</b> resets the timeout timer. The timer is not
      restarted, if <b>exp_continue</b> is called with the
      <b>-continue_timer</b> flag.</dd>
</dl>
<dl class="Bl-tag">
  <dt><b>expect_after</b><i> [expect_args]</i></dt>
  <dd>works identically to the <b>expect_before</b> except that if patterns from
      both <b>expect</b> and <b>expect_after</b> can match, the <b>expect</b>
      pattern is used. See the <b>expect_before</b> command for more
      information.</dd>
  <dt><b>expect_background</b><i> [expect_args]</i></dt>
  <dd>takes the same arguments as <b>expect</b>, however it returns immediately.
      Patterns are tested whenever new input arrives. The pattern <b>timeout</b>
      and <b>default</b> are meaningless to <b>expect_background</b> and are
      silently discarded. Otherwise, the <b>expect_background</b> command uses
      <b>expect_before</b> and <b>expect_after</b> patterns just like
      <b>expect</b> does.
    <p class="Pp">When <b>expect_background</b> actions are being evaluated,
        background processing for the same spawn id is blocked. Background
        processing is unblocked when the action completes. While background
        processing is blocked, it is possible to do a (foreground) <b>expect</b>
        on the same spawn id.</p>
    <p class="Pp">It is not possible to execute an <b>expect</b> while an
        <b>expect_background</b> is unblocked. <b>expect_background</b> for a
        particular spawn id is deleted by declaring a new expect_background with
        the same spawn id. Declaring <b>expect_background</b> with no pattern
        removes the given spawn id from the ability to match patterns in the
        background.</p>
  </dd>
  <dt><b>expect_before</b><i> [expect_args]</i></dt>
  <dd>takes the same arguments as <b>expect</b>, however it returns immediately.
      Pattern-action pairs from the most recent <b>expect_before</b> with the
      same spawn id are implicitly added to any following <b>expect</b>
      commands. If a pattern matches, it is treated as if it had been specified
      in the <b>expect</b> command itself, and the associated body is executed
      in the context of the <b>expect</b> command. If patterns from both
      <b>expect_before</b> and <b>expect</b> can match, the <b>expect_before</b>
      pattern is used.
    <p class="Pp">If no pattern is specified, the spawn id is not checked for
        any patterns.</p>
    <p class="Pp">Unless overridden by a <b>-i</b> flag, <b>expect_before</b>
        patterns match against the spawn id defined at the time that the
        <b>expect_before</b> command was executed (not when its pattern is
        matched).</p>
    <p class="Pp">The -info flag causes <b>expect_before</b> to return the
        current specifications of what patterns it will match. By default, it
        reports on the current spawn id. An optional spawn id specification may
        be given for information on that spawn id. For example</p>
    <pre>
    expect_before -info -i $proc
    </pre>
    At most one spawn id specification may be given. The flag -indirect
      suppresses direct spawn ids that come only from indirect specifications.
    <p class="Pp">Instead of a spawn id specification, the flag &quot;-all&quot;
        will cause &quot;-info&quot; to report on all spawn ids.</p>
    <p class="Pp">The output of the -info flag can be reused as the argument to
        expect_before.</p>
  </dd>
  <dt><b>expect_tty</b><i> [expect_args]</i></dt>
  <dd>is like <b>expect</b> but it reads characters from /dev/tty (i.e.
      keystrokes from the user). By default, reading is performed in cooked
      mode. Thus, lines must end with a return in order for <b>expect</b> to see
      them. This may be changed via <b>stty</b> (see the <b>stty</b> command
      below).</dd>
  <dt><b>expect_user</b><i> [expect_args]</i></dt>
  <dd>is like <b>expect</b> but it reads characters from stdin (i.e. keystrokes
      from the user). By default, reading is performed in cooked mode. Thus,
      lines must end with a return in order for <b>expect</b> to see them. This
      may be changed via <b>stty</b> (see the <b>stty</b> command below).</dd>
  <dt><b>fork</b></dt>
  <dd>creates a new process. The new process is an exact copy of the current
      <b>Expect</b> process. On success, <b>fork</b> returns 0 to the new
      (child) process and returns the process ID of the child process to the
      parent process. On failure (invariably due to lack of resources, e.g.,
      swap space, memory), <b>fork</b> returns -1 to the parent process, and no
      child process is created.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>Forked processes exit via the <b>exit</b> command, just like the original
      process. Forked processes are allowed to write to the log files. If you do
      not disable debugging or logging in most of the processes, the result can
      be confusing.</dd>
  <dt></dt>
  <dd>Some pty implementations may be confused by multiple readers and writers,
      even momentarily. Thus, it is safest to <b>fork</b> before spawning
      processes.</dd>
</dl>
<dl class="Bl-tag">
  <dt><b>interact</b><i> [string1 body1] ... [stringn [bodyn]]</i></dt>
  <dd>gives control of the current process to the user, so that keystrokes are
      sent to the current process, and the stdout and stderr of the current
      process are returned.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>String-body pairs may be specified as arguments, in which case the body is
      executed when the corresponding string is entered. (By default, the string
      is not sent to the current process.) The <b>interpreter</b> command is
      assumed, if the final body is missing.</dd>
  <dt></dt>
  <dd>If the arguments to the entire <b>interact</b> statement require more than
      one line, all the arguments may be &quot;braced&quot; into one so as to
      avoid terminating each line with a backslash. In this one case, the usual
      Tcl substitutions will occur despite the braces.</dd>
  <dt></dt>
  <dd>For example, the following command runs interact with the following
      string-body pairs defined: When ^Z is pressed, <b>Expect</b> is suspended.
      (The <b>-reset</b> flag restores the terminal modes.) When ^A is pressed,
      the user sees &quot;you typed a control-A&quot; and the process is sent a
      ^A. When $ is pressed, the user sees the date. When ^C is pressed,
      <b>Expect</b> exits. If &quot;foo&quot; is entered, the user sees
      &quot;bar&quot;. When ~~ is pressed, the <b>Expect</b> interpreter runs
      interactively.
    <pre>
    set CTRLZ \032
    interact {
        -reset $CTRLZ {exec kill -STOP [pid]}
        \001   {send_user &quot;you typed a control-A\n&quot;;
                send &quot;\001&quot;
               }
        $      {send_user &quot;The date is [clock format [clock seconds]].&quot;}
        \003   exit
        foo    {send_user &quot;bar&quot;}
        ~~
    }
    </pre>
  </dd>
  <dt></dt>
  <dd>In string-body pairs, strings are matched in the order they are listed as
      arguments. Strings that partially match are not sent to the current
      process in anticipation of the remainder coming. If characters are then
      entered such that there can no longer possibly be a match, only the part
      of the string will be sent to the process that cannot possibly begin
      another match. Thus, strings that are substrings of partial matches can
      match later, if the original strings that was attempting to be match
      ultimately fails.</dd>
  <dt></dt>
  <dd>By default, string matching is exact with no wild cards. (In contrast, the
      <b>expect</b> command uses glob-style patterns by default.) The <b>-ex</b>
      flag may be used to protect patterns that might otherwise match
      <b>interact</b> flags from doing so. Any pattern beginning with a
      &quot;-&quot; should be protected this way. (All strings starting with
      &quot;-&quot; are reserved for future options.)
    <p class="Pp">The <b>-re</b> flag forces the string to be interpreted as a
        regexp-style pattern. In this case, matching substrings are stored in
        the variable <i>interact_out</i> similarly to the way <b>expect</b>
        stores its output in the variable <b>expect_out</b>. The <b>-indices</b>
        flag is similarly supported.</p>
    <p class="Pp">The pattern <b>eof</b> introduces an action that is executed
        upon end-of-file. A separate <b>eof</b> pattern may also follow the
        <b>-output</b> flag in which case it is matched if an eof is detected
        while writing output. The default <b>eof</b> action is
        &quot;return&quot;, so that <b>interact</b> simply returns upon any
      EOF.</p>
    <p class="Pp">The pattern <b>timeout</b> introduces a timeout (in seconds)
        and action that is executed after no characters have been read for a
        given time. The <b>timeout</b> pattern applies to the most recently
        specified process. There is no default timeout. The special variable
        &quot;timeout&quot; (used by the <b>expect</b> command) has no affect on
        this timeout.</p>
    <p class="Pp">For example, the following statement could be used to
        autologout users who have not typed anything for an hour but who still
        get frequent system messages:</p>
    <pre>
    interact -input $user_spawn_id timeout 3600 return -output \
        $spawn_id 
    </pre>
    <p class="Pp">If the pattern is the keyword <b>null</b>, and nulls are
        allowed (via the <b>remove_nulls</b> command), the corresponding body is
        executed if a single ASCII 0 is matched. It is not possible to match 0
        bytes via glob or regexp patterns.</p>
    <p class="Pp">Prefacing a pattern with the flag <b>-iwrite</b> causes the
        variable <i>interact_out(spawn_id)</i> to be set to the spawn_id which
        matched the pattern (or eof).</p>
    <p class="Pp">Actions such as <b>break</b> and <b>continue</b> cause control
        structures (i.e., <b>for</b>, <b>proc</b>) to behave in the usual way.
        However <b>return</b> causes interact to return to its caller, while
        <b>inter_return</b> causes <b>interact</b> to cause a return in its
        caller. For example, if &quot;proc foo&quot; called <b>interact</b>
        which then executed the action <b>inter_return</b>, <b>proc foo</b>
        would return. (This means that if <b>interact</b> calls
        <b>interpreter</b> interactively typing <b>return</b> will cause the
        interact to continue, while <b>inter_return</b> will cause the interact
        to return to its caller.)</p>
  </dd>
  <dt></dt>
  <dd>During <b>interact</b>, raw mode is used so that all characters may be
      passed to the current process. If the current process does not catch job
      control signals, it will stop if sent a stop signal (by default ^Z). To
      restart it, send a continue signal (such as by &quot;kill -CONT
      &lt;pid&gt;&quot;). If you really want to send a SIGSTOP to such a process
      (by ^Z), consider spawning csh first and then running your program. On the
      other hand, if you want to send a SIGSTOP to <b>Expect</b> itself, first
      call interpreter (perhaps by using an escape character), and then press
      ^Z.</dd>
  <dt></dt>
  <dd>String-body pairs can be used as a shorthand for avoiding having to enter
      the interpreter and execute commands interactively. The previous terminal
      mode is used while the body of a string-body pair is being executed.</dd>
  <dt></dt>
  <dd>For speed, actions execute in raw mode by default. The <b>-reset</b> flag
      resets the terminal to the mode it had before <b>interact</b> was executed
      (invariably, cooked mode). Note that characters entered when the mode is
      being switched may be lost (an unfortunate feature of the terminal driver
      on some systems). The only reason to use <b>-reset</b> is if your action
      depends on running in cooked mode.</dd>
  <dt></dt>
  <dd>The <b>-echo</b> flag sends characters that match the following pattern
      back to the process that generated them as each character is read. This
      may be useful when the user needs to see feedback from partially typed
      patterns.</dd>
  <dt></dt>
  <dd>If a pattern is being echoed but eventually fails to match, the characters
      are sent to the spawned process. If the spawned process then echoes them,
      the user will see the characters twice. <b>-echo</b> is probably only
      appropriate in situations where the user is unlikely to not complete the
      pattern. For example, the following excerpt is from rftp, the
      recursive-ftp script, where the user is prompted to enter ~g, ~p, or ~l,
      to get, put, or list the current directory recursively. These are so far
      away from the normal ftp commands, that the user is unlikely to type ~
      followed by anything else, except mistakenly, in which case, they'll
      probably just ignore the result anyway.
    <pre>
    interact {
        -echo ~g {getcurdirectory 1}
        -echo ~l {getcurdirectory 0}
        -echo ~p {putcurdirectory}
    }
    </pre>
    The <b>-nobuffer</b> flag sends characters that match the following pattern
      on to the output process as characters are read.
    <p class="Pp">This is useful when you wish to let a program echo back the
        pattern. For example, the following might be used to monitor where a
        person is dialing (a Hayes-style modem). Each time &quot;atd&quot; is
        seen the script logs the rest of the line.</p>
    <pre>
    proc lognumber {} {
        interact -nobuffer -re &quot;(.*)\r&quot; return
        puts $log &quot;[clock format [clock seconds]]: dialed $interact_out(1,string)&quot;
    }
    interact -nobuffer &quot;atd&quot; lognumber
    </pre>
  </dd>
  <dt></dt>
  <dd>During <b>interact</b>, previous use of <b>log_user</b> is ignored. In
      particular, <b>interact</b> will force its output to be logged (sent to
      the standard output) since it is presumed the user doesn't wish to
      interact blindly.</dd>
  <dt></dt>
  <dd>The <b>-o</b> flag causes any following key-body pairs to be applied to
      the output of the current process. This can be useful, for example, when
      dealing with hosts that send unwanted characters during a telnet
    session.</dd>
  <dt></dt>
  <dd>By default, <b>interact</b> expects the user to be writing stdin and
      reading stdout of the <b>Expect</b> process itself. The <b>-u</b> flag
      (for &quot;user&quot;) makes <b>interact</b> look for the user as the
      process named by its argument (which must be a spawned id).</dd>
  <dt></dt>
  <dd>This allows two unrelated processes to be joined together without using an
      explicit loop. To aid in debugging, Expect diagnostics always go to stderr
      (or stdout for certain logging and debugging information). For the same
      reason, the <b>interpreter</b> command will read interactively from
    stdin.</dd>
  <dt></dt>
  <dd>For example, the following fragment creates a login process. Then it dials
      the user (not shown), and finally connects the two together. Of course,
      any process may be substituted for login. A shell, for example, would
      allow the user to work without supplying an account and password.
    <pre>
    spawn login
    set login $spawn_id
    spawn tip modem
    # dial back out to user
    # connect user to login
    interact -u $login
    </pre>
    To send output to multiple processes, list each spawn id list prefaced by a
      <b>-output</b> flag. Input for a group of output spawn ids may be
      determined by a spawn id list prefaced by a <b>-input</b> flag. (Both
      <b>-input</b> and <b>-output</b> may take lists in the same form as the
      <b>-i</b> flag in the <b>expect</b> command, except that any_spawn_id is
      not meaningful in <b>interact</b>.) All following flags and strings (or
      patterns) apply to this input until another -input flag appears. If no
      <b>-input</b> appears, <b>-output</b> implies &quot;-input $user_spawn_id
      -output&quot;. (Similarly, with patterns that do not have <b>-input</b>.)
      If one <b>-input</b> is specified, it overrides $user_spawn_id. If a
      second <b>-input</b> is specified, it overrides $spawn_id. Additional
      <b>-input</b> flags may be specified.
    <p class="Pp">The two implied input processes default to having their
        outputs specified as $spawn_id and $user_spawn_id (in reverse). If a
        <b>-input</b> flag appears with no <b>-output</b> flag, characters from
        that process are discarded.</p>
    <p class="Pp">The <b>-i</b> flag introduces a replacement for the current
        spawn_id when no other <b>-input</b> or <b>-output</b> flags are used. A
        -i flag implies a -o flag.</p>
    <p class="Pp">It is possible to change the processes that are being
        interacted with by using indirect spawn ids. (Indirect spawn ids are
        described in the section on the expect command.) Indirect spawn ids may
        be specified with the -i, -u, -input, or -output flags.</p>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt><b>interpreter [args]</b></dt>
  <dd>causes the user to be interactively prompted for <b>Expect</b> and Tcl
      commands. The result of each command is printed.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>Actions such as <b>break</b> and <b>continue</b> cause control structures
      (i.e., <b>for</b>, <b>proc</b>) to behave in the usual way. However
      <b>return</b> causes interpreter to return to its caller, while
      <b>inter_return</b> causes <b>interpreter</b> to cause a return in its
      caller. For example, if &quot;proc foo&quot; called <b>interpreter</b>
      which then executed the action <b>inter_return</b>, <b>proc foo</b> would
      return. Any other command causes <b>interpreter</b> to continue prompting
      for new commands.</dd>
  <dt></dt>
  <dd>By default, the prompt contains two integers. The first integer describes
      the depth of the evaluation stack (i.e., how many times Tcl_Eval has been
      called). The second integer is the Tcl history identifier. The prompt can
      be set by defining a procedure called &quot;prompt1&quot; whose return
      value becomes the next prompt. If a statement has open quotes, parens,
      braces, or brackets, a secondary prompt (by default &quot;+&gt; &quot;) is
      issued upon newline. The secondary prompt may be set by defining a
      procedure called &quot;prompt2&quot;.</dd>
  <dt></dt>
  <dd>During <b>interpreter</b>, cooked mode is used, even if the its caller was
      using raw mode.</dd>
  <dt></dt>
  <dd>If stdin is closed, <b>interpreter</b> will return unless the <b>-eof</b>
      flag is used, in which case the subsequent argument is invoked.</dd>
</dl>
<dl class="Bl-tag">
  <dt><b>log_file</b><i> [args] [[-a] file]</i></dt>
  <dd>If a filename is provided, <b>log_file</b> will record a transcript of the
      session (beginning at that point) in the file. <b>log_file</b> will stop
      recording if no argument is given. Any previous log file is closed.
    <p class="Pp">Instead of a filename, a Tcl file identifier may be provided
        by using the <b>-open</b> or <b>-leaveopen</b> flags. This is similar to
        the <b>spawn</b> command. (See <b>spawn</b> for more info.)</p>
    <p class="Pp">The <b>-a</b> flag forces output to be logged that was
        suppressed by the <b>log_user</b> command.</p>
    <p class="Pp">By default, the <b>log_file</b> command <i>appends</i> to old
        files rather than truncating them, for the convenience of being able to
        turn logging off and on multiple times in one session. To truncate
        files, use the <b>-noappend</b> flag.</p>
    <p class="Pp">The <b>-info</b> flag causes log_file to return a description
        of the most recent non-info arguments given.</p>
  </dd>
  <dt><b>log_user</b><i> -info|0|1</i></dt>
  <dd>By default, the send/expect dialogue is logged to stdout (and a logfile if
      open). The logging to stdout is disabled by the command &quot;log_user
      0&quot; and reenabled by &quot;log_user 1&quot;. Logging to the logfile is
      unchanged.
    <p class="Pp">The <b>-info</b> flag causes log_user to return a description
        of the most recent non-info arguments given.</p>
  </dd>
  <dt><b>match_max</b><i> [-d] [-i spawn_id] [size]</i></dt>
  <dd>defines the size of the buffer (in bytes) used internally by
      <b>expect</b>. With no <i>size</i> argument, the current size is
    returned.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>With the <b>-d</b> flag, the default size is set. (The initial default is
      2000.) With the <b>-i</b> flag, the size is set for the named spawn id,
      otherwise it is set for the current process.</dd>
</dl>
<dl class="Bl-tag">
  <dt><b>overlay</b><i> [-# spawn_id] [-# spawn_id] [...] program
    [args]</i></dt>
  <dd>executes <i>program args</i> in place of the current <b>Expect</b>
      program, which terminates. A bare hyphen argument forces a hyphen in front
      of the command name as if it was a login shell. All spawn_ids are closed
      except for those named as arguments. These are mapped onto the named file
      identifiers.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>Spawn_ids are mapped to file identifiers for the new program to inherit.
      For example, the following line runs chess and allows it to be controlled
      by the current process - say, a chess master.
    <pre>
    overlay -0 $spawn_id -1 $spawn_id -2 $spawn_id chess
    </pre>
    This is more efficient than &quot;interact -u&quot;, however, it sacrifices
      the ability to do programmed interaction since the <b>Expect</b> process
      is no longer in control.</dd>
  <dt></dt>
  <dd>Note that no controlling terminal is provided. Thus, if you disconnect or
      remap standard input, programs that do job control (shells, login, etc)
      will not function properly.</dd>
</dl>
<dl class="Bl-tag">
  <dt><b>parity</b><i> [-d] [-i spawn_id] [value]</i></dt>
  <dd>defines whether parity should be retained or stripped from the output of
      spawned processes. If <i>value</i> is zero, parity is stripped, otherwise
      it is not stripped. With no <i>value</i> argument, the current value is
      returned.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>With the <b>-d</b> flag, the default parity value is set. (The initial
      default is 1, i.e., parity is not stripped.) With the <b>-i</b> flag, the
      parity value is set for the named spawn id, otherwise it is set for the
      current process.</dd>
</dl>
<dl class="Bl-tag">
  <dt><b>remove_nulls</b><i> [-d] [-i spawn_id] [value]</i></dt>
  <dd>defines whether nulls are retained or removed from the output of spawned
      processes before pattern matching or storing in the variable
      <i>expect_out</i> or <i>interact_out</i>. If <i>value</i> is 1, nulls are
      removed. If <i>value</i> is 0, nulls are not removed. With no <i>value</i>
      argument, the current value is returned.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>With the <b>-d</b> flag, the default value is set. (The initial default is
      1, i.e., nulls are removed.) With the <b>-i</b> flag, the value is set for
      the named spawn id, otherwise it is set for the current process.
    <p class="Pp">Whether or not nulls are removed, <b>Expect</b> will record
        null bytes to the log and stdout.</p>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt><b>send</b><i> [-flags] string</i></dt>
  <dd>Sends <i>string</i> to the current process. For example, the command
    <pre>
    send &quot;hello world\r&quot;
    </pre>
    sends the characters, h e l l o &lt;blank&gt; w o r l d &lt;return&gt; to
      the current process. (Tcl includes a printf-like command (called
      <b>format</b>) which can build arbitrarily complex strings.)</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>Characters are sent immediately although programs with line-buffered input
      will not read the characters until a return character is sent. A return
      character is denoted &quot;\r&quot;.
    <p class="Pp">The <b>--</b> flag forces the next argument to be interpreted
        as a string rather than a flag. Any string can be preceded by
        &quot;--&quot; whether or not it actually looks like a flag. This
        provides a reliable mechanism to specify variable strings without being
        tripped up by those that accidentally look like flags. (All strings
        starting with &quot;-&quot; are reserved for future options.)</p>
    <p class="Pp">The <b>-i</b> flag declares that the string be sent to the
        named spawn_id. If the spawn_id is <i>user_spawn_id</i>, and the
        terminal is in raw mode, newlines in the string are translated to
        return-newline sequences so that they appear as if the terminal was in
        cooked mode. The <b>-raw</b> flag disables this translation.</p>
    <p class="Pp">The <b>-null</b> flag sends null characters (0 bytes). By
        default, one null is sent. An integer may follow the <b>-null</b> to
        indicate how many nulls to send.</p>
    <p class="Pp">The <b>-break</b> flag generates a break condition. This only
        makes sense if the spawn id refers to a tty device opened via
        &quot;spawn -open&quot;. If you have spawned a process such as tip, you
        should use tip's convention for generating a break.</p>
    <p class="Pp">The <b>-s</b> flag forces output to be sent
        &quot;slowly&quot;, thus avoid the common situation where a computer
        outtypes an input buffer that was designed for a human who would never
        outtype the same buffer. This output is controlled by the value of the
        variable &quot;send_slow&quot; which takes a two element list. The first
        element is an integer that describes the number of bytes to send
        atomically. The second element is a real number that describes the
        number of seconds by which the atomic sends must be separated. For
        example, &quot;set send_slow {10 .001}&quot; would force &quot;send
        -s&quot; to send strings with 1 millisecond in between each 10
        characters sent.</p>
    <p class="Pp">The <b>-h</b> flag forces output to be sent (somewhat) like a
        human actually typing. Human-like delays appear between the characters.
        (The algorithm is based upon a Weibull distribution, with modifications
        to suit this particular application.) This output is controlled by the
        value of the variable &quot;send_human&quot; which takes a five element
        list. The first two elements are average interarrival time of characters
        in seconds. The first is used by default. The second is used at word
        endings, to simulate the subtle pauses that occasionally occur at such
        transitions. The third parameter is a measure of variability where .1 is
        quite variable, 1 is reasonably variable, and 10 is quite invariable.
        The extremes are 0 to infinity. The last two parameters are,
        respectively, a minimum and maximum interarrival time. The minimum and
        maximum are used last and &quot;clip&quot; the final time. The ultimate
        average can be quite different from the given average if the minimum and
        maximum clip enough values.</p>
    <p class="Pp">As an example, the following command emulates a fast and
        consistent typist:</p>
    <pre>
    set send_human {.1 .3 1 .05 2}
    send -h &quot;I'm hungry.  Let's do lunch.&quot;
    </pre>
    while the following might be more suitable after a hangover:
    <pre>
    set send_human {.4 .4 .2 .5 100}
    send -h &quot;Goodd party lash night!&quot;
    </pre>
    Note that errors are not simulated, although you can set up error correction
      situations yourself by embedding mistakes and corrections in a send
      argument.
    <p class="Pp">The flags for sending null characters, for sending breaks, for
        forcing slow output and for human-style output are mutually exclusive.
        Only the one specified last will be used. Furthermore, no <i>string</i>
        argument can be specified with the flags for sending null characters or
        breaks.</p>
    <p class="Pp">It is a good idea to precede the first <b>send</b> to a
        process by an <b>expect</b>. <b>expect</b> will wait for the process to
        start, while <b>send</b> cannot. In particular, if the first <b>send</b>
        completes before the process starts running, you run the risk of having
        your data ignored. In situations where interactive programs offer no
        initial prompt, you can precede <b>send</b> by a delay as in:</p>
    <pre>
    # To avoid giving hackers hints on how to break in,
    # this system does not prompt for an external password.
    # Wait for 5 seconds for exec to complete
    spawn telnet very.secure.gov
    sleep 5
    send password\r
    </pre>
    <b>exp_send</b> is an alias for <b>send</b><i>.</i> If you are using Expectk
      or some other variant of Expect in the Tk environment, <b>send</b> is
      defined by Tk for an entirely different purpose. <b>exp_send</b> is
      provided for compatibility between environments. Similar aliases are
      provided for other Expect's other send commands.</dd>
</dl>
<dl class="Bl-tag">
  <dt><b>send_error</b><i> [-flags] string</i></dt>
  <dd>is like <b>send</b>, except that the output is sent to stderr rather than
      the current process.</dd>
  <dt><b>send_log</b><i> [--] string</i></dt>
  <dd>is like <b>send</b>, except that the string is only sent to the log file
      (see <b>log_file</b>.) The arguments are ignored if no log file is
    open.</dd>
  <dt><b>send_tty</b><i> [-flags] string</i></dt>
  <dd>is like <b>send</b>, except that the output is sent to /dev/tty rather
      than the current process.</dd>
  <dt><b>send_user</b><i> [-flags] string</i></dt>
  <dd>is like <b>send</b>, except that the output is sent to stdout rather than
      the current process.</dd>
  <dt><b>sleep</b><i> seconds</i></dt>
  <dd>causes the script to sleep for the given number of seconds. Seconds may be
      a decimal number. Interrupts (and Tk events if you are using Expectk) are
      processed while Expect sleeps.</dd>
  <dt><b>spawn</b><i> [args] program [args]</i></dt>
  <dd>creates a new process running <i>program args</i>. Its stdin, stdout and
      stderr are connected to Expect, so that they may be read and written by
      other <b>Expect</b> commands. The connection is broken by <b>close</b> or
      if the process itself closes any of the file identifiers.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>When a process is started by <b>spawn</b>, the variable <i>spawn_id</i> is
      set to a descriptor referring to that process. The process described by
      <i>spawn_id</i> is considered the <i>current process</i>. <i>spawn_id</i>
      may be read or written, in effect providing job control.</dd>
  <dt></dt>
  <dd><i>user_spawn_id</i> is a global variable containing a descriptor which
      refers to the user. For example, when <i>spawn_id</i> is set to this
      value, <b>expect</b> behaves like <b>expect_user</b>.
    <p class="Pp"><i><i>error_spawn_id</i></i> is a global variable containing a
        descriptor which refers to the standard error. For example, when
        <i>spawn_id</i> is set to this value, <b>send</b> behaves like
        <b>send_error</b>.</p>
  </dd>
  <dt></dt>
  <dd><i>tty_spawn_id</i> is a global variable containing a descriptor which
      refers to /dev/tty. If /dev/tty does not exist (such as in a cron, at, or
      batch script), then <i>tty_spawn_id</i> is not defined. This may be tested
      as:
    <pre>
    if {[info vars tty_spawn_id]} {
        # /dev/tty exists
    } else {
        # /dev/tty doesn't exist
        # probably in cron, batch, or at script
    }
    </pre>
  </dd>
  <dt></dt>
  <dd><b>spawn</b> returns the UNIX process id. If no process is spawned, 0 is
      returned. The variable <i>spawn_out(slave,name)</i> is set to the name of
      the pty slave device.</dd>
  <dt></dt>
  <dd>By default, <b>spawn</b> echoes the command name and arguments. The
      <b>-noecho</b> flag stops <b>spawn</b> from doing this.</dd>
  <dt></dt>
  <dd>The <b>-console</b> flag causes console output to be redirected to the
      spawned process. This is not supported on all systems.
    <p class="Pp">Internally, <b>spawn</b> uses a pty, initialized the same way
        as the user's tty. This is further initialized so that all settings are
        &quot;sane&quot; (according to stty(1)). If the variable
        <i>stty_init</i> is defined, it is interpreted in the style of stty
        arguments as further configuration. For example, &quot;set stty_init
        raw&quot; will cause further spawned processes's terminals to start in
        raw mode. <b>-nottycopy</b> skips the initialization based on the user's
        tty. <b>-nottyinit</b> skips the &quot;sane&quot; initialization.</p>
  </dd>
  <dt></dt>
  <dd>Normally, <b>spawn</b> takes little time to execute. If you notice spawn
      taking a significant amount of time, it is probably encountering ptys that
      are wedged. A number of tests are run on ptys to avoid entanglements with
      errant processes. (These take 10 seconds per wedged pty.) Running Expect
      with the <b>-d</b> option will show if <b>Expect</b> is encountering many
      ptys in odd states. If you cannot kill the processes to which these ptys
      are attached, your only recourse may be to reboot.
    <p class="Pp">If <i>program</i> cannot be spawned successfully because
        exec(2) fails (e.g. when <i>program</i> doesn't exist), an error message
        will be returned by the next <b>interact</b> or <b>expect</b> command as
        if <i>program</i> had run and produced the error message as output. This
        behavior is a natural consequence of the implementation of <b>spawn</b>.
        Internally, spawn forks, after which the spawned process has no way to
        communicate with the original <b>Expect</b> process except by
        communication via the spawn_id.</p>
    <p class="Pp">The <b>-open</b> flag causes the next argument to be
        interpreted as a Tcl file identifier (i.e., returned by <b>open</b>.)
        The spawn id can then be used as if it were a spawned process. (The file
        identifier should no longer be used.) This lets you treat raw devices,
        files, and pipelines as spawned processes without using a pty. 0 is
        returned to indicate there is no associated process. When the connection
        to the spawned process is closed, so is the Tcl file identifier. The
        <b>-leaveopen</b> flag is similar to <b>-open</b> except that
        <b>-leaveopen</b> causes the file identifier to be left open even after
        the spawn id is closed.</p>
    <p class="Pp">The <b>-pty</b> flag causes a pty to be opened but no process
        spawned. 0 is returned to indicate there is no associated process.
        Spawn_id is set as usual.</p>
    <p class="Pp">The variable <i>spawn_out(slave,fd)</i> is set to a file
        identifier corresponding to the pty slave. It can be closed using
        &quot;close -slave&quot;.</p>
    <p class="Pp">The <b>-ignore</b> flag names a signal to be ignored in the
        spawned process. Otherwise, signals get the default behavior. Signals
        are named as in the <b>trap</b> command, except that each signal
        requires a separate flag.</p>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt><b>strace</b><i> level</i></dt>
  <dd>causes following statements to be printed before being executed. (Tcl's
      trace command traces variables.) <i>level</i> indicates how far down in
      the call stack to trace. For example, the following command runs
      <b>Expect</b> while tracing the first 4 levels of calls, but none below
      that.
    <pre>
    expect -c &quot;strace 4&quot; script.exp
    </pre>
    <p class="Pp">The <b>-info</b> flag causes strace to return a description of
        the most recent non-info arguments given.</p>
  </dd>
  <dt><b>stty</b><i> args</i></dt>
  <dd>changes terminal modes similarly to the external stty command.
    <p class="Pp">By default, the controlling terminal is accessed. Other
        terminals can be accessed by appending &quot;&lt; /dev/tty...&quot; to
        the command. (Note that the arguments should not be grouped into a
        single argument.)</p>
    <p class="Pp">Requests for status return it as the result of the command. If
        no status is requested and the controlling terminal is accessed, the
        previous status of the raw and echo attributes are returned in a form
        which can later be used by the command.</p>
    <p class="Pp">For example, the arguments <b>raw</b> or <b>-cooked</b> put
        the terminal into raw mode. The arguments <b>-raw</b> or <b>cooked</b>
        put the terminal into cooked mode. The arguments <b>echo</b> and
        <b>-echo</b> put the terminal into echo and noecho mode
      respectively.</p>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>The following example illustrates how to temporarily disable echoing. This
      could be used in otherwise-automatic scripts to avoid embedding passwords
      in them. (See more discussion on this under EXPECT HINTS below.)
    <pre>
    stty -echo
    send_user &quot;Password: &quot;
    expect_user -re &quot;(.*)\n&quot;
    set password $expect_out(1,string)
    stty echo
    </pre>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt><b>system</b><i> args</i></dt>
  <dd>gives <i>args</i> to sh(1) as input, just as if it had been typed as a
      command from a terminal. <b>Expect</b> waits until the shell terminates.
      The return status from sh is handled the same way that <b>exec</b> handles
      its return status.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>In contrast to <b>exec</b> which redirects stdin and stdout to the script,
      <b>system</b> performs no redirection (other than that indicated by the
      string itself). Thus, it is possible to use programs which must talk
      directly to /dev/tty. For the same reason, the results of <b>system</b>
      are not recorded in the log.</dd>
</dl>
<dl class="Bl-tag">
  <dt><b>timestamp</b><i> [args]</i></dt>
  <dd>returns a timestamp. With no arguments, the number of seconds since the
      epoch is returned.
    <p class="Pp">The <b>-format</b> flag introduces a string which is returned
        but with substitutions made according to the POSIX rules for strftime.
        For example %a is replaced by an abbreviated weekday name (i.e., Sat).
        Others are:</p>
    <pre>
    %a      abbreviated weekday name
    %A      full weekday name
    %b      abbreviated month name
    %B      full month name
    %c      date-time as in: Wed Oct  6 11:45:56 1993
    %d      day of the month (01-31)
    %H      hour (00-23)
    %I      hour (01-12)
    %j      day (001-366)
    %m      month (01-12)
    %M      minute (00-59)
    %p      am or pm
    %S      second (00-61)
    %u      day (1-7, Monday is first day of week)
    %U      week (00-53, first Sunday is first day of week one)
    %V      week (01-53, ISO 8601 style)
    %w      day (0-6)
    %W      week (00-53, first Monday is first day of week one)
    %x      date-time as in: Wed Oct  6 1993
    %X      time as in: 23:59:59
    %y      year (00-99)
    %Y      year as in: 1993
    %Z      timezone (or nothing if not determinable)
    %%      a bare percent sign
    </pre>
    Other % specifications are undefined. Other characters will be passed
      through untouched. Only the C locale is supported.
    <p class="Pp">The <b>-seconds</b> flag introduces a number of seconds since
        the epoch to be used as a source from which to format. Otherwise, the
        current time is used.</p>
    <p class="Pp">The <b>-gmt</b> flag forces timestamp output to use the GMT
        timezone. With no flag, the local timezone is used.</p>
  </dd>
  <dt><b>trap</b><i> [[command] signals]</i></dt>
  <dd>causes the given <i>command</i> to be executed upon future receipt of any
      of the given signals. The command is executed in the global scope. If
      <i>command</i> is absent, the signal action is returned. If <i>command</i>
      is the string SIG_IGN, the signals are ignored. If <i>command</i> is the
      string SIG_DFL, the signals are result to the system default.
      <i>signals</i> is either a single signal or a list of signals. Signals may
      be specified numerically or symbolically as per signal(3). The
      &quot;SIG&quot; prefix may be omitted.
    <p class="Pp">With no arguments (or the argument -number), <b>trap</b>
        returns the signal number of the trap command currently being
      executed.</p>
    <p class="Pp">The <b>-code</b> flag uses the return code of the command in
        place of whatever code Tcl was about to return when the command
        originally started running.</p>
    <p class="Pp">The <b>-interp</b> flag causes the command to be evaluated
        using the interpreter active at the time the command started running
        rather than when the trap was declared.</p>
    <p class="Pp">The <b>-name</b> flag causes the <b>trap</b> command to return
        the signal name of the trap command currently being executed.</p>
    <p class="Pp">The <b>-max</b> flag causes the <b>trap</b> command to return
        the largest signal number that can be set.</p>
    <p class="Pp">For example, the command &quot;trap {send_user
        &quot;Ouch!&quot;} SIGINT&quot; will print &quot;Ouch!&quot; each time
        the user presses ^C.</p>
    <p class="Pp">By default, SIGINT (which can usually be generated by pressing
        ^C) and SIGTERM cause Expect to exit. This is due to the following trap,
        created by default when Expect starts.</p>
    <pre>
    trap exit {SIGINT SIGTERM}
    </pre>
    If you use the -D flag to start the debugger, SIGINT is redefined to start
      the interactive debugger. This is due to the following trap:
    <pre>
    trap {exp_debug 1} SIGINT
    </pre>
    The debugger trap can be changed by setting the environment variable
      EXPECT_DEBUG_INIT to a new trap command.
    <p class="Pp">You can, of course, override both of these just by adding trap
        commands to your script. In particular, if you have your own &quot;trap
        exit SIGINT&quot;, this will override the debugger trap. This is useful
        if you want to prevent users from getting to the debugger at all.</p>
    <p class="Pp">If you want to define your own trap on SIGINT but still trap
        to the debugger when it is running, use:</p>
    <pre>
    if {![exp_debug]} {trap mystuff SIGINT}
    </pre>
    Alternatively, you can trap to the debugger using some other signal.
    <p class="Pp"><b>trap</b> will not let you override the action for SIGALRM
        as this is used internally to <b>Expect</b>. The disconnect command sets
        SIGALRM to SIG_IGN (ignore). You can reenable this as long as you
        disable it during subsequent spawn commands.</p>
    <p class="Pp">See signal(3) for more info.</p>
  </dd>
  <dt><b>wait</b><i> [args]</i></dt>
  <dd>delays until a spawned process (or the current process if none is named)
      terminates.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd><b>wait</b> normally returns a list of four integers. The first integer is
      the pid of the process that was waited upon. The second integer is the
      corresponding spawn id. The third integer is -1 if an operating system
      error occurred, or 0 otherwise. If the third integer was 0, the fourth
      integer is the status returned by the spawned process. If the third
      integer was -1, the fourth integer is the value of errno set by the
      operating system. The global variable errorCode is also set.
    <p class="Pp">Additional elements may appear at the end of the return value
        from <b>wait</b>. An optional fifth element identifies a class of
        information. Currently, the only possible value for this element is
        CHILDKILLED in which case the next two values are the C-style signal
        name and a short textual description.</p>
  </dd>
  <dt></dt>
  <dd>The <b>-i</b> flag declares the process to wait corresponding to the named
      spawn_id (NOT the process id). Inside a SIGCHLD handler, it is possible to
      wait for any spawned process by using the spawn id -1.
    <p class="Pp">The <b>-nowait</b> flag causes the wait to return immediately
        with the indication of a successful wait. When the process exits
        (later), it will automatically disappear without the need for an
        explicit wait.</p>
    <p class="Pp">The <b>wait</b> command may also be used wait for a forked
        process using the arguments &quot;-i -1&quot;. Unlike its use with
        spawned processes, this command can be executed at any time. There is no
        control over which process is reaped. However, the return value can be
        checked for the process id.</p>
    <p class="Pp"></p>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="LIBRARIES"><a class="permalink" href="#LIBRARIES">LIBRARIES</a></h1>
Expect automatically knows about two built-in libraries for Expect scripts.
  These are defined by the directories named in the variables exp_library and
  exp_exec_library. Both are meant to contain utility files that can be used by
  other scripts.
<p class="Pp">exp_library contains architecture-independent files.
    exp_exec_library contains architecture-dependent files. Depending on your
    system, both directories may be totally empty. The existence of the file
    $exp_exec_library/cat-buffers describes whether your /bin/cat buffers by
    default.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="PRETTY-PRINTING"><a class="permalink" href="#PRETTY-PRINTING">PRETTY-PRINTING</a></h1>
A vgrind definition is available for pretty-printing <b>Expect</b> scripts.
  Assuming the vgrind definition supplied with the <b>Expect</b> distribution is
  correctly installed, you can use it as:
<pre>
    vgrind -lexpect file
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="EXAMPLES"><a class="permalink" href="#EXAMPLES">EXAMPLES</a></h1>
It many not be apparent how to put everything together that the man page
  describes. I encourage you to read and try out the examples in the example
  directory of the <b>Expect</b> distribution. Some of them are real programs.
  Others are simply illustrative of certain techniques, and of course, a couple
  are just quick hacks. The INSTALL file has a quick overview of these programs.
<p class="Pp">The <b>Expect</b> papers (see SEE ALSO) are also useful. While
    some papers use syntax corresponding to earlier versions of Expect, the
    accompanying rationales are still valid and go into a lot more detail than
    this man page.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="CAVEATS"><a class="permalink" href="#CAVEATS">CAVEATS</a></h1>
Extensions may collide with Expect's command names. For example, <b>send</b> is
  defined by Tk for an entirely different purpose. For this reason, most of the
  <b>Expect</b> commands are also available as &quot;exp_XXXX&quot;. Commands
  and variables beginning with &quot;exp&quot;, &quot;inter&quot;,
  &quot;spawn&quot;, and &quot;timeout&quot; do not have aliases. Use the
  extended command names if you need this compatibility between environments.
<p class="Pp"><b>Expect</b> takes a rather liberal view of scoping. In
    particular, variables read by commands specific to the <b>Expect</b> program
    will be sought first from the local scope, and if not found, in the global
    scope. For example, this obviates the need to place &quot;global
    timeout&quot; in every procedure you write that uses <b>expect</b>. On the
    other hand, variables written are always in the local scope (unless a
    &quot;global&quot; command has been issued). The most common problem this
    causes is when spawn is executed in a procedure. Outside the procedure,
    <i>spawn_id</i> no longer exists, so the spawned process is no longer
    accessible simply because of scoping. Add a &quot;global spawn_id&quot; to
    such a procedure.</p>
<p class="Pp">If you cannot enable the multispawning capability (i.e., your
    system supports neither select (BSD *.*), poll (SVR&gt;2), nor something
    equivalent), <b>Expect</b> will only be able to control a single process at
    a time. In this case, do not attempt to set <i>spawn_id</i>, nor should you
    execute processes via exec while a spawned process is running. Furthermore,
    you will not be able to <b>expect</b> from multiple processes (including the
    user as one) at the same time.</p>
<p class="Pp">Terminal parameters can have a big effect on scripts. For example,
    if a script is written to look for echoing, it will misbehave if echoing is
    turned off. For this reason, Expect forces sane terminal parameters by
    default. Unfortunately, this can make things unpleasant for other programs.
    As an example, the emacs shell wants to change the &quot;usual&quot;
    mappings: newlines get mapped to newlines instead of carriage-return
    newlines, and echoing is disabled. This allows one to use emacs to edit the
    input line. Unfortunately, Expect cannot possibly guess this.</p>
<p class="Pp">You can request that Expect not override its default setting of
    terminal parameters, but you must then be very careful when writing scripts
    for such environments. In the case of emacs, avoid depending upon things
    like echoing and end-of-line mappings.</p>
<p class="Pp">The commands that accepted arguments braced into a single list
    (the <b>expect</b> variants and <b>interact</b>) use a heuristic to decide
    if the list is actually one argument or many. The heuristic can fail only in
    the case when the list actually does represent a single argument which has
    multiple embedded \n's with non-whitespace characters between them. This
    seems sufficiently improbable, however the argument &quot;-nobrace&quot; can
    be used to force a single argument to be handled as a single argument. This
    could conceivably be used with machine-generated Expect code. Similarly,
    -brace forces a single argument to be handle as multiple
  patterns/actions.</p>
<p class="Pp"></p>
</section>
<section class="Sh">
<h1 class="Sh" id="BUGS"><a class="permalink" href="#BUGS">BUGS</a></h1>
It was really tempting to name the program &quot;sex&quot; (for either
  &quot;Smart EXec&quot; or &quot;Send-EXpect&quot;), but good sense (or perhaps
  just Puritanism) prevailed.
<p class="Pp">On some systems, when a shell is spawned, it complains about not
    being able to access the tty but runs anyway. This means your system has a
    mechanism for gaining the controlling tty that <b>Expect</b> doesn't know
    about. Please find out what it is, and send this information back to me.</p>
<p class="Pp">Ultrix 4.1 (at least the latest versions around here) considers
    timeouts of above 1000000 to be equivalent to 0.</p>
<p class="Pp">Digital UNIX 4.0A (and probably other versions) refuses to
    allocate ptys if you define a SIGCHLD handler. See grantpt page for more
    info.</p>
<p class="Pp">IRIX 6.0 does not handle pty permissions correctly so that if
    Expect attempts to allocate a pty previously used by someone else, it fails.
    Upgrade to IRIX 6.1.</p>
<p class="Pp">Telnet (verified only under SunOS 4.1.2) hangs if TERM is not set.
    This is a problem under cron, at and in cgi scripts, which do not define
    TERM. Thus, you must set it explicitly - to what type is usually irrelevant.
    It just has to be set to something! The following probably suffices for most
    cases.</p>
<pre>
    set env(TERM) vt100
</pre>
<p class="Pp">Tip (verified only under BSDI BSD/OS 3.1 i386) hangs if SHELL and
    HOME are not set. This is a problem under cron, at and in cgi scripts, which
    do not define these environment variables. Thus, you must set them
    explicitly - to what type is usually irrelevant. It just has to be set to
    something! The following probably suffices for most cases.</p>
<pre>
    set env(SHELL) /bin/sh
    set env(HOME) /usr/local/bin
</pre>
<p class="Pp"></p>
<p class="Pp">Some implementations of ptys are designed so that the kernel
    throws away any unread output after 10 to 15 seconds (actual number is
    implementation-dependent) after the process has closed the file descriptor.
    Thus <b>Expect</b> programs such as</p>
<pre>
    spawn date
    sleep 20
    expect
</pre>
will fail. To avoid this, invoke non-interactive programs with <b>exec</b>
  rather than <b>spawn</b>. While such situations are conceivable, in practice I
  have never encountered a situation in which the final output of a truly
  interactive program would be lost due to this behavior.
<p class="Pp">On the other hand, Cray UNICOS ptys throw away any unread output
    immediately after the process has closed the file descriptor. I have
    reported this to Cray and they are working on a fix.</p>
<p class="Pp">Sometimes a delay is required between a prompt and a response,
    such as when a tty interface is changing UART settings or matching baud
    rates by looking for start/stop bits. Usually, all this is require is to
    sleep for a second or two. A more robust technique is to retry until the
    hardware is ready to receive input. The following example uses both
    strategies:</p>
<pre>
    send &quot;speed 9600\r&quot;;
    sleep 1
    expect {
        timeout {send &quot;\r&quot;; exp_continue}
        $prompt
    }
</pre>
<p class="Pp">trap -code will not work with any command that sits in Tcl's event
    loop, such as sleep. The problem is that in the event loop, Tcl discards the
    return codes from async event handlers. A workaround is to set a flag in the
    trap code. Then check the flag immediately after the command (i.e.,
  sleep).</p>
<p class="Pp">The expect_background command ignores -timeout arguments and has
    no concept of timeouts in general.</p>
<p class="Pp"></p>
</section>
<section class="Sh">
<h1 class="Sh" id="EXPECT_HINTS"><a class="permalink" href="#EXPECT_HINTS">EXPECT
  HINTS</a></h1>
There are a couple of things about <b>Expect</b> that may be non-intuitive. This
  section attempts to address some of these things with a couple of suggestions.
<p class="Pp">A common expect problem is how to recognize shell prompts. Since
    these are customized differently by differently people and different shells,
    portably automating rlogin can be difficult without knowing the prompt. A
    reasonable convention is to have users store a regular expression describing
    their prompt (in particular, the end of it) in the environment variable
    EXPECT_PROMPT. Code like the following can be used. If EXPECT_PROMPT doesn't
    exist, the code still has a good chance of functioning correctly.</p>
<pre>
    set prompt &quot;(%|#|\\$) $&quot;          ;# default prompt
    catch {set prompt $env(EXPECT_PROMPT)}
    expect -re $prompt
</pre>
I encourage you to write <b>expect</b> patterns that include the end of whatever
  you expect to see. This avoids the possibility of answering a question before
  seeing the entire thing. In addition, while you may well be able to answer
  questions before seeing them entirely, if you answer early, your answer may
  appear echoed back in the middle of the question. In other words, the
  resulting dialogue will be correct but look scrambled.
<p class="Pp">Most prompts include a space character at the end. For example,
    the prompt from ftp is 'f', 't', 'p', '&gt;' and &lt;blank&gt;. To match
    this prompt, you must account for each of these characters. It is a common
    mistake not to include the blank. Put the blank in explicitly.</p>
<p class="Pp">If you use a pattern of the form X*, the * will match all the
    output received from the end of X to the last thing received. This sounds
    intuitive but can be somewhat confusing because the phrase &quot;last thing
    received&quot; can vary depending upon the speed of the computer and the
    processing of I/O both by the kernel and the device driver.</p>
<p class="Pp">In particular, humans tend to see program output arriving in huge
    chunks (atomically) when in reality most programs produce output one line at
    a time. Assuming this is the case, the * in the pattern of the previous
    paragraph may only match the end of the current line even though there seems
    to be more, because at the time of the match that was all the output that
    had been received.</p>
<p class="Pp"><b>expect</b> has no way of knowing that further output is coming
    unless your pattern specifically accounts for it.</p>
<p class="Pp">Even depending on line-oriented buffering is unwise. Not only do
    programs rarely make promises about the type of buffering they do, but
    system indigestion can break output lines up so that lines break at
    seemingly random places. Thus, if you can express the last few characters of
    a prompt when writing patterns, it is wise to do so.</p>
<p class="Pp">If you are waiting for a pattern in the last output of a program
    and the program emits something else instead, you will not be able to detect
    that with the <b>timeout</b> keyword. The reason is that <b>expect</b> will
    not timeout - instead it will get an <b>eof</b> indication. Use that
    instead. Even better, use both. That way if that line is ever moved around,
    you won't have to edit the line itself.</p>
<p class="Pp">Newlines are usually converted to carriage return, linefeed
    sequences when output by the terminal driver. Thus, if you want a pattern
    that explicitly matches the two lines, from, say,
    printf(&quot;foo\nbar&quot;), you should use the pattern
    &quot;foo\r\nbar&quot;.</p>
<p class="Pp">A similar translation occurs when reading from the user, via
    <b>expect_user</b>. In this case, when you press return, it will be
    translated to a newline. If <b>Expect</b> then passes that to a program
    which sets its terminal to raw mode (like telnet), there is going to be a
    problem, as the program expects a true return. (Some programs are actually
    forgiving in that they will automatically translate newlines to returns, but
    most don't.) Unfortunately, there is no way to find out that a program put
    its terminal into raw mode.</p>
<p class="Pp">Rather than manually replacing newlines with returns, the solution
    is to use the command &quot;stty raw&quot;, which will stop the translation.
    Note, however, that this means that you will no longer get the cooked
    line-editing features.</p>
<p class="Pp"><b>interact</b> implicitly sets your terminal to raw mode so this
    problem will not arise then.</p>
<p class="Pp">It is often useful to store passwords (or other private
    information) in <b>Expect</b> scripts. This is not recommended since
    anything that is stored on a computer is susceptible to being accessed by
    anyone. Thus, interactively prompting for passwords from a script is a
    smarter idea than embedding them literally. Nonetheless, sometimes such
    embedding is the only possibility.</p>
<p class="Pp">Unfortunately, the UNIX file system has no direct way of creating
    scripts which are executable but unreadable. Systems which support setgid
    shell scripts may indirectly simulate this as follows:</p>
<p class="Pp">Create the <b>Expect</b> script (that contains the secret data) as
    usual. Make its permissions be 750 (-rwxr-x---) and owned by a trusted
    group, i.e., a group which is allowed to read it. If necessary, create a new
    group for this purpose. Next, create a /bin/sh script with permissions 2751
    (-rwxr-s--x) owned by the same group as before.</p>
<p class="Pp">The result is a script which may be executed (and read) by anyone.
    When invoked, it runs the <b>Expect</b> script.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<b>Tcl</b>(3), <b>libexpect</b>(3)
<br/>
<i>&quot;Exploring Expect: A Tcl-Based Toolkit for Automating Interactive
  Programs&quot;</i> by Don Libes, pp. 602, ISBN 1-56592-090-2, O'Reilly and
  Associates, 1995.
<br/>
<i>&quot;expect: Curing Those Uncontrollable Fits of Interactivity&quot; by Don
  Libes,</i> Proceedings of the Summer 1990 USENIX Conference, Anaheim,
  California, June 11-15, 1990.
<br/>
<i>&quot;Using</i> <b>expect</b> to Automate System Administration Tasks&quot;
  by Don Libes, Proceedings of the 1990 USENIX Large Installation Systems
  Administration Conference, Colorado Springs, Colorado, October 17-19, 1990.
<br/>
<i>&quot;Tcl: An Embeddable Command Language&quot; by John Ousterhout,</i>
  Proceedings of the Winter 1990 USENIX Conference, Washington, D.C., January
  22-26, 1990.
<br/>
<i>&quot;expect: Scripts for Controlling Interactive Programs&quot; by Don
  Libes,</i> Computing Systems, Vol. 4, No. 2, University of California Press
  Journals, November 1991.
<br/>
<i>&quot;Regression Testing and Conformance Testing Interactive Programs&quot;,
  by Don</i> Libes, Proceedings of the Summer 1992 USENIX Conference, pp.
  135-144, San Antonio, TX, June 12-15, 1992.
<br/>
<i>&quot;Kibitz - Connecting Multiple Interactive Programs Together&quot;, by
  Don Libes,</i> Software - Practice &amp; Experience, John Wiley &amp; Sons,
  West Sussex, England, Vol. 23, No. 5, May, 1993.
<br/>
<i>&quot;A Debugger for Tcl Applications&quot;, by Don Libes,</i> Proceedings of
  the 1993 Tcl/Tk Workshop, Berkeley, CA, June 10-11, 1993.
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
Don Libes, National Institute of Standards and Technology
</section>
<section class="Sh">
<h1 class="Sh" id="ACKNOWLEDGMENTS"><a class="permalink" href="#ACKNOWLEDGMENTS">ACKNOWLEDGMENTS</a></h1>
Thanks to John Ousterhout for Tcl, and Scott Paisley for inspiration. Thanks to
  Rob Savoye for Expect's autoconfiguration code.
<p class="Pp">The HISTORY file documents much of the evolution of <b>expect</b>.
    It makes interesting reading and might give you further insight to this
    software. Thanks to the people mentioned in it who sent me bug fixes and
    gave other assistance.</p>
<p class="Pp">Design and implementation of <b>Expect</b> was paid for in part by
    the U.S. government and is therefore in the public domain. However the
    author and NIST would like credit if this program and documentation or
    portions of them are used.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">29 December 1994</td>
    <td class="foot-os"></td>
  </tr>
</table>
</body>
</html>
