<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    .Nd, .Bf, .Op { display: inline; }
    .Pa, .Ad { font-style: italic; }
    .Ms { font-weight: bold; }
    .Bl-diag > dt { font-weight: bold; }
    code.Nm, .Fl, .Cm, .Ic, code.In, .Fd, .Fn, .Cd { font-weight: bold;
      font-family: inherit; }
  </style>
  <title>Net::FTP(3pm)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Net::FTP(3pm)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">Net::FTP(3pm)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Net::FTP - FTP Client class</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>    use Net::FTP;
    $ftp = Net::FTP-&gt;new(&quot;some.host.name&quot;, Debug =&gt; 0)
      or die &quot;Cannot connect to some.host.name: $@&quot;;
    $ftp-&gt;login(&quot;anonymous&quot;,'-anonymous@')
      or die &quot;Cannot login &quot;, $ftp-&gt;message;
    $ftp-&gt;cwd(&quot;/pub&quot;)
      or die &quot;Cannot change working directory &quot;, $ftp-&gt;message;
    $ftp-&gt;get(&quot;that.file&quot;)
      or die &quot;get failed &quot;, $ftp-&gt;message;
    $ftp-&gt;quit;
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp"><span class="Li">&quot;Net::FTP&quot;</span> is a class
    implementing a simple FTP client in Perl as described in RFC959. It provides
    wrappers for the commonly used subset of the RFC959 commands. If
    IO::Socket::IP or IO::Socket::INET6 is installed it also provides support
    for IPv6 as defined in RFC2428. And with IO::Socket::SSL installed it
    provides support for implicit FTPS and explicit FTPS as defined in
  RFC4217.</p>
<p class="Pp">The Net::FTP class is a subclass of Net::Cmd and (depending on
    avaibility) of IO::Socket::IP, IO::Socket::INET6 or IO::Socket::INET.</p>
<section class="Ss">
<h2 class="Ss" id="Overview"><a class="permalink" href="#Overview">Overview</a></h2>
<p class="Pp">FTP stands for File Transfer Protocol. It is a way of transferring
    files between networked machines. The protocol defines a client (whose
    commands are provided by this module) and a server (not implemented in this
    module). Communication is always initiated by the client, and the server
    responds with a message and a status code (and sometimes with data).</p>
<p class="Pp">The FTP protocol allows files to be sent to or fetched from the
    server. Each transfer involves a <b>local file</b> (on the client) and a
    <b>remote file</b> (on the server). In this module, the same file name will
    be used for both local and remote if only one is specified. This means that
    transferring remote file <span class="Li">&quot;/path/to/file&quot;</span>
    will try to put that file in
    <span class="Li">&quot;/path/to/file&quot;</span> locally, unless you
    specify a local file name.</p>
<p class="Pp">The protocol also defines several standard <b>translations</b>
    which the file can undergo during transfer. These are ASCII, EBCDIC, binary,
    and byte. ASCII is the default type, and indicates that the sender of files
    will translate the ends of lines to a standard representation which the
    receiver will then translate back into their local representation. EBCDIC
    indicates the file being transferred is in EBCDIC format. Binary (also known
    as image) format sends the data as a contiguous bit stream. Byte format
    transfers the data as bytes, the values of which remain the same regardless
    of differences in byte size between the two machines (in theory - in
    practice you should only use this if you really know what you're doing).
    This class does not support the EBCDIC or byte formats, and will default to
    binary instead if they are attempted.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Class_Methods"><a class="permalink" href="#Class_Methods">Class
  Methods</a></h2>
<dl class="Bl-tag">
  <dt>&quot;new([$host][, %options])&quot;</dt>
  <dd>This is the constructor for a new Net::FTP object.
      <span class="Li">$host</span> is the name of the remote host to which an
      FTP connection is required.
    <p class="Pp"><span class="Li">$host</span> is optional. If
        <span class="Li">$host</span> is not given then it may instead be passed
        as the <span class="Li">&quot;Host&quot;</span> option described
      below.</p>
    <p class="Pp"><span class="Li">%options</span> are passed in a hash like
        fashion, using key and value pairs. Possible options are:</p>
    <p class="Pp"><b>Host</b> - FTP host to connect to. It may be a single
        scalar, as defined for the <span class="Li">&quot;PeerAddr&quot;</span>
        option in IO::Socket::INET, or a reference to an array with hosts to try
        in turn. The &quot;host&quot; method will return the value which was
        used to connect to the host.</p>
    <p class="Pp"><b>Firewall</b> - The name of a machine which acts as an FTP
        firewall. This can be overridden by an environment variable
        <span class="Li">&quot;FTP_FIREWALL&quot;</span>. If specified, and the
        given host cannot be directly connected to, then the connection is made
        to the firewall machine and the string <span class="Li">@hostname</span>
        is appended to the login identifier. This kind of setup is also referred
        to as an ftp proxy.</p>
    <p class="Pp"><b>FirewallType</b> - The type of firewall running on the
        machine indicated by <b>Firewall</b>. This can be overridden by an
        environment variable
        <span class="Li">&quot;FTP_FIREWALL_TYPE&quot;</span>. For a list of
        permissible types, see the description of ftp_firewall_type in
        Net::Config.</p>
    <p class="Pp"><b>BlockSize</b> - This is the block size that Net::FTP will
        use when doing transfers. (defaults to 10240)</p>
    <p class="Pp"><b>Port</b> - The port number to connect to on the remote
        machine for the FTP connection</p>
    <p class="Pp"><b>SSL</b> - If the connection should be done from start with
        SSL, contrary to later upgrade with
        <span class="Li">&quot;starttls&quot;</span>.</p>
    <p class="Pp"><b>SSL_*</b> - SSL arguments which will be applied when
        upgrading the control or data connection to SSL. You can use SSL
        arguments as documented in IO::Socket::SSL, but it will usually use the
        right arguments already.</p>
    <p class="Pp"><b>Timeout</b> - Set a timeout value in seconds (defaults to
        120)</p>
    <p class="Pp"><b>Debug</b> - debug level (see the debug method in
      Net::Cmd)</p>
    <p class="Pp"><b>Passive</b> - If set to a non-zero value then all data
        transfers will be done using passive mode. If set to zero then data
        transfers will be done using active mode. If the machine is connected to
        the Internet directly, both passive and active mode should work equally
        well. Behind most firewall and NAT configurations passive mode has a
        better chance of working. However, in some rare firewall configurations,
        active mode actually works when passive mode doesn't. Some really old
        FTP servers might not implement passive transfers. If not specified,
        then the transfer mode is set by the environment variable
        <span class="Li">&quot;FTP_PASSIVE&quot;</span> or if that one is not
        set by the settings done by the <i>libnetcfg</i> utility. If none of
        these apply then passive mode is used.</p>
    <p class="Pp"><b>Hash</b> - If given a reference to a file handle (e.g.,
        <span class="Li">&quot;\*STDERR&quot;</span>), print hash marks (#) on
        that filehandle every 1024 bytes. This simply invokes the
        <span class="Li">&quot;hash()&quot;</span> method for you, so that hash
        marks are displayed for all transfers. You can, of course, call
        <span class="Li">&quot;hash()&quot;</span> explicitly whenever you'd
        like.</p>
    <p class="Pp"><b>LocalAddr</b> - Local address to use for all socket
        connections. This argument will be passed to the super class, i.e.
        IO::Socket::INET or IO::Socket::IP.</p>
    <p class="Pp"><b>Domain</b> - Domain to use, i.e. AF_INET or AF_INET6. This
        argument will be passed to the IO::Socket super class. This can be used
        to enforce IPv4 even with IO::Socket::IP which would default to IPv6.
        <b>Family</b> is accepted as alternative name for <b>Domain</b>.</p>
    <p class="Pp">If the constructor fails undef will be returned and an error
        message will be in $@</p>
  </dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Object_Methods"><a class="permalink" href="#Object_Methods">Object
  Methods</a></h2>
<p class="Pp">Unless otherwise stated all methods return either a <i>true</i> or
    <i>false</i> value, with <i>true</i> meaning that the operation was a
    success. When a method states that it returns a value, failure will be
    returned as <i>undef</i> or an empty list.</p>
<p class="Pp"><span class="Li">&quot;Net::FTP&quot;</span> inherits from
    <span class="Li">&quot;Net::Cmd&quot;</span> so methods defined in
    <span class="Li">&quot;Net::Cmd&quot;</span> may be used to send commands to
    the remote FTP server in addition to the methods documented here.</p>
<dl class="Bl-tag">
  <dt>&quot;login([$login[, $password[, $account]]])&quot;</dt>
  <dd>Log into the remote FTP server with the given login information. If no
      arguments are given then the <span class="Li">&quot;Net::FTP&quot;</span>
      uses the <span class="Li">&quot;Net::Netrc&quot;</span> package to lookup
      the login information for the connected host. If no information is found
      then a login of <i>anonymous</i> is used. If no password is given and the
      login is <i>anonymous</i> then <i>anonymous@</i> will be used for
      password.
    <p class="Pp">If the connection is via a firewall then the
        <span class="Li">&quot;authorize&quot;</span> method will be called with
        no arguments.</p>
  </dd>
  <dt>&quot;starttls()&quot;</dt>
  <dd>Upgrade existing plain connection to SSL. The SSL arguments have to be
      given in <span class="Li">&quot;new&quot;</span> already because they are
      needed for data connections too.</dd>
  <dt>&quot;stoptls()&quot;</dt>
  <dd>Downgrade existing SSL connection back to plain. This is needed to work
      with some FTP helpers at firewalls, which need to see the PORT and PASV
      commands and responses to dynamically open the necessary ports. In this
      case <span class="Li">&quot;starttls&quot;</span> is usually only done to
      protect the authorization.</dd>
  <dt>&quot;prot($level)&quot;</dt>
  <dd>Set what type of data channel protection the client and server will be
      using. Only <span class="Li">$level</span>s &quot;C&quot; (clear) and
      &quot;P&quot; (private) are supported.</dd>
  <dt>&quot;host()&quot;</dt>
  <dd>Returns the value used by the constructor, and passed to the IO::Socket
      super class to connect to the host.</dd>
  <dt>&quot;account($acct)&quot;</dt>
  <dd>Set a string identifying the user's account.</dd>
  <dt>&quot;authorize([$auth[, $resp]])&quot;</dt>
  <dd>This is a protocol used by some firewall ftp proxies. It is used to
      authorise the user to send data out. If both arguments are not specified
      then <span class="Li">&quot;authorize&quot;</span> uses
      <span class="Li">&quot;Net::Netrc&quot;</span> to do a lookup.</dd>
  <dt>&quot;site($args)&quot;</dt>
  <dd>Send a SITE command to the remote server and wait for a response.
    <p class="Pp">Returns most significant digit of the response code.</p>
  </dd>
  <dt>&quot;ascii()&quot;</dt>
  <dd>Transfer file in ASCII. CRLF translation will be done if required</dd>
  <dt>&quot;binary()&quot;</dt>
  <dd>Transfer file in binary mode. No transformation will be done.
    <p class="Pp"><b>Hint</b>: If both server and client machines use the same
        line ending for text files, then it will be faster to transfer all files
        in binary mode.</p>
  </dd>
  <dt>&quot;type([$type])&quot;</dt>
  <dd>Set or get if files will be transferred in ASCII or binary mode.</dd>
  <dt>&quot;rename($oldname, $newname)&quot;</dt>
  <dd>Rename a file on the remote FTP server from
      <span class="Li">$oldname</span> to <span class="Li">$newname</span>. This
      is done by sending the RNFR and RNTO commands.</dd>
  <dt>&quot;delete($filename)&quot;</dt>
  <dd>Send a request to the server to delete
    <span class="Li">$filename</span>.</dd>
  <dt>&quot;cwd([$dir])&quot;</dt>
  <dd>Attempt to change directory to the directory given in
      <span class="Li">$dir</span>. If <span class="Li">$dir</span> is
      <span class="Li">&quot;..&quot;</span>, the FTP
      <span class="Li">&quot;CDUP&quot;</span> command is used to attempt to
      move up one directory. If no directory is given then an attempt is made to
      change the directory to the root directory.</dd>
  <dt>&quot;cdup()&quot;</dt>
  <dd>Change directory to the parent of the current directory.</dd>
  <dt>&quot;passive([$passive])&quot;</dt>
  <dd>Set or get if data connections will be initiated in passive mode.</dd>
  <dt>&quot;pwd()&quot;</dt>
  <dd>Returns the full pathname of the current directory.</dd>
  <dt>&quot;restart($where)&quot;</dt>
  <dd>Set the byte offset at which to begin the next data transfer. Net::FTP
      simply records this value and uses it when during the next data transfer.
      For this reason this method will not return an error, but setting it may
      cause a subsequent data transfer to fail.</dd>
  <dt>&quot;rmdir($dir[, $recurse])&quot;</dt>
  <dd>Remove the directory with the name <span class="Li">$dir</span>. If
      <span class="Li">$recurse</span> is <i>true</i> then
      <span class="Li">&quot;rmdir&quot;</span> will attempt to delete
      everything inside the directory.</dd>
  <dt>&quot;mkdir($dir[, $recurse])&quot;</dt>
  <dd>Create a new directory with the name <span class="Li">$dir</span>. If
      <span class="Li">$recurse</span> is <i>true</i> then
      <span class="Li">&quot;mkdir&quot;</span> will attempt to create all the
      directories in the given path.
    <p class="Pp">Returns the full pathname to the new directory.</p>
  </dd>
  <dt>&quot;alloc($size[, $record_size])&quot;</dt>
  <dd>The alloc command allows you to give the ftp server a hint about the size
      of the file about to be transferred using the ALLO ftp command. Some
      storage systems use this to make intelligent decisions about how to store
      the file. The <span class="Li">$size</span> argument represents the size
      of the file in bytes. The <span class="Li">$record_size</span> argument
      indicates a maximum record or page size for files sent with a record or
      page structure.
    <p class="Pp">The size of the file will be determined, and sent to the
        server automatically for normal files so that this method need only be
        called if you are transferring data from a socket, named pipe, or other
        stream not associated with a normal file.</p>
  </dd>
  <dt>&quot;ls([$dir])&quot;</dt>
  <dd>Get a directory listing of <span class="Li">$dir</span>, or the current
      directory.
    <p class="Pp">In an array context, returns a list of lines returned from the
        server. In a scalar context, returns a reference to a list.</p>
  </dd>
  <dt>&quot;dir([$dir])&quot;</dt>
  <dd>Get a directory listing of <span class="Li">$dir</span>, or the current
      directory in long format.
    <p class="Pp">In an array context, returns a list of lines returned from the
        server. In a scalar context, returns a reference to a list.</p>
  </dd>
  <dt>&quot;get($remote_file[, $local_file[, $where]])&quot;</dt>
  <dd>Get <span class="Li">$remote_file</span> from the server and store
      locally. <span class="Li">$local_file</span> may be a filename or a
      filehandle. If not specified, the file will be stored in the current
      directory with the same leafname as the remote file.
    <p class="Pp">If <span class="Li">$where</span> is given then the first
        <span class="Li">$where</span> bytes of the file will not be
        transferred, and the remaining bytes will be appended to the local file
        if it already exists.</p>
    <p class="Pp">Returns <span class="Li">$local_file</span>, or the generated
        local file name if <span class="Li">$local_file</span> is not given. If
        an error was encountered undef is returned.</p>
  </dd>
  <dt>&quot;put($local_file[, $remote_file])&quot;</dt>
  <dd>Put a file on the remote server. <span class="Li">$local_file</span> may
      be a name or a filehandle. If <span class="Li">$local_file</span> is a
      filehandle then <span class="Li">$remote_file</span> must be specified. If
      <span class="Li">$remote_file</span> is not specified then the file will
      be stored in the current directory with the same leafname as
      <span class="Li">$local_file</span>.
    <p class="Pp">Returns <span class="Li">$remote_file</span>, or the generated
        remote filename if <span class="Li">$remote_file</span> is not
      given.</p>
    <p class="Pp"><b>NOTE</b>: If for some reason the transfer does not complete
        and an error is returned then the contents that had been transferred
        will not be remove automatically.</p>
  </dd>
  <dt>&quot;put_unique($local_file[, $remote_file])&quot;</dt>
  <dd>Same as put but uses the <span class="Li">&quot;STOU&quot;</span> command.
    <p class="Pp">Returns the name of the file on the server.</p>
  </dd>
  <dt>&quot;append($local_file[, $remote_file])&quot;</dt>
  <dd>Same as put but appends to the file on the remote server.
    <p class="Pp">Returns <span class="Li">$remote_file</span>, or the generated
        remote filename if <span class="Li">$remote_file</span> is not
      given.</p>
  </dd>
  <dt>&quot;unique_name()&quot;</dt>
  <dd>Returns the name of the last file stored on the server using the
      <span class="Li">&quot;STOU&quot;</span> command.</dd>
  <dt>&quot;mdtm($file)&quot;</dt>
  <dd>Returns the <i>modification time</i> of the given file</dd>
  <dt>&quot;size($file)&quot;</dt>
  <dd>Returns the size in bytes for the given file as stored on the remote
      server.
    <p class="Pp"><b>NOTE</b>: The size reported is the size of the stored file
        on the remote server. If the file is subsequently transferred from the
        server in ASCII mode and the remote server and local machine have
        different ideas about &quot;End Of Line&quot; then the size of file on
        the local machine after transfer may be different.</p>
  </dd>
  <dt>&quot;supported($cmd)&quot;</dt>
  <dd>Returns TRUE if the remote server supports the given command.</dd>
  <dt>&quot;hash([$filehandle_glob_ref[, $bytes_per_hash_mark]])&quot;</dt>
  <dd>Called without parameters, or with the first argument false, hash marks
      are suppressed. If the first argument is true but not a reference to a
      file handle glob, then \*STDERR is used. The second argument is the number
      of bytes per hash mark printed, and defaults to 1024. In all cases the
      return value is a reference to an array of two: the filehandle glob
      reference and the bytes per hash mark.</dd>
  <dt>&quot;feature($name)&quot;</dt>
  <dd>Determine if the server supports the specified feature. The return value
      is a list of lines the server responded with to describe the options that
      it supports for the given feature. If the feature is unsupported then the
      empty list is returned.
    <p class="Pp"></p>
    <pre>  if ($ftp-&gt;feature( 'MDTM' )) {
    # Do something
  }
  if (grep { /\bTLS\b/ } $ftp-&gt;feature('AUTH')) {
    # Server supports TLS
  }
    </pre>
  </dd>
</dl>
<p class="Pp">The following methods can return different results depending on
    how they are called. If the user explicitly calls either of the
    <span class="Li">&quot;pasv&quot;</span> or
    <span class="Li">&quot;port&quot;</span> methods then these methods will
    return a <i>true</i> or <i>false</i> value. If the user does not call either
    of these methods then the result will be a reference to a
    <span class="Li">&quot;Net::FTP::dataconn&quot;</span> based object.</p>
<dl class="Bl-tag">
  <dt>&quot;nlst([$dir])&quot;</dt>
  <dd>Send an <span class="Li">&quot;NLST&quot;</span> command to the server,
      with an optional parameter.</dd>
  <dt>&quot;list([$dir])&quot;</dt>
  <dd>Same as <span class="Li">&quot;nlst&quot;</span> but using the
      <span class="Li">&quot;LIST&quot;</span> command</dd>
  <dt>&quot;retr($file)&quot;</dt>
  <dd>Begin the retrieval of a file called <span class="Li">$file</span> from
      the remote server.</dd>
  <dt>&quot;stor($file)&quot;</dt>
  <dd>Tell the server that you wish to store a file.
      <span class="Li">$file</span> is the name of the new file that should be
      created.</dd>
  <dt>&quot;stou($file)&quot;</dt>
  <dd>Same as <span class="Li">&quot;stor&quot;</span> but using the
      <span class="Li">&quot;STOU&quot;</span> command. The name of the unique
      file which was created on the server will be available via the
      <span class="Li">&quot;unique_name&quot;</span> method after the data
      connection has been closed.</dd>
  <dt>&quot;appe($file)&quot;</dt>
  <dd>Tell the server that we want to append some data to the end of a file
      called <span class="Li">$file</span>. If this file does not exist then
      create it.</dd>
</dl>
<p class="Pp">If for some reason you want to have complete control over the data
    connection, this includes generating it and calling the
    <span class="Li">&quot;response&quot;</span> method when required, then the
    user can use these methods to do so.</p>
<p class="Pp">However calling these methods only affects the use of the methods
    above that can return a data connection. They have no effect on methods
    <span class="Li">&quot;get&quot;</span>,
    <span class="Li">&quot;put&quot;</span>,
    <span class="Li">&quot;put_unique&quot;</span> and those that do not require
    data connections.</p>
<dl class="Bl-tag">
  <dt>&quot;port([$port])&quot;</dt>
  <dd></dd>
  <dt>&quot;eprt([$port])&quot;</dt>
  <dd>Send a <span class="Li">&quot;PORT&quot;</span> (IPv4) or
      <span class="Li">&quot;EPRT&quot;</span> (IPv6) command to the server. If
      <span class="Li">$port</span> is specified then it is sent to the server.
      If not, then a listen socket is created and the correct information sent
      to the server.</dd>
  <dt>&quot;pasv()&quot;</dt>
  <dd></dd>
  <dt>&quot;epsv()&quot;</dt>
  <dd>Tell the server to go into passive mode
      (<span class="Li">&quot;pasv&quot;</span> for IPv4,
      <span class="Li">&quot;epsv&quot;</span> for IPv6). Returns the text that
      represents the port on which the server is listening, this text is in a
      suitable form to send to another ftp server using the
      <span class="Li">&quot;port&quot;</span> or
      <span class="Li">&quot;eprt&quot;</span> method.</dd>
</dl>
<p class="Pp">The following methods can be used to transfer files between two
    remote servers, providing that these two servers can connect directly to
    each other.</p>
<dl class="Bl-tag">
  <dt>&quot;pasv_xfer($src_file, $dest_server[, $dest_file ])&quot;</dt>
  <dd>This method will do a file transfer between two remote ftp servers. If
      <span class="Li">$dest_file</span> is omitted then the leaf name of
      <span class="Li">$src_file</span> will be used.</dd>
  <dt>&quot;pasv_xfer_unique($src_file, $dest_server[, $dest_file ])&quot;</dt>
  <dd>Like <span class="Li">&quot;pasv_xfer&quot;</span> but the file is stored
      on the remote server using the STOU command.</dd>
  <dt>&quot;pasv_wait($non_pasv_server)&quot;</dt>
  <dd>This method can be used to wait for a transfer to complete between a
      passive server and a non-passive server. The method should be called on
      the passive server with the <span class="Li">&quot;Net::FTP&quot;</span>
      object for the non-passive server passed as an argument.</dd>
  <dt>&quot;abort()&quot;</dt>
  <dd>Abort the current data transfer.</dd>
  <dt>&quot;quit()&quot;</dt>
  <dd>Send the QUIT command to the remote FTP server and close the socket
      connection.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Methods_for_the_Adventurous"><a class="permalink" href="#Methods_for_the_Adventurous">Methods
  for the Adventurous</a></h2>
<dl class="Bl-tag">
  <dt>&quot;quot($cmd[, $args])&quot;</dt>
  <dd>Send a command, that Net::FTP does not directly support, to the remote
      server and wait for a response.
    <p class="Pp">Returns most significant digit of the response code.</p>
    <p class="Pp"><b>WARNING</b> This call should only be used on commands that
        do not require data connections. Misuse of this method can hang the
        connection.</p>
  </dd>
  <dt>&quot;can_inet6()&quot;</dt>
  <dd>Returns whether we can use IPv6.</dd>
  <dt>&quot;can_ssl()&quot;</dt>
  <dd>Returns whether we can use SSL.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="The_dataconn_Class"><a class="permalink" href="#The_dataconn_Class">The
  dataconn Class</a></h2>
<p class="Pp">Some of the methods defined in
    <span class="Li">&quot;Net::FTP&quot;</span> return an object which will be
    derived from the <span class="Li">&quot;Net::FTP::dataconn&quot;</span>
    class. See Net::FTP::dataconn for more details.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Unimplemented"><a class="permalink" href="#Unimplemented">Unimplemented</a></h2>
<p class="Pp">The following RFC959 commands have not been implemented:</p>
<dl class="Bl-tag">
  <dt>&quot;SMNT&quot;</dt>
  <dd>Mount a different file system structure without changing login or
      accounting information.</dd>
  <dt>&quot;HELP&quot;</dt>
  <dd>Ask the server for &quot;helpful information&quot; (that's what the RFC
      says) on the commands it accepts.</dd>
  <dt>&quot;MODE&quot;</dt>
  <dd>Specifies transfer mode (stream, block or compressed) for file to be
      transferred.</dd>
  <dt>&quot;SYST&quot;</dt>
  <dd>Request remote server system identification.</dd>
  <dt>&quot;STAT&quot;</dt>
  <dd>Request remote server status.</dd>
  <dt>&quot;STRU&quot;</dt>
  <dd>Specifies file structure for file to be transferred.</dd>
  <dt>&quot;REIN&quot;</dt>
  <dd>Reinitialize the connection, flushing all I/O and account
    information.</dd>
</dl>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="EXAMPLES"><a class="permalink" href="#EXAMPLES">EXAMPLES</a></h1>
<p class="Pp">For an example of the use of Net::FTP see</p>
<dl class="Bl-tag">
  <dt>&lt;https://www.csh.rit.edu/~adam/Progs/&gt;</dt>
  <dd><span class="Li">&quot;autoftp&quot;</span> is a program that can
      retrieve, send, or list files via the FTP protocol in a non-interactive
      manner.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="EXPORTS"><a class="permalink" href="#EXPORTS">EXPORTS</a></h1>
<p class="Pp"><i>None</i>.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="KNOWN_BUGS"><a class="permalink" href="#KNOWN_BUGS">KNOWN
  BUGS</a></h1>
<p class="Pp">See
    &lt;https://rt.cpan.org/Dist/Display.html?Status=Active&amp;Queue=libnet&gt;.</p>
<section class="Ss">
<h2 class="Ss" id="Reporting_Bugs"><a class="permalink" href="#Reporting_Bugs">Reporting
  Bugs</a></h2>
<p class="Pp">When reporting bugs/problems please include as much information as
    possible. It may be difficult for me to reproduce the problem as almost
    every setup is different.</p>
<p class="Pp">A small script which yields the problem will probably be of help.
    It would also be useful if this script was run with the extra options
    <span class="Li">&quot;Debug =&gt; 1&quot;</span> passed to the constructor,
    and the output sent with the bug report. If you cannot include a small
    script then please include a Debug trace from a run of your program which
    does yield the problem.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp">Net::Netrc, Net::Cmd, IO::Socket::SSL;</p>
<p class="Pp"><b>ftp</b>(1), <b>ftpd</b>(8);</p>
<p class="Pp">&lt;https://www.ietf.org/rfc/rfc959.txt&gt;,
    &lt;https://www.ietf.org/rfc/rfc2428.txt&gt;,
    &lt;https://www.ietf.org/rfc/rfc4217.txt&gt;.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="ACKNOWLEDGEMENTS"><a class="permalink" href="#ACKNOWLEDGEMENTS">ACKNOWLEDGEMENTS</a></h1>
<p class="Pp">Henry Gabryjelski &lt;henryg@WPI.EDU
    &lt;mailto:henryg@WPI.EDU&gt;&gt; - for the suggestion of creating
    directories recursively.</p>
<p class="Pp">Nathan Torkington &lt;gnat@frii.com
    &lt;mailto:gnat@frii.com&gt;&gt; - for some input on the documentation.</p>
<p class="Pp">Roderick Schertler &lt;roderick@gate.net
    &lt;mailto:roderick@gate.net&gt;&gt; - for various inputs</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">Graham Barr &lt;gbarr@pobox.com
    &lt;mailto:gbarr@pobox.com&gt;&gt;.</p>
<p class="Pp">Steve Hay &lt;shay@cpan.org &lt;mailto:shay@cpan.org&gt;&gt; is
    now maintaining libnet as of version 1.22_02.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT"><a class="permalink" href="#COPYRIGHT">COPYRIGHT</a></h1>
<p class="Pp">Copyright (C) 1995-2004 Graham Barr. All rights reserved.</p>
<p class="Pp">Copyright (C) 2013-2017, 2020 Steve Hay. All rights reserved.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="LICENCE"><a class="permalink" href="#LICENCE">LICENCE</a></h1>
<p class="Pp">This module is free software; you can redistribute it and/or
    modify it under the same terms as Perl itself, i.e. under the terms of
    either the GNU General Public License or the Artistic License, as specified
    in the <i>LICENCE</i> file.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="VERSION"><a class="permalink" href="#VERSION">VERSION</a></h1>
<p class="Pp">Version 3.13</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DATE"><a class="permalink" href="#DATE">DATE</a></h1>
<p class="Pp">23 Dec 2020</p>
</section>
<section class="Sh">
<h1 class="Sh" id="HISTORY"><a class="permalink" href="#HISTORY">HISTORY</a></h1>
<p class="Pp">See the <i>Changes</i> file.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2021-01-20</td>
    <td class="foot-os">perl v5.34.0</td>
  </tr>
</table>
</body>
</html>
