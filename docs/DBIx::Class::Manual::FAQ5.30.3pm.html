<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>DBIx::Class::Manual::FAQ(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">DBIx::Class::Manual::FAQ(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">DBIx::Class::Manual::FAQ(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
DBIx::Class::Manual::FAQ - Frequently Asked Questions (in theory)
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
This document is intended as an anti-map of the documentation. If you know what
  you want to do, but not how to do it in DBIx::Class, then look here. It does
  <b>not</b> contain much code or examples, it just gives explanations and
  pointers to the correct pieces of documentation to read.
</section>
<section class="Sh">
<h1 class="Sh" id="FAQs"><a class="permalink" href="#FAQs">FAQs</a></h1>
How Do I:
<section class="Ss">
<h2 class="Ss" id="Getting_started"><a class="permalink" href="#Getting_started">Getting
  started</a></h2>
<dl class="Bl-tag">
  <dt>.. create a database to use?</dt>
  <dd>First, choose a database. For testing/experimenting, we recommend
      DBD::SQLite, which is a self-contained small database (i.e. all you need
      to do is to install DBD::SQLite from CPAN, and it works).
    <p class="Pp">Next, spend some time defining which data you need to store,
        and how it relates to the other data you have. For some help on
        normalisation, go to &lt;http://b62.tripod.com/doc/dbbase.htm&gt;.</p>
    <p class="Pp">Now, decide whether you want to have the database itself be
        the definitive source of information about the data layout, or your
        DBIx::Class schema. If it's the former, look up the documentation for
        your database, eg. &lt;http://sqlite.org/lang_createtable.html&gt;, on
        how to create tables, and start creating them. For a nice universal
        interface to your database, you can try DBI::Shell. If you decided on
        the latter choice, read the FAQ on setting up your classes manually, and
        the one on creating tables from your schema.</p>
  </dd>
  <dt>.. use DBIx::Class with Catalyst?</dt>
  <dd>Install Catalyst::Model::DBIC::Schema from CPAN. See its documentation, or
      below, for further details.</dd>
  <dt>.. set up my DBIx::Class classes automatically from my database?</dt>
  <dd>Install DBIx::Class::Schema::Loader from CPAN, and read its
    documentation.</dd>
  <dt>.. set up my DBIx::Class classes manually?</dt>
  <dd>Look at the DBIx::Class::Manual::Example and come back here if you get
      lost.</dd>
  <dt>.. create my database tables from my DBIx::Class schema?</dt>
  <dd>Create your classes manually, as above. Write a script that calls
      &quot;deploy&quot; in DBIx::Class::Schema. See there for details, or the
      DBIx::Class::Manual::Cookbook.</dd>
  <dt>.. store/retrieve Unicode data in my database?</dt>
  <dd>Make sure you database supports Unicode and set the connect attributes
      appropriately - see &quot;Using Unicode&quot; in
      DBIx::Class::Manual::Cookbook</dd>
  <dt>.. connect to my database?</dt>
  <dd>Once you have created all the appropriate table/source classes, and an
      overall Schema class, you can start using them in an application. To do
      this, you need to create a central Schema object, which is used to access
      all the data in the various tables. See &quot;connect&quot; in
      DBIx::Class::Schema for details. The actual connection does not happen
      until you actually request data, so don't be alarmed if the error from
      incorrect connection details happens a lot later.</dd>
  <dt>.. use DBIx::Class across multiple databases?</dt>
  <dd>If your database server allows you to run queries across multiple
      databases at once, then so can DBIx::Class. All you need to do is make
      sure you write the database name as part of the table call. Eg:
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  __PACKAGE__-&gt;table('mydb.mytablename');
    </pre>
    <p class="Pp">And load all the Result classes for both / all databases by
        calling &quot;load_namespaces&quot; in DBIx::Class::Schema.</p>
  </dd>
  <dt>.. use DBIx::Class across PostgreSQL/DB2/Oracle schemas?</dt>
  <dd>Add the name of the schema to the table name, when invoking table, and
      make sure the user you are about to connect as has permissions to
      read/write all the schemas/tables as necessary.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Relationships"><a class="permalink" href="#Relationships">Relationships</a></h2>
<dl class="Bl-tag">
  <dt>.. tell DBIx::Class about relationships between my tables?</dt>
  <dd>There are a variety of relationship types that come pre-defined for you to
      use. These are all listed in DBIx::Class::Relationship. If you need a
      non-standard type, or more information, look in
      DBIx::Class::Relationship::Base.</dd>
  <dt>.. define a one-to-many relationship?</dt>
  <dd>This is called a <span class="Li">&quot;has_many&quot;</span> relationship
      on the one side, and a <span class="Li">&quot;belongs_to&quot;</span>
      relationship on the many side. Currently these need to be set up
      individually on each side. See DBIx::Class::Relationship for details.</dd>
  <dt>.. define a relationship where this table contains another table's primary
    key? (foreign key)</dt>
  <dd>Create a <span class="Li">&quot;belongs_to&quot;</span> relationship for
      the field containing the foreign key. See &quot;belongs_to&quot; in
      DBIx::Class::Relationship.</dd>
  <dt>.. define a foreign key relationship where the key field may contain
    NULL?</dt>
  <dd>Just create a <span class="Li">&quot;belongs_to&quot;</span> relationship,
      as above. If the column is NULL then the inflation to the foreign object
      will not happen. This has a side effect of not always fetching all the
      relevant data, if you use a nullable foreign-key relationship in a JOIN,
      then you probably want to set the
      <span class="Li">&quot;join_type&quot;</span> to
      <span class="Li">&quot;left&quot;</span>.</dd>
  <dt>.. define a relationship where the key consists of more than one
    column?</dt>
  <dd>Instead of supplying a single column name, all relationship types also
      allow you to supply a hashref containing the condition across which the
      tables are to be joined. The condition may contain as many fields as you
      like. See DBIx::Class::Relationship::Base.</dd>
  <dt>.. define a relationship bridge across an intermediate table?
    (many-to-many)</dt>
  <dd>The term 'relationship' is used loosely with many_to_many as it is not
      considered a relationship in the fullest sense. For more info, read the
      documentation on &quot;many_to_many&quot; in
    DBIx::Class::Relationship.</dd>
  <dt>.. stop DBIx::Class from attempting to cascade deletes on my has_many and
    might_have relationships?</dt>
  <dd>By default, DBIx::Class cascades deletes and updates across
      <span class="Li">&quot;has_many&quot;</span> and
      <span class="Li">&quot;might_have&quot;</span> relationships. You can
      disable this behaviour on a per-relationship basis by supplying
      <span class="Li">&quot;cascade_delete =&gt; 0&quot;</span> in the
      relationship attributes.
    <p class="Pp">The cascaded operations are performed after the requested
        delete or update, so if your database has a constraint on the
        relationship, it will have deleted/updated the related records or raised
        an exception before DBIx::Class gets to perform the cascaded
      operation.</p>
    <p class="Pp">See DBIx::Class::Relationship.</p>
  </dd>
  <dt>.. use a relationship?</dt>
  <dd>Use its name. An accessor is created using the name. See examples in
      &quot;USING RELATIONSHIPS&quot; in DBIx::Class::Manual::Cookbook.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Searching"><a class="permalink" href="#Searching">Searching</a></h2>
<dl class="Bl-tag">
  <dt>.. search for data?</dt>
  <dd>Create a <span class="Li">$schema</span> object, as mentioned above in
      &quot;.. connect to my database?&quot;. Find the ResultSet that you want
      to search in, by calling
      <span class="Li">&quot;$schema-&gt;resultset('MySource')&quot;</span> and
      call <span class="Li">&quot;search&quot;</span> on it. See
      &quot;search&quot; in DBIx::Class::ResultSet.</dd>
  <dt>.. search using database functions?</dt>
  <dd>Supplying something like:
    <p class="Pp"><span class="Li"></span></p>
    <pre>
 -&gt;search({'mydatefield' =&gt; 'now()'})
    </pre>
    <p class="Pp">to search, will probably not do what you expect. It will quote
        the text &quot;<b>now()</b>&quot;, instead of trying to call the
        function. To provide literal, unquoted text you need to pass in a scalar
        reference, like so:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
 -&gt;search({'mydatefield' =&gt; \'now()'})
    </pre>
  </dd>
  <dt>.. sort the results of my search?</dt>
  <dd>Supply a list of columns you want to sort by to the
      <span class="Li">&quot;order_by&quot;</span> attribute. See
      &quot;order_by&quot; in DBIx::Class::ResultSet.</dd>
  <dt>.. sort my results based on fields I've aliased using &quot;as&quot;?</dt>
  <dd>You didn't alias anything, since as <b>has nothing to do</b> with the
      produced SQL. See &quot;select&quot; in DBIx::Class::ResultSet for
      details.</dd>
  <dt>.. group the results of my search?</dt>
  <dd>Supply a list of columns you want to group on, to the
      <span class="Li">&quot;group_by&quot;</span> attribute, see
      &quot;group_by&quot; in DBIx::Class::ResultSet.</dd>
  <dt>.. group my results based on fields I've aliased using
    &quot;as&quot;?</dt>
  <dd>You don't. See the explanation on ordering by an alias above.</dd>
  <dt>.. filter the results of my search?</dt>
  <dd>The first argument to <span class="Li">&quot;search&quot;</span> is a
      hashref of accessor names and values to filter them by, for example:
    <p class="Pp"><span class="Li"></span></p>
    <pre>
 -&gt;search({'created_time' =&gt; { '&gt;=', '2006-06-01 00:00:00' } })
    </pre>
    <p class="Pp">Note that to use a function here you need to make it a scalar
        reference:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
 -&gt;search({'created_time' =&gt; { '&gt;=', \'yesterday()' } })
    </pre>
  </dd>
  <dt>.. search in several tables simultaneously?</dt>
  <dd>To search in two related tables, you first need to set up appropriate
      relationships between their respective classes. When searching you then
      supply the name of the relationship to the
      <span class="Li">&quot;join&quot;</span> attribute in your search, for
      example when searching in the Books table for all the books by the author
      &quot;Fred Bloggs&quot;:
    <p class="Pp"><span class="Li"></span></p>
    <pre>
 -&gt;search({'authors.name' =&gt; 'Fred Bloggs'}, { join =&gt; 'authors' })
    </pre>
    <p class="Pp">The type of join created in your SQL depends on the type of
        relationship between the two tables, see DBIx::Class::Relationship for
        the join used by each relationship.</p>
  </dd>
  <dt>.. create joins with conditions other than column equality?</dt>
  <dd>Currently, DBIx::Class can only create join conditions using equality, so
      you're probably better off creating a
      <span class="Li">&quot;view&quot;</span> in your database, and using that
      as your source. A <span class="Li">&quot;view&quot;</span> is a stored SQL
      query, which can be accessed similarly to a table, see your database
      documentation for details.</dd>
  <dt>.. search with an SQL function on the left hand side?</dt>
  <dd>To use an SQL function on the left hand side of a comparison you currently
      need to resort to literal SQL:
    <p class="Pp"><span class="Li"></span></p>
    <pre>
 -&gt;search( \[ 'YEAR(date_of_birth) = ?', 1979 ] );
    </pre>
  </dd>
  <dt>.. find more help on constructing searches?</dt>
  <dd>Behind the scenes, DBIx::Class uses SQL::Abstract to help construct its
      SQL searches. So if you fail to find help in the
      DBIx::Class::Manual::Cookbook, try looking in the SQL::Abstract
      documentation.</dd>
  <dt>.. make searches in Oracle (10gR2 and newer) case-insensitive?</dt>
  <dd>To make Oracle behave like most RDBMS use on_connect_do to issue alter
      session statements on database connection establishment:
    <p class="Pp"><span class="Li"></span></p>
    <pre>
 -&gt;on_connect_do(&quot;ALTER SESSION SET NLS_COMP = 'LINGUISTIC'&quot;);
 -&gt;on_connect_do(&quot;ALTER SESSION SET NLS_SORT = '&lt;NLS&gt;_CI'&quot;);
 e.g.
 -&gt;on_connect_do(&quot;ALTER SESSION SET NLS_SORT = 'BINARY_CI'&quot;);
 -&gt;on_connect_do(&quot;ALTER SESSION SET NLS_SORT = 'GERMAN_CI'&quot;);
    </pre>
  </dd>
  <dt>.. format a DateTime object for searching?</dt>
  <dd>search and find do not take DBIx::Class::InflateColumn into account, and
      so your DateTime object will not be correctly deflated into a format your
      RDBMS expects.
    <p class="Pp">The datetime_parser method on your storage object can be used
        to return the object that would normally do this, so it's easy to do it
        manually:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  my $dtf = $schema-&gt;storage-&gt;datetime_parser;
  my $rs = $schema-&gt;resultset('users')-&gt;search(
    {
      signup_date =&gt; {
        -between =&gt; [
          $dtf-&gt;format_datetime($dt_start),
          $dtf-&gt;format_datetime($dt_end),
        ],
      }
    },
  );
    </pre>
    <p class="Pp">With in a Result Class method, you can get this from the
        <span class="Li">&quot;result_source&quot;</span>.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  my $dtf = $self-&gt;result_source-&gt;storage-&gt;datetime_parser;
    </pre>
    <p class="Pp">This kludge is necessary only for conditions passed to search
        and &quot;find&quot; in DBIx::Class::ResultSet, whereas create and
        &quot;update&quot; in DBIx::Class::Row (but not &quot;update&quot; in
        DBIx::Class::ResultSet) are DBIx::Class::InflateColumn-aware and will do
        the right thing when supplied an inflated DateTime object.</p>
  </dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Fetching_data"><a class="permalink" href="#Fetching_data">Fetching
  data</a></h2>
<dl class="Bl-tag">
  <dt>.. fetch as much data as possible in as few select calls as possible?</dt>
  <dd>See the prefetch examples in the Cookbook.</dd>
  <dt>.. fetch a whole column of data instead of a row?</dt>
  <dd>Call <span class="Li">&quot;get_column&quot;</span> on a
      DBIx::Class::ResultSet. This returns a DBIx::Class::ResultSetColumn. See
      its documentation and the Cookbook for details.</dd>
  <dt>.. fetch a formatted column?</dt>
  <dd>In your table schema class, create a &quot;private&quot; column accessor
      with:
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  __PACKAGE__-&gt;add_columns(my_column =&gt; { accessor =&gt; '_hidden_my_column' });
    </pre>
    <p class="Pp">Then, in the same class, implement a subroutine called
        &quot;my_column&quot; that fetches the real value and does the
        formatting you want.</p>
    <p class="Pp">See the Cookbook for more details.</p>
  </dd>
  <dt>.. fetch a single (or topmost) row?</dt>
  <dd>Use the &quot;rows&quot; in DBIx::Class::ResultSet and
      &quot;order_by&quot; in DBIx::Class::ResultSet attributes to order your
      data and pick off a single row.
    <p class="Pp">See also &quot;Retrieve one and only one row from a
        resultset&quot; in DBIx::Class::Manual::Cookbook.</p>
    <p class="Pp">A less readable way is to ask a regular search to return 1
        row, using &quot;slice&quot; in DBIx::Class::ResultSet:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  -&gt;search-&gt;(undef, { order_by =&gt; &quot;id DESC&quot; })-&gt;slice(0)
    </pre>
    <p class="Pp">which (if supported by the database) will use LIMIT/OFFSET to
        hint to the database that we really only need one row. This can result
        in a significant speed improvement. The method using &quot;single&quot;
        in DBIx::Class::ResultSet mentioned in the cookbook can do the same if
        you pass a <span class="Li">&quot;rows&quot;</span> attribute to the
        search.</p>
  </dd>
  <dt>.. refresh a row from storage?</dt>
  <dd>Use &quot;discard_changes&quot; in DBIx::Class::Row.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  $result-&gt;discard_changes
    </pre>
    <p class="Pp">Discarding changes and refreshing from storage are two sides
        of the same coin. When you want to discard your local changes, just
        re-fetch the row from storage. When you want to get a new, fresh copy of
        the row, just re-fetch the row from storage. &quot;discard_changes&quot;
        in DBIx::Class::Row does just that by re-fetching the row from storage
        using the row's primary key.</p>
  </dd>
  <dt>.. fetch my data a &quot;page&quot; at a time?</dt>
  <dd>Pass the <span class="Li">&quot;rows&quot;</span> and
      <span class="Li">&quot;page&quot;</span> attributes to your search, eg:
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  -&gt;search({}, { rows =&gt; 10, page =&gt; 1});
    </pre>
  </dd>
  <dt>.. get a count of all rows even when paging?</dt>
  <dd>Call <span class="Li">&quot;pager&quot;</span> on the paged resultset, it
      will return a Data::Page object. Calling
      <span class="Li">&quot;total_entries&quot;</span> on the pager will return
      the correct total.
    <p class="Pp"><span class="Li">&quot;count&quot;</span> on the resultset
        will only return the total number in the page.</p>
  </dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Inserting_and_updating_data"><a class="permalink" href="#Inserting_and_updating_data">Inserting
  and updating data</a></h2>
<dl class="Bl-tag">
  <dt>.. insert a row with an auto incrementing primary key?</dt>
  <dd>This happens automatically. After creating a result object, the primary
      key value created by your database can be fetched by calling
      <span class="Li">&quot;id&quot;</span> (or the access of your primary key
      column) on the object.</dd>
  <dt>.. insert a row with a primary key that uses a sequence?</dt>
  <dd>You need to create a trigger in your database that updates your primary
      key field from the sequence. To help PK::Auto find the next key value, you
      can tell it the name of the sequence in the
      <span class="Li">&quot;column_info&quot;</span> supplied with
      <span class="Li">&quot;add_columns&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
 -&gt;add_columns({ id =&gt; { sequence =&gt; 'mysequence', auto_nextval =&gt; 1 } });
    </pre>
  </dd>
  <dt>.. insert many rows of data efficiently?</dt>
  <dd>The <span class="Li">&quot;populate&quot;</span> method in
      DBIx::Class::ResultSet provides efficient bulk inserts.
    <p class="Pp">DBIx::Class::Fixtures provides an alternative way to do
      this.</p>
  </dd>
  <dt>.. update a collection of rows at the same time?</dt>
  <dd>Create a resultset using a <span class="Li">&quot;search&quot;</span>, to
      filter the rows of data you would like to update, then call
      <span class="Li">&quot;update&quot;</span> on the resultset to change all
      the rows at once.</dd>
  <dt>.. use database functions when updating rows?</dt>
  <dd></dd>
  <dt>.. update a column using data from another column?</dt>
  <dd>To stop the column name from being quoted, you'll need to tell DBIC that
      the right hand side is an SQL identifier (it will be quoted properly if
      you have quoting enabled):
    <p class="Pp"><span class="Li"></span></p>
    <pre>
 -&gt;update({ somecolumn =&gt; { -ident =&gt; 'othercolumn' } })
    </pre>
    <p class="Pp">This method will not retrieve the new value and put it in your
        Row object. To fetch the new value, use the
        <span class="Li">&quot;discard_changes&quot;</span> method on the
      Row.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  # will return the scalar reference:
  $result-&gt;somecolumn()

  # issue a select using the PK to re-fetch the row data:
  $result-&gt;discard_changes();

  # Now returns the correct new value:
  $result-&gt;somecolumn()
    </pre>
    <p class="Pp">To update and refresh at once, chain your calls:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  $result-&gt;update({ 'somecolumn' =&gt; { -ident =&gt; 'othercolumn' } })-&gt;discard_changes;
    </pre>
  </dd>
  <dt>.. store JSON/YAML in a column and have it deflate/inflate
    automatically?</dt>
  <dd>You can use DBIx::Class::InflateColumn to accomplish YAML/JSON storage
      transparently.
    <p class="Pp">If you want to use JSON, then in your table schema class, do
        the following:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
 use JSON;

 __PACKAGE__-&gt;add_columns(qw/ ... my_column ../)
 __PACKAGE__-&gt;inflate_column('my_column', {
     inflate =&gt; sub { jsonToObj(shift) },
     deflate =&gt; sub { objToJson(shift) },
 });
    </pre>
    <p class="Pp">For YAML, in your table schema class, do the following:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
 use YAML;

 __PACKAGE__-&gt;add_columns(qw/ ... my_column ../)
 __PACKAGE__-&gt;inflate_column('my_column', {
     inflate =&gt; sub { YAML::Load(shift) },
     deflate =&gt; sub { YAML::Dump(shift) },
 });
    </pre>
    <p class="Pp">This technique is an easy way to store supplemental
        unstructured data in a table. Be careful not to overuse this capability,
        however. If you find yourself depending more and more on some data
        within the inflated column, then it may be time to factor that data
      out.</p>
  </dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Custom_methods_in_Result_classes"><a class="permalink" href="#Custom_methods_in_Result_classes">Custom
  methods in Result classes</a></h2>
You can add custom methods that do arbitrary things, even to unrelated tables.
  For example, to provide a <span class="Li">&quot;$book-&gt;foo()&quot;</span>
  method which searches the cd table, you'd could add this to Book.pm:
<p class="Pp"><span class="Li"></span></p>
<pre>
  sub foo {
    my ($self, $col_data) = @_;
    return $self-&gt;result_source-&gt;schema-&gt;resultset('cd')-&gt;search($col_data);
  }
</pre>
<p class="Pp">And invoke that on any Book Result object like so:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  my $rs = $book-&gt;foo({ title =&gt; 'Down to Earth' });
</pre>
<p class="Pp">When two tables ARE related, DBIx::Class::Relationship::Base
    provides many methods to find or create data in related tables for you. But
    if you want to write your own methods, you can.</p>
<p class="Pp">For example, to provide a
    <span class="Li">&quot;$book-&gt;foo()&quot;</span> method to manually
    implement what <b>create_related()</b> from DBIx::Class::Relationship::Base
    does, you could add this to Book.pm:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  sub foo {
    my ($self, $rel_name, $col_data) = @_;
    return $self-&gt;related_resultset($rel_name)-&gt;create($col_data);
  }
</pre>
<p class="Pp">Invoked like this:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  my $author = $book-&gt;foo('author', { name =&gt; 'Fred' });
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Misc"><a class="permalink" href="#Misc">Misc</a></h2>
<dl class="Bl-tag">
  <dt>How do I store my own (non-db) data in my DBIx::Class objects?</dt>
  <dd>You can add your own data accessors to your Result classes.
    <p class="Pp">One method is to use the built in mk_group_accessors (via
        Class::Accessor::Grouped)</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        package App::Schema::Result::MyTable;

        use parent 'DBIx::Class::Core';

        __PACKAGE__-&gt;table('foo'); #etc
        __PACKAGE__-&gt;mk_group_accessors('simple' =&gt; qw/non_column_data/); # must use simple group
    </pre>
    <p class="Pp">An another method is to use Moose with your DBIx::Class
        package.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        package App::Schema::Result::MyTable;

        use Moose; # import Moose
        use Moose::Util::TypeConstraint; # import Moose accessor type constraints

        extends 'DBIx::Class::Core'; # Moose changes the way we define our parent (base) package

        has 'non_column_data' =&gt; ( is =&gt; 'rw', isa =&gt; 'Str' ); # define a simple attribute

        __PACKAGE__-&gt;table('foo'); # etc
    </pre>
    <p class="Pp">With either of these methods the resulting use of the accessor
        would be</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        my $result;

        # assume that somewhere in here $result will get assigned to a MyTable row

        $result-&gt;non_column_data('some string'); # would set the non_column_data accessor

        # some other stuff happens here

        $result-&gt;update(); # would not inline the non_column_data accessor into the update
    </pre>
  </dd>
  <dt>How do I use DBIx::Class objects in my TT templates?</dt>
  <dd>Like normal objects, mostly. However you need to watch out for TT calling
      methods in list context. When calling relationship accessors you will not
      get resultsets, but a list of all the related objects.
    <p class="Pp">Use the &quot;search_rs&quot; in DBIx::Class::ResultSet
        method, or the relationship accessor methods ending with &quot;_rs&quot;
        to work around this issue.</p>
    <p class="Pp">See also &quot;has_many&quot; in
      DBIx::Class::Relationship.</p>
  </dd>
  <dt>See the SQL statements my code is producing?</dt>
  <dd>Set the shell environment variable
      <span class="Li">&quot;DBIC_TRACE&quot;</span> to a true value.
    <p class="Pp">For more info see DBIx::Class::Storage for details of how to
        turn on debugging in the environment, pass your own filehandle to save
        debug to, or create your own callback.</p>
  </dd>
  <dt>Why didn't my search run any SQL?</dt>
  <dd>DBIx::Class runs the actual SQL statement as late as possible, thus if you
      create a resultset using <span class="Li">&quot;search&quot;</span> in
      scalar context, no query is executed. You can create further resultset
      refinements by calling search again or relationship accessors. The SQL
      query is only run when you ask the resultset for an actual result
    object.</dd>
  <dt>How do I deal with tables that lack a primary key?</dt>
  <dd>If your table lacks a primary key, DBIx::Class can't work out which row it
      should operate on, for example to delete or update. However, a UNIQUE
      constraint on one or more columns allows DBIx::Class to uniquely identify
      the row, so you can tell DBIx::Class::ResultSource these columns act as a
      primary key, even if they don't from the database's point of view:
    <p class="Pp"><span class="Li"></span></p>
    <pre>
 $resultset-&gt;set_primary_key(@column);
    </pre>
  </dd>
  <dt>How do I make my program start faster?</dt>
  <dd>Look at the tips in &quot;STARTUP SPEED&quot; in
      DBIx::Class::Manual::Cookbook</dd>
  <dt>How do I reduce the overhead of database queries?</dt>
  <dd>You can reduce the overhead of object creation within DBIx::Class using
      the tips in &quot;Skip result object creation for faster results&quot; in
      DBIx::Class::Manual::Cookbook and &quot;Get raw data for blindingly fast
      results&quot; in DBIx::Class::Manual::Cookbook</dd>
  <dt>How do I override a run time method (e.g. a relationship accessor)?</dt>
  <dd>If you need access to the original accessor, then you must &quot;wrap
      around&quot; the original method. You can do that either with
      Moose::Manual::MethodModifiers or Class::Method::Modifiers. The code
      example works for both modules:
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    package Your::Schema::Group;
    use Class::Method::Modifiers;

    # ... declare columns ...

    __PACKAGE__-&gt;has_many('group_servers', 'Your::Schema::GroupServer', 'group_id');
    __PACKAGE__-&gt;many_to_many('servers', 'group_servers', 'server');

    # if the server group is a &quot;super group&quot;, then return all servers
    # otherwise return only servers that belongs to the given group
    around 'servers' =&gt; sub {
        my $orig = shift;
        my $self = shift;

        return $self-&gt;$orig(@_) unless $self-&gt;is_super_group;
        return $self-&gt;result_source-&gt;schema-&gt;resultset('Server')-&gt;all;
    };
    </pre>
    <p class="Pp">If you just want to override the original method, and don't
        care about the data from the original accessor, then you have two
        options. Either use Method::Signatures::Simple that does most of the
        work for you, or do it the &quot;dirty way&quot;.</p>
    <p class="Pp">Method::Signatures::Simple way:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    package Your::Schema::Group;
    use Method::Signatures::Simple;

    # ... declare columns ...

    __PACKAGE__-&gt;has_many('group_servers', 'Your::Schema::GroupServer', 'group_id');
    __PACKAGE__-&gt;many_to_many('servers', 'group_servers', 'server');

    # The method keyword automatically injects the annoying my $self = shift; for you.
    method servers {
        return $self-&gt;result_source-&gt;schema-&gt;resultset('Server')-&gt;search({ ... });
    }
    </pre>
    <p class="Pp">The dirty way:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    package Your::Schema::Group;
    use Sub::Name;

    # ... declare columns ...

    __PACKAGE__-&gt;has_many('group_servers', 'Your::Schema::GroupServer', 'group_id');
    __PACKAGE__-&gt;many_to_many('servers', 'group_servers', 'server');

    *servers = subname servers =&gt; sub {
        my $self = shift;
        return $self-&gt;result_source-&gt;schema-&gt;resultset('Server')-&gt;search({ ... });
    };
    </pre>
  </dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Notes_for__s-1CDBI_s0_users"><a class="permalink" href="#Notes_for__s-1CDBI_s0_users">Notes
  for CDBI users</a></h2>
<dl class="Bl-tag">
  <dt>Is there a way to make an object auto-stringify itself as a particular
    column or group of columns (a-la cdbi Stringfy column group, or
    stringify_self method) ?</dt>
  <dd>See &quot;Stringification&quot; in DBIx::Class::Manual::Cookbook</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Troubleshooting"><a class="permalink" href="#Troubleshooting">Troubleshooting</a></h2>
<dl class="Bl-tag">
  <dt>Help, I can't connect to postgresql!</dt>
  <dd>If you get an error such as:
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  DBI connect('dbname=dbic','user',...) failed: could not connect to server:
  No such file or directory Is the server running locally and accepting
  connections on Unix domain socket &quot;/var/run/postgresql/.s.PGSQL.5432&quot;?
    </pre>
    <p class="Pp">Likely you have/had two copies of postgresql installed
        simultaneously, the second one will use a default port of 5433, while
        DBD::Pg is compiled with a default port of 5432.</p>
    <p class="Pp">You can change the port setting in
        <span class="Li">&quot;postgresql.conf&quot;</span>.</p>
  </dd>
  <dt>I've lost or forgotten my mysql password</dt>
  <dd>Stop mysqld and restart it with the --skip-grant-tables option.
    <p class="Pp">Issue the following statements in the mysql client.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  UPDATE mysql.user SET Password=PASSWORD('MyNewPass') WHERE User='root';
  FLUSH PRIVILEGES;
    </pre>
    <p class="Pp">Restart mysql.</p>
    <p class="Pp">Taken from:</p>
    <p class="Pp">&lt;http://dev.mysql.com/doc/refman/5.1/en/resetting-permissions.html&gt;.</p>
  </dd>
</dl>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="FURTHER_QUESTIONS?"><a class="permalink" href="#FURTHER_QUESTIONS?">FURTHER
  QUESTIONS?</a></h1>
Check the list of additional DBIC resources.
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT_AND_LICENSE"><a class="permalink" href="#COPYRIGHT_AND_LICENSE">COPYRIGHT
  AND LICENSE</a></h1>
This module is free software copyright by the DBIx::Class (DBIC) authors. You
  can redistribute it and/or modify it under the same terms as the DBIx::Class
  library.
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2018-01-29</td>
    <td class="foot-os">perl v5.30.2</td>
  </tr>
</table>
</body>
</html>
