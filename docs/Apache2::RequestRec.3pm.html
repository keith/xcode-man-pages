<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    .Nd, .Bf, .Op { display: inline; }
    .Pa, .Ad { font-style: italic; }
    .Ms { font-weight: bold; }
    .Bl-diag > dt { font-weight: bold; }
    code.Nm, .Fl, .Cm, .Ic, code.In, .Fd, .Fn, .Cd { font-weight: bold;
      font-family: inherit; }
  </style>
  <title>install::TempContent::Objects::mod_perl-2.0.12::docs::api::Apache2::RequestRec(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">install::TempContent::Objects::mod_perl-2.0.12::docs::api::Apache2::RequestRec(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">install::TempContent::Objects::mod_perl-2.0.12::docs::api::Apache2::RequestRec(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Apache2::RequestRec - Perl API for Apache request record
  accessors</p>
</section>
<section class="Sh">
<h1 class="Sh" id="Synopsis"><a class="permalink" href="#Synopsis">Synopsis</a></h1>
<pre>  use Apache2::RequestRec ();
  
  # set supported by the handler HTTP methods
  $allowed = $r-&gt;allowed();
  
  # auth type
  $auth_type = $r-&gt;ap_auth_type();
  
  # QUERY_STRING
  $args = $r-&gt;args();
  
  # non-parsed-headers handler
  $status = $r-&gt;assbackwards();
  
  # how many bytes were sent
  $bytes_sent = $r-&gt;bytes_sent();
  
  # client connection record
  $c = $r-&gt;connection();
  
  # &quot;Content-Encoding&quot; HTTP response header
  $r-&gt;content_encoding(&quot;gzip&quot;);
  
  # the languages of the content
  $languages = $r-&gt;content_languages();
  
  # &quot;Content-Encoding&quot; HTTP response header
  $r-&gt;content_type('text/plain');
  
  # special response headers table
  $err_headers_out = $r-&gt;err_headers_out();
  
  # request mapped filename
  $filename = $r-&gt;filename();
  
  # request finfo
  $finfo = $r-&gt;finfo();
  
  # 'SetHandler perl-script' equivalent
  $r-&gt;handler('perl-script');
  
  # was it a HEAD request?
  $status = $r-&gt;header_only();
  
  # request input headers table
  $headers_in = $r-&gt;headers_in();
  
  # request output headers table
  $headers_out = $r-&gt;headers_out();
  
  # hostname
  $hostname = $r-&gt;hostname();
  
  # input filters stack
  $input_filters = $r-&gt;input_filters();
  
  # get the main request obj in a sub-request
  $main_r = $r-&gt;main();
  
  # what's the current request (GET/POST/etc)?
  $method = $r-&gt;method();
  
  # what's the current method number?
  $methnum = $r-&gt;method_number();
  
  # current resource last modified time
  $mtime = $r-&gt;mtime();
  
  # next request object (in redirect)
  $next_r = $r-&gt;next();
  
  # there is no local copy
  $r-&gt;no_local_copy();
  
  # Apache ascii notes table
  $notes = $r-&gt;notes();
  
  # output filters stack
  $output_filters = $r-&gt;output_filters();
  
  # PATH_INFO
  $path_info = $r-&gt;path_info();
  
  # used in configuration directives modules
  $per_dir_config = $r-&gt;per_dir_config();
  
  # pool with life span of the current request
  $p = $r-&gt;pool();
  
  # previous request object in the internal redirect
  $prev_r = $r-&gt;prev();
  
  # connection level input filters stack
  $proto_input_filters = $r-&gt;proto_input_filters();
  
  # HTTP protocol version number
  $proto_num = $r-&gt;proto_num();
  
  # connection level output filters stack
  $proto_output_filters = $r-&gt;proto_output_filters();
  
  # the protocol, the client speaks: &quot;HTTP/1.0&quot;, &quot;HTTP/1.1&quot;, etc.
  $protocol = $r-&gt;protocol();
  
  # is it a proxy request
  $status = $r-&gt;proxyreq($val);
  
  # Time when the request started
  $request_time = $r-&gt;request_time();
  
  # server object
  $s = $r-&gt;server();
  
  # response status
  $status = $r-&gt;status();
  
  # response status line
  $status_line = $r-&gt;status_line();
  
  # manipulate %ENV of the subprocess
  $r-&gt;subprocess_env;
  $r-&gt;subprocess_env($key =&gt; $val);
  
  # first HTTP request header
  $request = $r-&gt;the_request();
  
  # the URI without any parsing performed
  $unparsed_uri = $r-&gt;unparsed_uri();
  
  # The path portion of the URI
  $uri = $r-&gt;uri();
  
  # auth username
  $user = $r-&gt;user();
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="Description"><a class="permalink" href="#Description">Description</a></h1>
<p class="Pp"><span class="Li">&quot;Apache2::RequestRec&quot;</span> provides
    the Perl API for Apache request_rec object.</p>
<p class="Pp">The following packages extend the
    <span class="Li">&quot;Apache2::RequestRec&quot;</span> functionality:
    <span class="Li">&quot;Apache2::Access&quot;</span>,
    <span class="Li">&quot;Apache2::Log&quot;</span>,
    <span class="Li">&quot;Apache2::RequestIO&quot;</span>,
    <span class="Li">&quot;Apache2::RequestUtil&quot;</span>,
    <span class="Li">&quot;Apache2::Response&quot;</span>,
    <span class="Li">&quot;Apache2::SubRequest&quot;</span> and
    <span class="Li">&quot;Apache2::URI&quot;</span>.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="API"><a class="permalink" href="#API">API</a></h1>
<p class="Pp"><span class="Li">&quot;Apache2::RequestRec&quot;</span> provides
    the following functions and/or methods:</p>
<section class="Ss">
<h2 class="Ss" id="_allowed_"><a class="permalink" href="#_allowed_">&quot;allowed&quot;</a></h2>
<p class="Pp">Get/set the allowed methods bitmask.</p>
<p class="Pp"></p>
<pre>  $allowed      = $r-&gt;allowed();
  $prev_allowed = $r-&gt;allowed($new_allowed);
</pre>
<dl class="Bl-tag">
  <dt id="obj:"><a class="permalink" href="#obj:">obj: $r (
    &quot;Apache2::RequestRec object&quot; )</a></dt>
  <dd></dd>
  <dt id="opt"><a class="permalink" href="#opt">opt arg1: $new_allowed ( bitmask
    )</a></dt>
  <dd>Set the bitvector.</dd>
  <dt id="ret:"><a class="permalink" href="#ret:">ret: $allowed ( bitmask
    )</a></dt>
  <dd>returns <span class="Li">$allowed</span>, which is a bitvector of the
      allowed methods.
    <p class="Pp">If the <span class="Li">$new_allowed</span> argument is
        passed, the value before the change is returned.</p>
  </dd>
  <dt id="since:"><a class="permalink" href="#since:">since: 2.0.00</a></dt>
  <dd></dd>
</dl>
<p class="Pp">A handler must ensure that the request method is one that it is
    capable of handling. Generally modules should
    <span class="Li">&quot;Apache2::DECLINE&quot;</span> any request methods
    they do not handle. Prior to aborting the handler like this the handler
    should set <span class="Li">&quot;$r-&gt;allowed&quot;</span> to the list of
    methods that it is willing to handle. This bitvector is used to construct
    the <span class="Li">&quot;Allow:&quot;</span> header required for
    <span class="Li">&quot;OPTIONS&quot;</span> requests, and
    <span class="Li">&quot;Apache2::Const::HTTP_METHOD_NOT_ALLOWED&quot;</span>
    (405) and
    <span class="Li">&quot;Apache2::Const::HTTP_NOT_IMPLEMENTED&quot;</span>
    (501) status codes.</p>
<p class="Pp">Since the default Apache handler deals with the
    <span class="Li">&quot;OPTIONS&quot;</span> method, all response handlers
    can usually decline to deal with
    <span class="Li">&quot;OPTIONS&quot;</span>. For example if the response
    handler handles only <span class="Li">&quot;GET&quot;</span> and
    <span class="Li">&quot;POST&quot;</span> methods, and not
    <span class="Li">&quot;OPTIONS&quot;</span>, it may want to say:</p>
<p class="Pp"></p>
<pre>   use Apache2::Const -compile =&gt; qw(OK DECLINED M_GET M_POST M_OPTIONS);
   if ($r-&gt;method_number == Apache2::Const::M_OPTIONS) {
       $r-&gt;allowed($r-&gt;allowed | (1&lt;&lt;Apache2::Const::M_GET) | (1&lt;&lt;Apache2::Const::M_POST));
       return Apache2::Const::DECLINED;
   }
</pre>
<p class="Pp"><span class="Li">&quot;TRACE&quot;</span> is always allowed,
    modules don't need to set it explicitly.</p>
<p class="Pp">Since the default_handler will always handle a
    <span class="Li">&quot;GET&quot;</span>, a module which does *not* implement
    <span class="Li">&quot;GET&quot;</span> should probably return
    <span class="Li">&quot;Apache2::Const::HTTP_METHOD_NOT_ALLOWED&quot;</span>.
    Unfortunately this means that a script
    <span class="Li">&quot;GET&quot;</span> handler can't be installed by
    mod_actions.</p>
<p class="Pp">For example, if the module can handle only POST method it could
    start with:</p>
<p class="Pp"></p>
<pre>   use Apache2::Const -compile =&gt; qw(M_POST HTTP_METHOD_NOT_ALLOWED);
   unless ($r-&gt;method_number == Apache2::Const::M_POST) {
       $r-&gt;allowed($r-&gt;allowed | (1&lt;&lt;Apache2::Const::M_POST));
       return Apache2::Const::HTTP_METHOD_NOT_ALLOWED;
   }
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="_ap_auth_type_"><a class="permalink" href="#_ap_auth_type_">&quot;ap_auth_type&quot;</a></h2>
<p class="Pp">If an authentication check was made, get or set the
    <i>ap_auth_type</i> slot in the request record</p>
<p class="Pp"></p>
<pre>  $auth_type = $r-&gt;ap_auth_type();
  $r-&gt;ap_auth_type($newval);
</pre>
<dl class="Bl-tag">
  <dt id="obj:~2"><a class="permalink" href="#obj:~2">obj: $r (
    &quot;Apache2::RequestRec object&quot; )</a></dt>
  <dd></dd>
  <dt id="opt~2"><a class="permalink" href="#opt~2">opt arg1: $newval
    (string)</a></dt>
  <dd>If this argument is passed then a new auth type is assigned. For example:
    <p class="Pp"></p>
    <pre>  $r-&gt;auth_type('Basic');
    </pre>
  </dd>
  <dt id="ret:~2"><a class="permalink" href="#ret:~2">ret: $auth_type
    (string)</a></dt>
  <dd>If <span class="Li">$newval</span> is passed, nothing is returned.
      Otherwise the current auth type is returned.</dd>
  <dt id="since:~2"><a class="permalink" href="#since:~2">since: 2.0.00</a></dt>
  <dd></dd>
</dl>
<p class="Pp"><i>ap_auth_type</i> holds the authentication type that has been
    negotiated between the client and server during the actual request.
    Generally, <i>ap_auth_type</i> is populated automatically when you call
    <span class="Li">&quot;$r-&gt;get_basic_auth_pw&quot;</span> so you don't
    really need to worry too much about it, but if you want to roll your own
    authentication mechanism then you will have to populate <i>ap_auth_type</i>
    yourself.</p>
<p class="Pp">Note that <span class="Li">&quot;$r-&gt;ap_auth_type&quot;</span>
    was <span class="Li">&quot;$r-&gt;connection-&gt;auth_type&quot;</span> in
    the mod_perl 1.0 API.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_args_"><a class="permalink" href="#_args_">&quot;args&quot;</a></h2>
<p class="Pp">Get/set the request QUERY string</p>
<p class="Pp"></p>
<pre>  $args      = $r-&gt;args();
  $prev_args = $r-&gt;args($new_args);
</pre>
<dl class="Bl-tag">
  <dt id="obj:~3"><a class="permalink" href="#obj:~3">obj: $r (
    &quot;Apache2::RequestRec object&quot; )</a></dt>
  <dd></dd>
  <dt id="opt~3"><a class="permalink" href="#opt~3">opt arg1: $new_args ( string
    )</a></dt>
  <dd>Optionally set the new QUERY string</dd>
  <dt id="ret:~3"><a class="permalink" href="#ret:~3">ret: $args ( string
    )</a></dt>
  <dd>The current QUERY string
    <p class="Pp">If <span class="Li">$new_args</span> was passed, returns the
        value before the change.</p>
  </dd>
  <dt id="since:~3"><a class="permalink" href="#since:~3">since: 2.0.00</a></dt>
  <dd></dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="_assbackwards_"><a class="permalink" href="#_assbackwards_">&quot;assbackwards&quot;</a></h2>
<p class="Pp">When set to a true value, Apache won't send any HTTP response
    headers allowing you to send any headers.</p>
<p class="Pp"></p>
<pre>  $status      = $r-&gt;assbackwards();
  $prev_status = $r-&gt;assbackwards($newval);
</pre>
<dl class="Bl-tag">
  <dt id="obj:~4"><a class="permalink" href="#obj:~4">obj: $r (
    &quot;Apache2::RequestRec object&quot; )</a></dt>
  <dd></dd>
  <dt id="opt~4"><a class="permalink" href="#opt~4">opt arg1: $newval
    (integer)</a></dt>
  <dd>assign a new state.</dd>
  <dt id="ret:~4"><a class="permalink" href="#ret:~4">ret: $status
    (integer)</a></dt>
  <dd>current state.</dd>
  <dt id="since:~4"><a class="permalink" href="#since:~4">since: 2.0.00</a></dt>
  <dd></dd>
</dl>
<p class="Pp">If you send your own set of headers, which includes the
    <span class="Li">&quot;Keep-Alive&quot;</span> HTTP response header, you
    must make sure to increment the number of requests served over this
    connection (which is normally done by the core connection output filter
    <span class="Li">&quot;ap_http_header_filter&quot;</span>, but skipped when
    <span class="Li">&quot;assbackwards&quot;</span> is enabled).</p>
<p class="Pp"></p>
<pre>  $r-&gt;connection-&gt;keepalives($r-&gt;connection-&gt;keepalives + 1);
</pre>
<p class="Pp">otherwise code relying on the value of
    <span class="Li">&quot;$r-&gt;connection-&gt;keepalives&quot;</span> may
    malfunction. For example, this counter is used to tell when a new request is
    coming in over the same connection to a filter that wants to parse only HTTP
    headers (like
    <span class="Li">&quot;Apache2::Filter::HTTPHeadersFixup&quot;</span>). Of
    course you will need to set
    <span class="Li">&quot;$r-&gt;connection-&gt;keepalive(1)&quot;</span> ) as
    well.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_bytes_sent_"><a class="permalink" href="#_bytes_sent_">&quot;bytes_sent&quot;</a></h2>
<p class="Pp">The number of bytes sent to the client, handy for logging,
  etc.</p>
<p class="Pp"></p>
<pre>  $bytes_sent = $r-&gt;bytes_sent();
</pre>
<dl class="Bl-tag">
  <dt id="obj:~5"><a class="permalink" href="#obj:~5">obj: $r (
    &quot;Apache2::RequestRec object&quot; )</a></dt>
  <dd></dd>
  <dt id="ret:~5"><a class="permalink" href="#ret:~5">ret: $bytes_sent
    (integer)</a></dt>
  <dd></dd>
  <dt id="since:~5"><a class="permalink" href="#since:~5">since: 2.0.00</a></dt>
  <dd></dd>
</dl>
<p class="Pp">Though as of this writing in Apache 2.0 it doesn't really do what
    it did in Apache 1.3. It's just set to the size of the response body. The
    issue is that buckets from one request may get buffered and not sent during
    the lifetime of the request, so it's not easy to give a truly accurate count
    of &quot;bytes sent to the network for this response&quot;.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_connection_"><a class="permalink" href="#_connection_">&quot;connection&quot;</a></h2>
<p class="Pp">Get the client connection record</p>
<p class="Pp"></p>
<pre>  $c = $r-&gt;connection();
</pre>
<dl class="Bl-tag">
  <dt id="obj:~6"><a class="permalink" href="#obj:~6">obj: $r (
    &quot;Apache2::RequestRec object&quot; )</a></dt>
  <dd></dd>
  <dt id="ret:~6"><a class="permalink" href="#ret:~6">ret: $c (
    &quot;Apache2::Connection object&quot; )</a></dt>
  <dd></dd>
  <dt id="since:~6"><a class="permalink" href="#since:~6">since: 2.0.00</a></dt>
  <dd></dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="_content_encoding_"><a class="permalink" href="#_content_encoding_">&quot;content_encoding&quot;</a></h2>
<p class="Pp">Get/set content encoding (the &quot;Content-Encoding&quot; HTTP
    header). Content encodings are string like <i>&quot;gzip&quot;</i> or
    <i>&quot;compress&quot;</i>.</p>
<p class="Pp"></p>
<pre>  $ce      = $r-&gt;content_encoding();
  $prev_ce = $r-&gt;content_encoding($new_ce);
</pre>
<dl class="Bl-tag">
  <dt id="obj:~7"><a class="permalink" href="#obj:~7">obj: $r (
    &quot;Apache2::RequestRec object&quot; )</a></dt>
  <dd></dd>
  <dt id="opt~5"><a class="permalink" href="#opt~5">opt arg1: $new_ce ( string
    )</a></dt>
  <dd>If passed, sets the content encoding to a new value. It must be a
      lowercased string.</dd>
  <dt id="ret:~7"><a class="permalink" href="#ret:~7">ret: $ce ( string
    )</a></dt>
  <dd>The current content encoding.
    <p class="Pp">If <span class="Li">$new_ce</span> is passed, then the
        previous value is returned.</p>
  </dd>
  <dt id="since:~7"><a class="permalink" href="#since:~7">since: 2.0.00</a></dt>
  <dd></dd>
</dl>
<p class="Pp">For example, here is how to send a gzip'ed response:</p>
<p class="Pp"></p>
<pre>  require Compress::Zlib;
  $r-&gt;content_type(&quot;text/plain&quot;);
  $r-&gt;content_encoding(&quot;gzip&quot;);
  $r-&gt;print(Compress::Zlib::memGzip(&quot;some text to be gzipped));
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="_content_languages_"><a class="permalink" href="#_content_languages_">&quot;content_languages&quot;</a></h2>
<p class="Pp">Get/set content languages (the
    <span class="Li">&quot;Content-Language&quot;</span> HTTP header). Content
    languages are string like <i>&quot;en&quot;</i> or
  <i>&quot;fr&quot;</i>.</p>
<p class="Pp"></p>
<pre>  $languages = $r-&gt;content_languages();
  $prev_lang = $r-&gt;content_languages($nev_lang);
</pre>
<dl class="Bl-tag">
  <dt id="obj:~8"><a class="permalink" href="#obj:~8">obj: $r (
    &quot;Apache2::RequestRec object&quot; )</a></dt>
  <dd></dd>
  <dt id="opt~6"><a class="permalink" href="#opt~6">opt arg1: $new_lang ( ARRAY
    ref )</a></dt>
  <dd>If passed, sets the content languages to new values. It must be an ARRAY
      reference of language names, like <i>&quot;en&quot;</i> or
      <i>&quot;fr&quot;</i></dd>
  <dt id="ret:~8"><a class="permalink" href="#ret:~8">ret: $languages ( ARRAY
    ref )</a></dt>
  <dd>The current list of content languages, as an ARRAY reference.
    <p class="Pp">If <span class="Li">$new_lang</span> is passed, then the
        previous value is returned.</p>
  </dd>
  <dt id="since:~8"><a class="permalink" href="#since:~8">since: 2.0.00</a></dt>
  <dd></dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="_content_type_"><a class="permalink" href="#_content_type_">&quot;content_type&quot;</a></h2>
<p class="Pp">Get/set the HTTP response <i>Content-type</i> header value.</p>
<p class="Pp"></p>
<pre>  my $content_type      = $r-&gt;content_type();
  my $prev_content_type = $r-&gt;content_type($new_content_type);
</pre>
<dl class="Bl-tag">
  <dt id="obj:~9"><a class="permalink" href="#obj:~9">obj: $r (
    &quot;Apache2::RequestRec object&quot; )</a></dt>
  <dd></dd>
  <dt id="opt~7"><a class="permalink" href="#opt~7">opt arg1: $new_content_type
    (MIME type string)</a></dt>
  <dd>Assign a new HTTP response content-type. It will affect the response only
      if HTTP headers weren't sent yet.</dd>
  <dt id="ret:~9"><a class="permalink" href="#ret:~9">ret:
    $content_type</a></dt>
  <dd>The current content-type value.
    <p class="Pp">If <span class="Li">$new_content_type</span> was passed, the
        previous value is returned instead.</p>
  </dd>
  <dt id="since:~9"><a class="permalink" href="#since:~9">since: 2.0.00</a></dt>
  <dd></dd>
</dl>
<p class="Pp">For example, set the
    <span class="Li">&quot;Content-type&quot;</span> header to
    <i>text/plain</i>.</p>
<p class="Pp"></p>
<pre>  $r-&gt;content_type('text/plain');
</pre>
<p class="Pp">If you set this header via the
    <span class="Li">&quot;headers_out&quot;</span> table directly, it will be
    ignored by Apache. So do not do that.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_err_headers_out_"><a class="permalink" href="#_err_headers_out_">&quot;err_headers_out&quot;</a></h2>
<p class="Pp">Get/set MIME response headers, printed even on errors and persist
    across internal redirects.</p>
<p class="Pp"></p>
<pre>  $err_headers_out = $r-&gt;err_headers_out();
</pre>
<dl class="Bl-tag">
  <dt id="obj:~10"><a class="permalink" href="#obj:~10">obj: $r (
    &quot;Apache2::RequestRec object&quot; )</a></dt>
  <dd></dd>
  <dt id="ret:~10"><a class="permalink" href="#ret:~10">ret: $err_headers_out (
    &quot;APR::Table object&quot; )</a></dt>
  <dd></dd>
  <dt id="since:~10"><a class="permalink" href="#since:~10">since:
    2.0.00</a></dt>
  <dd></dd>
</dl>
<p class="Pp">The difference between
    <span class="Li">&quot;headers_out&quot;</span> and
    <span class="Li">&quot;err_headers_out&quot;</span>, is that the latter are
    printed even on error, and persist across internal redirects (so the headers
    printed for <span class="Li">&quot;ErrorDocument&quot;</span> handlers will
    have them).</p>
<p class="Pp">For example, if a handler wants to return a 404 response, but
    nevertheless to set a cookie, it has to be:</p>
<p class="Pp"></p>
<pre>  $r-&gt;err_headers_out-&gt;add('Set-Cookie' =&gt; $cookie);
  return Apache2::Const::NOT_FOUND;
</pre>
<p class="Pp">If the handler does:</p>
<p class="Pp"></p>
<pre>  $r-&gt;headers_out-&gt;add('Set-Cookie' =&gt; $cookie);
  return Apache2::Const::NOT_FOUND;
</pre>
<p class="Pp">the <span class="Li">&quot;Set-Cookie&quot;</span> header won't be
    sent.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_filename_"><a class="permalink" href="#_filename_">&quot;filename&quot;</a></h2>
<p class="Pp">Get/set the filename on disk corresponding to this response (the
    result of the <i>URI --&gt; filename</i> translation).</p>
<p class="Pp"></p>
<pre>  $filename      = $r-&gt;filename();
  $prev_filename = $r-&gt;filename($new_filename);
</pre>
<dl class="Bl-tag">
  <dt id="obj:~11"><a class="permalink" href="#obj:~11">obj: $r (
    &quot;Apache2::RequestRec object&quot; )</a></dt>
  <dd></dd>
  <dt id="opt~8"><a class="permalink" href="#opt~8">opt arg1: $new_filename (
    string )</a></dt>
  <dd>new value</dd>
  <dt id="ret:~11"><a class="permalink" href="#ret:~11">ret: $filename ( string
    )</a></dt>
  <dd>the current filename, or the previous value if the optional
      <span class="Li">$new_filename</span> argument was passed</dd>
  <dt id="since:~11"><a class="permalink" href="#since:~11">since:
    2.0.00</a></dt>
  <dd></dd>
</dl>
<p class="Pp">Note that if you change the filename after the
    <span class="Li">&quot;PerlMapToStorageHandler&quot;</span> phase was run
    and expect Apache to serve it, you need to update its
    <span class="Li">&quot;stat&quot;</span> record, like so:</p>
<p class="Pp"></p>
<pre>  use Apache2::RequestRec ();
  use APR::Finfo ();
  use APR::Const -compile =&gt; qw(FINFO_NORM);
  $r-&gt;filename($newfile);
  $r-&gt;finfo(APR::Finfo::stat($newfile, APR::Const::FINFO_NORM, $r-&gt;pool));
</pre>
<p class="Pp">if you don't, Apache will still try to use the previously cached
    information about the previously set value of the filename.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_finfo_"><a class="permalink" href="#_finfo_">&quot;finfo&quot;</a></h2>
<p class="Pp">Get and set the <i>finfo</i> request record member:</p>
<p class="Pp"></p>
<pre>  $finfo = $r-&gt;finfo();
  $r-&gt;finfo($finfo);
</pre>
<dl class="Bl-tag">
  <dt id="obj:~12"><a class="permalink" href="#obj:~12">obj: $r (
    &quot;Apache2::RequestRec object&quot; )</a></dt>
  <dd></dd>
  <dt id="opt~9"><a class="permalink" href="#opt~9">opt arg1: $finfo (
    &quot;APR::Finfo object&quot; )</a></dt>
  <dd></dd>
  <dt id="ret:~12"><a class="permalink" href="#ret:~12">ret: $finfo (
    &quot;APR::Finfo object&quot; )</a></dt>
  <dd>Always returns the current object.
    <p class="Pp">Due to the internal Apache implementation it's not possible to
        have two different objects originating from
        <span class="Li">&quot;$r-&gt;finfo&quot;</span> at the same time.
        Whenever <span class="Li">&quot;$r-&gt;finfo&quot;</span> is updated all
        objects will be updated too to the latest value.</p>
  </dd>
  <dt id="since:~12"><a class="permalink" href="#since:~12">since:
    2.0.00</a></dt>
  <dd></dd>
</dl>
<p class="Pp">Most of the time, this method is used to get the
    <span class="Li">&quot;finfo&quot;</span> member. The only reason you may
    want to set it is you need to use it before the Apache's default
    map_to_storage phase is called.</p>
<p class="Pp">Examples:</p>
<ul class="Bl-bullet">
  <li>What Apache thinks is the current request filename (post the
      <span class="Li">&quot;PerlMapToStorageHandler&quot;</span> phase):
    <p class="Pp"></p>
    <pre>  use Apache2::RequestRec ();
  use APR::Finfo ();
  print $r-&gt;finfo-&gt;fname;
    </pre>
  </li>
  <li>Populate the <span class="Li">&quot;finfo&quot;</span> member (normally,
      before the <span class="Li">&quot;PerlMapToStorageHandler&quot;</span>
      phase):
    <p class="Pp"></p>
    <pre>  use APR::Finfo ();
  use APR::Const -compile =&gt; qw(FINFO_NORM);
  
  my $finfo = APR::Finfo::stat(__FILE__, APR::Const::FINFO_NORM, $r-&gt;pool);
  $r-&gt;finfo($finfo);
    </pre>
  </li>
</ul>
</section>
<section class="Ss">
<h2 class="Ss" id="_handler_"><a class="permalink" href="#_handler_">&quot;handler&quot;</a></h2>
<p class="Pp">Get/set the equivalent of the
    <span class="Li">&quot;SetHandler&quot;</span> directive.</p>
<p class="Pp"></p>
<pre>  $handler      = $r-&gt;handler();
  $prev_handler = $r-&gt;handler($new_handler);
</pre>
<dl class="Bl-tag">
  <dt id="obj:~13"><a class="permalink" href="#obj:~13">obj: $r (
    &quot;Apache2::RequestRec object&quot; )</a></dt>
  <dd></dd>
  <dt id="opt~10"><a class="permalink" href="#opt~10">opt arg1: $new_handler (
    string )</a></dt>
  <dd>the new handler.</dd>
  <dt id="ret:~13"><a class="permalink" href="#ret:~13">ret: $handler ( string
    )</a></dt>
  <dd>the current handler.
    <p class="Pp">If <span class="Li">$new_handler</span> is passed, the
        previous value is returned.</p>
  </dd>
  <dt id="since:~13"><a class="permalink" href="#since:~13">since:
    2.0.00</a></dt>
  <dd></dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="_header_only_"><a class="permalink" href="#_header_only_">&quot;header_only&quot;</a></h2>
<p class="Pp">Did the client has asked for headers only? e.g. if the request
    method was <b>HEAD</b>.</p>
<p class="Pp"></p>
<pre>  $status = $r-&gt;header_only();
</pre>
<dl class="Bl-tag">
  <dt id="obj:~14"><a class="permalink" href="#obj:~14">obj: $r (
    &quot;Apache2::RequestRec object&quot; )</a></dt>
  <dd></dd>
  <dt id="ret:~14"><a class="permalink" href="#ret:~14">ret: $status ( boolean
    )</a></dt>
  <dd>Returns true if the client is asking for headers only, false
    otherwise</dd>
  <dt id="since:~14"><a class="permalink" href="#since:~14">since:
    2.0.00</a></dt>
  <dd></dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="_headers_in_"><a class="permalink" href="#_headers_in_">&quot;headers_in&quot;</a></h2>
<p class="Pp">Get/set the request MIME headers:</p>
<p class="Pp"></p>
<pre>  $headers_in = $r-&gt;headers_in();
</pre>
<dl class="Bl-tag">
  <dt id="obj:~15"><a class="permalink" href="#obj:~15">obj: $r (
    &quot;Apache2::RequestRec object&quot; )</a></dt>
  <dd></dd>
  <dt id="ret:~15"><a class="permalink" href="#ret:~15">ret: $headers_in (
    &quot;APR::Table object&quot; )</a></dt>
  <dd></dd>
  <dt id="since:~15"><a class="permalink" href="#since:~15">since:
    2.0.00</a></dt>
  <dd></dd>
</dl>
<p class="Pp">This table is available starting from the
    <span class="Li">&quot;PerlHeaderParserHandler&quot;</span> phase.</p>
<p class="Pp">For example you can use it to retrieve the cookie value sent by
    the client, in the <span class="Li">&quot;Cookie:&quot;</span> header:</p>
<p class="Pp"></p>
<pre>    my $cookie = $r-&gt;headers_in-&gt;{Cookie} || '';
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="_headers_out_"><a class="permalink" href="#_headers_out_">&quot;headers_out&quot;</a></h2>
<p class="Pp">Get/set MIME response headers, printed only on 2xx responses.</p>
<p class="Pp"></p>
<pre>  $headers_out = $r-&gt;headers_out();
</pre>
<dl class="Bl-tag">
  <dt id="obj:~16"><a class="permalink" href="#obj:~16">obj: $r (
    &quot;Apache2::RequestRec object&quot; )</a></dt>
  <dd></dd>
  <dt id="ret:~16"><a class="permalink" href="#ret:~16">ret: $headers_out (
    &quot;APR::Table object&quot; )</a></dt>
  <dd></dd>
  <dt id="since:~16"><a class="permalink" href="#since:~16">since:
    2.0.00</a></dt>
  <dd></dd>
</dl>
<p class="Pp">See also <span class="Li">&quot;err_headers_out&quot;</span>,
    which allows to set headers for non-2xx responses and persist across
    internal redirects.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_hostname_"><a class="permalink" href="#_hostname_">&quot;hostname&quot;</a></h2>
<p class="Pp">Host, as set by full URI or Host:</p>
<p class="Pp"></p>
<pre>  $hostname = $r-&gt;hostname();
  $prev_hostname = $r-&gt;hostname($new_hostname);
</pre>
<dl class="Bl-tag">
  <dt id="obj:~17"><a class="permalink" href="#obj:~17">obj: $r (
    &quot;Apache2::RequestRec object&quot; )</a></dt>
  <dd></dd>
  <dt id="opt~11"><a class="permalink" href="#opt~11">opt arg1: $new_hostname (
    string )</a></dt>
  <dd>new value</dd>
  <dt id="ret:~17"><a class="permalink" href="#ret:~17">ret: $hostname ( string
    )</a></dt>
  <dd>the current hostname, or the previous value if the optional
      <span class="Li">$new_hostname</span> argument was passed</dd>
  <dt id="since:~17"><a class="permalink" href="#since:~17">since:
    2.0.00</a></dt>
  <dd></dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="_input_filters_"><a class="permalink" href="#_input_filters_">&quot;input_filters&quot;</a></h2>
<p class="Pp">Get/set the first filter in a linked list of request level input
    filters:</p>
<p class="Pp"></p>
<pre>  $input_filters      = $r-&gt;input_filters();
  $prev_input_filters = $r-&gt;input_filters($new_input_filters);
</pre>
<dl class="Bl-tag">
  <dt id="obj:~18"><a class="permalink" href="#obj:~18">obj: $r (
    &quot;Apache2::RequestRec object&quot; )</a></dt>
  <dd></dd>
  <dt id="opt~12"><a class="permalink" href="#opt~12">opt arg1:
    $new_input_filters</a></dt>
  <dd>Set a new value</dd>
  <dt id="ret:~18"><a class="permalink" href="#ret:~18">ret: $input_filters (
    &quot;Apache2::Filter object&quot; )</a></dt>
  <dd>The first filter in the request level input filters chain.
    <p class="Pp">If <span class="Li">$new_input_filters</span> was passed,
        returns the previous value.</p>
  </dd>
  <dt id="since:~18"><a class="permalink" href="#since:~18">since:
    2.0.00</a></dt>
  <dd></dd>
</dl>
<p class="Pp">For example instead of using
    <span class="Li">&quot;$r-&gt;read()&quot;</span> to read the POST data, one
    could use an explicit walk through incoming bucket brigades to get that
    data. The following function <span class="Li">&quot;read_post()&quot;</span>
    does just that (in fact that's what
    <span class="Li">&quot;$r-&gt;read()&quot;</span> does behind the
  scenes):</p>
<p class="Pp"></p>
<pre>  use APR::Brigade ();
  use APR::Bucket ();
  use Apache2::Filter ();
  
  use Apache2::Const -compile =&gt; qw(MODE_READBYTES);
  use APR::Const    -compile =&gt; qw(SUCCESS BLOCK_READ);
  
  use constant IOBUFSIZE =&gt; 8192;
  
  sub read_post {
      my $r = shift;
  
      my $bb = APR::Brigade-&gt;new($r-&gt;pool,
                                 $r-&gt;connection-&gt;bucket_alloc);
  
      my $data = '';
      my $seen_eos = 0;
      do {
          $r-&gt;input_filters-&gt;get_brigade($bb, Apache2::Const::MODE_READBYTES,
                                         APR::Const::BLOCK_READ, IOBUFSIZE);
  
          for (my $b = $bb-&gt;first; $b; $b = $bb-&gt;next($b)) {
              if ($b-&gt;is_eos) {
                  $seen_eos++;
                  last;
              }
  
              if ($b-&gt;read(my $buf)) {
                  $data .= $buf;
              }
  
              $b-&gt;remove; # optimization to reuse memory
          }
  
      } while (!$seen_eos);
  
      $bb-&gt;destroy;
  
      return $data;
  }
</pre>
<p class="Pp">As you can see
    <span class="Li">&quot;$r-&gt;input_filters&quot;</span> gives us a pointer
    to the last of the top of the incoming filters stack.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_main_"><a class="permalink" href="#_main_">&quot;main&quot;</a></h2>
<p class="Pp">Get the main request record</p>
<p class="Pp"></p>
<pre>  $main_r = $r-&gt;main();
</pre>
<dl class="Bl-tag">
  <dt id="obj:~19"><a class="permalink" href="#obj:~19">obj: $r (
    &quot;Apache2::RequestRec object&quot; )</a></dt>
  <dd></dd>
  <dt id="ret:~19"><a class="permalink" href="#ret:~19">ret: $main_r (
    &quot;Apache2::RequestRec object&quot; )</a></dt>
  <dd>If the current request is a sub-request, this method returns a blessed
      reference to the main request structure. If the current request is the
      main request, then this method returns
      <span class="Li">&quot;undef&quot;</span>.
    <p class="Pp">To figure out whether you are inside a main request or a
        sub-request/internal redirect, use
        <span class="Li">&quot;$r-&gt;is_initial_req&quot;</span>.</p>
  </dd>
  <dt id="since:~19"><a class="permalink" href="#since:~19">since:
    2.0.00</a></dt>
  <dd></dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="_method_"><a class="permalink" href="#_method_">&quot;method&quot;</a></h2>
<p class="Pp">Get/set the current request method (e.g.
    <span class="Li">&quot;GET&quot;</span>,
    <span class="Li">&quot;HEAD&quot;</span>,
    <span class="Li">&quot;POST&quot;</span>, etc.):</p>
<p class="Pp"></p>
<pre>  $method     = $r-&gt;method();
  $pre_method = $r-&gt;method($new_method);
</pre>
<dl class="Bl-tag">
  <dt id="obj:~20"><a class="permalink" href="#obj:~20">obj: $r (
    &quot;Apache2::RequestRec object&quot; )</a></dt>
  <dd></dd>
  <dt id="opt~13"><a class="permalink" href="#opt~13">opt arg1: $new_method (
    string )</a></dt>
  <dd>a new value</dd>
  <dt id="ret:~20"><a class="permalink" href="#ret:~20">ret: $method ( string
    )</a></dt>
  <dd>The current method as a string
    <p class="Pp">if <span class="Li">$new_method</span> was passed the previous
        value is returned.</p>
  </dd>
  <dt id="since:~20"><a class="permalink" href="#since:~20">since:
    2.0.00</a></dt>
  <dd></dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="_method_number_"><a class="permalink" href="#_method_number_">&quot;method_number&quot;</a></h2>
<p class="Pp">Get/set the HTTP method, issued by the client
    (<span class="Li">&quot;Apache2::Const::M_GET&quot;</span>,
    <span class="Li">&quot;Apache2::Const::M_POST&quot;</span>, etc.)</p>
<p class="Pp"></p>
<pre>  $methnum      = $r-&gt;method_number();
  $prev_methnum = $r-&gt;method_number($new_methnum);
</pre>
<dl class="Bl-tag">
  <dt id="obj:~21"><a class="permalink" href="#obj:~21">obj: $r (
    &quot;Apache2::RequestRec object&quot; )</a></dt>
  <dd></dd>
  <dt id="opt~14"><a class="permalink" href="#opt~14">opt arg1: $new_methnum (
    &quot;Apache2::Const :methods constant&quot; )</a></dt>
  <dd>a new value</dd>
  <dt id="ret:~21"><a class="permalink" href="#ret:~21">ret: $methnum (
    &quot;Apache2::Const :methods constant&quot; )</a></dt>
  <dd>The current method as a number
    <p class="Pp">if <span class="Li">$new_methnum</span> was passed the
        previous value is returned.</p>
  </dd>
  <dt id="since:~21"><a class="permalink" href="#since:~21">since:
    2.0.00</a></dt>
  <dd></dd>
</dl>
<p class="Pp">See the <span class="Li">&quot;$r-&gt;allowed&quot;</span> entry
    for examples.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_mtime_"><a class="permalink" href="#_mtime_">&quot;mtime&quot;</a></h2>
<p class="Pp">Last modified time of the requested resource</p>
<p class="Pp"></p>
<pre>  $mtime      = $r-&gt;mtime();
  $prev_mtime = $r-&gt;mtime($new_mtime);
</pre>
<dl class="Bl-tag">
  <dt id="obj:~22"><a class="permalink" href="#obj:~22">obj: $r (
    &quot;Apache2::RequestRec object&quot; )</a></dt>
  <dd></dd>
  <dt id="opt~15"><a class="permalink" href="#opt~15">opt arg1: $new_mtime
    (epoch seconds).</a></dt>
  <dd>a new value</dd>
  <dt id="ret:~22"><a class="permalink" href="#ret:~22">ret: $mtime (epoch
    seconds).</a></dt>
  <dd>the current value
    <p class="Pp">if <span class="Li">$new_mtime</span> was passed the previous
        value is returned.</p>
  </dd>
  <dt id="since:~22"><a class="permalink" href="#since:~22">since:
    2.0.00</a></dt>
  <dd></dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="_next_"><a class="permalink" href="#_next_">&quot;next&quot;</a></h2>
<p class="Pp">Pointer to the redirected request if this is an external
  redirect</p>
<p class="Pp"></p>
<pre>  $next_r = $r-&gt;next();
</pre>
<dl class="Bl-tag">
  <dt id="obj:~23"><a class="permalink" href="#obj:~23">obj: $r (
    &quot;Apache2::RequestRec object&quot; )</a></dt>
  <dd></dd>
  <dt id="ret:~23"><a class="permalink" href="#ret:~23">ret: $next_r (
    &quot;Apache2::RequestRec object&quot; )</a></dt>
  <dd>returns a blessed reference to the next (internal) request structure or
      <span class="Li">&quot;undef&quot;</span> if there is no next
    request.</dd>
  <dt id="since:~23"><a class="permalink" href="#since:~23">since:
    2.0.00</a></dt>
  <dd></dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="_no_local_copy_"><a class="permalink" href="#_no_local_copy_">&quot;no_local_copy&quot;</a></h2>
<p class="Pp">There is no local copy of this response</p>
<p class="Pp"></p>
<pre>  $status = $r-&gt;no_local_copy();
</pre>
<dl class="Bl-tag">
  <dt id="obj:~24"><a class="permalink" href="#obj:~24">obj: $r (
    &quot;Apache2::RequestRec object&quot; )</a></dt>
  <dd></dd>
  <dt id="ret:~24"><a class="permalink" href="#ret:~24">ret: $status
    (integer)</a></dt>
  <dd></dd>
  <dt id="since:~24"><a class="permalink" href="#since:~24">since:
    2.0.00</a></dt>
  <dd></dd>
</dl>
<p class="Pp">Used internally in certain sub-requests to prevent sending
    <span class="Li">&quot;Apache2::Const::HTTP_NOT_MODIFIED&quot;</span> for a
    fragment or error documents. For example see the implementation in
    <i>modules/filters/mod_include.c</i>.</p>
<p class="Pp">Also used internally in
    <span class="Li">&quot;$r-&gt;meets_conditions&quot;</span> -- if set to a
    true value, the conditions are always met.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_notes_"><a class="permalink" href="#_notes_">&quot;notes&quot;</a></h2>
<p class="Pp">Get/set text notes for the duration of this request. These notes
    can be passed from one module to another (not only mod_perl, but modules in
    any other language):</p>
<p class="Pp"></p>
<pre>  $notes      = $r-&gt;notes();
  $prev_notes = $r-&gt;notes($new_notes);
</pre>
<dl class="Bl-tag">
  <dt id="obj:~25"><a class="permalink" href="#obj:~25">obj: $r (
    &quot;Apache2::RequestRec object&quot; )</a></dt>
  <dd></dd>
  <dt id="opt~16"><a class="permalink" href="#opt~16">opt arg1: $new_notes (
    &quot;APR::Table object&quot; )</a></dt>
  <dd></dd>
  <dt id="ret:~25"><a class="permalink" href="#ret:~25">ret: $notes (
    &quot;APR::Table object&quot; )</a></dt>
  <dd>the current notes table.
    <p class="Pp">if the <span class="Li">$new_notes</span> argument was passed,
        returns the previous value.</p>
  </dd>
  <dt id="since:~25"><a class="permalink" href="#since:~25">since:
    2.0.00</a></dt>
  <dd></dd>
</dl>
<p class="Pp">If you want to pass Perl structures, you can use
    <span class="Li">&quot;$r-&gt;pnotes&quot;</span>.</p>
<p class="Pp">Also see <span class="Li">&quot;$c-&gt;notes&quot;</span></p>
</section>
<section class="Ss">
<h2 class="Ss" id="_output_filters_"><a class="permalink" href="#_output_filters_">&quot;output_filters&quot;</a></h2>
<p class="Pp">Get the first filter in a linked list of request level output
    filters:</p>
<p class="Pp"></p>
<pre>  $output_filters      = $r-&gt;output_filters();
  $prev_output_filters = $r-&gt;output_filters($new_output_filters);
</pre>
<dl class="Bl-tag">
  <dt id="obj:~26"><a class="permalink" href="#obj:~26">obj: $r (
    &quot;Apache2::RequestRec object&quot; )</a></dt>
  <dd></dd>
  <dt id="opt~17"><a class="permalink" href="#opt~17">opt arg1:
    $new_output_filters</a></dt>
  <dd>Set a new value</dd>
  <dt id="ret:~26"><a class="permalink" href="#ret:~26">ret: $output_filters (
    &quot;Apache2::Filter object&quot; )</a></dt>
  <dd>The first filter in the request level output filters chain.
    <p class="Pp">If <span class="Li">$new_output_filters</span> was passed,
        returns the previous value.</p>
  </dd>
  <dt id="since:~26"><a class="permalink" href="#since:~26">since:
    2.0.00</a></dt>
  <dd></dd>
</dl>
<p class="Pp">For example instead of using
    <span class="Li">&quot;$r-&gt;print()&quot;</span> to send the response
    body, one could send the data directly to the first output filter. The
    following function <span class="Li">&quot;send_response_body()&quot;</span>
    does just that:</p>
<p class="Pp"></p>
<pre>  use APR::Brigade ();
  use APR::Bucket ();
  use Apache2::Filter ();
  
  sub send_response_body {
      my ($r, $data) = @_;
  
      my $bb = APR::Brigade-&gt;new($r-&gt;pool,
                                 $r-&gt;connection-&gt;bucket_alloc);
  
      my $b = APR::Bucket-&gt;new($bb-&gt;bucket_alloc, $data);
      $bb-&gt;insert_tail($b);
      $r-&gt;output_filters-&gt;fflush($bb);
      $bb-&gt;destroy;
  }
</pre>
<p class="Pp">In fact that's what
    <span class="Li">&quot;$r-&gt;read()&quot;</span> does behind the scenes.
    But it also knows to parse HTTP headers passed together with the data and it
    also implements buffering, which the above function does not.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_path_info_"><a class="permalink" href="#_path_info_">&quot;path_info&quot;</a></h2>
<p class="Pp">Get/set the <span class="Li">&quot;PATH_INFO&quot;</span>, what is
    left in the path after the <i>URI</i> <i>--&gt; filename</i>
  translation:</p>
<p class="Pp"></p>
<pre>  $path_info      = $r-&gt;path_info();
  $prev_path_info = $r-&gt;path_info($path_info);
</pre>
<dl class="Bl-tag">
  <dt id="obj:~27"><a class="permalink" href="#obj:~27">obj: $r (
    &quot;Apache2::RequestRec object&quot; )</a></dt>
  <dd></dd>
  <dt id="opt~18"><a class="permalink" href="#opt~18">opt arg1: $path_info (
    string )</a></dt>
  <dd>Set a new value</dd>
  <dt id="ret:~27"><a class="permalink" href="#ret:~27">ret: $path_info ( string
    )</a></dt>
  <dd>Return the current value.
    <p class="Pp">If the optional argument <span class="Li">$path_info</span> is
        passed, the previous value is returned.</p>
  </dd>
  <dt id="since:~27"><a class="permalink" href="#since:~27">since:
    2.0.00</a></dt>
  <dd></dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="_per_dir_config_"><a class="permalink" href="#_per_dir_config_">&quot;per_dir_config&quot;</a></h2>
<p class="Pp">Get the dir config vector:</p>
<p class="Pp"></p>
<pre>  $per_dir_config = $r-&gt;per_dir_config();
</pre>
<dl class="Bl-tag">
  <dt id="obj:~28"><a class="permalink" href="#obj:~28">obj: $r (
    &quot;Apache2::RequestRec object&quot; )</a></dt>
  <dd></dd>
  <dt id="ret:~28"><a class="permalink" href="#ret:~28">ret: $per_dir_config (
    &quot;Apache2::ConfVector object&quot; )</a></dt>
  <dd></dd>
  <dt id="since:~28"><a class="permalink" href="#since:~28">since:
    2.0.00</a></dt>
  <dd></dd>
</dl>
<p class="Pp">For an indepth discussion, refer to the Apache Server
    Configuration Customization in Perl chapter.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_pool_"><a class="permalink" href="#_pool_">&quot;pool&quot;</a></h2>
<p class="Pp">The pool associated with the request</p>
<p class="Pp"></p>
<pre>  $p = $r-&gt;pool();
</pre>
<dl class="Bl-tag">
  <dt id="obj:~29"><a class="permalink" href="#obj:~29">obj: $r (
    &quot;Apache2::RequestRec object&quot; )</a></dt>
  <dd></dd>
  <dt id="ret:~29"><a class="permalink" href="#ret:~29">ret: $p (
    &quot;APR::Pool object&quot; )</a></dt>
  <dd></dd>
  <dt id="since:~29"><a class="permalink" href="#since:~29">since:
    2.0.00</a></dt>
  <dd></dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="_prev_"><a class="permalink" href="#_prev_">&quot;prev&quot;</a></h2>
<p class="Pp">Pointer to the previous request if this is an internal
  redirect</p>
<p class="Pp"></p>
<pre>  $prev_r = $r-&gt;prev();
</pre>
<dl class="Bl-tag">
  <dt id="obj:~30"><a class="permalink" href="#obj:~30">obj: $r (
    &quot;Apache2::RequestRec object&quot; )</a></dt>
  <dd></dd>
  <dt id="ret:~30"><a class="permalink" href="#ret:~30">ret: $prev_r (
    &quot;Apache2::RequestRec object&quot; )</a></dt>
  <dd>a blessed reference to the previous (internal) request structure or
      <span class="Li">&quot;undef&quot;</span> if there is no previous
    request.</dd>
  <dt id="since:~30"><a class="permalink" href="#since:~30">since:
    2.0.00</a></dt>
  <dd></dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="_proto_input_filters_"><a class="permalink" href="#_proto_input_filters_">&quot;proto_input_filters&quot;</a></h2>
<p class="Pp">Get the first filter in a linked list of protocol level input
    filters:</p>
<p class="Pp"></p>
<pre>  $proto_input_filters      = $r-&gt;proto_input_filters();
  $prev_proto_input_filters = $r-&gt;proto_input_filters($new_proto_input_filters);
</pre>
<dl class="Bl-tag">
  <dt id="obj:~31"><a class="permalink" href="#obj:~31">obj: $r (
    &quot;Apache2::RequestRec object&quot; )</a></dt>
  <dd></dd>
  <dt id="opt~19"><a class="permalink" href="#opt~19">opt arg1:
    $new_proto_input_filters</a></dt>
  <dd>Set a new value</dd>
  <dt id="ret:~31"><a class="permalink" href="#ret:~31">ret:
    $proto_input_filters ( &quot;Apache2::Filter object&quot; )</a></dt>
  <dd>The first filter in the protocol level input filters chain.
    <p class="Pp">If <span class="Li">$new_proto_input_filters</span> was
        passed, returns the previous value.</p>
  </dd>
  <dt id="since:~31"><a class="permalink" href="#since:~31">since:
    2.0.00</a></dt>
  <dd></dd>
</dl>
<p class="Pp"><span class="Li">&quot;$r-&gt;proto_input_filters&quot;</span>
    points to the same filter as
    <span class="Li">&quot;$r-&gt;connection-&gt;input_filters&quot;</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_proto_num_"><a class="permalink" href="#_proto_num_">&quot;proto_num&quot;</a></h2>
<p class="Pp">Get current request's HTTP protocol version number</p>
<p class="Pp"></p>
<pre>  $proto_num = $r-&gt;proto_num();
</pre>
<dl class="Bl-tag">
  <dt id="obj:~32"><a class="permalink" href="#obj:~32">obj: $r (
    &quot;Apache2::RequestRec object&quot; )</a></dt>
  <dd></dd>
  <dt id="ret:~32"><a class="permalink" href="#ret:~32">ret: $proto_num
    (integer)</a></dt>
  <dd>current request's HTTP protocol version number, e.g.: HTTP/1.0 == 1000,
      HTTP/1.1 = 1001</dd>
  <dt id="since:~32"><a class="permalink" href="#since:~32">since:
    2.0.00</a></dt>
  <dd></dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="_proto_output_filters_"><a class="permalink" href="#_proto_output_filters_">&quot;proto_output_filters&quot;</a></h2>
<p class="Pp">Get the first filter in a linked list of protocol level output
    filters:</p>
<p class="Pp"></p>
<pre>  $proto_output_filters      = $r-&gt;proto_output_filters();
  $prev_proto_output_filters = $r-&gt;proto_output_filters($new_proto_output_filters);
</pre>
<dl class="Bl-tag">
  <dt id="obj:~33"><a class="permalink" href="#obj:~33">obj: $r (
    &quot;Apache2::RequestRec object&quot; )</a></dt>
  <dd></dd>
  <dt id="opt~20"><a class="permalink" href="#opt~20">opt arg1:
    $new_proto_output_filters</a></dt>
  <dd>Set a new value</dd>
  <dt id="ret:~33"><a class="permalink" href="#ret:~33">ret:
    $proto_output_filters ( &quot;Apache2::Filter object&quot; )</a></dt>
  <dd>The first filter in the protocol level output filters chain.
    <p class="Pp">If <span class="Li">$new_proto_output_filters</span> was
        passed, returns the previous value.</p>
  </dd>
  <dt id="since:~33"><a class="permalink" href="#since:~33">since:
    2.0.00</a></dt>
  <dd></dd>
</dl>
<p class="Pp"><span class="Li">&quot;$r-&gt;proto_output_filters&quot;</span>
    points to the same filter as
    <span class="Li">&quot;$r-&gt;connection-&gt;output_filters&quot;</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_protocol_"><a class="permalink" href="#_protocol_">&quot;protocol&quot;</a></h2>
<p class="Pp">Get a string identifying the protocol that the client speaks.</p>
<p class="Pp"></p>
<pre>  $protocol = $r-&gt;protocol();
</pre>
<dl class="Bl-tag">
  <dt id="obj:~34"><a class="permalink" href="#obj:~34">obj: $r (
    &quot;Apache2::RequestRec object&quot; )</a></dt>
  <dd></dd>
  <dt id="ret:~34"><a class="permalink" href="#ret:~34">ret: $protocl ( string
    )</a></dt>
  <dd>Typical values are <span class="Li">&quot;HTTP/1.0&quot;</span> or
      <span class="Li">&quot;HTTP/1.1&quot;</span>.
    <p class="Pp">If the client didn't specify the protocol version, the default
        is <span class="Li">&quot;HTTP/0.9&quot;</span></p>
  </dd>
  <dt id="since:~34"><a class="permalink" href="#since:~34">since:
    2.0.00</a></dt>
  <dd></dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="_proxyreq_"><a class="permalink" href="#_proxyreq_">&quot;proxyreq&quot;</a></h2>
<p class="Pp">Get/set the <i>proxyrec</i> request record member and optionally
    adjust other related fields.</p>
<p class="Pp"></p>
<pre>  $status = $r-&gt;proxyreq($val);
</pre>
<dl class="Bl-tag">
  <dt id="obj:~35"><a class="permalink" href="#obj:~35">obj: $r (
    &quot;Apache2::RequestRec object&quot; )</a></dt>
  <dd></dd>
  <dt id="opt~21"><a class="permalink" href="#opt~21">opt arg1: $val ( integer
    )</a></dt>
  <dd>PROXYREQ_NONE, PROXYREQ_PROXY, PROXYREQ_REVERSE, PROXYREQ_RESPONSE</dd>
  <dt id="ret:~35"><a class="permalink" href="#ret:~35">ret: $status ( integer
    )</a></dt>
  <dd>If <span class="Li">$val</span> is defined the <i>proxyrec</i> member will
      be set to that value and previous value will be returned.
    <p class="Pp">If <span class="Li">$val</span> is not passed, and
        <span class="Li">&quot;$r-&gt;proxyreq&quot;</span> is not true, and the
        proxy request is matching the current vhost (scheme, hostname and port),
        the <i>proxyrec</i> member will be set to PROXYREQ_PROXY and that value
        will be returned. In addition
        <span class="Li">&quot;$r-&gt;uri&quot;</span> is set to
        <span class="Li">&quot;$r-&gt;unparsed_uri&quot;</span> and
        <span class="Li">&quot;$r-&gt;filename&quot;</span> is set to
        <span class="Li">&quot;&quot;modperl-proxy:&quot;.$r-&gt;uri&quot;</span>.
        If those conditions aren't true 0 is returned.</p>
  </dd>
  <dt id="since:~35"><a class="permalink" href="#since:~35">since:
    2.0.00</a></dt>
  <dd></dd>
</dl>
<p class="Pp">For example to turn a normal request into a proxy request to be
    handled on the same server in the
    <span class="Li">&quot;PerlTransHandler&quot;</span> phase run:</p>
<p class="Pp"></p>
<pre>  my $real_url = $r-&gt;unparsed_uri;
  $r-&gt;proxyreq(Apache2::Const::PROXYREQ_PROXY);
  $r-&gt;uri($real_url);
  $r-&gt;filename(&quot;proxy:$real_url&quot;);
  $r-&gt;handler('proxy-server');
</pre>
<p class="Pp">Also remember that if you want to turn a proxy request into a
    non-proxy request, it's not enough to call:</p>
<p class="Pp"></p>
<pre>  $r-&gt;proxyreq(Apache2::Const::PROXYREQ_NONE);
</pre>
<p class="Pp">You need to adjust <span class="Li">&quot;$r-&gt;uri&quot;</span>
    and <span class="Li">&quot;$r-&gt;filename&quot;</span> as well if you run
    that code in <span class="Li">&quot;PerlPostReadRequestHandler&quot;</span>
    phase, since if you don't -- <span class="Li">&quot;mod_proxy&quot;</span>'s
    own post_read_request handler will override your settings (as it will run
    after the mod_perl handler).</p>
<p class="Pp">And you may also want to add</p>
<p class="Pp"></p>
<pre>  $r-&gt;set_handlers(PerlResponseHandler =&gt; []);
</pre>
<p class="Pp">so that any response handlers which match apache directives will
    not run in addition to the mod_proxy content handler.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_request_time_"><a class="permalink" href="#_request_time_">&quot;request_time&quot;</a></h2>
<p class="Pp">Time when the request started</p>
<p class="Pp"></p>
<pre>  $request_time = $r-&gt;request_time();
</pre>
<dl class="Bl-tag">
  <dt id="obj:~36"><a class="permalink" href="#obj:~36">obj: $r (
    &quot;Apache2::RequestRec object&quot; )</a></dt>
  <dd></dd>
  <dt id="ret:~36"><a class="permalink" href="#ret:~36">ret: $request_time
    (epoch seconds).</a></dt>
  <dd></dd>
  <dt id="since:~36"><a class="permalink" href="#since:~36">since:
    2.0.00</a></dt>
  <dd></dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="_server_"><a class="permalink" href="#_server_">&quot;server&quot;</a></h2>
<p class="Pp">Get the <span class="Li">&quot;Apache2::Server&quot;</span> object
    for the server the request <span class="Li">$r</span> is running under.</p>
<p class="Pp"></p>
<pre>  $s = $r-&gt;server();
</pre>
<dl class="Bl-tag">
  <dt id="obj:~37"><a class="permalink" href="#obj:~37">obj: $r (
    &quot;Apache2::RequestRec object&quot; )</a></dt>
  <dd></dd>
  <dt id="ret:~37"><a class="permalink" href="#ret:~37">ret: $s (
    &quot;Apache2::ServerRec object&quot; )</a></dt>
  <dd></dd>
  <dt id="since:~37"><a class="permalink" href="#since:~37">since:
    2.0.00</a></dt>
  <dd></dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="_status_"><a class="permalink" href="#_status_">&quot;status&quot;</a></h2>
<p class="Pp">Get/set the reply status for the client request.</p>
<p class="Pp"></p>
<pre>  $status      = $r-&gt;status();
  $prev_status = $r-&gt;status($new_status);
</pre>
<dl class="Bl-tag">
  <dt id="obj:~38"><a class="permalink" href="#obj:~38">obj: $r (
    &quot;Apache2::RequestRec object&quot; )</a></dt>
  <dd></dd>
  <dt id="opt~22"><a class="permalink" href="#opt~22">opt arg1: $new_status (
    integer )</a></dt>
  <dd>If <span class="Li">$new_status</span> is passed the new status is
      assigned.
    <p class="Pp">Normally you would use some
        <span class="Li">&quot;Apache2::Const</span>
        <span class="Li">constant&quot;</span>, e.g.
        <span class="Li">&quot;Apache2::Const::REDIRECT&quot;</span>.</p>
  </dd>
  <dt id="ret:~38"><a class="permalink" href="#ret:~38">ret: $newval ( integer
    )</a></dt>
  <dd>The current value.
    <p class="Pp">If <span class="Li">$new_status</span> is passed the old value
        is returned.</p>
  </dd>
  <dt id="since:~38"><a class="permalink" href="#since:~38">since:
    2.0.00</a></dt>
  <dd></dd>
</dl>
<p class="Pp">Usually you will set this value indirectly by returning the status
    code as the handler's function result. However, there are rare instances
    when you want to trick Apache into thinking that the module returned an
    <span class="Li">&quot;Apache2::Const::OK&quot;</span> status code, but
    actually send the browser a non-OK status. This may come handy when
    implementing an HTTP proxy handler. The proxy handler needs to send to the
    client, whatever status code the proxied server has returned, while
    returning <span class="Li">&quot;Apache2::Const::OK&quot;</span> to Apache.
    e.g.:</p>
<p class="Pp"></p>
<pre>  $r-&gt;status($some_code);
  return Apache2::Const::OK
</pre>
<p class="Pp">See also <span class="Li">&quot;$r-&gt;status_line&quot;</span>,
    which. if set, overrides
  <span class="Li">&quot;$r-&gt;status&quot;</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_status_line_"><a class="permalink" href="#_status_line_">&quot;status_line&quot;</a></h2>
<p class="Pp">Get/set the response status line. The status line is a string like
    &quot;200 Document follows&quot; and it will take precedence over the value
    specified using the <span class="Li">&quot;$r-&gt;status()&quot;</span>
    described above.</p>
<p class="Pp"></p>
<pre>  $status_line      = $r-&gt;status_line();
  $prev_status_line = $r-&gt;status_line($new_status_line);
</pre>
<dl class="Bl-tag">
  <dt id="obj:~39"><a class="permalink" href="#obj:~39">obj: $r (
    &quot;Apache2::RequestRec object&quot; )</a></dt>
  <dd></dd>
  <dt id="opt~23"><a class="permalink" href="#opt~23">opt arg1: $new_status_line
    ( string )</a></dt>
  <dd></dd>
  <dt id="ret:~39"><a class="permalink" href="#ret:~39">ret: $status_line (
    string )</a></dt>
  <dd></dd>
  <dt id="since:~39"><a class="permalink" href="#since:~39">since:
    2.0.00</a></dt>
  <dd></dd>
</dl>
<p class="Pp">When discussing <span class="Li">&quot;$r-&gt;status&quot;</span>
    we have mentioned that sometimes a handler runs to a successful completion,
    but may need to return a different code, which is the case with the proxy
    server. Assuming that the proxy handler forwards to the client whatever
    response the proxied server has sent, it'll usually use
    <span class="Li">&quot;status_line()&quot;</span>, like so:</p>
<p class="Pp"></p>
<pre>  $r-&gt;status_line($response-&gt;code() . ' ' . $response-&gt;message());
  return Apache2::Const::OK;
</pre>
<p class="Pp">In this example <span class="Li">$response</span> could be for
    example an <span class="Li">&quot;HTTP::Response&quot;</span> object, if
    <span class="Li">&quot;LWP::UserAgent&quot;</span> was used to implement the
    proxy.</p>
<p class="Pp">This method is also handy when you extend the HTTP protocol and
    add new response codes. For example you could invent a new error code and
    tell Apache to use that in the response like so:</p>
<p class="Pp"></p>
<pre>  $r-&gt;status_line(&quot;499 We have been FooBared&quot;);
  return Apache2::Const::OK;
</pre>
<p class="Pp">Here <span class="Li">499</span> is the new response code, and
    <i>We have been FooBared</i> is the custom response message.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_subprocess_env_"><a class="permalink" href="#_subprocess_env_">&quot;subprocess_env&quot;</a></h2>
<p class="Pp">Get/set the Apache
    <span class="Li">&quot;subprocess_env&quot;</span> table, or optionally set
    the value of a named entry.</p>
<p class="Pp"></p>
<pre>               $r-&gt;subprocess_env;
  $env_table = $r-&gt;subprocess_env;
  
         $r-&gt;subprocess_env($key =&gt; $val);
  $val = $r-&gt;subprocess_env($key);
</pre>
<dl class="Bl-tag">
  <dt id="obj:~40"><a class="permalink" href="#obj:~40">obj: $r (
    &quot;Apache2::RequestRec object&quot; )</a></dt>
  <dd></dd>
  <dt id="opt~24"><a class="permalink" href="#opt~24">opt arg1: $key ( string
    )</a></dt>
  <dd></dd>
  <dt id="opt~25"><a class="permalink" href="#opt~25">opt arg2: $val ( string
    )</a></dt>
  <dd></dd>
  <dt id="ret:~40"><a class="permalink" href="#ret:~40">ret:
    &quot;...&quot;</a></dt>
  <dd></dd>
  <dt id="since:~40"><a class="permalink" href="#since:~40">since:
    2.0.00</a></dt>
  <dd></dd>
</dl>
<p class="Pp">When called in VOID context with no arguments, it populate
    <span class="Li">%ENV</span> with special variables (e.g.
    <span class="Li">$ENV{QUERY_STRING}</span>) like mod_cgi does.</p>
<p class="Pp">When called in a non-VOID context with no arguments, it returns an
    <span class="Li">&quot;APR::Table object&quot;</span>.</p>
<p class="Pp">When the <span class="Li">$key</span> argument (string) is passed,
    it returns the corresponding value (if such exists, or
    <span class="Li">&quot;undef&quot;</span>. The following two lines are
    equivalent:</p>
<p class="Pp"></p>
<pre>  $val = $r-&gt;subprocess_env($key);
  $val = $r-&gt;subprocess_env-&gt;get($key);
</pre>
<p class="Pp">When the <span class="Li">$key</span> and the
    <span class="Li">$val</span> arguments (strings) are passed, the value is
    set. The following two lines are equivalent:</p>
<p class="Pp"></p>
<pre>  $r-&gt;subprocess_env($key =&gt; $val);
  $r-&gt;subprocess_env-&gt;set($key =&gt; $val);
</pre>
<p class="Pp">The <span class="Li">&quot;subprocess_env&quot;</span>
    <span class="Li">&quot;table&quot;</span> is used by
    <span class="Li">&quot;Apache2::SubProcess&quot;</span>, to pass environment
    variables to externally spawned processes. It's also used by various Apache
    modules, and you should use this table to pass the environment variables.
    For example if in
    <span class="Li">&quot;PerlHeaderParserHandler&quot;</span> you do:</p>
<p class="Pp"></p>
<pre>   $r-&gt;subprocess_env(MyLanguage =&gt; &quot;de&quot;);
</pre>
<p class="Pp">you can then deploy
    <span class="Li">&quot;mod_include&quot;</span> and write in <i>.shtml</i>
    document:</p>
<p class="Pp"></p>
<pre>   &lt;!--#if expr=&quot;$MyLanguage = en&quot; --&gt;
   English
   &lt;!--#elif expr=&quot;$MyLanguage = de&quot; --&gt;
   Deutsch
   &lt;!--#else --&gt;
   Sorry
   &lt;!--#endif --&gt;
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="_the_request_"><a class="permalink" href="#_the_request_">&quot;the_request&quot;</a></h2>
<p class="Pp">First HTTP request header</p>
<p class="Pp"></p>
<pre>  $request = $r-&gt;the_request();
  $old_request = $r-&gt;uri($new_request);
</pre>
<dl class="Bl-tag">
  <dt id="obj:~41"><a class="permalink" href="#obj:~41">obj: $r (
    &quot;Apache2::RequestRec object&quot; )</a></dt>
  <dd></dd>
  <dt id="opt~26"><a class="permalink" href="#opt~26">opt arg1: $new_request (
    string )</a></dt>
  <dd></dd>
  <dt id="ret:~41"><a class="permalink" href="#ret:~41">ret: $request ( string
    )</a></dt>
  <dd>For example:
    <p class="Pp"></p>
    <pre>  GET /foo/bar/my_path_info?args=3 HTTP/1.0
    </pre>
  </dd>
  <dt id="since:~41"><a class="permalink" href="#since:~41">since:
    2.0.00</a></dt>
  <dd></dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="_unparsed_uri_"><a class="permalink" href="#_unparsed_uri_">&quot;unparsed_uri&quot;</a></h2>
<p class="Pp">The URI without any parsing performed</p>
<p class="Pp"></p>
<pre>  $unparsed_uri = $r-&gt;unparsed_uri();
</pre>
<dl class="Bl-tag">
  <dt id="obj:~42"><a class="permalink" href="#obj:~42">obj: $r (
    &quot;Apache2::RequestRec object&quot; )</a></dt>
  <dd></dd>
  <dt id="ret:~42"><a class="permalink" href="#ret:~42">ret: $unparsed_uri (
    string )</a></dt>
  <dd></dd>
  <dt id="since:~42"><a class="permalink" href="#since:~42">since:
    2.0.00</a></dt>
  <dd></dd>
</dl>
<p class="Pp">If for example the request was:</p>
<p class="Pp"></p>
<pre>  GET /foo/bar/my_path_info?args=3 HTTP/1.0
</pre>
<p class="Pp"><span class="Li">&quot;$r-&gt;uri&quot;</span> returns:</p>
<p class="Pp"></p>
<pre>  /foo/bar/my_path_info
</pre>
<p class="Pp">whereas <span class="Li">&quot;$r-&gt;unparsed_uri&quot;</span>
    returns:</p>
<p class="Pp"></p>
<pre>  /foo/bar/my_path_info?args=3
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="_uri_"><a class="permalink" href="#_uri_">&quot;uri&quot;</a></h2>
<p class="Pp">The path portion of the URI</p>
<p class="Pp"></p>
<pre>  $uri         = $r-&gt;uri();
  my $prec_uri = $r-&gt;uri($new_uri);
</pre>
<dl class="Bl-tag">
  <dt id="obj:~43"><a class="permalink" href="#obj:~43">obj: $r (
    &quot;Apache2::RequestRec object&quot; )</a></dt>
  <dd></dd>
  <dt id="opt~27"><a class="permalink" href="#opt~27">opt arg1: $new_uri (
    string )</a></dt>
  <dd></dd>
  <dt id="ret:~43"><a class="permalink" href="#ret:~43">ret: $uri ( string
    )</a></dt>
  <dd></dd>
  <dt id="since:~43"><a class="permalink" href="#since:~43">since:
    2.0.00</a></dt>
  <dd></dd>
</dl>
<p class="Pp">See the example in the
    <span class="Li">&quot;$r-&gt;unparsed_uri&quot;</span> section.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_user_"><a class="permalink" href="#_user_">&quot;user&quot;</a></h2>
<p class="Pp">Get the user name, if an authentication process was successful. Or
    set it.</p>
<p class="Pp"></p>
<pre>  $user      = $r-&gt;user();
  $prev_user = $r-&gt;user($new_user);
</pre>
<dl class="Bl-tag">
  <dt id="obj:~44"><a class="permalink" href="#obj:~44">obj: $r (
    &quot;Apache2::RequestRec object&quot; )</a></dt>
  <dd></dd>
  <dt id="opt~28"><a class="permalink" href="#opt~28">opt arg1: $new_user (
    string )</a></dt>
  <dd>Pass <span class="Li">$new_user</span> to set a new value</dd>
  <dt id="ret:~44"><a class="permalink" href="#ret:~44">ret: $user ( string
    )</a></dt>
  <dd>The current username if an authentication process was successful.
    <p class="Pp">If <span class="Li">$new_user</span> was passed, the previous
        value is returned.</p>
  </dd>
  <dt id="since:~44"><a class="permalink" href="#since:~44">since:
    2.0.00</a></dt>
  <dd></dd>
</dl>
<p class="Pp">For example, let's print the username passed by the client:</p>
<p class="Pp"></p>
<pre>  my ($res, $sent_pw) = $r-&gt;get_basic_auth_pw;
  return $res if $res != Apache2::Const::OK;
  print &quot;User: &quot;, $r-&gt;user;
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="Unsupported_API"><a class="permalink" href="#Unsupported_API">Unsupported
  API</a></h1>
<p class="Pp"><span class="Li">&quot;Apache2::RequestRec&quot;</span> also
    provides auto-generated Perl interface for a few other methods which aren't
    tested at the moment and therefore their API is a subject to change. These
    methods will be finalized later as a need arises. If you want to rely on any
    of the following methods please contact the the mod_perl development mailing
    list so we can help each other take the steps necessary to shift the method
    to an officially supported API.</p>
<section class="Ss">
<h2 class="Ss" id="_allowed_methods_"><a class="permalink" href="#_allowed_methods_">&quot;allowed_methods&quot;</a></h2>
<p class="Pp">META: Autogenerated - needs to be reviewed/completed</p>
<p class="Pp">List of allowed methods</p>
<p class="Pp"></p>
<pre>  $list = $r-&gt;allowed_methods();
</pre>
<dl class="Bl-tag">
  <dt id="obj:~45"><a class="permalink" href="#obj:~45">obj: $r (
    &quot;Apache2::RequestRec object&quot; )</a></dt>
  <dd></dd>
  <dt id="ret:~45"><a class="permalink" href="#ret:~45">ret: $list (
    &quot;Apache2::MethodList object&quot; )</a></dt>
  <dd></dd>
  <dt id="since:~45"><a class="permalink" href="#since:~45">since:
    2.0.00</a></dt>
  <dd></dd>
</dl>
<p class="Pp">META: Apache2::MethodList is not available at the moment</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_allowed_xmethods_"><a class="permalink" href="#_allowed_xmethods_">&quot;allowed_xmethods&quot;</a></h2>
<p class="Pp">META: Autogenerated - needs to be reviewed/completed</p>
<p class="Pp">Array of extension methods</p>
<p class="Pp"></p>
<pre>  $array = $r-&gt;allowed_xmethods();
</pre>
<dl class="Bl-tag">
  <dt id="obj:~46"><a class="permalink" href="#obj:~46">obj: $r (
    &quot;Apache2::RequestRec object&quot; )</a></dt>
  <dd></dd>
  <dt id="ret:~46"><a class="permalink" href="#ret:~46">ret: $array (
    &quot;APR::ArrayHeader object&quot; )</a></dt>
  <dd></dd>
  <dt id="since:~46"><a class="permalink" href="#since:~46">since:
    2.0.00</a></dt>
  <dd></dd>
</dl>
<p class="Pp">META: APR::ArrayHeader is not available at the moment</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_request_config_"><a class="permalink" href="#_request_config_">&quot;request_config&quot;</a></h2>
<p class="Pp">Config vector containing pointers to request's per-server config
    structures</p>
<p class="Pp"></p>
<pre>  $ret = $r-&gt;request_config($newval);
</pre>
<dl class="Bl-tag">
  <dt id="obj:~47"><a class="permalink" href="#obj:~47">obj: $r (
    &quot;Apache2::RequestRec object&quot; )</a></dt>
  <dd></dd>
  <dt id="opt~29"><a class="permalink" href="#opt~29">opt arg1: $newval (
    &quot;Apache2::ConfVector object&quot; )</a></dt>
  <dd></dd>
  <dt id="since:~47"><a class="permalink" href="#since:~47">since:
    2.0.00</a></dt>
  <dd></dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="_used_path_info_"><a class="permalink" href="#_used_path_info_">&quot;used_path_info&quot;</a></h2>
<p class="Pp">META: Autogenerated - needs to be reviewed/completed</p>
<p class="Pp">Flag for the handler to accept or reject path_info on the current
    request. All modules should respect the AP_REQ_ACCEPT_PATH_INFO and
    AP_REQ_REJECT_PATH_INFO values, while AP_REQ_DEFAULT_PATH_INFO indicates
    they may follow existing conventions. This is set to the user's preference
    upon HOOK_VERY_FIRST of the fixups.</p>
<p class="Pp"></p>
<pre>  $ret = $r-&gt;used_path_info($newval);
</pre>
<dl class="Bl-tag">
  <dt id="obj:~48"><a class="permalink" href="#obj:~48">obj: $r (
    &quot;Apache2::RequestRec object&quot; )</a></dt>
  <dd></dd>
  <dt id="arg1:"><a class="permalink" href="#arg1:">arg1: $newval
    (integer)</a></dt>
  <dd></dd>
  <dt id="since:~48"><a class="permalink" href="#since:~48">since:
    2.0.00</a></dt>
  <dd></dd>
</dl>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="See_Also"><a class="permalink" href="#See_Also">See
  Also</a></h1>
<p class="Pp">mod_perl 2.0 documentation.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="Copyright"><a class="permalink" href="#Copyright">Copyright</a></h1>
<p class="Pp">mod_perl 2.0 and its core modules are copyrighted under The Apache
    Software License, Version 2.0.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="Authors"><a class="permalink" href="#Authors">Authors</a></h1>
<p class="Pp">The mod_perl development team and numerous contributors.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2015-06-18</td>
    <td class="foot-os">perl v5.30.2</td>
  </tr>
</table>
</body>
</html>
