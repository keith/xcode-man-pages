<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   generated by cd2nroff 0.1 from curl_easy_pause.md
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    .Nd, .Bf, .Op { display: inline; }
    .Pa, .Ad { font-style: italic; }
    .Ms { font-weight: bold; }
    .Bl-diag > dt { font-weight: bold; }
    code.Nm, .Fl, .Cm, .Ic, code.In, .Fd, .Fn, .Cd { font-weight: bold;
      font-family: inherit; }
  </style>
  <title>curl_easy_pause(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">curl_easy_pause(3)</td>
    <td class="head-vol">Library Functions Manual</td>
    <td class="head-rtitle">curl_easy_pause(3)</td>
  </tr>
</table>
<div class="manual-text">
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">curl_easy_pause - pause and unpause a connection</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>#include &lt;curl/curl.h&gt;
CURLcode curl_easy_pause(CURL *handle, int bitmask );</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">Using this function, you can explicitly mark a running connection
    to get paused, and you can unpause a connection that was previously paused.
    Unlike most other libcurl functions, <i>curl_easy_pause(3)</i> can be used
    from within callbacks.</p>
<p class="Pp">A connection can be paused by using this function or by letting
    the read or the write callbacks return the proper magic return code
    (<i>CURL_READFUNC_PAUSE</i> and <i>CURL_WRITEFUNC_PAUSE</i>). A write
    callback that returns pause signals to the library that it could not take
    care of any data at all, and that data is then delivered again to the
    callback when the transfer is unpaused.</p>
<p class="Pp">While it may feel tempting, take care and notice that you cannot
    call this function from another thread. To unpause, you may for example call
    it from the progress callback (<i>CURLOPT_PROGRESSFUNCTION(3)</i>).</p>
<p class="Pp">When this function is called to unpause receiving, the write
    callback might get called before this function returns to deliver cached
    content. When libcurl delivers such cached data to the write callback, it is
    delivered as fast as possible, which may overstep the boundary set in
    <i>CURLOPT_MAX_RECV_SPEED_LARGE(3)</i> etc.</p>
<p class="Pp">The <b>handle</b> argument identifies the transfer you want to
    pause or unpause.</p>
<p class="Pp">A paused transfer is excluded from low speed cancels via the
    <i>CURLOPT_LOW_SPEED_LIMIT(3)</i> option and unpausing a transfer resets the
    time period required for the low speed limit to be met.</p>
<p class="Pp">The <b>bitmask</b> argument is a set of bits that sets the new
    state of the connection. The following bits can be used:</p>
<dl class="Bl-tag">
  <dt id="CURLPAUSE_RECV"><a class="permalink" href="#CURLPAUSE_RECV">CURLPAUSE_RECV</a></dt>
  <dd>Pause receiving data. There is no data received on this connection until
      this function is called again without this bit set. Thus, the write
      callback (<i>CURLOPT_WRITEFUNCTION(3)</i>) is not called.</dd>
  <dt id="CURLPAUSE_SEND"><a class="permalink" href="#CURLPAUSE_SEND">CURLPAUSE_SEND</a></dt>
  <dd>Pause sending data. There is no data sent on this connection until this
      function is called again without this bit set. Thus, the read callback
      (<i>CURLOPT_READFUNCTION(3)</i>) is not called.</dd>
  <dt id="CURLPAUSE_ALL"><a class="permalink" href="#CURLPAUSE_ALL">CURLPAUSE_ALL</a></dt>
  <dd>Convenience define that pauses both directions.</dd>
  <dt id="CURLPAUSE_CONT"><a class="permalink" href="#CURLPAUSE_CONT">CURLPAUSE_CONT</a></dt>
  <dd>Convenience define that unpauses both directions.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="LIMITATIONS"><a class="permalink" href="#LIMITATIONS">LIMITATIONS</a></h1>
<p class="Pp">The pausing of transfers does not work with protocols that work
    without network connectivity, like FILE://. Trying to pause such a transfer,
    in any direction, might cause problems or error.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="MULTIPLEXED"><a class="permalink" href="#MULTIPLEXED">MULTIPLEXED</a></h1>
<p class="Pp">When a connection is used multiplexed, like for HTTP/2, and one of
    the transfers over the connection is paused and the others continue flowing,
    libcurl might end up buffering contents for the paused transfer. It has to
    do this because it needs to drain the socket for the other transfers and the
    already announced window size for the paused transfer allows the server to
    continue sending data up to that window size amount. By default, libcurl
    announces a 32 megabyte window size, which thus can make libcurl end up
    buffering 32 megabyte of data for a paused stream.</p>
<p class="Pp">When such a paused stream is unpaused again, any buffered data is
    delivered first.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="EXAMPLE"><a class="permalink" href="#EXAMPLE">EXAMPLE</a></h1>
<pre>int main(void)
{
<br/>
  CURL *curl = curl_easy_init();
<br/>
  if(curl) {
<br/>
    /* pause a transfer in both directions */
<br/>
    curl_easy_pause(curl, CURL_READFUNC_PAUSE | CURL_WRITEFUNC_PAUSE);
<br/>
  }
}</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="MEMORY_USE"><a class="permalink" href="#MEMORY_USE">MEMORY
  USE</a></h1>
<p class="Pp">When pausing a download transfer by returning the magic return
    code from a write callback, the read data is already in libcurl's internal
    buffers so it has to keep it in an allocated buffer until the receiving is
    again unpaused using this function.</p>
<p class="Pp">If the downloaded data is compressed and is asked to get
    uncompressed automatically on download, libcurl continues to uncompress the
    entire downloaded chunk and it caches the data uncompressed. This has the
    side- effect that if you download something that is compressed a lot, it can
    result in a large data amount needing to be allocated to save the data
    during the pause. Consider not using paused receiving if you allow libcurl
    to uncompress data automatically.</p>
<p class="Pp">If the download is done with HTTP/2 or HTTP/3, there is up to a
    stream window size worth of data that curl cannot stop but instead needs to
    cache while the transfer is paused. This means that if a window size of 64
    MB is used, libcurl might end up having to cache 64 MB of data.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AVAILABILITY"><a class="permalink" href="#AVAILABILITY">AVAILABILITY</a></h1>
<p class="Pp">Added in 7.18.0.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="RETURN_VALUE"><a class="permalink" href="#RETURN_VALUE">RETURN
  VALUE</a></h1>
<p class="Pp">CURLE_OK (zero) means that the option was set properly, and a
    non-zero return code means something wrong occurred after the new state was
    set. See the <i>libcurl-errors(3)</i> man page for the full list with
    descriptions.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp"><b>curl_easy_cleanup</b>(3), <b>curl_easy_reset</b>(3)</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">December 22, 2020</td>
    <td class="foot-os">libcurl 7.77.0</td>
  </tr>
</table>
</body>
</html>
