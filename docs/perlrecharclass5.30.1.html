<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    .Nd, .Bf, .Op { display: inline; }
    .Pa, .Ad { font-style: italic; }
    .Ms { font-weight: bold; }
    .Bl-diag > dt { font-weight: bold; }
    code.Nm, .Fl, .Cm, .Ic, code.In, .Fd, .Fn, .Cd { font-weight: bold;
      font-family: inherit; }
  </style>
  <title>PERLRECHARCLASS(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">PERLRECHARCLASS(1)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">PERLRECHARCLASS(1)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">perlrecharclass - Perl Regular Expression Character Classes</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">The top level documentation about Perl regular expressions is
    found in perlre.</p>
<p class="Pp">This manual page discusses the syntax and use of character classes
    in Perl regular expressions.</p>
<p class="Pp">A character class is a way of denoting a set of characters in such
    a way that one character of the set is matched. It's important to remember
    that: matching a character class consumes exactly one character in the
    source string. (The source string is the string the regular expression is
    matched against.)</p>
<p class="Pp">There are three types of character classes in Perl regular
    expressions: the dot, backslash sequences, and the form enclosed in square
    brackets. Keep in mind, though, that often the term &quot;character
    class&quot; is used to mean just the bracketed form. Certainly, most Perl
    documentation does that.</p>
<section class="Ss">
<h2 class="Ss" id="The_dot"><a class="permalink" href="#The_dot">The
  dot</a></h2>
<p class="Pp">The dot (or period), <span class="Li">&quot;.&quot;</span> is
    probably the most used, and certainly the most well-known character class.
    By default, a dot matches any character, except for the newline. That
    default can be changed to add matching the newline by using the <i>single
    line</i> modifier: for the entire regular expression with the
    <span class="Li">&quot;/s&quot;</span> modifier, or locally with
    <span class="Li">&quot;(?s)&quot;</span> (and even globally within the scope
    of <span class="Li">&quot;use re '/s'&quot;</span>). (The
    <span class="Li">&quot;\N&quot;</span> backslash sequence, described below,
    matches any character except newline without regard to the <i>single
    line</i> modifier.)</p>
<p class="Pp">Here are some examples:</p>
<p class="Pp"></p>
<pre> &quot;a&quot;  =~  /./       # Match
 &quot;.&quot;  =~  /./       # Match
 &quot;&quot;   =~  /./       # No match (dot has to match a character)
 &quot;\n&quot; =~  /./       # No match (dot does not match a newline)
 &quot;\n&quot; =~  /./s      # Match (global 'single line' modifier)
 &quot;\n&quot; =~  /(?s:.)/  # Match (local 'single line' modifier)
 &quot;ab&quot; =~  /^.$/     # No match (dot matches one character)
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Backslash_sequences"><a class="permalink" href="#Backslash_sequences">Backslash
  sequences</a></h2>
<p class="Pp">A backslash sequence is a sequence of characters, the first one of
    which is a backslash. Perl ascribes special meaning to many such sequences,
    and some of these are character classes. That is, they match a single
    character each, provided that the character belongs to the specific set of
    characters defined by the sequence.</p>
<p class="Pp">Here's a list of the backslash sequences that are character
    classes. They are discussed in more detail below. (For the backslash
    sequences that aren't character classes, see perlrebackslash.)</p>
<p class="Pp"></p>
<pre> \d             Match a decimal digit character.
 \D             Match a non-decimal-digit character.
 \w             Match a &quot;word&quot; character.
 \W             Match a non-&quot;word&quot; character.
 \s             Match a whitespace character.
 \S             Match a non-whitespace character.
 \h             Match a horizontal whitespace character.
 \H             Match a character that isn't horizontal whitespace.
 \v             Match a vertical whitespace character.
 \V             Match a character that isn't vertical whitespace.
 \N             Match a character that isn't a newline.
 \pP, \p{Prop}  Match a character that has the given Unicode property.
 \PP, \P{Prop}  Match a character that doesn't have the Unicode property
</pre>
<p class="Pp"><i>\N</i></p>
<p class="Pp"><span class="Li">&quot;\N&quot;</span>, available starting in
    v5.12, like the dot, matches any character that is not a newline. The
    difference is that <span class="Li">&quot;\N&quot;</span> is not influenced
    by the <i>single line</i> regular expression modifier (see &quot;The
    dot&quot; above). Note that the form
    <span class="Li">&quot;\N{...}&quot;</span> may mean something completely
    different. When the <span class="Li">&quot;{...}&quot;</span> is a
    quantifier, it means to match a non-newline character that many times. For
    example, <span class="Li">&quot;\N{3}&quot;</span> means to match 3
    non-newlines; <span class="Li">&quot;\N{5,}&quot;</span> means to match 5 or
    more non-newlines. But if <span class="Li">&quot;{...}&quot;</span> is not a
    legal quantifier, it is presumed to be a named character. See charnames for
    those. For example, none of <span class="Li">&quot;\N{COLON}&quot;</span>,
    <span class="Li">&quot;\N{4F}&quot;</span>, and
    <span class="Li">&quot;\N{F4}&quot;</span> contain legal quantifiers, so
    Perl will try to find characters whose names are respectively
    <span class="Li">&quot;COLON&quot;</span>,
    <span class="Li">&quot;4F&quot;</span>, and
    <span class="Li">&quot;F4&quot;</span>.</p>
<p class="Pp"><i>Digits</i></p>
<p class="Pp"><span class="Li">&quot;\d&quot;</span> matches a single character
    considered to be a decimal <i>digit</i>. If the
    <span class="Li">&quot;/a&quot;</span> regular expression modifier is in
    effect, it matches [0-9]. Otherwise, it matches anything that is matched by
    <span class="Li">&quot;\p{Digit}&quot;</span>, which includes [0-9]. (An
    unlikely possible exception is that under locale matching rules, the current
    locale might not have <span class="Li">&quot;[0-9]&quot;</span> matched by
    <span class="Li">&quot;\d&quot;</span>, and/or might match other characters
    whose code point is less than 256. The only such locale definitions that are
    legal would be to match <span class="Li">&quot;[0-9]&quot;</span> plus
    another set of 10 consecutive digit characters; anything else would be in
    violation of the C language standard, but Perl doesn't currently assume
    anything in regard to this.)</p>
<p class="Pp">What this means is that unless the
    <span class="Li">&quot;/a&quot;</span> modifier is in effect
    <span class="Li">&quot;\d&quot;</span> not only matches the digits '0' -
    '9', but also Arabic, Devanagari, and digits from other languages. This may
    cause some confusion, and some security issues.</p>
<p class="Pp">Some digits that <span class="Li">&quot;\d&quot;</span> matches
    look like some of the [0-9] ones, but have different values. For example,
    BENGALI DIGIT FOUR (U+09EA) looks very much like an ASCII DIGIT EIGHT
    (U+0038), and LEPCHA DIGIT SIX (U+1C46) looks very much like an ASCII DIGIT
    FIVE (U+0035). An application that is expecting only the ASCII digits might
    be misled, or if the match is <span class="Li">&quot;\d+&quot;</span>, the
    matched string might contain a mixture of digits from different writing
    systems that look like they signify a number different than they actually
    do. &quot;<b>num()</b>&quot; in Unicode::UCD can be used to safely calculate
    the value, returning <span class="Li">&quot;undef&quot;</span> if the input
    string contains such a mixture. Otherwise, for example, a displayed price
    might be deliberately different than it appears.</p>
<p class="Pp">What <span class="Li">&quot;\p{Digit}&quot;</span> means (and
    hence <span class="Li">&quot;\d&quot;</span> except under the
    <span class="Li">&quot;/a&quot;</span> modifier) is
    <span class="Li">&quot;\p{General_Category=Decimal_Number}&quot;</span>, or
    synonymously,
    <span class="Li">&quot;\p{General_Category=Digit}&quot;</span>. Starting
    with Unicode version 4.1, this is the same set of characters matched by
    <span class="Li">&quot;\p{Numeric_Type=Decimal}&quot;</span>. But Unicode
    also has a different property with a similar name,
    <span class="Li">&quot;\p{Numeric_Type=Digit}&quot;</span>, which matches a
    completely different set of characters. These characters are things such as
    <span class="Li">&quot;CIRCLED DIGIT ONE&quot;</span> or subscripts, or are
    from writing systems that lack all ten digits.</p>
<p class="Pp">The design intent is for <span class="Li">&quot;\d&quot;</span> to
    exactly match the set of characters that can safely be used with
    &quot;normal&quot; big-endian positional decimal syntax, where, for example
    123 means one 'hundred', plus two 'tens', plus three 'ones'. This positional
    notation does not necessarily apply to characters that match the other type
    of &quot;digit&quot;,
    <span class="Li">&quot;\p{Numeric_Type=Digit}&quot;</span>, and so
    <span class="Li">&quot;\d&quot;</span> doesn't match them.</p>
<p class="Pp">The Tamil digits (U+0BE6 - U+0BEF) can also legally be used in
    old-style Tamil numbers in which they would appear no more than one in a
    row, separated by characters that mean &quot;times 10&quot;, &quot;times
    100&quot;, etc. (See &lt;http://www.unicode.org/notes/tn21&gt;.)</p>
<p class="Pp">Any character not matched by
    <span class="Li">&quot;\d&quot;</span> is matched by
    <span class="Li">&quot;\D&quot;</span>.</p>
<p class="Pp"><i>Word characters</i></p>
<p class="Pp">A <span class="Li">&quot;\w&quot;</span> matches a single
    alphanumeric character (an alphabetic character, or a decimal digit); or a
    connecting punctuation character, such as an underscore (&quot;_&quot;); or
    a &quot;mark&quot; character (like some sort of accent) that attaches to one
    of those. It does not match a whole word. To match a whole word, use
    <span class="Li">&quot;\w+&quot;</span>. This isn't the same thing as
    matching an English word, but in the ASCII range it is the same as a string
    of Perl-identifier characters.</p>
<dl class="Bl-tag">
  <dt id="If"><a class="permalink" href="#If">If the &quot;/a&quot; modifier is
    in effect ...</a></dt>
  <dd><span class="Li">&quot;\w&quot;</span> matches the 63 characters
      [a-zA-Z0-9_].</dd>
  <dt id="otherwise"><a class="permalink" href="#otherwise">otherwise
    ...</a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="For"><a class="permalink" href="#For">For code points above 255
    ...</a></dt>
  <dd><span class="Li">&quot;\w&quot;</span> matches the same as
      <span class="Li">&quot;\p{Word}&quot;</span> matches in this range. That
      is, it matches Thai letters, Greek letters, etc. This includes connector
      punctuation (like the underscore) which connect two words together, or
      diacritics, such as a <span class="Li">&quot;COMBINING TILDE&quot;</span>
      and the modifier letters, which are generally used to add auxiliary
      markings to letters.</dd>
  <dt id="For~2"><a class="permalink" href="#For~2">For code points below 256
    ...</a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="if"><a class="permalink" href="#if">if locale rules are in effect
    ...</a></dt>
  <dd><span class="Li">&quot;\w&quot;</span> matches the platform's native
      underscore character plus whatever the locale considers to be
      alphanumeric.</dd>
  <dt id="if,"><a class="permalink" href="#if,">if, instead, Unicode rules are
    in effect ...</a></dt>
  <dd><span class="Li">&quot;\w&quot;</span> matches exactly what
      <span class="Li">&quot;\p{Word}&quot;</span> matches.</dd>
  <dt id="otherwise~2"><a class="permalink" href="#otherwise~2">otherwise
    ...</a></dt>
  <dd><span class="Li">&quot;\w&quot;</span> matches [a-zA-Z0-9_].</dd>
</dl>
</div>
<div class="Bd-indent"></div>
</div>
<div class="Bd-indent"></div>
<p class="Pp">Which rules apply are determined as described in &quot;Which
    character set modifier is in effect?&quot; in perlre.</p>
<p class="Pp">There are a number of security issues with the full Unicode list
    of word characters. See &lt;http://unicode.org/reports/tr36&gt;.</p>
<p class="Pp">Also, for a somewhat finer-grained set of characters that are in
    programming language identifiers beyond the ASCII range, you may wish to
    instead use the more customized &quot;Unicode Properties&quot;,
    <span class="Li">&quot;\p{ID_Start}&quot;</span>,
    <span class="Li">&quot;\p{ID_Continue}&quot;</span>,
    <span class="Li">&quot;\p{XID_Start}&quot;</span>, and
    <span class="Li">&quot;\p{XID_Continue}&quot;</span>. See
    &lt;http://unicode.org/reports/tr31&gt;.</p>
<p class="Pp">Any character not matched by
    <span class="Li">&quot;\w&quot;</span> is matched by
    <span class="Li">&quot;\W&quot;</span>.</p>
<p class="Pp"><i>Whitespace</i></p>
<p class="Pp"><span class="Li">&quot;\s&quot;</span> matches any single
    character considered whitespace.</p>
<dl class="Bl-tag">
  <dt id="If~2"><a class="permalink" href="#If~2">If the &quot;/a&quot; modifier
    is in effect ...</a></dt>
  <dd>In all Perl versions, <span class="Li">&quot;\s&quot;</span> matches the 5
      characters [\t\n\f\r ]; that is, the horizontal tab, the newline, the form
      feed, the carriage return, and the space. Starting in Perl v5.18, it also
      matches the vertical tab, <span class="Li">&quot;\cK&quot;</span>. See
      note <span class="Li">&quot;[1]&quot;</span> below for a discussion of
      this.</dd>
  <dt id="otherwise~3"><a class="permalink" href="#otherwise~3">otherwise
    ...</a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="For~3"><a class="permalink" href="#For~3">For code points above 255
    ...</a></dt>
  <dd><span class="Li">&quot;\s&quot;</span> matches exactly the code points
      above 255 shown with an &quot;s&quot; column in the table below.</dd>
  <dt id="For~4"><a class="permalink" href="#For~4">For code points below 256
    ...</a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="if~2"><a class="permalink" href="#if~2">if locale rules are in effect
    ...</a></dt>
  <dd><span class="Li">&quot;\s&quot;</span> matches whatever the locale
      considers to be whitespace.</dd>
  <dt id="if,~2"><a class="permalink" href="#if,~2">if, instead, Unicode rules
    are in effect ...</a></dt>
  <dd><span class="Li">&quot;\s&quot;</span> matches exactly the characters
      shown with an &quot;s&quot; column in the table below.</dd>
  <dt id="otherwise~4"><a class="permalink" href="#otherwise~4">otherwise
    ...</a></dt>
  <dd><span class="Li">&quot;\s&quot;</span> matches [\t\n\f\r ] and, starting
      in Perl v5.18, the vertical tab, <span class="Li">&quot;\cK&quot;</span>.
      (See note <span class="Li">&quot;[1]&quot;</span> below for a discussion
      of this.) Note that this list doesn't include the non-breaking space.</dd>
</dl>
</div>
<div class="Bd-indent"></div>
</div>
<div class="Bd-indent"></div>
<p class="Pp">Which rules apply are determined as described in &quot;Which
    character set modifier is in effect?&quot; in perlre.</p>
<p class="Pp">Any character not matched by
    <span class="Li">&quot;\s&quot;</span> is matched by
    <span class="Li">&quot;\S&quot;</span>.</p>
<p class="Pp"><span class="Li">&quot;\h&quot;</span> matches any character
    considered horizontal whitespace; this includes the platform's space and tab
    characters and several others listed in the table below.
    <span class="Li">&quot;\H&quot;</span> matches any character not considered
    horizontal whitespace. They use the platform's native character set, and do
    not consider any locale that may otherwise be in use.</p>
<p class="Pp"><span class="Li">&quot;\v&quot;</span> matches any character
    considered vertical whitespace; this includes the platform's carriage return
    and line feed characters (newline) plus several other characters, all listed
    in the table below. <span class="Li">&quot;\V&quot;</span> matches any
    character not considered vertical whitespace. They use the platform's native
    character set, and do not consider any locale that may otherwise be in
  use.</p>
<p class="Pp"><span class="Li">&quot;\R&quot;</span> matches anything that can
    be considered a newline under Unicode rules. It can match a multi-character
    sequence. It cannot be used inside a bracketed character class; use
    <span class="Li">&quot;\v&quot;</span> instead (vertical whitespace). It
    uses the platform's native character set, and does not consider any locale
    that may otherwise be in use. Details are discussed in perlrebackslash.</p>
<p class="Pp">Note that unlike <span class="Li">&quot;\s&quot;</span> (and
    <span class="Li">&quot;\d&quot;</span> and
    <span class="Li">&quot;\w&quot;</span>),
    <span class="Li">&quot;\h&quot;</span> and
    <span class="Li">&quot;\v&quot;</span> always match the same characters,
    without regard to other factors, such as the active locale or whether the
    source string is in UTF-8 format.</p>
<p class="Pp">One might think that <span class="Li">&quot;\s&quot;</span> is
    equivalent to <span class="Li">&quot;[\h\v]&quot;</span>. This is indeed
    true starting in Perl v5.18, but prior to that, the sole difference was that
    the vertical tab (<span class="Li">&quot;\cK&quot;</span>) was not matched
    by <span class="Li">&quot;\s&quot;</span>.</p>
<p class="Pp">The following table is a complete listing of characters matched by
    <span class="Li">&quot;\s&quot;</span>,
    <span class="Li">&quot;\h&quot;</span> and
    <span class="Li">&quot;\v&quot;</span> as of Unicode 6.3.</p>
<p class="Pp">The first column gives the Unicode code point of the character (in
    hex format), the second column gives the (Unicode) name. The third column
    indicates by which class(es) the character is matched (assuming no locale is
    in effect that changes the <span class="Li">&quot;\s&quot;</span>
  matching).</p>
<p class="Pp"></p>
<pre> 0x0009        CHARACTER TABULATION   h s
 0x000a              LINE FEED (LF)    vs
 0x000b             LINE TABULATION    vs  [1]
 0x000c              FORM FEED (FF)    vs
 0x000d        CARRIAGE RETURN (CR)    vs
 0x0020                       SPACE   h s
 0x0085             NEXT LINE (NEL)    vs  [2]
 0x00a0              NO-BREAK SPACE   h s  [2]
 0x1680            OGHAM SPACE MARK   h s
 0x2000                     EN QUAD   h s
 0x2001                     EM QUAD   h s
 0x2002                    EN SPACE   h s
 0x2003                    EM SPACE   h s
 0x2004          THREE-PER-EM SPACE   h s
 0x2005           FOUR-PER-EM SPACE   h s
 0x2006            SIX-PER-EM SPACE   h s
 0x2007                FIGURE SPACE   h s
 0x2008           PUNCTUATION SPACE   h s
 0x2009                  THIN SPACE   h s
 0x200a                  HAIR SPACE   h s
 0x2028              LINE SEPARATOR    vs
 0x2029         PARAGRAPH SEPARATOR    vs
 0x202f       NARROW NO-BREAK SPACE   h s
 0x205f   MEDIUM MATHEMATICAL SPACE   h s
 0x3000           IDEOGRAPHIC SPACE   h s
</pre>
<dl class="Bl-tag">
  <dt>[1]</dt>
  <dd>Prior to Perl v5.18, <span class="Li">&quot;\s&quot;</span> did not match
      the vertical tab. <span class="Li">&quot;[^\S\cK]&quot;</span> (obscurely)
      matches what <span class="Li">&quot;\s&quot;</span> traditionally
    did.</dd>
  <dt>[2]</dt>
  <dd>NEXT LINE and NO-BREAK SPACE may or may not match
      <span class="Li">&quot;\s&quot;</span> depending on the rules in effect.
      See the beginning of this section.</dd>
</dl>
<p class="Pp"><i>Unicode Properties</i></p>
<p class="Pp"><span class="Li">&quot;\pP&quot;</span> and
    <span class="Li">&quot;\p{Prop}&quot;</span> are character classes to match
    characters that fit given Unicode properties. One letter property names can
    be used in the <span class="Li">&quot;\pP&quot;</span> form, with the
    property name following the <span class="Li">&quot;\p&quot;</span>,
    otherwise, braces are required. When using braces, there is a single form,
    which is just the property name enclosed in the braces, and a compound form
    which looks like <span class="Li">&quot;\p{name=value}&quot;</span>, which
    means to match if the property &quot;name&quot; for the character has that
    particular &quot;value&quot;. For instance, a match for a number can be
    written as <span class="Li">&quot;/\pN/&quot;</span> or as
    <span class="Li">&quot;/\p{Number}/&quot;</span>, or as
    <span class="Li">&quot;/\p{Number=True}/&quot;</span>. Lowercase letters are
    matched by the property <i>Lowercase_Letter</i> which has the short form
    <i>Ll</i>. They need the braces, so are written as
    <span class="Li">&quot;/\p{Ll}/&quot;</span> or
    <span class="Li">&quot;/\p{Lowercase_Letter}/&quot;</span>, or
    <span class="Li">&quot;/\p{General_Category=Lowercase_Letter}/&quot;</span>
    (the underscores are optional). <span class="Li">&quot;/\pLl/&quot;</span>
    is valid, but means something different. It matches a two character string:
    a letter (Unicode property <span class="Li">&quot;\pL&quot;</span>),
    followed by a lowercase <span class="Li">&quot;l&quot;</span>.</p>
<p class="Pp">What a Unicode property matches is never subject to locale rules,
    and if locale rules are not otherwise in effect, the use of a Unicode
    property will force the regular expression into using Unicode rules, if it
    isn't already.</p>
<p class="Pp">Note that almost all properties are immune to case-insensitive
    matching. That is, adding a <span class="Li">&quot;/i&quot;</span> regular
    expression modifier does not change what they match. There are two sets that
    are affected. The first set is
    <span class="Li">&quot;Uppercase_Letter&quot;</span>,
    <span class="Li">&quot;Lowercase_Letter&quot;</span>, and
    <span class="Li">&quot;Titlecase_Letter&quot;</span>, all of which match
    <span class="Li">&quot;Cased_Letter&quot;</span> under
    <span class="Li">&quot;/i&quot;</span> matching. The second set is
    <span class="Li">&quot;Uppercase&quot;</span>,
    <span class="Li">&quot;Lowercase&quot;</span>, and
    <span class="Li">&quot;Titlecase&quot;</span>, all of which match
    <span class="Li">&quot;Cased&quot;</span> under
    <span class="Li">&quot;/i&quot;</span> matching. (The difference between
    these sets is that some things, such as Roman numerals, come in both upper
    and lower case, so they are <span class="Li">&quot;Cased&quot;</span>, but
    aren't considered to be letters, so they aren't
    <span class="Li">&quot;Cased_Letter&quot;</span>s. They're actually
    <span class="Li">&quot;Letter_Number&quot;</span>s.) This set also includes
    its subsets <span class="Li">&quot;PosixUpper&quot;</span> and
    <span class="Li">&quot;PosixLower&quot;</span>, both of which under
    <span class="Li">&quot;/i&quot;</span> match
    <span class="Li">&quot;PosixAlpha&quot;</span>.</p>
<p class="Pp">For more details on Unicode properties, see &quot;Unicode
    Character Properties&quot; in perlunicode; for a complete list of possible
    properties, see &quot;Properties accessible through \p{} and \P{}&quot; in
    perluniprops, which notes all forms that have
    <span class="Li">&quot;/i&quot;</span> differences. It is also possible to
    define your own properties. This is discussed in &quot;User-Defined
    Character Properties&quot; in perlunicode.</p>
<p class="Pp">Unicode properties are defined (surprise!) only on Unicode code
    points. Starting in v5.20, when matching against
    <span class="Li">&quot;\p&quot;</span> and
    <span class="Li">&quot;\P&quot;</span>, Perl treats non-Unicode code points
    (those above the legal Unicode maximum of 0x10FFFF) as if they were typical
    unassigned Unicode code points.</p>
<p class="Pp">Prior to v5.20, Perl raised a warning and made all matches fail on
    non-Unicode code points. This could be somewhat surprising:</p>
<p class="Pp"></p>
<pre> chr(0x110000) =~ \p{ASCII_Hex_Digit=True}     # Fails on Perls &lt; v5.20.
 chr(0x110000) =~ \p{ASCII_Hex_Digit=False}    # Also fails on Perls
                                               # &lt; v5.20
</pre>
<p class="Pp">Even though these two matches might be thought of as complements,
    until v5.20 they were so only on Unicode code points.</p>
<p class="Pp">Starting in perl v5.30, wildcards are allowed in Unicode property
    values. See &quot;Wildcards in Property Values&quot; in perlunicode.</p>
<p class="Pp">Examples</p>
<p class="Pp"></p>
<pre> &quot;a&quot;  =~  /\w/      # Match, &quot;a&quot; is a 'word' character.
 &quot;7&quot;  =~  /\w/      # Match, &quot;7&quot; is a 'word' character as well.
 &quot;a&quot;  =~  /\d/      # No match, &quot;a&quot; isn't a digit.
 &quot;7&quot;  =~  /\d/      # Match, &quot;7&quot; is a digit.
 &quot; &quot;  =~  /\s/      # Match, a space is whitespace.
 &quot;a&quot;  =~  /\D/      # Match, &quot;a&quot; is a non-digit.
 &quot;7&quot;  =~  /\D/      # No match, &quot;7&quot; is not a non-digit.
 &quot; &quot;  =~  /\S/      # No match, a space is not non-whitespace.
 &quot; &quot;  =~  /\h/      # Match, space is horizontal whitespace.
 &quot; &quot;  =~  /\v/      # No match, space is not vertical whitespace.
 &quot;\r&quot; =~  /\v/      # Match, a return is vertical whitespace.
 &quot;a&quot;  =~  /\pL/     # Match, &quot;a&quot; is a letter.
 &quot;a&quot;  =~  /\p{Lu}/  # No match, /\p{Lu}/ matches upper case letters.
 &quot;\x{0e0b}&quot; =~ /\p{Thai}/  # Match, \x{0e0b} is the character
                           # 'THAI CHARACTER SO SO', and that's in
                           # Thai Unicode class.
 &quot;a&quot;  =~  /\P{Lao}/ # Match, as &quot;a&quot; is not a Laotian character.
</pre>
<p class="Pp">It is worth emphasizing that
    <span class="Li">&quot;\d&quot;</span>,
    <span class="Li">&quot;\w&quot;</span>, etc, match single characters, not
    complete numbers or words. To match a number (that consists of digits), use
    <span class="Li">&quot;\d+&quot;</span>; to match a word, use
    <span class="Li">&quot;\w+&quot;</span>. But be aware of the security
    considerations in doing so, as mentioned above.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Bracketed_Character_Classes"><a class="permalink" href="#Bracketed_Character_Classes">Bracketed
  Character Classes</a></h2>
<p class="Pp">The third form of character class you can use in Perl regular
    expressions is the bracketed character class. In its simplest form, it lists
    the characters that may be matched, surrounded by square brackets, like
    this: <span class="Li">&quot;[aeiou]&quot;</span>. This matches one of
    <span class="Li">&quot;a&quot;</span>,
    <span class="Li">&quot;e&quot;</span>,
    <span class="Li">&quot;i&quot;</span>, <span class="Li">&quot;o&quot;</span>
    or <span class="Li">&quot;u&quot;</span>. Like the other character classes,
    exactly one character is matched.* To match a longer string consisting of
    characters mentioned in the character class, follow the character class with
    a quantifier. For instance, <span class="Li">&quot;[aeiou]+&quot;</span>
    matches one or more lowercase English vowels.</p>
<p class="Pp">Repeating a character in a character class has no effect; it's
    considered to be in the set only once.</p>
<p class="Pp">Examples:</p>
<p class="Pp"></p>
<pre> &quot;e&quot;  =~  /[aeiou]/        # Match, as &quot;e&quot; is listed in the class.
 &quot;p&quot;  =~  /[aeiou]/        # No match, &quot;p&quot; is not listed in the class.
 &quot;ae&quot; =~  /^[aeiou]$/      # No match, a character class only matches
                           # a single character.
 &quot;ae&quot; =~  /^[aeiou]+$/     # Match, due to the quantifier.
 -------
</pre>
<p class="Pp">* There are two exceptions to a bracketed character class matching
    a single character only. Each requires special handling by Perl to make
    things work:</p>
<ul class="Bl-bullet">
  <li>When the class is to match caselessly under
      <span class="Li">&quot;/i&quot;</span> matching rules, and a character
      that is explicitly mentioned inside the class matches a multiple-character
      sequence caselessly under Unicode rules, the class will also match that
      sequence. For example, Unicode says that the letter
      <span class="Li">&quot;LATIN SMALL LETTER SHARP S&quot;</span> should
      match the sequence <span class="Li">&quot;ss&quot;</span> under
      <span class="Li">&quot;/i&quot;</span> rules. Thus,
    <p class="Pp"></p>
    <pre> 'ss' =~ /\A\N{LATIN SMALL LETTER SHARP S}\z/i             # Matches
 'ss' =~ /\A[aeioust\N{LATIN SMALL LETTER SHARP S}]\z/i    # Matches
    </pre>
    <p class="Pp">For this to happen, the class must not be inverted (see
        &quot;Negation&quot;) and the character must be explicitly specified,
        and not be part of a multi-character range (not even as one of its
        endpoints). (&quot;Character Ranges&quot; will be explained shortly.)
        Therefore,</p>
    <p class="Pp"></p>
    <pre> 'ss' =~ /\A[\0-\x{ff}]\z/ui       # Doesn't match
 'ss' =~ /\A[\0-\N{LATIN SMALL LETTER SHARP S}]\z/ui   # No match
 'ss' =~ /\A[\xDF-\xDF]\z/ui   # Matches on ASCII platforms, since
                               # \xDF is LATIN SMALL LETTER SHARP S,
                               # and the range is just a single
                               # element
    </pre>
    <p class="Pp">Note that it isn't a good idea to specify these types of
        ranges anyway.</p>
  </li>
  <li>Some names known to <span class="Li">&quot;\N{...}&quot;</span> refer to a
      sequence of multiple characters, instead of the usual single character.
      When one of these is included in the class, the entire sequence is
      matched. For example,
    <p class="Pp"></p>
    <pre>  &quot;\N{TAMIL LETTER KA}\N{TAMIL VOWEL SIGN AU}&quot;
                              =~ / ^ [\N{TAMIL SYLLABLE KAU}]  $ /x;
    </pre>
    <p class="Pp">matches, because <span class="Li">&quot;\N{TAMIL SYLLABLE
        KAU}&quot;</span> is a named sequence consisting of the two characters
        matched against. Like the other instance where a bracketed class can
        match multiple characters, and for similar reasons, the class must not
        be inverted, and the named sequence may not appear in a range, even one
        where it is both endpoints. If these happen, it is a fatal error if the
        character class is within the scope of <span class="Li">&quot;use re
        'strict&quot;</span>, or within an extended
        <span class="Li">&quot;(?[...])&quot;</span> class; otherwise only the
        first code point is used (with a
        <span class="Li">&quot;regexp&quot;</span>-type warning raised).</p>
  </li>
</ul>
<p class="Pp"><i>Special Characters Inside a Bracketed Character Class</i></p>
<p class="Pp">Most characters that are meta characters in regular expressions
    (that is, characters that carry a special meaning like
    <span class="Li">&quot;.&quot;</span>,
    <span class="Li">&quot;*&quot;</span>, or
    <span class="Li">&quot;(&quot;</span>) lose their special meaning and can be
    used inside a character class without the need to escape them. For instance,
    <span class="Li">&quot;[()]&quot;</span> matches either an opening
    parenthesis, or a closing parenthesis, and the parens inside the character
    class don't group or capture. Be aware that, unless the pattern is evaluated
    in single-quotish context, variable interpolation will take place before the
    bracketed class is parsed:</p>
<p class="Pp"></p>
<pre> $, = &quot;\t| &quot;;
 $a =~ m'[$,]';        # single-quotish: matches '$' or ','
 $a =~ q{[$,]}'        # same
 $a =~ m/[$,]/;        # double-quotish: matches &quot;\t&quot;, &quot;|&quot;, or &quot; &quot;
</pre>
<p class="Pp">Characters that may carry a special meaning inside a character
    class are: <span class="Li">&quot;\&quot;</span>,
    <span class="Li">&quot;^&quot;</span>,
    <span class="Li">&quot;-&quot;</span>, <span class="Li">&quot;[&quot;</span>
    and <span class="Li">&quot;]&quot;</span>, and are discussed below. They can
    be escaped with a backslash, although this is sometimes not needed, in which
    case the backslash may be omitted.</p>
<p class="Pp">The sequence <span class="Li">&quot;\b&quot;</span> is special
    inside a bracketed character class. While outside the character class,
    <span class="Li">&quot;\b&quot;</span> is an assertion indicating a point
    that does not have either two word characters or two non-word characters on
    either side, inside a bracketed character class,
    <span class="Li">&quot;\b&quot;</span> matches a backspace character.</p>
<p class="Pp">The sequences <span class="Li">&quot;\a&quot;</span>,
    <span class="Li">&quot;\c&quot;</span>,
    <span class="Li">&quot;\e&quot;</span>,
    <span class="Li">&quot;\f&quot;</span>,
    <span class="Li">&quot;\n&quot;</span>,
    <span class="Li">&quot;\N{</span><span class="Li"><i>NAME</i></span><span class="Li">}&quot;</span>,
    <span class="Li">&quot;\N{U+</span><span class="Li"><i>hex
    char</i></span><span class="Li">}&quot;</span>,
    <span class="Li">&quot;\r&quot;</span>,
    <span class="Li">&quot;\t&quot;</span>, and
    <span class="Li">&quot;\x&quot;</span> are also special and have the same
    meanings as they do outside a bracketed character class.</p>
<p class="Pp">Also, a backslash followed by two or three octal digits is
    considered an octal number.</p>
<p class="Pp">A <span class="Li">&quot;[&quot;</span> is not special inside a
    character class, unless it's the start of a POSIX character class (see
    &quot;POSIX Character Classes&quot; below). It normally does not need
    escaping.</p>
<p class="Pp">A <span class="Li">&quot;]&quot;</span> is normally either the end
    of a POSIX character class (see &quot;POSIX Character Classes&quot; below),
    or it signals the end of the bracketed character class. If you want to
    include a <span class="Li">&quot;]&quot;</span> in the set of characters,
    you must generally escape it.</p>
<p class="Pp">However, if the <span class="Li">&quot;]&quot;</span> is the
    <i>first</i> (or the second if the first character is a caret) character of
    a bracketed character class, it does not denote the end of the class (as you
    cannot have an empty class) and is considered part of the set of characters
    that can be matched without escaping.</p>
<p class="Pp">Examples:</p>
<p class="Pp"></p>
<pre> &quot;+&quot;   =~ /[+?*]/     #  Match, &quot;+&quot; in a character class is not special.
 &quot;\cH&quot; =~ /[\b]/      #  Match, \b inside in a character class
                      #  is equivalent to a backspace.
 &quot;]&quot;   =~ /[][]/      #  Match, as the character class contains
                      #  both [ and ].
 &quot;[]&quot;  =~ /[[]]/      #  Match, the pattern contains a character class
                      #  containing just [, and the character class is
                      #  followed by a ].
</pre>
<p class="Pp"><i>Bracketed Character Classes and the
    </i><span class="Li"><i>&quot;/xx&quot;</i></span><i> pattern
  modifier</i></p>
<p class="Pp">Normally SPACE and TAB characters have no special meaning inside a
    bracketed character class; they are just added to the list of characters
    matched by the class. But if the <span class="Li">&quot;/xx&quot;</span>
    pattern modifier is in effect, they are generally ignored and can be added
    to improve readability. They can't be added in the middle of a single
    construct:</p>
<p class="Pp"></p>
<pre> / [ \x{10 FFFF} ] /xx  # WRONG!
</pre>
<p class="Pp">The SPACE in the middle of the hex constant is illegal.</p>
<p class="Pp">To specify a literal SPACE character, you can escape it with a
    backslash, like:</p>
<p class="Pp"></p>
<pre> /[ a e i o u \  ]/xx
</pre>
<p class="Pp">This matches the English vowels plus the SPACE character.</p>
<p class="Pp">For clarity, you should already have been using
    <span class="Li">&quot;\t&quot;</span> to specify a literal tab, and
    <span class="Li">&quot;\t&quot;</span> is unaffected by
    <span class="Li">&quot;/xx&quot;</span>.</p>
<p class="Pp"><i>Character Ranges</i></p>
<p class="Pp">It is not uncommon to want to match a range of characters.
    Luckily, instead of listing all characters in the range, one may use the
    hyphen (<span class="Li">&quot;-&quot;</span>). If inside a bracketed
    character class you have two characters separated by a hyphen, it's treated
    as if all characters between the two were in the class. For instance,
    <span class="Li">&quot;[0-9]&quot;</span> matches any ASCII digit, and
    <span class="Li">&quot;[a-m]&quot;</span> matches any lowercase letter from
    the first half of the ASCII alphabet.</p>
<p class="Pp">Note that the two characters on either side of the hyphen are not
    necessarily both letters or both digits. Any character is possible, although
    not advisable. <span class="Li">&quot;['-?]&quot;</span> contains a range of
    characters, but most people will not know which characters that means.
    Furthermore, such ranges may lead to portability problems if the code has to
    run on a platform that uses a different character set, such as EBCDIC.</p>
<p class="Pp">If a hyphen in a character class cannot syntactically be part of a
    range, for instance because it is the first or the last character of the
    character class, or if it immediately follows a range, the hyphen isn't
    special, and so is considered a character to be matched literally. If you
    want a hyphen in your set of characters to be matched and its position in
    the class is such that it could be considered part of a range, you must
    escape that hyphen with a backslash.</p>
<p class="Pp">Examples:</p>
<p class="Pp"></p>
<pre> [a-z]       #  Matches a character that is a lower case ASCII letter.
 [a-fz]      #  Matches any letter between 'a' and 'f' (inclusive) or
             #  the letter 'z'.
 [-z]        #  Matches either a hyphen ('-') or the letter 'z'.
 [a-f-m]     #  Matches any letter between 'a' and 'f' (inclusive), the
             #  hyphen ('-'), or the letter 'm'.
 ['-?]       #  Matches any of the characters  '()*+,-./0123456789:;&lt;=&gt;?
             #  (But not on an EBCDIC platform).
 [\N{APOSTROPHE}-\N{QUESTION MARK}]
             #  Matches any of the characters  '()*+,-./0123456789:;&lt;=&gt;?
             #  even on an EBCDIC platform.
 [\N{U+27}-\N{U+3F}] # Same. (U+27 is &quot;'&quot;, and U+3F is &quot;?&quot;)
</pre>
<p class="Pp">As the final two examples above show, you can achieve portability
    to non-ASCII platforms by using the
    <span class="Li">&quot;\N{...}&quot;</span> form for the range endpoints.
    These indicate that the specified range is to be interpreted using Unicode
    values, so <span class="Li">&quot;[\N{U+27}-\N{U+3F}]&quot;</span> means to
    match <span class="Li">&quot;\N{U+27}&quot;</span>,
    <span class="Li">&quot;\N{U+28}&quot;</span>,
    <span class="Li">&quot;\N{U+29}&quot;</span>, ...,
    <span class="Li">&quot;\N{U+3D}&quot;</span>,
    <span class="Li">&quot;\N{U+3E}&quot;</span>, and
    <span class="Li">&quot;\N{U+3F}&quot;</span>, whatever the native code point
    versions for those are. These are called &quot;Unicode&quot; ranges. If
    either end is of the <span class="Li">&quot;\N{...}&quot;</span> form, the
    range is considered Unicode. A <span class="Li">&quot;regexp&quot;</span>
    warning is raised under
    <span class="Li">&quot;use&#x00A0;re&#x00A0;'strict'&quot;</span> if the
    other endpoint is specified non-portably:</p>
<p class="Pp"></p>
<pre> [\N{U+00}-\x09]    # Warning under re 'strict'; \x09 is non-portable
 [\N{U+00}-\t]      # No warning;
</pre>
<p class="Pp">Both of the above match the characters
    <span class="Li">&quot;\N{U+00}&quot;</span>
    <span class="Li">&quot;\N{U+01}&quot;</span>, ...
    <span class="Li">&quot;\N{U+08}&quot;</span>,
    <span class="Li">&quot;\N{U+09}&quot;</span>, but the
    <span class="Li">&quot;\x09&quot;</span> looks like it could be a mistake so
    the warning is raised (under <span class="Li">&quot;re
    'strict'&quot;</span>) for it.</p>
<p class="Pp">Perl also guarantees that the ranges
    <span class="Li">&quot;A-Z&quot;</span>,
    <span class="Li">&quot;a-z&quot;</span>,
    <span class="Li">&quot;0-9&quot;</span>, and any subranges of these match
    what an English-only speaker would expect them to match on any platform.
    That is, <span class="Li">&quot;[A-Z]&quot;</span> matches the 26 ASCII
    uppercase letters; <span class="Li">&quot;[a-z]&quot;</span> matches the 26
    lowercase letters; and <span class="Li">&quot;[0-9]&quot;</span> matches the
    10 digits. Subranges, like <span class="Li">&quot;[h-k]&quot;</span>, match
    correspondingly, in this case just the four letters
    <span class="Li">&quot;h&quot;</span>,
    <span class="Li">&quot;i&quot;</span>,
    <span class="Li">&quot;j&quot;</span>, and
    <span class="Li">&quot;k&quot;</span>. This is the natural behavior on ASCII
    platforms where the code points (ordinal values) for
    <span class="Li">&quot;h&quot;</span> through
    <span class="Li">&quot;k&quot;</span> are consecutive integers (0x68 through
    0x6B). But special handling to achieve this may be needed on platforms with
    a non-ASCII native character set. For example, on EBCDIC platforms, the code
    point for <span class="Li">&quot;h&quot;</span> is 0x88,
    <span class="Li">&quot;i&quot;</span> is 0x89,
    <span class="Li">&quot;j&quot;</span> is 0x91, and
    <span class="Li">&quot;k&quot;</span> is 0x92. Perl specially treats
    <span class="Li">&quot;[h-k]&quot;</span> to exclude the seven code points
    in the gap: 0x8A through 0x90. This special handling is only invoked when
    the range is a subrange of one of the ASCII uppercase, lowercase, and digit
    ranges, AND each end of the range is expressed either as a literal, like
    <span class="Li">&quot;A&quot;</span>, or as a named character
    (<span class="Li">&quot;\N{...}&quot;</span>, including the
    <span class="Li">&quot;\N{U+...&quot;</span> form).</p>
<p class="Pp">EBCDIC Examples:</p>
<p class="Pp"></p>
<pre> [i-j]               #  Matches either &quot;i&quot; or &quot;j&quot;
 [i-\N{LATIN SMALL LETTER J}]  # Same
 [i-\N{U+6A}]        #  Same
 [\N{U+69}-\N{U+6A}] #  Same
 [\x{89}-\x{91}]     #  Matches 0x89 (&quot;i&quot;), 0x8A .. 0x90, 0x91 (&quot;j&quot;)
 [i-\x{91}]          #  Same
 [\x{89}-j]          #  Same
 [i-J]               #  Matches, 0x89 (&quot;i&quot;) .. 0xC1 (&quot;J&quot;); special
                     #  handling doesn't apply because range is mixed
                     #  case
</pre>
<p class="Pp"><i>Negation</i></p>
<p class="Pp">It is also possible to instead list the characters you do not want
    to match. You can do so by using a caret
    (<span class="Li">&quot;^&quot;</span>) as the first character in the
    character class. For instance, <span class="Li">&quot;[^a-z]&quot;</span>
    matches any character that is not a lowercase ASCII letter, which therefore
    includes more than a million Unicode code points. The class is said to be
    &quot;negated&quot; or &quot;inverted&quot;.</p>
<p class="Pp">This syntax make the caret a special character inside a bracketed
    character class, but only if it is the first character of the class. So if
    you want the caret as one of the characters to match, either escape the
    caret or else don't list it first.</p>
<p class="Pp">In inverted bracketed character classes, Perl ignores the Unicode
    rules that normally say that named sequence, and certain characters should
    match a sequence of multiple characters use under caseless
    <span class="Li">&quot;/i&quot;</span> matching. Following those rules could
    lead to highly confusing situations:</p>
<p class="Pp"></p>
<pre> &quot;ss&quot; =~ /^[^\xDF]+$/ui;   # Matches!
</pre>
<p class="Pp">This should match any sequences of characters that aren't
    <span class="Li">&quot;\xDF&quot;</span> nor what
    <span class="Li">&quot;\xDF&quot;</span> matches under
    <span class="Li">&quot;/i&quot;</span>.
    <span class="Li">&quot;s&quot;</span> isn't
    <span class="Li">&quot;\xDF&quot;</span>, but Unicode says that
    <span class="Li">&quot;ss&quot;</span> is what
    <span class="Li">&quot;\xDF&quot;</span> matches under
    <span class="Li">&quot;/i&quot;</span>. So which one &quot;wins&quot;? Do
    you fail the match because the string has
    <span class="Li">&quot;ss&quot;</span> or accept it because it has an
    <span class="Li">&quot;s&quot;</span> followed by another
    <span class="Li">&quot;s&quot;</span>? Perl has chosen the latter. (See note
    in &quot;Bracketed Character Classes&quot; above.)</p>
<p class="Pp">Examples:</p>
<p class="Pp"></p>
<pre> &quot;e&quot;  =~  /[^aeiou]/   #  No match, the 'e' is listed.
 &quot;x&quot;  =~  /[^aeiou]/   #  Match, as 'x' isn't a lowercase vowel.
 &quot;^&quot;  =~  /[^^]/       #  No match, matches anything that isn't a caret.
 &quot;^&quot;  =~  /[x^]/       #  Match, caret is not special here.
</pre>
<p class="Pp"><i>Backslash Sequences</i></p>
<p class="Pp">You can put any backslash sequence character class (with the
    exception of <span class="Li">&quot;\N&quot;</span> and
    <span class="Li">&quot;\R&quot;</span>) inside a bracketed character class,
    and it will act just as if you had put all characters matched by the
    backslash sequence inside the character class. For instance,
    <span class="Li">&quot;[a-f\d]&quot;</span> matches any decimal digit, or
    any of the lowercase letters between 'a' and 'f' inclusive.</p>
<p class="Pp"><span class="Li">&quot;\N&quot;</span> within a bracketed
    character class must be of the forms
    <span class="Li">&quot;\N{</span><span class="Li"><i>name</i></span><span class="Li">}&quot;</span>
    or <span class="Li">&quot;\N{U+</span><span class="Li"><i>hex
    char</i></span><span class="Li">}&quot;</span>, and NOT be the form that
    matches non-newlines, for the same reason that a dot
    <span class="Li">&quot;.&quot;</span> inside a bracketed character class
    loses its special meaning: it matches nearly anything, which generally isn't
    what you want to happen.</p>
<p class="Pp">Examples:</p>
<p class="Pp"></p>
<pre> /[\p{Thai}\d]/     # Matches a character that is either a Thai
                    # character, or a digit.
 /[^\p{Arabic}()]/  # Matches a character that is neither an Arabic
                    # character, nor a parenthesis.
</pre>
<p class="Pp">Backslash sequence character classes cannot form one of the
    endpoints of a range. Thus, you can't say:</p>
<p class="Pp"></p>
<pre> /[\p{Thai}-\d]/     # Wrong!
</pre>
<p class="Pp"><i>POSIX Character Classes</i></p>
<p class="Pp">POSIX character classes have the form
    <span class="Li">&quot;[:class:]&quot;</span>, where <i>class</i> is the
    name, and the <span class="Li">&quot;[:&quot;</span> and
    <span class="Li">&quot;:]&quot;</span> delimiters. POSIX character classes
    only appear <i>inside</i> bracketed character classes, and are a convenient
    and descriptive way of listing a group of characters.</p>
<p class="Pp">Be careful about the syntax,</p>
<p class="Pp"></p>
<pre> # Correct:
 $string =~ /[[:alpha:]]/
 # Incorrect (will warn):
 $string =~ /[:alpha:]/
</pre>
<p class="Pp">The latter pattern would be a character class consisting of a
    colon, and the letters <span class="Li">&quot;a&quot;</span>,
    <span class="Li">&quot;l&quot;</span>, <span class="Li">&quot;p&quot;</span>
    and <span class="Li">&quot;h&quot;</span>.</p>
<p class="Pp">POSIX character classes can be part of a larger bracketed
    character class. For example,</p>
<p class="Pp"></p>
<pre> [01[:alpha:]%]
</pre>
<p class="Pp">is valid and matches '0', '1', any alphabetic character, and the
    percent sign.</p>
<p class="Pp">Perl recognizes the following POSIX character classes:</p>
<p class="Pp"></p>
<pre> alpha  Any alphabetical character (e.g., [A-Za-z]).
 alnum  Any alphanumeric character (e.g., [A-Za-z0-9]).
 ascii  Any character in the ASCII character set.
 blank  A GNU extension, equal to a space or a horizontal tab (&quot;\t&quot;).
 cntrl  Any control character.  See Note [2] below.
 digit  Any decimal digit (e.g., [0-9]), equivalent to &quot;\d&quot;.
 graph  Any printable character, excluding a space.  See Note [3] below.
 lower  Any lowercase character (e.g., [a-z]).
 print  Any printable character, including a space.  See Note [4] below.
 punct  Any graphical character excluding &quot;word&quot; characters.  Note [5].
 space  Any whitespace character. &quot;\s&quot; including the vertical tab
        (&quot;\cK&quot;).
 upper  Any uppercase character (e.g., [A-Z]).
 word   A Perl extension (e.g., [A-Za-z0-9_]), equivalent to &quot;\w&quot;.
 xdigit Any hexadecimal digit (e.g., [0-9a-fA-F]).  Note [7].
</pre>
<p class="Pp">Like the Unicode properties, most of the POSIX properties match
    the same regardless of whether case-insensitive
    (<span class="Li">&quot;/i&quot;</span>) matching is in effect or not. The
    two exceptions are <span class="Li">&quot;[:upper:]&quot;</span> and
    <span class="Li">&quot;[:lower:]&quot;</span>. Under
    <span class="Li">&quot;/i&quot;</span>, they each match the union of
    <span class="Li">&quot;[:upper:]&quot;</span> and
    <span class="Li">&quot;[:lower:]&quot;</span>.</p>
<p class="Pp">Most POSIX character classes have two Unicode-style
    <span class="Li">&quot;\p&quot;</span> property counterparts. (They are not
    official Unicode properties, but Perl extensions derived from official
    Unicode properties.) The table below shows the relation between POSIX
    character classes and these counterparts.</p>
<p class="Pp">One counterpart, in the column labelled &quot;ASCII-range
    Unicode&quot; in the table, matches only characters in the ASCII character
    set.</p>
<p class="Pp">The other counterpart, in the column labelled &quot;Full-range
    Unicode&quot;, matches any appropriate characters in the full Unicode
    character set. For example, <span class="Li">&quot;\p{Alpha}&quot;</span>
    matches not just the ASCII alphabetic characters, but any character in the
    entire Unicode character set considered alphabetic. An entry in the column
    labelled &quot;backslash sequence&quot; is a (short) equivalent.</p>
<p class="Pp"></p>
<pre> [[:...:]]      ASCII-range          Full-range  backslash  Note
                 Unicode              Unicode     sequence
 -----------------------------------------------------
   alpha      \p{PosixAlpha}       \p{XPosixAlpha}
   alnum      \p{PosixAlnum}       \p{XPosixAlnum}
   ascii      \p{ASCII}
   blank      \p{PosixBlank}       \p{XPosixBlank}  \h      [1]
                                   or \p{HorizSpace}        [1]
   cntrl      \p{PosixCntrl}       \p{XPosixCntrl}          [2]
   digit      \p{PosixDigit}       \p{XPosixDigit}  \d
   graph      \p{PosixGraph}       \p{XPosixGraph}          [3]
   lower      \p{PosixLower}       \p{XPosixLower}
   print      \p{PosixPrint}       \p{XPosixPrint}          [4]
   punct      \p{PosixPunct}       \p{XPosixPunct}          [5]
              \p{PerlSpace}        \p{XPerlSpace}   \s      [6]
   space      \p{PosixSpace}       \p{XPosixSpace}          [6]
   upper      \p{PosixUpper}       \p{XPosixUpper}
   word       \p{PosixWord}        \p{XPosixWord}   \w
   xdigit     \p{PosixXDigit}      \p{XPosixXDigit}         [7]
</pre>
<dl class="Bl-tag">
  <dt>[1]</dt>
  <dd><span class="Li">&quot;\p{Blank}&quot;</span> and
      <span class="Li">&quot;\p{HorizSpace}&quot;</span> are synonyms.</dd>
  <dt>[2]</dt>
  <dd>Control characters don't produce output as such, but instead usually
      control the terminal somehow: for example, newline and backspace are
      control characters. On ASCII platforms, in the ASCII range, characters
      whose code points are between 0 and 31 inclusive, plus 127
      (<span class="Li">&quot;DEL&quot;</span>) are control characters; on
      EBCDIC platforms, their counterparts are control characters.</dd>
  <dt>[3]</dt>
  <dd>Any character that is <i>graphical</i>, that is, visible. This class
      consists of all alphanumeric characters and all punctuation
    characters.</dd>
  <dt>[4]</dt>
  <dd>All printable characters, which is the set of all graphical characters
      plus those whitespace characters which are not also controls.</dd>
  <dt>[5]</dt>
  <dd><span class="Li">&quot;\p{PosixPunct}&quot;</span> and
      <span class="Li">&quot;[[:punct:]]&quot;</span> in the ASCII range match
      all non-controls, non-alphanumeric, non-space characters:
      <span class="Li">&quot;[-!&quot;#$%&amp;'()*+,./:;&lt;=&gt;?@[\\\]^_`{|}~]&quot;</span>
      (although if a locale is in effect, it could alter the behavior of
      <span class="Li">&quot;[[:punct:]]&quot;</span>).
    <p class="Pp">The similarly named property,
        <span class="Li">&quot;\p{Punct}&quot;</span>, matches a somewhat
        different set in the ASCII range, namely
        <span class="Li">&quot;[-!&quot;#%&amp;'()*,./:;?@[\\\]_{}]&quot;</span>.
        That is, it is missing the nine characters
        <span class="Li">&quot;[$+&lt;=&gt;^`|~]&quot;</span>. This is because
        Unicode splits what POSIX considers to be punctuation into two
        categories, Punctuation and Symbols.</p>
    <p class="Pp"><span class="Li">&quot;\p{XPosixPunct}&quot;</span> and (under
        Unicode rules) <span class="Li">&quot;[[:punct:]]&quot;</span>, match
        what <span class="Li">&quot;\p{PosixPunct}&quot;</span> matches in the
        ASCII range, plus what <span class="Li">&quot;\p{Punct}&quot;</span>
        matches. This is different than strictly matching according to
        <span class="Li">&quot;\p{Punct}&quot;</span>. Another way to say it is
        that if Unicode rules are in effect,
        <span class="Li">&quot;[[:punct:]]&quot;</span> matches all characters
        that Unicode considers punctuation, plus all ASCII-range characters that
        Unicode considers symbols.</p>
  </dd>
  <dt>[6]</dt>
  <dd><span class="Li">&quot;\p{XPerlSpace}&quot;</span> and
      <span class="Li">&quot;\p{Space}&quot;</span> match identically starting
      with Perl v5.18. In earlier versions, these differ only in that in
      non-locale matching, <span class="Li">&quot;\p{XPerlSpace}&quot;</span>
      did not match the vertical tab, <span class="Li">&quot;\cK&quot;</span>.
      Same for the two ASCII-only range forms.</dd>
  <dt>[7]</dt>
  <dd>Unlike <span class="Li">&quot;[[:digit:]]&quot;</span> which matches
      digits in many writing systems, such as Thai and Devanagari, there are
      currently only two sets of hexadecimal digits, and it is unlikely that
      more will be added. This is because you not only need the ten digits, but
      also the six <span class="Li">&quot;[A-F]&quot;</span> (and
      <span class="Li">&quot;[a-f]&quot;</span>) to correspond. That means only
      the Latin script is suitable for these, and Unicode has only two sets of
      these, the familiar ASCII set, and the fullwidth forms starting at U+FF10
      (FULLWIDTH DIGIT ZERO).</dd>
</dl>
<p class="Pp">There are various other synonyms that can be used besides the
    names listed in the table. For example,
    <span class="Li">&quot;\p{XPosixAlpha}&quot;</span> can be written as
    <span class="Li">&quot;\p{Alpha}&quot;</span>. All are listed in
    &quot;Properties accessible through \p{} and \P{}&quot; in perluniprops.</p>
<p class="Pp">Both the <span class="Li">&quot;\p&quot;</span> counterparts
    always assume Unicode rules are in effect. On ASCII platforms, this means
    they assume that the code points from 128 to 255 are Latin-1, and that means
    that using them under locale rules is unwise unless the locale is guaranteed
    to be Latin-1 or UTF-8. In contrast, the POSIX character classes are useful
    under locale rules. They are affected by the actual rules in effect, as
    follows:</p>
<dl class="Bl-tag">
  <dt id="If~3"><a class="permalink" href="#If~3">If the &quot;/a&quot;
    modifier, is in effect ...</a></dt>
  <dd>Each of the POSIX classes matches exactly the same as their ASCII-range
      counterparts.</dd>
  <dt id="otherwise~5"><a class="permalink" href="#otherwise~5">otherwise
    ...</a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="For~5"><a class="permalink" href="#For~5">For code points above 255
    ...</a></dt>
  <dd>The POSIX class matches the same as its Full-range counterpart.</dd>
  <dt id="For~6"><a class="permalink" href="#For~6">For code points below 256
    ...</a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="if~3"><a class="permalink" href="#if~3">if locale rules are in effect
    ...</a></dt>
  <dd>The POSIX class matches according to the locale, except:</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>&quot;word&quot;</dt>
  <dd>also includes the platform's native underscore character, no matter what
      the locale is.</dd>
  <dt>&quot;ascii&quot;</dt>
  <dd>on platforms that don't have the POSIX
      <span class="Li">&quot;ascii&quot;</span> extension, this matches just the
      platform's native ASCII-range characters.</dd>
  <dt>&quot;blank&quot;</dt>
  <dd>on platforms that don't have the POSIX
      <span class="Li">&quot;blank&quot;</span> extension, this matches just the
      platform's native tab and space characters.</dd>
</dl>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt id="if,~3"><a class="permalink" href="#if,~3">if, instead, Unicode rules
    are in effect ...</a></dt>
  <dd>The POSIX class matches the same as the Full-range counterpart.</dd>
  <dt id="otherwise~6"><a class="permalink" href="#otherwise~6">otherwise
    ...</a></dt>
  <dd>The POSIX class matches the same as the ASCII range counterpart.</dd>
</dl>
</div>
<div class="Bd-indent"></div>
</div>
<div class="Bd-indent"></div>
<p class="Pp">Which rules apply are determined as described in &quot;Which
    character set modifier is in effect?&quot; in perlre.</p>
<p class="Pp">Negation of POSIX character classes</p>
<p class="Pp">A Perl extension to the POSIX character class is the ability to
    negate it. This is done by prefixing the class name with a caret
    (<span class="Li">&quot;^&quot;</span>). Some examples:</p>
<p class="Pp"></p>
<pre>     POSIX         ASCII-range     Full-range  backslash
                    Unicode         Unicode    sequence
 -----------------------------------------------------
 [[:^digit:]]   \P{PosixDigit}  \P{XPosixDigit}   \D
 [[:^space:]]   \P{PosixSpace}  \P{XPosixSpace}
                \P{PerlSpace}   \P{XPerlSpace}    \S
 [[:^word:]]    \P{PerlWord}    \P{XPosixWord}    \W
</pre>
<p class="Pp">The backslash sequence can mean either ASCII- or Full-range
    Unicode, depending on various factors as described in &quot;Which character
    set modifier is in effect?&quot; in perlre.</p>
<p class="Pp">[= =] and [. .]</p>
<p class="Pp">Perl recognizes the POSIX character classes
    <span class="Li">&quot;[=class=]&quot;</span> and
    <span class="Li">&quot;[.class.]&quot;</span>, but does not (yet?) support
    them. Any attempt to use either construct raises an exception.</p>
<p class="Pp">Examples</p>
<p class="Pp"></p>
<pre> /[[:digit:]]/            # Matches a character that is a digit.
 /[01[:lower:]]/          # Matches a character that is either a
                          # lowercase letter, or '0' or '1'.
 /[[:digit:][:^xdigit:]]/ # Matches a character that can be anything
                          # except the letters 'a' to 'f' and 'A' to
                          # 'F'.  This is because the main character
                          # class is composed of two POSIX character
                          # classes that are ORed together, one that
                          # matches any digit, and the other that
                          # matches anything that isn't a hex digit.
                          # The OR adds the digits, leaving only the
                          # letters 'a' to 'f' and 'A' to 'F' excluded.
</pre>
<p class="Pp"><i>Extended Bracketed Character Classes</i></p>
<p class="Pp">This is a fancy bracketed character class that can be used for
    more readable and less error-prone classes, and to perform set operations,
    such as intersection. An example is</p>
<p class="Pp"></p>
<pre> /(?[ \p{Thai} &amp; \p{Digit} ])/
</pre>
<p class="Pp">This will match all the digit characters that are in the Thai
    script.</p>
<p class="Pp">This is an experimental feature available starting in 5.18, and is
    subject to change as we gain field experience with it. Any attempt to use it
    will raise a warning, unless disabled via</p>
<p class="Pp"></p>
<pre> no warnings &quot;experimental::regex_sets&quot;;
</pre>
<p class="Pp">Comments on this feature are welcome; send email to
    <span class="Li">&quot;perl5-porters@perl.org&quot;</span>.</p>
<p class="Pp">The rules used by <span class="Li">&quot;use re
    'strict&quot;</span> apply to this construct.</p>
<p class="Pp">We can extend the example above:</p>
<p class="Pp"></p>
<pre> /(?[ ( \p{Thai} + \p{Lao} ) &amp; \p{Digit} ])/
</pre>
<p class="Pp">This matches digits that are in either the Thai or Laotian
    scripts.</p>
<p class="Pp">Notice the white space in these examples. This construct always
    has the <span class="Li">&quot;/xx&quot;</span> modifier turned on within
    it.</p>
<p class="Pp">The available binary operators are:</p>
<p class="Pp"></p>
<pre> &amp;    intersection
 +    union
 |    another name for '+', hence means union
 -    subtraction (the result matches the set consisting of those
      code points matched by the first operand, excluding any that
      are also matched by the second operand)
 ^    symmetric difference (the union minus the intersection).  This
      is like an exclusive or, in that the result is the set of code
      points that are matched by either, but not both, of the
      operands.
</pre>
<p class="Pp">There is one unary operator:</p>
<p class="Pp"></p>
<pre> !    complement
</pre>
<p class="Pp">All the binary operators left associate;
    <span class="Li">&quot;&amp;&quot;</span> is higher precedence than the
    others, which all have equal precedence. The unary operator right
    associates, and has highest precedence. Thus this follows the normal Perl
    precedence rules for logical operators. Use parentheses to override the
    default precedence and associativity.</p>
<p class="Pp">The main restriction is that everything is a metacharacter. Thus,
    you cannot refer to single characters by doing something like this:</p>
<p class="Pp"></p>
<pre> /(?[ a + b ])/ # Syntax error!
</pre>
<p class="Pp">The easiest way to specify an individual typable character is to
    enclose it in brackets:</p>
<p class="Pp"></p>
<pre> /(?[ [a] + [b] ])/
</pre>
<p class="Pp">(This is the same thing as
    <span class="Li">&quot;[ab]&quot;</span>.) You could also have said the
    equivalent:</p>
<p class="Pp"></p>
<pre> /(?[[ a b ]])/
</pre>
<p class="Pp">(You can, of course, specify single characters by using,
    <span class="Li">&quot;\x{...}&quot;</span>,
    <span class="Li">&quot;\N{...}&quot;</span>, etc.)</p>
<p class="Pp">This last example shows the use of this construct to specify an
    ordinary bracketed character class without additional set operations. Note
    the white space within it. This is allowed because
    <span class="Li">&quot;/xx&quot;</span> is automatically turned on within
    this construct.</p>
<p class="Pp">All the other escapes accepted by normal bracketed character
    classes are accepted here as well.</p>
<p class="Pp">Because this construct compiles under <span class="Li">&quot;use
    re 'strict&quot;</span>, unrecognized escapes that generate warnings in
    normal classes are fatal errors here, as well as all other warnings from
    these class elements, as well as some practices that don't currently warn
    outside <span class="Li">&quot;re 'strict'&quot;</span>. For example you
    cannot say</p>
<p class="Pp"></p>
<pre> /(?[ [ \xF ] ])/     # Syntax error!
</pre>
<p class="Pp">You have to have two hex digits after a braceless
    <span class="Li">&quot;\x&quot;</span> (use a leading zero to make two).
    These restrictions are to lower the incidence of typos causing the class to
    not match what you thought it would.</p>
<p class="Pp">If a regular bracketed character class contains a
    <span class="Li">&quot;\p{}&quot;</span> or
    <span class="Li">&quot;\P{}&quot;</span> and is matched against a
    non-Unicode code point, a warning may be raised, as the result is not
    Unicode-defined. No such warning will come when using this extended
  form.</p>
<p class="Pp">The final difference between regular bracketed character classes
    and these, is that it is not possible to get these to match a
    multi-character fold. Thus,</p>
<p class="Pp"></p>
<pre> /(?[ [\xDF] ])/iu
</pre>
<p class="Pp">does not match the string
  <span class="Li">&quot;ss&quot;</span>.</p>
<p class="Pp">You don't have to enclose POSIX class names inside double
    brackets, hence both of the following work:</p>
<p class="Pp"></p>
<pre> /(?[ [:word:] - [:lower:] ])/
 /(?[ [[:word:]] - [[:lower:]] ])/
</pre>
<p class="Pp">Any contained POSIX character classes, including things like
    <span class="Li">&quot;\w&quot;</span> and
    <span class="Li">&quot;\D&quot;</span> respect the
    <span class="Li">&quot;/a&quot;</span> (and
    <span class="Li">&quot;/aa&quot;</span>) modifiers.</p>
<p class="Pp">Note that <span class="Li">&quot;(?[ ])&quot;</span> is a
    regex-compile-time construct. Any attempt to use something which isn't
    knowable at the time the containing regular expression is compiled is a
    fatal error. In practice, this means just three limitations:</p>
<dl class="Bl-tag">
  <dt>1.</dt>
  <dd>When compiled within the scope of <span class="Li">&quot;use
      locale&quot;</span> (or the <span class="Li">&quot;/l&quot;</span> regex
      modifier), this construct assumes that the execution-time locale will be a
      UTF-8 one, and the generated pattern always uses Unicode rules. What gets
      matched or not thus isn't dependent on the actual runtime locale, so
      tainting is not enabled. But a <span class="Li">&quot;locale&quot;</span>
      category warning is raised if the runtime locale turns out to not be
      UTF-8.</dd>
  <dt>2.</dt>
  <dd>Any user-defined property used must be already defined by the time the
      regular expression is compiled (but note that this construct can be used
      instead of such properties).</dd>
  <dt>3.</dt>
  <dd>A regular expression that otherwise would compile using
      <span class="Li">&quot;/d&quot;</span> rules, and which uses this
      construct will instead use <span class="Li">&quot;/u&quot;</span>. Thus
      this construct tells Perl that you don't want
      <span class="Li">&quot;/d&quot;</span> rules for the entire regular
      expression containing it.</dd>
</dl>
<p class="Pp">Note that skipping white space applies only to the interior of
    this construct. There must not be any space between any of the characters
    that form the initial <span class="Li">&quot;(?[&quot;</span>. Nor may there
    be space between the closing <span class="Li">&quot;])&quot;</span>
    characters.</p>
<p class="Pp">Just as in all regular expressions, the pattern can be built up by
    including variables that are interpolated at regex compilation time. But its
    best to compile each sub-component.</p>
<p class="Pp"></p>
<pre> my $thai_or_lao = qr/(?[ \p{Thai} + \p{Lao} ])/;
 my $lower = qr/(?[ \p{Lower} + \p{Digit} ])/;
</pre>
<p class="Pp">When these are embedded in another pattern, what they match does
    not change, regardless of parenthesization or what modifiers are in effect
    in that outer pattern. If you fail to compile the subcomponents, you can get
    some nasty surprises. For example:</p>
<p class="Pp"></p>
<pre> my $thai_or_lao = '\p{Thai} + \p{Lao}';
 ...
 qr/(?[ \p{Digit} &amp; $thai_or_lao ])/;
</pre>
<p class="Pp">compiles to</p>
<p class="Pp"></p>
<pre> qr/(?[ \p{Digit} &amp; \p{Thai} + \p{Lao} ])/;
</pre>
<p class="Pp">But this does not have the effect that someone reading the source
    code would likely expect, as the intersection applies just to
    <span class="Li">&quot;\p{Thai}&quot;</span>, excluding the Laotian. Its
    best to compile the subcomponents, but you could also parenthesize the
    component pieces:</p>
<p class="Pp"></p>
<pre> my $thai_or_lao = '( \p{Thai} + \p{Lao} )';
</pre>
<p class="Pp">But any modifiers will still apply to all the components:</p>
<p class="Pp"></p>
<pre> my $lower = '\p{Lower} + \p{Digit}';
 qr/(?[ \p{Greek} &amp; $lower ])/i;
</pre>
<p class="Pp">matches upper case things. So just, compile the subcomponents, as
    illustrated above.</p>
<p class="Pp">Due to the way that Perl parses things, your parentheses and
    brackets may need to be balanced, even including comments. If you run into
    any examples, please submit them to
    &lt;https://github.com/Perl/perl5/issues&gt;, so that we can have a concrete
    example for this man page.</p>
<p class="Pp">We may change it so that things that remain legal uses in normal
    bracketed character classes might become illegal within this experimental
    construct. One proposal, for example, is to forbid adjacent uses of the same
    character, as in <span class="Li">&quot;(?[ [aa] ])&quot;</span>. The
    motivation for such a change is that this usage is likely a typo, as the
    second &quot;a&quot; adds nothing.</p>
</section>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2020-02-11</td>
    <td class="foot-os">perl v5.30.3</td>
  </tr>
</table>
</body>
</html>
