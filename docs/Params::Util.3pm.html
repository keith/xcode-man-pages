<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.10 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>Params::Util(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Params::Util(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Params::Util(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
Params::Util - Simple, compact and correct param-checking functions
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<span class="Li"></span>
<pre>
  # Import some functions
  use Params::Util qw{_SCALAR _HASH _INSTANCE};
  
  # If you are lazy, or need a lot of them...
  use Params::Util ':ALL';
  
  sub foo {
      my $object  = _INSTANCE(shift, 'Foo') or return undef;
      my $image   = _SCALAR(shift)          or return undef;
      my $options = _HASH(shift)            or return undef;
      # etc...
  }
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<span class="Li">&quot;Params::Util&quot;</span> provides a basic set of
  importable functions that makes checking parameters a hell of a lot easier
<p class="Pp">While they can be (and are) used in other contexts, the main point
    behind this module is that the functions <b>both</b> Do What You Mean, and
    Do The Right Thing, so they are most useful when you are getting params
    passed into your code from someone and/or somewhere else and you can't
    really trust the quality.</p>
<p class="Pp">Thus, <span class="Li">&quot;Params::Util&quot;</span> is of most
    use at the edges of your API, where params and data are coming in from
    outside your code.</p>
<p class="Pp">The functions provided by
    <span class="Li">&quot;Params::Util&quot;</span> check in the most strictly
    correct manner known, are documented as thoroughly as possible so their
    exact behaviour is clear, and heavily tested so make sure they are not
    fooled by weird data and Really Bad Things.</p>
<p class="Pp">To use, simply load the module providing the functions you want to
    use as arguments (as shown in the SYNOPSIS).</p>
<p class="Pp">To aid in maintainability,
    <span class="Li">&quot;Params::Util&quot;</span> will <b>never</b> export by
    default.</p>
<p class="Pp">You must explicitly name the functions you want to export, or use
    the <span class="Li">&quot;:ALL&quot;</span> param to just have it export
    everything (although this is not recommended if you have any _FOO functions
    yourself with which future additions to
    <span class="Li">&quot;Params::Util&quot;</span> may clash)</p>
</section>
<section class="Sh">
<h1 class="Sh" id="FUNCTIONS"><a class="permalink" href="#FUNCTIONS">FUNCTIONS</a></h1>
<section class="Ss">
<h2 class="Ss" id="_STRING_$string"><a class="permalink" href="#_STRING_$string">_STRING
  $string</a></h2>
The <span class="Li">&quot;_STRING&quot;</span> function is intended to be
  imported into your package, and provides a convenient way to test to see if a
  value is a normal non-false string of non-zero length.
<p class="Pp">Note that this will NOT do anything magic to deal with the special
    <span class="Li">'0'</span> false negative case, but will return it.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  # '0' not considered valid data
  my $name = _STRING(shift) or die &quot;Bad name&quot;;
  
  # '0' is considered valid data
  my $string = _STRING($_[0]) ? shift : die &quot;Bad string&quot;;
</pre>
<p class="Pp">Please also note that this function expects a normal string. It
    does not support overloading or other magic techniques to get a string.</p>
<p class="Pp">Returns the string as a conveince if it is a valid string, or
    <span class="Li">&quot;undef&quot;</span> if not.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_IDENTIFIER_$string"><a class="permalink" href="#_IDENTIFIER_$string">_IDENTIFIER
  $string</a></h2>
The <span class="Li">&quot;_IDENTIFIER&quot;</span> function is intended to be
  imported into your package, and provides a convenient way to test to see if a
  value is a string that is a valid Perl identifier.
<p class="Pp">Returns the string as a convenience if it is a valid identifier,
    or <span class="Li">&quot;undef&quot;</span> if not.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_CLASS_$string"><a class="permalink" href="#_CLASS_$string">_CLASS
  $string</a></h2>
The <span class="Li">&quot;_CLASS&quot;</span> function is intended to be
  imported into your package, and provides a convenient way to test to see if a
  value is a string that is a valid Perl class.
<p class="Pp">This function only checks that the format is valid, not that the
    class is actually loaded. It also assumes &quot;normalised&quot; form, and
    does not accept class names such as
    <span class="Li">&quot;::Foo&quot;</span> or
    <span class="Li">&quot;D'Oh&quot;</span>.</p>
<p class="Pp">Returns the string as a convenience if it is a valid class name,
    or <span class="Li">&quot;undef&quot;</span> if not.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_CLASSISA_$string,_$class"><a class="permalink" href="#_CLASSISA_$string,_$class">_CLASSISA
  $string, $class</a></h2>
The <span class="Li">&quot;_CLASSISA&quot;</span> function is intended to be
  imported into your package, and provides a convenient way to test to see if a
  value is a string that is a particularly class, or a subclass of it.
<p class="Pp">This function checks that the format is valid and calls the
    -&gt;isa method on the class name. It does not check that the class is
    actually loaded.</p>
<p class="Pp">It also assumes &quot;normalised&quot; form, and does not accept
    class names such as <span class="Li">&quot;::Foo&quot;</span> or
    <span class="Li">&quot;D'Oh&quot;</span>.</p>
<p class="Pp">Returns the string as a convenience if it is a valid class name,
    or <span class="Li">&quot;undef&quot;</span> if not.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_CLASSDOES_$string,_$role"><a class="permalink" href="#_CLASSDOES_$string,_$role">_CLASSDOES
  $string, $role</a></h2>
This routine behaves exactly like <span class="Li">&quot;_CLASSISA&quot;</span>,
  but checks with <span class="Li">&quot;-&gt;DOES&quot;</span> rather than
  <span class="Li">&quot;-&gt;isa&quot;</span>. This is probably only a good
  idea to use on Perl 5.10 or later, when UNIVERSAL::DOES has been implemented.
</section>
<section class="Ss">
<h2 class="Ss" id="_SUBCLASS_$string,_$class"><a class="permalink" href="#_SUBCLASS_$string,_$class">_SUBCLASS
  $string, $class</a></h2>
The <span class="Li">&quot;_SUBCLASS&quot;</span> function is intended to be
  imported into your package, and provides a convenient way to test to see if a
  value is a string that is a subclass of a specified class.
<p class="Pp">This function checks that the format is valid and calls the
    -&gt;isa method on the class name. It does not check that the class is
    actually loaded.</p>
<p class="Pp">It also assumes &quot;normalised&quot; form, and does not accept
    class names such as <span class="Li">&quot;::Foo&quot;</span> or
    <span class="Li">&quot;D'Oh&quot;</span>.</p>
<p class="Pp">Returns the string as a convenience if it is a valid class name,
    or <span class="Li">&quot;undef&quot;</span> if not.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_NUMBER_$scalar"><a class="permalink" href="#_NUMBER_$scalar">_NUMBER
  $scalar</a></h2>
The <span class="Li">&quot;_NUMBER&quot;</span> function is intended to be
  imported into your package, and provides a convenient way to test to see if a
  value is a number. That is, it is defined and perl thinks it's a number.
<p class="Pp">This function is basically a Params::Util-style wrapper around the
    Scalar::Util <span class="Li">&quot;looks_like_number&quot;</span>
  function.</p>
<p class="Pp">Returns the value as a convience, or
    <span class="Li">&quot;undef&quot;</span> if the value is not a number.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_POSINT_$integer"><a class="permalink" href="#_POSINT_$integer">_POSINT
  $integer</a></h2>
The <span class="Li">&quot;_POSINT&quot;</span> function is intended to be
  imported into your package, and provides a convenient way to test to see if a
  value is a positive integer (of any length).
<p class="Pp">Returns the value as a convience, or
    <span class="Li">&quot;undef&quot;</span> if the value is not a positive
    integer.</p>
<p class="Pp">The name itself is derived from the XML schema constraint of the
    same name.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_NONNEGINT_$integer"><a class="permalink" href="#_NONNEGINT_$integer">_NONNEGINT
  $integer</a></h2>
The <span class="Li">&quot;_NONNEGINT&quot;</span> function is intended to be
  imported into your package, and provides a convenient way to test to see if a
  value is a non-negative integer (of any length). That is, a positive integer,
  or zero.
<p class="Pp">Returns the value as a convience, or
    <span class="Li">&quot;undef&quot;</span> if the value is not a non-negative
    integer.</p>
<p class="Pp">As with other tests that may return false values, care should be
    taken to test via &quot;defined&quot; in boolean validy contexts.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  unless ( defined _NONNEGINT($value) ) {
     die &quot;Invalid value&quot;;
  }
</pre>
<p class="Pp">The name itself is derived from the XML schema constraint of the
    same name.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_SCALAR__e$scalar"><a class="permalink" href="#_SCALAR__e$scalar">_SCALAR
  \$scalar</a></h2>
The <span class="Li">&quot;_SCALAR&quot;</span> function is intended to be
  imported into your package, and provides a convenient way to test for a raw
  and unblessed <span class="Li">&quot;SCALAR&quot;</span> reference, with
  content of non-zero length.
<p class="Pp">For a version that allows zero length
    <span class="Li">&quot;SCALAR&quot;</span> references, see the
    <span class="Li">&quot;_SCALAR0&quot;</span> function.</p>
<p class="Pp">Returns the <span class="Li">&quot;SCALAR&quot;</span> reference
    itself as a convenience, or <span class="Li">&quot;undef&quot;</span> if the
    value provided is not a <span class="Li">&quot;SCALAR&quot;</span>
    reference.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_SCALAR0__e$scalar"><a class="permalink" href="#_SCALAR0__e$scalar">_SCALAR0
  \$scalar</a></h2>
The <span class="Li">&quot;_SCALAR0&quot;</span> function is intended to be
  imported into your package, and provides a convenient way to test for a raw
  and unblessed <span class="Li">&quot;SCALAR0&quot;</span> reference, allowing
  content of zero-length.
<p class="Pp">For a simpler &quot;give me some content&quot; version that
    requires non-zero length, <span class="Li">&quot;_SCALAR&quot;</span>
    function.</p>
<p class="Pp">Returns the <span class="Li">&quot;SCALAR&quot;</span> reference
    itself as a convenience, or <span class="Li">&quot;undef&quot;</span> if the
    value provided is not a <span class="Li">&quot;SCALAR&quot;</span>
    reference.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_ARRAY_$value"><a class="permalink" href="#_ARRAY_$value">_ARRAY
  $value</a></h2>
The <span class="Li">&quot;_ARRAY&quot;</span> function is intended to be
  imported into your package, and provides a convenient way to test for a raw
  and unblessed <span class="Li">&quot;ARRAY&quot;</span> reference containing
  <b>at least</b> one element of any kind.
<p class="Pp">For a more basic form that allows zero length ARRAY references,
    see the <span class="Li">&quot;_ARRAY0&quot;</span> function.</p>
<p class="Pp">Returns the <span class="Li">&quot;ARRAY&quot;</span> reference
    itself as a convenience, or <span class="Li">&quot;undef&quot;</span> if the
    value provided is not an <span class="Li">&quot;ARRAY&quot;</span>
    reference.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_ARRAY0_$value"><a class="permalink" href="#_ARRAY0_$value">_ARRAY0
  $value</a></h2>
The <span class="Li">&quot;_ARRAY0&quot;</span> function is intended to be
  imported into your package, and provides a convenient way to test for a raw
  and unblessed <span class="Li">&quot;ARRAY&quot;</span> reference, allowing
  <span class="Li">&quot;ARRAY&quot;</span> references that contain no elements.
<p class="Pp">For a more basic &quot;An array of something&quot; form that also
    requires at least one element, see the
    <span class="Li">&quot;_ARRAY&quot;</span> function.</p>
<p class="Pp">Returns the <span class="Li">&quot;ARRAY&quot;</span> reference
    itself as a convenience, or <span class="Li">&quot;undef&quot;</span> if the
    value provided is not an <span class="Li">&quot;ARRAY&quot;</span>
    reference.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_ARRAYLIKE_$value"><a class="permalink" href="#_ARRAYLIKE_$value">_ARRAYLIKE
  $value</a></h2>
The <span class="Li">&quot;_ARRAYLIKE&quot;</span> function tests whether a
  given scalar value can respond to array dereferencing. If it can, the value is
  returned. If it cannot, <span class="Li">&quot;_ARRAYLIKE&quot;</span> returns
  <span class="Li">&quot;undef&quot;</span>.
</section>
<section class="Ss">
<h2 class="Ss" id="_HASH_$value"><a class="permalink" href="#_HASH_$value">_HASH
  $value</a></h2>
The <span class="Li">&quot;_HASH&quot;</span> function is intended to be
  imported into your package, and provides a convenient way to test for a raw
  and unblessed <span class="Li">&quot;HASH&quot;</span> reference with at least
  one entry.
<p class="Pp">For a version of this function that allows the
    <span class="Li">&quot;HASH&quot;</span> to be empty, see the
    <span class="Li">&quot;_HASH0&quot;</span> function.</p>
<p class="Pp">Returns the <span class="Li">&quot;HASH&quot;</span> reference
    itself as a convenience, or <span class="Li">&quot;undef&quot;</span> if the
    value provided is not an <span class="Li">&quot;HASH&quot;</span>
  reference.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_HASH0_$value"><a class="permalink" href="#_HASH0_$value">_HASH0
  $value</a></h2>
The <span class="Li">&quot;_HASH0&quot;</span> function is intended to be
  imported into your package, and provides a convenient way to test for a raw
  and unblessed <span class="Li">&quot;HASH&quot;</span> reference, regardless
  of the <span class="Li">&quot;HASH&quot;</span> content.
<p class="Pp">For a simpler &quot;A hash of something&quot; version that
    requires at least one element, see the
    <span class="Li">&quot;_HASH&quot;</span> function.</p>
<p class="Pp">Returns the <span class="Li">&quot;HASH&quot;</span> reference
    itself as a convenience, or <span class="Li">&quot;undef&quot;</span> if the
    value provided is not an <span class="Li">&quot;HASH&quot;</span>
  reference.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_HASHLIKE_$value"><a class="permalink" href="#_HASHLIKE_$value">_HASHLIKE
  $value</a></h2>
The <span class="Li">&quot;_HASHLIKE&quot;</span> function tests whether a given
  scalar value can respond to hash dereferencing. If it can, the value is
  returned. If it cannot, <span class="Li">&quot;_HASHLIKE&quot;</span> returns
  <span class="Li">&quot;undef&quot;</span>.
</section>
<section class="Ss">
<h2 class="Ss" id="_CODE_$value"><a class="permalink" href="#_CODE_$value">_CODE
  $value</a></h2>
The <span class="Li">&quot;_CODE&quot;</span> function is intended to be
  imported into your package, and provides a convenient way to test for a raw
  and unblessed <span class="Li">&quot;CODE&quot;</span> reference.
<p class="Pp">Returns the <span class="Li">&quot;CODE&quot;</span> reference
    itself as a convenience, or <span class="Li">&quot;undef&quot;</span> if the
    value provided is not an <span class="Li">&quot;CODE&quot;</span>
  reference.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_CODELIKE_$value"><a class="permalink" href="#_CODELIKE_$value">_CODELIKE
  $value</a></h2>
The <span class="Li">&quot;_CODELIKE&quot;</span> is the more generic version of
  <span class="Li">&quot;_CODE&quot;</span>. Unlike
  <span class="Li">&quot;_CODE&quot;</span>, which checks for an explicit
  <span class="Li">&quot;CODE&quot;</span> reference, the
  <span class="Li">&quot;_CODELIKE&quot;</span> function also includes things
  that act like them, such as blessed objects that overload
  <span class="Li">'&amp;{}'</span>.
<p class="Pp">Please note that in the case of objects overloaded with '&amp;{}',
    you will almost always end up also testing it in 'bool' context at some
    stage.</p>
<p class="Pp">For example:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  sub foo {
      my $code1 = _CODELIKE(shift) or die &quot;No code param provided&quot;;
      my $code2 = _CODELIKE(shift);
      if ( $code2 ) {
           print &quot;Got optional second code param&quot;;
      }
  }
</pre>
<p class="Pp">As such, you will most likely always want to make sure your class
    has at least the following to allow it to evaluate to true in boolean
    context.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  # Always evaluate to true in boolean context
  use overload 'bool' =&gt; sub () { 1 };
</pre>
<p class="Pp">Returns the callable value as a convenience, or
    <span class="Li">&quot;undef&quot;</span> if the value provided is not
    callable.</p>
<p class="Pp">Note - This function was formerly known as _CALLABLE but has been
    renamed for greater symmetry with the other _XXXXLIKE functions.</p>
<p class="Pp">The use of _CALLABLE has been deprecated. It will continue to
    work, but with a warning, until end-2006, then will be removed.</p>
<p class="Pp">I apologise for any inconvenience caused.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_INVOCANT_$value"><a class="permalink" href="#_INVOCANT_$value">_INVOCANT
  $value</a></h2>
This routine tests whether the given value is a valid method invocant. This can
  be either an instance of an object, or a class name.
<p class="Pp">If so, the value itself is returned. Otherwise,
    <span class="Li">&quot;_INVOCANT&quot;</span> returns
    <span class="Li">&quot;undef&quot;</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_INSTANCE_$object,_$class"><a class="permalink" href="#_INSTANCE_$object,_$class">_INSTANCE
  $object, $class</a></h2>
The <span class="Li">&quot;_INSTANCE&quot;</span> function is intended to be
  imported into your package, and provides a convenient way to test for an
  object of a particular class in a strictly correct manner.
<p class="Pp">Returns the object itself as a convenience, or
    <span class="Li">&quot;undef&quot;</span> if the value provided is not an
    object of that type.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_INSTANCEDOES_$object,_$role"><a class="permalink" href="#_INSTANCEDOES_$object,_$role">_INSTANCEDOES
  $object, $role</a></h2>
This routine behaves exactly like <span class="Li">&quot;_INSTANCE&quot;</span>,
  but checks with <span class="Li">&quot;-&gt;DOES&quot;</span> rather than
  <span class="Li">&quot;-&gt;isa&quot;</span>. This is probably only a good
  idea to use on Perl 5.10 or later, when UNIVERSAL::DOES has been implemented.
</section>
<section class="Ss">
<h2 class="Ss" id="_REGEX_$value"><a class="permalink" href="#_REGEX_$value">_REGEX
  $value</a></h2>
The <span class="Li">&quot;_REGEX&quot;</span> function is intended to be
  imported into your package, and provides a convenient way to test for a
  regular expression.
<p class="Pp">Returns the value itself as a convenience, or
    <span class="Li">&quot;undef&quot;</span> if the value provided is not a
    regular expression.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_SET__e@array,_$class"><a class="permalink" href="#_SET__e@array,_$class">_SET
  \@array, $class</a></h2>
The <span class="Li">&quot;_SET&quot;</span> function is intended to be imported
  into your package, and provides a convenient way to test for set of at least
  one object of a particular class in a strictly correct manner.
<p class="Pp">The set is provided as a reference to an
    <span class="Li">&quot;ARRAY&quot;</span> of objects of the class
  provided.</p>
<p class="Pp">For an alternative function that allows zero-length sets, see the
    <span class="Li">&quot;_SET0&quot;</span> function.</p>
<p class="Pp">Returns the <span class="Li">&quot;ARRAY&quot;</span> reference
    itself as a convenience, or <span class="Li">&quot;undef&quot;</span> if the
    value provided is not a set of that class.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_SET0__e@array,_$class"><a class="permalink" href="#_SET0__e@array,_$class">_SET0
  \@array, $class</a></h2>
The <span class="Li">&quot;_SET0&quot;</span> function is intended to be
  imported into your package, and provides a convenient way to test for a set of
  objects of a particular class in a strictly correct manner, allowing for zero
  objects.
<p class="Pp">The set is provided as a reference to an
    <span class="Li">&quot;ARRAY&quot;</span> of objects of the class
  provided.</p>
<p class="Pp">For an alternative function that requires at least one object, see
    the <span class="Li">&quot;_SET&quot;</span> function.</p>
<p class="Pp">Returns the <span class="Li">&quot;ARRAY&quot;</span> reference
    itself as a convenience, or <span class="Li">&quot;undef&quot;</span> if the
    value provided is not a set of that class.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_HANDLE"><a class="permalink" href="#_HANDLE">_HANDLE</a></h2>
The <span class="Li">&quot;_HANDLE&quot;</span> function is intended to be
  imported into your package, and provides a convenient way to test whether or
  not a single scalar value is a file handle.
<p class="Pp">Unfortunately, in Perl the definition of a file handle can be a
    little bit fuzzy, so this function is likely to be somewhat imperfect (at
    first anyway).</p>
<p class="Pp">That said, it is implement as well or better than the other file
    handle detectors in existance (and we stole from the best of them).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_DRIVER_$string"><a class="permalink" href="#_DRIVER_$string">_DRIVER
  $string</a></h2>
<span class="Li"></span>
<pre>
  sub foo {
    my $class = _DRIVER(shift, 'My::Driver::Base') or die &quot;Bad driver&quot;;
    ...
  }
</pre>
<p class="Pp">The <span class="Li">&quot;_DRIVER&quot;</span> function is
    intended to be imported into your package, and provides a convenient way to
    load and validate a driver class.</p>
<p class="Pp">The most common pattern when taking a driver class as a parameter
    is to check that the name is a class (i.e. check against _CLASS) and then to
    load the class (if it exists) and then ensure that the class returns true
    for the isa method on some base driver name.</p>
<p class="Pp">Return the value as a convenience, or
    <span class="Li">&quot;undef&quot;</span> if the value is not a class name,
    the module does not exist, the module does not load, or the class fails the
    isa test.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="TO_DO"><a class="permalink" href="#TO_DO">TO DO</a></h1>
- Add _CAN to help resolve the UNIVERSAL::can debacle
<p class="Pp">- Would be even nicer if someone would demonstrate how the hell to
    build a Module::Install dist of the ::Util dual Perl/XS type. :/</p>
<p class="Pp">- Implement an assertion-like version of this module, that dies on
    error.</p>
<p class="Pp">- Implement a Test:: version of this module, for use in
  testing</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SUPPORT"><a class="permalink" href="#SUPPORT">SUPPORT</a></h1>
Bugs should be reported via the CPAN bug tracker at
<p class="Pp">&lt;http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Params-Util&gt;</p>
<p class="Pp">For other issues, contact the author.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
Adam Kennedy &lt;adamk@cpan.org&gt;
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
Params::Validate
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT"><a class="permalink" href="#COPYRIGHT">COPYRIGHT</a></h1>
Copyright 2005 - 2012 Adam Kennedy.
<p class="Pp">This program is free software; you can redistribute it and/or
    modify it under the same terms as Perl itself.</p>
<p class="Pp">The full text of the license can be found in the LICENSE file
    included with this module.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2012-03-11</td>
    <td class="foot-os">perl v5.28.2</td>
  </tr>
</table>
</body>
</html>
