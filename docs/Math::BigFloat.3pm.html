<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>Math::BigFloat(3pm)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Math::BigFloat(3pm)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">Math::BigFloat(3pm)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
Math::BigFloat - Arbitrary size floating point math package
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<span class="Li"></span>
<pre>
 use Math::BigFloat;

 # Number creation
 my $x = Math::BigFloat-&gt;new($str);     # defaults to 0
 my $y = $x-&gt;copy();                    # make a true copy
 my $nan  = Math::BigFloat-&gt;bnan();     # create a NotANumber
 my $zero = Math::BigFloat-&gt;bzero();    # create a +0
 my $inf = Math::BigFloat-&gt;binf();      # create a +inf
 my $inf = Math::BigFloat-&gt;binf('-');   # create a -inf
 my $one = Math::BigFloat-&gt;bone();      # create a +1
 my $mone = Math::BigFloat-&gt;bone('-');  # create a -1

 my $pi = Math::BigFloat-&gt;bpi(100);     # PI to 100 digits

 # the following examples compute their result to 100 digits accuracy:
 my $cos  = Math::BigFloat-&gt;new(1)-&gt;bcos(100);        # cosinus(1)
 my $sin  = Math::BigFloat-&gt;new(1)-&gt;bsin(100);        # sinus(1)
 my $atan = Math::BigFloat-&gt;new(1)-&gt;batan(100);       # arcus tangens(1)

 my $atan2 = Math::BigFloat-&gt;new(  1 )-&gt;batan2( 1 ,100); # batan(1)
 my $atan2 = Math::BigFloat-&gt;new(  1 )-&gt;batan2( 8 ,100); # batan(1/8)
 my $atan2 = Math::BigFloat-&gt;new( -2 )-&gt;batan2( 1 ,100); # batan(-2)

 # Testing
 $x-&gt;is_zero();          # true if arg is +0
 $x-&gt;is_nan();           # true if arg is NaN
 $x-&gt;is_one();           # true if arg is +1
 $x-&gt;is_one('-');        # true if arg is -1
 $x-&gt;is_odd();           # true if odd, false for even
 $x-&gt;is_even();          # true if even, false for odd
 $x-&gt;is_pos();           # true if &gt;= 0
 $x-&gt;is_neg();           # true if &lt;  0
 $x-&gt;is_inf(sign);       # true if +inf, or -inf (default is '+')

 $x-&gt;bcmp($y);           # compare numbers (undef,&lt;0,=0,&gt;0)
 $x-&gt;bacmp($y);          # compare absolutely (undef,&lt;0,=0,&gt;0)
 $x-&gt;sign();             # return the sign, either +,- or NaN
 $x-&gt;digit($n);          # return the nth digit, counting from right
 $x-&gt;digit(-$n);         # return the nth digit, counting from left 

 # The following all modify their first argument. If you want to pre-
 # serve $x, use $z = $x-&gt;copy()-&gt;bXXX($y); See under L&lt;/CAVEATS&gt; for
 # necessary when mixing $a = $b assignments with non-overloaded math.

 # set 
 $x-&gt;bzero();            # set $i to 0
 $x-&gt;bnan();             # set $i to NaN
 $x-&gt;bone();             # set $x to +1
 $x-&gt;bone('-');          # set $x to -1
 $x-&gt;binf();             # set $x to inf
 $x-&gt;binf('-');          # set $x to -inf

 $x-&gt;bneg();             # negation
 $x-&gt;babs();             # absolute value
 $x-&gt;bnorm();            # normalize (no-op)
 $x-&gt;bnot();             # two's complement (bit wise not)
 $x-&gt;binc();             # increment x by 1
 $x-&gt;bdec();             # decrement x by 1

 $x-&gt;badd($y);           # addition (add $y to $x)
 $x-&gt;bsub($y);           # subtraction (subtract $y from $x)
 $x-&gt;bmul($y);           # multiplication (multiply $x by $y)
 $x-&gt;bdiv($y);           # divide, set $x to quotient
                         # return (quo,rem) or quo if scalar

 $x-&gt;bmod($y);           # modulus ($x % $y)
 $x-&gt;bpow($y);           # power of arguments ($x ** $y)
 $x-&gt;bmodpow($exp,$mod); # modular exponentiation (($num**$exp) % $mod))
 $x-&gt;blsft($y, $n);      # left shift by $y places in base $n
 $x-&gt;brsft($y, $n);      # right shift by $y places in base $n
                         # returns (quo,rem) or quo if in scalar context

 $x-&gt;blog();             # logarithm of $x to base e (Euler's number)
 $x-&gt;blog($base);        # logarithm of $x to base $base (f.i. 2)
 $x-&gt;bexp();             # calculate e ** $x where e is Euler's number

 $x-&gt;band($y);           # bit-wise and
 $x-&gt;bior($y);           # bit-wise inclusive or
 $x-&gt;bxor($y);           # bit-wise exclusive or
 $x-&gt;bnot();             # bit-wise not (two's complement)

 $x-&gt;bsqrt();            # calculate square-root
 $x-&gt;broot($y);          # $y'th root of $x (e.g. $y == 3 =&gt; cubic root)
 $x-&gt;bfac();             # factorial of $x (1*2*3*4*..$x)

 $x-&gt;bround($N);         # accuracy: preserve $N digits
 $x-&gt;bfround($N);        # precision: round to the $Nth digit

 $x-&gt;bfloor();           # return integer less or equal than $x
 $x-&gt;bceil();            # return integer greater or equal than $x

  # The following do not modify their arguments:

 bgcd(@values);          # greatest common divisor
 blcm(@values);          # lowest common multiplicator

 $x-&gt;bstr();             # return string
 $x-&gt;bsstr();            # return string in scientific notation

 $x-&gt;as_int();           # return $x as BigInt 
 $x-&gt;exponent();         # return exponent as BigInt
 $x-&gt;mantissa();         # return mantissa as BigInt
 $x-&gt;parts();            # return (mantissa,exponent) as BigInt

 $x-&gt;length();           # number of digits (w/o sign and '.')
 ($l,$f) = $x-&gt;length(); # number of digits, and length of fraction

 $x-&gt;precision();        # return P of $x (or global, if P of $x undef)
 $x-&gt;precision($n);      # set P of $x to $n
 $x-&gt;accuracy();         # return A of $x (or global, if A of $x undef)
 $x-&gt;accuracy($n);       # set A $x to $n

 # these get/set the appropriate global value for all BigFloat objects
 Math::BigFloat-&gt;precision();   # Precision
 Math::BigFloat-&gt;accuracy();    # Accuracy
 Math::BigFloat-&gt;round_mode();  # rounding mode
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
All operators (including basic math operations) are overloaded if you declare
  your big floating point numbers as
<p class="Pp"><span class="Li"></span></p>
<pre>
  $i = new Math::BigFloat '12_3.456_789_123_456_789E-2';
</pre>
<p class="Pp">Operations with overloaded operators preserve the arguments, which
    is exactly what you expect.</p>
<section class="Ss">
<h2 class="Ss" id="Canonical_notation"><a class="permalink" href="#Canonical_notation">Canonical
  notation</a></h2>
Input to these routines are either BigFloat objects, or strings of the following
  four forms:
<ul class="Bl-bullet">
  <li><span class="Li">&quot;/^[+-]\d+$/&quot;</span></li>
  <li><span class="Li">&quot;/^[+-]\d+\.\d*$/&quot;</span></li>
  <li><span class="Li">&quot;/^[+-]\d+E[+-]?\d+$/&quot;</span></li>
  <li><span class="Li">&quot;/^[+-]\d*\.\d+E[+-]?\d+$/&quot;</span></li>
</ul>
<p class="Pp">all with optional leading and trailing zeros and/or spaces.
    Additionally, numbers are allowed to have an underscore between any two
    digits.</p>
<p class="Pp">Empty strings as well as other illegal numbers results in
  'NaN'.</p>
<p class="Pp"><i>bnorm()</i> on a BigFloat object is now effectively a no-op,
    since the numbers are always stored in normalized form. On a string, it
    creates a BigFloat object.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Output"><a class="permalink" href="#Output">Output</a></h2>
Output values are BigFloat objects (normalized), except for <i>bstr()</i> and
  <i>bsstr()</i>.
<p class="Pp">The string output will always have leading and trailing zeros
    stripped and drop a plus sign. <span class="Li">&quot;bstr()&quot;</span>
    will give you always the form with a decimal point, while
    <span class="Li">&quot;bsstr()&quot;</span> (s for scientific) gives you the
    scientific notation.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
        Input                   bstr()          bsstr()
        '-0'                    '0'             '0E1'
        '  -123 123 123'        '-123123123'    '-123123123E0'
        '00.0123'               '0.0123'        '123E-4'
        '123.45E-2'             '1.2345'        '12345E-4'
        '10E+3'                 '10000'         '1E4'
</pre>
<p class="Pp">Some routines (<span class="Li">&quot;is_odd()&quot;</span>,
    <span class="Li">&quot;is_even()&quot;</span>,
    <span class="Li">&quot;is_zero()&quot;</span>,
    <span class="Li">&quot;is_one()&quot;</span>,
    <span class="Li">&quot;is_nan()&quot;</span>) return true or false, while
    others (<span class="Li">&quot;bcmp()&quot;</span>,
    <span class="Li">&quot;bacmp()&quot;</span>) return either undef, &lt;0, 0
    or &gt;0 and are suited for sort.</p>
<p class="Pp">Actual math is done by using the class defined with
    <span class="Li">&quot;with =&gt; Class;&quot;</span> (which defaults to
    BigInts) to represent the mantissa and exponent.</p>
<p class="Pp">The sign <span class="Li">&quot;/^[+-]$/&quot;</span> is stored
    separately. The string 'NaN' is used to represent the result when input
    arguments are not numbers, as well as the result of dividing by zero.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_mantissa()_,__exponent()__and__parts()_"><a class="permalink" href="#_mantissa()_,__exponent()__and__parts()_">&quot;mantissa()&quot;,
  &quot;exponent()&quot; and &quot;parts()&quot;</a></h2>
<span class="Li">&quot;mantissa()&quot;</span> and
  <span class="Li">&quot;exponent()&quot;</span> return the said parts of the
  BigFloat as BigInts such that:
<p class="Pp"><span class="Li"></span></p>
<pre>
        $m = $x-&gt;mantissa();
        $e = $x-&gt;exponent();
        $y = $m * ( 10 ** $e );
        print &quot;ok\n&quot; if $x == $y;
</pre>
<p class="Pp"><span class="Li">&quot;($m,$e) = $x-&gt;parts();&quot;</span> is
    just a shortcut giving you both of them.</p>
<p class="Pp">A zero is represented and returned as <span class="Li">0E1</span>,
    <b>not</b> <span class="Li">0E0</span> (after Knuth).</p>
<p class="Pp">Currently the mantissa is reduced as much as possible, favouring
    higher exponents over lower ones (e.g. returning 1e7 instead of 10e6 or
    10000000e0). This might change in the future, so do not depend on it.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Accuracy_vs._Precision"><a class="permalink" href="#Accuracy_vs._Precision">Accuracy
  vs. Precision</a></h2>
See also: Rounding.
<p class="Pp">Math::BigFloat supports both precision (rounding to a certain
    place before or after the dot) and accuracy (rounding to a certain number of
    digits). For a full documentation, examples and tips on these topics please
    see the large section about rounding in Math::BigInt.</p>
<p class="Pp">Since things like <span class="Li">sqrt(2)</span> or
    <span class="Li">&quot;1 / 3&quot;</span> must presented with a limited
    accuracy lest a operation consumes all resources, each operation produces no
    more than the requested number of digits.</p>
<p class="Pp">If there is no global precision or accuracy set, <b>and</b> the
    operation in question was not called with a requested precision or accuracy,
    <b>and</b> the input <span class="Li">$x</span> has no accuracy or precision
    set, then a fallback parameter will be used. For historical reasons, it is
    called <span class="Li">&quot;div_scale&quot;</span> and can be accessed
    via:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
        $d = Math::BigFloat-&gt;div_scale();       # query
        Math::BigFloat-&gt;div_scale($n);          # set to $n digits
</pre>
<p class="Pp">The default value for
    <span class="Li">&quot;div_scale&quot;</span> is 40.</p>
<p class="Pp">In case the result of one operation has more digits than
    specified, it is rounded. The rounding mode taken is either the default
    mode, or the one supplied to the operation after the <i>scale</i>:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    $x = Math::BigFloat-&gt;new(2);
    Math::BigFloat-&gt;accuracy(5);              # 5 digits max
    $y = $x-&gt;copy()-&gt;bdiv(3);                 # will give 0.66667
    $y = $x-&gt;copy()-&gt;bdiv(3,6);               # will give 0.666667
    $y = $x-&gt;copy()-&gt;bdiv(3,6,undef,'odd');   # will give 0.666667
    Math::BigFloat-&gt;round_mode('zero');
    $y = $x-&gt;copy()-&gt;bdiv(3,6);               # will also give 0.666667
</pre>
<p class="Pp">Note that
    <span class="Li">&quot;Math::BigFloat-&gt;accuracy()&quot;</span> and
    <span class="Li">&quot;Math::BigFloat-&gt;precision()&quot;</span> set the
    global variables, and thus <b>any</b> newly created number will be subject
    to the global rounding <b>immediately</b>. This means that in the examples
    above, the <span class="Li">3</span> as argument to
    <span class="Li">&quot;bdiv()&quot;</span> will also get an accuracy of
    <b>5</b>.</p>
<p class="Pp">It is less confusing to either calculate the result fully, and
    afterwards round it explicitly, or use the additional parameters to the math
    functions like so:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
        use Math::BigFloat;
        $x = Math::BigFloat-&gt;new(2);
        $y = $x-&gt;copy()-&gt;bdiv(3);
        print $y-&gt;bround(5),&quot;\n&quot;;               # will give 0.66667

        or

        use Math::BigFloat;
        $x = Math::BigFloat-&gt;new(2);
        $y = $x-&gt;copy()-&gt;bdiv(3,5);             # will give 0.66667
        print &quot;$y\n&quot;;
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Rounding"><a class="permalink" href="#Rounding">Rounding</a></h2>
<dl class="Bl-tag">
  <dt>ffround ( +$scale )</dt>
  <dd>Rounds to the <span class="Li">$scale</span>'th place left from the '.',
      counting from the dot. The first digit is numbered 1.</dd>
  <dt>ffround ( -$scale )</dt>
  <dd>Rounds to the <span class="Li">$scale</span>'th place right from the '.',
      counting from the dot.</dd>
  <dt>ffround ( 0 )</dt>
  <dd>Rounds to an integer.</dd>
  <dt>fround ( +$scale )</dt>
  <dd>Preserves accuracy to <span class="Li">$scale</span> digits from the left
      (aka significant digits) and pads the rest with zeros. If the number is
      between 1 and -1, the significant digits count from the first non-zero
      after the '.'</dd>
  <dt>fround ( -$scale ) and fround ( 0 )</dt>
  <dd>These are effectively no-ops.</dd>
</dl>
<p class="Pp">All rounding functions take as a second parameter a rounding mode
    from one of the following: 'even', 'odd', '+inf', '-inf', 'zero', 'trunc' or
    'common'.</p>
<p class="Pp">The default rounding mode is 'even'. By using
    <span class="Li">&quot;Math::BigFloat-&gt;round_mode($round_mode);&quot;</span>
    you can get and set the default mode for subsequent rounding. The usage of
    <span class="Li">&quot;$Math::BigFloat::$round_mode&quot;</span> is no
    longer supported. The second parameter to the round functions then overrides
    the default temporarily.</p>
<p class="Pp">The <span class="Li">&quot;as_number()&quot;</span> function
    returns a BigInt from a Math::BigFloat. It uses 'trunc' as rounding mode to
    make it equivalent to:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
        $x = 2.5;
        $y = int($x) + 2;
</pre>
<p class="Pp">You can override this by passing the desired rounding mode as
    parameter to <span class="Li">&quot;as_number()&quot;</span>:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
        $x = Math::BigFloat-&gt;new(2.5);
        $y = $x-&gt;as_number('odd');      # $y = 3
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="METHODS"><a class="permalink" href="#METHODS">METHODS</a></h1>
Math::BigFloat supports all methods that Math::BigInt supports, except it
  calculates non-integer results when possible. Please see Math::BigInt for a
  full description of each method. Below are just the most important
  differences:
<section class="Ss">
<h2 class="Ss" id="accuracy"><a class="permalink" href="#accuracy">accuracy</a></h2>
<span class="Li"></span>
<pre>
        $x-&gt;accuracy(5);             # local for $x
        CLASS-&gt;accuracy(5);          # global for all members of CLASS
                                     # Note: This also applies to new()!

        $A = $x-&gt;accuracy();         # read out accuracy that affects $x
        $A = CLASS-&gt;accuracy();      # read out global accuracy
</pre>
<p class="Pp">Set or get the global or local accuracy, aka how many significant
    digits the results have. If you set a global accuracy, then this also
    applies to <i>new()</i>!</p>
<p class="Pp">Warning! The accuracy <i>sticks</i>, e.g. once you created a
    number under the influence of
    <span class="Li">&quot;CLASS-&gt;accuracy($A)&quot;</span>, all results from
    math operations with that number will also be rounded.</p>
<p class="Pp">In most cases, you should probably round the results explicitly
    using one of &quot;<i>round()</i>&quot; in Math::BigInt,
    &quot;<i>bround()</i>&quot; in Math::BigInt or &quot;<i>bfround()</i>&quot;
    in Math::BigInt or by passing the desired accuracy to the math operation as
    additional parameter:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
        my $x = Math::BigInt-&gt;new(30000);
        my $y = Math::BigInt-&gt;new(7);
        print scalar $x-&gt;copy()-&gt;bdiv($y, 2);           # print 4300
        print scalar $x-&gt;copy()-&gt;bdiv($y)-&gt;bround(2);   # print 4300
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="_fIprecision()_fP"><a class="permalink" href="#_fIprecision()_fP"><i>precision()</i></a></h2>
<span class="Li"></span>
<pre>
        $x-&gt;precision(-2);      # local for $x, round at the second
                                # digit right of the dot
        $x-&gt;precision(2);       # ditto, round at the second digit left
                                # of the dot

        CLASS-&gt;precision(5);    # Global for all members of CLASS
                                # This also applies to new()!
        CLASS-&gt;precision(-5);   # ditto

        $P = CLASS-&gt;precision();    # read out global precision
        $P = $x-&gt;precision();       # read out precision that affects $x
</pre>
<p class="Pp">Note: You probably want to use &quot;accuracy&quot; instead. With
    &quot;accuracy&quot; you set the number of digits each result should have,
    with &quot;<i>precision()</i>&quot; you set the place where to round!</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_fIbexp()_fP"><a class="permalink" href="#_fIbexp()_fP"><i>bexp()</i></a></h2>
<span class="Li"></span>
<pre>
        $x-&gt;bexp($accuracy);            # calculate e ** X
</pre>
<p class="Pp">Calculates the expression <span class="Li">&quot;e **
    $x&quot;</span> where <span class="Li">&quot;e&quot;</span> is Euler's
    number.</p>
<p class="Pp">This method was added in v1.82 of Math::BigInt (April 2007).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_fIbnok()_fP"><a class="permalink" href="#_fIbnok()_fP"><i>bnok()</i></a></h2>
<span class="Li"></span>
<pre>
        $x-&gt;bnok($y);   # x over y (binomial coefficient n over k)
</pre>
<p class="Pp">Calculates the binomial coefficient n over k, also called the
    &quot;choose&quot; function. The result is equivalent to:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
        ( n )      n!
        | - |  = -------
        ( k )    k!(n-k)!
</pre>
<p class="Pp">This method was added in v1.84 of Math::BigInt (April 2007).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_fIbpi()_fP"><a class="permalink" href="#_fIbpi()_fP"><i>bpi()</i></a></h2>
<span class="Li"></span>
<pre>
        print Math::BigFloat-&gt;bpi(100), &quot;\n&quot;;
</pre>
<p class="Pp">Calculate PI to N digits (including the 3 before the dot). The
    result is rounded according to the current rounding mode, which defaults to
    &quot;even&quot;.</p>
<p class="Pp">This method was added in v1.87 of Math::BigInt (June 2007).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_fIbcos()_fP"><a class="permalink" href="#_fIbcos()_fP"><i>bcos()</i></a></h2>
<span class="Li"></span>
<pre>
        my $x = Math::BigFloat-&gt;new(1);
        print $x-&gt;bcos(100), &quot;\n&quot;;
</pre>
<p class="Pp">Calculate the cosinus of <span class="Li">$x</span>, modifying
    <span class="Li">$x</span> in place.</p>
<p class="Pp">This method was added in v1.87 of Math::BigInt (June 2007).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_fIbsin()_fP"><a class="permalink" href="#_fIbsin()_fP"><i>bsin()</i></a></h2>
<span class="Li"></span>
<pre>
        my $x = Math::BigFloat-&gt;new(1);
        print $x-&gt;bsin(100), &quot;\n&quot;;
</pre>
<p class="Pp">Calculate the sinus of <span class="Li">$x</span>, modifying
    <span class="Li">$x</span> in place.</p>
<p class="Pp">This method was added in v1.87 of Math::BigInt (June 2007).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_fIbatan2()_fP"><a class="permalink" href="#_fIbatan2()_fP"><i>batan2()</i></a></h2>
<span class="Li"></span>
<pre>
        my $y = Math::BigFloat-&gt;new(2);
        my $x = Math::BigFloat-&gt;new(3);
        print $y-&gt;batan2($x), &quot;\n&quot;;
</pre>
<p class="Pp">Calculate the arcus tanges of <span class="Li">$y</span> divided
    by <span class="Li">$x</span>, modifying <span class="Li">$y</span> in
    place. See also &quot;<i>batan()</i>&quot;.</p>
<p class="Pp">This method was added in v1.87 of Math::BigInt (June 2007).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_fIbatan()_fP"><a class="permalink" href="#_fIbatan()_fP"><i>batan()</i></a></h2>
<span class="Li"></span>
<pre>
        my $x = Math::BigFloat-&gt;new(1);
        print $x-&gt;batan(100), &quot;\n&quot;;
</pre>
<p class="Pp">Calculate the arcus tanges of <span class="Li">$x</span>,
    modifying <span class="Li">$x</span> in place. See also
    &quot;<i>batan2()</i>&quot;.</p>
<p class="Pp">This method was added in v1.87 of Math::BigInt (June 2007).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_fIbmuladd()_fP"><a class="permalink" href="#_fIbmuladd()_fP"><i>bmuladd()</i></a></h2>
<span class="Li"></span>
<pre>
        $x-&gt;bmuladd($y,$z);
</pre>
<p class="Pp">Multiply <span class="Li">$x</span> by <span class="Li">$y</span>,
    and then add <span class="Li">$z</span> to the result.</p>
<p class="Pp">This method was added in v1.87 of Math::BigInt (June 2007).</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="Autocreating_constants"><a class="permalink" href="#Autocreating_constants">Autocreating
  constants</a></h1>
After <span class="Li">&quot;use Math::BigFloat ':constant'&quot;</span> all the
  floating point constants in the given scope are converted to
  <span class="Li">&quot;Math::BigFloat&quot;</span>. This conversion happens at
  compile time.
<p class="Pp">In particular</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  perl -MMath::BigFloat=:constant -e 'print 2E-100,&quot;\n&quot;'
</pre>
<p class="Pp">prints the value of <span class="Li">&quot;2E-100&quot;</span>.
    Note that without conversion of constants the expression 2E-100 will be
    calculated as normal floating point number.</p>
<p class="Pp">Please note that ':constant' does not affect integer constants,
    nor binary nor hexadecimal constants. Use bignum or Math::BigInt to get this
    to work.</p>
<section class="Ss">
<h2 class="Ss" id="Math_library"><a class="permalink" href="#Math_library">Math
  library</a></h2>
Math with the numbers is done (by default) by a module called
  Math::BigInt::Calc. This is equivalent to saying:
<p class="Pp"><span class="Li"></span></p>
<pre>
        use Math::BigFloat lib =&gt; 'Calc';
</pre>
<p class="Pp">You can change this by using:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
        use Math::BigFloat lib =&gt; 'GMP';
</pre>
<p class="Pp"><b>Note</b>: General purpose packages should not be explicit about
    the library to use; let the script author decide which is best.</p>
<p class="Pp">Note: The keyword 'lib' will warn when the requested library could
    not be loaded. To suppress the warning use 'try' instead:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
        use Math::BigFloat try =&gt; 'GMP';
</pre>
<p class="Pp">If your script works with huge numbers and Calc is too slow for
    them, you can also for the loading of one of these libraries and if none of
    them can be used, the code will die:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
        use Math::BigFloat only =&gt; 'GMP,Pari';
</pre>
<p class="Pp">The following would first try to find Math::BigInt::Foo, then
    Math::BigInt::Bar, and when this also fails, revert to
  Math::BigInt::Calc:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
        use Math::BigFloat lib =&gt; 'Foo,Math::BigInt::Bar';
</pre>
<p class="Pp">See the respective low-level library documentation for further
    details.</p>
<p class="Pp">Please note that Math::BigFloat does <b>not</b> use the denoted
    library itself, but it merely passes the lib argument to Math::BigInt. So,
    instead of the need to do:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
        use Math::BigInt lib =&gt; 'GMP';
        use Math::BigFloat;
</pre>
<p class="Pp">you can roll it all into one line:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
        use Math::BigFloat lib =&gt; 'GMP';
</pre>
<p class="Pp">It is also possible to just require Math::BigFloat:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
        require Math::BigFloat;
</pre>
<p class="Pp">This will load the necessary things (like BigInt) when they are
    needed, and automatically.</p>
<p class="Pp">See Math::BigInt for more details than you ever wanted to know
    about using a different low-level library.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Using_Math::BigInt::Lite"><a class="permalink" href="#Using_Math::BigInt::Lite">Using
  Math::BigInt::Lite</a></h2>
For backwards compatibility reasons it is still possible to request a different
  storage class for use with Math::BigFloat:
<p class="Pp"><span class="Li"></span></p>
<pre>
        use Math::BigFloat with =&gt; 'Math::BigInt::Lite';
</pre>
<p class="Pp">However, this request is ignored, as the current code now uses the
    low-level math library for directly storing the number parts.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="EXPORTS"><a class="permalink" href="#EXPORTS">EXPORTS</a></h1>
<span class="Li">&quot;Math::BigFloat&quot;</span> exports nothing by default,
  but can export the <span class="Li">&quot;bpi()&quot;</span> method:
<p class="Pp"><span class="Li"></span></p>
<pre>
        use Math::BigFloat qw/bpi/;

        print bpi(10), &quot;\n&quot;;
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="BUGS"><a class="permalink" href="#BUGS">BUGS</a></h1>
Please see the file BUGS in the CPAN distribution Math::BigInt for known bugs.
</section>
<section class="Sh">
<h1 class="Sh" id="CAVEATS"><a class="permalink" href="#CAVEATS">CAVEATS</a></h1>
Do not try to be clever to insert some operations in between switching
  libraries:
<p class="Pp"><span class="Li"></span></p>
<pre>
    require Math::BigFloat;
    my $matter = Math::BigFloat-&gt;bone() + 4;    # load BigInt and Calc
    Math::BigFloat-&gt;import( lib =&gt; 'Pari' );    # load Pari, too
    my $anti_matter = Math::BigFloat-&gt;bone()+4; # now use Pari
</pre>
<p class="Pp">This will create objects with numbers stored in two different
    backend libraries, and <b>VERY BAD THINGS</b> will happen when you use these
    together:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
        my $flash_and_bang = $matter + $anti_matter;    # Don't do this!
</pre>
<dl class="Bl-tag">
  <dt>stringify, <i>bstr()</i></dt>
  <dd>Both stringify and <i>bstr()</i> now drop the leading '+'. The old code
      would return '+1.23', the new returns '1.23'. See the documentation in
      Math::BigInt for reasoning and details.</dd>
  <dt>bdiv</dt>
  <dd>The following will probably not print what you expect:
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        print $c-&gt;bdiv(123.456),&quot;\n&quot;;
    </pre>
    <p class="Pp">It prints both quotient and remainder since print works in
        list context. Also, <i>bdiv()</i> will modify
        <span class="Li">$c</span>, so be careful. You probably want to use</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    print $c / 123.456,&quot;\n&quot;;
    print scalar $c-&gt;bdiv(123.456),&quot;\n&quot;;  # or if you want to modify $c
    </pre>
    <p class="Pp">instead.</p>
  </dd>
  <dt>brsft</dt>
  <dd>The following will probably not print what you expect:
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        my $c = Math::BigFloat-&gt;new('3.14159');
        print $c-&gt;brsft(3,10),&quot;\n&quot;;     # prints 0.00314153.1415
    </pre>
    <p class="Pp">It prints both quotient and remainder, since print calls
        <span class="Li">&quot;brsft()&quot;</span> in list context. Also,
        <span class="Li">&quot;$c-&gt;brsft()&quot;</span> will modify
        <span class="Li">$c</span>, so be careful. You probably want to use</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        print scalar $c-&gt;copy()-&gt;brsft(3,10),&quot;\n&quot;;
        # or if you really want to modify $c
        print scalar $c-&gt;brsft(3,10),&quot;\n&quot;;
    </pre>
    <p class="Pp">instead.</p>
  </dd>
  <dt>Modifying and =</dt>
  <dd>Beware of:
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        $x = Math::BigFloat-&gt;new(5);
        $y = $x;
    </pre>
    <p class="Pp">It will not do what you think, e.g. making a copy of
        <span class="Li">$x</span>. Instead it just makes a second reference to
        the <b>same</b> object and stores it in <span class="Li">$y</span>. Thus
        anything that modifies <span class="Li">$x</span> will modify
        <span class="Li">$y</span> (except overloaded math operators), and vice
        versa. See Math::BigInt for details and how to avoid that.</p>
  </dd>
  <dt>bpow</dt>
  <dd><span class="Li">&quot;bpow()&quot;</span> now modifies the first
      argument, unlike the old code which left it alone and only returned the
      result. This is to be consistent with
      <span class="Li">&quot;badd()&quot;</span> etc. The first will modify
      <span class="Li">$x</span>, the second one won't:
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        print bpow($x,$i),&quot;\n&quot;;         # modify $x
        print $x-&gt;bpow($i),&quot;\n&quot;;        # ditto
        print $x ** $i,&quot;\n&quot;;            # leave $x alone
    </pre>
  </dd>
  <dt><i>precision()</i> vs. <i>accuracy()</i></dt>
  <dd>A common pitfall is to use &quot;<i>precision()</i>&quot; when you want to
      round a result to a certain number of digits:
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    use Math::BigFloat;

    Math::BigFloat-&gt;precision(4);            # does not do what you
                                             # think it does
    my $x = Math::BigFloat-&gt;new(12345);      # rounds $x to &quot;12000&quot;!
    print &quot;$x\n&quot;;                            # print &quot;12000&quot;
    my $y = Math::BigFloat-&gt;new(3);          # rounds $y to &quot;0&quot;!
    print &quot;$y\n&quot;;                            # print &quot;0&quot;
    $z = $x / $y;                            # 12000 / 0 =&gt; NaN!
    print &quot;$z\n&quot;;
    print $z-&gt;precision(),&quot;\n&quot;;              # 4
    </pre>
    <p class="Pp">Replacing &quot;<i>precision()</i>&quot; with
        &quot;accuracy&quot; is probably not what you want, either:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    use Math::BigFloat;

    Math::BigFloat-&gt;accuracy(4);             # enables global rounding:
    my $x = Math::BigFloat-&gt;new(123456);     # rounded immediately
                                             #   to &quot;12350&quot;
    print &quot;$x\n&quot;;                            # print &quot;123500&quot;
    my $y = Math::BigFloat-&gt;new(3);          # rounded to &quot;3
    print &quot;$y\n&quot;;                            # print &quot;3&quot;
    print $z = $x-&gt;copy()-&gt;bdiv($y),&quot;\n&quot;;    # 41170
    print $z-&gt;accuracy(),&quot;\n&quot;;               # 4
    </pre>
    <p class="Pp">What you want to use instead is:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    use Math::BigFloat;

    my $x = Math::BigFloat-&gt;new(123456);     # no rounding
    print &quot;$x\n&quot;;                            # print &quot;123456&quot;
    my $y = Math::BigFloat-&gt;new(3);          # no rounding
    print &quot;$y\n&quot;;                            # print &quot;3&quot;
    print $z = $x-&gt;copy()-&gt;bdiv($y,4),&quot;\n&quot;;  # 41150
    print $z-&gt;accuracy(),&quot;\n&quot;;               # undef
    </pre>
    <p class="Pp">In addition to computing what you expected, the last example
        also does <b>not</b> &quot;taint&quot; the result with an accuracy or
        precision setting, which would influence any further operation.</p>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
Math::BigInt, Math::BigRat and Math::Big as well as Math::BigInt::Pari and
  Math::BigInt::GMP.
<p class="Pp">The pragmas bignum, bigint and bigrat might also be of interest
    because they solve the autoupgrading/downgrading issue, at least partly.</p>
<p class="Pp">The package at &lt;http://search.cpan.org/~tels/Math-BigInt&gt;
    contains more documentation including a full version history, testcases,
    empty subclass files and benchmarks.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="LICENSE"><a class="permalink" href="#LICENSE">LICENSE</a></h1>
This program is free software; you may redistribute it and/or modify it under
  the same terms as Perl itself.
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHORS"><a class="permalink" href="#AUTHORS">AUTHORS</a></h1>
Mark Biggar, overloaded interface by Ilya Zakharevich. Completely rewritten by
  Tels &lt;http://bloodgate.com&gt; in 2001 - 2006, and still at it in 2007.
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2014-09-30</td>
    <td class="foot-os">perl v5.18.4</td>
  </tr>
</table>
</body>
</html>
