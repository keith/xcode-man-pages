<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Copyright (c) 2008-2016 Apple Inc.  All rights reserved.
  
   @APPLE_LICENSE_HEADER_START@
  
   This file contains Original Code and/or Modifications of Original Code
   as defined in and that are subject to the Apple Public Source License
   Version 2.0 (the 'License'). You may not use this file except in
   compliance with the License. Please obtain a copy of the License at
   http://www.opensource.apple.com/apsl/ and read it before using this
   file.
  
   The Original Code and all software distributed under the License are
   distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
   EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
   INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
   FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
   Please see the License for the specific language governing rights and
   limitations under the License.
  
   @APPLE_LICENSE_HEADER_END@
  
   Copyright (c) 2000 Jonathan Lemon
   All rights reserved.
  
   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions
   are met:
   1. Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
   2. Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
  
   THIS SOFTWARE IS PROVIDED ``AS IS'' AND
   ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
   ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
   FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
   DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
   OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
   HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
   LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
   OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
   SUCH DAMAGE.
  
   $FreeBSD: src/lib/libc/sys/kqueue.2,v 1.32 2002/12/19 09:40:25 ru Exp $
   -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    .Nd, .Bf, .Op { display: inline; }
    .Pa, .Ad { font-style: italic; }
    .Ms { font-weight: bold; }
    .Bl-diag > dt { font-weight: bold; }
    code.Nm, .Fl, .Cm, .Ic, code.In, .Fd, .Fn, .Cd { font-weight: bold;
      font-family: inherit; }
  </style>
  <title>KQUEUE(2)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">KQUEUE(2)</td>
    <td class="head-vol">System Calls Manual</td>
    <td class="head-rtitle">KQUEUE(2)</td>
  </tr>
</table>
<div class="manual-text">
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp"><code class="Nm">kqueue</code>, <code class="Nm">kevent</code>,
    <code class="Nm">kevent64</code> and <code class="Nm">kevent_qos</code>
    &#x2014; <span class="Nd">kernel event notification mechanism</span></p>
</section>
<section class="Sh">
<h1 class="Sh" id="LIBRARY"><a class="permalink" href="#LIBRARY">LIBRARY</a></h1>
<p class="Pp"><span class="Lb">Standard C&#x00A0;Library (libc, -lc)</span></p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<p class="Pp"><code class="In">#include
    &lt;<a class="In">sys/types.h</a>&gt;</code>
  <br/>
  <code class="In">#include &lt;<a class="In">sys/event.h</a>&gt;</code>
  <br/>
  <code class="In">#include &lt;<a class="In">sys/time.h</a>&gt;</code></p>
<p class="Pp"><var class="Ft">int</var>
  <br/>
  <code class="Fn">kqueue</code>(<var class="Fa" style="white-space: nowrap;">void</var>);</p>
<p class="Pp"><var class="Ft">int</var>
  <br/>
  <code class="Fn">kevent</code>(<var class="Fa" style="white-space: nowrap;">int
    kq</var>, <var class="Fa" style="white-space: nowrap;">const struct kevent
    *changelist</var>, <var class="Fa" style="white-space: nowrap;">int
    nchanges</var>, <var class="Fa" style="white-space: nowrap;">struct kevent
    *eventlist</var>, <var class="Fa" style="white-space: nowrap;">int
    nevents</var>, <var class="Fa" style="white-space: nowrap;">const struct
    timespec *timeout</var>);</p>
<p class="Pp"><var class="Ft">int</var>
  <br/>
  <code class="Fn">kevent64</code>(<var class="Fa" style="white-space: nowrap;">int
    kq</var>, <var class="Fa" style="white-space: nowrap;">const struct
    kevent64_s *changelist</var>,
    <var class="Fa" style="white-space: nowrap;">int nchanges</var>,
    <var class="Fa" style="white-space: nowrap;">struct kevent64_s
    *eventlist</var>, <var class="Fa" style="white-space: nowrap;">int
    nevents</var>, <var class="Fa" style="white-space: nowrap;">unsigned int
    flags</var>, <var class="Fa" style="white-space: nowrap;">const struct
    timespec *timeout</var>);</p>
<p class="Pp"><var class="Ft">int</var>
  <br/>
  <code class="Fn">kevent_qos</code>(<var class="Fa" style="white-space: nowrap;">int
    kq</var>, <var class="Fa" style="white-space: nowrap;">const struct
    kevent_qos_s *changelist</var>,
    <var class="Fa" style="white-space: nowrap;">int nchanges</var>,
    <var class="Fa" style="white-space: nowrap;">struct kevent_qos_s
    *eventlist</var>, <var class="Fa" style="white-space: nowrap;">int
    nevents</var>, <var class="Fa" style="white-space: nowrap;">void
    *data_out</var>, <var class="Fa" style="white-space: nowrap;">size_t
    *data_available</var>, <var class="Fa" style="white-space: nowrap;">unsigned
    int flags</var>);</p>
<p class="Pp"><code class="Fn">EV_SET</code>(<var class="Fa" style="white-space: nowrap;">&amp;kev</var>,
    <var class="Fa" style="white-space: nowrap;">ident</var>,
    <var class="Fa" style="white-space: nowrap;">filter</var>,
    <var class="Fa" style="white-space: nowrap;">flags</var>,
    <var class="Fa" style="white-space: nowrap;">fflags</var>,
    <var class="Fa" style="white-space: nowrap;">data</var>,
    <var class="Fa" style="white-space: nowrap;">udata</var>);</p>
<p class="Pp"><code class="Fn">EV_SET64</code>(<var class="Fa" style="white-space: nowrap;">&amp;kev</var>,
    <var class="Fa" style="white-space: nowrap;">ident</var>,
    <var class="Fa" style="white-space: nowrap;">filter</var>,
    <var class="Fa" style="white-space: nowrap;">flags</var>,
    <var class="Fa" style="white-space: nowrap;">fflags</var>,
    <var class="Fa" style="white-space: nowrap;">data</var>,
    <var class="Fa" style="white-space: nowrap;">udata</var>,
    <var class="Fa" style="white-space: nowrap;">ext[0]</var>,
    <var class="Fa" style="white-space: nowrap;">ext[1]</var>);</p>
<p class="Pp"><code class="Fn">EV_SET_QOS</code>(<var class="Fa" style="white-space: nowrap;">&amp;kev</var>,
    <var class="Fa" style="white-space: nowrap;">ident</var>,
    <var class="Fa" style="white-space: nowrap;">filter</var>,
    <var class="Fa" style="white-space: nowrap;">flags</var>,
    <var class="Fa" style="white-space: nowrap;">qos</var>,
    <var class="Fa" style="white-space: nowrap;">udata</var>,
    <var class="Fa" style="white-space: nowrap;">fflags</var>,
    <var class="Fa" style="white-space: nowrap;">xflags</var>,
    <var class="Fa" style="white-space: nowrap;">data</var>,
    <var class="Fa" style="white-space: nowrap;">ext[0]</var>,
    <var class="Fa" style="white-space: nowrap;">ext[1]</var>,
    <var class="Fa" style="white-space: nowrap;">ext[2]</var>,
    <var class="Fa" style="white-space: nowrap;">ext[3]</var>);</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">The
    <a class="permalink" href="#kqueue"><code class="Fn" id="kqueue">kqueue</code></a>()
    system call allocates a kqueue file descriptor. This file descriptor
    provides a generic method of notifying the user when a kernel event (kevent)
    happens or a condition holds, based on the results of small pieces of kernel
    code termed filters.</p>
<p class="Pp">A kevent is identified by an (ident, filter, and optional udata
    value) tuple. It specifies the interesting conditions to be notified about
    for that tuple. An (ident, filter, and optional udata value) tuple can only
    appear once in a given kqueue. Subsequent attempts to register the same
    tuple for a given kqueue will result in the replacement of the conditions
    being watched, not an addition. Whether the udata value is considered as
    part of the tuple is controlled by the EV_UDATA_SPECIFIC flag on the
  kevent.</p>
<p class="Pp">The filter identified in a kevent is executed upon the initial
    registration of that event in order to detect whether a preexisting
    condition is present, and is also executed whenever an event is passed to
    the filter for evaluation. If the filter determines that the condition
    should be reported, then the kevent is placed on the kqueue for the user to
    retrieve.</p>
<p class="Pp">The filter is also run when the user attempts to retrieve the
    kevent from the kqueue. If the filter indicates that the condition that
    triggered the event no longer holds, the kevent is removed from the kqueue
    and is not returned.</p>
<p class="Pp" id="close">Multiple events which trigger the filter do not result
    in multiple kevents being placed on the kqueue; instead, the filter will
    aggregate the events into a single struct kevent. Calling
    <a class="permalink" href="#close"><code class="Fn">close</code></a>() on a
    file descriptor will remove any kevents that reference the descriptor.</p>
<p class="Pp" id="kqueue~2">The
    <a class="permalink" href="#kqueue~2"><code class="Fn">kqueue</code></a>()
    system call creates a new kernel event queue and returns a descriptor. The
    queue is not inherited by a child created with
  <a class="Xr">fork(2)</a>.</p>
<p class="Pp" id="kevent,">The
    <a class="permalink" href="#kevent,"><code class="Fn">kevent,</code></a>()
    <code class="Fn">kevent64</code>() and
    <a class="permalink" href="#kevent_qos"><code class="Fn" id="kevent_qos">kevent_qos</code></a>()
    system calls are used to register events with the queue, and return any
    pending events to the user. The <var class="Fa">changelist</var> argument is
    a pointer to an array of <var class="Va">kevent,</var>
    <var class="Va">kevent64_s</var> or <var class="Va">kevent_qos_s</var>
    structures, as defined in
    &#x27E8;<span class="Pa">sys/event.h</span>&#x27E9;. All changes contained
    in the <var class="Fa">changelist</var> are applied before any pending
    events are read from the queue. The <var class="Fa">nchanges</var> argument
    gives the size of <var class="Fa">changelist</var>.</p>
<p class="Pp">The <var class="Fa">eventlist</var> argument is a pointer to an
    array of out <var class="Va">kevent,</var> <var class="Va">kevent64_s</var>
    or <var class="Va">kevent_qos_s</var> structures. The
    <var class="Fa">nevents</var> argument determines the size of
    <var class="Fa">eventlist</var>.</p>
<p class="Pp">The <var class="Fa">data_out</var> argument provides space for
    extra out data provided by specific filters. The
    <var class="Fa">data_available</var> argument's contents specified the space
    available in the data pool on input, and contains the amount still remaining
    on output. If the KEVENT_FLAG_STACK_DATA flag is specified on the system
    call, the data is allocated from the pool in stack order instead of typical
    heap order.</p>
<p class="Pp" id="kevent">If <var class="Fa">timeout</var> is a non-NULL
    pointer, it specifies a maximum interval to wait for an event, which will be
    interpreted as a struct timespec. If <var class="Fa">timeout</var> is a NULL
    pointer, both
    <a class="permalink" href="#kevent"><code class="Fn">kevent</code></a>() and
    <code class="Fn">kevent64</code>() wait indefinitely. To effect a poll, the
    <var class="Fa">flags</var> argument to <code class="Fn">kevent64</code>()
    or <code class="Fn">kevent_qos</code>() can include the
    KEVENT_FLAG_IMMEDIATE value to indicate an immediate timeout. Alternatively,
    the <var class="Fa">timeout</var> argument should be non-NULL, pointing to a
    zero-valued <var class="Va">timespec</var> structure. The same array may be
    used for the <var class="Fa">changelist</var> and
    <var class="Fa">eventlist</var>.</p>
<p class="Pp" id="EV_SET">The
    <a class="permalink" href="#EV_SET"><code class="Fn">EV_SET</code></a>()
    macro is provided for ease of initializing a <var class="Va">kevent</var>
    structure. Similarly,
    <a class="permalink" href="#EV_SET64"><code class="Fn" id="EV_SET64">EV_SET64</code></a>()
    initializes a <var class="Va">kevent64_s</var> structure and
    <a class="permalink" href="#EV_SET_QOS"><code class="Fn" id="EV_SET_QOS">EV_SET_QOS</code></a>()
    initializes a <var class="Va">kevent_qos_s</var> structure.</p>
<p class="Pp">The <var class="Va">kevent,</var> <var class="Va">kevent64_s</var>
    and <var class="Va">kevent_qos_s</var> structures are defined as:</p>
<div class="Bd Pp Li">
<pre>struct kevent {
	uintptr_t 	ident;		/* identifier for this event */
	int16_t		filter;		/* filter for event */
	uint16_t	flags;		/* general flags */
	uint32_t	fflags;		/* filter-specific flags */
	intptr_t  	data;		/* filter-specific data */
	void		*udata;		/* opaque user data identifier */
};

struct kevent64_s {
        uint64_t        ident;          /* identifier for this event */
	int16_t         filter;         /* filter for event */
	uint16_t        flags;          /* general flags */
	uint32_t        fflags;         /* filter-specific flags */
	int64_t         data;           /* filter-specific data */
	uint64_t        udata;          /* opaque user data identifier */
	uint64_t        ext[2];         /* filter-specific extensions */
};

struct kevent_qos_s {
        uint64_t        ident;          /* identifier for this event */
	int16_t         filter;         /* filter for event */
	uint16_t        flags;          /* general flags */
	uint32_t        qos;            /* quality of service when servicing event */
	uint64_t        udata;          /* opaque user data identifier */
	uint32_t        fflags;         /* filter-specific flags */
	uint32_t        xflags;         /* extra filter-specific flags */
	int64_t         data;           /* filter-specific data */
	uint64_t        ext[4];         /* filter-specific extensions */
};</pre>
</div>
<p class="Pp">----</p>
<p class="Pp">The fields of <var class="Fa">struct kevent,</var>
    <var class="Fa">struct kevent64_s</var> and <var class="Fa">struct
    kevent_qos_s</var> are:</p>
<dl class="Bl-tag">
  <dt>ident</dt>
  <dd>Value used to identify the source of the event. The exact interpretation
      is determined by the attached filter, but often is a file descriptor.</dd>
  <dt>filter</dt>
  <dd>Identifies the kernel filter used to process this event. The pre-defined
      system filters are described below.</dd>
  <dt>flags</dt>
  <dd>Actions to perform on the event.</dd>
  <dt>fflags</dt>
  <dd>Filter-specific flags.</dd>
  <dt>data</dt>
  <dd>Filter-specific data value.</dd>
  <dt>udata</dt>
  <dd>Opaque user-defined value passed through the kernel unchanged. It can
      optionally be part of the uniquing decision of the kevent system</dd>
</dl>
<p class="Pp">In addition, <var class="Fa">struct kevent64_s</var> contains:</p>
<dl class="Bl-tag">
  <dt>ext[2]</dt>
  <dd>This field stores extensions for the event's filter. What type of
      extension depends on what type of filter is being used.</dd>
</dl>
<p class="Pp">In addition, <var class="Fa">struct kevent_qos_s</var>
  contains:</p>
<dl class="Bl-tag">
  <dt>xflags</dt>
  <dd>Extra filter-specific flags.</dd>
  <dt>ext[4]</dt>
  <dd>The QoS variant provides twice as many extension values for
      filter-specific uses.</dd>
</dl>
<p class="Pp">----</p>
<p class="Pp">The <var class="Va">flags</var> field can contain the following
    values:</p>
<dl class="Bl-tag">
  <dt>EV_ADD</dt>
  <dd>Adds the event to the kqueue. Re-adding an existing event will modify the
      parameters of the original event, and not result in a duplicate entry.
      Adding an event automatically enables it, unless overridden by the
      EV_DISABLE flag.</dd>
  <dt id="kevent,~2">EV_ENABLE</dt>
  <dd>Permit
      <a class="permalink" href="#kevent,~2"><code class="Fn">kevent,</code></a>()
      <code class="Fn">kevent64</code>() and
      <a class="permalink" href="#kevent_qos~2"><code class="Fn" id="kevent_qos~2">kevent_qos</code></a>()
      to return the event if it is triggered.</dd>
  <dt>EV_DISABLE</dt>
  <dd>Disable the event so <code class="Fn">kevent,</code>()
      <code class="Fn">kevent64</code>() and
      <code class="Fn">kevent_qos</code>() will not return it. The filter itself
      is not disabled.</dd>
  <dt>EV_DELETE</dt>
  <dd>Removes the event from the kqueue. Events which are attached to file
      descriptors are automatically deleted on the last close of the
    descriptor.</dd>
  <dt>EV_RECEIPT</dt>
  <dd>This flag is useful for making bulk changes to a kqueue without draining
      any pending events. When passed as input, it forces EV_ERROR to always be
      returned. When a filter is successfully added, the
      <var class="Va">data</var> field will be zero.</dd>
  <dt>EV_ONESHOT</dt>
  <dd>Causes the event to return only the first occurrence of the filter being
      triggered. After the user retrieves the event from the kqueue, it is
      deleted.</dd>
  <dt>EV_CLEAR</dt>
  <dd>After the event is retrieved by the user, its state is reset. This is
      useful for filters which report state transitions instead of the current
      state. Note that some filters may automatically set this flag
    internally.</dd>
  <dt>EV_EOF</dt>
  <dd>Filters may set this flag to indicate filter-specific EOF condition.</dd>
  <dt>EV_OOBAND</dt>
  <dd>Read filter on socket may set this flag to indicate the presence of out of
      band data on the descriptor.</dd>
  <dt>EV_ERROR</dt>
  <dd>See <a class="Sx" href="#RETURN_VALUES">RETURN VALUES</a> below.</dd>
</dl>
<p class="Pp">----</p>
<p class="Pp">The predefined system filters are listed below. Arguments may be
    passed to and from the filter via the <var class="Va">data,</var>
    <var class="Va">fflags</var> and optionally <var class="Va">xflags</var>
    fields in the <var class="Va">kevent,</var> <var class="Va">kevent64_s</var>
    or <var class="Va">kevent_qos_s</var> structure.</p>
<dl class="Bl-tag">
  <dt>EVFILT_READ</dt>
  <dd>Takes a file descriptor as the identifier, and returns whenever there is
      data available to read. The behavior of the filter is slightly different
      depending on the descriptor type.
    <dl class="Bl-tag">
      <dt id="listen">Sockets</dt>
      <dd>Sockets which have previously been passed to
          <a class="permalink" href="#listen"><code class="Fn">listen</code></a>()
          return when there is an incoming connection pending.
          <var class="Va">data</var> contains the size of the listen backlog.
        <p class="Pp">Other socket descriptors return when there is data to be
            read, subject to the <code class="Dv">SO_RCVLOWAT</code> value of
            the socket buffer. This may be overridden with a per-filter low
            water mark at the time the filter is added by setting the NOTE_LOWAT
            flag in <var class="Va">fflags</var>, and specifying the new low
            water mark in <var class="Va">data</var>. The derived per filter low
            water mark value is, however, bounded by socket receive buffer's
            high and low water mark values. On return,
            <var class="Va">data</var> contains the number of bytes of protocol
            data available to read.</p>
        <p class="Pp">The presence of EV_OOBAND in <var class="Va">flags</var>,
            indicates the presence of out of band data on the socket
            <var class="Va">data</var> equal to the potential number of OOB
            bytes availble to read.</p>
        <p class="Pp">If the read direction of the socket has shutdown, then the
            filter also sets EV_EOF in <var class="Va">flags</var>, and returns
            the socket error (if any) in <var class="Va">fflags</var>. It is
            possible for EOF to be returned (indicating the connection is gone)
            while there is still data pending in the socket buffer.</p>
      </dd>
      <dt>Vnodes</dt>
      <dd>Returns when the file pointer is not at the end of file.
          <var class="Va">data</var> contains the offset from current position
          to end of file, and may be negative.</dd>
      <dt>Fifos, Pipes</dt>
      <dd>Returns when there is data to read; <var class="Va">data</var>
          contains the number of bytes available.
        <p class="Pp">When the last writer disconnects, the filter will set
            EV_EOF in <var class="Va">flags</var>. This may be cleared by
            passing in EV_CLEAR, at which point the filter will resume waiting
            for data to become available before returning.</p>
      </dd>
      <dt>Device nodes</dt>
      <dd>Returns when there is data to read from the device;
          <var class="Va">data</var> contains the number of bytes available. If
          the device does not support returning number of bytes, it will not
          allow the filter to be attached. However, if the NOTE_LOWAT flag is
          specified and the <var class="Va">data</var> field contains 1 on
          input, those devices will attach - but cannot be relied upon to
          provide an accurate count of bytes to be read on output.</dd>
    </dl>
  </dd>
  <dt id="EVFILT_EXCEPT"><a class="permalink" href="#EVFILT_EXCEPT"><code class="Dv">EVFILT_EXCEPT</code></a></dt>
  <dd>Takes a descriptor as the identifier, and returns whenever one of the
      specified exceptional conditions has occurred on the descriptor.
      Conditions are specified in <var class="Va">fflags</var>. Currently, this
      filter can be used to monitor the arrival of out-of-band data on a socket
      descriptor using the filter flag <code class="Dv">NOTE_OOB</code>.
    <p class="Pp">If the read direction of the socket has shutdown, then the
        filter also sets EV_EOF in <var class="Va">flags</var>, and returns the
        socket error (if any) in <var class="Va">fflags</var>.</p>
  </dd>
  <dt>EVFILT_WRITE</dt>
  <dd>Takes a file descriptor as the identifier, and returns whenever it is
      possible to write to the descriptor. For sockets, pipes and fifos,
      <var class="Va">data</var> will contain the amount of space remaining in
      the write buffer. The filter will set EV_EOF when the reader disconnects,
      and for the fifo case, this may be cleared by use of EV_CLEAR. Note that
      this filter is not supported for vnodes.
    <p class="Pp">For sockets, the low water mark and socket error handling is
        identical to the EVFILT_READ case.</p>
  </dd>
  <dt id="kevent64">EVFILT_AIO</dt>
  <dd>Events for this filter are not registered with
      <a class="permalink" href="#kevent64"><code class="Fn">kevent64</code></a>()
      directly but are registered via the <var class="Va">aio_sigevent</var>
      member of an asynchronous I/O request when it is scheduled via an
      asynchronous I/O system call such as
      <a class="permalink" href="#aio_read"><code class="Fn" id="aio_read">aio_read</code></a>().</dd>
  <dt>EVFILT_VNODE</dt>
  <dd>Takes a file descriptor as the identifier and the events to watch for in
      <var class="Va">fflags</var>, and returns when one or more of the
      requested events occurs on the descriptor. The events to monitor are:
    <dl class="Bl-tag">
      <dt id="unlink">NOTE_DELETE</dt>
      <dd>The
          <a class="permalink" href="#unlink"><code class="Fn">unlink</code></a>()
          system call was called on the file referenced by the descriptor.</dd>
      <dt>NOTE_WRITE</dt>
      <dd>A write occurred on the file referenced by the descriptor.</dd>
      <dt>NOTE_EXTEND</dt>
      <dd>The file referenced by the descriptor was extended.</dd>
      <dt>NOTE_ATTRIB</dt>
      <dd>The file referenced by the descriptor had its attributes changed.</dd>
      <dt>NOTE_LINK</dt>
      <dd>The link count on the file changed.</dd>
      <dt>NOTE_RENAME</dt>
      <dd>The file referenced by the descriptor was renamed.</dd>
      <dt>NOTE_REVOKE</dt>
      <dd>Access to the file was revoked via <a class="Xr">revoke(2)</a> or the
          underlying fileystem was unmounted.</dd>
      <dt>NOTE_FUNLOCK</dt>
      <dd>The file was unlocked by calling <a class="Xr">flock(2)</a> or
          <a class="Xr">close(2)</a></dd>
      <dt>NOTE_LEASE_DOWNGRADE</dt>
      <dd>A lease break to downgrade the lease to read lease is requested on the
          file referenced by the descriptor.</dd>
      <dt>NOTE_LEASE_RELEASE</dt>
      <dd>A lease break to release the lease is requested on the file or
          directory referenced by the descriptor.</dd>
    </dl>
    <p class="Pp">On return, <var class="Va">fflags</var> contains the
        filter-specific flags which are associated with the triggered events
        seen by this filter.</p>
  </dd>
  <dt>EVFILT_PROC</dt>
  <dd>Takes the process ID to monitor as the identifier and the events to watch
      for in <var class="Va">fflags</var>, and returns when the process performs
      one or more of the requested events. If a process can normally see another
      process, it can attach an event to it. The events to monitor are:
    <dl class="Bl-tag">
      <dt>NOTE_EXIT</dt>
      <dd>The process has exited.</dd>
      <dt>NOTE_EXITSTATUS</dt>
      <dd>The process has exited and its exit status is in filter specific data.
          Valid only on child processes and to be used along with
        NOTE_EXIT.</dd>
      <dt>NOTE_FORK</dt>
      <dd>The process created a child process via <a class="Xr">fork(2)</a> or
          similar call.</dd>
      <dt>NOTE_EXEC</dt>
      <dd>The process executed a new process via <a class="Xr">execve(2)</a> or
          similar call.</dd>
      <dt>NOTE_SIGNAL</dt>
      <dd>The process was sent a signal. Status can be checked via
          <a class="Xr">waitpid(2)</a> or similar call.</dd>
      <dt>NOTE_REAP</dt>
      <dd>The process was reaped by the parent via <a class="Xr">wait(2)</a> or
          similar call. Deprecated, use NOTE_EXIT.</dd>
    </dl>
    <p class="Pp">On return, <var class="Va">fflags</var> contains the events
        which triggered the filter.</p>
  </dd>
  <dt id="signal">EVFILT_SIGNAL</dt>
  <dd>Takes the signal number to monitor as the identifier and returns when the
      given signal is generated for the process. This coexists with the
      <a class="permalink" href="#signal"><code class="Fn">signal</code></a>()
      and
      <a class="permalink" href="#sigaction"><code class="Fn" id="sigaction">sigaction</code></a>()
      facilities, and has a lower precedence. Only signals sent to the process,
      not to a particular thread, will trigger the filter. The filter will
      record all attempts to deliver a signal to a process, even if the signal
      has been marked as SIG_IGN. Event notification happens before normal
      signal delivery processing. <var class="Va">data</var> returns the number
      of times the signal has been generated since the last call to
      <code class="Fn">kevent</code>(). This filter automatically sets the
      EV_CLEAR flag internally.</dd>
  <dt>EVFILT_MACHPORT</dt>
  <dd>Takes the name of a mach port, or port set, in <var class="Va">ident</var>
      and waits until a message is enqueued on the port or port set. When a
      message is detected, but not directly received by the kevent call, the
      name of the specific port where the message is enqueued is returned in
      <var class="Va">data</var>. If <var class="Va">fflags</var> contains
      MACH_RCV_MSG, the ext[0] and ext[1] flags are assumed to contain a pointer
      to the buffer where the message is to be received and the size of the
      receive buffer, respectively. If MACH_RCV_MSG is specifed, yet the buffer
      size in ext[1] is zero, The space for the buffer may be carved out of the
      data_out area provided to <code class="Fn">kevent_qos</code>() if there is
      enough space remaining there.</dd>
  <dt>EVFILT_TIMER</dt>
  <dd>Establishes an interval timer identified by <var class="Va">ident</var>
      where <var class="Va">data</var> specifies the timeout period (in
      milliseconds).
    <p class="Pp"><var class="Va">fflags</var> can include one of the following
        flags to specify a different unit:</p>
    <dl class="Bl-tag">
      <dt id="data">NOTE_SECONDS</dt>
      <dd><var class="Va">data</var> is in seconds</dd>
      <dt id="data~2">NOTE_USECONDS</dt>
      <dd><var class="Va">data</var> is in microseconds</dd>
      <dt id="data~3">NOTE_NSECONDS</dt>
      <dd><var class="Va">data</var> is in nanoseconds</dd>
      <dt id="data~4">NOTE_MACHTIME</dt>
      <dd><var class="Va">data</var> is in Mach absolute time units</dd>
    </dl>
    <p class="Pp" id="mach_absolute_time"><var class="Va">fflags</var> can also
        include <code class="Dv">NOTE_ABSOLUTE,</code> which establishes an
        <code class="Dv">EV_ONESHOT</code> timer with an absolute deadline
        instead of an interval. The absolute deadline is expressed in terms of
        <a class="Xr">gettimeofday(2)</a>. With
        <code class="Dv">NOTE_MACHTIME,</code> the deadline is expressed in
        terms of
        <a class="permalink" href="#mach_absolute_time"><code class="Fn">mach_absolute_time</code></a>().</p>
    <p class="Pp">The timer can be coalesced with other timers to save power.
        The following flags can be set in <var class="Va">fflags</var> to modify
        this behavior:</p>
    <dl class="Bl-tag">
      <dt>NOTE_CRITICAL</dt>
      <dd>override default power-saving techniques to more strictly respect the
          leeway value</dd>
      <dt>NOTE_BACKGROUND</dt>
      <dd>apply more power-saving techniques to coalesce this timer with other
          timers</dd>
      <dt id="ext_1_">NOTE_LEEWAY</dt>
      <dd><var class="Va">ext[1]</var> holds user-supplied slop in deadline for
          timer coalescing.</dd>
    </dl>
    <p class="Pp">The timer will be periodic unless
        <code class="Dv">EV_ONESHOT</code> is specified. On return,
        <var class="Va">data</var> contains the number of times the timeout has
        expired since the last arming or last delivery of the timer event.</p>
    <p class="Pp">This filter automatically sets the
        <code class="Dv">EV_CLEAR</code> flag.</p>
  </dd>
</dl>
<p class="Pp">----</p>
<p class="Pp" id="kevent64~2">In the <var class="Va">ext[2]</var> field of the
    <var class="Va">kevent64_s</var> struture, <var class="Va">ext[0]</var> is
    only used with the EVFILT_MACHPORT filter. With other filters,
    <var class="Va">ext[0]</var> is passed through
    <a class="permalink" href="#kevent64~2"><code class="Fn">kevent64</code></a>()
    much like <var class="Va">udata</var>. <var class="Va">ext[1]</var> can
    always be used like <var class="Va">udata</var>. For the use of ext[0], see
    the EVFILT_MACHPORT filter above.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="RETURN_VALUES"><a class="permalink" href="#RETURN_VALUES">RETURN
  VALUES</a></h1>
<p class="Pp">The <code class="Fn">kqueue</code>() system call creates a new
    kernel event queue and returns a file descriptor. If there was an error
    creating the kernel event queue, a value of -1 is returned and errno
  set.</p>
<p class="Pp">The <code class="Fn">kevent</code>(),
    <code class="Fn">kevent64</code>() and <code class="Fn">kevent_qos</code>()
    system calls return the number of events placed in the
    <var class="Fa">eventlist</var>, up to the value given by
    <var class="Fa">nevents</var>. If an error occurs while processing an
    element of the <var class="Fa">changelist</var> and there is enough room in
    the <var class="Fa">eventlist</var>, then the event will be placed in the
    <var class="Fa">eventlist</var> with <code class="Dv">EV_ERROR</code> set in
    <var class="Va">flags</var> and the system error in
    <var class="Va">data</var>. Otherwise, <code class="Dv">-1</code> will be
    returned, and <code class="Dv">errno</code> will be set to indicate the
    error condition. If the time limit expires, then
    <code class="Fn">kevent</code>(), <code class="Fn">kevent64</code>() and
    <code class="Fn">kevent_qos</code>() return 0.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="ERRORS"><a class="permalink" href="#ERRORS">ERRORS</a></h1>
<p class="Pp">The <code class="Fn">kqueue</code>() system call fails if:</p>
<dl class="Bl-tag">
  <dt id="ENOMEM">[<a class="permalink" href="#ENOMEM"><code class="Er">ENOMEM</code></a>]</dt>
  <dd>The kernel failed to allocate enough memory for the kernel queue.</dd>
  <dt id="EMFILE">[<a class="permalink" href="#EMFILE"><code class="Er">EMFILE</code></a>]</dt>
  <dd>The per-process descriptor table is full.</dd>
  <dt id="ENFILE">[<a class="permalink" href="#ENFILE"><code class="Er">ENFILE</code></a>]</dt>
  <dd>The system file table is full.</dd>
</dl>
<p class="Pp">The <code class="Fn">kevent</code>() and
    <code class="Fn">kevent64</code>() system calls fail if:</p>
<dl class="Bl-tag">
  <dt id="EACCES">[<a class="permalink" href="#EACCES"><code class="Er">EACCES</code></a>]</dt>
  <dd>The process does not have permission to register a filter.</dd>
  <dt id="EFAULT">[<a class="permalink" href="#EFAULT"><code class="Er">EFAULT</code></a>]</dt>
  <dd>There was an error reading or writing the <var class="Va">kevent</var> or
      <var class="Va">kevent64_s</var> structure.</dd>
  <dt id="EBADF">[<a class="permalink" href="#EBADF"><code class="Er">EBADF</code></a>]</dt>
  <dd>The specified descriptor is invalid.</dd>
  <dt id="EINTR">[<a class="permalink" href="#EINTR"><code class="Er">EINTR</code></a>]</dt>
  <dd>A signal was delivered before the timeout expired and before any events
      were placed on the kqueue for return.</dd>
  <dt id="EINVAL">[<a class="permalink" href="#EINVAL"><code class="Er">EINVAL</code></a>]</dt>
  <dd>The specified time limit or filter is invalid.</dd>
  <dt id="ENOENT">[<a class="permalink" href="#ENOENT"><code class="Er">ENOENT</code></a>]</dt>
  <dd>The event could not be found to be modified or deleted.</dd>
  <dt id="ENOMEM~2">[<a class="permalink" href="#ENOMEM~2"><code class="Er">ENOMEM</code></a>]</dt>
  <dd>No memory was available to register the event.</dd>
  <dt id="ESRCH">[<a class="permalink" href="#ESRCH"><code class="Er">ESRCH</code></a>]</dt>
  <dd>The specified process to attach to does not exist.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp"><a class="Xr">aio_error(2)</a>, <a class="Xr">aio_read(2)</a>,
    <a class="Xr">aio_return(2)</a>, <a class="Xr">read(2)</a>,
    <a class="Xr">select(2)</a>, <a class="Xr">sigaction(2)</a>,
    <a class="Xr">write(2)</a>, <a class="Xr">signal(3)</a></p>
</section>
<section class="Sh">
<h1 class="Sh" id="HISTORY"><a class="permalink" href="#HISTORY">HISTORY</a></h1>
<p class="Pp">The <code class="Fn">kqueue</code>() and
    <code class="Fn">kevent</code>() system calls first appeared in
    <span class="Ux">FreeBSD 4.1</span>.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHORS"><a class="permalink" href="#AUTHORS">AUTHORS</a></h1>
<p class="Pp">The <code class="Fn">kqueue</code>() system and this manual page
    were written by <span class="An">Jonathan Lemon</span>
    &#x27E8;jlemon@FreeBSD.org&#x27E9;.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="BUGS"><a class="permalink" href="#BUGS">BUGS</a></h1>
<p class="Pp">Not all filesystem types support kqueue-style notifications. And
    even some that do, like some remote filesystems, may only support a subset
    of the notification semantics described here.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">October 21, 2008</td>
    <td class="foot-os">Mac OS X 12</td>
  </tr>
</table>
</body>
</html>
