<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    .Nd, .Bf, .Op { display: inline; }
    .Pa, .Ad { font-style: italic; }
    .Ms { font-weight: bold; }
    .Bl-diag > dt { font-weight: bold; }
    code.Nm, .Fl, .Cm, .Ic, code.In, .Fd, .Fn, .Cd { font-weight: bold;
      font-family: inherit; }
  </style>
  <title>overload(3pm)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">overload(3pm)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">overload(3pm)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">overload - Package for overloading Perl operations</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>    package SomeThing;
    use overload
        '+' =&gt; \&amp;myadd,
        '-' =&gt; \&amp;mysub;
        # etc
    ...
    package main;
    $a = SomeThing-&gt;new( 57 );
    $b = 5 + $a;
    ...
    if (overload::Overloaded $b) {...}
    ...
    $strval = overload::StrVal $b;
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">This pragma allows overloading of Perl's operators for a class. To
    overload built-in functions, see &quot;Overriding Built-in Functions&quot;
    in perlsub instead.</p>
<section class="Ss">
<h2 class="Ss" id="Fundamentals"><a class="permalink" href="#Fundamentals">Fundamentals</a></h2>
<p class="Pp"><i>Declaration</i></p>
<p class="Pp">Arguments of the <span class="Li">&quot;use overload&quot;</span>
    directive are (key, value) pairs. For the full set of legal keys, see
    &quot;Overloadable Operations&quot; below.</p>
<p class="Pp">Operator implementations (the values) can be subroutines,
    references to subroutines, or anonymous subroutines - in other words,
    anything legal inside a <span class="Li">&quot;&amp;{ ... }&quot;</span>
    call. Values specified as strings are interpreted as method names. Thus</p>
<p class="Pp"></p>
<pre>    package Number;
    use overload
        &quot;-&quot; =&gt; &quot;minus&quot;,
        &quot;*=&quot; =&gt; \&amp;muas,
        '&quot;&quot;' =&gt; sub { ...; };
</pre>
<p class="Pp">declares that subtraction is to be implemented by method
    <span class="Li">&quot;minus()&quot;</span> in the class
    <span class="Li">&quot;Number&quot;</span> (or one of its base classes), and
    that the function <span class="Li">&quot;Number::muas()&quot;</span> is to
    be used for the assignment form of multiplication,
    <span class="Li">&quot;*=&quot;</span>. It also defines an anonymous
    subroutine to implement stringification: this is called whenever an object
    blessed into the package <span class="Li">&quot;Number&quot;</span> is used
    in a string context (this subroutine might, for example, return the number
    as a Roman numeral).</p>
<p class="Pp"><i>Calling Conventions and Magic Autogeneration</i></p>
<p class="Pp">The following sample implementation of
    <span class="Li">&quot;minus()&quot;</span> (which assumes that
    <span class="Li">&quot;Number&quot;</span> objects are simply blessed
    references to scalars) illustrates the calling conventions:</p>
<p class="Pp"></p>
<pre>    package Number;
    sub minus {
        my ($self, $other, $swap) = @_;
        my $result = $$self - $other;         # *
        $result = -$result if $swap;
        ref $result ? $result : bless \$result;
    }
    # * may recurse once - see table below
</pre>
<p class="Pp">Three arguments are passed to all subroutines specified in the
    <span class="Li">&quot;use overload&quot;</span> directive (with one
    exception - see &quot;nomethod&quot;). The first of these is the operand
    providing the overloaded operator implementation - in this case, the object
    whose <span class="Li">&quot;minus()&quot;</span> method is being
  called.</p>
<p class="Pp">The second argument is the other operand, or
    <span class="Li">&quot;undef&quot;</span> in the case of a unary
  operator.</p>
<p class="Pp">The third argument is set to TRUE if (and only if) the two
    operands have been swapped. Perl may do this to ensure that the first
    argument (<span class="Li">$self</span>) is an object implementing the
    overloaded operation, in line with general object calling conventions. For
    example, if <span class="Li">$x</span> and <span class="Li">$y</span> are
    <span class="Li">&quot;Number&quot;</span>s:</p>
<p class="Pp"></p>
<pre>    operation   |   generates a call to
    ============|======================
    $x - $y     |   minus($x, $y, '')
    $x - 7      |   minus($x, 7, '')
    7 - $x      |   minus($x, 7, 1)
</pre>
<p class="Pp">Perl may also use <span class="Li">&quot;minus()&quot;</span> to
    implement other operators which have not been specified in the
    <span class="Li">&quot;use overload&quot;</span> directive, according to the
    rules for &quot;Magic Autogeneration&quot; described later. For example, the
    <span class="Li">&quot;use overload&quot;</span> above declared no
    subroutine for any of the operators <span class="Li">&quot;--&quot;</span>,
    <span class="Li">&quot;neg&quot;</span> (the overload key for unary minus),
    or <span class="Li">&quot;-=&quot;</span>. Thus</p>
<p class="Pp"></p>
<pre>    operation   |   generates a call to
    ============|======================
    -$x         |   minus($x, 0, 1)
    $x--        |   minus($x, 1, undef)
    $x -= 3     |   minus($x, 3, undef)
</pre>
<p class="Pp">Note the <span class="Li">&quot;undef&quot;</span>s: where
    autogeneration results in the method for a standard operator which does not
    change either of its operands, such as
    <span class="Li">&quot;-&quot;</span>, being used to implement an operator
    which changes the operand (&quot;mutators&quot;: here,
    <span class="Li">&quot;--&quot;</span> and
    <span class="Li">&quot;-=&quot;</span>), Perl passes undef as the third
    argument. This still evaluates as FALSE, consistent with the fact that the
    operands have not been swapped, but gives the subroutine a chance to alter
    its behaviour in these cases.</p>
<p class="Pp">In all the above examples,
    <span class="Li">&quot;minus()&quot;</span> is required only to return the
    result of the subtraction: Perl takes care of the assignment to
    <span class="Li">$x</span>. In fact, such methods should <i>not</i> modify
    their operands, even if <span class="Li">&quot;undef&quot;</span> is passed
    as the third argument (see &quot;Overloadable Operations&quot;).</p>
<p class="Pp">The same is not true of implementations of
    <span class="Li">&quot;++&quot;</span> and
    <span class="Li">&quot;--&quot;</span>: these are expected to modify their
    operand. An appropriate implementation of
    <span class="Li">&quot;--&quot;</span> might look like</p>
<p class="Pp"></p>
<pre>    use overload '--' =&gt; &quot;decr&quot;,
        # ...
    sub decr { --${$_[0]}; }
</pre>
<p class="Pp"><i>Mathemagic, Mutators, and Copy Constructors</i></p>
<p class="Pp">The term 'mathemagic' describes the overloaded implementation of
    mathematical operators. Mathemagical operations raise an issue. Consider the
    code:</p>
<p class="Pp"></p>
<pre>    $a = $b;
    --$a;
</pre>
<p class="Pp">If <span class="Li">$a</span> and <span class="Li">$b</span> are
    scalars then after these statements</p>
<p class="Pp"></p>
<pre>    $a == $b - 1
</pre>
<p class="Pp">An object, however, is a reference to blessed data, so if
    <span class="Li">$a</span> and <span class="Li">$b</span> are objects then
    the assignment <span class="Li">&quot;$a = $b&quot;</span> copies only the
    reference, leaving <span class="Li">$a</span> and <span class="Li">$b</span>
    referring to the same object data. One might therefore expect the operation
    <span class="Li">&quot;--$a&quot;</span> to decrement
    <span class="Li">$b</span> as well as <span class="Li">$a</span>. However,
    this would not be consistent with how we expect the mathematical operators
    to work.</p>
<p class="Pp">Perl resolves this dilemma by transparently calling a copy
    constructor before calling a method defined to implement a mutator
    (<span class="Li">&quot;--&quot;</span>,
    <span class="Li">&quot;+=&quot;</span>, and so on.). In the above example,
    when Perl reaches the decrement statement, it makes a copy of the object
    data in <span class="Li">$a</span> and assigns to <span class="Li">$a</span>
    a reference to the copied data. Only then does it call
    <span class="Li">&quot;decr()&quot;</span>, which alters the copied data,
    leaving <span class="Li">$b</span> unchanged. Thus the object metaphor is
    preserved as far as possible, while mathemagical operations still work
    according to the arithmetic metaphor.</p>
<p class="Pp">Note: the preceding paragraph describes what happens when Perl
    autogenerates the copy constructor for an object based on a scalar. For
    other cases, see &quot;Copy Constructor&quot;.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Overloadable_Operations"><a class="permalink" href="#Overloadable_Operations">Overloadable
  Operations</a></h2>
<p class="Pp">The complete list of keys that can be specified in the
    <span class="Li">&quot;use overload&quot;</span> directive are given,
    separated by spaces, in the values of the hash
    <span class="Li">%overload::ops</span>:</p>
<p class="Pp"></p>
<pre> with_assign      =&gt; '+ - * / % ** &lt;&lt; &gt;&gt; x .',
 assign           =&gt; '+= -= *= /= %= **= &lt;&lt;= &gt;&gt;= x= .=',
 num_comparison   =&gt; '&lt; &lt;= &gt; &gt;= == !=',
 '3way_comparison'=&gt; '&lt;=&gt; cmp',
 str_comparison   =&gt; 'lt le gt ge eq ne',
 binary           =&gt; '&amp; &amp;= | |= ^ ^=',
 unary            =&gt; 'neg ! ~',
 mutators         =&gt; '++ --',
 func             =&gt; 'atan2 cos sin exp abs log sqrt int',
 conversion       =&gt; 'bool &quot;&quot; 0+ qr',
 iterators        =&gt; '&lt;&gt;',
 filetest         =&gt; '-X',
 dereferencing    =&gt; '${} @{} %{} &amp;{} *{}',
 matching         =&gt; '~~',
 special          =&gt; 'nomethod fallback ='
</pre>
<p class="Pp">Most of the overloadable operators map one-to-one to these keys.
    Exceptions, including additional overloadable operations not apparent from
    this hash, are included in the notes which follow.</p>
<p class="Pp">A warning is issued if an attempt is made to register an operator
    not found above.</p>
<ul class="Bl-bullet">
  <li><span class="Li">&quot;not&quot;</span>
    <p class="Pp">The operator <span class="Li">&quot;not&quot;</span> is not a
        valid key for <span class="Li">&quot;use overload&quot;</span>. However,
        if the operator <span class="Li">&quot;!&quot;</span> is overloaded then
        the same implementation will be used for
        <span class="Li">&quot;not&quot;</span> (since the two operators differ
        only in precedence).</p>
  </li>
  <li><span class="Li">&quot;neg&quot;</span>
    <p class="Pp">The key <span class="Li">&quot;neg&quot;</span> is used for
        unary minus to disambiguate it from binary
        <span class="Li">&quot;-&quot;</span>.</p>
  </li>
  <li><span class="Li">&quot;++&quot;</span>,
      <span class="Li">&quot;--&quot;</span>
    <p class="Pp">Assuming they are to behave analogously to Perl's
        <span class="Li">&quot;++&quot;</span> and
        <span class="Li">&quot;--&quot;</span>, overloaded implementations of
        these operators are required to mutate their operands.</p>
    <p class="Pp">No distinction is made between prefix and postfix forms of the
        increment and decrement operators: these differ only in the point at
        which Perl calls the associated subroutine when evaluating an
        expression.</p>
  </li>
  <li><i>Assignments</i>
    <p class="Pp"></p>
    <pre>    +=  -=  *=  /=  %=  **=  &lt;&lt;=  &gt;&gt;=  x=  .=
    &amp;=  |=  ^=
    </pre>
    <p class="Pp">Simple assignment is not overloadable (the
        <span class="Li">'='</span> key is used for the &quot;Copy
        Constructor&quot;). Perl does have a way to make assignments to an
        object do whatever you want, but this involves using <i>tie()</i>, not
        overload - see &quot;tie&quot; in perlfunc and the &quot;COOKBOOK&quot;
        examples below.</p>
    <p class="Pp">The subroutine for the assignment variant of an operator is
        required only to return the result of the operation. It is permitted to
        change the value of its operand (this is safe because Perl calls the
        copy constructor first), but this is optional since Perl assigns the
        returned value to the left-hand operand anyway.</p>
    <p class="Pp">An object that overloads an assignment operator does so only
        in respect of assignments to that object. In other words, Perl never
        calls the corresponding methods with the third argument (the
        &quot;swap&quot; argument) set to TRUE. For example, the operation</p>
    <p class="Pp"></p>
    <pre>    $a *= $b
    </pre>
    <p class="Pp">cannot lead to <span class="Li">$b</span>'s implementation of
        <span class="Li">&quot;*=&quot;</span> being called, even if
        <span class="Li">$a</span> is a scalar. (It can, however, generate a
        call to <span class="Li">$b</span>'s method for
        <span class="Li">&quot;*&quot;</span>).</p>
  </li>
  <li><i>Non-mutators with a mutator variant</i>
    <p class="Pp"></p>
    <pre>     +  -  *  /  %  **  &lt;&lt;  &gt;&gt;  x  .
     &amp;  |  ^
    </pre>
    <p class="Pp">As described above, Perl may call methods for operators like
        <span class="Li">&quot;+&quot;</span> and
        <span class="Li">&quot;&amp;&quot;</span> in the course of implementing
        missing operations like <span class="Li">&quot;++&quot;</span>,
        <span class="Li">&quot;+=&quot;</span>, and
        <span class="Li">&quot;&amp;=&quot;</span>. While these methods may
        detect this usage by testing the definedness of the third argument, they
        should in all cases avoid changing their operands. This is because Perl
        does not call the copy constructor before invoking these methods.</p>
  </li>
  <li><span class="Li">&quot;int&quot;</span>
    <p class="Pp">Traditionally, the Perl function
        <span class="Li">&quot;int&quot;</span> rounds to 0 (see &quot;int&quot;
        in perlfunc), and so for floating-point-like types one should follow the
        same semantic.</p>
  </li>
  <li><i>String, numeric, boolean, and regexp conversions</i>
    <p class="Pp"></p>
    <pre>    &quot;&quot;  0+  bool
    </pre>
    <p class="Pp">These conversions are invoked according to context as
        necessary. For example, the subroutine for
        <span class="Li">'&quot;&quot;'</span> (stringify) may be used where the
        overloaded object is passed as an argument to
        <span class="Li">&quot;print&quot;</span>, and that for
        <span class="Li">'bool'</span> where it is tested in the condition of a
        flow control statement (like <span class="Li">&quot;while&quot;</span>)
        or the ternary <span class="Li">&quot;?:&quot;</span> operation.</p>
    <p class="Pp">Of course, in contexts like, for example,
        <span class="Li">&quot;$obj + 1&quot;</span>, Perl will invoke
        <span class="Li">$obj</span>'s implementation of
        <span class="Li">&quot;+&quot;</span> rather than (in this example)
        converting <span class="Li">$obj</span> to a number using the numify
        method <span class="Li">'0+'</span> (an exception to this is when no
        method has been provided for <span class="Li">'+'</span> and
        &quot;fallback&quot; is set to TRUE).</p>
    <p class="Pp">The subroutines for <span class="Li">'&quot;&quot;'</span>,
        <span class="Li">'0+'</span>, and <span class="Li">'bool'</span> can
        return any arbitrary Perl value. If the corresponding operation for this
        value is overloaded too, the operation will be called again with this
        value.</p>
    <p class="Pp">As a special case if the overload returns the object itself
        then it will be used directly. An overloaded conversion returning the
        object is probably a bug, because you're likely to get something that
        looks like
        <span class="Li">&quot;YourPackage=HASH(0x8172b34)&quot;</span>.</p>
    <p class="Pp"></p>
    <pre>    qr
    </pre>
    <p class="Pp">The subroutine for <span class="Li">'qr'</span> is used
        wherever the object is interpolated into or used as a regexp, including
        when it appears on the RHS of a <span class="Li">&quot;=~&quot;</span>
        or <span class="Li">&quot;!~&quot;</span> operator.</p>
    <p class="Pp"><span class="Li">&quot;qr&quot;</span> must return a compiled
        regexp, or a ref to a compiled regexp (such as
        <span class="Li">&quot;qr//&quot;</span> returns), and any further
        overloading on the return value will be ignored.</p>
  </li>
  <li><i>Iteration</i>
    <p class="Pp">If <span class="Li">&quot;&lt;&gt;&quot;</span> is overloaded
        then the same implementation is used for both the <i>read-filehandle</i>
        syntax <span class="Li">&quot;&lt;$var&gt;&quot;</span> and
        <i>globbing</i> syntax
        <span class="Li">&quot;&lt;${var}&gt;&quot;</span>.</p>
  </li>
  <li><i>File tests</i>
    <p class="Pp">The key <span class="Li">'-X'</span> is used to specify a
        subroutine to handle all the filetest operators
        (<span class="Li">&quot;-f&quot;</span>,
        <span class="Li">&quot;-x&quot;</span>, and so on: see &quot;-X&quot; in
        perlfunc for the full list); it is not possible to overload any filetest
        operator individually. To distinguish them, the letter following the '-'
        is passed as the second argument (that is, in the slot that for binary
        operators is used to pass the second operand).</p>
    <p class="Pp">Calling an overloaded filetest operator does not affect the
        stat value associated with the special filehandle
        <span class="Li">&quot;_&quot;</span>. It still refers to the result of
        the last <span class="Li">&quot;stat&quot;</span>,
        <span class="Li">&quot;lstat&quot;</span> or unoverloaded filetest.</p>
    <p class="Pp">This overload was introduced in Perl 5.12.</p>
  </li>
  <li><i>Matching</i>
    <p class="Pp">The key <span class="Li">&quot;~~&quot;</span> allows you to
        override the smart matching logic used by the
        <span class="Li">&quot;~~&quot;</span> operator and the switch construct
        (<span class="Li">&quot;given&quot;</span>/<span class="Li">&quot;when&quot;</span>).
        See &quot;Switch Statements&quot; in perlsyn and feature.</p>
    <p class="Pp">Unusually, the overloaded implementation of the smart match
        operator does not get full control of the smart match behaviour. In
        particular, in the following code:</p>
    <p class="Pp"></p>
    <pre>    package Foo;
    use overload '~~' =&gt; 'match';
    my $obj =  Foo-&gt;new();
    $obj ~~ [ 1,2,3 ];
    </pre>
    <p class="Pp">the smart match does <i>not</i> invoke the method call like
        this:</p>
    <p class="Pp"></p>
    <pre>    $obj-&gt;match([1,2,3],0);
    </pre>
    <p class="Pp">rather, the smart match distributive rule takes precedence, so
        <span class="Li">$obj</span> is smart matched against each array element
        in turn until a match is found, so you may see between one and three of
        these calls instead:</p>
    <p class="Pp"></p>
    <pre>    $obj-&gt;match(1,0);
    $obj-&gt;match(2,0);
    $obj-&gt;match(3,0);
    </pre>
    <p class="Pp">Consult the match table in &quot;Smartmatch Operator&quot; in
        perlop for details of when overloading is invoked.</p>
  </li>
  <li><i>Dereferencing</i>
    <p class="Pp"></p>
    <pre>    ${}  @{}  %{}  &amp;{}  *{}
    </pre>
    <p class="Pp">If these operators are not explicitly overloaded then they
        work in the normal way, yielding the underlying scalar, array, or
        whatever stores the object data (or the appropriate error message if the
        dereference operator doesn't match it). Defining a catch-all
        <span class="Li">'nomethod'</span> (see below) makes no difference to
        this as the catch-all function will not be called to implement a missing
        dereference operator.</p>
    <p class="Pp">If a dereference operator is overloaded then it must return a
        <i>reference</i> of the appropriate type (for example, the subroutine
        for key <span class="Li">'${}'</span> should return a reference to a
        scalar, not a scalar), or another object which overloads the operator:
        that is, the subroutine only determines what is dereferenced and the
        actual dereferencing is left to Perl. As a special case, if the
        subroutine returns the object itself then it will not be called again -
        avoiding infinite recursion.</p>
  </li>
  <li><i>Special</i>
    <p class="Pp"></p>
    <pre>    nomethod  fallback  =
    </pre>
    <p class="Pp">See &quot;Special Keys for <span class="Li">&quot;use
        overload&quot;</span>&quot;.</p>
  </li>
</ul>
</section>
<section class="Ss">
<h2 class="Ss" id="Magic_Autogeneration"><a class="permalink" href="#Magic_Autogeneration">Magic
  Autogeneration</a></h2>
<p class="Pp">If a method for an operation is not found then Perl tries to
    autogenerate a substitute implementation from the operations that have been
    defined.</p>
<p class="Pp">Note: the behaviour described in this section can be disabled by
    setting <span class="Li">&quot;fallback&quot;</span> to FALSE (see
    &quot;fallback&quot;).</p>
<p class="Pp">In the following tables, numbers indicate priority. For example,
    the table below states that, if no implementation for
    <span class="Li">'!'</span> has been defined then Perl will implement it
    using <span class="Li">'bool'</span> (that is, by inverting the value
    returned by the method for <span class="Li">'bool'</span>); if boolean
    conversion is also unimplemented then Perl will use
    <span class="Li">'0+'</span> or, failing that,
    <span class="Li">'&quot;&quot;'</span>.</p>
<p class="Pp"></p>
<pre>    operator | can be autogenerated from
             |
             | 0+   &quot;&quot;   bool   .   x
    =========|==========================
       0+    |       1     2
       &quot;&quot;    |  1          2
       bool  |  1    2
       int   |  1    2     3
       !     |  2    3     1
       qr    |  2    1     3
       .     |  2    1     3
       x     |  2    1     3
       .=    |  3    2     4    1
       x=    |  3    2     4        1
       &lt;&gt;    |  2    1     3
       -X    |  2    1     3
</pre>
<p class="Pp">Note: The iterator (<span class="Li">'&lt;&gt;'</span>) and file
    test (<span class="Li">'-X'</span>) operators work as normal: if the operand
    is not a blessed glob or IO reference then it is converted to a string
    (using the method for <span class="Li">'&quot;&quot;'</span>,
    <span class="Li">'0+'</span>, or <span class="Li">'bool'</span>) to be
    interpreted as a glob or filename.</p>
<p class="Pp"></p>
<pre>    operator | can be autogenerated from
             |
             |  &lt;   &lt;=&gt;   neg   -=    -
    =========|==========================
       neg   |                        1
       -=    |                        1
       --    |                   1    2
       abs   | a1    a2    b1        b2    [*]
       &lt;     |        1
       &lt;=    |        1
       &gt;     |        1
       &gt;=    |        1
       ==    |        1
       !=    |        1
    * one from [a1, a2] and one from [b1, b2]
</pre>
<p class="Pp">Just as numeric comparisons can be autogenerated from the method
    for <span class="Li">'&lt;=&gt;'</span>, string comparisons can be
    autogenerated from that for <span class="Li">'cmp'</span>:</p>
<p class="Pp"></p>
<pre>     operators          |  can be autogenerated from
    ====================|===========================
     lt gt le ge eq ne  |  cmp
</pre>
<p class="Pp">Similarly, autogeneration for keys <span class="Li">'+='</span>
    and <span class="Li">'++'</span> is analogous to
    <span class="Li">'-='</span> and <span class="Li">'--'</span> above:</p>
<p class="Pp"></p>
<pre>    operator | can be autogenerated from
             |
             |  +=    +
    =========|==========================
        +=   |        1
        ++   |   1    2
</pre>
<p class="Pp">And other assignment variations are analogous to
    <span class="Li">'+='</span> and <span class="Li">'-='</span> (and similar
    to <span class="Li">'.='</span> and <span class="Li">'x='</span> above):</p>
<p class="Pp"></p>
<pre>              operator ||  *= /= %= **= &lt;&lt;= &gt;&gt;= &amp;= ^= |=
    -------------------||--------------------------------
    autogenerated from ||  *  /  %  **  &lt;&lt;  &gt;&gt;  &amp;  ^  |
</pre>
<p class="Pp">Note also that the copy constructor (key
    <span class="Li">'='</span>) may be autogenerated, but only for objects
    based on scalars. See &quot;Copy Constructor&quot;.</p>
<p class="Pp"><i>Minimal Set of Overloaded Operations</i></p>
<p class="Pp">Since some operations can be automatically generated from others,
    there is a minimal set of operations that need to be overloaded in order to
    have the complete set of overloaded operations at one's disposal. Of course,
    the autogenerated operations may not do exactly what the user expects. The
    minimal set is:</p>
<p class="Pp"></p>
<pre>    + - * / % ** &lt;&lt; &gt;&gt; x
    &lt;=&gt; cmp
    &amp; | ^ ~
    atan2 cos sin exp log sqrt int
    &quot;&quot; 0+ bool
    ~~
</pre>
<p class="Pp">Of the conversions, only one of string, boolean or numeric is
    needed because each can be generated from either of the other two.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Special_Keys_for__use_overload_"><a class="permalink" href="#Special_Keys_for__use_overload_">Special
  Keys for &quot;use overload&quot;</a></h2>
<p class="Pp"><i></i><span class="Li"><i>&quot;nomethod&quot;</i></span><i></i></p>
<p class="Pp">The <span class="Li">'nomethod'</span> key is used to specify a
    catch-all function to be called for any operator that is not individually
    overloaded. The specified function will be passed four parameters. The first
    three arguments coincide with those that would have been passed to the
    corresponding method if it had been defined. The fourth argument is the
    <span class="Li">&quot;use overload&quot;</span> key for that missing
    method.</p>
<p class="Pp">For example, if <span class="Li">$a</span> is an object blessed
    into a package declaring</p>
<p class="Pp"></p>
<pre>    use overload 'nomethod' =&gt; 'catch_all', # ...
</pre>
<p class="Pp">then the operation</p>
<p class="Pp"></p>
<pre>    3 + $a
</pre>
<p class="Pp">could (unless a method is specifically declared for the key
    <span class="Li">'+'</span>) result in a call</p>
<p class="Pp"></p>
<pre>    catch_all($a, 3, 1, '+')
</pre>
<p class="Pp">See &quot;How Perl Chooses an Operator Implementation&quot;.</p>
<p class="Pp"><i></i><span class="Li"><i>&quot;fallback&quot;</i></span><i></i></p>
<p class="Pp">The value assigned to the key <span class="Li">'fallback'</span>
    tells Perl how hard it should try to find an alternative way to implement a
    missing operator.</p>
<ul class="Bl-bullet">
  <li>defined, but FALSE
    <p class="Pp"></p>
    <pre>    use overload &quot;fallback&quot; =&gt; 0, # ... ;
    </pre>
    <p class="Pp">This disables &quot;Magic Autogeneration&quot;.</p>
  </li>
  <li><span class="Li">&quot;undef&quot;</span>
    <p class="Pp">In the default case where no value is explicitly assigned to
        <span class="Li">&quot;fallback&quot;</span>, magic autogeneration is
        enabled.</p>
  </li>
  <li>TRUE
    <p class="Pp">The same as for <span class="Li">&quot;undef&quot;</span>, but
        if a missing operator cannot be autogenerated then, instead of issuing
        an error message, Perl is allowed to revert to what it would have done
        for that operator if there had been no <span class="Li">&quot;use
        overload&quot;</span> directive.</p>
    <p class="Pp">Note: in most cases, particularly the &quot;Copy
        Constructor&quot;, this is unlikely to be appropriate behaviour.</p>
  </li>
</ul>
<p class="Pp">See &quot;How Perl Chooses an Operator Implementation&quot;.</p>
<p class="Pp"><i>Copy Constructor</i></p>
<p class="Pp">As mentioned above, this operation is called when a mutator is
    applied to a reference that shares its object with some other reference. For
    example, if <span class="Li">$b</span> is mathemagical, and
    <span class="Li">'++'</span> is overloaded with
    <span class="Li">'incr'</span>, and <span class="Li">'='</span> is
    overloaded with <span class="Li">'clone'</span>, then the code</p>
<p class="Pp"></p>
<pre>    $a = $b;
    # ... (other code which does not modify $a or $b) ...
    ++$b;
</pre>
<p class="Pp">would be executed in a manner equivalent to</p>
<p class="Pp"></p>
<pre>    $a = $b;
    # ...
    $b = $b-&gt;clone(undef, &quot;&quot;);
    $b-&gt;incr(undef, &quot;&quot;);
</pre>
<p class="Pp">Note:</p>
<ul class="Bl-bullet">
  <li>The subroutine for <span class="Li">'='</span> does not overload the Perl
      assignment operator: it is used only to allow mutators to work as
      described here. (See &quot;Assignments&quot; above.)</li>
  <li>As for other operations, the subroutine implementing '=' is passed three
      arguments, though the last two are always
      <span class="Li">&quot;undef&quot;</span> and
    <span class="Li">''</span>.</li>
  <li>The copy constructor is called only before a call to a function declared
      to implement a mutator, for example, if
      <span class="Li">&quot;++$b;&quot;</span> in the code above is effected
      via a method declared for key <span class="Li">'++'</span> (or 'nomethod',
      passed <span class="Li">'++'</span> as the fourth argument) or, by
      autogeneration, <span class="Li">'+='</span>. It is not called if the
      increment operation is effected by a call to the method for
      <span class="Li">'+'</span> since, in the equivalent code,
    <p class="Pp"></p>
    <pre>    $a = $b;
    $b = $b + 1;
    </pre>
    <p class="Pp">the data referred to by <span class="Li">$a</span> is
        unchanged by the assignment to <span class="Li">$b</span> of a reference
        to new object data.</p>
  </li>
  <li>The copy constructor is not called if Perl determines that it is
      unnecessary because there is no other reference to the data being
      modified.</li>
  <li>If <span class="Li">'fallback'</span> is undefined or TRUE then a copy
      constructor can be autogenerated, but only for objects based on scalars.
      In other cases it needs to be defined explicitly. Where an object's data
      is stored as, for example, an array of scalars, the following might be
      appropriate:
    <p class="Pp"></p>
    <pre>    use overload '=' =&gt; sub { bless [ @{$_[0]} ] },  # ...
    </pre>
  </li>
  <li>If <span class="Li">'fallback'</span> is TRUE and no copy constructor is
      defined then, for objects not based on scalars, Perl may silently fall
      back on simple assignment - that is, assignment of the object reference.
      In effect, this disables the copy constructor mechanism since no new copy
      of the object data is created. This is almost certainly not what you want.
      (It is, however, consistent: for example, Perl's fallback for the
      <span class="Li">&quot;++&quot;</span> operator is to increment the
      reference itself.)</li>
</ul>
</section>
<section class="Ss">
<h2 class="Ss" id="How_Perl_Chooses_an_Operator_Implementation"><a class="permalink" href="#How_Perl_Chooses_an_Operator_Implementation">How
  Perl Chooses an Operator Implementation</a></h2>
<p class="Pp">Which is checked first,
    <span class="Li">&quot;nomethod&quot;</span> or
    <span class="Li">&quot;fallback&quot;</span>? If the two operands of an
    operator are of different types and both overload the operator, which
    implementation is used? The following are the precedence rules:</p>
<dl class="Bl-tag">
  <dt>1.</dt>
  <dd>If the first operand has declared a subroutine to overload the operator
      then use that implementation.</dd>
  <dt>2.</dt>
  <dd>Otherwise, if fallback is TRUE or undefined for the first operand then see
      if the rules for autogeneration allows another of its operators to be used
      instead.</dd>
  <dt>3.</dt>
  <dd>Unless the operator is an assignment
      (<span class="Li">&quot;+=&quot;</span>,
      <span class="Li">&quot;-=&quot;</span>, etc.), repeat step (1) in respect
      of the second operand.</dd>
  <dt>4.</dt>
  <dd>Repeat Step (2) in respect of the second operand.</dd>
  <dt>5.</dt>
  <dd>If the first operand has a &quot;nomethod&quot; method then use that.</dd>
  <dt>6.</dt>
  <dd>If the second operand has a &quot;nomethod&quot; method then use
    that.</dd>
  <dt>7.</dt>
  <dd>If <span class="Li">&quot;fallback&quot;</span> is TRUE for both operands
      then perform the usual operation for the operator, treating the operands
      as numbers, strings, or booleans as appropriate for the operator (see
      note).</dd>
  <dt>8.</dt>
  <dd>Nothing worked - die.</dd>
</dl>
<p class="Pp">Where there is only one operand (or only one operand with
    overloading) the checks in respect of the other operand above are
  skipped.</p>
<p class="Pp">There are exceptions to the above rules for dereference operations
    (which, if Step 1 fails, always fall back to the normal, built-in
    implementations - see Dereferencing), and for
    <span class="Li">&quot;~~&quot;</span> (which has its own set of rules - see
    <span class="Li">&quot;Matching&quot;</span> under &quot;Overloadable
    Operations&quot; above).</p>
<p class="Pp">Note on Step 7: some operators have a different semantic depending
    on the type of their operands. As there is no way to instruct Perl to treat
    the operands as, e.g., numbers instead of strings, the result here may not
    be what you expect. See &quot;BUGS AND PITFALLS&quot;.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Losing_Overloading"><a class="permalink" href="#Losing_Overloading">Losing
  Overloading</a></h2>
<p class="Pp">The restriction for the comparison operation is that even if, for
    example, <span class="Li">&quot;cmp&quot;</span> should return a blessed
    reference, the autogenerated <span class="Li">&quot;lt&quot;</span> function
    will produce only a standard logical value based on the numerical value of
    the result of <span class="Li">&quot;cmp&quot;</span>. In particular, a
    working numeric conversion is needed in this case (possibly expressed in
    terms of other conversions).</p>
<p class="Pp">Similarly, <span class="Li">&quot;.=&quot;</span> and
    <span class="Li">&quot;x=&quot;</span> operators lose their mathemagical
    properties if the string conversion substitution is applied.</p>
<p class="Pp">When you <i>chop()</i> a mathemagical object it is promoted to a
    string and its mathemagical properties are lost. The same can happen with
    other operations as well.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Inheritance_and_Overloading"><a class="permalink" href="#Inheritance_and_Overloading">Inheritance
  and Overloading</a></h2>
<p class="Pp">Overloading respects inheritance via the
    <span class="Li">@ISA</span> hierarchy. Inheritance interacts with
    overloading in two ways.</p>
<dl class="Bl-tag">
  <dt id="Method"><a class="permalink" href="#Method">Method names in the
    &quot;use overload&quot; directive</a></dt>
  <dd>If <span class="Li">&quot;value&quot;</span> in
    <p class="Pp"></p>
    <pre>  use overload key =&gt; value;
    </pre>
    <p class="Pp">is a string, it is interpreted as a method name - which may
        (in the usual way) be inherited from another class.</p>
  </dd>
  <dt id="Overloading"><a class="permalink" href="#Overloading">Overloading of
    an operation is inherited by derived classes</a></dt>
  <dd>Any class derived from an overloaded class is also overloaded and inherits
      its operator implementations. If the same operator is overloaded in more
      than one ancestor then the implementation is determined by the usual
      inheritance rules.
    <p class="Pp">For example, if <span class="Li">&quot;A&quot;</span> inherits
        from <span class="Li">&quot;B&quot;</span> and
        <span class="Li">&quot;C&quot;</span> (in that order),
        <span class="Li">&quot;B&quot;</span> overloads
        <span class="Li">&quot;+&quot;</span> with
        <span class="Li">&quot;\&amp;D::plus_sub&quot;</span>, and
        <span class="Li">&quot;C&quot;</span> overloads
        <span class="Li">&quot;+&quot;</span> by
        <span class="Li">&quot;plus_meth&quot;</span>, then the subroutine
        <span class="Li">&quot;D::plus_sub&quot;</span> will be called to
        implement operation <span class="Li">&quot;+&quot;</span> for an object
        in package <span class="Li">&quot;A&quot;</span>.</p>
  </dd>
</dl>
<p class="Pp">Note that in Perl version prior to 5.18 inheritance of the
    <span class="Li">&quot;fallback&quot;</span> key was not governed by the
    above rules. The value of <span class="Li">&quot;fallback&quot;</span> in
    the first overloaded ancestor was used. This was fixed in 5.18 to follow the
    usual rules of inheritance.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Run-time_Overloading"><a class="permalink" href="#Run-time_Overloading">Run-time
  Overloading</a></h2>
<p class="Pp">Since all <span class="Li">&quot;use&quot;</span> directives are
    executed at compile-time, the only way to change overloading during run-time
    is to</p>
<p class="Pp"></p>
<pre>    eval 'use overload &quot;+&quot; =&gt; \&amp;addmethod';
</pre>
<p class="Pp">You can also use</p>
<p class="Pp"></p>
<pre>    eval 'no overload &quot;+&quot;, &quot;--&quot;, &quot;&lt;=&quot;';
</pre>
<p class="Pp">though the use of these constructs during run-time is
    questionable.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Public_Functions"><a class="permalink" href="#Public_Functions">Public
  Functions</a></h2>
<p class="Pp">Package <span class="Li">&quot;overload.pm&quot;</span> provides
    the following public functions:</p>
<dl class="Bl-tag">
  <dt id="overload::StrVal(arg)"><a class="permalink" href="#overload::StrVal(arg)">overload::StrVal(arg)</a></dt>
  <dd>Gives the string value of <span class="Li">&quot;arg&quot;</span> as in
      the absence of stringify overloading. If you are using this to get the
      address of a reference (useful for checking if two references point to the
      same thing) then you may be better off using
      <span class="Li">&quot;Scalar::Util::refaddr()&quot;</span>, which is
      faster.</dd>
  <dt id="overload::Overloaded(arg)"><a class="permalink" href="#overload::Overloaded(arg)">overload::Overloaded(arg)</a></dt>
  <dd>Returns true if <span class="Li">&quot;arg&quot;</span> is subject to
      overloading of some operations.</dd>
  <dt id="overload::Method(obj,op)"><a class="permalink" href="#overload::Method(obj,op)">overload::Method(obj,op)</a></dt>
  <dd>Returns <span class="Li">&quot;undef&quot;</span> or a reference to the
      method that implements <span class="Li">&quot;op&quot;</span>.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Overloading_Constants"><a class="permalink" href="#Overloading_Constants">Overloading
  Constants</a></h2>
<p class="Pp">For some applications, the Perl parser mangles constants too much.
    It is possible to hook into this process via
    <span class="Li">&quot;overload::constant()&quot;</span> and
    <span class="Li">&quot;overload::remove_constant()&quot;</span>
  functions.</p>
<p class="Pp">These functions take a hash as an argument. The recognized keys of
    this hash are:</p>
<dl class="Bl-tag">
  <dt id="integer"><a class="permalink" href="#integer">integer</a></dt>
  <dd>to overload integer constants,</dd>
  <dt id="float"><a class="permalink" href="#float">float</a></dt>
  <dd>to overload floating point constants,</dd>
  <dt id="binary"><a class="permalink" href="#binary">binary</a></dt>
  <dd>to overload octal and hexadecimal constants,</dd>
  <dt id="q"><a class="permalink" href="#q">q</a></dt>
  <dd>to overload <span class="Li">&quot;q&quot;</span>-quoted strings, constant
      pieces of <span class="Li">&quot;qq&quot;</span>- and
      <span class="Li">&quot;qx&quot;</span>-quoted strings and
    here-documents,</dd>
  <dt id="qr"><a class="permalink" href="#qr">qr</a></dt>
  <dd>to overload constant pieces of regular expressions.</dd>
</dl>
<p class="Pp">The corresponding values are references to functions which take
    three arguments: the first one is the <i>initial</i> string form of the
    constant, the second one is how Perl interprets this constant, the third one
    is how the constant is used. Note that the initial string form does not
    contain string delimiters, and has backslashes in backslash-delimiter
    combinations stripped (thus the value of delimiter is not relevant for
    processing of this string). The return value of this function is how this
    constant is going to be interpreted by Perl. The third argument is undefined
    unless for overloaded <span class="Li">&quot;q&quot;</span>- and
    <span class="Li">&quot;qr&quot;</span>- constants, it is
    <span class="Li">&quot;q&quot;</span> in single-quote context (comes from
    strings, regular expressions, and single-quote HERE documents), it is
    <span class="Li">&quot;tr&quot;</span> for arguments of
    <span class="Li">&quot;tr&quot;</span>/<span class="Li">&quot;y&quot;</span>
    operators, it is <span class="Li">&quot;s&quot;</span> for right-hand side
    of <span class="Li">&quot;s&quot;</span>-operator, and it is
    <span class="Li">&quot;qq&quot;</span> otherwise.</p>
<p class="Pp">Since an expression <span class="Li">&quot;ab$cd,,&quot;</span> is
    just a shortcut for <span class="Li">'ab' . $cd . ',,'</span>, it is
    expected that overloaded constant strings are equipped with reasonable
    overloaded catenation operator, otherwise absurd results will result.
    Similarly, negative numbers are considered as negations of positive
    constants.</p>
<p class="Pp">Note that it is probably meaningless to call the functions
    <i>overload::constant()</i> and <i>overload::remove_constant()</i> from
    anywhere but <i>import()</i> and <i>unimport()</i> methods. From these
    methods they may be called as</p>
<p class="Pp"></p>
<pre>    sub import {
       shift;
       return unless @_;
       die &quot;unknown import: @_&quot; unless @_ == 1 and $_[0] eq ':constant';
       overload::constant integer =&gt; sub {Math::BigInt-&gt;new(shift)};
    }
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="IMPLEMENTATION"><a class="permalink" href="#IMPLEMENTATION">IMPLEMENTATION</a></h1>
<p class="Pp">What follows is subject to change RSN.</p>
<p class="Pp">The table of methods for all operations is cached in magic for the
    symbol table hash for the package. The cache is invalidated during
    processing of <span class="Li">&quot;use overload&quot;</span>,
    <span class="Li">&quot;no overload&quot;</span>, new function definitions,
    and changes in <span class="Li">@ISA</span>.</p>
<p class="Pp">(Every SVish thing has a magic queue, and magic is an entry in
    that queue. This is how a single variable may participate in multiple forms
    of magic simultaneously. For instance, environment variables regularly have
    two forms at once: their <span class="Li">%ENV</span> magic and their taint
    magic. However, the magic which implements overloading is applied to the
    stashes, which are rarely used directly, thus should not slow down
  Perl.)</p>
<p class="Pp">If a package uses overload, it carries a special flag. This flag
    is also set when new function are defined or <span class="Li">@ISA</span> is
    modified. There will be a slight speed penalty on the very first operation
    thereafter that supports overloading, while the overload tables are updated.
    If there is no overloading present, the flag is turned off. Thus the only
    speed penalty thereafter is the checking of this flag.</p>
<p class="Pp">It is expected that arguments to methods that are not explicitly
    supposed to be changed are constant (but this is not enforced).</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COOKBOOK"><a class="permalink" href="#COOKBOOK">COOKBOOK</a></h1>
<p class="Pp">Please add examples to what follows!</p>
<section class="Ss">
<h2 class="Ss" id="Two-face_Scalars"><a class="permalink" href="#Two-face_Scalars">Two-face
  Scalars</a></h2>
<p class="Pp">Put this in <i>two_face.pm</i> in your Perl library directory:</p>
<p class="Pp"></p>
<pre>  package two_face;             # Scalars with separate string and
                                # numeric values.
  sub new { my $p = shift; bless [@_], $p }
  use overload '&quot;&quot;' =&gt; \&amp;str, '0+' =&gt; \&amp;num, fallback =&gt; 1;
  sub num {shift-&gt;[1]}
  sub str {shift-&gt;[0]}
</pre>
<p class="Pp">Use it as follows:</p>
<p class="Pp"></p>
<pre>  require two_face;
  my $seven = two_face-&gt;new(&quot;vii&quot;, 7);
  printf &quot;seven=$seven, seven=%d, eight=%d\n&quot;, $seven, $seven+1;
  print &quot;seven contains 'i'\n&quot; if $seven =~ /i/;
</pre>
<p class="Pp">(The second line creates a scalar which has both a string value,
    and a numeric value.) This prints:</p>
<p class="Pp"></p>
<pre>  seven=vii, seven=7, eight=8
  seven contains 'i'
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Two-face_References"><a class="permalink" href="#Two-face_References">Two-face
  References</a></h2>
<p class="Pp">Suppose you want to create an object which is accessible as both
    an array reference and a hash reference.</p>
<p class="Pp"></p>
<pre>  package two_refs;
  use overload '%{}' =&gt; \&amp;gethash, '@{}' =&gt; sub { $ {shift()} };
  sub new {
    my $p = shift;
    bless \ [@_], $p;
  }
  sub gethash {
    my %h;
    my $self = shift;
    tie %h, ref $self, $self;
    \%h;
  }
  sub TIEHASH { my $p = shift; bless \ shift, $p }
  my %fields;
  my $i = 0;
  $fields{$_} = $i++ foreach qw{zero one two three};
  sub STORE {
    my $self = ${shift()};
    my $key = $fields{shift()};
    defined $key or die &quot;Out of band access&quot;;
    $$self-&gt;[$key] = shift;
  }
  sub FETCH {
    my $self = ${shift()};
    my $key = $fields{shift()};
    defined $key or die &quot;Out of band access&quot;;
    $$self-&gt;[$key];
  }
</pre>
<p class="Pp">Now one can access an object using both the array and hash
  syntax:</p>
<p class="Pp"></p>
<pre>  my $bar = two_refs-&gt;new(3,4,5,6);
  $bar-&gt;[2] = 11;
  $bar-&gt;{two} == 11 or die 'bad hash fetch';
</pre>
<p class="Pp">Note several important features of this example. First of all, the
    <i>actual</i> type of <span class="Li">$bar</span> is a scalar reference,
    and we do not overload the scalar dereference. Thus we can get the
    <i>actual</i> non-overloaded contents of <span class="Li">$bar</span> by
    just using <span class="Li">$$bar</span> (what we do in functions which
    overload dereference). Similarly, the object returned by the
    <i>TIEHASH()</i> method is a scalar reference.</p>
<p class="Pp">Second, we create a new tied hash each time the hash syntax is
    used. This allows us not to worry about a possibility of a reference loop,
    which would lead to a memory leak.</p>
<p class="Pp">Both these problems can be cured. Say, if we want to overload hash
    dereference on a reference to an object which is <i>implemented</i> as a
    hash itself, the only problem one has to circumvent is how to access this
    <i>actual</i> hash (as opposed to the <i>virtual</i> hash exhibited by the
    overloaded dereference operator). Here is one possible fetching routine:</p>
<p class="Pp"></p>
<pre>  sub access_hash {
    my ($self, $key) = (shift, shift);
    my $class = ref $self;
    bless $self, 'overload::dummy'; # Disable overloading of %{}
    my $out = $self-&gt;{$key};
    bless $self, $class;        # Restore overloading
    $out;
  }
</pre>
<p class="Pp">To remove creation of the tied hash on each access, one may an
    extra level of indirection which allows a non-circular structure of
    references:</p>
<p class="Pp"></p>
<pre>  package two_refs1;
  use overload '%{}' =&gt; sub { ${shift()}-&gt;[1] },
               '@{}' =&gt; sub { ${shift()}-&gt;[0] };
  sub new {
    my $p = shift;
    my $a = [@_];
    my %h;
    tie %h, $p, $a;
    bless \ [$a, \%h], $p;
  }
  sub gethash {
    my %h;
    my $self = shift;
    tie %h, ref $self, $self;
    \%h;
  }
  sub TIEHASH { my $p = shift; bless \ shift, $p }
  my %fields;
  my $i = 0;
  $fields{$_} = $i++ foreach qw{zero one two three};
  sub STORE {
    my $a = ${shift()};
    my $key = $fields{shift()};
    defined $key or die &quot;Out of band access&quot;;
    $a-&gt;[$key] = shift;
  }
  sub FETCH {
    my $a = ${shift()};
    my $key = $fields{shift()};
    defined $key or die &quot;Out of band access&quot;;
    $a-&gt;[$key];
  }
</pre>
<p class="Pp">Now if <span class="Li">$baz</span> is overloaded like this, then
    <span class="Li">$baz</span> is a reference to a reference to the
    intermediate array, which keeps a reference to an actual array, and the
    access hash. The <i>tie()</i>ing object for the access hash is a reference
    to a reference to the actual array, so</p>
<ul class="Bl-bullet">
  <li>There are no loops of references.</li>
  <li>Both &quot;objects&quot; which are blessed into the class
      <span class="Li">&quot;two_refs1&quot;</span> are references to a
      reference to an array, thus references to a <i>scalar</i>. Thus the
      accessor expression <span class="Li">&quot;$$foo-&gt;[$ind]&quot;</span>
      involves no overloaded operations.</li>
</ul>
</section>
<section class="Ss">
<h2 class="Ss" id="Symbolic_Calculator"><a class="permalink" href="#Symbolic_Calculator">Symbolic
  Calculator</a></h2>
<p class="Pp">Put this in <i>symbolic.pm</i> in your Perl library directory:</p>
<p class="Pp"></p>
<pre>  package symbolic;             # Primitive symbolic calculator
  use overload nomethod =&gt; \&amp;wrap;
  sub new { shift; bless ['n', @_] }
  sub wrap {
    my ($obj, $other, $inv, $meth) = @_;
    ($obj, $other) = ($other, $obj) if $inv;
    bless [$meth, $obj, $other];
  }
</pre>
<p class="Pp">This module is very unusual as overloaded modules go: it does not
    provide any usual overloaded operators, instead it provides an
    implementation for &quot;<span class="Li">&quot;nomethod&quot;</span>&quot;.
    In this example the <span class="Li">&quot;nomethod&quot;</span> subroutine
    returns an object which encapsulates operations done over the objects:
    <span class="Li">&quot;symbolic-&gt;new(3)&quot;</span> contains
    <span class="Li">&quot;['n', 3]&quot;</span>, <span class="Li">&quot;2
    +</span> <span class="Li">symbolic-&gt;new(3)&quot;</span> contains
    <span class="Li">&quot;['+', 2, ['n', 3]]&quot;</span>.</p>
<p class="Pp">Here is an example of the script which &quot;calculates&quot; the
    side of circumscribed octagon using the above package:</p>
<p class="Pp"></p>
<pre>  require symbolic;
  my $iter = 1;                 # 2**($iter+2) = 8
  my $side = symbolic-&gt;new(1);
  my $cnt = $iter;
  while ($cnt--) {
    $side = (sqrt(1 + $side**2) - 1)/$side;
  }
  print &quot;OK\n&quot;;
</pre>
<p class="Pp">The value of <span class="Li">$side</span> is</p>
<p class="Pp"></p>
<pre>  ['/', ['-', ['sqrt', ['+', 1, ['**', ['n', 1], 2]],
                       undef], 1], ['n', 1]]
</pre>
<p class="Pp">Note that while we obtained this value using a nice little script,
    there is no simple way to <i>use</i> this value. In fact this value may be
    inspected in debugger (see perldebug), but only if
    <span class="Li">&quot;bareStringify&quot;</span> <b>O</b>ption is set, and
    not via <span class="Li">&quot;p&quot;</span> command.</p>
<p class="Pp">If one attempts to print this value, then the overloaded operator
    <span class="Li">&quot;&quot;</span> will be called, which will call
    <span class="Li">&quot;nomethod&quot;</span> operator. The result of this
    operator will be stringified again, but this result is again of type
    <span class="Li">&quot;symbolic&quot;</span>, which will lead to an infinite
    loop.</p>
<p class="Pp">Add a pretty-printer method to the module <i>symbolic.pm</i>:</p>
<p class="Pp"></p>
<pre>  sub pretty {
    my ($meth, $a, $b) = @{+shift};
    $a = 'u' unless defined $a;
    $b = 'u' unless defined $b;
    $a = $a-&gt;pretty if ref $a;
    $b = $b-&gt;pretty if ref $b;
    &quot;[$meth $a $b]&quot;;
  }
</pre>
<p class="Pp">Now one can finish the script by</p>
<p class="Pp"></p>
<pre>  print &quot;side = &quot;, $side-&gt;pretty, &quot;\n&quot;;
</pre>
<p class="Pp">The method <span class="Li">&quot;pretty&quot;</span> is doing
    object-to-string conversion, so it is natural to overload the operator
    <span class="Li">&quot;&quot;</span> using this method. However, inside such
    a method it is not necessary to pretty-print the <i>components</i>
    <span class="Li">$a</span> and <span class="Li">$b</span> of an object. In
    the above subroutine <span class="Li">&quot;[$meth $a $b]&quot;</span> is a
    catenation of some strings and components <span class="Li">$a</span> and
    <span class="Li">$b</span>. If these components use overloading, the
    catenation operator will look for an overloaded operator
    <span class="Li">&quot;.&quot;</span>; if not present, it will look for an
    overloaded operator <span class="Li">&quot;&quot;</span>. Thus it is enough
    to use</p>
<p class="Pp"></p>
<pre>  use overload nomethod =&gt; \&amp;wrap, '&quot;&quot;' =&gt; \&amp;str;
  sub str {
    my ($meth, $a, $b) = @{+shift};
    $a = 'u' unless defined $a;
    $b = 'u' unless defined $b;
    &quot;[$meth $a $b]&quot;;
  }
</pre>
<p class="Pp">Now one can change the last line of the script to</p>
<p class="Pp"></p>
<pre>  print &quot;side = $side\n&quot;;
</pre>
<p class="Pp">which outputs</p>
<p class="Pp"></p>
<pre>  side = [/ [- [sqrt [+ 1 [** [n 1 u] 2]] u] 1] [n 1 u]]
</pre>
<p class="Pp">and one can inspect the value in debugger using all the possible
    methods.</p>
<p class="Pp">Something is still amiss: consider the loop variable
    <span class="Li">$cnt</span> of the script. It was a number, not an object.
    We cannot make this value of type
    <span class="Li">&quot;symbolic&quot;</span>, since then the loop will not
    terminate.</p>
<p class="Pp">Indeed, to terminate the cycle, the <span class="Li">$cnt</span>
    should become false. However, the operator
    <span class="Li">&quot;bool&quot;</span> for checking falsity is overloaded
    (this time via overloaded <span class="Li">&quot;&quot;</span>), and returns
    a long string, thus any object of type
    <span class="Li">&quot;symbolic&quot;</span> is true. To overcome this, we
    need a way to compare an object to 0. In fact, it is easier to write a
    numeric conversion routine.</p>
<p class="Pp">Here is the text of <i>symbolic.pm</i> with such a routine added
    (and slightly modified <i>str()</i>):</p>
<p class="Pp"></p>
<pre>  package symbolic;             # Primitive symbolic calculator
  use overload
    nomethod =&gt; \&amp;wrap, '&quot;&quot;' =&gt; \&amp;str, '0+' =&gt; \&amp;num;
  sub new { shift; bless ['n', @_] }
  sub wrap {
    my ($obj, $other, $inv, $meth) = @_;
    ($obj, $other) = ($other, $obj) if $inv;
    bless [$meth, $obj, $other];
  }
  sub str {
    my ($meth, $a, $b) = @{+shift};
    $a = 'u' unless defined $a;
    if (defined $b) {
      &quot;[$meth $a $b]&quot;;
    } else {
      &quot;[$meth $a]&quot;;
    }
  }
  my %subr = ( n =&gt; sub {$_[0]},
               sqrt =&gt; sub {sqrt $_[0]},
               '-' =&gt; sub {shift() - shift()},
               '+' =&gt; sub {shift() + shift()},
               '/' =&gt; sub {shift() / shift()},
               '*' =&gt; sub {shift() * shift()},
               '**' =&gt; sub {shift() ** shift()},
             );
  sub num {
    my ($meth, $a, $b) = @{+shift};
    my $subr = $subr{$meth}
      or die &quot;Do not know how to ($meth) in symbolic&quot;;
    $a = $a-&gt;num if ref $a eq __PACKAGE__;
    $b = $b-&gt;num if ref $b eq __PACKAGE__;
    $subr-&gt;($a,$b);
  }
</pre>
<p class="Pp">All the work of numeric conversion is done in
    <span class="Li">%subr</span> and <i>num()</i>. Of course,
    <span class="Li">%subr</span> is not complete, it contains only operators
    used in the example below. Here is the extra-credit question: why do we need
    an explicit recursion in <i>num()</i>? (Answer is at the end of this
    section.)</p>
<p class="Pp">Use this module like this:</p>
<p class="Pp"></p>
<pre>  require symbolic;
  my $iter = symbolic-&gt;new(2);  # 16-gon
  my $side = symbolic-&gt;new(1);
  my $cnt = $iter;
  while ($cnt) {
    $cnt = $cnt - 1;            # Mutator '--' not implemented
    $side = (sqrt(1 + $side**2) - 1)/$side;
  }
  printf &quot;%s=%f\n&quot;, $side, $side;
  printf &quot;pi=%f\n&quot;, $side*(2**($iter+2));
</pre>
<p class="Pp">It prints (without so many line breaks)</p>
<p class="Pp"></p>
<pre>  [/ [- [sqrt [+ 1 [** [/ [- [sqrt [+ 1 [** [n 1] 2]]] 1]
                          [n 1]] 2]]] 1]
     [/ [- [sqrt [+ 1 [** [n 1] 2]]] 1] [n 1]]]=0.198912
  pi=3.182598
</pre>
<p class="Pp">The above module is very primitive. It does not implement mutator
    methods (<span class="Li">&quot;++&quot;</span>,
    <span class="Li">&quot;-=&quot;</span> and so on), does not do deep copying
    (not required without mutators!), and implements only those arithmetic
    operations which are used in the example.</p>
<p class="Pp">To implement most arithmetic operations is easy; one should just
    use the tables of operations, and change the code which fills
    <span class="Li">%subr</span> to</p>
<p class="Pp"></p>
<pre>  my %subr = ( 'n' =&gt; sub {$_[0]} );
  foreach my $op (split &quot; &quot;, $overload::ops{with_assign}) {
    $subr{$op} = $subr{&quot;$op=&quot;} = eval &quot;sub {shift() $op shift()}&quot;;
  }
  my @bins = qw(binary 3way_comparison num_comparison str_comparison);
  foreach my $op (split &quot; &quot;, &quot;@overload::ops{ @bins }&quot;) {
    $subr{$op} = eval &quot;sub {shift() $op shift()}&quot;;
  }
  foreach my $op (split &quot; &quot;, &quot;@overload::ops{qw(unary func)}&quot;) {
    print &quot;defining '$op'\n&quot;;
    $subr{$op} = eval &quot;sub {$op shift()}&quot;;
  }
</pre>
<p class="Pp">Since subroutines implementing assignment operators are not
    required to modify their operands (see &quot;Overloadable Operations&quot;
    above), we do not need anything special to make
    <span class="Li">&quot;+=&quot;</span> and friends work, besides adding
    these operators to <span class="Li">%subr</span> and defining a copy
    constructor (needed since Perl has no way to know that the implementation of
    <span class="Li">'+='</span> does not mutate the argument - see &quot;Copy
    Constructor&quot;).</p>
<p class="Pp">To implement a copy constructor, add <span class="Li">&quot;'='
    =&gt; \&amp;cpy&quot;</span> to <span class="Li">&quot;use
    overload&quot;</span> line, and code (this code assumes that mutators change
    things one level deep only, so recursive copying is not needed):</p>
<p class="Pp"></p>
<pre>  sub cpy {
    my $self = shift;
    bless [@$self], ref $self;
  }
</pre>
<p class="Pp">To make <span class="Li">&quot;++&quot;</span> and
    <span class="Li">&quot;--&quot;</span> work, we need to implement actual
    mutators, either directly, or in
    <span class="Li">&quot;nomethod&quot;</span>. We continue to do things
    inside <span class="Li">&quot;nomethod&quot;</span>, thus add</p>
<p class="Pp"></p>
<pre>    if ($meth eq '++' or $meth eq '--') {
      @$obj = ($meth, (bless [@$obj]), 1); # Avoid circular reference
      return $obj;
    }
</pre>
<p class="Pp">after the first line of <i>wrap()</i>. This is not a most
    effective implementation, one may consider</p>
<p class="Pp"></p>
<pre>  sub inc { $_[0] = bless ['++', shift, 1]; }
</pre>
<p class="Pp">instead.</p>
<p class="Pp">As a final remark, note that one can fill
    <span class="Li">%subr</span> by</p>
<p class="Pp"></p>
<pre>  my %subr = ( 'n' =&gt; sub {$_[0]} );
  foreach my $op (split &quot; &quot;, $overload::ops{with_assign}) {
    $subr{$op} = $subr{&quot;$op=&quot;} = eval &quot;sub {shift() $op shift()}&quot;;
  }
  my @bins = qw(binary 3way_comparison num_comparison str_comparison);
  foreach my $op (split &quot; &quot;, &quot;@overload::ops{ @bins }&quot;) {
    $subr{$op} = eval &quot;sub {shift() $op shift()}&quot;;
  }
  foreach my $op (split &quot; &quot;, &quot;@overload::ops{qw(unary func)}&quot;) {
    $subr{$op} = eval &quot;sub {$op shift()}&quot;;
  }
  $subr{'++'} = $subr{'+'};
  $subr{'--'} = $subr{'-'};
</pre>
<p class="Pp">This finishes implementation of a primitive symbolic calculator in
    50 lines of Perl code. Since the numeric values of subexpressions are not
    cached, the calculator is very slow.</p>
<p class="Pp">Here is the answer for the exercise: In the case of <i>str()</i>,
    we need no explicit recursion since the overloaded
    <span class="Li">&quot;.&quot;</span>-operator will fall back to an existing
    overloaded operator <span class="Li">&quot;&quot;</span>. Overloaded
    arithmetic operators <i>do not</i> fall back to numeric conversion if
    <span class="Li">&quot;fallback&quot;</span> is not explicitly requested.
    Thus without an explicit recursion <i>num()</i> would convert
    <span class="Li">&quot;['+', $a, $b]&quot;</span> to
    <span class="Li">&quot;$a + $b&quot;</span>, which would just rebuild the
    argument of <i>num()</i>.</p>
<p class="Pp">If you wonder why defaults for conversion are different for
    <i>str()</i> and <i>num()</i>, note how easy it was to write the symbolic
    calculator. This simplicity is due to an appropriate choice of defaults. One
    extra note: due to the explicit recursion <i>num()</i> is more fragile than
    <i>sym()</i>: we need to explicitly check for the type of
    <span class="Li">$a</span> and <span class="Li">$b</span>. If components
    <span class="Li">$a</span> and <span class="Li">$b</span> happen to be of
    some related type, this may lead to problems.</p>
</section>
<section class="Ss">
<h2 class="Ss"><i>Really</i> Symbolic Calculator</h2>
<p class="Pp">One may wonder why we call the above calculator symbolic. The
    reason is that the actual calculation of the value of expression is
    postponed until the value is <i>used</i>.</p>
<p class="Pp">To see it in action, add a method</p>
<p class="Pp"></p>
<pre>  sub STORE {
    my $obj = shift;
    $#$obj = 1;
    @$obj-&gt;[0,1] = ('=', shift);
  }
</pre>
<p class="Pp">to the package <span class="Li">&quot;symbolic&quot;</span>. After
    this change one can do</p>
<p class="Pp"></p>
<pre>  my $a = symbolic-&gt;new(3);
  my $b = symbolic-&gt;new(4);
  my $c = sqrt($a**2 + $b**2);
</pre>
<p class="Pp">and the numeric value of <span class="Li">$c</span> becomes 5.
    However, after calling</p>
<p class="Pp"></p>
<pre>  $a-&gt;STORE(12);  $b-&gt;STORE(5);
</pre>
<p class="Pp">the numeric value of <span class="Li">$c</span> becomes 13. There
    is no doubt now that the module symbolic provides a <i>symbolic</i>
    calculator indeed.</p>
<p class="Pp">To hide the rough edges under the hood, provide a <i>tie()</i>d
    interface to the package <span class="Li">&quot;symbolic&quot;</span>. Add
    methods</p>
<p class="Pp"></p>
<pre>  sub TIESCALAR { my $pack = shift; $pack-&gt;new(@_) }
  sub FETCH { shift }
  sub nop {  }          # Around a bug
</pre>
<p class="Pp">(the bug, fixed in Perl 5.14, is described in &quot;BUGS&quot;).
    One can use this new interface as</p>
<p class="Pp"></p>
<pre>  tie $a, 'symbolic', 3;
  tie $b, 'symbolic', 4;
  $a-&gt;nop;  $b-&gt;nop;    # Around a bug
  my $c = sqrt($a**2 + $b**2);
</pre>
<p class="Pp">Now numeric value of <span class="Li">$c</span> is 5. After
    <span class="Li">&quot;$a = 12; $b = 5&quot;</span> the numeric value of
    <span class="Li">$c</span> becomes 13. To insulate the user of the module
    add a method</p>
<p class="Pp"></p>
<pre>  sub vars { my $p = shift; tie($_, $p), $_-&gt;nop foreach @_; }
</pre>
<p class="Pp">Now</p>
<p class="Pp"></p>
<pre>  my ($a, $b);
  symbolic-&gt;vars($a, $b);
  my $c = sqrt($a**2 + $b**2);
  $a = 3; $b = 4;
  printf &quot;c5  %s=%f\n&quot;, $c, $c;
  $a = 12; $b = 5;
  printf &quot;c13  %s=%f\n&quot;, $c, $c;
</pre>
<p class="Pp">shows that the numeric value of <span class="Li">$c</span> follows
    changes to the values of <span class="Li">$a</span> and
    <span class="Li">$b</span>.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">Ilya Zakharevich &lt;<i>ilya@math.mps.ohio-state.edu</i>&gt;.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp">The <span class="Li">&quot;overloading&quot;</span> pragma can be
    used to enable or disable overloaded operations within a lexical scope - see
    overloading.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DIAGNOSTICS"><a class="permalink" href="#DIAGNOSTICS">DIAGNOSTICS</a></h1>
<p class="Pp">When Perl is run with the <b>-Do</b> switch or its equivalent,
    overloading induces diagnostic messages.</p>
<p class="Pp">Using the <span class="Li">&quot;m&quot;</span> command of Perl
    debugger (see perldebug) one can deduce which operations are overloaded (and
    which ancestor triggers this overloading). Say, if
    <span class="Li">&quot;eq&quot;</span> is overloaded, then the method
    <span class="Li">&quot;(eq&quot;</span> is shown by debugger. The method
    <span class="Li">&quot;()&quot;</span> corresponds to the
    <span class="Li">&quot;fallback&quot;</span> key (in fact a presence of this
    method shows that this package has overloading enabled, and it is what is
    used by the <span class="Li">&quot;Overloaded&quot;</span> function of
    module <span class="Li">&quot;overload&quot;</span>).</p>
<p class="Pp">The module might issue the following warnings:</p>
<dl class="Bl-tag">
  <dt id="Odd"><a class="permalink" href="#Odd">Odd number of arguments for
    overload::constant</a></dt>
  <dd>(W) The call to overload::constant contained an odd number of arguments.
      The arguments should come in pairs.</dd>
  <dt>'%s' is not an overloadable type</dt>
  <dd>(W) You tried to overload a constant type the overload package is unaware
      of.</dd>
  <dt>'%s' is not a code reference</dt>
  <dd>(W) The second (fourth, sixth, ...) argument of overload::constant needs
      to be a code reference. Either an anonymous subroutine, or a reference to
      a subroutine.</dd>
  <dt id="overload"><a class="permalink" href="#overload">overload arg '%s' is
    invalid</a></dt>
  <dd>(W) <span class="Li">&quot;use overload&quot;</span> was passed an
      argument it did not recognize. Did you mistype an operator?</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="BUGS_AND_PITFALLS"><a class="permalink" href="#BUGS_AND_PITFALLS">BUGS
  AND PITFALLS</a></h1>
<ul class="Bl-bullet">
  <li>A pitfall when fallback is TRUE and Perl resorts to a built-in
      implementation of an operator is that some operators have more than one
      semantic, for example <span class="Li">&quot;|&quot;</span>:
    <p class="Pp"></p>
    <pre>        use overload '0+' =&gt; sub { $_[0]-&gt;{n}; },
            fallback =&gt; 1;
        my $x = bless { n =&gt; 4 }, &quot;main&quot;;
        my $y = bless { n =&gt; 8 }, &quot;main&quot;;
        print $x | $y, &quot;\n&quot;;
    </pre>
    <p class="Pp">You might expect this to output &quot;12&quot;. In fact, it
        prints &quot;&lt;&quot;: the ASCII result of treating &quot;|&quot; as a
        bitwise string operator - that is, the result of treating the operands
        as the strings &quot;4&quot; and &quot;8&quot; rather than numbers. The
        fact that numify (<span class="Li">&quot;0+&quot;</span>) is implemented
        but stringify (<span class="Li">&quot;&quot;</span>) isn't makes no
        difference since the latter is simply autogenerated from the former.</p>
    <p class="Pp">The only way to change this is to provide your own subroutine
        for <span class="Li">'|'</span>.</p>
  </li>
  <li>Magic autogeneration increases the potential for inadvertently creating
      self-referential structures. Currently Perl will not free self-referential
      structures until cycles are explicitly broken. For example,
    <p class="Pp"></p>
    <pre>    use overload '+' =&gt; 'add';
    sub add { bless [ \$_[0], \$_[1] ] };
    </pre>
    <p class="Pp">is asking for trouble, since</p>
    <p class="Pp"></p>
    <pre>    $obj += $y;
    </pre>
    <p class="Pp">will effectively become</p>
    <p class="Pp"></p>
    <pre>    $obj = add($obj, $y, undef);
    </pre>
    <p class="Pp">with the same result as</p>
    <p class="Pp"></p>
    <pre>    $obj = [\$obj, \$foo];
    </pre>
    <p class="Pp">Even if no <i>explicit</i> assignment-variants of operators
        are present in the script, they may be generated by the optimizer. For
        example,</p>
    <p class="Pp"></p>
    <pre>    &quot;obj = $obj\n&quot;
    </pre>
    <p class="Pp">may be optimized to</p>
    <p class="Pp"></p>
    <pre>    my $tmp = 'obj = ' . $obj;  $tmp .= &quot;\n&quot;;
    </pre>
  </li>
  <li>The symbol table is filled with names looking like line-noise.</li>
  <li>This bug was fixed in Perl 5.18, but may still trip you up if you are
      using older versions:
    <p class="Pp">For the purpose of inheritance every overloaded package
        behaves as if <span class="Li">&quot;fallback&quot;</span> is present
        (possibly undefined). This may create interesting effects if some
        package is not overloaded, but inherits from two overloaded
      packages.</p>
  </li>
  <li>Before Perl 5.14, the relation between overloading and <i>tie()</i>ing was
      broken. Overloading was triggered or not based on the <i>previous</i>
      class of the <i>tie()</i>d variable.
    <p class="Pp">This happened because the presence of overloading was checked
        too early, before any <i>tie()</i>d access was attempted. If the class
        of the value <i>FETCH()</i>ed from the tied variable does not change, a
        simple workaround for code that is to run on older Perl versions is to
        access the value (via <span class="Li">&quot;() = $foo&quot;</span> or
        some such) immediately after <i>tie()</i>ing, so that after this call
        the <i>previous</i> class coincides with the current one.</p>
  </li>
  <li>Barewords are not covered by overloaded string constants.</li>
  <li>The range operator <span class="Li">&quot;..&quot;</span> cannot be
      overloaded.</li>
</ul>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2014-09-30</td>
    <td class="foot-os">perl v5.18.4</td>
  </tr>
</table>
</body>
</html>
