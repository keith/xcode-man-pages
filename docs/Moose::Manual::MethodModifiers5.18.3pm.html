<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>Moose::Manual::MethodModifiers(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Moose::Manual::MethodModifiers(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Moose::Manual::MethodModifiers(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
Moose::Manual::MethodModifiers - Moose's method modifiers
</section>
<section class="Sh">
<h1 class="Sh" id="VERSION"><a class="permalink" href="#VERSION">VERSION</a></h1>
version 2.1202
</section>
<section class="Sh">
<h1 class="Sh" id="WHAT_IS_A_METHOD_MODIFIER?"><a class="permalink" href="#WHAT_IS_A_METHOD_MODIFIER?">WHAT
  IS A METHOD MODIFIER?</a></h1>
Moose provides a feature called &quot;method modifiers&quot;. You can also think
  of these as &quot;hooks&quot; or &quot;advice&quot;.
<p class="Pp">It's probably easiest to understand this feature with a few
    examples:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  package Example;

  use Moose;

  sub foo {
      print &quot;    foo\n&quot;;
  }

  before 'foo' =&gt; sub { print &quot;about to call foo\n&quot;; };
  after 'foo'  =&gt; sub { print &quot;just called foo\n&quot;; };

  around 'foo' =&gt; sub {
      my $orig = shift;
      my $self = shift;

      print &quot;  I'm around foo\n&quot;;

      $self-&gt;$orig(@_);

      print &quot;  I'm still around foo\n&quot;;
  };
</pre>
<p class="Pp">Now if I call
    <span class="Li">&quot;Example-&gt;new-&gt;foo&quot;</span> I'll get the
    following output:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  about to call foo
    I'm around foo
      foo
    I'm still around foo
  just called foo
</pre>
<p class="Pp">You probably could have figured that out from the names
    &quot;before&quot;, &quot;after&quot;, and &quot;around&quot;.</p>
<p class="Pp">Also, as you can see, the before modifiers come before around
    modifiers, and after modifiers come last.</p>
<p class="Pp">When there are multiple modifiers of the same type, the before and
    around modifiers run from the last added to the first, and after modifiers
    run from first added to last:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
   before 2
    before 1
     around 2
      around 1
       primary
      around 1
     around 2
    after 1
   after 2
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="WHY_USE_THEM?"><a class="permalink" href="#WHY_USE_THEM?">WHY
  USE THEM?</a></h1>
Method modifiers have many uses. They are often used in roles to alter the
  behavior of methods in the classes that consume the role. See
  Moose::Manual::Roles for more information about roles.
<p class="Pp">Since modifiers are mostly useful in roles, some of the examples
    below are a bit artificial. They're intended to give you an idea of how
    modifiers work, but may not be the most natural usage.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="BEFORE,_AFTER,_AND_AROUND"><a class="permalink" href="#BEFORE,_AFTER,_AND_AROUND">BEFORE,
  AFTER, AND AROUND</a></h1>
Method modifiers can be used to add behavior to methods without modifying the
  definition of those methods.
<section class="Ss">
<h2 class="Ss" id="_s-1BEFORE_s0_and__s-1AFTER_s0_modifiers"><a class="permalink" href="#_s-1BEFORE_s0_and__s-1AFTER_s0_modifiers">BEFORE
  and AFTER modifiers</a></h2>
Method modifiers can be used to add behavior to a method that Moose generates
  for you, such as an attribute accessor:
<p class="Pp"><span class="Li"></span></p>
<pre>
  has 'size' =&gt; ( is =&gt; 'rw' );

  before 'size' =&gt; sub {
      my $self = shift;

      if (@_) {
          Carp::cluck('Someone is setting size');
      }
  };
</pre>
<p class="Pp">Another use for the before modifier would be to do some sort of
    prechecking on a method call. For example:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  before 'size' =&gt; sub {
      my $self = shift;

      die 'Cannot set size while the person is growing'
          if @_ &amp;&amp; $self-&gt;is_growing;
  };
</pre>
<p class="Pp">This lets us implement logical checks that don't make sense as
    type constraints. In particular, they're useful for defining logical rules
    about an object's state changes.</p>
<p class="Pp">Similarly, an after modifier could be used for logging an action
    that was taken.</p>
<p class="Pp">Note that the return values of both before and after modifiers are
    ignored.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_s-1AROUND_s0_modifiers"><a class="permalink" href="#_s-1AROUND_s0_modifiers">AROUND
  modifiers</a></h2>
An around modifier is more powerful than either a before or after modifier. It
  can modify the arguments being passed to the original method, and you can even
  decide to simply not call the original method at all. You can also modify the
  return value with an around modifier.
<p class="Pp">An around modifier receives the original method as its first
    argument, <i>then</i> the object, and finally any arguments passed to the
    method.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  around 'size' =&gt; sub {
      my $orig = shift;
      my $self = shift;

      return $self-&gt;$orig()
          unless @_;

      my $size = shift;
      $size = $size / 2
          if $self-&gt;likes_small_things();

      return $self-&gt;$orig($size);
  };
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Wrapping_multiple_methods_at_once"><a class="permalink" href="#Wrapping_multiple_methods_at_once">Wrapping
  multiple methods at once</a></h2>
<span class="Li">&quot;before&quot;</span>,
  <span class="Li">&quot;after&quot;</span>, and
  <span class="Li">&quot;around&quot;</span> can also modify multiple methods at
  once. The simplest example of this is passing them as a list:
<p class="Pp"><span class="Li"></span></p>
<pre>
  before [qw(foo bar baz)] =&gt; sub {
      warn &quot;something is being called!&quot;;
  };
</pre>
<p class="Pp">This will add a <span class="Li">&quot;before&quot;</span>
    modifier to each of the <span class="Li">&quot;foo&quot;</span>,
    <span class="Li">&quot;bar&quot;</span>, and
    <span class="Li">&quot;baz&quot;</span> methods in the current class, just
    as though a separate call to <span class="Li">&quot;before&quot;</span> was
    made for each of them. The list can be passed either as a bare list, or as
    an arrayref. Note that the name of the function being modified isn't passed
    in in any way; this syntax is only intended for cases where the function
    being modified doesn't actually matter. If the function name does matter,
    use something like this:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  for my $func (qw(foo bar baz)) {
      before $func =&gt; sub {
          warn &quot;$func was called!&quot;;
      };
  }
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Using_regular_expressions_to_select_methods_to_wrap"><a class="permalink" href="#Using_regular_expressions_to_select_methods_to_wrap">Using
  regular expressions to select methods to wrap</a></h2>
In addition, you can specify a regular expression to indicate the methods to
  wrap, like so:
<p class="Pp"><span class="Li"></span></p>
<pre>
  after qr/^command_/ =&gt; sub {
      warn &quot;got a command&quot;;
  };
</pre>
<p class="Pp">This will match the regular expression against each method name
    returned by &quot;get_method_list&quot; in Class::MOP::Class, and add a
    modifier to each one that matches. The same caveats apply as above.</p>
<p class="Pp">Using regular expressions to determine methods to wrap is quite a
    bit more powerful than the previous alternatives, but it's also quite a bit
    more dangerous. Bear in mind that if your regular expression matches certain
    Perl and Moose reserved method names with a special meaning to Moose or
    Perl, such as <span class="Li">&quot;meta&quot;</span>,
    <span class="Li">&quot;new&quot;</span>,
    <span class="Li">&quot;BUILD&quot;</span>,
    <span class="Li">&quot;DESTROY&quot;</span>,
    <span class="Li">&quot;AUTOLOAD&quot;</span>, etc, this could cause
    unintended (and hard to debug) problems and is best avoided.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="INNER_AND_AUGMENT"><a class="permalink" href="#INNER_AND_AUGMENT">INNER
  AND AUGMENT</a></h1>
Augment and inner are two halves of the same feature. The augment modifier
  provides a sort of inverted subclassing. You provide part of the
  implementation in a superclass, and then document that subclasses are expected
  to provide the rest.
<p class="Pp">The superclass calls <span class="Li">&quot;inner()&quot;</span>,
    which then calls the <span class="Li">&quot;augment&quot;</span> modifier in
    the subclass:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  package Document;

  use Moose;

  sub as_xml {
      my $self = shift;

      my $xml = &quot;&lt;document&gt;\n&quot;;
      $xml .= inner();
      $xml .= &quot;&lt;/document&gt;\n&quot;;

      return $xml;
  }
</pre>
<p class="Pp">Using <span class="Li">&quot;inner()&quot;</span> in this method
    makes it possible for one or more subclasses to then augment this method
    with their own specific implementation:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  package Report;

  use Moose;

  extends 'Document';

  augment 'as_xml' =&gt; sub {
      my $self = shift;

      my $xml = &quot;  &lt;report&gt;\n&quot;;
      $xml .= inner();
      $xml .= &quot;  &lt;/report&gt;\n&quot;;

      return $xml;
  };
</pre>
<p class="Pp">When we call <span class="Li">&quot;as_xml&quot;</span> on a
    Report object, we get something like this:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  &lt;document&gt;
    &lt;report&gt;
    &lt;/report&gt;
  &lt;/document&gt;
</pre>
<p class="Pp">But we also called <span class="Li">&quot;inner()&quot;</span> in
    <span class="Li">&quot;Report&quot;</span>, so we can continue subclassing
    and adding more content inside the document:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  package Report::IncomeAndExpenses;

  use Moose;

  extends 'Report';

  augment 'as_xml' =&gt; sub {
      my $self = shift;

      my $xml = '    &lt;income&gt;' . $self-&gt;income . '&lt;/income&gt;';
      $xml .= &quot;\n&quot;;
      $xml .= '    &lt;expenses&gt;' . $self-&gt;expenses . '&lt;/expenses&gt;';
      $xml .= &quot;\n&quot;;

      $xml .= inner() || q{};

      return $xml;
  };
</pre>
<p class="Pp">Now our report has some content:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  &lt;document&gt;
    &lt;report&gt;
      &lt;income&gt;$10&lt;/income&gt;
      &lt;expenses&gt;$8&lt;/expenses&gt;
    &lt;/report&gt;
  &lt;/document&gt;
</pre>
<p class="Pp">What makes this combination of
    <span class="Li">&quot;augment&quot;</span> and
    <span class="Li">&quot;inner()&quot;</span> special is that it allows us to
    have methods which are called from parent (least specific) to child (most
    specific). This inverts the normal inheritance pattern.</p>
<p class="Pp">Note that in
    <span class="Li">&quot;Report::IncomeAndExpenses&quot;</span> we call
    <span class="Li">&quot;inner()&quot;</span> again. If the object is an
    instance of <span class="Li">&quot;Report::IncomeAndExpenses&quot;</span>
    then this call is a no-op, and just returns false. It's a good idea to
    always call <span class="Li">&quot;inner()&quot;</span> to allow for future
    subclassing.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="OVERRIDE_AND_SUPER"><a class="permalink" href="#OVERRIDE_AND_SUPER">OVERRIDE
  AND SUPER</a></h1>
Finally, Moose provides some simple sugar for Perl's built-in method overriding
  scheme. If you want to override a method from a parent class, you can do this
  with <span class="Li">&quot;override&quot;</span>:
<p class="Pp"><span class="Li"></span></p>
<pre>
  package Employee;

  use Moose;

  extends 'Person';

  has 'job_title' =&gt; ( is =&gt; 'rw' );

  override 'display_name' =&gt; sub {
      my $self = shift;

      return super() . q{, } . $self-&gt;title();
  };
</pre>
<p class="Pp">The call to <span class="Li">&quot;super()&quot;</span> is almost
    the same as calling
    <span class="Li">&quot;$self-&gt;SUPER::display_name&quot;</span>. The
    difference is that the arguments passed to the superclass's method will
    always be the same as the ones passed to the method modifier, and cannot be
    changed.</p>
<p class="Pp">All arguments passed to
    <span class="Li">&quot;super()&quot;</span> are ignored, as are any changes
    made to <span class="Li">@_</span> before
    <span class="Li">&quot;super()&quot;</span> is called.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEMI-COLONS"><a class="permalink" href="#SEMI-COLONS">SEMI-COLONS</a></h1>
Because all of these method modifiers are implemented as Perl functions, you
  must always end the modifier declaration with a semi-colon:
<p class="Pp"><span class="Li"></span></p>
<pre>
  after 'foo' =&gt; sub { };
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="CAVEATS"><a class="permalink" href="#CAVEATS">CAVEATS</a></h1>
These method modification features do not work well with multiple inheritance,
  due to how method resolution is performed in Perl. Experiment with a test
  program to ensure your class hierarchy works as expected, or more preferably,
  don't use multiple inheritance (roles can help with this)!
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHORS"><a class="permalink" href="#AUTHORS">AUTHORS</a></h1>
<ul class="Bl-bullet">
  <li>Stevan Little &lt;stevan.little@iinteractive.com&gt;</li>
  <li>Dave Rolsky &lt;autarch@urth.org&gt;</li>
  <li>Jesse Luehrs &lt;doy@tozt.net&gt;</li>
  <li>Shawn M Moore &lt;code@sartak.org&gt;</li>
  <li>XXXX XXX'XX (Yuval Kogman) &lt;nothingmuch@woobling.org&gt;</li>
  <li>Karen Etheridge &lt;ether@cpan.org&gt;</li>
  <li>Florian Ragwitz &lt;rafl@debian.org&gt;</li>
  <li>Hans Dieter Pearcey &lt;hdp@weftsoar.net&gt;</li>
  <li>Chris Prather &lt;chris@prather.org&gt;</li>
  <li>Matt S Trout &lt;mst@shadowcat.co.uk&gt;</li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT_AND_LICENSE"><a class="permalink" href="#COPYRIGHT_AND_LICENSE">COPYRIGHT
  AND LICENSE</a></h1>
This software is copyright (c) 2006 by Infinity Interactive, Inc..
<p class="Pp">This is free software; you can redistribute it and/or modify it
    under the same terms as the Perl 5 programming language system itself.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2014-01-19</td>
    <td class="foot-os">perl v5.18.2</td>
  </tr>
</table>
</body>
</html>
