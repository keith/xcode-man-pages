<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    .Nd, .Bf, .Op { display: inline; }
    .Pa, .Ad { font-style: italic; }
    .Ms { font-weight: bold; }
    .Bl-diag > dt { font-weight: bold; }
    code.Nm, .Fl, .Cm, .Ic, code.In, .Fd, .Fn, .Cd { font-weight: bold;
      font-family: inherit; }
  </style>
  <title>Expat(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Expat(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Expat(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">XML::Parser::Expat - Lowlevel access to James Clark's expat XML
    parser</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre> use XML::Parser::Expat;
 $parser = XML::Parser::Expat-&gt;new;
 $parser-&gt;setHandlers('Start' =&gt; \&amp;sh,
                      'End'   =&gt; \&amp;eh,
                      'Char'  =&gt; \&amp;ch);
 open(FOO, '&lt;', 'info.xml') or die &quot;Couldn't open&quot;;
 $parser-&gt;parse(*FOO);
 close(FOO);
 # $parser-&gt;parse('&lt;foo id=&quot;me&quot;&gt; here &lt;em&gt;we&lt;/em&gt; go &lt;/foo&gt;');
 sub sh
 {
   my ($p, $el, %atts) = @_;
   $p-&gt;setHandlers('Char' =&gt; \&amp;spec)
     if ($el eq 'special');
   ...
 }
 sub eh
 {
   my ($p, $el) = @_;
   $p-&gt;setHandlers('Char' =&gt; \&amp;ch)  # Special elements won't contain
     if ($el eq 'special');         # other special elements
   ...
 }
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">This module provides an interface to James Clark's XML parser,
    expat. As in expat, a single instance of the parser can only parse one
    document. Calls to parsestring after the first for a given instance will
    die.</p>
<p class="Pp">Expat (and XML::Parser::Expat) are event based. As the parser
    recognizes parts of the document (say the start or end of an XML element),
    then any handlers registered for that type of an event are called with
    suitable parameters.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="METHODS"><a class="permalink" href="#METHODS">METHODS</a></h1>
<dl class="Bl-tag">
  <dt id="new"><a class="permalink" href="#new">new</a></dt>
  <dd>This is a class method, the constructor for XML::Parser::Expat. Options
      are passed as keyword value pairs. The recognized options are:</dd>
</dl>
<div class="Bd-indent">
<ul class="Bl-bullet">
  <li>ProtocolEncoding
    <p class="Pp">The protocol encoding name. The default is none. The expat
        built-in encodings are: <span class="Li">&quot;UTF-8&quot;</span>,
        <span class="Li">&quot;ISO-8859-1&quot;</span>,
        <span class="Li">&quot;UTF-16&quot;</span>, and
        <span class="Li">&quot;US-ASCII&quot;</span>. Other encodings may be
        used if they have encoding maps in one of the directories in the
        <span class="Li">@Encoding_Path</span> list. Setting the protocol
        encoding overrides any encoding in the XML declaration.</p>
  </li>
  <li>Namespaces
    <p class="Pp">When this option is given with a true value, then the parser
        does namespace processing. By default, namespace processing is turned
        off. When it is turned on, the parser consumes <i>xmlns</i> attributes
        and strips off prefixes from element and attributes names where those
        prefixes have a defined namespace. A name's namespace can be found using
        the &quot;namespace&quot; method and two names can be checked for
        absolute equality with the &quot;eq_name&quot; method.</p>
  </li>
  <li>NoExpand
    <p class="Pp">Normally, the parser will try to expand references to entities
        defined in the internal subset. If this option is set to a true value,
        and a default handler is also set, then the default handler will be
        called when an entity reference is seen in text. This has no effect if a
        default handler has not been registered, and it has no effect on the
        expansion of entity references inside attribute values.</p>
  </li>
  <li>Stream_Delimiter
    <p class="Pp">This option takes a string value. When this string is found
        alone on a line while parsing from a stream, then the parse is ended as
        if it saw an end of file. The intended use is with a stream of xml
        documents in a MIME multipart format. The string should not contain a
        trailing newline.</p>
  </li>
  <li>ErrorContext
    <p class="Pp">When this option is defined, errors are reported in context.
        The value of ErrorContext should be the number of lines to show on
        either side of the line in which the error occurred.</p>
  </li>
  <li>ParseParamEnt
    <p class="Pp">Unless standalone is set to &quot;yes&quot; in the XML
        declaration, setting this to a true value allows the external DTD to be
        read, and parameter entities to be parsed and expanded.</p>
  </li>
  <li>Base
    <p class="Pp">The base to use for relative pathnames or URLs. This can also
        be done by using the base method.</p>
  </li>
</ul>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt id="setHandlers("><a class="permalink" href="#setHandlers(">setHandlers(TYPE,
    HANDLER [, TYPE, HANDLER [...]])</a></dt>
  <dd>This method registers handlers for the various events. If no handlers are
      registered, then a call to parsestring or parsefile will only determine if
      the corresponding XML document is well formed (by returning without
      error.) This may be called from within a handler, after the parse has
      started.
    <p class="Pp">Setting a handler to something that evaluates to false unsets
        that handler.</p>
    <p class="Pp">This method returns a list of type, handler pairs
        corresponding to the input. The handlers returned are the ones that were
        in effect before the call to setHandlers.</p>
    <p class="Pp">The recognized events and the parameters passed to the
        corresponding handlers are:</p>
  </dd>
</dl>
<div class="Bd-indent">
<ul class="Bl-bullet">
  <li>Start (Parser, Element [, Attr, Val [,...]])
    <p class="Pp">This event is generated when an XML start tag is recognized.
        Parser is an XML::Parser::Expat instance. Element is the name of the XML
        element that is opened with the start tag. The Attr &amp; Val pairs are
        generated for each attribute in the start tag.</p>
  </li>
  <li>End (Parser, Element)
    <p class="Pp">This event is generated when an XML end tag is recognized.
        Note that an XML empty tag (&lt;foo/&gt;) generates both a start and an
        end event.</p>
    <p class="Pp">There is always a lower level start and end handler installed
        that wrap the corresponding callbacks. This is to handle the context
        mechanism. A consequence of this is that the default handler (see below)
        will not see a start tag or end tag unless the default_current method is
        called.</p>
  </li>
  <li>Char (Parser, String)
    <p class="Pp">This event is generated when non-markup is recognized. The
        non-markup sequence of characters is in String. A single non-markup
        sequence of characters may generate multiple calls to this handler.
        Whatever the encoding of the string in the original document, this is
        given to the handler in UTF-8.</p>
  </li>
  <li>Proc (Parser, Target, Data)
    <p class="Pp">This event is generated when a processing instruction is
        recognized.</p>
  </li>
  <li>Comment (Parser, String)
    <p class="Pp">This event is generated when a comment is recognized.</p>
  </li>
  <li>CdataStart (Parser)
    <p class="Pp">This is called at the start of a CDATA section.</p>
  </li>
  <li>CdataEnd (Parser)
    <p class="Pp">This is called at the end of a CDATA section.</p>
  </li>
  <li>Default (Parser, String)
    <p class="Pp">This is called for any characters that don't have a registered
        handler. This includes both characters that are part of markup for which
        no events are generated (markup declarations) and characters that could
        generate events, but for which no handler has been registered.</p>
    <p class="Pp">Whatever the encoding in the original document, the string is
        returned to the handler in UTF-8.</p>
  </li>
  <li>Unparsed (Parser, Entity, Base, Sysid, Pubid, Notation)
    <p class="Pp">This is called for a declaration of an unparsed entity. Entity
        is the name of the entity. Base is the base to be used for resolving a
        relative URI. Sysid is the system id. Pubid is the public id. Notation
        is the notation name. Base and Pubid may be undefined.</p>
  </li>
  <li>Notation (Parser, Notation, Base, Sysid, Pubid)
    <p class="Pp">This is called for a declaration of notation. Notation is the
        notation name. Base is the base to be used for resolving a relative URI.
        Sysid is the system id. Pubid is the public id. Base, Sysid, and Pubid
        may all be undefined.</p>
  </li>
  <li>ExternEnt (Parser, Base, Sysid, Pubid)
    <p class="Pp">This is called when an external entity is referenced. Base is
        the base to be used for resolving a relative URI. Sysid is the system
        id. Pubid is the public id. Base, and Pubid may be undefined.</p>
    <p class="Pp">This handler should either return a string, which represents
        the contents of the external entity, or return an open filehandle that
        can be read to obtain the contents of the external entity, or return
        undef, which indicates the external entity couldn't be found and will
        generate a parse error.</p>
    <p class="Pp">If an open filehandle is returned, it must be returned as
        either a glob (*FOO) or as a reference to a glob (e.g. an instance of
        IO::Handle).</p>
  </li>
  <li>ExternEntFin (Parser)
    <p class="Pp">This is called after an external entity has been parsed. It
        allows applications to perform cleanup on actions performed in the above
        ExternEnt handler.</p>
  </li>
  <li>Entity (Parser, Name, Val, Sysid, Pubid, Ndata, IsParam)
    <p class="Pp">This is called when an entity is declared. For internal
        entities, the Val parameter will contain the value and the remaining
        three parameters will be undefined. For external entities, the Val
        parameter will be undefined, the Sysid parameter will have the system
        id, the Pubid parameter will have the public id if it was provided (it
        will be undefined otherwise), the Ndata parameter will contain the
        notation for unparsed entities. If this is a parameter entity
        declaration, then the IsParam parameter is true.</p>
    <p class="Pp">Note that this handler and the Unparsed handler above overlap.
        If both are set, then this handler will not be called for unparsed
        entities.</p>
  </li>
  <li>Element (Parser, Name, Model)
    <p class="Pp">The element handler is called when an element declaration is
        found. Name is the element name, and Model is the content model as an
        XML::Parser::ContentModel object. See &quot;XML::Parser::ContentModel
        Methods&quot; for methods available for this class.</p>
  </li>
  <li>Attlist (Parser, Elname, Attname, Type, Default, Fixed)
    <p class="Pp">This handler is called for each attribute in an ATTLIST
        declaration. So an ATTLIST declaration that has multiple attributes will
        generate multiple calls to this handler. The Elname parameter is the
        name of the element with which the attribute is being associated. The
        Attname parameter is the name of the attribute. Type is the attribute
        type, given as a string. Default is the default value, which will either
        be &quot;#REQUIRED&quot;, &quot;#IMPLIED&quot; or a quoted string (i.e.
        the returned string will begin and end with a quote character). If Fixed
        is true, then this is a fixed attribute.</p>
  </li>
  <li>Doctype (Parser, Name, Sysid, Pubid, Internal)
    <p class="Pp">This handler is called for DOCTYPE declarations. Name is the
        document type name. Sysid is the system id of the document type, if it
        was provided, otherwise it's undefined. Pubid is the public id of the
        document type, which will be undefined if no public id was given.
        Internal will be true or false, indicating whether or not the doctype
        declaration contains an internal subset.</p>
  </li>
  <li>DoctypeFin (Parser)
    <p class="Pp">This handler is called after parsing of the DOCTYPE
        declaration has finished, including any internal or external DTD
        declarations.</p>
  </li>
  <li>XMLDecl (Parser, Version, Encoding, Standalone)
    <p class="Pp">This handler is called for XML declarations. Version is a
        string containg the version. Encoding is either undefined or contains an
        encoding string. Standalone is either undefined, or true or false.
        Undefined indicates that no standalone parameter was given in the XML
        declaration. True or false indicates &quot;yes&quot; or &quot;no&quot;
        respectively.</p>
  </li>
</ul>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt id="namespace(name)"><a class="permalink" href="#namespace(name)">namespace(name)</a></dt>
  <dd>Return the URI of the namespace that the name belongs to. If the name
      doesn't belong to any namespace, an undef is returned. This is only valid
      on names received through the Start or End handlers from a single
      document, or through a call to the generate_ns_name method. In other
      words, don't use names generated from one instance of XML::Parser::Expat
      with other instances.</dd>
  <dt id="eq_name(name1,"><a class="permalink" href="#eq_name(name1,">eq_name(name1,
    name2)</a></dt>
  <dd>Return true if name1 and name2 are identical (i.e. same name and from the
      same namespace.) This is only meaningful if both names were obtained
      through the Start or End handlers from a single document, or through a
      call to the generate_ns_name method.</dd>
  <dt id="generate_ns_name(name,"><a class="permalink" href="#generate_ns_name(name,">generate_ns_name(name,
    namespace)</a></dt>
  <dd>Return a name, associated with a given namespace, good for using with the
      above 2 methods. The namespace argument should be the namespace URI, not a
      prefix.</dd>
  <dt id="new_ns_prefixes"><a class="permalink" href="#new_ns_prefixes">new_ns_prefixes</a></dt>
  <dd>When called from a start tag handler, returns namespace prefixes declared
      with this start tag. If called elsewere (or if there were no namespace
      prefixes declared), it returns an empty list. Setting of the default
      namespace is indicated with '#default' as a prefix.</dd>
  <dt id="expand_ns_prefix(prefix)"><a class="permalink" href="#expand_ns_prefix(prefix)">expand_ns_prefix(prefix)</a></dt>
  <dd>Return the uri to which the given prefix is currently bound. Returns undef
      if the prefix isn't currently bound. Use '#default' to find the current
      binding of the default namespace (if any).</dd>
  <dt id="current_ns_prefixes"><a class="permalink" href="#current_ns_prefixes">current_ns_prefixes</a></dt>
  <dd>Return a list of currently bound namespace prefixes. The order of the the
      prefixes in the list has no meaning. If the default namespace is currently
      bound, '#default' appears in the list.</dd>
  <dt id="recognized_string"><a class="permalink" href="#recognized_string">recognized_string</a></dt>
  <dd>Returns the string from the document that was recognized in order to call
      the current handler. For instance, when called from a start handler, it
      will give us the the start-tag string. The string is encoded in UTF-8.
      This method doesn't return a meaningful string inside declaration
      handlers.</dd>
  <dt id="original_string"><a class="permalink" href="#original_string">original_string</a></dt>
  <dd>Returns the verbatim string from the document that was recognized in order
      to call the current handler. The string is in the original document
      encoding. This method doesn't return a meaningful string inside
      declaration handlers.</dd>
  <dt id="default_current"><a class="permalink" href="#default_current">default_current</a></dt>
  <dd>When called from a handler, causes the sequence of characters that
      generated the corresponding event to be sent to the default handler (if
      one is registered). Use of this method is deprecated in favor the
      recognized_string method, which you can use without installing a default
      handler. This method doesn't deliver a meaningful string to the default
      handler when called from inside declaration handlers.</dd>
  <dt id="xpcroak(message)"><a class="permalink" href="#xpcroak(message)">xpcroak(message)</a></dt>
  <dd>Concatenate onto the given message the current line number within the XML
      document plus the message implied by ErrorContext. Then croak with the
      formed message.</dd>
  <dt id="xpcarp(message)"><a class="permalink" href="#xpcarp(message)">xpcarp(message)</a></dt>
  <dd>Concatenate onto the given message the current line number within the XML
      document plus the message implied by ErrorContext. Then carp with the
      formed message.</dd>
  <dt id="current_line"><a class="permalink" href="#current_line">current_line</a></dt>
  <dd>Returns the line number of the current position of the parse.</dd>
  <dt id="current_column"><a class="permalink" href="#current_column">current_column</a></dt>
  <dd>Returns the column number of the current position of the parse.</dd>
  <dt id="current_byte"><a class="permalink" href="#current_byte">current_byte</a></dt>
  <dd>Returns the current position of the parse.</dd>
  <dt id="base(_"><a class="permalink" href="#base(_">base([NEWBASE]);</a></dt>
  <dd>Returns the current value of the base for resolving relative URIs. If
      NEWBASE is supplied, changes the base to that value.</dd>
  <dt id="context"><a class="permalink" href="#context">context</a></dt>
  <dd>Returns a list of element names that represent open elements, with the
      last one being the innermost. Inside start and end tag handlers, this will
      be the tag of the parent element.</dd>
  <dt id="current_element"><a class="permalink" href="#current_element">current_element</a></dt>
  <dd>Returns the name of the innermost currently opened element. Inside start
      or end handlers, returns the parent of the element associated with those
      tags.</dd>
  <dt id="in_element("><a class="permalink" href="#in_element(">in_element(NAME)</a></dt>
  <dd>Returns true if NAME is equal to the name of the innermost currently
      opened element. If namespace processing is being used and you want to
      check against a name that may be in a namespace, then use the
      generate_ns_name method to create the NAME argument.</dd>
  <dt id="within_element("><a class="permalink" href="#within_element(">within_element(NAME)</a></dt>
  <dd>Returns the number of times the given name appears in the context list. If
      namespace processing is being used and you want to check against a name
      that may be in a namespace, then use the generate_ns_name method to create
      the NAME argument.</dd>
  <dt id="depth"><a class="permalink" href="#depth">depth</a></dt>
  <dd>Returns the size of the context list.</dd>
  <dt id="element_index"><a class="permalink" href="#element_index">element_index</a></dt>
  <dd>Returns an integer that is the depth-first visit order of the current
      element. This will be zero outside of the root element. For example, this
      will return 1 when called from the start handler for the root element
      start tag.</dd>
  <dt id="skip_until("><a class="permalink" href="#skip_until(">skip_until(INDEX)</a></dt>
  <dd>INDEX is an integer that represents an element index. When this method is
      called, all handlers are suspended until the start tag for an element that
      has an index number equal to INDEX is seen. If a start handler has been
      set, then this is the first tag that the start handler will see after
      skip_until has been called.</dd>
  <dt id="position_in_context("><a class="permalink" href="#position_in_context(">position_in_context(LINES)</a></dt>
  <dd>Returns a string that shows the current parse position. LINES should be an
      integer &gt;= 0 that represents the number of lines on either side of the
      current parse line to place into the returned string.</dd>
  <dt id="xml_escape("><a class="permalink" href="#xml_escape(">xml_escape(TEXT
    [, CHAR [, CHAR ...]])</a></dt>
  <dd>Returns TEXT with markup characters turned into character entities. Any
      additional characters provided as arguments are also turned into character
      references where found in TEXT.</dd>
  <dt id="parse"><a class="permalink" href="#parse">parse (SOURCE)</a></dt>
  <dd>The SOURCE parameter should either be a string containing the whole XML
      document, or it should be an open IO::Handle. Only a single document may
      be parsed for a given instance of XML::Parser::Expat, so this will croak
      if it's been called previously for this instance.</dd>
  <dt id="parsestring("><a class="permalink" href="#parsestring(">parsestring(XML_DOC_STRING)</a></dt>
  <dd>Parses the given string as an XML document. Only a single document may be
      parsed for a given instance of XML::Parser::Expat, so this will die if
      either parsestring or parsefile has been called for this instance
      previously.
    <p class="Pp">This method is deprecated in favor of the parse method.</p>
  </dd>
  <dt id="parsefile("><a class="permalink" href="#parsefile(">parsefile(FILENAME)</a></dt>
  <dd>Parses the XML document in the given file. Will die if parsestring or
      parsefile has been called previously for this instance.</dd>
  <dt id="is_defaulted("><a class="permalink" href="#is_defaulted(">is_defaulted(ATTNAME)</a></dt>
  <dd>NO LONGER WORKS. To find out if an attribute is defaulted please use the
      specified_attr method.</dd>
  <dt id="specified_attr"><a class="permalink" href="#specified_attr">specified_attr</a></dt>
  <dd>When the start handler receives lists of attributes and values, the
      non-defaulted (i.e. explicitly specified) attributes occur in the list
      first. This method returns the number of specified items in the list. So
      if this number is equal to the length of the list, there were no defaulted
      values. Otherwise the number points to the index of the first defaulted
      attribute name.</dd>
  <dt id="finish"><a class="permalink" href="#finish">finish</a></dt>
  <dd>Unsets all handlers (including internal ones that set context), but expat
      continues parsing to the end of the document or until it finds an error.
      It should finish up a lot faster than with the handlers set.</dd>
  <dt id="release"><a class="permalink" href="#release">release</a></dt>
  <dd>There are data structures used by XML::Parser::Expat that have circular
      references. This means that these structures will never be garbage
      collected unless these references are explicitly broken. Calling this
      method breaks those references (and makes the instance unusable.)
    <p class="Pp">Normally, higher level calls handle this for you, but if you
        are using XML::Parser::Expat directly, then it's your responsibility to
        call it.</p>
  </dd>
</dl>
<section class="Ss">
<h2 class="Ss" id="XML::Parser::ContentModel_Methods"><a class="permalink" href="#XML::Parser::ContentModel_Methods">XML::Parser::ContentModel
  Methods</a></h2>
<p class="Pp">The element declaration handlers are passed objects of this class
    as the content model of the element declaration. They also represent content
    particles, components of a content model.</p>
<p class="Pp">When referred to as a string, these objects are automagicly
    converted to a string representation of the model (or content particle).</p>
<dl class="Bl-tag">
  <dt id="isempty"><a class="permalink" href="#isempty">isempty</a></dt>
  <dd>This method returns true if the object is &quot;EMPTY&quot;, false
      otherwise.</dd>
  <dt id="isany"><a class="permalink" href="#isany">isany</a></dt>
  <dd>This method returns true if the object is &quot;ANY&quot;, false
      otherwise.</dd>
  <dt id="ismixed"><a class="permalink" href="#ismixed">ismixed</a></dt>
  <dd>This method returns true if the object is &quot;(#PCDATA)&quot; or
      &quot;(#PCDATA|...)*&quot;, false otherwise.</dd>
  <dt id="isname"><a class="permalink" href="#isname">isname</a></dt>
  <dd>This method returns if the object is an element name.</dd>
  <dt id="ischoice"><a class="permalink" href="#ischoice">ischoice</a></dt>
  <dd>This method returns true if the object is a choice of content
    particles.</dd>
  <dt id="isseq"><a class="permalink" href="#isseq">isseq</a></dt>
  <dd>This method returns true if the object is a sequence of content
    particles.</dd>
  <dt id="quant"><a class="permalink" href="#quant">quant</a></dt>
  <dd>This method returns undef or a string representing the quantifier ('?',
      '*', '+') associated with the model or particle.</dd>
  <dt id="children"><a class="permalink" href="#children">children</a></dt>
  <dd>This method returns undef or (for mixed, choice, and sequence types) an
      array of component content particles. There will always be at least one
      component for choices and sequences, but for a mixed content model of pure
      PCDATA, &quot;(#PCDATA)&quot;, then an undef is returned.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="XML::Parser::ExpatNB_Methods"><a class="permalink" href="#XML::Parser::ExpatNB_Methods">XML::Parser::ExpatNB
  Methods</a></h2>
<p class="Pp">The class XML::Parser::ExpatNB is a subclass of XML::Parser::Expat
    used for non-blocking access to the expat library. It does not support the
    parse, parsestring, or parsefile methods, but it does have these additional
    methods:</p>
<dl class="Bl-tag">
  <dt id="parse_more("><a class="permalink" href="#parse_more(">parse_more(DATA)</a></dt>
  <dd>Feed expat more text to munch on.</dd>
  <dt id="parse_done"><a class="permalink" href="#parse_done">parse_done</a></dt>
  <dd>Tell expat that it's gotten the whole document.</dd>
</dl>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="FUNCTIONS"><a class="permalink" href="#FUNCTIONS">FUNCTIONS</a></h1>
<dl class="Bl-tag">
  <dt id="XML::Parser::Expat::load_encoding("><a class="permalink" href="#XML::Parser::Expat::load_encoding(">XML::Parser::Expat::load_encoding(ENCODING)</a></dt>
  <dd>Load an external encoding. ENCODING is either the name of an encoding or
      the name of a file. The basename is converted to lowercase and a '.enc'
      extension is appended unless there's one already there. Then, unless it's
      an absolute pathname (i.e. begins with '/'), the first file by that name
      discovered in the <span class="Li">@Encoding_Path</span> path list is
      used.
    <p class="Pp">The encoding in the file is loaded and kept in the
        <span class="Li">%Encoding_Table</span> table. Earlier encodings of the
        same name are replaced.</p>
    <p class="Pp">This function is automatically called by expat when it
        encounters an encoding it doesn't know about. Expat shouldn't call this
        twice for the same encoding name. The only reason users should use this
        function is to explicitly load an encoding not contained in the
        <span class="Li">@Encoding_Path</span> list.</p>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHORS"><a class="permalink" href="#AUTHORS">AUTHORS</a></h1>
<p class="Pp">Larry Wall &lt;<i>larry@wall.org</i>&gt; wrote version 1.0.</p>
<p class="Pp">Clark Cooper &lt;<i>coopercc@netheaven.com</i>&gt; picked up
    support, changed the API for this version (2.x), provided documentation, and
    added some standard package features.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2011-06-02</td>
    <td class="foot-os">perl v5.18.4</td>
  </tr>
</table>
</body>
</html>
