<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.10 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>Unicode::Collate(3pm)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Unicode::Collate(3pm)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">Unicode::Collate(3pm)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
Unicode::Collate - Unicode Collation Algorithm
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<span class="Li"></span>
<pre>
  use Unicode::Collate;

  #construct
  $Collator = Unicode::Collate-&gt;new(%tailoring);

  #sort
  @sorted = $Collator-&gt;sort(@not_sorted);

  #compare
  $result = $Collator-&gt;cmp($a, $b); # returns 1, 0, or -1.
</pre>
<p class="Pp"><b>Note:</b> Strings in <span class="Li">@not_sorted</span>,
    <span class="Li">$a</span> and <span class="Li">$b</span> are interpreted
    according to Perl's Unicode support. See perlunicode, perluniintro,
    perlunitut, perlunifaq, utf8. Otherwise you can use
    <span class="Li">&quot;preprocess&quot;</span> or should decode them
  before.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
This module is an implementation of Unicode Technical Standard #10 (a.k.a. UTS
  #10) - Unicode Collation Algorithm (a.k.a. UCA).
<section class="Ss">
<h2 class="Ss" id="Constructor_and_Tailoring"><a class="permalink" href="#Constructor_and_Tailoring">Constructor
  and Tailoring</a></h2>
The <span class="Li">&quot;new&quot;</span> method returns a collator object. If
  <b>new()</b> is called with no parameters, the collator should do the default
  collation.
<p class="Pp"><span class="Li"></span></p>
<pre>
   $Collator = Unicode::Collate-&gt;new(
      UCA_Version =&gt; $UCA_Version,
      alternate =&gt; $alternate, # alias for 'variable'
      backwards =&gt; $levelNumber, # or \@levelNumbers
      entry =&gt; $element,
      hangul_terminator =&gt; $term_primary_weight,
      highestFFFF =&gt; $bool,
      identical =&gt; $bool,
      ignoreName =&gt; qr/$ignoreName/,
      ignoreChar =&gt; qr/$ignoreChar/,
      ignore_level2 =&gt; $bool,
      katakana_before_hiragana =&gt; $bool,
      level =&gt; $collationLevel,
      long_contraction =&gt; $bool,
      minimalFFFE =&gt; $bool,
      normalization  =&gt; $normalization_form,
      overrideCJK =&gt; \&amp;overrideCJK,
      overrideHangul =&gt; \&amp;overrideHangul,
      preprocess =&gt; \&amp;preprocess,
      rearrange =&gt; \@charList,
      rewrite =&gt; \&amp;rewrite,
      suppress =&gt; \@charList,
      table =&gt; $filename,
      undefName =&gt; qr/$undefName/,
      undefChar =&gt; qr/$undefChar/,
      upper_before_lower =&gt; $bool,
      variable =&gt; $variable,
   );
</pre>
<dl class="Bl-tag">
  <dt>UCA_Version</dt>
  <dd>If the revision (previously &quot;tracking version&quot;) number of UCA is
      given, behavior of that revision is emulated on collating. If omitted, the
      return value of <span class="Li">&quot;UCA_Version()&quot;</span> is used.
    <p class="Pp">The following revisions are supported. The default is 36.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
     UCA       Unicode Standard         DUCET (@version)
   -------------------------------------------------------
      8              3.1                3.0.1 (3.0.1d9)
      9     3.1 with Corrigendum 3      3.1.1 (3.1.1)
     11              4.0                4.0.0 (4.0.0)
     14             4.1.0               4.1.0 (4.1.0)
     16              5.0                5.0.0 (5.0.0)
     18             5.1.0               5.1.0 (5.1.0)
     20             5.2.0               5.2.0 (5.2.0)
     22             6.0.0               6.0.0 (6.0.0)
     24             6.1.0               6.1.0 (6.1.0)
     26             6.2.0               6.2.0 (6.2.0)
     28             6.3.0               6.3.0 (6.3.0)
     30             7.0.0               7.0.0 (7.0.0)
     32             8.0.0               8.0.0 (8.0.0)
     34             9.0.0               9.0.0 (9.0.0)
     36            10.0.0              10.0.0(10.0.0)
    </pre>
    <p class="Pp">* See below for
        <span class="Li">&quot;long_contraction&quot;</span> with
        <span class="Li">&quot;UCA_Version&quot;</span> 22 and 24.</p>
    <p class="Pp">* Noncharacters (e.g. U+FFFF) are not ignored, and can be
        overridden since <span class="Li">&quot;UCA_Version&quot;</span> 22.</p>
    <p class="Pp">* Out-of-range codepoints (greater than U+10FFFF) are not
        ignored, and can be overridden since
        <span class="Li">&quot;UCA_Version&quot;</span> 22.</p>
    <p class="Pp">* Fully ignorable characters were ignored, and would not
        interrupt contractions with
        <span class="Li">&quot;UCA_Version&quot;</span> 9 and 11.</p>
    <p class="Pp">* Treatment of ignorables after variables and some behaviors
        were changed at <span class="Li">&quot;UCA_Version&quot;</span> 9.</p>
    <p class="Pp">* Characters regarded as CJK unified ideographs (cf.
        <span class="Li">&quot;overrideCJK&quot;</span>) depend on
        <span class="Li">&quot;UCA_Version&quot;</span>.</p>
    <p class="Pp">* Many hangul jamo are assigned at
        <span class="Li">&quot;UCA_Version&quot;</span> 20, that will affect
        <span class="Li">&quot;hangul_terminator&quot;</span>.</p>
  </dd>
  <dt>alternate</dt>
  <dd>-- see 3.2.2 Alternate Weighting, version 8 of UTS #10
    <p class="Pp">For backward compatibility,
        <span class="Li">&quot;alternate&quot;</span> (old name) can be used as
        an alias for <span class="Li">&quot;variable&quot;</span>.</p>
  </dd>
  <dt>backwards</dt>
  <dd>-- see 3.4 Backward Accents, UTS #10.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
     backwards =&gt; $levelNumber or \@levelNumbers
    </pre>
    <p class="Pp">Weights in reverse order; ex. level 2 (diacritic ordering) in
        French. If omitted (or <span class="Li">$levelNumber</span> is
        <span class="Li">&quot;undef&quot;</span> or
        <span class="Li">&quot;\@levelNumbers&quot;</span> is
        <span class="Li">&quot;[]&quot;</span>), forwards at all the levels.</p>
  </dd>
  <dt>entry</dt>
  <dd>-- see 5 Tailoring; 9.1 Allkeys File Format, UTS #10.
    <p class="Pp">If the same character (or a sequence of characters) exists in
        the collation element table through
        <span class="Li">&quot;table&quot;</span>, mapping to collation elements
        is overridden. If it does not exist, the mapping is defined
        additionally.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    entry =&gt; &lt;&lt;'ENTRY', # for DUCET v4.0.0 (allkeys-4.0.0.txt)
0063 0068 ; [.0E6A.0020.0002.0063] # ch
0043 0068 ; [.0E6A.0020.0007.0043] # Ch
0043 0048 ; [.0E6A.0020.0008.0043] # CH
006C 006C ; [.0F4C.0020.0002.006C] # ll
004C 006C ; [.0F4C.0020.0007.004C] # Ll
004C 004C ; [.0F4C.0020.0008.004C] # LL
00F1      ; [.0F7B.0020.0002.00F1] # n-tilde
006E 0303 ; [.0F7B.0020.0002.00F1] # n-tilde
00D1      ; [.0F7B.0020.0008.00D1] # N-tilde
004E 0303 ; [.0F7B.0020.0008.00D1] # N-tilde
ENTRY

    entry =&gt; &lt;&lt;'ENTRY', # for DUCET v4.0.0 (allkeys-4.0.0.txt)
00E6 ; [.0E33.0020.0002.00E6][.0E8B.0020.0002.00E6] # ae ligature as &lt;a&gt;&lt;e&gt;
00C6 ; [.0E33.0020.0008.00C6][.0E8B.0020.0008.00C6] # AE ligature as &lt;A&gt;&lt;E&gt;
ENTRY
    </pre>
    <p class="Pp"><b>NOTE:</b> The code point in the UCA file format (before
        <span class="Li">';'</span>) <b>must</b> be a Unicode code point
        (defined as hexadecimal), but not a native code point. So
        <span class="Li">0063</span> must always denote
        <span class="Li">&quot;U+0063&quot;</span>, but not a character of
        <span class="Li">&quot;\x63&quot;</span>.</p>
    <p class="Pp">Weighting may vary depending on collation element table. So
        ensure the weights defined in <span class="Li">&quot;entry&quot;</span>
        will be consistent with those in the collation element table loaded via
        <span class="Li">&quot;table&quot;</span>.</p>
    <p class="Pp">In DUCET v4.0.0, primary weight of
        <span class="Li">&quot;C&quot;</span> is <span class="Li">0E60</span>
        and that of <span class="Li">&quot;D&quot;</span> is
        <span class="Li">&quot;0E6D&quot;</span>. So setting primary weight of
        <span class="Li">&quot;CH&quot;</span> to
        <span class="Li">&quot;0E6A&quot;</span> (as a value between
        <span class="Li">0E60</span> and
        <span class="Li">&quot;0E6D&quot;</span>) makes ordering as
        <span class="Li">&quot;C &lt; CH &lt; D&quot;</span>. Exactly speaking
        DUCET already has some characters between
        <span class="Li">&quot;C&quot;</span> and
        <span class="Li">&quot;D&quot;</span>: <span class="Li">&quot;small
        capital C&quot;</span> (<span class="Li">&quot;U+1D04&quot;</span>) with
        primary weight <span class="Li">0E64</span>,
        <span class="Li">&quot;c-hook/C-hook&quot;</span>
        (<span class="Li">&quot;U+0188/U+0187&quot;</span>) with
        <span class="Li">0E65</span>, and
        <span class="Li">&quot;c-curl&quot;</span>
        (<span class="Li">&quot;U+0255&quot;</span>) with
        <span class="Li">0E69</span>. Then primary weight
        <span class="Li">&quot;0E6A&quot;</span> for
        <span class="Li">&quot;CH&quot;</span> makes
        <span class="Li">&quot;CH&quot;</span> ordered between
        <span class="Li">&quot;c-curl&quot;</span> and
        <span class="Li">&quot;D&quot;</span>.</p>
  </dd>
  <dt>hangul_terminator</dt>
  <dd>-- see 7.1.4 Trailing Weights, UTS #10.
    <p class="Pp">If a true value is given (non-zero but should be positive), it
        will be added as a terminator primary weight to the end of every
        standard Hangul syllable. Secondary and any higher weights for
        terminator are set to zero. If the value is false or
        <span class="Li">&quot;hangul_terminator&quot;</span> key does not
        exist, insertion of terminator weights will not be performed.</p>
    <p class="Pp">Boundaries of Hangul syllables are determined according to
        conjoining Jamo behavior in <i>the Unicode Standard</i> and
        <i>HangulSyllableType.txt</i>.</p>
    <p class="Pp"><b>Implementation Note:</b> (1) For expansion mapping (Unicode
        character mapped to a sequence of collation elements), a terminator will
        not be added between collation elements, even if Hangul syllable
        boundary exists there. Addition of terminator is restricted to the next
        position to the last collation element.</p>
    <p class="Pp">(2) Non-conjoining Hangul letters (Compatibility Jamo,
        halfwidth Jamo, and enclosed letters) are not automatically terminated
        with a terminator primary weight. These characters may need terminator
        included in a collation element table beforehand.</p>
  </dd>
  <dt>highestFFFF</dt>
  <dd>-- see 2.4 Tailored noncharacter weights, UTS #35 (LDML) Part 5:
      Collation.
    <p class="Pp">If the parameter is made true,
        <span class="Li">&quot;U+FFFF&quot;</span> has a highest primary weight.
        When a boolean of <span class="Li">&quot;$coll-&gt;ge($str,
        &quot;abc&quot;)&quot;</span> and
        <span class="Li">&quot;$coll-&gt;le($str,
        &quot;abc\x{FFFF}&quot;)&quot;</span> is true, it is expected that
        <span class="Li">$str</span> begins with
        <span class="Li">&quot;abc&quot;</span>, or another primary equivalent.
        <span class="Li">$str</span> may be
        <span class="Li">&quot;abcd&quot;</span>,
        <span class="Li">&quot;abc012&quot;</span>, but should not include
        <span class="Li">&quot;U+FFFF&quot;</span> such as
        <span class="Li">&quot;abc\x{FFFF}xyz&quot;</span>.</p>
    <p class="Pp"><span class="Li">&quot;$coll-&gt;le($str,
        &quot;abc\x{FFFF}&quot;)&quot;</span> works like
        <span class="Li">&quot;$coll-&gt;lt($str, &quot;abd&quot;)&quot;</span>
        almost, but the latter has a problem that you should know which letter
        is next to <span class="Li">&quot;c&quot;</span>. For a certain language
        where <span class="Li">&quot;ch&quot;</span> as the next letter,
        <span class="Li">&quot;abch&quot;</span> is greater than
        <span class="Li">&quot;abc\x{FFFF}&quot;</span>, but less than
        <span class="Li">&quot;abd&quot;</span>.</p>
    <p class="Pp">Note: This is equivalent to <span class="Li">&quot;(entry
        =&gt; 'FFFF ; [.FFFE.0020.0005.FFFF]')&quot;</span>. Any other character
        than <span class="Li">&quot;U+FFFF&quot;</span> can be tailored by
        <span class="Li">&quot;entry&quot;</span>.</p>
  </dd>
  <dt>identical</dt>
  <dd>-- see A.3 Deterministic Comparison, UTS #10.
    <p class="Pp">By default, strings whose weights are equal should be equal,
        even though their code points are not equal. Completely ignorable
        characters are ignored.</p>
    <p class="Pp">If the parameter is made true, a final, tie-breaking level is
        used. If no difference of weights is found after the comparison through
        all the level specified by <span class="Li">&quot;level&quot;</span>,
        the comparison with code points will be performed. For the tie-breaking
        comparison, the sort key has code points of the original string
        appended. Completely ignorable characters are not ignored.</p>
    <p class="Pp">If <span class="Li">&quot;preprocess&quot;</span> and/or
        <span class="Li">&quot;normalization&quot;</span> is applied, the code
        points of the string after them (in NFD by default) are used.</p>
  </dd>
  <dt>ignoreChar</dt>
  <dd></dd>
  <dt>ignoreName</dt>
  <dd>-- see 3.6 Variable Weighting, UTS #10.
    <p class="Pp">Makes the entry in the table completely ignorable; i.e. as if
        the weights were zero at all level.</p>
    <p class="Pp">Through <span class="Li">&quot;ignoreChar&quot;</span>, any
        character matching <span class="Li">&quot;qr/$ignoreChar/&quot;</span>
        will be ignored. Through <span class="Li">&quot;ignoreName&quot;</span>,
        any character whose name (given in the
        <span class="Li">&quot;table&quot;</span> file as a comment) matches
        <span class="Li">&quot;qr/$ignoreName/&quot;</span> will be ignored.</p>
    <p class="Pp">E.g. when 'a' and 'e' are ignorable, 'element' is equal to
        'lament' (or 'lmnt').</p>
  </dd>
  <dt>ignore_level2</dt>
  <dd>-- see 5.1 Parametric Tailoring, UTS #10.
    <p class="Pp">By default, case-sensitive comparison (that is level 3
        difference) won't ignore accents (that is level 2 difference).</p>
    <p class="Pp">If the parameter is made true, accents (and other primary
        ignorable characters) are ignored, even though cases are taken into
        account.</p>
    <p class="Pp"><b>NOTE</b>: <span class="Li">&quot;level&quot;</span> should
        be 3 or greater.</p>
  </dd>
  <dt>katakana_before_hiragana</dt>
  <dd>-- see 7.2 Tertiary Weight Table, UTS #10.
    <p class="Pp">By default, hiragana is before katakana. If the parameter is
        made true, this is reversed.</p>
    <p class="Pp"><b>NOTE</b>: This parameter simplemindedly assumes that any
        hiragana/katakana distinctions must occur in level 3, and their weights
        at level 3 must be same as those mentioned in 7.3.1, UTS #10. If you
        define your collation elements which violate this requirement, this
        parameter does not work validly.</p>
  </dd>
  <dt>level</dt>
  <dd>-- see 4.3 Form Sort Key, UTS #10.
    <p class="Pp">Set the maximum level. Any higher levels than the specified
        one are ignored.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  Level 1: alphabetic ordering
  Level 2: diacritic ordering
  Level 3: case ordering
  Level 4: tie-breaking (e.g. in the case when variable is 'shifted')

  ex.level =&gt; 2,
    </pre>
    <p class="Pp">If omitted, the maximum is the 4th.</p>
    <p class="Pp"><b>NOTE:</b> The DUCET includes weights over 0xFFFF at the 4th
        level. But this module only uses weights within 0xFFFF. When
        <span class="Li">&quot;variable&quot;</span> is 'blanked' or
        'non-ignorable' (other than 'shifted' and 'shift-trimmed'), the level 4
        may be unreliable.</p>
    <p class="Pp">See also <span class="Li">&quot;identical&quot;</span>.</p>
  </dd>
  <dt>long_contraction</dt>
  <dd>-- see 3.8.2 Well-Formedness of the DUCET, 4.2 Produce Array, UTS #10.
    <p class="Pp">If the parameter is made true, for a contraction with three or
        more characters (here nicknamed &quot;long contraction&quot;), initial
        substrings will be handled. For example, a contraction ABC, where A is a
        starter, and B and C are non-starters (character with non-zero combining
        character class), will be detected even if there is not AB as a
        contraction.</p>
    <p class="Pp"><b>Default:</b> Usually false. If
        <span class="Li">&quot;UCA_Version&quot;</span> is 22 or 24, and the
        value of <span class="Li">&quot;long_contraction&quot;</span> is not
        specified in <span class="Li">&quot;new()&quot;</span>, a true value is
        set implicitly. This is a workaround to pass Conformance Tests for
        Unicode 6.0.0 and 6.1.0.</p>
    <p class="Pp"><span class="Li">&quot;change()&quot;</span> handles
        <span class="Li">&quot;long_contraction&quot;</span> explicitly only. If
        <span class="Li">&quot;long_contraction&quot;</span> is not specified in
        <span class="Li">&quot;change()&quot;</span>, even though
        <span class="Li">&quot;UCA_Version&quot;</span> is changed,
        <span class="Li">&quot;long_contraction&quot;</span> will not be
        changed.</p>
    <p class="Pp"><b>Limitation:</b> Scanning non-starters is one-way (no back
        tracking). If AB is found but not ABC is not found, other long
        contraction where the first character is A and the second is not B may
        not be found.</p>
    <p class="Pp">Under <span class="Li">&quot;(normalization =&gt;
        undef)&quot;</span>, detection step of discontiguous contractions will
        be skipped.</p>
    <p class="Pp"><b>Note:</b> The following contractions in DUCET are not
        considered in steps S2.1.1 to S2.1.3, where they are discontiguous.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    0FB2 0F71 0F80 (TIBETAN VOWEL SIGN VOCALIC RR)
    0FB3 0F71 0F80 (TIBETAN VOWEL SIGN VOCALIC LL)
    </pre>
    <p class="Pp">For example <span class="Li">&quot;TIBETAN VOWEL SIGN VOCALIC
        RR&quot;</span> with <span class="Li">&quot;COMBINING TILDE
        OVERLAY&quot;</span> (<span class="Li">&quot;U+0344&quot;</span>) is
        <span class="Li">&quot;0FB2 0344 0F71 0F80&quot;</span> in NFD. In this
        case <span class="Li">&quot;0FB2 0F80&quot;</span>
        (<span class="Li">&quot;TIBETAN VOWEL SIGN VOCALIC R&quot;</span>) is
        detected, instead of <span class="Li">&quot;0FB2 0F71 0F80&quot;</span>.
        Inserted <span class="Li">0344</span> makes <span class="Li">&quot;0FB2
        0F71 0F80&quot;</span> discontiguous and lack of contraction
        <span class="Li">&quot;0FB2 0F71&quot;</span> prohibits
        <span class="Li">&quot;0FB2 0F71 0F80&quot;</span> from being
      detected.</p>
  </dd>
  <dt>minimalFFFE</dt>
  <dd>-- see 1.1.1 U+FFFE, UTS #35 (LDML) Part 5: Collation.
    <p class="Pp">If the parameter is made true,
        <span class="Li">&quot;U+FFFE&quot;</span> has a minimal primary weight.
        The comparison between
        <span class="Li">&quot;$a1\x{FFFE}$a2&quot;</span> and
        <span class="Li">&quot;$b1\x{FFFE}$b2&quot;</span> first compares
        <span class="Li">$a1</span> and <span class="Li">$b1</span> at level 1,
        and then <span class="Li">$a2</span> and <span class="Li">$b2</span> at
        level 1, as followed.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        &quot;ab\x{FFFE}a&quot;
        &quot;Ab\x{FFFE}a&quot;
        &quot;ab\x{FFFE}c&quot;
        &quot;Ab\x{FFFE}c&quot;
        &quot;ab\x{FFFE}xyz&quot;
        &quot;abc\x{FFFE}def&quot;
        &quot;abc\x{FFFE}xYz&quot;
        &quot;aBc\x{FFFE}xyz&quot;
        &quot;abcX\x{FFFE}def&quot;
        &quot;abcx\x{FFFE}xyz&quot;
        &quot;b\x{FFFE}aaa&quot;
        &quot;bbb\x{FFFE}a&quot;
    </pre>
    <p class="Pp">Note: This is equivalent to <span class="Li">&quot;(entry
        =&gt; 'FFFE ; [.0001.0020.0005.FFFE]')&quot;</span>. Any other character
        than <span class="Li">&quot;U+FFFE&quot;</span> can be tailored by
        <span class="Li">&quot;entry&quot;</span>.</p>
  </dd>
  <dt>normalization</dt>
  <dd>-- see 4.1 Normalize, UTS #10.
    <p class="Pp">If specified, strings are normalized before preparation of
        sort keys (the normalization is executed after preprocess).</p>
    <p class="Pp">A form name
        <span class="Li">&quot;Unicode::Normalize::normalize()&quot;</span>
        accepts will be applied as <span class="Li">$normalization_form</span>.
        Acceptable names include <span class="Li">'NFD'</span>,
        <span class="Li">'NFC'</span>, <span class="Li">'NFKD'</span>, and
        <span class="Li">'NFKC'</span>. See
        <span class="Li">&quot;Unicode::Normalize::normalize()&quot;</span> for
        detail. If omitted, <span class="Li">'NFD'</span> is used.</p>
    <p class="Pp"><span class="Li">&quot;normalization&quot;</span> is performed
        after <span class="Li">&quot;preprocess&quot;</span> (if defined).</p>
    <p class="Pp">Furthermore, special values,
        <span class="Li">&quot;undef&quot;</span> and
        <span class="Li">&quot;prenormalized&quot;</span>, can be used, though
        they are not concerned with
        <span class="Li">&quot;Unicode::Normalize::normalize()&quot;</span>.</p>
    <p class="Pp">If <span class="Li">&quot;undef&quot;</span> (not a string
        <span class="Li">&quot;undef&quot;</span>) is passed explicitly as the
        value for this key, any normalization is not carried out (this may make
        tailoring easier if any normalization is not desired). Under
        <span class="Li">&quot;(normalization =&gt; undef)&quot;</span>, only
        contiguous contractions are resolved; e.g. even if
        <span class="Li">&quot;A-ring&quot;</span> (and
        <span class="Li">&quot;A-ring-cedilla&quot;</span>) is ordered after
        <span class="Li">&quot;Z&quot;</span>,
        <span class="Li">&quot;A-cedilla-ring&quot;</span> would be primary
        equal to <span class="Li">&quot;A&quot;</span>. In this point,
        <span class="Li">&quot;(normalization =&gt; undef, preprocess =&gt; sub
        { NFD(shift) })&quot;</span> <b>is not</b> equivalent to
        <span class="Li">&quot;(normalization =&gt; 'NFD')&quot;</span>.</p>
    <p class="Pp">In the case of <span class="Li">&quot;(normalization =&gt;
        &quot;prenormalized&quot;)&quot;</span>, any normalization is not
        performed, but discontiguous contractions with combining characters are
        performed. Therefore <span class="Li">&quot;(normalization =&gt;
        'prenormalized', preprocess =&gt; sub { NFD(shift) })&quot;</span>
        <b>is</b> equivalent to <span class="Li">&quot;(normalization =&gt;
        'NFD')&quot;</span>. If source strings are finely prenormalized,
        <span class="Li">&quot;(normalization =&gt;
        'prenormalized')&quot;</span> may save time for normalization.</p>
    <p class="Pp">Except <span class="Li">&quot;(normalization =&gt;
        undef)&quot;</span>, <b>Unicode::Normalize</b> is required (see also
        <b>CAVEAT</b>).</p>
  </dd>
  <dt>overrideCJK</dt>
  <dd>-- see 7.1 Derived Collation Elements, UTS #10.
    <p class="Pp">By default, CJK unified ideographs are ordered in Unicode
        codepoint order, but those in the CJK Unified Ideographs block are less
        than those in the CJK Unified Ideographs Extension A etc.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    In the CJK Unified Ideographs block:
    U+4E00..U+9FA5 if UCA_Version is 8, 9 or 11.
    U+4E00..U+9FBB if UCA_Version is 14 or 16.
    U+4E00..U+9FC3 if UCA_Version is 18.
    U+4E00..U+9FCB if UCA_Version is 20 or 22.
    U+4E00..U+9FCC if UCA_Version is 24 to 30.
    U+4E00..U+9FD5 if UCA_Version is 32 or 34.
    U+4E00..U+9FEA if UCA_Version is 36.

    In the CJK Unified Ideographs Extension blocks:
    Ext.A (U+3400..U+4DB5) and Ext.B (U+20000..U+2A6D6) in any UCA_Version.
    Ext.C (U+2A700..U+2B734) if UCA_Version is 20 or later.
    Ext.D (U+2B740..U+2B81D) if UCA_Version is 22 or later.
    Ext.E (U+2B820..U+2CEA1) if UCA_Version is 32 or later.
    Ext.F (U+2CEB0..U+2EBE0) if UCA_Version is 36.
    </pre>
    <p class="Pp">Through <span class="Li">&quot;overrideCJK&quot;</span>,
        ordering of CJK unified ideographs (including extensions) can be
        overridden.</p>
    <p class="Pp">ex. CJK unified ideographs in the JIS code point order.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  overrideCJK =&gt; sub {
      my $u = shift;             # get a Unicode codepoint
      my $b = pack('n', $u);     # to UTF-16BE
      my $s = your_unicode_to_sjis_converter($b); # convert
      my $n = unpack('n', $s);   # convert sjis to short
      [ $n, 0x20, 0x2, $u ];     # return the collation element
  },
    </pre>
    <p class="Pp">The return value may be an arrayref of 1st to 4th weights as
        shown above. The return value may be an integer as the primary weight as
        shown below. If <span class="Li">&quot;undef&quot;</span> is returned,
        the default derived collation element will be used.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  overrideCJK =&gt; sub {
      my $u = shift;             # get a Unicode codepoint
      my $b = pack('n', $u);     # to UTF-16BE
      my $s = your_unicode_to_sjis_converter($b); # convert
      my $n = unpack('n', $s);   # convert sjis to short
      return $n;                 # return the primary weight
  },
    </pre>
    <p class="Pp">The return value may be a list containing zero or more of an
        arrayref, an integer, or <span class="Li">&quot;undef&quot;</span>.</p>
    <p class="Pp">ex. ignores all CJK unified ideographs.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  overrideCJK =&gt; sub {()}, # CODEREF returning empty list

   # where -&gt;eq(&quot;Pe\x{4E00}rl&quot;, &quot;Perl&quot;) is true
   # as U+4E00 is a CJK unified ideograph and to be ignorable.
    </pre>
    <p class="Pp">If a false value (including
        <span class="Li">&quot;undef&quot;</span>) is passed,
        <span class="Li">&quot;overrideCJK&quot;</span> has no effect.
        <span class="Li">&quot;$Collator-&gt;change(overrideCJK =&gt;
        0)&quot;</span> resets the old one.</p>
    <p class="Pp">But assignment of weight for CJK unified ideographs in
        <span class="Li">&quot;table&quot;</span> or
        <span class="Li">&quot;entry&quot;</span> is still valid. If
        <span class="Li">&quot;undef&quot;</span> is passed explicitly as the
        value for this key, weights for CJK unified ideographs are treated as
        undefined. However when <span class="Li">&quot;UCA_Version&quot;</span>
        &gt; 8, <span class="Li">&quot;(overrideCJK =&gt; undef)&quot;</span>
        has no special meaning.</p>
    <p class="Pp"><b>Note:</b> In addition to them, 12 CJK compatibility
        ideographs (<span class="Li">&quot;U+FA0E&quot;</span>,
        <span class="Li">&quot;U+FA0F&quot;</span>,
        <span class="Li">&quot;U+FA11&quot;</span>,
        <span class="Li">&quot;U+FA13&quot;</span>,
        <span class="Li">&quot;U+FA14&quot;</span>,
        <span class="Li">&quot;U+FA1F&quot;</span>,
        <span class="Li">&quot;U+FA21&quot;</span>,
        <span class="Li">&quot;U+FA23&quot;</span>,
        <span class="Li">&quot;U+FA24&quot;</span>,
        <span class="Li">&quot;U+FA27&quot;</span>,
        <span class="Li">&quot;U+FA28&quot;</span>,
        <span class="Li">&quot;U+FA29&quot;</span>) are also treated as CJK
        unified ideographs. But they can't be overridden via
        <span class="Li">&quot;overrideCJK&quot;</span> when you use DUCET, as
        the table includes weights for them.
        <span class="Li">&quot;table&quot;</span> or
        <span class="Li">&quot;entry&quot;</span> has priority over
        <span class="Li">&quot;overrideCJK&quot;</span>.</p>
  </dd>
  <dt>overrideHangul</dt>
  <dd>-- see 7.1 Derived Collation Elements, UTS #10.
    <p class="Pp">By default, Hangul syllables are decomposed into Hangul Jamo,
        even if <span class="Li">&quot;(normalization =&gt; undef)&quot;</span>.
        But the mapping of Hangul syllables may be overridden.</p>
    <p class="Pp">This parameter works like
        <span class="Li">&quot;overrideCJK&quot;</span>, so see there for
        examples.</p>
    <p class="Pp">If you want to override the mapping of Hangul syllables, NFD
        and NFKD are not appropriate, since NFD and NFKD will decompose Hangul
        syllables before overriding. FCD may decompose Hangul syllables as the
        case may be.</p>
    <p class="Pp">If a false value (but not
        <span class="Li">&quot;undef&quot;</span>) is passed,
        <span class="Li">&quot;overrideHangul&quot;</span> has no effect.
        <span class="Li">&quot;$Collator-&gt;change(overrideHangul =&gt;
        0)&quot;</span> resets the old one.</p>
    <p class="Pp">If <span class="Li">&quot;undef&quot;</span> is passed
        explicitly as the value for this key, weight for Hangul syllables is
        treated as undefined without decomposition into Hangul Jamo. But
        definition of weight for Hangul syllables in
        <span class="Li">&quot;table&quot;</span> or
        <span class="Li">&quot;entry&quot;</span> is still valid.</p>
  </dd>
  <dt>overrideOut</dt>
  <dd>-- see 7.1.1 Handling Ill-Formed Code Unit Sequences, UTS #10.
    <p class="Pp">Perl seems to allow out-of-range values (greater than
        0x10FFFF). By default, out-of-range values are replaced with
        <span class="Li">&quot;U+FFFD&quot;</span> (REPLACEMENT CHARACTER) when
        <span class="Li">&quot;UCA_Version&quot;</span> &gt;= 22, or ignored
        when <span class="Li">&quot;UCA_Version&quot;</span> &lt;= 20.</p>
    <p class="Pp">When <span class="Li">&quot;UCA_Version&quot;</span> &gt;= 22,
        the weights of out-of-range values can be overridden. Though
        <span class="Li">&quot;table&quot;</span> or
        <span class="Li">&quot;entry&quot;</span> are available for them,
        out-of-range values are too many.</p>
    <p class="Pp"><span class="Li">&quot;overrideOut&quot;</span> can perform it
        algorithmically. This parameter works like
        <span class="Li">&quot;overrideCJK&quot;</span>, so see there for
        examples.</p>
    <p class="Pp">ex. ignores all out-of-range values.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  overrideOut =&gt; sub {()}, # CODEREF returning empty list
    </pre>
    <p class="Pp">If a false value (including
        <span class="Li">&quot;undef&quot;</span>) is passed,
        <span class="Li">&quot;overrideOut&quot;</span> has no effect.
        <span class="Li">&quot;$Collator-&gt;change(overrideOut =&gt;
        0)&quot;</span> resets the old one.</p>
    <p class="Pp"><b>NOTE ABOUT U+FFFD:</b></p>
    <p class="Pp">UCA recommends that out-of-range values should not be ignored
        for security reasons. Say,
        <span class="Li">&quot;pe\x{110000}rl&quot;</span> should not be equal
        to <span class="Li">&quot;perl&quot;</span>. However,
        <span class="Li">&quot;U+FFFD&quot;</span> is wrongly mapped to a
        variable collation element in DUCET for Unicode 6.0.0 to 6.2.0, that
        means out-of-range values will be ignored when
        <span class="Li">&quot;variable&quot;</span> isn't
        <span class="Li">&quot;Non-ignorable&quot;</span>.</p>
    <p class="Pp">The mapping of <span class="Li">&quot;U+FFFD&quot;</span> is
        corrected in Unicode 6.3.0. see
        &lt;http://www.unicode.org/reports/tr10/tr10-28.html#Trailing_Weights&gt;
        (7.1.4 Trailing Weights). Such a correction is reproduced by this.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  overrideOut =&gt; sub { 0xFFFD }, # CODEREF returning a very large integer
    </pre>
    <p class="Pp">This workaround is unnecessary since Unicode 6.3.0.</p>
  </dd>
  <dt>preprocess</dt>
  <dd>-- see 5.4 Preprocessing, UTS #10.
    <p class="Pp">If specified, the coderef is used to preprocess each string
        before the formation of sort keys.</p>
    <p class="Pp">ex. dropping English articles, such as &quot;a&quot; or
        &quot;the&quot;. Then, &quot;the pen&quot; is before &quot;a
        pencil&quot;.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
     preprocess =&gt; sub {
           my $str = shift;
           $str =~ s/\b(?:an?|the)\s+//gi;
           return $str;
        },
    </pre>
    <p class="Pp"><span class="Li">&quot;preprocess&quot;</span> is performed
        before <span class="Li">&quot;normalization&quot;</span> (if
      defined).</p>
    <p class="Pp">ex. decoding strings in a legacy encoding such as
      shift-jis:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    $sjis_collator = Unicode::Collate-&gt;new(
        preprocess =&gt; \&amp;your_shiftjis_to_unicode_decoder,
    );
    @result = $sjis_collator-&gt;sort(@shiftjis_strings);
    </pre>
    <p class="Pp"><b>Note:</b> Strings returned from the coderef will be
        interpreted according to Perl's Unicode support. See perlunicode,
        perluniintro, perlunitut, perlunifaq, utf8.</p>
  </dd>
  <dt>rearrange</dt>
  <dd>-- see 3.5 Rearrangement, UTS #10.
    <p class="Pp">Characters that are not coded in logical order and to be
        rearranged. If <span class="Li">&quot;UCA_Version&quot;</span> is equal
        to or less than 11, default is:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    rearrange =&gt; [ 0x0E40..0x0E44, 0x0EC0..0x0EC4 ],
    </pre>
    <p class="Pp">If you want to disallow any rearrangement, pass
        <span class="Li">&quot;undef&quot;</span> or
        <span class="Li">&quot;[]&quot;</span> (a reference to empty list) as
        the value for this key.</p>
    <p class="Pp">If <span class="Li">&quot;UCA_Version&quot;</span> is equal to
        or greater than 14, default is <span class="Li">&quot;[]&quot;</span>
        (i.e. no rearrangement).</p>
    <p class="Pp"><b>According to the version 9 of UCA, this parameter shall not
        be used;</b> <b>but it is not warned at present.</b></p>
  </dd>
  <dt>rewrite</dt>
  <dd>If specified, the coderef is used to rewrite lines in
      <span class="Li">&quot;table&quot;</span> or
      <span class="Li">&quot;entry&quot;</span>. The coderef will get each line,
      and then should return a rewritten line according to the UCA file format.
      If the coderef returns an empty line, the line will be skipped.
    <p class="Pp">e.g. any primary ignorable characters into tertiary
      ignorable:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    rewrite =&gt; sub {
        my $line = shift;
        $line =~ s/\[\.0000\..{4}\..{4}\./[.0000.0000.0000./g;
        return $line;
    },
    </pre>
    <p class="Pp">This example shows rewriting weights.
        <span class="Li">&quot;rewrite&quot;</span> is allowed to affect code
        points, weights, and the name.</p>
    <p class="Pp"><b>NOTE</b>: <span class="Li">&quot;table&quot;</span> is
        available to use another table file; preparing a modified table once
        would be more efficient than rewriting lines on reading an unmodified
        table every time.</p>
  </dd>
  <dt>suppress</dt>
  <dd>-- see 3.12 Special-Purpose Commands, UTS #35 (LDML) Part 5: Collation.
    <p class="Pp">Contractions beginning with the specified characters are
        suppressed, even if those contractions are defined in
        <span class="Li">&quot;table&quot;</span>.</p>
    <p class="Pp">An example for Russian and some languages using the Cyrillic
        script:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    suppress =&gt; [0x0400..0x0417, 0x041A..0x0437, 0x043A..0x045F],
    </pre>
    <p class="Pp">where 0x0400 stands for
        <span class="Li">&quot;U+0400&quot;</span>, CYRILLIC CAPITAL LETTER IE
        WITH GRAVE.</p>
    <p class="Pp"><b>NOTE</b>: Contractions via
        <span class="Li">&quot;entry&quot;</span> will not be suppressed.</p>
  </dd>
  <dt>table</dt>
  <dd>-- see 3.8 Default Unicode Collation Element Table, UTS #10.
    <p class="Pp">You can use another collation element table if desired.</p>
    <p class="Pp">The table file should locate in the <i>Unicode/Collate</i>
        directory on <span class="Li">@INC</span>. Say, if the filename is
        <i>Foo.txt</i>, the table file is searched as
        <i>Unicode/Collate/Foo.txt</i> in <span class="Li">@INC</span>.</p>
    <p class="Pp">By default, <i>allkeys.txt</i> (as the filename of DUCET) is
        used. If you will prepare your own table file, any name other than
        <i>allkeys.txt</i> may be better to avoid namespace conflict.</p>
    <p class="Pp"><b>NOTE</b>: When XSUB is used, the DUCET is compiled on
        building this module, and it may save time at the run time. Explicit
        saying <span class="Li">&quot;(table =&gt; 'allkeys.txt')&quot;</span>,
        or using another table, or using
        <span class="Li">&quot;ignoreChar&quot;</span>,
        <span class="Li">&quot;ignoreName&quot;</span>,
        <span class="Li">&quot;undefChar&quot;</span>,
        <span class="Li">&quot;undefName&quot;</span> or
        <span class="Li">&quot;rewrite&quot;</span> will prevent this module
        from using the compiled DUCET.</p>
    <p class="Pp">If <span class="Li">&quot;undef&quot;</span> is passed
        explicitly as the value for this key, no file is read (but you can
        define collation elements via
        <span class="Li">&quot;entry&quot;</span>).</p>
    <p class="Pp">A typical way to define a collation element table without any
        file of table:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
   $onlyABC = Unicode::Collate-&gt;new(
       table =&gt; undef,
       entry =&gt; &lt;&lt; 'ENTRIES',
0061 ; [.0101.0020.0002.0061] # LATIN SMALL LETTER A
0041 ; [.0101.0020.0008.0041] # LATIN CAPITAL LETTER A
0062 ; [.0102.0020.0002.0062] # LATIN SMALL LETTER B
0042 ; [.0102.0020.0008.0042] # LATIN CAPITAL LETTER B
0063 ; [.0103.0020.0002.0063] # LATIN SMALL LETTER C
0043 ; [.0103.0020.0008.0043] # LATIN CAPITAL LETTER C
ENTRIES
    );
    </pre>
    <p class="Pp">If <span class="Li">&quot;ignoreName&quot;</span> or
        <span class="Li">&quot;undefName&quot;</span> is used, character names
        should be specified as a comment (following
        <span class="Li">&quot;#&quot;</span>) on each line.</p>
  </dd>
  <dt>undefChar</dt>
  <dd></dd>
  <dt>undefName</dt>
  <dd>-- see 6.3.3 Reducing the Repertoire, UTS #10.
    <p class="Pp">Undefines the collation element as if it were unassigned in
        the <span class="Li">&quot;table&quot;</span>. This reduces the size of
        the table. If an unassigned character appears in the string to be
        collated, the sort key is made from its codepoint as a single-character
        collation element, as it is greater than any other assigned collation
        elements (in the codepoint order among the unassigned characters). But,
        it'd be better to ignore characters unfamiliar to you and maybe never
        used.</p>
    <p class="Pp">Through <span class="Li">&quot;undefChar&quot;</span>, any
        character matching <span class="Li">&quot;qr/$undefChar/&quot;</span>
        will be undefined. Through
        <span class="Li">&quot;undefName&quot;</span>, any character whose name
        (given in the <span class="Li">&quot;table&quot;</span> file as a
        comment) matches <span class="Li">&quot;qr/$undefName/&quot;</span> will
        be undefined.</p>
    <p class="Pp">ex. Collation weights for beyond-BMP characters are not stored
        in object:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    undefChar =&gt; qr/[^\0-\x{fffd}]/,
    </pre>
  </dd>
  <dt>upper_before_lower</dt>
  <dd>-- see 6.6 Case Comparisons, UTS #10.
    <p class="Pp">By default, lowercase is before uppercase. If the parameter is
        made true, this is reversed.</p>
    <p class="Pp"><b>NOTE</b>: This parameter simplemindedly assumes that any
        lowercase/uppercase distinctions must occur in level 3, and their
        weights at level 3 must be same as those mentioned in 7.3.1, UTS #10. If
        you define your collation elements which differs from this requirement,
        this parameter doesn't work validly.</p>
  </dd>
  <dt>variable</dt>
  <dd>-- see 3.6 Variable Weighting, UTS #10.
    <p class="Pp">This key allows for variable weighting of variable collation
        elements, which are marked with an ASTERISK in the table (NOTE: Many
        punctuation marks and symbols are variable in <i>allkeys.txt</i>).</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
   variable =&gt; 'blanked', 'non-ignorable', 'shifted', or 'shift-trimmed'.
    </pre>
    <p class="Pp">These names are case-insensitive. By default (if specification
        is omitted), 'shifted' is adopted.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
   'Blanked'        Variable elements are made ignorable at levels 1 through 3;
                    considered at the 4th level.

   'Non-Ignorable'  Variable elements are not reset to ignorable.

   'Shifted'        Variable elements are made ignorable at levels 1 through 3
                    their level 4 weight is replaced by the old level 1 weight.
                    Level 4 weight for Non-Variable elements is 0xFFFF.

   'Shift-Trimmed'  Same as 'shifted', but all FFFF's at the 4th level
                    are trimmed.
    </pre>
  </dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Methods_for_Collation"><a class="permalink" href="#Methods_for_Collation">Methods
  for Collation</a></h2>
<dl class="Bl-tag">
  <dt>&quot;@sorted = $Collator-&gt;sort(@not_sorted)&quot;</dt>
  <dd>Sorts a list of strings.</dd>
  <dt>&quot;$result = $Collator-&gt;cmp($a, $b)&quot;</dt>
  <dd>Returns 1 (when <span class="Li">$a</span> is greater than
      <span class="Li">$b</span>) or 0 (when <span class="Li">$a</span> is equal
      to <span class="Li">$b</span>) or -1 (when <span class="Li">$a</span> is
      less than <span class="Li">$b</span>).</dd>
  <dt>&quot;$result = $Collator-&gt;eq($a, $b)&quot;</dt>
  <dd></dd>
  <dt>&quot;$result = $Collator-&gt;ne($a, $b)&quot;</dt>
  <dd></dd>
  <dt>&quot;$result = $Collator-&gt;lt($a, $b)&quot;</dt>
  <dd></dd>
  <dt>&quot;$result = $Collator-&gt;le($a, $b)&quot;</dt>
  <dd></dd>
  <dt>&quot;$result = $Collator-&gt;gt($a, $b)&quot;</dt>
  <dd></dd>
  <dt>&quot;$result = $Collator-&gt;ge($a, $b)&quot;</dt>
  <dd>They works like the same name operators as theirs.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
   eq : whether $a is equal to $b.
   ne : whether $a is not equal to $b.
   lt : whether $a is less than $b.
   le : whether $a is less than $b or equal to $b.
   gt : whether $a is greater than $b.
   ge : whether $a is greater than $b or equal to $b.
    </pre>
  </dd>
  <dt>&quot;$sortKey = $Collator-&gt;getSortKey($string)&quot;</dt>
  <dd>-- see 4.3 Form Sort Key, UTS #10.
    <p class="Pp">Returns a sort key.</p>
    <p class="Pp">You compare the sort keys using a binary comparison and get
        the result of the comparison of the strings using UCA.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
   $Collator-&gt;getSortKey($a) cmp $Collator-&gt;getSortKey($b)

      is equivalent to

   $Collator-&gt;cmp($a, $b)
    </pre>
  </dd>
  <dt>&quot;$sortKeyForm = $Collator-&gt;viewSortKey($string)&quot;</dt>
  <dd>Converts a sorting key into its representation form. If
      <span class="Li">&quot;UCA_Version&quot;</span> is 8, the output is
      slightly different.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
   use Unicode::Collate;
   my $c = Unicode::Collate-&gt;new();
   print $c-&gt;viewSortKey(&quot;Perl&quot;),&quot;\n&quot;;

   # output:
   # [0B67 0A65 0B7F 0B03 | 0020 0020 0020 0020 | 0008 0002 0002 0002 | FFFF FFFF FFFF FFFF]
   #  Level 1               Level 2               Level 3               Level 4
    </pre>
  </dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Methods_for_Searching"><a class="permalink" href="#Methods_for_Searching">Methods
  for Searching</a></h2>
The <span class="Li">&quot;match&quot;</span>,
  <span class="Li">&quot;gmatch&quot;</span>,
  <span class="Li">&quot;subst&quot;</span>,
  <span class="Li">&quot;gsubst&quot;</span> methods work like
  <span class="Li">&quot;m//&quot;</span>,
  <span class="Li">&quot;m//g&quot;</span>,
  <span class="Li">&quot;s///&quot;</span>,
  <span class="Li">&quot;s///g&quot;</span>, respectively, but they are not
  aware of any pattern, but only a literal substring.
<p class="Pp"><b>DISCLAIMER:</b> If
    <span class="Li">&quot;preprocess&quot;</span> or
    <span class="Li">&quot;normalization&quot;</span> parameter is true for
    <span class="Li">$Collator</span>, calling these methods
    (<span class="Li">&quot;index&quot;</span>,
    <span class="Li">&quot;match&quot;</span>,
    <span class="Li">&quot;gmatch&quot;</span>,
    <span class="Li">&quot;subst&quot;</span>,
    <span class="Li">&quot;gsubst&quot;</span>) is croaked, as the position and
    the length might differ from those on the specified string.</p>
<p class="Pp"><span class="Li">&quot;rearrange&quot;</span> and
    <span class="Li">&quot;hangul_terminator&quot;</span> parameters are
    neglected. <span class="Li">&quot;katakana_before_hiragana&quot;</span> and
    <span class="Li">&quot;upper_before_lower&quot;</span> don't affect matching
    and searching, as it doesn't matter whether greater or less.</p>
<dl class="Bl-tag">
  <dt>&quot;$position = $Collator-&gt;index($string, $substring[,
    $position])&quot;</dt>
  <dd></dd>
  <dt>&quot;($position, $length) = $Collator-&gt;index($string, $substring[,
    $position])&quot;</dt>
  <dd>If <span class="Li">$substring</span> matches a part of
      <span class="Li">$string</span>, returns the position of the first
      occurrence of the matching part in scalar context; in list context,
      returns a two-element list of the position and the length of the matching
      part.
    <p class="Pp">If <span class="Li">$substring</span> does not match any part
        of <span class="Li">$string</span>, returns
        <span class="Li">&quot;-1&quot;</span> in scalar context and an empty
        list in list context.</p>
    <p class="Pp">e.g. when the content of <span class="Li">$str</span> is
        <span class="Li">&quot;&quot;Ich
        mu&quot;</span>ss<span class="Li">&quot; studieren
        Perl.&quot;&quot;</span>, you say the following where
        <span class="Li">$sub</span> is
        <span class="Li">&quot;&quot;M&quot;</span>ue<span class="Li">&quot;SS&quot;&quot;</span>,</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  my $Collator = Unicode::Collate-&gt;new( normalization =&gt; undef, level =&gt; 1 );
                                     # (normalization =&gt; undef) is REQUIRED.
  my $match;
  if (my($pos,$len) = $Collator-&gt;index($str, $sub)) {
      $match = substr($str, $pos, $len);
  }
    </pre>
    <p class="Pp">and get
        <span class="Li">&quot;&quot;mu&quot;</span>ss<span class="Li">&quot;&quot;&quot;</span>
        in <span class="Li">$match</span>, since
        <span class="Li">&quot;&quot;mu&quot;</span>ss<span class="Li">&quot;&quot;&quot;</span>
        is primary equal to
        <span class="Li">&quot;&quot;M&quot;</span>ue<span class="Li">&quot;SS&quot;&quot;</span>.</p>
  </dd>
  <dt>&quot;$match_ref = $Collator-&gt;match($string, $substring)&quot;</dt>
  <dd></dd>
  <dt>&quot;($match) = $Collator-&gt;match($string, $substring)&quot;</dt>
  <dd>If <span class="Li">$substring</span> matches a part of
      <span class="Li">$string</span>, in scalar context, returns <b>a reference
      to</b> the first occurrence of the matching part
      (<span class="Li">$match_ref</span> is always true if matches, since every
      reference is <b>true</b>); in list context, returns the first occurrence
      of the matching part.
    <p class="Pp">If <span class="Li">$substring</span> does not match any part
        of <span class="Li">$string</span>, returns
        <span class="Li">&quot;undef&quot;</span> in scalar context and an empty
        list in list context.</p>
    <p class="Pp">e.g.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    if ($match_ref = $Collator-&gt;match($str, $sub)) { # scalar context
        print &quot;matches [$$match_ref].\n&quot;;
    } else {
        print &quot;doesn't match.\n&quot;;
    }

     or

    if (($match) = $Collator-&gt;match($str, $sub)) { # list context
        print &quot;matches [$match].\n&quot;;
    } else {
        print &quot;doesn't match.\n&quot;;
    }
    </pre>
  </dd>
  <dt>&quot;@match = $Collator-&gt;gmatch($string, $substring)&quot;</dt>
  <dd>If <span class="Li">$substring</span> matches a part of
      <span class="Li">$string</span>, returns all the matching parts (or
      matching count in scalar context).
    <p class="Pp">If <span class="Li">$substring</span> does not match any part
        of <span class="Li">$string</span>, returns an empty list.</p>
  </dd>
  <dt>&quot;$count = $Collator-&gt;subst($string, $substring,
    $replacement)&quot;</dt>
  <dd>If <span class="Li">$substring</span> matches a part of
      <span class="Li">$string</span>, the first occurrence of the matching part
      is replaced by <span class="Li">$replacement</span>
      (<span class="Li">$string</span> is modified) and
      <span class="Li">$count</span> (always equals to
      <span class="Li">1</span>) is returned.
    <p class="Pp"><span class="Li">$replacement</span> can be a
        <span class="Li">&quot;CODEREF&quot;</span>, taking the matching part as
        an argument, and returning a string to replace the matching part (a bit
        similar to
        <span class="Li">&quot;s/(..)/$coderef-&gt;($1)/e&quot;</span>).</p>
  </dd>
  <dt>&quot;$count = $Collator-&gt;gsubst($string, $substring,
    $replacement)&quot;</dt>
  <dd>If <span class="Li">$substring</span> matches a part of
      <span class="Li">$string</span>, all the occurrences of the matching part
      are replaced by <span class="Li">$replacement</span>
      (<span class="Li">$string</span> is modified) and
      <span class="Li">$count</span> is returned.
    <p class="Pp"><span class="Li">$replacement</span> can be a
        <span class="Li">&quot;CODEREF&quot;</span>, taking the matching part as
        an argument, and returning a string to replace the matching part (a bit
        similar to
        <span class="Li">&quot;s/(..)/$coderef-&gt;($1)/eg&quot;</span>).</p>
    <p class="Pp">e.g.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  my $Collator = Unicode::Collate-&gt;new( normalization =&gt; undef, level =&gt; 1 );
                                     # (normalization =&gt; undef) is REQUIRED.
  my $str = &quot;Camel donkey zebra came\x{301}l CAMEL horse cam\0e\0l...&quot;;
  $Collator-&gt;gsubst($str, &quot;camel&quot;, sub { &quot;&lt;b&gt;$_[0]&lt;/b&gt;&quot; });

  # now $str is &quot;&lt;b&gt;Camel&lt;/b&gt; donkey zebra &lt;b&gt;came\x{301}l&lt;/b&gt; &lt;b&gt;CAMEL&lt;/b&gt; horse &lt;b&gt;cam\0e\0l&lt;/b&gt;...&quot;;
  # i.e., all the camels are made bold-faced.

   Examples: levels and ignore_level2 - what does camel match?
  ---------------------------------------------------------------------------
   level  ignore_level2  |  camel  Camel  came\x{301}l  c-a-m-e-l  cam\0e\0l
  -----------------------|---------------------------------------------------
     1        false      |   yes    yes      yes          yes        yes
     2        false      |   yes    yes      no           yes        yes
     3        false      |   yes    no       no           yes        yes
     4        false      |   yes    no       no           no         yes
  -----------------------|---------------------------------------------------
     1        true       |   yes    yes      yes          yes        yes
     2        true       |   yes    yes      yes          yes        yes
     3        true       |   yes    no       yes          yes        yes
     4        true       |   yes    no       yes          no         yes
  ---------------------------------------------------------------------------
   note: if variable =&gt; non-ignorable, camel doesn't match c-a-m-e-l
         at any level.
    </pre>
  </dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Other_Methods"><a class="permalink" href="#Other_Methods">Other
  Methods</a></h2>
<dl class="Bl-tag">
  <dt>&quot;%old_tailoring = $Collator-&gt;change(%new_tailoring)&quot;</dt>
  <dd></dd>
  <dt>&quot;$modified_collator = $Collator-&gt;change(%new_tailoring)&quot;</dt>
  <dd>Changes the value of specified keys and returns the changed part.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    $Collator = Unicode::Collate-&gt;new(level =&gt; 4);

    $Collator-&gt;eq(&quot;perl&quot;, &quot;PERL&quot;); # false

    %old = $Collator-&gt;change(level =&gt; 2); # returns (level =&gt; 4).

    $Collator-&gt;eq(&quot;perl&quot;, &quot;PERL&quot;); # true

    $Collator-&gt;change(%old); # returns (level =&gt; 2).

    $Collator-&gt;eq(&quot;perl&quot;, &quot;PERL&quot;); # false
    </pre>
    <p class="Pp">Not all <span class="Li">&quot;(key,value)&quot;</span>s are
        allowed to be changed. See also
        <span class="Li">@Unicode::Collate::ChangeOK</span> and
        <span class="Li">@Unicode::Collate::ChangeNG</span>.</p>
    <p class="Pp">In the scalar context, returns the modified collator (but it
        is <b>not</b> a clone from the original).</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    $Collator-&gt;change(level =&gt; 2)-&gt;eq(&quot;perl&quot;, &quot;PERL&quot;); # true

    $Collator-&gt;eq(&quot;perl&quot;, &quot;PERL&quot;); # true; now max level is 2nd.

    $Collator-&gt;change(level =&gt; 4)-&gt;eq(&quot;perl&quot;, &quot;PERL&quot;); # false
    </pre>
  </dd>
  <dt>&quot;$version = $Collator-&gt;version()&quot;</dt>
  <dd>Returns the version number (a string) of the Unicode Standard which the
      <span class="Li">&quot;table&quot;</span> file used by the collator object
      is based on. If the table does not include a version line (starting with
      <span class="Li">@version</span>), returns
      <span class="Li">&quot;unknown&quot;</span>.</dd>
  <dt>&quot;UCA_Version()&quot;</dt>
  <dd>Returns the revision number of UTS #10 this module consults, that should
      correspond with the DUCET incorporated.</dd>
  <dt>&quot;Base_Unicode_Version()&quot;</dt>
  <dd>Returns the version number of UTS #10 this module consults, that should
      correspond with the DUCET incorporated.</dd>
</dl>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="EXPORT"><a class="permalink" href="#EXPORT">EXPORT</a></h1>
No method will be exported.
</section>
<section class="Sh">
<h1 class="Sh" id="INSTALL"><a class="permalink" href="#INSTALL">INSTALL</a></h1>
Though this module can be used without any
  <span class="Li">&quot;table&quot;</span> file, to use this module easily, it
  is recommended to install a table file in the UCA format, by copying it under
  the directory &lt;a place in <span class="Li">@INC</span>&gt;/Unicode/Collate.
<p class="Pp">The most preferable one is &quot;The Default Unicode Collation
    Element Table&quot; (aka DUCET), available from the Unicode Consortium's
    website:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
   http://www.unicode.org/Public/UCA/

   http://www.unicode.org/Public/UCA/latest/allkeys.txt
   (latest version)
</pre>
<p class="Pp">If DUCET is not installed, it is recommended to copy the file from
    http://www.unicode.org/Public/UCA/latest/allkeys.txt to &lt;a place in
    <span class="Li">@INC</span>&gt;/Unicode/Collate/allkeys.txt manually.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="CAVEATS"><a class="permalink" href="#CAVEATS">CAVEATS</a></h1>
<dl class="Bl-tag">
  <dt>Normalization</dt>
  <dd>Use of the <span class="Li">&quot;normalization&quot;</span> parameter
      requires the <b>Unicode::Normalize</b> module (see Unicode::Normalize).
    <p class="Pp">If you need not it (say, in the case when you need not handle
        any combining characters), assign <span class="Li">&quot;(normalization
        =&gt; undef)&quot;</span> explicitly.</p>
    <p class="Pp">-- see 6.5 Avoiding Normalization, UTS #10.</p>
  </dd>
  <dt>Conformance Test</dt>
  <dd>The Conformance Test for the UCA is available under
      &lt;http://www.unicode.org/Public/UCA/&gt;.
    <p class="Pp">For <i>CollationTest_SHIFTED.txt</i>, a collator via
        <span class="Li">&quot;Unicode::Collate-&gt;new( )&quot;</span> should
        be used; for <i>CollationTest_NON_IGNORABLE.txt</i>, a collator via
        <span class="Li">&quot;Unicode::Collate-&gt;new(variable =&gt;
        &quot;non-ignorable&quot;, level =&gt; 3)&quot;</span>.</p>
    <p class="Pp">If <span class="Li">&quot;UCA_Version&quot;</span> is 26 or
        later, the <span class="Li">&quot;identical&quot;</span> level is
        preferred; <span class="Li">&quot;Unicode::Collate-&gt;new(identical
        =&gt; 1)&quot;</span> and
        <span class="Li">&quot;Unicode::Collate-&gt;new(identical =&gt;
        1,&quot;</span> <span class="Li">&quot;variable =&gt;
        &quot;non-ignorable&quot;, level =&gt; 3)&quot;</span> should be
      used.</p>
    <p class="Pp"><b>Unicode::Normalize is required to try The Conformance
        Test.</b></p>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR,_COPYRIGHT_AND_LICENSE"><a class="permalink" href="#AUTHOR,_COPYRIGHT_AND_LICENSE">AUTHOR,
  COPYRIGHT AND LICENSE</a></h1>
The Unicode::Collate module for perl was written by SADAHIRO Tomoyuki,
  &lt;SADAHIRO@cpan.org&gt;. This module is Copyright(C) 2001-2018, SADAHIRO
  Tomoyuki. Japan. All rights reserved.
<p class="Pp">This module is free software; you can redistribute it and/or
    modify it under the same terms as Perl itself.</p>
<p class="Pp">The file Unicode/Collate/allkeys.txt was copied verbatim from
    &lt;http://www.unicode.org/Public/UCA/9.0.0/allkeys.txt&gt;. For this file,
    Copyright (c) 2016 Unicode, Inc.; distributed under the Terms of Use in
    &lt;http://www.unicode.org/terms_of_use.html&gt;</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<dl class="Bl-tag">
  <dt>Unicode Collation Algorithm - UTS #10</dt>
  <dd>&lt;http://www.unicode.org/reports/tr10/&gt;</dd>
  <dt>The Default Unicode Collation Element Table (DUCET)</dt>
  <dd>&lt;http://www.unicode.org/Public/UCA/latest/allkeys.txt&gt;</dd>
  <dt>The conformance test for the UCA</dt>
  <dd>&lt;http://www.unicode.org/Public/UCA/latest/CollationTest.html&gt;
    <p class="Pp">&lt;http://www.unicode.org/Public/UCA/latest/CollationTest.zip&gt;</p>
  </dd>
  <dt>Hangul Syllable Type</dt>
  <dd>&lt;http://www.unicode.org/Public/UNIDATA/HangulSyllableType.txt&gt;</dd>
  <dt>Unicode Normalization Forms - UAX #15</dt>
  <dd>&lt;http://www.unicode.org/reports/tr15/&gt;</dd>
  <dt>Unicode Locale Data Markup Language (LDML) - UTS #35</dt>
  <dd>&lt;http://www.unicode.org/reports/tr35/&gt;</dd>
</dl>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2018-11-01</td>
    <td class="foot-os">perl v5.28.2</td>
  </tr>
</table>
</body>
</html>
