<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    .Nd, .Bf, .Op { display: inline; }
    .Pa, .Ad { font-style: italic; }
    .Ms { font-weight: bold; }
    .Bl-diag > dt { font-weight: bold; }
    code.Nm, .Fl, .Cm, .Ic, code.In, .Fd, .Fn, .Cd { font-weight: bold;
      font-family: inherit; }
  </style>
  <title>Hierarchy(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Hierarchy(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Hierarchy(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Data::Hierarchy - Handle data in a hierarchical structure</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>    my $tree = Data::Hierarchy-&gt;new();
    $tree-&gt;store ('/', {access =&gt; 'all'});
    $tree-&gt;store ('/private', {access =&gt; 'auth',
                               '.note' =&gt; 'this is private});
    $info = $tree-&gt;get ('/private/somewhere/deep');
    # return actual data points in list context
    ($info, @fromwhere) = $tree-&gt;get ('/private/somewhere/deep');
    my @items = $tree-&gt;find ('/', {access =&gt; qr/.*/});
    # override all children
    $tree-&gt;store ('/', {'.note' =&gt; undef}, {override_sticky_descendents =&gt; 1});
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">Data::Hierarchy provides a simple interface for manipulating
    inheritable data attached to a hierarchical environment (like a
  filesystem).</p>
<p class="Pp">One use of Data::Hierarchy is to allow an application to annotate
    paths in a real filesystem in a single compact data structure. However, the
    hierarchy does not actually need to correspond to an actual filesystem.</p>
<p class="Pp">Paths in a hierarchy are referred to in a Unix-like syntax;
    <span class="Li">&quot;/&quot;</span> is the root &quot;directory&quot;.
    (You can specify a different separator character than the slash when you
    construct a Data::Hierarchy object.) With the exception of the root path,
    paths should never contain trailing slashes. You can associate properties,
    which are arbitrary name/value pairs, with any path. (Properties cannot
    contain the undefined value.) By default, properties are inherited by child
    paths: thus, if you store some data at
    <span class="Li">&quot;/some/path&quot;</span>:</p>
<p class="Pp"></p>
<pre>    $tree-&gt;store('/some/path', {color =&gt; 'red'});
</pre>
<p class="Pp">you can fetch it again at a
    <span class="Li">&quot;/some/path/below/that&quot;</span>:</p>
<p class="Pp"></p>
<pre>    print $tree-&gt;get('/some/path/below/that')-&gt;{'color'};
    # prints red
</pre>
<p class="Pp">On the other hand, properties whose names begin with dots are
    uninherited, or &quot;sticky&quot;:</p>
<p class="Pp"></p>
<pre>    $tree-&gt;store('/some/path', {'.color' =&gt; 'blue'});
    print $tree-&gt;get('/some/path')-&gt;{'.color'};            # prints blue
    print $tree-&gt;get('/some/path/below/that')-&gt;{'.color'}; # undefined
</pre>
<p class="Pp">Note that you do not need to (and in fact, cannot) explicitly add
    &quot;files&quot; or &quot;directories&quot; to the hierarchy; you simply
    add and delete properties to paths.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="CONSTRUCTOR"><a class="permalink" href="#CONSTRUCTOR">CONSTRUCTOR</a></h1>
<p class="Pp">Creates a new hierarchy object. Takes the following options:</p>
<dl class="Bl-tag">
  <dt id="sep"><a class="permalink" href="#sep">sep</a></dt>
  <dd>The string used as a separator between path levels. Defaults to '/'.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="METHODS"><a class="permalink" href="#METHODS">METHODS</a></h1>
<section class="Ss">
<h2 class="Ss" id="Instance_Methods"><a class="permalink" href="#Instance_Methods">Instance
  Methods</a></h2>
<dl class="Bl-tag">
  <dt>&quot;store $path, $properties, {%options}&quot;</dt>
  <dd>Given a path and a hash reference of properties, stores the properties at
      the path.
    <p class="Pp">Unless the
        <span class="Li">&quot;override_descendents&quot;</span> option is given
        with a false value, it eliminates any non-sticky property in a
        descendent of <span class="Li">$path</span> with the same name.</p>
    <p class="Pp">If the
        <span class="Li">&quot;override_sticky_descendents&quot;</span> option
        is given with a true value, it eliminates any sticky property in a
        descendent of <span class="Li">$path</span> with the same name. override
        it.</p>
    <p class="Pp">A value of undef removes that value; note, though, that if an
        ancestor of <span class="Li">$path</span> defines that property, the
        ancestor's value will be inherited there; that is, with:</p>
    <p class="Pp"></p>
    <pre>    $t-&gt;store('/a',   {k =&gt; 'top'});
    $t-&gt;store('/a/b', {k =&gt; 'bottom'});
    $t-&gt;store('/a/b', {k =&gt; undef});
    print $t-&gt;get('/a/b')-&gt;{'k'};
    </pre>
    <p class="Pp">it will print 'top'.</p>
  </dd>
  <dt>&quot;get $path, [$dont_clone]&quot;</dt>
  <dd>Given a path, looks up all of the properteies (sticky and not) and returns
      them in a hash reference. The values are clones, unless you pass a true
      value for <span class="Li">$dont_clone</span>.
    <p class="Pp">If called in list context, returns that hash reference
        followed by all of the ancestral paths of <span class="Li">$path</span>
        which contain non-sticky properties (possibly including itself).</p>
  </dd>
  <dt>&quot;find $path, $property_regexps&quot;</dt>
  <dd>Given a path and a hash reference of name/regular expression pairs,
      returns a list of all paths which are descendents of
      <span class="Li">$path</span> (including itself) and define <b>at that
      path itself</b> (not inherited) all of the properties in the hash with
      values matching the given regular expressions. (You may want to use
      <span class="Li">&quot;qr/.*/&quot;</span> to merely see if it has any
      value defined there.) Properties can be sticky or not.</dd>
  <dt>&quot;merge $other_hierarchy, $path&quot;</dt>
  <dd>Given a second Data::Hierarchy object and a path, copies all the
      properties from the other object at <span class="Li">$path</span> or below
      into the corresponding paths in the object this method is invoked on. All
      properties from the object this is invoked on at
      <span class="Li">$path</span> or below are erased first.</dd>
  <dt>&quot;to_relative $base_path&quot;</dt>
  <dd>Given a path which <b>every</b> element of the hierarchy must be contained
      in, returns a special Data::Hierarchy::Relative object which represents
      the hierarchy relative that path. The <b>only</b> thing you can do with a
      Data::Hierarchy::Relative object is call
      <span class="Li">&quot;to_absolute($new_base_path)&quot;</span> on it,
      which returns a new Data::Hierarchy object at that base path. For example,
      if everything in the hierarchy is rooted at
      <span class="Li">&quot;/home/super_project&quot;</span> and it needs to be
      moved to <span class="Li">&quot;/home/awesome_project&quot;</span>, you
      can do
    <p class="Pp"></p>
    <pre>    $hierarchy = $hierarchy-&gt;to_relative('/home/super_project')-&gt;to_absolute('/home/awesome_project');
    </pre>
    <p class="Pp">(Data::Hierarchy::Relative objects may be a more convenient
        serialization format than Data::Hierarchy objects, if they are tracking
        the state of some relocatable resource.)</p>
  </dd>
</dl>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHORS"><a class="permalink" href="#AUTHORS">AUTHORS</a></h1>
<p class="Pp">Chia-liang Kao &lt;clkao@clkao.org&gt; David Glasser
    &lt;glasser@mit.edu&gt;</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT"><a class="permalink" href="#COPYRIGHT">COPYRIGHT</a></h1>
<p class="Pp">Copyright 2003-2006 by Chia-liang Kao &lt;clkao@clkao.org&gt;.</p>
<p class="Pp">This program is free software; you can redistribute it and/or
    modify it under the same terms as Perl itself.</p>
<p class="Pp">See &lt;http://www.perl.com/perl/misc/Artistic.html&gt;</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2006-11-05</td>
    <td class="foot-os">perl v5.34.0</td>
  </tr>
</table>
</body>
</html>
