<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    .Nd, .Bf, .Op { display: inline; }
    .Pa, .Ad { font-style: italic; }
    .Ms { font-weight: bold; }
    .Bl-diag > dt { font-weight: bold; }
    code.Nm, .Fl, .Cm, .Ic, code.In, .Fd, .Fn, .Cd { font-weight: bold;
      font-family: inherit; }
  </style>
  <title>Scalar::Util(3pm)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Scalar::Util(3pm)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">Scalar::Util(3pm)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Scalar::Util - A selection of general-utility scalar
  subroutines</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>    use Scalar::Util qw(blessed dualvar isdual readonly refaddr reftype
                        tainted weaken isweak isvstring looks_like_number
                        set_prototype);
                        # and other useful utils appearing below
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp"><span class="Li">&quot;Scalar::Util&quot;</span> contains a
    selection of subroutines that people have expressed would be nice to have in
    the perl core, but the usage would not really be high enough to warrant the
    use of a keyword, and the size would be so small that being individual
    extensions would be wasteful.</p>
<p class="Pp">By default <span class="Li">&quot;Scalar::Util&quot;</span> does
    not export any subroutines.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="FUNCTIONS_FOR_REFERENCES"><a class="permalink" href="#FUNCTIONS_FOR_REFERENCES">FUNCTIONS
  FOR REFERENCES</a></h1>
<p class="Pp">The following functions all perform some useful activity on
    reference values.</p>
<section class="Ss">
<h2 class="Ss" id="blessed"><a class="permalink" href="#blessed">blessed</a></h2>
<pre>    my $pkg = blessed( $ref );
</pre>
<p class="Pp">If <span class="Li">$ref</span> is a blessed reference, the name
    of the package that it is blessed into is returned. Otherwise
    <span class="Li">&quot;undef&quot;</span> is returned.</p>
<p class="Pp"></p>
<pre>    $scalar = &quot;foo&quot;;
    $class  = blessed $scalar;           # undef
    $ref    = [];
    $class  = blessed $ref;              # undef
    $obj    = bless [], &quot;Foo&quot;;
    $class  = blessed $obj;              # &quot;Foo&quot;
</pre>
<p class="Pp">Take care when using this function simply as a truth test (such as
    in <span class="Li">&quot;if(blessed $ref)...&quot;</span>) because the
    package name <span class="Li">&quot;0&quot;</span> is defined yet false.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="refaddr"><a class="permalink" href="#refaddr">refaddr</a></h2>
<pre>    my $addr = refaddr( $ref );
</pre>
<p class="Pp">If <span class="Li">$ref</span> is reference, the internal memory
    address of the referenced value is returned as a plain integer. Otherwise
    <span class="Li">&quot;undef&quot;</span> is returned.</p>
<p class="Pp"></p>
<pre>    $addr = refaddr &quot;string&quot;;           # undef
    $addr = refaddr \$var;              # eg 12345678
    $addr = refaddr [];                 # eg 23456784
    $obj  = bless {}, &quot;Foo&quot;;
    $addr = refaddr $obj;               # eg 88123488
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="reftype"><a class="permalink" href="#reftype">reftype</a></h2>
<pre>    my $type = reftype( $ref );
</pre>
<p class="Pp">If <span class="Li">$ref</span> is a reference, the basic Perl
    type of the variable referenced is returned as a plain string (such as
    <span class="Li">&quot;ARRAY&quot;</span> or
    <span class="Li">&quot;HASH&quot;</span>). Otherwise
    <span class="Li">&quot;undef&quot;</span> is returned.</p>
<p class="Pp"></p>
<pre>    $type = reftype &quot;string&quot;;           # undef
    $type = reftype \$var;              # SCALAR
    $type = reftype [];                 # ARRAY
    $obj  = bless {}, &quot;Foo&quot;;
    $type = reftype $obj;               # HASH
</pre>
<p class="Pp">Note that for internal reasons, all precompiled regexps
    (<span class="Li">&quot;qr/.../&quot;</span>) are blessed references; thus
    <span class="Li">&quot;ref()&quot;</span> returns the package name string
    <span class="Li">&quot;Regexp&quot;</span> on these but
    <span class="Li">&quot;reftype()&quot;</span> will return the underlying C
    structure type of <span class="Li">&quot;REGEXP&quot;</span> in all
    capitals.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="weaken"><a class="permalink" href="#weaken">weaken</a></h2>
<pre>    weaken( $ref );
</pre>
<p class="Pp">The lvalue <span class="Li">$ref</span> will be turned into a weak
    reference. This means that it will not hold a reference count on the object
    it references. Also, when the reference count on that object reaches zero,
    the reference will be set to undef. This function mutates the lvalue passed
    as its argument and returns no value.</p>
<p class="Pp">This is useful for keeping copies of references, but you don't
    want to prevent the object being DESTROY-ed at its usual time.</p>
<p class="Pp"></p>
<pre>    {
      my $var;
      $ref = \$var;
      weaken($ref);                     # Make $ref a weak reference
    }
    # $ref is now undef
</pre>
<p class="Pp">Note that if you take a copy of a scalar with a weakened
    reference, the copy will be a strong reference.</p>
<p class="Pp"></p>
<pre>    my $var;
    my $foo = \$var;
    weaken($foo);                       # Make $foo a weak reference
    my $bar = $foo;                     # $bar is now a strong reference
</pre>
<p class="Pp">This may be less obvious in other situations, such as
    <span class="Li">&quot;grep()&quot;</span>, for instance when grepping
    through a list of weakened references to objects that may have been
    destroyed already:</p>
<p class="Pp"></p>
<pre>    @object = grep { defined } @object;
</pre>
<p class="Pp">This will indeed remove all references to destroyed objects, but
    the remaining references to objects will be strong, causing the remaining
    objects to never be destroyed because there is now always a strong reference
    to them in the <span class="Li">@object</span> array.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="unweaken"><a class="permalink" href="#unweaken">unweaken</a></h2>
<pre>    unweaken( $ref );
</pre>
<p class="Pp"><i>Since version 1.36.</i></p>
<p class="Pp">The lvalue <span class="Li">&quot;REF&quot;</span> will be turned
    from a weak reference back into a normal (strong) reference again. This
    function mutates the lvalue passed as its argument and returns no value.
    This undoes the action performed by &quot;weaken&quot;.</p>
<p class="Pp">This function is slightly neater and more convenient than the
    otherwise-equivalent code</p>
<p class="Pp"></p>
<pre>    my $tmp = $REF;
    undef $REF;
    $REF = $tmp;
</pre>
<p class="Pp">(because in particular, simply assigning a weak reference back to
    itself does not work to unweaken it; <span class="Li">&quot;$REF =
    $REF&quot;</span> does not work).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="isweak"><a class="permalink" href="#isweak">isweak</a></h2>
<pre>    my $weak = isweak( $ref );
</pre>
<p class="Pp">Returns true if <span class="Li">$ref</span> is a weak
  reference.</p>
<p class="Pp"></p>
<pre>    $ref  = \$foo;
    $weak = isweak($ref);               # false
    weaken($ref);
    $weak = isweak($ref);               # true
</pre>
<p class="Pp"><b>NOTE</b>: Copying a weak reference creates a normal, strong,
    reference.</p>
<p class="Pp"></p>
<pre>    $copy = $ref;
    $weak = isweak($copy);              # false
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="OTHER_FUNCTIONS"><a class="permalink" href="#OTHER_FUNCTIONS">OTHER
  FUNCTIONS</a></h1>
<section class="Ss">
<h2 class="Ss" id="dualvar"><a class="permalink" href="#dualvar">dualvar</a></h2>
<pre>    my $var = dualvar( $num, $string );
</pre>
<p class="Pp">Returns a scalar that has the value <span class="Li">$num</span>
    in a numeric context and the value <span class="Li">$string</span> in a
    string context.</p>
<p class="Pp"></p>
<pre>    $foo = dualvar 10, &quot;Hello&quot;;
    $num = $foo + 2;                    # 12
    $str = $foo . &quot; world&quot;;             # Hello world
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="isdual"><a class="permalink" href="#isdual">isdual</a></h2>
<pre>    my $dual = isdual( $var );
</pre>
<p class="Pp"><i>Since version 1.26.</i></p>
<p class="Pp">If <span class="Li">$var</span> is a scalar that has both numeric
    and string values, the result is true.</p>
<p class="Pp"></p>
<pre>    $foo = dualvar 86, &quot;Nix&quot;;
    $dual = isdual($foo);               # true
</pre>
<p class="Pp">Note that a scalar can be made to have both string and numeric
    content through numeric operations:</p>
<p class="Pp"></p>
<pre>    $foo = &quot;10&quot;;
    $dual = isdual($foo);               # false
    $bar = $foo + 0;
    $dual = isdual($foo);               # true
</pre>
<p class="Pp">Note that although <span class="Li">$!</span> appears to be a
    dual-valued variable, it is actually implemented as a magical variable
    inside the interpreter:</p>
<p class="Pp"></p>
<pre>    $! = 1;
    print(&quot;$!\n&quot;);                      # &quot;Operation not permitted&quot;
    $dual = isdual($!);                 # false
</pre>
<p class="Pp">You can capture its numeric and string content using:</p>
<p class="Pp"></p>
<pre>    $err = dualvar $!, $!;
    $dual = isdual($err);               # true
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="isvstring"><a class="permalink" href="#isvstring">isvstring</a></h2>
<pre>    my $vstring = isvstring( $var );
</pre>
<p class="Pp">If <span class="Li">$var</span> is a scalar which was coded as a
    vstring, the result is true.</p>
<p class="Pp"></p>
<pre>    $vs   = v49.46.48;
    $fmt  = isvstring($vs) ? &quot;%vd&quot; : &quot;%s&quot;; #true
    printf($fmt,$vs);
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="looks_like_number"><a class="permalink" href="#looks_like_number">looks_like_number</a></h2>
<pre>    my $isnum = looks_like_number( $var );
</pre>
<p class="Pp">Returns true if perl thinks <span class="Li">$var</span> is a
    number. See &quot;looks_like_number&quot; in perlapi.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="openhandle"><a class="permalink" href="#openhandle">openhandle</a></h2>
<pre>    my $fh = openhandle( $fh );
</pre>
<p class="Pp">Returns <span class="Li">$fh</span> itself, if
    <span class="Li">$fh</span> may be used as a filehandle and is open, or if
    it is a tied handle. Otherwise <span class="Li">&quot;undef&quot;</span> is
    returned.</p>
<p class="Pp"></p>
<pre>    $fh = openhandle(*STDIN);           # \*STDIN
    $fh = openhandle(\*STDIN);          # \*STDIN
    $fh = openhandle(*NOTOPEN);         # undef
    $fh = openhandle(&quot;scalar&quot;);         # undef
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="readonly"><a class="permalink" href="#readonly">readonly</a></h2>
<pre>    my $ro = readonly( $var );
</pre>
<p class="Pp">Returns true if <span class="Li">$var</span> is readonly.</p>
<p class="Pp"></p>
<pre>    sub foo { readonly($_[0]) }
    $readonly = foo($bar);              # false
    $readonly = foo(0);                 # true
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="set_prototype"><a class="permalink" href="#set_prototype">set_prototype</a></h2>
<pre>    my $code = set_prototype( $code, $prototype );
</pre>
<p class="Pp">Sets the prototype of the function given by the
    <span class="Li">$code</span> reference, or deletes it if
    <span class="Li">$prototype</span> is
    <span class="Li">&quot;undef&quot;</span>. Returns the
    <span class="Li">$code</span> reference itself.</p>
<p class="Pp"></p>
<pre>    set_prototype \&amp;foo, '$$';
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="tainted"><a class="permalink" href="#tainted">tainted</a></h2>
<pre>    my $t = tainted( $var );
</pre>
<p class="Pp">Return true if <span class="Li">$var</span> is tainted.</p>
<p class="Pp"></p>
<pre>    $taint = tainted(&quot;constant&quot;);       # false
    $taint = tainted($ENV{PWD});        # true if running under -T
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="DIAGNOSTICS"><a class="permalink" href="#DIAGNOSTICS">DIAGNOSTICS</a></h1>
<p class="Pp">Module use may give one of the following errors during import.</p>
<dl class="Bl-tag">
  <dt id="Weak"><a class="permalink" href="#Weak">Weak references are not
    implemented in the version of perl</a></dt>
  <dd>The version of perl that you are using does not implement weak references,
      to use &quot;isweak&quot; or &quot;weaken&quot; you will need to use a
      newer release of perl.</dd>
  <dt id="Vstrings"><a class="permalink" href="#Vstrings">Vstrings are not
    implemented in the version of perl</a></dt>
  <dd>The version of perl that you are using does not implement Vstrings, to use
      &quot;isvstring&quot; you will need to use a newer release of perl.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="KNOWN_BUGS"><a class="permalink" href="#KNOWN_BUGS">KNOWN
  BUGS</a></h1>
<p class="Pp">There is a bug in perl5.6.0 with UV's that are &gt;= 1&lt;&lt;31.
    This will show up as tests 8 and 9 of dualvar.t failing</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp">List::Util</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT"><a class="permalink" href="#COPYRIGHT">COPYRIGHT</a></h1>
<p class="Pp">Copyright (c) 1997-2007 Graham Barr &lt;gbarr@pobox.com&gt;. All
    rights reserved. This program is free software; you can redistribute it
    and/or modify it under the same terms as Perl itself.</p>
<p class="Pp">Additionally &quot;weaken&quot; and &quot;isweak&quot; which
  are</p>
<p class="Pp">Copyright (c) 1999 Tuomas J. Lukka &lt;lukka@iki.fi&gt;. All
    rights reserved. This program is free software; you can redistribute it
    and/or modify it under the same terms as perl itself.</p>
<p class="Pp">Copyright (C) 2004, 2008 Matthijs van Duin. All rights reserved.
    Copyright (C) 2014 cPanel Inc. All rights reserved. This program is free
    software; you can redistribute it and/or modify it under the same terms as
    Perl itself.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2020-10-04</td>
    <td class="foot-os">perl v5.34.0</td>
  </tr>
</table>
</body>
</html>
