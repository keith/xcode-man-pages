<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>DBD::Gofer(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">DBD::Gofer(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">DBD::Gofer(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
DBD::Gofer - A stateless-proxy driver for communicating with a remote DBI
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<span class="Li"></span>
<pre>
  use DBI;

  $original_dsn = &quot;dbi:...&quot;; # your original DBI Data Source Name

  $dbh = DBI-&gt;connect(&quot;dbi:Gofer:transport=$transport;...;dsn=$original_dsn&quot;,
                      $user, $passwd, \%attributes);

  ... use $dbh as if it was connected to $original_dsn ...
</pre>
<p class="Pp">The <span class="Li">&quot;transport=$transport&quot;</span> part
    specifies the name of the module to use to transport the requests to the
    remote DBI. If <span class="Li">$transport</span> doesn't contain any double
    colons then it's prefixed with
    <span class="Li">&quot;DBD::Gofer::Transport::&quot;</span>.</p>
<p class="Pp">The <span class="Li">&quot;dsn=$original_dsn&quot;</span> part
    <i>must be the last element</i> of the DSN because everything after
    <span class="Li">&quot;dsn=&quot;</span> is assumed to be the DSN that the
    remote DBI should use.</p>
<p class="Pp">The <span class="Li">&quot;...&quot;</span> represents attributes
    that influence the operation of the Gofer driver or transport. These are
    described below or in the documentation of the transport module being
  used.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
DBD::Gofer is a DBI database driver that forwards requests to another DBI
  driver, usually in a separate process, often on a separate machine. It tries
  to be as transparent as possible so it appears that you are using the remote
  driver directly.
<p class="Pp">DBD::Gofer is very similar to DBD::Proxy. The major difference is
    that with DBD::Gofer no state is maintained on the remote end. That means
    every request contains all the information needed to create the required
    state. (So, for example, every request includes the DSN to connect to.) Each
    request can be sent to any available server. The server executes the request
    and returns a single response that includes all the data.</p>
<p class="Pp">This is very similar to the way http works as a stateless protocol
    for the web. Each request from your web browser can be handled by a
    different web server process.</p>
<section class="Ss">
<h2 class="Ss" id="Use_Cases"><a class="permalink" href="#Use_Cases">Use
  Cases</a></h2>
This may seem like pointless overhead but there are situations where this is a
  very good thing. Let's consider a specific case.
<p class="Pp">Imagine using DBD::Gofer with an http transport. Your application
    calls <i>connect()</i>, prepare(&quot;select * from table where
    foo=?&quot;), <i>bind_param()</i>, and <i>execute()</i>. At this point
    DBD::Gofer builds a request containing all the information about the method
    calls. It then uses the httpd transport to send that request to an apache
    web server.</p>
<p class="Pp">This 'dbi execute' web server executes the request (using
    DBI::Gofer::Execute and related modules) and builds a response that contains
    all the rows of data, if the statement returned any, along with all the
    attributes that describe the results, such as
    <span class="Li">$sth</span>-&gt;{NAME}. This response is sent back to
    DBD::Gofer which unpacks it and presents it to the application as if it had
    executed the statement itself.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Advantages"><a class="permalink" href="#Advantages">Advantages</a></h2>
Okay, but you still don't see the point? Well let's consider what we've gained:
<p class="Pp"><i>Connection Pooling and Throttling</i></p>
<p class="Pp">The 'dbi execute' web server leverages all the functionality of
    web infrastructure in terms of load balancing, high-availability, firewalls,
    access management, proxying, caching.</p>
<p class="Pp">At its most basic level you get a configurable pool of persistent
    database connections.</p>
<p class="Pp"><i>Simple Scaling</i></p>
<p class="Pp">Got thousands of processes all trying to connect to the database?
    You can use DBD::Gofer to connect them to your smaller pool of 'dbi execute'
    web servers instead.</p>
<p class="Pp"><i>Caching</i></p>
<p class="Pp">Client-side caching is as simple as adding
    &quot;<span class="Li">&quot;cache=1&quot;</span>&quot; to the DSN. This
    feature alone can be worth using DBD::Gofer for.</p>
<p class="Pp"><i>Fewer Network Round-trips</i></p>
<p class="Pp">DBD::Gofer sends as few requests as possible (dependent on the
    policy being used).</p>
<p class="Pp"><i>Thin Clients / Unsupported Platforms</i></p>
<p class="Pp">You no longer need drivers for your database on every system.
    DBD::Gofer is pure perl.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="CONSTRAINTS"><a class="permalink" href="#CONSTRAINTS">CONSTRAINTS</a></h1>
There are some natural constraints imposed by the DBD::Gofer 'stateless'
  approach. But not many:
<section class="Ss">
<h2 class="Ss" id="You_can't_change_database_handle_attributes_after__fIconnect()_fP"><a class="permalink" href="#You_can't_change_database_handle_attributes_after__fIconnect()_fP">You
  can't change database handle attributes after <i>connect()</i></a></h2>
You can't change database handle attributes after you've connected. Use the
  <i>connect()</i> call to specify all the attribute settings you want.
<p class="Pp">This is because it's critical that when a request is complete the
    database handle is left in the same state it was when first connected.</p>
<p class="Pp">An exception is made for attributes with names starting
    &quot;<span class="Li">&quot;private_&quot;</span>&quot;: They can be set
    after <i>connect()</i> but the change is only applied locally.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="You_can't_change_statement_handle_attributes_after__fIprepare()_fP"><a class="permalink" href="#You_can't_change_statement_handle_attributes_after__fIprepare()_fP">You
  can't change statement handle attributes after <i>prepare()</i></a></h2>
You can't change statement handle attributes after prepare.
<p class="Pp">An exception is made for attributes with names starting
    &quot;<span class="Li">&quot;private_&quot;</span>&quot;: They can be set
    after <i>prepare()</i> but the change is only applied locally.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="You_can't_use_transactions"><a class="permalink" href="#You_can't_use_transactions">You
  can't use transactions</a></h2>
AutoCommit only. Transactions aren't supported.
<p class="Pp">(In theory transactions could be supported when using a transport
    that maintains a connection, like <span class="Li">&quot;stream&quot;</span>
    does. If you're interested in this please get in touch via
  dbi-dev@perl.org)</p>
</section>
<section class="Ss">
<h2 class="Ss" id="You_can't_call_driver-private_sth_methods"><a class="permalink" href="#You_can't_call_driver-private_sth_methods">You
  can't call driver-private sth methods</a></h2>
But that's rarely needed anyway.
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="GENERAL_CAVEATS"><a class="permalink" href="#GENERAL_CAVEATS">GENERAL
  CAVEATS</a></h1>
A few important things to keep in mind when using DBD::Gofer:
<section class="Ss">
<h2 class="Ss" id="Temporary_tables,_locks,_and_other_per-connection_persistent_state"><a class="permalink" href="#Temporary_tables,_locks,_and_other_per-connection_persistent_state">Temporary
  tables, locks, and other per-connection persistent state</a></h2>
You shouldn't expect any per-session state to persist between requests. This
  includes locks and temporary tables.
<p class="Pp">Because the server-side may execute your requests via a different
    database connections, you can't rely on any per-connection persistent state,
    such as temporary tables, being available from one request to the next.</p>
<p class="Pp">This is an easy trap to fall into. A good way to check for this is
    to test your code with a Gofer policy package that sets the
    <span class="Li">&quot;connect_method&quot;</span> policy to 'connect' to
    force a new connection for each request. The
    <span class="Li">&quot;pedantic&quot;</span> policy does this.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Driver-private_Database_Handle_Attributes"><a class="permalink" href="#Driver-private_Database_Handle_Attributes">Driver-private
  Database Handle Attributes</a></h2>
Some driver-private dbh attributes may not be available if the driver has not
  implemented the <i>private_attribute_info()</i> method (added in DBI 1.54).
</section>
<section class="Ss">
<h2 class="Ss" id="Driver-private_Statement_Handle_Attributes"><a class="permalink" href="#Driver-private_Statement_Handle_Attributes">Driver-private
  Statement Handle Attributes</a></h2>
Driver-private sth attributes can be set in the <i>prepare()</i> call. TODO
<p class="Pp">Some driver-private sth attributes may not be available if the
    driver has not implemented the <i>private_attribute_info()</i> method (added
    in DBI 1.54).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Multiple_Resultsets"><a class="permalink" href="#Multiple_Resultsets">Multiple
  Resultsets</a></h2>
Multiple resultsets are supported only if the driver supports the
  <i>more_results()</i> method (an exception is made for DBD::Sybase).
</section>
<section class="Ss">
<h2 class="Ss" id="Statement_activity_that_also_updates_dbh_attributes"><a class="permalink" href="#Statement_activity_that_also_updates_dbh_attributes">Statement
  activity that also updates dbh attributes</a></h2>
Some drivers may update one or more dbh attributes after performing activity on
  a child sth. For example, DBD::mysql provides
  <span class="Li">$dbh</span>-&gt;{mysql_insertid} in addition to
  <span class="Li">$sth</span>-&gt;{mysql_insertid}. Currently mysql_insertid is
  supported via a hack but a more general mechanism is needed for other drivers
  to use.
</section>
<section class="Ss">
<h2 class="Ss" id="Methods_that_report_an_error_always_return_undef"><a class="permalink" href="#Methods_that_report_an_error_always_return_undef">Methods
  that report an error always return undef</a></h2>
With DBD::Gofer, a method that sets an error always return an undef or empty
  list. That shouldn't be a problem in practice because the DBI doesn't define
  any methods that return meaningful values while also reporting an error.
</section>
<section class="Ss">
<h2 class="Ss" id="Subclassing_only_applies_to_client-side"><a class="permalink" href="#Subclassing_only_applies_to_client-side">Subclassing
  only applies to client-side</a></h2>
The RootClass and DbTypeSubclass attributes are not passed to the Gofer server.
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="CAVEATS_FOR_SPECIFIC_METHODS"><a class="permalink" href="#CAVEATS_FOR_SPECIFIC_METHODS">CAVEATS
  FOR SPECIFIC METHODS</a></h1>
<section class="Ss">
<h2 class="Ss" id="last_insert_id"><a class="permalink" href="#last_insert_id">last_insert_id</a></h2>
To enable use of last_insert_id you need to indicate to DBD::Gofer that you'd
  like to use it. You do that my adding a
  <span class="Li">&quot;go_last_insert_id_args&quot;</span> attribute to the
  <i>do()</i> or <i>prepare()</i> method calls. For example:
<p class="Pp"><span class="Li"></span></p>
<pre>
    $dbh-&gt;do($sql, { go_last_insert_id_args =&gt; [...] });
</pre>
<p class="Pp">or</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    $sth = $dbh-&gt;prepare($sql, { go_last_insert_id_args =&gt; [...] });
</pre>
<p class="Pp">The array reference should contains the args that you want passed
    to the <i>last_insert_id()</i> method.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="execute_for_fetch"><a class="permalink" href="#execute_for_fetch">execute_for_fetch</a></h2>
The array methods <i>bind_param_array()</i> and <i>execute_array()</i> are
  supported. When <i>execute_array()</i> is called the data is serialized and
  executed in a single round-trip to the Gofer server. This makes it very fast,
  but requires enough memory to store all the serialized data.
<p class="Pp">The <i>execute_for_fetch()</i> method currently isn't optimised,
    it uses the DBI fallback behaviour of executing each tuple individually. (It
    could be implemented as a wrapper for <i>execute_array()</i> - patches
    welcome.)</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="TRANSPORTS"><a class="permalink" href="#TRANSPORTS">TRANSPORTS</a></h1>
DBD::Gofer doesn't concern itself with transporting requests and responses to
  and fro. For that it uses special Gofer transport modules.
<p class="Pp">Gofer transport modules usually come in pairs: one for the
    'client' DBD::Gofer driver to use and one for the remote 'server' end. They
    have very similar names:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    DBD::Gofer::Transport::&lt;foo&gt;
    DBI::Gofer::Transport::&lt;foo&gt;
</pre>
<p class="Pp">Sometimes the transports on the DBD and DBI sides may have
    different names. For example DBD::Gofer::Transport::http is typically used
    with DBI::Gofer::Transport::mod_perl (DBD::Gofer::Transport::http and
    DBI::Gofer::Transport::mod_perl modules are part of the GoferTransport-http
    distribution).</p>
<section class="Ss">
<h2 class="Ss" id="Bundled_Transports"><a class="permalink" href="#Bundled_Transports">Bundled
  Transports</a></h2>
Several transport modules are provided with DBD::Gofer:
<p class="Pp"><i>null</i></p>
<p class="Pp">The null transport is the simplest of them all. It doesn't
    actually transport the request anywhere. It just serializes (freezes) the
    request into a string, then thaws it back into a data structure before
    passing it to DBI::Gofer::Execute to execute. The same freeze and thaw is
    applied to the results.</p>
<p class="Pp">The null transport is the best way to test if your application
    will work with Gofer. Just set the DBI_AUTOPROXY environment variable to
    &quot;<span class="Li">&quot;dbi:Gofer:transport=null;policy=pedantic&quot;</span>&quot;
    (see &quot;Using DBI_AUTOPROXY&quot; below) and run your application, or
    ideally its test suite, as usual.</p>
<p class="Pp">It doesn't take any parameters.</p>
<p class="Pp"><i>pipeone</i></p>
<p class="Pp">The pipeone transport launches a subprocess for each request. It
    passes in the request and reads the response.</p>
<p class="Pp">The fact that a new subprocess is started for each request ensures
    that the server side is truly stateless. While this does make the transport
    <i>very</i> slow, it is useful as a way to test that your application
    doesn't depend on per-connection state, such as temporary tables, persisting
    between requests.</p>
<p class="Pp">It's also useful both as a proof of concept and as a base class
    for the stream driver.</p>
<p class="Pp"><i>stream</i></p>
<p class="Pp">The stream driver also launches a subprocess and writes requests
    and reads responses, like the pipeone transport. In this case, however, the
    subprocess is expected to handle more that one request. (Though it will be
    automatically restarted if it exits.)</p>
<p class="Pp">This is the first transport that is truly useful because it can
    launch the subprocess on a remote machine using
    <span class="Li">&quot;ssh&quot;</span>. This means you can now use
    DBD::Gofer to easily access any databases that's accessible from any system
    you can login to. You also get all the benefits of ssh, including encryption
    and optional compression.</p>
<p class="Pp">See &quot;Using DBI_AUTOPROXY&quot; below for an example.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Other_Transports"><a class="permalink" href="#Other_Transports">Other
  Transports</a></h2>
Implementing a Gofer transport is <i>very</i> simple, and more transports are
  very welcome. Just take a look at any existing transports that are similar to
  your needs.
<p class="Pp"><i>http</i></p>
<p class="Pp">See the GoferTransport-http distribution on CPAN:
    http://search.cpan.org/dist/GoferTransport-http/</p>
<p class="Pp"><i>Gearman</i></p>
<p class="Pp">I know Ask Bjorn Hansen has implemented a transport for the
    <span class="Li">&quot;gearman&quot;</span> distributed job system, though
    it's not on CPAN at the time of writing this.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="CONNECTING"><a class="permalink" href="#CONNECTING">CONNECTING</a></h1>
Simply prefix your existing DSN with
  &quot;<span class="Li">&quot;dbi:Gofer:transport=$transport;dsn=&quot;</span>&quot;
  where <span class="Li">$transport</span> is the name of the Gofer transport
  you want to use (see &quot;TRANSPORTS&quot;). The
  <span class="Li">&quot;transport&quot;</span> and
  <span class="Li">&quot;dsn&quot;</span> attributes must be specified and the
  <span class="Li">&quot;dsn&quot;</span> attributes must be last.
<p class="Pp">Other attributes can be specified in the DSN to configure
    DBD::Gofer and/or the Gofer transport module being used. The main attributes
    after <span class="Li">&quot;transport&quot;</span>, are
    <span class="Li">&quot;url&quot;</span> and
    <span class="Li">&quot;policy&quot;</span>. These and other attributes are
    described below.</p>
<section class="Ss">
<h2 class="Ss" id="Using__s-1DBI_AUTOPROXY_s0"><a class="permalink" href="#Using__s-1DBI_AUTOPROXY_s0">Using
  DBI_AUTOPROXY</a></h2>
The simplest way to try out DBD::Gofer is to set the DBI_AUTOPROXY environment
  variable. In this case you don't include the
  <span class="Li">&quot;dsn=&quot;</span> part. For example:
<p class="Pp"><span class="Li"></span></p>
<pre>
    export DBI_AUTOPROXY=&quot;dbi:Gofer:transport=null&quot;
</pre>
<p class="Pp">or, for a more useful example, try:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    export DBI_AUTOPROXY=&quot;dbi:Gofer:transport=stream;url=ssh:user@example.com&quot;
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Connection_Attributes"><a class="permalink" href="#Connection_Attributes">Connection
  Attributes</a></h2>
These attributes can be specified in the DSN. They can also be passed in the
  \%attr parameter of the DBI connect method by adding a
  &quot;<span class="Li">&quot;go_&quot;</span>&quot; prefix to the name.
<p class="Pp"><i>transport</i></p>
<p class="Pp">Specifies the Gofer transport class to use. Required. See
    &quot;TRANSPORTS&quot; above.</p>
<p class="Pp">If the value does not include
    <span class="Li">&quot;::&quot;</span> then
    &quot;<span class="Li">&quot;DBD::Gofer::Transport::&quot;</span>&quot; is
    prefixed.</p>
<p class="Pp">The transport object can be accessed via
    <span class="Li">$h</span>-&gt;{go_transport}.</p>
<p class="Pp"><i>dsn</i></p>
<p class="Pp">Specifies the DSN for the remote side to connect to. Required, and
    must be last.</p>
<p class="Pp"><i>url</i></p>
<p class="Pp">Used to tell the transport where to connect to. The exact form of
    the value depends on the transport used.</p>
<p class="Pp"><i>policy</i></p>
<p class="Pp">Specifies the policy to use. See &quot;CONFIGURING BEHAVIOUR
    POLICY&quot;.</p>
<p class="Pp">If the value does not include
    <span class="Li">&quot;::&quot;</span> then
    &quot;<span class="Li">&quot;DBD::Gofer::Policy&quot;</span>&quot; is
    prefixed.</p>
<p class="Pp">The policy object can be accessed via
    <span class="Li">$h</span>-&gt;{go_policy}.</p>
<p class="Pp"><i>timeout</i></p>
<p class="Pp">Specifies a timeout, in seconds, to use when waiting for responses
    from the server side.</p>
<p class="Pp"><i>retry_limit</i></p>
<p class="Pp">Specifies the number of times a failed request will be retried.
    Default is 0.</p>
<p class="Pp"><i>retry_hook</i></p>
<p class="Pp">Specifies a code reference to be called to decide if a failed
    request should be retried. The code reference is called like this:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  $transport = $h-&gt;{go_transport};
  $retry = $transport-&gt;go_retry_hook-&gt;($request, $response, $transport);
</pre>
<p class="Pp">If it returns true then the request will be retried, up to the
    <span class="Li">&quot;retry_limit&quot;</span>. If it returns a false but
    defined value then the request will not be retried. If it returns undef then
    the default behaviour will be used, as if
    <span class="Li">&quot;retry_hook&quot;</span> had not been specified.</p>
<p class="Pp">The default behaviour is to retry requests where
    <span class="Li">$request</span>-&gt;is_idempotent is true, or the error
    message matches <span class="Li">&quot;/induced by
    DBI_GOFER_RANDOM/&quot;</span>.</p>
<p class="Pp"><i>cache</i></p>
<p class="Pp">Specifies that client-side caching should be performed. The value
    is the name of a cache class to use.</p>
<p class="Pp">Any class implementing get($key) and set($key,
    <span class="Li">$value</span>) methods can be used. That includes a great
    many powerful caching classes on CPAN, including the Cache and Cache::Cache
    distributions.</p>
<p class="Pp">You can use
    &quot;<span class="Li">&quot;cache=1&quot;</span>&quot; is a shortcut for
    &quot;<span class="Li">&quot;cache=DBI::Util::CacheMemory&quot;</span>&quot;.
    See DBI::Util::CacheMemory for a description of this simple fast default
    cache.</p>
<p class="Pp">The cache object can be accessed via
    <span class="Li">$h</span>-&gt;go_cache. For example:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    $dbh-&gt;go_cache-&gt;clear; # free up memory being used by the cache
</pre>
<p class="Pp">The cache keys are the frozen (serialized) requests, and the
    values are the frozen responses.</p>
<p class="Pp">The default behaviour is to only use the cache for requests where
    <span class="Li">$request</span>-&gt;is_idempotent is true (i.e., the dbh
    has the ReadOnly attribute set or the SQL statement is obviously a SELECT
    without a FOR UPDATE clause.)</p>
<p class="Pp">For even more control you can use the
    <span class="Li">&quot;go_cache&quot;</span> attribute to pass in an
    instantiated cache object. Individual methods, including <i>prepare()</i>,
    can also specify alternative caches via the
    <span class="Li">&quot;go_cache&quot;</span> attribute. For example, to
    specify no caching for a particular query, you could use</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    $sth = $dbh-&gt;prepare( $sql, { go_cache =&gt; 0 } );
</pre>
<p class="Pp">This can be used to implement different caching policies for
    different statements.</p>
<p class="Pp">It's interesting to note that DBD::Gofer can be used to add
    client-side caching to any (gofer compatible) application, with no code
    changes and no need for a gofer server. Just set the DBI_AUTOPROXY
    environment variable like this:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    DBI_AUTOPROXY='dbi:Gofer:transport=null;cache=1'
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="CONFIGURING_BEHAVIOUR_POLICY"><a class="permalink" href="#CONFIGURING_BEHAVIOUR_POLICY">CONFIGURING
  BEHAVIOUR POLICY</a></h1>
DBD::Gofer supports a 'policy' mechanism that allows you to fine-tune the number
  of round-trips to the Gofer server. The policies are grouped into classes
  (which may be subclassed) and referenced by the name of the class.
<p class="Pp">The DBD::Gofer::Policy::Base class is the base class for all the
    policy packages and describes all the available policies.</p>
<p class="Pp">Three policy packages are supplied with DBD::Gofer:</p>
<p class="Pp">DBD::Gofer::Policy::pedantic is most 'transparent' but slowest
    because it makes more round-trips to the Gofer server.</p>
<p class="Pp">DBD::Gofer::Policy::classic is a reasonable compromise - it's the
    default policy.</p>
<p class="Pp">DBD::Gofer::Policy::rush is fastest, but may require code changes
    in your applications.</p>
<p class="Pp">Generally the default <span class="Li">&quot;classic&quot;</span>
    policy is fine. When first testing an existing application with Gofer it is
    a good idea to start with the <span class="Li">&quot;pedantic&quot;</span>
    policy first and then switch to <span class="Li">&quot;classic&quot;</span>
    or a custom policy, for final testing.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
Tim Bunce, &lt;http://www.tim.bunce.name&gt;
</section>
<section class="Sh">
<h1 class="Sh" id="LICENCE_AND_COPYRIGHT"><a class="permalink" href="#LICENCE_AND_COPYRIGHT">LICENCE
  AND COPYRIGHT</a></h1>
Copyright (c) 2007, Tim Bunce, Ireland. All rights reserved.
<p class="Pp">This module is free software; you can redistribute it and/or
    modify it under the same terms as Perl itself. See perlartistic.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="ACKNOWLEDGEMENTS"><a class="permalink" href="#ACKNOWLEDGEMENTS">ACKNOWLEDGEMENTS</a></h1>
The development of DBD::Gofer and related modules was sponsored by Shopzilla.com
  (&lt;http://Shopzilla.com&gt;), where I currently work.
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
DBI::Gofer::Request, DBI::Gofer::Response, DBI::Gofer::Execute.
<p class="Pp">DBI::Gofer::Transport::Base, DBD::Gofer::Policy::Base.</p>
<p class="Pp">DBI</p>
</section>
<section class="Sh">
<h1 class="Sh" id="Caveats_for_specific_drivers"><a class="permalink" href="#Caveats_for_specific_drivers">Caveats
  for specific drivers</a></h1>
This section aims to record issues to be aware of when using Gofer with specific
  drivers. It usually only documents issues that are not natural consequences of
  the limitations of the Gofer approach - as documented above.
</section>
<section class="Sh">
<h1 class="Sh" id="TODO"><a class="permalink" href="#TODO">TODO</a></h1>
This is just a random brain dump... (There's more in the source of the Changes
  file, not the pod)
<p class="Pp">Document policy mechanism</p>
<p class="Pp">Add mechanism for transports to list config params and for Gofer
    to apply any that match (and warn if any left over?)</p>
<p class="Pp">Driver-private sth attributes - set via <i>prepare()</i> - change
    DBI spec</p>
<p class="Pp">add hooks into transport base class for checking &amp; updating a
    result set cache
   ie via a standard cache interface such as:
   http://search.cpan.org/~robm/Cache-FastMmap/FastMmap.pm
   http://search.cpan.org/~bradfitz/Cache-Memcached/lib/Cache/Memcached.pm
   http://search.cpan.org/~dclinton/Cache-Cache/
   http://search.cpan.org/~cleishman/Cache/ Also caching instructions could be
    passed through the httpd transport layer in such a way that appropriate http
    cache headers are added to the results so that web caches (squid etc) could
    be used to implement the caching. (MUST require the use of GET rather than
    POST requests.)</p>
<p class="Pp">Rework handling of installed_methods to not piggyback on
    dbh_attributes?</p>
<p class="Pp">Perhaps support transactions for transports where it's possible
    (ie null and stream)? Would make stream transport (ie ssh) more useful to
    more people.</p>
<p class="Pp">Make sth_result_attr more like dbh_attributes (using '*' etc)</p>
<p class="Pp">Add <span class="Li">@val</span> = FETCH_many(@names) to DBI in C
    and use in Gofer/Execute?</p>
<p class="Pp">Implement _new_sth in C.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2013-11-14</td>
    <td class="foot-os">perl v5.18.4</td>
  </tr>
</table>
</body>
</html>
