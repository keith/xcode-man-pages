<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>MIME::Decoder(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">MIME::Decoder(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">MIME::Decoder(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
MIME::Decoder - an object for decoding the body part of a MIME stream
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
Before reading further, you should see MIME::Tools to make sure that you
  understand where this module fits into the grand scheme of things. Go on, do
  it now. I'll wait.
<p class="Pp">Ready? Ok...</p>
<section class="Ss">
<h2 class="Ss" id="Decoding_a_data_stream"><a class="permalink" href="#Decoding_a_data_stream">Decoding
  a data stream</a></h2>
Here's a simple filter program to read quoted-printable data from STDIN (until
  EOF) and write the decoded data to STDOUT:
<p class="Pp"><span class="Li"></span></p>
<pre>
    use MIME::Decoder;

    $decoder = new MIME::Decoder 'quoted-printable' or die &quot;unsupported&quot;;
    $decoder-&gt;decode(\*STDIN, \*STDOUT);
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Encoding_a_data_stream"><a class="permalink" href="#Encoding_a_data_stream">Encoding
  a data stream</a></h2>
Here's a simple filter program to read binary data from STDIN (until EOF) and
  write base64-encoded data to STDOUT:
<p class="Pp"><span class="Li"></span></p>
<pre>
    use MIME::Decoder;

    $decoder = new MIME::Decoder 'base64' or die &quot;unsupported&quot;;
    $decoder-&gt;encode(\*STDIN, \*STDOUT);
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Non-standard_encodings"><a class="permalink" href="#Non-standard_encodings">Non-standard
  encodings</a></h2>
You can <b>write and install</b> your own decoders so that MIME::Decoder will
  know about them:
<p class="Pp"><span class="Li"></span></p>
<pre>
    use MyBase64Decoder;

    install MyBase64Decoder 'base64';
</pre>
<p class="Pp">You can also <b>test</b> if a given encoding is supported:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    if (supported MIME::Decoder 'x-uuencode') {
        ### we can uuencode!
    }
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
This abstract class, and its private concrete subclasses (see below) provide an
  OO front end to the actions of...
<ul class="Bl-bullet">
  <li>Decoding a MIME-encoded stream</li>
  <li>Encoding a raw data stream into a MIME-encoded stream.</li>
</ul>
<p class="Pp">The constructor for MIME::Decoder takes the name of an encoding
    (<span class="Li">&quot;base64&quot;</span>,
    <span class="Li">&quot;7bit&quot;</span>, etc.), and returns an instance of
    a <i>subclass</i> of MIME::Decoder whose
    <span class="Li">&quot;decode()&quot;</span> method will perform the
    appropriate decoding action, and whose
    <span class="Li">&quot;encode()&quot;</span> method will perform the
    appropriate encoding action.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="PUBLIC_INTERFACE"><a class="permalink" href="#PUBLIC_INTERFACE">PUBLIC
  INTERFACE</a></h1>
<section class="Ss">
<h2 class="Ss" id="Standard_interface"><a class="permalink" href="#Standard_interface">Standard
  interface</a></h2>
If all you are doing is <i>using</i> this class, here's all you'll need...
<dl class="Bl-tag">
  <dt>new ENCODING</dt>
  <dd><i>Class method, constructor.</i> Create and return a new decoder object
      which can handle the given ENCODING.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    my $decoder = new MIME::Decoder &quot;7bit&quot;;
    </pre>
    <p class="Pp">Returns the undefined value if no known decoders are
        appropriate.</p>
  </dd>
  <dt>best ENCODING</dt>
  <dd><i>Class method, constructor.</i> Exactly like <i>new()</i>, except that
      this defaults any unsupported encoding to &quot;binary&quot;, after
      raising a suitable warning (it's a fatal error if there's no binary
      decoder).
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    my $decoder = best MIME::Decoder &quot;x-gzip64&quot;;
    </pre>
    <p class="Pp">Will either return a decoder, or a raise a fatal
      exception.</p>
  </dd>
  <dt>decode INSTREAM,OUTSTREAM</dt>
  <dd><i>Instance method.</i> Decode the document waiting in the input handle
      INSTREAM, writing the decoded information to the output handle OUTSTREAM.
    <p class="Pp">Read the section in this document on I/O handles for more
        information about the arguments. Note that you can still supply
        old-style unblessed filehandles for INSTREAM and OUTSTREAM.</p>
    <p class="Pp">Returns true on success, throws exception on failure.</p>
  </dd>
  <dt>encode INSTREAM,OUTSTREAM</dt>
  <dd><i>Instance method.</i> Encode the document waiting in the input
      filehandle INSTREAM, writing the encoded information to the output stream
      OUTSTREAM.
    <p class="Pp">Read the section in this document on I/O handles for more
        information about the arguments. Note that you can still supply
        old-style unblessed filehandles for INSTREAM and OUTSTREAM.</p>
    <p class="Pp">Returns true on success, throws exception on failure.</p>
  </dd>
  <dt>encoding</dt>
  <dd><i>Instance method.</i> Return the encoding that this object was created
      to handle, coerced to all lowercase (e.g.,
      <span class="Li">&quot;base64&quot;</span>).</dd>
  <dt>head [HEAD]</dt>
  <dd><i>Instance method.</i> Completely optional: some decoders need to know a
      little about the file they are encoding/decoding; e.g., x-uu likes to have
      the filename. The HEAD is any object which responds to messages like:
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    $head-&gt;mime_attr('content-disposition.filename');
    </pre>
  </dd>
  <dt>supported [ENCODING]</dt>
  <dd><i>Class method.</i> With one arg (an ENCODING name), returns truth if
      that encoding is currently handled, and falsity otherwise. The ENCODING
      will be automatically coerced to lowercase:
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    if (supported MIME::Decoder '7BIT') {
        ### yes, we can handle it...
    }
    else {
        ### drop back six and punt...
    }
    </pre>
    <p class="Pp">With no args, returns a reference to a hash of all available
        decoders, where the key is the encoding name (all lowercase, like
        '7bit'), and the value is true (it happens to be the name of the class
        that handles the decoding, but you probably shouldn't rely on that). You
        may safely modify this hash; it will <i>not</i> change the way the
        module performs its lookups. Only
        <span class="Li">&quot;install&quot;</span> can do that.</p>
    <p class="Pp"><i>Thanks to Achim Bohnet for suggesting this method.</i></p>
  </dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Subclass_interface"><a class="permalink" href="#Subclass_interface">Subclass
  interface</a></h2>
If you are writing (or installing) a new decoder subclass, there are some other
  methods you'll need to know about:
<dl class="Bl-tag">
  <dt>decode_it INSTREAM,OUTSTREAM</dt>
  <dd><i>Abstract instance method.</i> The back-end of the <b>decode</b> method.
      It takes an input handle opened for reading (INSTREAM), and an output
      handle opened for writing (OUTSTREAM).
    <p class="Pp">If you are writing your own decoder subclass, you must
        override this method in your class. Your method should read from the
        input handle via <span class="Li">&quot;getline()&quot;</span> or
        <span class="Li">&quot;read()&quot;</span>, decode this input, and print
        the decoded data to the output handle via
        <span class="Li">&quot;print()&quot;</span>. You may do this however you
        see fit, so long as the end result is the same.</p>
    <p class="Pp">Note that unblessed references and globrefs are automatically
        turned into I/O handles for you by
        <span class="Li">&quot;decode()&quot;</span>, so you don't need to worry
        about it.</p>
    <p class="Pp">Your method must return either
        <span class="Li">&quot;undef&quot;</span> (to indicate failure), or
        <span class="Li">1</span> (to indicate success). It may also throw an
        exception to indicate failure.</p>
  </dd>
  <dt>encode_it INSTREAM,OUTSTREAM</dt>
  <dd><i>Abstract instance method.</i> The back-end of the <b>encode</b> method.
      It takes an input handle opened for reading (INSTREAM), and an output
      handle opened for writing (OUTSTREAM).
    <p class="Pp">If you are writing your own decoder subclass, you must
        override this method in your class. Your method should read from the
        input handle via <span class="Li">&quot;getline()&quot;</span> or
        <span class="Li">&quot;read()&quot;</span>, encode this input, and print
        the encoded data to the output handle via
        <span class="Li">&quot;print()&quot;</span>. You may do this however you
        see fit, so long as the end result is the same.</p>
    <p class="Pp">Note that unblessed references and globrefs are automatically
        turned into I/O handles for you by
        <span class="Li">&quot;encode()&quot;</span>, so you don't need to worry
        about it.</p>
    <p class="Pp">Your method must return either
        <span class="Li">&quot;undef&quot;</span> (to indicate failure), or
        <span class="Li">1</span> (to indicate success). It may also throw an
        exception to indicate failure.</p>
  </dd>
  <dt>filter IN, OUT, COMMAND...</dt>
  <dd><i>Class method, utility.</i> If your decoder involves an external
      program, you can invoke them easily through this method. The command must
      be a &quot;filter&quot;: a command that reads input from its STDIN (which
      will come from the IN argument) and writes output to its STDOUT (which
      will go to the OUT argument).
    <p class="Pp">For example, here's a decoder that un-gzips its data:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    sub decode_it {
        my ($self, $in, $out) = @_;
        $self-&gt;filter($in, $out, &quot;gzip -d -&quot;);
    }
    </pre>
    <p class="Pp">The usage is similar to IPC::Open2::open2 (which it uses
        internally), so you can specify COMMAND as a single argument or as an
        array.</p>
  </dd>
  <dt>init ARGS...</dt>
  <dd><i>Instance method.</i> Do any necessary initialization of the new
      instance, taking whatever arguments were given to
      <span class="Li">&quot;new()&quot;</span>. Should return the self object
      on success, undef on failure.</dd>
  <dt>install ENCODINGS...</dt>
  <dd><i>Class method</i>. Install this class so that each encoding in ENCODINGS
      is handled by it:
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    install MyBase64Decoder 'base64', 'x-base64super';
    </pre>
    <p class="Pp">You should not override this method.</p>
  </dd>
  <dt>uninstall ENCODINGS...</dt>
  <dd><i>Class method</i>. Uninstall support for encodings. This is a way to
      turn off the decoding of &quot;experimental&quot; encodings. For safety,
      always use MIME::Decoder directly:
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    uninstall MIME::Decoder 'x-uu', 'x-uuencode';
    </pre>
    <p class="Pp">You should not override this method.</p>
  </dd>
</dl>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="DECODER_SUBCLASSES"><a class="permalink" href="#DECODER_SUBCLASSES">DECODER
  SUBCLASSES</a></h1>
You don't need to <span class="Li">&quot;use&quot;</span> any other Perl
  modules; the following &quot;standard&quot; subclasses are included as part of
  MIME::Decoder:
<p class="Pp"><span class="Li"></span></p>
<pre>
     Class:                         Handles encodings:
     ------------------------------------------------------------
     MIME::Decoder::Binary          binary
     MIME::Decoder::NBit            7bit, 8bit
     MIME::Decoder::Base64          base64
     MIME::Decoder::QuotedPrint     quoted-printable
</pre>
<p class="Pp">The following &quot;non-standard&quot; subclasses are also
    included:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
     Class:                         Handles encodings:
     ------------------------------------------------------------
     MIME::Decoder::UU              x-uu, x-uuencode
     MIME::Decoder::Gzip64          x-gzip64            ** requires gzip!
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="NOTES"><a class="permalink" href="#NOTES">NOTES</a></h1>
<section class="Ss">
<h2 class="Ss" id="Input/Output_handles"><a class="permalink" href="#Input/Output_handles">Input/Output
  handles</a></h2>
As of MIME-tools 2.0, this class has to play nice with the new MIME::Body
  class... which means that input and output routines cannot just assume that
  they are dealing with filehandles.
<p class="Pp">Therefore, all that MIME::Decoder and its subclasses require (and,
    thus, all that they can assume) is that INSTREAMs and OUTSTREAMs are objects
    which respond to a subset of the messages defined in the IO::Handle
    interface; minimally:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
      print
      getline
      read(BUF,NBYTES)
</pre>
<p class="Pp"><i>Thanks to Achim Bohnet for suggesting this more-generic I/O
    model.</i></p>
</section>
<section class="Ss">
<h2 class="Ss" id="Writing_a_decoder"><a class="permalink" href="#Writing_a_decoder">Writing
  a decoder</a></h2>
If you're experimenting with your own encodings, you'll probably want to write a
  decoder. Here are the basics:
<dl class="Bl-tag">
  <dt>1.</dt>
  <dd>Create a module, like &quot;MyDecoder::&quot;, for your decoder. Declare
      it to be a subclass of MIME::Decoder.</dd>
  <dt>2.</dt>
  <dd>Create the following instance methods in your class, as described above:
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    decode_it
    encode_it
    init
    </pre>
  </dd>
  <dt>3.</dt>
  <dd>In your application program, activate your decoder for one or more
      encodings like this:
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    require MyDecoder;

    install MyDecoder &quot;7bit&quot;;   ### use MyDecoder to decode &quot;7bit&quot;
    install MyDecoder &quot;x-foo&quot;;  ### also use MyDecoder to decode &quot;x-foo&quot;
    </pre>
  </dd>
</dl>
<p class="Pp">To illustrate, here's a custom decoder class for the
    <span class="Li">&quot;quoted-printable&quot;</span> encoding:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    package MyQPDecoder;

    @ISA = qw(MIME::Decoder);
    use MIME::Decoder;
    use MIME::QuotedPrint;

    ### decode_it - the private decoding method
    sub decode_it {
        my ($self, $in, $out) = @_;
        local $_;
        while (defined($_ = $in-&gt;getline)) {
            my $decoded = decode_qp($_);
            $out-&gt;print($decoded);
        }
        1;
    }

    ### encode_it - the private encoding method
    sub encode_it {
        my ($self, $in, $out) = @_;

        my ($buf, $nread) = ('', 0);
        while ($in-&gt;read($buf, 60)) {
            my $encoded = encode_qp($buf);
            $out-&gt;print($encoded);
        }
        1;
    }
</pre>
<p class="Pp">That's it. The task was pretty simple because the
    <span class="Li">&quot;quoted-printable&quot;</span> encoding can easily be
    converted line-by-line... as can even
    <span class="Li">&quot;7bit&quot;</span> and
    <span class="Li">&quot;8bit&quot;</span> (since all these encodings
    guarantee short lines, with a max of 1000 characters). The good news is: it
    is very likely that it will be similarly-easy to write a MIME::Decoder for
    any future standard encodings.</p>
<p class="Pp">The <span class="Li">&quot;binary&quot;</span> decoder, however,
    really required block reads and writes: see
    &quot;MIME::Decoder::Binary&quot; for details.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
MIME::Tools, other MIME::Decoder subclasses.
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
Eryq (<i>eryq@zeegee.com</i>), ZeeGee Software Inc
  (<i>http://www.zeegee.com</i>).
<p class="Pp">All rights reserved. This program is free software; you can
    redistribute it and/or modify it under the same terms as Perl itself.</p>
<p class="Pp">1;</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2013-11-14</td>
    <td class="foot-os">perl v5.18.4</td>
  </tr>
</table>
</body>
</html>
