<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.10 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>Safe(3pm)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Safe(3pm)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">Safe(3pm)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
Safe - Compile and execute code in restricted compartments
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<span class="Li"></span>
<pre>
  use Safe;

  $compartment = new Safe;

  $compartment-&gt;permit(qw(time sort :browse));

  $result = $compartment-&gt;reval($unsafe_code);
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
The Safe extension module allows the creation of compartments in which perl code
  can be evaluated. Each compartment has
<dl class="Bl-tag">
  <dt>a new namespace</dt>
  <dd>The &quot;root&quot; of the namespace (i.e. &quot;main::&quot;) is changed
      to a different package and code evaluated in the compartment cannot refer
      to variables outside this namespace, even with run-time glob lookups and
      other tricks.
    <p class="Pp">Code which is compiled outside the compartment can choose to
        place variables into (or <i>share</i> variables with) the compartment's
        namespace and only that data will be visible to code evaluated in the
        compartment.</p>
    <p class="Pp">By default, the only variables shared with compartments are
        the &quot;underscore&quot; variables <span class="Li">$_</span> and
        <span class="Li">@_</span> (and, technically, the less frequently used
        <span class="Li">%_</span>, the _ filehandle and so on). This is because
        otherwise perl operators which default to <span class="Li">$_</span>
        will not work and neither will the assignment of arguments to
        <span class="Li">@_</span> on subroutine entry.</p>
  </dd>
  <dt>an operator mask</dt>
  <dd>Each compartment has an associated &quot;operator mask&quot;. Recall that
      perl code is compiled into an internal format before execution. Evaluating
      perl code (e.g. via &quot;eval&quot; or &quot;do 'file'&quot;) causes the
      code to be compiled into an internal format and then, provided there was
      no error in the compilation, executed. Code evaluated in a compartment
      compiles subject to the compartment's operator mask. Attempting to
      evaluate code in a compartment which contains a masked operator will cause
      the compilation to fail with an error. The code will not be executed.
    <p class="Pp">The default operator mask for a newly created compartment is
        the ':default' optag.</p>
    <p class="Pp">It is important that you read the Opcode module documentation
        for more information, especially for detailed definitions of opnames,
        optags and opsets.</p>
    <p class="Pp">Since it is only at the compilation stage that the operator
        mask applies, controlled access to potentially unsafe operations can be
        achieved by having a handle to a wrapper subroutine (written outside the
        compartment) placed into the compartment. For example,</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    $cpt = new Safe;
    sub wrapper {
      # vet arguments and perform potentially unsafe operations
    }
    $cpt-&gt;share('&amp;wrapper');
    </pre>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="WARNING"><a class="permalink" href="#WARNING">WARNING</a></h1>
The authors make <b>no warranty</b>, implied or otherwise, about the suitability
  of this software for safety or security purposes.
<p class="Pp">The authors shall not in any case be liable for special,
    incidental, consequential, indirect or other similar damages arising from
    the use of this software.</p>
<p class="Pp">Your mileage will vary. If in any doubt <b>do not use it</b>.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="METHODS"><a class="permalink" href="#METHODS">METHODS</a></h1>
To create a new compartment, use
<p class="Pp"><span class="Li"></span></p>
<pre>
    $cpt = new Safe;
</pre>
<p class="Pp">Optional argument is (NAMESPACE), where NAMESPACE is the root
    namespace to use for the compartment (defaults to &quot;Safe::Root0&quot;,
    incremented for each new compartment).</p>
<p class="Pp">Note that version 1.00 of the Safe module supported a second
    optional parameter, MASK. That functionality has been withdrawn pending
    deeper consideration. Use the permit and deny methods described below.</p>
<p class="Pp">The following methods can then be used on the compartment object
    returned by the above constructor. The object argument is implicit in each
    case.</p>
<section class="Ss">
<h2 class="Ss" id="permit_(_s-1OP,_..._s0)"><a class="permalink" href="#permit_(_s-1OP,_..._s0)">permit
  (OP, ...)</a></h2>
Permit the listed operators to be used when compiling code in the compartment
  (in <i>addition</i> to any operators already permitted).
<p class="Pp">You can list opcodes by names, or use a tag name; see
    &quot;Predefined Opcode Tags&quot; in Opcode.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="permit_only_(_s-1OP,_..._s0)"><a class="permalink" href="#permit_only_(_s-1OP,_..._s0)">permit_only
  (OP, ...)</a></h2>
Permit <i>only</i> the listed operators to be used when compiling code in the
  compartment (<i>no</i> other operators are permitted).
</section>
<section class="Ss">
<h2 class="Ss" id="deny_(_s-1OP,_..._s0)"><a class="permalink" href="#deny_(_s-1OP,_..._s0)">deny
  (OP, ...)</a></h2>
Deny the listed operators from being used when compiling code in the compartment
  (other operators may still be permitted).
</section>
<section class="Ss">
<h2 class="Ss" id="deny_only_(_s-1OP,_..._s0)"><a class="permalink" href="#deny_only_(_s-1OP,_..._s0)">deny_only
  (OP, ...)</a></h2>
Deny <i>only</i> the listed operators from being used when compiling code in the
  compartment (<i>all</i> other operators will be permitted, so you probably
  don't want to use this method).
</section>
<section class="Ss">
<h2 class="Ss" id="trap_(_s-1OP,_..._s0),_untrap_(_s-1OP,_..._s0)"><a class="permalink" href="#trap_(_s-1OP,_..._s0),_untrap_(_s-1OP,_..._s0)">trap
  (OP, ...), untrap (OP, ...)</a></h2>
The trap and untrap methods are synonyms for deny and permit respectfully.
</section>
<section class="Ss">
<h2 class="Ss" id="share_(_s-1NAME,_..._s0)"><a class="permalink" href="#share_(_s-1NAME,_..._s0)">share
  (NAME, ...)</a></h2>
This shares the variable(s) in the argument list with the compartment. This is
  almost identical to exporting variables using the Exporter module.
<p class="Pp">Each NAME must be the <b>name</b> of a non-lexical variable,
    typically with the leading type identifier included. A bareword is treated
    as a function name.</p>
<p class="Pp">Examples of legal names are '$foo' for a scalar, '@foo' for an
    array, '%foo' for a hash, '&amp;foo' or 'foo' for a subroutine and '*foo'
    for a glob (i.e. all symbol table entries associated with &quot;foo&quot;,
    including scalar, array, hash, sub and filehandle).</p>
<p class="Pp">Each NAME is assumed to be in the calling package. See share_from
    for an alternative method (which <span class="Li">&quot;share&quot;</span>
    uses).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="share_from_(_s-1PACKAGE,_ARRAYREF_s0)"><a class="permalink" href="#share_from_(_s-1PACKAGE,_ARRAYREF_s0)">share_from
  (PACKAGE, ARRAYREF)</a></h2>
This method is similar to <b>share()</b> but allows you to explicitly name the
  package that symbols should be shared from. The symbol names (including type
  characters) are supplied as an array reference.
<p class="Pp"><span class="Li"></span></p>
<pre>
    $safe-&gt;share_from('main', [ '$foo', '%bar', 'func' ]);
</pre>
<p class="Pp">Names can include package names, which are relative to the
    specified PACKAGE. So these two calls have the same effect:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    $safe-&gt;share_from('Scalar::Util', [ 'reftype' ]);
    $safe-&gt;share_from('main', [ 'Scalar::Util::reftype' ]);
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="varglob_(_s-1VARNAME_s0)"><a class="permalink" href="#varglob_(_s-1VARNAME_s0)">varglob
  (VARNAME)</a></h2>
This returns a glob reference for the symbol table entry of VARNAME in the
  package of the compartment. VARNAME must be the <b>name</b> of a variable
  without any leading type marker. For example:
<p class="Pp"><span class="Li"></span></p>
<pre>
    ${$cpt-&gt;varglob('foo')} = &quot;Hello world&quot;;
</pre>
<p class="Pp">has the same effect as:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    $cpt = new Safe 'Root';
    $Root::foo = &quot;Hello world&quot;;
</pre>
<p class="Pp">but avoids the need to know <span class="Li">$cpt</span>'s package
    name.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="reval_(_s-1STRING,_STRICT_s0)"><a class="permalink" href="#reval_(_s-1STRING,_STRICT_s0)">reval
  (STRING, STRICT)</a></h2>
This evaluates STRING as perl code inside the compartment.
<p class="Pp">The code can only see the compartment's namespace (as returned by
    the <b>root</b> method). The compartment's root package appears to be the
    <span class="Li">&quot;main::&quot;</span> package to the code inside the
    compartment.</p>
<p class="Pp">Any attempt by the code in STRING to use an operator which is not
    permitted by the compartment will cause an error (at run-time of the main
    program but at compile-time for the code in STRING). The error is of the
    form &quot;'%s' trapped by operation mask...&quot;.</p>
<p class="Pp">If an operation is trapped in this way, then the code in STRING
    will not be executed. If such a trapped operation occurs or any other
    compile-time or return error, then $@ is set to the error message, just as
    with an <b>eval()</b>.</p>
<p class="Pp">If there is no error, then the method returns the value of the
    last expression evaluated, or a return statement may be used, just as with
    subroutines and <b></b><b>eval()</b><b></b>. The context (list or scalar) is
    determined by the caller as usual.</p>
<p class="Pp">If the return value of <b>reval()</b> is (or contains) any code
    reference, those code references are wrapped to be themselves executed
    always in the compartment. See &quot;wrap_code_refs_within&quot;.</p>
<p class="Pp">The formerly undocumented STRICT argument sets strictness: if true
    'use strict;' is used, otherwise it uses 'no strict;'. <b>Note</b>: if
    STRICT is omitted 'no strict;' is the default.</p>
<p class="Pp">Some points to note:</p>
<p class="Pp">If the entereval op is permitted then the code can use eval
    &quot;...&quot; to 'hide' code which might use denied ops. This is not a
    major problem since when the code tries to execute the eval it will fail
    because the opmask is still in effect. However this technique would allow
    clever, and possibly harmful, code to 'probe' the boundaries of what is
    possible.</p>
<p class="Pp">Any string eval which is executed by code executing in a
    compartment, or by code called from code executing in a compartment, will be
    eval'd in the namespace of the compartment. This is potentially a serious
    problem.</p>
<p class="Pp">Consider a function <b>foo()</b> in package pkg compiled outside a
    compartment but shared with it. Assume the compartment has a root package
    called 'Root'. If <b>foo()</b> contains an eval statement like eval '$foo =
    1' then, normally, <span class="Li">$pkg::foo</span> will be set to 1. If
    <b>foo()</b> is called from the compartment (by whatever means) then instead
    of setting <span class="Li">$pkg::foo</span>, the eval will actually set
    <span class="Li">$Root::pkg::foo</span>.</p>
<p class="Pp">This can easily be demonstrated by using a module, such as the
    Socket module, which uses eval &quot;...&quot; as part of an AUTOLOAD
    function. You can 'use' the module outside the compartment and share an
    (autoloaded) function with the compartment. If an autoload is triggered by
    code in the compartment, or by any code anywhere that is called by any means
    from the compartment, then the eval in the Socket module's AUTOLOAD function
    happens in the namespace of the compartment. Any variables created or used
    by the eval'd code are now under the control of the code in the
  compartment.</p>
<p class="Pp">A similar effect applies to <i>all</i> runtime symbol lookups in
    code called from a compartment but not compiled within it.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="rdo_(_s-1FILENAME_s0)"><a class="permalink" href="#rdo_(_s-1FILENAME_s0)">rdo
  (FILENAME)</a></h2>
This evaluates the contents of file FILENAME inside the compartment. It uses the
  same rules as perl's built-in <span class="Li">&quot;do&quot;</span> to locate
  the file, poossibly using <span class="Li">@INC</span>.
<p class="Pp">See above documentation on the <b>reval</b> method for further
    details.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="root_(_s-1NAMESPACE_s0)"><a class="permalink" href="#root_(_s-1NAMESPACE_s0)">root
  (NAMESPACE)</a></h2>
This method returns the name of the package that is the root of the
  compartment's namespace.
<p class="Pp">Note that this behaviour differs from version 1.00 of the Safe
    module where the root module could be used to change the namespace. That
    functionality has been withdrawn pending deeper consideration.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="mask_(_s-1MASK_s0)"><a class="permalink" href="#mask_(_s-1MASK_s0)">mask
  (MASK)</a></h2>
This is a get-or-set method for the compartment's operator mask.
<p class="Pp">With no MASK argument present, it returns the current operator
    mask of the compartment.</p>
<p class="Pp">With the MASK argument present, it sets the operator mask for the
    compartment (equivalent to calling the deny_only method).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="wrap_code_ref_(_s-1CODEREF_s0)"><a class="permalink" href="#wrap_code_ref_(_s-1CODEREF_s0)">wrap_code_ref
  (CODEREF)</a></h2>
Returns a reference to an anonymous subroutine that, when executed, will call
  CODEREF with the Safe compartment 'in effect'. In other words, with the
  package namespace adjusted and the opmask enabled.
<p class="Pp">Note that the opmask doesn't affect the already compiled code, it
    only affects any <i>further</i> compilation that the already compiled code
    may try to perform.</p>
<p class="Pp">This is particularly useful when applied to code references
    returned from <b>reval()</b>.</p>
<p class="Pp">(It also provides a kind of workaround for RT#60374: &quot;Safe.pm
    sort {} bug with -Dusethreads&quot;. See
    &lt;http://rt.perl.org/rt3//Public/Bug/Display.html?id=60374&gt; for
    <i>much</i> more detail.)</p>
</section>
<section class="Ss">
<h2 class="Ss" id="wrap_code_refs_within_(...)"><a class="permalink" href="#wrap_code_refs_within_(...)">wrap_code_refs_within
  (...)</a></h2>
Wraps any CODE references found within the arguments by replacing each with the
  result of calling &quot;wrap_code_ref&quot; on the CODE reference. Any ARRAY
  or HASH references in the arguments are inspected recursively.
<p class="Pp">Returns nothing.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="RISKS"><a class="permalink" href="#RISKS">RISKS</a></h1>
This section is just an outline of some of the things code in a compartment
  might do (intentionally or unintentionally) which can have an effect outside
  the compartment.
<dl class="Bl-tag">
  <dt>Memory</dt>
  <dd>Consuming all (or nearly all) available memory.</dd>
  <dt>CPU</dt>
  <dd>Causing infinite loops etc.</dd>
  <dt>Snooping</dt>
  <dd>Copying private information out of your system. Even something as simple
      as your user name is of value to others. Much useful information could be
      gleaned from your environment variables for example.</dd>
  <dt>Signals</dt>
  <dd>Causing signals (especially SIGFPE and SIGALARM) to affect your process.
    <p class="Pp">Setting up a signal handler will need to be carefully
        considered and controlled. What mask is in effect when a signal handler
        gets called? If a user can get an imported function to get an exception
        and call the user's signal handler, does that user's restricted mask get
        re-instated before the handler is called? Does an imported handler get
        called with its original mask or the user's one?</p>
  </dd>
  <dt>State Changes</dt>
  <dd>Ops such as chdir obviously effect the process as a whole and not just the
      code in the compartment. Ops such as rand and srand have a similar but
      more subtle effect.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
Originally designed and implemented by Malcolm Beattie.
<p class="Pp">Reworked to use the Opcode module and other changes added by Tim
    Bunce.</p>
<p class="Pp">Currently maintained by the Perl 5 Porters,
    &lt;perl5-porters@perl.org&gt;.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2018-11-01</td>
    <td class="foot-os">perl v5.28.2</td>
  </tr>
</table>
</body>
</html>
