<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>Module::Build::Cookbook(3pm)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Module::Build::Cookbook(3pm)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">Module::Build::Cookbook(3pm)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
Module::Build::Cookbook - Examples of Module::Build Usage
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<span class="Li">&quot;Module::Build&quot;</span> isn't conceptually very
  complicated, but examples are always helpful. The following recipes should
  help developers and/or installers put together the pieces from the other parts
  of the documentation.
</section>
<section class="Sh">
<h1 class="Sh" id="BASIC_RECIPES"><a class="permalink" href="#BASIC_RECIPES">BASIC
  RECIPES</a></h1>
<section class="Ss">
<h2 class="Ss" id="Installing_modules_that_use_Module::Build"><a class="permalink" href="#Installing_modules_that_use_Module::Build">Installing
  modules that use Module::Build</a></h2>
In most cases, you can just issue the following commands:
<p class="Pp"><span class="Li"></span></p>
<pre>
  perl Build.PL
  ./Build
  ./Build test
  ./Build install
</pre>
<p class="Pp">There's nothing complicated here - first you're running a script
    called <i>Build.PL</i>, then you're running a (newly-generated) script
    called <i>Build</i> and passing it various arguments.</p>
<p class="Pp">The exact commands may vary a bit depending on how you invoke perl
    scripts on your system. For instance, if you have multiple versions of perl
    installed, you can install to one particular perl's library directories like
    so:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  /usr/bin/perl5.8.1 Build.PL
  ./Build
  ./Build test
  ./Build install
</pre>
<p class="Pp">If you're on Windows where the current directory is always
    searched first for scripts, you'll probably do something like this:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  perl Build.PL
  Build
  Build test
  Build install
</pre>
<p class="Pp">On the old Mac OS (version 9 or lower) using MacPerl, you can
    double-click on the <i>Build.PL</i> script to create the <i>Build</i>
    script, then double-click on the <i>Build</i> script to run its
    <span class="Li">&quot;build&quot;</span>,
    <span class="Li">&quot;test&quot;</span>, and
    <span class="Li">&quot;install&quot;</span> actions.</p>
<p class="Pp">The <i>Build</i> script knows what perl was used to run
    <i>Build.PL</i>, so you don't need to re-invoke the <i>Build</i> script with
    the complete perl path each time. If you invoke it with the <i>wrong</i>
    perl path, you'll get a warning or a fatal error.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Modifying_Config.pm_values"><a class="permalink" href="#Modifying_Config.pm_values">Modifying
  Config.pm values</a></h2>
<span class="Li">&quot;Module::Build&quot;</span> relies heavily on various
  values from perl's <span class="Li">&quot;Config.pm&quot;</span> to do its
  work. For example, default installation paths are given by
  <span class="Li">&quot;installsitelib&quot;</span> and
  <span class="Li">&quot;installvendorman3dir&quot;</span> and friends, C linker
  &amp; compiler settings are given by <span class="Li">&quot;ld&quot;</span>,
  <span class="Li">&quot;lddlflags&quot;</span>,
  <span class="Li">&quot;cc&quot;</span>,
  <span class="Li">&quot;ccflags&quot;</span>, and so on. <i>If you're pretty
  sure</i> <i>you know what you're doing</i>, you can tell
  <span class="Li">&quot;Module::Build&quot;</span> to pretend there are
  different values in <i>Config.pm</i> than what's really there, by passing
  arguments for the <span class="Li">&quot;--config&quot;</span> parameter on
  the command line:
<p class="Pp"><span class="Li"></span></p>
<pre>
  perl Build.PL --config cc=gcc --config ld=gcc
</pre>
<p class="Pp">Inside the <span class="Li">&quot;Build.PL&quot;</span> script the
    same thing can be accomplished by passing values for the
    <span class="Li">&quot;config&quot;</span> parameter to
    <span class="Li">&quot;new()&quot;</span>:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
 my $build = Module::Build-&gt;new
   (
    ...
    config =&gt; { cc =&gt; 'gcc', ld =&gt; 'gcc' },
    ...
   );
</pre>
<p class="Pp">In custom build code, the same thing can be accomplished by
    calling the &quot;config&quot; in Module::Build method:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
 $build-&gt;config( cc =&gt; 'gcc' );     # Set
 $build-&gt;config( ld =&gt; 'gcc' );     # Set
 ...
 my $linker = $build-&gt;config('ld'); # Get
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Installing_modules_using_the_programmatic_interface"><a class="permalink" href="#Installing_modules_using_the_programmatic_interface">Installing
  modules using the programmatic interface</a></h2>
If you need to build, test, and/or install modules from within some other perl
  code (as opposed to having the user type installation commands at the shell),
  you can use the programmatic interface. Create a Module::Build object (or an
  object of a custom Module::Build subclass) and then invoke its
  <span class="Li">&quot;dispatch()&quot;</span> method to run various actions.
<p class="Pp"><span class="Li"></span></p>
<pre>
  my $build = Module::Build-&gt;new
    (
     module_name =&gt; 'Foo::Bar',
     license     =&gt; 'perl',
     requires    =&gt; { 'Some::Module'   =&gt; '1.23' },
    );
  $build-&gt;dispatch('build');
  $build-&gt;dispatch('test', verbose =&gt; 1);
  $build-&gt;dispatch('install');
</pre>
<p class="Pp">The first argument to
    <span class="Li">&quot;dispatch()&quot;</span> is the name of the action,
    and any following arguments are named parameters.</p>
<p class="Pp">This is the interface we use to test Module::Build itself in the
    regression tests.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Installing_to_a_temporary_directory"><a class="permalink" href="#Installing_to_a_temporary_directory">Installing
  to a temporary directory</a></h2>
To create packages for package managers like RedHat's
  <span class="Li">&quot;rpm&quot;</span> or Debian's
  <span class="Li">&quot;deb&quot;</span>, you may need to install to a
  temporary directory first and then create the package from that temporary
  installation. To do this, specify the
  <span class="Li">&quot;destdir&quot;</span> parameter to the
  <span class="Li">&quot;install&quot;</span> action:
<p class="Pp"><span class="Li"></span></p>
<pre>
  ./Build install --destdir /tmp/my-package-1.003
</pre>
<p class="Pp">This essentially just prepends all the installation paths with the
    <i>/tmp/my-package-1.003</i> directory.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Installing_to_a_non-standard_directory"><a class="permalink" href="#Installing_to_a_non-standard_directory">Installing
  to a non-standard directory</a></h2>
To install to a non-standard directory (for example, if you don't have
  permission to install in the system-wide directories), you can use the
  <span class="Li">&quot;install_base&quot;</span> or
  <span class="Li">&quot;prefix&quot;</span> parameters:
<p class="Pp"><span class="Li"></span></p>
<pre>
  ./Build install --install_base /foo/bar
</pre>
<p class="Pp">See &quot;INSTALL PATHS&quot; in Module::Build for a much more
    complete discussion of how installation paths are determined.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Installing_in_the_same_location_as_ExtUtils::MakeMaker"><a class="permalink" href="#Installing_in_the_same_location_as_ExtUtils::MakeMaker">Installing
  in the same location as ExtUtils::MakeMaker</a></h2>
With the introduction of <span class="Li">&quot;--prefix&quot;</span> in
  Module::Build 0.28 and <span class="Li">&quot;INSTALL_BASE&quot;</span> in
  <span class="Li">&quot;ExtUtils::MakeMaker&quot;</span> 6.31 its easy to get
  them both to install to the same locations.
<p class="Pp">First, ensure you have at least version 0.28 of Module::Build
    installed and 6.31 of
    <span class="Li">&quot;ExtUtils::MakeMaker&quot;</span>. Prior versions have
    differing (and in some cases quite strange) installation behaviors.</p>
<p class="Pp">The following installation flags are equivalent between
    <span class="Li">&quot;ExtUtils::MakeMaker&quot;</span> and
    <span class="Li">&quot;Module::Build&quot;</span>.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    MakeMaker             Module::Build
    PREFIX=...            --prefix ...
    INSTALL_BASE=...      --install_base ...
    DESTDIR=...           --destdir ...
    LIB=...               --install_path lib=...
    INSTALLDIRS=...       --installdirs ...
    INSTALLDIRS=perl      --installdirs core
    UNINST=...            --uninst ...
    INC=...               --extra_compiler_flags ...
    POLLUTE=1             --extra_compiler_flags -DPERL_POLLUTE
</pre>
<p class="Pp">For example, if you are currently installing
    <span class="Li">&quot;MakeMaker&quot;</span> modules with this command:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    perl Makefile.PL PREFIX=~
    make test
    make install UNINST=1
</pre>
<p class="Pp">You can install into the same location with Module::Build using
    this:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    perl Build.PL --prefix ~
    ./Build test
    ./Build install --uninst 1
</pre>
<p class="Pp"><i></i><i>&quot;prefix&quot;</i><i> vs
    </i><i>&quot;install_base&quot;</i><i></i></p>
<p class="Pp">The behavior of <span class="Li">&quot;prefix&quot;</span> is
    complicated and depends on how your Perl is configured. The resulting
    installation locations will vary from machine to machine and even different
    installations of Perl on the same machine. Because of this, it's difficult
    to document where <span class="Li">&quot;prefix&quot;</span> will place your
    modules.</p>
<p class="Pp">In contrast, <span class="Li">&quot;install_base&quot;</span> has
    predictable, easy to explain installation locations. Now that
    <span class="Li">&quot;Module::Build&quot;</span> and
    <span class="Li">&quot;MakeMaker&quot;</span> both have
    <span class="Li">&quot;install_base&quot;</span> there is little reason to
    use <span class="Li">&quot;prefix&quot;</span> other than to preserve your
    existing installation locations. If you are starting a fresh Perl
    installation we encourage you to use
    <span class="Li">&quot;install_base&quot;</span>. If you have an existing
    installation installed via <span class="Li">&quot;prefix&quot;</span>,
    consider moving it to an installation structure matching
    <span class="Li">&quot;install_base&quot;</span> and using that instead.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Running_a_single_test_file"><a class="permalink" href="#Running_a_single_test_file">Running
  a single test file</a></h2>
<span class="Li">&quot;Module::Build&quot;</span> supports running a single
  test, which enables you to track down errors more quickly. Use the following
  format:
<p class="Pp"><span class="Li"></span></p>
<pre>
  ./Build test --test_files t/mytest.t
</pre>
<p class="Pp">In addition, you may want to run the test in verbose mode to get
    more informative output:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  ./Build test --test_files t/mytest.t --verbose 1
</pre>
<p class="Pp">I run this so frequently that I define the following shell
  alias:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  alias t './Build test --verbose 1 --test_files'
</pre>
<p class="Pp">So then I can just execute <span class="Li">&quot;t
    t/mytest.t&quot;</span> to run a single test.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="ADVANCED_RECIPES"><a class="permalink" href="#ADVANCED_RECIPES">ADVANCED
  RECIPES</a></h1>
<section class="Ss">
<h2 class="Ss" id="Making_a__s-1CPAN_s0.pm_-compatible_distribution"><a class="permalink" href="#Making_a__s-1CPAN_s0.pm_-compatible_distribution">Making
  a CPAN.pm-compatible distribution</a></h2>
New versions of CPAN.pm understand how to use a <i>Build.PL</i> script, but old
  versions don't. If authors want to help users who have old versions, some form
  of <i>Makefile.PL</i> should be supplied. The easiest way to accomplish this
  is to use the <span class="Li">&quot;create_makefile_pl&quot;</span> parameter
  to <span class="Li">&quot;Module::Build-&gt;new()&quot;</span> in the
  <span class="Li">&quot;Build.PL&quot;</span> script, which can create various
  flavors of <i>Makefile.PL</i> during the
  <span class="Li">&quot;dist&quot;</span> action.
<p class="Pp">As a best practice, we recommend using the &quot;traditional&quot;
    style of <i>Makefile.PL</i> unless your distribution has needs that can't be
    accomplished that way.</p>
<p class="Pp">The <span class="Li">&quot;Module::Build::Compat&quot;</span>
    module, which is part of <span class="Li">&quot;Module::Build&quot;</span>'s
    distribution, is responsible for creating these <i>Makefile.PL</i>s. Please
    see Module::Build::Compat for the details.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Changing_the_order_of_the_build_process"><a class="permalink" href="#Changing_the_order_of_the_build_process">Changing
  the order of the build process</a></h2>
The <span class="Li">&quot;build_elements&quot;</span> property specifies the
  steps <span class="Li">&quot;Module::Build&quot;</span> will take when
  building a distribution. To change the build order, change the order of the
  entries in that property:
<p class="Pp"><span class="Li"></span></p>
<pre>
  # Process pod files first
  my @e = @{$build-&gt;build_elements};
  my ($i) = grep {$e[$_] eq 'pod'} 0..$#e;
  unshift @e, splice @e, $i, 1;
</pre>
<p class="Pp">Currently, <span class="Li">&quot;build_elements&quot;</span> has
    the following default value:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  [qw( PL support pm xs pod script )]
</pre>
<p class="Pp">Do take care when altering this property, since there may be
    non-obvious (and non-documented!) ordering dependencies in the
    <span class="Li">&quot;Module::Build&quot;</span> code.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Adding_new_file_types_to_the_build_process"><a class="permalink" href="#Adding_new_file_types_to_the_build_process">Adding
  new file types to the build process</a></h2>
Sometimes you might have extra types of files that you want to install alongside
  the standard types like <i>.pm</i> and <i>.pod</i> files. For instance, you
  might have a <i>Bar.dat</i> file containing some data related to the
  <span class="Li">&quot;Foo::Bar&quot;</span> module and you'd like for it to
  end up as <i>Foo/Bar.dat</i> somewhere in perl's <span class="Li">@INC</span>
  path so <span class="Li">&quot;Foo::Bar&quot;</span> can access it easily at
  runtime. The following code from a sample
  <span class="Li">&quot;Build.PL&quot;</span> file demonstrates how to
  accomplish this:
<p class="Pp"><span class="Li"></span></p>
<pre>
  use Module::Build;
  my $build = Module::Build-&gt;new
    (
     module_name =&gt; 'Foo::Bar',
     ...other stuff here...
    );
  $build-&gt;add_build_element('dat');
  $build-&gt;create_build_script;
</pre>
<p class="Pp">This will find all <i>.dat</i> files in the <i>lib/</i> directory,
    copy them to the <i>blib/lib/</i> directory during the
    <span class="Li">&quot;build&quot;</span> action, and install them during
    the <span class="Li">&quot;install&quot;</span> action.</p>
<p class="Pp">If your extra files aren't located in the
    <span class="Li">&quot;lib/&quot;</span> directory in your distribution, you
    can explicitly say where they are, just as you'd do with <i>.pm</i> or
    <i>.pod</i> files:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  use Module::Build;
  my $build = new Module::Build
    (
     module_name =&gt; 'Foo::Bar',
     dat_files =&gt; {'some/dir/Bar.dat' =&gt; 'lib/Foo/Bar.dat'},
     ...other stuff here...
    );
  $build-&gt;add_build_element('dat');
  $build-&gt;create_build_script;
</pre>
<p class="Pp">If your extra files actually need to be created on the user's
    machine, or if they need some other kind of special processing, you'll
    probably want to subclass <span class="Li">&quot;Module::Build&quot;</span>
    and create a special method to process them, named
    <span class="Li">&quot;process_${kind}_files()&quot;</span>:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  use Module::Build;
  my $class = Module::Build-&gt;subclass(code =&gt; &lt;&lt;'EOF');
    sub process_dat_files {
      my $self = shift;
      ... locate and process *.dat files,
      ... and create something in blib/lib/
    }
  EOF
  my $build = $class-&gt;new
    (
     module_name =&gt; 'Foo::Bar',
     ...other stuff here...
    );
  $build-&gt;add_build_element('dat');
  $build-&gt;create_build_script;
</pre>
<p class="Pp">If your extra files don't go in <i>lib/</i> but in some other
    place, see &quot;Adding new elements to the install process&quot; for how to
    actually get them installed.</p>
<p class="Pp">Please note that these examples use some capabilities of
    Module::Build that first appeared in version 0.26. Before that it could
    still be done, but the simple cases took a bit more work.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Adding_new_elements_to_the_install_process"><a class="permalink" href="#Adding_new_elements_to_the_install_process">Adding
  new elements to the install process</a></h2>
By default, Module::Build creates seven subdirectories of the <i>blib</i>
  directory during the build process: <i>lib</i>, <i>arch</i>, <i>bin</i>,
  <i>script</i>, <i>bindoc</i>, <i>libdoc</i>, and <i>html</i> (some of these
  may be missing or empty if there's nothing to go in them). Anything copied to
  these directories during the build will eventually be installed during the
  <span class="Li">&quot;install&quot;</span> action (see &quot;INSTALL
  PATHS&quot; in Module::Build.
<p class="Pp">If you need to create a new custom type of installable element,
    e.g. <span class="Li">&quot;conf&quot;</span>, then you need to tell
    Module::Build where things in <i>blib/conf/</i> should be installed. To do
    this, use the <span class="Li">&quot;install_path&quot;</span> parameter to
    the <span class="Li">&quot;new()&quot;</span> method:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  my $build = Module::Build-&gt;new
    (
     ...other stuff here...
     install_path =&gt; { conf =&gt; $installation_path }
    );
</pre>
<p class="Pp">Or you can call the
    <span class="Li">&quot;install_path()&quot;</span> method later:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  $build-&gt;install_path(conf =&gt; $installation_path);
</pre>
<p class="Pp">The user may also specify the path on the command line:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  perl Build.PL --install_path conf=/foo/path/etc
</pre>
<p class="Pp">The important part, though, is that <i>somehow</i> the install
    path needs to be set, or else nothing in the <i>blib/conf/</i> directory
    will get installed, and a runtime error during the
    <span class="Li">&quot;install&quot;</span> action will result.</p>
<p class="Pp">See also &quot;Adding new file types to the build process&quot;
    for how to create the stuff in <i>blib/conf/</i> in the first place.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="EXAMPLES_ON_CPAN"><a class="permalink" href="#EXAMPLES_ON_CPAN">EXAMPLES
  ON CPAN</a></h1>
Several distributions on CPAN are making good use of various features of
  Module::Build. They can serve as real-world examples for others.
<section class="Ss">
<h2 class="Ss" id="SVN-Notify-Mirror"><a class="permalink" href="#SVN-Notify-Mirror">SVN-Notify-Mirror</a></h2>
&lt;http://search.cpan.org/~jpeacock/SVN-Notify-Mirror/&gt;
<p class="Pp">John Peacock, author of the
    <span class="Li">&quot;SVN-Notify-Mirror&quot;</span> distribution,
  says:</p>
<dl class="Bl-tag">
  <dt>1. Using &quot;auto_features&quot;, I check to see whether two optional
    modules are available - SVN::Notify::Config and Net::SSH;</dt>
  <dd></dd>
  <dt>2. If the S::N::Config module is loaded, I automatically generate test
    files for it during Build (using the &quot;PL_files&quot; property).</dt>
  <dd></dd>
  <dt>3. If the &quot;ssh_feature&quot; is available, I ask if the user wishes
    to perform the ssh tests (since it requires a little preliminary
    setup);</dt>
  <dd></dd>
  <dt>4. Only if the user has &quot;ssh_feature&quot; and answers yes to the
    testing, do I generate a test file.</dt>
  <dd>I'm sure I could not have handled this complexity with EU::MM, but it was
      very easy to do with M::B.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Modifying_an_action"><a class="permalink" href="#Modifying_an_action">Modifying
  an action</a></h2>
Sometimes you might need an to have an action, say
  <span class="Li">&quot;./Build install&quot;</span>, do something unusual. For
  instance, you might need to change the ownership of a file or do something
  else peculiar to your application.
<p class="Pp">You can subclass <span class="Li">&quot;Module::Build&quot;</span>
    on the fly using the <span class="Li">&quot;subclass()&quot;</span> method
    and override the methods that perform the actions. You may need to read
    through <span class="Li">&quot;Module::Build::Authoring&quot;</span> and
    <span class="Li">&quot;Module::Build::API&quot;</span> to find the methods
    you want to override. All &quot;action&quot; methods are implemented by a
    method called &quot;ACTION_&quot; followed by the action's name, so here's
    an example of how it would work for the
    <span class="Li">&quot;install&quot;</span> action:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  # Build.PL
  use Module::Build;
  my $class = Module::Build-&gt;subclass(
      class =&gt; &quot;Module::Build::Custom&quot;,
      code =&gt; &lt;&lt;'SUBCLASS' );

  sub ACTION_install {
      my $self = shift;
      # YOUR CODE HERE
      $self-&gt;SUPER::ACTION_install;
  }
  SUBCLASS

  $class-&gt;new(
      module_name =&gt; 'Your::Module',
      # rest of the usual Module::Build parameters
  )-&gt;create_build_script;
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Adding_an_action"><a class="permalink" href="#Adding_an_action">Adding
  an action</a></h2>
You can add a new <span class="Li">&quot;./Build&quot;</span> action simply by
  writing the method for it in your subclass. Use
  <span class="Li">&quot;depends_on&quot;</span> to declare that another action
  must have been run before your action.
<p class="Pp">For example, let's say you wanted to be able to write
    <span class="Li">&quot;./Build</span> <span class="Li">commit&quot;</span>
    to test your code and commit it to Subversion.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  # Build.PL
  use Module::Build;
  my $class = Module::Build-&gt;subclass(
      class =&gt; &quot;Module::Build::Custom&quot;,
      code =&gt; &lt;&lt;'SUBCLASS' );

  sub ACTION_commit {
      my $self = shift;

      $self-&gt;depends_on(&quot;test&quot;);
      $self-&gt;do_system(qw(svn commit));
  }
  SUBCLASS
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Bundling_Module::Build"><a class="permalink" href="#Bundling_Module::Build">Bundling
  Module::Build</a></h2>
Note: This section probably needs an update as the technology improves (see
  contrib/bundle.pl in the distribution).
<p class="Pp">Suppose you want to use some new-ish features of Module::Build,
    e.g. newer than the version of Module::Build your users are likely to
    already have installed on their systems. The first thing you should do is
    set <span class="Li">&quot;configure_requires&quot;</span> to your minimum
    version of Module::Build. See Module::Build::Authoring.</p>
<p class="Pp">But not every build system honors
    <span class="Li">&quot;configure_requires&quot;</span> yet. Here's how you
    can ship a copy of Module::Build, but still use a newer installed version to
    take advantage of any bug fixes and upgrades.</p>
<p class="Pp">First, install Module::Build into
    <i>Your-Project/inc/Module-Build</i>. CPAN will not index anything in the
    <i>inc</i> directory so this copy will not show up in CPAN searches.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    cd Module-Build
    perl Build.PL --install_base /path/to/Your-Project/inc/Module-Build
    ./Build test
    ./Build install
</pre>
<p class="Pp">You should now have all the Module::Build .pm files in
    <i>Your-Project/inc/Module-Build/lib/perl5</i>.</p>
<p class="Pp">Next, add this to the top of your <i>Build.PL</i>.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    my $Bundled_MB = 0.30;  # or whatever version it was.

    # Find out what version of Module::Build is installed or fail quietly.
    # This should be cross-platform.
    my $Installed_MB =
        `$^X -e &quot;eval q{require Module::Build; print Module::Build-&gt;VERSION} or exit 1&quot;;

    # some operating systems put a newline at the end of every print.
    chomp $Installed_MB;

    $Installed_MB = 0 if $?;

    # Use our bundled copy of Module::Build if it's newer than the installed.
    unshift @INC, &quot;inc/Module-Build/lib/perl5&quot; if $Bundled_MB &gt; $Installed_MB;

    require Module::Build;
</pre>
<p class="Pp">And write the rest of your <i>Build.PL</i> normally. Module::Build
    will remember your change to <span class="Li">@INC</span> and use it when
    you run <i>./Build</i>.</p>
<p class="Pp">In the future, we hope to provide a more automated solution for
    this scenario; see <span class="Li">&quot;inc/latest.pm&quot;</span> in the
    Module::Build distribution for one indication of the direction we're
  moving.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
Ken Williams &lt;kwilliams@cpan.org&gt;
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT"><a class="permalink" href="#COPYRIGHT">COPYRIGHT</a></h1>
Copyright (c) 2001-2008 Ken Williams. All rights reserved.
<p class="Pp">This library is free software; you can redistribute it and/or
    modify it under the same terms as Perl itself.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<i>perl</i>(1), Module::Build(3), Module::Build::Authoring(3),
  Module::Build::API(3)
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2014-09-30</td>
    <td class="foot-os">perl v5.18.4</td>
  </tr>
</table>
</body>
</html>
