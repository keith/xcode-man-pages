<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>Moose::Manual::MooseX(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Moose::Manual::MooseX(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Moose::Manual::MooseX(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
Moose::Manual::MooseX - Recommended Moose extensions
</section>
<section class="Sh">
<h1 class="Sh" id="VERSION"><a class="permalink" href="#VERSION">VERSION</a></h1>
version 2.2012
</section>
<section class="Sh">
<h1 class="Sh" id="MooseX?"><a class="permalink" href="#MooseX?">MooseX?</a></h1>
It's easy to extend and change Moose, and this is part of what makes Moose so
  powerful. You can use the MOP API to do things your own way, add new features,
  and generally customize your Moose.
<p class="Pp">Writing your own extensions does require a good understanding of
    the meta-model. You can start learning about this with the
    Moose::Manual::MOP docs. There are also several extension recipes in the
    Moose::Cookbook.</p>
<p class="Pp">Explaining how to write extensions is beyond the scope of this
    manual. Fortunately, lots of people have already written extensions and put
    them on CPAN for you.</p>
<p class="Pp">This document covers a few of the ones we like best.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="MooseX::AttributeHelpers"><a class="permalink" href="#MooseX::AttributeHelpers">MooseX::AttributeHelpers</a></h1>
The functionality of this MooseX module has been moved into Moose core. See
  Moose::Meta::Attribute::Native.
</section>
<section class="Sh">
<h1 class="Sh" id="Moose::Autobox"><a class="permalink" href="#Moose::Autobox">Moose::Autobox</a></h1>
MooseX::AttributeHelpers, but turned inside out, Moose::Autobox provides methods
  on both arrays/hashes/etc. but also references to them, using Moose roles,
  allowing you do to things like:
<p class="Pp"><span class="Li"></span></p>
<pre>
  use Moose::Autobox;

  $somebody_elses_object-&gt;orders-&gt;push($order);
</pre>
<p class="Pp">Lexically scoped and not to everybody's taste, but very handy for
    sugaring up other people's APIs and your own code.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="MooseX::StrictConstructor"><a class="permalink" href="#MooseX::StrictConstructor">MooseX::StrictConstructor</a></h1>
By default, Moose lets you pass any old junk into a class's constructor. If you
  load MooseX::StrictConstructor, your class will throw an error if it sees
  something it doesn't recognize;
<p class="Pp"><span class="Li"></span></p>
<pre>
  package User;

  use Moose;
  use MooseX::StrictConstructor;

  has 'name';
  has 'email';

  User-&gt;new( name =&gt; 'Bob', emali =&gt; 'bob@example.com' );
</pre>
<p class="Pp">With MooseX::StrictConstructor, that typo (&quot;emali&quot;) will
    cause a runtime error. With plain old Moose, the &quot;emali&quot; attribute
    would be silently ignored.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="MooseX::Params::Validate"><a class="permalink" href="#MooseX::Params::Validate">MooseX::Params::Validate</a></h1>
We have high hopes for the future of MooseX::Method::Signatures and Moops.
  However, these modules, while used regularly in production by some of the more
  insane members of the community, are still marked alpha just in case backwards
  incompatible changes need to be made.
<p class="Pp">If you don't want to risk that, for now we recommend the decidedly
    more clunky (but also faster and simpler) MooseX::Params::Validate. This
    module lets you apply Moose types and coercions to any method arguments.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  package User;

  use Moose;
  use MooseX::Params::Validate;

  sub login {
      my $self = shift;
      my ($password)
          = validated_list( \@_, password =&gt; { isa =&gt; 'Str', required =&gt; 1 } );

      ...
  }
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="MooseX::Getopt"><a class="permalink" href="#MooseX::Getopt">MooseX::Getopt</a></h1>
This is a role which adds a <span class="Li">&quot;new_with_options&quot;</span>
  method to your class. This is a constructor that takes the command line
  options and uses them to populate attributes.
<p class="Pp">This makes writing a command-line application as a module
    trivially simple:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  package App::Foo;

  use Moose;
  with 'MooseX::Getopt';

  has 'input' =&gt; (
      is       =&gt; 'ro',
      isa      =&gt; 'Str',
      required =&gt; 1
  );

  has 'output' =&gt; (
      is       =&gt; 'ro',
      isa      =&gt; 'Str',
      required =&gt; 1
  );

  sub run { ... }
</pre>
<p class="Pp">Then in the script that gets run we have:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  use App::Foo;

  App::Foo-&gt;new_with_options-&gt;run;
</pre>
<p class="Pp">From the command line, someone can execute the script:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  foo@example&gt; foo --input /path/to/input --output /path/to/output
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="MooseX::Singleton"><a class="permalink" href="#MooseX::Singleton">MooseX::Singleton</a></h1>
To be honest, using a singleton is just a way to have a magic global variable in
  languages that don't actually have global variables.
<p class="Pp">In perl, you can just as easily use a global. However, if your
    colleagues are Java-infected, they might prefer a singleton. Also, if you
    have an existing class that <i>isn't</i> a singleton but should be, using
    MooseX::Singleton is the easiest way to convert it.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  package Config;

  use MooseX::Singleton; # instead of Moose

  has 'cache_dir' =&gt; ( ... );
</pre>
<p class="Pp">It's that simple.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="EXTENSIONS_TO_CONSIDER"><a class="permalink" href="#EXTENSIONS_TO_CONSIDER">EXTENSIONS
  TO CONSIDER</a></h1>
There are literally dozens of other extensions on CPAN. This is a list of
  extensions that you might find useful, but we're not quite ready to endorse
  just yet.
<section class="Ss">
<h2 class="Ss" id="MooseX::Declare"><a class="permalink" href="#MooseX::Declare">MooseX::Declare</a></h2>
MooseX::Declare is based on Devel::Declare, a giant bag of crack originally
  implemented by mst with the goal of upsetting the perl core developers so much
  by its very existence that they implemented proper keyword handling in the
  core.
<p class="Pp">As of perl5 version 14, this goal has been achieved, and modules
    such as Devel::CallParser, Function::Parameters, and Keyword::Simple provide
    mechanisms to mangle perl syntax that don't require hallucinogenic drugs to
    interpret the error messages they produce.</p>
<p class="Pp">If you want to use declarative syntax in new code, please for the
    love of kittens get yourself a recent perl and look at Moops instead.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="MooseX::Types"><a class="permalink" href="#MooseX::Types">MooseX::Types</a></h2>
This extension helps you build a type library for your application. It also lets
  you predeclare type names and use them as barewords.
<p class="Pp"><span class="Li"></span></p>
<pre>
  use MooseX::Types -declare =&gt; ['PositiveInt'];
  use MooseX::Types::Moose 'Int';

  subtype PositiveInt,
      as Int,
      where { $_ &gt; 0 },
      message { &quot;Int is not larger than 0&quot; };
</pre>
<p class="Pp">One nice feature is that those bareword names are actually
    namespaced in Moose's type registry, so multiple applications can use the
    same bareword names, even if the type definitions differ.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="MooseX::Types::Structured"><a class="permalink" href="#MooseX::Types::Structured">MooseX::Types::Structured</a></h2>
This extension builds on top of MooseX::Types to let you declare complex data
  structure types.
<p class="Pp"><span class="Li"></span></p>
<pre>
  use MooseX::Types -declare =&gt; [ qw( Name Color ) ];
  use MooseX::Types::Moose qw(Str Int);
  use MooseX::Types::Structured qw(Dict Tuple Optional);

  subtype Name
      =&gt; as Dict[ first =&gt; Str, middle =&gt; Optional[Str], last =&gt; Str ];

  subtype Color
      =&gt; as Tuple[ Int, Int, Int, Optional[Int] ];
</pre>
<p class="Pp">Of course, you could always use objects to represent these sorts
    of things too.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="MooseX::ClassAttribute"><a class="permalink" href="#MooseX::ClassAttribute">MooseX::ClassAttribute</a></h2>
This extension provides class attributes for Moose classes. The declared class
  attributes are introspectable just like regular Moose attributes.
<p class="Pp"><span class="Li"></span></p>
<pre>
  package User;

  use Moose;
  use MooseX::ClassAttribute;

  has 'name' =&gt; ( ... );

  class_has 'Cache' =&gt; ( ... );
</pre>
<p class="Pp">Note however that this class attribute does <i>not</i> inherit
    like a Class::Data::Inheritable or similar attribute - calling</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  $subclass-&gt;Cache($cache);
</pre>
<p class="Pp">will set it for the superclass as well. Additionally, class data
    is usually The Wrong Thing To Do in a strongly OO program since it makes
    testing a lot harder - consider carefully whether you'd be better off with
    an object that's passed around instead.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="MooseX::Daemonize"><a class="permalink" href="#MooseX::Daemonize">MooseX::Daemonize</a></h2>
This is a role that provides a number of methods useful for creating a daemon,
  including methods for starting and stopping, managing a PID file, and signal
  handling.
</section>
<section class="Ss">
<h2 class="Ss" id="MooseX::Role::Parameterized"><a class="permalink" href="#MooseX::Role::Parameterized">MooseX::Role::Parameterized</a></h2>
If you find yourself wanting a role that customizes itself for each consumer,
  this is the tool for you. With this module, you can create a role that accepts
  parameters and generates attributes, methods, etc. on a customized basis for
  each consumer.
</section>
<section class="Ss">
<h2 class="Ss" id="MooseX::POE"><a class="permalink" href="#MooseX::POE">MooseX::POE</a></h2>
This is a small wrapper that ties together a Moose class with
  <span class="Li">&quot;POE::Session&quot;</span>, and gives you an
  <span class="Li">&quot;event&quot;</span> sugar function to declare event
  handlers.
</section>
<section class="Ss">
<h2 class="Ss" id="MooseX::FollowPBP"><a class="permalink" href="#MooseX::FollowPBP">MooseX::FollowPBP</a></h2>
Automatically names all accessors <i>Perl Best Practices</i>-style,
  &quot;get_size&quot; and &quot;set_size&quot;.
</section>
<section class="Ss">
<h2 class="Ss" id="MooseX::SemiAffordanceAccessor"><a class="permalink" href="#MooseX::SemiAffordanceAccessor">MooseX::SemiAffordanceAccessor</a></h2>
Automatically names all accessors with an explicit set and implicit get,
  &quot;size&quot; and &quot;set_size&quot;.
</section>
<section class="Ss">
<h2 class="Ss" id="MooseX::NonMoose"><a class="permalink" href="#MooseX::NonMoose">MooseX::NonMoose</a></h2>
MooseX::NonMoose allows for easily subclassing non-Moose classes with Moose,
  taking care of the annoying details connected with doing this, such as setting
  up proper inheritance from Moose::Object and installing (and inlining, at
  make_immutable time) a constructor that makes sure things like BUILD methods
  are called.
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHORS"><a class="permalink" href="#AUTHORS">AUTHORS</a></h1>
<ul class="Bl-bullet">
  <li>Stevan Little &lt;stevan.little@iinteractive.com&gt;</li>
  <li>Dave Rolsky &lt;autarch@urth.org&gt;</li>
  <li>Jesse Luehrs &lt;doy@tozt.net&gt;</li>
  <li>Shawn M Moore &lt;code@sartak.org&gt;</li>
  <li>&#x05D9;&#x05D5;&#x05D1;&#x05DC; &#x05E7;&#x05D5;&#x05D2;'&#x05DE;&#x05DF;
      (Yuval Kogman) &lt;nothingmuch@woobling.org&gt;</li>
  <li>Karen Etheridge &lt;ether@cpan.org&gt;</li>
  <li>Florian Ragwitz &lt;rafl@debian.org&gt;</li>
  <li>Hans Dieter Pearcey &lt;hdp@weftsoar.net&gt;</li>
  <li>Chris Prather &lt;chris@prather.org&gt;</li>
  <li>Matt S Trout &lt;mst@shadowcat.co.uk&gt;</li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT_AND_LICENSE"><a class="permalink" href="#COPYRIGHT_AND_LICENSE">COPYRIGHT
  AND LICENSE</a></h1>
This software is copyright (c) 2006 by Infinity Interactive, Inc.
<p class="Pp">This is free software; you can redistribute it and/or modify it
    under the same terms as the Perl 5 programming language system itself.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2019-11-22</td>
    <td class="foot-os">perl v5.30.2</td>
  </tr>
</table>
</body>
</html>
