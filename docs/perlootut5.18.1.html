<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>PERLOOTUT(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">PERLOOTUT(1)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">PERLOOTUT(1)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
perlootut - Object-Oriented Programming in Perl Tutorial
</section>
<section class="Sh">
<h1 class="Sh" id="DATE"><a class="permalink" href="#DATE">DATE</a></h1>
This document was created in February, 2011, and the last major revision was in
  February, 2013.
<p class="Pp">If you are reading this in the future then it's possible that the
    state of the art has changed. We recommend you start by reading the
    perlootut document in the latest stable release of Perl, rather than this
    version.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
This document provides an introduction to object-oriented programming in Perl.
  It begins with a brief overview of the concepts behind object oriented design.
  Then it introduces several different OO systems from CPAN
  &lt;http://search.cpan.org&gt; which build on top of what Perl provides.
<p class="Pp">By default, Perl's built-in OO system is very minimal, leaving you
    to do most of the work. This minimalism made a lot of sense in 1994, but in
    the years since Perl 5.0 we've seen a number of common patterns emerge in
    Perl OO. Fortunately, Perl's flexibility has allowed a rich ecosystem of
    Perl OO systems to flourish.</p>
<p class="Pp">If you want to know how Perl OO works under the hood, the perlobj
    document explains the nitty gritty details.</p>
<p class="Pp">This document assumes that you already understand the basics of
    Perl syntax, variable types, operators, and subroutine calls. If you don't
    understand these concepts yet, please read perlintro first. You should also
    read the perlsyn, perlop, and perlsub documents.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="OBJECT-ORIENTED_FUNDAMENTALS"><a class="permalink" href="#OBJECT-ORIENTED_FUNDAMENTALS">OBJECT-ORIENTED
  FUNDAMENTALS</a></h1>
Most object systems share a number of common concepts. You've probably heard
  terms like &quot;class&quot;, &quot;object, &quot;method&quot;, and
  &quot;attribute&quot; before. Understanding the concepts will make it much
  easier to read and write object-oriented code. If you're already familiar with
  these terms, you should still skim this section, since it explains each
  concept in terms of Perl's OO implementation.
<p class="Pp">Perl's OO system is class-based. Class-based OO is fairly common.
    It's used by Java, C++, C#, Python, Ruby, and many other languages. There
    are other object orientation paradigms as well. JavaScript is the most
    popular language to use another paradigm. JavaScript's OO system is
    prototype-based.</p>
<section class="Ss">
<h2 class="Ss" id="Object"><a class="permalink" href="#Object">Object</a></h2>
An <b>object</b> is a data structure that bundles together data and subroutines
  which operate on that data. An object's data is called <b>attributes</b>, and
  its subroutines are called <b>methods</b>. An object can be thought of as a
  noun (a person, a web service, a computer).
<p class="Pp">An object represents a single discrete thing. For example, an
    object might represent a file. The attributes for a file object might
    include its path, content, and last modification time. If we created an
    object to represent <i>/etc/hostname</i> on a machine named
    &quot;foo.example.com&quot;, that object's path would be
    &quot;/etc/hostname&quot;, its content would be &quot;foo\n&quot;, and it's
    last modification time would be 1304974868 seconds since the beginning of
    the epoch.</p>
<p class="Pp">The methods associated with a file might include
    <span class="Li">&quot;rename()&quot;</span> and
    <span class="Li">&quot;write()&quot;</span>.</p>
<p class="Pp">In Perl most objects are hashes, but the OO systems we recommend
    keep you from having to worry about this. In practice, it's best to consider
    an object's internal data structure opaque.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Class"><a class="permalink" href="#Class">Class</a></h2>
A <b>class</b> defines the behavior of a category of objects. A class is a name
  for a category (like &quot;File&quot;), and a class also defines the behavior
  of objects in that category.
<p class="Pp">All objects belong to a specific class. For example, our
    <i>/etc/hostname</i> object belongs to the
    <span class="Li">&quot;File&quot;</span> class. When we want to create a
    specific object, we start with its class, and <b>construct</b> or
    <b>instantiate</b> an object. A specific object is often referred to as an
    <b>instance</b> of a class.</p>
<p class="Pp">In Perl, any package can be a class. The difference between a
    package which is a class and one which isn't is based on how the package is
    used. Here's our &quot;class declaration&quot; for the
    <span class="Li">&quot;File&quot;</span> class:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  package File;
</pre>
<p class="Pp">In Perl, there is no special keyword for constructing an object.
    However, most OO modules on CPAN use a method named
    <span class="Li">&quot;new()&quot;</span> to construct a new object:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  my $hostname = File-&gt;new(
      path          =&gt; '/etc/hostname',
      content       =&gt; &quot;foo\n&quot;,
      last_mod_time =&gt; 1304974868,
  );
</pre>
<p class="Pp">(Don't worry about that <span class="Li">&quot;-&gt;&quot;</span>
    operator, it will be explained later.)</p>
<p class="Pp"><i>Blessing</i></p>
<p class="Pp">As we said earlier, most Perl objects are hashes, but an object
    can be an instance of any Perl data type (scalar, array, etc.). Turning a
    plain data structure into an object is done by <b>blessing</b> that data
    structure using Perl's <span class="Li">&quot;bless&quot;</span>
  function.</p>
<p class="Pp">While we strongly suggest you don't build your objects from
    scratch, you should know the term <b>bless</b>. A <b>blessed</b> data
    structure (aka &quot;a referent&quot;) is an object. We sometimes say that
    an object has been &quot;blessed into a class&quot;.</p>
<p class="Pp">Once a referent has been blessed, the
    <span class="Li">&quot;blessed&quot;</span> function from the Scalar::Util
    core module can tell us its class name. This subroutine returns an object's
    class when passed an object, and false otherwise.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  use Scalar::Util 'blessed';

  print blessed($hash);      # undef
  print blessed($hostname);  # File
</pre>
<p class="Pp"><i>Constructor</i></p>
<p class="Pp">A <b>constructor</b> creates a new object. In Perl, a class's
    constructor is just another method, unlike some other languages, which
    provide syntax for constructors. Most Perl classes use
    <span class="Li">&quot;new&quot;</span> as the name for their
  constructor:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  my $file = File-&gt;new(...);
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Methods"><a class="permalink" href="#Methods">Methods</a></h2>
You already learned that a <b>method</b> is a subroutine that operates on an
  object. You can think of a method as the things that an object can <i>do</i>.
  If an object is a noun, then methods are its verbs (save, print, open).
<p class="Pp">In Perl, methods are simply subroutines that live in a class's
    package. Methods are always written to receive the object as their first
    argument:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  sub print_info {
      my $self = shift;

      print &quot;This file is at &quot;, $self-&gt;path, &quot;\n&quot;;
  }

  $file-&gt;print_info;
  # The file is at /etc/hostname
</pre>
<p class="Pp">What makes a method special is <i>how it's called</i>. The arrow
    operator (<span class="Li">&quot;-&gt;&quot;</span>) tells Perl that we are
    calling a method.</p>
<p class="Pp">When we make a method call, Perl arranges for the method's
    <b>invocant</b> to be passed as the first argument. <b>Invocant</b> is a
    fancy name for the thing on the left side of the arrow. The invocant can
    either be a class name or an object. We can also pass additional arguments
    to the method:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  sub print_info {
      my $self   = shift;
      my $prefix = shift // &quot;This file is at &quot;;

      print $prefix, &quot;, &quot;, $self-&gt;path, &quot;\n&quot;;
  }

  $file-&gt;print_info(&quot;The file is located at &quot;);
  # The file is located at /etc/hostname
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Attributes"><a class="permalink" href="#Attributes">Attributes</a></h2>
Each class can define its <b>attributes</b>. When we instantiate an object, we
  assign values to those attributes. For example, every
  <span class="Li">&quot;File&quot;</span> object has a path. Attributes are
  sometimes called <b>properties</b>.
<p class="Pp">Perl has no special syntax for attributes. Under the hood,
    attributes are often stored as keys in the object's underlying hash, but
    don't worry about this.</p>
<p class="Pp">We recommend that you only access attributes via <b>accessor</b>
    methods. These are methods that can get or set the value of each attribute.
    We saw this earlier in the <span class="Li">&quot;print_info()&quot;</span>
    example, which calls <span class="Li">&quot;$self-&gt;path&quot;</span>.</p>
<p class="Pp">You might also see the terms <b>getter</b> and <b>setter</b>.
    These are two types of accessors. A getter gets the attribute's value, while
    a setter sets it. Another term for a setter is <b>mutator</b></p>
<p class="Pp">Attributes are typically defined as read-only or read-write.
    Read-only attributes can only be set when the object is first created, while
    read-write attributes can be altered at any time.</p>
<p class="Pp">The value of an attribute may itself be another object. For
    example, instead of returning its last mod time as a number, the
    <span class="Li">&quot;File&quot;</span> class could return a DateTime
    object representing that value.</p>
<p class="Pp">It's possible to have a class that does not expose any publicly
    settable attributes. Not every class has attributes and methods.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Polymorphism"><a class="permalink" href="#Polymorphism">Polymorphism</a></h2>
<b>Polymorphism</b> is a fancy way of saying that objects from two different
  classes share an API. For example, we could have
  <span class="Li">&quot;File&quot;</span> and
  <span class="Li">&quot;WebPage&quot;</span> classes which both have a
  <span class="Li">&quot;print_content()&quot;</span> method. This method might
  produce different output for each class, but they share a common interface.
<p class="Pp">While the two classes may differ in many ways, when it comes to
    the <span class="Li">&quot;print_content()&quot;</span> method, they are the
    same. This means that we can try to call the
    <span class="Li">&quot;print_content()&quot;</span> method on an object of
    either class, and <b>we don't have to know what class the object belongs
    to!</b></p>
<p class="Pp">Polymorphism is one of the key concepts of object-oriented
  design.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Inheritance"><a class="permalink" href="#Inheritance">Inheritance</a></h2>
<b>Inheritance</b> lets you create a specialized version of an existing class.
  Inheritance lets the new class reuse the methods and attributes of another
  class.
<p class="Pp">For example, we could create an
    <span class="Li">&quot;File::MP3&quot;</span> class which <b>inherits</b>
    from <span class="Li">&quot;File&quot;</span>. An
    <span class="Li">&quot;File::MP3&quot;</span> <b>is-a</b> <i>more
    specific</i> type of <span class="Li">&quot;File&quot;</span>. All mp3 files
    are files, but not all files are mp3 files.</p>
<p class="Pp">We often refer to inheritance relationships as <b>parent-child</b>
    or <span class="Li">&quot;superclass/subclass&quot;</span> relationships.
    Sometimes we say that the child has an <b>is-a</b> relationship with its
    parent class.</p>
<p class="Pp"><span class="Li">&quot;File&quot;</span> is a <b>superclass</b> of
    <span class="Li">&quot;File::MP3&quot;</span>, and
    <span class="Li">&quot;File::MP3&quot;</span> is a <b>subclass</b> of
    <span class="Li">&quot;File&quot;</span>.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  package File::MP3;

  use parent 'File';
</pre>
<p class="Pp">The parent module is one of several ways that Perl lets you define
    inheritance relationships.</p>
<p class="Pp">Perl allows multiple inheritance, which means that a class can
    inherit from multiple parents. While this is possible, we strongly recommend
    against it. Generally, you can use <b>roles</b> to do everything you can do
    with multiple inheritance, but in a cleaner way.</p>
<p class="Pp">Note that there's nothing wrong with defining multiple subclasses
    of a given class. This is both common and safe. For example, we might define
    <span class="Li">&quot;File::MP3::FixedBitrate&quot;</span> and
    <span class="Li">&quot;File::MP3::VariableBitrate&quot;</span> classes to
    distinguish between different types of mp3 file.</p>
<p class="Pp"><i>Overriding methods and method resolution</i></p>
<p class="Pp">Inheritance allows two classes to share code. By default, every
    method in the parent class is also available in the child. The child can
    explicitly <b>override</b> a parent's method to provide its own
    implementation. For example, if we have an
    <span class="Li">&quot;File::MP3&quot;</span> object, it has the
    <span class="Li">&quot;print_info()&quot;</span> method from
    <span class="Li">&quot;File&quot;</span>:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  my $cage = File::MP3-&gt;new(
      path          =&gt; 'mp3s/My-Body-Is-a-Cage.mp3',
      content       =&gt; $mp3_data,
      last_mod_time =&gt; 1304974868,
      title         =&gt; 'My Body Is a Cage',
  );

  $cage-&gt;print_info;
  # The file is at mp3s/My-Body-Is-a-Cage.mp3
</pre>
<p class="Pp">If we wanted to include the mp3's title in the greeting, we could
    override the method:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  package File::MP3;

  use parent 'File';

  sub print_info {
      my $self = shift;

      print &quot;This file is at &quot;, $self-&gt;path, &quot;\n&quot;;
      print &quot;Its title is &quot;, $self-&gt;title, &quot;\n&quot;;
  }

  $cage-&gt;print_info;
  # The file is at mp3s/My-Body-Is-a-Cage.mp3
  # Its title is My Body Is a Cage
</pre>
<p class="Pp">The process of determining what method should be used is called
    <b>method resolution</b>. What Perl does is look at the object's class first
    (<span class="Li">&quot;File::MP3&quot;</span> in this case). If that class
    defines the method, then that class's version of the method is called. If
    not, Perl looks at each parent class in turn. For
    <span class="Li">&quot;File::MP3&quot;</span>, its only parent is
    <span class="Li">&quot;File&quot;</span>. If
    <span class="Li">&quot;File::MP3&quot;</span> does not define the method,
    but <span class="Li">&quot;File&quot;</span> does, then Perl calls the
    method in <span class="Li">&quot;File&quot;</span>.</p>
<p class="Pp">If <span class="Li">&quot;File&quot;</span> inherited from
    <span class="Li">&quot;DataSource&quot;</span>, which inherited from
    <span class="Li">&quot;Thing&quot;</span>, then Perl would keep looking
    &quot;up the chain&quot; if necessary.</p>
<p class="Pp">It is possible to explicitly call a parent method from a
  child:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  package File::MP3;

  use parent 'File';

  sub print_info {
      my $self = shift;

      $self-&gt;SUPER::print_info();
      print &quot;Its title is &quot;, $self-&gt;title, &quot;\n&quot;;
  }
</pre>
<p class="Pp">The <span class="Li">&quot;SUPER::&quot;</span> bit tells Perl to
    look for the <span class="Li">&quot;print_info()&quot;</span> in the
    <span class="Li">&quot;File::MP3&quot;</span> class's inheritance chain.
    When it finds the parent class that implements this method, the method is
    called.</p>
<p class="Pp">We mentioned multiple inheritance earlier. The main problem with
    multiple inheritance is that it greatly complicates method resolution. See
    perlobj for more details.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Encapsulation"><a class="permalink" href="#Encapsulation">Encapsulation</a></h2>
<b>Encapsulation</b> is the idea that an object is opaque. When another
  developer uses your class, they don't need to know <i>how</i> it is
  implemented, they just need to know <i>what</i> it does.
<p class="Pp">Encapsulation is important for several reasons. First, it allows
    you to separate the public API from the private implementation. This means
    you can change that implementation without breaking the API.</p>
<p class="Pp">Second, when classes are well encapsulated, they become easier to
    subclass. Ideally, a subclass uses the same APIs to access object data that
    its parent class uses. In reality, subclassing sometimes involves violating
    encapsulation, but a good API can minimize the need to do this.</p>
<p class="Pp">We mentioned earlier that most Perl objects are implemented as
    hashes under the hood. The principle of encapsulation tells us that we
    should not rely on this. Instead, we should use accessor methods to access
    the data in that hash. The object systems that we recommend below all
    automate the generation of accessor methods. If you use one of them, you
    should never have to access the object as a hash directly.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Composition"><a class="permalink" href="#Composition">Composition</a></h2>
In object-oriented code, we often find that one object references another
  object. This is called <b>composition</b>, or a <b>has-a</b> relationship.
<p class="Pp">Earlier, we mentioned that the
    <span class="Li">&quot;File&quot;</span> class's
    <span class="Li">&quot;last_mod_time&quot;</span> accessor could return a
    DateTime object. This is a perfect example of composition. We could go even
    further, and make the <span class="Li">&quot;path&quot;</span> and
    <span class="Li">&quot;content&quot;</span> accessors return objects as
    well. The <span class="Li">&quot;File&quot;</span> class would then be
    <b>composed</b> of several other objects.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Roles"><a class="permalink" href="#Roles">Roles</a></h2>
<b>Roles</b> are something that a class <i>does</i>, rather than something that
  it <i>is</i>. Roles are relatively new to Perl, but have become rather
  popular. Roles are <b>applied</b> to classes. Sometimes we say that classes
  <b>consume</b> roles.
<p class="Pp">Roles are an alternative to inheritance for providing
    polymorphism. Let's assume we have two classes,
    <span class="Li">&quot;Radio&quot;</span> and
    <span class="Li">&quot;Computer&quot;</span>. Both of these things have
    on/off switches. We want to model that in our class definitions.</p>
<p class="Pp">We could have both classes inherit from a common parent, like
    <span class="Li">&quot;Machine&quot;</span>, but not all machines have
    on/off switches. We could create a parent class called
    <span class="Li">&quot;HasOnOffSwitch&quot;</span>, but that is very
    artificial. Radios and computers are not specializations of this parent.
    This parent is really a rather ridiculous creation.</p>
<p class="Pp">This is where roles come in. It makes a lot of sense to create a
    <span class="Li">&quot;HasOnOffSwitch&quot;</span> role and apply it to both
    classes. This role would define a known API like providing
    <span class="Li">&quot;turn_on()&quot;</span> and
    <span class="Li">&quot;turn_off()&quot;</span> methods.</p>
<p class="Pp">Perl does not have any built-in way to express roles. In the past,
    people just bit the bullet and used multiple inheritance. Nowadays, there
    are several good choices on CPAN for using roles.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="When_to_Use__s-1OO_s0"><a class="permalink" href="#When_to_Use__s-1OO_s0">When
  to Use OO</a></h2>
Object Orientation is not the best solution to every problem. In <i>Perl</i>
  <i>Best Practices</i> (copyright 2004, Published by O'Reilly Media, Inc.),
  Damian Conway provides a list of criteria to use when deciding if OO is the
  right fit for your problem:
<ul class="Bl-bullet">
  <li>The system being designed is large, or is likely to become large.</li>
  <li>The data can be aggregated into obvious structures, especially if there's
      a large amount of data in each aggregate.</li>
  <li>The various types of data aggregate form a natural hierarchy that
      facilitates the use of inheritance and polymorphism.</li>
  <li>You have a piece of data on which many different operations are
    applied.</li>
  <li>You need to perform the same general operations on related types of data,
      but with slight variations depending on the specific type of data the
      operations are applied to.</li>
  <li>It's likely you'll have to add new data types later.</li>
  <li>The typical interactions between pieces of data are best represented by
      operators.</li>
  <li>The implementation of individual components of the system is likely to
      change over time.</li>
  <li>The system design is already object-oriented.</li>
  <li>Large numbers of other programmers will be using your code modules.</li>
</ul>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="PERL_OO_SYSTEMS"><a class="permalink" href="#PERL_OO_SYSTEMS">PERL
  OO SYSTEMS</a></h1>
As we mentioned before, Perl's built-in OO system is very minimal, but also
  quite flexible. Over the years, many people have developed systems which build
  on top of Perl's built-in system to provide more features and convenience.
<p class="Pp">We strongly recommend that you use one of these systems. Even the
    most minimal of them eliminates a lot of repetitive boilerplate. There's
    really no good reason to write your classes from scratch in Perl.</p>
<p class="Pp">If you are interested in the guts underlying these systems, check
    out perlobj.</p>
<section class="Ss">
<h2 class="Ss" id="Moose"><a class="permalink" href="#Moose">Moose</a></h2>
Moose bills itself as a &quot;postmodern object system for Perl 5&quot;. Don't
  be scared, the &quot;postmodern&quot; label is a callback to Larry's
  description of Perl as &quot;the first postmodern computer language&quot;.
<p class="Pp"><span class="Li">&quot;Moose&quot;</span> provides a complete,
    modern OO system. Its biggest influence is the Common Lisp Object System,
    but it also borrows ideas from Smalltalk and several other languages.
    <span class="Li">&quot;Moose&quot;</span> was created by Stevan Little, and
    draws heavily from his work on the Perl 6 OO design.</p>
<p class="Pp">Here is our <span class="Li">&quot;File&quot;</span> class using
    <span class="Li">&quot;Moose&quot;</span>:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  package File;
  use Moose;

  has path          =&gt; ( is =&gt; 'ro' );
  has content       =&gt; ( is =&gt; 'ro' );
  has last_mod_time =&gt; ( is =&gt; 'ro' );

  sub print_info {
      my $self = shift;

      print &quot;This file is at &quot;, $self-&gt;path, &quot;\n&quot;;
  }
</pre>
<p class="Pp"><span class="Li">&quot;Moose&quot;</span> provides a number of
    features:</p>
<ul class="Bl-bullet">
  <li>Declarative sugar
    <p class="Pp"><span class="Li">&quot;Moose&quot;</span> provides a layer of
        declarative &quot;sugar&quot; for defining classes. That sugar is just a
        set of exported functions that make declaring how your class works
        simpler and more palatable. This lets you describe <i>what</i> your
        class is, rather than having to tell Perl <i>how</i> to implement your
        class.</p>
    <p class="Pp">The <span class="Li">&quot;has()&quot;</span> subroutine
        declares an attribute, and <span class="Li">&quot;Moose&quot;</span>
        automatically creates accessors for these attributes. It also takes care
        of creating a <span class="Li">&quot;new()&quot;</span> method for you.
        This constructor knows about the attributes you declared, so you can set
        them when creating a new <span class="Li">&quot;File&quot;</span>.</p>
  </li>
  <li>Roles built-in
    <p class="Pp"><span class="Li">&quot;Moose&quot;</span> lets you define
        roles the same way you define classes:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  package HasOnOfSwitch;
  use Moose::Role;

  has is_on =&gt; (
      is  =&gt; 'rw',
      isa =&gt; 'Bool',
  );

  sub turn_on {
      my $self = shift;
      $self-&gt;is_on(1);
  }

  sub turn_off {
      my $self = shift;
      $self-&gt;is_on(0);
  }
    </pre>
  </li>
  <li>A miniature type system
    <p class="Pp">In the example above, you can see that we passed
        <span class="Li">&quot;isa =&gt; 'Bool'&quot;</span> to
        <span class="Li">&quot;has()&quot;</span> when creating our
        <span class="Li">&quot;is_on&quot;</span> attribute. This tells
        <span class="Li">&quot;Moose&quot;</span> that this attribute must be a
        boolean value. If we try to set it to an invalid value, our code will
        throw an error.</p>
  </li>
  <li>Full introspection and manipulation
    <p class="Pp">Perl's built-in introspection features are fairly minimal.
        <span class="Li">&quot;Moose&quot;</span> builds on top of them and
        creates a full introspection layer for your classes. This lets you ask
        questions like &quot;what methods does the File class implement?&quot;
        It also lets you modify your classes programmatically.</p>
  </li>
  <li>Self-hosted and extensible
    <p class="Pp"><span class="Li">&quot;Moose&quot;</span> describes itself
        using its own introspection API. Besides being a cool trick, this means
        that you can extend <span class="Li">&quot;Moose&quot;</span> using
        <span class="Li">&quot;Moose&quot;</span> itself.</p>
  </li>
  <li>Rich ecosystem
    <p class="Pp">There is a rich ecosystem of
        <span class="Li">&quot;Moose&quot;</span> extensions on CPAN under the
        MooseX &lt;http://search.cpan.org/search?query=MooseX&amp;mode=dist&gt;
        namespace. In addition, many modules on CPAN already use
        <span class="Li">&quot;Moose&quot;</span>, providing you with lots of
        examples to learn from.</p>
  </li>
  <li>Many more features
    <p class="Pp"><span class="Li">&quot;Moose&quot;</span> is a very powerful
        tool, and we can't cover all of its features here. We encourage you to
        learn more by reading the <span class="Li">&quot;Moose&quot;</span>
        documentation, starting with Moose::Manual
        &lt;http://search.cpan.org/perldoc?Moose::Manual&gt;.</p>
  </li>
</ul>
<p class="Pp">Of course, <span class="Li">&quot;Moose&quot;</span> isn't
    perfect.</p>
<p class="Pp"><span class="Li">&quot;Moose&quot;</span> can make your code
    slower to load. <span class="Li">&quot;Moose&quot;</span> itself is not
    small, and it does a <i>lot</i> of code generation when you define your
    class. This code generation means that your runtime code is as fast as it
    can be, but you pay for this when your modules are first loaded.</p>
<p class="Pp">This load time hit can be a problem when startup speed is
    important, such as with a command-line script or a &quot;plain vanilla&quot;
    CGI script that must be loaded each time it is executed.</p>
<p class="Pp">Before you panic, know that many people do use
    <span class="Li">&quot;Moose&quot;</span> for command-line tools and other
    startup-sensitive code. We encourage you to try
    <span class="Li">&quot;Moose&quot;</span> out first before worrying about
    startup speed.</p>
<p class="Pp"><span class="Li">&quot;Moose&quot;</span> also has several
    dependencies on other modules. Most of these are small stand-alone modules,
    a number of which have been spun off from
    <span class="Li">&quot;Moose&quot;</span>.
    <span class="Li">&quot;Moose&quot;</span> itself, and some of its
    dependencies, require a compiler. If you need to install your software on a
    system without a compiler, or if having <i>any</i> dependencies is a
    problem, then <span class="Li">&quot;Moose&quot;</span> may not be right for
    you.</p>
<p class="Pp"><i>Moo</i></p>
<p class="Pp">If you try <span class="Li">&quot;Moose&quot;</span> and find that
    one of these issues is preventing you from using
    <span class="Li">&quot;Moose&quot;</span>, we encourage you to consider Moo
    next. <span class="Li">&quot;Moo&quot;</span> implements a subset of
    <span class="Li">&quot;Moose&quot;</span>'s functionality in a simpler
    package. For most features that it does implement, the end-user API is
    <i>identical</i> to <span class="Li">&quot;Moose&quot;</span>, meaning you
    can switch from <span class="Li">&quot;Moo&quot;</span> to
    <span class="Li">&quot;Moose&quot;</span> quite easily.</p>
<p class="Pp"><span class="Li">&quot;Moo&quot;</span> does not implement most of
    <span class="Li">&quot;Moose&quot;</span>'s introspection API, so it's often
    faster when loading your modules. Additionally, none of its dependencies
    require XS, so it can be installed on machines without a compiler.</p>
<p class="Pp">One of <span class="Li">&quot;Moo&quot;</span>'s most compelling
    features is its interoperability with
    <span class="Li">&quot;Moose&quot;</span>. When someone tries to use
    <span class="Li">&quot;Moose&quot;</span>'s introspection API on a
    <span class="Li">&quot;Moo&quot;</span> class or role, it is transparently
    inflated into a <span class="Li">&quot;Moose&quot;</span> class or role.
    This makes it easier to incorporate
    <span class="Li">&quot;Moo&quot;</span>-using code into a
    <span class="Li">&quot;Moose&quot;</span> code base and vice versa.</p>
<p class="Pp">For example, a <span class="Li">&quot;Moose&quot;</span> class can
    subclass a <span class="Li">&quot;Moo&quot;</span> class using
    <span class="Li">&quot;extends&quot;</span> or consume a
    <span class="Li">&quot;Moo&quot;</span> role using
    <span class="Li">&quot;with&quot;</span>.</p>
<p class="Pp">The <span class="Li">&quot;Moose&quot;</span> authors hope that
    one day <span class="Li">&quot;Moo&quot;</span> can be made obsolete by
    improving <span class="Li">&quot;Moose&quot;</span> enough, but for now it
    provides a worthwhile alternative to
    <span class="Li">&quot;Moose&quot;</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Class::Accessor"><a class="permalink" href="#Class::Accessor">Class::Accessor</a></h2>
Class::Accessor is the polar opposite of
  <span class="Li">&quot;Moose&quot;</span>. It provides very few features, nor
  is it self-hosting.
<p class="Pp">It is, however, very simple, pure Perl, and it has no non-core
    dependencies. It also provides a &quot;Moose-like&quot; API on demand for
    the features it supports.</p>
<p class="Pp">Even though it doesn't do much, it is still preferable to writing
    your own classes from scratch.</p>
<p class="Pp">Here's our <span class="Li">&quot;File&quot;</span> class with
    <span class="Li">&quot;Class::Accessor&quot;</span>:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  package File;
  use Class::Accessor 'antlers';

  has path          =&gt; ( is =&gt; 'ro' );
  has content       =&gt; ( is =&gt; 'ro' );
  has last_mod_time =&gt; ( is =&gt; 'ro' );

  sub print_info {
      my $self = shift;

      print &quot;This file is at &quot;, $self-&gt;path, &quot;\n&quot;;
  }
</pre>
<p class="Pp">The <span class="Li">&quot;antlers&quot;</span> import flag tells
    <span class="Li">&quot;Class::Accessor&quot;</span> that you want to define
    your attributes using <span class="Li">&quot;Moose&quot;</span>-like syntax.
    The only parameter that you can pass to
    <span class="Li">&quot;has&quot;</span> is
    <span class="Li">&quot;is&quot;</span>. We recommend that you use this
    Moose-like syntax if you choose
    <span class="Li">&quot;Class::Accessor&quot;</span> since it means you will
    have a smoother upgrade path if you later decide to move to
    <span class="Li">&quot;Moose&quot;</span>.</p>
<p class="Pp">Like <span class="Li">&quot;Moose&quot;</span>,
    <span class="Li">&quot;Class::Accessor&quot;</span> generates accessor
    methods and a constructor for your class.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Object::Tiny"><a class="permalink" href="#Object::Tiny">Object::Tiny</a></h2>
Finally, we have Object::Tiny. This module truly lives up to its name. It has an
  incredibly minimal API and absolutely no dependencies (core or not). Still, we
  think it's a lot easier to use than writing your own OO code from scratch.
<p class="Pp">Here's our <span class="Li">&quot;File&quot;</span> class once
    more:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  package File;
  use Object::Tiny qw( path content last_mod_time );

  sub print_info {
      my $self = shift;

      print &quot;This file is at &quot;, $self-&gt;path, &quot;\n&quot;;
  }
</pre>
<p class="Pp">That's it!</p>
<p class="Pp">With <span class="Li">&quot;Object::Tiny&quot;</span>, all
    accessors are read-only. It generates a constructor for you, as well as the
    accessors you define.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Role::Tiny"><a class="permalink" href="#Role::Tiny">Role::Tiny</a></h2>
As we mentioned before, roles provide an alternative to inheritance, but Perl
  does not have any built-in role support. If you choose to use Moose, it comes
  with a full-fledged role implementation. However, if you use one of our other
  recommended OO modules, you can still use roles with Role::Tiny
<p class="Pp"><span class="Li">&quot;Role::Tiny&quot;</span> provides some of
    the same features as Moose's role system, but in a much smaller package.
    Most notably, it doesn't support any sort of attribute declaration, so you
    have to do that by hand. Still, it's useful, and works well with
    <span class="Li">&quot;Class::Accessor&quot;</span> and
    <span class="Li">&quot;Object::Tiny&quot;</span></p>
</section>
<section class="Ss">
<h2 class="Ss" id="_s-1OO_s0_System_Summary"><a class="permalink" href="#_s-1OO_s0_System_Summary">OO
  System Summary</a></h2>
Here's a brief recap of the options we covered:
<ul class="Bl-bullet">
  <li>Moose
    <p class="Pp"><span class="Li">&quot;Moose&quot;</span> is the maximal
        option. It has a lot of features, a big ecosystem, and a thriving user
        base. We also covered Moo briefly.
        <span class="Li">&quot;Moo&quot;</span> is
        <span class="Li">&quot;Moose&quot;</span> lite, and a reasonable
        alternative when Moose doesn't work for your application.</p>
  </li>
  <li>Class::Accessor
    <p class="Pp"><span class="Li">&quot;Class::Accessor&quot;</span> does a lot
        less than <span class="Li">&quot;Moose&quot;</span>, and is a nice
        alternative if you find <span class="Li">&quot;Moose&quot;</span>
        overwhelming. It's been around a long time and is well battle-tested. It
        also has a minimal <span class="Li">&quot;Moose&quot;</span>
        compatibility mode which makes moving from
        <span class="Li">&quot;Class::Accessor&quot;</span> to
        <span class="Li">&quot;Moose&quot;</span> easy.</p>
  </li>
  <li>Object::Tiny
    <p class="Pp"><span class="Li">&quot;Object::Tiny&quot;</span> is the
        absolute minimal option. It has no dependencies, and almost no syntax to
        learn. It's a good option for a super minimal environment and for
        throwing something together quickly without having to worry about
        details.</p>
  </li>
  <li>Role::Tiny
    <p class="Pp">Use <span class="Li">&quot;Role::Tiny&quot;</span> with
        <span class="Li">&quot;Class::Accessor&quot;</span> or
        <span class="Li">&quot;Object::Tiny&quot;</span> if you find yourself
        considering multiple inheritance. If you go with
        <span class="Li">&quot;Moose&quot;</span>, it comes with its own role
        implementation.</p>
  </li>
</ul>
</section>
<section class="Ss">
<h2 class="Ss" id="Other__s-1OO_s0_Systems"><a class="permalink" href="#Other__s-1OO_s0_Systems">Other
  OO Systems</a></h2>
There are literally dozens of other OO-related modules on CPAN besides those
  covered here, and you're likely to run across one or more of them if you work
  with other people's code.
<p class="Pp">In addition, plenty of code in the wild does all of its OO
    &quot;by hand&quot;, using just the Perl built-in OO features. If you need
    to maintain such code, you should read perlobj to understand exactly how
    Perl's built-in OO works.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="CONCLUSION"><a class="permalink" href="#CONCLUSION">CONCLUSION</a></h1>
As we said before, Perl's minimal OO system has led to a profusion of OO systems
  on CPAN. While you can still drop down to the bare metal and write your
  classes by hand, there's really no reason to do that with modern Perl.
<p class="Pp">For small systems, Object::Tiny and Class::Accessor both provide
    minimal object systems that take care of basic boilerplate for you.</p>
<p class="Pp">For bigger projects, Moose provides a rich set of features that
    will let you focus on implementing your business logic.</p>
<p class="Pp">We encourage you to play with and evaluate Moose, Class::Accessor,
    and Object::Tiny to see which OO system is right for you.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2014-09-30</td>
    <td class="foot-os">perl v5.18.4</td>
  </tr>
</table>
</body>
</html>
