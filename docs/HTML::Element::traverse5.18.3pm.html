<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>HTML::Element::traverse(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">HTML::Element::traverse(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">HTML::Element::traverse(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
HTML::Element::traverse - discussion of HTML::Element's traverse method
</section>
<section class="Sh">
<h1 class="Sh" id="VERSION"><a class="permalink" href="#VERSION">VERSION</a></h1>
This document describes version 5.07 of HTML::Element::traverse, released August
  31, 2017 as part of HTML-Tree.
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<span class="Li"></span>
<pre>
  # $element-&gt;traverse is unnecessary and obscure.
  #   Don't use it in new code.
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<span class="Li">&quot;HTML::Element&quot;</span> provides a method
  <span class="Li">&quot;traverse&quot;</span> that traverses the tree and calls
  user-specified callbacks for each node, in pre- or post-order. However, use of
  the method is quite superfluous: if you want to recursively visit every node
  in the tree, it's almost always simpler to write a subroutine does just that,
  than it is to bundle up the pre- and/or post-order code in callbacks for the
  <span class="Li">&quot;traverse&quot;</span> method.
</section>
<section class="Sh">
<h1 class="Sh" id="EXAMPLES"><a class="permalink" href="#EXAMPLES">EXAMPLES</a></h1>
Suppose you want to traverse at/under a node <span class="Li">$tree</span> and
  give elements an 'id' attribute unless they already have one.
<p class="Pp">You can use the <span class="Li">&quot;traverse&quot;</span>
    method:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  {
    my $counter = 'x0000';
    $start_node-&gt;traverse(
      [ # Callbacks;
        # pre-order callback:
        sub {
          my $x = $_[0];
          $x-&gt;attr('id', $counter++) unless defined $x-&gt;attr('id');
          return HTML::Element::OK; # keep traversing
        },
        # post-order callback:
        undef
      ],
      1, # don't call the callbacks for text nodes
    );
  }
</pre>
<p class="Pp">or you can just be simple and clear (and not have to understand
    the calling format for <span class="Li">&quot;traverse&quot;</span>) by
    writing a sub that traverses the tree by just calling itself:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  {
    my $counter = 'x0000';
    sub give_id {
      my $x = $_[0];
      $x-&gt;attr('id', $counter++) unless defined $x-&gt;attr('id');
      foreach my $c ($x-&gt;content_list) {
        give_id($c) if ref $c; # ignore text nodes
      }
    };
    give_id($start_node);
  }
</pre>
<p class="Pp">See, isn't that nice and clear?</p>
<p class="Pp">But, if you really need to know:</p>
</section>
<section class="Sh">
<h1 class="Sh" id="THE_TRAVERSE_METHOD"><a class="permalink" href="#THE_TRAVERSE_METHOD">THE
  TRAVERSE METHOD</a></h1>
The <span class="Li">&quot;traverse()&quot;</span> method is a general
  object-method for traversing a tree or subtree and calling user-specified
  callbacks. It accepts the following syntaxes:
<dl class="Bl-tag">
  <dt>$h-&gt;traverse(\&amp;callback)</dt>
  <dd></dd>
  <dt>or $h-&gt;traverse(\&amp;callback, $ignore_text)</dt>
  <dd></dd>
  <dt>or $h-&gt;traverse( [\&amp;pre_callback,\&amp;post_callback] ,
    $ignore_text)</dt>
  <dd></dd>
</dl>
<p class="Pp">These all mean to traverse the element and all of its children.
    That is, this method starts at node <span class="Li">$h</span>,
    &quot;pre-order visits&quot; <span class="Li">$h</span>, traverses its
    children, and then will &quot;post-order visit&quot;
    <span class="Li">$h</span>. &quot;Visiting&quot; means that the callback
    routine is called, with these arguments:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    $_[0] : the node (element or text segment),
    $_[1] : a startflag, and
    $_[2] : the depth
</pre>
<p class="Pp">If the <span class="Li">$ignore_text</span> parameter is given and
    true, then the pre-order call <i>will not</i> be happen for text
  content.</p>
<p class="Pp">The startflag is 1 when we enter a node (i.e., in pre-order calls)
    and 0 when we leave the node (in post-order calls).</p>
<p class="Pp">Note, however, that post-order calls don't happen for nodes that
    are text segments or are elements that are prototypically empty (like
    &quot;br&quot;, &quot;hr&quot;, etc.).</p>
<p class="Pp">If we visit text nodes (i.e., unless
    <span class="Li">$ignore_text</span> is given and true), then when text
    nodes are visited, we will also pass two extra arguments to the
  callback:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    $_[3] : the element that's the parent
             of this text node
    $_[4] : the index of this text node
             in its parent's content list
</pre>
<p class="Pp">Note that you can specify that the pre-order routine can be a
    different routine from the post-order one:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    $h-&gt;traverse( [\&amp;pre_callback,\&amp;post_callback], ...);
</pre>
<p class="Pp">You can also specify that no post-order calls are to be made, by
    providing a false value as the post-order routine:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    $h-&gt;traverse([ \&amp;pre_callback,0 ], ...);
</pre>
<p class="Pp">And similarly for suppressing pre-order callbacks:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    $h-&gt;traverse([ 0,\&amp;post_callback ], ...);
</pre>
<p class="Pp">Note that these two syntaxes specify the same operation:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    $h-&gt;traverse([\&amp;foo,\&amp;foo], ...);
    $h-&gt;traverse( \&amp;foo       , ...);
</pre>
<p class="Pp">The return values from calls to your pre- or post-order routines
    are significant, and are used to control recursion into the tree.</p>
<p class="Pp">These are the values you can return, listed in descending order of
    my estimation of their usefulness:</p>
<dl class="Bl-tag">
  <dt>HTML::Element::OK, 1, or any other true value</dt>
  <dd>...to keep on traversing.
    <p class="Pp">Note that
        <span class="Li">&quot;HTML::Element::OK&quot;</span> et al are
        constants. So if you're running under <span class="Li">&quot;use
        strict&quot;</span> (as I hope you are), and you say:
        <span class="Li">&quot;return HTML::Element::PRUEN&quot;</span> the
        compiler will flag this as an error (an unallowable bareword,
        specifically), whereas if you spell PRUNE correctly, the compiler will
        not complain.</p>
  </dd>
  <dt>undef, 0, '0', '', or HTML::Element::PRUNE</dt>
  <dd>...to block traversing under the current element's content. (This is
      ignored if received from a post-order callback, since by then the
      recursion has already happened.) If this is returned by a pre-order
      callback, no post-order callback for the current node will happen. (Recall
      that if your callback exits with just
      <span class="Li">&quot;return;&quot;</span>, it is returning undef -- at
      least in scalar context, and <span class="Li">&quot;traverse&quot;</span>
      always calls your callbacks in scalar context.)</dd>
  <dt>HTML::Element::ABORT</dt>
  <dd>...to abort the whole traversal immediately. This is often useful when
      you're looking for just the first node in the tree that meets some
      criterion of yours.</dd>
  <dt>HTML::Element::PRUNE_UP</dt>
  <dd>...to abort continued traversal into this node and its parent node. No
      post-order callback for the current or parent node will happen.</dd>
  <dt>HTML::Element::PRUNE_SOFTLY</dt>
  <dd>Like PRUNE, except that the post-order call for the current node is not
      blocked.</dd>
</dl>
<p class="Pp">Almost every task to do with extracting information from a tree
    can be expressed in terms of traverse operations (usually in only one pass,
    and usually paying attention to only pre-order, or to only post-order), or
    operations based on traversing. (In fact, many of the other methods in this
    class are basically calls to <i>traverse()</i> with particular
  arguments.)</p>
<p class="Pp">The source code for HTML::Element and HTML::TreeBuilder contain
    several examples of the use of the &quot;traverse&quot; method to gather
    information about the content of trees and subtrees.</p>
<p class="Pp">(Note: you should not change the structure of a tree <i>while</i>
    you are traversing it.)</p>
<p class="Pp">[End of documentation for the
    <span class="Li">&quot;traverse()&quot;</span> method]</p>
<section class="Ss">
<h2 class="Ss" id="Traversing_with_Recursive_Anonymous_Routines"><a class="permalink" href="#Traversing_with_Recursive_Anonymous_Routines">Traversing
  with Recursive Anonymous Routines</a></h2>
Now, if you've been reading <i>Structure and Interpretation of Computer
  Programs</i> too much, maybe you even want a recursive lambda. Go ahead:
<p class="Pp"><span class="Li"></span></p>
<pre>
  {
    my $counter = 'x0000';
    my $give_id;
    $give_id = sub {
      my $x = $_[0];
      $x-&gt;attr('id', $counter++) unless defined $x-&gt;attr('id');
      foreach my $c ($x-&gt;content_list) {
        $give_id-&gt;($c) if ref $c; # ignore text nodes
      }
    };
    $give_id-&gt;($start_node);
    undef $give_id;
  }
</pre>
<p class="Pp">It's a bit nutty, and it's <i>still</i> more concise than a call
    to the <span class="Li">&quot;traverse&quot;</span> method!</p>
<p class="Pp">It is left as an exercise to the reader to figure out how to do
    the same thing without using a <span class="Li">$give_id</span> symbol at
    all.</p>
<p class="Pp">It is also left as an exercise to the reader to figure out why I
    undefine <span class="Li">$give_id</span>, above; and why I could achieved
    the same effect with any of:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    $give_id = 'I like pie!';
   # or...
    $give_id = [];
   # or even;
    $give_id = sub { print &quot;Mmmm pie!\n&quot; };
</pre>
<p class="Pp">But not:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    $give_id = sub { print &quot;I'm $give_id and I like pie!\n&quot; };
   # nor...
    $give_id = \$give_id;
   # nor...
    $give_id = { 'pie' =&gt; \$give_id, 'mode' =&gt; 'a la' };
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Doing_Recursive_Things_Iteratively"><a class="permalink" href="#Doing_Recursive_Things_Iteratively">Doing
  Recursive Things Iteratively</a></h2>
Note that you may at times see an iterative implementation of pre-order
  traversal, like so:
<p class="Pp"><span class="Li"></span></p>
<pre>
   {
     my @to_do = ($tree); # start-node
     while(@to_do) {
       my $this = shift @to_do;

       # &quot;Visit&quot; the node:
       $this-&gt;attr('id', $counter++)
        unless defined $this-&gt;attr('id');

       unshift @to_do, grep ref $_, $this-&gt;content_list;
        # Put children on the stack -- they'll be visited next
     }
   }
</pre>
<p class="Pp">This can <i>under certain circumstances</i> be more efficient than
    just a normal recursive routine, but at the cost of being rather obscure. It
    gains efficiency by avoiding the overhead of function-calling, but since
    there are several method dispatches however you do it (to
    <span class="Li">&quot;attr&quot;</span> and
    <span class="Li">&quot;content_list&quot;</span>), the overhead for a simple
    function call is insignificant.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Pruning_and_Whatnot"><a class="permalink" href="#Pruning_and_Whatnot">Pruning
  and Whatnot</a></h2>
The <span class="Li">&quot;traverse&quot;</span> method does have the fairly
  neat features of the <span class="Li">&quot;ABORT&quot;</span>,
  <span class="Li">&quot;PRUNE_UP&quot;</span> and
  <span class="Li">&quot;PRUNE_SOFTLY&quot;</span> signals. None of these can be
  implemented <i>totally</i> straightforwardly with recursive routines, but it
  is quite possible. <span class="Li">&quot;ABORT&quot;</span>-like behavior can
  be implemented either with using non-local returning with
  <span class="Li">&quot;eval&quot;</span>/<span class="Li">&quot;die&quot;</span>:
<p class="Pp"><span class="Li"></span></p>
<pre>
  my $died_on; # if you need to know where...
  sub thing {
    ... visits $_[0]...
    ... maybe set $died_on to $_[0] and die &quot;ABORT_TRAV&quot; ...
    ... else call thing($child) for each child...
    ...any post-order visiting $_[0]...
  }
  eval { thing($node) };
  if($@) {
    if($@ =~ m&lt;^ABORT_TRAV&gt;) {
      ...it died (aborted) on $died_on...
    } else {
      die $@; # some REAL error happened
    }
  }
</pre>
<p class="Pp">or you can just do it with flags:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  my($abort_flag, $died_on);
  sub thing {
    ... visits $_[0]...
    ... maybe set $abort_flag = 1; $died_on = $_[0]; return;
    foreach my $c ($_[0]-&gt;content_list) {
      thing($c);
      return if $abort_flag;
    }
    ...any post-order visiting $_[0]...
    return;
  }

  $abort_flag = $died_on = undef;
  thing($node);
  ...if defined $abort_flag, it died on $died_on
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
HTML::Element
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
Current maintainers:
<ul class="Bl-bullet">
  <li>Christopher J. Madsen
      <span class="Li">&quot;&lt;perl&#x00A0;AT&#x00A0;cjmweb.net&gt;&quot;</span></li>
  <li>Jeff Fearn
      <span class="Li">&quot;&lt;jfearn&#x00A0;AT&#x00A0;cpan.org&gt;&quot;</span></li>
</ul>
<p class="Pp">Original HTML-Tree author:</p>
<dl class="Bl-tag">
  <dt>&#x2022;</dt>
  <dd>Gisle Aas</dd>
</dl>
<p class="Pp">Former maintainers:</p>
<ul class="Bl-bullet">
  <li>Sean M. Burke</li>
  <li>Andy Lester</li>
  <li>Pete Krawczyk
      <span class="Li">&quot;&lt;petek&#x00A0;AT&#x00A0;cpan.org&gt;&quot;</span></li>
</ul>
<p class="Pp">You can follow or contribute to HTML-Tree's development at
    &lt;https://github.com/kentfredric/HTML-Tree&gt;.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT"><a class="permalink" href="#COPYRIGHT">COPYRIGHT</a></h1>
Copyright 2000,2001 Sean M. Burke
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2020-10-18</td>
    <td class="foot-os">perl v5.18.4</td>
  </tr>
</table>
</body>
</html>
