<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>DBIx::Class::Manual::Joining(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">DBIx::Class::Manual::Joining(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">DBIx::Class::Manual::Joining(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
DBIx::Class::Manual::Joining - Manual on joining tables with DBIx::Class
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
This document should help you to use DBIx::Class if you are trying to convert
  your normal SQL queries into DBIx::Class based queries, if you use joins
  extensively (and also probably if you don't).
</section>
<section class="Sh">
<h1 class="Sh" id="WHAT_ARE_JOINS"><a class="permalink" href="#WHAT_ARE_JOINS">WHAT
  ARE JOINS</a></h1>
If you ended up here and you don't actually know what joins are yet, then you
  should likely try the DBIx::Class::Manual::Intro instead. Skip this part if
  you know what joins are..
<p class="Pp">But I'll explain anyway. Assuming you have created your database
    in a more or less sensible way, you will end up with several tables that
    contain <span class="Li">&quot;related&quot;</span> information. For
    example, you may have a table containing information about
    <span class="Li">&quot;CD&quot;</span>s, containing the CD title and its
    year of publication, and another table containing all the
    <span class="Li">&quot;Track&quot;</span>s for the CDs, one track per
  row.</p>
<p class="Pp">When you wish to extract information about a particular CD and all
    its tracks, You can either fetch the CD row, then make another query to
    fetch the tracks, or you can use a join. Compare:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  SELECT ID, Title, Year FROM CD WHERE Title = 'Funky CD';
  # .. Extract the ID, which is 10
  SELECT Name, Artist FROM Tracks WHERE CDID = 10;

  SELECT cd.ID, cd.Title, cd.Year, tracks.Name, tracks.Artist FROM CD JOIN Tracks ON CD.ID = tracks.CDID WHERE cd.Title = 'Funky CD';
</pre>
<p class="Pp">So, joins are a way of extending simple select statements to
    include fields from other, related, tables. There are various types of
    joins, depending on which combination of the data you wish to retrieve, see
    MySQL's doc on JOINs:
    &lt;http://dev.mysql.com/doc/refman/5.0/en/join.html&gt;.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DEFINING_JOINS_AND_RELATIONSHIPS"><a class="permalink" href="#DEFINING_JOINS_AND_RELATIONSHIPS">DEFINING
  JOINS AND RELATIONSHIPS</a></h1>
In DBIx::Class each relationship between two tables needs to first be defined in
  the ResultSource for the table. If the relationship needs to be accessed in
  both directions (i.e. Fetch all tracks of a CD, and fetch the CD data for a
  Track), then it needs to be defined for both tables.
<p class="Pp">For the CDs/Tracks example, that means writing, in
    <span class="Li">&quot;MySchema::CD&quot;</span>:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  MySchema::CD-&gt;has_many('tracks', 'MySchema::Tracks');
</pre>
<p class="Pp">And in <span class="Li">&quot;MySchema::Tracks&quot;</span>:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  MySchema::Tracks-&gt;belongs_to('cd', 'MySchema::CD', 'CDID');
</pre>
<p class="Pp">There are several other types of relationships, they are more
    comprehensively described in DBIx::Class::Relationship.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="USING_JOINS"><a class="permalink" href="#USING_JOINS">USING
  JOINS</a></h1>
Once you have defined all your relationships, using them in actual joins is
  fairly simple. The type of relationship that you chose e.g.
  <span class="Li">&quot;has_many&quot;</span>, already indicates what sort of
  join will be performed. <span class="Li">&quot;has_many&quot;</span> produces
  a <span class="Li">&quot;LEFT JOIN&quot;</span> for example, which will fetch
  all the rows on the left side, whether there are matching rows on the right
  (table being joined to), or not. You can force other types of joins in your
  relationship, see the DBIx::Class::Relationship docs.
<p class="Pp">When performing either a search or a find operation, you can
    specify which <span class="Li">&quot;relations&quot;</span> to also refine
    your results based on, using the join attribute, like this:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  $schema-&gt;resultset('CD')-&gt;search(
    { 'Title' =&gt; 'Funky CD',
      'tracks.Name' =&gt; { like =&gt; 'T%' }
    },
    { join      =&gt; 'tracks',
      order_by  =&gt; ['tracks.id'],
    }
  );
</pre>
<p class="Pp">If you don't recognise most of this syntax, you should probably go
    read &quot;search&quot; in DBIx::Class::ResultSet and &quot;ATTRIBUTES&quot;
    in DBIx::Class::ResultSet, but here's a quick break down:</p>
<p class="Pp">The first argument to search is a hashref of the WHERE attributes,
    in this case a restriction on the Title column in the CD table, and a
    restriction on the name of the track in the Tracks table, but ONLY for
    tracks actually related to the chosen CD(s). The second argument is a
    hashref of attributes to the search, the results will be returned sorted by
    the <span class="Li">&quot;id&quot;</span> of the related tracks.</p>
<p class="Pp">The special 'join' attribute specifies which
    <span class="Li">&quot;relationships&quot;</span> to include in the query.
    The distinction between <span class="Li">&quot;relationships&quot;</span>
    and <span class="Li">&quot;tables&quot;</span> is important here, only the
    <span class="Li">&quot;relationship&quot;</span> names are valid.</p>
<p class="Pp">This slightly nonsense example will produce SQL similar to:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  SELECT cd.ID, cd.Title, cd.Year FROM CD cd JOIN Tracks tracks ON cd.ID = tracks.CDID WHERE cd.Title = 'Funky CD' AND tracks.Name LIKE 'T%' ORDER BY 'tracks.id';
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="FETCHING_RELATED_DATA"><a class="permalink" href="#FETCHING_RELATED_DATA">FETCHING
  RELATED DATA</a></h1>
Another common use for joining to related tables, is to fetch the data from both
  tables in one query, preventing extra round-trips to the database. See the
  example above in &quot;WHAT ARE JOINS&quot;.
<p class="Pp">Three techniques are described here. Of the three, only the
    <span class="Li">&quot;prefetch&quot;</span> technique will deal sanely with
    fetching related objects over a <span class="Li">&quot;has_many&quot;</span>
    relation. The others work fine for 1 to 1 type relationships.</p>
<section class="Ss">
<h2 class="Ss" id="Whole_related_objects"><a class="permalink" href="#Whole_related_objects">Whole
  related objects</a></h2>
To fetch entire related objects, e.g. CDs and all Track data, use the 'prefetch'
  attribute:
<p class="Pp"><span class="Li"></span></p>
<pre>
  $schema-&gt;resultset('CD')-&gt;search(
    { 'Title' =&gt; 'Funky CD',
    },
    { prefetch      =&gt; 'tracks',
      order_by  =&gt; ['tracks.id'],
    }
  );
</pre>
<p class="Pp">This will produce SQL similar to the following:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  SELECT cd.ID, cd.Title, cd.Year, tracks.id, tracks.Name, tracks.Artist FROM CD JOIN Tracks ON CD.ID = tracks.CDID WHERE cd.Title = 'Funky CD' ORDER BY 'tracks.id';
</pre>
<p class="Pp">The syntax of 'prefetch' is the same as 'join' and implies the
    joining, so there is no need to use both together.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Subset_of_related_fields"><a class="permalink" href="#Subset_of_related_fields">Subset
  of related fields</a></h2>
To fetch a subset or the related fields, the '+select' and '+as' attributes can
  be used. For example, if the CD data is required and just the track name from
  the Tracks table:
<p class="Pp"><span class="Li"></span></p>
<pre>
  $schema-&gt;resultset('CD')-&gt;search(
    { 'Title' =&gt; 'Funky CD',
    },
    { join      =&gt; 'tracks',
      '+select' =&gt; ['tracks.Name'],
      '+as'     =&gt; ['track_name'],
      order_by  =&gt; ['tracks.id'],
    }
  );
</pre>
<p class="Pp">Which will produce the query:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  SELECT cd.ID, cd.Title, cd.Year, tracks.Name FROM CD JOIN Tracks ON CD.ID = tracks.CDID WHERE cd.Title = 'Funky CD' ORDER BY 'tracks.id';
</pre>
<p class="Pp">Note that the '+as' does not produce an SQL 'AS' keyword in the
    output, see the DBIx::Class::Manual::FAQ for an explanation.</p>
<p class="Pp">This type of column restriction has a downside, the returned
    <span class="Li">$result</span> object will have no 'track_name'
  accessor:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  while(my $result = $search_rs-&gt;next) {
     print $result-&gt;track_name; ## ERROR
  }
</pre>
<p class="Pp">Instead <span class="Li">&quot;get_column&quot;</span> must be
    used:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  while(my $result = $search_rs-&gt;next) {
     print $result-&gt;get_column('track_name'); ## WORKS
  }
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Incomplete_related_objects"><a class="permalink" href="#Incomplete_related_objects">Incomplete
  related objects</a></h2>
In rare circumstances, you may also wish to fetch related data as incomplete
  objects. The usual reason to do is when the related table has a very large
  field you don't need for the current data output. This is better solved by
  storing that field in a separate table which you only join to when needed.
<p class="Pp">To fetch an incomplete related object, supply the dotted notation
    to the '+as' attribute:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  $schema-&gt;resultset('CD')-&gt;search(
    { 'Title' =&gt; 'Funky CD',
    },
    { join      =&gt; 'tracks',
      '+select' =&gt; ['tracks.Name'],
      '+as'     =&gt; ['tracks.Name'],
      order_by  =&gt; ['tracks.id'],
    }
  );
</pre>
<p class="Pp">Which will produce same query as above;</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  SELECT cd.ID, cd.Title, cd.Year, tracks.Name FROM CD JOIN Tracks ON CD.ID = tracks.CDID WHERE cd.Title = 'Funky CD' ORDER BY 'tracks.id';
</pre>
<p class="Pp">Now you can access the result using the relationship accessor:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  while(my $result = $search_rs-&gt;next) {
     print $result-&gt;tracks-&gt;name; ## WORKS
  }
</pre>
<p class="Pp">However, this will produce broken objects. If the tracks id column
    is not fetched, the object will not be usable for any operation other than
    reading its data. Use the &quot;Whole related objects&quot; method as much
    as possible to avoid confusion in your code later.</p>
<p class="Pp">Broken means: Update will not work. Fetching other related objects
    will not work. Deleting the object will not work.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="COMPLEX_JOINS_AND_STUFF"><a class="permalink" href="#COMPLEX_JOINS_AND_STUFF">COMPLEX
  JOINS AND STUFF</a></h1>
<section class="Ss">
<h2 class="Ss" id="Across_multiple_relations"><a class="permalink" href="#Across_multiple_relations">Across
  multiple relations</a></h2>
For simplicity in the example above, the
  <span class="Li">&quot;Artist&quot;</span> was shown as a simple text field in
  the <span class="Li">&quot;Tracks&quot;</span> table, in reality, you'll want
  to have the artists in their own table as well, thus to fetch the complete set
  of data we'll need to join to the Artist table too.
<p class="Pp">In <span class="Li">&quot;MySchema::Tracks&quot;</span>:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  MySchema::Tracks-&gt;belongs_to('artist', 'MySchema::Artist', 'ArtistID');
</pre>
<p class="Pp">The search:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  $schema-&gt;resultset('CD')-&gt;search(
    { 'Title' =&gt; 'Funky CD' },
    { join      =&gt; { 'tracks' =&gt; 'artist' },
    }
  );
</pre>
<p class="Pp">Which is:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  SELECT me.ID, me.Title, me.Year FROM CD me JOIN Tracks tracks ON CD.ID = tracks.CDID JOIN Artists artist ON tracks.ArtistID = artist.ID WHERE me.Title = 'Funky CD';
</pre>
<p class="Pp">To perform joins using relations of the tables you are joining to,
    use a hashref to indicate the join depth. This can theoretically go as deep
    as you like (warning: contrived examples!):</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  join =&gt; { room =&gt; { table =&gt; 'leg' } }
</pre>
<p class="Pp">To join two relations at the same level, use an arrayref
  instead:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  join =&gt; { room =&gt; [ 'chair', 'table' ] }
</pre>
<p class="Pp">Or combine the two:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  join =&gt; { room =&gt; [ 'chair', { table =&gt; 'leg' } ]
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Table_aliases"><a class="permalink" href="#Table_aliases">Table
  aliases</a></h2>
As an aside to all the discussion on joins, note that DBIx::Class uses the
  <span class="Li">&quot;relation names&quot;</span> as table aliases. This is
  important when you need to add grouping or ordering to your queries:
<p class="Pp"><span class="Li"></span></p>
<pre>
  $schema-&gt;resultset('CD')-&gt;search(
    { 'Title' =&gt; 'Funky CD' },
    { join      =&gt; { 'tracks' =&gt; 'artist' },
      order_by  =&gt; [ 'tracks.Name', 'artist.Artist' ],
    }
  );

  SELECT me.ID, me.Title, me.Year FROM CD me JOIN Tracks tracks ON CD.ID = tracks.CDID JOIN Artists artist ON tracks.ArtistID = artist.ID WHERE me.Title = 'Funky CD' ORDER BY tracks.Name, artist.Artist;
</pre>
<p class="Pp">This is essential if any of your tables have columns with the same
    names.</p>
<p class="Pp">Note that the table of the resultsource the search was performed
    on, is always aliased to <span class="Li">&quot;me&quot;</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Joining_to_the_same_table_twice"><a class="permalink" href="#Joining_to_the_same_table_twice">Joining
  to the same table twice</a></h2>
There is no magic to this, just do it. The table aliases will automatically be
  numbered:
<p class="Pp"><span class="Li"></span></p>
<pre>
  join =&gt; [ 'room', 'room' ]
</pre>
<p class="Pp">The aliases are: <span class="Li">&quot;room&quot;</span> and
    <span class="Li">&quot;room_2&quot;</span>.</p>
</section>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2014-01-05</td>
    <td class="foot-os">perl v5.18.4</td>
  </tr>
</table>
</body>
</html>
