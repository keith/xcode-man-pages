<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.10 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>File::Find(3pm)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">File::Find(3pm)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">File::Find(3pm)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
File::Find - Traverse a directory tree.
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<span class="Li"></span>
<pre>
    use File::Find;
    find(\&amp;wanted, @directories_to_search);
    sub wanted { ... }

    use File::Find;
    finddepth(\&amp;wanted, @directories_to_search);
    sub wanted { ... }

    use File::Find;
    find({ wanted =&gt; \&amp;process, follow =&gt; 1 }, '.');
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
These are functions for searching through directory trees doing work on each
  file found similar to the Unix <i>find</i> command. File::Find exports two
  functions, <span class="Li">&quot;find&quot;</span> and
  <span class="Li">&quot;finddepth&quot;</span>. They work similarly but have
  subtle differences.
<dl class="Bl-tag">
  <dt><b>find</b></dt>
  <dd><span class="Li"></span>
    <pre>
  find(\&amp;wanted,  @directories);
  find(\%options, @directories);
    </pre>
    <p class="Pp"><span class="Li">&quot;find()&quot;</span> does a depth-first
        search over the given <span class="Li">@directories</span> in the order
        they are given. For each file or directory found, it calls the
        <span class="Li">&amp;wanted</span> subroutine. (See below for details
        on how to use the <span class="Li">&amp;wanted</span> function).
        Additionally, for each directory found, it will
        <span class="Li">&quot;chdir()&quot;</span> into that directory and
        continue the search, invoking the <span class="Li">&amp;wanted</span>
        function on each file or subdirectory in the directory.</p>
  </dd>
  <dt><b>finddepth</b></dt>
  <dd><span class="Li"></span>
    <pre>
  finddepth(\&amp;wanted,  @directories);
  finddepth(\%options, @directories);
    </pre>
    <p class="Pp"><span class="Li">&quot;finddepth()&quot;</span> works just
        like <span class="Li">&quot;find()&quot;</span> except that it invokes
        the <span class="Li">&amp;wanted</span> function for a directory
        <i>after</i> invoking it for the directory's contents. It does a
        postorder traversal instead of a preorder traversal, working from the
        bottom of the directory tree up where
        <span class="Li">&quot;find()&quot;</span> works from the top of the
        tree down.</p>
  </dd>
</dl>
<section class="Ss">
<h2 class="Ss" id="_options"><a class="permalink" href="#_options">%options</a></h2>
The first argument to <span class="Li">&quot;find()&quot;</span> is either a
  code reference to your <span class="Li">&amp;wanted</span> function, or a hash
  reference describing the operations to be performed for each file. The code
  reference is described in &quot;The wanted function&quot; below.
<p class="Pp">Here are the possible keys for the hash:</p>
<dl class="Bl-tag">
  <dt>&quot;wanted&quot;</dt>
  <dd>The value should be a code reference. This code reference is described in
      &quot;The wanted function&quot; below. The
      <span class="Li">&amp;wanted</span> subroutine is mandatory.</dd>
  <dt>&quot;bydepth&quot;</dt>
  <dd>Reports the name of a directory only AFTER all its entries have been
      reported. Entry point <span class="Li">&quot;finddepth()&quot;</span> is a
      shortcut for specifying <span class="Li">&quot;{ bydepth =&gt; 1
      }&quot;</span> in the first argument of
      <span class="Li">&quot;find()&quot;</span>.</dd>
  <dt>&quot;preprocess&quot;</dt>
  <dd>The value should be a code reference. This code reference is used to
      preprocess the current directory. The name of the currently processed
      directory is in <span class="Li">$File::Find::dir</span>. Your
      preprocessing function is called after
      <span class="Li">&quot;readdir()&quot;</span>, but before the loop that
      calls the <span class="Li">&quot;wanted()&quot;</span> function. It is
      called with a list of strings (actually file/directory names) and is
      expected to return a list of strings. The code can be used to sort the
      file/directory names alphabetically, numerically, or to filter out
      directory entries based on their name alone. When <i>follow</i> or
      <i>follow_fast</i> are in effect,
      <span class="Li">&quot;preprocess&quot;</span> is a no-op.</dd>
  <dt>&quot;postprocess&quot;</dt>
  <dd>The value should be a code reference. It is invoked just before leaving
      the currently processed directory. It is called in void context with no
      arguments. The name of the current directory is in
      <span class="Li">$File::Find::dir</span>. This hook is handy for
      summarizing a directory, such as calculating its disk usage. When
      <i>follow</i> or <i>follow_fast</i> are in effect,
      <span class="Li">&quot;postprocess&quot;</span> is a no-op.</dd>
  <dt>&quot;follow&quot;</dt>
  <dd>Causes symbolic links to be followed. Since directory trees with symbolic
      links (followed) may contain files more than once and may even have
      cycles, a hash has to be built up with an entry for each file. This might
      be expensive both in space and time for a large directory tree. See
      &quot;follow_fast&quot; and &quot;follow_skip&quot; below. If either
      <i>follow</i> or <i>follow_fast</i> is in effect:</dd>
</dl>
<div class="Bd-indent">
<ul class="Bl-bullet">
  <li>It is guaranteed that an <i>lstat</i> has been called before the user's
      <span class="Li">&quot;wanted()&quot;</span> function is called. This
      enables fast file checks involving <span class="Li">&quot;_&quot;</span>.
      Note that this guarantee no longer holds if <i>follow</i> or
      <i>follow_fast</i> are not set.</li>
  <li>There is a variable <span class="Li">$File::Find::fullname</span> which
      holds the absolute pathname of the file with all symbolic links resolved.
      If the link is a dangling symbolic link, then fullname will be set to
      <span class="Li">&quot;undef&quot;</span>.</li>
</ul>
</div>
<div class="Bd-indent">
<p class="Pp">This is a no-op on Win32.</p>
</div>
<dl class="Bl-tag">
  <dt>&quot;follow_fast&quot;</dt>
  <dd>This is similar to <i>follow</i> except that it may report some files more
      than once. It does detect cycles, however. Since only symbolic links have
      to be hashed, this is much cheaper both in space and time. If processing a
      file more than once (by the user's
      <span class="Li">&quot;wanted()&quot;</span> function) is worse than just
      taking time, the option <i>follow</i> should be used.
    <p class="Pp">This is also a no-op on Win32.</p>
  </dd>
  <dt>&quot;follow_skip&quot;</dt>
  <dd><span class="Li">&quot;follow_skip==1&quot;</span>, which is the default,
      causes all files which are neither directories nor symbolic links to be
      ignored if they are about to be processed a second time. If a directory or
      a symbolic link are about to be processed a second time, File::Find dies.
    <p class="Pp"><span class="Li">&quot;follow_skip==0&quot;</span> causes
        File::Find to die if any file is about to be processed a second
      time.</p>
    <p class="Pp"><span class="Li">&quot;follow_skip==2&quot;</span> causes
        File::Find to ignore any duplicate files and directories but to proceed
        normally otherwise.</p>
  </dd>
  <dt>&quot;dangling_symlinks&quot;</dt>
  <dd>Specifies what to do with symbolic links whose target doesn't exist. If
      true and a code reference, will be called with the symbolic link name and
      the directory it lives in as arguments. Otherwise, if true and warnings
      are on, a warning of the form <span class="Li">&quot;symbolic_link_name is
      a dangling</span> <span class="Li">symbolic link\n&quot;</span> will be
      issued. If false, the dangling symbolic link will be silently
    ignored.</dd>
  <dt>&quot;no_chdir&quot;</dt>
  <dd>Does not <span class="Li">&quot;chdir()&quot;</span> to each directory as
      it recurses. The <span class="Li">&quot;wanted()&quot;</span> function
      will need to be aware of this, of course. In this case,
      <span class="Li">$_</span> will be the same as
      <span class="Li">$File::Find::name</span>.</dd>
  <dt>&quot;untaint&quot;</dt>
  <dd>If find is used in taint-mode (-T command line switch or if EUID != UID or
      if EGID != GID), then internally directory names have to be untainted
      before they can be <span class="Li">&quot;chdir&quot;</span>'d to.
      Therefore they are checked against a regular expression
      <i>untaint_pattern</i>. Note that all names passed to the user's
      <span class="Li">&quot;wanted()&quot;</span> function are still tainted.
      If this option is used while not in taint-mode,
      <span class="Li">&quot;untaint&quot;</span> is a no-op.</dd>
  <dt>&quot;untaint_pattern&quot;</dt>
  <dd>See above. This should be set using the
      <span class="Li">&quot;qr&quot;</span> quoting operator. The default is
      set to <span class="Li">&quot;qr|^([-+@\w./]+)$|&quot;</span>. Note that
      the parentheses are vital.</dd>
  <dt>&quot;untaint_skip&quot;</dt>
  <dd>If set, a directory which fails the <i>untaint_pattern</i> is skipped,
      including all its sub-directories. The default is to
      <span class="Li">&quot;die&quot;</span> in such a case.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="The_wanted_function"><a class="permalink" href="#The_wanted_function">The
  wanted function</a></h2>
The <span class="Li">&quot;wanted()&quot;</span> function does whatever
  verifications you want on each file and directory. Note that despite its name,
  the <span class="Li">&quot;wanted()&quot;</span> function is a generic
  callback function, and does <b>not</b> tell File::Find if a file is
  &quot;wanted&quot; or not. In fact, its return value is ignored.
<p class="Pp">The wanted function takes no arguments but rather does its work
    through a collection of variables.</p>
<dl class="Bl-tag">
  <dt>$File::Find::dir is the current directory name,</dt>
  <dd></dd>
  <dt>$_ is the current filename within that directory</dt>
  <dd></dd>
  <dt>$File::Find::name is the complete pathname to the file.</dt>
  <dd></dd>
</dl>
<p class="Pp">The above variables have all been localized and may be changed
    without affecting data outside of the wanted function.</p>
<p class="Pp">For example, when examining the file <i>/some/path/foo.ext</i> you
    will have:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    $File::Find::dir  = /some/path/
    $_                = foo.ext
    $File::Find::name = /some/path/foo.ext
</pre>
<p class="Pp">You are <b>chdir()</b>'d to
    <span class="Li">$File::Find::dir</span> when the function is called, unless
    <span class="Li">&quot;no_chdir&quot;</span> was specified. Note that when
    changing to directories is in effect, the root directory (<i>/</i>) is a
    somewhat special case inasmuch as the concatenation of
    <span class="Li">$File::Find::dir</span>, <span class="Li">'/'</span> and
    <span class="Li">$_</span> is not literally equal to
    <span class="Li">$File::Find::name</span>. The table below summarizes all
    variants:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
              $File::Find::name  $File::Find::dir  $_
 default      /                  /                 .
 no_chdir=&gt;0  /etc               /                 etc
              /etc/x             /etc              x

 no_chdir=&gt;1  /                  /                 /
              /etc               /                 /etc
              /etc/x             /etc              /etc/x
</pre>
<p class="Pp">When <span class="Li">&quot;follow&quot;</span> or
    <span class="Li">&quot;follow_fast&quot;</span> are in effect, there is also
    a <span class="Li">$File::Find::fullname</span>. The function may set
    <span class="Li">$File::Find::prune</span> to prune the tree unless
    <span class="Li">&quot;bydepth&quot;</span> was specified. Unless
    <span class="Li">&quot;follow&quot;</span> or
    <span class="Li">&quot;follow_fast&quot;</span> is specified, for
    compatibility reasons (find.pl, find2perl) there are in addition the
    following globals available: <span class="Li">$File::Find::topdir</span>,
    <span class="Li">$File::Find::topdev</span>,
    <span class="Li">$File::Find::topino</span>,
    <span class="Li">$File::Find::topmode</span> and
    <span class="Li">$File::Find::topnlink</span>.</p>
<p class="Pp">This library is useful for the
    <span class="Li">&quot;find2perl&quot;</span> tool (distributed as part of
    the App-find2perl CPAN distribution), which when fed,</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  find2perl / -name .nfs\* -mtime +7 \
    -exec rm -f {} \; -o -fstype nfs -prune
</pre>
<p class="Pp">produces something like:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
 sub wanted {
    /^\.nfs.*\z/s &amp;&amp;
    (($dev, $ino, $mode, $nlink, $uid, $gid) = lstat($_)) &amp;&amp;
    int(-M _) &gt; 7 &amp;&amp;
    unlink($_)
    ||
    ($nlink || (($dev, $ino, $mode, $nlink, $uid, $gid) = lstat($_))) &amp;&amp;
    $dev &lt; 0 &amp;&amp;
    ($File::Find::prune = 1);
 }
</pre>
<p class="Pp">Notice the <span class="Li">&quot;_&quot;</span> in the above
    <span class="Li">&quot;int(-M _)&quot;</span>: the
    <span class="Li">&quot;_&quot;</span> is a magical filehandle that caches
    the information from the preceding
    <span class="Li">&quot;stat()&quot;</span>,
    <span class="Li">&quot;lstat()&quot;</span>, or filetest.</p>
<p class="Pp">Here's another interesting wanted function. It will find all
    symbolic links that don't resolve:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    sub wanted {
         -l &amp;&amp; !-e &amp;&amp; print &quot;bogus link: $File::Find::name\n&quot;;
    }
</pre>
<p class="Pp">Note that you may mix directories and (non-directory) files in the
    list of directories to be searched by the
    <span class="Li">&quot;wanted()&quot;</span> function.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    find(\&amp;wanted, &quot;./foo&quot;, &quot;./bar&quot;, &quot;./baz/epsilon&quot;);
</pre>
<p class="Pp">In the example above, no file in <i>./baz/</i> other than
    <i>./baz/epsilon</i> will be evaluated by
    <span class="Li">&quot;wanted()&quot;</span>.</p>
<p class="Pp">See also the script <span class="Li">&quot;pfind&quot;</span> on
    CPAN for a nice application of this module.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="WARNINGS"><a class="permalink" href="#WARNINGS">WARNINGS</a></h1>
If you run your program with the <span class="Li">&quot;-w&quot;</span> switch,
  or if you use the <span class="Li">&quot;warnings&quot;</span> pragma,
  File::Find will report warnings for several weird situations. You can disable
  these warnings by putting the statement
<p class="Pp"><span class="Li"></span></p>
<pre>
    no warnings 'File::Find';
</pre>
<p class="Pp">in the appropriate scope. See warnings for more info about lexical
    warnings.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="CAVEAT"><a class="permalink" href="#CAVEAT">CAVEAT</a></h1>
<dl class="Bl-tag">
  <dt>$dont_use_nlink</dt>
  <dd>You can set the variable
      <span class="Li">$File::Find::dont_use_nlink</span> to 1 if you want to
      force File::Find to always stat directories. This was used for file
      systems that do not have an <span class="Li">&quot;nlink&quot;</span>
      count matching the number of sub-directories. Examples are ISO-9660
      (CD-ROM), AFS, HPFS (OS/2 file system), FAT (DOS file system) and a couple
      of others.
    <p class="Pp">You shouldn't need to set this variable, since File::Find
        should now detect such file systems on-the-fly and switch itself to
        using stat. This works even for parts of your file system, like a
        mounted CD-ROM.</p>
    <p class="Pp">If you do set
        <span class="Li">$File::Find::dont_use_nlink</span> to 1, you will
        notice slow-downs.</p>
  </dd>
  <dt>symlinks</dt>
  <dd>Be aware that the option to follow symbolic links can be dangerous.
      Depending on the structure of the directory tree (including symbolic links
      to directories) you might traverse a given (physical) directory more than
      once (only if <span class="Li">&quot;follow_fast&quot;</span> is in
      effect). Furthermore, deleting or changing files in a symbolically linked
      directory might cause very unpleasant surprises, since you delete or
      change files in an unknown directory.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="BUGS_AND_CAVEATS"><a class="permalink" href="#BUGS_AND_CAVEATS">BUGS
  AND CAVEATS</a></h1>
Despite the name of the <span class="Li">&quot;finddepth()&quot;</span>
  function, both <span class="Li">&quot;find()&quot;</span> and
  <span class="Li">&quot;finddepth()&quot;</span> perform a depth-first search
  of the directory hierarchy.
</section>
<section class="Sh">
<h1 class="Sh" id="HISTORY"><a class="permalink" href="#HISTORY">HISTORY</a></h1>
File::Find used to produce incorrect results if called recursively. During the
  development of perl 5.8 this bug was fixed. The first fixed version of
  File::Find was 1.01.
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<b>find</b>(1), find2perl.
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2018-03-01</td>
    <td class="foot-os">perl v5.28.2</td>
  </tr>
</table>
</body>
</html>
