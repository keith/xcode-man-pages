<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>IP(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">IP(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">IP(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
Net::IP - Perl extension for manipulating IPv4/IPv6 addresses
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<span class="Li"></span>
<pre>
  use Net::IP;
  
  my $ip = new Net::IP ('193.0.1/24') or die (Net::IP::Error());
  print (&quot;IP  : &quot;.$ip-&gt;ip().&quot;\n&quot;);
  print (&quot;Sho : &quot;.$ip-&gt;short().&quot;\n&quot;);
  print (&quot;Bin : &quot;.$ip-&gt;binip().&quot;\n&quot;);
  print (&quot;Int : &quot;.$ip-&gt;intip().&quot;\n&quot;);
  print (&quot;Mask: &quot;.$ip-&gt;mask().&quot;\n&quot;);
  print (&quot;Last: &quot;.$ip-&gt;last_ip().&quot;\n&quot;);
  print (&quot;Len : &quot;.$ip-&gt;prefixlen().&quot;\n&quot;);
  print (&quot;Size: &quot;.$ip-&gt;size().&quot;\n&quot;);
  print (&quot;Type: &quot;.$ip-&gt;iptype().&quot;\n&quot;);
  print (&quot;Rev:  &quot;.$ip-&gt;reverse_ip().&quot;\n&quot;);
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
This module provides functions to deal with <b>IPv4/IPv6</b> addresses. The
  module can be used as a class, allowing the user to instantiate IP objects,
  which can be single IP addresses, prefixes, or ranges of addresses. There is
  also a procedural way of accessing most of the functions. Most subroutines can
  take either <b>IPv4</b> or <b>IPv6</b> addresses transparently.
</section>
<section class="Sh">
<h1 class="Sh" id="OBJECT-ORIENTED_INTERFACE"><a class="permalink" href="#OBJECT-ORIENTED_INTERFACE">OBJECT-ORIENTED
  INTERFACE</a></h1>
<section class="Ss">
<h2 class="Ss" id="Object_Creation"><a class="permalink" href="#Object_Creation">Object
  Creation</a></h2>
A Net::IP object can be created from a single IP address:
<p class="Pp"><span class="Li"></span></p>
<pre>
  $ip = new Net::IP ('193.0.1.46') || die ...
</pre>
<p class="Pp">Or from a Classless Prefix (a /24 prefix is equivalent to a C
    class):</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  $ip = new Net::IP ('195.114.80/24') || die ...
</pre>
<p class="Pp">Or from a range of addresses:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  $ip = new Net::IP ('20.34.101.207 - 201.3.9.99') || die ...
</pre>
<p class="Pp">Or from a address plus a number:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  $ip = new Net::IP ('20.34.10.0 + 255') || die ...
</pre>
<p class="Pp">The <b>new()</b> function accepts IPv4 and IPv6 addresses:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  $ip = new Net::IP ('dead:beef::/32') || die ...
</pre>
<p class="Pp">Optionnaly, the function can be passed the version of the IP.
    Otherwise, it tries to guess what the version is (see
    <b></b><b>_is_ipv4()</b> <b></b> and <b></b><b>_is_ipv6()</b><b></b>).</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  $ip = new Net::IP ('195/8',4); # Class A
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="OBJECT_METHODS"><a class="permalink" href="#OBJECT_METHODS">OBJECT
  METHODS</a></h1>
Most of these methods are front-ends for the real functions, which use a
  procedural interface. Most functions return undef on failure, and a true value
  on success. A detailed description of the procedural interface is provided
  below.
<section class="Ss">
<h2 class="Ss" id="set"><a class="permalink" href="#set">set</a></h2>
Set an IP address in an existing IP object. This method has the same
  functionality as the <b>new()</b> method, except that it reuses an existing
  object to store the new IP.
<p class="Pp"><span class="Li">&quot;$ip-&gt;set('130.23.1/24',4);&quot;</span></p>
<p class="Pp">Like <b>new()</b>, <b>set()</b> takes two arguments - a string
    used to build an IP address, prefix, or range, and optionally, the IP
    version of the considered address.</p>
<p class="Pp">It returns an IP object on success, and undef on failure.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="error"><a class="permalink" href="#error">error</a></h2>
Return the current object error string. The error string is set whenever one of
  the methods produces an error. Also, a global, class-wide
  <b></b><b>Error()</b> <b></b> function is avaliable.
<p class="Pp"><span class="Li">&quot;warn ($ip-&gt;error());&quot;</span></p>
</section>
<section class="Ss">
<h2 class="Ss" id="errno"><a class="permalink" href="#errno">errno</a></h2>
Return the current object error number. The error number is set whenever one of
  the methods produces an error. Also, a global <b></b><b>$ERRNO</b><b></b>
  variable is set when an error is produced.
<p class="Pp"><span class="Li">&quot;warn ($ip-&gt;errno());&quot;</span></p>
</section>
<section class="Ss">
<h2 class="Ss" id="ip"><a class="permalink" href="#ip">ip</a></h2>
Return the IP address (or first IP of the prefix or range) in quad format, as a
  string.
<p class="Pp"><span class="Li">&quot;print ($ip-&gt;ip());&quot;</span></p>
</section>
<section class="Ss">
<h2 class="Ss" id="binip"><a class="permalink" href="#binip">binip</a></h2>
Return the IP address as a binary string of 0s and 1s.
<p class="Pp"><span class="Li">&quot;print ($ip-&gt;binip());&quot;</span></p>
</section>
<section class="Ss">
<h2 class="Ss" id="prefixlen"><a class="permalink" href="#prefixlen">prefixlen</a></h2>
Return the length in bits of the current prefix.
<p class="Pp"><span class="Li">&quot;print
  ($ip-&gt;prefixlen());&quot;</span></p>
</section>
<section class="Ss">
<h2 class="Ss" id="version"><a class="permalink" href="#version">version</a></h2>
Return the version of the current IP object (4 or 6).
<p class="Pp"><span class="Li">&quot;print ($ip-&gt;version());&quot;</span></p>
</section>
<section class="Ss">
<h2 class="Ss" id="size"><a class="permalink" href="#size">size</a></h2>
Return the number of IP addresses in the current prefix or range. Use of this
  function requires Math::BigInt.
<p class="Pp"><span class="Li">&quot;print ($ip-&gt;size());&quot;</span></p>
</section>
<section class="Ss">
<h2 class="Ss" id="binmask"><a class="permalink" href="#binmask">binmask</a></h2>
Return the binary mask of the current prefix, if applicable.
<p class="Pp"><span class="Li">&quot;print ($ip-&gt;binmask());&quot;</span></p>
</section>
<section class="Ss">
<h2 class="Ss" id="mask"><a class="permalink" href="#mask">mask</a></h2>
Return the mask in quad format of the current prefix.
<p class="Pp"><span class="Li">&quot;print ($ip-&gt;mask());&quot;</span></p>
</section>
<section class="Ss">
<h2 class="Ss" id="prefix"><a class="permalink" href="#prefix">prefix</a></h2>
Return the full prefix (ip+prefix length) in quad (standard) format.
<p class="Pp"><span class="Li">&quot;print ($ip-&gt;prefix());&quot;</span></p>
</section>
<section class="Ss">
<h2 class="Ss" id="print"><a class="permalink" href="#print">print</a></h2>
Print the IP object (IP/Prefix or First - Last)
<p class="Pp"><span class="Li">&quot;print ($ip-&gt;print());&quot;</span></p>
</section>
<section class="Ss">
<h2 class="Ss" id="intip"><a class="permalink" href="#intip">intip</a></h2>
Convert the IP in integer format and return it as a Math::BigInt object.
<p class="Pp"><span class="Li">&quot;print ($ip-&gt;intip());&quot;</span></p>
</section>
<section class="Ss">
<h2 class="Ss" id="hexip"><a class="permalink" href="#hexip">hexip</a></h2>
Return the IP in hex format
<p class="Pp"><span class="Li">&quot;print ($ip-&gt;hexip());&quot;</span></p>
</section>
<section class="Ss">
<h2 class="Ss" id="hexmask"><a class="permalink" href="#hexmask">hexmask</a></h2>
Return the mask in hex format
<p class="Pp"><span class="Li">&quot;print ($ip-&gt;hexmask());&quot;</span></p>
</section>
<section class="Ss">
<h2 class="Ss" id="short"><a class="permalink" href="#short">short</a></h2>
Return the IP in short format: 	IPv4 addresses: 194.5/16 	IPv6 addresses:
  ab32:f000::
<p class="Pp"><span class="Li">&quot;print ($ip-&gt;short());&quot;</span></p>
</section>
<section class="Ss">
<h2 class="Ss" id="iptype"><a class="permalink" href="#iptype">iptype</a></h2>
Return the IP Type - this describes the type of an IP (Public, Private,
  Reserved, etc.) See procedural interface ip_iptype for more details.
<p class="Pp"><span class="Li">&quot;print ($ip-&gt;iptype());&quot;</span></p>
</section>
<section class="Ss">
<h2 class="Ss" id="reverse_ip"><a class="permalink" href="#reverse_ip">reverse_ip</a></h2>
Return the reverse IP for a given IP address (in.addr. format).
<p class="Pp"><span class="Li">&quot;print
  ($ip-&gt;reserve_ip());&quot;</span></p>
</section>
<section class="Ss">
<h2 class="Ss" id="last_ip"><a class="permalink" href="#last_ip">last_ip</a></h2>
Return the last IP of a prefix/range in quad format.
<p class="Pp"><span class="Li">&quot;print ($ip-&gt;last_ip());&quot;</span></p>
</section>
<section class="Ss">
<h2 class="Ss" id="last_bin"><a class="permalink" href="#last_bin">last_bin</a></h2>
Return the last IP of a prefix/range in binary format.
<p class="Pp"><span class="Li">&quot;print
  ($ip-&gt;last_bin());&quot;</span></p>
</section>
<section class="Ss">
<h2 class="Ss" id="last_int"><a class="permalink" href="#last_int">last_int</a></h2>
Return the last IP of a prefix/range in integer format.
<p class="Pp"><span class="Li">&quot;print
  ($ip-&gt;last_int());&quot;</span></p>
</section>
<section class="Ss">
<h2 class="Ss" id="find_prefixes"><a class="permalink" href="#find_prefixes">find_prefixes</a></h2>
This function finds all the prefixes that can be found between the two addresses
  of a range. The function returns a list of prefixes.
<p class="Pp"><span class="Li">&quot;@list =
    $ip-&gt;find_prefixes($other_ip));&quot;</span></p>
</section>
<section class="Ss">
<h2 class="Ss" id="bincomp"><a class="permalink" href="#bincomp">bincomp</a></h2>
Binary comparaison of two IP objects. The function takes an operation and an IP
  object as arguments. It returns a boolean value.
<p class="Pp">The operation can be one of: lt: less than (smaller than) le:
    smaller or equal to gt: greater than ge: greater or equal to</p>
<p class="Pp"><span class="Li">&quot;if ($ip-&gt;bincomp('lt',$ip2)
    {...}&quot;</span></p>
</section>
<section class="Ss">
<h2 class="Ss" id="binadd"><a class="permalink" href="#binadd">binadd</a></h2>
Binary addition of two IP objects. The value returned is an IP object.
<p class="Pp"><span class="Li">&quot;my $sum =
    $ip-&gt;binadd($ip2);&quot;</span></p>
</section>
<section class="Ss">
<h2 class="Ss" id="aggregate"><a class="permalink" href="#aggregate">aggregate</a></h2>
Aggregate 2 IPs - Append one range/prefix of IPs to another. The last address of
  the first range must be the one immediately preceding the first address of the
  second range. A new IP object is returned.
<p class="Pp"><span class="Li">&quot;my $total =
    $ip-&gt;aggregate($ip2);&quot;</span></p>
</section>
<section class="Ss">
<h2 class="Ss" id="overlaps"><a class="permalink" href="#overlaps">overlaps</a></h2>
Check if two IP ranges/prefixes overlap each other. The value returned by the
  function should be one of: 	<span class="Li">$IP_PARTIAL_OVERLAP</span>
  (ranges overlap) 	<span class="Li">$IP_NO_OVERLAP</span> (no overlap)
  	<span class="Li">$IP_A_IN_B_OVERLAP</span> (range2 contains range1)
  	<span class="Li">$IP_B_IN_A_OVERLAP</span> (range1 contains range2)
  	<span class="Li">$IP_IDENTICAL</span> (ranges are identical) 	undef (problem)
<p class="Pp"><span class="Li">&quot;if
    ($ip-&gt;overlaps($ip2)==$IP_A_IN_B_OVERLAP) {...};&quot;</span></p>
</section>
<section class="Ss">
<h2 class="Ss" id="looping"><a class="permalink" href="#looping">looping</a></h2>
The <span class="Li">&quot;+&quot;</span> operator is overloaded in order to
  allow looping though a whole range of IP addresses:
<p class="Pp"><span class="Li"></span></p>
<pre>
  my $ip = new Net::IP ('195.45.6.7 - 195.45.6.19') || die;
  # Loop
  do {
      print $ip-&gt;ip(), &quot;\n&quot;;
  } while (++$ip);
</pre>
<p class="Pp">The ++ operator returns undef when the last address of the range
    is reached.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="auth"><a class="permalink" href="#auth">auth</a></h2>
Return IP authority information from the IP::Authority module
<p class="Pp"><span class="Li">&quot;$auth = ip-&quot;</span>auth ();&gt;</p>
<p class="Pp">Note: IPv4 only</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="PROCEDURAL_INTERFACE"><a class="permalink" href="#PROCEDURAL_INTERFACE">PROCEDURAL
  INTERFACE</a></h1>
These functions do the real work in the module. Like the OO methods, most of
  these return undef on failure. In order to access error codes and strings,
  instead of using <span class="Li">$ip</span>-&gt;<b>error()</b> and
  <span class="Li">$ip</span>-&gt;<b>errno()</b>, use the global functions
  <span class="Li">&quot;Error()&quot;</span> and
  <span class="Li">&quot;Errno()&quot;</span>.
<p class="Pp">The functions of the procedural interface are not exported by
    default. In order to import these functions, you need to modify the use
    statement for the module:</p>
<p class="Pp"><span class="Li">&quot;use Net::IP qw(:PROC);&quot;</span></p>
<section class="Ss">
<h2 class="Ss" id="Error"><a class="permalink" href="#Error">Error</a></h2>
Returns the error string corresponding to the last error generated in the
  module. This is also useful for the OO interface, as if the <b>new()</b>
  function fails, we cannot call <span class="Li">$ip</span>-&gt;<b>error()</b>
  and so we have to use <b>Error()</b>.
<p class="Pp">warn <b>Error()</b>;</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Errno"><a class="permalink" href="#Errno">Errno</a></h2>
Returns a numeric error code corresponding to the error string returned by
  Error.
</section>
<section class="Ss">
<h2 class="Ss" id="ip_iptobin"><a class="permalink" href="#ip_iptobin">ip_iptobin</a></h2>
Transform an IP address into a bit string.
<p class="Pp"><span class="Li"></span></p>
<pre>
    Params  : IP address, IP version
    Returns : binary IP string on success, undef otherwise
</pre>
<p class="Pp"><span class="Li">&quot;$binip = ip_iptobin
  ($ip,6);&quot;</span></p>
</section>
<section class="Ss">
<h2 class="Ss" id="ip_bintoip"><a class="permalink" href="#ip_bintoip">ip_bintoip</a></h2>
Transform a bit string into an IP address
<p class="Pp"><span class="Li"></span></p>
<pre>
    Params  : binary IP, IP version
    Returns : IP address on success, undef otherwise
</pre>
<p class="Pp"><span class="Li">&quot;$ip = ip_bintoip
  ($binip,6);&quot;</span></p>
</section>
<section class="Ss">
<h2 class="Ss" id="ip_bintoint"><a class="permalink" href="#ip_bintoint">ip_bintoint</a></h2>
Transform a bit string into a BigInt.
<p class="Pp"><span class="Li"></span></p>
<pre>
    Params  : binary IP
    Returns : BigInt
</pre>
<p class="Pp"><span class="Li">&quot;$bigint = new Math::BigInt
    (ip_bintoint($binip));&quot;</span></p>
</section>
<section class="Ss">
<h2 class="Ss" id="ip_inttobin"><a class="permalink" href="#ip_inttobin">ip_inttobin</a></h2>
Transform a BigInt into a bit string. <i>Warning</i>: sets warnings
  (<span class="Li">&quot;-w&quot;</span>) off. This is necessary because
  Math::BigInt is not compliant.
<p class="Pp"><span class="Li"></span></p>
<pre>
    Params  : BigInt, IP version
    Returns : binary IP
</pre>
<p class="Pp"><span class="Li">&quot;$binip = ip_inttobin
    ($bigint);&quot;</span></p>
</section>
<section class="Ss">
<h2 class="Ss" id="ip_get_version"><a class="permalink" href="#ip_get_version">ip_get_version</a></h2>
Try to guess the IP version of an IP address.
<p class="Pp"><span class="Li"></span></p>
<pre>
    Params  : IP address
    Returns : 4, 6, undef(unable to determine)
</pre>
<p class="Pp"><span class="Li">&quot;$version = ip_get_version
    ($ip)&quot;</span></p>
</section>
<section class="Ss">
<h2 class="Ss" id="ip_is_ipv4"><a class="permalink" href="#ip_is_ipv4">ip_is_ipv4</a></h2>
Check if an IP address is of type 4.
<p class="Pp"><span class="Li"></span></p>
<pre>
    Params  : IP address
    Returns : 1 (yes) or 0 (no)
</pre>
<p class="Pp"><span class="Li">&quot;ip_is_ipv4($ip) and print &quot;$ip is
    IPv4&quot;;&quot;</span></p>
</section>
<section class="Ss">
<h2 class="Ss" id="ip_is_ipv6"><a class="permalink" href="#ip_is_ipv6">ip_is_ipv6</a></h2>
Check if an IP address is of type 6.
<p class="Pp"><span class="Li"></span></p>
<pre>
    Params            : IP address
    Returns           : 1 (yes) or 0 (no)
</pre>
<p class="Pp"><span class="Li">&quot;ip_is_ipv6($ip) and print &quot;$ip is
    IPv6&quot;;&quot;</span></p>
</section>
<section class="Ss">
<h2 class="Ss" id="ip_expand_address"><a class="permalink" href="#ip_expand_address">ip_expand_address</a></h2>
Expand an IP address from compact notation.
<p class="Pp"><span class="Li"></span></p>
<pre>
    Params  : IP address, IP version
    Returns : expanded IP address or undef on failure
</pre>
<p class="Pp"><span class="Li">&quot;$ip = ip_expand_address
    ($ip,4);&quot;</span></p>
</section>
<section class="Ss">
<h2 class="Ss" id="ip_get_mask"><a class="permalink" href="#ip_get_mask">ip_get_mask</a></h2>
Get IP mask from prefix length.
<p class="Pp"><span class="Li"></span></p>
<pre>
    Params  : Prefix length, IP version
    Returns : Binary Mask
</pre>
<p class="Pp"><span class="Li">&quot;$mask = ip_get_mask
  ($len,6);&quot;</span></p>
</section>
<section class="Ss">
<h2 class="Ss" id="ip_last_address_bin"><a class="permalink" href="#ip_last_address_bin">ip_last_address_bin</a></h2>
Return the last binary address of a prefix.
<p class="Pp"><span class="Li"></span></p>
<pre>
    Params  : First binary IP, prefix length, IP version
    Returns : Binary IP
</pre>
<p class="Pp"><span class="Li">&quot;$lastbin = ip_last_address_bin
    ($ip,$len,6);&quot;</span></p>
</section>
<section class="Ss">
<h2 class="Ss" id="ip_splitprefix"><a class="permalink" href="#ip_splitprefix">ip_splitprefix</a></h2>
Split a prefix into IP and prefix length. If it was passed a simple IP, it just
  returns it.
<p class="Pp"><span class="Li"></span></p>
<pre>
    Params  : Prefix
    Returns : IP, optionnaly length of prefix
</pre>
<p class="Pp"><span class="Li">&quot;($ip,$len) = ip_splitprefix
    ($prefix)&quot;</span></p>
</section>
<section class="Ss">
<h2 class="Ss" id="ip_prefix_to_range"><a class="permalink" href="#ip_prefix_to_range">ip_prefix_to_range</a></h2>
Get a range of IPs from a prefix.
<p class="Pp"><span class="Li"></span></p>
<pre>
    Params  : Prefix, IP version
    Returns : First IP, last IP
</pre>
<p class="Pp"><span class="Li">&quot;($ip1,$ip2) = ip_prefix_to_range
    ($prefix,6);&quot;</span></p>
</section>
<section class="Ss">
<h2 class="Ss" id="ip_bincomp"><a class="permalink" href="#ip_bincomp">ip_bincomp</a></h2>
Compare binary Ips with &lt;, &gt;, &lt;=, &gt;=.
 Operators are lt(&lt;), le(&lt;=), gt(&gt;), and ge(&gt;=)
<p class="Pp"><span class="Li"></span></p>
<pre>
    Params  : First binary IP, operator, Last binary IP
    Returns : 1 (yes), 0 (no), or undef (problem)
</pre>
<p class="Pp"><span class="Li">&quot;ip_bincomp ($ip1,'lt',$ip2) == 1 or do
    {}&quot;</span></p>
</section>
<section class="Ss">
<h2 class="Ss" id="ip_binadd"><a class="permalink" href="#ip_binadd">ip_binadd</a></h2>
Add two binary IPs.
<p class="Pp"><span class="Li"></span></p>
<pre>
    Params  : First binary IP, Last binary IP
    Returns : Binary sum or undef (problem)
</pre>
<p class="Pp"><span class="Li">&quot;$binip = ip_binadd
    ($bin1,$bin2);&quot;</span></p>
</section>
<section class="Ss">
<h2 class="Ss" id="ip_get_prefix_length"><a class="permalink" href="#ip_get_prefix_length">ip_get_prefix_length</a></h2>
Get the prefix length for a given range of 2 IPs.
<p class="Pp"><span class="Li"></span></p>
<pre>
    Params  : First binary IP, Last binary IP
    Returns : Length of prefix or undef (problem)
</pre>
<p class="Pp"><span class="Li">&quot;$len = ip_get_prefix_length
    ($ip1,$ip2);&quot;</span></p>
</section>
<section class="Ss">
<h2 class="Ss" id="ip_range_to_prefix"><a class="permalink" href="#ip_range_to_prefix">ip_range_to_prefix</a></h2>
Return all prefixes between two IPs.
<p class="Pp"><span class="Li"></span></p>
<pre>
    Params  : First IP (binary format), Last IP (binary format), IP version
    Returns : List of Prefixes or undef (problem)
</pre>
<p class="Pp">The prefixes returned have the form q.q.q.q/nn.</p>
<p class="Pp"><span class="Li">&quot;@prefix = ip_range_to_prefix
    ($ip1,$ip2,6);&quot;</span></p>
</section>
<section class="Ss">
<h2 class="Ss" id="ip_compress_v4_prefix"><a class="permalink" href="#ip_compress_v4_prefix">ip_compress_v4_prefix</a></h2>
Compress an IPv4 Prefix.
<p class="Pp"><span class="Li"></span></p>
<pre>
    Params  : IP, Prefix length
    Returns : Compressed Prefix
</pre>
<p class="Pp"><span class="Li">&quot;$ip = ip_compress_v4_prefix ($ip,
    $len);&quot;</span></p>
</section>
<section class="Ss">
<h2 class="Ss" id="ip_compress_address"><a class="permalink" href="#ip_compress_address">ip_compress_address</a></h2>
Compress an IPv6 address. Just returns the IP if it is an IPv4.
<p class="Pp"><span class="Li"></span></p>
<pre>
    Params  : IP, IP version
    Returns : Compressed IP or undef (problem)
</pre>
<p class="Pp"><span class="Li">&quot;$ip = ip_compress_adress ($ip,
    $version);&quot;</span></p>
</section>
<section class="Ss">
<h2 class="Ss" id="ip_is_overlap"><a class="permalink" href="#ip_is_overlap">ip_is_overlap</a></h2>
Check if two ranges of IPs overlap.
<p class="Pp"><span class="Li"></span></p>
<pre>
    Params  : Four binary IPs (begin of range 1,end1,begin2,end2), IP version
        $IP_PARTIAL_OVERLAP (ranges overlap) 
        $IP_NO_OVERLAP      (no overlap)
        $IP_A_IN_B_OVERLAP  (range2 contains range1)
        $IP_B_IN_A_OVERLAP  (range1 contains range2)
        $IP_IDENTICAL       (ranges are identical)
        undef               (problem)
</pre>
<p class="Pp"><span class="Li">&quot;(ip_is_overlap($rb1,$re1,$rb2,$re2,4) eq
    $IP_A_IN_B_OVERLAP) and do {};&quot;</span></p>
</section>
<section class="Ss">
<h2 class="Ss" id="ip_get_embedded_ipv4"><a class="permalink" href="#ip_get_embedded_ipv4">ip_get_embedded_ipv4</a></h2>
Get an IPv4 embedded in an IPv6 address
<p class="Pp"><span class="Li"></span></p>
<pre>
    Params  : IPv6
    Returns : IPv4 string or undef (not found)
</pre>
<p class="Pp"><span class="Li">&quot;$ip4 =
  ip_get_embedded($ip6);&quot;</span></p>
</section>
<section class="Ss">
<h2 class="Ss" id="ip_check_mask"><a class="permalink" href="#ip_check_mask">ip_check_mask</a></h2>
Check the validity of a binary IP mask
<p class="Pp"><span class="Li"></span></p>
<pre>
    Params  : Mask
    Returns : 1 or undef (invalid)
</pre>
<p class="Pp"><span class="Li">&quot;ip_check_mask($binmask) or do
    {};&quot;</span></p>
<p class="Pp">Checks if mask has only 1s followed by 0s.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="ip_aggregate"><a class="permalink" href="#ip_aggregate">ip_aggregate</a></h2>
Aggregate 2 ranges of binary IPs
<p class="Pp"><span class="Li"></span></p>
<pre>
    Params  : 1st range (1st IP, Last IP), last range (1st IP, last IP), IP version
    Returns : prefix or undef (invalid)
</pre>
<p class="Pp"><span class="Li">&quot;$prefix = ip_aggregate
    ($bip1,$eip1,$bip2,$eip2) || die ...&quot;</span></p>
</section>
<section class="Ss">
<h2 class="Ss" id="ip_iptypev4"><a class="permalink" href="#ip_iptypev4">ip_iptypev4</a></h2>
Return the type of an IPv4 address.
<p class="Pp"><span class="Li"></span></p>
<pre>
    Params:  binary IP
    Returns: type as of the following table or undef (invalid ip)
</pre>
<p class="Pp">See RFC 5735 and RFC 6598</p>
<p class="Pp">Address&#x00A0;Block&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;Present&#x00A0;Use&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;Reference
    -------------------------------------------------------------------
    0.0.0.0/8&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&quot;This&quot;&#x00A0;Network&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;RFC&#x00A0;1122&#x00A0;PRIVATE
    10.0.0.0/8&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;Private-Use&#x00A0;Networks&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;RFC&#x00A0;1918&#x00A0;PRIVATE
    100.64.0.0/10&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;CGN&#x00A0;Shared&#x00A0;Address&#x00A0;Space&#x00A0;&#x00A0;&#x00A0;RFC&#x00A0;6598&#x00A0;SHARED
    127.0.0.0/8&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;Loopback&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;RFC&#x00A0;1122&#x00A0;LOOPBACK
    169.254.0.0/16&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;Link&#x00A0;Local&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;RFC&#x00A0;3927&#x00A0;LINK-LOCAL
    172.16.0.0/12&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;Private-Use&#x00A0;Networks&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;RFC&#x00A0;1918&#x00A0;PRIVATE
    192.0.0.0/24&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;IETF&#x00A0;Protocol&#x00A0;Assignments&#x00A0;&#x00A0;RFC&#x00A0;5736&#x00A0;RESERVED
    192.0.2.0/24&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;TEST-NET-1&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;RFC&#x00A0;5737&#x00A0;TEST-NET
    192.88.99.0/24&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;6to4&#x00A0;Relay&#x00A0;Anycast&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;RFC&#x00A0;3068&#x00A0;6TO4-RELAY
    192.168.0.0/16&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;Private-Use&#x00A0;Networks&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;RFC&#x00A0;1918&#x00A0;PRIVATE
    198.18.0.0/15&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;Network&#x00A0;Interconnect
    &#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;Device&#x00A0;Benchmark&#x00A0;Testing&#x00A0;&#x00A0;&#x00A0;RFC&#x00A0;2544&#x00A0;RESERVED
    198.51.100.0/24&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;TEST-NET-2&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;RFC&#x00A0;5737&#x00A0;TEST-NET
    203.0.113.0/24&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;TEST-NET-3&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;RFC&#x00A0;5737&#x00A0;TEST-NET
    224.0.0.0/4&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;Multicast&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;RFC&#x00A0;3171&#x00A0;MULTICAST
    240.0.0.0/4&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;Reserved&#x00A0;for&#x00A0;Future&#x00A0;Use&#x00A0;&#x00A0;&#x00A0;&#x00A0;RFC&#x00A0;1112&#x00A0;RESERVED
    255.255.255.255/32&#x00A0;&#x00A0;Limited&#x00A0;Broadcast&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;RFC&#x00A0;919&#x00A0;&#x00A0;BROADCAST
    &#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;RFC&#x00A0;922</p>
</section>
<section class="Ss">
<h2 class="Ss" id="ip_iptypev6"><a class="permalink" href="#ip_iptypev6">ip_iptypev6</a></h2>
Return the type of an IPv6 address.
<p class="Pp"><span class="Li"></span></p>
<pre>
    Params:  binary ip
    Returns: type as of the following table or undef (invalid)
</pre>
<p class="Pp">See IANA Internet Protocol Version 6 Address Space
    &lt;http://www.iana.org/assignments/ipv6-address-space/ipv6-address-space.txt&gt;
    and IANA IPv6 Special Purpose Address Registry
    &lt;http://www.iana.org/assignments/iana-ipv6-special-registry/iana-ipv6-special-registry.txt&gt;</p>
<p class="Pp">Prefix&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;Allocation&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;Reference
    -------------------------------------------------------------
    0000::/8&#x00A0;&#x00A0;&#x00A0;&#x00A0;Reserved&#x00A0;by&#x00A0;IETF&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;[RFC4291]&#x00A0;RESERVED
    0100::/8&#x00A0;&#x00A0;&#x00A0;&#x00A0;Reserved&#x00A0;by&#x00A0;IETF&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;[RFC4291]&#x00A0;RESERVED
    0200::/7&#x00A0;&#x00A0;&#x00A0;&#x00A0;Reserved&#x00A0;by&#x00A0;IETF&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;[RFC4048]&#x00A0;RESERVED
    0400::/6&#x00A0;&#x00A0;&#x00A0;&#x00A0;Reserved&#x00A0;by&#x00A0;IETF&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;[RFC4291]&#x00A0;RESERVED
    0800::/5&#x00A0;&#x00A0;&#x00A0;&#x00A0;Reserved&#x00A0;by&#x00A0;IETF&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;[RFC4291]&#x00A0;RESERVED
    1000::/4&#x00A0;&#x00A0;&#x00A0;&#x00A0;Reserved&#x00A0;by&#x00A0;IETF&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;[RFC4291]&#x00A0;RESERVED
    2000::/3&#x00A0;&#x00A0;&#x00A0;&#x00A0;Global&#x00A0;Unicast&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;[RFC4291]&#x00A0;GLOBAL-UNICAST
    4000::/3&#x00A0;&#x00A0;&#x00A0;&#x00A0;Reserved&#x00A0;by&#x00A0;IETF&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;[RFC4291]&#x00A0;RESERVED
    6000::/3&#x00A0;&#x00A0;&#x00A0;&#x00A0;Reserved&#x00A0;by&#x00A0;IETF&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;[RFC4291]&#x00A0;RESERVED
    8000::/3&#x00A0;&#x00A0;&#x00A0;&#x00A0;Reserved&#x00A0;by&#x00A0;IETF&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;[RFC4291]&#x00A0;RESERVED
    A000::/3&#x00A0;&#x00A0;&#x00A0;&#x00A0;Reserved&#x00A0;by&#x00A0;IETF&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;[RFC4291]&#x00A0;RESERVED
    C000::/3&#x00A0;&#x00A0;&#x00A0;&#x00A0;Reserved&#x00A0;by&#x00A0;IETF&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;[RFC4291]&#x00A0;RESERVED
    E000::/4&#x00A0;&#x00A0;&#x00A0;&#x00A0;Reserved&#x00A0;by&#x00A0;IETF&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;[RFC4291]&#x00A0;RESERVED
    F000::/5&#x00A0;&#x00A0;&#x00A0;&#x00A0;Reserved&#x00A0;by&#x00A0;IETF&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;[RFC4291]&#x00A0;RESERVED
    F800::/6&#x00A0;&#x00A0;&#x00A0;&#x00A0;Reserved&#x00A0;by&#x00A0;IETF&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;[RFC4291]&#x00A0;RESERVED
    FC00::/7&#x00A0;&#x00A0;&#x00A0;&#x00A0;Unique&#x00A0;Local&#x00A0;Unicast&#x00A0;[RFC4193]&#x00A0;UNIQUE-LOCAL-UNICAST
    FE00::/9&#x00A0;&#x00A0;&#x00A0;&#x00A0;Reserved&#x00A0;by&#x00A0;IETF&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;[RFC4291]&#x00A0;RESERVED
    FE80::/10&#x00A0;&#x00A0;&#x00A0;Link&#x00A0;Local&#x00A0;Unicast&#x00A0;&#x00A0;&#x00A0;[RFC4291]&#x00A0;LINK-LOCAL-UNICAST
    FEC0::/10&#x00A0;&#x00A0;&#x00A0;Reserved&#x00A0;by&#x00A0;IETF&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;[RFC3879]&#x00A0;RESERVED
    FF00::/8&#x00A0;&#x00A0;&#x00A0;&#x00A0;Multicast&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;[RFC4291]&#x00A0;MULTICAST</p>
<p class="Pp">Prefix&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;Assignment&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;Reference
    ---------------------------------------------------------------------
    ::1/128&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;Loopback&#x00A0;Address&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;[RFC4291]&#x00A0;UNSPECIFIED
    ::/128&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;Unspecified&#x00A0;Address&#x00A0;&#x00A0;&#x00A0;[RFC4291]&#x00A0;LOOPBACK
    ::FFFF:0:0/96&#x00A0;&#x00A0;&#x00A0;IPv4-mapped&#x00A0;Address&#x00A0;&#x00A0;&#x00A0;[RFC4291]&#x00A0;IPV4MAP
    0100::/64&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;Discard-Only&#x00A0;Prefix&#x00A0;&#x00A0;&#x00A0;[RFC6666]&#x00A0;DISCARD
    2001:0000::/32&#x00A0;&#x00A0;TEREDO&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;[RFC4380]&#x00A0;TEREDO
    2001:0002::/48&#x00A0;&#x00A0;BMWG&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;[RFC5180]&#x00A0;BMWG
    2001:db8::/32&#x00A0;&#x00A0;&#x00A0;Documentation&#x00A0;Prefix&#x00A0;&#x00A0;[RFC3849]&#x00A0;DOCUMENTATION
    2001:10::/28&#x00A0;&#x00A0;&#x00A0;&#x00A0;ORCHID&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;[RFC4843]&#x00A0;ORCHID
    2002::/16&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;6to4&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;[RFC3056]&#x00A0;6TO4
    FC00::/7&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;Unique-Local&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;[RFC4193]&#x00A0;UNIQUE-LOCAL-UNICAST
    FE80::/10&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;Linked-Scoped&#x00A0;Unicast&#x00A0;[RFC4291]&#x00A0;LINK-LOCAL-UNICAST
    FF00::/8&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;Multicast&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;[RFC4291]&#x00A0;MULTICAST</p>
</section>
<section class="Ss">
<h2 class="Ss" id="ip_iptype"><a class="permalink" href="#ip_iptype">ip_iptype</a></h2>
Return the type of an IP (Public, Private, Reserved)
<p class="Pp"><span class="Li"></span></p>
<pre>
    Params  : Binary IP to test, IP version (defaults to 6)
    Returns : type (see ip_iptypev4 and ip_iptypev6 for details) or undef (invalid)
</pre>
<p class="Pp"><span class="Li">&quot;$type = ip_iptype ($ip);&quot;</span></p>
</section>
<section class="Ss">
<h2 class="Ss" id="ip_check_prefix"><a class="permalink" href="#ip_check_prefix">ip_check_prefix</a></h2>
Check the validity of a prefix
<p class="Pp"><span class="Li"></span></p>
<pre>
    Params  : binary IP, length of prefix, IP version
    Returns : 1 or undef (invalid)
</pre>
<p class="Pp">Checks if the variant part of a prefix only has 0s, and the length
    is correct.</p>
<p class="Pp"><span class="Li">&quot;ip_check_prefix ($ip,$len,$ipv) or do
    {};&quot;</span></p>
</section>
<section class="Ss">
<h2 class="Ss" id="ip_reverse"><a class="permalink" href="#ip_reverse">ip_reverse</a></h2>
Get a reverse name from a prefix
<p class="Pp"><span class="Li"></span></p>
<pre>
    Params  : IP, length of prefix, IP version
    Returns : Reverse name or undef (error)
</pre>
<p class="Pp"><span class="Li">&quot;$reverse = ip_reverse
  ($ip);&quot;</span></p>
</section>
<section class="Ss">
<h2 class="Ss" id="ip_normalize"><a class="permalink" href="#ip_normalize">ip_normalize</a></h2>
Normalize data to a range/prefix of IP addresses
<p class="Pp"><span class="Li"></span></p>
<pre>
    Params  : Data String (Single IP, Range, Prefix)
    Returns : ip1, ip2 (if range/prefix) or undef (error)
</pre>
<p class="Pp"><span class="Li">&quot;($ip1,$ip2) = ip_normalize
    ($data);&quot;</span></p>
</section>
<section class="Ss">
<h2 class="Ss" id="ip_auth"><a class="permalink" href="#ip_auth">ip_auth</a></h2>
Return IP authority information from the IP::Authority module
<p class="Pp"><span class="Li"></span></p>
<pre>
    Params  : IP, version
    Returns : Auth info (RI for RIPE, AR for ARIN, etc)
</pre>
<p class="Pp"><span class="Li">&quot;$auth = ip_auth ($ip,4);&quot;</span></p>
<p class="Pp">Note: IPv4 only</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="BUGS"><a class="permalink" href="#BUGS">BUGS</a></h1>
The Math::BigInt library is needed for functions that use integers. These are
  ip_inttobin, ip_bintoint, and the size method. In a next version, Math::BigInt
  will become optionnal.
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHORS"><a class="permalink" href="#AUTHORS">AUTHORS</a></h1>
Manuel Valente &lt;manuel.valente@gmail.com&gt;.
<p class="Pp">Original IPv4 code by Monica Cortes Sack
  &lt;mcortes@ripe.net&gt;.</p>
<p class="Pp">Original IPv6 code by Lee Wilmot &lt;lee@ripe.net&gt;.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="BASED_ON"><a class="permalink" href="#BASED_ON">BASED
  ON</a></h1>
ipv4pack.pm, iplib.pm, iplibncc.pm.
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<b>perl</b>(1), IP::Authority
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2012-11-28</td>
    <td class="foot-os">perl v5.30.2</td>
  </tr>
</table>
</body>
</html>
