<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    .Nd, .Bf, .Op { display: inline; }
    .Pa, .Ad { font-style: italic; }
    .Ms { font-weight: bold; }
    .Bl-diag > dt { font-weight: bold; }
    code.Nm, .Fl, .Cm, .Ic, code.In, .Fd, .Fn, .Cd { font-weight: bold;
      font-family: inherit; }
  </style>
  <title>XML::Simple(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">XML::Simple(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">XML::Simple(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">XML::Simple - An API for simple XML files</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<p class="Pp">PLEASE DO NOT USE THIS MODULE IN NEW CODE. If you ignore this
    warning and use it anyway, the
    <span class="Li">&quot;qw(:strict)&quot;</span> mode will save you a little
    pain.</p>
<p class="Pp"></p>
<pre>    use XML::Simple qw(:strict);
    my $ref = XMLin([&lt;xml file or string&gt;] [, &lt;options&gt;]);
    my $xml = XMLout($hashref [, &lt;options&gt;]);
</pre>
<p class="Pp">Or the object oriented way:</p>
<p class="Pp"></p>
<pre>    require XML::Simple qw(:strict);
    my $xs = XML::Simple-&gt;new([&lt;options&gt;]);
    my $ref = $xs-&gt;XMLin([&lt;xml file or string&gt;] [, &lt;options&gt;]);
    my $xml = $xs-&gt;XMLout($hashref [, &lt;options&gt;]);
</pre>
<p class="Pp">(or see &quot;SAX SUPPORT&quot; for 'the SAX way').</p>
<p class="Pp">Note, in these examples, the square brackets are used to denote
    optional items not to imply items should be supplied in arrayrefs.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="STATUS_OF_THIS_MODULE"><a class="permalink" href="#STATUS_OF_THIS_MODULE">STATUS
  OF THIS MODULE</a></h1>
<p class="Pp">The use of this module in new code is <b>strongly discouraged</b>.
    Other modules are available which provide more straightforward and
    consistent interfaces. In particular, XML::LibXML is highly recommended and
    you can refer to Perl XML::LibXML by Example
    &lt;http://grantm.github.io/perl-libxml-by-example/&gt; for a tutorial
    introduction.</p>
<p class="Pp">XML::Twig is another excellent alternative.</p>
<p class="Pp">The major problems with this module are the large number of
    options (some of which have unfortunate defaults) and the arbitrary ways in
    which these options interact - often producing unexpected results.</p>
<p class="Pp">Patches with bug fixes and documentation fixes are welcome, but
    new features are unlikely to be added.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="QUICK_START"><a class="permalink" href="#QUICK_START">QUICK
  START</a></h1>
<p class="Pp">Say you have a script called <b>foo</b> and a file of
    configuration options called <b>foo.xml</b> containing the following:</p>
<p class="Pp"></p>
<pre>  &lt;config logdir=&quot;/var/log/foo/&quot; debugfile=&quot;/tmp/foo.debug&quot;&gt;
    &lt;server name=&quot;sahara&quot; osname=&quot;solaris&quot; osversion=&quot;2.6&quot;&gt;
      &lt;address&gt;10.0.0.101&lt;/address&gt;
      &lt;address&gt;10.0.1.101&lt;/address&gt;
    &lt;/server&gt;
    &lt;server name=&quot;gobi&quot; osname=&quot;irix&quot; osversion=&quot;6.5&quot;&gt;
      &lt;address&gt;10.0.0.102&lt;/address&gt;
    &lt;/server&gt;
    &lt;server name=&quot;kalahari&quot; osname=&quot;linux&quot; osversion=&quot;2.0.34&quot;&gt;
      &lt;address&gt;10.0.0.103&lt;/address&gt;
      &lt;address&gt;10.0.1.103&lt;/address&gt;
    &lt;/server&gt;
  &lt;/config&gt;
</pre>
<p class="Pp">The following lines of code in <b>foo</b>:</p>
<p class="Pp"></p>
<pre>  use XML::Simple qw(:strict);
  my $config = XMLin(undef, KeyAttr =&gt; { server =&gt; 'name' }, ForceArray =&gt; [ 'server', 'address' ]);
</pre>
<p class="Pp">will 'slurp' the configuration options into the hashref
    <span class="Li">$config</span> (because no filename or XML string was
    passed as the first argument to <span class="Li">&quot;XMLin()&quot;</span>
    the name and location of the XML file will be inferred from name and
    location of the script). You can dump out the contents of the hashref using
    Data::Dumper:</p>
<p class="Pp"></p>
<pre>  use Data::Dumper;
  print Dumper($config);
</pre>
<p class="Pp">which will produce something like this (formatting has been
    adjusted for brevity):</p>
<p class="Pp"></p>
<pre>  {
      'logdir'        =&gt; '/var/log/foo/',
      'debugfile'     =&gt; '/tmp/foo.debug',
      'server'        =&gt; {
          'sahara'        =&gt; {
              'osversion'     =&gt; '2.6',
              'osname'        =&gt; 'solaris',
              'address'       =&gt; [ '10.0.0.101', '10.0.1.101' ]
          },
          'gobi'          =&gt; {
              'osversion'     =&gt; '6.5',
              'osname'        =&gt; 'irix',
              'address'       =&gt; [ '10.0.0.102' ]
          },
          'kalahari'      =&gt; {
              'osversion'     =&gt; '2.0.34',
              'osname'        =&gt; 'linux',
              'address'       =&gt; [ '10.0.0.103', '10.0.1.103' ]
          }
      }
  }
</pre>
<p class="Pp">Your script could then access the name of the log directory like
    this:</p>
<p class="Pp"></p>
<pre>  print $config-&gt;{logdir};
</pre>
<p class="Pp">similarly, the second address on the server 'kalahari' could be
    referenced as:</p>
<p class="Pp"></p>
<pre>  print $config-&gt;{server}-&gt;{kalahari}-&gt;{address}-&gt;[1];
</pre>
<p class="Pp">Note: If the mapping between the output of Data::Dumper and the
    print statements above is not obvious to you, then please refer to the
    'references' tutorial (AKA: &quot;Mark's very short tutorial about
    references&quot;) at perlreftut.</p>
<p class="Pp">In this example, the
    <span class="Li">&quot;ForceArray&quot;</span> option was used to list
    elements that might occur multiple times and should therefore be represented
    as arrayrefs (even when only one element is present).</p>
<p class="Pp">The <span class="Li">&quot;KeyAttr&quot;</span> option was used to
    indicate that each <span class="Li">&quot;&lt;server&gt;&quot;</span>
    element has a unique identifier in the
    <span class="Li">&quot;name&quot;</span> attribute. This allows you to index
    directly to a particular server record using the name as a hash key (as
    shown above).</p>
<p class="Pp">For simple requirements, that's really all there is to it. If you
    want to store your XML in a different directory or file, or pass it in as a
    string or even pass it in via some derivative of an IO::Handle, you'll need
    to check out &quot;OPTIONS&quot;. If you want to turn off or tweak the array
    folding feature (that neat little transformation that produced
    <span class="Li">$config</span>-&gt;{server}) you'll find options for that
    as well.</p>
<p class="Pp">If you want to generate XML (for example to write a modified
    version of <span class="Li">$config</span> back out as XML), check out
    <span class="Li">&quot;XMLout()&quot;</span>.</p>
<p class="Pp">If your needs are not so simple, this may not be the module for
    you. In that case, you might want to read &quot;WHERE TO FROM
  HERE?&quot;.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">The XML::Simple module provides a simple API layer on top of an
    underlying XML parsing module (either XML::Parser or one of the SAX2 parser
    modules). Two functions are exported:
    <span class="Li">&quot;XMLin()&quot;</span> and
    <span class="Li">&quot;XMLout()&quot;</span>. Note: you can explicitly
    request the lower case versions of the function names:
    <span class="Li">&quot;xml_in()&quot;</span> and
    <span class="Li">&quot;xml_out()&quot;</span>.</p>
<p class="Pp">The simplest approach is to call these two functions directly, but
    an optional object oriented interface (see &quot;OPTIONAL OO INTERFACE&quot;
    below) allows them to be called as methods of an <b>XML::Simple</b> object.
    The object interface can also be used at either end of a SAX pipeline.</p>
<section class="Ss">
<h2 class="Ss"><b>XMLin()</b></h2>
<p class="Pp">Parses XML formatted data and returns a reference to a data
    structure which contains the same information in a more readily accessible
    form. (Skip down to &quot;EXAMPLES&quot; below, for more sample code).</p>
<p class="Pp"><span class="Li">&quot;XMLin()&quot;</span> accepts an optional
    XML specifier followed by zero or more 'name =&gt; value' option pairs. The
    XML specifier can be one of the following:</p>
<dl class="Bl-tag">
  <dt id="A"><a class="permalink" href="#A">A filename</a></dt>
  <dd>If the filename contains no directory components
      <span class="Li">&quot;XMLin()&quot;</span> will look for the file in each
      directory in the SearchPath (see &quot;OPTIONS&quot; below) or in the
      current directory if the SearchPath option is not defined. eg:
    <p class="Pp"></p>
    <pre>  $ref = XMLin('/etc/params.xml');
    </pre>
    <p class="Pp">Note, the filename '-' can be used to parse from STDIN.</p>
  </dd>
  <dt id="undef"><a class="permalink" href="#undef">undef</a></dt>
  <dd>If there is no XML specifier, <span class="Li">&quot;XMLin()&quot;</span>
      will check the script directory and each of the SearchPath directories for
      a file with the same name as the script but with the extension '.xml'.
      Note: if you wish to specify options, you must specify the value 'undef'.
      eg:
    <p class="Pp"></p>
    <pre>  $ref = XMLin(undef, ForceArray =&gt; 1);
    </pre>
  </dd>
  <dt id="A~2"><a class="permalink" href="#A~2">A string of XML</a></dt>
  <dd>A string containing XML (recognised by the presence of '&lt;' and '&gt;'
      characters) will be parsed directly. eg:
    <p class="Pp"></p>
    <pre>  $ref = XMLin('&lt;opt username=&quot;bob&quot; password=&quot;flurp&quot; /&gt;');
    </pre>
  </dd>
  <dt id="An"><a class="permalink" href="#An">An IO::Handle object</a></dt>
  <dd>An IO::Handle object will be read to EOF and its contents parsed. eg:
    <p class="Pp"></p>
    <pre>  $fh = IO::File-&gt;new('/etc/params.xml');
  $ref = XMLin($fh);
    </pre>
  </dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss"><b>XMLout()</b></h2>
<p class="Pp">Takes a data structure (generally a hashref) and returns an XML
    encoding of that structure. If the resulting XML is parsed using
    <span class="Li">&quot;XMLin()&quot;</span>, it should return a data
    structure equivalent to the original (see caveats below).</p>
<p class="Pp">The <span class="Li">&quot;XMLout()&quot;</span> function can also
    be used to output the XML as SAX events see the
    <span class="Li">&quot;Handler&quot;</span> option and &quot;SAX
    SUPPORT&quot; for more details).</p>
<p class="Pp">When translating hashes to XML, hash keys which have a leading '-'
    will be silently skipped. This is the approved method for marking elements
    of a data structure which should be ignored by
    <span class="Li">&quot;XMLout&quot;</span>. (Note: If these items were not
    skipped the key names would be emitted as element or attribute names with a
    leading '-' which would not be valid XML).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Caveats"><a class="permalink" href="#Caveats">Caveats</a></h2>
<p class="Pp">Some care is required in creating data structures which will be
    passed to <span class="Li">&quot;XMLout()&quot;</span>. Hash keys from the
    data structure will be encoded as either XML element names or attribute
    names. Therefore, you should use hash key names which conform to the
    relatively strict XML naming rules:</p>
<p class="Pp">Names in XML must begin with a letter. The remaining characters
    may be letters, digits, hyphens (-), underscores (_) or full stops (.). It
    is also allowable to include one colon (:) in an element name but this
    should only be used when working with namespaces (<b>XML::Simple</b> can
    only usefully work with namespaces when teamed with a SAX Parser).</p>
<p class="Pp">You can use other punctuation characters in hash values (just not
    in hash keys) however <b>XML::Simple</b> does not support dumping binary
    data.</p>
<p class="Pp">If you break these rules, the current implementation of
    <span class="Li">&quot;XMLout()&quot;</span> will simply emit non-compliant
    XML which will be rejected if you try to read it back in. (A later version
    of <b>XML::Simple</b> might take a more proactive approach).</p>
<p class="Pp">Note also that although you can nest hashes and arrays to
    arbitrary levels, circular data structures are not supported and will cause
    <span class="Li">&quot;XMLout()&quot;</span> to die.</p>
<p class="Pp">If you wish to 'round-trip' arbitrary data structures from Perl to
    XML and back to Perl, then you should probably disable array folding (using
    the KeyAttr option) both with <span class="Li">&quot;XMLout()&quot;</span>
    and with <span class="Li">&quot;XMLin()&quot;</span>. If you still don't get
    the expected results, you may prefer to use XML::Dumper which is designed
    for exactly that purpose.</p>
<p class="Pp">Refer to &quot;WHERE TO FROM HERE?&quot; if
    <span class="Li">&quot;XMLout()&quot;</span> is too simple for your
  needs.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="OPTIONS"><a class="permalink" href="#OPTIONS">OPTIONS</a></h1>
<p class="Pp"><b>XML::Simple</b> supports a number of options (in fact as each
    release of <b>XML::Simple</b> adds more options, the module's claim to the
    name 'Simple' becomes increasingly tenuous). If you find yourself repeatedly
    having to specify the same options, you might like to investigate
    &quot;OPTIONAL OO INTERFACE&quot; below.</p>
<p class="Pp">If you can't be bothered reading the documentation, refer to
    &quot;STRICT MODE&quot; to automatically catch common mistakes.</p>
<p class="Pp">Because there are so many options, it's hard for new users to know
    which ones are important, so here are the two you really need to know
  about:</p>
<ul class="Bl-bullet">
  <li>check out <span class="Li">&quot;ForceArray&quot;</span> because you'll
      almost certainly want to turn it on</li>
  <li>make sure you know what the <span class="Li">&quot;KeyAttr&quot;</span>
      option does and what its default value is because it may surprise you
      otherwise (note in particular that 'KeyAttr' affects both
      <span class="Li">&quot;XMLin&quot;</span> and
      <span class="Li">&quot;XMLout&quot;</span>)</li>
</ul>
<p class="Pp">The option name headings below have a trailing 'comment' - a hash
    followed by two pieces of metadata:</p>
<ul class="Bl-bullet">
  <li>Options are marked with '<i>in</i>' if they are recognised by
      <span class="Li">&quot;XMLin()&quot;</span> and '<i>out</i>' if they are
      recognised by <span class="Li">&quot;XMLout()&quot;</span>.</li>
  <li>Each option is also flagged to indicate whether it is:
    <p class="Pp"></p>
    <pre> 'important'   - don't use the module until you understand this one
 'handy'       - you can skip this on the first time through
 'advanced'    - you can skip this on the second time through
 'SAX only'    - don't worry about this unless you're using SAX (or
                 alternatively if you need this, you also need SAX)
 'seldom used' - you'll probably never use this unless you were the
                 person that requested the feature
    </pre>
  </li>
</ul>
<p class="Pp">The options are listed alphabetically:</p>
<p class="Pp">Note: option names are no longer case sensitive so you can use the
    mixed case versions shown here; all lower case as required by versions 2.03
    and earlier; or you can add underscores between the words (eg:
  key_attr).</p>
<section class="Ss">
<h2 class="Ss" id="AttrIndent_=__1_"><a class="permalink" href="#AttrIndent_=__1_">AttrIndent
  =&gt; 1 <i># out - handy</i></a></h2>
<p class="Pp">When you are using <span class="Li">&quot;XMLout()&quot;</span>,
    enable this option to have attributes printed one-per-line with sensible
    indentation rather than all on one line.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Cache_=____cache_schemes___"><a class="permalink" href="#Cache_=____cache_schemes___">Cache
  =&gt; [ cache schemes ] <i># in - advanced</i></a></h2>
<p class="Pp">Because loading the <b>XML::Parser</b> module and parsing an XML
    file can consume a significant number of CPU cycles, it is often desirable
    to cache the output of <span class="Li">&quot;XMLin()&quot;</span> for later
    reuse.</p>
<p class="Pp">When parsing from a named file, <b>XML::Simple</b> supports a
    number of caching schemes. The 'Cache' option may be used to specify one or
    more schemes (using an anonymous array). Each scheme will be tried in turn
    in the hope of finding a cached pre-parsed representation of the XML file.
    If no cached copy is found, the file will be parsed and the first cache
    scheme in the list will be used to save a copy of the results. The following
    cache schemes have been implemented:</p>
<dl class="Bl-tag">
  <dt id="storable"><a class="permalink" href="#storable">storable</a></dt>
  <dd>Utilises <b>Storable.pm</b> to read/write a cache file with the same name
      as the XML file but with the extension .stor</dd>
  <dt id="memshare"><a class="permalink" href="#memshare">memshare</a></dt>
  <dd>When a file is first parsed, a copy of the resulting data structure is
      retained in memory in the <b>XML::Simple</b> module's namespace.
      Subsequent calls to parse the same file will return a reference to this
      structure. This cached version will persist only for the life of the Perl
      interpreter (which in the case of mod_perl for example, may be some
      significant time).
    <p class="Pp">Because each caller receives a reference to the same data
        structure, a change made by one caller will be visible to all. For this
        reason, the reference returned should be treated as read-only.</p>
  </dd>
  <dt id="memcopy"><a class="permalink" href="#memcopy">memcopy</a></dt>
  <dd>This scheme works identically to 'memshare' (above) except that each
      caller receives a reference to a new data structure which is a copy of the
      cached version. Copying the data structure will add a little processing
      overhead, therefore this scheme should only be used where the caller
      intends to modify the data structure (or wishes to protect itself from
      others who might). This scheme uses <b>Storable.pm</b> to perform the
      copy.</dd>
</dl>
<p class="Pp">Warning! The memory-based caching schemes compare the timestamp on
    the file to the time when it was last parsed. If the file is stored on an
    NFS filesystem (or other network share) and the clock on the file server is
    not exactly synchronised with the clock where your script is run, updates to
    the source XML file may appear to be ignored.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="ContentKey_=__'keyname'_"><a class="permalink" href="#ContentKey_=__'keyname'_">ContentKey
  =&gt; 'keyname' <i># in+out - seldom used</i></a></h2>
<p class="Pp">When text content is parsed to a hash value, this option lets you
    specify a name for the hash key to override the default 'content'. So for
    example:</p>
<p class="Pp"></p>
<pre>  XMLin('&lt;opt one=&quot;1&quot;&gt;Text&lt;/opt&gt;', ContentKey =&gt; 'text')
</pre>
<p class="Pp">will parse to:</p>
<p class="Pp"></p>
<pre>  { 'one' =&gt; 1, 'text' =&gt; 'Text' }
</pre>
<p class="Pp">instead of:</p>
<p class="Pp"></p>
<pre>  { 'one' =&gt; 1, 'content' =&gt; 'Text' }
</pre>
<p class="Pp"><span class="Li">&quot;XMLout()&quot;</span> will also honour the
    value of this option when converting a hashref to XML.</p>
<p class="Pp">You can also prefix your selected key name with a '-' character to
    have <span class="Li">&quot;XMLin()&quot;</span> try a little harder to
    eliminate unnecessary 'content' keys after array folding. For example:</p>
<p class="Pp"></p>
<pre>  XMLin(
    '&lt;opt&gt;&lt;item name=&quot;one&quot;&gt;First&lt;/item&gt;&lt;item name=&quot;two&quot;&gt;Second&lt;/item&gt;&lt;/opt&gt;',
    KeyAttr =&gt; {item =&gt; 'name'},
    ForceArray =&gt; [ 'item' ],
    ContentKey =&gt; '-content'
  )
</pre>
<p class="Pp">will parse to:</p>
<p class="Pp"></p>
<pre>  {
    'item' =&gt; {
      'one' =&gt;  'First'
      'two' =&gt;  'Second'
    }
  }
</pre>
<p class="Pp">rather than this (without the '-'):</p>
<p class="Pp"></p>
<pre>  {
    'item' =&gt; {
      'one' =&gt; { 'content' =&gt; 'First' }
      'two' =&gt; { 'content' =&gt; 'Second' }
    }
  }
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="DataHandler_=__code_ref_"><a class="permalink" href="#DataHandler_=__code_ref_">DataHandler
  =&gt; code_ref <i># in - SAX only</i></a></h2>
<p class="Pp">When you use an <b>XML::Simple</b> object as a SAX handler, it
    will return a 'simple tree' data structure in the same format as
    <span class="Li">&quot;XMLin()&quot;</span> would return. If this option is
    set (to a subroutine reference), then when the tree is built the subroutine
    will be called and passed two arguments: a reference to the
    <b>XML::Simple</b> object and a reference to the data tree. The return value
    from the subroutine will be returned to the SAX driver. (See &quot;SAX
    SUPPORT&quot; for more details).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="ForceArray_=__1_"><a class="permalink" href="#ForceArray_=__1_">ForceArray
  =&gt; 1 <i># in - important</i></a></h2>
<p class="Pp">This option should be set to '1' to force nested elements to be
    represented as arrays even when there is only one. Eg, with ForceArray
    enabled, this XML:</p>
<p class="Pp"></p>
<pre>    &lt;opt&gt;
      &lt;name&gt;value&lt;/name&gt;
    &lt;/opt&gt;
</pre>
<p class="Pp">would parse to this:</p>
<p class="Pp"></p>
<pre>    {
      'name' =&gt; [
                  'value'
                ]
    }
</pre>
<p class="Pp">instead of this (the default):</p>
<p class="Pp"></p>
<pre>    {
      'name' =&gt; 'value'
    }
</pre>
<p class="Pp">This option is especially useful if the data structure is likely
    to be written back out as XML and the default behaviour of rolling single
    nested elements up into attributes is not desirable.</p>
<p class="Pp">If you are using the array folding feature, you should almost
    certainly enable this option. If you do not, single nested elements will not
    be parsed to arrays and therefore will not be candidates for folding to a
    hash. (Given that the default value of 'KeyAttr' enables array folding, the
    default value of this option should probably also have been enabled too -
    sorry).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="ForceArray_=____names___"><a class="permalink" href="#ForceArray_=____names___">ForceArray
  =&gt; [ names ] <i># in - important</i></a></h2>
<p class="Pp">This alternative (and preferred) form of the 'ForceArray' option
    allows you to specify a list of element names which should always be forced
    into an array representation, rather than the 'all or nothing' approach
    above.</p>
<p class="Pp">It is also possible (since version 2.05) to include compiled
    regular expressions in the list - any element names which match the pattern
    will be forced to arrays. If the list contains only a single regex, then it
    is not necessary to enclose it in an arrayref. Eg:</p>
<p class="Pp"></p>
<pre>  ForceArray =&gt; qr/_list$/
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="ForceContent_=__1_"><a class="permalink" href="#ForceContent_=__1_">ForceContent
  =&gt; 1 <i># in - seldom used</i></a></h2>
<p class="Pp">When <span class="Li">&quot;XMLin()&quot;</span> parses elements
    which have text content as well as attributes, the text content must be
    represented as a hash value rather than a simple scalar. This option allows
    you to force text content to always parse to a hash value even when there
    are no attributes. So for example:</p>
<p class="Pp"></p>
<pre>  XMLin('&lt;opt&gt;&lt;x&gt;text1&lt;/x&gt;&lt;y a=&quot;2&quot;&gt;text2&lt;/y&gt;&lt;/opt&gt;', ForceContent =&gt; 1)
</pre>
<p class="Pp">will parse to:</p>
<p class="Pp"></p>
<pre>  {
    'x' =&gt; {           'content' =&gt; 'text1' },
    'y' =&gt; { 'a' =&gt; 2, 'content' =&gt; 'text2' }
  }
</pre>
<p class="Pp">instead of:</p>
<p class="Pp"></p>
<pre>  {
    'x' =&gt; 'text1',
    'y' =&gt; { 'a' =&gt; 2, 'content' =&gt; 'text2' }
  }
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="GroupTags_=____grouping_tag_=__grouped_tag___"><a class="permalink" href="#GroupTags_=____grouping_tag_=__grouped_tag___">GroupTags
  =&gt; { grouping tag =&gt; grouped tag } <i># in+out - handy</i></a></h2>
<p class="Pp">You can use this option to eliminate extra levels of indirection
    in your Perl data structure. For example this XML:</p>
<p class="Pp"></p>
<pre>  &lt;opt&gt;
   &lt;searchpath&gt;
     &lt;dir&gt;/usr/bin&lt;/dir&gt;
     &lt;dir&gt;/usr/local/bin&lt;/dir&gt;
     &lt;dir&gt;/usr/X11/bin&lt;/dir&gt;
   &lt;/searchpath&gt;
 &lt;/opt&gt;
</pre>
<p class="Pp">Would normally be read into a structure like this:</p>
<p class="Pp"></p>
<pre>  {
    searchpath =&gt; {
                    dir =&gt; [ '/usr/bin', '/usr/local/bin', '/usr/X11/bin' ]
                  }
  }
</pre>
<p class="Pp">But when read in with the appropriate value for 'GroupTags':</p>
<p class="Pp"></p>
<pre>  my $opt = XMLin($xml, GroupTags =&gt; { searchpath =&gt; 'dir' });
</pre>
<p class="Pp">It will return this simpler structure:</p>
<p class="Pp"></p>
<pre>  {
    searchpath =&gt; [ '/usr/bin', '/usr/local/bin', '/usr/X11/bin' ]
  }
</pre>
<p class="Pp">The grouping element
    (<span class="Li">&quot;&lt;searchpath&gt;&quot;</span> in the example) must
    not contain any attributes or elements other than the grouped element.</p>
<p class="Pp">You can specify multiple 'grouping element' to 'grouped element'
    mappings in the same hashref. If this option is combined with
    <span class="Li">&quot;KeyAttr&quot;</span>, the array folding will occur
    first and then the grouped element names will be eliminated.</p>
<p class="Pp"><span class="Li">&quot;XMLout&quot;</span> will also use the
    grouptag mappings to re-introduce the tags around the grouped elements.
    Beware though that this will occur in all places that the 'grouping tag'
    name occurs - you probably don't want to use the same name for elements as
    well as attributes.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Handler_=__object_ref_"><a class="permalink" href="#Handler_=__object_ref_">Handler
  =&gt; object_ref <i># out - SAX only</i></a></h2>
<p class="Pp">Use the 'Handler' option to have
    <span class="Li">&quot;XMLout()&quot;</span> generate SAX events rather than
    returning a string of XML. For more details see &quot;SAX SUPPORT&quot;
    below.</p>
<p class="Pp">Note: the current implementation of this option generates a string
    of XML and uses a SAX parser to translate it into SAX events. The normal
    encoding rules apply here - your data must be UTF8 encoded unless you
    specify an alternative encoding via the 'XMLDecl' option; and by the time
    the data reaches the handler object, it will be in UTF8 form regardless of
    the encoding you supply. A future implementation of this option may generate
    the events directly.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="KeepRoot_=__1_"><a class="permalink" href="#KeepRoot_=__1_">KeepRoot
  =&gt; 1 <i># in+out - handy</i></a></h2>
<p class="Pp">In its attempt to return a data structure free of superfluous
    detail and unnecessary levels of indirection,
    <span class="Li">&quot;XMLin()&quot;</span> normally discards the root
    element name. Setting the 'KeepRoot' option to '1' will cause the root
    element name to be retained. So after executing this code:</p>
<p class="Pp"></p>
<pre>  $config = XMLin('&lt;config tempdir=&quot;/tmp&quot; /&gt;', KeepRoot =&gt; 1)
</pre>
<p class="Pp">You'll be able to reference the tempdir as
    <span class="Li">&quot;$config-&gt;{config}-&gt;{tempdir}&quot;</span>
    instead of the default
    <span class="Li">&quot;$config-&gt;{tempdir}&quot;</span>.</p>
<p class="Pp">Similarly, setting the 'KeepRoot' option to '1' will tell
    <span class="Li">&quot;XMLout()&quot;</span> that the data structure already
    contains a root element name and it is not necessary to add another.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="KeyAttr_=____list___"><a class="permalink" href="#KeyAttr_=____list___">KeyAttr
  =&gt; [ list ] <i># in+out - important</i></a></h2>
<p class="Pp">This option controls the 'array folding' feature which translates
    nested elements from an array to a hash. It also controls the 'unfolding' of
    hashes to arrays.</p>
<p class="Pp">For example, this XML:</p>
<p class="Pp"></p>
<pre>    &lt;opt&gt;
      &lt;user login=&quot;grep&quot; fullname=&quot;Gary R Epstein&quot; /&gt;
      &lt;user login=&quot;stty&quot; fullname=&quot;Simon T Tyson&quot; /&gt;
    &lt;/opt&gt;
</pre>
<p class="Pp">would, by default, parse to this:</p>
<p class="Pp"></p>
<pre>    {
      'user' =&gt; [
                  {
                    'login' =&gt; 'grep',
                    'fullname' =&gt; 'Gary R Epstein'
                  },
                  {
                    'login' =&gt; 'stty',
                    'fullname' =&gt; 'Simon T Tyson'
                  }
                ]
    }
</pre>
<p class="Pp">If the option 'KeyAttr =&gt; &quot;login&quot;' were used to
    specify that the 'login' attribute is a key, the same XML would parse
  to:</p>
<p class="Pp"></p>
<pre>    {
      'user' =&gt; {
                  'stty' =&gt; {
                              'fullname' =&gt; 'Simon T Tyson'
                            },
                  'grep' =&gt; {
                              'fullname' =&gt; 'Gary R Epstein'
                            }
                }
    }
</pre>
<p class="Pp">The key attribute names should be supplied in an arrayref if there
    is more than one. <span class="Li">&quot;XMLin()&quot;</span> will attempt
    to match attribute names in the order supplied.
    <span class="Li">&quot;XMLout()&quot;</span> will use the first attribute
    name supplied when 'unfolding' a hash into an array.</p>
<p class="Pp">Note 1: The default value for 'KeyAttr' is ['name', 'key', 'id'].
    If you do not want folding on input or unfolding on output you must set this
    option to an empty list to disable the feature.</p>
<p class="Pp">Note 2: If you wish to use this option, you should also enable the
    <span class="Li">&quot;ForceArray&quot;</span> option. Without 'ForceArray',
    a single nested element will be rolled up into a scalar rather than an array
    and therefore will not be folded (since only arrays get folded).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="KeyAttr_=____list___~2"><a class="permalink" href="#KeyAttr_=____list___~2">KeyAttr
  =&gt; { list } <i># in+out - important</i></a></h2>
<p class="Pp">This alternative (and preferred) method of specifying the key
    attributes allows more fine grained control over which elements are folded
    and on which attributes. For example the option 'KeyAttr =&gt; { package
    =&gt; 'id' } will cause any package elements to be folded on the 'id'
    attribute. No other elements which have an 'id' attribute will be folded at
    all.</p>
<p class="Pp">Note: <span class="Li">&quot;XMLin()&quot;</span> will generate a
    warning (or a fatal error in &quot;STRICT MODE&quot;) if this syntax is used
    and an element which does not have the specified key attribute is
    encountered (eg: a 'package' element without an 'id' attribute, to use the
    example above). Warnings can be suppressed with the lexical
    <span class="Li">&quot;no warnings;&quot;</span> pragma or
    <span class="Li">&quot;no warnings 'XML::Simple';&quot;</span>.</p>
<p class="Pp">Two further variations are made possible by prefixing a '+' or a
    '-' character to the attribute name:</p>
<p class="Pp">The option 'KeyAttr =&gt; { user =&gt; &quot;+login&quot; }' will
    cause this XML:</p>
<p class="Pp"></p>
<pre>    &lt;opt&gt;
      &lt;user login=&quot;grep&quot; fullname=&quot;Gary R Epstein&quot; /&gt;
      &lt;user login=&quot;stty&quot; fullname=&quot;Simon T Tyson&quot; /&gt;
    &lt;/opt&gt;
</pre>
<p class="Pp">to parse to this data structure:</p>
<p class="Pp"></p>
<pre>    {
      'user' =&gt; {
                  'stty' =&gt; {
                              'fullname' =&gt; 'Simon T Tyson',
                              'login'    =&gt; 'stty'
                            },
                  'grep' =&gt; {
                              'fullname' =&gt; 'Gary R Epstein',
                              'login'    =&gt; 'grep'
                            }
                }
    }
</pre>
<p class="Pp">The '+' indicates that the value of the key attribute should be
    copied rather than moved to the folded hash key.</p>
<p class="Pp">A '-' prefix would produce this result:</p>
<p class="Pp"></p>
<pre>    {
      'user' =&gt; {
                  'stty' =&gt; {
                              'fullname' =&gt; 'Simon T Tyson',
                              '-login'    =&gt; 'stty'
                            },
                  'grep' =&gt; {
                              'fullname' =&gt; 'Gary R Epstein',
                              '-login'    =&gt; 'grep'
                            }
                }
    }
</pre>
<p class="Pp">As described earlier, <span class="Li">&quot;XMLout&quot;</span>
    will ignore hash keys starting with a '-'.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="NoAttr_=__1_"><a class="permalink" href="#NoAttr_=__1_">NoAttr
  =&gt; 1 <i># in+out - handy</i></a></h2>
<p class="Pp">When used with <span class="Li">&quot;XMLout()&quot;</span>, the
    generated XML will contain no attributes. All hash key/values will be
    represented as nested elements instead.</p>
<p class="Pp">When used with <span class="Li">&quot;XMLin()&quot;</span>, any
    attributes in the XML will be ignored.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="NoEscape_=__1_"><a class="permalink" href="#NoEscape_=__1_">NoEscape
  =&gt; 1 <i># out - seldom used</i></a></h2>
<p class="Pp">By default, <span class="Li">&quot;XMLout()&quot;</span> will
    translate the characters '&lt;', '&gt;', '&amp;' and '&quot;' to '&amp;lt;',
    '&amp;gt;', '&amp;amp;' and '&amp;quot' respectively. Use this option to
    suppress escaping (presumably because you've already escaped the data in
    some more sophisticated manner).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="NoIndent_=__1_"><a class="permalink" href="#NoIndent_=__1_">NoIndent
  =&gt; 1 <i># out - seldom used</i></a></h2>
<p class="Pp">Set this option to 1 to disable
    <span class="Li">&quot;XMLout()&quot;</span>'s default 'pretty printing'
    mode. With this option enabled, the XML output will all be on one line
    (unless there are newlines in the data) - this may be easier for downstream
    processing.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="NoSort_=__1_"><a class="permalink" href="#NoSort_=__1_">NoSort
  =&gt; 1 <i># out - seldom used</i></a></h2>
<p class="Pp">Newer versions of XML::Simple sort elements and attributes
    alphabetically (*), by default. Enable this option to suppress the sorting -
    possibly for backwards compatibility.</p>
<p class="Pp">* Actually, sorting is alphabetical but 'key' attribute or element
    names (as in 'KeyAttr') sort first. Also, when a hash of hashes is
    'unfolded', the elements are sorted alphabetically by the value of the key
    field.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="NormaliseSpace_=__0___1___2_"><a class="permalink" href="#NormaliseSpace_=__0___1___2_">NormaliseSpace
  =&gt; 0 | 1 | 2 <i># in - handy</i></a></h2>
<p class="Pp">This option controls how whitespace in text content is handled.
    Recognised values for the option are:</p>
<ul class="Bl-bullet">
  <li>0 = (default) whitespace is passed through unaltered (except of course for
      the normalisation of whitespace in attribute values which is mandated by
      the XML recommendation)</li>
  <li>1 = whitespace is normalised in any value used as a hash key (normalising
      means removing leading and trailing whitespace and collapsing sequences of
      whitespace characters to a single space)</li>
  <li>2 = whitespace is normalised in all text content</li>
</ul>
<p class="Pp">Note: you can spell this option with a 'z' if that is more natural
    for you.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="NSExpand_=__1_"><a class="permalink" href="#NSExpand_=__1_">NSExpand
  =&gt; 1 <i># in+out handy - SAX only</i></a></h2>
<p class="Pp">This option controls namespace expansion - the translation of
    element and attribute names of the form 'prefix:name' to '{uri}name'. For
    example the element name 'xsl:template' might be expanded to:
    '{http://www.w3.org/1999/XSL/Transform}template'.</p>
<p class="Pp">By default, <span class="Li">&quot;XMLin()&quot;</span> will
    return element names and attribute names exactly as they appear in the XML.
    Setting this option to 1 will cause all element and attribute names to be
    expanded to include their namespace prefix.</p>
<p class="Pp"><i>Note: You must be using a SAX parser for this option to work
    (ie: it does not</i> <i>work with XML::Parser)</i>.</p>
<p class="Pp">This option also controls whether
    <span class="Li">&quot;XMLout()&quot;</span> performs the reverse
    translation from '{uri}name' back to 'prefix:name'. The default is no
    translation. If your data contains expanded names, you should set this
    option to 1 otherwise <span class="Li">&quot;XMLout&quot;</span> will emit
    XML which is not well formed.</p>
<p class="Pp"><i>Note: You must have the XML::NamespaceSupport module installed
    if you want</i>
    <i></i><span class="Li"><i>&quot;XMLout()&quot;</i></span><i> to translate
    URIs back to prefixes</i>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="NumericEscape_=__0___1___2_"><a class="permalink" href="#NumericEscape_=__0___1___2_">NumericEscape
  =&gt; 0 | 1 | 2 <i># out - handy</i></a></h2>
<p class="Pp">Use this option to have 'high' (non-ASCII) characters in your Perl
    data structure converted to numeric entities (eg: &amp;#8364;) in the XML
    output. Three levels are possible:</p>
<p class="Pp">0 - default: no numeric escaping (OK if you're writing out
  UTF8)</p>
<p class="Pp">1 - only characters above 0xFF are escaped (ie: characters in the
    0x80-FF range are not escaped), possibly useful with ISO8859-1 output</p>
<p class="Pp">2 - all characters above 0x7F are escaped (good for plain ASCII
    output)</p>
</section>
<section class="Ss">
<h2 class="Ss" id="OutputFile_=___file_specifier__"><a class="permalink" href="#OutputFile_=___file_specifier__">OutputFile
  =&gt; &lt;file specifier&gt; <i># out - handy</i></a></h2>
<p class="Pp">The default behaviour of
    <span class="Li">&quot;XMLout()&quot;</span> is to return the XML as a
    string. If you wish to write the XML to a file, simply supply the filename
    using the 'OutputFile' option.</p>
<p class="Pp">This option also accepts an IO handle object - especially useful
    in Perl 5.8.0 and later for output using an encoding other than UTF-8,
  eg:</p>
<p class="Pp"></p>
<pre>  open my $fh, '&gt;:encoding(iso-8859-1)', $path or die &quot;open($path): $!&quot;;
  XMLout($ref, OutputFile =&gt; $fh);
</pre>
<p class="Pp">Note, XML::Simple does not require that the object you pass in to
    the OutputFile option inherits from IO::Handle - it simply assumes the
    object supports a <span class="Li">&quot;print&quot;</span> method.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="ParserOpts_=____XML::Parser_Options___"><a class="permalink" href="#ParserOpts_=____XML::Parser_Options___">ParserOpts
  =&gt; [ XML::Parser Options ] <i># in - don't use this</i></a></h2>
<p class="Pp"><i>Note: This option is now officially deprecated. If you find it
    useful, email</i> <i>the author with an example of what you use it for. Do
    not use this option to</i> <i>set the ProtocolEncoding, that's just plain
    wrong - fix the XML</i>.</p>
<p class="Pp">This option allows you to pass parameters to the constructor of
    the underlying XML::Parser object (which of course assumes you're not using
    SAX).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="RootName_=__'string'_"><a class="permalink" href="#RootName_=__'string'_">RootName
  =&gt; 'string' <i># out - handy</i></a></h2>
<p class="Pp">By default, when <span class="Li">&quot;XMLout()&quot;</span>
    generates XML, the root element will be named 'opt'. This option allows you
    to specify an alternative name.</p>
<p class="Pp">Specifying either undef or the empty string for the RootName
    option will produce XML with no root elements. In most cases the resulting
    XML fragment will not be 'well formed' and therefore could not be read back
    in by <span class="Li">&quot;XMLin()&quot;</span>. Nevertheless, the option
    has been found to be useful in certain circumstances.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="SearchPath_=____list___"><a class="permalink" href="#SearchPath_=____list___">SearchPath
  =&gt; [ list ] <i># in - handy</i></a></h2>
<p class="Pp">If you pass <span class="Li">&quot;XMLin()&quot;</span> a
    filename, but the filename include no directory component, you can use this
    option to specify which directories should be searched to locate the file.
    You might use this option to search first in the user's home directory, then
    in a global directory such as /etc.</p>
<p class="Pp">If a filename is provided to
    <span class="Li">&quot;XMLin()&quot;</span> but SearchPath is not defined,
    the file is assumed to be in the current directory.</p>
<p class="Pp">If the first parameter to
    <span class="Li">&quot;XMLin()&quot;</span> is undefined, the default
    SearchPath will contain only the directory in which the script itself is
    located. Otherwise the default SearchPath will be empty.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="StrictMode_=__1___0__"><a class="permalink" href="#StrictMode_=__1___0__">StrictMode
  =&gt; 1 | 0 <i># in+out seldom used</i></a></h2>
<p class="Pp">This option allows you to turn &quot;STRICT MODE&quot; on or off
    for a particular call, regardless of whether it was enabled at the time
    XML::Simple was loaded.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="SuppressEmpty_=__1___''___undef_"><a class="permalink" href="#SuppressEmpty_=__1___''___undef_">SuppressEmpty
  =&gt; 1 | '' | undef <i># in+out - handy</i></a></h2>
<p class="Pp">This option controls what
    <span class="Li">&quot;XMLin()&quot;</span> should do with empty elements
    (no attributes and no content). The default behaviour is to represent them
    as empty hashes. Setting this option to a true value (eg: 1) will cause
    empty elements to be skipped altogether. Setting the option to 'undef' or
    the empty string will cause empty elements to be represented as the
    undefined value or the empty string respectively. The latter two
    alternatives are a little easier to test for in your code than a hash with
    no keys.</p>
<p class="Pp">The option also controls what
    <span class="Li">&quot;XMLout()&quot;</span> does with undefined values.
    Setting the option to undef causes undefined values to be output as empty
    elements (rather than empty attributes), it also suppresses the generation
    of warnings about undefined values. Setting the option to a true value (eg:
    1) causes undefined values to be skipped altogether on output.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="ValueAttr_=____names___"><a class="permalink" href="#ValueAttr_=____names___">ValueAttr
  =&gt; [ names ] <i># in - handy</i></a></h2>
<p class="Pp">Use this option to deal elements which always have a single
    attribute and no content. Eg:</p>
<p class="Pp"></p>
<pre>  &lt;opt&gt;
    &lt;colour value=&quot;red&quot; /&gt;
    &lt;size   value=&quot;XXL&quot; /&gt;
  &lt;/opt&gt;
</pre>
<p class="Pp">Setting <span class="Li">&quot;ValueAttr =&gt; [ 'value'
    ]&quot;</span> will cause the above XML to parse to:</p>
<p class="Pp"></p>
<pre>  {
    colour =&gt; 'red',
    size   =&gt; 'XXL'
  }
</pre>
<p class="Pp">instead of this (the default):</p>
<p class="Pp"></p>
<pre>  {
    colour =&gt; { value =&gt; 'red' },
    size   =&gt; { value =&gt; 'XXL' }
  }
</pre>
<p class="Pp">Note: This form of the ValueAttr option is not compatible with
    <span class="Li">&quot;XMLout()&quot;</span> - since the attribute name is
    discarded at parse time, the original XML cannot be reconstructed.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="ValueAttr_=____element_=__attribute,_...___"><a class="permalink" href="#ValueAttr_=____element_=__attribute,_...___">ValueAttr
  =&gt; { element =&gt; attribute, ... } <i># in+out - handy</i></a></h2>
<p class="Pp">This (preferred) form of the ValueAttr option requires you to
    specify both the element and the attribute names. This is not only safer, it
    also allows the original XML to be reconstructed by
    <span class="Li">&quot;XMLout()&quot;</span>.</p>
<p class="Pp">Note: You probably don't want to use this option and the NoAttr
    option at the same time.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Variables_=____name_=__value___"><a class="permalink" href="#Variables_=____name_=__value___">Variables
  =&gt; { name =&gt; value } <i># in - handy</i></a></h2>
<p class="Pp">This option allows variables in the XML to be expanded when the
    file is read. (there is no facility for putting the variable names back if
    you regenerate XML using <span class="Li">&quot;XMLout&quot;</span>).</p>
<p class="Pp">A 'variable' is any text of the form
    <span class="Li">&quot;${name}&quot;</span> which occurs in an attribute
    value or in the text content of an element. If 'name' matches a key in the
    supplied hashref, <span class="Li">&quot;${name}&quot;</span> will be
    replaced with the corresponding value from the hashref. If no matching key
    is found, the variable will not be replaced. Names must match the regex:
    <span class="Li">&quot;[\w.]+&quot;</span> (ie: only 'word' characters and
    dots are allowed).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="VarAttr_=__'attr_name'_"><a class="permalink" href="#VarAttr_=__'attr_name'_">VarAttr
  =&gt; 'attr_name' <i># in - handy</i></a></h2>
<p class="Pp">In addition to the variables defined using
    <span class="Li">&quot;Variables&quot;</span>, this option allows variables
    to be defined in the XML. A variable definition consists of an element with
    an attribute called 'attr_name' (the value of the
    <span class="Li">&quot;VarAttr&quot;</span> option). The value of the
    attribute will be used as the variable name and the text content of the
    element will be used as the value. A variable defined in this way will
    override a variable defined using the
    <span class="Li">&quot;Variables&quot;</span> option. For example:</p>
<p class="Pp"></p>
<pre>  XMLin( '&lt;opt&gt;
            &lt;dir name=&quot;prefix&quot;&gt;/usr/local/apache&lt;/dir&gt;
            &lt;dir name=&quot;exec_prefix&quot;&gt;${prefix}&lt;/dir&gt;
            &lt;dir name=&quot;bindir&quot;&gt;${exec_prefix}/bin&lt;/dir&gt;
          &lt;/opt&gt;',
         VarAttr =&gt; 'name', ContentKey =&gt; '-content'
        );
</pre>
<p class="Pp">produces the following data structure:</p>
<p class="Pp"></p>
<pre>  {
    dir =&gt; {
             prefix      =&gt; '/usr/local/apache',
             exec_prefix =&gt; '/usr/local/apache',
             bindir      =&gt; '/usr/local/apache/bin',
           }
  }
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="XMLDecl_=__1__or__XMLDecl_=__'string'__"><a class="permalink" href="#XMLDecl_=__1__or__XMLDecl_=__'string'__">XMLDecl
  =&gt; 1 or XMLDecl =&gt; 'string' <i># out - handy</i></a></h2>
<p class="Pp">If you want the output from
    <span class="Li">&quot;XMLout()&quot;</span> to start with the optional XML
    declaration, simply set the option to '1'. The default XML declaration
  is:</p>
<p class="Pp"></p>
<pre>        &lt;?xml version='1.0' standalone='yes'?&gt;
</pre>
<p class="Pp">If you want some other string (for example to declare an encoding
    value), set the value of this option to the complete string you require.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="OPTIONAL_OO_INTERFACE"><a class="permalink" href="#OPTIONAL_OO_INTERFACE">OPTIONAL
  OO INTERFACE</a></h1>
<p class="Pp">The procedural interface is both simple and convenient however
    there are a couple of reasons why you might prefer to use the object
    oriented (OO) interface:</p>
<ul class="Bl-bullet">
  <li>to define a set of default values which should be used on all subsequent
      calls to <span class="Li">&quot;XMLin()&quot;</span> or
      <span class="Li">&quot;XMLout()&quot;</span></li>
  <li>to override methods in <b>XML::Simple</b> to provide customised
    behaviour</li>
</ul>
<p class="Pp">The default values for the options described above are unlikely to
    suit everyone. The OO interface allows you to effectively override
    <b>XML::Simple</b>'s defaults with your preferred values. It works like
    this:</p>
<p class="Pp">First create an XML::Simple parser object with your preferred
    defaults:</p>
<p class="Pp"></p>
<pre>  my $xs = XML::Simple-&gt;new(ForceArray =&gt; 1, KeepRoot =&gt; 1);
</pre>
<p class="Pp">then call <span class="Li">&quot;XMLin()&quot;</span> or
    <span class="Li">&quot;XMLout()&quot;</span> as a method of that object:</p>
<p class="Pp"></p>
<pre>  my $ref = $xs-&gt;XMLin($xml);
  my $xml = $xs-&gt;XMLout($ref);
</pre>
<p class="Pp">You can also specify options when you make the method calls and
    these values will be merged with the values specified when the object was
    created. Values specified in a method call take precedence.</p>
<p class="Pp">Note: when called as methods, the
    <span class="Li">&quot;XMLin()&quot;</span> and
    <span class="Li">&quot;XMLout()&quot;</span> routines may be called as
    <span class="Li">&quot;xml_in()&quot;</span> or
    <span class="Li">&quot;xml_out()&quot;</span>. The method names are aliased
    so the only difference is the aesthetics.</p>
<section class="Ss">
<h2 class="Ss" id="Parsing_Methods"><a class="permalink" href="#Parsing_Methods">Parsing
  Methods</a></h2>
<p class="Pp">You can explicitly call one of the following methods rather than
    rely on the <span class="Li">&quot;xml_in()&quot;</span> method
    automatically determining whether the target to be parsed is a string, a
    file or a filehandle:</p>
<dl class="Bl-tag">
  <dt id="parse_string(text)"><a class="permalink" href="#parse_string(text)">parse_string(text)</a></dt>
  <dd>Works exactly like the <span class="Li">&quot;xml_in()&quot;</span> method
      but assumes the first argument is a string of XML (or a reference to a
      scalar containing a string of XML).</dd>
  <dt id="parse_file(filename)"><a class="permalink" href="#parse_file(filename)">parse_file(filename)</a></dt>
  <dd>Works exactly like the <span class="Li">&quot;xml_in()&quot;</span> method
      but assumes the first argument is the name of a file containing XML.</dd>
  <dt id="parse_fh(file_handle)"><a class="permalink" href="#parse_fh(file_handle)">parse_fh(file_handle)</a></dt>
  <dd>Works exactly like the <span class="Li">&quot;xml_in()&quot;</span> method
      but assumes the first argument is a filehandle which can be read to get
      XML.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Hook_Methods"><a class="permalink" href="#Hook_Methods">Hook
  Methods</a></h2>
<p class="Pp">You can make your own class which inherits from XML::Simple and
    overrides certain behaviours. The following methods may provide useful
    'hooks' upon which to hang your modified behaviour. You may find other
    undocumented methods by examining the source, but those may be subject to
    change in future releases.</p>
<dl class="Bl-tag">
  <dt id="new_xml_parser()"><a class="permalink" href="#new_xml_parser()"><b>new_xml_parser()</b></a></dt>
  <dd>This method will be called when a new XML::Parser object must be
      constructed (either because XML::SAX is not installed or XML::Parser is
      preferred).</dd>
  <dt id="handle_options(direction,"><a class="permalink" href="#handle_options(direction,">handle_options(direction,
    name =&gt; value ...)</a></dt>
  <dd>This method will be called when one of the parsing methods or the
      <span class="Li">&quot;XMLout()&quot;</span> method is called. The initial
      argument will be a string (either 'in' or 'out') and the remaining
      arguments will be name value pairs.</dd>
  <dt id="default_config_file()"><a class="permalink" href="#default_config_file()"><b>default_config_file()</b></a></dt>
  <dd>Calculates and returns the name of the file which should be parsed if no
      filename is passed to <span class="Li">&quot;XMLin()&quot;</span>
      (default: <span class="Li">&quot;$0.xml&quot;</span>).</dd>
  <dt id="build_simple_tree(filename,"><a class="permalink" href="#build_simple_tree(filename,">build_simple_tree(filename,
    string)</a></dt>
  <dd>Called from <span class="Li">&quot;XMLin()&quot;</span> or any of the
      parsing methods. Takes either a file name as the first argument or
      <span class="Li">&quot;undef&quot;</span> followed by a 'string' as the
      second argument. Returns a simple tree data structure. You could override
      this method to apply your own transformations before the data structure is
      returned to the caller.</dd>
  <dt id="new_hashref()"><a class="permalink" href="#new_hashref()"><b>new_hashref()</b></a></dt>
  <dd>When the 'simple tree' data structure is being built, this method will be
      called to create any required anonymous hashrefs.</dd>
  <dt id="sorted_keys(name,"><a class="permalink" href="#sorted_keys(name,">sorted_keys(name,
    hashref)</a></dt>
  <dd>Called when <span class="Li">&quot;XMLout()&quot;</span> is translating a
      hashref to XML. This routine returns a list of hash keys in the order that
      the corresponding attributes/elements should appear in the output.</dd>
  <dt id="escape_value(string)"><a class="permalink" href="#escape_value(string)">escape_value(string)</a></dt>
  <dd>Called from <span class="Li">&quot;XMLout()&quot;</span>, takes a string
      and returns a copy of the string with XML character escaping rules
      applied.</dd>
  <dt id="escape_attr(string)"><a class="permalink" href="#escape_attr(string)">escape_attr(string)</a></dt>
  <dd>Called from <span class="Li">&quot;XMLout()&quot;</span>, to handle
      attribute values. By default, just calls
      <span class="Li">&quot;escape_value()&quot;</span>, but you can override
      this method if you want attributes escaped differently than text
    content.</dd>
  <dt id="numeric_escape(string)"><a class="permalink" href="#numeric_escape(string)">numeric_escape(string)</a></dt>
  <dd>Called from <span class="Li">&quot;escape_value()&quot;</span>, to handle
      non-ASCII characters (depending on the value of the NumericEscape
    option).</dd>
  <dt id="copy_hash(hashref,"><a class="permalink" href="#copy_hash(hashref,">copy_hash(hashref,
    extra_key =&gt; value, ...)</a></dt>
  <dd>Called from <span class="Li">&quot;XMLout()&quot;</span>, when 'unfolding'
      a hash of hashes into an array of hashes. You might wish to override this
      method if you're using tied hashes and don't want them to get untied.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Cache_Methods"><a class="permalink" href="#Cache_Methods">Cache
  Methods</a></h2>
<p class="Pp">XML::Simple implements three caching schemes ('storable',
    'memshare' and 'memcopy'). You can implement a custom caching scheme by
    implementing two methods - one for reading from the cache and one for
    writing to it.</p>
<p class="Pp">For example, you might implement a new 'dbm' scheme that stores
    cached data structures using the MLDBM module. First, you would add a
    <span class="Li">&quot;cache_read_dbm()&quot;</span> method which accepted a
    filename for use as a lookup key and returned a data structure on success,
    or undef on failure. Then, you would implement a
    <span class="Li">&quot;cache_read_dbm()&quot;</span> method which accepted a
    data structure and a filename.</p>
<p class="Pp">You would use this caching scheme by specifying the option:</p>
<p class="Pp"></p>
<pre>  Cache =&gt; [ 'dbm' ]
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="STRICT_MODE"><a class="permalink" href="#STRICT_MODE">STRICT
  MODE</a></h1>
<p class="Pp">If you import the <b>XML::Simple</b> routines like this:</p>
<p class="Pp"></p>
<pre>  use XML::Simple qw(:strict);
</pre>
<p class="Pp">the following common mistakes will be detected and treated as
    fatal errors</p>
<ul class="Bl-bullet">
  <li>Failing to explicitly set the <span class="Li">&quot;KeyAttr&quot;</span>
      option - if you can't be bothered reading about this option, turn it off
      with: KeyAttr =&gt; [ ]</li>
  <li>Failing to explicitly set the
      <span class="Li">&quot;ForceArray&quot;</span> option - if you can't be
      bothered reading about this option, set it to the safest mode with:
      ForceArray =&gt; 1</li>
  <li>Setting ForceArray to an array, but failing to list all the elements from
      the KeyAttr hash.</li>
  <li>Data error - KeyAttr is set to say { part =&gt; 'partnum' } but the XML
      contains one or more &lt;part&gt; elements without a 'partnum' attribute
      (or nested element). Note: if strict mode is not set but
      <span class="Li">&quot;use warnings;&quot;</span> is in force, this
      condition triggers a warning.</li>
  <li>Data error - as above, but non-unique values are present in the key
      attribute (eg: more than one &lt;part&gt; element with the same partnum).
      This will also trigger a warning if strict mode is not enabled.</li>
  <li>Data error - as above, but value of key attribute (eg: partnum) is not a
      scalar string (due to nested elements etc). This will also trigger a
      warning if strict mode is not enabled.</li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="SAX_SUPPORT"><a class="permalink" href="#SAX_SUPPORT">SAX
  SUPPORT</a></h1>
<p class="Pp">From version 1.08_01, <b>XML::Simple</b> includes support for SAX
    (the Simple API for XML) - specifically SAX2.</p>
<p class="Pp">In a typical SAX application, an XML parser (or SAX 'driver')
    module generates SAX events (start of element, character data, end of
    element, etc) as it parses an XML document and a 'handler' module processes
    the events to extract the required data. This simple model allows for some
    interesting and powerful possibilities:</p>
<ul class="Bl-bullet">
  <li>Applications written to the SAX API can extract data from huge XML
      documents without the memory overheads of a DOM or tree API.</li>
  <li>The SAX API allows for plug and play interchange of parser modules without
      having to change your code to fit a new module's API. A number of SAX
      parsers are available with capabilities ranging from extreme portability
      to blazing performance.</li>
  <li>A SAX 'filter' module can implement both a handler interface for receiving
      data and a generator interface for passing modified data on to a
      downstream handler. Filters can be chained together in 'pipelines'.</li>
  <li>One filter module might split a data stream to direct data to two or more
      downstream handlers.</li>
  <li>Generating SAX events is not the exclusive preserve of XML parsing
      modules. For example, a module might extract data from a relational
      database using DBI and pass it on to a SAX pipeline for filtering and
      formatting.</li>
</ul>
<p class="Pp"><b>XML::Simple</b> can operate at either end of a SAX pipeline.
    For example, you can take a data structure in the form of a hashref and pass
    it into a SAX pipeline using the 'Handler' option on
    <span class="Li">&quot;XMLout()&quot;</span>:</p>
<p class="Pp"></p>
<pre>  use XML::Simple;
  use Some::SAX::Filter;
  use XML::SAX::Writer;
  my $ref = {
               ....   # your data here
            };
  my $writer = XML::SAX::Writer-&gt;new();
  my $filter = Some::SAX::Filter-&gt;new(Handler =&gt; $writer);
  my $simple = XML::Simple-&gt;new(Handler =&gt; $filter);
  $simple-&gt;XMLout($ref);
</pre>
<p class="Pp">You can also put <b>XML::Simple</b> at the opposite end of the
    pipeline to take advantage of the simple 'tree' data structure once the
    relevant data has been isolated through filtering:</p>
<p class="Pp"></p>
<pre>  use XML::SAX;
  use Some::SAX::Filter;
  use XML::Simple;
  my $simple = XML::Simple-&gt;new(ForceArray =&gt; 1, KeyAttr =&gt; ['partnum']);
  my $filter = Some::SAX::Filter-&gt;new(Handler =&gt; $simple);
  my $parser = XML::SAX::ParserFactory-&gt;parser(Handler =&gt; $filter);
  my $ref = $parser-&gt;parse_uri('some_huge_file.xml');
  print $ref-&gt;{part}-&gt;{'555-1234'};
</pre>
<p class="Pp">You can build a filter by using an XML::Simple object as a handler
    and setting its DataHandler option to point to a routine which takes the
    resulting tree, modifies it and sends it off as SAX events to a downstream
    handler:</p>
<p class="Pp"></p>
<pre>  my $writer = XML::SAX::Writer-&gt;new();
  my $filter = XML::Simple-&gt;new(
                 DataHandler =&gt; sub {
                                  my $simple = shift;
                                  my $data = shift;
                                  # Modify $data here
                                  $simple-&gt;XMLout($data, Handler =&gt; $writer);
                                }
               );
  my $parser = XML::SAX::ParserFactory-&gt;parser(Handler =&gt; $filter);
  $parser-&gt;parse_uri($filename);
</pre>
<p class="Pp"><i>Note: In this last example, the 'Handler' option was specified
    in the call to</i>
    <i></i><span class="Li"><i>&quot;XMLout()&quot;</i></span><i> but it could
    also have been specified in the constructor</i>.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="ENVIRONMENT"><a class="permalink" href="#ENVIRONMENT">ENVIRONMENT</a></h1>
<p class="Pp">If you don't care which parser module <b>XML::Simple</b> uses then
    skip this section entirely (it looks more complicated than it really
  is).</p>
<p class="Pp"><b>XML::Simple</b> will default to using a <b>SAX</b> parser if
    one is available or <b>XML::Parser</b> if SAX is not available.</p>
<p class="Pp">You can dictate which parser module is used by setting either the
    environment variable 'XML_SIMPLE_PREFERRED_PARSER' or the package variable
    <span class="Li">$XML::Simple::PREFERRED_PARSER</span> to contain the module
    name. The following rules are used:</p>
<ul class="Bl-bullet">
  <li>The package variable takes precedence over the environment variable if
      both are defined. To force <b>XML::Simple</b> to ignore the environment
      settings and use its default rules, you can set the package variable to an
      empty string.</li>
  <li>If the 'preferred parser' is set to the string 'XML::Parser', then
      XML::Parser will be used (or <span class="Li">&quot;XMLin()&quot;</span>
      will die if XML::Parser is not installed).</li>
  <li>If the 'preferred parser' is set to some other value, then it is assumed
      to be the name of a SAX parser module and is passed to
      XML::SAX::ParserFactory. If XML::SAX is not installed, or the requested
      parser module is not installed, then
      <span class="Li">&quot;XMLin()&quot;</span> will die.</li>
  <li>If the 'preferred parser' is not defined at all (the normal default
      state), an attempt will be made to load XML::SAX. If XML::SAX is
      installed, then a parser module will be selected according to
      XML::SAX::ParserFactory's normal rules (which typically means the last SAX
      parser installed).</li>
  <li>if the 'preferred parser' is not defined and <b>XML::SAX</b> is not
      installed, then <b>XML::Parser</b> will be used.
      <span class="Li">&quot;XMLin()&quot;</span> will die if XML::Parser is not
      installed.</li>
</ul>
<p class="Pp">Note: The <b>XML::SAX</b> distribution includes an XML parser
    written entirely in Perl. It is very portable but it is not very fast. You
    should consider installing XML::LibXML or XML::SAX::Expat if they are
    available for your platform.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="ERROR_HANDLING"><a class="permalink" href="#ERROR_HANDLING">ERROR
  HANDLING</a></h1>
<p class="Pp">The XML standard is very clear on the issue of non-compliant
    documents. An error in parsing any single element (for example a missing end
    tag) must cause the whole document to be rejected. <b>XML::Simple</b> will
    die with an appropriate message if it encounters a parsing error.</p>
<p class="Pp">If dying is not appropriate for your application, you should
    arrange to call <span class="Li">&quot;XMLin()&quot;</span> in an eval block
    and look for errors in $@. eg:</p>
<p class="Pp"></p>
<pre>    my $config = eval { XMLin() };
    PopUpMessage($@) if($@);
</pre>
<p class="Pp">Note, there is a common misconception that use of <b>eval</b> will
    significantly slow down a script. While that may be true when the code being
    eval'd is in a string, it is not true of code like the sample above.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="EXAMPLES"><a class="permalink" href="#EXAMPLES">EXAMPLES</a></h1>
<p class="Pp">When <span class="Li">&quot;XMLin()&quot;</span> reads the
    following very simple piece of XML:</p>
<p class="Pp"></p>
<pre>    &lt;opt username=&quot;testuser&quot; password=&quot;frodo&quot;&gt;&lt;/opt&gt;
</pre>
<p class="Pp">it returns the following data structure:</p>
<p class="Pp"></p>
<pre>    {
      'username' =&gt; 'testuser',
      'password' =&gt; 'frodo'
    }
</pre>
<p class="Pp">The identical result could have been produced with this
    alternative XML:</p>
<p class="Pp"></p>
<pre>    &lt;opt username=&quot;testuser&quot; password=&quot;frodo&quot; /&gt;
</pre>
<p class="Pp">Or this (although see 'ForceArray' option for variations):</p>
<p class="Pp"></p>
<pre>    &lt;opt&gt;
      &lt;username&gt;testuser&lt;/username&gt;
      &lt;password&gt;frodo&lt;/password&gt;
    &lt;/opt&gt;
</pre>
<p class="Pp">Repeated nested elements are represented as anonymous arrays:</p>
<p class="Pp"></p>
<pre>    &lt;opt&gt;
      &lt;person firstname=&quot;Joe&quot; lastname=&quot;Smith&quot;&gt;
        &lt;email&gt;joe@smith.com&lt;/email&gt;
        &lt;email&gt;jsmith@yahoo.com&lt;/email&gt;
      &lt;/person&gt;
      &lt;person firstname=&quot;Bob&quot; lastname=&quot;Smith&quot;&gt;
        &lt;email&gt;bob@smith.com&lt;/email&gt;
      &lt;/person&gt;
    &lt;/opt&gt;
    {
      'person' =&gt; [
                    {
                      'email' =&gt; [
                                   'joe@smith.com',
                                   'jsmith@yahoo.com'
                                 ],
                      'firstname' =&gt; 'Joe',
                      'lastname' =&gt; 'Smith'
                    },
                    {
                      'email' =&gt; 'bob@smith.com',
                      'firstname' =&gt; 'Bob',
                      'lastname' =&gt; 'Smith'
                    }
                  ]
    }
</pre>
<p class="Pp">Nested elements with a recognised key attribute are transformed
    (folded) from an array into a hash keyed on the value of that attribute (see
    the <span class="Li">&quot;KeyAttr&quot;</span> option):</p>
<p class="Pp"></p>
<pre>    &lt;opt&gt;
      &lt;person key=&quot;jsmith&quot; firstname=&quot;Joe&quot; lastname=&quot;Smith&quot; /&gt;
      &lt;person key=&quot;tsmith&quot; firstname=&quot;Tom&quot; lastname=&quot;Smith&quot; /&gt;
      &lt;person key=&quot;jbloggs&quot; firstname=&quot;Joe&quot; lastname=&quot;Bloggs&quot; /&gt;
    &lt;/opt&gt;
    {
      'person' =&gt; {
                    'jbloggs' =&gt; {
                                   'firstname' =&gt; 'Joe',
                                   'lastname' =&gt; 'Bloggs'
                                 },
                    'tsmith' =&gt; {
                                  'firstname' =&gt; 'Tom',
                                  'lastname' =&gt; 'Smith'
                                },
                    'jsmith' =&gt; {
                                  'firstname' =&gt; 'Joe',
                                  'lastname' =&gt; 'Smith'
                                }
                  }
    }
</pre>
<p class="Pp">The &lt;anon&gt; tag can be used to form anonymous arrays:</p>
<p class="Pp"></p>
<pre>    &lt;opt&gt;
      &lt;head&gt;&lt;anon&gt;Col 1&lt;/anon&gt;&lt;anon&gt;Col 2&lt;/anon&gt;&lt;anon&gt;Col 3&lt;/anon&gt;&lt;/head&gt;
      &lt;data&gt;&lt;anon&gt;R1C1&lt;/anon&gt;&lt;anon&gt;R1C2&lt;/anon&gt;&lt;anon&gt;R1C3&lt;/anon&gt;&lt;/data&gt;
      &lt;data&gt;&lt;anon&gt;R2C1&lt;/anon&gt;&lt;anon&gt;R2C2&lt;/anon&gt;&lt;anon&gt;R2C3&lt;/anon&gt;&lt;/data&gt;
      &lt;data&gt;&lt;anon&gt;R3C1&lt;/anon&gt;&lt;anon&gt;R3C2&lt;/anon&gt;&lt;anon&gt;R3C3&lt;/anon&gt;&lt;/data&gt;
    &lt;/opt&gt;
    {
      'head' =&gt; [
                  [ 'Col 1', 'Col 2', 'Col 3' ]
                ],
      'data' =&gt; [
                  [ 'R1C1', 'R1C2', 'R1C3' ],
                  [ 'R2C1', 'R2C2', 'R2C3' ],
                  [ 'R3C1', 'R3C2', 'R3C3' ]
                ]
    }
</pre>
<p class="Pp">Anonymous arrays can be nested to arbitrary levels and as a
    special case, if the surrounding tags for an XML document contain only an
    anonymous array the arrayref will be returned directly rather than the usual
    hashref:</p>
<p class="Pp"></p>
<pre>    &lt;opt&gt;
      &lt;anon&gt;&lt;anon&gt;Col 1&lt;/anon&gt;&lt;anon&gt;Col 2&lt;/anon&gt;&lt;/anon&gt;
      &lt;anon&gt;&lt;anon&gt;R1C1&lt;/anon&gt;&lt;anon&gt;R1C2&lt;/anon&gt;&lt;/anon&gt;
      &lt;anon&gt;&lt;anon&gt;R2C1&lt;/anon&gt;&lt;anon&gt;R2C2&lt;/anon&gt;&lt;/anon&gt;
    &lt;/opt&gt;
    [
      [ 'Col 1', 'Col 2' ],
      [ 'R1C1', 'R1C2' ],
      [ 'R2C1', 'R2C2' ]
    ]
</pre>
<p class="Pp">Elements which only contain text content will simply be
    represented as a scalar. Where an element has both attributes and text
    content, the element will be represented as a hashref with the text content
    in the 'content' key (see the <span class="Li">&quot;ContentKey&quot;</span>
    option):</p>
<p class="Pp"></p>
<pre>  &lt;opt&gt;
    &lt;one&gt;first&lt;/one&gt;
    &lt;two attr=&quot;value&quot;&gt;second&lt;/two&gt;
  &lt;/opt&gt;
  {
    'one' =&gt; 'first',
    'two' =&gt; { 'attr' =&gt; 'value', 'content' =&gt; 'second' }
  }
</pre>
<p class="Pp">Mixed content (elements which contain both text content and nested
    elements) will be not be represented in a useful way - element order and
    significant whitespace will be lost. If you need to work with mixed content,
    then XML::Simple is not the right tool for your job - check out the next
    section.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="WHERE_TO_FROM_HERE?"><a class="permalink" href="#WHERE_TO_FROM_HERE?">WHERE
  TO FROM HERE?</a></h1>
<p class="Pp"><b>XML::Simple</b> is able to present a simple API because it
    makes some assumptions on your behalf. These include:</p>
<ul class="Bl-bullet">
  <li>You're not interested in text content consisting only of whitespace</li>
  <li>You don't mind that when things get slurped into a hash the order is
    lost</li>
  <li>You don't want fine-grained control of the formatting of generated
    XML</li>
  <li>You would never use a hash key that was not a legal XML element name</li>
  <li>You don't need help converting between different encodings</li>
</ul>
<p class="Pp">In a serious XML project, you'll probably outgrow these
    assumptions fairly quickly. This section of the document used to offer some
    advice on choosing a more powerful option. That advice has now grown into
    the 'Perl-XML FAQ' document which you can find at:
    &lt;http://perl-xml.sourceforge.net/faq/&gt;</p>
<p class="Pp">The advice in the FAQ boils down to a quick explanation of tree
    versus event based parsers and then recommends:</p>
<p class="Pp">For event based parsing, use SAX (do not set out to write any new
    code for XML::Parser's handler API - it is obsolete).</p>
<p class="Pp">For tree-based parsing, you could choose between the 'Perlish'
    approach of XML::Twig and more standards based DOM implementations -
    preferably one with XPath support such as XML::LibXML.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp"><b>XML::Simple</b> requires either XML::Parser or XML::SAX.</p>
<p class="Pp">To generate documents with namespaces, XML::NamespaceSupport is
    required.</p>
<p class="Pp">The optional caching functions require Storable.</p>
<p class="Pp">Answers to Frequently Asked Questions about XML::Simple are
    bundled with this distribution as: XML::Simple::FAQ</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT"><a class="permalink" href="#COPYRIGHT">COPYRIGHT</a></h1>
<p class="Pp">Copyright 1999-2004 Grant McLean &lt;grantm@cpan.org&gt;</p>
<p class="Pp">This library is free software; you can redistribute it and/or
    modify it under the same terms as Perl itself.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2018-03-18</td>
    <td class="foot-os">perl v5.30.2</td>
  </tr>
</table>
</body>
</html>
