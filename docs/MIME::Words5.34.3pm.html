<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    .Nd, .Bf, .Op { display: inline; }
    .Pa, .Ad { font-style: italic; }
    .Ms { font-weight: bold; }
    .Bl-diag > dt { font-weight: bold; }
    code.Nm, .Fl, .Cm, .Ic, code.In, .Fd, .Fn, .Cd { font-weight: bold;
      font-family: inherit; }
  </style>
  <title>MIME::Words(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">MIME::Words(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">MIME::Words(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">MIME::Words - deal with RFC 2047 encoded words</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<p class="Pp">Before reading further, you should see MIME::Tools to make sure
    that you understand where this module fits into the grand scheme of things.
    Go on, do it now. I'll wait.</p>
<p class="Pp">Ready? Ok...</p>
<p class="Pp"></p>
<pre>    use MIME::Words qw(:all);
    ### Decode the string into another string, forgetting the charsets:
    $decoded = decode_mimewords(
          'To: =?ISO-8859-1?Q?Keld_J=F8rn_Simonsen?= &lt;keld@dkuug.dk&gt;',
          );
    ### Split string into array of decoded [DATA,CHARSET] pairs:
    @decoded = decode_mimewords(
          'To: =?ISO-8859-1?Q?Keld_J=F8rn_Simonsen?= &lt;keld@dkuug.dk&gt;',
          );
    ### Encode a single unsafe word:
    $encoded = encode_mimeword(&quot;\xABFran\xE7ois\xBB&quot;);
    ### Encode a string, trying to find the unsafe words inside it:
    $encoded = encode_mimewords(&quot;Me and \xABFran\xE7ois\xBB in town&quot;);
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">Fellow Americans, you probably won't know what the hell this
    module is for. Europeans, Russians, et al, you probably do.
    <span class="Li">&quot;:-)&quot;</span>.</p>
<p class="Pp">For example, here's a valid MIME header you might get:</p>
<p class="Pp"></p>
<pre>      From: =?US-ASCII?Q?Keith_Moore?= &lt;moore@cs.utk.edu&gt;
      To: =?ISO-8859-1?Q?Keld_J=F8rn_Simonsen?= &lt;keld@dkuug.dk&gt;
      CC: =?ISO-8859-1?Q?Andr=E9_?= Pirard &lt;PIRARD@vm1.ulg.ac.be&gt;
      Subject: =?ISO-8859-1?B?SWYgeW91IGNhbiByZWFkIHRoaXMgeW8=?=
       =?ISO-8859-2?B?dSB1bmRlcnN0YW5kIHRoZSBleGFtcGxlLg==?=
       =?US-ASCII?Q?.._cool!?=
</pre>
<p class="Pp">The fields basically decode to (sorry, I can only approximate the
    Latin characters with 7 bit sequences /o and 'e):</p>
<p class="Pp"></p>
<pre>      From: Keith Moore &lt;moore@cs.utk.edu&gt;
      To: Keld J/orn Simonsen &lt;keld@dkuug.dk&gt;
      CC: Andr'e  Pirard &lt;PIRARD@vm1.ulg.ac.be&gt;
      Subject: If you can read this you understand the example... cool!
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="PUBLIC_INTERFACE"><a class="permalink" href="#PUBLIC_INTERFACE">PUBLIC
  INTERFACE</a></h1>
<dl class="Bl-tag">
  <dt id="decode_mimewords"><a class="permalink" href="#decode_mimewords">decode_mimewords
    ENCODED</a></dt>
  <dd><i>Function.</i> Go through the string looking for RFC 2047-style
      &quot;Q&quot; (quoted-printable, sort of) or &quot;B&quot; (base64)
      encoding, and decode them.
    <p class="Pp"><b>In an array context,</b> splits the ENCODED string into a
        list of decoded <span class="Li">&quot;[DATA, CHARSET]&quot;</span>
        pairs, and returns that list. Unencoded data are returned in a 1-element
        array <span class="Li">&quot;[DATA]&quot;</span>, giving an effective
        CHARSET of <span class="Li">&quot;undef&quot;</span>.</p>
    <p class="Pp"></p>
    <pre>    $enc = '=?ISO-8859-1?Q?Keld_J=F8rn_Simonsen?= &lt;keld@dkuug.dk&gt;';
    foreach (decode_mimewords($enc)) {
        print &quot;&quot;, ($_-&gt;[1] || 'US-ASCII'), &quot;: &quot;, $_-&gt;[0], &quot;\n&quot;;
    }
    </pre>
    <p class="Pp"><b>In a scalar context,</b> joins the &quot;data&quot;
        elements of the above list together, and returns that. <i>Warning: this
        is information-lossy,</i> and probably <i>not</i> what you want, but if
        you know that all charsets in the ENCODED string are identical, it might
        be useful to you. (Before you use this, please see &quot;unmime&quot; in
        MIME::WordDecoder, which is probably what you want.)</p>
    <p class="Pp">In the event of a syntax error, $@ will be set to a
        description of the error, but parsing will continue as best as possible
        (so as to get <i>something</i> back when decoding headers). $@ will be
        false if no error was detected.</p>
    <p class="Pp">Any arguments past the ENCODED string are taken to define a
        hash of options:</p>
  </dd>
  <dt id="encode_mimeword"><a class="permalink" href="#encode_mimeword">encode_mimeword
    RAW, [ENCODING], [CHARSET]</a></dt>
  <dd><i>Function.</i> Encode a single RAW &quot;word&quot; that has unsafe
      characters. The &quot;word&quot; will be encoded in its entirety.
    <p class="Pp"></p>
    <pre>    ### Encode &quot;&lt;&lt;Franc,ois&gt;&gt;&quot;:
    $encoded = encode_mimeword(&quot;\xABFran\xE7ois\xBB&quot;);
    </pre>
    <p class="Pp">You may specify the ENCODING
        (<span class="Li">&quot;Q&quot;</span> or
        <span class="Li">&quot;B&quot;</span>), which defaults to
        <span class="Li">&quot;Q&quot;</span>. You may specify the CHARSET,
        which defaults to <span class="Li">&quot;iso-8859-1&quot;</span>.</p>
  </dd>
  <dt id="encode_mimewords"><a class="permalink" href="#encode_mimewords">encode_mimewords
    RAW, [OPTS]</a></dt>
  <dd><i>Function.</i> Given a RAW string, try to find and encode all
      &quot;unsafe&quot; sequences of characters:
    <p class="Pp"></p>
    <pre>    ### Encode a string with some unsafe &quot;words&quot;:
    $encoded = encode_mimewords(&quot;Me and \xABFran\xE7ois\xBB&quot;);
    </pre>
    <p class="Pp">Returns the encoded string. Any arguments past the RAW string
        are taken to define a hash of options:</p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Charset"><a class="permalink" href="#Charset">Charset</a></dt>
  <dd>Encode all unsafe stuff with this charset. Default is 'ISO-8859-1', a.k.a.
      &quot;Latin-1&quot;.</dd>
  <dt id="Encoding"><a class="permalink" href="#Encoding">Encoding</a></dt>
  <dd>The encoding to use, <span class="Li">&quot;q&quot;</span> or
      <span class="Li">&quot;b&quot;</span>. The default is
      <span class="Li">&quot;q&quot;</span>.</dd>
</dl>
</div>
<div class="Bd-indent">
<p class="Pp"><b>Warning:</b> this is a quick-and-dirty solution, intended for
    character sets which overlap ASCII. <b>It does not comply with the RFC
    2047</b> <b>rules regarding the use of encoded words in message headers</b>.
    You may want to roll your own variant, using
    <span class="Li">&quot;encode_mimeword()&quot;</span>, for your application.
    <i>Thanks to Jan Kasprzak for reminding me about this problem.</i></p>
</div>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp">MIME::Base64, MIME::QuotedPrint, MIME::Tools</p>
<p class="Pp">For other implementations of this or similar functionality
    (particularly, ones with proper UTF8 support), see:</p>
<p class="Pp">Encode::MIME::Header, MIME::EncWords, MIME::AltWords</p>
<p class="Pp">At some future point, one of these implementations will likely
    replace MIME::Words and MIME::Words will become deprecated.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="NOTES"><a class="permalink" href="#NOTES">NOTES</a></h1>
<p class="Pp">Exports its principle functions by default, in keeping with
    MIME::Base64 and MIME::QuotedPrint.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">Eryq (<i>eryq@zeegee.com</i>), ZeeGee Software Inc
    (<i>http://www.zeegee.com</i>). Dianne Skoll (dfs@roaringpenguin.com)
    http://www.roaringpenguin.com</p>
<p class="Pp">All rights reserved. This program is free software; you can
    redistribute it and/or modify it under the same terms as Perl itself.</p>
<p class="Pp">Thanks also to...</p>
<p class="Pp"></p>
<pre>      Kent Boortz        For providing the idea, and the baseline
                         RFC-1522-decoding code!
      KJJ at PrimeNet    For requesting that this be split into
                         its own module.
      Stephane Barizien  For reporting a nasty bug.
</pre>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2017-04-05</td>
    <td class="foot-os">perl v5.34.0</td>
  </tr>
</table>
</body>
</html>
