<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    .Nd, .Bf, .Op { display: inline; }
    .Pa, .Ad { font-style: italic; }
    .Ms { font-weight: bold; }
    .Bl-diag > dt { font-weight: bold; }
    code.Nm, .Fl, .Cm, .Ic, code.In, .Fd, .Fn, .Cd { font-weight: bold;
      font-family: inherit; }
  </style>
  <title>Pegex::API(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Pegex::API(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Pegex::API(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="The_Pegex_API"><a class="permalink" href="#The_Pegex_API">The
  Pegex API</a></h1>
<p class="Pp">Pegex can be used in many ways: inside scripts, from the command
    line or as the foundation of a modular parsing framework. This document
    details the various ways to use Pegex.</p>
<p class="Pp">At the most abstract level, Pegex works like this:</p>
<p class="Pp"></p>
<pre>    $result = $parser-&gt;new($grammar, $receiver)-&gt;parse($input);
</pre>
<p class="Pp">Which is to say, abstractly: a Pegex parser, under the direction
    of a Pegex grammar, parses an input stream, and reports matches to a Pegex
    receiver, which produces a result.</p>
<p class="Pp">The parser, grammar, receiver and even the input, are Pegex
    objects. These 4 objects are involved in every Pegex parse operation, so
    let's review them briefly:</p>
<dl class="Bl-tag">
  <dt id="Pegex::Parser"><a class="permalink" href="#Pegex::Parser">Pegex::Parser</a></dt>
  <dd>The Pegex parsing engine. This engine applies the logic of the grammar to
      an input text. A <b>parser</b> object contains a <b>grammar</b> object and
      a <b>receiver</b> object. Its primary method is called
      <span class="Li">&quot;parse&quot;</span>. The default parser engine is
      non-backtracking, recursive descent. However there are parser subclasses
      for various alternative types of parsing.</dd>
  <dt id="Pegex::Grammar"><a class="permalink" href="#Pegex::Grammar">Pegex::Grammar</a></dt>
  <dd>A Pegex grammar starts as a text file/string composed in the <b>Pegex</b>
      syntax. Before it can be used in by a Parser it must be compiled. After
      compilation, it is turned into a data tree consisting of rules and
      regexes. In modules that are based on a Pegex grammar, the grammar will be
      compiled into a class file. Pegex itself, uses a Pegex grammar class
      called Pegex::Pegex::Grammar to parse various Pegex grammars.</dd>
  <dt id="Pegex::Receiver"><a class="permalink" href="#Pegex::Receiver">Pegex::Receiver</a></dt>
  <dd>A parser on it's own has no idea what to do with the text it matches. A
      Pegex <b>receiver</b> is a class that contains methods corresponding to
      the rules in a grammar. As a rule in the grammar matches, its
      corresponding receiver method (if one exists) is called with the data that
      has been matched. It is the receiver's job to take action on the data,
      often building it into some new structure. Pegex will use
      Pegex::Tree::Wrap as the default receiver; it produces a reasonably
      readable tree of the matched/captured data.</dd>
  <dt id="Pegex::Input"><a class="permalink" href="#Pegex::Input">Pegex::Input</a></dt>
  <dd>Pegex abstracts its input streams into an object interface as well. Any
      operation that can take an input string, can also take an input object.
      Pegex will turn regular strings into these objects. This is probably the
      API concept you will encounter the least, but it is covered here for
      completeness.</dd>
</dl>
<p class="Pp">All of these object classes can be subclassed to achieve various
    results. Normally, you will write your own Pegex grammar and a Pegex
    receiver to achieve a task.</p>
<section class="Ss">
<h2 class="Ss" id="Starting_Simple_"><a class="permalink" href="#Starting_Simple_">Starting
  Simple - The &quot;pegex&quot; Function</a></h2>
<p class="Pp">The Pegex module exports a function called
    <span class="Li">&quot;pegex&quot;</span> that you can use for smaller
    tasks. Here is an example:</p>
<p class="Pp"></p>
<pre>    use Pegex;
    use YAML;
    $grammar = &quot;
    expr: num PLUS num
    num: /( DIGIT+ )/
    &quot;;
    print Dump pegex($grammar)-&gt;parse('2+2');
</pre>
<p class="Pp">This program would produce:</p>
<p class="Pp"></p>
<pre>    expr:
    - num: 2
    - num: 2
</pre>
<p class="Pp">Let's review what's happening here. The Pegex module is exporting
    a <span class="Li">&quot;pegex&quot;</span> function. This function takes a
    Pegex grammar string as input. Internally this function compiles the grammar
    string into a grammar object. Then it creates a parser object containing the
    grammar object and returns it.</p>
<p class="Pp">The parse method is called on the input string:
    <span class="Li">'2+2'</span>. The string matches, and a nice data structure
    is returned.</p>
<p class="Pp">So how was the data structure created? By the receiver object, of
    course! But we didn't specify one, did we? Nope. It used the default
    receiver, Pegex::Tree::Wrap. We could have said:</p>
<p class="Pp"></p>
<pre>    print Dump pegex($grammar, 'Pegex::Tree::Wrap')-&gt;parse('2+2');
</pre>
<p class="Pp">This receiver basically generates a mapping, where rule names of
    matches are the keys, and the leaf values are the regex captures.</p>
<p class="Pp">The more basic receiver called Pegex::Tree generates a tree of
    sequences that contain just the data (without the rule names). This
  code:</p>
<p class="Pp"></p>
<pre>    print Dump pegex($grammar, 'Pegex::Tree')-&gt;parse('2+2');
</pre>
<p class="Pp">would produce:</p>
<p class="Pp"></p>
<pre>    - 2
    - 2
</pre>
<p class="Pp">If we wrote our own receiver class called
    <span class="Li">&quot;Calculator&quot;</span> like this:</p>
<p class="Pp"></p>
<pre>    package Calculator;
    use base 'Pegex::Tree';
    sub got_expr {
        my ($receiver, $data) = @_;
        my ($a, $b) = @$data;
        return $a + $b;
    }
</pre>
<p class="Pp">Then, this:</p>
<p class="Pp"></p>
<pre>    print pegex(grammar, 'Calculator')-&gt;parse('2+2');
</pre>
<p class="Pp">would print:</p>
<p class="Pp"></p>
<pre>    4
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="More_Explicit_Usage"><a class="permalink" href="#More_Explicit_Usage">More
  Explicit Usage</a></h2>
<p class="Pp">Continuing with the example above, let's see how to do it a little
    more formally.</p>
<p class="Pp"></p>
<pre>    use Pegex::Parser;
    use Pegex::Grammar;
    use Pegex::Tree;
    use Pegex::Input;
    use YAML;
    $grammar_text = &quot;
    expr: num PLUS num
    num: /( DIGIT+ )/
    &quot;;
    $grammar = Pegex::Grammar-&gt;new(text =&gt; $grammar_text);
    $receiver = Pegex::Tree-&gt;new();
    $parser = Pegex::Parser-&gt;new(
        grammar =&gt; $grammar,
        receiver =&gt; $receiver,
    );
    $input = Pegex::Input-&gt;new(string =&gt; '2+2');
    print Dump $parser-&gt;parse($input);
</pre>
<p class="Pp">This code does the same thing as the first example, but this time
    we've made all the objects ourselves.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Precompiled_Grammars"><a class="permalink" href="#Precompiled_Grammars">Precompiled
  Grammars</a></h2>
<p class="Pp">If you ship a Pegex grammar as part of a CPAN distribution, you'll
    want it to be precompiled into a module. Pegex makes that easy.</p>
<p class="Pp">Say the grammar_text about is stored in a file called
    <span class="Li">&quot;share/expr.pgx&quot;</span>. If you create a module
    called <span class="Li">&quot;lib/MyThing/Grammar.pm&quot;</span> with
    content like this:</p>
<p class="Pp"></p>
<pre>    package MyThing::Grammar;
    use base 'Pegex::Grammar';
    use constant file =&gt; './share/expr.pgx';
    sub make_tree {
    }
    1;
</pre>
<p class="Pp">Then run this command line:</p>
<p class="Pp"></p>
<pre>    perl -Ilib -MMyThing::Grammar=compile
</pre>
<p class="Pp">It will rewrite your module to look something like this:</p>
<p class="Pp"></p>
<pre>    package MyThing::Grammar;
    use base 'Pegex::Grammar';
    use constant file =&gt; './share/expr.pgx';
    sub make_tree {
      { '+toprule' =&gt; 'expr',
        'PLUS' =&gt; { '.rgx' =&gt; qr/\G\+/ },
        'expr' =&gt; {
          '.all' =&gt; [
            { '.ref' =&gt; 'num' },
            { '.ref' =&gt; 'PLUS' },
            { '.ref' =&gt; 'num' }
          ]
        },
        'num' =&gt; { '.rgx' =&gt; qr/\G([0-9]+)/ }
      }
    }
    1;
</pre>
<p class="Pp">This command found the file where your grammar is, compiled it,
    and used Data::Dumper to output it back into your module's
    <span class="Li">&quot;make_tree&quot;</span> method.</p>
<p class="Pp">This is what a compiled Pegex grammar looks like. As soon as this
    module is loaded, the grammar is ready to be used by Pegex.</p>
<p class="Pp"><i>Automatically rebuilding during development with environment
    variable</i></p>
<p class="Pp">If you find yourself needing to compile your grammar module a lot
    during development, just set this environment variable like so:</p>
<p class="Pp"></p>
<pre>    export PERL_PEGEX_AUTO_COMPILE=MyThing::Grammar
</pre>
<p class="Pp">Now, every time the grammar module is loaded it will check to see
    if it needs to be recompiled, and do it on the fly.</p>
<p class="Pp">If you have more than one grammar to recompile, just list all the
    names separated by commas.</p>
<p class="Pp"><i>Automatically rebuilding during development using
    </i><span class="Li"><i>&quot;make&quot;</i></span><i></i></p>
<p class="Pp">Alternatively, if your module uses
    <span class="Li">&quot;ExtUtils::MakeMaker&quot;</span>, you can have
    <span class="Li">&quot;make&quot;</span> automatically rebuild your
    <span class="Li">&quot;Grammar&quot;</span> class if your
    <span class="Li">&quot;.pgx&quot;</span> file is updated.</p>
<p class="Pp">Simply add this at the bottom of your
    <span class="Li">&quot;Makefile.PL&quot;</span>:</p>
<p class="Pp"></p>
<pre>    sub MY::postamble {
      &lt;&lt;EOF;
    lib/MyThing/Grammar.pm : share/expr.pgx
    \t\$(PERL) -Ilib -MMyThing::Grammar=compile
    EOF
    }
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="See_Also"><a class="permalink" href="#See_Also">See
  Also</a></h1>
<ul class="Bl-bullet">
  <li>Pegex::Parser</li>
  <li>Pegex::Grammar</li>
  <li>Pegex::Receiver</li>
  <li>Pegex::Tree</li>
  <li>Pegex::Tree::Wrap</li>
  <li>Pegex::Input</li>
</ul>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2020-02-13</td>
    <td class="foot-os">perl v5.34.0</td>
  </tr>
</table>
</body>
</html>
