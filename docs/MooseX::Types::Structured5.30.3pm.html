<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>MooseX::Types::Structured(3pm)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">MooseX::Types::Structured(3pm)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">MooseX::Types::Structured(3pm)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
MooseX::Types::Structured - Structured Type Constraints for Moose
</section>
<section class="Sh">
<h1 class="Sh" id="VERSION"><a class="permalink" href="#VERSION">VERSION</a></h1>
version 0.36
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
The following is example usage for this module.
<p class="Pp"><span class="Li"></span></p>
<pre>
    package Person;

    use Moose;
    use MooseX::Types::Moose qw(Str Int HashRef);
    use MooseX::Types::Structured qw(Dict Tuple Optional);

    ## A name has a first and last part, but middle names are not required
    has name =&gt; (
        isa=&gt;Dict[
            first =&gt; Str,
            last =&gt; Str,
            middle =&gt; Optional[Str],
        ],
    );

    ## description is a string field followed by a HashRef of tagged data.
    has description =&gt; (
      isa=&gt;Tuple[
        Str,
        Optional[HashRef],
     ],
    );

    ## Remainder of your class attributes and methods
</pre>
<p class="Pp">Then you can instantiate this class with something like:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    my $john = Person-&gt;new(
        name =&gt; {
            first =&gt; 'John',
            middle =&gt; 'James'
            last =&gt; 'Napiorkowski',
        },
        description =&gt; [
            'A cool guy who loves Perl and Moose.', {
                married_to =&gt; 'Vanessa Li',
                born_in =&gt; 'USA',
            };
        ]
    );
</pre>
<p class="Pp">Or with:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    my $vanessa = Person-&gt;new(
        name =&gt; {
            first =&gt; 'Vanessa',
            last =&gt; 'Li'
        },
        description =&gt; ['A great student!'],
    );
</pre>
<p class="Pp">But all of these would cause a constraint error for the
    <span class="Li">&quot;name&quot;</span> attribute:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    ## Value for 'name' not a HashRef
    Person-&gt;new( name =&gt; 'John' );

    ## Value for 'name' has incorrect hash key and missing required keys
    Person-&gt;new( name =&gt; {
        first_name =&gt; 'John'
    });

    ## Also incorrect keys
    Person-&gt;new( name =&gt; {
        first_name =&gt; 'John',
        age =&gt; 39,
    });

    ## key 'middle' incorrect type, should be a Str not a ArrayRef
    Person-&gt;new( name =&gt; {
        first =&gt; 'Vanessa',
        middle =&gt; [1,2],
        last =&gt; 'Li',
    });
</pre>
<p class="Pp">And these would cause a constraint error for the
    <span class="Li">&quot;description&quot;</span> attribute:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    ## Should be an ArrayRef
    Person-&gt;new( description =&gt; 'Hello I am a String' );

    ## First element must be a string not a HashRef.
    Person-&gt;new (description =&gt; [{
        tag1 =&gt; 'value1',
        tag2 =&gt; 'value2'
    }]);
</pre>
<p class="Pp">Please see the test cases for more examples.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
A structured type constraint is a standard container Moose type constraint, such
  as an <span class="Li">&quot;ArrayRef&quot;</span> or
  <span class="Li">&quot;HashRef&quot;</span>, which has been enhanced to allow
  you to explicitly name all the allowed type constraints inside the structure.
  The generalized form is:
<p class="Pp"><span class="Li"></span></p>
<pre>
    TypeConstraint[@TypeParameters or %TypeParameters]
</pre>
<p class="Pp">Where <span class="Li">&quot;TypeParameters&quot;</span> is an
    array reference or hash references of Moose::Meta::TypeConstraint
  objects.</p>
<p class="Pp">This type library enables structured type constraints. It is built
    on top of the MooseX::Types library system, so you should review the
    documentation for that if you are not familiar with it.</p>
<section class="Ss">
<h2 class="Ss" id="Comparing_Parameterized_types_to_Structured_types"><a class="permalink" href="#Comparing_Parameterized_types_to_Structured_types">Comparing
  Parameterized types to Structured types</a></h2>
Parameterized constraints are built into core Moose and you are probably already
  familiar with the type constraints <span class="Li">&quot;HashRef&quot;</span>
  and <span class="Li">&quot;ArrayRef&quot;</span>. Structured types have
  similar functionality, so their syntax is likewise similar. For example, you
  could define a parameterized constraint like:
<p class="Pp"><span class="Li"></span></p>
<pre>
    subtype ArrayOfInts,
     as ArrayRef[Int];
</pre>
<p class="Pp">which would constrain a value to something like [1,2,3,...] and so
    on. On the other hand, a structured type constraint explicitly names all
    it's allowed 'internal' type parameter constraints. For the example:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    subtype StringFollowedByInt,
     as Tuple[Str,Int];
</pre>
<p class="Pp">would constrain its value to things like
    <span class="Li">&quot;['hello', 111]&quot;</span> but
    <span class="Li">&quot;['hello', 'world']&quot;</span> would fail, as well
    as <span class="Li">&quot;['hello', 111, 'world']&quot;</span> and so on.
    Here's another example:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
        package MyApp::Types;

    use MooseX::Types -declare [qw(StringIntOptionalHashRef)];
    use MooseX::Types::Moose qw(Str Int);
    use MooseX::Types::Structured qw(Tuple Optional);

    subtype StringIntOptionalHashRef,
     as Tuple[
        Str, Int,
        Optional[HashRef]
     ];
</pre>
<p class="Pp">This defines a type constraint that validates values like:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    ['Hello', 100, {key1 =&gt; 'value1', key2 =&gt; 'value2'}];
    ['World', 200];
</pre>
<p class="Pp">Notice that the last type constraint in the structure is optional.
    This is enabled via the helper <span class="Li">&quot;Optional&quot;</span>
    type constraint, which is a variation of the core Moose type constraint
    <span class="Li">&quot;Maybe&quot;</span>. The main difference is that
    <span class="Li">&quot;Optional&quot;</span> type constraints are required
    to validate if they exist, while <span class="Li">&quot;Maybe&quot;</span>
    permits undefined values. So the following example would not validate:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    StringIntOptionalHashRef-&gt;validate(['Hello Undefined', 1000, undef]);
</pre>
<p class="Pp">Please note the subtle difference between undefined and null. If
    you wish to allow both null and undefined, you should use the core Moose
    <span class="Li">&quot;Maybe&quot;</span> type constraint instead:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    package MyApp::Types;

    use MooseX::Types -declare [qw(StringIntMaybeHashRef)];
    use MooseX::Types::Moose qw(Str Int Maybe);
    use MooseX::Types::Structured qw(Tuple);

    subtype StringIntMaybeHashRef,
     as Tuple[
        Str, Int, Maybe[HashRef]
     ];
</pre>
<p class="Pp">This would validate the following:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    ['Hello', 100, {key1 =&gt; 'value1', key2 =&gt; 'value2'}];
    ['World', 200, undef];
    ['World', 200];
</pre>
<p class="Pp">Structured constraints are not limited to arrays. You can define a
    structure against a <span class="Li">&quot;HashRef&quot;</span> with the
    <span class="Li">&quot;Dict&quot;</span> type constraint as in this
  example:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    subtype FirstNameLastName,
     as Dict[
        firstname =&gt; Str,
        lastname =&gt; Str,
     ];
</pre>
<p class="Pp">This would constrain a <span class="Li">&quot;HashRef&quot;</span>
    that validates something like:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    {firstname =&gt; 'Christopher', lastname =&gt; 'Parsons'};
</pre>
<p class="Pp">but all the following would fail validation:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    ## Incorrect keys
    {first =&gt; 'Christopher', last =&gt; 'Parsons'};

    ## Too many keys
    {firstname =&gt; 'Christopher', lastname =&gt; 'Parsons', middlename =&gt; 'Allen'};

    ## Not a HashRef
    ['Christopher', 'Parsons'];
</pre>
<p class="Pp">These structures can be as simple or elaborate as you wish. You
    can even combine various structured, parameterized and simple constraints
    all together:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    subtype Crazy,
     as Tuple[
        Int,
        Dict[name=&gt;Str, age=&gt;Int],
        ArrayRef[Int]
     ];
</pre>
<p class="Pp">Which would match:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    [1, {name=&gt;'John', age=&gt;25},[10,11,12]];
</pre>
<p class="Pp">Please notice how the type parameters can be visually arranged to
    your liking and to improve the clarity of your meaning. You don't need to
    run then altogether onto a single line. Additionally, since the
    <span class="Li">&quot;Dict&quot;</span> type constraint defines a hash
    constraint, the key order is not meaningful. For example:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    subtype AnyKeyOrder,
      as Dict[
        key1=&gt;Int,
        key2=&gt;Str,
        key3=&gt;Int,
     ];
</pre>
<p class="Pp">Would validate both:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    {key1 =&gt; 1, key2 =&gt; &quot;Hi!&quot;, key3 =&gt; 2};
    {key2 =&gt; &quot;Hi!&quot;, key1 =&gt; 100, key3 =&gt; 300};
</pre>
<p class="Pp">As you would expect, since underneath it's just a plain old Perl
    hash at work.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Alternatives"><a class="permalink" href="#Alternatives">Alternatives</a></h2>
You should exercise some care as to whether or not your complex structured
  constraints would be better off contained by a real object as in the following
  example:
<p class="Pp"><span class="Li"></span></p>
<pre>
    package MyApp::MyStruct;
    use Moose;

    ## lazy way to make a bunch of attributes
    has $_ for qw(full_name age_in_years);

    package MyApp::MyClass;
    use Moose;

    has person =&gt; (isa =&gt; 'MyApp::MyStruct');

    my $instance = MyApp::MyClass-&gt;new(
        person=&gt;MyApp::MyStruct-&gt;new(
            full_name =&gt; 'John',
            age_in_years =&gt; 39,
        ),
    );
</pre>
<p class="Pp">This method may take some additional time to set up but will give
    you more flexibility. However, structured constraints are highly compatible
    with this method, granting some interesting possibilities for coercion.
  Try:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    package MyApp::MyClass;

    use Moose;
    use MyApp::MyStruct;

    ## It's recommended your type declarations live in a separate class in order
    ## to promote reusability and clarity.  Inlined here for brevity.

    use MooseX::Types::DateTime qw(DateTime);
    use MooseX::Types -declare [qw(MyStruct)];
    use MooseX::Types::Moose qw(Str Int);
    use MooseX::Types::Structured qw(Dict);

    ## Use class_type to create an ISA type constraint if your object doesn't
    ## inherit from Moose::Object.
    class_type 'MyApp::MyStruct';

    ## Just a shorter version really.
    subtype MyStruct,
     as 'MyApp::MyStruct';

    ## Add the coercions.
    coerce MyStruct,
     from Dict[
        full_name=&gt;Str,
        age_in_years=&gt;Int
     ], via {
        MyApp::MyStruct-&gt;new(%$_);
     },
     from Dict[
        lastname=&gt;Str,
        firstname=&gt;Str,
        dob=&gt;DateTime
     ], via {
        my $name = $_-&gt;{firstname} .' '. $_-&gt;{lastname};
        my $age = DateTime-&gt;now - $_-&gt;{dob};

        MyApp::MyStruct-&gt;new(
            full_name=&gt;$name,
            age_in_years=&gt;$age-&gt;years,
        );
     };

    has person =&gt; (isa=&gt;MyStruct);
</pre>
<p class="Pp">This would allow you to instantiate with something like:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    my $obj = MyApp::MyClass-&gt;new( person =&gt; {
        full_name=&gt;'John Napiorkowski',
        age_in_years=&gt;39,
    });
</pre>
<p class="Pp">Or even:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    my $obj = MyApp::MyClass-&gt;new( person =&gt; {
        lastname=&gt;'John',
        firstname=&gt;'Napiorkowski',
        dob=&gt;DateTime-&gt;new(year=&gt;1969),
    });
</pre>
<p class="Pp">If you are not familiar with how coercions work, check out the
    Moose cookbook entry Moose::Cookbook::Recipe5 for an explanation. The
    section &quot;Coercions&quot; has additional examples and discussion.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Subtyping_a_Structured_type_constraint"><a class="permalink" href="#Subtyping_a_Structured_type_constraint">Subtyping
  a Structured type constraint</a></h2>
You need to exercise some care when you try to subtype a structured type as in
  this example:
<p class="Pp"><span class="Li"></span></p>
<pre>
    subtype Person,
     as Dict[name =&gt; Str];

    subtype FriendlyPerson,
     as Person[
        name =&gt; Str,
        total_friends =&gt; Int,
     ];
</pre>
<p class="Pp">This will actually work BUT you have to take care that the subtype
    has a structure that does not contradict the structure of it's parent. For
    now the above works, but I will clarify the syntax for this at a future
    point, so it's recommended to avoid (should not really be needed so much
    anyway). For now this is supported in an EXPERIMENTAL way. Your thoughts,
    test cases and patches are welcomed for discussion. If you find a good use
    for this, please let me know.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Coercions"><a class="permalink" href="#Coercions">Coercions</a></h2>
Coercions currently work for 'one level' deep. That is you can do:
<p class="Pp"><span class="Li"></span></p>
<pre>
    subtype Person,
     as Dict[
        name =&gt; Str,
        age =&gt; Int
    ];

    subtype Fullname,
     as Dict[
        first =&gt; Str,
        last =&gt; Str
     ];

    coerce Person,
     ## Coerce an object of a particular class
     from BlessedPersonObject, via {
        +{
            name=&gt;$_-&gt;name,
            age=&gt;$_-&gt;age,
        };
     },

     ## Coerce from [$name, $age]
     from ArrayRef, via {
        +{
            name=&gt;$_-&gt;[0],
            age=&gt;$_-&gt;[1],
        },
     },
     ## Coerce from {fullname=&gt;{first=&gt;...,last=&gt;...}, dob=&gt;$DateTimeObject}
     from Dict[fullname=&gt;Fullname, dob=&gt;DateTime], via {
        my $age = $_-&gt;dob - DateTime-&gt;now;
        my $firstn = $_-&gt;{fullname}-&gt;{first};
        my $lastn = $_-&gt;{fullname}-&gt;{last}
        +{
            name =&gt; $_-&gt;{fullname}-&gt;{first} .' '. ,
            age =&gt;$age-&gt;years
        }
     };
</pre>
<p class="Pp">And that should just work as expected. However, if there are any
    'inner' coercions, such as a coercion on
    <span class="Li">&quot;Fullname&quot;</span> or on
    <span class="Li">&quot;DateTime&quot;</span>, that coercion won't currently
    get activated.</p>
<p class="Pp">Please see the test <i>07-coerce.t</i> for a more detailed
    example. Discussion on extending coercions to support this welcome on the
    Moose development channel or mailing list.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Recursion"><a class="permalink" href="#Recursion">Recursion</a></h2>
Newer versions of MooseX::Types support recursive type constraints. That is you
  can include a type constraint as a contained type constraint of itself. For
  example:
<p class="Pp"><span class="Li"></span></p>
<pre>
    subtype Person,
     as Dict[
         name=&gt;Str,
         friends=&gt;Optional[
             ArrayRef[Person]
         ],
     ];
</pre>
<p class="Pp">This would declare a <span class="Li">&quot;Person&quot;</span>
    subtype that contains a name and an optional
    <span class="Li">&quot;ArrayRef&quot;</span> of
    <span class="Li">&quot;Person&quot;</span>s who are friends as in:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    {
        name =&gt; 'Mike',
        friends =&gt; [
            { name =&gt; 'John' },
            { name =&gt; 'Vincent' },
            {
                name =&gt; 'Tracey',
                friends =&gt; [
                    { name =&gt; 'Stephenie' },
                    { name =&gt; 'Ilya' },
                ],
            },
        ],
    };
</pre>
<p class="Pp">Please take care to make sure the recursion node is either
    <span class="Li">&quot;Optional&quot;</span>, or declare a union with an
    non-recursive option such as:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    subtype Value
     as Tuple[
         Str,
         Str|Tuple,
     ];
</pre>
<p class="Pp">Which validates:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    [
        'Hello', [
            'World', [
                'Is', [
                    'Getting',
                    'Old',
                ],
            ],
        ],
    ];
</pre>
<p class="Pp">Otherwise you will define a subtype that is impossible to validate
    since it is infinitely recursive. For more information about defining
    recursive types, please see the documentation in MooseX::Types and the test
    cases.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="TYPE_CONSTRAINTS"><a class="permalink" href="#TYPE_CONSTRAINTS">TYPE
  CONSTRAINTS</a></h1>
This type library defines the following constraints.
<section class="Ss">
<h2 class="Ss" id="Tuple_@constraints_"><a class="permalink" href="#Tuple_@constraints_">Tuple[@constraints]</a></h2>
This defines an ArrayRef based constraint which allows you to validate a
  specific list of contained constraints. For example:
<p class="Pp"><span class="Li"></span></p>
<pre>
    Tuple[Int,Str]; ## Validates [1,'hello']
    Tuple[Str|Object, Int]; ## Validates ['hello', 1] or [$object, 2]
</pre>
<p class="Pp">The Values of <span class="Li">@constraints</span> should ideally
    be MooseX::Types declared type constraints. We do support 'old style' Moose
    string based constraints to a limited degree but these string type
    constraints are considered deprecated. There will be limited support for
    bugs resulting from mixing string and MooseX::Types in your structures. If
    you encounter such a bug and really need it fixed, we will required a
    detailed test case at the minimum.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Dict__constraints_"><a class="permalink" href="#Dict__constraints_">Dict[%constraints]</a></h2>
This defines a HashRef based constraint which allowed you to validate a specific
  hashref. For example:
<p class="Pp"><span class="Li"></span></p>
<pre>
    Dict[name=&gt;Str, age=&gt;Int]; ## Validates {name=&gt;'John', age=&gt;39}
</pre>
<p class="Pp">The keys in <span class="Li">%constraints</span> follow the same
    rules as <span class="Li">@constraints</span> in the above section.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Map__$key_constraint,_$value_constraint__"><a class="permalink" href="#Map__$key_constraint,_$value_constraint__">Map[
  $key_constraint, $value_constraint ]</a></h2>
This defines a <span class="Li">&quot;HashRef&quot;</span>-based constraint in
  which both the keys and values are required to meet certain constraints. For
  example, to map hostnames to IP addresses, you might say:
<p class="Pp"><span class="Li"></span></p>
<pre>
  Map[ HostName, IPAddress ]
</pre>
<p class="Pp">The type constraint would only be met if every key was a valid
    <span class="Li">&quot;HostName&quot;</span> and every value was a valid
    <span class="Li">&quot;IPAddress&quot;</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Optional_$constraint_"><a class="permalink" href="#Optional_$constraint_">Optional[$constraint]</a></h2>
This is primarily a helper constraint for
  <span class="Li">&quot;Dict&quot;</span> and
  <span class="Li">&quot;Tuple&quot;</span> type constraints. What this allows
  is for you to assert that a given type constraint is allowed to be null (but
  NOT undefined). If the value is null, then the type constraint passes but if
  the value is defined it must validate against the type constraint. This makes
  it easy to make a Dict where one or more of the keys doesn't have to exist or
  a tuple where some of the values are not required. For example:
<p class="Pp"><span class="Li"></span></p>
<pre>
    subtype Name() =&gt; as Dict[
        first=&gt;Str,
        last=&gt;Str,
        middle=&gt;Optional[Str],
    ];
</pre>
<p class="Pp">...creates a constraint that validates against a hashref with the
    keys 'first' and 'last' being strings and required while an optional key
    'middle' is must be a string if it appears but doesn't have to appear. So in
    this case both the following are valid:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    {first=&gt;'John', middle=&gt;'James', last=&gt;'Napiorkowski'}
    {first=&gt;'Vanessa', last=&gt;'Li'}
</pre>
<p class="Pp">If you use the <span class="Li">&quot;Maybe&quot;</span> type
    constraint instead, your values will also validate against
    <span class="Li">&quot;undef&quot;</span>, which may be incorrect for
  you.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="EXPORTABLE_SUBROUTINES"><a class="permalink" href="#EXPORTABLE_SUBROUTINES">EXPORTABLE
  SUBROUTINES</a></h1>
This type library makes available for export the following subroutines
<section class="Ss">
<h2 class="Ss" id="slurpy"><a class="permalink" href="#slurpy">slurpy</a></h2>
Structured type constraints by their nature are closed; that is validation will
  depend on an exact match between your structure definition and the arguments
  to be checked. Sometimes you might wish for a slightly looser amount of
  validation. For example, you may wish to validate the first 3 elements of an
  array reference and allow for an arbitrary number of additional elements. At
  first thought you might think you could do it this way:
<p class="Pp"><span class="Li"></span></p>
<pre>
    #  I want to validate stuff like: [1,&quot;hello&quot;, $obj, 2,3,4,5,6,...]
    subtype AllowTailingArgs,
     as Tuple[
       Int,
       Str,
       Object,
       ArrayRef[Int],
     ];
</pre>
<p class="Pp">However what this will actually validate are structures like
  this:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    [10,&quot;Hello&quot;, $obj, [11,12,13,...] ]; # Notice element 4 is an ArrayRef
</pre>
<p class="Pp">In order to allow structured validation of, &quot;and then
    some&quot;, arguments, you can use the &quot;slurpy&quot; method against a
    type constraint. For example:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    use MooseX::Types::Structured qw(Tuple slurpy);

    subtype AllowTailingArgs,
     as Tuple[
       Int,
       Str,
       Object,
       slurpy ArrayRef[Int],
     ];
</pre>
<p class="Pp">This will now work as expected, validating ArrayRef structures
    such as:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    [1,&quot;hello&quot;, $obj, 2,3,4,5,6,...]
</pre>
<p class="Pp">A few caveats apply. First, the slurpy type constraint must be the
    last one in the list of type constraint parameters. Second, the parent type
    of the slurpy type constraint must match that of the containing type
    constraint. That means that a <span class="Li">&quot;Tuple&quot;</span> can
    allow a slurpy <span class="Li">&quot;ArrayRef&quot;</span> (or children of
    <span class="Li">&quot;ArrayRef&quot;</span>s, including another
    <span class="Li">&quot;Tuple&quot;</span>) and a
    <span class="Li">&quot;Dict&quot;</span> can allow a slurpy
    <span class="Li">&quot;HashRef&quot;</span> (or children/subtypes of
    HashRef, also including other <span class="Li">&quot;Dict&quot;</span>
    constraints).</p>
<p class="Pp">Please note the technical way this works 'under the hood' is that
    the slurpy keyword transforms the target type constraint into a coderef.
    Please do not try to create your own custom coderefs; always use the slurpy
    method. The underlying technology may change in the future but the slurpy
    keyword will be supported.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="ERROR_MESSAGES"><a class="permalink" href="#ERROR_MESSAGES">ERROR
  MESSAGES</a></h1>
Error reporting has been improved to return more useful debugging messages. Now
  I will stringify the incoming check value with Devel::PartialDump so that you
  can see the actual structure that is tripping up validation. Also, I report
  the 'internal' validation error, so that if a particular element inside the
  Structured Type is failing validation, you will see that. There's a limit to
  how deep this internal reporting goes, but you shouldn't see any of the
  &quot;failed with ARRAY(XXXXXX)&quot; that we got with earlier versions of
  this module.
<p class="Pp">This support is continuing to expand, so it's best to use these
    messages for debugging purposes and not for creating messages that 'escape
    into the wild' such as error messages sent to the user.</p>
<p class="Pp">Please see the test '12-error.t' for a more lengthy example. Your
    thoughts and preferable tests or code patches very welcome!</p>
</section>
<section class="Sh">
<h1 class="Sh" id="EXAMPLES"><a class="permalink" href="#EXAMPLES">EXAMPLES</a></h1>
Here are some additional example usage for structured types. All examples can be
  found also in the 't/examples.t' test. Your contributions are also welcomed.
<section class="Ss">
<h2 class="Ss" id="Normalize_a_HashRef"><a class="permalink" href="#Normalize_a_HashRef">Normalize
  a HashRef</a></h2>
You need a hashref to conform to a canonical structure but are required accept a
  bunch of different incoming structures. You can normalize using the
  <span class="Li">&quot;Dict&quot;</span> type constraint and coercions. This
  example also shows structured types mixed which other MooseX::Types libraries.
<p class="Pp"><span class="Li"></span></p>
<pre>
    package Test::MooseX::Meta::TypeConstraint::Structured::Examples::Normalize;

    use Moose;
    use DateTime;

    use MooseX::Types::Structured qw(Dict Tuple);
    use MooseX::Types::DateTime qw(DateTime);
    use MooseX::Types::Moose qw(Int Str Object);
    use MooseX::Types -declare =&gt; [qw(Name Age Person)];

    subtype Person,
     as Dict[
         name=&gt;Str,
         age=&gt;Int,
     ];

    coerce Person,
     from Dict[
         first=&gt;Str,
         last=&gt;Str,
         years=&gt;Int,
     ], via { +{
        name =&gt; &quot;$_-&gt;{first} $_-&gt;{last}&quot;,
        age =&gt; $_-&gt;{years},
     }},
     from Dict[
         fullname=&gt;Dict[
             last=&gt;Str,
             first=&gt;Str,
         ],
         dob=&gt;DateTime,
     ],
     ## DateTime needs to be inside of single quotes here to disambiguate the
     ## class package from the DataTime type constraint imported via the
     ## line &quot;use MooseX::Types::DateTime qw(DateTime);&quot;
     via { +{
        name =&gt; &quot;$_-&gt;{fullname}{first} $_-&gt;{fullname}{last}&quot;,
        age =&gt; ($_-&gt;{dob} - 'DateTime'-&gt;now)-&gt;years,
     }};

    has person =&gt; (is=&gt;'rw', isa=&gt;Person, coerce=&gt;1);
</pre>
<p class="Pp">And now you can instantiate with all the following:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    __PACKAGE__-&gt;new(
        person=&gt;{
            name=&gt;'John Napiorkowski',
            age=&gt;39,
        },
    );

    __PACKAGE__-&gt;new(
        person=&gt;{
            first=&gt;'John',
            last=&gt;'Napiorkowski',
            years=&gt;39,
        },
    );

    __PACKAGE__-&gt;new(
        person=&gt;{
            fullname =&gt; {
                first=&gt;'John',
                last=&gt;'Napiorkowski'
            },
            dob =&gt; 'DateTime'-&gt;new(
                year=&gt;1969,
                month=&gt;2,
                day=&gt;13
            ),
        },
    );
</pre>
<p class="Pp">This technique is a way to support various ways to instantiate
    your class in a clean and declarative way.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
The following modules or resources may be of interest.
<p class="Pp">Moose, MooseX::Types, Moose::Meta::TypeConstraint,
    MooseX::Meta::TypeConstraint::Structured</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SUPPORT"><a class="permalink" href="#SUPPORT">SUPPORT</a></h1>
Bugs may be submitted through the RT bug tracker
  &lt;https://rt.cpan.org/Public/Dist/Display.html?Name=MooseX-Types-Structured&gt;
  (or bug-MooseX-Types-Structured@rt.cpan.org
  &lt;mailto:bug-MooseX-Types-Structured@rt.cpan.org&gt;).
<p class="Pp">There is also a mailing list available for users of this
    distribution, at &lt;http://lists.perl.org/list/moose.html&gt;.</p>
<p class="Pp">There is also an irc channel available for users of this
    distribution, at <span class="Li">&quot;#moose&quot;</span> on
    <span class="Li">&quot;irc.perl.org&quot;</span>
    &lt;irc://irc.perl.org/#moose&gt;.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHORS"><a class="permalink" href="#AUTHORS">AUTHORS</a></h1>
<ul class="Bl-bullet">
  <li>John Napiorkowski &lt;jjnapiork@cpan.org&gt;</li>
  <li>Florian Ragwitz &lt;rafl@debian.org&gt;</li>
  <li>XXXX XXX'XX (Yuval Kogman) &lt;nothingmuch@woobling.org&gt;</li>
  <li>Tomas (t0m) Doran &lt;bobtfish@bobtfish.net&gt;</li>
  <li>Robert Sedlacek &lt;rs@474.at&gt;</li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="CONTRIBUTORS"><a class="permalink" href="#CONTRIBUTORS">CONTRIBUTORS</a></h1>
<ul class="Bl-bullet">
  <li>Karen Etheridge &lt;ether@cpan.org&gt;</li>
  <li>Ricardo Signes &lt;rjbs@cpan.org&gt;</li>
  <li>Dave Rolsky &lt;autarch@urth.org&gt;</li>
  <li>Ansgar Burchardt &lt;ansgar@43-1.org&gt;</li>
  <li>Stevan Little &lt;stevan.little@iinteractive.com&gt;</li>
  <li>arcanez &lt;justin.d.hunter@gmail.com&gt;</li>
  <li>Jesse Luehrs &lt;doy@tozt.net&gt;</li>
  <li>D. Ilmari Mannsaaker &lt;ilmari@cpan.org&gt;</li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT_AND_LICENSE"><a class="permalink" href="#COPYRIGHT_AND_LICENSE">COPYRIGHT
  AND LICENSE</a></h1>
This software is copyright (c) 2008 by John Napiorkowski.
<p class="Pp">This is free software; you can redistribute it and/or modify it
    under the same terms as the Perl 5 programming language system itself.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2017-05-09</td>
    <td class="foot-os">perl v5.30.2</td>
  </tr>
</table>
</body>
</html>
