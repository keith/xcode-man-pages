<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>encoding(3pm)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">encoding(3pm)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">encoding(3pm)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
encoding - allows you to write your script in non-ascii or non-utf8
</section>
<section class="Sh">
<h1 class="Sh" id="WARNING"><a class="permalink" href="#WARNING">WARNING</a></h1>
This module is deprecated under perl 5.18. It uses a mechanism provided by perl
  that is deprecated under 5.18 and higher, and may be removed in a future
  version.
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<span class="Li"></span>
<pre>
  use encoding &quot;greek&quot;;  # Perl like Greek to you?
  use encoding &quot;euc-jp&quot;; # Jperl!

  # or you can even do this if your shell supports your native encoding

  perl -Mencoding=latin2 -e'...' # Feeling centrally European?
  perl -Mencoding=euc-kr -e'...' # Or Korean?

  # more control

  # A simple euc-cn =&gt; utf-8 converter
  use encoding &quot;euc-cn&quot;, STDOUT =&gt; &quot;utf8&quot;;  while(&lt;&gt;){print};

  # &quot;no encoding;&quot; supported (but not scoped!)
  no encoding;

  # an alternate way, Filter
  use encoding &quot;euc-jp&quot;, Filter=&gt;1;
  # now you can use kanji identifiers -- in euc-jp!

  # switch on locale -
  # note that this probably means that unless you have a complete control
  # over the environments the application is ever going to be run, you should
  # NOT use the feature of encoding pragma allowing you to write your script
  # in any recognized encoding because changing locale settings will wreck
  # the script; you can of course still use the other features of the pragma.
  use encoding ':locale';
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="ABSTRACT"><a class="permalink" href="#ABSTRACT">ABSTRACT</a></h1>
Let's start with a bit of history: Perl 5.6.0 introduced Unicode support. You
  could apply <span class="Li">&quot;substr()&quot;</span> and regexes even to
  complex CJK characters -- so long as the script was written in UTF-8. But back
  then, text editors that supported UTF-8 were still rare and many users instead
  chose to write scripts in legacy encodings, giving up a whole new feature of
  Perl 5.6.
<p class="Pp">Rewind to the future: starting from perl 5.8.0 with the
    <b>encoding</b> pragma, you can write your script in any encoding you like
    (so long as the <span class="Li">&quot;Encode&quot;</span> module supports
    it) and still enjoy Unicode support. This pragma achieves that by doing the
    following:</p>
<ul class="Bl-bullet">
  <li>Internally converts all literals
      (<span class="Li">&quot;q//,qq//,qr//,qw///, qx//&quot;</span>) from the
      encoding specified to utf8. In Perl 5.8.1 and later, literals in
      <span class="Li">&quot;tr///&quot;</span> and
      <span class="Li">&quot;DATA&quot;</span> pseudo-filehandle are also
      converted.</li>
  <li>Changing PerlIO layers of <span class="Li">&quot;STDIN&quot;</span> and
      <span class="Li">&quot;STDOUT&quot;</span> to the encoding
     specified.</li>
</ul>
<section class="Ss">
<h2 class="Ss" id="Literal_Conversions"><a class="permalink" href="#Literal_Conversions">Literal
  Conversions</a></h2>
You can write code in EUC-JP as follows:
<p class="Pp"><span class="Li"></span></p>
<pre>
  my $Rakuda = &quot;\xF1\xD1\xF1\xCC&quot;; # Camel in Kanji
               #&lt;-char-&gt;&lt;-char-&gt;   # 4 octets
  s/\bCamel\b/$Rakuda/;
</pre>
<p class="Pp">And with <span class="Li">&quot;use encoding
    &quot;euc-jp&quot;&quot;</span> in effect, it is the same thing as the code
    in UTF-8:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  my $Rakuda = &quot;\x{99F1}\x{99DD}&quot;; # two Unicode Characters
  s/\bCamel\b/$Rakuda/;
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="PerlIO_layers_for__STD(IN_OUT)_"><a class="permalink" href="#PerlIO_layers_for__STD(IN_OUT)_">PerlIO
  layers for &quot;STD(IN|OUT)&quot;</a></h2>
The <b>encoding</b> pragma also modifies the filehandle layers of STDIN and
  STDOUT to the specified encoding. Therefore,
<p class="Pp"><span class="Li"></span></p>
<pre>
  use encoding &quot;euc-jp&quot;;
  my $message = &quot;Camel is the symbol of perl.\n&quot;;
  my $Rakuda = &quot;\xF1\xD1\xF1\xCC&quot;; # Camel in Kanji
  $message =~ s/\bCamel\b/$Rakuda/;
  print $message;
</pre>
<p class="Pp">Will print &quot;\xF1\xD1\xF1\xCC is the symbol of perl.\n&quot;,
    not &quot;\x{99F1}\x{99DD} is the symbol of perl.\n&quot;.</p>
<p class="Pp">You can override this by giving extra arguments; see below.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Implicit_upgrading_for_byte_strings"><a class="permalink" href="#Implicit_upgrading_for_byte_strings">Implicit
  upgrading for byte strings</a></h2>
By default, if strings operating under byte semantics and strings with Unicode
  character data are concatenated, the new string will be created by decoding
  the byte strings as <i>ISO 8859-1 (Latin-1)</i>.
<p class="Pp">The <b>encoding</b> pragma changes this to use the specified
    encoding instead. For example:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    use encoding 'utf8';
    my $string = chr(20000); # a Unicode string
    utf8::encode($string);   # now it's a UTF-8 encoded byte string
    # concatenate with another Unicode string
    print length($string . chr(20000));
</pre>
<p class="Pp">Will print <span class="Li">2</span>, because
    <span class="Li">$string</span> is upgraded as UTF-8. Without
    <span class="Li">&quot;use encoding 'utf8';&quot;</span>, it will print
    <span class="Li">4</span> instead, since <span class="Li">$string</span> is
    three octets when interpreted as Latin-1.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Side_effects"><a class="permalink" href="#Side_effects">Side
  effects</a></h2>
If the <span class="Li">&quot;encoding&quot;</span> pragma is in scope then the
  lengths returned are calculated from the length of <span class="Li">$/</span>
  in Unicode characters, which is not always the same as the length of
  <span class="Li">$/</span> in the native encoding.
<p class="Pp">This pragma affects utf8::upgrade, but not utf8::downgrade.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="FEATURES_THAT_REQUIRE_5.8.1"><a class="permalink" href="#FEATURES_THAT_REQUIRE_5.8.1">FEATURES
  THAT REQUIRE 5.8.1</a></h1>
Some of the features offered by this pragma requires perl 5.8.1. Most of these
  are done by Inaba Hiroto. Any other features and changes are good for 5.8.0.
<dl class="Bl-tag">
  <dt>&quot;NON-EUC&quot; doublebyte encodings</dt>
  <dd>Because perl needs to parse script before applying this pragma, such
      encodings as Shift_JIS and Big-5 that may contain '\' (BACKSLASH; \x5c) in
      the second byte fails because the second byte may accidentally escape the
      quoting character that follows. Perl 5.8.1 or later fixes this
    problem.</dd>
  <dt>tr//</dt>
  <dd><span class="Li">&quot;tr//&quot;</span> was overlooked by Perl 5 porters
      when they released perl 5.8.0 See the section below for details.</dd>
  <dt>DATA pseudo-filehandle</dt>
  <dd>Another feature that was overlooked was
      <span class="Li">&quot;DATA&quot;</span>.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="USAGE"><a class="permalink" href="#USAGE">USAGE</a></h1>
<dl class="Bl-tag">
  <dt>use encoding [<i>ENCNAME</i>] ;</dt>
  <dd>Sets the script encoding to <i>ENCNAME</i>. And unless ${^UNICODE} exists
      and non-zero, PerlIO layers of STDIN and STDOUT are set to
      &quot;:encoding(<i>ENCNAME</i>)&quot;.
    <p class="Pp">Note that STDERR WILL NOT be changed.</p>
    <p class="Pp">Also note that non-STD file handles remain unaffected. Use
        <span class="Li">&quot;use</span> <span class="Li">open&quot;</span> or
        <span class="Li">&quot;binmode&quot;</span> to change layers of
      those.</p>
    <p class="Pp">If no encoding is specified, the environment variable
        PERL_ENCODING is consulted. If no encoding can be found, the error
        <span class="Li">&quot;Unknown encoding</span>
        <span class="Li">'</span><i>ENCNAME</i><span class="Li">'&quot;</span>
        will be thrown.</p>
  </dd>
  <dt>use encoding <i>ENCNAME</i> [ STDIN =&gt; <i>ENCNAME_IN</i> ...] ;</dt>
  <dd>You can also individually set encodings of STDIN and STDOUT via the
      <span class="Li">&quot;STDIN =&gt;
      </span><i>ENCNAME</i><span class="Li">&quot;</span> form. In this case,
      you cannot omit the first <i>ENCNAME</i>. <span class="Li">&quot;STDIN
      =&gt; undef&quot;</span> turns the IO transcoding completely off.
    <p class="Pp">When ${^UNICODE} exists and non-zero, these options will
        completely ignored. ${^UNICODE} is a variable introduced in perl 5.8.1.
        See perlrun see &quot;${^UNICODE}&quot; in perlvar and &quot;-C&quot; in
        perlrun for details (perl 5.8.1 and later).</p>
  </dd>
  <dt>use encoding <i>ENCNAME</i> Filter=&gt;1;</dt>
  <dd>This turns the encoding pragma into a source filter. While the default
      approach just decodes interpolated literals (in <i>qq()</i> and
      <i>qr()</i>), this will apply a source filter to the entire source code.
      See &quot;The Filter Option&quot; below for details.</dd>
  <dt>no encoding;</dt>
  <dd>Unsets the script encoding. The layers of STDIN, STDOUT are reset to
      &quot;:raw&quot; (the default unprocessed raw stream of bytes).</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="The_Filter_Option"><a class="permalink" href="#The_Filter_Option">The
  Filter Option</a></h1>
The magic of <span class="Li">&quot;use encoding&quot;</span> is not applied to
  the names of identifiers. In order to make
  <span class="Li">&quot;${&quot;\x{4eba}&quot;}++&quot;</span> ($human++, where
  human is a single Han ideograph) work, you still need to write your script in
  UTF-8 -- or use a source filter. That's what 'Filter=&gt;1' does.
<p class="Pp">What does this mean? Your source code behaves as if it is written
    in UTF-8 with 'use utf8' in effect. So even if your editor only supports
    Shift_JIS, for example, you can still try examples in Chapter 15 of
    <span class="Li">&quot;Programming Perl, 3rd Ed.&quot;</span>. For instance,
    you can use UTF-8 identifiers.</p>
<p class="Pp">This option is significantly slower and (as of this writing)
    non-ASCII identifiers are not very stable WITHOUT this option and with the
    source code written in UTF-8.</p>
<section class="Ss">
<h2 class="Ss" id="Filter-related_changes_at_Encode_version_1.87"><a class="permalink" href="#Filter-related_changes_at_Encode_version_1.87">Filter-related
  changes at Encode version 1.87</a></h2>
<ul class="Bl-bullet">
  <li>The Filter option now sets STDIN and STDOUT like non-filter options. And
      <span class="Li">&quot;STDIN=&gt;</span><i>ENCODING</i><span class="Li">&quot;</span>
      and
      <span class="Li">&quot;STDOUT=&gt;</span><i>ENCODING</i><span class="Li">&quot;</span>
      work like non-filter version.</li>
  <li><span class="Li">&quot;use utf8&quot;</span> is implicitly declared so you
      no longer have to <span class="Li">&quot;use</span>
      <span class="Li">utf8&quot;</span> to
      <span class="Li">&quot;${&quot;\x{4eba}&quot;}++&quot;</span>.</li>
</ul>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="CAVEATS"><a class="permalink" href="#CAVEATS">CAVEATS</a></h1>
<section class="Ss">
<h2 class="Ss" id="_s-1NOT_SCOPED_s0"><a class="permalink" href="#_s-1NOT_SCOPED_s0">NOT
  SCOPED</a></h2>
The pragma is a per script, not a per block lexical. Only the last
  <span class="Li">&quot;use encoding&quot;</span> or <span class="Li">&quot;no
  encoding&quot;</span> matters, and it affects <b>the whole script</b>.
  However, the &lt;no encoding&gt; pragma is supported and <b>use encoding</b>
  can appear as many times as you want in a given script. The multiple use of
  this pragma is discouraged.
<p class="Pp">By the same reason, the use this pragma inside modules is also
    discouraged (though not as strongly discouraged as the case above. See
    below).</p>
<p class="Pp">If you still have to write a module with this pragma, be very
    careful of the load order. See the codes below;</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  # called module
  package Module_IN_BAR;
  use encoding &quot;bar&quot;;
  # stuff in &quot;bar&quot; encoding here
  1;

  # caller script
  use encoding &quot;foo&quot;
  use Module_IN_BAR;
  # surprise! use encoding &quot;bar&quot; is in effect.
</pre>
<p class="Pp">The best way to avoid this oddity is to use this pragma RIGHT
    AFTER other modules are loaded. i.e.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  use Module_IN_BAR;
  use encoding &quot;foo&quot;;
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="_s-1DO_NOT_MIX_MULTIPLE_ENCODINGS_s0"><a class="permalink" href="#_s-1DO_NOT_MIX_MULTIPLE_ENCODINGS_s0">DO
  NOT MIX MULTIPLE ENCODINGS</a></h2>
Notice that only literals (string or regular expression) having only legacy code
  points are affected: if you mix data like this
<p class="Pp"><span class="Li"></span></p>
<pre>
    \xDF\x{100}
</pre>
<p class="Pp">the data is assumed to be in (Latin 1 and) Unicode, not in your
    native encoding. In other words, this will match in &quot;greek&quot;:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    &quot;\xDF&quot; =~ /\x{3af}/
</pre>
<p class="Pp">but this will not</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    &quot;\xDF\x{100}&quot; =~ /\x{3af}\x{100}/
</pre>
<p class="Pp">since the <span class="Li">&quot;\xDF&quot;</span> (ISO 8859-7
    GREEK SMALL LETTER IOTA WITH TONOS) on the left will <b>not</b> be upgraded
    to <span class="Li">&quot;\x{3af}&quot;</span> (Unicode GREEK SMALL LETTER
    IOTA WITH TONOS) because of the <span class="Li">&quot;\x{100}&quot;</span>
    on the left. You should not be mixing your legacy data and Unicode in the
    same string.</p>
<p class="Pp">This pragma also affects encoding of the 0x80..0xFF code point
    range: normally characters in that range are left as eight-bit bytes (unless
    they are combined with characters with code points 0x100 or larger, in which
    case all characters need to become UTF-8 encoded), but if the
    <span class="Li">&quot;encoding&quot;</span> pragma is present, even the
    0x80..0xFF range always gets UTF-8 encoded.</p>
<p class="Pp">After all, the best thing about this pragma is that you don't have
    to resort to \x{....} just to spell your name in a native encoding. So feel
    free to put your strings in your encoding in quotes and regexes.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="tr///_with_ranges"><a class="permalink" href="#tr///_with_ranges">tr///
  with ranges</a></h2>
The <b>encoding</b> pragma works by decoding string literals in
  <span class="Li">&quot;q//,qq//,qr//,qw///, qx//&quot;</span> and so forth. In
  perl 5.8.0, this does not apply to <span class="Li">&quot;tr///&quot;</span>.
  Therefore,
<p class="Pp"><span class="Li"></span></p>
<pre>
  use encoding 'euc-jp';
  #....
  $kana =~ tr/\xA4\xA1-\xA4\xF3/\xA5\xA1-\xA5\xF3/;
  #           -------- -------- -------- --------
</pre>
<p class="Pp">Does not work as</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  $kana =~ tr/\x{3041}-\x{3093}/\x{30a1}-\x{30f3}/;
</pre>
<dl class="Bl-tag">
  <dt>Legend of characters above</dt>
  <dd><span class="Li"></span>
    <pre>
  utf8     euc-jp   charnames::viacode()
  -----------------------------------------
  \x{3041} \xA4\xA1 HIRAGANA LETTER SMALL A
  \x{3093} \xA4\xF3 HIRAGANA LETTER N
  \x{30a1} \xA5\xA1 KATAKANA LETTER SMALL A
  \x{30f3} \xA5\xF3 KATAKANA LETTER N
    </pre>
  </dd>
</dl>
<p class="Pp">This counterintuitive behavior has been fixed in perl 5.8.1.</p>
<p class="Pp"><i>workaround to tr///;</i></p>
<p class="Pp">In perl 5.8.0, you can work around as follows;</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  use encoding 'euc-jp';
  #  ....
  eval qq{ \$kana =~ tr/\xA4\xA1-\xA4\xF3/\xA5\xA1-\xA5\xF3/ };
</pre>
<p class="Pp">Note the <span class="Li">&quot;tr//&quot;</span> expression is
    surrounded by <span class="Li">&quot;qq{}&quot;</span>. The idea behind is
    the same as classic idiom that makes
    <span class="Li">&quot;tr///&quot;</span> 'interpolate'.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
   tr/$from/$to/;            # wrong!
   eval qq{ tr/$from/$to/ }; # workaround.
</pre>
<p class="Pp">Nevertheless, in case of <b>encoding</b> pragma even
    <span class="Li">&quot;q//&quot;</span> is affected so
    <span class="Li">&quot;tr///&quot;</span> not being decoded was obviously
    against the will of Perl5 Porters so it has been fixed in Perl 5.8.1 or
    later.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="EXAMPLE__-_Greekperl"><a class="permalink" href="#EXAMPLE__-_Greekperl">EXAMPLE
  - Greekperl</a></h1>
<span class="Li"></span>
<pre>
    use encoding &quot;iso 8859-7&quot;;

    # \xDF in ISO 8859-7 (Greek) is \x{3af} in Unicode.

    $a = &quot;\xDF&quot;;
    $b = &quot;\x{100}&quot;;

    printf &quot;%#x\n&quot;, ord($a); # will print 0x3af, not 0xdf

    $c = $a . $b;

    # $c will be &quot;\x{3af}\x{100}&quot;, not &quot;\x{df}\x{100}&quot;.

    # chr() is affected, and ...

    print &quot;mega\n&quot;  if ord(chr(0xdf)) == 0x3af;

    # ... ord() is affected by the encoding pragma ...

    print &quot;tera\n&quot; if ord(pack(&quot;C&quot;, 0xdf)) == 0x3af;

    # ... as are eq and cmp ...

    print &quot;peta\n&quot; if &quot;\x{3af}&quot; eq  pack(&quot;C&quot;, 0xdf);
    print &quot;exa\n&quot;  if &quot;\x{3af}&quot; cmp pack(&quot;C&quot;, 0xdf) == 0;

    # ... but pack/unpack C are not affected, in case you still
    # want to go back to your native encoding

    print &quot;zetta\n&quot; if unpack(&quot;C&quot;, (pack(&quot;C&quot;, 0xdf))) == 0xdf;
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="KNOWN_PROBLEMS"><a class="permalink" href="#KNOWN_PROBLEMS">KNOWN
  PROBLEMS</a></h1>
<dl class="Bl-tag">
  <dt>literals in regex that are longer than 127 bytes</dt>
  <dd>For native multibyte encodings (either fixed or variable length), the
      current implementation of the regular expressions may introduce recoding
      errors for regular expression literals longer than 127 bytes.</dd>
  <dt>EBCDIC</dt>
  <dd>The encoding pragma is not supported on EBCDIC platforms. (Porters who are
      willing and able to remove this limitation are welcome.)</dd>
  <dt>format</dt>
  <dd>This pragma doesn't work well with format because PerlIO does not get
      along very well with it. When format contains non-ascii characters it
      prints funny or gets &quot;wide character warnings&quot;. To understand
      it, try the code below.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  # Save this one in utf8
  # replace *non-ascii* with a non-ascii string
  my $camel;
  format STDOUT =
  *non-ascii*@&gt;&gt;&gt;&gt;&gt;&gt;&gt;
  $camel
  .
  $camel = &quot;*non-ascii*&quot;;
  binmode(STDOUT=&gt;':encoding(utf8)'); # bang!
  write;              # funny
  print $camel, &quot;\n&quot;; # fine
    </pre>
    <p class="Pp">Without binmode this happens to work but without binmode,
        <i>print()</i> fails instead of <i>write()</i>.</p>
    <p class="Pp">At any rate, the very use of format is questionable when it
        comes to unicode characters since you have to consider such things as
        character width (i.e. double-width for ideographs) and directions (i.e.
        BIDI for Arabic and Hebrew).</p>
  </dd>
  <dt>Thread safety</dt>
  <dd><span class="Li">&quot;use encoding ...&quot;</span> is not thread-safe
      (i.e., do not use in threaded applications).</dd>
</dl>
<section class="Ss">
<h2 class="Ss" id="The_Logic_of_:locale"><a class="permalink" href="#The_Logic_of_:locale">The
  Logic of :locale</a></h2>
The logic of <span class="Li">&quot;:locale&quot;</span> is as follows:
<dl class="Bl-tag">
  <dt>1.</dt>
  <dd>If the platform supports the langinfo(CODESET) interface, the codeset
      returned is used as the default encoding for the open pragma.</dd>
  <dt>2.</dt>
  <dd>If 1. didn't work but we are under the locale pragma, the environment
      variables LC_ALL and LANG (in that order) are matched for encodings (the
      part after <span class="Li">&quot;.&quot;</span>, if any), and if any
      found, that is used as the default encoding for the open pragma.</dd>
  <dt>3.</dt>
  <dd>If 1. and 2. didn't work, the environment variables LC_ALL and LANG (in
      that order) are matched for anything looking like UTF-8, and if any found,
      <span class="Li">&quot;:utf8&quot;</span> is used as the default encoding
      for the open pragma.</dd>
</dl>
<p class="Pp">If your locale environment variables (LC_ALL, LC_CTYPE, LANG)
    contain the strings 'UTF-8' or 'UTF8' (case-insensitive matching), the
    default encoding of your STDIN, STDOUT, and STDERR, and of <b>any subsequent
    file open</b>, is UTF-8.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="HISTORY"><a class="permalink" href="#HISTORY">HISTORY</a></h1>
This pragma first appeared in Perl 5.8.0. For features that require 5.8.1 and
  better, see above.
<p class="Pp">The <span class="Li">&quot;:locale&quot;</span> subpragma was
    implemented in 2.01, or Perl 5.8.6.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
perlunicode, Encode, open, Filter::Util::Call,
<p class="Pp">Ch. 15 of <span class="Li">&quot;Programming Perl (3rd
    Edition)&quot;</span> by Larry Wall, Tom Christiansen, Jon Orwant; O'Reilly
    &amp; Associates; ISBN 0-596-00027-8</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2014-09-30</td>
    <td class="foot-os">perl v5.18.4</td>
  </tr>
</table>
</body>
</html>
