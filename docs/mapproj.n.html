<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Generated from file '/System/Volumes/Data/SWE/macOS/BuildRoots/6b362bc7f6/Library/Caches/com.apple.xbs/Sources/tcl/tcl-134/tcl_ext/tcllib/tcllib/modules/mapproj/mapproj.man' by tcllib/doctools with format 'nroff'
   Copyright (c) 2007 Kevin B. Kenny <kennykb@acm.org>
  
   The definitions below are for supplemental macros used in Tcl/Tk
   manual entries.
  
   .AP type name in/out ?indent?
  	Start paragraph describing an argument to a library procedure.
  	type is type of argument (int, etc.), in/out is either "in", "out",
  	or "in/out" to describe whether procedure reads or modifies arg,
  	and indent is equivalent to second arg of .IP (shouldn't ever be
  	needed;  use .AS below instead)
  
   .AS ?type? ?name?
  	Give maximum sizes of arguments for setting tab stops.  Type and
  	name are examples of largest possible arguments that will be passed
  	to .AP later.  If args are omitted, default tab stops are used.
  
   .BS
  	Start box enclosure.  From here until next .BE, everything will be
  	enclosed in one large box.
  
   .BE
  	End of box enclosure.
  
   .CS
  	Begin code excerpt.
  
   .CE
  	End code excerpt.
  
   .VS ?version? ?br?
  	Begin vertical sidebar, for use in marking newly-changed parts
  	of man pages.  The first argument is ignored and used for recording
  	the version when the .VS was added, so that the sidebars can be
  	found and removed when they reach a certain age.  If another argument
  	is present, then a line break is forced before starting the sidebar.
  
   .VE
  	End of vertical sidebar.
  
   .DS
  	Begin an indented unfilled display.
  
   .DE
  	End of indented unfilled display.
  
   .SO
  	Start of list of standard options for a Tk widget.  The
  	options follow on successive lines, in four columns separated
  	by tabs.
  
   .SE
  	End of list of standard options for a Tk widget.
  
   .OP cmdName dbName dbClass
  	Start of description of a specific option.  cmdName gives the
  	option's name as specified in the class command, dbName gives
  	the option's name in the option database, and dbClass gives
  	the option's class in the option database.
  
   .UL arg1 arg2
  	Print arg1 underlined, then print arg2 normally.
  
   RCS: @(#) $Id: man.macros,v 1.1 2009/01/30 04:56:47 andreas_kupries Exp $
  
  	# Set up traps and other miscellaneous stuff for Tcl/Tk man pages.
  	# Start an argument description
  .b
  	# define tabbing values for .AP
  
  	# BS - start boxed text
  	# ^y = starting y location
  	# ^b = 1
  	# BE - end boxed text (draw box now)
  	Draw four-sided box normally, but don't draw top of
  	box if the box started on an earlier page.
  	# VS - start vertical sidebar
  	# ^Y = starting y location
  	# ^v = 1 (for troff;  for nroff this doesn't matter)
  	# VE - end of vertical sidebar
  	# Special macro to handle page bottom:  finish off current
  	# box/sidebar if in box/sidebar mode, then invoked standard
  	# page bottom macro.
  	Draw three-sided box if this is the box's first page,
  	draw two sides but no top otherwise.
  	# DS - begin display
  	# DE - end display
  	# SO - start of list of standard options
  	# SE - end of list of standard options
  	# OP - start of full description for a single option
  	# CS - begin code excerpt
  	# CE - end code excerpt
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>mapproj(n)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">mapproj(n)</td>
    <td class="head-vol">Tcl Library</td>
    <td class="head-rtitle">mapproj(n)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<pre>

</pre>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
mapproj - Map projection routines
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
package require <b>Tcl ?8.4?</b>
<p class="Pp">package require <b>math::interpolate ?1.0?</b></p>
<p class="Pp">package require <b>math::special ?0.2.1?</b></p>
<p class="Pp">package require <b>mapproj ?1.0?</b></p>
<p class="Pp"><b>::mapproj::toPlateCarree</b> <i>lambda_0</i> <i>phi_0</i>
    <i>lambda</i> <i>phi</i></p>
<p class="Pp"><b>::mapproj::fromPlateCarree</b> <i>lambda_0</i> <i>phi_0</i>
    <i>x</i> <i>y</i></p>
<p class="Pp"><b>::mapproj::toCylindricalEqualArea</b> <i>lambda_0</i>
    <i>phi_0</i> <i>lambda</i> <i>phi</i></p>
<p class="Pp"><b>::mapproj::fromCylindricalEqualArea</b> <i>lambda_0</i>
    <i>phi_0</i> <i>x</i> <i>y</i></p>
<p class="Pp"><b>::mapproj::toMercator</b> <i>lambda_0</i> <i>phi_0</i>
    <i>lambda</i> <i>phi</i></p>
<p class="Pp"><b>::mapproj::fromMercator</b> <i>lambda_0</i> <i>phi_0</i>
    <i>x</i> <i>y</i></p>
<p class="Pp"><b>::mapproj::toMillerCylindrical</b> <i>lambda_0</i>
    <i>lambda</i> <i>phi</i></p>
<p class="Pp"><b>::mapproj::fromMillerCylindrical</b> <i>lambda_0</i> <i>x</i>
    <i>y</i></p>
<p class="Pp"><b>::mapproj::toSinusoidal</b> <i>lambda_0</i> <i>phi_0</i>
    <i>lambda</i> <i>phi</i></p>
<p class="Pp"><b>::mapproj::fromSinusoidal</b> <i>lambda_0</i> <i>phi_0</i>
    <i>x</i> <i>y</i></p>
<p class="Pp"><b>::mapproj::toMollweide</b> <i>lambda_0</i> <i>lambda</i>
    <i>phi</i></p>
<p class="Pp"><b>::mapproj::fromMollweide</b> <i>lambda_0</i> <i>x</i>
  <i>y</i></p>
<p class="Pp"><b>::mapproj::toEckertIV</b> <i>lambda_0</i> <i>lambda</i>
    <i>phi</i></p>
<p class="Pp"><b>::mapproj::fromEckertIV</b> <i>lambda_0</i> <i>x</i>
  <i>y</i></p>
<p class="Pp"><b>::mapproj::toEckertVI</b> <i>lambda_0</i> <i>lambda</i>
    <i>phi</i></p>
<p class="Pp"><b>::mapproj::fromEckertVI</b> <i>lambda_0</i> <i>x</i>
  <i>y</i></p>
<p class="Pp"><b>::mapproj::toRobinson</b> <i>lambda_0</i> <i>lambda</i>
    <i>phi</i></p>
<p class="Pp"><b>::mapproj::fromRobinson</b> <i>lambda_0</i> <i>x</i>
  <i>y</i></p>
<p class="Pp"><b>::mapproj::toCassini</b> <i>lambda_0</i> <i>phi_0</i>
    <i>lambda</i> <i>phi</i></p>
<p class="Pp"><b>::mapproj::fromCassini</b> <i>lambda_0</i> <i>phi_0</i>
    <i>x</i> <i>y</i></p>
<p class="Pp"><b>::mapproj::toPeirceQuincuncial</b> <i>lambda_0</i>
    <i>lambda</i> <i>phi</i></p>
<p class="Pp"><b>::mapproj::fromPeirceQuincuncial</b> <i>lambda_0</i> <i>x</i>
    <i>y</i></p>
<p class="Pp"><b>::mapproj::toOrthographic</b> <i>lambda_0</i> <i>phi_0</i>
    <i>lambda</i> <i>phi</i></p>
<p class="Pp"><b>::mapproj::fromOrthographic</b> <i>lambda_0</i> <i>phi_0</i>
    <i>x</i> <i>y</i></p>
<p class="Pp"><b>::mapproj::toStereographic</b> <i>lambda_0</i> <i>phi_0</i>
    <i>lambda</i> <i>phi</i></p>
<p class="Pp"><b>::mapproj::fromStereographic</b> <i>lambda_0</i> <i>phi_0</i>
    <i>x</i> <i>y</i></p>
<p class="Pp"><b>::mapproj::toGnomonic</b> <i>lambda_0</i> <i>phi_0</i>
    <i>lambda</i> <i>phi</i></p>
<p class="Pp"><b>::mapproj::fromGnomonic</b> <i>lambda_0</i> <i>phi_0</i>
    <i>x</i> <i>y</i></p>
<p class="Pp"><b>::mapproj::toAzimuthalEquidistant</b> <i>lambda_0</i>
    <i>phi_0</i> <i>lambda</i> <i>phi</i></p>
<p class="Pp"><b>::mapproj::fromAzimuthalEquidistant</b> <i>lambda_0</i>
    <i>phi_0</i> <i>x</i> <i>y</i></p>
<p class="Pp"><b>::mapproj::toLambertAzimuthalEqualArea</b> <i>lambda_0</i>
    <i>phi_0</i> <i>lambda</i> <i>phi</i></p>
<p class="Pp"><b>::mapproj::fromLambertAzimuthalEqualArea</b> <i>lambda_0</i>
    <i>phi_0</i> <i>x</i> <i>y</i></p>
<p class="Pp"><b>::mapproj::toHammer</b> <i>lambda_0</i> <i>lambda</i>
    <i>phi</i></p>
<p class="Pp"><b>::mapproj::fromHammer</b> <i>lambda_0</i> <i>x</i> <i>y</i></p>
<p class="Pp"><b>::mapproj::toConicEquidistant</b> <i>lambda_0</i> <i>phi_0</i>
    <i>phi_1</i> <i>phi_2</i> <i>lambda</i> <i>phi</i></p>
<p class="Pp"><b>::mapproj::fromConicEquidistant</b> <i>lambda_0</i>
    <i>phi_0</i> <i>phi_1</i> <i>phi_2</i> <i>x</i> <i>y</i></p>
<p class="Pp"><b>::mapproj::toAlbersEqualAreaConic</b> <i>lambda_0</i>
    <i>phi_0</i> <i>phi_1</i> <i>phi_2</i> <i>lambda</i> <i>phi</i></p>
<p class="Pp"><b>::mapproj::fromAlbersEqualAreaConic</b> <i>lambda_0</i>
    <i>phi_0</i> <i>phi_1</i> <i>phi_2</i> <i>x</i> <i>y</i></p>
<p class="Pp"><b>::mapproj::toLambertConformalConic</b> <i>lambda_0</i>
    <i>phi_0</i> <i>phi_1</i> <i>phi_2</i> <i>lambda</i> <i>phi</i></p>
<p class="Pp"><b>::mapproj::fromLambertConformalConic</b> <i>lambda_0</i>
    <i>phi_0</i> <i>phi_1</i> <i>phi_2</i> <i>x</i> <i>y</i></p>
<p class="Pp"><b>::mapproj::toLambertCylindricalEqualArea</b> <i>lambda_0</i>
    <i>phi_0</i> <i>lambda</i> <i>phi</i></p>
<p class="Pp"><b>::mapproj::fromLambertCylindricalEqualArea</b> <i>lambda_0</i>
    <i>phi_0</i> <i>x</i> <i>y</i></p>
<p class="Pp"><b>::mapproj::toBehrmann</b> <i>lambda_0</i> <i>phi_0</i>
    <i>lambda</i> <i>phi</i></p>
<p class="Pp"><b>::mapproj::fromBehrmann</b> <i>lambda_0</i> <i>phi_0</i>
    <i>x</i> <i>y</i></p>
<p class="Pp"><b>::mapproj::toTrystanEdwards</b> <i>lambda_0</i> <i>phi_0</i>
    <i>lambda</i> <i>phi</i></p>
<p class="Pp"><b>::mapproj::fromTrystanEdwards</b> <i>lambda_0</i> <i>phi_0</i>
    <i>x</i> <i>y</i></p>
<p class="Pp"><b>::mapproj::toHoboDyer</b> <i>lambda_0</i> <i>phi_0</i>
    <i>lambda</i> <i>phi</i></p>
<p class="Pp"><b>::mapproj::fromHoboDyer</b> <i>lambda_0</i> <i>phi_0</i>
    <i>x</i> <i>y</i></p>
<p class="Pp"><b>::mapproj::toGallPeters</b> <i>lambda_0</i> <i>phi_0</i>
    <i>lambda</i> <i>phi</i></p>
<p class="Pp"><b>::mapproj::fromGallPeters</b> <i>lambda_0</i> <i>phi_0</i>
    <i>x</i> <i>y</i></p>
<p class="Pp"><b>::mapproj::toBalthasart</b> <i>lambda_0</i> <i>phi_0</i>
    <i>lambda</i> <i>phi</i></p>
<p class="Pp"><b>::mapproj::fromBalthasart</b> <i>lambda_0</i> <i>phi_0</i>
    <i>x</i> <i>y</i></p>
<p class="Pp"></p>
<pre>

</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
The <b>mapproj</b> package provides a set of procedures for converting between
  world co-ordinates (latitude and longitude) and map co-ordinates on a number
  of different map projections.
</section>
<section class="Sh">
<h1 class="Sh" id="COMMANDS"><a class="permalink" href="#COMMANDS">COMMANDS</a></h1>
The following commands convert between world co-ordinates and map co-ordinates:
<dl class="Bl-tag">
  <dt><b>::mapproj::toPlateCarree</b> <i>lambda_0</i> <i>phi_0</i> <i>lambda</i>
    <i>phi</i></dt>
  <dd>Converts to the <i>plate carr&#x00E9;e</i> (cylindrical equidistant)
      projection.</dd>
  <dt><b>::mapproj::fromPlateCarree</b> <i>lambda_0</i> <i>phi_0</i> <i>x</i>
    <i>y</i></dt>
  <dd>Converts from the <i>plate carr&#x00E9;e</i> (cylindrical equidistant)
      projection.</dd>
  <dt><b>::mapproj::toCylindricalEqualArea</b> <i>lambda_0</i> <i>phi_0</i>
    <i>lambda</i> <i>phi</i></dt>
  <dd>Converts to the cylindrical equal-area projection.</dd>
  <dt><b>::mapproj::fromCylindricalEqualArea</b> <i>lambda_0</i> <i>phi_0</i>
    <i>x</i> <i>y</i></dt>
  <dd>Converts from the cylindrical equal-area projection.</dd>
  <dt><b>::mapproj::toMercator</b> <i>lambda_0</i> <i>phi_0</i> <i>lambda</i>
    <i>phi</i></dt>
  <dd>Converts to the Mercator (cylindrical conformal) projection.</dd>
  <dt><b>::mapproj::fromMercator</b> <i>lambda_0</i> <i>phi_0</i> <i>x</i>
    <i>y</i></dt>
  <dd>Converts from the Mercator (cylindrical conformal) projection.</dd>
  <dt><b>::mapproj::toMillerCylindrical</b> <i>lambda_0</i> <i>lambda</i>
    <i>phi</i></dt>
  <dd>Converts to the Miller Cylindrical projection.</dd>
  <dt><b>::mapproj::fromMillerCylindrical</b> <i>lambda_0</i> <i>x</i>
    <i>y</i></dt>
  <dd>Converts from the Miller Cylindrical projection.</dd>
  <dt><b>::mapproj::toSinusoidal</b> <i>lambda_0</i> <i>phi_0</i> <i>lambda</i>
    <i>phi</i></dt>
  <dd>Converts to the sinusoidal (Sanson-Flamsteed) projection. projection.</dd>
  <dt><b>::mapproj::fromSinusoidal</b> <i>lambda_0</i> <i>phi_0</i> <i>x</i>
    <i>y</i></dt>
  <dd>Converts from the sinusoidal (Sanson-Flamsteed) projection.
    projection.</dd>
  <dt><b>::mapproj::toMollweide</b> <i>lambda_0</i> <i>lambda</i>
    <i>phi</i></dt>
  <dd>Converts to the Mollweide projection.</dd>
  <dt><b>::mapproj::fromMollweide</b> <i>lambda_0</i> <i>x</i> <i>y</i></dt>
  <dd>Converts from the Mollweide projection.</dd>
  <dt><b>::mapproj::toEckertIV</b> <i>lambda_0</i> <i>lambda</i> <i>phi</i></dt>
  <dd>Converts to the Eckert IV projection.</dd>
  <dt><b>::mapproj::fromEckertIV</b> <i>lambda_0</i> <i>x</i> <i>y</i></dt>
  <dd>Converts from the Eckert IV projection.</dd>
  <dt><b>::mapproj::toEckertVI</b> <i>lambda_0</i> <i>lambda</i> <i>phi</i></dt>
  <dd>Converts to the Eckert VI projection.</dd>
  <dt><b>::mapproj::fromEckertVI</b> <i>lambda_0</i> <i>x</i> <i>y</i></dt>
  <dd>Converts from the Eckert VI projection.</dd>
  <dt><b>::mapproj::toRobinson</b> <i>lambda_0</i> <i>lambda</i> <i>phi</i></dt>
  <dd>Converts to the Robinson projection.</dd>
  <dt><b>::mapproj::fromRobinson</b> <i>lambda_0</i> <i>x</i> <i>y</i></dt>
  <dd>Converts from the Robinson projection.</dd>
  <dt><b>::mapproj::toCassini</b> <i>lambda_0</i> <i>phi_0</i> <i>lambda</i>
    <i>phi</i></dt>
  <dd>Converts to the Cassini (transverse cylindrical equidistant)
    projection.</dd>
  <dt><b>::mapproj::fromCassini</b> <i>lambda_0</i> <i>phi_0</i> <i>x</i>
    <i>y</i></dt>
  <dd>Converts from the Cassini (transverse cylindrical equidistant)
    projection.</dd>
  <dt><b>::mapproj::toPeirceQuincuncial</b> <i>lambda_0</i> <i>lambda</i>
    <i>phi</i></dt>
  <dd>Converts to the Peirce Quincuncial Projection.</dd>
  <dt><b>::mapproj::fromPeirceQuincuncial</b> <i>lambda_0</i> <i>x</i>
    <i>y</i></dt>
  <dd>Converts from the Peirce Quincuncial Projection.</dd>
  <dt><b>::mapproj::toOrthographic</b> <i>lambda_0</i> <i>phi_0</i>
    <i>lambda</i> <i>phi</i></dt>
  <dd>Converts to the orthographic projection.</dd>
  <dt><b>::mapproj::fromOrthographic</b> <i>lambda_0</i> <i>phi_0</i> <i>x</i>
    <i>y</i></dt>
  <dd>Converts from the orthographic projection.</dd>
  <dt><b>::mapproj::toStereographic</b> <i>lambda_0</i> <i>phi_0</i>
    <i>lambda</i> <i>phi</i></dt>
  <dd>Converts to the stereographic (azimuthal conformal) projection.</dd>
  <dt><b>::mapproj::fromStereographic</b> <i>lambda_0</i> <i>phi_0</i> <i>x</i>
    <i>y</i></dt>
  <dd>Converts from the stereographic (azimuthal conformal) projection.</dd>
  <dt><b>::mapproj::toGnomonic</b> <i>lambda_0</i> <i>phi_0</i> <i>lambda</i>
    <i>phi</i></dt>
  <dd>Converts to the gnomonic projection.</dd>
  <dt><b>::mapproj::fromGnomonic</b> <i>lambda_0</i> <i>phi_0</i> <i>x</i>
    <i>y</i></dt>
  <dd>Converts from the gnomonic projection.</dd>
  <dt><b>::mapproj::toAzimuthalEquidistant</b> <i>lambda_0</i> <i>phi_0</i>
    <i>lambda</i> <i>phi</i></dt>
  <dd>Converts to the azimuthal equidistant projection.</dd>
  <dt><b>::mapproj::fromAzimuthalEquidistant</b> <i>lambda_0</i> <i>phi_0</i>
    <i>x</i> <i>y</i></dt>
  <dd>Converts from the azimuthal equidistant projection.</dd>
  <dt><b>::mapproj::toLambertAzimuthalEqualArea</b> <i>lambda_0</i> <i>phi_0</i>
    <i>lambda</i> <i>phi</i></dt>
  <dd>Converts to the Lambert azimuthal equal-area projection.</dd>
  <dt><b>::mapproj::fromLambertAzimuthalEqualArea</b> <i>lambda_0</i>
    <i>phi_0</i> <i>x</i> <i>y</i></dt>
  <dd>Converts from the Lambert azimuthal equal-area projection.</dd>
  <dt><b>::mapproj::toHammer</b> <i>lambda_0</i> <i>lambda</i> <i>phi</i></dt>
  <dd>Converts to the Hammer projection.</dd>
  <dt><b>::mapproj::fromHammer</b> <i>lambda_0</i> <i>x</i> <i>y</i></dt>
  <dd>Converts from the Hammer projection.</dd>
  <dt><b>::mapproj::toConicEquidistant</b> <i>lambda_0</i> <i>phi_0</i>
    <i>phi_1</i> <i>phi_2</i> <i>lambda</i> <i>phi</i></dt>
  <dd>Converts to the conic equidistant projection.</dd>
  <dt><b>::mapproj::fromConicEquidistant</b> <i>lambda_0</i> <i>phi_0</i>
    <i>phi_1</i> <i>phi_2</i> <i>x</i> <i>y</i></dt>
  <dd>Converts from the conic equidistant projection.</dd>
  <dt><b>::mapproj::toAlbersEqualAreaConic</b> <i>lambda_0</i> <i>phi_0</i>
    <i>phi_1</i> <i>phi_2</i> <i>lambda</i> <i>phi</i></dt>
  <dd>Converts to the Albers equal-area conic projection.</dd>
  <dt><b>::mapproj::fromAlbersEqualAreaConic</b> <i>lambda_0</i> <i>phi_0</i>
    <i>phi_1</i> <i>phi_2</i> <i>x</i> <i>y</i></dt>
  <dd>Converts from the Albers equal-area conic projection.</dd>
  <dt><b>::mapproj::toLambertConformalConic</b> <i>lambda_0</i> <i>phi_0</i>
    <i>phi_1</i> <i>phi_2</i> <i>lambda</i> <i>phi</i></dt>
  <dd>Converts to the Lambert conformal conic projection.</dd>
  <dt><b>::mapproj::fromLambertConformalConic</b> <i>lambda_0</i> <i>phi_0</i>
    <i>phi_1</i> <i>phi_2</i> <i>x</i> <i>y</i></dt>
  <dd>Converts from the Lambert conformal conic projection.</dd>
</dl>
<p class="Pp">Among the cylindrical equal-area projections, there are a number
    of choices of standard parallels that have names:</p>
<dl class="Bl-tag">
  <dt><b>::mapproj::toLambertCylindricalEqualArea</b> <i>lambda_0</i>
    <i>phi_0</i> <i>lambda</i> <i>phi</i></dt>
  <dd>Converts to the Lambert cylindrical equal area projection. (standard
      parallel is the Equator.)</dd>
  <dt><b>::mapproj::fromLambertCylindricalEqualArea</b> <i>lambda_0</i>
    <i>phi_0</i> <i>x</i> <i>y</i></dt>
  <dd>Converts from the Lambert cylindrical equal area projection. (standard
      parallel is the Equator.)</dd>
  <dt><b>::mapproj::toBehrmann</b> <i>lambda_0</i> <i>phi_0</i> <i>lambda</i>
    <i>phi</i></dt>
  <dd>Converts to the Behrmann cylindrical equal area projection. (standard
      parallels are 30 degrees North and South)</dd>
  <dt><b>::mapproj::fromBehrmann</b> <i>lambda_0</i> <i>phi_0</i> <i>x</i>
    <i>y</i></dt>
  <dd>Converts from the Behrmann cylindrical equal area projection. (standard
      parallels are 30 degrees North and South.)</dd>
  <dt><b>::mapproj::toTrystanEdwards</b> <i>lambda_0</i> <i>phi_0</i>
    <i>lambda</i> <i>phi</i></dt>
  <dd>Converts to the Trystan Edwards cylindrical equal area projection.
      (standard parallels are 37.4 degrees North and South)</dd>
  <dt><b>::mapproj::fromTrystanEdwards</b> <i>lambda_0</i> <i>phi_0</i> <i>x</i>
    <i>y</i></dt>
  <dd>Converts from the Trystan Edwards cylindrical equal area projection.
      (standard parallels are 37.4 degrees North and South.)</dd>
  <dt><b>::mapproj::toHoboDyer</b> <i>lambda_0</i> <i>phi_0</i> <i>lambda</i>
    <i>phi</i></dt>
  <dd>Converts to the Hobo-Dyer cylindrical equal area projection. (standard
      parallels are 37.5 degrees North and South)</dd>
  <dt><b>::mapproj::fromHoboDyer</b> <i>lambda_0</i> <i>phi_0</i> <i>x</i>
    <i>y</i></dt>
  <dd>Converts from the Hobo-Dyer cylindrical equal area projection. (standard
      parallels are 37.5 degrees North and South.)</dd>
  <dt><b>::mapproj::toGallPeters</b> <i>lambda_0</i> <i>phi_0</i> <i>lambda</i>
    <i>phi</i></dt>
  <dd>Converts to the Gall-Peters cylindrical equal area projection. (standard
      parallels are 45 degrees North and South)</dd>
  <dt><b>::mapproj::fromGallPeters</b> <i>lambda_0</i> <i>phi_0</i> <i>x</i>
    <i>y</i></dt>
  <dd>Converts from the Gall-Peters cylindrical equal area projection. (standard
      parallels are 45 degrees North and South.)</dd>
  <dt><b>::mapproj::toBalthasart</b> <i>lambda_0</i> <i>phi_0</i> <i>lambda</i>
    <i>phi</i></dt>
  <dd>Converts to the Balthasart cylindrical equal area projection. (standard
      parallels are 50 degrees North and South)</dd>
  <dt><b>::mapproj::fromBalthasart</b> <i>lambda_0</i> <i>phi_0</i> <i>x</i>
    <i>y</i></dt>
  <dd>Converts from the Balthasart cylindrical equal area projection. (standard
      parallels are 50 degrees North and South.)</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="ARGUMENTS"><a class="permalink" href="#ARGUMENTS">ARGUMENTS</a></h1>
The following arguments are accepted by the projection commands:
<dl class="Bl-tag">
  <dt><i>lambda</i></dt>
  <dd>Longitude of the point to be projected, in degrees.</dd>
  <dt><i>phi</i></dt>
  <dd>Latitude of the point to be projected, in degrees.</dd>
  <dt><i>lambda_0</i></dt>
  <dd>Longitude of the center of the sheet, in degrees. For many projections,
      this figure is also the reference meridian of the projection.</dd>
  <dt><i>phi_0</i></dt>
  <dd>Latitude of the center of the sheet, in degrees. For the azimuthal
      projections, this figure is also the latitude of the center of the
      projection.</dd>
  <dt><i>phi_1</i></dt>
  <dd>Latitude of the first reference parallel, for projections that use
      reference parallels.</dd>
  <dt><i>phi_2</i></dt>
  <dd>Latitude of the second reference parallel, for projections that use
      reference parallels.</dd>
  <dt><i>x</i></dt>
  <dd>X co-ordinate of a point on the map, in units of Earth radii.</dd>
  <dt><i>y</i></dt>
  <dd>Y co-ordinate of a point on the map, in units of Earth radii.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="RESULTS"><a class="permalink" href="#RESULTS">RESULTS</a></h1>
For all of the procedures whose names begin with 'to', the return value is a
  list comprising an <i>x</i> co-ordinate and a <i>y</i> co-ordinate. The
  co-ordinates are relative to the center of the map sheet to be drawn, measured
  in Earth radii at the reference location on the map. For all of the functions
  whose names begin with 'from', the return value is a list comprising the
  longitude and latitude, in degrees.
</section>
<section class="Sh">
<h1 class="Sh" id="CHOOSING_A_PROJECTION"><a class="permalink" href="#CHOOSING_A_PROJECTION">CHOOSING
  A PROJECTION</a></h1>
This package offers a great many projections, because no single projection is
  appropriate to all maps. This section attempts to provide guidance on how to
  choose a projection.
<p class="Pp">First, consider the type of data that you intend to display on the
    map. If the data are <i>directional</i> (<i>e.g.,</i> winds, ocean currents,
    or magnetic fields) then you need to use a projection that preserves angles;
    these are known as <i>conformal</i> projections. Conformal projections
    include the Mercator, the Albers azimuthal equal-area, the stereographic,
    and the Peirce Quincuncial projection. If the data are <i>thematic</i>,
    describing properties of land or water, such as temperature, population
    density, land use, or demographics; then you need a projection that will
    show these data with the areas on the map proportional to the areas in real
    life. These so-called <i>equal area</i> projections include the various
    cylindrical equal area projections, the sinusoidal projection, the Lambert
    azimuthal equal-area projection, the Albers equal-area conic projection, and
    several of the world-map projections (Miller Cylindrical, Mollweide, Eckert
    IV, Eckert VI, Robinson, and Hammer). If the significant factor in your data
    is distance from a central point or line (such as air routes), then you will
    do best with an <i>equidistant</i> projection such as <i>plate
    carr&#x00E9;e</i>, Cassini, azimuthal equidistant, or conic equidistant. If
    direction from a central point is a critical factor in your data (for
    instance, air routes, radio antenna pointing), then you will almost surely
    want to use one of the azimuthal projections. Appropriate choices are
    azimuthal equidistant, azimuthal equal-area, stereographic, and perhaps
    orthographic.</p>
<p class="Pp">Next, consider how much of the Earth your map will cover, and the
    general shape of the area of interest. For maps of the entire Earth, the
    cylindrical equal area, Eckert IV and VI, Mollweide, Robinson, and Hammer
    projections are good overall choices. The Mercator projection is
    traditional, but the extreme distortions of area at high latitudes make it a
    poor choice unless a conformal projection is required. The Peirce projection
    is a better choice of conformal projection, having less distortion of
    landforms. The Miller Cylindrical is a compromise designed to give shapes
    similar to the traditional Mercator, but with less polar stretching. The
    Peirce Quincuncial projection shows all the continents with acceptable
    distortion if a reference meridian close to +20 degrees is chosen. The
    Robinson projection yields attractive maps for things like political
    divisions, but should be avoided in presenting scientific data, since other
    projections have moe useful geometric properties.</p>
<p class="Pp">If the map will cover a hemisphere, then choose stereographic,
    azimuthal-equidistant, Hammer, or Mollweide projections; these all project
    the hemisphere into a circle.</p>
<p class="Pp">If the map will cover a large area (at least a few hundred km on a
    side), but less than a hemisphere, then you have several choices. Azimuthal
    projections are usually good (choose stereographic, azimuthal equidistant,
    or Lambert azimuthal equal-area according to whether shapes, distances from
    a central point, or areas are important). Azimuthal projections (and
    possibly the Cassini projection) are the only really good choices for
    mapping the polar regions.</p>
<p class="Pp">If the large area is in one of the temperate zones and is round or
    has a primarily east-west extent, then the conic projections are good
    choices. Choose the Lambert conformal conic, the conic equidistant, or the
    Albers equal-area conic according to whether shape, distance, or area are
    the most important parameters. For any of these, the reference parallels
    should be chosen at approximately 1/6 and 5/6 of the range of latitudes to
    be displayed. For instance, maps of the 48 coterminous United States are
    attractive with reference parallels of 28.5 and 45.5 degrees.</p>
<p class="Pp">If the large area is equatorial and is round or has a primarily
    east-west extent, then the Mercator projection is a good choice for a
    conformal projection; Lambert cylindrical equal-area and sinusoidal
    projections are good equal-area projections; and the <i>plate
    carr&#x00E9;e</i> is a good equidistant projection.</p>
<p class="Pp">Large areas having a primarily North-South aspect, particularly
    those spanning the Equator, need some other choices. The Cassini projection
    is a good choice for an equidistant projection (for instance, a Cassini
    projection with a central meridian of 80 degrees West produces an attractive
    map of the Americas). The cylindrical equal-area, Albers equal-area conic,
    sinusoidal, Mollweide and Hammer projections are possible choices for
    equal-area projections. A good conformal projection in this situation is the
    Transverse Mercator, which alas, is not yet implemented.</p>
<p class="Pp">Small areas begin to get into a realm where the ellipticity of the
    Earth affects the map scale. This package does not attempt to handle
    accurate mapping for large-scale topographic maps. If slight scale errors
    are acceptable in your application, then any of the projections appropriate
    to large areas should work for small ones as well.</p>
<p class="Pp">There are a few projections that are included for their special
    properties. The orthographic projection produces views of the Earth as seen
    from space. The gnomonic projection produces a map on which all great
    circles (the shortest distance between two points on the Earth's surface)
    are rendered as straight lines. While this projection is useful for
    navigational planning, it has extreme distortions of shape and area, and can
    display only a limited area of the Earth (substantially less than a
    hemisphere).</p>
</section>
<section class="Sh">
<h1 class="Sh" id="KEYWORDS"><a class="permalink" href="#KEYWORDS">KEYWORDS</a></h1>
geodesy, map, projection
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT"><a class="permalink" href="#COPYRIGHT">COPYRIGHT</a></h1>
<pre>
Copyright (c) 2007 Kevin B. Kenny &lt;kennykb@acm.org&gt;
</pre>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">0.1</td>
    <td class="foot-os">mapproj</td>
  </tr>
</table>
</body>
</html>
