<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.10 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>Test::Tutorial(3pm)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Test::Tutorial(3pm)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">Test::Tutorial(3pm)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
Test::Tutorial - A tutorial about writing really basic tests
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<i>AHHHHHHH!!!! NOT TESTING! Anything but testing!</i> <i>Beat me, whip me, send
  me to Detroit, but don't make</i> <i>me write tests!</i>
<p class="Pp"><i>*sob*</i></p>
<p class="Pp"><i>Besides, I don't know how to write the damned things.</i></p>
<p class="Pp">Is this you? Is writing tests right up there with writing
    documentation and having your fingernails pulled out? Did you open up a test
    and read</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    ######## We start with some black magic
</pre>
<p class="Pp">and decide that's quite enough for you?</p>
<p class="Pp">It's ok. That's all gone now. We've done all the black magic for
    you. And here are the tricks...</p>
<section class="Ss">
<h2 class="Ss" id="Nuts_and_bolts_of_testing."><a class="permalink" href="#Nuts_and_bolts_of_testing.">Nuts
  and bolts of testing.</a></h2>
Here's the most basic test program.
<p class="Pp"><span class="Li"></span></p>
<pre>
    #!/usr/bin/perl -w

    print &quot;1..1\n&quot;;

    print 1 + 1 == 2 ? &quot;ok 1\n&quot; : &quot;not ok 1\n&quot;;
</pre>
<p class="Pp">Because 1 + 1 is 2, it prints:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    1..1
    ok 1
</pre>
<p class="Pp">What this says is: <span class="Li">1..1</span> &quot;I'm going to
    run one test.&quot; [1] <span class="Li">&quot;ok 1&quot;</span> &quot;The
    first test passed&quot;. And that's about all magic there is to testing.
    Your basic unit of testing is the <i>ok</i>. For each thing you test, an
    <span class="Li">&quot;ok&quot;</span> is printed. Simple. Test::Harness
    interprets your test results to determine if you succeeded or failed (more
    on that later).</p>
<p class="Pp">Writing all these print statements rapidly gets tedious.
    Fortunately, there's Test::Simple. It has one function,
    <span class="Li">&quot;ok()&quot;</span>.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    #!/usr/bin/perl -w

    use Test::Simple tests =&gt; 1;

    ok( 1 + 1 == 2 );
</pre>
<p class="Pp">That does the same thing as the previous code.
    <span class="Li">&quot;ok()&quot;</span> is the backbone of Perl testing,
    and we'll be using it instead of roll-your-own from here on. If
    <span class="Li">&quot;ok()&quot;</span> gets a true value, the test passes.
    False, it fails.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    #!/usr/bin/perl -w

    use Test::Simple tests =&gt; 2;
    ok( 1 + 1 == 2 );
    ok( 2 + 2 == 5 );
</pre>
<p class="Pp">From that comes:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    1..2
    ok 1
    not ok 2
    #     Failed test (test.pl at line 5)
    # Looks like you failed 1 tests of 2.
</pre>
<p class="Pp"><span class="Li">1..2</span> &quot;I'm going to run two
    tests.&quot; This number is a <i>plan</i>. It helps to ensure your test
    program ran all the way through and didn't die or skip some tests.
    <span class="Li">&quot;ok 1&quot;</span> &quot;The first test passed.&quot;
    <span class="Li">&quot;not ok 2&quot;</span> &quot;The second test
    failed&quot;. Test::Simple helpfully prints out some extra commentary about
    your tests.</p>
<p class="Pp">It's not scary. Come, hold my hand. We're going to give an example
    of testing a module. For our example, we'll be testing a date library,
    Date::ICal. It's on CPAN, so download a copy and follow along. [2]</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Where_to_start?"><a class="permalink" href="#Where_to_start?">Where
  to start?</a></h2>
This is the hardest part of testing, where do you start? People often get
  overwhelmed at the apparent enormity of the task of testing a whole module.
  The best place to start is at the beginning. Date::ICal is an object-oriented
  module, and that means you start by making an object. Test
  <span class="Li">&quot;new()&quot;</span>.
<p class="Pp"><span class="Li"></span></p>
<pre>
    #!/usr/bin/perl -w

    # assume these two lines are in all subsequent examples
    use strict;
    use warnings;

    use Test::Simple tests =&gt; 2;

    use Date::ICal;

    my $ical = Date::ICal-&gt;new;         # create an object
    ok( defined $ical );                # check that we got something
    ok( $ical-&gt;isa('Date::ICal') );     # and it's the right class
</pre>
<p class="Pp">Run that and you should get:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    1..2
    ok 1
    ok 2
</pre>
<p class="Pp">Congratulations! You've written your first useful test.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Names"><a class="permalink" href="#Names">Names</a></h2>
That output isn't terribly descriptive, is it? When you have two tests you can
  figure out which one is #2, but what if you have 102 tests?
<p class="Pp">Each test can be given a little descriptive name as the second
    argument to <span class="Li">&quot;ok()&quot;</span>.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    use Test::Simple tests =&gt; 2;

    ok( defined $ical,              'new() returned something' );
    ok( $ical-&gt;isa('Date::ICal'),   &quot;  and it's the right class&quot; );
</pre>
<p class="Pp">Now you'll see:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    1..2
    ok 1 - new() returned something
    ok 2 -   and it's the right class
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Test_the_manual"><a class="permalink" href="#Test_the_manual">Test
  the manual</a></h2>
The simplest way to build up a decent testing suite is to just test what the
  manual says it does. [3] Let's pull something out of the &quot;SYNOPSIS&quot;
  in Date::ICal and test that all its bits work.
<p class="Pp"><span class="Li"></span></p>
<pre>
    #!/usr/bin/perl -w

    use Test::Simple tests =&gt; 8;

    use Date::ICal;

    $ical = Date::ICal-&gt;new( year =&gt; 1964, month =&gt; 10, day =&gt; 16,
                             hour =&gt; 16,   min   =&gt; 12, sec =&gt; 47,
                             tz   =&gt; '0530' );

    ok( defined $ical,            'new() returned something' );
    ok( $ical-&gt;isa('Date::ICal'), &quot;  and it's the right class&quot; );
    ok( $ical-&gt;sec   == 47,       '  sec()'   );
    ok( $ical-&gt;min   == 12,       '  min()'   );
    ok( $ical-&gt;hour  == 16,       '  hour()'  );
    ok( $ical-&gt;day   == 17,       '  day()'   );
    ok( $ical-&gt;month == 10,       '  month()' );
    ok( $ical-&gt;year  == 1964,     '  year()'  );
</pre>
<p class="Pp">Run that and you get:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    1..8
    ok 1 - new() returned something
    ok 2 -   and it's the right class
    ok 3 -   sec()
    ok 4 -   min()
    ok 5 -   hour()
    not ok 6 -   day()
    #     Failed test (- at line 16)
    ok 7 -   month()
    ok 8 -   year()
    # Looks like you failed 1 tests of 8.
</pre>
<p class="Pp">Whoops, a failure! [4] Test::Simple helpfully lets us know on what
    line the failure occurred, but not much else. We were supposed to get 17,
    but we didn't. What did we get?? Dunno. You could re-run the test in the
    debugger or throw in some print statements to find out.</p>
<p class="Pp">Instead, switch from Test::Simple to Test::More. Test::More does
    everything Test::Simple does, and more! In fact, Test::More does things
    <i>exactly</i> the way Test::Simple does. You can literally swap
    Test::Simple out and put Test::More in its place. That's just what we're
    going to do.</p>
<p class="Pp">Test::More does more than Test::Simple. The most important
    difference at this point is it provides more informative ways to say
    &quot;ok&quot;. Although you can write almost any test with a generic
    <span class="Li">&quot;ok()&quot;</span>, it can't tell you what went wrong.
    The <span class="Li">&quot;is()&quot;</span> function lets us declare that
    something is supposed to be the same as something else:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    use Test::More tests =&gt; 8;

    use Date::ICal;

    $ical = Date::ICal-&gt;new( year =&gt; 1964, month =&gt; 10, day =&gt; 16,
                             hour =&gt; 16,   min   =&gt; 12, sec =&gt; 47,
                             tz   =&gt; '0530' );

    ok( defined $ical,            'new() returned something' );
    ok( $ical-&gt;isa('Date::ICal'), &quot;  and it's the right class&quot; );
    is( $ical-&gt;sec,     47,       '  sec()'   );
    is( $ical-&gt;min,     12,       '  min()'   );
    is( $ical-&gt;hour,    16,       '  hour()'  );
    is( $ical-&gt;day,     17,       '  day()'   );
    is( $ical-&gt;month,   10,       '  month()' );
    is( $ical-&gt;year,    1964,     '  year()'  );
</pre>
<p class="Pp">&quot;Is <span class="Li">&quot;$ical-&gt;sec&quot;</span>
    47?&quot; &quot;Is <span class="Li">&quot;$ical-&gt;min&quot;</span>
    12?&quot; With <span class="Li">&quot;is()&quot;</span> in place, you get
    more information:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    1..8
    ok 1 - new() returned something
    ok 2 -   and it's the right class
    ok 3 -   sec()
    ok 4 -   min()
    ok 5 -   hour()
    not ok 6 -   day()
    #     Failed test (- at line 16)
    #          got: '16'
    #     expected: '17'
    ok 7 -   month()
    ok 8 -   year()
    # Looks like you failed 1 tests of 8.
</pre>
<p class="Pp">Aha. <span class="Li">&quot;$ical-&gt;day&quot;</span> returned
    16, but we expected 17. A quick check shows that the code is working fine,
    we made a mistake when writing the tests. Change it to:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    is( $ical-&gt;day,     16,       '  day()'   );
</pre>
<p class="Pp">... and everything works.</p>
<p class="Pp">Any time you're doing a &quot;this equals that&quot; sort of test,
    use <span class="Li">&quot;is()&quot;</span>. It even works on arrays. The
    test is always in scalar context, so you can test how many elements are in
    an array this way. [5]</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    is( @foo, 5, 'foo has 5 elements' );
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Sometimes_the_tests_are_wrong"><a class="permalink" href="#Sometimes_the_tests_are_wrong">Sometimes
  the tests are wrong</a></h2>
This brings up a very important lesson. Code has bugs. Tests are code. Ergo,
  tests have bugs. A failing test could mean a bug in the code, but don't
  discount the possibility that the test is wrong.
<p class="Pp">On the flip side, don't be tempted to prematurely declare a test
    incorrect just because you're having trouble finding the bug. Invalidating a
    test isn't something to be taken lightly, and don't use it as a cop out to
    avoid work.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Testing_lots_of_values"><a class="permalink" href="#Testing_lots_of_values">Testing
  lots of values</a></h2>
We're going to be wanting to test a lot of dates here, trying to trick the code
  with lots of different edge cases. Does it work before 1970? After 2038?
  Before 1904? Do years after 10,000 give it trouble? Does it get leap years
  right? We could keep repeating the code above, or we could set up a little
  try/expect loop.
<p class="Pp"><span class="Li"></span></p>
<pre>
    use Test::More tests =&gt; 32;
    use Date::ICal;

    my %ICal_Dates = (
            # An ICal string     And the year, month, day
            #                    hour, minute and second we expect.
            '19971024T120000' =&gt;    # from the docs.
                                [ 1997, 10, 24, 12,  0,  0 ],
            '20390123T232832' =&gt;    # after the Unix epoch
                                [ 2039,  1, 23, 23, 28, 32 ],
            '19671225T000000' =&gt;    # before the Unix epoch
                                [ 1967, 12, 25,  0,  0,  0 ],
            '18990505T232323' =&gt;    # before the MacOS epoch
                                [ 1899,  5,  5, 23, 23, 23 ],
    );


    while( my($ical_str, $expect) = each %ICal_Dates ) {
        my $ical = Date::ICal-&gt;new( ical =&gt; $ical_str );

        ok( defined $ical,            &quot;new(ical =&gt; '$ical_str')&quot; );
        ok( $ical-&gt;isa('Date::ICal'), &quot;  and it's the right class&quot; );

        is( $ical-&gt;year,    $expect-&gt;[0],     '  year()'  );
        is( $ical-&gt;month,   $expect-&gt;[1],     '  month()' );
        is( $ical-&gt;day,     $expect-&gt;[2],     '  day()'   );
        is( $ical-&gt;hour,    $expect-&gt;[3],     '  hour()'  );
        is( $ical-&gt;min,     $expect-&gt;[4],     '  min()'   );
        is( $ical-&gt;sec,     $expect-&gt;[5],     '  sec()'   );
    }
</pre>
<p class="Pp">Now we can test bunches of dates by just adding them to
    <span class="Li">%ICal_Dates</span>. Now that it's less work to test with
    more dates, you'll be inclined to just throw more in as you think of them.
    Only problem is, every time we add to that we have to keep adjusting the
    <span class="Li">&quot;use Test::More tests =&gt; ##&quot;</span> line. That
    can rapidly get annoying. There are ways to make this work better.</p>
<p class="Pp">First, we can calculate the plan dynamically using the
    <span class="Li">&quot;plan()&quot;</span> function.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    use Test::More;
    use Date::ICal;

    my %ICal_Dates = (
        ...same as before...
    );

    # For each key in the hash we're running 8 tests.
    plan tests =&gt; keys(%ICal_Dates) * 8;

    ...and then your tests...
</pre>
<p class="Pp">To be even more flexible, use
    <span class="Li">&quot;done_testing&quot;</span>. This means we're just
    running some tests, don't know how many. [6]</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    use Test::More;   # instead of tests =&gt; 32

    ... # tests here

    done_testing();   # reached the end safely
</pre>
<p class="Pp">If you don't specify a plan, Test::More expects to see
    <span class="Li">&quot;done_testing()&quot;</span> before your program
    exits. It will warn you if you forget it. You can give
    <span class="Li">&quot;done_testing()&quot;</span> an optional number of
    tests you expected to run, and if the number ran differs, Test::More will
    give you another kind of warning.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Informative_names"><a class="permalink" href="#Informative_names">Informative
  names</a></h2>
Take a look at the line:
<p class="Pp"><span class="Li"></span></p>
<pre>
    ok( defined $ical,            &quot;new(ical =&gt; '$ical_str')&quot; );
</pre>
<p class="Pp">We've added more detail about what we're testing and the ICal
    string itself we're trying out to the name. So you get results like:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    ok 25 - new(ical =&gt; '19971024T120000')
    ok 26 -   and it's the right class
    ok 27 -   year()
    ok 28 -   month()
    ok 29 -   day()
    ok 30 -   hour()
    ok 31 -   min()
    ok 32 -   sec()
</pre>
<p class="Pp">If something in there fails, you'll know which one it was and that
    will make tracking down the problem easier. Try to put a bit of debugging
    information into the test names.</p>
<p class="Pp">Describe what the tests test, to make debugging a failed test
    easier for you or for the next person who runs your test.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Skipping_tests"><a class="permalink" href="#Skipping_tests">Skipping
  tests</a></h2>
Poking around in the existing Date::ICal tests, I found this in
  <i>t/01sanity.t</i> [7]
<p class="Pp"><span class="Li"></span></p>
<pre>
    #!/usr/bin/perl -w

    use Test::More tests =&gt; 7;
    use Date::ICal;

    # Make sure epoch time is being handled sanely.
    my $t1 = Date::ICal-&gt;new( epoch =&gt; 0 );
    is( $t1-&gt;epoch, 0,          &quot;Epoch time of 0&quot; );

    # XXX This will only work on unix systems.
    is( $t1-&gt;ical, '19700101Z', &quot;  epoch to ical&quot; );

    is( $t1-&gt;year,  1970,       &quot;  year()&quot;  );
    is( $t1-&gt;month, 1,          &quot;  month()&quot; );
    is( $t1-&gt;day,   1,          &quot;  day()&quot;   );

    # like the tests above, but starting with ical instead of epoch
    my $t2 = Date::ICal-&gt;new( ical =&gt; '19700101Z' );
    is( $t2-&gt;ical, '19700101Z', &quot;Start of epoch in ICal notation&quot; );

    is( $t2-&gt;epoch, 0,          &quot;  and back to ICal&quot; );
</pre>
<p class="Pp">The beginning of the epoch is different on most non-Unix operating
    systems [8]. Even though Perl smooths out the differences for the most part,
    certain ports do it differently. MacPerl is one off the top of my head. [9]
    Rather than putting a comment in the test and hoping someone will read the
    test while debugging the failure, we can explicitly say it's never going to
    work and skip the test.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    use Test::More tests =&gt; 7;
    use Date::ICal;

    # Make sure epoch time is being handled sanely.
    my $t1 = Date::ICal-&gt;new( epoch =&gt; 0 );
    is( $t1-&gt;epoch, 0,          &quot;Epoch time of 0&quot; );

    SKIP: {
        skip('epoch to ICal not working on Mac OS', 6)
            if $^O eq 'MacOS';

        is( $t1-&gt;ical, '19700101Z', &quot;  epoch to ical&quot; );

        is( $t1-&gt;year,  1970,       &quot;  year()&quot;  );
        is( $t1-&gt;month, 1,          &quot;  month()&quot; );
        is( $t1-&gt;day,   1,          &quot;  day()&quot;   );

        # like the tests above, but starting with ical instead of epoch
        my $t2 = Date::ICal-&gt;new( ical =&gt; '19700101Z' );
        is( $t2-&gt;ical, '19700101Z', &quot;Start of epoch in ICal notation&quot; );

        is( $t2-&gt;epoch, 0,          &quot;  and back to ICal&quot; );
    }
</pre>
<p class="Pp">A little bit of magic happens here. When running on anything but
    MacOS, all the tests run normally. But when on MacOS,
    <span class="Li">&quot;skip()&quot;</span> causes the entire contents of the
    SKIP block to be jumped over. It never runs. Instead,
    <span class="Li">&quot;skip()&quot;</span> prints special output that tells
    Test::Harness that the tests have been skipped.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    1..7
    ok 1 - Epoch time of 0
    ok 2 # skip epoch to ICal not working on MacOS
    ok 3 # skip epoch to ICal not working on MacOS
    ok 4 # skip epoch to ICal not working on MacOS
    ok 5 # skip epoch to ICal not working on MacOS
    ok 6 # skip epoch to ICal not working on MacOS
    ok 7 # skip epoch to ICal not working on MacOS
</pre>
<p class="Pp">This means your tests won't fail on MacOS. This means fewer emails
    from MacPerl users telling you about failing tests that you know will never
    work. You've got to be careful with skip tests. These are for tests which
    don't work and <i>never will</i>. It is not for skipping genuine bugs (we'll
    get to that in a moment).</p>
<p class="Pp">The tests are wholly and completely skipped. [10] This will
  work.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    SKIP: {
        skip(&quot;I don't wanna die!&quot;);

        die, die, die, die, die;
    }
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Todo_tests"><a class="permalink" href="#Todo_tests">Todo
  tests</a></h2>
While thumbing through the Date::ICal man page, I came across this:
<p class="Pp"><span class="Li"></span></p>
<pre>
   ical

       $ical_string = $ical-&gt;ical;

   Retrieves, or sets, the date on the object, using any
   valid ICal date/time string.
</pre>
<p class="Pp">&quot;Retrieves or sets&quot;. Hmmm. I didn't see a test for using
    <span class="Li">&quot;ical()&quot;</span> to set the date in the Date::ICal
    test suite. So I wrote one:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    use Test::More tests =&gt; 1;
    use Date::ICal;

    my $ical = Date::ICal-&gt;new;
    $ical-&gt;ical('20201231Z');
    is( $ical-&gt;ical, '20201231Z',   'Setting via ical()' );
</pre>
<p class="Pp">Run that. I saw:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    1..1
    not ok 1 - Setting via ical()
    #     Failed test (- at line 6)
    #          got: '20010814T233649Z'
    #     expected: '20201231Z'
    # Looks like you failed 1 tests of 1.
</pre>
<p class="Pp">Whoops! Looks like it's unimplemented. Assume you don't have the
    time to fix this. [11] Normally, you'd just comment out the test and put a
    note in a todo list somewhere. Instead, explicitly state &quot;this test
    will fail&quot; by wrapping it in a <span class="Li">&quot;TODO&quot;</span>
    block:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    use Test::More tests =&gt; 1;

    TODO: {
        local $TODO = 'ical($ical) not yet implemented';

        my $ical = Date::ICal-&gt;new;
        $ical-&gt;ical('20201231Z');

        is( $ical-&gt;ical, '20201231Z',   'Setting via ical()' );
    }
</pre>
<p class="Pp">Now when you run, it's a little different:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    1..1
    not ok 1 - Setting via ical() # TODO ical($ical) not yet implemented
    #          got: '20010822T201551Z'
    #     expected: '20201231Z'
</pre>
<p class="Pp">Test::More doesn't say &quot;Looks like you failed 1 tests of
    1&quot;. That '# TODO' tells Test::Harness &quot;this is supposed to
    fail&quot; and it treats a failure as a successful test. You can write tests
    even before you've fixed the underlying code.</p>
<p class="Pp">If a TODO test passes, Test::Harness will report it
    &quot;UNEXPECTEDLY SUCCEEDED&quot;. When that happens, remove the TODO block
    with <span class="Li">&quot;local $TODO&quot;</span> and turn it into a real
    test.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Testing_with_taint_mode."><a class="permalink" href="#Testing_with_taint_mode.">Testing
  with taint mode.</a></h2>
Taint mode is a funny thing. It's the globalest of all global features. Once you
  turn it on, it affects <i>all</i> code in your program and <i>all</i> modules
  used (and all the modules they use). If a single piece of code isn't taint
  clean, the whole thing explodes. With that in mind, it's very important to
  ensure your module works under taint mode.
<p class="Pp">It's very simple to have your tests run under taint mode. Just
    throw a <span class="Li">&quot;-T&quot;</span> into the
    <span class="Li">&quot;#!&quot;</span> line. Test::Harness will read the
    switches in <span class="Li">&quot;#!&quot;</span> and use them to run your
    tests.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    #!/usr/bin/perl -Tw

    ...test normally here...
</pre>
<p class="Pp">When you say <span class="Li">&quot;make test&quot;</span> it will
    run with taint mode on.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="FOOTNOTES"><a class="permalink" href="#FOOTNOTES">FOOTNOTES</a></h1>
<dl class="Bl-tag">
  <dt>1.</dt>
  <dd>The first number doesn't really mean anything, but it has to be 1. It's
      the second number that's important.</dd>
  <dt>2.</dt>
  <dd>For those following along at home, I'm using version 1.31. It has some
      bugs, which is good -- we'll uncover them with our tests.</dd>
  <dt>3.</dt>
  <dd>You can actually take this one step further and test the manual itself.
      Have a look at Test::Inline (formerly Pod::Tests).</dd>
  <dt>4.</dt>
  <dd>Yes, there's a mistake in the test suite. What! Me, contrived?</dd>
  <dt>5.</dt>
  <dd>We'll get to testing the contents of lists later.</dd>
  <dt>6.</dt>
  <dd>But what happens if your test program dies halfway through?! Since we
      didn't say how many tests we're going to run, how can we know it failed?
      No problem, Test::More employs some magic to catch that death and turn the
      test into a failure, even if every test passed up to that point.</dd>
  <dt>7.</dt>
  <dd>I cleaned it up a little.</dd>
  <dt>8.</dt>
  <dd>Most Operating Systems record time as the number of seconds since a
      certain date. This date is the beginning of the epoch. Unix's starts at
      midnight January 1st, 1970 GMT.</dd>
  <dt>9.</dt>
  <dd>MacOS's epoch is midnight January 1st, 1904. VMS's is midnight, November
      17th, 1858, but vmsperl emulates the Unix epoch so it's not a
    problem.</dd>
  <dt>10.</dt>
  <dd>As long as the code inside the SKIP block at least compiles. Please don't
      ask how. No, it's not a filter.</dd>
  <dt>11.</dt>
  <dd>Do NOT be tempted to use TODO tests as a way to avoid fixing simple
    bugs!</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHORS"><a class="permalink" href="#AUTHORS">AUTHORS</a></h1>
Michael G Schwern &lt;schwern@pobox.com&gt; and the perl-qa dancers!
</section>
<section class="Sh">
<h1 class="Sh" id="MAINTAINERS"><a class="permalink" href="#MAINTAINERS">MAINTAINERS</a></h1>
<dl class="Bl-tag">
  <dt>Chad Granum &lt;exodist@cpan.org&gt;</dt>
  <dd></dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT"><a class="permalink" href="#COPYRIGHT">COPYRIGHT</a></h1>
Copyright 2001 by Michael G Schwern &lt;schwern@pobox.com&gt;.
<p class="Pp">This documentation is free; you can redistribute it and/or modify
    it under the same terms as Perl itself.</p>
<p class="Pp">Irrespective of its distribution, all code examples in these files
    are hereby placed into the public domain. You are permitted and encouraged
    to use this code in your own programs for fun or for profit as you see fit.
    A simple comment in the code giving credit would be courteous but is not
    required.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2018-11-01</td>
    <td class="foot-os">perl v5.28.2</td>
  </tr>
</table>
</body>
</html>
