<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Copyright (c) 2011 Apple Inc. All rights reserved.
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>xpc_connection_create(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">xpc_connection_create(3)</td>
    <td class="head-vol">Library Functions Manual</td>
    <td class="head-rtitle">xpc_connection_create(3)</td>
  </tr>
</table>
<div class="manual-text">
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<code class="Nm">xpc_connection_create</code> &#x2014;
<div class="Nd">creation and management of XPC connections</div>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<code class="In">#include <a class="In">&lt;xpc/xpc.h&gt;</a></code>
<p class="Pp"><var class="Ft">xpc_connection_t</var>
  <br/>
  <code class="Fn">xpc_connection_create</code>(<var class="Fa">const char
    *name</var>, <var class="Fa">dispatch_queue_t targetq</var>);</p>
<p class="Pp"><var class="Ft">xpc_connection_t</var>
  <br/>
  <code class="Fn">xpc_connection_create_mach_service</code>(<var class="Fa">const
    char *name</var>, <var class="Fa">dispatch_queue_t targetq</var>,
    <var class="Fa">uint64_t flags</var>);</p>
<p class="Pp"><var class="Ft">xpc_connection_t</var>
  <br/>
  <code class="Fn">xpc_connection_create_from_endpoint</code>(<var class="Fa">xpc_endpoint_t
    endpoint</var>);</p>
<p class="Pp"><var class="Ft">void</var>
  <br/>
  <code class="Fn">xpc_connection_set_target_queue</code>(<var class="Fa">xpc_connection_t
    connection</var>, <var class="Fa">dispatch_queue_t targetq</var>);</p>
<p class="Pp"><var class="Ft">void</var>
  <br/>
  <code class="Fn">xpc_connection_set_event_handler</code>(<var class="Fa">xpc_connection_t
    connection</var>, <var class="Fa">xpc_handler_t handler</var>);</p>
<p class="Pp"><var class="Ft">void</var>
  <br/>
  <code class="Fn">xpc_connection_activate</code>(<var class="Fa">xpc_connection_t
    connection</var>);</p>
<p class="Pp"><var class="Ft">void</var>
  <br/>
  <code class="Fn">xpc_connection_suspend</code>(<var class="Fa">xpc_connection_t
    connection</var>);</p>
<p class="Pp"><var class="Ft">void</var>
  <br/>
  <code class="Fn">xpc_connection_resume</code>(<var class="Fa">xpc_connection_t
    connection</var>);</p>
<p class="Pp"><var class="Ft">void</var>
  <br/>
  <code class="Fn">xpc_connection_send_message</code>(<var class="Fa">xpc_connection_t
    connection</var>, <var class="Fa">xpc_object_t message</var>);</p>
<p class="Pp"><var class="Ft">void</var>
  <br/>
  <code class="Fn">xpc_connection_send_barrier</code>(<var class="Fa">xpc_connection_t
    connection</var>, <var class="Fa">dispatch_block_t barrier</var>);</p>
<p class="Pp"><var class="Ft">void</var>
  <br/>
  <code class="Fn">xpc_connection_send_message_with_reply</code>(<var class="Fa">xpc_connection_t
    connection</var>, <var class="Fa">xpc_object_t message</var>,
    <var class="Fa">dispatch_queue_t targetq</var>,
    <var class="Fa">xpc_handler_t handler</var>);</p>
<p class="Pp"><var class="Ft">xpc_object_t</var>
  <br/>
  <code class="Fn">xpc_connection_send_message_with_reply_sync</code>(<var class="Fa">xpc_connection_t
    connection</var>, <var class="Fa">xpc_object_t message</var>);</p>
<p class="Pp"><var class="Ft">void</var>
  <br/>
  <code class="Fn">xpc_connection_cancel</code>(<var class="Fa">xpc_connection_t
    connection</var>);</p>
<p class="Pp"><var class="Ft">const char *</var>
  <br/>
  <code class="Fn">xpc_connection_get_name</code>(<var class="Fa">xpc_connection_t
    connection</var>);</p>
<p class="Pp"><var class="Ft">uid_t</var>
  <br/>
  <code class="Fn">xpc_connection_get_euid</code>(<var class="Fa">xpc_connection_t
    connection</var>);</p>
<p class="Pp"><var class="Ft">gid_t</var>
  <br/>
  <code class="Fn">xpc_connection_get_guid</code>(<var class="Fa">xpc_connection_t
    connection</var>);</p>
<p class="Pp"><var class="Ft">pid_t</var>
  <br/>
  <code class="Fn">xpc_connection_get_pid</code>(<var class="Fa">xpc_connection_t
    connection</var>);</p>
<p class="Pp"><var class="Ft">au_asid_t</var>
  <br/>
  <code class="Fn">xpc_connection_get_asid</code>(<var class="Fa">xpc_connection_t
    connection</var>);</p>
<p class="Pp"><var class="Ft">void</var>
  <br/>
  <code class="Fn">xpc_connection_set_context</code>(<var class="Fa">xpc_connection_t
    connection</var>, <var class="Fa">void *ctx</var>);</p>
<p class="Pp"><var class="Ft">void *</var>
  <br/>
  <code class="Fn">xpc_connection_get_context</code>(<var class="Fa">xpc_connection_t
    connection</var>);</p>
<p class="Pp"><var class="Ft">void</var>
  <br/>
  <code class="Fn">xpc_connection_set_finalizer_f</code>(<var class="Fa">xpc_connection_t
    connection</var>, <var class="Fa">xpc_finalizer_t finalizer</var>);</p>
<p class="Pp"><var class="Ft">xpc_endpoint_t</var>
  <br/>
  <code class="Fn">xpc_endpoint_create</code>(<var class="Fa">xpc_connection_t
    connection</var>);</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
Connections are the fundamental primitives for sending and receiving messages.
  Connections also inform the caller of certain non-message events through
  errors.
<p class="Pp">Messages sent to a connection are sent in FIFO order, and
    message-send operations over a connection are non-blocking. When a message
    is sent over a connection, it is atomically enqueued on a queue which is
    managed by the XPC runtime. As it becomes possible to successfully deliver
    messages to the remote end of the connection, messages will be dequeued from
    the queue and delivered.</p>
<p class="Pp">Connections may either be used to communicate with XPC services
    residing within an application bundle or with a MachService advertised by a
    launchd job in its <a class="Xr">launchd.plist(5)</a>. XPC connections
    maintain a one-to-one relationship between the local and remote ends of the
    connection. Therefore, for every connection created to a service, the remote
    end will see a distinct peer connection object. This model is semantically
    similar to the <a class="Xr">accept(3)</a> model, whereby the server listens
    on a single file descriptor, and that listening descriptor emits new file
    descriptors for each connection that occurs.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="EVENT_HANDLERS"><a class="permalink" href="#EVENT_HANDLERS">EVENT
  HANDLERS</a></h1>
Each connection must have an event handler associated with it. The event handler
  block takes one argument of type <var class="Fa">xpc_object_t</var>. The event
  handler block will deliver different types of objects depending on the nature
  of the event.
<p class="Pp">The type of object can be queried using
    <a class="Xr">xpc_get_type(3)</a>. If the event handler block delivers an
    object of type <var class="Ft">XPC_TYPE_DICTIONARY</var>, the event is a
    message that needs processing. If the event handler delivers an object of
    type <var class="Ft">XPC_TYPE_ERROR</var>, an error has occurred on the
    connection that must be handled.</p>
<p class="Pp">Regardless of the type of object passed to the event handler, the
    caller will NOT implicitly gain a reference to the object. Therefore, if the
    caller wishes to work with the object after the event handler has returned,
    it should call <a class="Xr">xpc_retain(3)</a> to keep a reference on the
    object for itself from within the event handler. It is unsafe to retain the
    object after the event handler has returned.</p>
<p class="Pp">The event handler of a connection may be changed while the
    connection is processing events using the
    <code class="Fn">xpc_connection_set_event_handler</code>() API. Calls to
    this API will <i class="Em">not</i> interrupt currently-executing
    invocations of the connection's event handler. Once the currently-executing
    event handler returns, the new event handler will take effect. If called
    from within the event handler itself, the next invocation of the event
    handler will honor the new one set.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="TARGET_QUEUES"><a class="permalink" href="#TARGET_QUEUES">TARGET
  QUEUES</a></h1>
Each connection has an associated target queue. All connection-related activity
  will happen on an internal queue which is synchronized with the target queue.
  Event handler invocations are included in connection-related activity. The
  target queue may be changed while the connection is processing events using
  the <code class="Fn">xpc_connection_set_target_queue</code>() API. Setting of
  the target queue on a connection is asynchronous, and the caller should not
  assume that when this API returns, the new target queue is in effect. The
  actual change will take place at a later time.
<p class="Pp">By default, all connections target the
    <a class="Xr">DISPATCH_TARGET_QUEUE_DEFAULT(3)</a> queue. This queue will be
    used if NULL is given as the <var class="Fa">targetq</var> argument to
    <code class="Fn">xpc_connection_set_target_queue</code>(),
    <code class="Fn">xpc_connection_create</code>() or
    <code class="Fn">xpc_connection_create_mach_service</code>(). Note that
    connections received either through the <a class="Xr">xpc_main(3)</a> event
    handler or the handler given to a connection created with the
    <var class="Ft">XPC_CONNECTION_MACH_SERVICE_LISTENER</var> flag do not
    inherit the target queue of that connection. It must always be set
    explicitly.</p>
<p class="Pp"><i class="Em">Important</i>: The result of calling
    <a class="Xr">dispatch_get_current_queue(3)</a> from within a connection's
    event handler is undefined and should not be considered reliable for
    attempting to avoid deadlocks.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="LAUNCH_ON_DEMAND"><a class="permalink" href="#LAUNCH_ON_DEMAND">LAUNCH-ON-DEMAND</a></h1>
When the caller obtains a connection to a named service, the fact that it has a
  connection does not imply anything about whether the remote end is alive and
  running. Connections are virtual, and if the remote end is not yet running,
  the act of sending a message will cause it to launch on-demand.
<p class="Pp">If the caller has a connection to a named service, then the remote
    process closing the connection or crashing will deliver the
    <var class="Ft">XPC_ERROR_CONNECTION_INTERRUPTED</var> error to the event
    handler. This error is recoverable, and after receiving it, the connection
    is still usable. If the caller had previously sent state over the
    connection, this error indicates that that state should be updated, if
    needed, and resent.</p>
<p class="Pp"><i class="Em">NOTE</i>: Services work best when they are as
    stateless as possible. Even if you write perfectly bug-free code, the
    libraries and frameworks your service links against may have bugs that could
    crash the service. So a service must be able to recover from such abnormal
    exits.</p>
<p class="Pp">One strategy for implementing a robust and recoverable service is
    to have each client of the service maintain state for the service. If the
    service crashes, then each client will detect that condition and resend the
    needed state to the service so that it can resume any interrupted
    operations.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="PEERING"><a class="permalink" href="#PEERING">PEERING</a></h1>
The local and remote ends of a connection have a one-to-one association. So when
  a new connection to a service is created and has a message sent over it, the
  service will receive a new connection in the event handler it specified to
  <a class="Xr">xpc_main(3)</a>. If the service is a MachService advertised by
  <a class="Xr">launchd(8)</a>, then the listener connection for the named
  service will receive the new connection in its event handler.
<p class="Pp">Even if the same process creates multiple connections to the same
    service, each connection will be distinct. The peer connection received by
    the service will deliver <var class="Ft">XPC_ERROR_CONNECTION_INVALID</var>
    to its event handler when the connection has been closed. These peer
    connections cannot be re-created by the XPC runtime, and therefore they will
    never deliver the <var class="Ft">XPC_ERROR_CONNECTION_INTERRUPTED</var>
    error to their event handlers.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="ACTIVATE,_SUSPEND_AND_RESUME"><a class="permalink" href="#ACTIVATE,_SUSPEND_AND_RESUME">ACTIVATE,
  SUSPEND AND RESUME</a></h1>
All connections are created in an inactive state. Therefore, they will not begin
  processing messages or events until an initial call to
  <code class="Fn">xpc_connection_activate</code>() is made. Before activating
  the connection, the caller must set an event handler using
  <code class="Fn">xpc_connection_set_event_handler</code>(). Note that the
  activation does not need to immediately follow setting the event handler. The
  caller is free to delay the activation as long as it chooses.
<p class="Pp">A connection may be suspended to halt the processing of incoming
    events and outgoing messages. This behavior is useful to rate-limit or
    throttle over-active clients who are sending too many messages or to allow
    certain synchronization behaviors with the internal state engine.</p>
<p class="Pp">Each connection maintains a suspend count, so
    <code class="Fn">xpc_connection_suspend</code>() may be called multiple
    times on the same connection. The connection will resume processing events
    when an equal number of calls to
    <code class="Fn">xpc_connection_resume</code>() have been performed on the
    connection, resetting the suspend count to zero.</p>
<p class="Pp"><i class="Em">Important</i>: <i class="Em">All</i> calls to
    <code class="Fn">xpc_connection_suspend</code>() must be balanced by a call
    to <code class="Fn">xpc_connection_resume</code>() before the final
    reference on a connection is released. It is not valid to release the last
    reference on a suspended or inactive connection.</p>
<p class="Pp"><i class="Em">Important</i>: It is invalid to underflow the
    suspend count by calling <code class="Fn">xpc_connection_resume</code>()
    more times than <code class="Fn">xpc_connection_suspend</code>() has been
    called.</p>
<p class="Pp"><i class="Em">Backward compatibility</i>: For backward
    compatibility reasons, calling
    <code class="Fn">xpc_connection_resume</code>() on an inactive connection
    that is not otherwise suspended behaves like a call to
    <code class="Fn">xpc_connection_activate</code>(). This behavior is referred
    to as the <i class="Em">initial resume</i> of the connection in older XPC
    documentation.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="CONTEXT"><a class="permalink" href="#CONTEXT">CONTEXT</a></h1>
Connections may have associated context that can be set and retrieved using the
  <code class="Fn">xpc_connection_set_context</code>() and
  <code class="Fn">xpc_connection_get_context</code>() APIs, respectively. When
  setting context on a connection, an optional finalizer may be specified using
  <code class="Fn">xpc_connection_set_finalizer_f</code>(). The function given
  as the <var class="Fa">finalizer</var> argument will be invoked just before
  the connection's memory is being deallocated. For simple context structures
  allocated through <a class="Xr">malloc(3)</a>, this provides a convenient
  shortcut. For example:
<div class="Bd Pp Bd-indent">
<pre>
struct my_context_s *ctx = malloc(sizeof(*ctx));
xpc_connection_set_context(connection, ctx);
xpc_connection_set_finalizer_f(connection, free);
</pre>
</div>
<p class="Pp"><i class="Em">Important</i>: The connection object itself should
    <i class="Em">not</i> be referenced or modified in any way within the
    context of the finalizer.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="MESSAGE_SENDING"><a class="permalink" href="#MESSAGE_SENDING">MESSAGE
  SENDING</a></h1>
Messages are sent to the remote end of a connection with the
  <code class="Fn">xpc_connection_send_message</code>() API. This API will
  enqueue the <var class="Fa">message</var> in a FIFO queue which will be
  drained asynchronously by the XPC runtime. The caller should not assume that,
  when this API returns, the message has been delivered to the remote end. If
  the caller needs to know when the message has been processed by the runtime,
  it should call the <code class="Fn">xpc_connection_send_barrier</code>() API
  directly after calling <code class="Fn">xpc_connection_send_message</code>().
  The supplied <var class="Fa">barrier</var> block will be invoked by the
  connection when the runtime has finished processing the message.
<section class="Ss">
<h2 class="Ss" id="Execution_Ordering"><a class="permalink" href="#Execution_Ordering">Execution
  Ordering</a></h2>
Send barriers are NOT immediately enqueued on the connection's target queue and
  therefore has no guaranteed execution order with respect to other blocks
  scheduled on that queue. The following code illustrates this anti-pattern:
<div class="Bd Pp Bd-indent">
<pre>
xpc_connection_set_target_queue(connection, queue);

static bool aboolean = false;
xpc_connection_send_barrier(connection, ^{
	aboolean = true;
});

dispatch_async(queue, ^{
	// Assertion will fail.
	assert(aboolean == true);
});
</pre>
</div>
<p class="Pp">To achieve the desired effect of deferring the second block's
    execution until after the barrier has completed, the caller can use a
    dispatch group <a class="Xr">(dispatch_group_create(3))</a> as follows:</p>
<div class="Bd Pp Bd-indent">
<pre>
xpc_connection_set_target_queue(connection, queue);

static bool aboolean = false;

dispatch_group_t group = dispatch_group_create();

dispatch_group_enter(group)
xpc_connection_send_barrier(connection, ^{
	aboolean = true;
	dispatch_group_leave(group);
});

dispatch_group_notify(group, queue, ^{
	assert(aboolean == true);
});
</pre>
</div>
<p class="Pp">Alternatively, the caller can also
    <a class="Xr">dispatch_async(3)</a> the second block from within the barrier
    block.</p>
<p class="Pp"><i class="Em">Important</i>: The caller should not assume that the
    remote end of the connection has received the message when a barrier is
    invoked. Even though the message has been delivered to the remote end, the
    remote end may not have yet been scheduled for execution or may have
    suspended its end of the connection. The only way for the sender to know
    whether the remote end has received the message is to specify in its message
    protocol that the remote end must send a message back to the sender
    acknowledging receipt of the message.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="REPLY_MESSAGES"><a class="permalink" href="#REPLY_MESSAGES">REPLY
  MESSAGES</a></h1>
By default, all messages sent to a connection will result in an invocation of
  the remote end's connection's event handler with that message as the argument.
  If the caller wishes to tie the invocation of a particular block to a reply to
  a particular message, however, it may use the
  <code class="Fn">xpc_connection_send_message_with_reply</code>() API. Like
  <code class="Fn">xpc_connection_send_message</code>(), this API will return
  immediately and, when the remote end sends a reply back, the supplied
  <var class="Fa">handler</var> block will be submitted to the supplied
  <var class="Fa">targetq</var> instead of causing the connection's event
  handler to be invoked. The reply handler block may deliver an error to the
  caller, which indicates that the remote end will never send a reply.
<p class="Pp">The remote end must create the reply message by calling
    <a class="Xr">xpc_dictionary_create_reply(3)</a> and sending it to its peer
    connection as it normally would. The caller must, in turn, specify in the
    message itself whether it expects a reply to be delivered.</p>
<p class="Pp"><i class="Em">CLIENT SIDE</i></p>
<div class="Bd Pp Bd-indent">
<pre>
xpc_connection_send_message_with_reply(connection, message, replyq, ^(xpc_object_t reply) {
	if (xpc_get_type(reply) == XPC_TYPE_DICTIONARY) {
		// Process reply message that is specific to the message sent.
	} else {
		// There was an error, indicating that the caller will never receive
		// a reply to this message. Tear down any associated data structures.
	}
});
</pre>
</div>
<p class="Pp"><i class="Em">SERVICE SIDE</i></p>
<div class="Bd Pp Bd-indent">
<pre>
void
handle_message(xpc_object_t message)
{
	if (xpc_dictionary_get_bool(message, &quot;ExpectsReply&quot;)) {
		// Sender has set the protocol-defined &quot;ExpectsReply&quot; key, and therefore
		// it expects the reply to be delivered specially.
		xpc_object_t reply = xpc_dictionary_create_reply(message);
		// Populate 'reply' as a normal dictionary.

		// This is the connection from which the message originated.
		xpc_connection_t remote = xpc_dictionary_get_remote_connection(message);
		xpc_connection_send_message(remote, reply);
		xpc_release(reply);
	} else {
		// The sender does not expect any kind of special reply.
	}
}
</pre>
</div>
<p class="Pp"><i class="Em">Important</i>: The invocations of reply handlers are
    independent of the connection's normal incoming message stream. Therefore,
    reply messages are delivered to the recipient independently of the
    connection's normal FIFO semantics.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNCHRONOUS_OPERATION"><a class="permalink" href="#SYNCHRONOUS_OPERATION">SYNCHRONOUS
  OPERATION</a></h1>
If the caller needs to block execution until a reply to a message is received,
  it should use the
  <code class="Fn">xpc_connection_send_message_with_reply_sync</code>() API.
  This result of this API will be the reply sent by the server. Like the handler
  given to <code class="Fn">xpc_connection_send_message_with_reply</code>(),
  this API may return errors indicating that the remote end of the connection
  will never deliver a reply.
<p class="Pp"><i class="Em">Important</i>: This API is primarily intended for
    allowing existing synchronous API to be re- implemented in terms of XPC. But
    in cases where the you are designing a new API that calls out to a service
    to retrieve a value, we strongly encourage you to have the API return the
    value asynchronously using a queue/block pair rather than blocking the
    caller until the service returns the requested value:</p>
<div class="Bd Pp Bd-indent">
<pre>
void
retrieve_uint64(dispatch_queue_t q, void (^handler)(uint64_t value))
{
	xpc_object_t message = xpc_dictionary_create(NULL, NULL, 0);
	xpc_dictionary_set_string(message, &quot;RetrieveValue&quot;, &quot;uint64&quot;);

	// 'connection' is a previously-created singleton.
	xpc_connection_send_message_with_reply(connection, message, q, ^(xpc_object_t reply) {
		if (xpc_get_type(reply) == XPC_TYPE_DICTIONARY) {
			uint64_t replyvalue = xpc_dictionary_get_uint64(reply, &quot;Value&quot;);
			// 'reply' is captured by this block and copied to the heap. It will
			// be released when this block is disposed of.
			handler(replyvalue);
		} else {
			// Invoke 'reply' with a value indicating that there was an error.
		}
		xpc_release(message);
	});
}
</pre>
</div>
<p class="Pp">However, such a scheme may introduce unwanted complexity in the
    API. The trade- off for making the example implementation above synchronous
    involves factors such as where the data for the response comes from and how
    likely it is that the API will be called on the main thread.</p>
<p class="Pp">If the response will be constructed with data that exists
    in-memory in the server, it is usually safe to make the API synchronous. But
    if constructing the response requires I/O, and it is likely to be called
    from the main thread (or a thread which synchronizes with the main thread),
    we highly encourage that you take the asynchronous route to avoid the risk
    of blocking the UI.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="CREDENTIALS"><a class="permalink" href="#CREDENTIALS">CREDENTIALS</a></h1>
Identifying information about the sending processs can be obtained from a
  connection. Available credential information includes the sending process
  identifer (PID), effective user identifier (EUID), effective group identifier
  (EGID) and audit session identifier (ASID). These values can be obtained with
  the functions <code class="Fn">xpc_connection_get_pid</code>(),
  <code class="Fn">xpc_connection_get_euid</code>(),
  <code class="Fn">xpc_connection_get_egid</code>() and
  <code class="Fn">xpc_connection_get_asid</code>() respectively.
<p class="Pp">Credentials for a connection may not be immediately available. For
    example, when creating a new connection with
    <code class="Fn">xpc_connection_create</code>(), XPC will not know the
    credentials of the remote end of the connection until it has actually
    exchanged messages with it. Until this credential information is filled in,
    these methods will return sensible values to indicate absence of crucial
    information. <code class="Fn">xpc_connection_get_pid</code>() will return 0,
    <code class="Fn">xpc_connection_get_euid</code>() and
    <code class="Fn">xpc_connection_get_egid</code>() will return -1 and
    <code class="Fn">xpc_connection_get_asid</code>() will return AU_ASSIGN_ASID
    (see <a class="Xr">setaudit_addr(2))</a>.</p>
<p class="Pp">For peer connections received through a listener's event handler
    or through the handler given to <a class="Xr">xpc_main(3)</a>, credentials
    will be immediately available.</p>
<p class="Pp">Connection credentials have similar semantics to file descriptor
    credentials. That is, the credentials that the connection was created with
    are &quot;baked in&quot; to it and do not change as a result of calls to
    <a class="Xr">setuid(3)</a> and friends. Use of these APIs is heavily
    discouraged in IPC protocols due to the inherently racy nature of credential
    checking.</p>
<p class="Pp"><i class="Em">Important</i>: PIDs on OS X roll over when they
    reach a relatively small value, and a given PID cannot be assumed to be
    unique for a given boot session. For services bundled with an application,
    this is not a practical concern because the application is the only process
    capable of looking up its services. But MachServices advertised through
    launchd have a much higher visibility, so extra care should be taken when
    checking credentials to mitigate <a class="Xr">fork(2)</a> bomb-style
    attacks.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="CANCELLATION"><a class="permalink" href="#CANCELLATION">CANCELLATION</a></h1>
A connection may be canceled when it is no longer needed. Once canceled, a
  connection will receive the <var class="Ft">XPC_ERROR_CONNECTION_INVALID</var>
  error in its event handler, and no further events will be delivered.
  Cancellation does not affect the reference count of the connection, so if you
  hold references to the connection, they must still be released in order for
  all of the connection's associated resources to be freed.
<p class="Pp">Note that, if a connection receives
    <var class="Ft">XPC_ERROR_CONNECTION_INVALID</var> in its event handler due
    to other circumstances, it is already in a canceled state, and therefore a
    call to <code class="Fn">xpc_connection_cancel</code>() is unnecessary (but
    harmless) in this case.</p>
<p class="Pp">Canceling a connection on one side has effects on the other side
    of a connection. For example, if you cancel a connection received through a
    listener connection's event handler, the remote peer connection will receive
    <var class="Ft">XPC_ERROR_CONNECTION_INTERRUPTED</var> in its event handler.
    Even though the connection was canceled, the remote end is still able to
    send messages to the connection.</p>
<p class="Pp">If, on the other hand, the creator of a named connection cancels
    the connection, the peer connection given to the remote end through a
    listener connection will receive
    <var class="Ft">XPC_ERROR_CONNECTION_INVALID</var> in its event handler.</p>
<p class="Pp"><i class="Em">Important</i>: As discussed previously, some
    connections (such as named connections created through
    <code class="Fn">xpc_connection_create</code>()) will not receive
    <var class="Ft">XPC_ERROR_CONNECTION_INVALID</var> in the normal course of
    their operation. But if another part of your code can end up calling
    <code class="Fn">xpc_connection_cancel</code>(), then the connection's event
    handler must handle this error.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="BUNDLED_SERVICES"><a class="permalink" href="#BUNDLED_SERVICES">BUNDLED
  SERVICES</a></h1>
Applications may include XPC service bundles in their own bundle. When the
  application is run, the XPC runtime automatically recognizes each bundled
  service and makes it accessible to the application through the
  <code class="Fn">xpc_connection_create</code>() API. To connect to a bundled
  service, the caller must pass the CFBundleIdentifier specified in the
  service's Info.plist as the <var class="Fa">name</var> argument. The service
  itself will call <a class="Xr">xpc_main(3)</a> to initialize its runtime, and
  the provided event handler function will be invoked with any incoming
  connections.
<p class="Pp">Services bundled with an application are <i class="Em">only</i>
    accessible to that application. An external process cannot connect to those
    services.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="MACH_SERVICES"><a class="permalink" href="#MACH_SERVICES">MACH
  SERVICES</a></h1>
If a caller wishes to connect to a MachService advertised in a
  <a class="Xr">launchd.plist(5)</a>, it should pass the MachService name to
  which it wishes to connect with
  <code class="Fn">xpc_connection_create_mach_service</code>(). If the
  destination service is advertised in the root Mach bootstrap (i.e. the
  <a class="Xr">launchd.plist(5)</a> lives in /Library/LaunchDaemons), the
  caller may ensure that the service that it connects to is privileged and not
  being spoofed through a man-in-the-middle attack by OR'ing the
  <var class="Ft">XPC_CONNECTION_MACH_SERVICE_PRIVILEGED</var> flag into the
  <var class="Fa">flags</var> argument. This flag will cause
  <var class="Ft">XPC_ERROR_CONNECTION_INVALID</var> to be given to the event
  handler if the service name was not found in the root Mach bootstrap. If the
  <a class="Xr">launchd.plist(5)</a> lives in /Library/LaunchAgents or
  ~/Library/LaunchAgents, then this flag should not be passed.
<p class="Pp">The launchd job using XPC is required to create a listener
    connection manually by calling
    <code class="Fn">xpc_connection_create_mach_service</code>() with the
    <var class="Ft">XPC_CONNECTION_MACH_SERVICE_LISTENER</var> flag OR'ed into
    the <var class="Fa">flags</var> argument. The
    <var class="Fa">XPC_CONNECTION_MACH_SERVICE_PRIVILEGED</var> flag has no
    effect on these connections. If the service name for the connection is not
    present in your launchd.plist's MachServices dictionary, your listener
    connection's event handler will receive the XPC_ERROR_CONNECTION_INVALID
    error, as XPC disallows ad-hoc service name registrations. However, assuming
    your configuration is correct, the listener connection will only ever
    deliver new peer connections to its event handler. The connections received
    by the event handler must have an event hander set on them and resumed along
    with an optional target queue, just like the peer connections delivered to
    the handler given to <a class="Xr">xpc_main(3)</a>. Note connections
    received through listener connection's event handler do not inherit the
    target queue of the listener.</p>
<div class="Bd Pp Bd-indent">
<pre>
int
main(void)
{
	xpc_connection_t listener = xpc_connection_create_mach_service(&quot;com.apple.myservice&quot;, NULL, XPC_CONNECTION_MACH_SERVICE_LISTENER);
	xpc_connection_set_event_handler(listener, ^(xpc_object_t peer) {
		// It is safe to cast 'peer' to xpc_connection_t assuming
		// we have a correct configuration in our launchd.plist.
		xpc_connection_set_event_handler(peer, ^(xpc_object_t event) {
			// Handle event, whether it is a message or an error.
		});
		xpc_connection_activate(peer);
	});
	xpc_connection_activate(listener);

	dispatch_main();
	exit(EXIT_FAILURE);
}
</pre>
</div>
<p class="Pp"><i class="Em">Important</i>: New service names may
    <i class="Em">NOT</i> be dynamically registered using
    <code class="Fn">xpc_connection_create_mach_service</code>(). Only launchd
    jobs may listen on certain service names, and any service name that the job
    wishes to listen on must be declared in its
    <a class="Xr">launchd.plist(5)</a>. XPC may make allowances for dynamic name
    registration in debug scenarios, but these allowances absolutely will
    <i class="Em">NOT</i> be made in the production scenario.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="UNLOADING"><a class="permalink" href="#UNLOADING">UNLOADING</a></h1>
An XPC connection to a MachService advertised by a <a class="Xr">launchd(8)</a>
  job will receive the <var class="Ft">XPC_ERROR_CONNECTION_INTERRUPTED</var>
  error followed by the <var class="Ft">XPC_ERROR_CONNECTION_INVALID</var> error
  if the job is unloaded. There will be no indication of when the job has been
  loaded again. Using job loading and unloading as a normal part of your job's
  operation is highly discouraged.
</section>
<section class="Sh">
<h1 class="Sh" id="ANONYMOUS_CONNECTIONS"><a class="permalink" href="#ANONYMOUS_CONNECTIONS">ANONYMOUS
  CONNECTIONS</a></h1>
If a caller wishes to create a listener connection that is not bound to a
  particular service name, it may create an anonymous listener connection by
  calling <code class="Fn">xpc_connection_create</code>() and passing NULL as
  the <var class="Fa">name</var>. This connection may be given to
  <a class="Xr">xpc_endpoint_create(3)</a>, and the result may be embedded in a
  message. The recipient of that message will then be able to create a
  connection from that endpoint using
  <code class="Fn">xpc_connection_create_from_endpoint</code>().
<p class="Pp">The resulting connection will behave like a connection to a named
    service created using <code class="Fn">xpc_connection_create</code>(). The
    fundamental difference is that an anonymous connection is not backed a name
    that can be looked up. Therefore, if an connection created from an endpoint
    is closed, there is no guarantee that it can be re-established. So anonymous
    connections' event handlers must always handle <i class="Em">both</i> the
    <var class="Ft">XPC_ERROR_CONNECTION_INTERRUPTED</var> and
    <var class="Ft">XPC_ERROR_CONNECTION_INVALID</var> errors.</p>
<p class="Pp">The <var class="Ft">endpoint</var> type may be thought of as a
    boxed connection, in the same way that the <var class="Ft">uint64</var> type
    is a boxed <var class="Ft">uint64_t</var>. Like other types, the collection
    APIs provide primitive setters and getters for connections, so instead of
    first boxing a connection in an endpoint, the
    <a class="Xr">xpc_dictionary_set_connection(3)</a>,
    <a class="Xr">xpc_dictionary_create_connection(3)</a>,
    <a class="Xr">xpc_array_set_connection(3)</a>, and
    <a class="Xr">xpc_array_create_connection(3)</a> APIs may be used.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<a class="Xr">xpc(3)</a>, <a class="Xr">xpc_main(3)</a>,
  <a class="Xr">xpc_object(3)</a>, <a class="Xr">xpc_dictionary_create(3)</a>,
  <a class="Xr">xpc_objects(3)</a>, <a class="Xr">setaudit_addr(2)</a>,
  <a class="Xr">dispatch_group_create(3)</a>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">20 June, 2012</td>
    <td class="foot-os">Darwin</td>
  </tr>
</table>
</body>
</html>
