<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>PERLFORM(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">PERLFORM(1)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">PERLFORM(1)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
perlform - Perl formats
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
Perl has a mechanism to help you generate simple reports and charts. To
  facilitate this, Perl helps you code up your output page close to how it will
  look when it's printed. It can keep track of things like how many lines are on
  a page, what page you're on, when to print page headers, etc. Keywords are
  borrowed from FORTRAN: <b>format()</b> to declare and <b>write()</b> to
  execute; see their entries in perlfunc. Fortunately, the layout is much more
  legible, more like BASIC's PRINT USING statement. Think of it as a poor man's
  <b>nroff</b>(1).
<p class="Pp">Formats, like packages and subroutines, are declared rather than
    executed, so they may occur at any point in your program. (Usually it's best
    to keep them all together though.) They have their own namespace apart from
    all the other &quot;types&quot; in Perl. This means that if you have a
    function named &quot;Foo&quot;, it is not the same thing as having a format
    named &quot;Foo&quot;. However, the default name for the format associated
    with a given filehandle is the same as the name of the filehandle. Thus, the
    default format for STDOUT is named &quot;STDOUT&quot;, and the default
    format for filehandle TEMP is named &quot;TEMP&quot;. They just look the
    same. They aren't.</p>
<p class="Pp">Output record formats are declared as follows:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    format NAME =
    FORMLIST
    .
</pre>
<p class="Pp">If the name is omitted, format &quot;STDOUT&quot; is defined. A
    single &quot;.&quot; in column 1 is used to terminate a format. FORMLIST
    consists of a sequence of lines, each of which may be one of three
  types:</p>
<dl class="Bl-tag">
  <dt>1.</dt>
  <dd>A comment, indicated by putting a '#' in the first column.</dd>
  <dt>2.</dt>
  <dd>A &quot;picture&quot; line giving the format for one output line.</dd>
  <dt>3.</dt>
  <dd>An argument line supplying values to plug into the previous picture
    line.</dd>
</dl>
<p class="Pp">Picture lines contain output field definitions, intermingled with
    literal text. These lines do not undergo any kind of variable interpolation.
    Field definitions are made up from a set of characters, for starting and
    extending a field to its desired width. This is the complete set of
    characters for field definitions:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
   @    start of regular field
   ^    start of special field
   &lt;    pad character for left justification
   |    pad character for centering
   &gt;    pad character for right justification
   #    pad character for a right-justified numeric field
   0    instead of first #: pad number with leading zeroes
   .    decimal point within a numeric field
   ...  terminate a text field, show &quot;...&quot; as truncation evidence
   @*   variable width field for a multi-line value
   ^*   variable width field for next line of a multi-line value
   ~    suppress line with all fields empty
   ~~   repeat line until all fields are exhausted
</pre>
<p class="Pp">Each field in a picture line starts with either &quot;@&quot; (at)
    or &quot;^&quot; (caret), indicating what we'll call, respectively, a
    &quot;regular&quot; or &quot;special&quot; field. The choice of pad
    characters determines whether a field is textual or numeric. The tilde
    operators are not part of a field. Let's look at the various possibilities
    in detail.</p>
<section class="Ss">
<h2 class="Ss" id="Text_Fields"><a class="permalink" href="#Text_Fields">Text
  Fields</a></h2>
The length of the field is supplied by padding out the field with multiple
  &quot;&lt;&quot;, &quot;&gt;&quot;, or &quot;|&quot; characters to specify a
  non-numeric field with, respectively, left justification, right justification,
  or centering. For a regular field, the value (up to the first newline) is
  taken and printed according to the selected justification, truncating excess
  characters. If you terminate a text field with &quot;...&quot;, three dots
  will be shown if the value is truncated. A special text field may be used to
  do rudimentary multi-line text block filling; see &quot;Using Fill Mode&quot;
  for details.
<p class="Pp"><span class="Li"></span></p>
<pre>
   Example:
      format STDOUT =
      @&lt;&lt;&lt;&lt;&lt;&lt;   @||||||   @&gt;&gt;&gt;&gt;&gt;&gt;
      &quot;left&quot;,   &quot;middle&quot;, &quot;right&quot;
      .
   Output:
      left      middle    right
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Numeric_Fields"><a class="permalink" href="#Numeric_Fields">Numeric
  Fields</a></h2>
Using &quot;#&quot; as a padding character specifies a numeric field, with right
  justification. An optional &quot;.&quot; defines the position of the decimal
  point. With a &quot;0&quot; (zero) instead of the first &quot;#&quot;, the
  formatted number will be padded with leading zeroes if necessary. A special
  numeric field is blanked out if the value is undefined. If the resulting value
  would exceed the width specified the field is filled with &quot;#&quot; as
  overflow evidence.
<p class="Pp"><span class="Li"></span></p>
<pre>
   Example:
      format STDOUT =
      @###   @.###   @##.###  @###   @###   ^####
       42,   3.1415,  undef,    0, 10000,   undef
      .
   Output:
        42   3.142     0.000     0   ####
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="The_Field_@*_for_Variable-Width_Multi-Line_Text"><a class="permalink" href="#The_Field_@*_for_Variable-Width_Multi-Line_Text">The
  Field @* for Variable-Width Multi-Line Text</a></h2>
The field &quot;@*&quot; can be used for printing multi-line, nontruncated
  values; it should (but need not) appear by itself on a line. A final line feed
  is chomped off, but all other characters are emitted verbatim.
</section>
<section class="Ss">
<h2 class="Ss" id="The_Field__*_for_Variable-Width_One-line-at-a-time_Text"><a class="permalink" href="#The_Field__*_for_Variable-Width_One-line-at-a-time_Text">The
  Field ^* for Variable-Width One-line-at-a-time Text</a></h2>
Like &quot;@*&quot;, this is a variable-width field. The value supplied must be
  a scalar variable. Perl puts the first line (up to the first &quot;\n&quot;)
  of the text into the field, and then chops off the front of the string so that
  the next time the variable is referenced, more of the text can be printed. The
  variable will <i>not</i> be restored.
<p class="Pp"><span class="Li"></span></p>
<pre>
   Example:
      $text = &quot;line 1\nline 2\nline 3&quot;;
      format STDOUT =
      Text: ^*
            $text
      ~~    ^*
            $text
      .
   Output:
      Text: line 1
            line 2
            line 3
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Specifying_Values"><a class="permalink" href="#Specifying_Values">Specifying
  Values</a></h2>
The values are specified on the following format line in the same order as the
  picture fields. The expressions providing the values must be separated by
  commas. They are all evaluated in a list context before the line is processed,
  so a single list expression could produce multiple list elements. The
  expressions may be spread out to more than one line if enclosed in braces. If
  so, the opening brace must be the first token on the first line. If an
  expression evaluates to a number with a decimal part, and if the corresponding
  picture specifies that the decimal part should appear in the output (that is,
  any picture except multiple &quot;#&quot; characters <b>without</b> an
  embedded &quot;.&quot;), the character used for the decimal point is
  determined by the current LC_NUMERIC locale if <span class="Li">&quot;use
  locale&quot;</span> is in effect. This means that, if, for example, the
  run-time environment happens to specify a German locale, &quot;,&quot; will be
  used instead of the default &quot;.&quot;. See perllocale and
  &quot;WARNINGS&quot; for more information.
</section>
<section class="Ss">
<h2 class="Ss" id="Using_Fill_Mode"><a class="permalink" href="#Using_Fill_Mode">Using
  Fill Mode</a></h2>
On text fields the caret enables a kind of fill mode. Instead of an arbitrary
  expression, the value supplied must be a scalar variable that contains a text
  string. Perl puts the next portion of the text into the field, and then chops
  off the front of the string so that the next time the variable is referenced,
  more of the text can be printed. (Yes, this means that the variable itself is
  altered during execution of the <b>write()</b> call, and is not restored.) The
  next portion of text is determined by a crude line-breaking algorithm. You may
  use the carriage return character (<span class="Li">&quot;\r&quot;</span>) to
  force a line break. You can change which characters are legal to break on by
  changing the variable <span class="Li">$:</span> (that's
  <span class="Li">$FORMAT_LINE_BREAK_CHARACTERS</span> if you're using the
  English module) to a list of the desired characters.
<p class="Pp">Normally you would use a sequence of fields in a vertical stack
    associated with the same scalar variable to print out a block of text. You
    might wish to end the final field with the text &quot;...&quot;, which will
    appear in the output if the text was too long to appear in its entirety.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Suppressing_Lines_Where_All_Fields_Are_Void"><a class="permalink" href="#Suppressing_Lines_Where_All_Fields_Are_Void">Suppressing
  Lines Where All Fields Are Void</a></h2>
Using caret fields can produce lines where all fields are blank. You can
  suppress such lines by putting a &quot;~&quot; (tilde) character anywhere in
  the line. The tilde will be translated to a space upon output.
</section>
<section class="Ss">
<h2 class="Ss" id="Repeating_Format_Lines"><a class="permalink" href="#Repeating_Format_Lines">Repeating
  Format Lines</a></h2>
If you put two contiguous tilde characters &quot;~~&quot; anywhere into a line,
  the line will be repeated until all the fields on the line are exhausted, i.e.
  undefined. For special (caret) text fields this will occur sooner or later,
  but if you use a text field of the at variety, the expression you supply had
  better not give the same value every time forever!
  (<span class="Li">&quot;shift(@f)&quot;</span> is a simple example that would
  work.) Don't use a regular (at) numeric field in such lines, because it will
  never go blank.
</section>
<section class="Ss">
<h2 class="Ss" id="Top_of_Form_Processing"><a class="permalink" href="#Top_of_Form_Processing">Top
  of Form Processing</a></h2>
Top-of-form processing is by default handled by a format with the same name as
  the current filehandle with &quot;_TOP&quot; concatenated to it. It's
  triggered at the top of each page. See &quot;write&quot; in perlfunc.
<p class="Pp">Examples:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
 # a report on the /etc/passwd file
 format STDOUT_TOP =
                         Passwd File
 Name                Login    Office   Uid   Gid Home
 ------------------------------------------------------------------
 .
 format STDOUT =
 @&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; @||||||| @&lt;&lt;&lt;&lt;&lt;&lt;@&gt;&gt;&gt;&gt; @&gt;&gt;&gt;&gt; @&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;
 $name,              $login,  $office,$uid,$gid, $home
 .


 # a report from a bug report form
 format STDOUT_TOP =
                         Bug Reports
 @&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;     @|||         @&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
 $system,                      $%,         $date
 ------------------------------------------------------------------
 .
 format STDOUT =
 Subject: @&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;
          $subject
 Index: @&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; ^&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;
        $index,                       $description
 Priority: @&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; Date: @&lt;&lt;&lt;&lt;&lt;&lt;&lt; ^&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;
           $priority,        $date,   $description
 From: @&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; ^&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;
       $from,                         $description
 Assigned to: @&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; ^&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;
              $programmer,            $description
 ~                                    ^&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;
                                      $description
 ~                                    ^&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;
                                      $description
 ~                                    ^&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;
                                      $description
 ~                                    ^&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;
                                      $description
 ~                                    ^&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;...
                                      $description
 .
</pre>
<p class="Pp">It is possible to intermix <b>print()</b>s with <b>write()</b>s on
    the same output channel, but you'll have to handle
    <span class="Li">&quot;$-&quot;</span>
    (<span class="Li">$FORMAT_LINES_LEFT</span>) yourself.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Format_Variables"><a class="permalink" href="#Format_Variables">Format
  Variables</a></h2>
The current format name is stored in the variable <span class="Li">$~</span>
  (<span class="Li">$FORMAT_NAME</span>), and the current top of form format
  name is in <span class="Li">$^</span>
  (<span class="Li">$FORMAT_TOP_NAME</span>). The current output page number is
  stored in <span class="Li">$%</span>
  (<span class="Li">$FORMAT_PAGE_NUMBER</span>), and the number of lines on the
  page is in <span class="Li">$=</span>
  (<span class="Li">$FORMAT_LINES_PER_PAGE</span>). Whether to autoflush output
  on this handle is stored in <span class="Li">$|</span>
  (<span class="Li">$OUTPUT_AUTOFLUSH</span>). The string output before each top
  of page (except the first) is stored in <span class="Li">$^L</span>
  (<span class="Li">$FORMAT_FORMFEED</span>). These variables are set on a
  per-filehandle basis, so you'll need to <b>select()</b> into a different one
  to affect them:
<p class="Pp"><span class="Li"></span></p>
<pre>
    select((select(OUTF),
            $~ = &quot;My_Other_Format&quot;,
            $^ = &quot;My_Top_Format&quot;
           )[0]);
</pre>
<p class="Pp">Pretty ugly, eh? It's a common idiom though, so don't be too
    surprised when you see it. You can at least use a temporary variable to hold
    the previous filehandle: (this is a much better approach in general, because
    not only does legibility improve, you now have an intermediary stage in the
    expression to single-step the debugger through):</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    $ofh = select(OUTF);
    $~ = &quot;My_Other_Format&quot;;
    $^ = &quot;My_Top_Format&quot;;
    select($ofh);
</pre>
<p class="Pp">If you use the English module, you can even read the variable
    names:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    use English;
    $ofh = select(OUTF);
    $FORMAT_NAME     = &quot;My_Other_Format&quot;;
    $FORMAT_TOP_NAME = &quot;My_Top_Format&quot;;
    select($ofh);
</pre>
<p class="Pp">But you still have those funny <b>select()</b>s. So just use the
    FileHandle module. Now, you can access these special variables using
    lowercase method names instead:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    use FileHandle;
    format_name     OUTF &quot;My_Other_Format&quot;;
    format_top_name OUTF &quot;My_Top_Format&quot;;
</pre>
<p class="Pp">Much better!</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="NOTES"><a class="permalink" href="#NOTES">NOTES</a></h1>
Because the values line may contain arbitrary expressions (for at fields, not
  caret fields), you can farm out more sophisticated processing to other
  functions, like <b>sprintf()</b> or one of your own. For example:
<p class="Pp"><span class="Li"></span></p>
<pre>
    format Ident =
        @&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;
        &amp;commify($n)
    .
</pre>
<p class="Pp">To get a real at or caret into the field, do this:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    format Ident =
    I have an @ here.
            &quot;@&quot;
    .
</pre>
<p class="Pp">To center a whole line of text, do something like this:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    format Ident =
    @|||||||||||||||||||||||||||||||||||||||||||||||
            &quot;Some text line&quot;
    .
</pre>
<p class="Pp">There is no builtin way to say &quot;float this to the right hand
    side of the page, however wide it is.&quot; You have to specify where it
    goes. The truly desperate can generate their own format on the fly, based on
    the current number of columns, and then <b>eval()</b> it:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    $format  = &quot;format STDOUT = \n&quot;
             . '^' . '&lt;' x $cols . &quot;\n&quot;
             . '$entry' . &quot;\n&quot;
             . &quot;\t^&quot; . &quot;&lt;&quot; x ($cols-8) . &quot;~~\n&quot;
             . '$entry' . &quot;\n&quot;
             . &quot;.\n&quot;;
    print $format if $Debugging;
    eval $format;
    die $@ if $@;
</pre>
<p class="Pp">Which would generate a format looking something like this:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
 format STDOUT =
 ^&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;
 $entry
         ^&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;~~
 $entry
 .
</pre>
<p class="Pp">Here's a little program that's somewhat like <b>fmt</b>(1):</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
 format =
 ^&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; ~~
 $_

 .

 $/ = '';
 while (&lt;&gt;) {
     s/\s*\n\s*/ /g;
     write;
 }
</pre>
<section class="Ss">
<h2 class="Ss" id="Footers"><a class="permalink" href="#Footers">Footers</a></h2>
While <span class="Li">$FORMAT_TOP_NAME</span> contains the name of the current
  header format, there is no corresponding mechanism to automatically do the
  same thing for a footer. Not knowing how big a format is going to be until you
  evaluate it is one of the major problems. It's on the TODO list.
<p class="Pp">Here's one strategy: If you have a fixed-size footer, you can get
    footers by checking <span class="Li">$FORMAT_LINES_LEFT</span> before each
    <b>write()</b> and print the footer yourself if necessary.</p>
<p class="Pp">Here's another strategy: Open a pipe to yourself, using
    <span class="Li">&quot;open(MYSELF, &quot;|-&quot;)&quot;</span> (see
    &quot;open&quot; in perlfunc) and always <b>write()</b> to MYSELF instead of
    STDOUT. Have your child process massage its STDIN to rearrange headers and
    footers however you like. Not very convenient, but doable.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Accessing_Formatting_Internals"><a class="permalink" href="#Accessing_Formatting_Internals">Accessing
  Formatting Internals</a></h2>
For low-level access to the formatting mechanism, you may use <b>formline()</b>
  and access <span class="Li">$^A</span> (the
  <span class="Li">$ACCUMULATOR</span> variable) directly.
<p class="Pp">For example:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    $str = formline &lt;&lt;'END', 1,2,3;
    @&lt;&lt;&lt;  @|||  @&gt;&gt;&gt;
    END

    print &quot;Wow, I just stored '$^A' in the accumulator!\n&quot;;
</pre>
<p class="Pp">Or to make an <b>swrite()</b> subroutine, which is to
    <b>write()</b> what <b>sprintf()</b> is to <b>printf()</b>, do this:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    use Carp;
    sub swrite {
        croak &quot;usage: swrite PICTURE ARGS&quot; unless @_;
        my $format = shift;
        $^A = &quot;&quot;;
        formline($format,@_);
        return $^A;
    }

    $string = swrite(&lt;&lt;'END', 1, 2, 3);
 Check me out
 @&lt;&lt;&lt;  @|||  @&gt;&gt;&gt;
 END
    print $string;
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="WARNINGS"><a class="permalink" href="#WARNINGS">WARNINGS</a></h1>
The lone dot that ends a format can also prematurely end a mail message passing
  through a misconfigured Internet mailer (and based on experience, such
  misconfiguration is the rule, not the exception). So when sending format code
  through mail, you should indent it so that the format-ending dot is not on the
  left margin; this will prevent SMTP cutoff.
<p class="Pp">Lexical variables (declared with &quot;my&quot;) are not visible
    within a format unless the format is declared within the scope of the
    lexical variable.</p>
<p class="Pp">If a program's environment specifies an LC_NUMERIC locale and
    <span class="Li">&quot;use</span> <span class="Li">locale&quot;</span> is in
    effect when the format is declared, the locale is used to specify the
    decimal point character in formatted output. Formatted output cannot be
    controlled by <span class="Li">&quot;use locale&quot;</span> at the time
    when <b>write()</b> is called. See perllocale for further discussion of
    locale handling.</p>
<p class="Pp">Within strings that are to be displayed in a fixed-length text
    field, each control character is substituted by a space. (But remember the
    special meaning of <span class="Li">&quot;\r&quot;</span> when using fill
    mode.) This is done to avoid misalignment when control characters
    &quot;disappear&quot; on some output media.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2019-10-24</td>
    <td class="foot-os">perl v5.30.2</td>
  </tr>
</table>
</body>
</html>
