<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>PERLSUB(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">PERLSUB(1)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">PERLSUB(1)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
perlsub - Perl subroutines
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
To declare subroutines:
<p class="Pp"><span class="Li"></span></p>
<pre>
    sub NAME;                     # A &quot;forward&quot; declaration.
    sub NAME(PROTO);              #  ditto, but with prototypes
    sub NAME : ATTRS;             #  with attributes
    sub NAME(PROTO) : ATTRS;      #  with attributes and prototypes

    sub NAME BLOCK                # A declaration and a definition.
    sub NAME(PROTO) BLOCK         #  ditto, but with prototypes
    sub NAME : ATTRS BLOCK        #  with attributes
    sub NAME(PROTO) : ATTRS BLOCK #  with prototypes and attributes
</pre>
<p class="Pp">To define an anonymous subroutine at runtime:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    $subref = sub BLOCK;                 # no proto
    $subref = sub (PROTO) BLOCK;         # with proto
    $subref = sub : ATTRS BLOCK;         # with attributes
    $subref = sub (PROTO) : ATTRS BLOCK; # with proto and attributes
</pre>
<p class="Pp">To import subroutines:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    use MODULE qw(NAME1 NAME2 NAME3);
</pre>
<p class="Pp">To call subroutines:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    NAME(LIST);    # &amp; is optional with parentheses.
    NAME LIST;     # Parentheses optional if predeclared/imported.
    &amp;NAME(LIST);   # Circumvent prototypes.
    &amp;NAME;         # Makes current @_ visible to called subroutine.
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
Like many languages, Perl provides for user-defined subroutines. These may be
  located anywhere in the main program, loaded in from other files via the
  <span class="Li">&quot;do&quot;</span>,
  <span class="Li">&quot;require&quot;</span>, or
  <span class="Li">&quot;use&quot;</span> keywords, or generated on the fly
  using <span class="Li">&quot;eval&quot;</span> or anonymous subroutines. You
  can even call a function indirectly using a variable containing its name or a
  CODE reference.
<p class="Pp">The Perl model for function call and return values is simple: all
    functions are passed as parameters one single flat list of scalars, and all
    functions likewise return to their caller one single flat list of scalars.
    Any arrays or hashes in these call and return lists will collapse, losing
    their identities--but you may always use pass-by-reference instead to avoid
    this. Both call and return lists may contain as many or as few scalar
    elements as you'd like. (Often a function without an explicit return
    statement is called a subroutine, but there's really no difference from
    Perl's perspective.)</p>
<p class="Pp">Any arguments passed in show up in the array
    <span class="Li">@_</span>. Therefore, if you called a function with two
    arguments, those would be stored in <span class="Li">$_[0]</span> and
    <span class="Li">$_[1]</span>. The array <span class="Li">@_</span> is a
    local array, but its elements are aliases for the actual scalar parameters.
    In particular, if an element <span class="Li">$_[0]</span> is updated, the
    corresponding argument is updated (or an error occurs if it is not
    updatable). If an argument is an array or hash element which did not exist
    when the function was called, that element is created only when (and if) it
    is modified or a reference to it is taken. (Some earlier versions of Perl
    created the element whether or not the element was assigned to.) Assigning
    to the whole array <span class="Li">@_</span> removes that aliasing, and
    does not update any arguments.</p>
<p class="Pp">A <span class="Li">&quot;return&quot;</span> statement may be used
    to exit a subroutine, optionally specifying the returned value, which will
    be evaluated in the appropriate context (list, scalar, or void) depending on
    the context of the subroutine call. If you specify no return value, the
    subroutine returns an empty list in list context, the undefined value in
    scalar context, or nothing in void context. If you return one or more
    aggregates (arrays and hashes), these will be flattened together into one
    large indistinguishable list.</p>
<p class="Pp">If no <span class="Li">&quot;return&quot;</span> is found and if
    the last statement is an expression, its value is returned. If the last
    statement is a loop control structure like a
    <span class="Li">&quot;foreach&quot;</span> or a
    <span class="Li">&quot;while&quot;</span>, the returned value is
    unspecified. The empty sub returns the empty list.</p>
<p class="Pp">Perl does not have named formal parameters. In practice all you do
    is assign to a <span class="Li">&quot;my()&quot;</span> list of these.
    Variables that aren't declared to be private are global variables. For gory
    details on creating private variables, see &quot;Private Variables via
    <i>my()</i>&quot; and &quot;Temporary Values via <i>local()</i>&quot;. To
    create protected environments for a set of functions in a separate package
    (and probably a separate file), see &quot;Packages&quot; in perlmod.</p>
<p class="Pp">Example:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    sub max {
        my $max = shift(@_);
        foreach $foo (@_) {
            $max = $foo if $max &lt; $foo;
        }
        return $max;
    }
    $bestday = max($mon,$tue,$wed,$thu,$fri);
</pre>
<p class="Pp">Example:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    # get a line, combining continuation lines
    #  that start with whitespace

    sub get_line {
        $thisline = $lookahead;  # global variables!
        LINE: while (defined($lookahead = &lt;STDIN&gt;)) {
            if ($lookahead =~ /^[ \t]/) {
                $thisline .= $lookahead;
            }
            else {
                last LINE;
            }
        }
        return $thisline;
    }

    $lookahead = &lt;STDIN&gt;;       # get first line
    while (defined($line = get_line())) {
        ...
    }
</pre>
<p class="Pp">Assigning to a list of private variables to name your
  arguments:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    sub maybeset {
        my($key, $value) = @_;
        $Foo{$key} = $value unless $Foo{$key};
    }
</pre>
<p class="Pp">Because the assignment copies the values, this also has the effect
    of turning call-by-reference into call-by-value. Otherwise a function is
    free to do in-place modifications of <span class="Li">@_</span> and change
    its caller's values.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    upcase_in($v1, $v2);  # this changes $v1 and $v2
    sub upcase_in {
        for (@_) { tr/a-z/A-Z/ }
    }
</pre>
<p class="Pp">You aren't allowed to modify constants in this way, of course. If
    an argument were actually literal and you tried to change it, you'd take a
    (presumably fatal) exception. For example, this won't work:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    upcase_in(&quot;frederick&quot;);
</pre>
<p class="Pp">It would be much safer if the
    <span class="Li">&quot;upcase_in()&quot;</span> function were written to
    return a copy of its parameters instead of changing them in place:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    ($v3, $v4) = upcase($v1, $v2);  # this doesn't change $v1 and $v2
    sub upcase {
        return unless defined wantarray;  # void context, do nothing
        my @parms = @_;
        for (@parms) { tr/a-z/A-Z/ }
        return wantarray ? @parms : $parms[0];
    }
</pre>
<p class="Pp">Notice how this (unprototyped) function doesn't care whether it
    was passed real scalars or arrays. Perl sees all arguments as one big, long,
    flat parameter list in <span class="Li">@_</span>. This is one area where
    Perl's simple argument-passing style shines. The
    <span class="Li">&quot;upcase()&quot;</span> function would work perfectly
    well without changing the <span class="Li">&quot;upcase()&quot;</span>
    definition even if we fed it things like this:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    @newlist   = upcase(@list1, @list2);
    @newlist   = upcase( split /:/, $var );
</pre>
<p class="Pp">Do not, however, be tempted to do this:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    (@a, @b)   = upcase(@list1, @list2);
</pre>
<p class="Pp">Like the flattened incoming parameter list, the return list is
    also flattened on return. So all you have managed to do here is stored
    everything in <span class="Li">@a</span> and made <span class="Li">@b</span>
    empty. See &quot;Pass by Reference&quot; for alternatives.</p>
<p class="Pp">A subroutine may be called using an explicit
    <span class="Li">&quot;&amp;&quot;</span> prefix. The
    <span class="Li">&quot;&amp;&quot;</span> is optional in modern Perl, as are
    parentheses if the subroutine has been predeclared. The
    <span class="Li">&quot;&amp;&quot;</span> is <i>not</i> optional when just
    naming the subroutine, such as when it's used as an argument to
    <i>defined()</i> or <i>undef()</i>. Nor is it optional when you want to do
    an indirect subroutine call with a subroutine name or reference using the
    <span class="Li">&quot;&amp;$subref()&quot;</span> or
    <span class="Li">&quot;&amp;{$subref}()&quot;</span> constructs, although
    the <span class="Li">&quot;$subref-&gt;()&quot;</span> notation solves that
    problem. See perlref for more about all that.</p>
<p class="Pp">Subroutines may be called recursively. If a subroutine is called
    using the <span class="Li">&quot;&amp;&quot;</span> form, the argument list
    is optional, and if omitted, no <span class="Li">@_</span> array is set up
    for the subroutine: the <span class="Li">@_</span> array at the time of the
    call is visible to subroutine instead. This is an efficiency mechanism that
    new users may wish to avoid.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    &amp;foo(1,2,3);        # pass three arguments
    foo(1,2,3);         # the same

    foo();              # pass a null list
    &amp;foo();             # the same

    &amp;foo;               # foo() get current args, like foo(@_) !!
    foo;                # like foo() IFF sub foo predeclared, else &quot;foo&quot;
</pre>
<p class="Pp">Not only does the <span class="Li">&quot;&amp;&quot;</span> form
    make the argument list optional, it also disables any prototype checking on
    arguments you do provide. This is partly for historical reasons, and partly
    for having a convenient way to cheat if you know what you're doing. See
    &quot;Prototypes&quot; below.</p>
<p class="Pp">Since Perl 5.16.0, the <span class="Li">&quot;__SUB__&quot;</span>
    token is available under <span class="Li">&quot;use feature</span>
    <span class="Li">'current_sub'&quot;</span> and <span class="Li">&quot;use
    5.16.0&quot;</span>. It will evaluate to a reference to the
    currently-running sub, which allows for recursive calls without knowing your
    subroutine's name.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    use 5.16.0;
    my $factorial = sub {
      my ($x) = @_;
      return 1 if $x == 1;
      return($x * __SUB__-&gt;( $x - 1 ) );
    };
</pre>
<p class="Pp">The behaviour of <span class="Li">&quot;__SUB__&quot;</span>
    within a regex code block (such as
    <span class="Li">&quot;/(?{...})/&quot;</span>) is subject to change.</p>
<p class="Pp">Subroutines whose names are in all upper case are reserved to the
    Perl core, as are modules whose names are in all lower case. A subroutine in
    all capitals is a loosely-held convention meaning it will be called
    indirectly by the run-time system itself, usually due to a triggered event.
    Subroutines that do special, pre-defined things include
    <span class="Li">&quot;AUTOLOAD&quot;</span>,
    <span class="Li">&quot;CLONE&quot;</span>,
    <span class="Li">&quot;DESTROY&quot;</span> plus all functions mentioned in
    perltie and PerlIO::via.</p>
<p class="Pp">The <span class="Li">&quot;BEGIN&quot;</span>,
    <span class="Li">&quot;UNITCHECK&quot;</span>,
    <span class="Li">&quot;CHECK&quot;</span>,
    <span class="Li">&quot;INIT&quot;</span> and
    <span class="Li">&quot;END&quot;</span> subroutines are not so much
    subroutines as named special code blocks, of which you can have more than
    one in a package, and which you can <b>not</b> call explicitly. See
    &quot;BEGIN, UNITCHECK, CHECK, INIT and END&quot; in perlmod</p>
<section class="Ss">
<h2 class="Ss" id="Private_Variables_via__fImy()_fP"><a class="permalink" href="#Private_Variables_via__fImy()_fP">Private
  Variables via <i>my()</i></a></h2>
Synopsis:
<p class="Pp"><span class="Li"></span></p>
<pre>
    my $foo;            # declare $foo lexically local
    my (@wid, %get);    # declare list of variables local
    my $foo = &quot;flurp&quot;;  # declare $foo lexical, and init it
    my @oof = @bar;     # declare @oof lexical, and init it
    my $x : Foo = $y;   # similar, with an attribute applied
</pre>
<p class="Pp"><b>WARNING</b>: The use of attribute lists on
    <span class="Li">&quot;my&quot;</span> declarations is still evolving. The
    current semantics and interface are subject to change. See attributes and
    Attribute::Handlers.</p>
<p class="Pp">The <span class="Li">&quot;my&quot;</span> operator declares the
    listed variables to be lexically confined to the enclosing block,
    conditional (<span class="Li">&quot;if/unless/elsif/else&quot;</span>), loop
    (<span class="Li">&quot;for/foreach/while/until/continue&quot;</span>),
    subroutine, <span class="Li">&quot;eval&quot;</span>, or
    <span class="Li">&quot;do/require/use&quot;</span>'d file. If more than one
    value is listed, the list must be placed in parentheses. All listed elements
    must be legal lvalues. Only alphanumeric identifiers may be lexically
    scoped--magical built-ins like <span class="Li">$/</span> must currently be
    <span class="Li">&quot;local&quot;</span>ized with
    <span class="Li">&quot;local&quot;</span> instead.</p>
<p class="Pp">Unlike dynamic variables created by the
    <span class="Li">&quot;local&quot;</span> operator, lexical variables
    declared with <span class="Li">&quot;my&quot;</span> are totally hidden from
    the outside world, including any called subroutines. This is true if it's
    the same subroutine called from itself or elsewhere--every call gets its own
    copy.</p>
<p class="Pp">This doesn't mean that a <span class="Li">&quot;my&quot;</span>
    variable declared in a statically enclosing lexical scope would be
    invisible. Only dynamic scopes are cut off. For example, the
    <span class="Li">&quot;bumpx()&quot;</span> function below has access to the
    lexical <span class="Li">$x</span> variable because both the
    <span class="Li">&quot;my&quot;</span> and the
    <span class="Li">&quot;sub&quot;</span> occurred at the same scope,
    presumably file scope.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    my $x = 10;
    sub bumpx { $x++ }
</pre>
<p class="Pp">An <span class="Li">&quot;eval()&quot;</span>, however, can see
    lexical variables of the scope it is being evaluated in, so long as the
    names aren't hidden by declarations within the
    <span class="Li">&quot;eval()&quot;</span> itself. See perlref.</p>
<p class="Pp">The parameter list to <i>my()</i> may be assigned to if desired,
    which allows you to initialize your variables. (If no initializer is given
    for a particular variable, it is created with the undefined value.) Commonly
    this is used to name input parameters to a subroutine. Examples:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    $arg = &quot;fred&quot;;        # &quot;global&quot; variable
    $n = cube_root(27);
    print &quot;$arg thinks the root is $n\n&quot;;
 fred thinks the root is 3

    sub cube_root {
        my $arg = shift;  # name doesn't matter
        $arg **= 1/3;
        return $arg;
    }
</pre>
<p class="Pp">The <span class="Li">&quot;my&quot;</span> is simply a modifier on
    something you might assign to. So when you do assign to variables in its
    argument list, <span class="Li">&quot;my&quot;</span> doesn't change whether
    those variables are viewed as a scalar or an array. So</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    my ($foo) = &lt;STDIN&gt;;                # WRONG?
    my @FOO = &lt;STDIN&gt;;
</pre>
<p class="Pp">both supply a list context to the right-hand side, while</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    my $foo = &lt;STDIN&gt;;
</pre>
<p class="Pp">supplies a scalar context. But the following declares only one
    variable:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    my $foo, $bar = 1;                  # WRONG
</pre>
<p class="Pp">That has the same effect as</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    my $foo;
    $bar = 1;
</pre>
<p class="Pp">The declared variable is not introduced (is not visible) until
    after the current statement. Thus,</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    my $x = $x;
</pre>
<p class="Pp">can be used to initialize a new <span class="Li">$x</span> with
    the value of the old <span class="Li">$x</span>, and the expression</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    my $x = 123 and $x == 123
</pre>
<p class="Pp">is false unless the old <span class="Li">$x</span> happened to
    have the value <span class="Li">123</span>.</p>
<p class="Pp">Lexical scopes of control structures are not bounded precisely by
    the braces that delimit their controlled blocks; control expressions are
    part of that scope, too. Thus in the loop</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    while (my $line = &lt;&gt;) {
        $line = lc $line;
    } continue {
        print $line;
    }
</pre>
<p class="Pp">the scope of <span class="Li">$line</span> extends from its
    declaration throughout the rest of the loop construct (including the
    <span class="Li">&quot;continue&quot;</span> clause), but not beyond it.
    Similarly, in the conditional</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    if ((my $answer = &lt;STDIN&gt;) =~ /^yes$/i) {
        user_agrees();
    } elsif ($answer =~ /^no$/i) {
        user_disagrees();
    } else {
        chomp $answer;
        die &quot;'$answer' is neither 'yes' nor 'no'&quot;;
    }
</pre>
<p class="Pp">the scope of <span class="Li">$answer</span> extends from its
    declaration through the rest of that conditional, including any
    <span class="Li">&quot;elsif&quot;</span> and
    <span class="Li">&quot;else&quot;</span> clauses, but not beyond it. See
    &quot;Simple Statements&quot; in perlsyn for information on the scope of
    variables in statements with modifiers.</p>
<p class="Pp">The <span class="Li">&quot;foreach&quot;</span> loop defaults to
    scoping its index variable dynamically in the manner of
    <span class="Li">&quot;local&quot;</span>. However, if the index variable is
    prefixed with the keyword <span class="Li">&quot;my&quot;</span>, or if
    there is already a lexical by that name in scope, then a new lexical is
    created instead. Thus in the loop</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    for my $i (1, 2, 3) {
        some_function();
    }
</pre>
<p class="Pp">the scope of <span class="Li">$i</span> extends to the end of the
    loop, but not beyond it, rendering the value of <span class="Li">$i</span>
    inaccessible within <span class="Li">&quot;some_function()&quot;</span>.</p>
<p class="Pp">Some users may wish to encourage the use of lexically scoped
    variables. As an aid to catching implicit uses to package variables, which
    are always global, if you say</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    use strict 'vars';
</pre>
<p class="Pp">then any variable mentioned from there to the end of the enclosing
    block must either refer to a lexical variable, be predeclared via
    <span class="Li">&quot;our&quot;</span> or <span class="Li">&quot;use
    vars&quot;</span>, or else must be fully qualified with the package name. A
    compilation error results otherwise. An inner block may countermand this
    with <span class="Li">&quot;no strict 'vars'&quot;</span>.</p>
<p class="Pp">A <span class="Li">&quot;my&quot;</span> has both a compile-time
    and a run-time effect. At compile time, the compiler takes notice of it. The
    principal usefulness of this is to quiet <span class="Li">&quot;use strict
    'vars'&quot;</span>, but it is also essential for generation of closures as
    detailed in perlref. Actual initialization is delayed until run time,
    though, so it gets executed at the appropriate time, such as each time
    through a loop, for example.</p>
<p class="Pp">Variables declared with <span class="Li">&quot;my&quot;</span> are
    not part of any package and are therefore never fully qualified with the
    package name. In particular, you're not allowed to try to make a package
    variable (or other global) lexical:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    my $pack::var;      # ERROR!  Illegal syntax
</pre>
<p class="Pp">In fact, a dynamic variable (also known as package or global
    variables) are still accessible using the fully qualified
    <span class="Li">&quot;::&quot;</span> notation even while a lexical of the
    same name is also visible:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    package main;
    local $x = 10;
    my    $x = 20;
    print &quot;$x and $::x\n&quot;;
</pre>
<p class="Pp">That will print out <span class="Li">20</span> and
    <span class="Li">10</span>.</p>
<p class="Pp">You may declare <span class="Li">&quot;my&quot;</span> variables
    at the outermost scope of a file to hide any such identifiers from the world
    outside that file. This is similar in spirit to C's static variables when
    they are used at the file level. To do this with a subroutine requires the
    use of a closure (an anonymous function that accesses enclosing lexicals).
    If you want to create a private subroutine that cannot be called from
    outside that block, it can declare a lexical variable containing an
    anonymous sub reference:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    my $secret_version = '1.001-beta';
    my $secret_sub = sub { print $secret_version };
    &amp;$secret_sub();
</pre>
<p class="Pp">As long as the reference is never returned by any function within
    the module, no outside module can see the subroutine, because its name is
    not in any package's symbol table. Remember that it's not <i>REALLY</i>
    called <span class="Li">$some_pack::secret_version</span> or anything; it's
    just <span class="Li">$secret_version</span>, unqualified and
  unqualifiable.</p>
<p class="Pp">This does not work with object methods, however; all object
    methods have to be in the symbol table of some package to be found. See
    &quot;Function Templates&quot; in perlref for something of a work-around to
    this.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Persistent_Private_Variables"><a class="permalink" href="#Persistent_Private_Variables">Persistent
  Private Variables</a></h2>
There are two ways to build persistent private variables in Perl 5.10. First,
  you can simply use the <span class="Li">&quot;state&quot;</span> feature. Or,
  you can use closures, if you want to stay compatible with releases older than
  5.10.
<p class="Pp"><i>Persistent variables via </i><i>state()</i><i></i></p>
<p class="Pp">Beginning with Perl 5.10.0, you can declare variables with the
    <span class="Li">&quot;state&quot;</span> keyword in place of
    <span class="Li">&quot;my&quot;</span>. For that to work, though, you must
    have enabled that feature beforehand, either by using the
    <span class="Li">&quot;feature&quot;</span> pragma, or by using
    <span class="Li">&quot;-E&quot;</span> on one-liners (see feature).
    Beginning with Perl 5.16, the
    <span class="Li">&quot;CORE::state&quot;</span> form does not require the
    <span class="Li">&quot;feature&quot;</span> pragma.</p>
<p class="Pp">The <span class="Li">&quot;state&quot;</span> keyword creates a
    lexical variable (following the same scoping rules as
    <span class="Li">&quot;my&quot;</span>) that persists from one subroutine
    call to the next. If a state variable resides inside an anonymous
    subroutine, then each copy of the subroutine has its own copy of the state
    variable. However, the value of the state variable will still persist
    between calls to the same copy of the anonymous subroutine. (Don't forget
    that <span class="Li">&quot;sub { ... }&quot;</span> creates a new
    subroutine each time it is executed.)</p>
<p class="Pp">For example, the following code maintains a private counter,
    incremented each time the <i>gimme_another()</i> function is called:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    use feature 'state';
    sub gimme_another { state $x; return ++$x }
</pre>
<p class="Pp">And this example uses anonymous subroutines to create separate
    counters:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    use feature 'state';
    sub create_counter {
        return sub { state $x; return ++$x }
    }
</pre>
<p class="Pp">Also, since <span class="Li">$x</span> is lexical, it can't be
    reached or modified by any Perl code outside.</p>
<p class="Pp">When combined with variable declaration, simple scalar assignment
    to <span class="Li">&quot;state&quot;</span> variables (as in
    <span class="Li">&quot;state $x = 42&quot;</span>) is executed only the
    first time. When such statements are evaluated subsequent times, the
    assignment is ignored. The behavior of this sort of assignment to non-scalar
    variables is undefined.</p>
<p class="Pp"><i>Persistent variables with closures</i></p>
<p class="Pp">Just because a lexical variable is lexically (also called
    statically) scoped to its enclosing block,
    <span class="Li">&quot;eval&quot;</span>, or
    <span class="Li">&quot;do&quot;</span> FILE, this doesn't mean that within a
    function it works like a C static. It normally works more like a C auto, but
    with implicit garbage collection.</p>
<p class="Pp">Unlike local variables in C or C++, Perl's lexical variables don't
    necessarily get recycled just because their scope has exited. If something
    more permanent is still aware of the lexical, it will stick around. So long
    as something else references a lexical, that lexical won't be freed--which
    is as it should be. You wouldn't want memory being free until you were done
    using it, or kept around once you were done. Automatic garbage collection
    takes care of this for you.</p>
<p class="Pp">This means that you can pass back or save away references to
    lexical variables, whereas to return a pointer to a C auto is a grave error.
    It also gives us a way to simulate C's function statics. Here's a mechanism
    for giving a function private variables with both lexical scoping and a
    static lifetime. If you do want to create something like C's static
    variables, just enclose the whole function in an extra block, and put the
    static variable outside the function but in the block.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    {
        my $secret_val = 0;
        sub gimme_another {
            return ++$secret_val;
        }
    }
    # $secret_val now becomes unreachable by the outside
    # world, but retains its value between calls to gimme_another
</pre>
<p class="Pp">If this function is being sourced in from a separate file via
    <span class="Li">&quot;require&quot;</span> or
    <span class="Li">&quot;use&quot;</span>, then this is probably just fine. If
    it's all in the main program, you'll need to arrange for the
    <span class="Li">&quot;my&quot;</span> to be executed early, either by
    putting the whole block above your main program, or more likely, placing
    merely a <span class="Li">&quot;BEGIN&quot;</span> code block around it to
    make sure it gets executed before your program starts to run:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    BEGIN {
        my $secret_val = 0;
        sub gimme_another {
            return ++$secret_val;
        }
    }
</pre>
<p class="Pp">See &quot;BEGIN, UNITCHECK, CHECK, INIT and END&quot; in perlmod
    about the special triggered code blocks,
    <span class="Li">&quot;BEGIN&quot;</span>,
    <span class="Li">&quot;UNITCHECK&quot;</span>,
    <span class="Li">&quot;CHECK&quot;</span>,
    <span class="Li">&quot;INIT&quot;</span> and
    <span class="Li">&quot;END&quot;</span>.</p>
<p class="Pp">If declared at the outermost scope (the file scope), then lexicals
    work somewhat like C's file statics. They are available to all functions in
    that same file declared below them, but are inaccessible from outside that
    file. This strategy is sometimes used in modules to create private variables
    that the whole module can see.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Temporary_Values_via__fIlocal()_fP"><a class="permalink" href="#Temporary_Values_via__fIlocal()_fP">Temporary
  Values via <i>local()</i></a></h2>
<b>WARNING</b>: In general, you should be using
  <span class="Li">&quot;my&quot;</span> instead of
  <span class="Li">&quot;local&quot;</span>, because it's faster and safer.
  Exceptions to this include the global punctuation variables, global
  filehandles and formats, and direct manipulation of the Perl symbol table
  itself. <span class="Li">&quot;local&quot;</span> is mostly used when the
  current value of a variable must be visible to called subroutines.
<p class="Pp">Synopsis:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    # localization of values

    local $foo;                 # make $foo dynamically local
    local (@wid, %get);         # make list of variables local
    local $foo = &quot;flurp&quot;;       # make $foo dynamic, and init it
    local @oof = @bar;          # make @oof dynamic, and init it

    local $hash{key} = &quot;val&quot;;   # sets a local value for this hash entry
    delete local $hash{key};    # delete this entry for the current block
    local ($cond ? $v1 : $v2);  # several types of lvalues support
                                # localization

    # localization of symbols

    local *FH;                  # localize $FH, @FH, %FH, &amp;FH  ...
    local *merlyn = *randal;    # now $merlyn is really $randal, plus
                                #     @merlyn is really @randal, etc
    local *merlyn = 'randal';   # SAME THING: promote 'randal' to *randal
    local *merlyn = \$randal;   # just alias $merlyn, not @merlyn etc
</pre>
<p class="Pp">A <span class="Li">&quot;local&quot;</span> modifies its listed
    variables to be &quot;local&quot; to the enclosing block,
    <span class="Li">&quot;eval&quot;</span>, or <span class="Li">&quot;do
    FILE&quot;</span>--and to <i>any subroutine</i> <i>called from within that
    block</i>. A <span class="Li">&quot;local&quot;</span> just gives temporary
    values to global (meaning package) variables. It does <i>not</i> create a
    local variable. This is known as dynamic scoping. Lexical scoping is done
    with <span class="Li">&quot;my&quot;</span>, which works more like C's auto
    declarations.</p>
<p class="Pp">Some types of lvalues can be localized as well: hash and array
    elements and slices, conditionals (provided that their result is always
    localizable), and symbolic references. As for simple variables, this creates
    new, dynamically scoped values.</p>
<p class="Pp">If more than one variable or expression is given to
    <span class="Li">&quot;local&quot;</span>, they must be placed in
    parentheses. This operator works by saving the current values of those
    variables in its argument list on a hidden stack and restoring them upon
    exiting the block, subroutine, or eval. This means that called subroutines
    can also reference the local variable, but not the global one. The argument
    list may be assigned to if desired, which allows you to initialize your
    local variables. (If no initializer is given for a particular variable, it
    is created with an undefined value.)</p>
<p class="Pp">Because <span class="Li">&quot;local&quot;</span> is a run-time
    operator, it gets executed each time through a loop. Consequently, it's more
    efficient to localize your variables outside the loop.</p>
<p class="Pp"><i>Grammatical note on </i><i>local()</i><i></i></p>
<p class="Pp">A <span class="Li">&quot;local&quot;</span> is simply a modifier
    on an lvalue expression. When you assign to a
    <span class="Li">&quot;local&quot;</span>ized variable, the
    <span class="Li">&quot;local&quot;</span> doesn't change whether its list is
    viewed as a scalar or an array. So</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    local($foo) = &lt;STDIN&gt;;
    local @FOO = &lt;STDIN&gt;;
</pre>
<p class="Pp">both supply a list context to the right-hand side, while</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    local $foo = &lt;STDIN&gt;;
</pre>
<p class="Pp">supplies a scalar context.</p>
<p class="Pp"><i>Localization of special variables</i></p>
<p class="Pp">If you localize a special variable, you'll be giving a new value
    to it, but its magic won't go away. That means that all side-effects related
    to this magic still work with the localized value.</p>
<p class="Pp">This feature allows code like this to work :</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    # Read the whole contents of FILE in $slurp
    { local $/ = undef; $slurp = &lt;FILE&gt;; }
</pre>
<p class="Pp">Note, however, that this restricts localization of some values ;
    for example, the following statement dies, as of perl 5.10.0, with an error
    <i>Modification of a read-only value attempted</i>, because the
    <span class="Li">$1</span> variable is magical and read-only :</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    local $1 = 2;
</pre>
<p class="Pp">One exception is the default scalar variable: starting with perl
    5.14 <span class="Li">&quot;local($_)&quot;</span> will always strip all
    magic from <span class="Li">$_</span>, to make it possible to safely reuse
    <span class="Li">$_</span> in a subroutine.</p>
<p class="Pp"><b>WARNING</b>: Localization of tied arrays and hashes does not
    currently work as described. This will be fixed in a future release of Perl;
    in the meantime, avoid code that relies on any particular behaviour of
    localising tied arrays or hashes (localising individual elements is still
    okay). See &quot;Localising Tied Arrays and Hashes Is Broken&quot; in
    perl58delta for more details.</p>
<p class="Pp"><i>Localization of globs</i></p>
<p class="Pp">The construct</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    local *name;
</pre>
<p class="Pp">creates a whole new symbol table entry for the glob
    <span class="Li">&quot;name&quot;</span> in the current package. That means
    that all variables in its glob slot ($name, <span class="Li">@name</span>,
    <span class="Li">%name</span>, &amp;name, and the
    <span class="Li">&quot;name&quot;</span> filehandle) are dynamically
  reset.</p>
<p class="Pp">This implies, among other things, that any magic eventually
    carried by those variables is locally lost. In other words, saying
    <span class="Li">&quot;local */&quot;</span> will not have any effect on the
    internal value of the input record separator.</p>
<p class="Pp"><i>Localization of elements of composite types</i></p>
<p class="Pp">It's also worth taking a moment to explain what happens when you
    <span class="Li">&quot;local&quot;</span>ize a member of a composite type
    (i.e. an array or hash element). In this case, the element is
    <span class="Li">&quot;local&quot;</span>ized <i>by name</i>. This means
    that when the scope of the <span class="Li">&quot;local()&quot;</span> ends,
    the saved value will be restored to the hash element whose key was named in
    the <span class="Li">&quot;local()&quot;</span>, or the array element whose
    index was named in the <span class="Li">&quot;local()&quot;</span>. If that
    element was deleted while the <span class="Li">&quot;local()&quot;</span>
    was in effect (e.g. by a <span class="Li">&quot;delete()&quot;</span> from a
    hash or a <span class="Li">&quot;shift()&quot;</span> of an array), it will
    spring back into existence, possibly extending an array and filling in the
    skipped elements with <span class="Li">&quot;undef&quot;</span>. For
    instance, if you say</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    %hash = ( 'This' =&gt; 'is', 'a' =&gt; 'test' );
    @ary  = ( 0..5 );
    {
         local($ary[5]) = 6;
         local($hash{'a'}) = 'drill';
         while (my $e = pop(@ary)) {
             print &quot;$e . . .\n&quot;;
             last unless $e &gt; 3;
         }
         if (@ary) {
             $hash{'only a'} = 'test';
             delete $hash{'a'};
         }
    }
    print join(' ', map { &quot;$_ $hash{$_}&quot; } sort keys %hash),&quot;.\n&quot;;
    print &quot;The array has &quot;,scalar(@ary),&quot; elements: &quot;,
          join(', ', map { defined $_ ? $_ : 'undef' } @ary),&quot;\n&quot;;
</pre>
<p class="Pp">Perl will print</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    6 . . .
    4 . . .
    3 . . .
    This is a test only a test.
    The array has 6 elements: 0, 1, 2, undef, undef, 5
</pre>
<p class="Pp">The behavior of <i>local()</i> on non-existent members of
    composite types is subject to change in future.</p>
<p class="Pp"><i>Localized deletion of elements of composite types</i></p>
<p class="Pp">You can use the <span class="Li">&quot;delete local
    $array[$idx]&quot;</span> and <span class="Li">&quot;delete local
    $hash{key}&quot;</span> constructs to delete a composite type entry for the
    current block and restore it when it ends. They return the array/hash value
    before the localization, which means that they are respectively equivalent
    to</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    do {
        my $val = $array[$idx];
        local  $array[$idx];
        delete $array[$idx];
        $val
    }
</pre>
<p class="Pp">and</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    do {
        my $val = $hash{key};
        local  $hash{key};
        delete $hash{key};
        $val
    }
</pre>
<p class="Pp">except that for those the
    <span class="Li">&quot;local&quot;</span> is scoped to the
    <span class="Li">&quot;do&quot;</span> block. Slices are also accepted.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    my %hash = (
     a =&gt; [ 7, 8, 9 ],
     b =&gt; 1,
    )

    {
     my $a = delete local $hash{a};
     # $a is [ 7, 8, 9 ]
     # %hash is (b =&gt; 1)

     {
      my @nums = delete local @$a[0, 2]
      # @nums is (7, 9)
      # $a is [ undef, 8 ]

      $a[0] = 999; # will be erased when the scope ends
     }
     # $a is back to [ 7, 8, 9 ]

    }
    # %hash is back to its original state
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Lvalue_subroutines"><a class="permalink" href="#Lvalue_subroutines">Lvalue
  subroutines</a></h2>
<b>WARNING</b>: Lvalue subroutines are still experimental and the implementation
  may change in future versions of Perl.
<p class="Pp">It is possible to return a modifiable value from a subroutine. To
    do this, you have to declare the subroutine to return an lvalue.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    my $val;
    sub canmod : lvalue {
        $val;  # or:  return $val;
    }
    sub nomod {
        $val;
    }

    canmod() = 5;   # assigns to $val
    nomod()  = 5;   # ERROR
</pre>
<p class="Pp">The scalar/list context for the subroutine and for the right-hand
    side of assignment is determined as if the subroutine call is replaced by a
    scalar. For example, consider:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    data(2,3) = get_data(3,4);
</pre>
<p class="Pp">Both subroutines here are called in a scalar context, while
  in:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    (data(2,3)) = get_data(3,4);
</pre>
<p class="Pp">and in:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    (data(2),data(3)) = get_data(3,4);
</pre>
<p class="Pp">all the subroutines are called in a list context.</p>
<dl class="Bl-tag">
  <dt>Lvalue subroutines are EXPERIMENTAL</dt>
  <dd>They appear to be convenient, but there is at least one reason to be
      circumspect.
    <p class="Pp">They violate encapsulation. A normal mutator can check the
        supplied argument before setting the attribute it is protecting, an
        lvalue subroutine never gets that chance. Consider;</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    my $some_array_ref = [];    # protected by mutators ??

    sub set_arr {               # normal mutator
        my $val = shift;
        die(&quot;expected array, you supplied &quot;, ref $val)
           unless ref $val eq 'ARRAY';
        $some_array_ref = $val;
    }
    sub set_arr_lv : lvalue {   # lvalue mutator
        $some_array_ref;
    }

    # set_arr_lv cannot stop this !
    set_arr_lv() = { a =&gt; 1 };
    </pre>
  </dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Lexical_Subroutines"><a class="permalink" href="#Lexical_Subroutines">Lexical
  Subroutines</a></h2>
<b>WARNING</b>: Lexical subroutines are still experimental. The feature may be
  modified or removed in future versions of Perl.
<p class="Pp">Lexical subroutines are only available under the
    <span class="Li">&quot;use feature</span>
    <span class="Li">'lexical_subs'&quot;</span> pragma, which produces a
    warning unless the &quot;experimental::lexical_subs&quot; warnings category
    is disabled.</p>
<p class="Pp">Beginning with Perl 5.18, you can declare a private subroutine
    with <span class="Li">&quot;my&quot;</span> or
    <span class="Li">&quot;state&quot;</span>. As with state variables, the
    <span class="Li">&quot;state&quot;</span> keyword is only available under
    <span class="Li">&quot;use feature 'state'&quot;</span> or
    <span class="Li">&quot;use 5.010&quot;</span> or higher.</p>
<p class="Pp">These subroutines are only visible within the block in which they
    are declared, and only after that declaration:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    no warnings &quot;experimental::lexical_subs&quot;;
    use feature 'lexical_subs';

    foo();              # calls the package/global subroutine
    state sub foo {
        foo();          # also calls the package subroutine
    }
    foo();              # calls &quot;state&quot; sub
    my $ref = \&amp;foo;    # take a reference to &quot;state&quot; sub

    my sub bar { ... }
    bar();              # calls &quot;my&quot; sub
</pre>
<p class="Pp">To use a lexical subroutine from inside the subroutine itself, you
    must predeclare it. The <span class="Li">&quot;sub foo {...}&quot;</span>
    subroutine definition syntax respects any previous <span class="Li">&quot;my
    sub;&quot;</span> or <span class="Li">&quot;state sub;&quot;</span>
    declaration.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    my sub baz;         # predeclaration
    sub baz {           # define the &quot;my&quot; sub
        baz();          # recursive call
    }
</pre>
<p class="Pp"><i></i><i>&quot;state sub&quot;</i><i> vs </i><i>&quot;my
    sub&quot;</i><i></i></p>
<p class="Pp">What is the difference between &quot;state&quot; subs and
    &quot;my&quot; subs? Each time that execution enters a block when
    &quot;my&quot; subs are declared, a new copy of each sub is created.
    &quot;State&quot; subroutines persist from one execution of the containing
    block to the next.</p>
<p class="Pp">So, in general, &quot;state&quot; subroutines are faster. But
    &quot;my&quot; subs are necessary if you want to create closures:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    no warnings &quot;experimental::lexical_subs&quot;;
    use feature 'lexical_subs';

    sub whatever {
        my $x = shift;
        my sub inner {
            ... do something with $x ...
        }
        inner();
    }
</pre>
<p class="Pp">In this example, a new <span class="Li">$x</span> is created when
    <span class="Li">&quot;whatever&quot;</span> is called, and also a new
    <span class="Li">&quot;inner&quot;</span>, which can see the new
    <span class="Li">$x</span>. A &quot;state&quot; sub will only see the
    <span class="Li">$x</span> from the first call to
    <span class="Li">&quot;whatever&quot;</span>.</p>
<p class="Pp"><i></i><i>&quot;our&quot;</i><i> subroutines</i></p>
<p class="Pp">Like <span class="Li">&quot;our $variable&quot;</span>,
    <span class="Li">&quot;our sub&quot;</span> creates a lexical alias to the
    package subroutine of the same name.</p>
<p class="Pp">The two main uses for this are to switch back to using the package
    sub inside an inner scope:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    no warnings &quot;experimental::lexical_subs&quot;;
    use feature 'lexical_subs';

    sub foo { ... }

    sub bar {
        my sub foo { ... }
        {
            # need to use the outer foo here
            our sub foo;
            foo();
        }
    }
</pre>
<p class="Pp">and to make a subroutine visible to other packages in the same
    scope:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    package MySneakyModule;

    no warnings &quot;experimental::lexical_subs&quot;;
    use feature 'lexical_subs';

    our sub do_something { ... }

    sub do_something_with_caller {
        package DB;
        () = caller 1;          # sets @DB::args
        do_something(@args);    # uses MySneakyModule::do_something
    }
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Passing_Symbol_Table_Entries_(typeglobs)"><a class="permalink" href="#Passing_Symbol_Table_Entries_(typeglobs)">Passing
  Symbol Table Entries (typeglobs)</a></h2>
<b>WARNING</b>: The mechanism described in this section was originally the only
  way to simulate pass-by-reference in older versions of Perl. While it still
  works fine in modern versions, the new reference mechanism is generally easier
  to work with. See below.
<p class="Pp">Sometimes you don't want to pass the value of an array to a
    subroutine but rather the name of it, so that the subroutine can modify the
    global copy of it rather than working with a local copy. In perl you can
    refer to all objects of a particular name by prefixing the name with a star:
    <span class="Li">*foo</span>. This is often known as a &quot;typeglob&quot;,
    because the star on the front can be thought of as a wildcard match for all
    the funny prefix characters on variables and subroutines and such.</p>
<p class="Pp">When evaluated, the typeglob produces a scalar value that
    represents all the objects of that name, including any filehandle, format,
    or subroutine. When assigned to, it causes the name mentioned to refer to
    whatever <span class="Li">&quot;*&quot;</span> value was assigned to it.
    Example:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    sub doubleary {
        local(*someary) = @_;
        foreach $elem (@someary) {
            $elem *= 2;
        }
    }
    doubleary(*foo);
    doubleary(*bar);
</pre>
<p class="Pp">Scalars are already passed by reference, so you can modify scalar
    arguments without using this mechanism by referring explicitly to
    <span class="Li">$_[0]</span> etc. You can modify all the elements of an
    array by passing all the elements as scalars, but you have to use the
    <span class="Li">&quot;*&quot;</span> mechanism (or the equivalent reference
    mechanism) to <span class="Li">&quot;push&quot;</span>,
    <span class="Li">&quot;pop&quot;</span>, or change the size of an array. It
    will certainly be faster to pass the typeglob (or reference).</p>
<p class="Pp">Even if you don't want to modify an array, this mechanism is
    useful for passing multiple arrays in a single LIST, because normally the
    LIST mechanism will merge all the array values so that you can't extract out
    the individual arrays. For more on typeglobs, see &quot;Typeglobs and
    Filehandles&quot; in perldata.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="When_to_Still_Use__fIlocal()_fP"><a class="permalink" href="#When_to_Still_Use__fIlocal()_fP">When
  to Still Use <i>local()</i></a></h2>
Despite the existence of <span class="Li">&quot;my&quot;</span>, there are still
  three places where the <span class="Li">&quot;local&quot;</span> operator
  still shines. In fact, in these three places, you <i>must</i> use
  <span class="Li">&quot;local&quot;</span> instead of
  <span class="Li">&quot;my&quot;</span>.
<dl class="Bl-tag">
  <dt>1.</dt>
  <dd>You need to give a global variable a temporary value, especially
      <span class="Li">$_</span>.
    <p class="Pp">The global variables, like <span class="Li">@ARGV</span> or
        the punctuation variables, must be
        <span class="Li">&quot;local&quot;</span>ized with
        <span class="Li">&quot;local()&quot;</span>. This block reads in
        <i>/etc/motd</i>, and splits it up into chunks separated by lines of
        equal signs, which are placed in <span class="Li">@Fields</span>.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    {
        local @ARGV = (&quot;/etc/motd&quot;);
        local $/ = undef;
        local $_ = &lt;&gt;;  
        @Fields = split /^\s*=+\s*$/;
    }
    </pre>
    <p class="Pp">It particular, it's important to
        <span class="Li">&quot;local&quot;</span>ize <span class="Li">$_</span>
        in any routine that assigns to it. Look out for implicit assignments in
        <span class="Li">&quot;while&quot;</span> conditionals.</p>
  </dd>
  <dt>2.</dt>
  <dd>You need to create a local file or directory handle or a local function.
    <p class="Pp">A function that needs a filehandle of its own must use
        <span class="Li">&quot;local()&quot;</span> on a complete typeglob. This
        can be used to create new symbol table entries:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    sub ioqueue {
        local  (*READER, *WRITER);    # not my!
        pipe    (READER,  WRITER)     or die &quot;pipe: $!&quot;;
        return (*READER, *WRITER);
    }
    ($head, $tail) = ioqueue();
    </pre>
    <p class="Pp">See the Symbol module for a way to create anonymous symbol
        table entries.</p>
    <p class="Pp">Because assignment of a reference to a typeglob creates an
        alias, this can be used to create what is effectively a local function,
        or at least, a local alias.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    {
        local *grow = \&amp;shrink; # only until this block exits
        grow();                 # really calls shrink()
        move();                 # if move() grow()s, it shrink()s too
    }
    grow();                     # get the real grow() again
    </pre>
    <p class="Pp">See &quot;Function Templates&quot; in perlref for more about
        manipulating functions by name in this way.</p>
  </dd>
  <dt>3.</dt>
  <dd>You want to temporarily change just one element of an array or hash.
    <p class="Pp">You can <span class="Li">&quot;local&quot;</span>ize just one
        element of an aggregate. Usually this is done on dynamics:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    {
        local $SIG{INT} = 'IGNORE';
        funct();                            # uninterruptible
    } 
    # interruptibility automatically restored here
    </pre>
    <p class="Pp">But it also works on lexically declared aggregates.</p>
  </dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Pass_by_Reference"><a class="permalink" href="#Pass_by_Reference">Pass
  by Reference</a></h2>
If you want to pass more than one array or hash into a function--or return them
  from it--and have them maintain their integrity, then you're going to have to
  use an explicit pass-by-reference. Before you do that, you need to understand
  references as detailed in perlref. This section may not make much sense to you
  otherwise.
<p class="Pp">Here are a few simple examples. First, let's pass in several
    arrays to a function and have it <span class="Li">&quot;pop&quot;</span> all
    of then, returning a new list of all their former last elements:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    @tailings = popmany ( \@a, \@b, \@c, \@d );

    sub popmany {
        my $aref;
        my @retlist = ();
        foreach $aref ( @_ ) {
            push @retlist, pop @$aref;
        }
        return @retlist;
    }
</pre>
<p class="Pp">Here's how you might write a function that returns a list of keys
    occurring in all the hashes passed to it:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    @common = inter( \%foo, \%bar, \%joe );
    sub inter {
        my ($k, $href, %seen); # locals
        foreach $href (@_) {
            while ( $k = each %$href ) {
                $seen{$k}++;
            }
        }
        return grep { $seen{$_} == @_ } keys %seen;
    }
</pre>
<p class="Pp">So far, we're using just the normal list return mechanism. What
    happens if you want to pass or return a hash? Well, if you're using only one
    of them, or you don't mind them concatenating, then the normal calling
    convention is ok, although a little expensive.</p>
<p class="Pp">Where people get into trouble is here:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    (@a, @b) = func(@c, @d);
or
    (%a, %b) = func(%c, %d);
</pre>
<p class="Pp">That syntax simply won't work. It sets just
    <span class="Li">@a</span> or <span class="Li">%a</span> and clears the
    <span class="Li">@b</span> or <span class="Li">%b</span>. Plus the function
    didn't get passed into two separate arrays or hashes: it got one long list
    in <span class="Li">@_</span>, as always.</p>
<p class="Pp">If you can arrange for everyone to deal with this through
    references, it's cleaner code, although not so nice to look at. Here's a
    function that takes two array references as arguments, returning the two
    array elements in order of how many elements they have in them:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    ($aref, $bref) = func(\@c, \@d);
    print &quot;@$aref has more than @$bref\n&quot;;
    sub func {
        my ($cref, $dref) = @_;
        if (@$cref &gt; @$dref) {
            return ($cref, $dref);
        } else {
            return ($dref, $cref);
        }
    }
</pre>
<p class="Pp">It turns out that you can actually do this also:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    (*a, *b) = func(\@c, \@d);
    print &quot;@a has more than @b\n&quot;;
    sub func {
        local (*c, *d) = @_;
        if (@c &gt; @d) {
            return (\@c, \@d);
        } else {
            return (\@d, \@c);
        }
    }
</pre>
<p class="Pp">Here we're using the typeglobs to do symbol table aliasing. It's a
    tad subtle, though, and also won't work if you're using
    <span class="Li">&quot;my&quot;</span> variables, because only globals (even
    in disguise as <span class="Li">&quot;local&quot;</span>s) are in the symbol
    table.</p>
<p class="Pp">If you're passing around filehandles, you could usually just use
    the bare typeglob, like <span class="Li">*STDOUT</span>, but typeglobs
    references work, too. For example:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    splutter(\*STDOUT);
    sub splutter {
        my $fh = shift;
        print $fh &quot;her um well a hmmm\n&quot;;
    }

    $rec = get_rec(\*STDIN);
    sub get_rec {
        my $fh = shift;
        return scalar &lt;$fh&gt;;
    }
</pre>
<p class="Pp">If you're planning on generating new filehandles, you could do
    this. Notice to pass back just the bare *FH, not its reference.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    sub openit {
        my $path = shift;
        local *FH;
        return open (FH, $path) ? *FH : undef;
    }
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Prototypes"><a class="permalink" href="#Prototypes">Prototypes</a></h2>
Perl supports a very limited kind of compile-time argument checking using
  function prototyping. If you declare
<p class="Pp"><span class="Li"></span></p>
<pre>
    sub mypush (+@)
</pre>
<p class="Pp">then <span class="Li">&quot;mypush()&quot;</span> takes arguments
    exactly like <span class="Li">&quot;push()&quot;</span> does. The function
    declaration must be visible at compile time. The prototype affects only
    interpretation of new-style calls to the function, where new-style is
    defined as not using the <span class="Li">&quot;&amp;&quot;</span>
    character. In other words, if you call it like a built-in function, then it
    behaves like a built-in function. If you call it like an old-fashioned
    subroutine, then it behaves like an old-fashioned subroutine. It naturally
    falls out from this rule that prototypes have no influence on subroutine
    references like <span class="Li">&quot;\&amp;foo&quot;</span> or on indirect
    subroutine calls like <span class="Li">&quot;&amp;{$subref}&quot;</span> or
    <span class="Li">&quot;$subref-&gt;()&quot;</span>.</p>
<p class="Pp">Method calls are not influenced by prototypes either, because the
    function to be called is indeterminate at compile time, since the exact code
    called depends on inheritance.</p>
<p class="Pp">Because the intent of this feature is primarily to let you define
    subroutines that work like built-in functions, here are prototypes for some
    other functions that parse almost exactly like the corresponding
  built-in.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    Declared as                 Called as

    sub mylink ($$)          mylink $old, $new
    sub myvec ($$$)          myvec $var, $offset, 1
    sub myindex ($$;$)       myindex &amp;getstring, &quot;substr&quot;
    sub mysyswrite ($$$;$)   mysyswrite $buf, 0, length($buf) - $off, $off
    sub myreverse (@)        myreverse $a, $b, $c
    sub myjoin ($@)          myjoin &quot;:&quot;, $a, $b, $c
    sub mypop (+)            mypop @array
    sub mysplice (+$$@)      mysplice @array, 0, 2, @pushme
    sub mykeys (+)           mykeys %{$hashref}
    sub myopen (*;$)         myopen HANDLE, $name
    sub mypipe (**)          mypipe READHANDLE, WRITEHANDLE
    sub mygrep (&amp;@)          mygrep { /foo/ } $a, $b, $c
    sub myrand (;$)          myrand 42
    sub mytime ()            mytime
</pre>
<p class="Pp">Any backslashed prototype character represents an actual argument
    that must start with that character (optionally preceded by
    <span class="Li">&quot;my&quot;</span>,
    <span class="Li">&quot;our&quot;</span> or
    <span class="Li">&quot;local&quot;</span>), with the exception of
    <span class="Li">&quot;$&quot;</span>, which will accept any scalar lvalue
    expression, such as <span class="Li">&quot;$foo = 7&quot;</span> or
    <span class="Li">&quot;my_function()-&gt;[0]&quot;</span>. The value passed
    as part of <span class="Li">@_</span> will be a reference to the actual
    argument given in the subroutine call, obtained by applying
    <span class="Li">&quot;\&quot;</span> to that argument.</p>
<p class="Pp">You can use the <span class="Li">&quot;\[]&quot;</span> backslash
    group notation to specify more than one allowed argument type. For
  example:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    sub myref (\[$@%&amp;*])
</pre>
<p class="Pp">will allow calling <i>myref()</i> as</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    myref $var
    myref @array
    myref %hash
    myref &amp;sub
    myref *glob
</pre>
<p class="Pp">and the first argument of <i>myref()</i> will be a reference to a
    scalar, an array, a hash, a code, or a glob.</p>
<p class="Pp">Unbackslashed prototype characters have special meanings. Any
    unbackslashed <span class="Li">&quot;@&quot;</span> or
    <span class="Li">&quot;%&quot;</span> eats all remaining arguments, and
    forces list context. An argument represented by
    <span class="Li">&quot;$&quot;</span> forces scalar context. An
    <span class="Li">&quot;&amp;&quot;</span> requires an anonymous subroutine,
    which, if passed as the first argument, does not require the
    <span class="Li">&quot;sub&quot;</span> keyword or a subsequent comma.</p>
<p class="Pp">A <span class="Li">&quot;*&quot;</span> allows the subroutine to
    accept a bareword, constant, scalar expression, typeglob, or a reference to
    a typeglob in that slot. The value will be available to the subroutine
    either as a simple scalar, or (in the latter two cases) as a reference to
    the typeglob. If you wish to always convert such arguments to a typeglob
    reference, use <i>Symbol::qualify_to_ref()</i> as follows:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    use Symbol 'qualify_to_ref';

    sub foo (*) {
        my $fh = qualify_to_ref(shift, caller);
        ...
    }
</pre>
<p class="Pp">The <span class="Li">&quot;+&quot;</span> prototype is a special
    alternative to <span class="Li">&quot;$&quot;</span> that will act like
    <span class="Li">&quot;\[@%]&quot;</span> when given a literal array or hash
    variable, but will otherwise force scalar context on the argument. This is
    useful for functions which should accept either a literal array or an array
    reference as the argument:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    sub mypush (+@) {
        my $aref = shift;
        die &quot;Not an array or arrayref&quot; unless ref $aref eq 'ARRAY';
        push @$aref, @_;
    }
</pre>
<p class="Pp">When using the <span class="Li">&quot;+&quot;</span> prototype,
    your function must check that the argument is of an acceptable type.</p>
<p class="Pp">A semicolon (<span class="Li">&quot;;&quot;</span>) separates
    mandatory arguments from optional arguments. It is redundant before
    <span class="Li">&quot;@&quot;</span> or
    <span class="Li">&quot;%&quot;</span>, which gobble up everything else.</p>
<p class="Pp">As the last character of a prototype, or just before a semicolon,
    a <span class="Li">&quot;@&quot;</span> or a
    <span class="Li">&quot;%&quot;</span>, you can use
    <span class="Li">&quot;_&quot;</span> in place of
    <span class="Li">&quot;$&quot;</span>: if this argument is not provided,
    <span class="Li">$_</span> will be used instead.</p>
<p class="Pp">Note how the last three examples in the table above are treated
    specially by the parser. <span class="Li">&quot;mygrep()&quot;</span> is
    parsed as a true list operator, <span class="Li">&quot;myrand()&quot;</span>
    is parsed as a true unary operator with unary precedence the same as
    <span class="Li">&quot;rand()&quot;</span>, and
    <span class="Li">&quot;mytime()&quot;</span> is truly without arguments,
    just like <span class="Li">&quot;time()&quot;</span>. That is, if you
  say</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    mytime +2;
</pre>
<p class="Pp">you'll get <span class="Li">&quot;mytime() + 2&quot;</span>, not
    <span class="Li">mytime(2)</span>, which is how it would be parsed without a
    prototype. If you want to force a unary function to have the same precedence
    as a list operator, add <span class="Li">&quot;;&quot;</span> to the end of
    the prototype:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    sub mygetprotobynumber($;);
    mygetprotobynumber $a &gt; $b; # parsed as mygetprotobynumber($a &gt; $b)
</pre>
<p class="Pp">The interesting thing about
    <span class="Li">&quot;&amp;&quot;</span> is that you can generate new
    syntax with it, provided it's in the initial position:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    sub try (&amp;@) {
        my($try,$catch) = @_;
        eval { &amp;$try };
        if ($@) {
            local $_ = $@;
            &amp;$catch;
        }
    }
    sub catch (&amp;) { $_[0] }

    try {
        die &quot;phooey&quot;;
    } catch {
        /phooey/ and print &quot;unphooey\n&quot;;
    };
</pre>
<p class="Pp">That prints <span class="Li">&quot;unphooey&quot;</span>. (Yes,
    there are still unresolved issues having to do with visibility of
    <span class="Li">@_</span>. I'm ignoring that question for the moment. (But
    note that if we make <span class="Li">@_</span> lexically scoped, those
    anonymous subroutines can act like closures... (Gee, is this sounding a
    little Lispish? (Never mind.))))</p>
<p class="Pp">And here's a reimplementation of the Perl
    <span class="Li">&quot;grep&quot;</span> operator:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    sub mygrep (&amp;@) {
        my $code = shift;
        my @result;
        foreach $_ (@_) {
            push(@result, $_) if &amp;$code;
        }
        @result;
    }
</pre>
<p class="Pp">Some folks would prefer full alphanumeric prototypes.
    Alphanumerics have been intentionally left out of prototypes for the express
    purpose of someday in the future adding named, formal parameters. The
    current mechanism's main goal is to let module writers provide better
    diagnostics for module users. Larry feels the notation quite understandable
    to Perl programmers, and that it will not intrude greatly upon the meat of
    the module, nor make it harder to read. The line noise is visually
    encapsulated into a small pill that's easy to swallow.</p>
<p class="Pp">If you try to use an alphanumeric sequence in a prototype you will
    generate an optional warning - &quot;Illegal character in
    prototype...&quot;. Unfortunately earlier versions of Perl allowed the
    prototype to be used as long as its prefix was a valid prototype. The
    warning may be upgraded to a fatal error in a future version of Perl once
    the majority of offending code is fixed.</p>
<p class="Pp">It's probably best to prototype new functions, not retrofit
    prototyping into older ones. That's because you must be especially careful
    about silent impositions of differing list versus scalar contexts. For
    example, if you decide that a function should take just one parameter, like
    this:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    sub func ($) {
        my $n = shift;
        print &quot;you gave me $n\n&quot;;
    }
</pre>
<p class="Pp">and someone has been calling it with an array or expression
    returning a list:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    func(@foo);
    func( split /:/ );
</pre>
<p class="Pp">Then you've just supplied an automatic
    <span class="Li">&quot;scalar&quot;</span> in front of their argument, which
    can be more than a bit surprising. The old <span class="Li">@foo</span>
    which used to hold one thing doesn't get passed in. Instead,
    <span class="Li">&quot;func()&quot;</span> now gets passed in a
    <span class="Li">1</span>; that is, the number of elements in
    <span class="Li">@foo</span>. And the
    <span class="Li">&quot;split&quot;</span> gets called in scalar context so
    it starts scribbling on your <span class="Li">@_</span> parameter list.
    Ouch!</p>
<p class="Pp">This is all very powerful, of course, and should be used only in
    moderation to make the world a better place.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Constant_Functions"><a class="permalink" href="#Constant_Functions">Constant
  Functions</a></h2>
Functions with a prototype of <span class="Li">&quot;()&quot;</span> are
  potential candidates for inlining. If the result after optimization and
  constant folding is either a constant or a lexically-scoped scalar which has
  no other references, then it will be used in place of function calls made
  without <span class="Li">&quot;&amp;&quot;</span>. Calls made using
  <span class="Li">&quot;&amp;&quot;</span> are never inlined. (See
  <i>constant.pm</i> for an easy way to declare most constants.)
<p class="Pp">The following functions would all be inlined:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    sub pi ()           { 3.14159 }             # Not exact, but close.
    sub PI ()           { 4 * atan2 1, 1 }      # As good as it gets,
                                                # and it's inlined, too!
    sub ST_DEV ()       { 0 }
    sub ST_INO ()       { 1 }

    sub FLAG_FOO ()     { 1 &lt;&lt; 8 }
    sub FLAG_BAR ()     { 1 &lt;&lt; 9 }
    sub FLAG_MASK ()    { FLAG_FOO | FLAG_BAR }

    sub OPT_BAZ ()      { not (0x1B58 &amp; FLAG_MASK) }

    sub N () { int(OPT_BAZ) / 3 }

    sub FOO_SET () { 1 if FLAG_MASK &amp; FLAG_FOO }
</pre>
<p class="Pp">Be aware that these will not be inlined; as they contain inner
    scopes, the constant folding doesn't reduce them to a single constant:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    sub foo_set () { if (FLAG_MASK &amp; FLAG_FOO) { 1 } }

    sub baz_val () {
        if (OPT_BAZ) {
            return 23;
        }
        else {
            return 42;
        }
    }
</pre>
<p class="Pp">If you redefine a subroutine that was eligible for inlining,
    you'll get a warning by default. (You can use this warning to tell whether
    or not a particular subroutine is considered constant.) The warning is
    considered severe enough not to be affected by the <b>-w</b> switch (or its
    absence) because previously compiled invocations of the function will still
    be using the old value of the function. If you need to be able to redefine
    the subroutine, you need to ensure that it isn't inlined, either by dropping
    the <span class="Li">&quot;()&quot;</span> prototype (which changes calling
    semantics, so beware) or by thwarting the inlining mechanism in some other
    way, such as</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    sub not_inlined () {
        23 if $];
    }
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Overriding_Built-in_Functions"><a class="permalink" href="#Overriding_Built-in_Functions">Overriding
  Built-in Functions</a></h2>
Many built-in functions may be overridden, though this should be tried only
  occasionally and for good reason. Typically this might be done by a package
  attempting to emulate missing built-in functionality on a non-Unix system.
<p class="Pp">Overriding may be done only by importing the name from a module at
    compile time--ordinary predeclaration isn't good enough. However, the
    <span class="Li">&quot;use subs&quot;</span> pragma lets you, in effect,
    predeclare subs via the import syntax, and these names may then override
    built-in ones:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    use subs 'chdir', 'chroot', 'chmod', 'chown';
    chdir $somewhere;
    sub chdir { ... }
</pre>
<p class="Pp">To unambiguously refer to the built-in form, precede the built-in
    name with the special package qualifier
    <span class="Li">&quot;CORE::&quot;</span>. For example, saying
    <span class="Li">&quot;CORE::open()&quot;</span> always refers to the
    built-in <span class="Li">&quot;open()&quot;</span>, even if the current
    package has imported some other subroutine called
    <span class="Li">&quot;&amp;open()&quot;</span> from elsewhere. Even though
    it looks like a regular function call, it isn't: the CORE:: prefix in that
    case is part of Perl's syntax, and works for any keyword, regardless of what
    is in the CORE package. Taking a reference to it, that is,
    <span class="Li">&quot;\&amp;CORE::open&quot;</span>, only works for some
    keywords. See CORE.</p>
<p class="Pp">Library modules should not in general export built-in names like
    <span class="Li">&quot;open&quot;</span> or
    <span class="Li">&quot;chdir&quot;</span> as part of their default
    <span class="Li">@EXPORT</span> list, because these may sneak into someone
    else's namespace and change the semantics unexpectedly. Instead, if the
    module adds that name to <span class="Li">@EXPORT_OK</span>, then it's
    possible for a user to import the name explicitly, but not implicitly. That
    is, they could say</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    use Module 'open';
</pre>
<p class="Pp">and it would import the <span class="Li">&quot;open&quot;</span>
    override. But if they said</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    use Module;
</pre>
<p class="Pp">they would get the default imports without overrides.</p>
<p class="Pp">The foregoing mechanism for overriding built-in is restricted,
    quite deliberately, to the package that requests the import. There is a
    second method that is sometimes applicable when you wish to override a
    built-in everywhere, without regard to namespace boundaries. This is
    achieved by importing a sub into the special namespace
    <span class="Li">&quot;CORE::GLOBAL::&quot;</span>. Here is an example that
    quite brazenly replaces the <span class="Li">&quot;glob&quot;</span>
    operator with something that understands regular expressions.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    package REGlob;
    require Exporter;
    @ISA = 'Exporter';
    @EXPORT_OK = 'glob';

    sub import {
        my $pkg = shift;
        return unless @_;
        my $sym = shift;
        my $where = ($sym =~ s/^GLOBAL_// ? 'CORE::GLOBAL' : caller(0));
        $pkg-&gt;export($where, $sym, @_);
    }

    sub glob {
        my $pat = shift;
        my @got;
        if (opendir my $d, '.') { 
            @got = grep /$pat/, readdir $d; 
            closedir $d;   
        }
        return @got;
    }
    1;
</pre>
<p class="Pp">And here's how it could be (ab)used:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    #use REGlob 'GLOBAL_glob';      # override glob() in ALL namespaces
    package Foo;
    use REGlob 'glob';              # override glob() in Foo:: only
    print for &lt;^[a-z_]+\.pm\$&gt;;     # show all pragmatic modules
</pre>
<p class="Pp">The initial comment shows a contrived, even dangerous example. By
    overriding <span class="Li">&quot;glob&quot;</span> globally, you would be
    forcing the new (and subversive) behavior for the
    <span class="Li">&quot;glob&quot;</span> operator for <i>every</i>
    namespace, without the complete cognizance or cooperation of the modules
    that own those namespaces. Naturally, this should be done with extreme
    caution--if it must be done at all.</p>
<p class="Pp">The <span class="Li">&quot;REGlob&quot;</span> example above does
    not implement all the support needed to cleanly override perl's
    <span class="Li">&quot;glob&quot;</span> operator. The built-in
    <span class="Li">&quot;glob&quot;</span> has different behaviors depending
    on whether it appears in a scalar or list context, but our
    <span class="Li">&quot;REGlob&quot;</span> doesn't. Indeed, many perl
    built-in have such context sensitive behaviors, and these must be adequately
    supported by a properly written override. For a fully functional example of
    overriding <span class="Li">&quot;glob&quot;</span>, study the
    implementation of <span class="Li">&quot;File::DosGlob&quot;</span> in the
    standard library.</p>
<p class="Pp">When you override a built-in, your replacement should be
    consistent (if possible) with the built-in native syntax. You can achieve
    this by using a suitable prototype. To get the prototype of an overridable
    built-in, use the <span class="Li">&quot;prototype&quot;</span> function
    with an argument of <span class="Li">&quot;CORE::builtin_name&quot;</span>
    (see &quot;prototype&quot; in perlfunc).</p>
<p class="Pp">Note however that some built-ins can't have their syntax expressed
    by a prototype (such as <span class="Li">&quot;system&quot;</span> or
    <span class="Li">&quot;chomp&quot;</span>). If you override them you won't
    be able to fully mimic their original syntax.</p>
<p class="Pp">The built-ins <span class="Li">&quot;do&quot;</span>,
    <span class="Li">&quot;require&quot;</span> and
    <span class="Li">&quot;glob&quot;</span> can also be overridden, but due to
    special magic, their original syntax is preserved, and you don't have to
    define a prototype for their replacements. (You can't override the
    <span class="Li">&quot;do BLOCK&quot;</span> syntax, though).</p>
<p class="Pp"><span class="Li">&quot;require&quot;</span> has special additional
    dark magic: if you invoke your <span class="Li">&quot;require&quot;</span>
    replacement as <span class="Li">&quot;require Foo::Bar&quot;</span>, it will
    actually receive the argument <span class="Li">&quot;Foo/Bar.pm&quot;</span>
    in <span class="Li">@_</span>. See &quot;require&quot; in perlfunc.</p>
<p class="Pp">And, as you'll have noticed from the previous example, if you
    override <span class="Li">&quot;glob&quot;</span>, the
    <span class="Li">&quot;&lt;*&gt;&quot;</span> glob operator is overridden as
    well.</p>
<p class="Pp">In a similar fashion, overriding the
    <span class="Li">&quot;readline&quot;</span> function also overrides the
    equivalent I/O operator
    <span class="Li">&quot;&lt;FILEHANDLE&gt;&quot;</span>. Also, overriding
    <span class="Li">&quot;readpipe&quot;</span> also overrides the operators
    <span class="Li">&quot;``&quot;</span> and
    <span class="Li">&quot;qx//&quot;</span>.</p>
<p class="Pp">Finally, some built-ins (e.g.
    <span class="Li">&quot;exists&quot;</span> or
    <span class="Li">&quot;grep&quot;</span>) can't be overridden.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Autoloading"><a class="permalink" href="#Autoloading">Autoloading</a></h2>
If you call a subroutine that is undefined, you would ordinarily get an
  immediate, fatal error complaining that the subroutine doesn't exist.
  (Likewise for subroutines being used as methods, when the method doesn't exist
  in any base class of the class's package.) However, if an
  <span class="Li">&quot;AUTOLOAD&quot;</span> subroutine is defined in the
  package or packages used to locate the original subroutine, then that
  <span class="Li">&quot;AUTOLOAD&quot;</span> subroutine is called with the
  arguments that would have been passed to the original subroutine. The fully
  qualified name of the original subroutine magically appears in the global
  <span class="Li">$AUTOLOAD</span> variable of the same package as the
  <span class="Li">&quot;AUTOLOAD&quot;</span> routine. The name is not passed
  as an ordinary argument because, er, well, just because, that's why. (As an
  exception, a method call to a nonexistent
  <span class="Li">&quot;import&quot;</span> or
  <span class="Li">&quot;unimport&quot;</span> method is just skipped instead.
  Also, if the AUTOLOAD subroutine is an XSUB, there are other ways to retrieve
  the subroutine name. See &quot;Autoloading with XSUBs&quot; in perlguts for
  details.)
<p class="Pp">Many <span class="Li">&quot;AUTOLOAD&quot;</span> routines load in
    a definition for the requested subroutine using <i>eval()</i>, then execute
    that subroutine using a special form of <i>goto()</i> that erases the stack
    frame of the <span class="Li">&quot;AUTOLOAD&quot;</span> routine without a
    trace. (See the source to the standard module documented in AutoLoader, for
    example.) But an <span class="Li">&quot;AUTOLOAD&quot;</span> routine can
    also just emulate the routine and never define it. For example, let's
    pretend that a function that wasn't defined should just invoke
    <span class="Li">&quot;system&quot;</span> with those arguments. All you'd
    do is:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    sub AUTOLOAD {
        my $program = $AUTOLOAD;
        $program =~ s/.*:://;
        system($program, @_);
    }
    date();
    who('am', 'i');
    ls('-l');
</pre>
<p class="Pp">In fact, if you predeclare functions you want to call that way,
    you don't even need parentheses:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    use subs qw(date who ls);
    date;
    who &quot;am&quot;, &quot;i&quot;;
    ls '-l';
</pre>
<p class="Pp">A more complete example of this is the Shell module on CPAN, which
    can treat undefined subroutine calls as calls to external programs.</p>
<p class="Pp">Mechanisms are available to help modules writers split their
    modules into autoloadable files. See the standard AutoLoader module
    described in AutoLoader and in AutoSplit, the standard SelfLoader modules in
    SelfLoader, and the document on adding C functions to Perl code in
  perlxs.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Subroutine_Attributes"><a class="permalink" href="#Subroutine_Attributes">Subroutine
  Attributes</a></h2>
A subroutine declaration or definition may have a list of attributes associated
  with it. If such an attribute list is present, it is broken up at space or
  colon boundaries and treated as though a <span class="Li">&quot;use
  attributes&quot;</span> had been seen. See attributes for details about what
  attributes are currently supported. Unlike the limitation with the obsolescent
  <span class="Li">&quot;use attrs&quot;</span>, the <span class="Li">&quot;sub
  : ATTRLIST&quot;</span> syntax works to associate the attributes with a
  pre-declaration, and not just with a subroutine definition.
<p class="Pp">The attributes must be valid as simple identifier names (without
    any punctuation other than the '_' character). They may have a parameter
    list appended, which is only checked for whether its parentheses ('(',')')
    nest properly.</p>
<p class="Pp">Examples of valid syntax (even though the attributes are
  unknown):</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    sub fnord (&amp;\%) : switch(10,foo(7,3))  :  expensive;
    sub plugh () : Ugly('\(&quot;) :Bad;
    sub xyzzy : _5x5 { ... }
</pre>
<p class="Pp">Examples of invalid syntax:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    sub fnord : switch(10,foo(); # ()-string not balanced
    sub snoid : Ugly('(');        # ()-string not balanced
    sub xyzzy : 5x5;              # &quot;5x5&quot; not a valid identifier
    sub plugh : Y2::north;        # &quot;Y2::north&quot; not a simple identifier
    sub snurt : foo + bar;        # &quot;+&quot; not a colon or space
</pre>
<p class="Pp">The attribute list is passed as a list of constant strings to the
    code which associates them with the subroutine. In particular, the second
    example of valid syntax above currently looks like this in terms of how it's
    parsed and invoked:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    use attributes __PACKAGE__, \&amp;plugh, q[Ugly('\(&quot;)], 'Bad';
</pre>
<p class="Pp">For further details on attribute lists and their manipulation, see
    attributes and Attribute::Handlers.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
See &quot;Function Templates&quot; in perlref for more about references and
  closures. See perlxs if you'd like to learn about calling C subroutines from
  Perl. See perlembed if you'd like to learn about calling Perl subroutines from
  C. See perlmod to learn about bundling up your functions in separate files.
  See perlmodlib to learn what library modules come standard on your system. See
  perlootut to learn how to make object method calls.
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2014-09-30</td>
    <td class="foot-os">perl v5.18.4</td>
  </tr>
</table>
</body>
</html>
