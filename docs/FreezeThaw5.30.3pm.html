<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    .Nd, .Bf, .Op { display: inline; }
    .Pa, .Ad { font-style: italic; }
    .Ms { font-weight: bold; }
    .Bl-diag > dt { font-weight: bold; }
    code.Nm, .Fl, .Cm, .Ic, code.In, .Fd, .Fn, .Cd { font-weight: bold;
      font-family: inherit; }
  </style>
  <title>FreezeThaw(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">FreezeThaw(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">FreezeThaw(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">FreezeThaw - converting Perl structures to strings and back.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>  use FreezeThaw qw(freeze thaw cmpStr safeFreeze cmpStrHard);
  $string = freeze $data1, $data2, $data3;
  ...
  ($olddata1, $olddata2, $olddata3) = thaw $string;
  if (cmpStr($olddata2,$data2) == 0) {print &quot;OK!&quot;}
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">Converts data to/from stringified form, appropriate for
    saving-to/reading-from permanent storage.</p>
<p class="Pp">Deals with objects, circular lists, repeated appearence of the
    same refence. Does not deal with overloaded <i>stringify</i> operator
  yet.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="EXPORT"><a class="permalink" href="#EXPORT">EXPORT</a></h1>
<dl class="Bl-tag">
  <dt id="Default"><a class="permalink" href="#Default">Default</a></dt>
  <dd>None.</dd>
  <dt id="Exportable"><a class="permalink" href="#Exportable">Exportable</a></dt>
  <dd><span class="Li">&quot;freeze thaw cmpStr cmpStrHard
      safeFreeze&quot;</span>.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="User_API"><a class="permalink" href="#User_API">User
  API</a></h1>
<dl class="Bl-tag">
  <dt>&quot;cmpStr&quot;</dt>
  <dd>analogue of <span class="Li">&quot;cmp&quot;</span> for data. Takes two
      arguments and compares them as separate entities.</dd>
  <dt>&quot;cmpStrHard&quot;</dt>
  <dd>analogue of <span class="Li">&quot;cmp&quot;</span> for data. Takes two
      arguments and compares them considered as a group.</dd>
  <dt>&quot;freeze&quot;</dt>
  <dd>returns a string that encupsulates its arguments (considered as a group).
      <span class="Li">&quot;thaw&quot;</span>ing this string leads to a fatal
      error if arguments to <span class="Li">&quot;freeze&quot;</span> contained
      references to <span class="Li">&quot;GLOB&quot;</span>s and
      <span class="Li">&quot;CODE&quot;</span>s.</dd>
  <dt>&quot;safeFreeze&quot;</dt>
  <dd>returns a string that encupsulates its arguments (considered as a group).
      The result is <span class="Li">&quot;thaw&quot;</span>able in the same
      process. <span class="Li">&quot;thaw&quot;</span>ing the result in a
      different process should result in a fatal error if arguments to
      <span class="Li">&quot;safeFreeze&quot;</span> contained references to
      <span class="Li">&quot;GLOB&quot;</span>s and
      <span class="Li">&quot;CODE&quot;</span>s.</dd>
  <dt>&quot;thaw&quot;</dt>
  <dd>takes one string argument and returns an array. The elements of the array
      are &quot;equivalent&quot; to arguments of the
      <span class="Li">&quot;freeze&quot;</span> command that created the
      string. Can result in a fatal error (see above).</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="Developer_API"><a class="permalink" href="#Developer_API">Developer
  API</a></h1>
<p class="Pp"><span class="Li">&quot;FreezeThaw&quot;</span>
    <span class="Li">&quot;freeze&quot;</span>s and
    <span class="Li">&quot;thaw&quot;</span>s data blessed in some package by
    calling methods <span class="Li">&quot;Freeze&quot;</span> and
    <span class="Li">&quot;Thaw&quot;</span> in the package. The fallback
    methods are provided by the <span class="Li">&quot;FreezeThaw&quot;</span>
    itself. The fallback <span class="Li">&quot;Freeze&quot;</span> freezes the
    &quot;content&quot; of blessed object (from Perl point of view). The
    fallback <span class="Li">&quot;Thaw&quot;</span> blesses the
    <span class="Li">&quot;thaw&quot;</span>ed data back into the package.</p>
<p class="Pp">So the package needs to define its own methods only if the
    fallback methods will fail (for example, for a lot of data the
    &quot;content&quot; of an object is an address of some <b>C</b> data). The
    methods are called like</p>
<p class="Pp"></p>
<pre>  $newcooky = $obj-&gt;Freeze($cooky);
  $obj = Package-&gt;Thaw($content,$cooky);
</pre>
<p class="Pp">To save and restore the data the following method are
  applicable:</p>
<p class="Pp"></p>
<pre>  $cooky-&gt;FreezeScalar($data,$ignorePackage,$noduplicate);
</pre>
<p class="Pp">during <b>Freeze()</b>ing, and</p>
<p class="Pp"></p>
<pre>  $data = $cooky-&gt;ThawScalar;
</pre>
<p class="Pp">Two optional arguments <span class="Li">$ignorePackage</span> and
    <span class="Li">$noduplicate</span> regulate whether the freezing should
    not call the methods even if <span class="Li">$data</span> is a reference to
    a blessed object, and whether the data should not be marked as seen already
    even if it was seen before. The default methods</p>
<p class="Pp"></p>
<pre>  sub UNIVERSAL::Freeze {
    my ($obj, $cooky) = (shift, shift);
    $cooky-&gt;FreezeScalar($obj,1,1);
  }
  sub UNIVERSAL::Thaw {
    my ($package, $cooky) = (shift, shift);
    my $obj = $cooky-&gt;ThawScalar;
    bless $obj, $package;
  }
</pre>
<p class="Pp">call the <span class="Li">&quot;FreezeScalar&quot;</span> method
    of the <span class="Li">$cooky</span> since the freezing engine will see the
    data the second time during this call. Indeed, it is the freezing engine who
    calls <b>UNIVERSAL::Freeze()</b>, and it calls it because it needs to freeze
    <span class="Li">$obj</span>. The above call to
    <span class="Li">$cooky</span>-&gt;<b>FreezeScalar()</b> handles the same
    data back to engine, but because flags are different, the code does not
    cycle.</p>
<p class="Pp">Freezing and thawing <span class="Li">$cooky</span> also allows
    the following additional methods:</p>
<p class="Pp"></p>
<pre>  $cooky-&gt;isSafe;
</pre>
<p class="Pp">to find out whether the current freeze was initiated by
    <span class="Li">&quot;freeze&quot;</span> or
    <span class="Li">&quot;safeFreeze&quot;</span> command. Analogous method for
    thaw <span class="Li">$cooky</span> returns whether the current thaw
    operation is considered safe (i.e., either does not contain cached elsewhere
    data, or comes from the same application). You can use</p>
<p class="Pp"></p>
<pre>  $cooky-&gt;makeSafe;
</pre>
<p class="Pp">to prohibit cached data for the duration of the rest of freezing
    or thawing of current object.</p>
<p class="Pp">Two methods</p>
<p class="Pp"></p>
<pre>  $value = $cooky-&gt;repeatedOK;
  $cooky-&gt;noRepeated;           # Now repeated are prohibited
</pre>
<p class="Pp">allow to find out/change the current setting for allowing repeated
    references.</p>
<p class="Pp">If you want to flush the cache of saved objects you can use</p>
<p class="Pp"></p>
<pre>  FreezeThaw-&gt;flushCache;
</pre>
<p class="Pp">this can invalidate some frozen string, so that thawing them will
    result in fatal error.</p>
<section class="Ss">
<h2 class="Ss" id="Instantiating"><a class="permalink" href="#Instantiating">Instantiating</a></h2>
<p class="Pp">Sometimes, when an object from a package is recreated in presense
    of repeated references, it is not safe to recreate the internal structure of
    an object in one step. In such a situation recreation of an object is
    carried out in two steps: in the first the object is
    <span class="Li">&quot;allocate&quot;</span>d, in the second it is
    <span class="Li">&quot;instantiate&quot;</span>d.</p>
<p class="Pp">The restriction is that during the <i>allocation</i> step you
    cannot use any reference to any Perl object that can be referenced from any
    other place. This restriction is applied since that object may not exist
    yet.</p>
<p class="Pp">Correspondingly, during <i>instantiation</i> step the previosly
    <i>allocated</i> object should be
    <span class="Li">&quot;filled&quot;</span>, i.e., it can be changed in any
    way such that the references to this object remain valid.</p>
<p class="Pp">The methods are called like this:</p>
<p class="Pp"></p>
<pre>  $pre_object_ref = Package-&gt;Allocate($pre_pre_object_ref);
        # Returns reference
  Package-&gt;Instantiate($pre_object_ref,$cooky);
        # Converts into reference to blessed object
</pre>
<p class="Pp">The reverse operations are</p>
<p class="Pp"></p>
<pre>  $object_ref-&gt;FreezeEmpty($cooky);
  $object_ref-&gt;FreezeInstance($cooky);
</pre>
<p class="Pp">during these calls object can
    <span class="Li">&quot;freezeScalar&quot;</span> some information (in a
    usual way) that will be used during
    <span class="Li">&quot;Allocate&quot;</span> and
    <span class="Li">&quot;Instantiate&quot;</span> calls (via
    <span class="Li">&quot;thawScalar&quot;</span>). Note that the return value
    of <span class="Li">&quot;FreezeEmpty&quot;</span> is cached during the
    phase of creation of uninialized objects. This <b>must</b> be used like
    this: the return value is the reference to the created object, so it is not
    destructed until other objects are created, thus the frozen values of the
    different objects will not share the same references. Example of bad
  result:</p>
<p class="Pp"></p>
<pre>  $o1-&gt;FreezeEmpty($cooky)
</pre>
<p class="Pp">freezes <span class="Li">&quot;{}&quot;</span>, and
    <span class="Li">&quot;$o2-&gt;FreezeEmpty($cooky)&quot;</span> makes the
    same. Now nobody guaranties that that these two copies of
    <span class="Li">&quot;{}&quot;</span> are different, unless a reference to
    the first one is preserved during the call to
    <span class="Li">&quot;$o2-&gt;FreezeEmpty($cooky)&quot;</span>. If
    <span class="Li">&quot;$o1-&gt;FreezeEmpty($cooky)&quot;</span> returns the
    value of <span class="Li">&quot;{}&quot;</span> it uses, it will be
    preserved by the engine.</p>
<p class="Pp">The helper function
    <span class="Li">&quot;FreezeThaw::copyContents&quot;</span> is provided for
    simplification of instantiation. The syntax is</p>
<p class="Pp"></p>
<pre>  FreezeThaw::copyContents $to, $from;
</pre>
<p class="Pp">The function copies contents the object
    <span class="Li">$from</span> point to into what the object
    <span class="Li">$to</span> points to (including package for blessed
    references). Both arguments should be references.</p>
<p class="Pp">The default methods are provided. They do the following:</p>
<dl class="Bl-tag">
  <dt>&quot;FreezeEmpty&quot;</dt>
  <dd>Freezes an <i>empty</i> object of underlying type.</dd>
  <dt>&quot;FreezeInstance&quot;</dt>
  <dd>Calls <span class="Li">&quot;Freeze&quot;</span>.</dd>
  <dt>&quot;Allocate&quot;</dt>
  <dd>Thaws what was frozen by
    <span class="Li">&quot;FreezeEmpty&quot;</span>.</dd>
  <dt>&quot;Instantiate&quot;</dt>
  <dd>Thaws what was frozen by
      <span class="Li">&quot;FreezeInstance&quot;</span>, uses
      <span class="Li">&quot;copyContents&quot;</span> to transfer this to the
      <span class="Li">$pre_object</span>.</dd>
</dl>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="BUGS_and_LIMITATIONS"><a class="permalink" href="#BUGS_and_LIMITATIONS">BUGS
  and LIMITATIONS</a></h1>
<p class="Pp">A lot of objects are blessed in some obscure packages by XSUB
    typemaps. It is not clear how to (automatically) prevent the
    <span class="Li">&quot;UNIVERSAL&quot;</span> methods to be called for
    objects in these packages.</p>
<p class="Pp">The objects which can survive <b>freeze()</b>/<b>thaw()</b> cycle
    must also survive a change of a &quot;member&quot; to an equal member. Say,
    after</p>
<p class="Pp"></p>
<pre>  $a = [a =&gt; 3];
  $a-&gt;{b} = \ $a-&gt;{a};
</pre>
<p class="Pp"><span class="Li">$a</span> satisfies</p>
<p class="Pp"></p>
<pre>  $a-&gt;{b} == \ $a-&gt;{a}
</pre>
<p class="Pp">This property will be broken by <b>freeze()</b>/<b>thaw()</b>, but
    it is also broken by</p>
<p class="Pp"></p>
<pre>  $a-&gt;{a} = delete $a-&gt;{a};
</pre>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2010-04-03</td>
    <td class="foot-os">perl v5.30.2</td>
  </tr>
</table>
</body>
</html>
