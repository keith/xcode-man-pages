<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.10 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>XML::LibXML::Document(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">XML::LibXML::Document(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">XML::LibXML::Document(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
XML::LibXML::Document - XML::LibXML DOM Document Class
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<span class="Li"></span>
<pre>
  use XML::LibXML;
  # Only methods specific to Document nodes are listed here,
  # see XML::LibXML::Node manpage for other methods

  $dom = XML::LibXML::Document-&gt;new( $version, $encoding );
  $dom = XML::LibXML::Document-&gt;createDocument( $version, $encoding );
  $strURI = $doc-&gt;URI();
  $doc-&gt;setURI($strURI);
  $strEncoding = $doc-&gt;encoding();
  $strEncoding = $doc-&gt;actualEncoding();
  $doc-&gt;setEncoding($new_encoding);
  $strVersion = $doc-&gt;version();
  $doc-&gt;standalone
  $doc-&gt;setStandalone($numvalue);
  my $compression = $doc-&gt;compression;
  $doc-&gt;setCompression($ziplevel);
  $docstring = $dom-&gt;toString($format);
  $c14nstr = $doc-&gt;toStringC14N($comment_flag, $xpath [, $xpath_context ]);
  $ec14nstr = $doc-&gt;toStringEC14N($comment_flag, $xpath [, $xpath_context ], $inclusive_prefix_list);
  $str = $doc-&gt;serialize($format);
  $state = $doc-&gt;toFile($filename, $format);
  $state = $doc-&gt;toFH($fh, $format);
  $str = $document-&gt;toStringHTML();
  $str = $document-&gt;serialize_html();
  $bool = $dom-&gt;is_valid();
  $dom-&gt;validate();
  $root = $dom-&gt;documentElement();
  $dom-&gt;setDocumentElement( $root );
  $element = $dom-&gt;createElement( $nodename );
  $element = $dom-&gt;createElementNS( $namespaceURI, $qname );
  $text = $dom-&gt;createTextNode( $content_text );
  $comment = $dom-&gt;createComment( $comment_text );
  $attrnode = $doc-&gt;createAttribute($name [,$value]);
  $attrnode = $doc-&gt;createAttributeNS( namespaceURI, $name [,$value] );
  $fragment = $doc-&gt;createDocumentFragment();
  $cdata = $dom-&gt;createCDATASection( $cdata_content );
  my $pi = $doc-&gt;createProcessingInstruction( $target, $data );
  my $entref = $doc-&gt;createEntityReference($refname);
  $dtd = $document-&gt;createInternalSubset( $rootnode, $public, $system);
  $dtd = $document-&gt;createExternalSubset( $rootnode_name, $publicId, $systemId);
  $document-&gt;importNode( $node );
  $document-&gt;adoptNode( $node );
  my $dtd = $doc-&gt;externalSubset;
  my $dtd = $doc-&gt;internalSubset;
  $doc-&gt;setExternalSubset($dtd);
  $doc-&gt;setInternalSubset($dtd);
  my $dtd = $doc-&gt;removeExternalSubset();
  my $dtd = $doc-&gt;removeInternalSubset();
  my @nodelist = $doc-&gt;getElementsByTagName($tagname);
  my @nodelist = $doc-&gt;getElementsByTagNameNS($nsURI,$tagname);
  my @nodelist = $doc-&gt;getElementsByLocalName($localname);
  my $node = $doc-&gt;getElementById($id);
  $dom-&gt;indexElements();
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
The Document Class is in most cases the result of a parsing process. But
  sometimes it is necessary to create a Document from scratch. The DOM Document
  Class provides functions that conform to the DOM Core naming style.
<p class="Pp">It inherits all functions from XML::LibXML::Node as specified in
    the DOM specification. This enables access to the nodes besides the root
    element on document level - a <span class="Li">&quot;DTD&quot;</span> for
    example. The support for these nodes is limited at the moment.</p>
<p class="Pp">While generally nodes are bound to a document in the DOM concept
    it is suggested that one should always create a node not bound to any
    document. There is no need of really including the node to the document, but
    once the node is bound to a document, it is quite safe that all strings have
    the correct encoding. If an unbound text node with an ISO encoded string is
    created (e.g. with <span class="Li">$CLASS</span>-&gt;<b>new()</b>), the
    <span class="Li">&quot;toString&quot;</span> function may not return the
    expected result.</p>
<p class="Pp">To prevent such problems, it is recommended to pass all data to
    XML::LibXML methods as character strings (i.e. UTF-8 encoded, with the UTF8
    flag on).</p>
</section>
<section class="Sh">
<h1 class="Sh" id="METHODS"><a class="permalink" href="#METHODS">METHODS</a></h1>
Many functions listed here are extensively documented in the DOM Level 3
  specification (&lt;http://www.w3.org/TR/DOM-Level-3-Core/&gt;). Please refer
  to the specification for extensive documentation.
<dl class="Bl-tag">
  <dt>new</dt>
  <dd><span class="Li"></span>
    <pre>
  $dom = XML::LibXML::Document-&gt;new( $version, $encoding );
    </pre>
    <p class="Pp">alias for <b>createDocument()</b></p>
  </dd>
  <dt>createDocument</dt>
  <dd><span class="Li"></span>
    <pre>
  $dom = XML::LibXML::Document-&gt;createDocument( $version, $encoding );
    </pre>
    <p class="Pp">The constructor for the document class. As Parameter it takes
        the version string and (optionally) the encoding string. Simply calling
        <i>createDocument</i>() will create the document:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  &lt;?xml version=&quot;your version&quot; encoding=&quot;your encoding&quot;?&gt;
    </pre>
    <p class="Pp">Both parameter are optional. The default value for
        <i></i><i>$version</i><i></i> is <span class="Li">1.0</span>, of course.
        If the <i></i><i>$encoding</i><i></i> parameter is not set, the encoding
        will be left unset, which means UTF-8 is implied.</p>
    <p class="Pp">The call of <i>createDocument</i>() without any parameter will
        result the following code:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  &lt;?xml version=&quot;1.0&quot;?&gt;
    </pre>
    <p class="Pp">Alternatively one can call this constructor directly from the
        XML::LibXML class level, to avoid some typing. This will not have any
        effect on the class instance, which is always XML::LibXML::Document.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  my $document = XML::LibXML-&gt;createDocument( &quot;1.0&quot;, &quot;UTF-8&quot; );
    </pre>
    <p class="Pp">is therefore a shortcut for</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  my $document = XML::LibXML::Document-&gt;createDocument( &quot;1.0&quot;, &quot;UTF-8&quot; );
    </pre>
  </dd>
  <dt>URI</dt>
  <dd><span class="Li"></span>
    <pre>
  $strURI = $doc-&gt;URI();
    </pre>
    <p class="Pp">Returns the URI (or filename) of the original document. For
        documents obtained by parsing a string of a FH without using the URI
        parsing argument of the corresponding
        <span class="Li">&quot;parse_*&quot;</span> function, the result is a
        generated string unknown-XYZ where XYZ is some number; for documents
        created with the constructor <span class="Li">&quot;new&quot;</span>,
        the URI is undefined.</p>
    <p class="Pp">The value can be modified by calling
        <span class="Li">&quot;setURI&quot;</span> method on the document
      node.</p>
  </dd>
  <dt>setURI</dt>
  <dd><span class="Li"></span>
    <pre>
  $doc-&gt;setURI($strURI);
    </pre>
    <p class="Pp">Sets the URI of the document reported by the method URI (see
        also the URI argument to the various
        <span class="Li">&quot;parse_*&quot;</span> functions).</p>
  </dd>
  <dt>encoding</dt>
  <dd><span class="Li"></span>
    <pre>
  $strEncoding = $doc-&gt;encoding();
    </pre>
    <p class="Pp">returns the encoding string of the document.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  my $doc = XML::LibXML-&gt;createDocument( &quot;1.0&quot;, &quot;ISO-8859-15&quot; );
  print $doc-&gt;encoding; # prints ISO-8859-15
    </pre>
  </dd>
  <dt>actualEncoding</dt>
  <dd><span class="Li"></span>
    <pre>
  $strEncoding = $doc-&gt;actualEncoding();
    </pre>
    <p class="Pp">returns the encoding in which the XML will be returned by
        <span class="Li">$doc</span>-&gt;<b>toString()</b>. This is usually the
        original encoding of the document as declared in the XML declaration and
        returned by <span class="Li">$doc</span>-&gt;encoding. If the original
        encoding is not known (e.g. if created in memory or parsed from a XML
        without a declared encoding), 'UTF-8' is returned.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  my $doc = XML::LibXML-&gt;createDocument( &quot;1.0&quot;, &quot;ISO-8859-15&quot; );
  print $doc-&gt;encoding; # prints ISO-8859-15
    </pre>
  </dd>
  <dt>setEncoding</dt>
  <dd><span class="Li"></span>
    <pre>
  $doc-&gt;setEncoding($new_encoding);
    </pre>
    <p class="Pp">This method allows one to change the declaration of encoding
        in the XML declaration of the document. The value also affects the
        encoding in which the document is serialized to XML by
        <span class="Li">$doc</span>-&gt;<b>toString()</b>. Use
        <b>setEncoding()</b> to remove the encoding declaration.</p>
  </dd>
  <dt>version</dt>
  <dd><span class="Li"></span>
    <pre>
  $strVersion = $doc-&gt;version();
    </pre>
    <p class="Pp">returns the version string of the document</p>
    <p class="Pp"><i></i><b><i>getVersion()</i></b><i></i> is an alternative
        form of this function.</p>
  </dd>
  <dt>standalone</dt>
  <dd><span class="Li"></span>
    <pre>
  $doc-&gt;standalone
    </pre>
    <p class="Pp">This function returns the Numerical value of a documents XML
        declarations standalone attribute. It returns <i>1</i> if
        standalone=&quot;yes&quot; was found, <i>0</i> if
        standalone=&quot;no&quot; was found and <i>-1</i> if standalone was not
        specified (default on creation).</p>
  </dd>
  <dt>setStandalone</dt>
  <dd><span class="Li"></span>
    <pre>
  $doc-&gt;setStandalone($numvalue);
    </pre>
    <p class="Pp">Through this method it is possible to alter the value of a
        documents standalone attribute. Set it to <i>1</i> to set
        standalone=&quot;yes&quot;, to <i>0</i> to set standalone=&quot;no&quot;
        or set it to <i>-1</i> to remove the standalone attribute from the XML
        declaration.</p>
  </dd>
  <dt>compression</dt>
  <dd><span class="Li"></span>
    <pre>
  my $compression = $doc-&gt;compression;
    </pre>
    <p class="Pp">libxml2 allows reading of documents directly from gzipped
        files. In this case the compression variable is set to the compression
        level of that file (0-8). If XML::LibXML parsed a different source or
        the file wasn't compressed, the returned value will be <i>-1</i>.</p>
  </dd>
  <dt>setCompression</dt>
  <dd><span class="Li"></span>
    <pre>
  $doc-&gt;setCompression($ziplevel);
    </pre>
    <p class="Pp">If one intends to write the document directly to a file, it is
        possible to set the compression level for a given document. This level
        can be in the range from 0 to 8. If XML::LibXML should not try to
        compress use <i>-1</i> (default).</p>
    <p class="Pp">Note that this feature will <i>only</i> work if libxml2 is
        compiled with zlib support and <b>toFile()</b> is used for output.</p>
  </dd>
  <dt>toString</dt>
  <dd><span class="Li"></span>
    <pre>
  $docstring = $dom-&gt;toString($format);
    </pre>
    <p class="Pp"><i>toString</i> is a DOM serializing function, so the DOM Tree
        is serialized into an XML string, ready for output.</p>
    <p class="Pp">IMPORTANT: unlike toString for other nodes, on document nodes
        this function returns the XML as a byte string in the original encoding
        of the document (see the <b>actualEncoding()</b> method)! This means you
        can simply do:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  open my $out_fh, '&gt;', $file;
  print {$out_fh} $doc-&gt;toString;
    </pre>
    <p class="Pp">regardless of the actual encoding of the document. See the
        section on encodings in XML::LibXML for more details.</p>
    <p class="Pp">The optional <i></i><i>$format</i><i></i> parameter sets the
        indenting of the output. This parameter is expected to be an
        <span class="Li">&quot;integer&quot;</span> value, that specifies that
        indentation should be used. The format parameter can have three
        different values if it is used:</p>
    <p class="Pp">If <span class="Li">$format</span> is 0, than the document is
        dumped as it was originally parsed</p>
    <p class="Pp">If <span class="Li">$format</span> is 1, libxml2 will add
        ignorable white spaces, so the nodes content is easier to read. Existing
        text nodes will not be altered</p>
    <p class="Pp">If <span class="Li">$format</span> is 2 (or higher), libxml2
        will act as <span class="Li">$format</span> == 1 but it add a leading
        and a trailing line break to each text node.</p>
    <p class="Pp">libxml2 uses a hard-coded indentation of 2 space characters
        per indentation level. This value can not be altered on run-time.</p>
  </dd>
  <dt>toStringC14N</dt>
  <dd><span class="Li"></span>
    <pre>
  $c14nstr = $doc-&gt;toStringC14N($comment_flag, $xpath [, $xpath_context ]);
    </pre>
    <p class="Pp">See the documentation in XML::LibXML::Node.</p>
  </dd>
  <dt>toStringEC14N</dt>
  <dd><span class="Li"></span>
    <pre>
  $ec14nstr = $doc-&gt;toStringEC14N($comment_flag, $xpath [, $xpath_context ], $inclusive_prefix_list);
    </pre>
    <p class="Pp">See the documentation in XML::LibXML::Node.</p>
  </dd>
  <dt>serialize</dt>
  <dd><span class="Li"></span>
    <pre>
  $str = $doc-&gt;serialize($format);
    </pre>
    <p class="Pp">An alias for <b>toString()</b>. This function was name added
        to be more consistent with libxml2.</p>
  </dd>
  <dt>serialize_c14n</dt>
  <dd>An alias for <b>toStringC14N()</b>.</dd>
  <dt>serialize_exc_c14n</dt>
  <dd>An alias for <b>toStringEC14N()</b>.</dd>
  <dt>toFile</dt>
  <dd><span class="Li"></span>
    <pre>
  $state = $doc-&gt;toFile($filename, $format);
    </pre>
    <p class="Pp">This function is similar to <b>toString()</b>, but it writes
        the document directly into a filesystem. This function is very useful,
        if one needs to store large documents.</p>
    <p class="Pp">The format parameter has the same behaviour as in
        <b>toString()</b>.</p>
  </dd>
  <dt>toFH</dt>
  <dd><span class="Li"></span>
    <pre>
  $state = $doc-&gt;toFH($fh, $format);
    </pre>
    <p class="Pp">This function is similar to <b>toString()</b>, but it writes
        the document directly to a filehandle or a stream. A byte stream in the
        document encoding is passed to the file handle. Do NOT apply any
        <span class="Li">&quot;:encoding(...)&quot;</span> or
        <span class="Li">&quot;:utf8&quot;</span> PerlIO layer to the
        filehandle! See the section on encodings in XML::LibXML for more
        details.</p>
    <p class="Pp">The format parameter has the same behaviour as in
        <b>toString()</b>.</p>
  </dd>
  <dt>toStringHTML</dt>
  <dd><span class="Li"></span>
    <pre>
  $str = $document-&gt;toStringHTML();
    </pre>
    <p class="Pp"><i>toStringHTML</i> serialize the tree to a byte string in the
        document encoding as HTML. With this method indenting is automatic and
        managed by libxml2 internally.</p>
  </dd>
  <dt>serialize_html</dt>
  <dd><span class="Li"></span>
    <pre>
  $str = $document-&gt;serialize_html();
    </pre>
    <p class="Pp">An alias for <b>toStringHTML()</b>.</p>
  </dd>
  <dt>is_valid</dt>
  <dd><span class="Li"></span>
    <pre>
  $bool = $dom-&gt;is_valid();
    </pre>
    <p class="Pp">Returns either TRUE or FALSE depending on whether the DOM Tree
        is a valid Document or not.</p>
    <p class="Pp">You may also pass in a XML::LibXML::Dtd object, to validate
        against an external DTD:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  if (!$dom-&gt;is_valid($dtd)) {
       warn(&quot;document is not valid!&quot;);
   }
    </pre>
  </dd>
  <dt>validate</dt>
  <dd><span class="Li"></span>
    <pre>
  $dom-&gt;validate();
    </pre>
    <p class="Pp">This is an exception throwing equivalent of is_valid. If the
        document is not valid it will throw an exception containing the error.
        This allows you much better error reporting than simply is_valid or
      not.</p>
    <p class="Pp">Again, you may pass in a DTD object</p>
  </dd>
  <dt>documentElement</dt>
  <dd><span class="Li"></span>
    <pre>
  $root = $dom-&gt;documentElement();
    </pre>
    <p class="Pp">Returns the root element of the Document. A document can have
        just one root element to contain the documents data.</p>
    <p class="Pp">Optionally one can use <i>getDocumentElement</i>.</p>
  </dd>
  <dt>setDocumentElement</dt>
  <dd><span class="Li"></span>
    <pre>
  $dom-&gt;setDocumentElement( $root );
    </pre>
    <p class="Pp">This function enables you to set the root element for a
        document. The function supports the import of a node from a different
        document tree, but does not support a document fragment as
        <span class="Li">$root</span>.</p>
  </dd>
  <dt>createElement</dt>
  <dd><span class="Li"></span>
    <pre>
  $element = $dom-&gt;createElement( $nodename );
    </pre>
    <p class="Pp">This function creates a new Element Node bound to the DOM with
        the name <span class="Li">$nodename</span>.</p>
  </dd>
  <dt>createElementNS</dt>
  <dd><span class="Li"></span>
    <pre>
  $element = $dom-&gt;createElementNS( $namespaceURI, $qname );
    </pre>
    <p class="Pp">This function creates a new Element Node bound to the DOM with
        the name <span class="Li">$nodename</span> and placed in the given
        namespace.</p>
  </dd>
  <dt>createTextNode</dt>
  <dd><span class="Li"></span>
    <pre>
  $text = $dom-&gt;createTextNode( $content_text );
    </pre>
    <p class="Pp">As an equivalent of <i>createElement</i>, but it creates a
        <i>Text Node</i> bound to the DOM.</p>
  </dd>
  <dt>createComment</dt>
  <dd><span class="Li"></span>
    <pre>
  $comment = $dom-&gt;createComment( $comment_text );
    </pre>
    <p class="Pp">As an equivalent of <i>createElement</i>, but it creates a
        <i>Comment Node</i> bound to the DOM.</p>
  </dd>
  <dt>createAttribute</dt>
  <dd><span class="Li"></span>
    <pre>
  $attrnode = $doc-&gt;createAttribute($name [,$value]);
    </pre>
    <p class="Pp">Creates a new Attribute node.</p>
  </dd>
  <dt>createAttributeNS</dt>
  <dd><span class="Li"></span>
    <pre>
  $attrnode = $doc-&gt;createAttributeNS( namespaceURI, $name [,$value] );
    </pre>
    <p class="Pp">Creates an Attribute bound to a namespace.</p>
  </dd>
  <dt>createDocumentFragment</dt>
  <dd><span class="Li"></span>
    <pre>
  $fragment = $doc-&gt;createDocumentFragment();
    </pre>
    <p class="Pp">This function creates a DocumentFragment.</p>
  </dd>
  <dt>createCDATASection</dt>
  <dd><span class="Li"></span>
    <pre>
  $cdata = $dom-&gt;createCDATASection( $cdata_content );
    </pre>
    <p class="Pp">Similar to createTextNode and createComment, this function
        creates a CDataSection bound to the current DOM.</p>
  </dd>
  <dt>createProcessingInstruction</dt>
  <dd><span class="Li"></span>
    <pre>
  my $pi = $doc-&gt;createProcessingInstruction( $target, $data );
    </pre>
    <p class="Pp">create a processing instruction node.</p>
    <p class="Pp">Since this method is quite long one may use its short form
        <i></i> <b><i>createPI()</i></b><i></i>.</p>
  </dd>
  <dt>createEntityReference</dt>
  <dd><span class="Li"></span>
    <pre>
  my $entref = $doc-&gt;createEntityReference($refname);
    </pre>
    <p class="Pp">If a document has a DTD specified, one can create entity
        references by using this function. If one wants to add a entity
        reference to the document, this reference has to be created by this
        function.</p>
    <p class="Pp">An entity reference is unique to a document and cannot be
        passed to other documents as other nodes can be passed.</p>
    <p class="Pp"><i>NOTE:</i> A text content containing something that looks
        like an entity reference, will not be expanded to a real entity
        reference unless it is a predefined entity</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  my $string = &quot;&amp;foo;&quot;;
   $some_element-&gt;appendText( $string );
   print $some_element-&gt;textContent; # prints &quot;&amp;amp;foo;&quot;
    </pre>
  </dd>
  <dt>createInternalSubset</dt>
  <dd><span class="Li"></span>
    <pre>
  $dtd = $document-&gt;createInternalSubset( $rootnode, $public, $system);
    </pre>
    <p class="Pp">This function creates and adds an internal subset to the given
        document. Because the function automatically adds the DTD to the
        document there is no need to add the created node explicitly to the
        document.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  my $document = XML::LibXML::Document-&gt;new();
   my $dtd      = $document-&gt;createInternalSubset( &quot;foo&quot;, undef, &quot;foo.dtd&quot; );
    </pre>
    <p class="Pp">will result in the following XML document:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  &lt;?xml version=&quot;1.0&quot;?&gt;
   &lt;!DOCTYPE foo SYSTEM &quot;foo.dtd&quot;&gt;
    </pre>
    <p class="Pp">By setting the public parameter it is possible to set PUBLIC
        DTDs to a given document. So</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  my $document = XML::LibXML::Document-&gt;new();
  my $dtd      = $document-&gt;createInternalSubset( &quot;foo&quot;, &quot;-//FOO//DTD FOO 0.1//EN&quot;, undef );
    </pre>
    <p class="Pp">will cause the following declaration to be created on the
        document:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  &lt;?xml version=&quot;1.0&quot;?&gt;
  &lt;!DOCTYPE foo PUBLIC &quot;-//FOO//DTD FOO 0.1//EN&quot;&gt;
    </pre>
  </dd>
  <dt>createExternalSubset</dt>
  <dd><span class="Li"></span>
    <pre>
  $dtd = $document-&gt;createExternalSubset( $rootnode_name, $publicId, $systemId);
    </pre>
    <p class="Pp">This function is similar to
        <span class="Li">&quot;createInternalSubset()&quot;</span> but this DTD
        is considered to be external and is therefore not added to the document
        itself. Nevertheless it can be used for validation purposes.</p>
  </dd>
  <dt>importNode</dt>
  <dd><span class="Li"></span>
    <pre>
  $document-&gt;importNode( $node );
    </pre>
    <p class="Pp">If a node is not part of a document, it can be imported to
        another document. As specified in DOM Level 2 Specification the Node
        will not be altered or removed from its original document
        (<span class="Li">&quot;$node-&gt;cloneNode(1)&quot;</span> will get
        called implicitly).</p>
    <p class="Pp"><i>NOTE:</i> Don't try to use <b>importNode()</b> to import
        sub-trees that contain an entity reference - even if the entity
        reference is the root node of the sub-tree. This will cause serious
        problems to your program. This is a limitation of libxml2 and not of
        XML::LibXML itself.</p>
  </dd>
  <dt>adoptNode</dt>
  <dd><span class="Li"></span>
    <pre>
  $document-&gt;adoptNode( $node );
    </pre>
    <p class="Pp">If a node is not part of a document, it can be imported to
        another document. As specified in DOM Level 3 Specification the Node
        will not be altered but it will removed from its original document.</p>
    <p class="Pp">After a document adopted a node, the node, its attributes and
        all its descendants belong to the new document. Because the node does
        not belong to the old document, it will be unlinked from its old
        location first.</p>
    <p class="Pp"><i>NOTE:</i> Don't try to <b>adoptNode()</b> to import
        sub-trees that contain entity references - even if the entity reference
        is the root node of the sub-tree. This will cause serious problems to
        your program. This is a limitation of libxml2 and not of XML::LibXML
        itself.</p>
  </dd>
  <dt>externalSubset</dt>
  <dd><span class="Li"></span>
    <pre>
  my $dtd = $doc-&gt;externalSubset;
    </pre>
    <p class="Pp">If a document has an external subset defined it will be
        returned by this function.</p>
    <p class="Pp"><i>NOTE</i> Dtd nodes are no ordinary nodes in libxml2. The
        support for these nodes in XML::LibXML is still limited. In particular
        one may not want use common node function on doctype declaration
      nodes!</p>
  </dd>
  <dt>internalSubset</dt>
  <dd><span class="Li"></span>
    <pre>
  my $dtd = $doc-&gt;internalSubset;
    </pre>
    <p class="Pp">If a document has an internal subset defined it will be
        returned by this function.</p>
    <p class="Pp"><i>NOTE</i> Dtd nodes are no ordinary nodes in libxml2. The
        support for these nodes in XML::LibXML is still limited. In particular
        one may not want use common node function on doctype declaration
      nodes!</p>
  </dd>
  <dt>setExternalSubset</dt>
  <dd><span class="Li"></span>
    <pre>
  $doc-&gt;setExternalSubset($dtd);
    </pre>
    <p class="Pp"><i>EXPERIMENTAL!</i></p>
    <p class="Pp">This method sets a DTD node as an external subset of the given
        document.</p>
  </dd>
  <dt>setInternalSubset</dt>
  <dd><span class="Li"></span>
    <pre>
  $doc-&gt;setInternalSubset($dtd);
    </pre>
    <p class="Pp"><i>EXPERIMENTAL!</i></p>
    <p class="Pp">This method sets a DTD node as an internal subset of the given
        document.</p>
  </dd>
  <dt>removeExternalSubset</dt>
  <dd><span class="Li"></span>
    <pre>
  my $dtd = $doc-&gt;removeExternalSubset();
    </pre>
    <p class="Pp"><i>EXPERIMENTAL!</i></p>
    <p class="Pp">If a document has an external subset defined it can be removed
        from the document by using this function. The removed dtd node will be
        returned.</p>
  </dd>
  <dt>removeInternalSubset</dt>
  <dd><span class="Li"></span>
    <pre>
  my $dtd = $doc-&gt;removeInternalSubset();
    </pre>
    <p class="Pp"><i>EXPERIMENTAL!</i></p>
    <p class="Pp">If a document has an internal subset defined it can be removed
        from the document by using this function. The removed dtd node will be
        returned.</p>
  </dd>
  <dt>getElementsByTagName</dt>
  <dd><span class="Li"></span>
    <pre>
  my @nodelist = $doc-&gt;getElementsByTagName($tagname);
    </pre>
    <p class="Pp">Implements the DOM Level 2 function</p>
    <p class="Pp">In SCALAR context this function returns an
        XML::LibXML::NodeList object.</p>
  </dd>
  <dt>getElementsByTagNameNS</dt>
  <dd><span class="Li"></span>
    <pre>
  my @nodelist = $doc-&gt;getElementsByTagNameNS($nsURI,$tagname);
    </pre>
    <p class="Pp">Implements the DOM Level 2 function</p>
    <p class="Pp">In SCALAR context this function returns an
        XML::LibXML::NodeList object.</p>
  </dd>
  <dt>getElementsByLocalName</dt>
  <dd><span class="Li"></span>
    <pre>
  my @nodelist = $doc-&gt;getElementsByLocalName($localname);
    </pre>
    <p class="Pp">This allows the fetching of all nodes from a given document
        with the given Localname.</p>
    <p class="Pp">In SCALAR context this function returns an
        XML::LibXML::NodeList object.</p>
  </dd>
  <dt>getElementById</dt>
  <dd><span class="Li"></span>
    <pre>
  my $node = $doc-&gt;getElementById($id);
    </pre>
    <p class="Pp">Returns the element that has an ID attribute with the given
        value. If no such element exists, this returns undef.</p>
    <p class="Pp">Note: the ID of an element may change while manipulating the
        document. For documents with a DTD, the information about ID attributes
        is only available if DTD loading/validation has been requested. For HTML
        documents parsed with the HTML parser ID detection is done
        automatically. In XML documents, all &quot;xml:id&quot; attributes are
        considered to be of type ID. You can test ID-ness of an attribute node
        with <span class="Li">$attr</span>-&gt;<b>isId()</b>.</p>
    <p class="Pp">In versions 1.59 and earlier this method was called
        <b>getElementsById()</b> (plural) by mistake. Starting from 1.60 this
        name is maintained as an alias only for backward compatibility.</p>
  </dd>
  <dt>indexElements</dt>
  <dd><span class="Li"></span>
    <pre>
  $dom-&gt;indexElements();
    </pre>
    <p class="Pp">This function causes libxml2 to stamp all elements in a
        document with their document position index which considerably speeds up
        XPath queries for large documents. It should only be used with static
        documents that won't be further changed by any DOM methods, because once
        a document is indexed, XPath will always prefer the index to other
        methods of determining the document order of nodes. XPath could
        therefore return improperly ordered node-lists when applied on a
        document that has been changed after being indexed. It is of course
        possible to use this method to re-index a modified document before using
        it with XPath again. This function is not a part of the DOM
        specification.</p>
    <p class="Pp">This function returns number of elements indexed, -1 if error
        occurred, or -2 if this feature is not available in the running
      libxml2.</p>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHORS"><a class="permalink" href="#AUTHORS">AUTHORS</a></h1>
Matt Sergeant, Christian Glahn, Petr Pajas
</section>
<section class="Sh">
<h1 class="Sh" id="VERSION"><a class="permalink" href="#VERSION">VERSION</a></h1>
2.0110
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT"><a class="permalink" href="#COPYRIGHT">COPYRIGHT</a></h1>
2001-2007, AxKit.com Ltd.
<p class="Pp">2002-2006, Christian Glahn.</p>
<p class="Pp">2006-2009, Petr Pajas.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="LICENSE"><a class="permalink" href="#LICENSE">LICENSE</a></h1>
This program is free software; you can redistribute it and/or modify it under
  the same terms as Perl itself.
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2014-02-01</td>
    <td class="foot-os">perl v5.28.2</td>
  </tr>
</table>
</body>
</html>
