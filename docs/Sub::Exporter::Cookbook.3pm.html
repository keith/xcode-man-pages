<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    .Nd, .Bf, .Op { display: inline; }
    .Pa, .Ad { font-style: italic; }
    .Ms { font-weight: bold; }
    .Bl-diag > dt { font-weight: bold; }
    code.Nm, .Fl, .Cm, .Ic, code.In, .Fd, .Fn, .Cd { font-weight: bold;
      font-family: inherit; }
  </style>
  <title>Sub::Exporter::Cookbook(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Sub::Exporter::Cookbook(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Sub::Exporter::Cookbook(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Sub::Exporter::Cookbook - useful, demonstrative, or stupid
    Sub::Exporter tricks</p>
</section>
<section class="Sh">
<h1 class="Sh" id="VERSION"><a class="permalink" href="#VERSION">VERSION</a></h1>
<p class="Pp">version 0.987</p>
</section>
<section class="Sh">
<h1 class="Sh" id="OVERVIEW"><a class="permalink" href="#OVERVIEW">OVERVIEW</a></h1>
<p class="Pp">Sub::Exporter is a fairly simple tool, and can be used to achieve
    some very simple goals. Its basic behaviors and their basic application
    (that is, &quot;traditional&quot; exporting of routines) are described in
    Sub::Exporter::Tutorial and Sub::Exporter. This document presents
    applications that may not be immediately obvious, or that can demonstrate
    how certain features can be put to use (for good or evil).</p>
</section>
<section class="Sh">
<h1 class="Sh" id="THE_RECIPES"><a class="permalink" href="#THE_RECIPES">THE
  RECIPES</a></h1>
<section class="Ss">
<h2 class="Ss" id="Exporting_Methods_as_Routines"><a class="permalink" href="#Exporting_Methods_as_Routines">Exporting
  Methods as Routines</a></h2>
<p class="Pp">With Exporter.pm, exporting methods is a non-starter.
    Sub::Exporter makes it simple. By using the
    <span class="Li">&quot;curry_method&quot;</span> utility provided in
    Sub::Exporter::Util, a method can be exported with the invocant built
  in.</p>
<p class="Pp"></p>
<pre>  package Object::Strenuous;
  use Sub::Exporter::Util 'curry_method';
  use Sub::Exporter -setup =&gt; {
    exports =&gt; [ objection =&gt; curry_method('new') ],
  };
</pre>
<p class="Pp">With this configuration, the importing code may contain:</p>
<p class="Pp"></p>
<pre>  my $obj = objection(&quot;irrelevant&quot;);
</pre>
<p class="Pp">...and this will be equivalent to:</p>
<p class="Pp"></p>
<pre>  my $obj = Object::Strenuous-&gt;new(&quot;irrelevant&quot;);
</pre>
<p class="Pp">The built-in invocant is determined by the invocant for the
    <span class="Li">&quot;import&quot;</span> method. That means that if we
    were to subclass Object::Strenuous as follows:</p>
<p class="Pp"></p>
<pre>  package Object::Strenuous::Repeated;
  @ISA = 'Object::Strenuous';
</pre>
<p class="Pp">...then importing <span class="Li">&quot;objection&quot;</span>
    from the subclass would build-in that subclass.</p>
<p class="Pp">Finally, since the invocant can be an object, you can write
    something like this:</p>
<p class="Pp"></p>
<pre>  package Cypher;
  use Sub::Exporter::Util 'curry_method';
  use Sub::Exporter -setup =&gt; {
    exports =&gt; [ encypher =&gt; curry_method ],
  };
</pre>
<p class="Pp">with the expectation that
    <span class="Li">&quot;import&quot;</span> will be called on an instantiated
    Cypher object:</p>
<p class="Pp"></p>
<pre>  BEGIN {
    my $cypher = Cypher-&gt;new( ... );
    $cypher-&gt;import('encypher');
  }
</pre>
<p class="Pp">Now there is a globally-available
    <span class="Li">&quot;encypher&quot;</span> routine which calls the
    encypher method on an otherwise unavailable Cypher object.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Exporting_Methods_as_Methods"><a class="permalink" href="#Exporting_Methods_as_Methods">Exporting
  Methods as Methods</a></h2>
<p class="Pp">While exporting modules usually export subroutines to be called as
    subroutines, it's easy to use Sub::Exporter to export subroutines meant to
    be called as methods on the importing package or its objects.</p>
<p class="Pp">Here's a trivial (and naive) example:</p>
<p class="Pp"></p>
<pre>  package Mixin::DumpObj;
  use Data::Dumper;
  use Sub::Exporter -setup =&gt; {
    exports =&gt; [ qw(dump) ]
  };
  sub dump {
    my ($self) = @_;
    return Dumper($self);
  }
</pre>
<p class="Pp">When writing your own object class, you can then import
    <span class="Li">&quot;dump&quot;</span> to be used as a method, called like
    so:</p>
<p class="Pp"></p>
<pre>  $object-&gt;dump;
</pre>
<p class="Pp">By assuming that the importing class will provide a certain
    interface, a method-exporting module can be used as a simple plugin:</p>
<p class="Pp"></p>
<pre>  package Number::Plugin::Upto;
  use Sub::Exporter -setup =&gt; {
    into    =&gt; 'Number',
    exports =&gt; [ qw(upto) ],
    groups  =&gt; [ default =&gt; [ qw(upto) ] ],
  };
  sub upto {
    my ($self) = @_;
    return 1 .. abs($self-&gt;as_integer);
  }
</pre>
<p class="Pp">The <span class="Li">&quot;into&quot;</span> line in the
    configuration says that this plugin will export, by default, into the Number
    package, not into the <span class="Li">&quot;use&quot;</span>-ing package.
    It can be exported anyway, though, and will work as long as the destination
    provides an <span class="Li">&quot;as_integer&quot;</span> method like the
    one it expects. To import it to a different destination, one can just
  write:</p>
<p class="Pp"></p>
<pre>  use Number::Plugin::Upto { into =&gt; 'Quantity' };
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Mixing-in_Complex_External_Behavior"><a class="permalink" href="#Mixing-in_Complex_External_Behavior">Mixing-in
  Complex External Behavior</a></h2>
<p class="Pp">When exporting methods to be used as methods (see above), one very
    powerful option is to export methods that are generated routines that
    maintain an enclosed reference to the exporting module. This allows a user
    to import a single method which is implemented in terms of a complete,
    well-structured package.</p>
<p class="Pp">Here is a very small example:</p>
<p class="Pp"></p>
<pre>  package Data::Analyzer;
  use Sub::Exporter -setup =&gt; {
    exports =&gt; [ analyze =&gt; \'_generate_analyzer' ],
  };
  sub _generate_analyzer {
    my ($mixin, $name, $arg, $col) = @_;
    return sub {
      my ($self) = @_;
      my $values = [ $self-&gt;values ];
      my $analyzer = $mixin-&gt;new($values);
      $analyzer-&gt;perform_analysis;
      $analyzer-&gt;aggregate_results;
      return $analyzer-&gt;summary;
    };
  }
</pre>
<p class="Pp">If imported by any package providing a
    <span class="Li">&quot;values&quot;</span> method, this plugin will provide
    a single <span class="Li">&quot;analyze&quot;</span> method that acts as a
    simple interface to a more complex set of behaviors.</p>
<p class="Pp">Even more importantly, because the <span class="Li">$mixin</span>
    value will be the invocant on which the
    <span class="Li">&quot;import&quot;</span> was actually called, one can
    subclass <span class="Li">&quot;Data::Analyzer&quot;</span> and replace only
    individual pieces of the complex behavior, making it easy to write complex,
    subclassable toolkits with simple single points of entry for external
    interfaces.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Exporting_Constants"><a class="permalink" href="#Exporting_Constants">Exporting
  Constants</a></h2>
<p class="Pp">While Sub::Exporter isn't in the constant-exporting business, it's
    easy to export constants by using one of its sister modules,
    Package::Generator.</p>
<p class="Pp"></p>
<pre>  package Important::Constants;
 
  use Sub::Exporter -setup =&gt; {
    collectors =&gt; [ constants =&gt; \'_set_constants' ],
  };
 
  sub _set_constants {
    my ($class, $value, $data) = @_;
 
    Package::Generator-&gt;assign_symbols(
      $data-&gt;{into},
      [
        MEANING_OF_LIFE =&gt; \42,
        ONE_TRUE_BASE   =&gt; \13,
        FACTORS         =&gt; [ 6, 9 ],
      ],
    );
    return 1;
  }
</pre>
<p class="Pp">Then, someone can write:</p>
<p class="Pp"></p>
<pre>  use Important::Constants 'constants';
  
  print &quot;The factors @FACTORS produce $MEANING_OF_LIFE in $ONE_TRUE_BASE.&quot;;
</pre>
<p class="Pp">(The constants must be exported via a collector, because they are
    effectively altering the importing class in a way other than installing
    subroutines.)</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Altering_the_Importer's_@ISA"><a class="permalink" href="#Altering_the_Importer's_@ISA">Altering
  the Importer's @ISA</a></h2>
<p class="Pp">It's trivial to make a collector that changes the inheritance of
    an importing package:</p>
<p class="Pp"></p>
<pre>  use Sub::Exporter -setup =&gt; {
    collectors =&gt; { -base =&gt; \'_make_base' },
  };
  sub _make_base {
    my ($class, $value, $data) = @_;
    my $target = $data-&gt;{into};
    push @{&quot;$target\::ISA&quot;}, $class;
  }
</pre>
<p class="Pp">Then, the user of your class can write:</p>
<p class="Pp"></p>
<pre>  use Some::Class -base;
</pre>
<p class="Pp">and become a subclass. This can be quite useful in building, for
    example, a module that helps build plugins. We may want a few utilities
    imported, but we also want to inherit behavior from some base plugin
  class;</p>
<p class="Pp"></p>
<pre>  package Framework::Util;
  use Sub::Exporter -setup =&gt; {
    exports    =&gt; [ qw(log global_config) ],
    groups     =&gt; [ _plugin =&gt; [ qw(log global_config) ]
    collectors =&gt; { '-plugin' =&gt; \'_become_plugin' },
  };
  sub _become_plugin {
    my ($class, $value, $data) = @_;
    my $target = $data-&gt;{into};
    push @{&quot;$target\::ISA&quot;}, $class-&gt;plugin_base_class;
    push @{ $data-&gt;{import_args} }, '-_plugin';
  }
</pre>
<p class="Pp">Now, you can write a plugin like this:</p>
<p class="Pp"></p>
<pre>  package Framework::Plugin::AirFreshener;
  use Framework::Util -plugin;
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Eating_Exporter.pm's_Brain"><a class="permalink" href="#Eating_Exporter.pm's_Brain">Eating
  Exporter.pm's Brain</a></h2>
<p class="Pp">You probably shouldn't actually do this in production. It's
    offered more as a demonstration than a suggestion.</p>
<p class="Pp"></p>
<pre> sub exporter_upgrade {
   my ($pkg) = @_;
   my $new_pkg = &quot;$pkg\::UsingSubExporter&quot;;
   return $new_pkg if $new_pkg-&gt;isa($pkg);
   Sub::Exporter::setup_exporter({
     as      =&gt; 'import',
     into    =&gt; $new_pkg,
     exports =&gt; [ @{&quot;$pkg\::EXPORT_OK&quot;} ],
     groups  =&gt; {
       %{&quot;$pkg\::EXPORT_TAG&quot;},
       default =&gt; [ @{&quot;$pkg\::EXPORTS&quot;} ],
     },
   });
   @{&quot;$new_pkg\::ISA&quot;} = $pkg;
   return $new_pkg;
 }
</pre>
<p class="Pp">This routine, given the name of an existing package configured to
    use Exporter.pm, returns the name of a new package with a
    Sub::Exporter-powered <span class="Li">&quot;import&quot;</span> routine.
    This lets you import
    <span class="Li">&quot;Toolkit::exported_sub&quot;</span> into the current
    package with the name <span class="Li">&quot;foo&quot;</span> by
  writing:</p>
<p class="Pp"></p>
<pre>  BEGIN {
    require Toolkit;
    exporter_upgrade('Toolkit')-&gt;import(exported_sub =&gt; { -as =&gt; 'foo' })
  }
</pre>
<p class="Pp">If you're feeling particularly naughty, this routine could have
    been declared in the UNIVERSAL package, meaning you could write:</p>
<p class="Pp"></p>
<pre>  BEGIN {
    require Toolkit;
    Toolkit-&gt;exporter_upgrade-&gt;import(exported_sub =&gt; { -as =&gt; 'foo' })
  }
</pre>
<p class="Pp">The new package will have all the same exporter configuration as
    the original, but will support export and group renaming, including
    exporting into scalar references. Further, since Sub::Exporter uses
    <span class="Li">&quot;can&quot;</span> to find the routine being exported,
    the new package may be subclassed and some of its exports replaced.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">Ricardo Signes &lt;rjbs@cpan.org&gt;</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT_AND_LICENSE"><a class="permalink" href="#COPYRIGHT_AND_LICENSE">COPYRIGHT
  AND LICENSE</a></h1>
<p class="Pp">This software is copyright (c) 2007 by Ricardo Signes.</p>
<p class="Pp">This is free software; you can redistribute it and/or modify it
    under the same terms as the Perl 5 programming language system itself.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2013-10-18</td>
    <td class="foot-os">perl v5.30.2</td>
  </tr>
</table>
</body>
</html>
