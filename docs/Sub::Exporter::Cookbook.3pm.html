<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.10 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>Sub::Exporter::Cookbook(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Sub::Exporter::Cookbook(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Sub::Exporter::Cookbook(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
Sub::Exporter::Cookbook - useful, demonstrative, or stupid Sub::Exporter tricks
</section>
<section class="Sh">
<h1 class="Sh" id="VERSION"><a class="permalink" href="#VERSION">VERSION</a></h1>
version 0.987
</section>
<section class="Sh">
<h1 class="Sh" id="OVERVIEW"><a class="permalink" href="#OVERVIEW">OVERVIEW</a></h1>
Sub::Exporter is a fairly simple tool, and can be used to achieve some very
  simple goals. Its basic behaviors and their basic application (that is,
  &quot;traditional&quot; exporting of routines) are described in
  Sub::Exporter::Tutorial and Sub::Exporter. This document presents applications
  that may not be immediately obvious, or that can demonstrate how certain
  features can be put to use (for good or evil).
</section>
<section class="Sh">
<h1 class="Sh" id="THE_RECIPES"><a class="permalink" href="#THE_RECIPES">THE
  RECIPES</a></h1>
<section class="Ss">
<h2 class="Ss" id="Exporting_Methods_as_Routines"><a class="permalink" href="#Exporting_Methods_as_Routines">Exporting
  Methods as Routines</a></h2>
With Exporter.pm, exporting methods is a non-starter. Sub::Exporter makes it
  simple. By using the <span class="Li">&quot;curry_method&quot;</span> utility
  provided in Sub::Exporter::Util, a method can be exported with the invocant
  built in.
<p class="Pp"><span class="Li"></span></p>
<pre>
  package Object::Strenuous;

  use Sub::Exporter::Util 'curry_method';
  use Sub::Exporter -setup =&gt; {
    exports =&gt; [ objection =&gt; curry_method('new') ],
  };
</pre>
<p class="Pp">With this configuration, the importing code may contain:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  my $obj = objection(&quot;irrelevant&quot;);
</pre>
<p class="Pp">...and this will be equivalent to:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  my $obj = Object::Strenuous-&gt;new(&quot;irrelevant&quot;);
</pre>
<p class="Pp">The built-in invocant is determined by the invocant for the
    <span class="Li">&quot;import&quot;</span> method. That means that if we
    were to subclass Object::Strenuous as follows:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  package Object::Strenuous::Repeated;
  @ISA = 'Object::Strenuous';
</pre>
<p class="Pp">...then importing <span class="Li">&quot;objection&quot;</span>
    from the subclass would build-in that subclass.</p>
<p class="Pp">Finally, since the invocant can be an object, you can write
    something like this:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  package Cypher;
  use Sub::Exporter::Util 'curry_method';
  use Sub::Exporter -setup =&gt; {
    exports =&gt; [ encypher =&gt; curry_method ],
  };
</pre>
<p class="Pp">with the expectation that
    <span class="Li">&quot;import&quot;</span> will be called on an instantiated
    Cypher object:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  BEGIN {
    my $cypher = Cypher-&gt;new( ... );
    $cypher-&gt;import('encypher');
  }
</pre>
<p class="Pp">Now there is a globally-available
    <span class="Li">&quot;encypher&quot;</span> routine which calls the
    encypher method on an otherwise unavailable Cypher object.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Exporting_Methods_as_Methods"><a class="permalink" href="#Exporting_Methods_as_Methods">Exporting
  Methods as Methods</a></h2>
While exporting modules usually export subroutines to be called as subroutines,
  it's easy to use Sub::Exporter to export subroutines meant to be called as
  methods on the importing package or its objects.
<p class="Pp">Here's a trivial (and naive) example:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  package Mixin::DumpObj;

  use Data::Dumper;

  use Sub::Exporter -setup =&gt; {
    exports =&gt; [ qw(dump) ]
  };

  sub dump {
    my ($self) = @_;
    return Dumper($self);
  }
</pre>
<p class="Pp">When writing your own object class, you can then import
    <span class="Li">&quot;dump&quot;</span> to be used as a method, called like
    so:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  $object-&gt;dump;
</pre>
<p class="Pp">By assuming that the importing class will provide a certain
    interface, a method-exporting module can be used as a simple plugin:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  package Number::Plugin::Upto;
  use Sub::Exporter -setup =&gt; {
    into    =&gt; 'Number',
    exports =&gt; [ qw(upto) ],
    groups  =&gt; [ default =&gt; [ qw(upto) ] ],
  };

  sub upto {
    my ($self) = @_;
    return 1 .. abs($self-&gt;as_integer);
  }
</pre>
<p class="Pp">The <span class="Li">&quot;into&quot;</span> line in the
    configuration says that this plugin will export, by default, into the Number
    package, not into the <span class="Li">&quot;use&quot;</span>-ing package.
    It can be exported anyway, though, and will work as long as the destination
    provides an <span class="Li">&quot;as_integer&quot;</span> method like the
    one it expects. To import it to a different destination, one can just
  write:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  use Number::Plugin::Upto { into =&gt; 'Quantity' };
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Mixing-in_Complex_External_Behavior"><a class="permalink" href="#Mixing-in_Complex_External_Behavior">Mixing-in
  Complex External Behavior</a></h2>
When exporting methods to be used as methods (see above), one very powerful
  option is to export methods that are generated routines that maintain an
  enclosed reference to the exporting module. This allows a user to import a
  single method which is implemented in terms of a complete, well-structured
  package.
<p class="Pp">Here is a very small example:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  package Data::Analyzer;

  use Sub::Exporter -setup =&gt; {
    exports =&gt; [ analyze =&gt; \'_generate_analyzer' ],
  };

  sub _generate_analyzer {
    my ($mixin, $name, $arg, $col) = @_;

    return sub {
      my ($self) = @_;

      my $values = [ $self-&gt;values ];

      my $analyzer = $mixin-&gt;new($values);
      $analyzer-&gt;perform_analysis;
      $analyzer-&gt;aggregate_results;

      return $analyzer-&gt;summary;
    };
  }
</pre>
<p class="Pp">If imported by any package providing a
    <span class="Li">&quot;values&quot;</span> method, this plugin will provide
    a single <span class="Li">&quot;analyze&quot;</span> method that acts as a
    simple interface to a more complex set of behaviors.</p>
<p class="Pp">Even more importantly, because the <span class="Li">$mixin</span>
    value will be the invocant on which the
    <span class="Li">&quot;import&quot;</span> was actually called, one can
    subclass <span class="Li">&quot;Data::Analyzer&quot;</span> and replace only
    individual pieces of the complex behavior, making it easy to write complex,
    subclassable toolkits with simple single points of entry for external
    interfaces.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Exporting_Constants"><a class="permalink" href="#Exporting_Constants">Exporting
  Constants</a></h2>
While Sub::Exporter isn't in the constant-exporting business, it's easy to
  export constants by using one of its sister modules, Package::Generator.
<p class="Pp"><span class="Li"></span></p>
<pre>
  package Important::Constants;
 
  use Sub::Exporter -setup =&gt; {
    collectors =&gt; [ constants =&gt; \'_set_constants' ],
  };
 
  sub _set_constants {
    my ($class, $value, $data) = @_;
 
    Package::Generator-&gt;assign_symbols(
      $data-&gt;{into},
      [
        MEANING_OF_LIFE =&gt; \42,
        ONE_TRUE_BASE   =&gt; \13,
        FACTORS         =&gt; [ 6, 9 ],
      ],
    );

    return 1;
  }
</pre>
<p class="Pp">Then, someone can write:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  use Important::Constants 'constants';
  
  print &quot;The factors @FACTORS produce $MEANING_OF_LIFE in $ONE_TRUE_BASE.&quot;;
</pre>
<p class="Pp">(The constants must be exported via a collector, because they are
    effectively altering the importing class in a way other than installing
    subroutines.)</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Altering_the_Importer's_@ISA"><a class="permalink" href="#Altering_the_Importer's_@ISA">Altering
  the Importer's @ISA</a></h2>
It's trivial to make a collector that changes the inheritance of an importing
  package:
<p class="Pp"><span class="Li"></span></p>
<pre>
  use Sub::Exporter -setup =&gt; {
    collectors =&gt; { -base =&gt; \'_make_base' },
  };

  sub _make_base {
    my ($class, $value, $data) = @_;

    my $target = $data-&gt;{into};
    push @{&quot;$target\::ISA&quot;}, $class;
  }
</pre>
<p class="Pp">Then, the user of your class can write:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  use Some::Class -base;
</pre>
<p class="Pp">and become a subclass. This can be quite useful in building, for
    example, a module that helps build plugins. We may want a few utilities
    imported, but we also want to inherit behavior from some base plugin
  class;</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  package Framework::Util;

  use Sub::Exporter -setup =&gt; {
    exports    =&gt; [ qw(log global_config) ],
    groups     =&gt; [ _plugin =&gt; [ qw(log global_config) ]
    collectors =&gt; { '-plugin' =&gt; \'_become_plugin' },
  };

  sub _become_plugin {
    my ($class, $value, $data) = @_;

    my $target = $data-&gt;{into};
    push @{&quot;$target\::ISA&quot;}, $class-&gt;plugin_base_class;

    push @{ $data-&gt;{import_args} }, '-_plugin';
  }
</pre>
<p class="Pp">Now, you can write a plugin like this:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  package Framework::Plugin::AirFreshener;
  use Framework::Util -plugin;
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Eating_Exporter.pm's_Brain"><a class="permalink" href="#Eating_Exporter.pm's_Brain">Eating
  Exporter.pm's Brain</a></h2>
You probably shouldn't actually do this in production. It's offered more as a
  demonstration than a suggestion.
<p class="Pp"><span class="Li"></span></p>
<pre>
 sub exporter_upgrade {
   my ($pkg) = @_;
   my $new_pkg = &quot;$pkg\::UsingSubExporter&quot;;

   return $new_pkg if $new_pkg-&gt;isa($pkg);

   Sub::Exporter::setup_exporter({
     as      =&gt; 'import',
     into    =&gt; $new_pkg,
     exports =&gt; [ @{&quot;$pkg\::EXPORT_OK&quot;} ],
     groups  =&gt; {
       %{&quot;$pkg\::EXPORT_TAG&quot;},
       default =&gt; [ @{&quot;$pkg\::EXPORTS&quot;} ],
     },
   });

   @{&quot;$new_pkg\::ISA&quot;} = $pkg;
   return $new_pkg;
 }
</pre>
<p class="Pp">This routine, given the name of an existing package configured to
    use Exporter.pm, returns the name of a new package with a
    Sub::Exporter-powered <span class="Li">&quot;import&quot;</span> routine.
    This lets you import
    <span class="Li">&quot;Toolkit::exported_sub&quot;</span> into the current
    package with the name <span class="Li">&quot;foo&quot;</span> by
  writing:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  BEGIN {
    require Toolkit;
    exporter_upgrade('Toolkit')-&gt;import(exported_sub =&gt; { -as =&gt; 'foo' })
  }
</pre>
<p class="Pp">If you're feeling particularly naughty, this routine could have
    been declared in the UNIVERSAL package, meaning you could write:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  BEGIN {
    require Toolkit;
    Toolkit-&gt;exporter_upgrade-&gt;import(exported_sub =&gt; { -as =&gt; 'foo' })
  }
</pre>
<p class="Pp">The new package will have all the same exporter configuration as
    the original, but will support export and group renaming, including
    exporting into scalar references. Further, since Sub::Exporter uses
    <span class="Li">&quot;can&quot;</span> to find the routine being exported,
    the new package may be subclassed and some of its exports replaced.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
Ricardo Signes &lt;rjbs@cpan.org&gt;
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT_AND_LICENSE"><a class="permalink" href="#COPYRIGHT_AND_LICENSE">COPYRIGHT
  AND LICENSE</a></h1>
This software is copyright (c) 2007 by Ricardo Signes.
<p class="Pp">This is free software; you can redistribute it and/or modify it
    under the same terms as the Perl 5 programming language system itself.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2013-10-18</td>
    <td class="foot-os">perl v5.28.2</td>
  </tr>
</table>
</body>
</html>
