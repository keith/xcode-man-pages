<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    .Nd, .Bf, .Op { display: inline; }
    .Pa, .Ad { font-style: italic; }
    .Ms { font-weight: bold; }
    .Bl-diag > dt { font-weight: bold; }
    code.Nm, .Fl, .Cm, .Ic, code.In, .Fd, .Fn, .Cd { font-weight: bold;
      font-family: inherit; }
  </style>
  <title>PERLOBJ(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">PERLOBJ(1)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">PERLOBJ(1)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">perlobj - Perl object reference</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">This document provides a reference for Perl's object orientation
    features. If you're looking for an introduction to object-oriented
    programming in Perl, please see perlootut.</p>
<p class="Pp">In order to understand Perl objects, you first need to understand
    references in Perl. See perlref for details.</p>
<p class="Pp">This document describes all of Perl's object-oriented (OO)
    features from the ground up. If you're just looking to write some
    object-oriented code of your own, you are probably better served by using
    one of the object systems from CPAN described in perlootut.</p>
<p class="Pp">If you're looking to write your own object system, or you need to
    maintain code which implements objects from scratch then this document will
    help you understand exactly how Perl does object orientation.</p>
<p class="Pp">There are a few basic principles which define object oriented
    Perl:</p>
<dl class="Bl-tag">
  <dt>1.</dt>
  <dd>An object is simply a data structure that knows to which class it
    belongs.</dd>
  <dt>2.</dt>
  <dd>A class is simply a package. A class provides methods that expect to
      operate on objects.</dd>
  <dt>3.</dt>
  <dd>A method is simply a subroutine that expects a reference to an object (or
      a package name, for class methods) as the first argument.</dd>
</dl>
<p class="Pp">Let's look at each of these principles in depth.</p>
<section class="Ss">
<h2 class="Ss" id="An_Object_is_Simply_a_Data_Structure"><a class="permalink" href="#An_Object_is_Simply_a_Data_Structure">An
  Object is Simply a Data Structure</a></h2>
<p class="Pp">Unlike many other languages which support object orientation, Perl
    does not provide any special syntax for constructing an object. Objects are
    merely Perl data structures (hashes, arrays, scalars, filehandles, etc.)
    that have been explicitly associated with a particular class.</p>
<p class="Pp">That explicit association is created by the built-in
    <span class="Li">&quot;bless&quot;</span> function, which is typically used
    within the <i>constructor</i> subroutine of the class.</p>
<p class="Pp">Here is a simple constructor:</p>
<p class="Pp"></p>
<pre>  package File;
  sub new {
      my $class = shift;
      return bless {}, $class;
  }
</pre>
<p class="Pp">The name <span class="Li">&quot;new&quot;</span> isn't special. We
    could name our constructor something else:</p>
<p class="Pp"></p>
<pre>  package File;
  sub load {
      my $class = shift;
      return bless {}, $class;
  }
</pre>
<p class="Pp">The modern convention for OO modules is to always use
    <span class="Li">&quot;new&quot;</span> as the name for the constructor, but
    there is no requirement to do so. Any subroutine that blesses a data
    structure into a class is a valid constructor in Perl.</p>
<p class="Pp">In the previous examples, the
    <span class="Li">&quot;{}&quot;</span> code creates a reference to an empty
    anonymous hash. The <span class="Li">&quot;bless&quot;</span> function then
    takes that reference and associates the hash with the class in
    <span class="Li">$class</span>. In the simplest case, the
    <span class="Li">$class</span> variable will end up containing the string
    &quot;File&quot;.</p>
<p class="Pp">We can also use a variable to store a reference to the data
    structure that is being blessed as our object:</p>
<p class="Pp"></p>
<pre>  sub new {
      my $class = shift;
      my $self = {};
      bless $self, $class;
      return $self;
  }
</pre>
<p class="Pp">Once we've blessed the hash referred to by
    <span class="Li">$self</span> we can start calling methods on it. This is
    useful if you want to put object initialization in its own separate
  method:</p>
<p class="Pp"></p>
<pre>  sub new {
      my $class = shift;
      my $self = {};
      bless $self, $class;
      $self-&gt;_initialize();
      return $self;
  }
</pre>
<p class="Pp">Since the object is also a hash, you can treat it as one, using it
    to store data associated with the object. Typically, code inside the class
    can treat the hash as an accessible data structure, while code outside the
    class should always treat the object as opaque. This is called
    <b>encapsulation</b>. Encapsulation means that the user of an object does
    not have to know how it is implemented. The user simply calls documented
    methods on the object.</p>
<p class="Pp">Note, however, that (unlike most other OO languages) Perl does not
    ensure or enforce encapsulation in any way. If you want objects to actually
    <i>be</i> opaque you need to arrange for that yourself. This can be done in
    a varierty of ways, including using &quot;Inside-Out objects&quot; or
    modules from CPAN.</p>
<p class="Pp"><i>Objects Are Blessed; Variables Are Not</i></p>
<p class="Pp">When we bless something, we are not blessing the variable which
    contains a reference to that thing, nor are we blessing the reference that
    the variable stores; we are blessing the thing that the variable refers to
    (sometimes known as the <i>referent</i>). This is best demonstrated with
    this code:</p>
<p class="Pp"></p>
<pre>  use Scalar::Util 'blessed';
  my $foo = {};
  my $bar = $foo;
  bless $foo, 'Class';
  print blessed( $bar );      # prints &quot;Class&quot;
  $bar = &quot;some other value&quot;;
  print blessed( $bar );      # prints undef
</pre>
<p class="Pp">When we call <span class="Li">&quot;bless&quot;</span> on a
    variable, we are actually blessing the underlying data structure that the
    variable refers to. We are not blessing the reference itself, nor the
    variable that contains that reference. That's why the second call to
    <span class="Li">&quot;blessed( $bar )&quot;</span> returns false. At that
    point <span class="Li">$bar</span> is no longer storing a reference to an
    object.</p>
<p class="Pp">You will sometimes see older books or documentation mention
    &quot;blessing a reference&quot; or describe an object as a &quot;blessed
    reference&quot;, but this is incorrect. It isn't the reference that is
    blessed as an object; it's the thing the reference refers to (i.e. the
    referent).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="A_Class_is_Simply_a_Package"><a class="permalink" href="#A_Class_is_Simply_a_Package">A
  Class is Simply a Package</a></h2>
<p class="Pp">Perl does not provide any special syntax for class definitions. A
    package is simply a namespace containing variables and subroutines. The only
    difference is that in a class, the subroutines may expect a reference to an
    object or the name of a class as the first argument. This is purely a matter
    of convention, so a class may contain both methods and subroutines which
    <i>don't</i> operate on an object or class.</p>
<p class="Pp">Each package contains a special array called
    <span class="Li">@ISA</span>. The <span class="Li">@ISA</span> array
    contains a list of that class's parent classes, if any. This array is
    examined when Perl does method resolution, which we will cover later.</p>
<p class="Pp">It is possible to manually set <span class="Li">@ISA</span>, and
    you may see this in older Perl code. Much older code also uses the base
    pragma. For new code, we recommend that you use the parent pragma to declare
    your parents. This pragma will take care of setting
    <span class="Li">@ISA</span>. It will also load the parent classes and make
    sure that the package doesn't inherit from itself.</p>
<p class="Pp">However the parent classes are set, the package's
    <span class="Li">@ISA</span> variable will contain a list of those parents.
    This is simply a list of scalars, each of which is a string that corresponds
    to a package name.</p>
<p class="Pp">All classes inherit from the UNIVERSAL class implicitly. The
    UNIVERSAL class is implemented by the Perl core, and provides several
    default methods, such as <span class="Li">&quot;isa()&quot;</span>,
    <span class="Li">&quot;can()&quot;</span>, and
    <span class="Li">&quot;VERSION()&quot;</span>. The
    <span class="Li">&quot;UNIVERSAL&quot;</span> class will <i>never</i> appear
    in a package's <span class="Li">@ISA</span> variable.</p>
<p class="Pp">Perl <i>only</i> provides method inheritance as a built-in
    feature. Attribute inheritance is left up the class to implement. See the
    &quot;Writing Accessors&quot; section for details.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="A_Method_is_Simply_a_Subroutine"><a class="permalink" href="#A_Method_is_Simply_a_Subroutine">A
  Method is Simply a Subroutine</a></h2>
<p class="Pp">Perl does not provide any special syntax for defining a method. A
    method is simply a regular subroutine, and is declared with
    <span class="Li">&quot;sub&quot;</span>. What makes a method special is that
    it expects to receive either an object or a class name as its first
    argument.</p>
<p class="Pp">Perl <i>does</i> provide special syntax for method invocation, the
    <span class="Li">&quot;-&gt;&quot;</span> operator. We will cover this in
    more detail later.</p>
<p class="Pp">Most methods you write will expect to operate on objects:</p>
<p class="Pp"></p>
<pre>  sub save {
      my $self = shift;
      open my $fh, '&gt;', $self-&gt;path() or die $!;
      print {$fh} $self-&gt;data()       or die $!;
      close $fh                       or die $!;
  }
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Method_Invocation"><a class="permalink" href="#Method_Invocation">Method
  Invocation</a></h2>
<p class="Pp">Calling a method on an object is written as
    <span class="Li">&quot;$object-&gt;method&quot;</span>.</p>
<p class="Pp">The left hand side of the method invocation (or arrow) operator is
    the object (or class name), and the right hand side is the method name.</p>
<p class="Pp"></p>
<pre>  my $pod = File-&gt;new( 'perlobj.pod', $data );
  $pod-&gt;save();
</pre>
<p class="Pp">The <span class="Li">&quot;-&gt;&quot;</span> syntax is also used
    when dereferencing a reference. It looks like the same operator, but these
    are two different operations.</p>
<p class="Pp">When you call a method, the thing on the left side of the arrow is
    passed as the first argument to the method. That means when we call
    <span class="Li">&quot;Critter-&gt;new()&quot;</span>, the
    <span class="Li">&quot;new()&quot;</span> method receives the string
    <span class="Li">&quot;Critter&quot;</span> as its first argument. When we
    call <span class="Li">&quot;$fred-&gt;speak()&quot;</span>, the
    <span class="Li">$fred</span> variable is passed as the first argument to
    <span class="Li">&quot;speak()&quot;</span>.</p>
<p class="Pp">Just as with any Perl subroutine, all of the arguments passed in
    <span class="Li">@_</span> are aliases to the original argument. This
    includes the object itself. If you assign directly to
    <span class="Li">$_[0]</span> you will change the contents of the variable
    that holds the reference to the object. We recommend that you don't do this
    unless you know exactly what you're doing.</p>
<p class="Pp">Perl knows what package the method is in by looking at the left
    side of the arrow. If the left hand side is a package name, it looks for the
    method in that package. If the left hand side is an object, then Perl looks
    for the method in the package that the object has been blessed into.</p>
<p class="Pp">If the left hand side is neither a package name nor an object,
    then the method call will cause an error, but see the section on
    &quot;Method Call Variations&quot; for more nuances.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Inheritance"><a class="permalink" href="#Inheritance">Inheritance</a></h2>
<p class="Pp">We already talked about the special <span class="Li">@ISA</span>
    array and the parent pragma.</p>
<p class="Pp">When a class inherits from another class, any methods defined in
    the parent class are available to the child class. If you attempt to call a
    method on an object that isn't defined in its own class, Perl will also look
    for that method in any parent classes it may have.</p>
<p class="Pp"></p>
<pre>  package File::MP3;
  use parent 'File';    # sets @File::MP3::ISA = ('File');
  my $mp3 = File::MP3-&gt;new( 'Andvari.mp3', $data );
  $mp3-&gt;save();
</pre>
<p class="Pp">Since we didn't define a
    <span class="Li">&quot;save()&quot;</span> method in the
    <span class="Li">&quot;File::MP3&quot;</span> class, Perl will look at the
    <span class="Li">&quot;File::MP3&quot;</span> class's parent classes to find
    the <span class="Li">&quot;save()&quot;</span> method. If Perl cannot find a
    <span class="Li">&quot;save()&quot;</span> method anywhere in the
    inheritance hierarchy, it will die.</p>
<p class="Pp">In this case, it finds a
    <span class="Li">&quot;save()&quot;</span> method in the
    <span class="Li">&quot;File&quot;</span> class. Note that the object passed
    to <span class="Li">&quot;save()&quot;</span> in this case is still a
    <span class="Li">&quot;File::MP3&quot;</span> object, even though the method
    is found in the <span class="Li">&quot;File&quot;</span> class.</p>
<p class="Pp">We can override a parent's method in a child class. When we do so,
    we can still call the parent class's method with the
    <span class="Li">&quot;SUPER&quot;</span> pseudo-class.</p>
<p class="Pp"></p>
<pre>  sub save {
      my $self = shift;
      say 'Prepare to rock';
      $self-&gt;SUPER::save();
  }
</pre>
<p class="Pp">The <span class="Li">&quot;SUPER&quot;</span> modifier can
    <i>only</i> be used for method calls. You can't use it for regular
    subroutine calls or class methods:</p>
<p class="Pp"></p>
<pre>  SUPER::save($thing);     # FAIL: looks for save() sub in package SUPER
  SUPER-&gt;save($thing);     # FAIL: looks for save() method in class
                           #       SUPER
  $thing-&gt;SUPER::save();   # Okay: looks for save() method in parent
                           #       classes
</pre>
<p class="Pp"><i>How SUPER is Resolved</i></p>
<p class="Pp">The <span class="Li">&quot;SUPER&quot;</span> pseudo-class is
    resolved from the package where the call is made. It is <i>not</i> resolved
    based on the object's class. This is important, because it lets methods at
    different levels within a deep inheritance hierarchy each correctly call
    their respective parent methods.</p>
<p class="Pp"></p>
<pre>  package A;
  sub new {
      return bless {}, shift;
  }
  sub speak {
      my $self = shift;
      say 'A';
  }
  package B;
  use parent -norequire, 'A';
  sub speak {
      my $self = shift;
      $self-&gt;SUPER::speak();
      say 'B';
  }
  package C;
  use parent -norequire, 'B';
  sub speak {
      my $self = shift;
      $self-&gt;SUPER::speak();
      say 'C';
  }
  my $c = C-&gt;new();
  $c-&gt;speak();
</pre>
<p class="Pp">In this example, we will get the following output:</p>
<p class="Pp"></p>
<pre>  A
  B
  C
</pre>
<p class="Pp">This demonstrates how <span class="Li">&quot;SUPER&quot;</span> is
    resolved. Even though the object is blessed into the
    <span class="Li">&quot;C&quot;</span> class, the
    <span class="Li">&quot;speak()&quot;</span> method in the
    <span class="Li">&quot;B&quot;</span> class can still call
    <span class="Li">&quot;SUPER::speak()&quot;</span> and expect it to
    correctly look in the parent class of <span class="Li">&quot;B&quot;</span>
    (i.e the class the method call is in), not in the parent class of
    <span class="Li">&quot;C&quot;</span> (i.e. the class the object belongs
    to).</p>
<p class="Pp">There are rare cases where this package-based resolution can be a
    problem. If you copy a subroutine from one package to another,
    <span class="Li">&quot;SUPER&quot;</span> resolution will be done based on
    the original package.</p>
<p class="Pp"><i>Multiple Inheritance</i></p>
<p class="Pp">Multiple inheritance often indicates a design problem, but Perl
    always gives you enough rope to hang yourself with if you ask for it.</p>
<p class="Pp">To declare multiple parents, you simply need to pass multiple
    class names to <span class="Li">&quot;use parent&quot;</span>:</p>
<p class="Pp"></p>
<pre>  package MultiChild;
  use parent 'Parent1', 'Parent2';
</pre>
<p class="Pp"><i>Method Resolution Order</i></p>
<p class="Pp">Method resolution order only matters in the case of multiple
    inheritance. In the case of single inheritance, Perl simply looks up the
    inheritance chain to find a method:</p>
<p class="Pp"></p>
<pre>  Grandparent
    |
  Parent
    |
  Child
</pre>
<p class="Pp">If we call a method on a <span class="Li">&quot;Child&quot;</span>
    object and that method is not defined in the
    <span class="Li">&quot;Child&quot;</span> class, Perl will look for that
    method in the <span class="Li">&quot;Parent&quot;</span> class and then, if
    necessary, in the <span class="Li">&quot;Grandparent&quot;</span> class.</p>
<p class="Pp">If Perl cannot find the method in any of these classes, it will
    die with an error message.</p>
<p class="Pp">When a class has multiple parents, the method lookup order becomes
    more complicated.</p>
<p class="Pp">By default, Perl does a depth-first left-to-right search for a
    method. That means it starts with the first parent in the
    <span class="Li">@ISA</span> array, and then searches all of its parents,
    grandparents, etc. If it fails to find the method, it then goes to the next
    parent in the original class's <span class="Li">@ISA</span> array and
    searches from there.</p>
<p class="Pp"></p>
<pre>            SharedGreatGrandParent
            /                    \
  PaternalGrandparent       MaternalGrandparent
            \                    /
             Father        Mother
                   \      /
                    Child
</pre>
<p class="Pp">So given the diagram above, Perl will search
    <span class="Li">&quot;Child&quot;</span>,
    <span class="Li">&quot;Father&quot;</span>,
    <span class="Li">&quot;PaternalGrandparent&quot;</span>,
    <span class="Li">&quot;SharedGreatGrandParent&quot;</span>,
    <span class="Li">&quot;Mother&quot;</span>, and finally
    <span class="Li">&quot;MaternalGrandparent&quot;</span>. This may be a
    problem because now we're looking in
    <span class="Li">&quot;SharedGreatGrandParent&quot;</span> <i>before</i>
    we've checked all its derived classes (i.e. before we tried
    <span class="Li">&quot;Mother&quot;</span> and
    <span class="Li">&quot;MaternalGrandparent&quot;</span>).</p>
<p class="Pp">It is possible to ask for a different method resolution order with
    the mro pragma.</p>
<p class="Pp"></p>
<pre>  package Child;
  use mro 'c3';
  use parent 'Father', 'Mother';
</pre>
<p class="Pp">This pragma lets you switch to the &quot;C3&quot; resolution
    order. In simple terms, &quot;C3&quot; order ensures that shared parent
    classes are never searched before child classes, so Perl will now search:
    <span class="Li">&quot;Child&quot;</span>,
    <span class="Li">&quot;Father&quot;</span>,
    <span class="Li">&quot;PaternalGrandparent&quot;</span>,
    <span class="Li">&quot;Mother&quot;</span>
    <span class="Li">&quot;MaternalGrandparent&quot;</span>, and finally
    <span class="Li">&quot;SharedGreatGrandParent&quot;</span>. Note however
    that this is not &quot;breadth-first&quot; searching: All the
    <span class="Li">&quot;Father&quot;</span> ancestors (except the common
    ancestor) are searched before any of the
    <span class="Li">&quot;Mother&quot;</span> ancestors are considered.</p>
<p class="Pp">The C3 order also lets you call methods in sibling classes with
    the <span class="Li">&quot;next&quot;</span> pseudo-class. See the mro
    documentation for more details on this feature.</p>
<p class="Pp"><i>Method Resolution Caching</i></p>
<p class="Pp">When Perl searches for a method, it caches the lookup so that
    future calls to the method do not need to search for it again. Changing a
    class's parent class or adding subroutines to a class will invalidate the
    cache for that class.</p>
<p class="Pp">The mro pragma provides some functions for manipulating the method
    cache directly.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Writing_Constructors"><a class="permalink" href="#Writing_Constructors">Writing
  Constructors</a></h2>
<p class="Pp">As we mentioned earlier, Perl provides no special constructor
    syntax. This means that a class must implement its own constructor. A
    constructor is simply a class method that returns a reference to a new
    object.</p>
<p class="Pp">The constructor can also accept additional parameters that define
    the object. Let's write a real constructor for the
    <span class="Li">&quot;File&quot;</span> class we used earlier:</p>
<p class="Pp"></p>
<pre>  package File;
  sub new {
      my $class = shift;
      my ( $path, $data ) = @_;
      my $self = bless {
          path =&gt; $path,
          data =&gt; $data,
      }, $class;
      return $self;
  }
</pre>
<p class="Pp">As you can see, we've stored the path and file data in the object
    itself. Remember, under the hood, this object is still just a hash. Later,
    we'll write accessors to manipulate this data.</p>
<p class="Pp">For our File::MP3 class, we can check to make sure that the path
    we're given ends with &quot;.mp3&quot;:</p>
<p class="Pp"></p>
<pre>  package File::MP3;
  sub new {
      my $class = shift;
      my ( $path, $data ) = @_;
      die &quot;You cannot create a File::MP3 without an mp3 extension\n&quot;
          unless $path =~ /\.mp3\z/;
      return $class-&gt;SUPER::new(@_);
  }
</pre>
<p class="Pp">This constructor lets its parent class do the actual object
    construction.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Attributes"><a class="permalink" href="#Attributes">Attributes</a></h2>
<p class="Pp">An attribute is a piece of data belonging to a particular object.
    Unlike most object-oriented languages, Perl provides no special syntax or
    support for declaring and manipulating attributes.</p>
<p class="Pp">Attributes are often stored in the object itself. For example, if
    the object is an anonymous hash, we can store the attribute values in the
    hash using the attribute name as the key.</p>
<p class="Pp">While it's possible to refer directly to these hash keys outside
    of the class, it's considered a best practice to wrap all access to the
    attribute with accessor methods.</p>
<p class="Pp">This has several advantages. Accessors make it easier to change
    the implementation of an object later while still preserving the original
    API.</p>
<p class="Pp">An accessor lets you add additional code around attribute access.
    For example, you could apply a default to an attribute that wasn't set in
    the constructor, or you could validate that a new value for the attribute is
    acceptable.</p>
<p class="Pp">Finally, using accessors makes inheritance much simpler.
    Subclasses can use the accessors rather than having to know how a parent
    class is implemented internally.</p>
<p class="Pp"><i>Writing Accessors</i></p>
<p class="Pp">As with constructors, Perl provides no special accessor
    declaration syntax, so classes must provide explicitly written accessor
    methods. There are two common types of accessors, read-only and
  read-write.</p>
<p class="Pp">A simple read-only accessor simply gets the value of a single
    attribute:</p>
<p class="Pp"></p>
<pre>  sub path {
      my $self = shift;
      return $self-&gt;{path};
  }
</pre>
<p class="Pp">A read-write accessor will allow the caller to set the value as
    well as get it:</p>
<p class="Pp"></p>
<pre>  sub path {
      my $self = shift;
      if (@_) {
          $self-&gt;{path} = shift;
      }
      return $self-&gt;{path};
  }
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="An_Aside_About_Smarter_and_Safer_Code"><a class="permalink" href="#An_Aside_About_Smarter_and_Safer_Code">An
  Aside About Smarter and Safer Code</a></h2>
<p class="Pp">Our constructor and accessors are not very smart. They don't check
    that a <span class="Li">$path</span> is defined, nor do they check that a
    <span class="Li">$path</span> is a valid filesystem path.</p>
<p class="Pp">Doing these checks by hand can quickly become tedious. Writing a
    bunch of accessors by hand is also incredibly tedious. There are a lot of
    modules on CPAN that can help you write safer and more concise code,
    including the modules we recommend in perlootut.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Method_Call_Variations"><a class="permalink" href="#Method_Call_Variations">Method
  Call Variations</a></h2>
<p class="Pp">Perl supports several other ways to call methods besides the
    <span class="Li">&quot;$object-&gt;method()&quot;</span> usage we've seen so
    far.</p>
<p class="Pp"><i>Method Names as Strings</i></p>
<p class="Pp">Perl lets you use a scalar variable containing a string as a
    method name:</p>
<p class="Pp"></p>
<pre>  my $file = File-&gt;new( $path, $data );
  my $method = 'save';
  $file-&gt;$method();
</pre>
<p class="Pp">This works exactly like calling
    <span class="Li">&quot;$file-&gt;save()&quot;</span>. This can be very
    useful for writing dynamic code. For example, it allows you to pass a method
    name to be called as a parameter to another method.</p>
<p class="Pp"><i>Class Names as Strings</i></p>
<p class="Pp">Perl also lets you use a scalar containing a string as a class
    name:</p>
<p class="Pp"></p>
<pre>  my $class = 'File';
  my $file = $class-&gt;new( $path, $data );
</pre>
<p class="Pp">Again, this allows for very dynamic code.</p>
<p class="Pp"><i>Subroutine References as Methods</i></p>
<p class="Pp">You can also use a subroutine reference as a method:</p>
<p class="Pp"></p>
<pre>  my $sub = sub {
      my $self = shift;
      $self-&gt;save();
  };
  $file-&gt;$sub();
</pre>
<p class="Pp">This is exactly equivalent to writing
    <span class="Li">&quot;$sub-&gt;($file)&quot;</span>. You may see this idiom
    in the wild combined with a call to
  <span class="Li">&quot;can&quot;</span>:</p>
<p class="Pp"></p>
<pre>  if ( my $meth = $object-&gt;can('foo') ) {
      $object-&gt;$meth();
  }
</pre>
<p class="Pp"><i>Deferencing Method Call</i></p>
<p class="Pp">Perl also lets you use a dereferenced scalar reference in a method
    call. That's a mouthful, so let's look at some code:</p>
<p class="Pp"></p>
<pre>  $file-&gt;${ \'save' };
  $file-&gt;${ returns_scalar_ref() };
  $file-&gt;${ \( returns_scalar() ) };
  $file-&gt;${ returns_ref_to_sub_ref() };
</pre>
<p class="Pp">This works if the dereference produces a string <i>or</i> a
    subroutine reference.</p>
<p class="Pp"><i>Method Calls on Filehandles</i></p>
<p class="Pp">Under the hood, Perl filehandles are instances of the
    <span class="Li">&quot;IO::Handle&quot;</span> or
    <span class="Li">&quot;IO::File&quot;</span> class. Once you have an open
    filehandle, you can call methods on it. Additionally, you can call methods
    on the <span class="Li">&quot;STDIN&quot;</span>,
    <span class="Li">&quot;STDOUT&quot;</span>, and
    <span class="Li">&quot;STDERR&quot;</span> filehandles.</p>
<p class="Pp"></p>
<pre>  open my $fh, '&gt;', 'path/to/file';
  $fh-&gt;autoflush();
  $fh-&gt;print('content');
  STDOUT-&gt;autoflush();
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Invoking_Class_Methods"><a class="permalink" href="#Invoking_Class_Methods">Invoking
  Class Methods</a></h2>
<p class="Pp">Because Perl allows you to use barewords for package names and
    subroutine names, it sometimes interprets a bareword's meaning incorrectly.
    For example, the construct
    <span class="Li">&quot;Class-&gt;new()&quot;</span> can be interpreted as
    either <span class="Li">&quot;'Class'-&gt;new()&quot;</span> or
    <span class="Li">&quot;Class()-&gt;new()&quot;</span>. In English, that
    second interpretation reads as &quot;call a subroutine named <i>Class()</i>,
    then call <i>new()</i> as a method on the return value of
    <i>Class()</i>&quot;. If there is a subroutine named
    <span class="Li">&quot;Class()&quot;</span> in the current namespace, Perl
    will always interpret <span class="Li">&quot;Class-&gt;new()&quot;</span> as
    the second alternative: a call to <span class="Li">&quot;new()&quot;</span>
    on the object returned by a call to
    <span class="Li">&quot;Class()&quot;</span></p>
<p class="Pp">You can force Perl to use the first interpretation (i.e. as a
    method call on the class named &quot;Class&quot;) in two ways. First, you
    can append a <span class="Li">&quot;::&quot;</span> to the class name:</p>
<p class="Pp"></p>
<pre>    Class::-&gt;new()
</pre>
<p class="Pp">Perl will always interpret this as a method call.</p>
<p class="Pp">Alternatively, you can quote the class name:</p>
<p class="Pp"></p>
<pre>    'Class'-&gt;new()
</pre>
<p class="Pp">Of course, if the class name is in a scalar Perl will do the right
    thing as well:</p>
<p class="Pp"></p>
<pre>    my $class = 'Class';
    $class-&gt;new();
</pre>
<p class="Pp"><i>Indirect Object Syntax</i></p>
<p class="Pp"><b>Outside of the file handle case, use of this syntax is
    discouraged as</b> <b>it can confuse the Perl interpreter. See below for
    more details.</b></p>
<p class="Pp">Perl suports another method invocation syntax called
    &quot;indirect object&quot; notation. This syntax is called
    &quot;indirect&quot; because the method comes before the object it is being
    invoked on.</p>
<p class="Pp">This syntax can be used with any class or object method:</p>
<p class="Pp"></p>
<pre>    my $file = new File $path, $data;
    save $file;
</pre>
<p class="Pp">We recommend that you avoid this syntax, for several reasons.</p>
<p class="Pp">First, it can be confusing to read. In the above example, it's not
    clear if <span class="Li">&quot;save&quot;</span> is a method provided by
    the <span class="Li">&quot;File&quot;</span> class or simply a subroutine
    that expects a file object as its first argument.</p>
<p class="Pp">When used with class methods, the problem is even worse. Because
    Perl allows subroutine names to be written as barewords, Perl has to guess
    whether the bareword after the method is a class name or subroutine name. In
    other words, Perl can resolve the syntax as either
    <span class="Li">&quot;File-&gt;new( $path, $data )&quot;</span> <b>or</b>
    <span class="Li">&quot;new( File( $path, $data ) )&quot;</span>.</p>
<p class="Pp">To parse this code, Perl uses a heuristic based on what package
    names it has seen, what subroutines exist in the current package, what
    barewords it has previously seen, and other input. Needless to say,
    heuristics can produce very surprising results!</p>
<p class="Pp">Older documentation (and some CPAN modules) encouraged this
    syntax, particularly for constructors, so you may still find it in the wild.
    However, we encourage you to avoid using it in new code.</p>
<p class="Pp">You can force Perl to interpret the bareword as a class name by
    appending &quot;::&quot; to it, like we saw earlier:</p>
<p class="Pp"></p>
<pre>  my $file = new File:: $path, $data;
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="_bless_,__blessed_,_and__ref_"><a class="permalink" href="#_bless_,__blessed_,_and__ref_">&quot;bless&quot;,
  &quot;blessed&quot;, and &quot;ref&quot;</a></h2>
<p class="Pp">As we saw earlier, an object is simply a data structure that has
    been blessed into a class via the <span class="Li">&quot;bless&quot;</span>
    function. The <span class="Li">&quot;bless&quot;</span> function can take
    either one or two arguments:</p>
<p class="Pp"></p>
<pre>  my $object = bless {}, $class;
  my $object = bless {};
</pre>
<p class="Pp">In the first form, the anonymous hash is being blessed into the
    class in <span class="Li">$class</span>. In the second form, the anonymous
    hash is blessed into the current package.</p>
<p class="Pp">The second form is strongly discouraged, because it breaks the
    ability of a subclass to reuse the parent's constructor, but you may still
    run across it in existing code.</p>
<p class="Pp">If you want to know whether a particular scalar refers to an
    object, you can use the <span class="Li">&quot;blessed&quot;</span> function
    exported by Scalar::Util, which is shipped with the Perl core.</p>
<p class="Pp"></p>
<pre>  use Scalar::Util 'blessed';
  if ( defined blessed($thing) ) { ... }
</pre>
<p class="Pp">If <span class="Li">$thing</span> refers to an object, then this
    function returns the name of the package the object has been blessed into.
    If <span class="Li">$thing</span> doesn't contain a reference to a blessed
    object, the <span class="Li">&quot;blessed&quot;</span> function returns
    <span class="Li">&quot;undef&quot;</span>.</p>
<p class="Pp">Note that <span class="Li">&quot;blessed($thing)&quot;</span> will
    also return false if <span class="Li">$thing</span> has been blessed into a
    class named &quot;0&quot;. This is a possible, but quite pathological. Don't
    create a class named &quot;0&quot; unless you know what you're doing.</p>
<p class="Pp">Similarly, Perl's built-in <span class="Li">&quot;ref&quot;</span>
    function treats a reference to a blessed object specially. If you call
    <span class="Li">&quot;ref($thing)&quot;</span> and
    <span class="Li">$thing</span> holds a reference to an object, it will
    return the name of the class that the object has been blessed into.</p>
<p class="Pp">If you simply want to check that a variable contains an object
    reference, we recommend that you use <span class="Li">&quot;defined
    blessed($object)&quot;</span>, since <span class="Li">&quot;ref&quot;</span>
    returns true values for all references, not just objects.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="The_"><a class="permalink" href="#The_">The UNIVERSAL
  Class</a></h2>
<p class="Pp">All classes automatically inherit from the UNIVERSAL class, which
    is built-in to the Perl core. This class provides a number of methods, all
    of which can be called on either a class or an object. You can also choose
    to override some of these methods in your class. If you do so, we recommend
    that you follow the built-in semantics described below.</p>
<dl class="Bl-tag">
  <dt id="isa($class)"><a class="permalink" href="#isa($class)">isa($class)</a></dt>
  <dd>The <span class="Li">&quot;isa&quot;</span> method returns <i>true</i> if
      the object is a member of the class in <span class="Li">$class</span>, or
      a member of a subclass of <span class="Li">$class</span>.
    <p class="Pp">If you override this method, it should never throw an
        exception.</p>
  </dd>
  <dt id="DOES"><a class="permalink" href="#DOES">DOES($role)</a></dt>
  <dd>The <span class="Li">&quot;DOES&quot;</span> method returns <i>true</i> if
      its object claims to perform the role <span class="Li">$role</span>. By
      default, this is equivalent to <span class="Li">&quot;isa&quot;</span>.
      This method is provided for use by object system extensions that implement
      roles, like <span class="Li">&quot;Moose&quot;</span> and
      <span class="Li">&quot;Role::Tiny&quot;</span>.
    <p class="Pp">You can also override <span class="Li">&quot;DOES&quot;</span>
        directly in your own classes. If you override this method, it should
        never throw an exception.</p>
  </dd>
  <dt id="can($method)"><a class="permalink" href="#can($method)">can($method)</a></dt>
  <dd>The <span class="Li">&quot;can&quot;</span> method checks to see if the
      class or object it was called on has a method named
      <span class="Li">$method</span>. This checks for the method in the class
      and all of its parents. If the method exists, then a reference to the
      subroutine is returned. If it does not then
      <span class="Li">&quot;undef&quot;</span> is returned.
    <p class="Pp">If your class responds to method calls via
        <span class="Li">&quot;AUTOLOAD&quot;</span>, you may want to overload
        <span class="Li">&quot;can&quot;</span> to return a subroutine reference
        for methods which your <span class="Li">&quot;AUTOLOAD&quot;</span>
        method handles.</p>
    <p class="Pp">If you override this method, it should never throw an
        exception.</p>
  </dd>
  <dt id="VERSION"><a class="permalink" href="#VERSION">VERSION($need)</a></dt>
  <dd>The <span class="Li">&quot;VERSION&quot;</span> method returns the version
      number of the class (package).
    <p class="Pp">If the <span class="Li">$need</span> argument is given then it
        will check that the current version (as defined by the
        <span class="Li">$VERSION</span> variable in the package) is greater
        than or equal to <span class="Li">$need</span>; it will die if this is
        not the case. This method is called automatically by the
        <span class="Li">&quot;VERSION&quot;</span> form of
        <span class="Li">&quot;use&quot;</span>.</p>
    <p class="Pp"></p>
    <pre>    use Package 1.2 qw(some imported subs);
    # implies:
    Package-&gt;VERSION(1.2);
    </pre>
    <p class="Pp">We recommend that you use this method to access another
        package's version, rather than looking directly at
        <span class="Li">$Package::VERSION</span>. The package you are looking
        at could have overridden the <span class="Li">&quot;VERSION&quot;</span>
        method.</p>
    <p class="Pp">We also recommend using this method to check whether a module
        has a sufficient version. The internal implementation uses the version
        module to make sure that different types of version numbers are compared
        correctly.</p>
  </dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss">AUTOLOAD </h2>
<p class="Pp">If you call a method that doesn't exist in a class, Perl will
    throw an error. However, if that class or any of its parent classes defines
    an <span class="Li">&quot;AUTOLOAD&quot;</span> method, that
    <span class="Li">&quot;AUTOLOAD&quot;</span> method is called instead.</p>
<p class="Pp"><span class="Li">&quot;AUTOLOAD&quot;</span> is called as a
    regular method, and the caller will not know the difference. Whatever value
    your <span class="Li">&quot;AUTOLOAD&quot;</span> method returns is returned
    to the caller.</p>
<p class="Pp">The fully qualified method name that was called is available in
    the <span class="Li">$AUTOLOAD</span> package global for your class. Since
    this is a global, if you want to refer to do it without a package name
    prefix under <span class="Li">&quot;strict</span>
    <span class="Li">'vars'&quot;</span>, you need to declare it.</p>
<p class="Pp"></p>
<pre>  # XXX - this is a terrible way to implement accessors, but it makes
  # for a simple example.
  our $AUTOLOAD;
  sub AUTOLOAD {
      my $self = shift;
      # Remove qualifier from original method name...
      my $called =  $AUTOLOAD =~ s/.*:://r;
      # Is there an attribute of that name?
      die &quot;No such attribute: $called&quot;
          unless exists $self-&gt;{$called};
      # If so, return it...
      return $self-&gt;{$called};
  }
  sub DESTROY { } # see below
</pre>
<p class="Pp">Without the <span class="Li">&quot;our $AUTOLOAD&quot;</span>
    declaration, this code will not compile under the strict pragma.</p>
<p class="Pp">As the comment says, this is not a good way to implement
    accessors. It's slow and too clever by far. However, you may see this as a
    way to provide accessors in older Perl code. See perlootut for
    recommendations on OO coding in Perl.</p>
<p class="Pp">If your class does have an
    <span class="Li">&quot;AUTOLOAD&quot;</span> method, we strongly recommend
    that you override <span class="Li">&quot;can&quot;</span> in your class as
    well. Your overridden <span class="Li">&quot;can&quot;</span> method should
    return a subroutine reference for any method that your
    <span class="Li">&quot;AUTOLOAD&quot;</span> responds to.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Destructors"><a class="permalink" href="#Destructors">Destructors</a></h2>
<p class="Pp">When the last reference to an object goes away, the object is
    destroyed. If you only have one reference to an object stored in a lexical
    scalar, the object is destroyed when that scalar goes out of scope. If you
    store the object in a package global, that object may not go out of scope
    until the program exits.</p>
<p class="Pp">If you want to do something when the object is destroyed, you can
    define a <span class="Li">&quot;DESTROY&quot;</span> method in your class.
    This method will always be called by Perl at the appropriate time, unless
    the method is empty.</p>
<p class="Pp">This is called just like any other method, with the object as the
    first argument. It does not receive any additional arguments. However, the
    <span class="Li">$_[0]</span> variable will be read-only in the destructor,
    so you cannot assign a value to it.</p>
<p class="Pp">If your <span class="Li">&quot;DESTROY&quot;</span> method throws
    an error, this error will be ignored. It will not be sent to
    <span class="Li">&quot;STDERR&quot;</span> and it will not cause the program
    to die. However, if your destructor is running inside an
    <span class="Li">&quot;eval {}&quot;</span> block, then the error will
    change the value of <span class="Li">$@</span>.</p>
<p class="Pp">Because <span class="Li">&quot;DESTROY&quot;</span> methods can be
    called at any time, you should localize any global variables you might
    update in your <span class="Li">&quot;DESTROY&quot;</span>. In particular,
    if you use <span class="Li">&quot;eval {}&quot;</span> you should localize
    <span class="Li">$@</span>, and if you use
    <span class="Li">&quot;system&quot;</span> or backticks you should localize
    <span class="Li">$?</span>.</p>
<p class="Pp">If you define an <span class="Li">&quot;AUTOLOAD&quot;</span> in
    your class, then Perl will call your
    <span class="Li">&quot;AUTOLOAD&quot;</span> to handle the
    <span class="Li">&quot;DESTROY&quot;</span> method. You can prevent this by
    defining an empty <span class="Li">&quot;DESTROY&quot;</span>, like we did
    in the autoloading example. You can also check the value of
    <span class="Li">$AUTOLOAD</span> and return without doing anything when
    called to handle <span class="Li">&quot;DESTROY&quot;</span>.</p>
<p class="Pp"><i>Global Destruction</i></p>
<p class="Pp">The order in which objects are destroyed during the global
    destruction before the program exits is unpredictable. This means that any
    objects contained by your object may already have been destroyed. You should
    check that a contained object is defined before calling a method on it:</p>
<p class="Pp"></p>
<pre>  sub DESTROY {
      my $self = shift;
      $self-&gt;{handle}-&gt;close() if $self-&gt;{handle};
  }
</pre>
<p class="Pp">You can use the
    <span class="Li">&quot;${^GLOBAL_PHASE}&quot;</span> variable to detect if
    you are currently in the global destruction phase:</p>
<p class="Pp"></p>
<pre>  sub DESTROY {
      my $self = shift;
      return if ${^GLOBAL_PHASE} eq 'DESTRUCT';
      $self-&gt;{handle}-&gt;close();
  }
</pre>
<p class="Pp">Note that this variable was added in Perl 5.14.0. If you want to
    detect the global destruction phase on older versions of Perl, you can use
    the <span class="Li">&quot;Devel::GlobalDestruction&quot;</span> module on
    CPAN.</p>
<p class="Pp">If your <span class="Li">&quot;DESTROY&quot;</span> method issues
    a warning during global destruction, the Perl interpreter will append the
    string &quot; during global destruction&quot; the warning.</p>
<p class="Pp">During global destruction, Perl will always garbage collect
    objects before unblessed references. See &quot;PERL_DESTRUCT_LEVEL&quot; in
    perlhacktips for more information about global destruction.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Non-Hash_Objects"><a class="permalink" href="#Non-Hash_Objects">Non-Hash
  Objects</a></h2>
<p class="Pp">All the examples so far have shown objects based on a blessed
    hash. However, it's possible to bless any type of data structure or
    referent, including scalars, globs, and subroutines. You may see this sort
    of thing when looking at code in the wild.</p>
<p class="Pp">Here's an example of a module as a blessed scalar:</p>
<p class="Pp"></p>
<pre>  package Time;
  use strict;
  use warnings;
  sub new {
      my $class = shift;
      my $time = time;
      return bless \$time, $class;
  }
  sub epoch {
      my $self = shift;
      return ${ $self };
  }
  my $time = Time-&gt;new();
  print $time-&gt;epoch();
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Inside-Out_objects"><a class="permalink" href="#Inside-Out_objects">Inside-Out
  objects</a></h2>
<p class="Pp">In the past, the Perl community experimented with a technique
    called &quot;inside-out objects&quot;. An inside-out object stores its data
    outside of the object's reference, indexed on a unique property of the
    object, such as its memory address, rather than in the object itself. This
    has the advantage of enforcing the encapsulation of object attributes, since
    their data is not stored in the object itself.</p>
<p class="Pp">This technique was popular for a while (and was recommended in
    Damian Conway's <i>Perl Best Practices</i>), but never achieved universal
    adoption. The Object::InsideOut module on CPAN provides a comprehensive
    implementation of this technique, and you may see it or other inside-out
    modules in the wild.</p>
<p class="Pp">Here is a simple example of the technique, using the
    Hash::Util::FieldHash core module. This module was added to the core to
    support inside-out object implementations.</p>
<p class="Pp"></p>
<pre>  package Time;
  use strict;
  use warnings;
  use Hash::Util::FieldHash 'fieldhash';
  fieldhash my %time_for;
  sub new {
      my $class = shift;
      my $self = bless \( my $object ), $class;
      $time_for{$self} = time;
      return $self;
  }
  sub epoch {
      my $self = shift;
      return $time_for{$self};
  }
  my $time = Time-&gt;new;
  print $time-&gt;epoch;
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Pseudo-hashes"><a class="permalink" href="#Pseudo-hashes">Pseudo-hashes</a></h2>
<p class="Pp">The pseudo-hash feature was an experimental feature introduced in
    earlier versions of Perl and removed in 5.10.0. A pseudo-hash is an array
    reference which can be accessed using named keys like a hash. You may run in
    to some code in the wild which uses it. See the fields pragma for more
    information.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp">A kinder, gentler tutorial on object-oriented programming in Perl
    can be found in perlootut. You should also check out perlmodlib for some
    style guides on constructing both modules and classes.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2014-09-30</td>
    <td class="foot-os">perl v5.18.4</td>
  </tr>
</table>
</body>
</html>
