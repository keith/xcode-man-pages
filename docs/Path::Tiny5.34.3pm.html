<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    .Nd, .Bf, .Op { display: inline; }
    .Pa, .Ad { font-style: italic; }
    .Ms { font-weight: bold; }
    .Bl-diag > dt { font-weight: bold; }
    code.Nm, .Fl, .Cm, .Ic, code.In, .Fd, .Fn, .Cd { font-weight: bold;
      font-family: inherit; }
  </style>
  <title>Path::Tiny(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Path::Tiny(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Path::Tiny(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Path::Tiny - File path utility</p>
</section>
<section class="Sh">
<h1 class="Sh" id="VERSION"><a class="permalink" href="#VERSION">VERSION</a></h1>
<p class="Pp">version 0.114</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>  use Path::Tiny;
  # creating Path::Tiny objects
  $dir = path(&quot;/tmp&quot;);
  $foo = path(&quot;foo.txt&quot;);
  $subdir = $dir-&gt;child(&quot;foo&quot;);
  $bar = $subdir-&gt;child(&quot;bar.txt&quot;);
  # stringifies as cleaned up path
  $file = path(&quot;./foo.txt&quot;);
  print $file; # &quot;foo.txt&quot;
  # reading files
  $guts = $file-&gt;slurp;
  $guts = $file-&gt;slurp_utf8;
  @lines = $file-&gt;lines;
  @lines = $file-&gt;lines_utf8;
  ($head) = $file-&gt;lines( {count =&gt; 1} );
  ($tail) = $file-&gt;lines( {count =&gt; -1} );
  # writing files
  $bar-&gt;spew( @data );
  $bar-&gt;spew_utf8( @data );
  # reading directories
  for ( $dir-&gt;children ) { ... }
  $iter = $dir-&gt;iterator;
  while ( my $next = $iter-&gt;() ) { ... }
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">This module provides a small, fast utility for working with file
    paths. It is friendlier to use than File::Spec and provides easy access to
    functions from several other core file handling modules. It aims to be
    smaller and faster than many alternatives on CPAN, while helping people do
    many common things in consistent and less error-prone ways.</p>
<p class="Pp">Path::Tiny does not try to work for anything except Unix-like and
    Win32 platforms. Even then, it might break if you try something particularly
    obscure or tortuous. (Quick! What does this mean:
    <span class="Li">&quot;///../../..//./././a//b/.././c/././&quot;</span>? And
    how does it differ on Win32?)</p>
<p class="Pp">All paths are forced to have Unix-style forward slashes.
    Stringifying the object gives you back the path (after some clean up).</p>
<p class="Pp">File input/output methods
    <span class="Li">&quot;flock&quot;</span> handles before reading or writing,
    as appropriate (if supported by the platform and/or filesystem).</p>
<p class="Pp">The <span class="Li">*_utf8</span> methods
    (<span class="Li">&quot;slurp_utf8&quot;</span>,
    <span class="Li">&quot;lines_utf8&quot;</span>, etc.) operate in raw mode.
    On Windows, that means they will not have CRLF translation from the
    <span class="Li">&quot;:crlf&quot;</span> IO layer. Installing Unicode::UTF8
    0.58 or later will speed up <span class="Li">*_utf8</span> situations in
    many cases and is highly recommended. Alternatively, installing
    PerlIO::utf8_strict 0.003 or later will be used in place of the default
    <span class="Li">&quot;:encoding(UTF-8)&quot;</span>.</p>
<p class="Pp">This module depends heavily on PerlIO layers for correct operation
    and thus requires Perl 5.008001 or later.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="CONSTRUCTORS"><a class="permalink" href="#CONSTRUCTORS">CONSTRUCTORS</a></h1>
<section class="Ss">
<h2 class="Ss" id="path"><a class="permalink" href="#path">path</a></h2>
<pre>    $path = path(&quot;foo/bar&quot;);
    $path = path(&quot;/tmp&quot;, &quot;file.txt&quot;); # list
    $path = path(&quot;.&quot;);                # cwd
    $path = path(&quot;~user/file.txt&quot;);   # tilde processing
</pre>
<p class="Pp">Constructs a <span class="Li">&quot;Path::Tiny&quot;</span>
    object. It doesn't matter if you give a file or directory path. It's still
    up to you to call directory-like methods only on directories and file-like
    methods only on files. This function is exported automatically by
  default.</p>
<p class="Pp">The first argument must be defined and have non-zero length or an
    exception will be thrown. This prevents subtle, dangerous errors with code
    like <span class="Li">&quot;path( maybe_undef()
    )-&gt;remove_tree&quot;</span>.</p>
<p class="Pp">If the first component of the path is a tilde ('~') then the
    component will be replaced with the output of
    <span class="Li">&quot;glob('~')&quot;</span>. If the first component of the
    path is a tilde followed by a user name then the component will be replaced
    with output of <span class="Li">&quot;glob('~username')&quot;</span>.
    Behaviour for non-existent users depends on the output of
    <span class="Li">&quot;glob&quot;</span> on the system.</p>
<p class="Pp">On Windows, if the path consists of a drive identifier without a
    path component (<span class="Li">&quot;C:&quot;</span> or
    <span class="Li">&quot;D:&quot;</span>), it will be expanded to the absolute
    path of the current directory on that volume using
    <span class="Li">&quot;Cwd::getdcwd()&quot;</span>.</p>
<p class="Pp">If called with a single
    <span class="Li">&quot;Path::Tiny&quot;</span> argument, the original is
    returned unless the original is holding a temporary file or directory
    reference in which case a stringified copy is made.</p>
<p class="Pp"></p>
<pre>    $path = path(&quot;foo/bar&quot;);
    $temp = Path::Tiny-&gt;tempfile;
    $p2 = path($path); # like $p2 = $path
    $t2 = path($temp); # like $t2 = path( &quot;$temp&quot; )
</pre>
<p class="Pp">This optimizes copies without proliferating references
    unexpectedly if a copy is made by code outside your control.</p>
<p class="Pp">Current API available since 0.017.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="new"><a class="permalink" href="#new">new</a></h2>
<pre>    $path = Path::Tiny-&gt;new(&quot;foo/bar&quot;);
</pre>
<p class="Pp">This is just like <span class="Li">&quot;path&quot;</span>, but
    with method call overhead. (Why would you do that?)</p>
<p class="Pp">Current API available since 0.001.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="cwd"><a class="permalink" href="#cwd">cwd</a></h2>
<pre>    $path = Path::Tiny-&gt;cwd; # path( Cwd::getcwd )
    $path = cwd; # optional export
</pre>
<p class="Pp">Gives you the absolute path to the current directory as a
    <span class="Li">&quot;Path::Tiny&quot;</span> object. This is slightly
    faster than
    <span class="Li">&quot;path(&quot;.&quot;)-&gt;absolute&quot;</span>.</p>
<p class="Pp"><span class="Li">&quot;cwd&quot;</span> may be exported on request
    and used as a function instead of as a method.</p>
<p class="Pp">Current API available since 0.018.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="rootdir"><a class="permalink" href="#rootdir">rootdir</a></h2>
<pre>    $path = Path::Tiny-&gt;rootdir; # /
    $path = rootdir;             # optional export
</pre>
<p class="Pp">Gives you
    <span class="Li">&quot;File::Spec-&gt;rootdir&quot;</span> as a
    <span class="Li">&quot;Path::Tiny&quot;</span> object if you're too picky
    for <span class="Li">&quot;path(&quot;/&quot;)&quot;</span>.</p>
<p class="Pp"><span class="Li">&quot;rootdir&quot;</span> may be exported on
    request and used as a function instead of as a method.</p>
<p class="Pp">Current API available since 0.018.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="tempfile,_tempdir"><a class="permalink" href="#tempfile,_tempdir">tempfile,
  tempdir</a></h2>
<pre>    $temp = Path::Tiny-&gt;tempfile( @options );
    $temp = Path::Tiny-&gt;tempdir( @options );
    $temp = tempfile( @options ); # optional export
    $temp = tempdir( @options );  # optional export
</pre>
<p class="Pp"><span class="Li">&quot;tempfile&quot;</span> passes the options to
    <span class="Li">&quot;File::Temp-&gt;new&quot;</span> and returns a
    <span class="Li">&quot;Path::Tiny&quot;</span> object with the file name.
    The <span class="Li">&quot;TMPDIR&quot;</span> option is enabled by
  default.</p>
<p class="Pp">The resulting <span class="Li">&quot;File::Temp&quot;</span>
    object is cached. When the <span class="Li">&quot;Path::Tiny&quot;</span>
    object is destroyed, the <span class="Li">&quot;File::Temp&quot;</span>
    object will be as well.</p>
<p class="Pp"><span class="Li">&quot;File::Temp&quot;</span> annoyingly requires
    you to specify a custom template in slightly different ways depending on
    which function or method you call, but
    <span class="Li">&quot;Path::Tiny&quot;</span> lets you ignore that and can
    take either a leading template or a
    <span class="Li">&quot;TEMPLATE&quot;</span> option and does the right
    thing.</p>
<p class="Pp"></p>
<pre>    $temp = Path::Tiny-&gt;tempfile( &quot;customXXXXXXXX&quot; );             # ok
    $temp = Path::Tiny-&gt;tempfile( TEMPLATE =&gt; &quot;customXXXXXXXX&quot; ); # ok
</pre>
<p class="Pp">The tempfile path object will be normalized to have an absolute
    path, even if created in a relative directory using
    <span class="Li">&quot;DIR&quot;</span>. If you want it to have the
    <span class="Li">&quot;realpath&quot;</span> instead, pass a leading options
    hash like this:</p>
<p class="Pp"></p>
<pre>    $real_temp = tempfile({realpath =&gt; 1}, @options);
</pre>
<p class="Pp"><span class="Li">&quot;tempdir&quot;</span> is just like
    <span class="Li">&quot;tempfile&quot;</span>, except it calls
    <span class="Li">&quot;File::Temp-&gt;newdir&quot;</span> instead.</p>
<p class="Pp">Both <span class="Li">&quot;tempfile&quot;</span> and
    <span class="Li">&quot;tempdir&quot;</span> may be exported on request and
    used as functions instead of as methods.</p>
<p class="Pp"><b>Note</b>: for tempfiles, the filehandles from File::Temp are
    closed and not reused. This is not as secure as using File::Temp handles
    directly, but is less prone to deadlocks or access problems on some
    platforms. Think of what <span class="Li">&quot;Path::Tiny&quot;</span>
    gives you to be just a temporary file <b>name</b> that gets cleaned up.</p>
<p class="Pp"><b>Note 2</b>: if you don't want these cleaned up automatically
    when the object is destroyed, File::Temp requires different options for
    directories and files. Use <span class="Li">&quot;CLEANUP =&gt;
    0&quot;</span> for directories and <span class="Li">&quot;UNLINK =&gt;
    0&quot;</span> for files.</p>
<p class="Pp"><b>Note 3</b>: Don't lose the temporary object by chaining a
    method call instead of storing it:</p>
<p class="Pp"></p>
<pre>    my $lost = tempdir()-&gt;child(&quot;foo&quot;); # tempdir cleaned up right away
</pre>
<p class="Pp"><b>Note 4</b>: The cached object may be accessed with the
    &quot;cached_temp&quot; method. Keeping a reference to, or modifying the
    cached object may break the behavior documented above and is not supported.
    Use at your own risk.</p>
<p class="Pp">Current API available since 0.097.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="METHODS"><a class="permalink" href="#METHODS">METHODS</a></h1>
<section class="Ss">
<h2 class="Ss" id="absolute"><a class="permalink" href="#absolute">absolute</a></h2>
<pre>    $abs = path(&quot;foo/bar&quot;)-&gt;absolute;
    $abs = path(&quot;foo/bar&quot;)-&gt;absolute(&quot;/tmp&quot;);
</pre>
<p class="Pp">Returns a new <span class="Li">&quot;Path::Tiny&quot;</span>
    object with an absolute path (or itself if already absolute). If no argument
    is given, the current directory is used as the absolute base path. If an
    argument is given, it will be converted to an absolute path (if it is not
    already) and used as the absolute base path.</p>
<p class="Pp">This will not resolve upward directories (&quot;foo/../bar&quot;)
    unless <span class="Li">&quot;canonpath&quot;</span> in File::Spec would
    normally do so on your platform. If you need them resolved, you must call
    the more expensive <span class="Li">&quot;realpath&quot;</span> method
    instead.</p>
<p class="Pp">On Windows, an absolute path without a volume component will have
    it added based on the current drive.</p>
<p class="Pp">Current API available since 0.101.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="append,_append_raw,_append_utf8"><a class="permalink" href="#append,_append_raw,_append_utf8">append,
  append_raw, append_utf8</a></h2>
<pre>    path(&quot;foo.txt&quot;)-&gt;append(@data);
    path(&quot;foo.txt&quot;)-&gt;append(\@data);
    path(&quot;foo.txt&quot;)-&gt;append({binmode =&gt; &quot;:raw&quot;}, @data);
    path(&quot;foo.txt&quot;)-&gt;append_raw(@data);
    path(&quot;foo.txt&quot;)-&gt;append_utf8(@data);
</pre>
<p class="Pp">Appends data to a file. The file is locked with
    <span class="Li">&quot;flock&quot;</span> prior to writing and closed
    afterwards. An optional hash reference may be used to pass options. Valid
    options are:</p>
<ul class="Bl-bullet">
  <li><span class="Li">&quot;binmode&quot;</span>: passed to
      <span class="Li">&quot;binmode()&quot;</span> on the handle used for
      writing.</li>
  <li><span class="Li">&quot;truncate&quot;</span>: truncates the file after
      locking and before appending</li>
</ul>
<p class="Pp">The <span class="Li">&quot;truncate&quot;</span> option is a way
    to replace the contents of a file <b>in place</b>, unlike &quot;spew&quot;
    which writes to a temporary file and then replaces the original (if it
    exists).</p>
<p class="Pp"><span class="Li">&quot;append_raw&quot;</span> is like
    <span class="Li">&quot;append&quot;</span> with a
    <span class="Li">&quot;binmode&quot;</span> of
    <span class="Li">&quot;:unix&quot;</span> for fast, unbuffered, raw
  write.</p>
<p class="Pp"><span class="Li">&quot;append_utf8&quot;</span> is like
    <span class="Li">&quot;append&quot;</span> with a
    <span class="Li">&quot;binmode&quot;</span> of
    <span class="Li">&quot;:unix:encoding(UTF-8)&quot;</span> (or
    PerlIO::utf8_strict). If Unicode::UTF8 0.58+ is installed, a raw append will
    be done instead on the data encoded with
    <span class="Li">&quot;Unicode::UTF8&quot;</span>.</p>
<p class="Pp">Current API available since 0.060.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="assert"><a class="permalink" href="#assert">assert</a></h2>
<pre>    $path = path(&quot;foo.txt&quot;)-&gt;assert( sub { $_-&gt;exists } );
</pre>
<p class="Pp">Returns the invocant after asserting that a code reference
    argument returns true. When the assertion code reference runs, it will have
    the invocant object in the <span class="Li">$_</span> variable. If it
    returns false, an exception will be thrown. The assertion code reference may
    also throw its own exception.</p>
<p class="Pp">If no assertion is provided, the invocant is returned without
    error.</p>
<p class="Pp">Current API available since 0.062.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="basename"><a class="permalink" href="#basename">basename</a></h2>
<pre>    $name = path(&quot;foo/bar.txt&quot;)-&gt;basename;        # bar.txt
    $name = path(&quot;foo.txt&quot;)-&gt;basename('.txt');    # foo
    $name = path(&quot;foo.txt&quot;)-&gt;basename(qr/.txt/);  # foo
    $name = path(&quot;foo.txt&quot;)-&gt;basename(@suffixes);
</pre>
<p class="Pp">Returns the file portion or last directory portion of a path.</p>
<p class="Pp">Given a list of suffixes as strings or regular expressions, any
    that match at the end of the file portion or last directory portion will be
    removed before the result is returned.</p>
<p class="Pp">Current API available since 0.054.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="canonpath"><a class="permalink" href="#canonpath">canonpath</a></h2>
<pre>    $canonical = path(&quot;foo/bar&quot;)-&gt;canonpath; # foo\bar on Windows
</pre>
<p class="Pp">Returns a string with the canonical format of the path name for
    the platform. In particular, this means directory separators will be
    <span class="Li">&quot;\&quot;</span> on Windows.</p>
<p class="Pp">Current API available since 0.001.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="cached_temp"><a class="permalink" href="#cached_temp">cached_temp</a></h2>
<p class="Pp">Returns the cached <span class="Li">&quot;File::Temp&quot;</span>
    or <span class="Li">&quot;File::Temp::Dir&quot;</span> object if the
    <span class="Li">&quot;Path::Tiny&quot;</span> object was created with
    <span class="Li">&quot;/tempfile&quot;</span> or
    <span class="Li">&quot;/tempdir&quot;</span>. If there is no such object,
    this method throws.</p>
<p class="Pp"><b>WARNING</b>: Keeping a reference to, or modifying the cached
    object may break the behavior documented for temporary files and directories
    created with <span class="Li">&quot;Path::Tiny&quot;</span> and is not
    supported. Use at your own risk.</p>
<p class="Pp">Current API available since 0.101.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="child"><a class="permalink" href="#child">child</a></h2>
<pre>    $file = path(&quot;/tmp&quot;)-&gt;child(&quot;foo.txt&quot;); # &quot;/tmp/foo.txt&quot;
    $file = path(&quot;/tmp&quot;)-&gt;child(@parts);
</pre>
<p class="Pp">Returns a new <span class="Li">&quot;Path::Tiny&quot;</span>
    object relative to the original. Works like
    <span class="Li">&quot;catfile&quot;</span> or
    <span class="Li">&quot;catdir&quot;</span> from File::Spec, but without
    caring about file or directories.</p>
<p class="Pp"><b>WARNING</b>: because the argument could contain
    <span class="Li">&quot;..&quot;</span> or refer to symlinks, there is no
    guarantee that the new path refers to an actual descendent of the original.
    If this is important to you, transform parent and child with
    &quot;realpath&quot; and check them with &quot;subsumes&quot;.</p>
<p class="Pp">Current API available since 0.001.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="children"><a class="permalink" href="#children">children</a></h2>
<pre>    @paths = path(&quot;/tmp&quot;)-&gt;children;
    @paths = path(&quot;/tmp&quot;)-&gt;children( qr/\.txt\z/ );
</pre>
<p class="Pp">Returns a list of <span class="Li">&quot;Path::Tiny&quot;</span>
    objects for all files and directories within a directory. Excludes
    &quot;.&quot; and &quot;..&quot; automatically.</p>
<p class="Pp">If an optional <span class="Li">&quot;qr//&quot;</span> argument
    is provided, it only returns objects for child names that match the given
    regular expression. Only the base name is used for matching:</p>
<p class="Pp"></p>
<pre>    @paths = path(&quot;/tmp&quot;)-&gt;children( qr/^foo/ );
    # matches children like the glob foo*
</pre>
<p class="Pp">Current API available since 0.028.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="chmod"><a class="permalink" href="#chmod">chmod</a></h2>
<pre>    path(&quot;foo.txt&quot;)-&gt;chmod(0777);
    path(&quot;foo.txt&quot;)-&gt;chmod(&quot;0755&quot;);
    path(&quot;foo.txt&quot;)-&gt;chmod(&quot;go-w&quot;);
    path(&quot;foo.txt&quot;)-&gt;chmod(&quot;a=r,u+wx&quot;);
</pre>
<p class="Pp">Sets file or directory permissions. The argument can be a numeric
    mode, a octal string beginning with a &quot;0&quot; or a limited subset of
    the symbolic mode use by <i>/bin/chmod</i>.</p>
<p class="Pp">The symbolic mode must be a comma-delimited list of mode clauses.
    Clauses must match
    <span class="Li">&quot;qr/\A([augo]+)([=+-])([rwx]+)\z/&quot;</span>, which
    defines &quot;who&quot;, &quot;op&quot; and &quot;perms&quot; parameters for
    each clause. Unlike <i>/bin/chmod</i>, all three parameters are required for
    each clause, multiple ops are not allowed and permissions
    <span class="Li">&quot;stugoX&quot;</span> are not supported. (See
    File::chmod for more complex needs.)</p>
<p class="Pp">Current API available since 0.053.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="copy"><a class="permalink" href="#copy">copy</a></h2>
<pre>    path(&quot;/tmp/foo.txt&quot;)-&gt;copy(&quot;/tmp/bar.txt&quot;);
</pre>
<p class="Pp">Copies the current path to the given destination using
    File::Copy's <span class="Li">&quot;copy&quot;</span> function. Upon
    success, returns the <span class="Li">&quot;Path::Tiny&quot;</span> object
    for the newly copied file.</p>
<p class="Pp">Current API available since 0.070.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="digest"><a class="permalink" href="#digest">digest</a></h2>
<pre>    $obj = path(&quot;/tmp/foo.txt&quot;)-&gt;digest;        # SHA-256
    $obj = path(&quot;/tmp/foo.txt&quot;)-&gt;digest(&quot;MD5&quot;); # user-selected
    $obj = path(&quot;/tmp/foo.txt&quot;)-&gt;digest( { chunk_size =&gt; 1e6 }, &quot;MD5&quot; );
</pre>
<p class="Pp">Returns a hexadecimal digest for a file. An optional hash
    reference of options may be given. The only option is
    <span class="Li">&quot;chunk_size&quot;</span>. If
    <span class="Li">&quot;chunk_size&quot;</span> is given, that many bytes
    will be read at a time. If not provided, the entire file will be slurped
    into memory to compute the digest.</p>
<p class="Pp">Any subsequent arguments are passed to the constructor for Digest
    to select an algorithm. If no arguments are given, the default is
  SHA-256.</p>
<p class="Pp">Current API available since 0.056.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="dirname_(deprecated)"><a class="permalink" href="#dirname_(deprecated)">dirname
  (deprecated)</a></h2>
<pre>    $name = path(&quot;/tmp/foo.txt&quot;)-&gt;dirname; # &quot;/tmp/&quot;
</pre>
<p class="Pp">Returns the directory portion you would get from calling
    <span class="Li">&quot;File::Spec-&gt;splitpath( $path-&gt;stringify
    )&quot;</span> or <span class="Li">&quot;.&quot;</span> for a path without a
    parent directory portion. Because File::Spec is inconsistent, the result
    might or might not have a trailing slash. Because of this, this method is
    <b>deprecated</b>.</p>
<p class="Pp">A better, more consistently approach is likely
    <span class="Li">&quot;$path-&gt;parent-&gt;stringify&quot;</span>, which
    will not have a trailing slash except for a root directory.</p>
<p class="Pp">Deprecated in 0.056.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="edit,_edit_raw,_edit_utf8"><a class="permalink" href="#edit,_edit_raw,_edit_utf8">edit,
  edit_raw, edit_utf8</a></h2>
<pre>    path(&quot;foo.txt&quot;)-&gt;edit( \&amp;callback, $options );
    path(&quot;foo.txt&quot;)-&gt;edit_utf8( \&amp;callback );
    path(&quot;foo.txt&quot;)-&gt;edit_raw( \&amp;callback );
</pre>
<p class="Pp">These are convenience methods that allow &quot;editing&quot; a
    file using a single callback argument. They slurp the file using
    <span class="Li">&quot;slurp&quot;</span>, place the contents inside a
    localized <span class="Li">$_</span> variable, call the callback function
    (without arguments), and then write <span class="Li">$_</span> (presumably
    mutated) back to the file with <span class="Li">&quot;spew&quot;</span>.</p>
<p class="Pp">An optional hash reference may be used to pass options. The only
    option is <span class="Li">&quot;binmode&quot;</span>, which is passed to
    <span class="Li">&quot;slurp&quot;</span> and
    <span class="Li">&quot;spew&quot;</span>.</p>
<p class="Pp"><span class="Li">&quot;edit_utf8&quot;</span> and
    <span class="Li">&quot;edit_raw&quot;</span> act like their respective
    <span class="Li">&quot;slurp_*&quot;</span> and
    <span class="Li">&quot;spew_*&quot;</span> methods.</p>
<p class="Pp">Current API available since 0.077.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="edit_lines,_edit_lines_utf8,_edit_lines_raw"><a class="permalink" href="#edit_lines,_edit_lines_utf8,_edit_lines_raw">edit_lines,
  edit_lines_utf8, edit_lines_raw</a></h2>
<pre>    path(&quot;foo.txt&quot;)-&gt;edit_lines( \&amp;callback, $options );
    path(&quot;foo.txt&quot;)-&gt;edit_lines_utf8( \&amp;callback );
    path(&quot;foo.txt&quot;)-&gt;edit_lines_raw( \&amp;callback );
</pre>
<p class="Pp">These are convenience methods that allow &quot;editing&quot; a
    file's lines using a single callback argument. They iterate over the file:
    for each line, the line is put into a localized <span class="Li">$_</span>
    variable, the callback function is executed (without arguments) and then
    <span class="Li">$_</span> is written to a temporary file. When iteration is
    finished, the temporary file is atomically renamed over the original.</p>
<p class="Pp">An optional hash reference may be used to pass options. The only
    option is <span class="Li">&quot;binmode&quot;</span>, which is passed to
    the method that open handles for reading and writing.</p>
<p class="Pp"><span class="Li">&quot;edit_lines_utf8&quot;</span> and
    <span class="Li">&quot;edit_lines_raw&quot;</span> act like their respective
    <span class="Li">&quot;slurp_*&quot;</span> and
    <span class="Li">&quot;spew_*&quot;</span> methods.</p>
<p class="Pp">Current API available since 0.077.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="exists,_is_file,_is_dir"><a class="permalink" href="#exists,_is_file,_is_dir">exists,
  is_file, is_dir</a></h2>
<pre>    if ( path(&quot;/tmp&quot;)-&gt;exists ) { ... }     # -e
    if ( path(&quot;/tmp&quot;)-&gt;is_dir ) { ... }     # -d
    if ( path(&quot;/tmp&quot;)-&gt;is_file ) { ... }    # -e &amp;&amp; ! -d
</pre>
<p class="Pp">Implements file test operations, this means the file or directory
    actually has to exist on the filesystem. Until then, it's just a path.</p>
<p class="Pp"><b>Note</b>: <span class="Li">&quot;is_file&quot;</span> is not
    <span class="Li">&quot;-f&quot;</span> because
    <span class="Li">&quot;-f&quot;</span> is not the opposite of
    <span class="Li">&quot;-d&quot;</span>.
    <span class="Li">&quot;-f&quot;</span> means &quot;plain file&quot;,
    excluding symlinks, devices, etc. that often can be read just like
  files.</p>
<p class="Pp">Use <span class="Li">&quot;-f&quot;</span> instead if you really
    mean to check for a plain file.</p>
<p class="Pp">Current API available since 0.053.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="filehandle"><a class="permalink" href="#filehandle">filehandle</a></h2>
<pre>    $fh = path(&quot;/tmp/foo.txt&quot;)-&gt;filehandle($mode, $binmode);
    $fh = path(&quot;/tmp/foo.txt&quot;)-&gt;filehandle({ locked =&gt; 1 }, $mode, $binmode);
    $fh = path(&quot;/tmp/foo.txt&quot;)-&gt;filehandle({ exclusive =&gt; 1  }, $mode, $binmode);
</pre>
<p class="Pp">Returns an open file handle. The <span class="Li">$mode</span>
    argument must be a Perl-style read/write mode string (&quot;&lt;&quot;
    ,&quot;&gt;&quot;, &quot;&gt;&gt;&quot;, etc.). If a
    <span class="Li">$binmode</span> is given, it is set during the
    <span class="Li">&quot;open&quot;</span> call.</p>
<p class="Pp">An optional hash reference may be used to pass options.</p>
<p class="Pp">The <span class="Li">&quot;locked&quot;</span> option governs file
    locking; if true, handles opened for writing, appending or read-write are
    locked with <span class="Li">&quot;LOCK_EX&quot;</span>; otherwise, they are
    locked with <span class="Li">&quot;LOCK_SH&quot;</span>. When using
    <span class="Li">&quot;locked&quot;</span>, &quot;&gt;&quot; or
    &quot;+&gt;&quot; modes will delay truncation until after the lock is
    acquired.</p>
<p class="Pp">The <span class="Li">&quot;exclusive&quot;</span> option causes
    the <b>open()</b> call to fail if the file already exists. This corresponds
    to the O_EXCL flag to sysopen / <b>open</b>(2).
    <span class="Li">&quot;exclusive&quot;</span> implies
    <span class="Li">&quot;locked&quot;</span> and will set it for you if you
    forget it.</p>
<p class="Pp">See <span class="Li">&quot;openr&quot;</span>,
    <span class="Li">&quot;openw&quot;</span>,
    <span class="Li">&quot;openrw&quot;</span>, and
    <span class="Li">&quot;opena&quot;</span> for sugar.</p>
<p class="Pp">Current API available since 0.066.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="is_absolute,_is_relative"><a class="permalink" href="#is_absolute,_is_relative">is_absolute,
  is_relative</a></h2>
<pre>    if ( path(&quot;/tmp&quot;)-&gt;is_absolute ) { ... }
    if ( path(&quot;/tmp&quot;)-&gt;is_relative ) { ... }
</pre>
<p class="Pp">Booleans for whether the path appears absolute or relative.</p>
<p class="Pp">Current API available since 0.001.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="is_rootdir"><a class="permalink" href="#is_rootdir">is_rootdir</a></h2>
<pre>    while ( ! $path-&gt;is_rootdir ) {
        $path = $path-&gt;parent;
        ...
    }
</pre>
<p class="Pp">Boolean for whether the path is the root directory of the volume.
    I.e. the <span class="Li">&quot;dirname&quot;</span> is
    <span class="Li">&quot;q[/]&quot;</span> and the
    <span class="Li">&quot;basename&quot;</span> is
    <span class="Li">&quot;q[]&quot;</span>.</p>
<p class="Pp">This works even on <span class="Li">&quot;MSWin32&quot;</span>
    with drives and UNC volumes:</p>
<p class="Pp"></p>
<pre>    path(&quot;C:/&quot;)-&gt;is_rootdir;             # true
    path(&quot;//server/share/&quot;)-&gt;is_rootdir; #true
</pre>
<p class="Pp">Current API available since 0.038.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="iterator"><a class="permalink" href="#iterator">iterator</a></h2>
<pre>    $iter = path(&quot;/tmp&quot;)-&gt;iterator( \%options );
</pre>
<p class="Pp">Returns a code reference that walks a directory lazily. Each
    invocation returns a <span class="Li">&quot;Path::Tiny&quot;</span> object
    or undef when the iterator is exhausted.</p>
<p class="Pp"></p>
<pre>    $iter = path(&quot;/tmp&quot;)-&gt;iterator;
    while ( $path = $iter-&gt;() ) {
        ...
    }
</pre>
<p class="Pp">The current and parent directory entries (&quot;.&quot; and
    &quot;..&quot;) will not be included.</p>
<p class="Pp">If the <span class="Li">&quot;recurse&quot;</span> option is true,
    the iterator will walk the directory recursively, breadth-first. If the
    <span class="Li">&quot;follow_symlinks&quot;</span> option is also true,
    directory links will be followed recursively. There is no protection against
    loops when following links. If a directory is not readable, it will not be
    followed.</p>
<p class="Pp">The default is the same as:</p>
<p class="Pp"></p>
<pre>    $iter = path(&quot;/tmp&quot;)-&gt;iterator( {
        recurse         =&gt; 0,
        follow_symlinks =&gt; 0,
    } );
</pre>
<p class="Pp">For a more powerful, recursive iterator with built-in loop
    avoidance, see Path::Iterator::Rule.</p>
<p class="Pp">See also &quot;visit&quot;.</p>
<p class="Pp">Current API available since 0.016.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="lines,_lines_raw,_lines_utf8"><a class="permalink" href="#lines,_lines_raw,_lines_utf8">lines,
  lines_raw, lines_utf8</a></h2>
<pre>    @contents = path(&quot;/tmp/foo.txt&quot;)-&gt;lines;
    @contents = path(&quot;/tmp/foo.txt&quot;)-&gt;lines(\%options);
    @contents = path(&quot;/tmp/foo.txt&quot;)-&gt;lines_raw;
    @contents = path(&quot;/tmp/foo.txt&quot;)-&gt;lines_utf8;
    @contents = path(&quot;/tmp/foo.txt&quot;)-&gt;lines( { chomp =&gt; 1, count =&gt; 4 } );
</pre>
<p class="Pp">Returns a list of lines from a file. Optionally takes a
    hash-reference of options. Valid options are
    <span class="Li">&quot;binmode&quot;</span>,
    <span class="Li">&quot;count&quot;</span> and
    <span class="Li">&quot;chomp&quot;</span>.</p>
<p class="Pp">If <span class="Li">&quot;binmode&quot;</span> is provided, it
    will be set on the handle prior to reading.</p>
<p class="Pp">If a positive <span class="Li">&quot;count&quot;</span> is
    provided, that many lines will be returned from the start of the file. If a
    negative <span class="Li">&quot;count&quot;</span> is provided, the entire
    file will be read, but only <span class="Li">&quot;abs(count)&quot;</span>
    will be kept and returned. If <span class="Li">&quot;abs(count)&quot;</span>
    exceeds the number of lines in the file, all lines will be returned.</p>
<p class="Pp">If <span class="Li">&quot;chomp&quot;</span> is set, any
    end-of-line character sequences (<span class="Li">&quot;CR&quot;</span>,
    <span class="Li">&quot;CRLF&quot;</span>, or
    <span class="Li">&quot;LF&quot;</span>) will be removed from the lines
    returned.</p>
<p class="Pp">Because the return is a list,
    <span class="Li">&quot;lines&quot;</span> in scalar context will return the
    number of lines (and throw away the data).</p>
<p class="Pp"></p>
<pre>    $number_of_lines = path(&quot;/tmp/foo.txt&quot;)-&gt;lines;
</pre>
<p class="Pp"><span class="Li">&quot;lines_raw&quot;</span> is like
    <span class="Li">&quot;lines&quot;</span> with a
    <span class="Li">&quot;binmode&quot;</span> of
    <span class="Li">&quot;:raw&quot;</span>. We use
    <span class="Li">&quot;:raw&quot;</span> instead of
    <span class="Li">&quot;:unix&quot;</span> so PerlIO buffering can manage
    reading by line.</p>
<p class="Pp"><span class="Li">&quot;lines_utf8&quot;</span> is like
    <span class="Li">&quot;lines&quot;</span> with a
    <span class="Li">&quot;binmode&quot;</span> of
    <span class="Li">&quot;:raw:encoding(UTF-8)&quot;</span> (or
    PerlIO::utf8_strict). If Unicode::UTF8 0.58+ is installed, a raw UTF-8 slurp
    will be done and then the lines will be split. This is actually faster than
    relying on <span class="Li">&quot;:encoding(UTF-8)&quot;</span>, though a
    bit memory intensive. If memory use is a concern, consider
    <span class="Li">&quot;openr_utf8&quot;</span> and iterating directly on the
    handle.</p>
<p class="Pp">Current API available since 0.065.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="mkpath"><a class="permalink" href="#mkpath">mkpath</a></h2>
<pre>    path(&quot;foo/bar/baz&quot;)-&gt;mkpath;
    path(&quot;foo/bar/baz&quot;)-&gt;mkpath( \%options );
</pre>
<p class="Pp">Like calling <span class="Li">&quot;make_path&quot;</span> from
    File::Path. An optional hash reference is passed through to
    <span class="Li">&quot;make_path&quot;</span>. Errors will be trapped and an
    exception thrown. Returns the list of directories created or an empty list
    if the directories already exist, just like
    <span class="Li">&quot;make_path&quot;</span>.</p>
<p class="Pp">Current API available since 0.001.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="move"><a class="permalink" href="#move">move</a></h2>
<pre>    path(&quot;foo.txt&quot;)-&gt;move(&quot;bar.txt&quot;);
</pre>
<p class="Pp">Move the current path to the given destination path using Perl's
    built-in rename function. Returns the result of the
    <span class="Li">&quot;rename&quot;</span> function (except it throws an
    exception if it fails).</p>
<p class="Pp">Current API available since 0.001.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="openr,_openw,_openrw,_opena"><a class="permalink" href="#openr,_openw,_openrw,_opena">openr,
  openw, openrw, opena</a></h2>
<pre>    $fh = path(&quot;foo.txt&quot;)-&gt;openr($binmode);  # read
    $fh = path(&quot;foo.txt&quot;)-&gt;openr_raw;
    $fh = path(&quot;foo.txt&quot;)-&gt;openr_utf8;
    $fh = path(&quot;foo.txt&quot;)-&gt;openw($binmode);  # write
    $fh = path(&quot;foo.txt&quot;)-&gt;openw_raw;
    $fh = path(&quot;foo.txt&quot;)-&gt;openw_utf8;
    $fh = path(&quot;foo.txt&quot;)-&gt;opena($binmode);  # append
    $fh = path(&quot;foo.txt&quot;)-&gt;opena_raw;
    $fh = path(&quot;foo.txt&quot;)-&gt;opena_utf8;
    $fh = path(&quot;foo.txt&quot;)-&gt;openrw($binmode); # read/write
    $fh = path(&quot;foo.txt&quot;)-&gt;openrw_raw;
    $fh = path(&quot;foo.txt&quot;)-&gt;openrw_utf8;
</pre>
<p class="Pp">Returns a file handle opened in the specified mode. The
    <span class="Li">&quot;openr&quot;</span> style methods take a single
    <span class="Li">&quot;binmode&quot;</span> argument. All of the
    <span class="Li">&quot;open*&quot;</span> methods have
    <span class="Li">&quot;open*_raw&quot;</span> and
    <span class="Li">&quot;open*_utf8&quot;</span> equivalents that use
    <span class="Li">&quot;:raw&quot;</span> and
    <span class="Li">&quot;:raw:encoding(UTF-8)&quot;</span>, respectively.</p>
<p class="Pp">An optional hash reference may be used to pass options. The only
    option is <span class="Li">&quot;locked&quot;</span>. If true, handles
    opened for writing, appending or read-write are locked with
    <span class="Li">&quot;LOCK_EX&quot;</span>; otherwise, they are locked for
    <span class="Li">&quot;LOCK_SH&quot;</span>.</p>
<p class="Pp"></p>
<pre>    $fh = path(&quot;foo.txt&quot;)-&gt;openrw_utf8( { locked =&gt; 1 } );
</pre>
<p class="Pp">See &quot;filehandle&quot; for more on locking.</p>
<p class="Pp">Current API available since 0.011.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="parent"><a class="permalink" href="#parent">parent</a></h2>
<pre>    $parent = path(&quot;foo/bar/baz&quot;)-&gt;parent; # foo/bar
    $parent = path(&quot;foo/wibble.txt&quot;)-&gt;parent; # foo
    $parent = path(&quot;foo/bar/baz&quot;)-&gt;parent(2); # foo
</pre>
<p class="Pp">Returns a <span class="Li">&quot;Path::Tiny&quot;</span> object
    corresponding to the parent directory of the original directory or file. An
    optional positive integer argument is the number of parent directories
    upwards to return. <span class="Li">&quot;parent&quot;</span> by itself is
    equivalent to <span class="Li">parent(1)</span>.</p>
<p class="Pp">Current API available since 0.014.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="realpath"><a class="permalink" href="#realpath">realpath</a></h2>
<pre>    $real = path(&quot;/baz/foo/../bar&quot;)-&gt;realpath;
    $real = path(&quot;foo/../bar&quot;)-&gt;realpath;
</pre>
<p class="Pp">Returns a new <span class="Li">&quot;Path::Tiny&quot;</span>
    object with all symbolic links and upward directory parts resolved using
    Cwd's <span class="Li">&quot;realpath&quot;</span>. Compared to
    <span class="Li">&quot;absolute&quot;</span>, this is more expensive as it
    must actually consult the filesystem.</p>
<p class="Pp">If the parent path can't be resolved (e.g. if it includes
    directories that don't exist), an exception will be thrown:</p>
<p class="Pp"></p>
<pre>    $real = path(&quot;doesnt_exist/foo&quot;)-&gt;realpath; # dies
</pre>
<p class="Pp">However, if the parent path exists and only the last component
    (e.g. filename) doesn't exist, the realpath will be the realpath of the
    parent plus the non-existent last component:</p>
<p class="Pp"></p>
<pre>    $real = path(&quot;./aasdlfasdlf&quot;)-&gt;realpath; # works
</pre>
<p class="Pp">The underlying Cwd module usually worked this way on Unix, but
    died on Windows (and some Unixes) if the full path didn't exist. As of
    version 0.064, it's safe to use anywhere.</p>
<p class="Pp">Current API available since 0.001.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="relative"><a class="permalink" href="#relative">relative</a></h2>
<pre>    $rel = path(&quot;/tmp/foo/bar&quot;)-&gt;relative(&quot;/tmp&quot;); # foo/bar
</pre>
<p class="Pp">Returns a <span class="Li">&quot;Path::Tiny&quot;</span> object
    with a path relative to a new base path given as an argument. If no argument
    is given, the current directory will be used as the new base path.</p>
<p class="Pp">If either path is already relative, it will be made absolute based
    on the current directly before determining the new relative path.</p>
<p class="Pp">The algorithm is roughly as follows:</p>
<ul class="Bl-bullet">
  <li>If the original and new base path are on different volumes, an exception
      will be thrown.</li>
  <li>If the original and new base are identical, the relative path is
      <span class="Li">&quot;.&quot;</span>.</li>
  <li>If the new base subsumes the original, the relative path is the original
      path with the new base chopped off the front</li>
  <li>If the new base does not subsume the original, a common prefix path is
      determined (possibly the root directory) and the relative path will
      consist of updirs (<span class="Li">&quot;..&quot;</span>) to reach the
      common prefix, followed by the original path less the common prefix.</li>
</ul>
<p class="Pp">Unlike <span class="Li">&quot;File::Spec::abs2rel&quot;</span>, in
    the last case above, the calculation based on a common prefix takes into
    account symlinks that could affect the updir process. Given an original path
    &quot;/A/B&quot; and a new base &quot;/A/C&quot;, (where &quot;A&quot;,
    &quot;B&quot; and &quot;C&quot; could each have multiple path
  components):</p>
<ul class="Bl-bullet">
  <li>Symlinks in &quot;A&quot; don't change the result unless the last
      component of A is a symlink and the first component of &quot;C&quot; is an
      updir.</li>
  <li>Symlinks in &quot;B&quot; don't change the result and will exist in the
      result as given.</li>
  <li>Symlinks and updirs in &quot;C&quot; must be resolved to actual paths,
      taking into account the possibility that not all path components might
      exist on the filesystem.</li>
</ul>
<p class="Pp">Current API available since 0.001. New algorithm (that accounts
    for symlinks) available since 0.079.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="remove"><a class="permalink" href="#remove">remove</a></h2>
<pre>    path(&quot;foo.txt&quot;)-&gt;remove;
</pre>
<p class="Pp">This is just like <span class="Li">&quot;unlink&quot;</span>,
    except for its error handling: if the path does not exist, it returns false;
    if deleting the file fails, it throws an exception.</p>
<p class="Pp">Current API available since 0.012.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="remove_tree"><a class="permalink" href="#remove_tree">remove_tree</a></h2>
<pre>    # directory
    path(&quot;foo/bar/baz&quot;)-&gt;remove_tree;
    path(&quot;foo/bar/baz&quot;)-&gt;remove_tree( \%options );
    path(&quot;foo/bar/baz&quot;)-&gt;remove_tree( { safe =&gt; 0 } ); # force remove
</pre>
<p class="Pp">Like calling <span class="Li">&quot;remove_tree&quot;</span> from
    File::Path, but defaults to <span class="Li">&quot;safe&quot;</span> mode.
    An optional hash reference is passed through to
    <span class="Li">&quot;remove_tree&quot;</span>. Errors will be trapped and
    an exception thrown. Returns the number of directories deleted, just like
    <span class="Li">&quot;remove_tree&quot;</span>.</p>
<p class="Pp">If you want to remove a directory only if it is empty, use the
    built-in <span class="Li">&quot;rmdir&quot;</span> function instead.</p>
<p class="Pp"></p>
<pre>    rmdir path(&quot;foo/bar/baz/&quot;);
</pre>
<p class="Pp">Current API available since 0.013.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="sibling"><a class="permalink" href="#sibling">sibling</a></h2>
<pre>    $foo = path(&quot;/tmp/foo.txt&quot;);
    $sib = $foo-&gt;sibling(&quot;bar.txt&quot;);        # /tmp/bar.txt
    $sib = $foo-&gt;sibling(&quot;baz&quot;, &quot;bam.txt&quot;); # /tmp/baz/bam.txt
</pre>
<p class="Pp">Returns a new <span class="Li">&quot;Path::Tiny&quot;</span>
    object relative to the parent of the original. This is slightly more
    efficient than
    <span class="Li">&quot;$path-&gt;parent-&gt;child(...)&quot;</span>.</p>
<p class="Pp">Current API available since 0.058.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="slurp,_slurp_raw,_slurp_utf8"><a class="permalink" href="#slurp,_slurp_raw,_slurp_utf8">slurp,
  slurp_raw, slurp_utf8</a></h2>
<pre>    $data = path(&quot;foo.txt&quot;)-&gt;slurp;
    $data = path(&quot;foo.txt&quot;)-&gt;slurp( {binmode =&gt; &quot;:raw&quot;} );
    $data = path(&quot;foo.txt&quot;)-&gt;slurp_raw;
    $data = path(&quot;foo.txt&quot;)-&gt;slurp_utf8;
</pre>
<p class="Pp">Reads file contents into a scalar. Takes an optional hash
    reference which may be used to pass options. The only available option is
    <span class="Li">&quot;binmode&quot;</span>, which is passed to
    <span class="Li">&quot;binmode()&quot;</span> on the handle used for
    reading.</p>
<p class="Pp"><span class="Li">&quot;slurp_raw&quot;</span> is like
    <span class="Li">&quot;slurp&quot;</span> with a
    <span class="Li">&quot;binmode&quot;</span> of
    <span class="Li">&quot;:unix&quot;</span> for a fast, unbuffered, raw
  read.</p>
<p class="Pp"><span class="Li">&quot;slurp_utf8&quot;</span> is like
    <span class="Li">&quot;slurp&quot;</span> with a
    <span class="Li">&quot;binmode&quot;</span> of
    <span class="Li">&quot;:unix:encoding(UTF-8)&quot;</span> (or
    PerlIO::utf8_strict). If Unicode::UTF8 0.58+ is installed, a raw slurp will
    be done instead and the result decoded with
    <span class="Li">&quot;Unicode::UTF8&quot;</span>. This is just as strict
    and is roughly an order of magnitude faster than using
    <span class="Li">&quot;:encoding(UTF-8)&quot;</span>.</p>
<p class="Pp"><b>Note</b>: <span class="Li">&quot;slurp&quot;</span> and friends
    lock the filehandle before slurping. If you plan to slurp from a file
    created with File::Temp, be sure to close other handles or open without
    locking to avoid a deadlock:</p>
<p class="Pp"></p>
<pre>    my $tempfile = File::Temp-&gt;new(EXLOCK =&gt; 0);
    my $guts = path($tempfile)-&gt;slurp;
</pre>
<p class="Pp">Current API available since 0.004.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="spew,_spew_raw,_spew_utf8"><a class="permalink" href="#spew,_spew_raw,_spew_utf8">spew,
  spew_raw, spew_utf8</a></h2>
<pre>    path(&quot;foo.txt&quot;)-&gt;spew(@data);
    path(&quot;foo.txt&quot;)-&gt;spew(\@data);
    path(&quot;foo.txt&quot;)-&gt;spew({binmode =&gt; &quot;:raw&quot;}, @data);
    path(&quot;foo.txt&quot;)-&gt;spew_raw(@data);
    path(&quot;foo.txt&quot;)-&gt;spew_utf8(@data);
</pre>
<p class="Pp">Writes data to a file atomically. The file is written to a
    temporary file in the same directory, then renamed over the original. An
    optional hash reference may be used to pass options. The only option is
    <span class="Li">&quot;binmode&quot;</span>, which is passed to
    <span class="Li">&quot;binmode()&quot;</span> on the handle used for
    writing.</p>
<p class="Pp"><span class="Li">&quot;spew_raw&quot;</span> is like
    <span class="Li">&quot;spew&quot;</span> with a
    <span class="Li">&quot;binmode&quot;</span> of
    <span class="Li">&quot;:unix&quot;</span> for a fast, unbuffered, raw
  write.</p>
<p class="Pp"><span class="Li">&quot;spew_utf8&quot;</span> is like
    <span class="Li">&quot;spew&quot;</span> with a
    <span class="Li">&quot;binmode&quot;</span> of
    <span class="Li">&quot;:unix:encoding(UTF-8)&quot;</span> (or
    PerlIO::utf8_strict). If Unicode::UTF8 0.58+ is installed, a raw spew will
    be done instead on the data encoded with
    <span class="Li">&quot;Unicode::UTF8&quot;</span>.</p>
<p class="Pp"><b>NOTE</b>: because the file is written to a temporary file and
    then renamed, the new file will wind up with permissions based on your
    current umask. This is a feature to protect you from a race condition that
    would otherwise give different permissions than you might expect. If you
    really want to keep the original mode flags, use &quot;append&quot; with the
    <span class="Li">&quot;truncate&quot;</span> option.</p>
<p class="Pp">Current API available since 0.011.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="stat,_lstat"><a class="permalink" href="#stat,_lstat">stat,
  lstat</a></h2>
<pre>    $stat = path(&quot;foo.txt&quot;)-&gt;stat;
    $stat = path(&quot;/some/symlink&quot;)-&gt;lstat;
</pre>
<p class="Pp">Like calling <span class="Li">&quot;stat&quot;</span> or
    <span class="Li">&quot;lstat&quot;</span> from File::stat.</p>
<p class="Pp">Current API available since 0.001.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="stringify"><a class="permalink" href="#stringify">stringify</a></h2>
<pre>    $path = path(&quot;foo.txt&quot;);
    say $path-&gt;stringify; # same as &quot;$path&quot;
</pre>
<p class="Pp">Returns a string representation of the path. Unlike
    <span class="Li">&quot;canonpath&quot;</span>, this method returns the path
    standardized with Unix-style <span class="Li">&quot;/&quot;</span> directory
    separators.</p>
<p class="Pp">Current API available since 0.001.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="subsumes"><a class="permalink" href="#subsumes">subsumes</a></h2>
<pre>    path(&quot;foo/bar&quot;)-&gt;subsumes(&quot;foo/bar/baz&quot;); # true
    path(&quot;/foo/bar&quot;)-&gt;subsumes(&quot;/foo/baz&quot;);   # false
</pre>
<p class="Pp">Returns true if the first path is a prefix of the second path at a
    directory boundary.</p>
<p class="Pp">This <b>does not</b> resolve parent directory entries
    (<span class="Li">&quot;..&quot;</span>) or symlinks:</p>
<p class="Pp"></p>
<pre>    path(&quot;foo/bar&quot;)-&gt;subsumes(&quot;foo/bar/../baz&quot;); # true
</pre>
<p class="Pp">If such things are important to you, ensure that both paths are
    resolved to the filesystem with
    <span class="Li">&quot;realpath&quot;</span>:</p>
<p class="Pp"></p>
<pre>    my $p1 = path(&quot;foo/bar&quot;)-&gt;realpath;
    my $p2 = path(&quot;foo/bar/../baz&quot;)-&gt;realpath;
    if ( $p1-&gt;subsumes($p2) ) { ... }
</pre>
<p class="Pp">Current API available since 0.048.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="touch"><a class="permalink" href="#touch">touch</a></h2>
<pre>    path(&quot;foo.txt&quot;)-&gt;touch;
    path(&quot;foo.txt&quot;)-&gt;touch($epoch_secs);
</pre>
<p class="Pp">Like the Unix <span class="Li">&quot;touch&quot;</span> utility.
    Creates the file if it doesn't exist, or else changes the modification and
    access times to the current time. If the first argument is the epoch seconds
    then it will be used.</p>
<p class="Pp">Returns the path object so it can be easily chained with other
    methods:</p>
<p class="Pp"></p>
<pre>    # won't die if foo.txt doesn't exist
    $content = path(&quot;foo.txt&quot;)-&gt;touch-&gt;slurp;
</pre>
<p class="Pp">Current API available since 0.015.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="touchpath"><a class="permalink" href="#touchpath">touchpath</a></h2>
<pre>    path(&quot;bar/baz/foo.txt&quot;)-&gt;touchpath;
</pre>
<p class="Pp">Combines <span class="Li">&quot;mkpath&quot;</span> and
    <span class="Li">&quot;touch&quot;</span>. Creates the parent directory if
    it doesn't exist, before touching the file. Returns the path object like
    <span class="Li">&quot;touch&quot;</span> does.</p>
<p class="Pp">Current API available since 0.022.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="visit"><a class="permalink" href="#visit">visit</a></h2>
<pre>    path(&quot;/tmp&quot;)-&gt;visit( \&amp;callback, \%options );
</pre>
<p class="Pp">Executes a callback for each child of a directory. It returns a
    hash reference with any state accumulated during iteration.</p>
<p class="Pp">The options are the same as for &quot;iterator&quot; (which it
    uses internally): <span class="Li">&quot;recurse&quot;</span> and
    <span class="Li">&quot;follow_symlinks&quot;</span>. Both default to
  false.</p>
<p class="Pp">The callback function will receive a
    <span class="Li">&quot;Path::Tiny&quot;</span> object as the first argument
    and a hash reference to accumulate state as the second argument. For
    example:</p>
<p class="Pp"></p>
<pre>    # collect files sizes
    my $sizes = path(&quot;/tmp&quot;)-&gt;visit(
        sub {
            my ($path, $state) = @_;
            return if $path-&gt;is_dir;
            $state-&gt;{$path} = -s $path;
        },
        { recurse =&gt; 1 }
    );
</pre>
<p class="Pp">For convenience, the
    <span class="Li">&quot;Path::Tiny&quot;</span> object will also be locally
    aliased as the <span class="Li">$_</span> global variable:</p>
<p class="Pp"></p>
<pre>    # print paths matching /foo/
    path(&quot;/tmp&quot;)-&gt;visit( sub { say if /foo/ }, { recurse =&gt; 1} );
</pre>
<p class="Pp">If the callback returns a <b>reference</b> to a false scalar
    value, iteration will terminate. This is not the same as &quot;pruning&quot;
    a directory search; this just stops all iteration and returns the state hash
    reference.</p>
<p class="Pp"></p>
<pre>    # find up to 10 files larger than 100K
    my $files = path(&quot;/tmp&quot;)-&gt;visit(
        sub {
            my ($path, $state) = @_;
            $state-&gt;{$path}++ if -s $path &gt; 102400
            return \0 if keys %$state == 10;
        },
        { recurse =&gt; 1 }
    );
</pre>
<p class="Pp">If you want more flexible iteration, use a module like
    Path::Iterator::Rule.</p>
<p class="Pp">Current API available since 0.062.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="volume"><a class="permalink" href="#volume">volume</a></h2>
<pre>    $vol = path(&quot;/tmp/foo.txt&quot;)-&gt;volume;   # &quot;&quot;
    $vol = path(&quot;C:/tmp/foo.txt&quot;)-&gt;volume; # &quot;C:&quot;
</pre>
<p class="Pp">Returns the volume portion of the path. This is equivalent to what
    File::Spec would give from <span class="Li">&quot;splitpath&quot;</span> and
    thus usually is the empty string on Unix-like operating systems or the drive
    letter for an absolute path on
  <span class="Li">&quot;MSWin32&quot;</span>.</p>
<p class="Pp">Current API available since 0.001.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="EXCEPTION_HANDLING"><a class="permalink" href="#EXCEPTION_HANDLING">EXCEPTION
  HANDLING</a></h1>
<p class="Pp">Simple usage errors will generally croak. Failures of underlying
    Perl functions will be thrown as exceptions in the class
    <span class="Li">&quot;Path::Tiny::Error&quot;</span>.</p>
<p class="Pp">A <span class="Li">&quot;Path::Tiny::Error&quot;</span> object
    will be a hash reference with the following fields:</p>
<ul class="Bl-bullet">
  <li><span class="Li">&quot;op&quot;</span> &#x2014; a description of the
      operation, usually function call and any extra info</li>
  <li><span class="Li">&quot;file&quot;</span> &#x2014; the file or directory
      relating to the error</li>
  <li><span class="Li">&quot;err&quot;</span> &#x2014; hold
      <span class="Li">$!</span> at the time the error was thrown</li>
  <li><span class="Li">&quot;msg&quot;</span> &#x2014; a string combining the
      above data and a Carp-like short stack trace</li>
</ul>
<p class="Pp">Exception objects will stringify as the
    <span class="Li">&quot;msg&quot;</span> field.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="ENVIRONMENT"><a class="permalink" href="#ENVIRONMENT">ENVIRONMENT</a></h1>
<section class="Ss">
<h2 class="Ss">PERL_PATH_TINY_NO_FLOCK</h2>
<p class="Pp">If the environment variable
    <span class="Li">&quot;PERL_PATH_TINY_NO_FLOCK&quot;</span> is set to a true
    value then flock will NOT be used when accessing files (this is not
    recommended).</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="CAVEATS"><a class="permalink" href="#CAVEATS">CAVEATS</a></h1>
<section class="Ss">
<h2 class="Ss" id="Subclassing_not_supported"><a class="permalink" href="#Subclassing_not_supported">Subclassing
  not supported</a></h2>
<p class="Pp">For speed, this class is implemented as an array based object and
    uses many direct function calls internally. You must not subclass it and
    expect things to work properly.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="File_locking"><a class="permalink" href="#File_locking">File
  locking</a></h2>
<p class="Pp">If flock is not supported on a platform, it will not be used, even
    if locking is requested.</p>
<p class="Pp">In situations where a platform normally would support locking, but
    the flock fails due to a filesystem limitation, Path::Tiny has some
    heuristics to detect this and will warn once and continue in an unsafe mode.
    If you want this failure to be fatal, you can fatalize the 'flock' warnings
    category:</p>
<p class="Pp"></p>
<pre>    use warnings FATAL =&gt; 'flock';
</pre>
<p class="Pp">See additional caveats below.</p>
<p class="Pp"><i>NFS and BSD</i></p>
<p class="Pp">On BSD, Perl's flock implementation may not work to lock files on
    an NFS filesystem. If detected, this situation will warn once, as described
    above.</p>
<p class="Pp"><i>Lustre</i></p>
<p class="Pp">The Lustre filesystem does not support flock. If detected, this
    situation will warn once, as described above.</p>
<p class="Pp"><i>AIX and locking</i></p>
<p class="Pp">AIX requires a write handle for locking. Therefore, calls that
    normally open a read handle and take a shared lock instead will open a
    read-write handle and take an exclusive lock. If the user does not have
    write permission, no lock will be used.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="utf8_vs_"><a class="permalink" href="#utf8_vs_">utf8 vs
  UTF-8</a></h2>
<p class="Pp">All the <span class="Li">*_utf8</span> methods by default use
    <span class="Li">&quot;:encoding(UTF-8)&quot;</span> -- either as
    <span class="Li">&quot;:unix:encoding(UTF-8)&quot;</span> (unbuffered) or
    <span class="Li">&quot;:raw:encoding(UTF-8)&quot;</span> (buffered) -- which
    is strict against the Unicode spec and disallows illegal Unicode codepoints
    or UTF-8 sequences.</p>
<p class="Pp">Unfortunately,
    <span class="Li">&quot;:encoding(UTF-8)&quot;</span> is very, very slow. If
    you install Unicode::UTF8 0.58 or later, that module will be used by some
    <span class="Li">*_utf8</span> methods to encode or decode data after a raw,
    binary input/output operation, which is much faster. Alternatively, if you
    install PerlIO::utf8_strict, that will be used instead of
    <span class="Li">&quot;:encoding(UTF-8)&quot;</span> and is also very
  fast.</p>
<p class="Pp">If you need the performance and can accept the security risk,
    <span class="Li">&quot;slurp({binmode =&gt;
    &quot;:unix:utf8&quot;})&quot;</span> will be faster than
    <span class="Li">&quot;:unix:encoding(UTF-8)&quot;</span> (but not as fast
    as <span class="Li">&quot;Unicode::UTF8&quot;</span>).</p>
<p class="Pp">Note that the <span class="Li">*_utf8</span> methods read in
    <b>raw</b> mode. There is no CRLF translation on Windows. If you must have
    CRLF translation, use the regular input/output methods with an appropriate
    binmode:</p>
<p class="Pp"></p>
<pre>  $path-&gt;spew_utf8($data);                            # raw
  $path-&gt;spew({binmode =&gt; &quot;:encoding(UTF-8)&quot;}, $data; # LF -&gt; CRLF
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Default_"><a class="permalink" href="#Default_">Default IO
  layers and the open pragma</a></h2>
<p class="Pp">If you have Perl 5.10 or later, file input/output methods
    (<span class="Li">&quot;slurp&quot;</span>,
    <span class="Li">&quot;spew&quot;</span>, etc.) and high-level handle
    opening methods ( <span class="Li">&quot;filehandle&quot;</span>,
    <span class="Li">&quot;openr&quot;</span>,
    <span class="Li">&quot;openw&quot;</span>, etc. ) respect default encodings
    set by the <span class="Li">&quot;-C&quot;</span> switch or lexical open
    settings of the caller. For UTF-8, this is almost certainly slower than
    using the dedicated <span class="Li">&quot;_utf8&quot;</span> methods if you
    have Unicode::UTF8.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="TYPE_CONSTRAINTS_AND_COERCION"><a class="permalink" href="#TYPE_CONSTRAINTS_AND_COERCION">TYPE
  CONSTRAINTS AND COERCION</a></h1>
<p class="Pp">A standard MooseX::Types library is available at
    MooseX::Types::Path::Tiny. A Type::Tiny equivalent is available as
    Types::Path::Tiny.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp">These are other file/path utilities, which may offer a different
    feature set than <span class="Li">&quot;Path::Tiny&quot;</span>.</p>
<ul class="Bl-bullet">
  <li>File::chmod</li>
  <li>File::Fu</li>
  <li>IO::All</li>
  <li>Path::Class</li>
</ul>
<p class="Pp">These iterators may be slightly faster than the recursive iterator
    in <span class="Li">&quot;Path::Tiny&quot;</span>:</p>
<ul class="Bl-bullet">
  <li>Path::Iterator::Rule</li>
  <li>File::Next</li>
</ul>
<p class="Pp">There are probably comparable, non-Tiny tools. Let me know if you
    want me to add a module to the list.</p>
<p class="Pp">This module was featured in the 2013 Perl Advent Calendar
    &lt;http://www.perladvent.org/2013/2013-12-18.html&gt;.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SUPPORT"><a class="permalink" href="#SUPPORT">SUPPORT</a></h1>
<section class="Ss">
<h2 class="Ss" id="Bugs_/_Feature_Requests"><a class="permalink" href="#Bugs_/_Feature_Requests">Bugs
  / Feature Requests</a></h2>
<p class="Pp">Please report any bugs or feature requests through the issue
    tracker at &lt;https://github.com/dagolden/Path-Tiny/issues&gt;. You will be
    notified automatically of any progress on your issue.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Source_Code"><a class="permalink" href="#Source_Code">Source
  Code</a></h2>
<p class="Pp">This is open source software. The code repository is available for
    public review and contribution under the terms of the license.</p>
<p class="Pp">&lt;https://github.com/dagolden/Path-Tiny&gt;</p>
<p class="Pp"></p>
<pre>  git clone https://github.com/dagolden/Path-Tiny.git
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">David Golden &lt;dagolden@cpan.org&gt;</p>
</section>
<section class="Sh">
<h1 class="Sh" id="CONTRIBUTORS"><a class="permalink" href="#CONTRIBUTORS">CONTRIBUTORS</a></h1>
<ul class="Bl-bullet">
  <li>Alex Efros &lt;powerman@powerman.name&gt;</li>
  <li>Aristotle Pagaltzis &lt;pagaltzis@gmx.de&gt;</li>
  <li>Chris Williams &lt;bingos@cpan.org&gt;</li>
  <li>Dan Book &lt;grinnz@grinnz.com&gt;</li>
  <li>Dave Rolsky &lt;autarch@urth.org&gt;</li>
  <li>David Steinbrunner &lt;dsteinbrunner@pobox.com&gt;</li>
  <li>Doug Bell &lt;madcityzen@gmail.com&gt;</li>
  <li>Gabor Szabo &lt;szabgab@cpan.org&gt;</li>
  <li>Gabriel Andrade &lt;gabiruh@gmail.com&gt;</li>
  <li>George Hartzell &lt;hartzell@cpan.org&gt;</li>
  <li>Geraud Continsouzas &lt;geraud@scsi.nc&gt;</li>
  <li>Goro Fuji &lt;gfuji@cpan.org&gt;</li>
  <li>Graham Knop &lt;haarg@haarg.org&gt;</li>
  <li>Graham Ollis &lt;plicease@cpan.org&gt;</li>
  <li>Ian Sillitoe &lt;ian@sillit.com&gt;</li>
  <li>James Hunt &lt;james@niftylogic.com&gt;</li>
  <li>John Karr &lt;brainbuz@brainbuz.org&gt;</li>
  <li>Karen Etheridge &lt;ether@cpan.org&gt;</li>
  <li>Mark Ellis &lt;mark.ellis@cartridgesave.co.uk&gt;</li>
  <li>Martin H. Sluka &lt;fany@cpan.org&gt;</li>
  <li>Martin Kjeldsen &lt;mk@bluepipe.dk&gt;</li>
  <li>Michael G. Schwern &lt;mschwern@cpan.org&gt;</li>
  <li>Nigel Gregoire &lt;nigelgregoire@gmail.com&gt;</li>
  <li>Philippe Bruhat (BooK) &lt;book@cpan.org&gt;</li>
  <li>Regina Verbae &lt;regina-verbae@users.noreply.github.com&gt;</li>
  <li>Roy Ivy III &lt;rivy@cpan.org&gt;</li>
  <li>Shlomi Fish &lt;shlomif@shlomifish.org&gt;</li>
  <li>Smylers &lt;Smylers@stripey.com&gt;</li>
  <li>Tatsuhiko Miyagawa &lt;miyagawa@bulknews.net&gt;</li>
  <li>Toby Inkster &lt;tobyink@cpan.org&gt;</li>
  <li>Yanick Champoux &lt;yanick@babyl.dyndns.org&gt;</li>
  <li>&#xAE40;&#xB3C4;&#xD615; - Keedi Kim &lt;keedi@cpan.org&gt;</li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT_AND_LICENSE"><a class="permalink" href="#COPYRIGHT_AND_LICENSE">COPYRIGHT
  AND LICENSE</a></h1>
<p class="Pp">This software is Copyright (c) 2014 by David Golden.</p>
<p class="Pp">This is free software, licensed under:</p>
<p class="Pp"></p>
<pre>  The Apache License, Version 2.0, January 2004
</pre>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2020-04-26</td>
    <td class="foot-os">perl v5.34.0</td>
  </tr>
</table>
</body>
</html>
