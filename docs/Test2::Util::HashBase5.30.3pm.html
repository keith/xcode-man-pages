<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    .Nd, .Bf, .Op { display: inline; }
    .Pa, .Ad { font-style: italic; }
    .Ms { font-weight: bold; }
    .Bl-diag > dt { font-weight: bold; }
    code.Nm, .Fl, .Cm, .Ic, code.In, .Fd, .Fn, .Cd { font-weight: bold;
      font-family: inherit; }
  </style>
  <title>Test2::Util::HashBase(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Test2::Util::HashBase(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Test2::Util::HashBase(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Test2::Util::HashBase - Build hash based classes.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<p class="Pp">A class:</p>
<p class="Pp"></p>
<pre>    package My::Class;
    use strict;
    use warnings;
    # Generate 3 accessors
    use Test2::Util::HashBase qw/foo -bar ^baz &lt;bat &gt;ban +boo/;
    # Chance to initialize defaults
    sub init {
        my $self = shift;    # No other args
        $self-&gt;{+FOO} ||= &quot;foo&quot;;
        $self-&gt;{+BAR} ||= &quot;bar&quot;;
        $self-&gt;{+BAZ} ||= &quot;baz&quot;;
        $self-&gt;{+BAT} ||= &quot;bat&quot;;
        $self-&gt;{+BAN} ||= &quot;ban&quot;;
        $self-&gt;{+BOO} ||= &quot;boo&quot;;
    }
    sub print {
        print join &quot;, &quot; =&gt; map { $self-&gt;{$_} } FOO, BAR, BAZ, BAT, BAN, BOO;
    }
</pre>
<p class="Pp">Subclass it</p>
<p class="Pp"></p>
<pre>    package My::Subclass;
    use strict;
    use warnings;
    # Note, you should subclass before loading HashBase.
    use base 'My::Class';
    use Test2::Util::HashBase qw/bub/;
    sub init {
        my $self = shift;
        # We get the constants from the base class for free.
        $self-&gt;{+FOO} ||= 'SubFoo';
        $self-&gt;{+BUB} ||= 'bub';
        $self-&gt;SUPER::init();
    }
</pre>
<p class="Pp">use it:</p>
<p class="Pp"></p>
<pre>    package main;
    use strict;
    use warnings;
    use My::Class;
    # These are all functionally identical
    my $one   = My::Class-&gt;new(foo =&gt; 'MyFoo', bar =&gt; 'MyBar');
    my $two   = My::Class-&gt;new({foo =&gt; 'MyFoo', bar =&gt; 'MyBar'});
    my $three = My::Class-&gt;new(['MyFoo', 'MyBar']);
    # Readers!
    my $foo = $one-&gt;foo;    # 'MyFoo'
    my $bar = $one-&gt;bar;    # 'MyBar'
    my $baz = $one-&gt;baz;    # Defaulted to: 'baz'
    my $bat = $one-&gt;bat;    # Defaulted to: 'bat'
    # '&gt;ban' means setter only, no reader
    # '+boo' means no setter or reader, just the BOO constant
    # Setters!
    $one-&gt;set_foo('A Foo');
    #'-bar' means read-only, so the setter will throw an exception (but is defined).
    $one-&gt;set_bar('A bar');
    # '^baz' means deprecated setter, this will warn about the setter being
    # deprecated.
    $one-&gt;set_baz('A Baz');
    # '&lt;bat' means no setter defined at all
    # '+boo' means no setter or reader, just the BOO constant
    $one-&gt;{+FOO} = 'xxx';
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">This package is used to generate classes based on hashrefs. Using
    this class will give you a <span class="Li">&quot;new()&quot;</span> method,
    as well as generating accessors you request. Generated accessors will be
    getters, <span class="Li">&quot;set_ACCESSOR&quot;</span> setters will also
    be generated for you. You also get constants for each accessor (all caps)
    which return the key into the hash for that accessor. Single inheritance is
    also supported.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="THIS_IS_A_BUNDLED_COPY_OF_HASHBASE"><a class="permalink" href="#THIS_IS_A_BUNDLED_COPY_OF_HASHBASE">THIS
  IS A BUNDLED COPY OF HASHBASE</a></h1>
<p class="Pp">This is a bundled copy of Object::HashBase. This file was
    generated using the
    <span class="Li">&quot;/home/exodist/perl5/perlbrew/perls/main/bin/hashbase_inc.pl&quot;</span>
    script.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="METHODS"><a class="permalink" href="#METHODS">METHODS</a></h1>
<section class="Ss">
<h2 class="Ss">PROVIDED BY HASH BASE</h2>
<dl class="Bl-tag">
  <dt>$it = $class-&gt;new(%PAIRS)</dt>
  <dd></dd>
  <dt>$it = $class-&gt;new(\%PAIRS)</dt>
  <dd></dd>
  <dt>$it = $class-&gt;new(\@ORDERED_VALUES)</dt>
  <dd>Create a new instance.
    <p class="Pp">HashBase will not export
        <span class="Li">&quot;new()&quot;</span> if there is already a
        <span class="Li">&quot;new()&quot;</span> method in your packages
        inheritance chain.</p>
    <p class="Pp"><b>If you do not want this method you can define your own</b>
        you just have to declare it before loading Test2::Util::HashBase.</p>
    <p class="Pp"></p>
    <pre>    package My::Package;
    # predeclare new() so that HashBase does not give us one.
    sub new;
    use Test2::Util::HashBase qw/foo bar baz/;
    # Now we define our own new method.
    sub new { ... }
    </pre>
    <p class="Pp">This makes it so that HashBase sees that you have your own
        <span class="Li">&quot;new()&quot;</span> method. Alternatively you can
        define the method before loading HashBase instead of just declaring it,
        but that scatters your use statements.</p>
    <p class="Pp">The most common way to create an object is to pass in
        key/value pairs where each key is an attribute and each value is what
        you want assigned to that attribute. No checking is done to verify the
        attributes or values are valid, you may do that in
        <span class="Li">&quot;init()&quot;</span> if desired.</p>
    <p class="Pp">If you would like, you can pass in a hashref instead of pairs.
        When you do so the hashref will be copied, and the copy will be returned
        blessed as an object. There is no way to ask HashBase to bless a
        specific hashref.</p>
    <p class="Pp">In some cases an object may only have 1 or 2 attributes, in
        which case a hashref may be too verbose for your liking. In these cases
        you can pass in an arrayref with only values. The values will be
        assigned to attributes in the order the attributes were listed. When
        there is inheritance involved the attributes from parent classes will
        come before subclasses.</p>
  </dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss">HOOKS</h2>
<dl class="Bl-tag">
  <dt>$self-&gt;<b>init()</b></dt>
  <dd>This gives you the chance to set some default values to your fields. The
      only argument is <span class="Li">$self</span> with its indexes already
      set from the constructor.
    <p class="Pp"><b>Note:</b> Test2::Util::HashBase checks for an init using
        <span class="Li">&quot;$class-&gt;can('init')&quot;</span> during
        construction. It DOES NOT call <span class="Li">&quot;can()&quot;</span>
        on the created object. Also note that the result of the check is cached,
        it is only ever checked once, the first time an instance of your class
        is created. This means that adding an
        <span class="Li">&quot;init()&quot;</span> method AFTER the first
        construction will result in it being ignored.</p>
  </dd>
</dl>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="ACCESSORS"><a class="permalink" href="#ACCESSORS">ACCESSORS</a></h1>
<section class="Ss">
<h2 class="Ss">READ/WRITE</h2>
<p class="Pp">To generate accessors you list them when using the module:</p>
<p class="Pp"></p>
<pre>    use Test2::Util::HashBase qw/foo/;
</pre>
<p class="Pp">This will generate the following subs in your namespace:</p>
<dl class="Bl-tag">
  <dt id="foo()"><a class="permalink" href="#foo()"><b>foo()</b></a></dt>
  <dd>Getter, used to get the value of the
      <span class="Li">&quot;foo&quot;</span> field.</dd>
  <dt id="set_foo()"><a class="permalink" href="#set_foo()"><b>set_foo()</b></a></dt>
  <dd>Setter, used to set the value of the
      <span class="Li">&quot;foo&quot;</span> field.</dd>
  <dt id="FOO"><a class="permalink" href="#FOO"><b>FOO()</b></a></dt>
  <dd>Constant, returns the field <span class="Li">&quot;foo&quot;</span>'s key
      into the class hashref. Subclasses will also get this function as a
      constant, not simply a method, that means it is copied into the subclass
      namespace.
    <p class="Pp">The main reason for using these constants is to help avoid
        spelling mistakes and similar typos. It will not help you if you forget
        to prefix the '+' though.</p>
  </dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss">READ ONLY</h2>
<pre>    use Test2::Util::HashBase qw/-foo/;
</pre>
<dl class="Bl-tag">
  <dt id="set_foo()~2"><a class="permalink" href="#set_foo()~2"><b>set_foo()</b></a></dt>
  <dd>Throws an exception telling you the attribute is read-only. This is
      exported to override any active setters for the attribute in a parent
      class.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss">DEPRECATED SETTER</h2>
<pre>    use Test2::Util::HashBase qw/^foo/;
</pre>
<dl class="Bl-tag">
  <dt id="set_foo()~3"><a class="permalink" href="#set_foo()~3"><b>set_foo()</b></a></dt>
  <dd>This will set the value, but it will also warn you that the method is
      deprecated.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss">NO SETTER</h2>
<pre>    use Test2::Util::HashBase qw/&lt;foo/;
</pre>
<p class="Pp">Only gives you a reader, no
    <span class="Li">&quot;set_foo&quot;</span> method is defined at all.</p>
</section>
<section class="Ss">
<h2 class="Ss">NO READER</h2>
<pre>    use Test2::Util::HashBase qw/&gt;foo/;
</pre>
<p class="Pp">Only gives you a write
    (<span class="Li">&quot;set_foo&quot;</span>), no
    <span class="Li">&quot;foo&quot;</span> method is defined at all.</p>
</section>
<section class="Ss">
<h2 class="Ss">CONSTANT ONLY</h2>
<pre>    use Test2::Util::HashBase qw/+foo/;
</pre>
<p class="Pp">This does not create any methods for you, it just adds the
    <span class="Li">&quot;FOO&quot;</span> constant.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="SUBCLASSING"><a class="permalink" href="#SUBCLASSING">SUBCLASSING</a></h1>
<p class="Pp">You can subclass an existing HashBase class.</p>
<p class="Pp"></p>
<pre>    use base 'Another::HashBase::Class';
    use Test2::Util::HashBase qw/foo bar baz/;
</pre>
<p class="Pp">The base class is added to <span class="Li">@ISA</span> for you,
    and all constants from base classes are added to subclasses
  automatically.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="GETTING_A_LIST_OF_ATTRIBUTES_FOR_A_CLASS"><a class="permalink" href="#GETTING_A_LIST_OF_ATTRIBUTES_FOR_A_CLASS">GETTING
  A LIST OF ATTRIBUTES FOR A CLASS</a></h1>
<p class="Pp">Test2::Util::HashBase provides a function for retrieving a list of
    attributes for an Test2::Util::HashBase class.</p>
<dl class="Bl-tag">
  <dt>@list = Test2::Util::HashBase::attr_list($class)</dt>
  <dd></dd>
  <dt>@list = $class-&gt;<b>Test2::Util::HashBase::attr_list()</b></dt>
  <dd>Either form above will work. This will return a list of attributes defined
      on the object. This list is returned in the attribute definition order,
      parent class attributes are listed before subclass attributes. Duplicate
      attributes will be removed before the list is returned.
    <p class="Pp"><b>Note:</b> This list is used in the
        <span class="Li">&quot;$class-&gt;new(\@ARRAY)&quot;</span> constructor
        to determine the attribute to which each value will be paired.</p>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="SOURCE"><a class="permalink" href="#SOURCE">SOURCE</a></h1>
<p class="Pp">The source code repository for HashBase can be found at
    <i>http://github.com/Test-More/HashBase/</i>.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="MAINTAINERS"><a class="permalink" href="#MAINTAINERS">MAINTAINERS</a></h1>
<dl class="Bl-tag">
  <dt id="Chad"><a class="permalink" href="#Chad">Chad Granum
    &lt;exodist@cpan.org&gt;</a></dt>
  <dd></dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHORS"><a class="permalink" href="#AUTHORS">AUTHORS</a></h1>
<dl class="Bl-tag">
  <dt id="Chad~2"><a class="permalink" href="#Chad~2">Chad Granum
    &lt;exodist@cpan.org&gt;</a></dt>
  <dd></dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT"><a class="permalink" href="#COPYRIGHT">COPYRIGHT</a></h1>
<p class="Pp">Copyright 2017 Chad Granum &lt;exodist@cpan.org&gt;.</p>
<p class="Pp">This program is free software; you can redistribute it and/or
    modify it under the same terms as Perl itself.</p>
<p class="Pp">See <i>http://dev.perl.org/licenses/</i></p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2020-10-22</td>
    <td class="foot-os">perl v5.30.2</td>
  </tr>
</table>
</body>
</html>
