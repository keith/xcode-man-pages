<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>PERLINTRO(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">PERLINTRO(1)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">PERLINTRO(1)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
perlintro -- a brief introduction and overview of Perl
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
This document is intended to give you a quick overview of the Perl programming
  language, along with pointers to further documentation. It is intended as a
  &quot;bootstrap&quot; guide for those who are new to the language, and
  provides just enough information for you to be able to read other peoples'
  Perl and understand roughly what it's doing, or write your own simple scripts.
<p class="Pp">This introductory document does not aim to be complete. It does
    not even aim to be entirely accurate. In some cases perfection has been
    sacrificed in the goal of getting the general idea across. You are
    <i>strongly</i> advised to follow this introduction with more information
    from the full Perl manual, the table of contents to which can be found in
    perltoc.</p>
<p class="Pp">Throughout this document you'll see references to other parts of
    the Perl documentation. You can read that documentation using the
    <span class="Li">&quot;perldoc&quot;</span> command or whatever method
    you're using to read this document.</p>
<p class="Pp">Throughout Perl's documentation, you'll find numerous examples
    intended to help explain the discussed features. Please keep in mind that
    many of them are code fragments rather than complete programs.</p>
<p class="Pp">These examples often reflect the style and preference of the
    author of that piece of the documentation, and may be briefer than a
    corresponding line of code in a real program. Except where otherwise noted,
    you should assume that <span class="Li">&quot;use strict&quot;</span> and
    <span class="Li">&quot;use warnings&quot;</span> statements appear earlier
    in the &quot;program&quot;, and that any variables used have already been
    declared, even if those declarations have been omitted to make the example
    easier to read.</p>
<p class="Pp">Do note that the examples have been written by many different
    authors over a period of several decades. Styles and techniques will
    therefore differ, although some effort has been made to not vary styles too
    widely in the same sections. Do not consider one style to be better than
    others - &quot;There's More Than One Way To Do It&quot; is one of Perl's
    mottos. After all, in your journey as a programmer, you are likely to
    encounter different styles.</p>
<section class="Ss">
<h2 class="Ss" id="What_is_Perl?"><a class="permalink" href="#What_is_Perl?">What
  is Perl?</a></h2>
Perl is a general-purpose programming language originally developed for text
  manipulation and now used for a wide range of tasks including system
  administration, web development, network programming, GUI development, and
  more.
<p class="Pp">The language is intended to be practical (easy to use, efficient,
    complete) rather than beautiful (tiny, elegant, minimal). Its major features
    are that it's easy to use, supports both procedural and object-oriented (OO)
    programming, has powerful built-in support for text processing, and has one
    of the world's most impressive collections of third-party modules.</p>
<p class="Pp">Different definitions of Perl are given in perl, perlfaq1 and no
    doubt other places. From this we can determine that Perl is different things
    to different people, but that lots of people think it's at least worth
    writing about.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Running_Perl_programs"><a class="permalink" href="#Running_Perl_programs">Running
  Perl programs</a></h2>
To run a Perl program from the Unix command line:
<p class="Pp"><span class="Li"></span></p>
<pre>
 perl progname.pl
</pre>
<p class="Pp">Alternatively, put this as the first line of your script:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
 #!/usr/bin/env perl
</pre>
<p class="Pp">... and run the script as <i>/path/to/script.pl</i>. Of course,
    it'll need to be executable first, so <span class="Li">&quot;chmod 755
    script.pl&quot;</span> (under Unix).</p>
<p class="Pp">(This start line assumes you have the <b>env</b> program. You can
    also put directly the path to your perl executable, like in
    <span class="Li">&quot;#!/usr/bin/perl&quot;</span>).</p>
<p class="Pp">For more information, including instructions for other platforms
    such as Windows and Mac OS, read perlrun.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Safety_net"><a class="permalink" href="#Safety_net">Safety
  net</a></h2>
Perl by default is very forgiving. In order to make it more robust it is
  recommended to start every program with the following lines:
<p class="Pp"><span class="Li"></span></p>
<pre>
 #!/usr/bin/perl
 use strict;
 use warnings;
</pre>
<p class="Pp">The two additional lines request from perl to catch various common
    problems in your code. They check different things so you need both. A
    potential problem caught by <span class="Li">&quot;use strict;&quot;</span>
    will cause your code to stop immediately when it is encountered, while
    <span class="Li">&quot;use warnings;&quot;</span> will merely give a warning
    (like the command-line switch <b>-w</b>) and let your code run. To read more
    about them check their respective manual pages at strict and warnings.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Basic_syntax_overview"><a class="permalink" href="#Basic_syntax_overview">Basic
  syntax overview</a></h2>
A Perl script or program consists of one or more statements. These statements
  are simply written in the script in a straightforward fashion. There is no
  need to have a <span class="Li">&quot;main()&quot;</span> function or anything
  of that kind.
<p class="Pp">Perl statements end in a semi-colon:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
 print &quot;Hello, world&quot;;
</pre>
<p class="Pp">Comments start with a hash symbol and run to the end of the
  line</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
 # This is a comment
</pre>
<p class="Pp">Whitespace is irrelevant:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
 print
     &quot;Hello, world&quot;
     ;
</pre>
<p class="Pp">... except inside quoted strings:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
 # this would print with a linebreak in the middle
 print &quot;Hello
 world&quot;;
</pre>
<p class="Pp">Double quotes or single quotes may be used around literal
  strings:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
 print &quot;Hello, world&quot;;
 print 'Hello, world';
</pre>
<p class="Pp">However, only double quotes &quot;interpolate&quot; variables and
    special characters such as newlines
    (<span class="Li">&quot;\n&quot;</span>):</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
 print &quot;Hello, $name\n&quot;;     # works fine
 print 'Hello, $name\n';     # prints $name\n literally
</pre>
<p class="Pp">Numbers don't need quotes around them:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
 print 42;
</pre>
<p class="Pp">You can use parentheses for functions' arguments or omit them
    according to your personal taste. They are only required occasionally to
    clarify issues of precedence.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
 print(&quot;Hello, world\n&quot;);
 print &quot;Hello, world\n&quot;;
</pre>
<p class="Pp">More detailed information about Perl syntax can be found in
    perlsyn.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Perl_variable_types"><a class="permalink" href="#Perl_variable_types">Perl
  variable types</a></h2>
Perl has three main variable types: scalars, arrays, and hashes.
<dl class="Bl-tag">
  <dt>Scalars</dt>
  <dd>A scalar represents a single value:
    <p class="Pp"><span class="Li"></span></p>
    <pre>
 my $animal = &quot;camel&quot;;
 my $answer = 42;
    </pre>
    <p class="Pp">Scalar values can be strings, integers or floating point
        numbers, and Perl will automatically convert between them as required.
        There is no need to pre-declare your variable types, but you have to
        declare them using the <span class="Li">&quot;my&quot;</span> keyword
        the first time you use them. (This is one of the requirements of
        <span class="Li">&quot;use strict;&quot;</span>.)</p>
    <p class="Pp">Scalar values can be used in various ways:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
 print $animal;
 print &quot;The animal is $animal\n&quot;;
 print &quot;The square of $answer is &quot;, $answer * $answer, &quot;\n&quot;;
    </pre>
    <p class="Pp">There are a number of &quot;magic&quot; scalars with names
        that look like punctuation or line noise. These special variables are
        used for all kinds of purposes, and are documented in perlvar. The only
        one you need to know about for now is <span class="Li">$_</span> which
        is the &quot;default variable&quot;. It's used as the default argument
        to a number of functions in Perl, and it's set implicitly by certain
        looping constructs.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
 print;          # prints contents of $_ by default
    </pre>
  </dd>
  <dt>Arrays</dt>
  <dd>An array represents a list of values:
    <p class="Pp"><span class="Li"></span></p>
    <pre>
 my @animals = (&quot;camel&quot;, &quot;llama&quot;, &quot;owl&quot;);
 my @numbers = (23, 42, 69);
 my @mixed   = (&quot;camel&quot;, 42, 1.23);
    </pre>
    <p class="Pp">Arrays are zero-indexed. Here's how you get at elements in an
        array:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
 print $animals[0];              # prints &quot;camel&quot;
 print $animals[1];              # prints &quot;llama&quot;
    </pre>
    <p class="Pp">The special variable <span class="Li">$#array</span> tells you
        the index of the last element of an array:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
 print $mixed[$#mixed];       # last element, prints 1.23
    </pre>
    <p class="Pp">You might be tempted to use <span class="Li">&quot;$#array +
        1&quot;</span> to tell you how many items there are in an array. Don't
        bother. As it happens, using <span class="Li">@array</span> where Perl
        expects to find a scalar value (&quot;in scalar context&quot;) will give
        you the number of elements in the array:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
 if (@animals &lt; 5) { ... }
    </pre>
    <p class="Pp">The elements we're getting from the array start with a
        <span class="Li">&quot;$&quot;</span> because we're getting just a
        single value out of the array; you ask for a scalar, you get a
      scalar.</p>
    <p class="Pp">To get multiple values from an array:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
 @animals[0,1];                 # gives (&quot;camel&quot;, &quot;llama&quot;);
 @animals[0..2];                # gives (&quot;camel&quot;, &quot;llama&quot;, &quot;owl&quot;);
 @animals[1..$#animals];        # gives all except the first element
    </pre>
    <p class="Pp">This is called an &quot;array slice&quot;.</p>
    <p class="Pp">You can do various useful things to lists:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
 my @sorted    = sort @animals;
 my @backwards = reverse @numbers;
    </pre>
    <p class="Pp">There are a couple of special arrays too, such as
        <span class="Li">@ARGV</span> (the command line arguments to your
        script) and <span class="Li">@_</span> (the arguments passed to a
        subroutine). These are documented in perlvar.</p>
  </dd>
  <dt>Hashes</dt>
  <dd>A hash represents a set of key/value pairs:
    <p class="Pp"><span class="Li"></span></p>
    <pre>
 my %fruit_color = (&quot;apple&quot;, &quot;red&quot;, &quot;banana&quot;, &quot;yellow&quot;);
    </pre>
    <p class="Pp">You can use whitespace and the
        <span class="Li">&quot;=&gt;&quot;</span> operator to lay them out more
        nicely:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
 my %fruit_color = (
     apple  =&gt; &quot;red&quot;,
     banana =&gt; &quot;yellow&quot;,
 );
    </pre>
    <p class="Pp">To get at hash elements:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
 $fruit_color{&quot;apple&quot;};           # gives &quot;red&quot;
    </pre>
    <p class="Pp">You can get at lists of keys and values with
        <span class="Li">&quot;keys()&quot;</span> and
        <span class="Li">&quot;values()&quot;</span>.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
 my @fruits = keys %fruit_colors;
 my @colors = values %fruit_colors;
    </pre>
    <p class="Pp">Hashes have no particular internal order, though you can sort
        the keys and loop through them.</p>
    <p class="Pp">Just like special scalars and arrays, there are also special
        hashes. The most well known of these is <span class="Li">%ENV</span>
        which contains environment variables. Read all about it (and other
        special variables) in perlvar.</p>
  </dd>
</dl>
<p class="Pp">Scalars, arrays and hashes are documented more fully in
  perldata.</p>
<p class="Pp">More complex data types can be constructed using references, which
    allow you to build lists and hashes within lists and hashes.</p>
<p class="Pp">A reference is a scalar value and can refer to any other Perl data
    type. So by storing a reference as the value of an array or hash element,
    you can easily create lists and hashes within lists and hashes. The
    following example shows a 2 level hash of hash structure using anonymous
    hash references.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
 my $variables = {
     scalar  =&gt;  {
                  description =&gt; &quot;single item&quot;,
                  sigil =&gt; '$',
                 },
     array   =&gt;  {
                  description =&gt; &quot;ordered list of items&quot;,
                  sigil =&gt; '@',
                 },
     hash    =&gt;  {
                  description =&gt; &quot;key/value pairs&quot;,
                  sigil =&gt; '%',
                 },
 };

 print &quot;Scalars begin with a $variables-&gt;{'scalar'}-&gt;{'sigil'}\n&quot;;
</pre>
<p class="Pp">Exhaustive information on the topic of references can be found in
    perlreftut, perllol, perlref and perldsc.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Variable_scoping"><a class="permalink" href="#Variable_scoping">Variable
  scoping</a></h2>
Throughout the previous section all the examples have used the syntax:
<p class="Pp"><span class="Li"></span></p>
<pre>
 my $var = &quot;value&quot;;
</pre>
<p class="Pp">The <span class="Li">&quot;my&quot;</span> is actually not
    required; you could just use:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
 $var = &quot;value&quot;;
</pre>
<p class="Pp">However, the above usage will create global variables throughout
    your program, which is bad programming practice.
    <span class="Li">&quot;my&quot;</span> creates lexically scoped variables
    instead. The variables are scoped to the block (i.e. a bunch of statements
    surrounded by curly-braces) in which they are defined.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
 my $x = &quot;foo&quot;;
 my $some_condition = 1;
 if ($some_condition) {
     my $y = &quot;bar&quot;;
     print $x;           # prints &quot;foo&quot;
     print $y;           # prints &quot;bar&quot;
 }
 print $x;               # prints &quot;foo&quot;
 print $y;               # prints nothing; $y has fallen out of scope
</pre>
<p class="Pp">Using <span class="Li">&quot;my&quot;</span> in combination with a
    <span class="Li">&quot;use strict;&quot;</span> at the top of your Perl
    scripts means that the interpreter will pick up certain common programming
    errors. For instance, in the example above, the final
    <span class="Li">&quot;print $y&quot;</span> would cause a compile-time
    error and prevent you from running the program. Using
    <span class="Li">&quot;strict&quot;</span> is highly recommended.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Conditional_and_looping_constructs"><a class="permalink" href="#Conditional_and_looping_constructs">Conditional
  and looping constructs</a></h2>
Perl has most of the usual conditional and looping constructs. As of Perl 5.10,
  it even has a case/switch statement (spelled
  <span class="Li">&quot;given&quot;</span>/<span class="Li">&quot;when&quot;</span>).
  See &quot;Switch Statements&quot; in perlsyn for more details.
<p class="Pp">The conditions can be any Perl expression. See the list of
    operators in the next section for information on comparison and boolean
    logic operators, which are commonly used in conditional statements.</p>
<dl class="Bl-tag">
  <dt>if</dt>
  <dd><span class="Li"></span>
    <pre>
 if ( condition ) {
     ...
 } elsif ( other condition ) {
     ...
 } else {
     ...
 }
    </pre>
    <p class="Pp">There's also a negated version of it:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
 unless ( condition ) {
     ...
 }
    </pre>
    <p class="Pp">This is provided as a more readable version of
        <span class="Li">&quot;if
        (!</span><i>condition</i><span class="Li">)&quot;</span>.</p>
    <p class="Pp">Note that the braces are required in Perl, even if you've only
        got one line in the block. However, there is a clever way of making your
        one-line conditional blocks more English like:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
 # the traditional way
 if ($zippy) {
     print &quot;Yow!&quot;;
 }

 # the Perlish post-condition way
 print &quot;Yow!&quot; if $zippy;
 print &quot;We have no bananas&quot; unless $bananas;
    </pre>
  </dd>
  <dt>while</dt>
  <dd><span class="Li"></span>
    <pre>
 while ( condition ) {
     ...
 }
    </pre>
    <p class="Pp">There's also a negated version, for the same reason we have
        <span class="Li">&quot;unless&quot;</span>:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
 until ( condition ) {
     ...
 }
    </pre>
    <p class="Pp">You can also use <span class="Li">&quot;while&quot;</span> in
        a post-condition:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
 print &quot;LA LA LA\n&quot; while 1;          # loops forever
    </pre>
  </dd>
  <dt>for</dt>
  <dd>Exactly like C:
    <p class="Pp"><span class="Li"></span></p>
    <pre>
 for ($i = 0; $i &lt;= $max; $i++) {
     ...
 }
    </pre>
    <p class="Pp">The C style for loop is rarely needed in Perl since Perl
        provides the more friendly list scanning
        <span class="Li">&quot;foreach&quot;</span> loop.</p>
  </dd>
  <dt>foreach</dt>
  <dd><span class="Li"></span>
    <pre>
 foreach (@array) {
     print &quot;This element is $_\n&quot;;
 }

 print $list[$_] foreach 0 .. $max;

 # you don't have to use the default $_ either...
 foreach my $key (keys %hash) {
     print &quot;The value of $key is $hash{$key}\n&quot;;
 }
    </pre>
    <p class="Pp">The <span class="Li">&quot;foreach&quot;</span> keyword is
        actually a synonym for the <span class="Li">&quot;for&quot;</span>
        keyword. See <span class="Li">&quot;&quot;Foreach Loops&quot; in
        perlsyn&quot;</span>.</p>
  </dd>
</dl>
<p class="Pp">For more detail on looping constructs (and some that weren't
    mentioned in this overview) see perlsyn.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Builtin_operators_and_functions"><a class="permalink" href="#Builtin_operators_and_functions">Builtin
  operators and functions</a></h2>
Perl comes with a wide selection of builtin functions. Some of the ones we've
  already seen include <span class="Li">&quot;print&quot;</span>,
  <span class="Li">&quot;sort&quot;</span> and
  <span class="Li">&quot;reverse&quot;</span>. A list of them is given at the
  start of perlfunc and you can easily read about any given function by using
  <span class="Li">&quot;perldoc -f
  </span><i>functionname</i><span class="Li">&quot;</span>.
<p class="Pp">Perl operators are documented in full in perlop, but here are a
    few of the most common ones:</p>
<dl class="Bl-tag">
  <dt>Arithmetic</dt>
  <dd><span class="Li"></span>
    <pre>
 +   addition
 -   subtraction
 *   multiplication
 /   division
    </pre>
  </dd>
  <dt>Numeric comparison</dt>
  <dd><span class="Li"></span>
    <pre>
 ==  equality
 !=  inequality
 &lt;   less than
 &gt;   greater than
 &lt;=  less than or equal
 &gt;=  greater than or equal
    </pre>
  </dd>
  <dt>String comparison</dt>
  <dd><span class="Li"></span>
    <pre>
 eq  equality
 ne  inequality
 lt  less than
 gt  greater than
 le  less than or equal
 ge  greater than or equal
    </pre>
    <p class="Pp">(Why do we have separate numeric and string comparisons?
        Because we don't have special variable types, and Perl needs to know
        whether to sort numerically (where 99 is less than 100) or
        alphabetically (where 100 comes before 99).</p>
  </dd>
  <dt>Boolean logic</dt>
  <dd><span class="Li"></span>
    <pre>
 &amp;&amp;  and
 ||  or
 !   not
    </pre>
    <p class="Pp">(<span class="Li">&quot;and&quot;</span>,
        <span class="Li">&quot;or&quot;</span> and
        <span class="Li">&quot;not&quot;</span> aren't just in the above table
        as descriptions of the operators. They're also supported as operators in
        their own right. They're more readable than the C-style operators, but
        have different precedence to
        <span class="Li">&quot;&amp;&amp;&quot;</span> and friends. Check perlop
        for more detail.)</p>
  </dd>
  <dt>Miscellaneous</dt>
  <dd><span class="Li"></span>
    <pre>
 =   assignment
 .   string concatenation
 x   string multiplication
 ..  range operator (creates a list of numbers)
    </pre>
  </dd>
</dl>
<p class="Pp">Many operators can be combined with a
    <span class="Li">&quot;=&quot;</span> as follows:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
 $a += 1;        # same as $a = $a + 1
 $a -= 1;        # same as $a = $a - 1
 $a .= &quot;\n&quot;;     # same as $a = $a . &quot;\n&quot;;
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Files_and_I/O"><a class="permalink" href="#Files_and_I/O">Files
  and I/O</a></h2>
You can open a file for input or output using the
  <span class="Li">&quot;open()&quot;</span> function. It's documented in
  extravagant detail in perlfunc and perlopentut, but in short:
<p class="Pp"><span class="Li"></span></p>
<pre>
 open(my $in,  &quot;&lt;&quot;,  &quot;input.txt&quot;)  or die &quot;Can't open input.txt: $!&quot;;
 open(my $out, &quot;&gt;&quot;,  &quot;output.txt&quot;) or die &quot;Can't open output.txt: $!&quot;;
 open(my $log, &quot;&gt;&gt;&quot;, &quot;my.log&quot;)     or die &quot;Can't open my.log: $!&quot;;
</pre>
<p class="Pp">You can read from an open filehandle using the
    <span class="Li">&quot;&lt;&gt;&quot;</span> operator. In scalar context it
    reads a single line from the filehandle, and in list context it reads the
    whole file in, assigning each line to an element of the list:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
 my $line  = &lt;$in&gt;;
 my @lines = &lt;$in&gt;;
</pre>
<p class="Pp">Reading in the whole file at one time is called slurping. It can
    be useful but it may be a memory hog. Most text file processing can be done
    a line at a time with Perl's looping constructs.</p>
<p class="Pp">The <span class="Li">&quot;&lt;&gt;&quot;</span> operator is most
    often seen in a <span class="Li">&quot;while&quot;</span> loop:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
 while (&lt;$in&gt;) {     # assigns each line in turn to $_
     print &quot;Just read in this line: $_&quot;;
 }
</pre>
<p class="Pp">We've already seen how to print to standard output using
    <span class="Li">&quot;print()&quot;</span>. However,
    <span class="Li">&quot;print()&quot;</span> can also take an optional first
    argument specifying which filehandle to print to:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
 print STDERR &quot;This is your final warning.\n&quot;;
 print $out $record;
 print $log $logmessage;
</pre>
<p class="Pp">When you're done with your filehandles, you should
    <span class="Li">&quot;close()&quot;</span> them (though to be honest, Perl
    will clean up after you if you forget):</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
 close $in or die &quot;$in: $!&quot;;
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Regular_expressions"><a class="permalink" href="#Regular_expressions">Regular
  expressions</a></h2>
Perl's regular expression support is both broad and deep, and is the subject of
  lengthy documentation in perlrequick, perlretut, and elsewhere. However, in
  short:
<dl class="Bl-tag">
  <dt>Simple matching</dt>
  <dd><span class="Li"></span>
    <pre>
 if (/foo/)       { ... }  # true if $_ contains &quot;foo&quot;
 if ($a =~ /foo/) { ... }  # true if $a contains &quot;foo&quot;
    </pre>
    <p class="Pp">The <span class="Li">&quot;//&quot;</span> matching operator
        is documented in perlop. It operates on <span class="Li">$_</span> by
        default, or can be bound to another variable using the
        <span class="Li">&quot;=~&quot;</span> binding operator (also documented
        in perlop).</p>
  </dd>
  <dt>Simple substitution</dt>
  <dd><span class="Li"></span>
    <pre>
 s/foo/bar/;               # replaces foo with bar in $_
 $a =~ s/foo/bar/;         # replaces foo with bar in $a
 $a =~ s/foo/bar/g;        # replaces ALL INSTANCES of foo with bar
                           # in $a
    </pre>
    <p class="Pp">The <span class="Li">&quot;s///&quot;</span> substitution
        operator is documented in perlop.</p>
  </dd>
  <dt>More complex regular expressions</dt>
  <dd>You don't just have to match on fixed strings. In fact, you can match on
      just about anything you could dream of by using more complex regular
      expressions. These are documented at great length in perlre, but for the
      meantime, here's a quick cheat sheet:
    <p class="Pp"><span class="Li"></span></p>
    <pre>
 .                   a single character
 \s                  a whitespace character (space, tab, newline,
                     ...)
 \S                  non-whitespace character
 \d                  a digit (0-9)
 \D                  a non-digit
 \w                  a word character (a-z, A-Z, 0-9, _)
 \W                  a non-word character
 [aeiou]             matches a single character in the given set
 [^aeiou]            matches a single character outside the given
                     set
 (foo|bar|baz)       matches any of the alternatives specified

 ^                   start of string
 $                   end of string
    </pre>
    <p class="Pp">Quantifiers can be used to specify how many of the previous
        thing you want to match on, where &quot;thing&quot; means either a
        literal character, one of the metacharacters listed above, or a group of
        characters or metacharacters in parentheses.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
 *                   zero or more of the previous thing
 +                   one or more of the previous thing
 ?                   zero or one of the previous thing
 {3}                 matches exactly 3 of the previous thing
 {3,6}               matches between 3 and 6 of the previous thing
 {3,}                matches 3 or more of the previous thing
    </pre>
    <p class="Pp">Some brief examples:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
 /^\d+/              string starts with one or more digits
 /^$/                nothing in the string (start and end are
                     adjacent)
 /(\d\s){3}/         three digits, each followed by a whitespace
                     character (eg &quot;3 4 5 &quot;)
 /(a.)+/             matches a string in which every odd-numbered
                     letter is a (eg &quot;abacadaf&quot;)

 # This loop reads from STDIN, and prints non-blank lines:
 while (&lt;&gt;) {
     next if /^$/;
     print;
 }
    </pre>
  </dd>
  <dt>Parentheses for capturing</dt>
  <dd>As well as grouping, parentheses serve a second purpose. They can be used
      to capture the results of parts of the regexp match for later use. The
      results end up in <span class="Li">$1</span>, <span class="Li">$2</span>
      and so on.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
 # a cheap and nasty way to break an email address up into parts

 if ($email =~ /([^@]+)@(.+)/) {
     print &quot;Username is $1\n&quot;;
     print &quot;Hostname is $2\n&quot;;
 }
    </pre>
  </dd>
  <dt>Other regexp features</dt>
  <dd>Perl regexps also support backreferences, lookaheads, and all kinds of
      other complex details. Read all about them in perlrequick, perlretut, and
      perlre.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Writing_subroutines"><a class="permalink" href="#Writing_subroutines">Writing
  subroutines</a></h2>
Writing subroutines is easy:
<p class="Pp"><span class="Li"></span></p>
<pre>
 sub logger {
    my $logmessage = shift;
    open my $logfile, &quot;&gt;&gt;&quot;, &quot;my.log&quot; or die &quot;Could not open my.log: $!&quot;;
    print $logfile $logmessage;
 }
</pre>
<p class="Pp">Now we can use the subroutine just as any other built-in
  function:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
 logger(&quot;We have a logger subroutine!&quot;);
</pre>
<p class="Pp">What's that <span class="Li">&quot;shift&quot;</span>? Well, the
    arguments to a subroutine are available to us as a special array called
    <span class="Li">@_</span> (see perlvar for more on that). The default
    argument to the <span class="Li">&quot;shift&quot;</span> function just
    happens to be <span class="Li">@_</span>. So <span class="Li">&quot;my
    $logmessage = shift;&quot;</span> shifts the first item off the list of
    arguments and assigns it to <span class="Li">$logmessage</span>.</p>
<p class="Pp">We can manipulate <span class="Li">@_</span> in other ways
  too:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
 my ($logmessage, $priority) = @_;       # common
 my $logmessage = $_[0];                 # uncommon, and ugly
</pre>
<p class="Pp">Subroutines can also return values:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
 sub square {
     my $num = shift;
     my $result = $num * $num;
     return $result;
 }
</pre>
<p class="Pp">Then use it like:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
 $sq = square(8);
</pre>
<p class="Pp">For more information on writing subroutines, see perlsub.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_s-1OO_s0_Perl"><a class="permalink" href="#_s-1OO_s0_Perl">OO
  Perl</a></h2>
OO Perl is relatively simple and is implemented using references which know what
  sort of object they are based on Perl's concept of packages. However, OO Perl
  is largely beyond the scope of this document. Read perlootut and perlobj.
<p class="Pp">As a beginning Perl programmer, your most common use of OO Perl
    will be in using third-party modules, which are documented below.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Using_Perl_modules"><a class="permalink" href="#Using_Perl_modules">Using
  Perl modules</a></h2>
Perl modules provide a range of features to help you avoid reinventing the
  wheel, and can be downloaded from CPAN ( http://www.cpan.org/ ). A number of
  popular modules are included with the Perl distribution itself.
<p class="Pp">Categories of modules range from text manipulation to network
    protocols to database integration to graphics. A categorized list of modules
    is also available from CPAN.</p>
<p class="Pp">To learn how to install modules you download from CPAN, read
    perlmodinstall.</p>
<p class="Pp">To learn how to use a particular module, use
    <span class="Li">&quot;perldoc
    </span><i>Module::Name</i><span class="Li">&quot;</span>. Typically you will
    want to <span class="Li">&quot;use
    </span><i>Module::Name</i><span class="Li">&quot;</span>, which will then
    give you access to exported functions or an OO interface to the module.</p>
<p class="Pp">perlfaq contains questions and answers related to many common
    tasks, and often provides suggestions for good CPAN modules to use.</p>
<p class="Pp">perlmod describes Perl modules in general. perlmodlib lists the
    modules which came with your Perl installation.</p>
<p class="Pp">If you feel the urge to write Perl modules, perlnewmod will give
    you good advice.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
Kirrily &quot;Skud&quot; Robert &lt;skud@cpan.org&gt;
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2014-01-31</td>
    <td class="foot-os">perl v5.18.4</td>
  </tr>
</table>
</body>
</html>
