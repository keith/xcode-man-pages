<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>XML::Simple::FAQ(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">XML::Simple::FAQ(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">XML::Simple::FAQ(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
XML::Simple::FAQ - Frequently Asked Questions about XML::Simple
</section>
<section class="Sh">
<h1 class="Sh" id="Basics"><a class="permalink" href="#Basics">Basics</a></h1>
<section class="Ss">
<h2 class="Ss" id="What_should_I_use_XML::Simple_for?"><a class="permalink" href="#What_should_I_use_XML::Simple_for?">What
  should I use XML::Simple for?</a></h2>
Nothing!
<p class="Pp">It's as simple as that.</p>
<p class="Pp">Choose a better module. See Perl XML::LibXML by Example
    &lt;http://grantm.github.io/perl-libxml-by-example/&gt; for a gentle
    introduction to XML::LibXML with lots of examples.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="What_was_XML::Simple_designed_to_be_used_for?"><a class="permalink" href="#What_was_XML::Simple_designed_to_be_used_for?">What
  was XML::Simple designed to be used for?</a></h2>
XML::Simple is a Perl module that was originally developed as a tool for reading
  and writing configuration data in XML format. You could use it for other
  purposes that involve storing and retrieving structured data in XML but it's
  likely to be a frustrating experience.
</section>
<section class="Ss">
<h2 class="Ss" id="Why_store_configuration_data_in__s-1XML_s0_anyway?"><a class="permalink" href="#Why_store_configuration_data_in__s-1XML_s0_anyway?">Why
  store configuration data in XML anyway?</a></h2>
It seemed like a good idea at the time. Now, I use and recommend Config::General
  which uses a format similar to that used by the Apache web server. This is
  easier to read than XML while still allowing advanced concepts such as nested
  sections.
<p class="Pp">At the time XML::Simple was written, the advantages of using XML
    format for configuration data were thought to include:</p>
<ul class="Bl-bullet">
  <li>Using existing XML parsing tools requires less development time, is easier
      and more robust than developing your own config file parsing code</li>
  <li>XML can represent relationships between pieces of data, such as nesting of
      sections to arbitrary levels (not easily done with .INI files for
    example)</li>
  <li>XML is basically just text, so you can easily edit a config file (easier
      than editing a Win32 registry)</li>
  <li>XML provides standard solutions for handling character sets and encoding
      beyond basic ASCII (important for internationalization)</li>
  <li>If it becomes necessary to change your configuration file format, there
      are many tools available for performing transformations on XML files</li>
  <li>XML is an open standard (the world does not need more proprietary binary
      file formats)</li>
  <li>Taking the extra step of developing a DTD allows the format of
      configuration files to be validated before your program reads them (not
      directly supported by XML::Simple)</li>
  <li>Combining a DTD with a good XML editor can give you a GUI config editor
      for minimal coding effort</li>
</ul>
</section>
<section class="Ss">
<h2 class="Ss" id="What_isn't_XML::Simple_good_for?"><a class="permalink" href="#What_isn't_XML::Simple_good_for?">What
  isn't XML::Simple good for?</a></h2>
The main limitation of XML::Simple is that it does not work with 'mixed content'
  (see the next question). If you consider your XML files contain marked up text
  rather than structured data, you should probably use another module.
<p class="Pp">If your source XML documents change regularly, it's likely that
    you will experience intermittent failures. In particular, failure to
    properly use the ForceArray and KeyAttr options will produce code that works
    when you get a list of elements with the same name, but fails when there's
    only one item in the list. These types of problems can be avoided by not
    using XML::Simple in the first place.</p>
<p class="Pp">If you are working with very large XML files, XML::Simple's
    approach of representing the whole file in memory as a 'tree' data structure
    may not be suitable.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="What_is_mixed_content?"><a class="permalink" href="#What_is_mixed_content?">What
  is mixed content?</a></h2>
Consider this example XML:
<p class="Pp"><span class="Li"></span></p>
<pre>
  &lt;document&gt;
    &lt;para&gt;This is &lt;em&gt;mixed&lt;/em&gt; content.&lt;/para&gt;
  &lt;/document&gt;
</pre>
<p class="Pp">This is said to be mixed content, because the &lt;para&gt; element
    contains both character data (text content) and nested elements.</p>
<p class="Pp">Here's some more XML:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  &lt;person&gt;
    &lt;first_name&gt;Joe&lt;/first_name&gt;
    &lt;last_name&gt;Bloggs&lt;/last_name&gt;
    &lt;dob&gt;25-April-1969&lt;/dob&gt;
  &lt;/person&gt;
</pre>
<p class="Pp">This second example is not generally considered to be mixed
    content. The &lt;first_name&gt;, &lt;last_name&gt; and &lt;dob&gt; elements
    contain only character data and the &lt;person&gt; element contains only
    nested elements. (Note: Strictly speaking, the whitespace between the nested
    elements is character data, but it is ignored by XML::Simple).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Why_doesn't_XML::Simple_handle_mixed_content?"><a class="permalink" href="#Why_doesn't_XML::Simple_handle_mixed_content?">Why
  doesn't XML::Simple handle mixed content?</a></h2>
Because if it did, it would no longer be simple :-)
<p class="Pp">Seriously though, there are plenty of excellent modules that allow
    you to work with mixed content in a variety of ways. Handling mixed content
    correctly is not easy and by ignoring these issues, XML::Simple is able to
    present an API without a steep learning curve.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Which_Perl_modules_do_handle_mixed_content?"><a class="permalink" href="#Which_Perl_modules_do_handle_mixed_content?">Which
  Perl modules do handle mixed content?</a></h2>
Every one of them except XML::Simple :-)
<p class="Pp">If you're looking for a recommendation, I'd suggest you look at
    the Perl-XML FAQ at:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  http://perl-xml.sourceforge.net/faq/
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="Installation"><a class="permalink" href="#Installation">Installation</a></h1>
<section class="Ss">
<h2 class="Ss" id="How_do_I_install_XML::Simple?"><a class="permalink" href="#How_do_I_install_XML::Simple?">How
  do I install XML::Simple?</a></h2>
If you're running ActiveState Perl, or Strawberry Perl
  &lt;http://strawberryperl.com/&gt; you've probably already got XML::Simple and
  therefore do not need to install it at all. But you probably also have
  XML::LibXML, which is a much better module, so just use that.
<p class="Pp">If you do need to install XML::Simple, you'll need to install an
    XML parser module first. Install either XML::Parser (which you may have
    already) or XML::SAX. If you install both, XML::SAX will be used by
  default.</p>
<p class="Pp">Once you have a parser installed ...</p>
<p class="Pp">On Unix systems, try:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  perl -MCPAN -e 'install XML::Simple'
</pre>
<p class="Pp">If that doesn't work, download the latest distribution from
    ftp://ftp.cpan.org/pub/CPAN/authors/id/G/GR/GRANTM , unpack it and run these
    commands:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  perl Makefile.PL
  make
  make test
  make install
</pre>
<p class="Pp">On Win32, if you have a recent build of ActiveState Perl (618 or
    better) try this command:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  ppm install XML::Simple
</pre>
<p class="Pp">If that doesn't work, you really only need the Simple.pm file, so
    extract it from the .tar.gz file (eg: using WinZIP) and save it in the
    \site\lib\XML directory under your Perl installation (typically
  C:\Perl).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="I'm_trying_to_install_XML::Simple_and_'make_test'_fails"><a class="permalink" href="#I'm_trying_to_install_XML::Simple_and_'make_test'_fails">I'm
  trying to install XML::Simple and 'make test' fails</a></h2>
Is the directory where you've unpacked XML::Simple mounted from a file server
  using NFS, SMB or some other network file sharing? If so, that may cause
  errors in the following test scripts:
<p class="Pp"><span class="Li"></span></p>
<pre>
  3_Storable.t
  4_MemShare.t
  5_MemCopy.t
</pre>
<p class="Pp">The test suite is designed to exercise the boundary conditions of
    all XML::Simple's functionality and these three scripts exercise the caching
    functions. If XML::Simple is asked to parse a file for which it has a cached
    copy of a previous parse, then it compares the timestamp on the XML file
    with the timestamp on the cached copy. If the cached copy is *newer* then it
    will be used. If the cached copy is older or the same age then the file is
    re-parsed. The test scripts will get confused by networked filesystems if
    the workstation and server system clocks are not synchronised (to the
    second).</p>
<p class="Pp">If you get an error in one of these three test scripts but you
    don't plan to use the caching options (they're not enabled by default), then
    go right ahead and run 'make install'. If you do plan to use caching, then
    try unpacking the distribution on local disk and doing the build/test
  there.</p>
<p class="Pp">It's probably not a good idea to use the caching options with
    networked filesystems in production. If the file server's clock is ahead of
    the local clock, XML::Simple will re-parse files when it could have used the
    cached copy. However if the local clock is ahead of the file server clock
    and a file is changed immediately after it is cached, the old cached copy
    will be used.</p>
<p class="Pp">Is one of the three test scripts (above) failing but you're not
    running on a network filesystem? Are you running Win32? If so, you may be
    seeing a bug in Win32 where writes to a file do not affect its modification
    timestamp.</p>
<p class="Pp">If none of these scenarios match your situation, please confirm
    you're running the latest version of XML::Simple and then email the output
    of 'make test' to me at grantm@cpan.org</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Why_is_XML::Simple_so_slow?"><a class="permalink" href="#Why_is_XML::Simple_so_slow?">Why
  is XML::Simple so slow?</a></h2>
If you find that XML::Simple is very slow reading XML, the most likely reason is
  that you have XML::SAX installed but no additional SAX parser module. The
  XML::SAX distribution includes an XML parser written entirely in Perl. This is
  very portable but not very fast. For better performance install either
  XML::SAX::Expat or XML::LibXML.
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="Usage"><a class="permalink" href="#Usage">Usage</a></h1>
<section class="Ss">
<h2 class="Ss" id="How_do_I_use_XML::Simple?"><a class="permalink" href="#How_do_I_use_XML::Simple?">How
  do I use XML::Simple?</a></h2>
If you don't know how to use XML::Simple then the best approach is to learn to
  use XML::LibXML &lt;http://grantm.github.io/perl-libxml-by-example/&gt;
  instead. Stop reading this document and use that one instead.
<p class="Pp">If you are determined to use XML::Simple, it come with copious
    documentation, so read that.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="There_are_so_many_options,_which_ones_do_I_really_need_to_know_about?"><a class="permalink" href="#There_are_so_many_options,_which_ones_do_I_really_need_to_know_about?">There
  are so many options, which ones do I really need to know about?</a></h2>
Although you can get by without using any options, you shouldn't even consider
  using XML::Simple in production until you know what these two options do:
<ul class="Bl-bullet">
  <li>forcearray</li>
  <li>keyattr</li>
</ul>
<p class="Pp">The reason you really need to read about them is because the
    default values for these options will trip you up if you don't. Although
    everyone agrees that these defaults are not ideal, there is not wide
    agreement on what they should be changed to. The answer therefore is to read
    about them (see below) and select values which are right for you.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="What_is_the_forcearray_option_all_about?"><a class="permalink" href="#What_is_the_forcearray_option_all_about?">What
  is the forcearray option all about?</a></h2>
Consider this XML in a file called ./person.xml:
<p class="Pp"><span class="Li"></span></p>
<pre>
  &lt;person&gt;
    &lt;first_name&gt;Joe&lt;/first_name&gt;
    &lt;last_name&gt;Bloggs&lt;/last_name&gt;
    &lt;hobbie&gt;bungy jumping&lt;/hobbie&gt;
    &lt;hobbie&gt;sky diving&lt;/hobbie&gt;
    &lt;hobbie&gt;knitting&lt;/hobbie&gt;
  &lt;/person&gt;
</pre>
<p class="Pp">You could read it in with this line:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  my $person = XMLin('./person.xml');
</pre>
<p class="Pp">Which would give you a data structure like this:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  $person = {
    'first_name' =&gt; 'Joe',
    'last_name'  =&gt; 'Bloggs',
    'hobbie'     =&gt; [ 'bungy jumping', 'sky diving', 'knitting' ]
  };
</pre>
<p class="Pp">The &lt;first_name&gt; and &lt;last_name&gt; elements are
    represented as simple scalar values which you could refer to like this:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  print &quot;$person-&gt;{first_name} $person-&gt;{last_name}\n&quot;;
</pre>
<p class="Pp">The &lt;hobbie&gt; elements are represented as an array - since
    there is more than one. You could refer to the first one like this:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  print $person-&gt;{hobbie}-&gt;[0], &quot;\n&quot;;
</pre>
<p class="Pp">Or the whole lot like this:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  print join(', ', @{$person-&gt;{hobbie}} ), &quot;\n&quot;;
</pre>
<p class="Pp">The catch is, that these last two lines of code will only work for
    people who have more than one hobbie. If there is only one &lt;hobbie&gt;
    element, it will be represented as a simple scalar (just like
    &lt;first_name&gt; and &lt;last_name&gt;). Which might lead you to write
    code like this:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  if(ref($person-&gt;{hobbie})) {
    print join(', ', @{$person-&gt;{hobbie}} ), &quot;\n&quot;;
  }
  else {
    print $person-&gt;{hobbie}, &quot;\n&quot;;
  }
</pre>
<p class="Pp">Don't do that.</p>
<p class="Pp">One alternative approach is to set the forcearray option to a true
    value:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  my $person = XMLin('./person.xml', forcearray =&gt; 1);
</pre>
<p class="Pp">Which will give you a data structure like this:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  $person = {
    'first_name' =&gt; [ 'Joe' ],
    'last_name'  =&gt; [ 'Bloggs' ],
    'hobbie'     =&gt; [ 'bungy jumping', 'sky diving', 'knitting' ]
  };
</pre>
<p class="Pp">Then you can use this line to refer to all the list of hobbies
    even if there was only one:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  print join(', ', @{$person-&gt;{hobbie}} ), &quot;\n&quot;;
</pre>
<p class="Pp">The downside of this approach is that the &lt;first_name&gt; and
    &lt;last_name&gt; elements will also always be represented as arrays even
    though there will never be more than one:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  print &quot;$person-&gt;{first_name}-&gt;[0] $person-&gt;{last_name}-&gt;[0]\n&quot;;
</pre>
<p class="Pp">This might be OK if you change the XML to use attributes for
    things that will always be singular and nested elements for things that may
    be plural:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  &lt;person first_name=&quot;Jane&quot; last_name=&quot;Bloggs&quot;&gt;
    &lt;hobbie&gt;motorcycle maintenance&lt;/hobbie&gt;
  &lt;/person&gt;
</pre>
<p class="Pp">On the other hand, if you prefer not to use attributes, then you
    could specify that any &lt;hobbie&gt; elements should always be represented
    as arrays and all other nested elements should be simple scalar values
    unless there is more than one:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  my $person = XMLin('./person.xml', forcearray =&gt; [ 'hobbie' ]);
</pre>
<p class="Pp">The forcearray option accepts a list of element names which should
    always be forced to an array representation:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  forcearray =&gt; [ qw(hobbie qualification childs_name) ]
</pre>
<p class="Pp">See the XML::Simple manual page for more information.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="What_is_the_keyattr_option_all_about?"><a class="permalink" href="#What_is_the_keyattr_option_all_about?">What
  is the keyattr option all about?</a></h2>
Consider this sample XML:
<p class="Pp"><span class="Li"></span></p>
<pre>
  &lt;catalog&gt;
    &lt;part partnum=&quot;1842334&quot; desc=&quot;High pressure flange&quot; price=&quot;24.50&quot; /&gt;
    &lt;part partnum=&quot;9344675&quot; desc=&quot;Threaded gasket&quot;      price=&quot;9.25&quot; /&gt;
    &lt;part partnum=&quot;5634896&quot; desc=&quot;Low voltage washer&quot;   price=&quot;12.00&quot; /&gt;
  &lt;/catalog&gt;
</pre>
<p class="Pp">You could slurp it in with this code:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  my $catalog = XMLin('./catalog.xml');
</pre>
<p class="Pp">Which would return a data structure like this:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  $catalog = {
      'part' =&gt; [
          {
            'partnum' =&gt; '1842334',
            'desc'    =&gt; 'High pressure flange',
            'price'   =&gt; '24.50'
          },
          {
            'partnum' =&gt; '9344675',
            'desc'    =&gt; 'Threaded gasket',
            'price'   =&gt; '9.25'
          },
          {
            'partnum' =&gt; '5634896',
            'desc'    =&gt; 'Low voltage washer',
            'price'   =&gt; '12.00'
          }
      ]
  };
</pre>
<p class="Pp">Then you could access the description of the first part in the
    catalog with this code:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  print $catalog-&gt;{part}-&gt;[0]-&gt;{desc}, &quot;\n&quot;;
</pre>
<p class="Pp">However, if you wanted to access the description of the part with
    the part number of &quot;9344675&quot; then you'd have to code a loop like
    this:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  foreach my $part (@{$catalog-&gt;{part}}) {
    if($part-&gt;{partnum} eq '9344675') {
      print $part-&gt;{desc}, &quot;\n&quot;;
      last;
    }
  }
</pre>
<p class="Pp">The knowledge that each &lt;part&gt; element has a unique partnum
    attribute allows you to eliminate this search. You can pass this knowledge
    on to XML::Simple like this:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  my $catalog = XMLin($xml, keyattr =&gt; ['partnum']);
</pre>
<p class="Pp">Which will return a data structure like this:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  $catalog = {
    'part' =&gt; {
      '5634896' =&gt; { 'desc' =&gt; 'Low voltage washer',   'price' =&gt; '12.00' },
      '1842334' =&gt; { 'desc' =&gt; 'High pressure flange', 'price' =&gt; '24.50' },
      '9344675' =&gt; { 'desc' =&gt; 'Threaded gasket',      'price' =&gt; '9.25'  }
    }
  };
</pre>
<p class="Pp">XML::Simple has been able to transform
    <span class="Li">$catalog</span>-&gt;{part} from an arrayref to a hashref
    (keyed on partnum). This transformation is called 'array folding'.</p>
<p class="Pp">Through the use of array folding, you can now index directly to
    the description of the part you want:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  print $catalog-&gt;{part}-&gt;{9344675}-&gt;{desc}, &quot;\n&quot;;
</pre>
<p class="Pp">The 'keyattr' option also enables array folding when the unique
    key is in a nested element rather than an attribute. eg:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  &lt;catalog&gt;
    &lt;part&gt;
      &lt;partnum&gt;1842334&lt;/partnum&gt;
      &lt;desc&gt;High pressure flange&lt;/desc&gt;
      &lt;price&gt;24.50&lt;/price&gt;
    &lt;/part&gt;
    &lt;part&gt;
      &lt;partnum&gt;9344675&lt;/partnum&gt;
      &lt;desc&gt;Threaded gasket&lt;/desc&gt;
      &lt;price&gt;9.25&lt;/price&gt;
    &lt;/part&gt;
    &lt;part&gt;
      &lt;partnum&gt;5634896&lt;/partnum&gt;
      &lt;desc&gt;Low voltage washer&lt;/desc&gt;
      &lt;price&gt;12.00&lt;/price&gt;
    &lt;/part&gt;
  &lt;/catalog&gt;
</pre>
<p class="Pp">See the XML::Simple manual page for more information.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="So_what's_the_catch_with_'keyattr'?"><a class="permalink" href="#So_what's_the_catch_with_'keyattr'?">So
  what's the catch with 'keyattr'?</a></h2>
One thing to watch out for is that you might get array folding even if you don't
  supply the keyattr option. The default value for this option is:
<p class="Pp"><span class="Li"></span></p>
<pre>
  [ 'name', 'key', 'id']
</pre>
<p class="Pp">Which means if your XML elements have a 'name', 'key' or 'id'
    attribute (or nested element) then they may get folded on those values. This
    means that you can take advantage of array folding simply through careful
    choice of attribute names. On the hand, if you really don't want array
    folding at all, you'll need to set 'key attr to an empty list:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  my $ref = XMLin($xml, keyattr =&gt; []);
</pre>
<p class="Pp">A second 'gotcha' is that array folding only works on arrays. That
    might seem obvious, but if there's only one record in your XML and you
    didn't set the 'forcearray' option then it won't be represented as an array
    and consequently won't get folded into a hash. The moral is that if you're
    using array folding, you should always turn on the forcearray option.</p>
<p class="Pp">You probably want to be as specific as you can be too. For
    instance, the safest way to parse the &lt;catalog&gt; example above would
    be:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  my $catalog = XMLin($xml, keyattr =&gt; { part =&gt; 'partnum'},
                            forcearray =&gt; ['part']);
</pre>
<p class="Pp">By using the hashref for keyattr, you can specify that only
    &lt;part&gt; elements should be folded on the 'partnum' attribute (and that
    the &lt;part&gt; elements should not be folded on any other attribute).</p>
<p class="Pp">By supplying a list of element names for forcearray, you're
    ensuring that folding will work even if there's only one &lt;part&gt;.
    You're also ensuring that if the 'partnum' unique key is supplied in a
    nested element then that element won't get forced to an array too.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="How_do_I_know_what_my_data_structure_should_look_like?"><a class="permalink" href="#How_do_I_know_what_my_data_structure_should_look_like?">How
  do I know what my data structure should look like?</a></h2>
The rules are fairly straightforward:
<ul class="Bl-bullet">
  <li>each element gets represented as a hash</li>
  <li>unless it contains only text, in which case it'll be a simple scalar
    value</li>
  <li>or unless there's more than one element with the same name, in which case
      they'll be represented as an array</li>
  <li>unless you've got array folding enabled, in which case they'll be folded
      into a hash</li>
  <li>empty elements (no text contents <b>and</b> no attributes) will either be
      represented as an empty hash, an empty string or undef - depending on the
      value of the 'suppressempty' option.</li>
</ul>
<p class="Pp">If you're in any doubt, use Data::Dumper, eg:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  use XML::Simple;
  use Data::Dumper;

  my $ref = XMLin($xml);

  print Dumper($ref);
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="I'm_getting_'Use_of_uninitialized_value'_warnings"><a class="permalink" href="#I'm_getting_'Use_of_uninitialized_value'_warnings">I'm
  getting 'Use of uninitialized value' warnings</a></h2>
You're probably trying to index into a non-existant hash key - try Data::Dumper.
</section>
<section class="Ss">
<h2 class="Ss" id="I'm_getting_a_'Not_an__s-1ARRAY_s0_reference'_error"><a class="permalink" href="#I'm_getting_a_'Not_an__s-1ARRAY_s0_reference'_error">I'm
  getting a 'Not an ARRAY reference' error</a></h2>
Something that you expect to be an array is not. The two most likely causes are
  that you forgot to use 'forcearray' or that the array got folded into a hash -
  try Data::Dumper.
</section>
<section class="Ss">
<h2 class="Ss" id="I'm_getting_a_'No_such_array_field'_error"><a class="permalink" href="#I'm_getting_a_'No_such_array_field'_error">I'm
  getting a 'No such array field' error</a></h2>
Something that you expect to be a hash is actually an array. Perhaps array
  folding failed because one element was missing the key attribute - try
  Data::Dumper.
</section>
<section class="Ss">
<h2 class="Ss" id="I'm_getting_an_'Out_of_memory'_error"><a class="permalink" href="#I'm_getting_an_'Out_of_memory'_error">I'm
  getting an 'Out of memory' error</a></h2>
Something in the data structure is not as you expect and Perl may be trying
  unsuccessfully to autovivify things - try Data::Dumper.
<p class="Pp">If you're already using Data::Dumper, try calling <i>Dumper()</i>
    immediately after <i>XMLin()</i> - ie: before you attempt to access anything
    in the data structure.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="My_element_order_is_getting_jumbled_up"><a class="permalink" href="#My_element_order_is_getting_jumbled_up">My
  element order is getting jumbled up</a></h2>
If you read an XML file with <i>XMLin()</i> and then write it back out with
  <i>XMLout()</i>, the order of the elements will likely be different. (However,
  if you read the file back in with <i>XMLin()</i> you'll get the same Perl data
  structure).
<p class="Pp">The reordering happens because XML::Simple uses hashrefs to store
    your data and Perl hashes do not really have any order.</p>
<p class="Pp">It is possible that a future version of XML::Simple will use
    Tie::IxHash to store the data in hashrefs which do retain the order. However
    this will not fix all cases of element order being lost.</p>
<p class="Pp">If your application really is sensitive to element order, don't
    use XML::Simple (and don't put order-sensitive values in attributes).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="XML::Simple_turns_nested_elements_into_attributes"><a class="permalink" href="#XML::Simple_turns_nested_elements_into_attributes">XML::Simple
  turns nested elements into attributes</a></h2>
If you read an XML file with <i>XMLin()</i> and then write it back out with
  <i>XMLout()</i>, some data which was originally stored in nested elements may
  end up in attributes. (However, if you read the file back in with
  <i>XMLin()</i> you'll get the same Perl data structure).
<p class="Pp">There are a number of ways you might handle this:</p>
<ul class="Bl-bullet">
  <li>use the 'forcearray' option with <i>XMLin()</i></li>
  <li>use the 'noattr' option with <i>XMLout()</i></li>
  <li>live with it</li>
  <li>don't use XML::Simple</li>
</ul>
</section>
<section class="Ss">
<h2 class="Ss" id="Why_does__fIXMLout()_fP_insert__name__elements_(or_attributes)?"><a class="permalink" href="#Why_does__fIXMLout()_fP_insert__name__elements_(or_attributes)?">Why
  does <i>XMLout()</i> insert &lt;name&gt; elements (or attributes)?</a></h2>
Try setting keyattr =&gt; [].
<p class="Pp">When you call <i>XMLin()</i> to read XML, the 'keyattr' option
    controls whether arrays get 'folded' into hashes. Similarly, when you call
    <i>XMLout()</i>, the 'keyattr' option controls whether hashes get 'unfolded'
    into arrays. As described above, 'keyattr' is enabled by default.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Why_are_empty_elements_represented_as_empty_hashes?"><a class="permalink" href="#Why_are_empty_elements_represented_as_empty_hashes?">Why
  are empty elements represented as empty hashes?</a></h2>
An element is always represented as a hash unless it contains only text, in
  which case it is represented as a scalar string.
<p class="Pp">If you would prefer empty elements to be represented as empty
    strings or the undefined value, set the 'suppressempty' option to '' or
    undef respectively.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Why_is_ParserOpts_deprecated?"><a class="permalink" href="#Why_is_ParserOpts_deprecated?">Why
  is ParserOpts deprecated?</a></h2>
The <span class="Li">&quot;ParserOpts&quot;</span> option is a remnant of the
  time when XML::Simple only worked with the XML::Parser API. Its value is
  completely ignored if you're using a SAX parser, so writing code which relied
  on it would bar you from taking advantage of SAX.
<p class="Pp">Even if you are using XML::Parser, it is seldom necessary to pass
    options to the parser object. A number of people have written to say they
    use this option to set XML::Parser's
    <span class="Li">&quot;ProtocolEncoding&quot;</span> option. Don't do that,
    it's wrong, Wrong, WRONG! Fix the XML document so that it's well-formed and
    you won't have a problem.</p>
<p class="Pp">Having said all of that, as long as XML::Simple continues to
    support the XML::Parser API, this option will not be removed. There are
    currently no plans to remove support for the XML::Parser API.</p>
</section>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2018-03-17</td>
    <td class="foot-os">perl v5.18.4</td>
  </tr>
</table>
</body>
</html>
