<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>IO::Compress::RawDeflate(3pm)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">IO::Compress::RawDeflate(3pm)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">IO::Compress::RawDeflate(3pm)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
IO::Compress::RawDeflate - Write RFC 1951 files/buffers
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<span class="Li"></span>
<pre>
    use IO::Compress::RawDeflate qw(rawdeflate $RawDeflateError) ;

    my $status = rawdeflate $input =&gt; $output [,OPTS]
        or die &quot;rawdeflate failed: $RawDeflateError\n&quot;;

    my $z = new IO::Compress::RawDeflate $output [,OPTS]
        or die &quot;rawdeflate failed: $RawDeflateError\n&quot;;

    $z-&gt;print($string);
    $z-&gt;printf($format, $string);
    $z-&gt;write($string);
    $z-&gt;syswrite($string [, $length, $offset]);
    $z-&gt;flush();
    $z-&gt;tell();
    $z-&gt;eof();
    $z-&gt;seek($position, $whence);
    $z-&gt;binmode();
    $z-&gt;fileno();
    $z-&gt;opened();
    $z-&gt;autoflush();
    $z-&gt;input_line_number();
    $z-&gt;newStream( [OPTS] );

    $z-&gt;deflateParams();

    $z-&gt;close() ;

    $RawDeflateError ;

    # IO::File mode

    print $z $string;
    printf $z $format, $string;
    tell $z
    eof $z
    seek $z, $position, $whence
    binmode $z
    fileno $z
    close $z ;
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
This module provides a Perl interface that allows writing compressed data to
  files or buffer as defined in RFC 1951.
<p class="Pp">Note that RFC 1951 data is not a good choice of compression format
    to use in isolation, especially if you want to auto-detect it.</p>
<p class="Pp">For reading RFC 1951 files/buffers, see the companion module
    IO::Uncompress::RawInflate.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="Functional_Interface"><a class="permalink" href="#Functional_Interface">Functional
  Interface</a></h1>
A top-level function, <span class="Li">&quot;rawdeflate&quot;</span>, is
  provided to carry out &quot;one-shot&quot; compression between buffers and/or
  files. For finer control over the compression process, see the &quot;OO
  Interface&quot; section.
<p class="Pp"><span class="Li"></span></p>
<pre>
    use IO::Compress::RawDeflate qw(rawdeflate $RawDeflateError) ;

    rawdeflate $input_filename_or_reference =&gt; $output_filename_or_reference [,OPTS]
        or die &quot;rawdeflate failed: $RawDeflateError\n&quot;;
</pre>
<p class="Pp">The functional interface needs Perl5.005 or better.</p>
<section class="Ss">
<h2 class="Ss" id="rawdeflate_$input_filename_or_reference_=__$output_filename_or_reference__,__s-1OPTS_s0_"><a class="permalink" href="#rawdeflate_$input_filename_or_reference_=__$output_filename_or_reference__,__s-1OPTS_s0_">rawdeflate
  $input_filename_or_reference =&gt; $output_filename_or_reference [,
  OPTS]</a></h2>
<span class="Li">&quot;rawdeflate&quot;</span> expects at least two parameters,
  <span class="Li">$input_filename_or_reference</span> and
  <span class="Li">$output_filename_or_reference</span>.
<p class="Pp"><i>The </i><i>$input_filename_or_reference</i><i>
  parameter</i></p>
<p class="Pp">The parameter,
    <span class="Li">$input_filename_or_reference</span>, is used to define the
    source of the uncompressed data.</p>
<p class="Pp">It can take one of the following forms:</p>
<dl class="Bl-tag">
  <dt>A filename</dt>
  <dd>If the &lt;$input_filename_or_reference&gt; parameter is a simple scalar,
      it is assumed to be a filename. This file will be opened for reading and
      the input data will be read from it.</dd>
  <dt>A filehandle</dt>
  <dd>If the <span class="Li">$input_filename_or_reference</span> parameter is a
      filehandle, the input data will be read from it. The string '-' can be
      used as an alias for standard input.</dd>
  <dt>A scalar reference</dt>
  <dd>If <span class="Li">$input_filename_or_reference</span> is a scalar
      reference, the input data will be read from
      <span class="Li">$$input_filename_or_reference</span>.</dd>
  <dt>An array reference</dt>
  <dd>If <span class="Li">$input_filename_or_reference</span> is an array
      reference, each element in the array must be a filename.
    <p class="Pp">The input data will be read from each file in turn.</p>
    <p class="Pp">The complete array will be walked to ensure that it only
        contains valid filenames before any data is compressed.</p>
  </dd>
  <dt>An Input FileGlob string</dt>
  <dd>If <span class="Li">$input_filename_or_reference</span> is a string that
      is delimited by the characters &quot;&lt;&quot; and &quot;&gt;&quot;
      <span class="Li">&quot;rawdeflate&quot;</span> will assume that it is an
      <i>input fileglob string</i>. The input is the list of files that match
      the fileglob.
    <p class="Pp">See File::GlobMapper for more details.</p>
  </dd>
</dl>
<p class="Pp">If the <span class="Li">$input_filename_or_reference</span>
    parameter is any other type, <span class="Li">&quot;undef&quot;</span> will
    be returned.</p>
<p class="Pp"><i>The </i><i>$output_filename_or_reference</i><i>
  parameter</i></p>
<p class="Pp">The parameter
    <span class="Li">$output_filename_or_reference</span> is used to control the
    destination of the compressed data. This parameter can take one of these
    forms.</p>
<dl class="Bl-tag">
  <dt>A filename</dt>
  <dd>If the <span class="Li">$output_filename_or_reference</span> parameter is
      a simple scalar, it is assumed to be a filename. This file will be opened
      for writing and the compressed data will be written to it.</dd>
  <dt>A filehandle</dt>
  <dd>If the <span class="Li">$output_filename_or_reference</span> parameter is
      a filehandle, the compressed data will be written to it. The string '-'
      can be used as an alias for standard output.</dd>
  <dt>A scalar reference</dt>
  <dd>If <span class="Li">$output_filename_or_reference</span> is a scalar
      reference, the compressed data will be stored in
      <span class="Li">$$output_filename_or_reference</span>.</dd>
  <dt>An Array Reference</dt>
  <dd>If <span class="Li">$output_filename_or_reference</span> is an array
      reference, the compressed data will be pushed onto the array.</dd>
  <dt>An Output FileGlob</dt>
  <dd>If <span class="Li">$output_filename_or_reference</span> is a string that
      is delimited by the characters &quot;&lt;&quot; and &quot;&gt;&quot;
      <span class="Li">&quot;rawdeflate&quot;</span> will assume that it is an
      <i>output fileglob string</i>. The output is the list of files that match
      the fileglob.
    <p class="Pp">When <span class="Li">$output_filename_or_reference</span> is
        an fileglob string, <span class="Li">$input_filename_or_reference</span>
        must also be a fileglob string. Anything else is an error.</p>
    <p class="Pp">See File::GlobMapper for more details.</p>
  </dd>
</dl>
<p class="Pp">If the <span class="Li">$output_filename_or_reference</span>
    parameter is any other type, <span class="Li">&quot;undef&quot;</span> will
    be returned.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Notes"><a class="permalink" href="#Notes">Notes</a></h2>
When <span class="Li">$input_filename_or_reference</span> maps to multiple
  files/buffers and <span class="Li">$output_filename_or_reference</span> is a
  single file/buffer the input files/buffers will be stored in
  <span class="Li">$output_filename_or_reference</span> as a concatenated series
  of compressed data streams.
</section>
<section class="Ss">
<h2 class="Ss" id="Optional_Parameters"><a class="permalink" href="#Optional_Parameters">Optional
  Parameters</a></h2>
Unless specified below, the optional parameters for
  <span class="Li">&quot;rawdeflate&quot;</span>,
  <span class="Li">&quot;OPTS&quot;</span>, are the same as those used with the
  OO interface defined in the &quot;Constructor Options&quot; section below.
<dl class="Bl-tag">
  <dt>&quot;AutoClose =&gt; 0|1&quot;</dt>
  <dd>This option applies to any input or output data streams to
      <span class="Li">&quot;rawdeflate&quot;</span> that are filehandles.
    <p class="Pp">If <span class="Li">&quot;AutoClose&quot;</span> is specified,
        and the value is true, it will result in all input and/or output
        filehandles being closed once
        <span class="Li">&quot;rawdeflate&quot;</span> has completed.</p>
    <p class="Pp">This parameter defaults to 0.</p>
  </dd>
  <dt>&quot;BinModeIn =&gt; 0|1&quot;</dt>
  <dd>This option is now a no-op. All files will be read in binmode.</dd>
  <dt>&quot;Append =&gt; 0|1&quot;</dt>
  <dd>The behaviour of this option is dependent on the type of output data
      stream.</dd>
</dl>
<div class="Bd-indent">
<ul class="Bl-bullet">
  <li>A Buffer
    <p class="Pp">If <span class="Li">&quot;Append&quot;</span> is enabled, all
        compressed data will be append to the end of the output buffer.
        Otherwise the output buffer will be cleared before any compressed data
        is written to it.</p>
  </li>
  <li>A Filename
    <p class="Pp">If <span class="Li">&quot;Append&quot;</span> is enabled, the
        file will be opened in append mode. Otherwise the contents of the file,
        if any, will be truncated before any compressed data is written to
      it.</p>
  </li>
  <li>A Filehandle
    <p class="Pp">If <span class="Li">&quot;Append&quot;</span> is enabled, the
        filehandle will be positioned to the end of the file via a call to
        <span class="Li">&quot;seek&quot;</span> before any compressed data is
        written to it. Otherwise the file pointer will not be moved.</p>
  </li>
</ul>
</div>
<div class="Bd-indent">
<p class="Pp">When <span class="Li">&quot;Append&quot;</span> is specified, and
    set to true, it will <i>append</i> all compressed data to the output data
    stream.</p>
<p class="Pp">So when the output is a filehandle it will carry out a seek to the
    eof before writing any compressed data. If the output is a filename, it will
    be opened for appending. If the output is a buffer, all compressed data will
    be appended to the existing buffer.</p>
<p class="Pp">Conversely when <span class="Li">&quot;Append&quot;</span> is not
    specified, or it is present and is set to false, it will operate as
  follows.</p>
<p class="Pp">When the output is a filename, it will truncate the contents of
    the file before writing any compressed data. If the output is a filehandle
    its position will not be changed. If the output is a buffer, it will be
    wiped before any compressed data is output.</p>
<p class="Pp">Defaults to 0.</p>
</div>
</section>
<section class="Ss">
<h2 class="Ss" id="Examples"><a class="permalink" href="#Examples">Examples</a></h2>
To read the contents of the file <span class="Li">&quot;file1.txt&quot;</span>
  and write the compressed data to the file
  <span class="Li">&quot;file1.txt.1951&quot;</span>.
<p class="Pp"><span class="Li"></span></p>
<pre>
    use strict ;
    use warnings ;
    use IO::Compress::RawDeflate qw(rawdeflate $RawDeflateError) ;

    my $input = &quot;file1.txt&quot;;
    rawdeflate $input =&gt; &quot;$input.1951&quot;
        or die &quot;rawdeflate failed: $RawDeflateError\n&quot;;
</pre>
<p class="Pp">To read from an existing Perl filehandle,
    <span class="Li">$input</span>, and write the compressed data to a buffer,
    <span class="Li">$buffer</span>.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    use strict ;
    use warnings ;
    use IO::Compress::RawDeflate qw(rawdeflate $RawDeflateError) ;
    use IO::File ;

    my $input = new IO::File &quot;&lt;file1.txt&quot;
        or die &quot;Cannot open 'file1.txt': $!\n&quot; ;
    my $buffer ;
    rawdeflate $input =&gt; \$buffer
        or die &quot;rawdeflate failed: $RawDeflateError\n&quot;;
</pre>
<p class="Pp">To compress all files in the directory &quot;/my/home&quot; that
    match &quot;*.txt&quot; and store the compressed data in the same
  directory</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    use strict ;
    use warnings ;
    use IO::Compress::RawDeflate qw(rawdeflate $RawDeflateError) ;

    rawdeflate '&lt;/my/home/*.txt&gt;' =&gt; '&lt;*.1951&gt;'
        or die &quot;rawdeflate failed: $RawDeflateError\n&quot;;
</pre>
<p class="Pp">and if you want to compress each file one at a time, this will do
    the trick</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    use strict ;
    use warnings ;
    use IO::Compress::RawDeflate qw(rawdeflate $RawDeflateError) ;

    for my $input ( glob &quot;/my/home/*.txt&quot; )
    {
        my $output = &quot;$input.1951&quot; ;
        rawdeflate $input =&gt; $output
            or die &quot;Error compressing '$input': $RawDeflateError\n&quot;;
    }
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="OO_Interface"><a class="permalink" href="#OO_Interface">OO
  Interface</a></h1>
<section class="Ss">
<h2 class="Ss" id="Constructor"><a class="permalink" href="#Constructor">Constructor</a></h2>
The format of the constructor for
  <span class="Li">&quot;IO::Compress::RawDeflate&quot;</span> is shown below
<p class="Pp"><span class="Li"></span></p>
<pre>
    my $z = new IO::Compress::RawDeflate $output [,OPTS]
        or die &quot;IO::Compress::RawDeflate failed: $RawDeflateError\n&quot;;
</pre>
<p class="Pp">It returns an
    <span class="Li">&quot;IO::Compress::RawDeflate&quot;</span> object on
    success and undef on failure. The variable
    <span class="Li">$RawDeflateError</span> will contain an error message on
    failure.</p>
<p class="Pp">If you are running Perl 5.005 or better the object,
    <span class="Li">$z</span>, returned from IO::Compress::RawDeflate can be
    used exactly like an IO::File filehandle. This means that all normal output
    file operations can be carried out with <span class="Li">$z</span>. For
    example, to write to a compressed file/buffer you can use either of these
    forms</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    $z-&gt;print(&quot;hello world\n&quot;);
    print $z &quot;hello world\n&quot;;
</pre>
<p class="Pp">The mandatory parameter <span class="Li">$output</span> is used to
    control the destination of the compressed data. This parameter can take one
    of these forms.</p>
<dl class="Bl-tag">
  <dt>A filename</dt>
  <dd>If the <span class="Li">$output</span> parameter is a simple scalar, it is
      assumed to be a filename. This file will be opened for writing and the
      compressed data will be written to it.</dd>
  <dt>A filehandle</dt>
  <dd>If the <span class="Li">$output</span> parameter is a filehandle, the
      compressed data will be written to it. The string '-' can be used as an
      alias for standard output.</dd>
  <dt>A scalar reference</dt>
  <dd>If <span class="Li">$output</span> is a scalar reference, the compressed
      data will be stored in <span class="Li">$$output</span>.</dd>
</dl>
<p class="Pp">If the <span class="Li">$output</span> parameter is any other
    type, <span class="Li">&quot;IO::Compress::RawDeflate&quot;</span>::new will
    return undef.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Constructor_Options"><a class="permalink" href="#Constructor_Options">Constructor
  Options</a></h2>
<span class="Li">&quot;OPTS&quot;</span> is any combination of the following
  options:
<dl class="Bl-tag">
  <dt>&quot;AutoClose =&gt; 0|1&quot;</dt>
  <dd>This option is only valid when the <span class="Li">$output</span>
      parameter is a filehandle. If specified, and the value is true, it will
      result in the <span class="Li">$output</span> being closed once either the
      <span class="Li">&quot;close&quot;</span> method is called or the
      <span class="Li">&quot;IO::Compress::RawDeflate&quot;</span> object is
      destroyed.
    <p class="Pp">This parameter defaults to 0.</p>
  </dd>
  <dt>&quot;Append =&gt; 0|1&quot;</dt>
  <dd>Opens <span class="Li">$output</span> in append mode.
    <p class="Pp">The behaviour of this option is dependent on the type of
        <span class="Li">$output</span>.</p>
  </dd>
</dl>
<div class="Bd-indent">
<ul class="Bl-bullet">
  <li>A Buffer
    <p class="Pp">If <span class="Li">$output</span> is a buffer and
        <span class="Li">&quot;Append&quot;</span> is enabled, all compressed
        data will be append to the end of <span class="Li">$output</span>.
        Otherwise <span class="Li">$output</span> will be cleared before any
        data is written to it.</p>
  </li>
  <li>A Filename
    <p class="Pp">If <span class="Li">$output</span> is a filename and
        <span class="Li">&quot;Append&quot;</span> is enabled, the file will be
        opened in append mode. Otherwise the contents of the file, if any, will
        be truncated before any compressed data is written to it.</p>
  </li>
  <li>A Filehandle
    <p class="Pp">If <span class="Li">$output</span> is a filehandle, the file
        pointer will be positioned to the end of the file via a call to
        <span class="Li">&quot;seek&quot;</span> before any compressed data is
        written to it. Otherwise the file pointer will not be moved.</p>
  </li>
</ul>
</div>
<div class="Bd-indent">
<p class="Pp">This parameter defaults to 0.</p>
</div>
<dl class="Bl-tag">
  <dt>&quot;Merge =&gt; 0|1&quot;</dt>
  <dd>This option is used to compress input data and append it to an existing
      compressed data stream in <span class="Li">$output</span>. The end result
      is a single compressed data stream stored in
      <span class="Li">$output</span>.
    <p class="Pp">It is a fatal error to attempt to use this option when
        <span class="Li">$output</span> is not an RFC 1951 data stream.</p>
    <p class="Pp">There are a number of other limitations with the
        <span class="Li">&quot;Merge&quot;</span> option:</p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>1.</dt>
  <dd>This module needs to have been built with zlib 1.2.1 or better to work. A
      fatal error will be thrown if <span class="Li">&quot;Merge&quot;</span> is
      used with an older version of zlib.</dd>
  <dt>2.</dt>
  <dd>If <span class="Li">$output</span> is a file or a filehandle, it must be
      seekable.</dd>
</dl>
</div>
<div class="Bd-indent">
<p class="Pp">This parameter defaults to 0.</p>
</div>
<dl class="Bl-tag">
  <dt>-Level</dt>
  <dd>Defines the compression level used by zlib. The value should either be a
      number between 0 and 9 (0 means no compression and 9 is maximum
      compression), or one of the symbolic constants defined below.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
   Z_NO_COMPRESSION
   Z_BEST_SPEED
   Z_BEST_COMPRESSION
   Z_DEFAULT_COMPRESSION
    </pre>
    <p class="Pp">The default is Z_DEFAULT_COMPRESSION.</p>
    <p class="Pp">Note, these constants are not imported by
        <span class="Li">&quot;IO::Compress::RawDeflate&quot;</span> by
      default.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    use IO::Compress::RawDeflate qw(:strategy);
    use IO::Compress::RawDeflate qw(:constants);
    use IO::Compress::RawDeflate qw(:all);
    </pre>
  </dd>
  <dt>-Strategy</dt>
  <dd>Defines the strategy used to tune the compression. Use one of the symbolic
      constants defined below.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
   Z_FILTERED
   Z_HUFFMAN_ONLY
   Z_RLE
   Z_FIXED
   Z_DEFAULT_STRATEGY
    </pre>
    <p class="Pp">The default is Z_DEFAULT_STRATEGY.</p>
  </dd>
  <dt>&quot;Strict =&gt; 0|1&quot;</dt>
  <dd>This is a placeholder option.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Examples_2"><a class="permalink" href="#Examples_2">Examples</a></h2>
TODO
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="Methods"><a class="permalink" href="#Methods">Methods</a></h1>
<section class="Ss">
<h2 class="Ss" id="print"><a class="permalink" href="#print">print</a></h2>
Usage is
<p class="Pp"><span class="Li"></span></p>
<pre>
    $z-&gt;print($data)
    print $z $data
</pre>
<p class="Pp">Compresses and outputs the contents of the
    <span class="Li">$data</span> parameter. This has the same behaviour as the
    <span class="Li">&quot;print&quot;</span> built-in.</p>
<p class="Pp">Returns true if successful.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="printf"><a class="permalink" href="#printf">printf</a></h2>
Usage is
<p class="Pp"><span class="Li"></span></p>
<pre>
    $z-&gt;printf($format, $data)
    printf $z $format, $data
</pre>
<p class="Pp">Compresses and outputs the contents of the
    <span class="Li">$data</span> parameter.</p>
<p class="Pp">Returns true if successful.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="syswrite"><a class="permalink" href="#syswrite">syswrite</a></h2>
Usage is
<p class="Pp"><span class="Li"></span></p>
<pre>
    $z-&gt;syswrite $data
    $z-&gt;syswrite $data, $length
    $z-&gt;syswrite $data, $length, $offset
</pre>
<p class="Pp">Compresses and outputs the contents of the
    <span class="Li">$data</span> parameter.</p>
<p class="Pp">Returns the number of uncompressed bytes written, or
    <span class="Li">&quot;undef&quot;</span> if unsuccessful.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="write"><a class="permalink" href="#write">write</a></h2>
Usage is
<p class="Pp"><span class="Li"></span></p>
<pre>
    $z-&gt;write $data
    $z-&gt;write $data, $length
    $z-&gt;write $data, $length, $offset
</pre>
<p class="Pp">Compresses and outputs the contents of the
    <span class="Li">$data</span> parameter.</p>
<p class="Pp">Returns the number of uncompressed bytes written, or
    <span class="Li">&quot;undef&quot;</span> if unsuccessful.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="flush"><a class="permalink" href="#flush">flush</a></h2>
Usage is
<p class="Pp"><span class="Li"></span></p>
<pre>
    $z-&gt;flush;
    $z-&gt;flush($flush_type);
</pre>
<p class="Pp">Flushes any pending compressed data to the output file/buffer.</p>
<p class="Pp">This method takes an optional parameter,
    <span class="Li">$flush_type</span>, that controls how the flushing will be
    carried out. By default the <span class="Li">$flush_type</span> used is
    <span class="Li">&quot;Z_FINISH&quot;</span>. Other valid values for
    <span class="Li">$flush_type</span> are
    <span class="Li">&quot;Z_NO_FLUSH&quot;</span>,
    <span class="Li">&quot;Z_SYNC_FLUSH&quot;</span>,
    <span class="Li">&quot;Z_FULL_FLUSH&quot;</span> and
    <span class="Li">&quot;Z_BLOCK&quot;</span>. It is strongly recommended that
    you only set the <span class="Li">&quot;flush_type&quot;</span> parameter if
    you fully understand the implications of what it does - overuse of
    <span class="Li">&quot;flush&quot;</span> can seriously degrade the level of
    compression achieved. See the <span class="Li">&quot;zlib&quot;</span>
    documentation for details.</p>
<p class="Pp">Returns true on success.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="tell"><a class="permalink" href="#tell">tell</a></h2>
Usage is
<p class="Pp"><span class="Li"></span></p>
<pre>
    $z-&gt;tell()
    tell $z
</pre>
<p class="Pp">Returns the uncompressed file offset.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="eof"><a class="permalink" href="#eof">eof</a></h2>
Usage is
<p class="Pp"><span class="Li"></span></p>
<pre>
    $z-&gt;eof();
    eof($z);
</pre>
<p class="Pp">Returns true if the <span class="Li">&quot;close&quot;</span>
    method has been called.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="seek"><a class="permalink" href="#seek">seek</a></h2>
<span class="Li"></span>
<pre>
    $z-&gt;seek($position, $whence);
    seek($z, $position, $whence);
</pre>
<p class="Pp">Provides a sub-set of the <span class="Li">&quot;seek&quot;</span>
    functionality, with the restriction that it is only legal to seek forward in
    the output file/buffer. It is a fatal error to attempt to seek backward.</p>
<p class="Pp">Empty parts of the file/buffer will have NULL (0x00) bytes written
    to them.</p>
<p class="Pp">The <span class="Li">$whence</span> parameter takes one the usual
    values, namely SEEK_SET, SEEK_CUR or SEEK_END.</p>
<p class="Pp">Returns 1 on success, 0 on failure.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="binmode"><a class="permalink" href="#binmode">binmode</a></h2>
Usage is
<p class="Pp"><span class="Li"></span></p>
<pre>
    $z-&gt;binmode
    binmode $z ;
</pre>
<p class="Pp">This is a noop provided for completeness.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="opened"><a class="permalink" href="#opened">opened</a></h2>
<span class="Li"></span>
<pre>
    $z-&gt;opened()
</pre>
<p class="Pp">Returns true if the object currently refers to a opened
    file/buffer.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="autoflush"><a class="permalink" href="#autoflush">autoflush</a></h2>
<span class="Li"></span>
<pre>
    my $prev = $z-&gt;autoflush()
    my $prev = $z-&gt;autoflush(EXPR)
</pre>
<p class="Pp">If the <span class="Li">$z</span> object is associated with a file
    or a filehandle, this method returns the current autoflush setting for the
    underlying filehandle. If <span class="Li">&quot;EXPR&quot;</span> is
    present, and is non-zero, it will enable flushing after every write/print
    operation.</p>
<p class="Pp">If <span class="Li">$z</span> is associated with a buffer, this
    method has no effect and always returns
    <span class="Li">&quot;undef&quot;</span>.</p>
<p class="Pp"><b>Note</b> that the special variable <span class="Li">$|</span>
    <b>cannot</b> be used to set or retrieve the autoflush setting.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="input_line_number"><a class="permalink" href="#input_line_number">input_line_number</a></h2>
<span class="Li"></span>
<pre>
    $z-&gt;input_line_number()
    $z-&gt;input_line_number(EXPR)
</pre>
<p class="Pp">This method always returns
    <span class="Li">&quot;undef&quot;</span> when compressing.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="fileno"><a class="permalink" href="#fileno">fileno</a></h2>
<span class="Li"></span>
<pre>
    $z-&gt;fileno()
    fileno($z)
</pre>
<p class="Pp">If the <span class="Li">$z</span> object is associated with a file
    or a filehandle, <span class="Li">&quot;fileno&quot;</span> will return the
    underlying file descriptor. Once the
    <span class="Li">&quot;close&quot;</span> method is called
    <span class="Li">&quot;fileno&quot;</span> will return
    <span class="Li">&quot;undef&quot;</span>.</p>
<p class="Pp">If the <span class="Li">$z</span> object is associated with a
    buffer, this method will return
  <span class="Li">&quot;undef&quot;</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="close"><a class="permalink" href="#close">close</a></h2>
<span class="Li"></span>
<pre>
    $z-&gt;close() ;
    close $z ;
</pre>
<p class="Pp">Flushes any pending compressed data and then closes the output
    file/buffer.</p>
<p class="Pp">For most versions of Perl this method will be automatically
    invoked if the IO::Compress::RawDeflate object is destroyed (either
    explicitly or by the variable with the reference to the object going out of
    scope). The exceptions are Perl versions 5.005 through 5.00504 and 5.8.0. In
    these cases, the <span class="Li">&quot;close&quot;</span> method will be
    called automatically, but not until global destruction of all live objects
    when the program is terminating.</p>
<p class="Pp">Therefore, if you want your scripts to be able to run on all
    versions of Perl, you should call <span class="Li">&quot;close&quot;</span>
    explicitly and not rely on automatic closing.</p>
<p class="Pp">Returns true on success, otherwise 0.</p>
<p class="Pp">If the <span class="Li">&quot;AutoClose&quot;</span> option has
    been enabled when the IO::Compress::RawDeflate object was created, and the
    object is associated with a file, the underlying file will also be
  closed.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="newStream(__s-1OPTS_s0_)"><a class="permalink" href="#newStream(__s-1OPTS_s0_)">newStream([OPTS])</a></h2>
Usage is
<p class="Pp"><span class="Li"></span></p>
<pre>
    $z-&gt;newStream( [OPTS] )
</pre>
<p class="Pp">Closes the current compressed data stream and starts a new
  one.</p>
<p class="Pp">OPTS consists of any of the options that are available when
    creating the <span class="Li">$z</span> object.</p>
<p class="Pp">See the &quot;Constructor Options&quot; section for more
  details.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="deflateParams"><a class="permalink" href="#deflateParams">deflateParams</a></h2>
Usage is
<p class="Pp"><span class="Li"></span></p>
<pre>
    $z-&gt;deflateParams
</pre>
<p class="Pp">TODO</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="Importing"><a class="permalink" href="#Importing">Importing</a></h1>
A number of symbolic constants are required by some methods in
  <span class="Li">&quot;IO::Compress::RawDeflate&quot;</span>. None are
  imported by default.
<dl class="Bl-tag">
  <dt>:all</dt>
  <dd>Imports <span class="Li">&quot;rawdeflate&quot;</span>,
      <span class="Li">$RawDeflateError</span> and all symbolic constants that
      can be used by
      <span class="Li">&quot;IO::Compress::RawDeflate&quot;</span>. Same as
      doing this
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    use IO::Compress::RawDeflate qw(rawdeflate $RawDeflateError :constants) ;
    </pre>
  </dd>
  <dt>:constants</dt>
  <dd>Import all symbolic constants. Same as doing this
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    use IO::Compress::RawDeflate qw(:flush :level :strategy) ;
    </pre>
  </dd>
  <dt>:flush</dt>
  <dd>These symbolic constants are used by the
      <span class="Li">&quot;flush&quot;</span> method.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    Z_NO_FLUSH
    Z_PARTIAL_FLUSH
    Z_SYNC_FLUSH
    Z_FULL_FLUSH
    Z_FINISH
    Z_BLOCK
    </pre>
  </dd>
  <dt>:level</dt>
  <dd>These symbolic constants are used by the
      <span class="Li">&quot;Level&quot;</span> option in the constructor.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    Z_NO_COMPRESSION
    Z_BEST_SPEED
    Z_BEST_COMPRESSION
    Z_DEFAULT_COMPRESSION
    </pre>
  </dd>
  <dt>:strategy</dt>
  <dd>These symbolic constants are used by the
      <span class="Li">&quot;Strategy&quot;</span> option in the constructor.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    Z_FILTERED
    Z_HUFFMAN_ONLY
    Z_RLE
    Z_FIXED
    Z_DEFAULT_STRATEGY
    </pre>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="EXAMPLES"><a class="permalink" href="#EXAMPLES">EXAMPLES</a></h1>
<section class="Ss">
<h2 class="Ss" id="Apache::GZip_Revisited"><a class="permalink" href="#Apache::GZip_Revisited">Apache::GZip
  Revisited</a></h2>
See IO::Compress::FAQ
</section>
<section class="Ss">
<h2 class="Ss" id="Working_with_Net::FTP"><a class="permalink" href="#Working_with_Net::FTP">Working
  with Net::FTP</a></h2>
See IO::Compress::FAQ
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
Compress::Zlib, IO::Compress::Gzip, IO::Uncompress::Gunzip,
  IO::Compress::Deflate, IO::Uncompress::Inflate, IO::Uncompress::RawInflate,
  IO::Compress::Bzip2, IO::Uncompress::Bunzip2, IO::Compress::Lzma,
  IO::Uncompress::UnLzma, IO::Compress::Xz, IO::Uncompress::UnXz,
  IO::Compress::Lzip, IO::Uncompress::UnLzip, IO::Compress::Lzop,
  IO::Uncompress::UnLzop, IO::Compress::Lzf, IO::Uncompress::UnLzf,
  IO::Compress::Zstd, IO::Uncompress::UnZstd, IO::Uncompress::AnyInflate,
  IO::Uncompress::AnyUncompress
<p class="Pp">IO::Compress::FAQ</p>
<p class="Pp">File::GlobMapper, Archive::Zip, Archive::Tar, IO::Zlib</p>
<p class="Pp">For RFC 1950, 1951 and 1952 see
    &lt;http://www.faqs.org/rfcs/rfc1950.html&gt;,
    &lt;http://www.faqs.org/rfcs/rfc1951.html&gt; and
    &lt;http://www.faqs.org/rfcs/rfc1952.html&gt;</p>
<p class="Pp">The <i>zlib</i> compression library was written by Jean-loup
    Gailly <span class="Li">&quot;gzip@prep.ai.mit.edu&quot;</span> and Mark
    Adler <span class="Li">&quot;madler@alumni.caltech.edu&quot;</span>.</p>
<p class="Pp">The primary site for the <i>zlib</i> compression library is
    &lt;http://www.zlib.org&gt;.</p>
<p class="Pp">The primary site for gzip is &lt;http://www.gzip.org&gt;.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
This module was written by Paul Marquess,
  <span class="Li">&quot;pmqs@cpan.org&quot;</span>.
</section>
<section class="Sh">
<h1 class="Sh" id="MODIFICATION_HISTORY"><a class="permalink" href="#MODIFICATION_HISTORY">MODIFICATION
  HISTORY</a></h1>
See the Changes file.
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT_AND_LICENSE"><a class="permalink" href="#COPYRIGHT_AND_LICENSE">COPYRIGHT
  AND LICENSE</a></h1>
Copyright (c) 2005-2019 Paul Marquess. All rights reserved.
<p class="Pp">This program is free software; you can redistribute it and/or
    modify it under the same terms as Perl itself.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2019-10-24</td>
    <td class="foot-os">perl v5.30.2</td>
  </tr>
</table>
</body>
</html>
