<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Generated from file '/Library/Caches/com.apple.xbs/Sources/tcl/tcl-129.40.1/tcl_ext/tcllib/tcllib/modules/struct/graph.man' by tcllib/doctools with format 'nroff'
   Copyright (c) 2002-2009 Andreas Kupries <andreas_kupries@users.sourceforge.net>
  
   The definitions below are for supplemental macros used in Tcl/Tk
   manual entries.
  
   .AP type name in/out ?indent?
  	Start paragraph describing an argument to a library procedure.
  	type is type of argument (int, etc.), in/out is either "in", "out",
  	or "in/out" to describe whether procedure reads or modifies arg,
  	and indent is equivalent to second arg of .IP (shouldn't ever be
  	needed;  use .AS below instead)
  
   .AS ?type? ?name?
  	Give maximum sizes of arguments for setting tab stops.  Type and
  	name are examples of largest possible arguments that will be passed
  	to .AP later.  If args are omitted, default tab stops are used.
  
   .BS
  	Start box enclosure.  From here until next .BE, everything will be
  	enclosed in one large box.
  
   .BE
  	End of box enclosure.
  
   .CS
  	Begin code excerpt.
  
   .CE
  	End code excerpt.
  
   .VS ?version? ?br?
  	Begin vertical sidebar, for use in marking newly-changed parts
  	of man pages.  The first argument is ignored and used for recording
  	the version when the .VS was added, so that the sidebars can be
  	found and removed when they reach a certain age.  If another argument
  	is present, then a line break is forced before starting the sidebar.
  
   .VE
  	End of vertical sidebar.
  
   .DS
  	Begin an indented unfilled display.
  
   .DE
  	End of indented unfilled display.
  
   .SO
  	Start of list of standard options for a Tk widget.  The
  	options follow on successive lines, in four columns separated
  	by tabs.
  
   .SE
  	End of list of standard options for a Tk widget.
  
   .OP cmdName dbName dbClass
  	Start of description of a specific option.  cmdName gives the
  	option's name as specified in the class command, dbName gives
  	the option's name in the option database, and dbClass gives
  	the option's class in the option database.
  
   .UL arg1 arg2
  	Print arg1 underlined, then print arg2 normally.
  
   RCS: @(#) $Id: man.macros,v 1.1 2009/01/30 04:56:47 andreas_kupries Exp $
  
  	# Set up traps and other miscellaneous stuff for Tcl/Tk man pages.
  	# Start an argument description
  .b
  	# define tabbing values for .AP
  
  	# BS - start boxed text
  	# ^y = starting y location
  	# ^b = 1
  	# BE - end boxed text (draw box now)
  	Draw four-sided box normally, but don't draw top of
  	box if the box started on an earlier page.
  	# VS - start vertical sidebar
  	# ^Y = starting y location
  	# ^v = 1 (for troff;  for nroff this doesn't matter)
  	# VE - end of vertical sidebar
  	# Special macro to handle page bottom:  finish off current
  	# box/sidebar if in box/sidebar mode, then invoked standard
  	# page bottom macro.
  	Draw three-sided box if this is the box's first page,
  	draw two sides but no top otherwise.
  	# DS - begin display
  	# DE - end display
  	# SO - start of list of standard options
  	# SE - end of list of standard options
  	# OP - start of full description for a single option
  	# CS - begin code excerpt
  	# CE - end code excerpt
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>struct::graph(n)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">struct::graph(n)</td>
    <td class="head-vol">Tcl Data Structures</td>
    <td class="head-rtitle">struct::graph(n)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<pre>

</pre>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
struct::graph - Create and manipulate directed graph objects
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
package require <b>Tcl 8.4</b>
<p class="Pp">package require <b>struct::graph ?2.4?</b></p>
<p class="Pp">package require <b>struct::list ?1.5?</b></p>
<p class="Pp">package require <b>struct::set ?2.2.3?</b></p>
<p class="Pp"><b>::struct::graph</b> ?<i>graphName</i>?
    ?<b>=</b>|<b>:=</b>|<b>as</b>|<b>deserialize</b> <i>source</i>?</p>
<p class="Pp"><b>graphName</b> <i>option</i> ?<i>arg arg ...</i>?</p>
<p class="Pp"><i>graphName</i> <b>=</b> <i>sourcegraph</i></p>
<p class="Pp"><i>graphName</i> <b>--&gt;</b> <i>destgraph</i></p>
<p class="Pp"><i>graphName</i> <b>append</b> <i>key</i> <i>value</i></p>
<p class="Pp"><i>graphName</i> <b>deserialize</b> <i>serialization</i></p>
<p class="Pp"><i>graphName</i> <b>destroy</b></p>
<p class="Pp"><i>graphName</i> <b>arc append</b> <i>arc</i> <i>key</i>
    <i>value</i></p>
<p class="Pp"><i>graphName</i> <b>arc attr</b> <i>key</i></p>
<p class="Pp"><i>graphName</i> <b>arc attr</b> <i>key</i> <b>-arcs</b>
    <i>list</i></p>
<p class="Pp"><i>graphName</i> <b>arc attr</b> <i>key</i> <b>-glob</b>
    <i>globpattern</i></p>
<p class="Pp"><i>graphName</i> <b>arc attr</b> <i>key</i> <b>-regexp</b>
    <i>repattern</i></p>
<p class="Pp"><i>graphName</i> <b>arc delete</b> <i>arc</i> ?<i>arc</i> ...?</p>
<p class="Pp"><i>graphName</i> <b>arc exists</b> <i>arc</i></p>
<p class="Pp"><i>graphName</i> <b>arc flip</b> <i>arc</i></p>
<p class="Pp"><i>graphName</i> <b>arc get</b> <i>arc</i> <i>key</i></p>
<p class="Pp"><i>graphName</i> <b>arc getall</b> <i>arc</i> ?<i>pattern</i>?</p>
<p class="Pp"><i>graphName</i> <b>arc getunweighted</b></p>
<p class="Pp"><i>graphName</i> <b>arc getweight</b> <i>arc</i></p>
<p class="Pp"><i>graphName</i> <b>arc keys</b> <i>arc</i> ?<i>pattern</i>?</p>
<p class="Pp"><i>graphName</i> <b>arc keyexists</b> <i>arc</i> <i>key</i></p>
<p class="Pp"><i>graphName</i> <b>arc insert</b> <i>start</i> <i>end</i>
    ?<i>child</i>?</p>
<p class="Pp"><i>graphName</i> <b>arc lappend</b> <i>arc</i> <i>key</i>
    <i>value</i></p>
<p class="Pp"><i>graphName</i> <b>arc rename</b> <i>arc</i> <i>newname</i></p>
<p class="Pp"><i>graphName</i> <b>arc set</b> <i>arc</i> <i>key</i>
    ?<i>value</i>?</p>
<p class="Pp"><i>graphName</i> <b>arc setunweighted</b> ?<i>weight</i>?</p>
<p class="Pp"><i>graphName</i> <b>arc setweight</b> <i>arc</i> <i>weight</i></p>
<p class="Pp"><i>graphName</i> <b>arc unsetweight</b> <i>arc</i></p>
<p class="Pp"><i>graphName</i> <b>arc hasweight</b> <i>arc</i></p>
<p class="Pp"><i>graphName</i> <b>arc source</b> <i>arc</i></p>
<p class="Pp"><i>graphName</i> <b>arc target</b> <i>arc</i></p>
<p class="Pp"><i>graphName</i> <b>arc nodes</b> <i>arc</i></p>
<p class="Pp"><i>graphName</i> <b>arc move-source</b> <i>arc</i>
    <i>newsource</i></p>
<p class="Pp"><i>graphName</i> <b>arc move-target</b> <i>arc</i>
    <i>newtarget</i></p>
<p class="Pp"><i>graphName</i> <b>arc move</b> <i>arc</i> <i>newsource</i>
    <i>newtarget</i></p>
<p class="Pp"><i>graphName</i> <b>arc unset</b> <i>arc</i> <i>key</i></p>
<p class="Pp"><i>graphName</i> <b>arc weights</b></p>
<p class="Pp"><i>graphName</i> <b>arcs</b> ?-key <i>key</i>? ?-value
    <i>value</i>? ?-filter <i>cmdprefix</i>? ?-in|-out|-adj|-inner|-embedding
    <i>node node...</i>?</p>
<p class="Pp"><i>graphName</i> <b>lappend</b> <i>key</i> <i>value</i></p>
<p class="Pp"><i>graphName</i> <b>node append</b> <i>node</i> <i>key</i>
    <i>value</i></p>
<p class="Pp"><i>graphName</i> <b>node attr</b> <i>key</i></p>
<p class="Pp"><i>graphName</i> <b>node attr</b> <i>key</i> <b>-nodes</b>
    <i>list</i></p>
<p class="Pp"><i>graphName</i> <b>node attr</b> <i>key</i> <b>-glob</b>
    <i>globpattern</i></p>
<p class="Pp"><i>graphName</i> <b>node attr</b> <i>key</i> <b>-regexp</b>
    <i>repattern</i></p>
<p class="Pp"><i>graphName</i> <b>node degree</b> ?-in|-out? <i>node</i></p>
<p class="Pp"><i>graphName</i> <b>node delete</b> <i>node</i>
  ?<i>node</i>...?</p>
<p class="Pp"><i>graphName</i> <b>node exists</b> <i>node</i></p>
<p class="Pp"><i>graphName</i> <b>node get</b> <i>node</i> <i>key</i></p>
<p class="Pp"><i>graphName</i> <b>node getall</b> <i>node</i>
  ?<i>pattern</i>?</p>
<p class="Pp"><i>graphName</i> <b>node keys</b> <i>node</i> ?<i>pattern</i>?</p>
<p class="Pp"><i>graphName</i> <b>node keyexists</b> <i>node</i> <i>key</i></p>
<p class="Pp"><i>graphName</i> <b>node insert</b> ?<i>node</i>...?</p>
<p class="Pp"><i>graphName</i> <b>node lappend</b> <i>node</i> <i>key</i>
    <i>value</i></p>
<p class="Pp"><i>graphName</i> <b>node opposite</b> <i>node</i> <i>arc</i></p>
<p class="Pp"><i>graphName</i> <b>node rename</b> <i>node</i> <i>newname</i></p>
<p class="Pp"><i>graphName</i> <b>node set</b> <i>node</i> <i>key</i>
    ?<i>value</i>?</p>
<p class="Pp"><i>graphName</i> <b>node unset</b> <i>node</i> <i>key</i></p>
<p class="Pp"><i>graphName</i> <b>nodes</b> ?-key <i>key</i>? ?-value
    <i>value</i>? ?-filter <i>cmdprefix</i>? ?-in|-out|-adj|-inner|-embedding
    <i>node</i> <i>node</i>...?</p>
<p class="Pp"><i>graphName</i> <b>get</b> <i>key</i></p>
<p class="Pp"><i>graphName</i> <b>getall</b> ?<i>pattern</i>?</p>
<p class="Pp"><i>graphName</i> <b>keys</b> ?<i>pattern</i>?</p>
<p class="Pp"><i>graphName</i> <b>keyexists</b> <i>key</i></p>
<p class="Pp"><i>graphName</i> <b>serialize</b> ?<i>node</i>...?</p>
<p class="Pp"><i>graphName</i> <b>set</b> <i>key</i> ?<i>value</i>?</p>
<p class="Pp"><i>graphName</i> <b>swap</b> <i>node1</i> <i>node2</i></p>
<p class="Pp"><i>graphName</i> <b>unset</b> <i>key</i></p>
<p class="Pp"><i>graphName</i> <b>walk</b> <i>node</i> ?-order <i>order</i>?
    ?-type <i>type</i>? ?-dir <i>direction</i>? -command <i>cmd</i></p>
<p class="Pp"></p>
<pre>

</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
A directed graph is a structure containing two collections of elements, called
  <i>nodes</i> and <i>arcs</i> respectively, together with a relation
  (&quot;connectivity&quot;) that places a general structure upon the nodes and
  arcs.
<p class="Pp">Each arc is connected to two nodes, one of which is called the
    <i>source</i> and the other the <i>target</i>. This imposes a direction upon
    the arc, which is said to go from the source to the target. It is allowed
    that source and target of an arc are the same node. Such an arc is called a
    <i>loop</i>. Whenever a node is either the source or target of an arc both
    are said to be <i>adjacent</i>. This extends into a relation between nodes,
    i.e. if two nodes are connected through at least one arc they are said to be
    <i>adjacent</i> too.</p>
<p class="Pp">Each node can be the source and target for any number of arcs. The
    former are called the <i>outgoing arcs</i> of the node, the latter the
    <i>incoming arcs</i> of the node. The number of arcs in either set is called
    the <i>in-degree</i> resp. the <i>out-degree</i> of the node.</p>
<p class="Pp">In addition to maintaining the node and arc relationships, this
    graph implementation allows any number of named <i>attributes</i> to be
    associated with the graph itself, and each node or arc.</p>
<p class="Pp"><i>Note:</i> The major version of the package <b>struct</b> has
    been changed to version 2.0, due to backward incompatible changes in the API
    of this module. Please read the section <b>Changes for 2.0</b> for a full
    list of all changes, incompatible and otherwise.</p>
<p class="Pp"><i>Note:</i> A C-implementation of the command can be had from the
    location <i>http://www.purl.org/NET/schlenker/tcl/cgraph</i>. See also
    <i>http://wiki.tcl.tk/cgraph</i>. This implementation uses a bit less memory
    than the tcl version provided here directly, and is faster. Its support is
    limited to versions of the package before 2.0.</p>
<p class="Pp">As of version 2.2 of this package a critcl based C implementation
    is available from here as well. This implementation however requires Tcl 8.4
    to run.</p>
<p class="Pp">The main command of the package is:</p>
<dl class="Bl-tag">
  <dt><b>::struct::graph</b> ?<i>graphName</i>?
    ?<b>=</b>|<b>:=</b>|<b>as</b>|<b>deserialize</b> <i>source</i>?</dt>
  <dd>The command creates a new graph object with an associated global Tcl
      command whose name is <i>graphName</i>. This command may be used to invoke
      various operations on the graph. It has the following general form:</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>graphName</b> <i>option</i> ?<i>arg arg ...</i>?</dt>
  <dd><i>Option</i> and the <i>arg</i>s determine the exact behavior of the
      command.</dd>
</dl>
</div>
<p class="Pp">If <i>graphName</i> is not specified a unique name will be
    generated by the package itself. If a <i>source</i> is specified the new
    graph will be initialized to it. For the operators <b>=</b>, <b>:=</b>, and
    <b>as</b> the <i>source</i> argument is interpreted as the name of another
    graph object, and the assignment operator <b>=</b> will be executed. For the
    operator <b>deserialize</b> the <i>source</i> is a serialized graph object
    and <b>deserialize</b> will be executed.</p>
<p class="Pp">In other words</p>
<p class="Pp"></p>
<pre>
    ::struct::graph mygraph = b
</pre>
<p class="Pp">is equivalent to</p>
<p class="Pp"></p>
<pre>
    ::struct::graph mygraph
    mygraph = b
</pre>
<p class="Pp">and</p>
<p class="Pp"></p>
<pre>
    ::struct::graph mygraph deserialize $b
</pre>
<p class="Pp">is equivalent to</p>
<p class="Pp"></p>
<pre>
    ::struct::graph mygraph
    mygraph deserialize $b
</pre>
<p class="Pp">The following commands are possible for graph objects:</p>
<dl class="Bl-tag">
  <dt><i>graphName</i> <b>=</b> <i>sourcegraph</i></dt>
  <dd>This is the <i>assignment</i> operator for graph objects. It copies the
      graph contained in the graph object <i>sourcegraph</i> over the graph data
      in <i>graphName</i>. The old contents of <i>graphName</i> are deleted by
      this operation.
    <p class="Pp">This operation is in effect equivalent to</p>
    <p class="Pp"></p>
    <pre>
    <i>graphName</i> <b>deserialize</b> [<i>sourcegraph</i> <b>serialize</b>]
    </pre>
    <p class="Pp">The operation assumes that the <i>sourcegraph</i> provides the
        method <b>serialize</b> and that this method returns a valid graph
        serialization.</p>
  </dd>
  <dt><i>graphName</i> <b>--&gt;</b> <i>destgraph</i></dt>
  <dd>This is the <i>reverse assignment</i> operator for graph objects. It
      copies the graph contained in the graph object <i>graphName</i> over the
      graph data in the object <i>destgraph</i>. The old contents of
      <i>destgraph</i> are deleted by this operation.
    <p class="Pp">This operation is in effect equivalent to</p>
    <p class="Pp"></p>
    <pre>
    <i>destgraph</i> <b>deserialize</b> [<i>graphName</i> <b>serialize</b>]
    </pre>
    <p class="Pp">The operation assumes that the <i>destgraph</i> provides the
        method <b>deserialize</b> and that this method takes a graph
        serialization.</p>
  </dd>
  <dt><i>graphName</i> <b>append</b> <i>key</i> <i>value</i></dt>
  <dd>Appends a <i>value</i> to one of the keyed values associated with the
      graph. Returns the new value given to the attribute <i>key</i>.</dd>
  <dt><i>graphName</i> <b>deserialize</b> <i>serialization</i></dt>
  <dd>This is the complement to <b>serialize</b>. It replaces the graph data in
      <i>graphName</i> with the graph described by the <i>serialization</i>
      value. The old contents of <i>graphName</i> are deleted by this
    operation.</dd>
  <dt><i>graphName</i> <b>destroy</b></dt>
  <dd>Destroys the graph, including its storage space and associated
    command.</dd>
  <dt><i>graphName</i> <b>arc append</b> <i>arc</i> <i>key</i> <i>value</i></dt>
  <dd>Appends a <i>value</i> to one of the keyed values associated with an
      <i>arc</i>. Returns the new value given to the attribute <i>key</i>.</dd>
  <dt><i>graphName</i> <b>arc attr</b> <i>key</i></dt>
  <dd></dd>
  <dt><i>graphName</i> <b>arc attr</b> <i>key</i> <b>-arcs</b> <i>list</i></dt>
  <dd></dd>
  <dt><i>graphName</i> <b>arc attr</b> <i>key</i> <b>-glob</b>
    <i>globpattern</i></dt>
  <dd></dd>
  <dt><i>graphName</i> <b>arc attr</b> <i>key</i> <b>-regexp</b>
    <i>repattern</i></dt>
  <dd>This method retrieves the value of the attribute named <i>key</i>, for all
      arcs in the graph (matching the restriction specified via one of the
      possible options) and having the specified attribute.
    <p class="Pp">The result is a dictionary mapping from arc names to the value
        of attribute <i>key</i> at that arc. Arcs not having the attribute
        <i>key</i>, or not passing a specified restriction, are not listed in
        the result.</p>
    <p class="Pp">The possible restrictions are:</p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>-arcs</b></dt>
  <dd>The value is a list of arcs. Only the arcs mentioned in this list are
      searched for the attribute.</dd>
  <dt><b>-glob</b></dt>
  <dd>The value is a glob pattern. Only the arcs in the graph whose names match
      this pattern are searched for the attribute.</dd>
  <dt><b>-regexp</b></dt>
  <dd>The value is a regular expression. Only the arcs in the graph whose names
      match this pattern are searched for the attribute.</dd>
</dl>
</div>
<p class="Pp"></p>
<dl class="Bl-tag">
  <dt><i>graphName</i> <b>arc delete</b> <i>arc</i> ?<i>arc</i> ...?</dt>
  <dd>Remove the specified arcs from the graph.</dd>
  <dt><i>graphName</i> <b>arc exists</b> <i>arc</i></dt>
  <dd>Return true if the specified <i>arc</i> exists in the graph.</dd>
  <dt><i>graphName</i> <b>arc flip</b> <i>arc</i></dt>
  <dd>Reverses the direction of the named <i>arc</i>, i.e. the source and target
      nodes of the arc are exchanged with each other.</dd>
  <dt><i>graphName</i> <b>arc get</b> <i>arc</i> <i>key</i></dt>
  <dd>Returns the value associated with the key <i>key</i> for the
    <i>arc</i>.</dd>
  <dt><i>graphName</i> <b>arc getall</b> <i>arc</i> ?<i>pattern</i>?</dt>
  <dd>Returns a dictionary (suitable for use with [<b>array set</b>]) for the
      <i>arc</i>. If the <i>pattern</i> is specified only the attributes whose
      names match the pattern will be part of the returned dictionary. The
      pattern is a <b>glob</b> pattern.</dd>
  <dt><i>graphName</i> <b>arc getunweighted</b></dt>
  <dd>Returns a list containing the names of all arcs in the graph which have no
      weight associated with them.</dd>
  <dt><i>graphName</i> <b>arc getweight</b> <i>arc</i></dt>
  <dd>Returns the weight associated with the <i>arc</i>. Throws an error if the
      arc has no weight associated with it.</dd>
  <dt><i>graphName</i> <b>arc keys</b> <i>arc</i> ?<i>pattern</i>?</dt>
  <dd>Returns a list of keys for the <i>arc</i>. If the <i>pattern</i> is
      specified only the attributes whose names match the pattern will be part
      of the returned list. The pattern is a <b>glob</b> pattern.</dd>
  <dt><i>graphName</i> <b>arc keyexists</b> <i>arc</i> <i>key</i></dt>
  <dd>Return true if the specified <i>key</i> exists for the <i>arc</i>.</dd>
  <dt><i>graphName</i> <b>arc insert</b> <i>start</i> <i>end</i>
    ?<i>child</i>?</dt>
  <dd>Insert an arc named <i>child</i> into the graph beginning at the node
      <i>start</i> and ending at the node <i>end</i>. If the name of the new arc
      is not specified the system will generate a unique name of the form
      <i>arc</i><i>x</i>.</dd>
  <dt><i>graphName</i> <b>arc lappend</b> <i>arc</i> <i>key</i>
    <i>value</i></dt>
  <dd>Appends a <i>value</i> (as a list) to one of the keyed values associated
      with an <i>arc</i>. Returns the new value given to the attribute
      <i>key</i>.</dd>
  <dt><i>graphName</i> <b>arc rename</b> <i>arc</i> <i>newname</i></dt>
  <dd>Renames the arc <i>arc</i> to <i>newname</i>. An error is thrown if either
      the arc does not exist, or a arc with name <i>newname</i> does exist. The
      result of the command is the new name of the arc.</dd>
  <dt><i>graphName</i> <b>arc set</b> <i>arc</i> <i>key</i> ?<i>value</i>?</dt>
  <dd>Set or get one of the keyed values associated with an arc. An arc may have
      any number of keyed values associated with it. If <i>value</i> is not
      specified, this command returns the current value assigned to the key; if
      <i>value</i> is specified, this command assigns that value to the key, and
      returns that value.</dd>
  <dt><i>graphName</i> <b>arc setunweighted</b> ?<i>weight</i>?</dt>
  <dd>Sets the weight of all arcs without a weight to <i>weight</i>. Returns the
      empty string as its result. If not present <i>weight</i> defaults to
      <b>0</b>.</dd>
  <dt><i>graphName</i> <b>arc setweight</b> <i>arc</i> <i>weight</i></dt>
  <dd>Sets the weight of the <i>arc</i> to <i>weight</i>. Returns
    <i>weight</i>.</dd>
  <dt><i>graphName</i> <b>arc unsetweight</b> <i>arc</i></dt>
  <dd>Removes the weight of the <i>arc</i>, if present. Does nothing otherwise.
      Returns the empty string.</dd>
  <dt><i>graphName</i> <b>arc hasweight</b> <i>arc</i></dt>
  <dd>Determines if the <i>arc</i> has a weight associated with it. The result
      is a boolean value, <b>True</b> if a weight is defined, and <b>False</b>
      otherwise.</dd>
  <dt><i>graphName</i> <b>arc source</b> <i>arc</i></dt>
  <dd>Return the node the given <i>arc</i> begins at.</dd>
  <dt><i>graphName</i> <b>arc target</b> <i>arc</i></dt>
  <dd>Return the node the given <i>arc</i> ends at.</dd>
  <dt><i>graphName</i> <b>arc nodes</b> <i>arc</i></dt>
  <dd>Return the nodes the given <i>arc</i> begins and ends at, as a two-element
      list.</dd>
  <dt><i>graphName</i> <b>arc move-source</b> <i>arc</i> <i>newsource</i></dt>
  <dd>Changes the source node of the arc to <i>newsource</i>. It can be said
      that the arc rotates around its target node.</dd>
  <dt><i>graphName</i> <b>arc move-target</b> <i>arc</i> <i>newtarget</i></dt>
  <dd>Changes the target node of the arc to <i>newtarget</i>. It can be said
      that the arc rotates around its source node.</dd>
  <dt><i>graphName</i> <b>arc move</b> <i>arc</i> <i>newsource</i>
    <i>newtarget</i></dt>
  <dd>Changes both source and target nodes of the arc to <i>newsource</i>, and
      <i>newtarget</i> resp.</dd>
  <dt><i>graphName</i> <b>arc unset</b> <i>arc</i> <i>key</i></dt>
  <dd>Remove a keyed value from the arc <i>arc</i>. The method will do nothing
      if the <i>key</i> does not exist.</dd>
  <dt><i>graphName</i> <b>arc weights</b></dt>
  <dd>Returns a dictionary whose keys are the names of all arcs which have a
      weight associated with them, and the values are these weights.</dd>
  <dt><i>graphName</i> <b>arcs</b> ?-key <i>key</i>? ?-value <i>value</i>?
    ?-filter <i>cmdprefix</i>? ?-in|-out|-adj|-inner|-embedding <i>node
    node...</i>?</dt>
  <dd>Returns a list of arcs in the graph. If no restriction is specified a list
      containing all arcs is returned. Restrictions can limit the list of
      returned arcs based on the nodes that are connected by the arc, on the
      keyed values associated with the arc, or both. A general filter command
      can be used as well. The restrictions that involve connected nodes take a
      variable number of nodes as argument, specified after the name of the
      restriction itself.
    <p class="Pp">The restrictions imposed by either <b>-in</b>, <b>-out</b>,
        <b>-adj</b>, <b>-inner</b>, or <b>-embedded</b> are applied first.
        Specifying more than one of them is illegal.</p>
    <p class="Pp">After that the restrictions set via <b>-key</b> (and
        <b>-value</b>) are applied. Specifying more than one <b>-key</b> (and
        <b>-value</b>) is illegal. Specifying <b>-value</b> alone, without
        <b>-key</b> is illegal as well.</p>
    <p class="Pp">Any restriction set through <b>-filter</b> is applied last.
        Specifying more than one <b>-filter</b> is illegal.</p>
    <p class="Pp">Coming back to the restrictions based on a set of nodes, the
        command recognizes the following switches:</p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>-in</b></dt>
  <dd>Return a list of all arcs whose target is one of the nodes in the set of
      nodes. I.e. it computes the union of all incoming arcs of the nodes in the
      set.</dd>
  <dt><b>-out</b></dt>
  <dd>Return a list of all arcs whose source is one of the nodes in the set of
      nodes. I.e. it computes the union of all outgoing arcs of the nodes in the
      set.</dd>
  <dt><b>-adj</b></dt>
  <dd>Return a list of all arcs adjacent to at least one of the nodes in the
      set. This is the union of the nodes returned by <b>-in</b> and
      <b>-out</b>.</dd>
  <dt><b>-inner</b></dt>
  <dd>Return a list of all arcs which are adjacent to two of the nodes in the
      set. This is the set of arcs in the subgraph spawned by the specified
      nodes.</dd>
  <dt><b>-embedding</b></dt>
  <dd>Return a list of all arcs adjacent to exactly one of the nodes in the set.
      This is the set of arcs connecting the subgraph spawned by the specified
      nodes to the rest of the graph.</dd>
  <dt><b>-key</b> <i>key</i></dt>
  <dd>Limit the list of arcs that are returned to those arcs that have an
      associated key <i>key</i>.</dd>
  <dt><b>-value</b> <i>value</i></dt>
  <dd>This restriction can only be used in combination with <b>-key</b>. It
      limits the list of arcs that are returned to those arcs whose associated
      key <i>key</i> has the value <i>value</i>.</dd>
  <dt><b>-filter</b> <i>cmdrefix</i></dt>
  <dd>Limit the list of arcs that are returned to those arcs that pass the test.
      The command in <i>cmdprefix</i> is called with two arguments, the name of
      the graph object, and the name of the arc in question. It is executed in
      the context of the caller and has to return a boolean value. Arcs for
      which the command returns <b>false</b> are removed from the result list
      before it is returned to the caller.</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt><i>graphName</i> <b>lappend</b> <i>key</i> <i>value</i></dt>
  <dd>Appends a <i>value</i> (as a list) to one of the keyed values associated
      with the graph. Returns the new value given to the attribute
    <i>key</i>.</dd>
  <dt><i>graphName</i> <b>node append</b> <i>node</i> <i>key</i>
    <i>value</i></dt>
  <dd>Appends a <i>value</i> to one of the keyed values associated with an
      <i>node</i>. Returns the new value given to the attribute <i>key</i>.</dd>
  <dt><i>graphName</i> <b>node attr</b> <i>key</i></dt>
  <dd></dd>
  <dt><i>graphName</i> <b>node attr</b> <i>key</i> <b>-nodes</b>
    <i>list</i></dt>
  <dd></dd>
  <dt><i>graphName</i> <b>node attr</b> <i>key</i> <b>-glob</b>
    <i>globpattern</i></dt>
  <dd></dd>
  <dt><i>graphName</i> <b>node attr</b> <i>key</i> <b>-regexp</b>
    <i>repattern</i></dt>
  <dd>This method retrieves the value of the attribute named <i>key</i>, for all
      nodes in the graph (matching the restriction specified via one of the
      possible options) and having the specified attribute.
    <p class="Pp">The result is a dictionary mapping from node names to the
        value of attribute <i>key</i> at that node. Nodes not having the
        attribute <i>key</i>, or not passing a specified restriction, are not
        listed in the result.</p>
    <p class="Pp">The possible restrictions are:</p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>-nodes</b></dt>
  <dd>The value is a list of nodes. Only the nodes mentioned in this list are
      searched for the attribute.</dd>
  <dt><b>-glob</b></dt>
  <dd>The value is a glob pattern. Only the nodes in the graph whose names match
      this pattern are searched for the attribute.</dd>
  <dt><b>-regexp</b></dt>
  <dd>The value is a regular expression. Only the nodes in the graph whose names
      match this pattern are searched for the attribute.</dd>
</dl>
</div>
<p class="Pp"></p>
<dl class="Bl-tag">
  <dt><i>graphName</i> <b>node degree</b> ?-in|-out? <i>node</i></dt>
  <dd>Return the number of arcs adjacent to the specified <i>node</i>. If one of
      the restrictions <b>-in</b> or <b>-out</b> is given only the incoming
      resp. outgoing arcs are counted.</dd>
  <dt><i>graphName</i> <b>node delete</b> <i>node</i> ?<i>node</i>...?</dt>
  <dd>Remove the specified nodes from the graph. All of the nodes' arcs will be
      removed as well to prevent unconnected arcs.</dd>
  <dt><i>graphName</i> <b>node exists</b> <i>node</i></dt>
  <dd>Return true if the specified <i>node</i> exists in the graph.</dd>
  <dt><i>graphName</i> <b>node get</b> <i>node</i> <i>key</i></dt>
  <dd>Return the value associated with the key <i>key</i> for the
    <i>node</i>.</dd>
  <dt><i>graphName</i> <b>node getall</b> <i>node</i> ?<i>pattern</i>?</dt>
  <dd>Returns a dictionary (suitable for use with [<b>array set</b>]) for the
      <i>node</i>. If the <i>pattern</i> is specified only the attributes whose
      names match the pattern will be part of the returned dictionary. The
      pattern is a <b>glob</b> pattern.</dd>
  <dt><i>graphName</i> <b>node keys</b> <i>node</i> ?<i>pattern</i>?</dt>
  <dd>Returns a list of keys for the <i>node</i>. If the <i>pattern</i> is
      specified only the attributes whose names match the pattern will be part
      of the returned list. The pattern is a <b>glob</b> pattern.</dd>
  <dt><i>graphName</i> <b>node keyexists</b> <i>node</i> <i>key</i></dt>
  <dd>Return true if the specified <i>key</i> exists for the <i>node</i>.</dd>
  <dt><i>graphName</i> <b>node insert</b> ?<i>node</i>...?</dt>
  <dd>Insert one or more nodes into the graph. The new nodes have no arcs
      connected to them. If no node is specified one node will be inserted, and
      the system will generate a unique name of the form <i>node</i><i>x</i> for
      it.</dd>
  <dt><i>graphName</i> <b>node lappend</b> <i>node</i> <i>key</i>
    <i>value</i></dt>
  <dd>Appends a <i>value</i> (as a list) to one of the keyed values associated
      with an <i>node</i>. Returns the new value given to the attribute
      <i>key</i>.</dd>
  <dt><i>graphName</i> <b>node opposite</b> <i>node</i> <i>arc</i></dt>
  <dd>Return the node at the other end of the specified <i>arc</i>, which has to
      be adjacent to the given <i>node</i>.</dd>
  <dt><i>graphName</i> <b>node rename</b> <i>node</i> <i>newname</i></dt>
  <dd>Renames the node <i>node</i> to <i>newname</i>. An error is thrown if
      either the node does not exist, or a node with name <i>newname</i> does
      exist. The result of the command is the new name of the node.</dd>
  <dt><i>graphName</i> <b>node set</b> <i>node</i> <i>key</i>
    ?<i>value</i>?</dt>
  <dd>Set or get one of the keyed values associated with a node. A node may have
      any number of keyed values associated with it. If <i>value</i> is not
      specified, this command returns the current value assigned to the key; if
      <i>value</i> is specified, this command assigns that value to the
    key.</dd>
  <dt><i>graphName</i> <b>node unset</b> <i>node</i> <i>key</i></dt>
  <dd>Remove a keyed value from the node <i>node</i>. The method will do nothing
      if the <i>key</i> does not exist.</dd>
  <dt><i>graphName</i> <b>nodes</b> ?-key <i>key</i>? ?-value <i>value</i>?
    ?-filter <i>cmdprefix</i>? ?-in|-out|-adj|-inner|-embedding <i>node</i>
    <i>node</i>...?</dt>
  <dd>Return a list of nodes in the graph. Restrictions can limit the list of
      returned nodes based on neighboring nodes, or based on the keyed values
      associated with the node. The restrictions that involve neighboring nodes
      have a list of nodes as argument, specified after the name of the
      restriction itself.
    <p class="Pp">The possible restrictions are the same as for method
        <b>arcs</b>. The exact meanings change slightly, as they operate on
        nodes instead of arcs. The command recognizes:</p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>-in</b></dt>
  <dd>Return a list of all nodes with at least one outgoing arc ending in a node
      found in the specified set of nodes. Alternatively specified as the set of
      source nodes for the <b>-in</b> arcs of the node set. The <i>incoming
      neighbours</i>.</dd>
  <dt><b>-out</b></dt>
  <dd>Return a list of all nodes with at least one incoming arc starting in a
      node found in the specified set of nodes. Alternatively specified as the
      set of target nodes for the <b>-out</b> arcs of the node set. The
      <i>outgoing neighbours</i>.</dd>
  <dt><b>-adj</b></dt>
  <dd>This is the union of the nodes returned by <b>-in</b> and <b>-out</b>. The
      <i>neighbours</i>.</dd>
  <dt><b>-inner</b></dt>
  <dd>The set of neighbours (see <b>-adj</b> above) which are also in the set of
      nodes. I.e. the intersection between the set of nodes and the neighbours
      per <b>-adj</b>.</dd>
  <dt><b>-embedding</b></dt>
  <dd>The set of neighbours (see <b>-adj</b> above) which are not in the set of
      nodes. I.e. the difference between the neighbours as per <b>-adj</b>, and
      the set of nodes.</dd>
  <dt><b>-key</b> <i>key</i></dt>
  <dd>Limit the list of nodes that are returned to those nodes that have an
      associated key <i>key</i>.</dd>
  <dt><b>-value</b> <i>value</i></dt>
  <dd>This restriction can only be used in combination with <b>-key</b>. It
      limits the list of nodes that are returned to those nodes whose associated
      key <i>key</i> has the value <i>value</i>.</dd>
  <dt><b>-filter</b> <i>cmdrefix</i></dt>
  <dd>Limit the list of nodes that are returned to those nodes that pass the
      test. The command in <i>cmdprefix</i> is called with two arguments, the
      name of the graph object, and the name of the node in question. It is
      executed in the context of the caller and has to return a boolean value.
      Nodes for which the command returns <b>false</b> are removed from the
      result list before it is returned to the caller.</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt><i>graphName</i> <b>get</b> <i>key</i></dt>
  <dd>Return the value associated with the key <i>key</i> for the graph.</dd>
  <dt><i>graphName</i> <b>getall</b> ?<i>pattern</i>?</dt>
  <dd>Returns a dictionary (suitable for use with [<b>array set</b>]) for the
      whole graph. If the <i>pattern</i> is specified only the attributes whose
      names match the pattern will be part of the returned dictionary. The
      pattern is a <b>glob</b> pattern.</dd>
  <dt><i>graphName</i> <b>keys</b> ?<i>pattern</i>?</dt>
  <dd>Returns a list of keys for the whole graph. If the <i>pattern</i> is
      specified only the attributes whose names match the pattern will be part
      of the returned list. The pattern is a <b>glob</b> pattern.</dd>
  <dt><i>graphName</i> <b>keyexists</b> <i>key</i></dt>
  <dd>Return true if the specified <i>key</i> exists for the whole graph.</dd>
  <dt><i>graphName</i> <b>serialize</b> ?<i>node</i>...?</dt>
  <dd>This method serializes the sub-graph spanned up by the <i>node</i>s. In
      other words it returns a tcl value completely describing that graph. If no
      nodes are specified the whole graph will be serialized. This allows, for
      example, the transfer of graph objects (or parts thereof) over arbitrary
      channels, persistence, etc. This method is also the basis for both the
      copy constructor and the assignment operator.
    <p class="Pp">The result of this method has to be semantically identical
        over all implementations of the graph interface. This is what will
        enable us to copy graph data between different implementations of the
        same interface.</p>
    <p class="Pp">The result is a list containing a multiple of three items,
        plus one! In other words, '[llength $serial] % 3 == 1'. Valid values
        include 1, 4, 7, ...</p>
    <p class="Pp">The last element of the list is a dictionary containing the
        attributes associated with the whole graph. Regarding the other
        elements; each triple consists of</p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>[1]</dt>
  <dd>The name of the node to be described,</dd>
  <dt>[2]</dt>
  <dd>A dictionary containing the attributes associated with the node,</dd>
  <dt>[3]</dt>
  <dd>And a list describing all the arcs starting at that node.</dd>
</dl>
</div>
<p class="Pp">The elements of the arc list are lists containing three or four
    elements each, i.e.</p>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>[1]</dt>
  <dd>The name of the arc described by the element,</dd>
  <dt>[2]</dt>
  <dd>A reference to the destination node of the arc. This reference is an
      integer number given the index of that node in the main serialization
      list. As that it is greater than or equal to zero, less than the length of
      the serialization, and a multiple of three. <i>Note:</i> For internal
      consistency no arc name may be used twice, whether in the same node, or at
      some other node. This is a global consistency requirement for the
      serialization.</dd>
  <dt>[3]</dt>
  <dd>And a dictionary containing the attributes associated with the arc.</dd>
  <dt>[4]</dt>
  <dd>The weight associated with the arc. This value is optional. Its
      non-presence means that the arc in question has no weight associated with
      it.
    <p class="Pp"><i>Note:</i> This information is new, compared to the
        serialization of <b>graph</b> 2.3 and earlier. By making it an optional
        element the new format is maximally compatible with the old. This means
        that any graph not using weights will generate a serialization which is
        still understood by the older graph package. A serialization will not be
        understood any longer by the older packages if, and only if the graph it
        was generated from actually has arcs with weights.</p>
  </dd>
</dl>
</div>
<p class="Pp">For all attribute dictionaries they keys are the names of the
    attributes, and the values are the values for each name.</p>
<p class="Pp"><i>Note:</i> The order of the nodes in the serialization has no
    relevance, nor has the order of the arcs per node.</p>
<pre>
    # A possible serialization for the graph structure
    #
    #        d -----&gt; %2
    #       /         ^ \\
    #      /         /   \\
    #     /         b     \\
    #    /         /       \\
    #  %1 &lt;- a - %0         e
    #    ^         \\      /
    #     \\        c     /
    #      \\        \\  /
    #       \\        v v
    #        f ------ %3
    # is
    #
    # %3 {} {{f 6 {}}} %0 {} {{a 6 {}} {b 9 {}} {c 0 {}}} %1 {} {{d 9 {}}} %2 {} {{e 0 {}}} {}
    #
    # This assumes that the graph has neither attribute data nor weighted arcs.
</pre>
<p class="Pp"></p>
<dl class="Bl-tag">
  <dt><i>graphName</i> <b>set</b> <i>key</i> ?<i>value</i>?</dt>
  <dd>Set or get one of the keyed values associated with a graph. A graph may
      have any number of keyed values associated with it. If <i>value</i> is not
      specified, this command returns the current value assigned to the key; if
      <i>value</i> is specified, this command assigns that value to the
    key.</dd>
  <dt><i>graphName</i> <b>swap</b> <i>node1</i> <i>node2</i></dt>
  <dd>Swap the position of <i>node1</i> and <i>node2</i> in the graph.</dd>
  <dt><i>graphName</i> <b>unset</b> <i>key</i></dt>
  <dd>Remove a keyed value from the graph. The method will do nothing if the
      <i>key</i> does not exist.</dd>
  <dt><i>graphName</i> <b>walk</b> <i>node</i> ?-order <i>order</i>? ?-type
    <i>type</i>? ?-dir <i>direction</i>? -command <i>cmd</i></dt>
  <dd>Perform a breadth-first or depth-first walk of the graph starting at the
      node <i>node</i> going in either the direction of outgoing or opposite to
      the incoming arcs.
    <p class="Pp">The type of walk, breadth-first or depth-first, is determined
        by the value of <i>type</i>; <b>bfs</b> indicates breadth-first,
        <b>dfs</b> indicates depth-first. Depth-first is the default.</p>
    <p class="Pp">The order of the walk, pre-order, post-order or both-order is
        determined by the value of <i>order</i>; <b>pre</b> indicates pre-order,
        <b>post</b> indicates post-order, <b>both</b> indicates both-order.
        Pre-order is the default. Pre-order walking means that a node is visited
        before any of its neighbors (as defined by the <i>direction</i>, see
        below). Post-order walking means that a parent is visited after any of
        its neighbors. Both-order walking means that a node is visited before
        <i>and</i> after any of its neighbors. The combination of a
        breadth-first walk with post- or both-order is illegal.</p>
    <p class="Pp">The direction of the walk is determined by the value of
        <i>dir</i>; <b>backward</b> indicates the direction opposite to the
        incoming arcs, <b>forward</b> indicates the direction of the outgoing
        arcs.</p>
    <p class="Pp">As the walk progresses, the command <i>cmd</i> will be
        evaluated at each node, with the mode of the call (<b>enter</b> or
        <b>leave</b>) and values <i>graphName</i> and the name of the current
        node appended. For a pre-order walk, all nodes are <b>enter</b>ed, for a
        post-order all nodes are left. In a both-order walk the first visit of a
        node <b>enter</b>s it, the second visit <b>leave</b>s it.</p>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="CHANGES_FOR_2.0"><a class="permalink" href="#CHANGES_FOR_2.0">CHANGES
  FOR 2.0</a></h1>
The following noteworthy changes have occurred:
<dl class="Bl-tag">
  <dt>[1]</dt>
  <dd>The API for accessing attributes and their values has been simplified.
    <p class="Pp">All functionality regarding the default attribute
        &quot;data&quot; has been removed. This default attribute does not exist
        anymore. All accesses to attributes have to specify the name of the
        attribute in question. This backward <i>incompatible</i> change allowed
        us to simplify the signature of all methods handling attributes.</p>
    <p class="Pp">Especially the flag <b>-key</b> is not required anymore, even
        more, its use is now forbidden. Please read the documentation for the
        arc and node methods <b>set</b>, <b>get</b>, <b>getall</b>,
        <b>unset</b>, <b>append</b>, <b>lappend</b>, <b>keyexists</b> and
        <b>keys</b> for a description of the new API's.</p>
  </dd>
  <dt>[2]</dt>
  <dd>The methods <b>keys</b> and <b>getall</b> now take an optional pattern
      argument and will return only attribute data for keys matching this
      pattern.</dd>
  <dt>[3]</dt>
  <dd>Arcs and nodes can now be renamed. See the documentation for the methods
      <b>arc rename</b> and <b>node rename</b>.</dd>
  <dt>[4]</dt>
  <dd>The structure has been extended with API's for the serialization and
      deserialization of graph objects, and a number of operations based on them
      (graph assignment, copy construction).
    <p class="Pp">Please read the documentation for the methods
        <b>serialize</b>, <b>deserialize</b>, <b>=</b>, and <b>--&gt;</b>, and
        the documentation on the construction of graph objects.</p>
    <p class="Pp">Beyond the copying of whole graph objects these new API's also
        enable the transfer of graph objects over arbitrary channels and for
        easy persistence.</p>
  </dd>
  <dt>[5]</dt>
  <dd>A new method, <b>attr</b>, was added to both <b>arc</b> and <b>node</b>
      allowing the query and retrieval of attribute data without regard to arc
      and node relationships.</dd>
  <dt>[6]</dt>
  <dd>Both methods <b>arcs</b> and <b>nodes</b> have been extended with the
      ability to select arcs and nodes based on an arbitrary filtering
      criterium.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="BUGS,_IDEAS,_FEEDBACK"><a class="permalink" href="#BUGS,_IDEAS,_FEEDBACK">BUGS,
  IDEAS, FEEDBACK</a></h1>
This document, and the package it describes, will undoubtedly contain bugs and
  other problems. Please report such in the category <i>struct :: graph</i> of
  the <i>Tcllib SF Trackers</i>
  [http://sourceforge.net/tracker/?group_id=12883]. Please also report any ideas
  for enhancements you may have for either package and/or documentation.
</section>
<section class="Sh">
<h1 class="Sh" id="KEYWORDS"><a class="permalink" href="#KEYWORDS">KEYWORDS</a></h1>
adjacent, arc, cgraph, degree, edge, graph, loop, neighbour, node,
  serialization, subgraph, vertex
</section>
<section class="Sh">
<h1 class="Sh" id="CATEGORY"><a class="permalink" href="#CATEGORY">CATEGORY</a></h1>
Data structures
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT"><a class="permalink" href="#COPYRIGHT">COPYRIGHT</a></h1>
<pre>
Copyright (c) 2002-2009 Andreas Kupries &lt;andreas_kupries@users.sourceforge.net&gt;
</pre>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2.4</td>
    <td class="foot-os">struct</td>
  </tr>
</table>
</body>
</html>
