<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    .Nd, .Bf, .Op { display: inline; }
    .Pa, .Ad { font-style: italic; }
    .Ms { font-weight: bold; }
    .Bl-diag > dt { font-weight: bold; }
    code.Nm, .Fl, .Cm, .Ic, code.In, .Fd, .Fn, .Cd { font-weight: bold;
      font-family: inherit; }
  </style>
  <title>PERLEMBED(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">PERLEMBED(1)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">PERLEMBED(1)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">perlembed - how to embed perl in your C program</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<section class="Ss">
<h2 class="Ss">PREAMBLE</h2>
<p class="Pp">Do you want to:</p>
<dl class="Bl-tag">
  <dt id="Use"><a class="permalink" href="#Use"><b>Use C from Perl?</b></a></dt>
  <dd>Read perlxstut, perlxs, h2xs, perlguts, and perlapi.</dd>
  <dt id="Use~2"><a class="permalink" href="#Use~2"><b>Use a Unix program from
    Perl?</b></a></dt>
  <dd>Read about back-quotes and about
      <span class="Li">&quot;system&quot;</span> and
      <span class="Li">&quot;exec&quot;</span> in perlfunc.</dd>
  <dt id="Use~3"><a class="permalink" href="#Use~3"><b>Use Perl from
    Perl?</b></a></dt>
  <dd>Read about &quot;do&quot; in perlfunc and &quot;eval&quot; in perlfunc and
      &quot;require&quot; in perlfunc and &quot;use&quot; in perlfunc.</dd>
  <dt id="Use~4"><a class="permalink" href="#Use~4"><b>Use C from
    C?</b></a></dt>
  <dd>Rethink your design.</dd>
  <dt id="Use~5"><a class="permalink" href="#Use~5"><b>Use Perl from
    C?</b></a></dt>
  <dd>Read on...</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss">ROADMAP</h2>
<ul class="Bl-bullet">
  <li>Compiling your C program</li>
  <li>Adding a Perl interpreter to your C program</li>
  <li>Calling a Perl subroutine from your C program</li>
  <li>Evaluating a Perl statement from your C program</li>
  <li>Performing Perl pattern matches and substitutions from your C program</li>
  <li>Fiddling with the Perl stack from your C program</li>
  <li>Maintaining a persistent interpreter</li>
  <li>Maintaining multiple interpreter instances</li>
  <li>Using Perl modules, which themselves use C libraries, from your C
    program</li>
  <li>Embedding Perl under Win32</li>
</ul>
</section>
<section class="Ss">
<h2 class="Ss" id="Compiling_your_C_program"><a class="permalink" href="#Compiling_your_C_program">Compiling
  your C program</a></h2>
<p class="Pp">If you have trouble compiling the scripts in this documentation,
    you're not alone. The cardinal rule: COMPILE THE PROGRAMS IN EXACTLY THE
    SAME WAY THAT YOUR PERL WAS COMPILED. (Sorry for yelling.)</p>
<p class="Pp">Also, every C program that uses Perl must link in the <i>perl
    library</i>. What's that, you ask? Perl is itself written in C; the perl
    library is the collection of compiled C programs that were used to create
    your perl executable (<i>/usr/bin/perl</i> or equivalent). (Corollary: you
    can't use Perl from your C program unless Perl has been compiled on your
    machine, or installed properly--that's why you shouldn't blithely copy Perl
    executables from machine to machine without also copying the <i>lib</i>
    directory.)</p>
<p class="Pp">When you use Perl from C, your C program will--usually--allocate,
    &quot;run&quot;, and deallocate a <i>PerlInterpreter</i> object, which is
    defined by the perl library.</p>
<p class="Pp">If your copy of Perl is recent enough to contain this
    documentation (version 5.002 or later), then the perl library (and
    <i>EXTERN.h</i> and <i>perl.h</i>, which you'll also need) will reside in a
    directory that looks like this:</p>
<p class="Pp"></p>
<pre>    /usr/local/lib/perl5/your_architecture_here/CORE
</pre>
<p class="Pp">or perhaps just</p>
<p class="Pp"></p>
<pre>    /usr/local/lib/perl5/CORE
</pre>
<p class="Pp">or maybe something like</p>
<p class="Pp"></p>
<pre>    /usr/opt/perl5/CORE
</pre>
<p class="Pp">Execute this statement for a hint about where to find CORE:</p>
<p class="Pp"></p>
<pre>    perl -MConfig -e 'print $Config{archlib}'
</pre>
<p class="Pp">Here's how you'd compile the example in the next section,
    &quot;Adding a Perl interpreter to your C program&quot;, on my Linux
  box:</p>
<p class="Pp"></p>
<pre>    % gcc -O2 -Dbool=char -DHAS_BOOL -I/usr/local/include
    -I/usr/local/lib/perl5/i586-linux/5.003/CORE
    -L/usr/local/lib/perl5/i586-linux/5.003/CORE
    -o interp interp.c -lperl -lm
</pre>
<p class="Pp">(That's all one line.) On my DEC Alpha running old 5.003_05, the
    incantation is a bit different:</p>
<p class="Pp"></p>
<pre>    % cc -O2 -Olimit 2900 -I/usr/local/include
    -I/usr/local/lib/perl5/alpha-dec_osf/5.00305/CORE
    -L/usr/local/lib/perl5/alpha-dec_osf/5.00305/CORE -L/usr/local/lib
    -D__LANGUAGE_C__ -D_NO_PROTO -o interp interp.c -lperl -lm
</pre>
<p class="Pp">How can you figure out what to add? Assuming your Perl is
    post-5.001, execute a <span class="Li">&quot;perl -V&quot;</span> command
    and pay special attention to the &quot;cc&quot; and &quot;ccflags&quot;
    information.</p>
<p class="Pp">You'll have to choose the appropriate compiler (<i>cc</i>,
    <i>gcc</i>, et al.) for your machine: <span class="Li">&quot;perl -MConfig
    -e 'print $Config{cc}'&quot;</span> will tell you what to use.</p>
<p class="Pp">You'll also have to choose the appropriate library directory
    (<i>/usr/local/lib/...</i>) for your machine. If your compiler complains
    that certain functions are undefined, or that it can't locate <i>-lperl</i>,
    then you need to change the path following the
    <span class="Li">&quot;-L&quot;</span>. If it complains that it can't find
    <i>EXTERN.h</i> and <i>perl.h</i>, you need to change the path following the
    <span class="Li">&quot;-I&quot;</span>.</p>
<p class="Pp">You may have to add extra libraries as well. Which ones? Perhaps
    those printed by</p>
<p class="Pp"></p>
<pre>   perl -MConfig -e 'print $Config{libs}'
</pre>
<p class="Pp">Provided your perl binary was properly configured and installed
    the <b>ExtUtils::Embed</b> module will determine all of this information for
    you:</p>
<p class="Pp"></p>
<pre>   % cc -o interp interp.c `perl -MExtUtils::Embed -e ccopts -e ldopts`
</pre>
<p class="Pp">If the <b>ExtUtils::Embed</b> module isn't part of your Perl
    distribution, you can retrieve it from
    &lt;http://www.perl.com/perl/CPAN/modules/by-module/ExtUtils/&gt; (If this
    documentation came from your Perl distribution, then you're running 5.004 or
    better and you already have it.)</p>
<p class="Pp">The <b>ExtUtils::Embed</b> kit on CPAN also contains all source
    code for the examples in this document, tests, additional examples and other
    information you may find useful.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Adding_a_Perl_interpreter_to_your_C_program"><a class="permalink" href="#Adding_a_Perl_interpreter_to_your_C_program">Adding
  a Perl interpreter to your C program</a></h2>
<p class="Pp">In a sense, perl (the C program) is a good example of embedding
    Perl (the language), so I'll demonstrate embedding with
    <i>miniperlmain.c</i>, included in the source distribution. Here's a
    bastardized, non-portable version of <i>miniperlmain.c</i> containing the
    essentials of embedding:</p>
<p class="Pp"></p>
<pre> #include &lt;EXTERN.h&gt;               /* from the Perl distribution     */
 #include &lt;perl.h&gt;                 /* from the Perl distribution     */
 static PerlInterpreter *my_perl;  /***    The Perl interpreter    ***/
 int main(int argc, char **argv, char **env)
 {
        PERL_SYS_INIT3(&amp;argc,&amp;argv,&amp;env);
        my_perl = perl_alloc();
        perl_construct(my_perl);
        PL_exit_flags |= PERL_EXIT_DESTRUCT_END;
        perl_parse(my_perl, NULL, argc, argv, (char **)NULL);
        perl_run(my_perl);
        perl_destruct(my_perl);
        perl_free(my_perl);
        PERL_SYS_TERM();
        exit(EXIT_SUCCESS);
 }
</pre>
<p class="Pp">Notice that we don't use the
    <span class="Li">&quot;env&quot;</span> pointer. Normally handed to
    <span class="Li">&quot;perl_parse&quot;</span> as its final argument,
    <span class="Li">&quot;env&quot;</span> here is replaced by
    <span class="Li">&quot;NULL&quot;</span>, which means that the current
    environment will be used.</p>
<p class="Pp">The macros <b>PERL_SYS_INIT3()</b> and <b>PERL_SYS_TERM()</b>
    provide system-specific tune up of the C runtime environment necessary to
    run Perl interpreters; they should only be called once regardless of how
    many interpreters you create or destroy. Call <b>PERL_SYS_INIT3()</b> before
    you create your first interpreter, and <b>PERL_SYS_TERM()</b> after you free
    your last interpreter.</p>
<p class="Pp">Since <b>PERL_SYS_INIT3()</b> may change
    <span class="Li">&quot;env&quot;</span>, it may be more appropriate to
    provide <span class="Li">&quot;env&quot;</span> as an argument to
    <b>perl_parse()</b>.</p>
<p class="Pp">Also notice that no matter what arguments you pass to
    <b>perl_parse()</b>, <b>PERL_SYS_INIT3()</b> must be invoked on the C
    <b>main()</b> argc, argv and env and only once.</p>
<p class="Pp">Mind that argv[argc] must be NULL, same as those passed to a main
    function in C.</p>
<p class="Pp">Now compile this program (I'll call it <i>interp.c</i>) into an
    executable:</p>
<p class="Pp"></p>
<pre>    % cc -o interp interp.c `perl -MExtUtils::Embed -e ccopts -e ldopts`
</pre>
<p class="Pp">After a successful compilation, you'll be able to use
    <i>interp</i> just like perl itself:</p>
<p class="Pp"></p>
<pre>    % interp
    print &quot;Pretty Good Perl \n&quot;;
    print &quot;10890 - 9801 is &quot;, 10890 - 9801;
    &lt;CTRL-D&gt;
    Pretty Good Perl
    10890 - 9801 is 1089
</pre>
<p class="Pp">or</p>
<p class="Pp"></p>
<pre>    % interp -e 'printf(&quot;%x&quot;, 3735928559)'
    deadbeef
</pre>
<p class="Pp">You can also read and execute Perl statements from a file while in
    the midst of your C program, by placing the filename in <i>argv[1]</i>
    before calling <i>perl_run</i>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Calling_a_Perl_subroutine_from_your_C_program"><a class="permalink" href="#Calling_a_Perl_subroutine_from_your_C_program">Calling
  a Perl subroutine from your C program</a></h2>
<p class="Pp">To call individual Perl subroutines, you can use any of the
    <b>call_*</b> functions documented in perlcall. In this example we'll use
    <span class="Li">&quot;call_argv&quot;</span>.</p>
<p class="Pp">That's shown below, in a program I'll call <i>showtime.c</i>.</p>
<p class="Pp"></p>
<pre>    #include &lt;EXTERN.h&gt;
    #include &lt;perl.h&gt;
    static PerlInterpreter *my_perl;
    int main(int argc, char **argv, char **env)
    {
        char *args[] = { NULL };
        PERL_SYS_INIT3(&amp;argc,&amp;argv,&amp;env);
        my_perl = perl_alloc();
        perl_construct(my_perl);
        perl_parse(my_perl, NULL, argc, argv, NULL);
        PL_exit_flags |= PERL_EXIT_DESTRUCT_END;
        /*** skipping perl_run() ***/
        call_argv(&quot;showtime&quot;, G_DISCARD | G_NOARGS, args);
        perl_destruct(my_perl);
        perl_free(my_perl);
        PERL_SYS_TERM();
        exit(EXIT_SUCCESS);
    }
</pre>
<p class="Pp">where <i>showtime</i> is a Perl subroutine that takes no arguments
    (that's the <i>G_NOARGS</i>) and for which I'll ignore the return value
    (that's the <i>G_DISCARD</i>). Those flags, and others, are discussed in
    perlcall.</p>
<p class="Pp">I'll define the <i>showtime</i> subroutine in a file called
    <i>showtime.pl</i>:</p>
<p class="Pp"></p>
<pre> print &quot;I shan't be printed.&quot;;
 sub showtime {
     print time;
 }
</pre>
<p class="Pp">Simple enough. Now compile and run:</p>
<p class="Pp"></p>
<pre> % cc -o showtime showtime.c \
     `perl -MExtUtils::Embed -e ccopts -e ldopts`
 % showtime showtime.pl
 818284590
</pre>
<p class="Pp">yielding the number of seconds that elapsed between January 1,
    1970 (the beginning of the Unix epoch), and the moment I began writing this
    sentence.</p>
<p class="Pp">In this particular case we don't have to call <i>perl_run</i>, as
    we set the PL_exit_flag PERL_EXIT_DESTRUCT_END which executes END blocks in
    perl_destruct.</p>
<p class="Pp">If you want to pass arguments to the Perl subroutine, you can add
    strings to the <span class="Li">&quot;NULL&quot;</span>-terminated
    <span class="Li">&quot;args&quot;</span> list passed to <i>call_argv</i>.
    For other data types, or to examine return values, you'll need to manipulate
    the Perl stack. That's demonstrated in &quot;Fiddling with the Perl stack
    from your C program&quot;.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Evaluating_a_Perl_statement_from_your_C_program"><a class="permalink" href="#Evaluating_a_Perl_statement_from_your_C_program">Evaluating
  a Perl statement from your C program</a></h2>
<p class="Pp">Perl provides two API functions to evaluate pieces of Perl code.
    These are &quot;eval_sv&quot; in perlapi and &quot;eval_pv&quot; in
  perlapi.</p>
<p class="Pp">Arguably, these are the only routines you'll ever need to execute
    snippets of Perl code from within your C program. Your code can be as long
    as you wish; it can contain multiple statements; it can employ
    &quot;use&quot; in perlfunc, &quot;require&quot; in perlfunc, and
    &quot;do&quot; in perlfunc to include external Perl files.</p>
<p class="Pp"><i>eval_pv</i> lets us evaluate individual Perl strings, and then
    extract variables for coercion into C types. The following program,
    <i>string.c</i>, executes three Perl strings, extracting an
    <span class="Li">&quot;int&quot;</span> from the first, a
    <span class="Li">&quot;float&quot;</span> from the second, and a
    <span class="Li">&quot;char *&quot;</span> from the third.</p>
<p class="Pp"></p>
<pre> #include &lt;EXTERN.h&gt;
 #include &lt;perl.h&gt;
 static PerlInterpreter *my_perl;
 main (int argc, char **argv, char **env)
 {
     char *embedding[] = { &quot;&quot;, &quot;-e&quot;, &quot;0&quot;, NULL };
     PERL_SYS_INIT3(&amp;argc,&amp;argv,&amp;env);
     my_perl = perl_alloc();
     perl_construct( my_perl );
     perl_parse(my_perl, NULL, 3, embedding, NULL);
     PL_exit_flags |= PERL_EXIT_DESTRUCT_END;
     perl_run(my_perl);
     /** Treat $a as an integer **/
     eval_pv(&quot;$a = 3; $a **= 2&quot;, TRUE);
     printf(&quot;a = %d\n&quot;, SvIV(get_sv(&quot;a&quot;, 0)));
     /** Treat $a as a float **/
     eval_pv(&quot;$a = 3.14; $a **= 2&quot;, TRUE);
     printf(&quot;a = %f\n&quot;, SvNV(get_sv(&quot;a&quot;, 0)));
     /** Treat $a as a string **/
     eval_pv(
       &quot;$a = 'rekcaH lreP rehtonA tsuJ'; $a = reverse($a);&quot;, TRUE);
     printf(&quot;a = %s\n&quot;, SvPV_nolen(get_sv(&quot;a&quot;, 0)));
     perl_destruct(my_perl);
     perl_free(my_perl);
     PERL_SYS_TERM();
 }
</pre>
<p class="Pp">All of those strange functions with <i>sv</i> in their names help
    convert Perl scalars to C types. They're described in perlguts and
  perlapi.</p>
<p class="Pp">If you compile and run <i>string.c</i>, you'll see the results of
    using <i></i><b><i>SvIV()</i></b><i></i> to create an
    <span class="Li">&quot;int&quot;</span>, <i></i><b><i>SvNV()</i></b><i></i>
    to create a <span class="Li">&quot;float&quot;</span>, and
    <i></i><b><i>SvPV()</i></b><i></i> to create a string:</p>
<p class="Pp"></p>
<pre>   a = 9
   a = 9.859600
   a = Just Another Perl Hacker
</pre>
<p class="Pp">In the example above, we've created a global variable to
    temporarily store the computed value of our eval'ed expression. It is also
    possible and in most cases a better strategy to fetch the return value from
    <i></i><b><i>eval_pv()</i></b><i></i> instead. Example:</p>
<p class="Pp"></p>
<pre>   ...
   SV *val = eval_pv(&quot;reverse 'rekcaH lreP rehtonA tsuJ'&quot;, TRUE);
   printf(&quot;%s\n&quot;, SvPV_nolen(val));
   ...
</pre>
<p class="Pp">This way, we avoid namespace pollution by not creating global
    variables and we've simplified our code as well.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Performing_Perl_pattern_matches_and_substitutions_from_your_C_program"><a class="permalink" href="#Performing_Perl_pattern_matches_and_substitutions_from_your_C_program">Performing
  Perl pattern matches and substitutions from your C program</a></h2>
<p class="Pp">The <i></i><b><i>eval_sv()</i></b><i></i> function lets us
    evaluate strings of Perl code, so we can define some functions that use it
    to &quot;specialize&quot; in matches and substitutions:
    <i></i><b><i>match()</i></b><i></i>,
    <i></i><b><i>substitute()</i></b><i></i>, and
    <i></i><b><i>matches()</i></b><i></i>.</p>
<p class="Pp"></p>
<pre>   I32 match(SV *string, char *pattern);
</pre>
<p class="Pp">Given a string and a pattern (e.g.,
    <span class="Li">&quot;m/clasp/&quot;</span> or
    <span class="Li">&quot;/\b\w*\b/&quot;</span>, which in your C program might
    appear as &quot;/\\b\\w*\\b/&quot;), <b>match()</b> returns 1 if the string
    matches the pattern and 0 otherwise.</p>
<p class="Pp"></p>
<pre>   int substitute(SV **string, char *pattern);
</pre>
<p class="Pp">Given a pointer to an <span class="Li">&quot;SV&quot;</span> and
    an <span class="Li">&quot;=~&quot;</span> operation (e.g.,
    <span class="Li">&quot;s/bob/robert/g&quot;</span> or
    <span class="Li">&quot;tr[A-Z][a-z]&quot;</span>), <b>substitute()</b>
    modifies the string within the <span class="Li">&quot;SV&quot;</span> as
    according to the operation, returning the number of substitutions made.</p>
<p class="Pp"></p>
<pre>   SSize_t matches(SV *string, char *pattern, AV **matches);
</pre>
<p class="Pp">Given an <span class="Li">&quot;SV&quot;</span>, a pattern, and a
    pointer to an empty <span class="Li">&quot;AV&quot;</span>, <b>matches()</b>
    evaluates <span class="Li">&quot;$string =~ $pattern&quot;</span> in a list
    context, and fills in <i>matches</i> with the array elements, returning the
    number of matches found.</p>
<p class="Pp">Here's a sample program, <i>match.c</i>, that uses all three (long
    lines have been wrapped here):</p>
<p class="Pp"></p>
<pre> #include &lt;EXTERN.h&gt;
 #include &lt;perl.h&gt;
 static PerlInterpreter *my_perl;
 /** my_eval_sv(code, error_check)
 ** kinda like eval_sv(),
 ** but we pop the return value off the stack
 **/
 SV* my_eval_sv(SV *sv, I32 croak_on_error)
 {
     dSP;
     SV* retval;
     PUSHMARK(SP);
     eval_sv(sv, G_SCALAR);
     SPAGAIN;
     retval = POPs;
     PUTBACK;
     if (croak_on_error &amp;&amp; SvTRUE(ERRSV))
        croak_sv(ERRSV);
     return retval;
 }
 /** match(string, pattern)
 **
 ** Used for matches in a scalar context.
 **
 ** Returns 1 if the match was successful; 0 otherwise.
 **/
 I32 match(SV *string, char *pattern)
 {
     SV *command = newSV(0), *retval;
     sv_setpvf(command, &quot;my $string = '%s'; $string =~ %s&quot;,
              SvPV_nolen(string), pattern);
     retval = my_eval_sv(command, TRUE);
     SvREFCNT_dec(command);
     return SvIV(retval);
 }
 /** substitute(string, pattern)
 **
 ** Used for =~ operations that
 ** modify their left-hand side (s/// and tr///)
 **
 ** Returns the number of successful matches, and
 ** modifies the input string if there were any.
 **/
 I32 substitute(SV **string, char *pattern)
 {
     SV *command = newSV(0), *retval;
     sv_setpvf(command, &quot;$string = '%s'; ($string =~ %s)&quot;,
              SvPV_nolen(*string), pattern);
     retval = my_eval_sv(command, TRUE);
     SvREFCNT_dec(command);
     *string = get_sv(&quot;string&quot;, 0);
     return SvIV(retval);
 }
 /** matches(string, pattern, matches)
 **
 ** Used for matches in a list context.
 **
 ** Returns the number of matches,
 ** and fills in **matches with the matching substrings
 **/
 SSize_t matches(SV *string, char *pattern, AV **match_list)
 {
     SV *command = newSV(0);
     SSize_t num_matches;
     sv_setpvf(command, &quot;my $string = '%s'; @array = ($string =~ %s)&quot;,
              SvPV_nolen(string), pattern);
     my_eval_sv(command, TRUE);
     SvREFCNT_dec(command);
     *match_list = get_av(&quot;array&quot;, 0);
     num_matches = av_top_index(*match_list) + 1;
     return num_matches;
 }
 main (int argc, char **argv, char **env)
 {
     char *embedding[] = { &quot;&quot;, &quot;-e&quot;, &quot;0&quot;, NULL };
     AV *match_list;
     I32 num_matches, i;
     SV *text;
     PERL_SYS_INIT3(&amp;argc,&amp;argv,&amp;env);
     my_perl = perl_alloc();
     perl_construct(my_perl);
     perl_parse(my_perl, NULL, 3, embedding, NULL);
     PL_exit_flags |= PERL_EXIT_DESTRUCT_END;
     text = newSV(0);
     sv_setpv(text, &quot;When he is at a convenience store and the &quot;
        &quot;bill comes to some amount like 76 cents, Maynard is &quot;
        &quot;aware that there is something he *should* do, something &quot;
        &quot;that will enable him to get back a quarter, but he has &quot;
        &quot;no idea *what*.  He fumbles through his red squeezey &quot;
        &quot;changepurse and gives the boy three extra pennies with &quot;
        &quot;his dollar, hoping that he might luck into the correct &quot;
        &quot;amount.  The boy gives him back two of his own pennies &quot;
        &quot;and then the big shiny quarter that is his prize. &quot;
        &quot;-RICHH&quot;);
     if (match(text, &quot;m/quarter/&quot;)) /** Does text contain 'quarter'? **/
        printf(&quot;match: Text contains the word 'quarter'.\n\n&quot;);
     else
        printf(&quot;match: Text doesn't contain the word 'quarter'.\n\n&quot;);
     if (match(text, &quot;m/eighth/&quot;)) /** Does text contain 'eighth'? **/
        printf(&quot;match: Text contains the word 'eighth'.\n\n&quot;);
     else
        printf(&quot;match: Text doesn't contain the word 'eighth'.\n\n&quot;);
     /** Match all occurrences of /wi../ **/
     num_matches = matches(text, &quot;m/(wi..)/g&quot;, &amp;match_list);
     printf(&quot;matches: m/(wi..)/g found %d matches...\n&quot;, num_matches);
     for (i = 0; i &lt; num_matches; i++)
         printf(&quot;match: %s\n&quot;,
                  SvPV_nolen(*av_fetch(match_list, i, FALSE)));
     printf(&quot;\n&quot;);
     /** Remove all vowels from text **/
     num_matches = substitute(&amp;text, &quot;s/[aeiou]//gi&quot;);
     if (num_matches) {
        printf(&quot;substitute: s/[aeiou]//gi...%lu substitutions made.\n&quot;,
               (unsigned long)num_matches);
        printf(&quot;Now text is: %s\n\n&quot;, SvPV_nolen(text));
     }
     /** Attempt a substitution **/
     if (!substitute(&amp;text, &quot;s/Perl/C/&quot;)) {
        printf(&quot;substitute: s/Perl/C...No substitution made.\n\n&quot;);
     }
     SvREFCNT_dec(text);
     PL_perl_destruct_level = 1;
     perl_destruct(my_perl);
     perl_free(my_perl);
     PERL_SYS_TERM();
 }
</pre>
<p class="Pp">which produces the output (again, long lines have been wrapped
    here)</p>
<p class="Pp"></p>
<pre>  match: Text contains the word 'quarter'.
  match: Text doesn't contain the word 'eighth'.
  matches: m/(wi..)/g found 2 matches...
  match: will
  match: with
  substitute: s/[aeiou]//gi...139 substitutions made.
  Now text is: Whn h s t  cnvnnc str nd th bll cms t sm mnt lk 76 cnts,
  Mynrd s wr tht thr s smthng h *shld* d, smthng tht wll nbl hm t gt
  bck qrtr, bt h hs n d *wht*.  H fmbls thrgh hs rd sqzy chngprs nd
  gvs th by thr xtr pnns wth hs dllr, hpng tht h mght lck nt th crrct
  mnt.  Th by gvs hm bck tw f hs wn pnns nd thn th bg shny qrtr tht s
  hs prz. -RCHH
  substitute: s/Perl/C...No substitution made.
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Fiddling_with_the_Perl_stack_from_your_C_program"><a class="permalink" href="#Fiddling_with_the_Perl_stack_from_your_C_program">Fiddling
  with the Perl stack from your C program</a></h2>
<p class="Pp">When trying to explain stacks, most computer science textbooks
    mumble something about spring-loaded columns of cafeteria plates: the last
    thing you pushed on the stack is the first thing you pop off. That'll do for
    our purposes: your C program will push some arguments onto &quot;the Perl
    stack&quot;, shut its eyes while some magic happens, and then pop the
    results--the return value of your Perl subroutine--off the stack.</p>
<p class="Pp">First you'll need to know how to convert between C types and Perl
    types, with <b>newSViv()</b> and <b>sv_setnv()</b> and <b>newAV()</b> and
    all their friends. They're described in perlguts and perlapi.</p>
<p class="Pp">Then you'll need to know how to manipulate the Perl stack. That's
    described in perlcall.</p>
<p class="Pp">Once you've understood those, embedding Perl in C is easy.</p>
<p class="Pp">Because C has no builtin function for integer exponentiation,
    let's make Perl's ** operator available to it (this is less useful than it
    sounds, because Perl implements ** with C's
    <i></i><b><i>pow()</i></b><i></i> function). First I'll create a stub
    exponentiation function in <i>power.pl</i>:</p>
<p class="Pp"></p>
<pre>    sub expo {
        my ($a, $b) = @_;
        return $a ** $b;
    }
</pre>
<p class="Pp">Now I'll create a C program, <i>power.c</i>, with a function
    <i></i><b><i>PerlPower()</i></b><i></i> that contains all the perlguts
    necessary to push the two arguments into <i></i><b><i>expo()</i></b><i></i>
    and to pop the return value out. Take a deep breath...</p>
<p class="Pp"></p>
<pre> #include &lt;EXTERN.h&gt;
 #include &lt;perl.h&gt;
 static PerlInterpreter *my_perl;
 static void
 PerlPower(int a, int b)
 {
   dSP;                            /* initialize stack pointer      */
   ENTER;                          /* everything created after here */
   SAVETMPS;                       /* ...is a temporary variable.   */
   PUSHMARK(SP);                   /* remember the stack pointer    */
   XPUSHs(sv_2mortal(newSViv(a))); /* push the base onto the stack  */
   XPUSHs(sv_2mortal(newSViv(b))); /* push the exponent onto stack  */
   PUTBACK;                      /* make local stack pointer global */
   call_pv(&quot;expo&quot;, G_SCALAR);      /* call the function             */
   SPAGAIN;                        /* refresh stack pointer         */
                                 /* pop the return value from stack */
   printf (&quot;%d to the %dth power is %d.\n&quot;, a, b, POPi);
   PUTBACK;
   FREETMPS;                       /* free that return value        */
   LEAVE;                       /* ...and the XPUSHed &quot;mortal&quot; args.*/
 }
 int main (int argc, char **argv, char **env)
 {
   char *my_argv[] = { &quot;&quot;, &quot;power.pl&quot;, NULL };
   PERL_SYS_INIT3(&amp;argc,&amp;argv,&amp;env);
   my_perl = perl_alloc();
   perl_construct( my_perl );
   perl_parse(my_perl, NULL, 2, my_argv, (char **)NULL);
   PL_exit_flags |= PERL_EXIT_DESTRUCT_END;
   perl_run(my_perl);
   PerlPower(3, 4);                      /*** Compute 3 ** 4 ***/
   perl_destruct(my_perl);
   perl_free(my_perl);
   PERL_SYS_TERM();
   exit(EXIT_SUCCESS);
 }
</pre>
<p class="Pp">Compile and run:</p>
<p class="Pp"></p>
<pre>    % cc -o power power.c `perl -MExtUtils::Embed -e ccopts -e ldopts`
    % power
    3 to the 4th power is 81.
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Maintaining_a_persistent_interpreter"><a class="permalink" href="#Maintaining_a_persistent_interpreter">Maintaining
  a persistent interpreter</a></h2>
<p class="Pp">When developing interactive and/or potentially long-running
    applications, it's a good idea to maintain a persistent interpreter rather
    than allocating and constructing a new interpreter multiple times. The major
    reason is speed: since Perl will only be loaded into memory once.</p>
<p class="Pp">However, you have to be more cautious with namespace and variable
    scoping when using a persistent interpreter. In previous examples we've been
    using global variables in the default package
    <span class="Li">&quot;main&quot;</span>. We knew exactly what code would be
    run, and assumed we could avoid variable collisions and outrageous symbol
    table growth.</p>
<p class="Pp">Let's say your application is a server that will occasionally run
    Perl code from some arbitrary file. Your server has no way of knowing what
    code it's going to run. Very dangerous.</p>
<p class="Pp">If the file is pulled in by
    <span class="Li">&quot;perl_parse()&quot;</span>, compiled into a newly
    constructed interpreter, and subsequently cleaned out with
    <span class="Li">&quot;perl_destruct()&quot;</span> afterwards, you're
    shielded from most namespace troubles.</p>
<p class="Pp">One way to avoid namespace collisions in this scenario is to
    translate the filename into a guaranteed-unique package name, and then
    compile the code into that package using &quot;eval&quot; in perlfunc. In
    the example below, each file will only be compiled once. Or, the application
    might choose to clean out the symbol table associated with the file after
    it's no longer needed. Using &quot;call_argv&quot; in perlapi, We'll call
    the subroutine
    <span class="Li">&quot;Embed::Persistent::eval_file&quot;</span> which lives
    in the file <span class="Li">&quot;persistent.pl&quot;</span> and pass the
    filename and boolean cleanup/cache flag as arguments.</p>
<p class="Pp">Note that the process will continue to grow for each file that it
    uses. In addition, there might be
    <span class="Li">&quot;AUTOLOAD&quot;</span>ed subroutines and other
    conditions that cause Perl's symbol table to grow. You might want to add
    some logic that keeps track of the process size, or restarts itself after a
    certain number of requests, to ensure that memory consumption is minimized.
    You'll also want to scope your variables with &quot;my&quot; in perlfunc
    whenever possible.</p>
<p class="Pp"></p>
<pre> package Embed::Persistent;
 #persistent.pl
 use strict;
 our %Cache;
 use Symbol qw(delete_package);
 sub valid_package_name {
     my($string) = @_;
     $string =~ s/([^A-Za-z0-9\/])/sprintf(&quot;_%2x&quot;,unpack(&quot;C&quot;,$1))/eg;
     # second pass only for words starting with a digit
     $string =~ s|/(\d)|sprintf(&quot;/_%2x&quot;,unpack(&quot;C&quot;,$1))|eg;
     # Dress it up as a real package name
     $string =~ s|/|::|g;
     return &quot;Embed&quot; . $string;
 }
 sub eval_file {
     my($filename, $delete) = @_;
     my $package = valid_package_name($filename);
     my $mtime = -M $filename;
     if(defined $Cache{$package}{mtime}
        &amp;&amp;
        $Cache{$package}{mtime} &lt;= $mtime)
     {
        # we have compiled this subroutine already,
        # it has not been updated on disk, nothing left to do
        print STDERR &quot;already compiled $package-&gt;handler\n&quot;;
     }
     else {
        local *FH;
        open FH, $filename or die &quot;open '$filename' $!&quot;;
        local($/) = undef;
        my $sub = &lt;FH&gt;;
        close FH;
        #wrap the code into a subroutine inside our unique package
        my $eval = qq{package $package; sub handler { $sub; }};
        {
            # hide our variables within this block
            my($filename,$mtime,$package,$sub);
            eval $eval;
        }
        die $@ if $@;
        #cache it unless we're cleaning out each time
        $Cache{$package}{mtime} = $mtime unless $delete;
     }
     eval {$package-&gt;handler;};
     die $@ if $@;
     delete_package($package) if $delete;
     #take a look if you want
     #print Devel::Symdump-&gt;rnew($package)-&gt;as_string, $/;
 }
 1;
 __END__
 /* persistent.c */
 #include &lt;EXTERN.h&gt;
 #include &lt;perl.h&gt;
 /* 1 = clean out filename's symbol table after each request,
    0 = don't
 */
 #ifndef DO_CLEAN
 #define DO_CLEAN 0
 #endif
 #define BUFFER_SIZE 1024
 static PerlInterpreter *my_perl = NULL;
 int
 main(int argc, char **argv, char **env)
 {
     char *embedding[] = { &quot;&quot;, &quot;persistent.pl&quot;, NULL };
     char *args[] = { &quot;&quot;, DO_CLEAN, NULL };
     char filename[BUFFER_SIZE];
     int failing, exitstatus;
     PERL_SYS_INIT3(&amp;argc,&amp;argv,&amp;env);
     if((my_perl = perl_alloc()) == NULL) {
        fprintf(stderr, &quot;no memory!&quot;);
        exit(EXIT_FAILURE);
     }
     perl_construct(my_perl);
     PL_origalen = 1; /* don't let $0 assignment update the
                         proctitle or embedding[0] */
     failing = perl_parse(my_perl, NULL, 2, embedding, NULL);
     PL_exit_flags |= PERL_EXIT_DESTRUCT_END;
     if(!failing)
        failing = perl_run(my_perl);
     if(!failing) {
        while(printf(&quot;Enter file name: &quot;) &amp;&amp;
              fgets(filename, BUFFER_SIZE, stdin)) {
            filename[strlen(filename)-1] = '\0'; /* strip \n */
            /* call the subroutine,
                     passing it the filename as an argument */
            args[0] = filename;
            call_argv(&quot;Embed::Persistent::eval_file&quot;,
                           G_DISCARD | G_EVAL, args);
            /* check $@ */
            if(SvTRUE(ERRSV))
                fprintf(stderr, &quot;eval error: %s\n&quot;, SvPV_nolen(ERRSV));
        }
     }
     PL_perl_destruct_level = 0;
     exitstatus = perl_destruct(my_perl);
     perl_free(my_perl);
     PERL_SYS_TERM();
     exit(exitstatus);
 }
</pre>
<p class="Pp">Now compile:</p>
<p class="Pp"></p>
<pre> % cc -o persistent persistent.c \
        `perl -MExtUtils::Embed -e ccopts -e ldopts`
</pre>
<p class="Pp">Here's an example script file:</p>
<p class="Pp"></p>
<pre> #test.pl
 my $string = &quot;hello&quot;;
 foo($string);
 sub foo {
     print &quot;foo says: @_\n&quot;;
 }
</pre>
<p class="Pp">Now run:</p>
<p class="Pp"></p>
<pre> % persistent
 Enter file name: test.pl
 foo says: hello
 Enter file name: test.pl
 already compiled Embed::test_2epl-&gt;handler
 foo says: hello
 Enter file name: ^C
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Execution_of_"><a class="permalink" href="#Execution_of_">Execution
  of END blocks</a></h2>
<p class="Pp">Traditionally END blocks have been executed at the end of the
    perl_run. This causes problems for applications that never call perl_run.
    Since perl 5.7.2 you can specify <span class="Li">&quot;PL_exit_flags |=
    PERL_EXIT_DESTRUCT_END&quot;</span> to get the new behaviour. This also
    enables the running of END blocks if the perl_parse fails and
    <span class="Li">&quot;perl_destruct&quot;</span> will return the exit
    value.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="$0_assignments"><a class="permalink" href="#$0_assignments">$0
  assignments</a></h2>
<p class="Pp">When a perl script assigns a value to <span class="Li">$0</span>
    then the perl runtime will try to make this value show up as the program
    name reported by &quot;ps&quot; by updating the memory pointed to by the
    argv passed to <b>perl_parse()</b> and also calling API functions like
    <b>setproctitle()</b> where available. This behaviour might not be
    appropriate when embedding perl and can be disabled by assigning the value
    <span class="Li">1</span> to the variable
    <span class="Li">&quot;PL_origalen&quot;</span> before <b>perl_parse()</b>
    is called.</p>
<p class="Pp">The <i>persistent.c</i> example above is for instance likely to
    segfault when <span class="Li">$0</span> is assigned to if the
    <span class="Li">&quot;PL_origalen = 1;&quot;</span> assignment is removed.
    This because perl will try to write to the read only memory of the
    <span class="Li">&quot;embedding[]&quot;</span> strings.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Maintaining_multiple_interpreter_instances"><a class="permalink" href="#Maintaining_multiple_interpreter_instances">Maintaining
  multiple interpreter instances</a></h2>
<p class="Pp">Some rare applications will need to create more than one
    interpreter during a session. Such an application might sporadically decide
    to release any resources associated with the interpreter.</p>
<p class="Pp">The program must take care to ensure that this takes place
    <i>before</i> the next interpreter is constructed. By default, when perl is
    not built with any special options, the global variable
    <span class="Li">&quot;PL_perl_destruct_level&quot;</span> is set to
    <span class="Li">0</span>, since extra cleaning isn't usually needed when a
    program only ever creates a single interpreter in its entire lifetime.</p>
<p class="Pp">Setting <span class="Li">&quot;PL_perl_destruct_level&quot;</span>
    to <span class="Li">1</span> makes everything squeaky clean:</p>
<p class="Pp"></p>
<pre> while(1) {
     ...
     /* reset global variables here with PL_perl_destruct_level = 1 */
     PL_perl_destruct_level = 1;
     perl_construct(my_perl);
     ...
     /* clean and reset _everything_ during perl_destruct */
     PL_perl_destruct_level = 1;
     perl_destruct(my_perl);
     perl_free(my_perl);
     ...
     /* let's go do it again! */
 }
</pre>
<p class="Pp">When <i></i><b><i>perl_destruct()</i></b><i></i> is called, the
    interpreter's syntax parse tree and symbol tables are cleaned up, and global
    variables are reset. The second assignment to
    <span class="Li">&quot;PL_perl_destruct_level&quot;</span> is needed because
    perl_construct resets it to <span class="Li">0</span>.</p>
<p class="Pp">Now suppose we have more than one interpreter instance running at
    the same time. This is feasible, but only if you used the Configure option
    <span class="Li">&quot;-Dusemultiplicity&quot;</span> or the options
    <span class="Li">&quot;-Dusethreads -Duseithreads&quot;</span> when building
    perl. By default, enabling one of these Configure options sets the
    per-interpreter global variable
    <span class="Li">&quot;PL_perl_destruct_level&quot;</span> to
    <span class="Li">1</span>, so that thorough cleaning is automatic and
    interpreter variables are initialized correctly. Even if you don't intend to
    run two or more interpreters at the same time, but to run them sequentially,
    like in the above example, it is recommended to build perl with the
    <span class="Li">&quot;-Dusemultiplicity&quot;</span> option otherwise some
    interpreter variables may not be initialized correctly between consecutive
    runs and your application may crash.</p>
<p class="Pp">See also &quot;Thread-aware system interfaces&quot; in perlxs.</p>
<p class="Pp">Using <span class="Li">&quot;-Dusethreads
    -Duseithreads&quot;</span> rather than
    <span class="Li">&quot;-Dusemultiplicity&quot;</span> is more appropriate if
    you intend to run multiple interpreters concurrently in different threads,
    because it enables support for linking in the thread libraries of your
    system with the interpreter.</p>
<p class="Pp">Let's give it a try:</p>
<p class="Pp"></p>
<pre> #include &lt;EXTERN.h&gt;
 #include &lt;perl.h&gt;
 /* we're going to embed two interpreters */
 #define SAY_HELLO &quot;-e&quot;, &quot;print qq(Hi, I'm $^X\n)&quot;
 int main(int argc, char **argv, char **env)
 {
     PerlInterpreter *one_perl, *two_perl;
     char *one_args[] = { &quot;one_perl&quot;, SAY_HELLO, NULL };
     char *two_args[] = { &quot;two_perl&quot;, SAY_HELLO, NULL };
     PERL_SYS_INIT3(&amp;argc,&amp;argv,&amp;env);
     one_perl = perl_alloc();
     two_perl = perl_alloc();
     PERL_SET_CONTEXT(one_perl);
     perl_construct(one_perl);
     PERL_SET_CONTEXT(two_perl);
     perl_construct(two_perl);
     PERL_SET_CONTEXT(one_perl);
     perl_parse(one_perl, NULL, 3, one_args, (char **)NULL);
     PERL_SET_CONTEXT(two_perl);
     perl_parse(two_perl, NULL, 3, two_args, (char **)NULL);
     PERL_SET_CONTEXT(one_perl);
     perl_run(one_perl);
     PERL_SET_CONTEXT(two_perl);
     perl_run(two_perl);
     PERL_SET_CONTEXT(one_perl);
     perl_destruct(one_perl);
     PERL_SET_CONTEXT(two_perl);
     perl_destruct(two_perl);
     PERL_SET_CONTEXT(one_perl);
     perl_free(one_perl);
     PERL_SET_CONTEXT(two_perl);
     perl_free(two_perl);
     PERL_SYS_TERM();
     exit(EXIT_SUCCESS);
 }
</pre>
<p class="Pp">Note the calls to <b>PERL_SET_CONTEXT()</b>. These are necessary
    to initialize the global state that tracks which interpreter is the
    &quot;current&quot; one on the particular process or thread that may be
    running it. It should always be used if you have more than one interpreter
    and are making perl API calls on both interpreters in an interleaved
    fashion.</p>
<p class="Pp">PERL_SET_CONTEXT(interp) should also be called whenever
    <span class="Li">&quot;interp&quot;</span> is used by a thread that did not
    create it (using either <b>perl_alloc()</b>, or the more esoteric
    <b>perl_clone()</b>).</p>
<p class="Pp">Compile as usual:</p>
<p class="Pp"></p>
<pre> % cc -o multiplicity multiplicity.c \
  `perl -MExtUtils::Embed -e ccopts -e ldopts`
</pre>
<p class="Pp">Run it, Run it:</p>
<p class="Pp"></p>
<pre> % multiplicity
 Hi, I'm one_perl
 Hi, I'm two_perl
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Using_Perl_modules,_which_themselves_use_C_libraries,_from_your_C_program"><a class="permalink" href="#Using_Perl_modules,_which_themselves_use_C_libraries,_from_your_C_program">Using
  Perl modules, which themselves use C libraries, from your C program</a></h2>
<p class="Pp">If you've played with the examples above and tried to embed a
    script that <i></i><b><i>use()</i></b><i></i>s a Perl module (such as
    <i>Socket</i>) which itself uses a C or C++ library, this probably
  happened:</p>
<p class="Pp"></p>
<pre> Can't load module Socket, dynamic loading not available in this perl.
  (You may need to build a new perl executable which either supports
  dynamic loading or has the Socket module statically linked into it.)
</pre>
<p class="Pp">What's wrong?</p>
<p class="Pp">Your interpreter doesn't know how to communicate with these
    extensions on its own. A little glue will help. Up until now you've been
    calling <i></i><b><i>perl_parse()</i></b><i></i>, handing it NULL for the
    second argument:</p>
<p class="Pp"></p>
<pre> perl_parse(my_perl, NULL, argc, my_argv, NULL);
</pre>
<p class="Pp">That's where the glue code can be inserted to create the initial
    contact between Perl and linked C/C++ routines. Let's take a look some
    pieces of <i>perlmain.c</i> to see how Perl does this:</p>
<p class="Pp"></p>
<pre> static void xs_init (pTHX);
 EXTERN_C void boot_DynaLoader (pTHX_ CV* cv);
 EXTERN_C void boot_Socket (pTHX_ CV* cv);
 EXTERN_C void
 xs_init(pTHX)
 {
        char *file = __FILE__;
        /* DynaLoader is a special case */
        newXS(&quot;DynaLoader::boot_DynaLoader&quot;, boot_DynaLoader, file);
        newXS(&quot;Socket::bootstrap&quot;, boot_Socket, file);
 }
</pre>
<p class="Pp">Simply put: for each extension linked with your Perl executable
    (determined during its initial configuration on your computer or when adding
    a new extension), a Perl subroutine is created to incorporate the
    extension's routines. Normally, that subroutine is named
    <i></i><b><i>Module::bootstrap()</i></b><i></i> and is invoked when you say
    <i>use Module</i>. In turn, this hooks into an XSUB, <i>boot_Module</i>,
    which creates a Perl counterpart for each of the extension's XSUBs. Don't
    worry about this part; leave that to the <i>xsubpp</i> and extension
    authors. If your extension is dynamically loaded, DynaLoader creates
    <i></i><b><i>Module::bootstrap()</i></b><i></i> for you on the fly. In fact,
    if you have a working DynaLoader then there is rarely any need to link in
    any other extensions statically.</p>
<p class="Pp">Once you have this code, slap it into the second argument of
    <i></i><b><i>perl_parse()</i></b><i></i>:</p>
<p class="Pp"></p>
<pre> perl_parse(my_perl, xs_init, argc, my_argv, NULL);
</pre>
<p class="Pp">Then compile:</p>
<p class="Pp"></p>
<pre> % cc -o interp interp.c `perl -MExtUtils::Embed -e ccopts -e ldopts`
 % interp
   use Socket;
   use SomeDynamicallyLoadedModule;
   print &quot;Now I can use extensions!\n&quot;'
</pre>
<p class="Pp"><b>ExtUtils::Embed</b> can also automate writing the
    <i>xs_init</i> glue code.</p>
<p class="Pp"></p>
<pre> % perl -MExtUtils::Embed -e xsinit -- -o perlxsi.c
 % cc -c perlxsi.c `perl -MExtUtils::Embed -e ccopts`
 % cc -c interp.c  `perl -MExtUtils::Embed -e ccopts`
 % cc -o interp perlxsi.o interp.o `perl -MExtUtils::Embed -e ldopts`
</pre>
<p class="Pp">Consult perlxs, perlguts, and perlapi for more details.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Using_embedded_Perl_with_"><a class="permalink" href="#Using_embedded_Perl_with_">Using
  embedded Perl with POSIX locales</a></h2>
<p class="Pp">(See perllocale for information about these.) When a Perl
    interpreter normally starts up, it tells the system it wants to use the
    system's default locale. This is often, but not necessarily, the
    &quot;C&quot; or &quot;POSIX&quot; locale. Absent a
    <span class="Li">&quot;use&#x00A0;locale&quot;</span> within the perl code,
    this mostly has no effect (but see &quot;Not within the scope of &quot;use
    locale&quot;&quot; in perllocale). Also, there is not a problem if the
    locale you want to use in your embedded perl is the same as the system
    default. However, this doesn't work if you have set up and want to use a
    locale that isn't the system default one. Starting in Perl v5.20, you can
    tell the embedded Perl interpreter that the locale is already properly set
    up, and to skip doing its own normal initialization. It skips if the
    environment variable
    <span class="Li">&quot;PERL_SKIP_LOCALE_INIT&quot;</span> is set (even if
    set to 0 or <span class="Li">&quot;&quot;</span>). A perl that has this
    capability will define the C pre-processor symbol
    <span class="Li">&quot;HAS_SKIP_LOCALE_INIT&quot;</span>. This allows code
    that has to work with multiple Perl versions to do some sort of work-around
    when confronted with an earlier Perl.</p>
<p class="Pp">If your program is using the POSIX 2008 multi-thread locale
    functionality, you should switch into the global locale and set that up
    properly before starting the Perl interpreter. It will then properly switch
    back to using the thread-safe functions.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="Hiding_Perl_"><a class="permalink" href="#Hiding_Perl_">Hiding
  Perl_</a></h1>
<p class="Pp">If you completely hide the short forms of the Perl public API, add
    -DPERL_NO_SHORT_NAMES to the compilation flags. This means that for example
    instead of writing</p>
<p class="Pp"></p>
<pre>    warn(&quot;%d bottles of beer on the wall&quot;, bottlecount);
</pre>
<p class="Pp">you will have to write the explicit full form</p>
<p class="Pp"></p>
<pre>    Perl_warn(aTHX_ &quot;%d bottles of beer on the wall&quot;, bottlecount);
</pre>
<p class="Pp">(See &quot;Background and PERL_IMPLICIT_CONTEXT&quot; in perlguts
    for the explanation of the <span class="Li">&quot;aTHX_&quot;</span>. )
    Hiding the short forms is very useful for avoiding all sorts of nasty (C
    preprocessor or otherwise) conflicts with other software packages (Perl
    defines about 2400 APIs with these short names, take or leave few hundred,
    so there certainly is room for conflict.)</p>
</section>
<section class="Sh">
<h1 class="Sh" id="MORAL"><a class="permalink" href="#MORAL">MORAL</a></h1>
<p class="Pp">You can sometimes <i>write faster code</i> in C, but you can
    always <i>write code faster</i> in Perl. Because you can use each from the
    other, combine them as you wish.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">Jon Orwant &lt;<i>orwant@media.mit.edu</i>&gt; and Doug MacEachern
    &lt;<i>dougm@covalent.net</i>&gt;, with small contributions from Tim Bunce,
    Tom Christiansen, Guy Decoux, Hallvard Furuseth, Dov Grobgeld, and Ilya
    Zakharevich.</p>
<p class="Pp">Doug MacEachern has an article on embedding in Volume 1, Issue 4
    of The Perl Journal ( &lt;http://www.tpj.com/&gt; ). Doug is also the
    developer of the most widely-used Perl embedding: the mod_perl system
    (perl.apache.org), which embeds Perl in the Apache web server. Oracle,
    Binary Evolution, ActiveState, and Ben Sugars's nsapi_perl have used this
    model for Oracle, Netscape and Internet Information Server Perl plugins.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT"><a class="permalink" href="#COPYRIGHT">COPYRIGHT</a></h1>
<p class="Pp">Copyright (C) 1995, 1996, 1997, 1998 Doug MacEachern and Jon
    Orwant. All Rights Reserved.</p>
<p class="Pp">This document may be distributed under the same terms as Perl
    itself.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2019-10-21</td>
    <td class="foot-os">perl v5.30.3</td>
  </tr>
</table>
</body>
</html>
