<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>Net::DNS::Nameserver(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Net::DNS::Nameserver(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Net::DNS::Nameserver(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
Net::DNS::Nameserver - DNS server class
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<span class="Li"></span>
<pre>
    use Net::DNS::Nameserver;

    $nameserver = new Net::DNS::Nameserver(
        LocalAddr        =&gt; ['::1' , '127.0.0.1' ],
        LocalPort        =&gt; &quot;5353&quot;,
        ReplyHandler =&gt; \&amp;reply_handler,
        Verbose          =&gt; 1,
        Truncate         =&gt; 0
    );
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
Instances of the <span class="Li">&quot;Net::DNS::Nameserver&quot;</span> class
  represent DNS server objects. See &quot;EXAMPLE&quot; for an example.
</section>
<section class="Sh">
<h1 class="Sh" id="METHODS"><a class="permalink" href="#METHODS">METHODS</a></h1>
<section class="Ss">
<h2 class="Ss" id="new"><a class="permalink" href="#new">new</a></h2>
<span class="Li"></span>
<pre>
    my $ns = new Net::DNS::Nameserver(
        LocalAddr       =&gt; &quot;10.1.2.3&quot;,
        LocalPort       =&gt; &quot;5353&quot;,
        ReplyHandler    =&gt; \&amp;reply_handler,
        Verbose         =&gt; 1
        );



    my $ns = new Net::DNS::Nameserver(
        LocalAddr       =&gt; ['::1' , '127.0.0.1' ],
        LocalPort       =&gt; &quot;5353&quot;,
        ReplyHandler    =&gt; \&amp;reply_handler,
        Verbose         =&gt; 1,
        Truncate        =&gt; 0
        );
</pre>
<p class="Pp">Returns a Net::DNS::Nameserver object, or undef if the object
    could not be created.</p>
<p class="Pp">Attributes are:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    LocalAddr           IP address on which to listen.  Defaults to INADDR_ANY.
    LocalPort           Port on which to listen.        Defaults to 53.
    ReplyHandler        Reference to reply-handling
                        subroutine                      Required.
    NotifyHandler       Reference to reply-handling
                        subroutine for queries with
                        opcode NOTIFY (RFC1996)
    Verbose             Print info about received
                        queries.                        Defaults to 0 (off).
    Truncate            Truncates UDP packets that
                        are too big for the reply       Defaults to 1 (on)
    IdleTimeout         TCP clients are disconnected
                        if they are idle longer than
                        this duration.                  Defaults to 120 (secs)
</pre>
<p class="Pp">The LocalAddr attribute may alternatively be specified as a list
    of IP addresses to listen to.</p>
<p class="Pp">If IO::Socket::INET6 and Socket6 are available on the system you
    can also list IPv6 addresses and the default is '0' (listen on all
    interfaces on IPv6 and IPv4);</p>
<p class="Pp">The ReplyHandler subroutine is passed the query name, query class,
    query type and optionally an argument containing the peerhost, the incoming
    query, and the name of the incoming socket (sockethost). It must either
    return the response code and references to the answer, authority, and
    additional sections of the response, or undef to leave the query unanswered.
    Common response codes are:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    NOERROR     No error
    FORMERR     Format error
    SERVFAIL    Server failure
    NXDOMAIN    Non-existent domain (name doesn't exist)
    NOTIMP      Not implemented
    REFUSED     Query refused
</pre>
<p class="Pp">For advanced usage it may also contain a headermask containing an
    hashref with the settings for the <span class="Li">&quot;aa&quot;</span>,
    <span class="Li">&quot;ra&quot;</span>, and
    <span class="Li">&quot;ad&quot;</span> header bits. The argument is of the
    form <span class="Li">&quot;{ ad =&gt; 1, aa =&gt; 0, ra =&gt; 1
    }&quot;</span>.</p>
<p class="Pp">See RFC 1035 and the IANA dns-parameters file for more
    information:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  ftp://ftp.rfc-editor.org/in-notes/rfc1035.txt
  http://www.isi.edu/in-notes/iana/assignments/dns-parameters
</pre>
<p class="Pp">The nameserver will listen for both UDP and TCP connections. On
    Unix-like systems, the program will probably have to run as root to listen
    on the default port, 53.	A non-privileged user should be able to listen on
    ports 1024 and higher.</p>
<p class="Pp">Packet Truncation is new functionality available in VERSION &gt;
    830. Only UDP replies are truncated. The size limit is determined by the
    advertised EDNS0 size in the query, otherwise 512 is used.</p>
<p class="Pp">If you want to do packet truncation yourself you should set
    Truncate to 0 and truncate the reply packet in the code of the
  ReplyHandler.</p>
<p class="Pp">See &quot;EXAMPLE&quot; for an example.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="main_loop"><a class="permalink" href="#main_loop">main_loop</a></h2>
<span class="Li"></span>
<pre>
    $ns-&gt;main_loop;
</pre>
<p class="Pp">Start accepting queries. Calling main_loop never returns.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="loop_once"><a class="permalink" href="#loop_once">loop_once</a></h2>
<span class="Li"></span>
<pre>
    $ns-&gt;loop_once( [TIMEOUT_IN_SECONDS] );
</pre>
<p class="Pp">Start accepting queries, but returns. If called without a
    parameter, the call will not return until a request has been received (and
    replied to). If called with a number, that number specifies how many seconds
    (even fractional) to maximum wait before returning. If called with 0 it will
    return immediately unless there's something to do.</p>
<p class="Pp">Handling a request and replying obviously depends on the speed of
    ReplyHandler. Assuming ReplyHandler is super fast, loop_once should spend
    just a fraction of a second, if called with a timeout value of 0 seconds.
    One exception is when an AXFR has requested a huge amount of data that the
    OS is not ready to receive in full. In that case, it will keep running
    through a loop (while servicing new requests) until the reply has been
  sent.</p>
<p class="Pp">In case loop_once accepted a TCP connection it will immediatly
    check if there is data to be read from the socket. If not it will return and
    you will have to call <i>loop_once()</i> again to check if there is any data
    waiting on the socket to be processed. In most cases you will have to count
    on calling &quot;loop_once&quot; twice.</p>
<p class="Pp">A code fragment like:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    $ns-&gt;loop_once(10);
    while( $ns-&gt;get_open_tcp() ){
        $ns-&gt;loop_once(0);
    }
</pre>
<p class="Pp">Would wait for 10 seconds for the initial connection and would
    then process all TCP sockets until none is left.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="get_open_tcp"><a class="permalink" href="#get_open_tcp">get_open_tcp</a></h2>
In scalar context returns the number of TCP connections for which state is
  maintained. In array context it returns IO::Socket objects, these could be
  useful for troubleshooting but be careful using them.
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="EXAMPLE"><a class="permalink" href="#EXAMPLE">EXAMPLE</a></h1>
The following example will listen on port 5353 and respond to all queries for A
  records with the IP address 10.1.2.3.	 All other queries will be answered with
  NXDOMAIN.	 Authority and additional sections are left empty. The
  <span class="Li">$peerhost</span> variable catches the IP address of the peer
  host, so that additional filtering on its basis may be applied.
<p class="Pp"><span class="Li"></span></p>
<pre>
    #!/usr/bin/perl

    use strict;
    use warnings;
    use Net::DNS::Nameserver;

    sub reply_handler {
        my ($qname, $qclass, $qtype, $peerhost,$query,$conn) = @_;
        my ($rcode, @ans, @auth, @add);

        print &quot;Received query from $peerhost to &quot;. $conn-&gt;{sockhost}. &quot;\n&quot;;
        $query-&gt;print;

        if ($qtype eq &quot;A&quot; &amp;&amp; $qname eq &quot;foo.example.com&quot; ) {
                my ($ttl, $rdata) = (3600, &quot;10.1.2.3&quot;);
                my $rr = new Net::DNS::RR(&quot;$qname $ttl $qclass $qtype $rdata&quot;);
                push @ans, $rr;
                $rcode = &quot;NOERROR&quot;;
        }elsif( $qname eq &quot;foo.example.com&quot; ) {
                $rcode = &quot;NOERROR&quot;;

        }else{
                $rcode = &quot;NXDOMAIN&quot;;
        }

        # mark the answer as authoritive (by setting the 'aa' flag
        return ($rcode, \@ans, \@auth, \@add, { aa =&gt; 1 });
    }

    my $ns = new Net::DNS::Nameserver(
        LocalPort    =&gt; 5353,
        ReplyHandler =&gt; \&amp;reply_handler,
        Verbose      =&gt; 1
        ) || die &quot;couldn't create nameserver object\n&quot;;

    $ns-&gt;main_loop;
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="BUGS"><a class="permalink" href="#BUGS">BUGS</a></h1>
Limitations in perl 5.8.6 makes it impossible to guarantee that replies to UDP
  queries from Net::DNS::Nameserver are sent from the IP-address they were
  received on. This is a problem for machines with multiple IP-addresses and
  causes violation of RFC2181 section 4. Thus a UDP socket created listening to
  INADDR_ANY (all available IP-addresses) will reply not necessarily with the
  source address being the one to which the request was sent, but rather with
  the address that the operating system chooses. This is also often called
  &quot;the closest address&quot;. This should really only be a problem on a
  server which has more than one IP-address (besides localhost - any experience
  with IPv6 complications here, would be nice). If this is a problem for you, a
  work-around would be to not listen to INADDR_ANY but to specify each address
  that you want this module to listen on. A separate set of sockets will then be
  created for each IP-address.
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT"><a class="permalink" href="#COPYRIGHT">COPYRIGHT</a></h1>
Copyright (c)1997-2002 Michael Fuhr.
<p class="Pp">Portions Copyright (c)2002-2004 Chris Reinhardt.</p>
<p class="Pp">Portions Copyright (c)2005-2009 O.M, Kolkman, RIPE NCC.</p>
<p class="Pp">Portions Copyright (c)2005 Robert Martin-Legene.</p>
<p class="Pp">All rights reserved.</p>
<p class="Pp">This program is free software; you may redistribute it and/or
    modify it under the same terms as Perl itself.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
perl, Net::DNS, Net::DNS::Resolver, Net::DNS::Packet, Net::DNS::Update,
  Net::DNS::Header, Net::DNS::Question, Net::DNS::RR, RFC 1035
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2014-01-16</td>
    <td class="foot-os">perl v5.18.4</td>
  </tr>
</table>
</body>
</html>
