<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>Import::Into(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Import::Into(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Import::Into(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
Import::Into - import packages into other packages
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<span class="Li"></span>
<pre>
  package My::MultiExporter;

  use Import::Into;

  use Thing1 ();
  use Thing2 ();

  # simple
  sub import {
    Thing1-&gt;import::into(scalar caller);
  }

  # multiple
  sub import {
    my $target = caller;
    Thing1-&gt;import::into($target);
    Thing2-&gt;import::into($target, qw(import arguments));
  }

  # by level
  sub import {
    Thing1-&gt;import::into(1);
  }

  # with exporter
  use base qw(Exporter);
  sub import {
    shift-&gt;export_to_level(1);
    Thing1-&gt;import::into(1);
  }

  # no My::MultiExporter == no Thing1
  sub unimport {
    Thing1-&gt;unimport::out_of(scalar caller);
  }
</pre>
<p class="Pp">People wanting to re-export your module should also be using
    Import::Into. Any exporter or pragma will work seamlessly.</p>
<p class="Pp">Note: You do <b>not</b> need to make any changes to Thing1 to be
    able to call <span class="Li">&quot;import::into&quot;</span> on it. This is
    a global method, and is callable on any package (and in fact on any object
    as well, although it's rarer that you'd want to do that).</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
Writing exporters is a pain. Some use Exporter, some use Sub::Exporter, some use
  Moose::Exporter, some use Exporter::Declare ... and some things are pragmas.
<p class="Pp">Exporting on someone else's behalf is harder. The exporters don't
    provide a consistent API for this, and pragmas need to have their import
    method called directly, since they effect the current unit of
  compilation.</p>
<p class="Pp"><span class="Li">&quot;Import::Into&quot;</span> provides global
    methods to make this painless.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="METHODS"><a class="permalink" href="#METHODS">METHODS</a></h1>
<section class="Ss">
<h2 class="Ss" id="$package_-_import::into(_$target,_@arguments_);"><a class="permalink" href="#$package_-_import::into(_$target,_@arguments_);">$package-&gt;import::into(
  $target, @arguments );</a></h2>
A global method, callable on any package. Imports the given package into
  <span class="Li">$target</span>. <span class="Li">@arguments</span> are passed
  along to the package's import method.
<p class="Pp"><span class="Li">$target</span> can be an package name to export
    to, an integer for the caller level to export to, or a hashref with the
    following options:</p>
<dl class="Bl-tag">
  <dt>package</dt>
  <dd>The target package to export to.</dd>
  <dt>filename</dt>
  <dd>The apparent filename to export to. Some exporting modules, such as
      autodie or strictures, care about the filename they are being imported
    to.</dd>
  <dt>line</dt>
  <dd>The apparent line number to export to. To be combined with the
      <span class="Li">&quot;filename&quot;</span> option.</dd>
  <dt>level</dt>
  <dd>The caller level to export to. This will automatically populate the
      <span class="Li">&quot;package&quot;</span>,
      <span class="Li">&quot;filename&quot;</span>, and
      <span class="Li">&quot;line&quot;</span> options, making it the easiest
      most constent option.</dd>
  <dt>version</dt>
  <dd>A version number to check for the module. The equivalent of specifying the
      version number on a <span class="Li">&quot;use&quot;</span> line.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="$package_-_unimport::out_of(_$target,_@arguments_);"><a class="permalink" href="#$package_-_unimport::out_of(_$target,_@arguments_);">$package-&gt;unimport::out_of(
  $target, @arguments );</a></h2>
Equivalent to <span class="Li">&quot;import::into&quot;</span>, but dispatches
  to <span class="Li">$package</span>'s
  <span class="Li">&quot;unimport&quot;</span> method instead of
  <span class="Li">&quot;import&quot;</span>.
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="WHY_USE_THIS_MODULE"><a class="permalink" href="#WHY_USE_THIS_MODULE">WHY
  USE THIS MODULE</a></h1>
The APIs for exporting modules aren't consistent. Exporter subclasses provide
  export_to_level, but if they overrode their import method all bets are off.
  Sub::Exporter provides an into parameter but figuring out something used it
  isn't trivial. Pragmas need to have their
  <span class="Li">&quot;import&quot;</span> method called directly since they
  affect the current unit of compilation.
<p class="Pp">It's ... annoying.</p>
<p class="Pp">However, there is an approach that actually works for all of these
    types.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  eval &quot;package $target; use $thing;&quot;
</pre>
<p class="Pp">will work for anything checking caller, which is everything except
    pragmas. But it doesn't work for pragmas - pragmas need:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  $thing-&gt;import;
</pre>
<p class="Pp">because they're designed to affect the code currently being
    compiled - so within an eval, that's the scope of the eval itself, not the
    module that just <span class="Li">&quot;use&quot;</span>d you - so</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  sub import {
    eval &quot;use strict;&quot;
  }
</pre>
<p class="Pp">doesn't do what you wanted, but</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  sub import {
    strict-&gt;import;
  }
</pre>
<p class="Pp">will apply strict to the calling file correctly.</p>
<p class="Pp">Of course, now you have two new problems - first, that you still
    need to know if something's a pragma, and second that you can't use either
    of these approaches alone on something like Moose or Moo that's both an
    exporter and a pragma.</p>
<p class="Pp">So, a solution for that is:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  my $sub = eval &quot;package $target; sub { shift-&gt;import(\@_) }&quot;;
  $sub-&gt;($thing, @import_args);
</pre>
<p class="Pp">which means that import is called from the right place for pragmas
    to take effect, and from the right package for caller checking to work - and
    so behaves correctly for all types of exporter, for pragmas, and for
    hybrids.</p>
<p class="Pp">Additionally, some import routines check the filename they are
    being imported to. This can be dealt with by generating a #line directive in
    the eval, which will change what <span class="Li">&quot;caller&quot;</span>
    reports for the filename when called in the importer. The filename and line
    number to use in the directive then need to be fetched using
    <span class="Li">&quot;caller&quot;</span>:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  my ($target, $file, $line) = caller(1);
  my $sub = eval qq{
    package $target;
  #line $line &quot;$file&quot;
    sub { shift-&gt;import(\@_) }
  };
  $sub-&gt;($thing, @import_args);
</pre>
<p class="Pp">And you need to switch between these implementations depending on
    if you are targetting a specific package, or something in your call
  stack.</p>
<p class="Pp">Remembering all this, however, is excessively irritating. So I
    wrote a module so I didn't have to anymore. Loading Import::Into creates a
    global method <span class="Li">&quot;import::into&quot;</span> which you can
    call on any package to import it into another package. So now you can simply
    write:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  use Import::Into;

  $thing-&gt;import::into($target, @import_args);
</pre>
<p class="Pp">This works because of how perl resolves method calls - a call to a
    simple method name is resolved against the package of the class or object,
    so</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  $thing-&gt;method_name(@args);
</pre>
<p class="Pp">is roughly equivalent to:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  my $code_ref = $thing-&gt;can('method_name');
  $code_ref-&gt;($thing, @args);
</pre>
<p class="Pp">while if a <span class="Li">&quot;::&quot;</span> is found, the
    lookup is made relative to the package name (i.e. everything before the last
    <span class="Li">&quot;::&quot;</span>) so</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  $thing-&gt;Package::Name::method_name(@args);
</pre>
<p class="Pp">is roughly equivalent to:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  my $code_ref = Package::Name-&gt;can('method_name');
  $code_ref-&gt;($thing, @args);
</pre>
<p class="Pp">So since Import::Into defines a method
    <span class="Li">&quot;into&quot;</span> in package
    <span class="Li">&quot;import&quot;</span> the syntax reliably calls
  that.</p>
<p class="Pp">For more craziness of this order, have a look at the article I
    wrote at &lt;http://shadow.cat/blog/matt-s-trout/madness-with-methods&gt;
    which covers coderef abuse and the
    <span class="Li">&quot;${\...}&quot;</span> syntax.</p>
<p class="Pp">Final note: You do still need to ensure that you already loaded
    <span class="Li">$thing</span> - if you're receiving this from a parameter,
    I recommend using Module::Runtime:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  use Import::Into;
  use Module::Runtime qw(use_module);

  use_module($thing)-&gt;import::into($target, @import_args);
</pre>
<p class="Pp">And that's it.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="ACKNOWLEDGEMENTS"><a class="permalink" href="#ACKNOWLEDGEMENTS">ACKNOWLEDGEMENTS</a></h1>
Thanks to Getty for asking &quot;how can I get <span class="Li">&quot;use
  strict; use warnings;&quot;</span> turned on for all consumers of my
  code?&quot; and then &quot;why is this not a module?!&quot;.
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
mst - Matt S. Trout (cpan:MSTROUT) &lt;mst@shadowcat.co.uk&gt;
</section>
<section class="Sh">
<h1 class="Sh" id="CONTRIBUTORS"><a class="permalink" href="#CONTRIBUTORS">CONTRIBUTORS</a></h1>
haarg - Graham Knop (cpan:HAARG) &lt;haarg@haarg.org&gt;
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT"><a class="permalink" href="#COPYRIGHT">COPYRIGHT</a></h1>
Copyright (c) 2012 the Import::Into &quot;AUTHOR&quot; and
  &quot;CONTRIBUTORS&quot; as listed above.
</section>
<section class="Sh">
<h1 class="Sh" id="LICENSE"><a class="permalink" href="#LICENSE">LICENSE</a></h1>
This library is free software and may be distributed under the same terms as
  perl itself.
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2013-12-10</td>
    <td class="foot-os">perl v5.18.4</td>
  </tr>
</table>
</body>
</html>
