<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>Params::Validate(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Params::Validate(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Params::Validate(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
Params::Validate - Validate method/function parameters
</section>
<section class="Sh">
<h1 class="Sh" id="VERSION"><a class="permalink" href="#VERSION">VERSION</a></h1>
version 1.08
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<span class="Li"></span>
<pre>
    use Params::Validate qw(:all);

    # takes named params (hash or hashref)
    sub foo {
        validate(
            @_, {
                foo =&gt; 1,    # mandatory
                bar =&gt; 0,    # optional
            }
        );
    }

    # takes positional params
    sub bar {
        # first two are mandatory, third is optional
        validate_pos( @_, 1, 1, 0 );
    }

    sub foo2 {
        validate(
            @_, {
                foo =&gt;
                    # specify a type
                    { type =&gt; ARRAYREF },
                bar =&gt;
                    # specify an interface
                    { can =&gt; [ 'print', 'flush', 'frobnicate' ] },
                baz =&gt; {
                    type      =&gt; SCALAR,     # a scalar ...
                                             # ... that is a plain integer ...
                    regex     =&gt; qr/^\d+$/,
                    callbacks =&gt; {           # ... and smaller than 90
                        'less than 90' =&gt; sub { shift() &lt; 90 },
                    },
                }
            }
        );
    }

    sub with_defaults {
        my %p = validate(
            @_, {
                # required
                foo =&gt; 1,
                # $p{bar} will be 99 if bar is not given.  bar is now
                # optional.
                bar =&gt; { default =&gt; 99 }
            }
        );
    }

    sub pos_with_defaults {
        my @p = validate_pos( @_, 1, { default =&gt; 99 } );
    }

    sub sets_options_on_call {
        my %p = validate_with(
            params =&gt; \@_,
            spec   =&gt; { foo =&gt; { type =&gt; SCALAR, default =&gt; 2 } },
            normalize_keys =&gt; sub { $_[0] =~ s/^-//; lc $_[0] },
        );
    }
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
The Params::Validate module allows you to validate method or function call
  parameters to an arbitrary level of specificity. At the simplest level, it is
  capable of validating the required parameters were given and that no
  unspecified additional parameters were passed in.
<p class="Pp">It is also capable of determining that a parameter is of a
    specific type, that it is an object of a certain class hierarchy, that it
    possesses certain methods, or applying validation callbacks to
  arguments.</p>
<section class="Ss">
<h2 class="Ss" id="_s-1EXPORT_s0"><a class="permalink" href="#_s-1EXPORT_s0">EXPORT</a></h2>
The module always exports the <span class="Li">&quot;validate()&quot;</span> and
  <span class="Li">&quot;validate_pos()&quot;</span> functions.
<p class="Pp">It also has an additional function available for export,
    <span class="Li">&quot;validate_with&quot;</span>, which can be used to
    validate any type of parameters, and set various options on a per-invocation
    basis.</p>
<p class="Pp">In addition, it can export the following constants, which are used
    as part of the type checking. These are
    <span class="Li">&quot;SCALAR&quot;</span>,
    <span class="Li">&quot;ARRAYREF&quot;</span>,
    <span class="Li">&quot;HASHREF&quot;</span>,
    <span class="Li">&quot;CODEREF&quot;</span>,
    <span class="Li">&quot;GLOB&quot;</span>,
    <span class="Li">&quot;GLOBREF&quot;</span>, and
    <span class="Li">&quot;SCALARREF&quot;</span>,
    <span class="Li">&quot;UNDEF&quot;</span>,
    <span class="Li">&quot;OBJECT&quot;</span>,
    <span class="Li">&quot;BOOLEAN&quot;</span>, and
    <span class="Li">&quot;HANDLE&quot;</span>. These are explained in the
    section on Type Validation.</p>
<p class="Pp">The constants are available via the export tag
    <span class="Li">&quot;:types&quot;</span>. There is also an
    <span class="Li">&quot;:all&quot;</span> tag which includes all of the
    constants as well as the
    <span class="Li">&quot;validation_options()&quot;</span> function.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="PARAMETER_VALIDATION"><a class="permalink" href="#PARAMETER_VALIDATION">PARAMETER
  VALIDATION</a></h1>
The validation mechanisms provided by this module can handle both named or
  positional parameters. For the most part, the same features are available for
  each. The biggest difference is the way that the validation specification is
  given to the relevant subroutine. The other difference is in the error
  messages produced when validation checks fail.
<p class="Pp">When handling named parameters, the module will accept either a
    hash or a hash reference.</p>
<p class="Pp">Subroutines expecting named parameters should call the
    <span class="Li">&quot;validate()&quot;</span> subroutine like this:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    validate(
        @_, {
            parameter1 =&gt; validation spec,
            parameter2 =&gt; validation spec,
            ...
        }
    );
</pre>
<p class="Pp">Subroutines expecting positional parameters should call the
    <span class="Li">&quot;validate_pos()&quot;</span> subroutine like this:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    validate_pos( @_, { validation spec }, { validation spec } );
</pre>
<section class="Ss">
<h2 class="Ss" id="Mandatory/Optional_Parameters"><a class="permalink" href="#Mandatory/Optional_Parameters">Mandatory/Optional
  Parameters</a></h2>
If you just want to specify that some parameters are mandatory and others are
  optional, this can be done very simply.
<p class="Pp">For a subroutine expecting named parameters, you would do
  this:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    validate( @_, { foo =&gt; 1, bar =&gt; 1, baz =&gt; 0 } );
</pre>
<p class="Pp">This says that the &quot;foo&quot; and &quot;bar&quot; parameters
    are mandatory and that the &quot;baz&quot; parameter is optional. The
    presence of any other parameters will cause an error.</p>
<p class="Pp">For a subroutine expecting positional parameters, you would do
    this:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    validate_pos( @_, 1, 1, 0, 0 );
</pre>
<p class="Pp">This says that you expect at least 2 and no more than 4
    parameters. If you have a subroutine that has a minimum number of parameters
    but can take any maximum number, you can do this:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    validate_pos( @_, 1, 1, (0) x (@_ - 2) );
</pre>
<p class="Pp">This will always be valid as long as at least two parameters are
    given. A similar construct could be used for the more complex validation
    parameters described further on.</p>
<p class="Pp">Please note that this:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    validate_pos( @_, 1, 1, 0, 1, 1 );
</pre>
<p class="Pp">makes absolutely no sense, so don't do it. Any zeros must come at
    the end of the validation specification.</p>
<p class="Pp">In addition, if you specify that a parameter can have a default,
    then it is considered optional.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Type_Validation"><a class="permalink" href="#Type_Validation">Type
  Validation</a></h2>
This module supports the following simple types, which can be exported as
  constants:
<ul class="Bl-bullet">
  <li>SCALAR
    <p class="Pp">A scalar which is not a reference, such as
        <span class="Li">10</span> or <span class="Li">'hello'</span>. A
        parameter that is undefined is <b>not</b> treated as a scalar. If you
        want to allow undefined values, you will have to specify
        <span class="Li">&quot;SCALAR |</span>
        <span class="Li">UNDEF&quot;</span>.</p>
  </li>
  <li>ARRAYREF
    <p class="Pp">An array reference such as <span class="Li">&quot;[1, 2,
        3]&quot;</span> or <span class="Li">&quot;\@foo&quot;</span>.</p>
  </li>
  <li>HASHREF
    <p class="Pp">A hash reference such as <span class="Li">&quot;{ a =&gt; 1, b
        =&gt; 2 }&quot;</span> or <span class="Li">&quot;\%bar&quot;</span>.</p>
  </li>
  <li>CODEREF
    <p class="Pp">A subroutine reference such as
        <span class="Li">&quot;\&amp;foo_sub&quot;</span> or
        <span class="Li">&quot;sub { print &quot;hello&quot; }&quot;</span>.</p>
  </li>
  <li>GLOB
    <p class="Pp">This one is a bit tricky. A glob would be something like
        <span class="Li">*FOO</span>, but not
        <span class="Li">&quot;\*FOO&quot;</span>, which is a glob reference. It
        should be noted that this trick:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    my $fh = do { local *FH; };
    </pre>
    <p class="Pp">makes <span class="Li">$fh</span> a glob, not a glob
        reference. On the other hand, the return value from
        <span class="Li">&quot;Symbol::gensym&quot;</span> is a glob reference.
        Either can be used as a file or directory handle.</p>
  </li>
  <li>GLOBREF
    <p class="Pp">A glob reference such as
        <span class="Li">&quot;\*FOO&quot;</span>. See the GLOB entry above for
        more details.</p>
  </li>
  <li>SCALARREF
    <p class="Pp">A reference to a scalar such as
        <span class="Li">&quot;\$x&quot;</span>.</p>
  </li>
  <li>UNDEF
    <p class="Pp">An undefined value</p>
  </li>
  <li>OBJECT
    <p class="Pp">A blessed reference.</p>
  </li>
  <li>BOOLEAN
    <p class="Pp">This is a special option, and is just a shortcut for
        <span class="Li">&quot;UNDEF | SCALAR&quot;</span>.</p>
  </li>
  <li>HANDLE
    <p class="Pp">This option is also special, and is just a shortcut for
        <span class="Li">&quot;GLOB |</span>
        <span class="Li">GLOBREF&quot;</span>. However, it seems likely that
        most people interested in either globs or glob references are likely to
        really be interested in whether the parameter in question could be a
        valid file or directory handle.</p>
  </li>
</ul>
<p class="Pp">To specify that a parameter must be of a given type when using
    named parameters, do this:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    validate(
        @_, {
            foo =&gt; { type =&gt; SCALAR },
            bar =&gt; { type =&gt; HASHREF }
        }
    );
</pre>
<p class="Pp">If a parameter can be of more than one type, just use the bitwise
    or (<span class="Li">&quot;|&quot;</span>) operator to combine them.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    validate( @_, { foo =&gt; { type =&gt; GLOB | GLOBREF } );
</pre>
<p class="Pp">For positional parameters, this can be specified as follows:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    validate_pos( @_, { type =&gt; SCALAR | ARRAYREF }, { type =&gt; CODEREF } );
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Interface_Validation"><a class="permalink" href="#Interface_Validation">Interface
  Validation</a></h2>
To specify that a parameter is expected to have a certain set of methods, we can
  do the following:
<p class="Pp"><span class="Li"></span></p>
<pre>
    validate(
        @_, {
            foo =&gt;
                # just has to be able to -&gt;bar
                { can =&gt; 'bar' }
        }
    );

 ... or ...

    validate(
        @_, {
            foo =&gt;
                # must be able to -&gt;bar and -&gt;print
                { can =&gt; [qw( bar print )] }
        }
    );
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Class_Validation"><a class="permalink" href="#Class_Validation">Class
  Validation</a></h2>
A word of warning. When constructing your external interfaces, it is probably
  better to specify what methods you expect an object to have rather than what
  class it should be of (or a child of). This will make your API much more
  flexible.
<p class="Pp">With that said, if you want to validate that an incoming parameter
    belongs to a class (or child class) or classes, do:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    validate(
        @_,
        { foo =&gt; { isa =&gt; 'My::Frobnicator' } }
    );

 ... or ...

    validate(
        @_,
        # must be both, not either!
        { foo =&gt; { isa =&gt; [qw( My::Frobnicator IO::Handle )] } }
    );
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Regex_Validation"><a class="permalink" href="#Regex_Validation">Regex
  Validation</a></h2>
If you want to specify that a given parameter must match a specific regular
  expression, this can be done with &quot;regex&quot; spec key. For example:
<p class="Pp"><span class="Li"></span></p>
<pre>
    validate(
        @_,
        { foo =&gt; { regex =&gt; qr/^\d+$/ } }
    );
</pre>
<p class="Pp">The value of the &quot;regex&quot; key may be either a string or a
    pre-compiled regex created via <span class="Li">&quot;qr&quot;</span>.</p>
<p class="Pp">If the value being checked against a regex is undefined, the regex
    is explicitly checked against the empty string ('') instead, in order to
    avoid &quot;Use of uninitialized value&quot; warnings.</p>
<p class="Pp">The <span class="Li">&quot;Regexp::Common&quot;</span> module on
    CPAN is an excellent source of regular expressions suitable for validating
    input.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Callback_Validation"><a class="permalink" href="#Callback_Validation">Callback
  Validation</a></h2>
If none of the above are enough, it is possible to pass in one or more callbacks
  to validate the parameter. The callback will be given the <b>value</b> of the
  parameter as its first argument. Its second argument will be all the
  parameters, as a reference to either a hash or array. Callbacks are specified
  as hash reference. The key is an id for the callback (used in error messages)
  and the value is a subroutine reference, such as:
<p class="Pp"><span class="Li"></span></p>
<pre>
    validate(
        @_, {
            foo =&gt; {
                callbacks =&gt; {
                    'smaller than a breadbox' =&gt; sub { shift() &lt; $breadbox },
                    'green or blue' =&gt;
                        sub { $_[0] eq 'green' || $_[0] eq 'blue' }
                }
            }
        );

    validate(
        @_, {
            foo =&gt; {
                callbacks =&gt; {
                    'bigger than baz' =&gt; sub { $_[0] &gt; $_[1]-&gt;{baz} }
                }
            }
        }
    );
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Untainting"><a class="permalink" href="#Untainting">Untainting</a></h2>
If you want values untainted, set the &quot;untaint&quot; key in a spec hashref
  to a true value, like this:
<p class="Pp"><span class="Li"></span></p>
<pre>
    my %p = validate(
        @_, {
            foo =&gt; { type =&gt; SCALAR, untaint =&gt; 1 },
            bar =&gt; { type =&gt; ARRAYREF }
        }
    );
</pre>
<p class="Pp">This will untaint the &quot;foo&quot; parameter if the parameters
    are valid.</p>
<p class="Pp">Note that untainting is only done if <i>all parameters</i> are
    valid. Also, only the return values are untainted, not the original values
    passed into the validation function.</p>
<p class="Pp">Asking for untainting of a reference value will not do anything,
    as <span class="Li">&quot;Params::Validate&quot;</span> will only attempt to
    untaint the reference itself.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Mandatory/Optional_Revisited"><a class="permalink" href="#Mandatory/Optional_Revisited">Mandatory/Optional
  Revisited</a></h2>
If you want to specify something such as type or interface, plus the fact that a
  parameter can be optional, do this:
<p class="Pp"><span class="Li"></span></p>
<pre>
    validate(
        @_, {
            foo =&gt; { type =&gt; SCALAR },
            bar =&gt; { type =&gt; ARRAYREF, optional =&gt; 1 }
        }
    );
</pre>
<p class="Pp">or this for positional parameters:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    validate_pos(
        @_,
        { type =&gt; SCALAR },
        { type =&gt; ARRAYREF, optional =&gt; 1 }
    );
</pre>
<p class="Pp">By default, parameters are assumed to be mandatory unless
    specified as optional.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Dependencies"><a class="permalink" href="#Dependencies">Dependencies</a></h2>
It also possible to specify that a given optional parameter depends on the
  presence of one or more other optional parameters.
<p class="Pp"><span class="Li"></span></p>
<pre>
    validate(
        @_, {
            cc_number =&gt; {
                type     =&gt; SCALAR,
                optional =&gt; 1,
                depends  =&gt; [ 'cc_expiration', 'cc_holder_name' ],
            },
            cc_expiration  { type =&gt; SCALAR, optional =&gt; 1 },
            cc_holder_name { type =&gt; SCALAR, optional =&gt; 1 },
        }
    );
</pre>
<p class="Pp">In this case, &quot;cc_number&quot;, &quot;cc_expiration&quot;,
    and &quot;cc_holder_name&quot; are all optional. However, if
    &quot;cc_number&quot; is provided, then &quot;cc_expiration&quot; and
    &quot;cc_holder_name&quot; must be provided as well.</p>
<p class="Pp">This allows you to group together sets of parameters that all must
    be provided together.</p>
<p class="Pp">The <span class="Li">&quot;validate_pos()&quot;</span> version of
    dependencies is slightly different, in that you can only depend on one other
    parameter. Also, if for example, the second parameter 2 depends on the
    fourth parameter, then it implies a dependency on the third parameter as
    well. This is because if the fourth parameter is required, then the user
    must also provide a third parameter so that there can be four parameters in
    total.</p>
<p class="Pp"><span class="Li">&quot;Params::Validate&quot;</span> will die if
    you try to depend on a parameter not declared as part of your parameter
    specification.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Specifying_defaults"><a class="permalink" href="#Specifying_defaults">Specifying
  defaults</a></h2>
If the <span class="Li">&quot;validate()&quot;</span> or
  <span class="Li">&quot;validate_pos()&quot;</span> functions are called in a
  list context, they will return a hash or containing the original parameters
  plus defaults as indicated by the validation spec.
<p class="Pp">If the function is not called in a list context, providing a
    default in the validation spec still indicates that the parameter is
    optional.</p>
<p class="Pp">The hash or array returned from the function will always be a copy
    of the original parameters, in order to leave <span class="Li">@_</span>
    untouched for the calling function.</p>
<p class="Pp">Simple examples of defaults would be:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    my %p = validate( @_, { foo =&gt; 1, bar =&gt; { default =&gt; 99 } } );

    my @p = validate_pos( @_, 1, { default =&gt; 99 } );
</pre>
<p class="Pp">In scalar context, a hash reference or array reference will be
    returned, as appropriate.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="USAGE_NOTES"><a class="permalink" href="#USAGE_NOTES">USAGE
  NOTES</a></h1>
<section class="Ss">
<h2 class="Ss" id="Validation_failure"><a class="permalink" href="#Validation_failure">Validation
  failure</a></h2>
By default, when validation fails
  <span class="Li">&quot;Params::Validate&quot;</span> calls
  <span class="Li">&quot;Carp::confess()&quot;</span>. This can be overridden by
  setting the <span class="Li">&quot;on_fail&quot;</span> option, which is
  described in the &quot;GLOBAL&quot; OPTIONS section.
</section>
<section class="Ss">
<h2 class="Ss" id="Method_calls"><a class="permalink" href="#Method_calls">Method
  calls</a></h2>
When using this module to validate the parameters passed to a method call, you
  will probably want to remove the class/object from the parameter list
  <b>before</b> calling <span class="Li">&quot;validate()&quot;</span> or
  <span class="Li">&quot;validate_pos()&quot;</span>. If your method expects
  named parameters, then this is necessary for the
  <span class="Li">&quot;validate()&quot;</span> function to actually work,
  otherwise <span class="Li">@_</span> will not be usable as a hash, because it
  will first have your object (or class) <b>followed</b> by a set of keys and
  values.
<p class="Pp">Thus the idiomatic usage of
    <span class="Li">&quot;validate()&quot;</span> in a method call will look
    something like this:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    sub method {
        my $self = shift;

        my %params = validate(
            @_, {
                foo =&gt; 1,
                bar =&gt; { type =&gt; ARRAYREF },
            }
        );
    }
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Speeding_Up_Validation"><a class="permalink" href="#Speeding_Up_Validation">Speeding
  Up Validation</a></h2>
In most cases, the validation spec will remain the same for each call to a
  subroutine. In that case, you can speed up validation by defining the
  validation spec just once, rather than on each call to the subroutine:
<p class="Pp"><span class="Li"></span></p>
<pre>
    my %spec = ( ... );
    sub foo {
        my %params = validate( @_, \%spec );
    }
</pre>
<p class="Pp">You can also use the <span class="Li">&quot;state&quot;</span>
    feature to do this:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    use feature 'state';

    sub foo {
        state $spec = { ... };
        my %params = validate( @_, $spec );
    }
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="_GLOBAL__OPTIONS"><a class="permalink" href="#_GLOBAL__OPTIONS">&quot;GLOBAL&quot;
  OPTIONS</a></h1>
Because the API for the <span class="Li">&quot;validate()&quot;</span> and
  <span class="Li">&quot;validate_pos()&quot;</span> functions does not make it
  possible to specify any options other than the validation spec, it is possible
  to set some options as pseudo-'globals'. These allow you to specify such
  things as whether or not the validation of named parameters should be case
  sensitive, for one example.
<p class="Pp">These options are called pseudo-'globals' because these settings
    are <b>only applied to calls originating from the package that set the</b>
    <b>options</b>.</p>
<p class="Pp">In other words, if I am in package
    <span class="Li">&quot;Foo&quot;</span> and I call
    <span class="Li">&quot;validation_options()&quot;</span>, those options are
    only in effect when I call <span class="Li">&quot;validate()&quot;</span>
    from package <span class="Li">&quot;Foo&quot;</span>.</p>
<p class="Pp">While this is quite different from how most other modules operate,
    I feel that this is necessary in able to make it possible for one
    module/application to use Params::Validate while still using other modules
    that also use Params::Validate, perhaps with different options set.</p>
<p class="Pp">The downside to this is that if you are writing an app with a
    standard calling style for all functions, and your app has ten modules,
    <b>each</b> <b>module must include a call to
    </b><b>&quot;validation_options()&quot;</b><b></b>. You could of course
    write a module that all your modules use which uses various trickery to do
    this when imported.</p>
<section class="Ss">
<h2 class="Ss" id="Options"><a class="permalink" href="#Options">Options</a></h2>
<ul class="Bl-bullet">
  <li>normalize_keys =&gt; <span class="Li">$callback</span>
    <p class="Pp">This option is only relevant when dealing with named
        parameters.</p>
    <p class="Pp">This callback will be used to transform the hash keys of both
        the parameters and the parameter spec when
        <span class="Li">&quot;validate()&quot;</span> or
        <span class="Li">&quot;validate_with()&quot;</span> are called.</p>
    <p class="Pp">Any alterations made by this callback will be reflected in the
        parameter hash that is returned by the validation function. For
      example:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    sub foo {
        return validate_with(
            params =&gt; \@_,
            spec   =&gt; { foo =&gt; { type =&gt; SCALAR } },
            normalize_keys =&gt;
                sub { my $k = shift; $k =~ s/^-//; return uc $k },
        );

    }

    %p = foo( foo =&gt; 20 );

    # $p{FOO} is now 20

    %p = foo( -fOo =&gt; 50 );

    # $p{FOO} is now 50
    </pre>
    <p class="Pp">The callback must return a defined value.</p>
    <p class="Pp">If a callback is given then the deprecated
        &quot;ignore_case&quot; and &quot;strip_leading&quot; options are
        ignored.</p>
  </li>
  <li>allow_extra =&gt; <span class="Li">$boolean</span>
    <p class="Pp">If true, then the validation routine will allow extra
        parameters not named in the validation specification. In the case of
        positional parameters, this allows an unlimited number of maximum
        parameters (though a minimum may still be set). Defaults to false.</p>
  </li>
  <li>on_fail =&gt; <span class="Li">$callback</span>
    <p class="Pp">If given, this callback will be called whenever a validation
        check fails. It will be called with a single parameter, which will be a
        string describing the failure. This is useful if you wish to have this
        module throw exceptions as objects rather than as strings, for
      example.</p>
    <p class="Pp">This callback is expected to
        <span class="Li">&quot;die()&quot;</span> internally. If it does not,
        the validation will proceed onwards, with unpredictable results.</p>
    <p class="Pp">The default is to simply use the Carp module's
        <span class="Li">&quot;confess()&quot;</span> function.</p>
  </li>
  <li>stack_skip =&gt; <span class="Li">$number</span>
    <p class="Pp">This tells Params::Validate how many stack frames to skip when
        finding a subroutine name to use in error messages. By default, it looks
        one frame back, at the immediate caller to
        <span class="Li">&quot;validate()&quot;</span> or
        <span class="Li">&quot;validate_pos()&quot;</span>. If this option is
        set, then the given number of frames are skipped instead.</p>
  </li>
  <li>ignore_case =&gt; <span class="Li">$boolean</span>
    <p class="Pp">DEPRECATED</p>
    <p class="Pp">This is only relevant when dealing with named parameters. If
        it is true, then the validation code will ignore the case of parameter
        names. Defaults to false.</p>
  </li>
  <li>strip_leading =&gt; <span class="Li">$characters</span>
    <p class="Pp">DEPRECATED</p>
    <p class="Pp">This too is only relevant when dealing with named parameters.
        If this is given then any parameters starting with these characters will
        be considered equivalent to parameters without them entirely. For
        example, if this is specified as '-', then
        <span class="Li">&quot;-foo&quot;</span> and
        <span class="Li">&quot;foo&quot;</span> would be considered
      identical.</p>
  </li>
</ul>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="PER-INVOCATION_OPTIONS"><a class="permalink" href="#PER-INVOCATION_OPTIONS">PER-INVOCATION
  OPTIONS</a></h1>
The <span class="Li">&quot;validate_with()&quot;</span> function can be used to
  set the options listed above on a per-invocation basis. For example:
<p class="Pp"><span class="Li"></span></p>
<pre>
    my %p = validate_with(
        params =&gt; \@_,
        spec   =&gt; {
            foo =&gt; { type    =&gt; SCALAR },
            bar =&gt; { default =&gt; 10 }
        },
        allow_extra =&gt; 1,
    );
</pre>
<p class="Pp">In addition to the options listed above, it is also possible to
    set the option &quot;called&quot;, which should be a string. This string
    will be used in any error messages caused by a failure to meet the
    validation spec.</p>
<p class="Pp">This subroutine will validate named parameters as a hash if the
    &quot;spec&quot; parameter is a hash reference. If it is an array reference,
    the parameters are assumed to be positional.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    my %p = validate_with(
        params =&gt; \@_,
        spec   =&gt; {
            foo =&gt; { type    =&gt; SCALAR },
            bar =&gt; { default =&gt; 10 }
        },
        allow_extra =&gt; 1,
        called      =&gt; 'The Quux::Baz class constructor',
    );

    my @p = validate_with(
        params =&gt; \@_,
        spec   =&gt; [
            { type    =&gt; SCALAR },
            { default =&gt; 10 }
        ],
        allow_extra =&gt; 1,
        called      =&gt; 'The Quux::Baz class constructor',
    );
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DISABLING_VALIDATION"><a class="permalink" href="#DISABLING_VALIDATION">DISABLING
  VALIDATION</a></h1>
If the environment variable
  <span class="Li">&quot;PERL_NO_VALIDATION&quot;</span> is set to something
  true, then validation is turned off. This may be useful if you only want to
  use this module during development but don't want the speed hit during
  production.
<p class="Pp">The only error that will be caught will be when an odd number of
    parameters are passed into a function/method that expects a hash.</p>
<p class="Pp">If you want to selectively turn validation on and off at runtime,
    you can directly set the
    <span class="Li">$Params::Validate::NO_VALIDATION</span> global variable. It
    is <b>strongly</b> recommended that you <b>localize</b> any changes to this
    variable, because other modules you are using may expect validation to be on
    when they execute. For example:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    {
        local $Params::Validate::NO_VALIDATION = 1;

        # no error
        foo( bar =&gt; 2 );
    }

    # error
    foo( bar =&gt; 2 );

    sub foo {
        my %p = validate( @_, { foo =&gt; 1 } );
        ...;
    }
</pre>
<p class="Pp">But if you want to shoot yourself in the foot and just turn it
    off, go ahead!</p>
</section>
<section class="Sh">
<h1 class="Sh" id="LIMITATIONS"><a class="permalink" href="#LIMITATIONS">LIMITATIONS</a></h1>
Right now there is no way (short of a callback) to specify that something must
  be of one of a list of classes, or that it must possess one of a list of
  methods. If this is desired, it can be added in the future.
<p class="Pp">Ideally, there would be only one validation function. If someone
    figures out how to do this, please let me know.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SUPPORT"><a class="permalink" href="#SUPPORT">SUPPORT</a></h1>
Please submit bugs and patches to the CPAN RT system at
  http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Params%3A%3AValidate or via
  email at bug-params-validate@rt.cpan.org.
<p class="Pp">Support questions can be sent to Dave at autarch@urth.org.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DONATIONS"><a class="permalink" href="#DONATIONS">DONATIONS</a></h1>
If you'd like to thank me for the work I've done on this module, please consider
  making a &quot;donation&quot; to me via PayPal. I spend a lot of free time
  creating free software, and would appreciate any support you'd care to offer.
<p class="Pp">Please note that <b>I am not suggesting that you must do this</b>
    in order for me to continue working on this particular software. I will
    continue to do so, inasmuch as I have in the past, for as long as it
    interests me.</p>
<p class="Pp">Similarly, a donation made in this way will probably not make me
    work on this software much more, unless I get so many donations that I can
    consider working on free software full time, which seems unlikely at
  best.</p>
<p class="Pp">To donate, log into PayPal and send money to autarch@urth.org or
    use the button on this page:
    &lt;http://www.urth.org/~autarch/fs-donation.html&gt;</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
Dave Rolsky, &lt;autarch@urth.org&gt; and Ilya Martynov
  &lt;ilya@martynov.org&gt;
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT_AND_LICENSE"><a class="permalink" href="#COPYRIGHT_AND_LICENSE">COPYRIGHT
  AND LICENSE</a></h1>
This software is Copyright (c) 2013 by Dave Rolsky and Ilya Martynov.
<p class="Pp">This is free software, licensed under:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  The Artistic License 2.0 (GPL Compatible)
</pre>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2020-10-18</td>
    <td class="foot-os">perl v5.18.4</td>
  </tr>
</table>
</body>
</html>
