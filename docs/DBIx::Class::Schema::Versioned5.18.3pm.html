<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>DBIx::Class::Schema::Versioned(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">DBIx::Class::Schema::Versioned(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">DBIx::Class::Schema::Versioned(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
DBIx::Class::Schema::Versioned - DBIx::Class::Schema plugin for Schema upgrades
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<span class="Li"></span>
<pre>
  package MyApp::Schema;
  use base qw/DBIx::Class::Schema/;

  our $VERSION = 0.001;

  # load MyApp::Schema::CD, MyApp::Schema::Book, MyApp::Schema::DVD
  __PACKAGE__-&gt;load_classes(qw/CD Book DVD/);

  __PACKAGE__-&gt;load_components(qw/Schema::Versioned/);
  __PACKAGE__-&gt;upgrade_directory('/path/to/upgrades/');
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
This module provides methods to apply DDL changes to your database using SQL
  diff files. Normally these diff files would be created using
  &quot;create_ddl_dir&quot; in DBIx::Class::Schema.
<p class="Pp">A table called <i>dbix_class_schema_versions</i> is created and
    maintained by the module. This is used to determine which version your
    database is currently at. Similarly the <span class="Li">$VERSION</span> in
    your DBIC schema class is used to determine the current DBIC schema
  version.</p>
<p class="Pp">The upgrade is initiated manually by calling
    <span class="Li">&quot;upgrade&quot;</span> on your schema object, this will
    attempt to upgrade the database from its current version to the current
    schema version using a diff from your <i>upgrade_directory</i>. If a
    suitable diff is not found then no upgrade is possible.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
DBIx::Class::DeploymentHandler is a much more powerful alternative to this
  module. Examples of things it can do that this module cannot do include
<ul class="Bl-bullet">
  <li>Downgrades in addition to upgrades</li>
  <li>Multiple sql files per upgrade/downgrade/install</li>
  <li>Perl scripts allowed for upgrade/downgrade/install</li>
  <li>Just one set of files needed for upgrade, unlike this module where one
      might need to generate <span class="Li">&quot;factorial(scalar
      @versions)&quot;</span></li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="GETTING_STARTED"><a class="permalink" href="#GETTING_STARTED">GETTING
  STARTED</a></h1>
Firstly you need to setup your schema class as per the &quot;SYNOPSIS&quot;,
  make sure you have specified an upgrade_directory and an initial
  <span class="Li">$VERSION</span>.
<p class="Pp">Then you'll need two scripts, one to create DDL files and diffs
    and another to perform upgrades. Your creation script might look like a bit
    like this:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  use strict;
  use Pod::Usage;
  use Getopt::Long;
  use MyApp::Schema;

  my ( $preversion, $help );
  GetOptions(
    'p|preversion:s'  =&gt; \$preversion,
  ) or die pod2usage;

  my $schema = MyApp::Schema-&gt;connect(
    $dsn,
    $user,
    $password,
  );
  my $sql_dir = './sql';
  my $version = $schema-&gt;schema_version();
  $schema-&gt;create_ddl_dir( 'MySQL', $version, $sql_dir, $preversion );
</pre>
<p class="Pp">Then your upgrade script might look like so:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  use strict;
  use MyApp::Schema;

  my $schema = MyApp::Schema-&gt;connect(
    $dsn,
    $user,
    $password,
  );

  if (!$schema-&gt;get_db_version()) {
    # schema is unversioned
    $schema-&gt;deploy();
  } else {
    $schema-&gt;upgrade();
  }
</pre>
<p class="Pp">The script above assumes that if the database is unversioned then
    it is empty and we can safely deploy the DDL to it. However things are not
    always so simple.</p>
<p class="Pp">if you want to initialise a pre-existing database where the DDL is
    not the same as the DDL for your current schema version then you will need a
    diff which converts the database's DDL to the current DDL. The best way to
    do this is to get a dump of the database schema (without data) and save that
    in your SQL directory as version 0.000 (the filename must be as with
    &quot;ddl_filename&quot; in DBIx::Class::Schema) then create a diff using
    your create DDL script given above from version 0.000 to the current
    version. Then hand check and if necessary edit the resulting diff to ensure
    that it will apply. Once you have done all that you can do this:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  if (!$schema-&gt;get_db_version()) {
    # schema is unversioned
    $schema-&gt;install(&quot;0.000&quot;);
  }

  # this will now apply the 0.000 to current version diff
  $schema-&gt;upgrade();
</pre>
<p class="Pp">In the case of an unversioned database the above code will create
    the dbix_class_schema_versions table and write version 0.000 to it, then
    upgrade will then apply the diff we talked about creating in the previous
    paragraph and then you're good to go.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="METHODS"><a class="permalink" href="#METHODS">METHODS</a></h1>
<section class="Ss">
<h2 class="Ss" id="upgrade_directory"><a class="permalink" href="#upgrade_directory">upgrade_directory</a></h2>
Use this to set the directory your upgrade files are stored in.
</section>
<section class="Ss">
<h2 class="Ss" id="backup_directory"><a class="permalink" href="#backup_directory">backup_directory</a></h2>
Use this to set the directory you want your backups stored in (note that backups
  are disabled by default).
</section>
<section class="Ss">
<h2 class="Ss" id="install"><a class="permalink" href="#install">install</a></h2>
<dl class="Bl-tag">
  <dt>Arguments: $db_version</dt>
  <dd></dd>
</dl>
<p class="Pp">Call this to initialise a previously unversioned database. The
    table 'dbix_class_schema_versions' will be created which will be used to
    store the database version.</p>
<p class="Pp">Takes one argument which should be the version that the database
    is currently at. Defaults to the return value of
  &quot;schema_version&quot;.</p>
<p class="Pp">See &quot;getting_started&quot; for more details.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="deploy"><a class="permalink" href="#deploy">deploy</a></h2>
Same as &quot;deploy&quot; in DBIx::Class::Schema but also calls
  <span class="Li">&quot;install&quot;</span>.
</section>
<section class="Ss">
<h2 class="Ss" id="create_upgrade_path"><a class="permalink" href="#create_upgrade_path">create_upgrade_path</a></h2>
<dl class="Bl-tag">
  <dt>Arguments: { upgrade_file =&gt; $file }</dt>
  <dd></dd>
</dl>
<p class="Pp">Virtual method that should be overridden to create an upgrade
    file. This is useful in the case of upgrading across multiple versions to
    concatenate several files to create one upgrade file.</p>
<p class="Pp">You'll probably want the db_version retrieved via
    <span class="Li">$self</span>-&gt;get_db_version and the schema_version
    which is retrieved via <span class="Li">$self</span>-&gt;schema_version</p>
</section>
<section class="Ss">
<h2 class="Ss" id="ordered_schema_versions"><a class="permalink" href="#ordered_schema_versions">ordered_schema_versions</a></h2>
<dl class="Bl-tag">
  <dt>Return Value: a list of version numbers, ordered from lowest to
    highest</dt>
  <dd></dd>
</dl>
<p class="Pp">Virtual method that should be overridden to return an ordered list
    of schema versions. This is then used to produce a set of steps to upgrade
    through to achieve the required schema version.</p>
<p class="Pp">You may want the db_version retrieved via
    <span class="Li">$self</span>-&gt;get_db_version and the schema_version
    which is retrieved via <span class="Li">$self</span>-&gt;schema_version</p>
</section>
<section class="Ss">
<h2 class="Ss" id="upgrade"><a class="permalink" href="#upgrade">upgrade</a></h2>
Call this to attempt to upgrade your database from the version it is at to the
  version this DBIC schema is at. If they are the same it does nothing.
<p class="Pp">It will call &quot;ordered_schema_versions&quot; to retrieve an
    ordered list of schema versions (if ordered_schema_versions returns nothing
    then it is assumed you can do the upgrade as a single step). It then
    iterates through the list of versions between the current db version and the
    schema version applying one update at a time until all relevant updates are
    applied.</p>
<p class="Pp">The individual update steps are performed by using
    &quot;upgrade_single_step&quot;, which will apply the update and also update
    the dbix_class_schema_versions table.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="upgrade_single_step"><a class="permalink" href="#upgrade_single_step">upgrade_single_step</a></h2>
<dl class="Bl-tag">
  <dt>Arguments: db_version - the version currently within the db</dt>
  <dd></dd>
  <dt>Arguments: target_version - the version to upgrade to</dt>
  <dd></dd>
</dl>
<p class="Pp">Call this to attempt to upgrade your database from the
    <i>db_version</i> to the <i>target_version</i>. If they are the same it does
    nothing.</p>
<p class="Pp">It requires an SQL diff file to exist in your
    <i>upgrade_directory</i>, normally you will have created this using
    &quot;create_ddl_dir&quot; in DBIx::Class::Schema.</p>
<p class="Pp">If successful the dbix_class_schema_versions table is updated with
    the <i>target_version</i>.</p>
<p class="Pp">This method may be called repeatedly by the upgrade method to
    upgrade through a series of updates.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="do_upgrade"><a class="permalink" href="#do_upgrade">do_upgrade</a></h2>
This is an overwritable method used to run your upgrade. The freeform method
  allows you to run your upgrade any way you please, you can call
  <span class="Li">&quot;run_upgrade&quot;</span> any number of times to run the
  actual SQL commands, and in between you can sandwich your data upgrading. For
  example, first run all the <b>CREATE</b> commands, then migrate your data from
  old to new tables/formats, then issue the DROP commands when you are finished.
  Will run the whole file as it is by default.
</section>
<section class="Ss">
<h2 class="Ss" id="run_upgrade"><a class="permalink" href="#run_upgrade">run_upgrade</a></h2>
<span class="Li"></span>
<pre>
 $self-&gt;run_upgrade(qr/create/i);
</pre>
<p class="Pp">Runs a set of SQL statements matching a passed in regular
    expression. The idea is that this method can be called any number of times
    from your <span class="Li">&quot;do_upgrade&quot;</span> method, running
    whichever commands you specify via the regex in the parameter. Probably
    won't work unless called from the overridable do_upgrade method.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="apply_statement"><a class="permalink" href="#apply_statement">apply_statement</a></h2>
Takes an SQL statement and runs it. Override this if you want to handle errors
  differently.
</section>
<section class="Ss">
<h2 class="Ss" id="get_db_version"><a class="permalink" href="#get_db_version">get_db_version</a></h2>
Returns the version that your database is currently at. This is determined by
  the values in the dbix_class_schema_versions table that
  <span class="Li">&quot;upgrade&quot;</span> and
  <span class="Li">&quot;install&quot;</span> write to.
</section>
<section class="Ss">
<h2 class="Ss" id="schema_version"><a class="permalink" href="#schema_version">schema_version</a></h2>
Returns the current schema class' <span class="Li">$VERSION</span>
</section>
<section class="Ss">
<h2 class="Ss" id="backup"><a class="permalink" href="#backup">backup</a></h2>
This is an overwritable method which is called just before the upgrade, to allow
  you to make a backup of the database. Per default this method attempts to call
  <span class="Li">&quot;$self-&gt;storage-&gt;backup&quot;</span>, to run the
  standard backup on each database type.
<p class="Pp">This method should return the name of the backup file, if
    appropriate..</p>
<p class="Pp">This method is disabled by default. Set
    <span class="Li">$schema</span>-&gt;<i>do_backup</i>(1) to enable it.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="connection"><a class="permalink" href="#connection">connection</a></h2>
Overloaded method. This checks the DBIC schema version against the DB version
  and warns if they are not the same or if the DB is unversioned. It also
  provides compatibility between the old versions table (SchemaVersions) and the
  new one (dbix_class_schema_versions).
<p class="Pp">To avoid the checks on connect, set the environment var
    DBIC_NO_VERSION_CHECK or alternatively you can set the ignore_version attr
    in the forth argument like so:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  my $schema = MyApp::Schema-&gt;connect(
    $dsn,
    $user,
    $password,
    { ignore_version =&gt; 1 },
  );
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR_AND_CONTRIBUTORS"><a class="permalink" href="#AUTHOR_AND_CONTRIBUTORS">AUTHOR
  AND CONTRIBUTORS</a></h1>
See AUTHOR and CONTRIBUTORS in DBIx::Class
</section>
<section class="Sh">
<h1 class="Sh" id="LICENSE"><a class="permalink" href="#LICENSE">LICENSE</a></h1>
You may distribute this code under the same terms as Perl itself.
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2014-01-05</td>
    <td class="foot-os">perl v5.18.2</td>
  </tr>
</table>
</body>
</html>
