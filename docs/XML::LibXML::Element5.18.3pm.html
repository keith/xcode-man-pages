<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>XML::LibXML::Element(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">XML::LibXML::Element(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">XML::LibXML::Element(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
XML::LibXML::Element - XML::LibXML Class for Element Nodes
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<span class="Li"></span>
<pre>
  use XML::LibXML;
  # Only methods specific to Element nodes are listed here,
  # see XML::LibXML::Node manpage for other methods

  $node = XML::LibXML::Element-&gt;new( $name );
  $node-&gt;setAttribute( $aname, $avalue );
  $node-&gt;setAttributeNS( $nsURI, $aname, $avalue );
  $avalue = $node-&gt;getAttribute( $aname );
  $avalue = $node-&gt;getAttributeNS( $nsURI, $aname );
  $attrnode = $node-&gt;getAttributeNode( $aname );
  $attrnode = $node-&gt;getAttributeNodeNS( $namespaceURI, $aname );
  $node-&gt;removeAttribute( $aname );
  $node-&gt;removeAttributeNS( $nsURI, $aname );
  $boolean = $node-&gt;hasAttribute( $aname );
  $boolean = $node-&gt;hasAttributeNS( $nsURI, $aname );
  @nodes = $node-&gt;getChildrenByTagName($tagname);
  @nodes = $node-&gt;getChildrenByTagNameNS($nsURI,$tagname);
  @nodes = $node-&gt;getChildrenByLocalName($localname);
  @nodes = $node-&gt;getElementsByTagName($tagname);
  @nodes = $node-&gt;getElementsByTagNameNS($nsURI,$localname);
  @nodes = $node-&gt;getElementsByLocalName($localname);
  $node-&gt;appendWellBalancedChunk( $chunk );
  $node-&gt;appendText( $PCDATA );
  $node-&gt;appendTextNode( $PCDATA );
  $node-&gt;appendTextChild( $childname , $PCDATA );
  $node-&gt;setNamespace( $nsURI , $nsPrefix, $activate );
  $node-&gt;setNamespaceDeclURI( $nsPrefix, $newURI );
  $node-&gt;setNamespaceDeclPrefix( $oldPrefix, $newPrefix );
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="METHODS"><a class="permalink" href="#METHODS">METHODS</a></h1>
The class inherits from XML::LibXML::Node. The documentation for Inherited
  methods is not listed here.
<p class="Pp">Many functions listed here are extensively documented in the DOM
    Level 3 specification (&lt;http://www.w3.org/TR/DOM-Level-3-Core/&gt;).
    Please refer to the specification for extensive documentation.</p>
<dl class="Bl-tag">
  <dt>new</dt>
  <dd><span class="Li"></span>
    <pre>
  $node = XML::LibXML::Element-&gt;new( $name );
    </pre>
    <p class="Pp">This function creates a new node unbound to any DOM.</p>
  </dd>
  <dt>setAttribute</dt>
  <dd><span class="Li"></span>
    <pre>
  $node-&gt;setAttribute( $aname, $avalue );
    </pre>
    <p class="Pp">This method sets or replaces the node's attribute
        <span class="Li">$aname</span> to the value
        <span class="Li">$avalue</span></p>
  </dd>
  <dt>setAttributeNS</dt>
  <dd><span class="Li"></span>
    <pre>
  $node-&gt;setAttributeNS( $nsURI, $aname, $avalue );
    </pre>
    <p class="Pp">Namespace-aware version of
        <span class="Li">&quot;setAttribute&quot;</span>, where
        <span class="Li">$nsURI</span> is a namespace URI,
        <span class="Li">$aname</span> is a qualified name, and
        <span class="Li">$avalue</span> is the value. The namespace URI may be
        null (empty or undefined) in order to create an attribute which has no
        namespace.</p>
    <p class="Pp">The current implementation differs from DOM in the following
        aspects</p>
    <p class="Pp">If an attribute with the same local name and namespace URI
        already exists on the element, but its prefix differs from the prefix of
        <span class="Li">$aname</span>, then this function is supposed to change
        the prefix (regardless of namespace declarations and possible
        collisions). However, the current implementation does rather the
        opposite. If a prefix is declared for the namespace URI in the scope of
        the attribute, then the already declared prefix is used, disregarding
        the prefix specified in <span class="Li">$aname</span>. If no prefix is
        declared for the namespace, the function tries to declare the prefix
        specified in <span class="Li">$aname</span> and dies if the prefix is
        already taken by some other namespace.</p>
    <p class="Pp">According to DOM Level 2 specification, this method can also
        be used to create or modify special attributes used for declaring XML
        namespaces (which belong to the namespace
        &quot;http://www.w3.org/2000/xmlns/&quot; and have prefix or name
        &quot;xmlns&quot;). This should work since version 1.61, but again the
        implementation differs from DOM specification in the following: if a
        declaration of the same namespace prefix already exists on the element,
        then changing its value via this method automatically changes the
        namespace of all elements and attributes in its scope. This is because
        in libxml2 the namespace URI of an element is not static but is computed
        from a pointer to a namespace declaration attribute.</p>
  </dd>
  <dt>getAttribute</dt>
  <dd><span class="Li"></span>
    <pre>
  $avalue = $node-&gt;getAttribute( $aname );
    </pre>
    <p class="Pp">If <span class="Li">$node</span> has an attribute with the
        name <span class="Li">$aname</span>, the value of this attribute will
        get returned.</p>
  </dd>
  <dt>getAttributeNS</dt>
  <dd><span class="Li"></span>
    <pre>
  $avalue = $node-&gt;getAttributeNS( $nsURI, $aname );
    </pre>
    <p class="Pp">Retrieves an attribute value by local name and namespace
      URI.</p>
  </dd>
  <dt>getAttributeNode</dt>
  <dd><span class="Li"></span>
    <pre>
  $attrnode = $node-&gt;getAttributeNode( $aname );
    </pre>
    <p class="Pp">Retrieve an attribute node by name. If no attribute with a
        given name exists, <span class="Li">&quot;undef&quot;</span> is
        returned.</p>
  </dd>
  <dt>getAttributeNodeNS</dt>
  <dd><span class="Li"></span>
    <pre>
  $attrnode = $node-&gt;getAttributeNodeNS( $namespaceURI, $aname );
    </pre>
    <p class="Pp">Retrieves an attribute node by local name and namespace URI.
        If no attribute with a given localname and namespace exists,
        <span class="Li">&quot;undef&quot;</span> is returned.</p>
  </dd>
  <dt>removeAttribute</dt>
  <dd><span class="Li"></span>
    <pre>
  $node-&gt;removeAttribute( $aname );
    </pre>
    <p class="Pp">The method removes the attribute
        <span class="Li">$aname</span> from the node's attribute list, if the
        attribute can be found.</p>
  </dd>
  <dt>removeAttributeNS</dt>
  <dd><span class="Li"></span>
    <pre>
  $node-&gt;removeAttributeNS( $nsURI, $aname );
    </pre>
    <p class="Pp">Namespace version of
        <span class="Li">&quot;removeAttribute&quot;</span></p>
  </dd>
  <dt>hasAttribute</dt>
  <dd><span class="Li"></span>
    <pre>
  $boolean = $node-&gt;hasAttribute( $aname );
    </pre>
    <p class="Pp">This function tests if the named attribute is set for the
        node. If the attribute is specified, TRUE \fIs0(1) will be returned,
        otherwise the return value is FALSE \fIs0(0).</p>
  </dd>
  <dt>hasAttributeNS</dt>
  <dd><span class="Li"></span>
    <pre>
  $boolean = $node-&gt;hasAttributeNS( $nsURI, $aname );
    </pre>
    <p class="Pp">namespace version of
        <span class="Li">&quot;hasAttribute&quot;</span></p>
  </dd>
  <dt>getChildrenByTagName</dt>
  <dd><span class="Li"></span>
    <pre>
  @nodes = $node-&gt;getChildrenByTagName($tagname);
    </pre>
    <p class="Pp">The function gives direct access to all child elements of the
        current node with a given tagname, where tagname is a qualified name,
        that is, in case of namespace usage it may consist of a prefix and local
        name. This function makes things a lot easier if one needs to handle big
        data sets. A special tagname '*' can be used to match any name.</p>
    <p class="Pp">If this function is called in SCALAR context, it returns the
        number of elements found.</p>
  </dd>
  <dt>getChildrenByTagNameNS</dt>
  <dd><span class="Li"></span>
    <pre>
  @nodes = $node-&gt;getChildrenByTagNameNS($nsURI,$tagname);
    </pre>
    <p class="Pp">Namespace version of
        <span class="Li">&quot;getChildrenByTagName&quot;</span>. A special
        nsURI '*' matches any namespace URI, in which case the function behaves
        just like
      <span class="Li">&quot;getChildrenByLocalName&quot;</span>.</p>
    <p class="Pp">If this function is called in SCALAR context, it returns the
        number of elements found.</p>
  </dd>
  <dt>getChildrenByLocalName</dt>
  <dd><span class="Li"></span>
    <pre>
  @nodes = $node-&gt;getChildrenByLocalName($localname);
    </pre>
    <p class="Pp">The function gives direct access to all child elements of the
        current node with a given local name. It makes things a lot easier if
        one needs to handle big data sets. A special
        <span class="Li">&quot;localname&quot;</span> '*' can be used to match
        any local name.</p>
    <p class="Pp">If this function is called in SCALAR context, it returns the
        number of elements found.</p>
  </dd>
  <dt>getElementsByTagName</dt>
  <dd><span class="Li"></span>
    <pre>
  @nodes = $node-&gt;getElementsByTagName($tagname);
    </pre>
    <p class="Pp">This function is part of the spec. It fetches all descendants
        of a node with a given tagname, where
        <span class="Li">&quot;tagname&quot;</span> is a qualified name, that
        is, in case of namespace usage it may consist of a prefix and local
        name. A special <span class="Li">&quot;tagname&quot;</span> '*' can be
        used to match any tag name.</p>
    <p class="Pp">In SCALAR context this function returns an
        XML::LibXML::NodeList object.</p>
  </dd>
  <dt>getElementsByTagNameNS</dt>
  <dd><span class="Li"></span>
    <pre>
  @nodes = $node-&gt;getElementsByTagNameNS($nsURI,$localname);
    </pre>
    <p class="Pp">Namespace version of
        <span class="Li">&quot;getElementsByTagName&quot;</span> as found in the
        DOM spec. A special <span class="Li">&quot;localname&quot;</span> '*'
        can be used to match any local name and
        <span class="Li">&quot;nsURI&quot;</span> '*' can be used to match any
        namespace URI.</p>
    <p class="Pp">In SCALAR context this function returns an
        XML::LibXML::NodeList object.</p>
  </dd>
  <dt>getElementsByLocalName</dt>
  <dd><span class="Li"></span>
    <pre>
  @nodes = $node-&gt;getElementsByLocalName($localname);
    </pre>
    <p class="Pp">This function is not found in the DOM specification. It is a
        mix of getElementsByTagName and getElementsByTagNameNS. It will fetch
        all tags matching the given local-name. This allows one to select tags
        with the same local name across namespace borders.</p>
    <p class="Pp">In SCALAR context this function returns an
        XML::LibXML::NodeList object.</p>
  </dd>
  <dt>appendWellBalancedChunk</dt>
  <dd><span class="Li"></span>
    <pre>
  $node-&gt;appendWellBalancedChunk( $chunk );
    </pre>
    <p class="Pp">Sometimes it is necessary to append a string coded XML Tree to
        a node. <i>appendWellBalancedChunk</i> will do the trick for you. But
        this is only done if the String is
        <span class="Li">&quot;well-balanced&quot;</span>.</p>
    <p class="Pp"><i>Note that </i><i>appendWellBalancedChunk()</i><i> is only
        left for compatibility reasons</i>. Implicitly it uses</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  my $fragment = $parser-&gt;parse_balanced_chunk( $chunk );
   $node-&gt;appendChild( $fragment );
    </pre>
    <p class="Pp">This form is more explicit and makes it easier to control the
        flow of a script.</p>
  </dd>
  <dt>appendText</dt>
  <dd><span class="Li"></span>
    <pre>
  $node-&gt;appendText( $PCDATA );
    </pre>
    <p class="Pp">alias for <i>appendTextNode()</i>.</p>
  </dd>
  <dt>appendTextNode</dt>
  <dd><span class="Li"></span>
    <pre>
  $node-&gt;appendTextNode( $PCDATA );
    </pre>
    <p class="Pp">This wrapper function lets you add a string directly to an
        element node.</p>
  </dd>
  <dt>appendTextChild</dt>
  <dd><span class="Li"></span>
    <pre>
  $node-&gt;appendTextChild( $childname , $PCDATA );
    </pre>
    <p class="Pp">Somewhat similar with
        <span class="Li">&quot;appendTextNode&quot;</span>: It lets you set an
        Element, that contains only a <span class="Li">&quot;text
        node&quot;</span> directly by specifying the name and the text
      content.</p>
  </dd>
  <dt>setNamespace</dt>
  <dd><span class="Li"></span>
    <pre>
  $node-&gt;setNamespace( $nsURI , $nsPrefix, $activate );
    </pre>
    <p class="Pp"><i>setNamespace()</i> allows one to apply a namespace to an
        element. The function takes three parameters: 1. the namespace URI,
        which is required and the two optional values prefix, which is the
        namespace prefix, as it should be used in child elements or attributes
        as well as the additional activate parameter. If prefix is not given,
        undefined or empty, this function tries to create a declaration of the
        default namespace.</p>
    <p class="Pp">The activate parameter is most useful: If this parameter is
        set to FALSE \fIs0(0), a new namespace declaration is simply added to
        the element while the element's namespace itself is not altered.
        Nevertheless, activate is set to TRUE \fIs0(1) on default. In this case
        the namespace is used as the node's effective namespace. This means the
        namespace prefix is added to the node name and if there was a namespace
        already active for the node, it will be replaced (but its declaration is
        not removed from the document). A new namespace declaration is only
        created if necessary (that is, if the element is already in the scope of
        a namespace declaration associating the prefix with the namespace URI,
        then this declaration is reused).</p>
    <p class="Pp">The following example may clarify this:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  my $e1 = $doc-&gt;createElement(&quot;bar&quot;);
   $e1-&gt;setNamespace(&quot;http://foobar.org&quot;, &quot;foo&quot;)
    </pre>
    <p class="Pp">results</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  &lt;foo:bar xmlns:foo=&quot;http://foobar.org&quot;/&gt;
    </pre>
    <p class="Pp">while</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  my $e2 = $doc-&gt;createElement(&quot;bar&quot;);
   $e2-&gt;setNamespace(&quot;http://foobar.org&quot;, &quot;foo&quot;,0)
    </pre>
    <p class="Pp">results only</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  &lt;bar xmlns:foo=&quot;http://foobar.org&quot;/&gt;
    </pre>
    <p class="Pp">By using <span class="Li">$activate</span> == 0 it is possible
        to create multiple namespace declarations on a single element.</p>
    <p class="Pp">The function fails if it is required to create a declaration
        associating the prefix with the namespace URI but the element already
        carries a declaration with the same prefix but different namespace
      URI.</p>
  </dd>
  <dt>setNamespaceDeclURI</dt>
  <dd><span class="Li"></span>
    <pre>
  $node-&gt;setNamespaceDeclURI( $nsPrefix, $newURI );
    </pre>
    <p class="Pp">EXPERIMENTAL IN 1.61 !</p>
    <p class="Pp">This function manipulates directly with an existing namespace
        declaration on an element. It takes two parameters: the prefix by which
        it looks up the namespace declaration and a new namespace URI which
        replaces its previous value.</p>
    <p class="Pp">It returns 1 if the namespace declaration was found and
        changed, 0 otherwise.</p>
    <p class="Pp">All elements and attributes (even those previously unbound
        from the document) for which the namespace declaration determines their
        namespace belong to the new namespace after the change.</p>
    <p class="Pp">If the new URI is undef or empty, the nodes have no namespace
        and no prefix after the change. Namespace declarations once nulled in
        this way do not further appear in the serialized output (but do remain
        in the document for internal integrity of libxml2 data structures).</p>
    <p class="Pp">This function is NOT part of any DOM API.</p>
  </dd>
  <dt>setNamespaceDeclPrefix</dt>
  <dd><span class="Li"></span>
    <pre>
  $node-&gt;setNamespaceDeclPrefix( $oldPrefix, $newPrefix );
    </pre>
    <p class="Pp">EXPERIMENTAL IN 1.61 !</p>
    <p class="Pp">This function manipulates directly with an existing namespace
        declaration on an element. It takes two parameters: the old prefix by
        which it looks up the namespace declaration and a new prefix which is to
        replace the old one.</p>
    <p class="Pp">The function dies with an error if the element is in the scope
        of another declaration whose prefix equals to the new prefix, or if the
        change should result in a declaration with a non-empty prefix but empty
        namespace URI. Otherwise, it returns 1 if the namespace declaration was
        found and changed and 0 if not found.</p>
    <p class="Pp">All elements and attributes (even those previously unbound
        from the document) for which the namespace declaration determines their
        namespace change their prefix to the new value.</p>
    <p class="Pp">If the new prefix is undef or empty, the namespace declaration
        becomes a declaration of a default namespace. The corresponding nodes
        drop their namespace prefix (but remain in the, now default, namespace).
        In this case the function fails, if the containing element is in the
        scope of another default namespace declaration.</p>
    <p class="Pp">This function is NOT part of any DOM API.</p>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="OVERLOADING"><a class="permalink" href="#OVERLOADING">OVERLOADING</a></h1>
XML::LibXML::Element overloads hash dereferencing to provide access to the
  element's attributes. For non-namespaced attributes, the attribute name is the
  hash key, and the attribute value is the hash value. For namespaced
  attributes, the hash key is qualified with the namespace URI, using Clark
  notation.
<p class="Pp">Perl's &quot;tied hash&quot; feature is used, which means that the
    hash gives you read-write access to the element's attributes. For more
    information, see XML::LibXML::AttributeHash</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHORS"><a class="permalink" href="#AUTHORS">AUTHORS</a></h1>
Matt Sergeant, Christian Glahn, Petr Pajas
</section>
<section class="Sh">
<h1 class="Sh" id="VERSION"><a class="permalink" href="#VERSION">VERSION</a></h1>
2.0110
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT"><a class="permalink" href="#COPYRIGHT">COPYRIGHT</a></h1>
2001-2007, AxKit.com Ltd.
<p class="Pp">2002-2006, Christian Glahn.</p>
<p class="Pp">2006-2009, Petr Pajas.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="LICENSE"><a class="permalink" href="#LICENSE">LICENSE</a></h1>
This program is free software; you can redistribute it and/or modify it under
  the same terms as Perl itself.
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2014-02-01</td>
    <td class="foot-os">perl v5.18.2</td>
  </tr>
</table>
</body>
</html>
