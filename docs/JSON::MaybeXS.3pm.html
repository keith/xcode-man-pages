<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>JSON::MaybeXS(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">JSON::MaybeXS(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">JSON::MaybeXS(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
JSON::MaybeXS - Use Cpanel::JSON::XS with a fallback to JSON::XS and JSON::PP
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<span class="Li"></span>
<pre>
  use JSON::MaybeXS;

  my $data_structure = decode_json($json_input);

  my $json_output = encode_json($data_structure);

  my $json = JSON()-&gt;new;

  my $json_with_args = JSON::MaybeXS-&gt;new(utf8 =&gt; 1); # or { utf8 =&gt; 1 }
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
This module first checks to see if either Cpanel::JSON::XS or JSON::XS (at at
  least version 3.0) is already loaded, in which case it uses that module.
  Otherwise it tries to load Cpanel::JSON::XS, then JSON::XS, then JSON::PP in
  order, and either uses the first module it finds or throws an error.
<p class="Pp">It then exports the
    <span class="Li">&quot;encode_json&quot;</span> and
    <span class="Li">&quot;decode_json&quot;</span> functions from the loaded
    module, along with a <span class="Li">&quot;JSON&quot;</span> constant that
    returns the class name for calling <span class="Li">&quot;new&quot;</span>
    on.</p>
<p class="Pp">If you're writing fresh code rather than replacing JSON.pm usage,
    you might want to pass options as constructor args rather than calling
    mutators, so we provide our own <span class="Li">&quot;new&quot;</span>
    method that supports that.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="EXPORTS"><a class="permalink" href="#EXPORTS">EXPORTS</a></h1>
<span class="Li">&quot;encode_json&quot;</span>,
  <span class="Li">&quot;decode_json&quot;</span> and
  <span class="Li">&quot;JSON&quot;</span> are exported by default;
  <span class="Li">&quot;is_bool&quot;</span> is exported on request.
<p class="Pp">To import only some symbols, specify them on the
    <span class="Li">&quot;use&quot;</span> line:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  use JSON::MaybeXS qw(encode_json decode_json is_bool); # functions only

  use JSON::MaybeXS qw(JSON); # JSON constant only
</pre>
<p class="Pp">To import all available sensible symbols
    (<span class="Li">&quot;encode_json&quot;</span>,
    <span class="Li">&quot;decode_json&quot;</span>, and
    <span class="Li">&quot;is_bool&quot;</span>), use
    <span class="Li">&quot;:all&quot;</span>:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  use JSON::MaybeXS ':all';
</pre>
<p class="Pp">To import all symbols including those needed by legacy apps that
    use JSON::PP:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  use JSON::MaybeXS ':legacy';
</pre>
<p class="Pp">This imports the <span class="Li">&quot;to_json&quot;</span> and
    <span class="Li">&quot;from_json&quot;</span> symbols as well as everything
    in <span class="Li">&quot;:all&quot;</span>. NOTE: This is to support legacy
    code that makes extensive use of <span class="Li">&quot;to_json&quot;</span>
    and <span class="Li">&quot;from_json&quot;</span> which you are not yet in a
    position to refactor. DO NOT use this import tag in new code, in order to
    avoid the crawling horrors of getting UTF-8 support subtly wrong. See the
    documentation for JSON for further details.</p>
<section class="Ss">
<h2 class="Ss" id="encode_json"><a class="permalink" href="#encode_json">encode_json</a></h2>
This is the <span class="Li">&quot;encode_json&quot;</span> function provided by
  the selected implementation module, and takes a perl data structure which is
  serialised to JSON text.
<p class="Pp"><span class="Li"></span></p>
<pre>
  my $json_text = encode_json($data_structure);
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="decode_json"><a class="permalink" href="#decode_json">decode_json</a></h2>
This is the <span class="Li">&quot;decode_json&quot;</span> function provided by
  the selected implementation module, and takes a string of JSON text to
  deserialise to a perl data structure.
<p class="Pp"><span class="Li"></span></p>
<pre>
  my $data_structure = decode_json($json_text);
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="to_json,_from_json"><a class="permalink" href="#to_json,_from_json">to_json,
  from_json</a></h2>
See JSON for details. These are included to support legacy code <b>only</b>.
</section>
<section class="Ss">
<h2 class="Ss" id="_s-1JSON_s0"><a class="permalink" href="#_s-1JSON_s0">JSON</a></h2>
The <span class="Li">&quot;JSON&quot;</span> constant returns the selected
  implementation module's name for use as a class name - so:
<p class="Pp"><span class="Li"></span></p>
<pre>
  my $json_obj = JSON()-&gt;new; # returns a Cpanel::JSON::XS or JSON::PP object
</pre>
<p class="Pp">and that object can then be used normally:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  my $data_structure = $json_obj-&gt;decode($json_text); # etc.
</pre>
<p class="Pp">The use of parentheses here is optional, and only used as a hint
    to the reader that this use of <span class="Li">&quot;JSON&quot;</span> is a
    <i>subroutine</i> call, <i>not</i> a class name.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="is_bool"><a class="permalink" href="#is_bool">is_bool</a></h2>
<span class="Li"></span>
<pre>
  $is_boolean = is_bool($scalar)
</pre>
<p class="Pp">Returns true if the passed scalar represents either
    <span class="Li">&quot;true&quot;</span> or
    <span class="Li">&quot;false&quot;</span>, two constants that act like
    <span class="Li">1</span> and <span class="Li">0</span>, respectively and
    are used to represent JSON <span class="Li">&quot;true&quot;</span> and
    <span class="Li">&quot;false&quot;</span> values in Perl.</p>
<p class="Pp">Since this is a bare sub in the various backend classes, it cannot
    be called as a class method like the other interfaces; it must be called as
    a function, with no invocant. It supports the representation used in all
    JSON backends.</p>
<p class="Pp">Available since version 1.002004.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="CONSTRUCTOR"><a class="permalink" href="#CONSTRUCTOR">CONSTRUCTOR</a></h1>
<section class="Ss">
<h2 class="Ss" id="new"><a class="permalink" href="#new">new</a></h2>
With JSON::PP, JSON::XS and Cpanel::JSON::XS you are required to call mutators
  to set options, such as:
<p class="Pp"><span class="Li"></span></p>
<pre>
  my $json = $class-&gt;new-&gt;utf8(1)-&gt;pretty(1);
</pre>
<p class="Pp">Since this is a trifle irritating and noticeably un-perlish, we
    also offer:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  my $json = JSON::MaybeXS-&gt;new(utf8 =&gt; 1, pretty =&gt; 1);
</pre>
<p class="Pp">which works equivalently to the above (and in the usual tradition
    will accept a hashref instead of a hash, should you so desire).</p>
<p class="Pp">The resulting object is blessed into the underlying backend, which
    offers (at least) the methods <span class="Li">&quot;encode&quot;</span> and
    <span class="Li">&quot;decode&quot;</span>.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="BOOLEANS"><a class="permalink" href="#BOOLEANS">BOOLEANS</a></h1>
To include JSON-aware booleans (<span class="Li">&quot;true&quot;</span>,
  <span class="Li">&quot;false&quot;</span>) in your data, just do:
<p class="Pp"><span class="Li"></span></p>
<pre>
    use JSON::MaybeXS;
    my $true = JSON()-&gt;true;
    my $false = JSON()-&gt;false;
</pre>
<p class="Pp">The booleans are also available as subs or methods on
    JSON::MaybeXS.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    use JSON::MaybeXS ();
    my $true = JSON::MaybeXS::true;
    my $true = JSON::MaybeXS-&gt;true;
    my $false = JSON::MaybeXS::false;
    my $false = JSON::MaybeXS-&gt;false;
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="CONVERTING_FROM_JSON::Any"><a class="permalink" href="#CONVERTING_FROM_JSON::Any">CONVERTING
  FROM JSON::Any</a></h1>
JSON::Any used to be the favoured compatibility layer above the various JSON
  backends, but over time has grown a lot of extra code to deal with legacy
  backends (e.g. JSON::Syck) that are no longer needed. This is a rough guide of
  translating such code:
<p class="Pp">Change code from:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    use JSON::Any;
    my $json = JSON::Any-&gt;new-&gt;objToJson($data);    # or to_json($data), or Dump($data)
</pre>
<p class="Pp">to:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    use JSON::MaybeXS;
    my $json = encode_json($data);
</pre>
<p class="Pp">Change code from:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    use JSON::Any;
    my $data = JSON::Any-&gt;new-&gt;jsonToObj($json);    # or from_json($json), or Load($json)
</pre>
<p class="Pp">to:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    use JSON::MaybeXS;
    my $json = decode_json($data);
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="CAVEATS"><a class="permalink" href="#CAVEATS">CAVEATS</a></h1>
The <span class="Li">&quot;new()&quot;</span> method in this module is
  technically a factory, not a constructor, because the objects it returns will
  <i>NOT</i> be blessed into the
  <span class="Li">&quot;JSON::MaybeXS&quot;</span> class.
<p class="Pp">If you are using an object returned by this module as a Moo(se)
    attribute, this type constraint code:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    is 'json' =&gt; ( isa =&gt; 'JSON::MaybeXS' );
</pre>
<p class="Pp">will <i>NOT</i> do what you expect. Instead, either rely on the
    <span class="Li">&quot;JSON&quot;</span> class constant described above, as
    so:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    is 'json' =&gt; ( isa =&gt; JSON::MaybeXS::JSON() );
</pre>
<p class="Pp">Alternatively, you can use duck typing:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    use Moose::Util::TypeConstraints 'duck_type';
    is 'json' =&gt; ( isa =&gt; Object , duck_type([qw/ encode decode /]));
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="INSTALLATION"><a class="permalink" href="#INSTALLATION">INSTALLATION</a></h1>
At installation time, <i>Makefile.PL</i> will attempt to determine if you have a
  working compiler available, and therefore whether you are able to run XS code.
  If so, Cpanel::JSON::XS will be added to the prerequisite list, unless
  JSON::XS is already installed at a high enough version. JSON::XS may also be
  upgraded to fix any incompatibility issues.
<p class="Pp">Because running XS code is not mandatory and JSON::PP (which is in
    perl core) is used as a fallback backend, this module is safe to be used in
    a suite of code that is fatpacked or installed into a restricted-resource
    environment.</p>
<p class="Pp">You can also prevent any XS dependencies from being installed by
    setting <span class="Li">&quot;PUREPERL_ONLY=1&quot;</span> in
    <i>Makefile.PL</i> options (or in the
    <span class="Li">&quot;PERL_MM_OPT&quot;</span> environment variable), or
    using the <span class="Li">&quot;--pp&quot;</span> or
    <span class="Li">&quot;--pureperl&quot;</span> flags with the cpanminus
    client.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
mst - Matt S. Trout (cpan:MSTROUT) &lt;mst@shadowcat.co.uk&gt;
</section>
<section class="Sh">
<h1 class="Sh" id="CONTRIBUTORS"><a class="permalink" href="#CONTRIBUTORS">CONTRIBUTORS</a></h1>
<ul class="Bl-bullet">
  <li>Clinton Gormley &lt;drtech@cpan.org&gt;</li>
  <li>Karen Etheridge &lt;ether@cpan.org&gt;</li>
  <li>Kieren Diment &lt;diment@gmail.com&gt;</li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT"><a class="permalink" href="#COPYRIGHT">COPYRIGHT</a></h1>
Copyright (c) 2013 the <span class="Li">&quot;JSON::MaybeXS&quot;</span>
  &quot;AUTHOR&quot; and &quot;CONTRIBUTORS&quot; as listed above.
</section>
<section class="Sh">
<h1 class="Sh" id="LICENSE"><a class="permalink" href="#LICENSE">LICENSE</a></h1>
This library is free software and may be distributed under the same terms as
  perl itself.
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2020-05-17</td>
    <td class="foot-os">perl v5.30.2</td>
  </tr>
</table>
</body>
</html>
