<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>DBIx::Class::Relationship::Base(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">DBIx::Class::Relationship::Base(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">DBIx::Class::Relationship::Base(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
DBIx::Class::Relationship::Base - Inter-table relationships
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<span class="Li"></span>
<pre>
  __PACKAGE__-&gt;add_relationship(
    spiders =&gt; 'My::DB::Result::Creatures',
    sub {
      my $args = shift;
      return {
        &quot;$args-&gt;{foreign_alias}.id&quot;   =&gt; { -ident =&gt; &quot;$args-&gt;{self_alias}.id&quot; },
        &quot;$args-&gt;{foreign_alias}.type&quot; =&gt; 'arachnid'
      };
    },
  );
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
This class provides methods to describe the relationships between the tables in
  your database model. These are the &quot;bare bones&quot; relationships
  methods, for predefined ones, look in DBIx::Class::Relationship.
</section>
<section class="Sh">
<h1 class="Sh" id="METHODS"><a class="permalink" href="#METHODS">METHODS</a></h1>
<section class="Ss">
<h2 class="Ss" id="add_relationship"><a class="permalink" href="#add_relationship">add_relationship</a></h2>
<dl class="Bl-tag">
  <dt>Arguments: $rel_name, $foreign_class, $condition, $attrs</dt>
  <dd></dd>
</dl>
<p class="Pp"><span class="Li"></span></p>
<pre>
  __PACKAGE__-&gt;add_relationship('rel_name',
                                'Foreign::Class',
                                $condition, $attrs);
</pre>
<p class="Pp">Create a custom relationship between one result source and another
    source, indicated by its class name.</p>
<p class="Pp"><i>condition</i></p>
<p class="Pp">The condition argument describes the
    <span class="Li">&quot;ON&quot;</span> clause of the
    <span class="Li">&quot;JOIN&quot;</span> expression used to connect the two
    sources when creating SQL queries.</p>
<p class="Pp">Simple equality</p>
<p class="Pp">To create simple equality joins, supply a hashref containing the
    remote table column name as the key(s) prefixed by
    <span class="Li">'foreign.'</span>, and the corresponding local table column
    name as the value(s) prefixed by <span class="Li">'self.'</span>. Both
    <span class="Li">&quot;foreign&quot;</span> and
    <span class="Li">&quot;self&quot;</span> are pseudo aliases and must be
    entered literally. They will be replaced with the actual correct table alias
    when the SQL is produced.</p>
<p class="Pp">For example given:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  My::Schema::Author-&gt;has_many(
    books =&gt; 'My::Schema::Book',
    { 'foreign.author_id' =&gt; 'self.id' }
  );
</pre>
<p class="Pp">A query like:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  $author_rs-&gt;search_related('books')-&gt;next
</pre>
<p class="Pp">will result in the following
    <span class="Li">&quot;JOIN&quot;</span> clause:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  ... FROM author me LEFT JOIN book books ON books.author_id = me.id ...
</pre>
<p class="Pp">This describes a relationship between the
    <span class="Li">&quot;Author&quot;</span> table and the
    <span class="Li">&quot;Book&quot;</span> table where the
    <span class="Li">&quot;Book&quot;</span> table has a column
    <span class="Li">&quot;author_id&quot;</span> containing the ID value of the
    <span class="Li">&quot;Author&quot;</span>.</p>
<p class="Pp">Similarly:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  My::Schema::Book-&gt;has_many(
    editions =&gt; 'My::Schema::Edition',
    {
      'foreign.publisher_id' =&gt; 'self.publisher_id',
      'foreign.type_id'      =&gt; 'self.type_id',
    }
  );

  ...

  $book_rs-&gt;search_related('editions')-&gt;next
</pre>
<p class="Pp">will result in the <span class="Li">&quot;JOIN&quot;</span>
    clause:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  ... FROM book me
      LEFT JOIN edition editions ON
           editions.publisher_id = me.publisher_id
       AND editions.type_id = me.type_id ...
</pre>
<p class="Pp">This describes the relationship from
    <span class="Li">&quot;Book&quot;</span> to
    <span class="Li">&quot;Edition&quot;</span>, where the
    <span class="Li">&quot;Edition&quot;</span> table refers to a publisher and
    a type (e.g. &quot;paperback&quot;):</p>
<p class="Pp">Multiple groups of simple equality conditions</p>
<p class="Pp">As is the default in SQL::Abstract, the key-value pairs will be
    <span class="Li">&quot;AND&quot;</span>ed in the resulting
    <span class="Li">&quot;JOIN&quot;</span> clause. An
    <span class="Li">&quot;OR&quot;</span> can be achieved with an arrayref. For
    example a condition like:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  My::Schema::Item-&gt;has_many(
    related_item_links =&gt; My::Schema::Item::Links,
    [
      { 'foreign.left_itemid'  =&gt; 'self.id' },
      { 'foreign.right_itemid' =&gt; 'self.id' },
    ],
  );
</pre>
<p class="Pp">will translate to the following
    <span class="Li">&quot;JOIN&quot;</span> clause:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
 ... FROM item me JOIN item_relations related_item_links ON
         related_item_links.left_itemid = me.id
      OR related_item_links.right_itemid = me.id ...
</pre>
<p class="Pp">This describes the relationship from
    <span class="Li">&quot;Item&quot;</span> to
    <span class="Li">&quot;Item::Links&quot;</span>, where
    <span class="Li">&quot;Item::Links&quot;</span> is a many-to-many linking
    table, linking items back to themselves in a peer fashion (without a
    &quot;parent-child&quot; designation)</p>
<p class="Pp">Custom join conditions</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  NOTE: The custom join condition specification mechanism is capable of
  generating JOIN clauses of virtually unlimited complexity. This may limit
  your ability to traverse some of the more involved relationship chains the
  way you expect, *and* may bring your RDBMS to its knees. Exercise care
  when declaring relationships as described here.
</pre>
<p class="Pp">To specify joins which describe more than a simple equality of
    column values, the custom join condition coderef syntax can be used. For
    example:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  My::Schema::Artist-&gt;has_many(
    cds_80s =&gt; 'My::Schema::CD',
    sub {
      my $args = shift;

      return {
        &quot;$args-&gt;{foreign_alias}.artist&quot; =&gt; { -ident =&gt; &quot;$args-&gt;{self_alias}.artistid&quot; },
        &quot;$args-&gt;{foreign_alias}.year&quot;   =&gt; { '&gt;', &quot;1979&quot;, '&lt;', &quot;1990&quot; },
      };
    }
  );

  ...

  $artist_rs-&gt;search_related('cds_80s')-&gt;next;
</pre>
<p class="Pp">will result in the <span class="Li">&quot;JOIN&quot;</span>
    clause:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  ... FROM artist me LEFT JOIN cd cds_80s ON
        cds_80s.artist = me.artistid
    AND cds_80s.year &lt; ?
    AND cds_80s.year &gt; ?
</pre>
<p class="Pp">with the bind values:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
   '1990', '1979'
</pre>
<p class="Pp"><span class="Li">&quot;$args-&gt;{foreign_alias}&quot;</span> and
    <span class="Li">&quot;$args-&gt;{self_alias}&quot;</span> are supplied the
    same values that would be otherwise substituted for
    <span class="Li">&quot;foreign&quot;</span> and
    <span class="Li">&quot;self&quot;</span> in the simple hashref syntax
  case.</p>
<p class="Pp">The coderef is expected to return a valid SQL::Abstract
    query-structure, just like what one would supply as the first argument to
    &quot;search&quot; in DBIx::Class::ResultSet. The return value will be
    passed directly to SQL::Abstract and the resulting SQL will be used verbatim
    as the <span class="Li">&quot;ON&quot;</span> clause of the
    <span class="Li">&quot;JOIN&quot;</span> statement associated with this
    relationship.</p>
<p class="Pp">While every coderef-based condition must return a valid
    <span class="Li">&quot;ON&quot;</span> clause, it may elect to additionally
    return a simplified <b>optional</b> join-free condition consisting of a
    hashref with <b>all keys being fully qualified names of columns</b>
    <b>declared on the corresponding result source</b>. This boils down to two
    scenarios:</p>
<ul class="Bl-bullet">
  <li>When relationship resolution is invoked after
      <span class="Li">&quot;$result-&gt;$rel_name&quot;</span>, as opposed to
      <span class="Li">&quot;$rs-&gt;related_resultset($rel_name)&quot;</span>,
      the <span class="Li">$result</span> object is passed to the coderef as
      <span class="Li">&quot;$args-&gt;{self_result_object}&quot;</span>.</li>
  <li>Alternatively when the user-space invokes resolution via
      <span class="Li">&quot;$result-&gt;set_from_related( $rel_name =&gt;
      $foreign_values_or_object )&quot;</span>, the corresponding data is passed
      to the coderef as
      <span class="Li">&quot;$args-&gt;{foreign_values}&quot;</span>,
      <b>always</b> in the form of a hashref. If a foreign result object is
      supplied (which is valid usage of &quot;set_from_related&quot;), its
      values will be extracted into hashref form by calling get_columns.</li>
</ul>
<p class="Pp">Note that the above scenarios are mutually exclusive, that is you
    will be supplied none or only one of
    <span class="Li">&quot;self_result_object&quot;</span> and
    <span class="Li">&quot;foreign_values&quot;</span>. In other words if you
    define your condition coderef as:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  sub {
    my $args = shift;

    return (
      {
        &quot;$args-&gt;{foreign_alias}.artist&quot; =&gt; { -ident =&gt; &quot;$args-&gt;{self_alias}.artistid&quot; },
        &quot;$args-&gt;{foreign_alias}.year&quot;   =&gt; { '&gt;', &quot;1979&quot;, '&lt;', &quot;1990&quot; },
      },
      ! $args-&gt;{self_result_object} ? () : {
        &quot;$args-&gt;{foreign_alias}.artist&quot; =&gt; $args-&gt;{self_result_object}-&gt;artistid,
        &quot;$args-&gt;{foreign_alias}.year&quot;   =&gt; { '&gt;', &quot;1979&quot;, '&lt;', &quot;1990&quot; },
      },
      ! $args-&gt;{foreign_values} ? () : {
        &quot;$args-&gt;{self_alias}.artistid&quot; =&gt; $args-&gt;{foreign_values}{artist},
      }
    );
  }
</pre>
<p class="Pp">Then this code:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    my $artist = $schema-&gt;resultset(&quot;Artist&quot;)-&gt;find({ id =&gt; 4 });
    $artist-&gt;cds_80s-&gt;all;
</pre>
<p class="Pp">Can skip a <span class="Li">&quot;JOIN&quot;</span> altogether and
    instead produce:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    SELECT cds_80s.cdid, cds_80s.artist, cds_80s.title, cds_80s.year, cds_80s.genreid, cds_80s.single_track
      FROM cd cds_80s
      WHERE cds_80s.artist = ?
        AND cds_80s.year &lt; ?
        AND cds_80s.year &gt; ?
</pre>
<p class="Pp">With the bind values:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    '4', '1990', '1979'
</pre>
<p class="Pp">While this code:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    my $cd = $schema-&gt;resultset(&quot;CD&quot;)-&gt;search({ artist =&gt; 1 }, { rows =&gt; 1 })-&gt;single;
    my $artist = $schema-&gt;resultset(&quot;Artist&quot;)-&gt;new({});
    $artist-&gt;set_from_related('cds_80s');
</pre>
<p class="Pp">Will properly set the
    <span class="Li">&quot;$artist-&gt;artistid&quot;</span> field of this new
    object to <span class="Li">1</span></p>
<p class="Pp">Note that in order to be able to use &quot;set_from_related&quot;
    (and by extension <span class="Li">$result</span>-&gt;create_related), the
    returned join free condition <b>must</b> contain only plain
    values/deflatable objects. For instance the
    <span class="Li">&quot;year&quot;</span> constraint in the above example
    prevents the relationship from being used to create related objects using
    <span class="Li">&quot;$artst-&gt;create_related( cds_80s =&gt; { title
    =&gt; 'blah' } )&quot;</span> (an exception will be thrown).</p>
<p class="Pp">In order to allow the user to go truly crazy when generating a
    custom <span class="Li">&quot;ON&quot;</span> clause, the
    <span class="Li">$args</span> hashref passed to the subroutine contains some
    extra metadata. Currently the supplied coderef is executed as:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  $relationship_info-&gt;{cond}-&gt;({
    self_resultsource   =&gt; The resultsource instance on which rel_name is registered
    rel_name            =&gt; The relationship name (does *NOT* always match foreign_alias)

    self_alias          =&gt; The alias of the invoking resultset
    foreign_alias       =&gt; The alias of the to-be-joined resultset (does *NOT* always match rel_name)

    # only one of these (or none at all) will ever be supplied to aid in the
    # construction of a join-free condition

    self_result_object  =&gt; The invocant *object* itself in case of a call like
                           $result_object-&gt;$rel_name( ... )

    foreign_values      =&gt; A *hashref* of related data: may be passed in directly or
                           derived via -&gt;get_columns() from a related object in case of
                           $result_object-&gt;set_from_related( $rel_name, $foreign_result_object )

    # deprecated inconsistent names, will be forever available for legacy code
    self_rowobj         =&gt; Old deprecated slot for self_result_object
    foreign_relname     =&gt; Old deprecated slot for rel_name
  });
</pre>
<p class="Pp"><i>attributes</i></p>
<p class="Pp">The standard ResultSet attributes may be used as relationship
    attributes. In particular, the 'where' attribute is useful for filtering
    relationships:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
     __PACKAGE__-&gt;has_many( 'valid_users', 'MyApp::Schema::User',
        { 'foreign.user_id' =&gt; 'self.user_id' },
        { where =&gt; { valid =&gt; 1 } }
    );
</pre>
<p class="Pp">The following attributes are also valid:</p>
<dl class="Bl-tag">
  <dt>join_type</dt>
  <dd>Explicitly specifies the type of join to use in the relationship. Any SQL
      join type is valid, e.g. <span class="Li">&quot;LEFT&quot;</span> or
      <span class="Li">&quot;RIGHT&quot;</span>. It will be placed in the SQL
      command immediately before <span class="Li">&quot;JOIN&quot;</span>.</dd>
  <dt>proxy =&gt; $column | \@columns | \%column</dt>
  <dd>The 'proxy' attribute can be used to retrieve values, and to perform
      updates if the relationship has 'cascade_update' set. The 'might_have' and
      'has_one' relationships have this set by default; if you want a proxy to
      update across a 'belongs_to' relationship, you must set the attribute
      yourself.</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>\@columns</dt>
  <dd>An arrayref containing a list of accessors in the foreign class to create
      in the main class. If, for example, you do the following:
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  MyApp::Schema::CD-&gt;might_have(liner_notes =&gt; 'MyApp::Schema::LinerNotes',
    undef, {
      proxy =&gt; [ qw/notes/ ],
    });
    </pre>
    <p class="Pp">Then, assuming MyApp::Schema::LinerNotes has an accessor named
        notes, you can do:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  my $cd = MyApp::Schema::CD-&gt;find(1);
  $cd-&gt;notes('Notes go here'); # set notes -- LinerNotes object is
                               # created if it doesn't exist
    </pre>
    <p class="Pp">For a 'belongs_to relationship, note the 'cascade_update':</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  MyApp::Schema::Track-&gt;belongs_to( cd =&gt; 'MyApp::Schema::CD', 'cd,
      { proxy =&gt; ['title'], cascade_update =&gt; 1 }
  );
  $track-&gt;title('New Title');
  $track-&gt;update; # updates title in CD
    </pre>
  </dd>
  <dt>\%column</dt>
  <dd>A hashref where each key is the accessor you want installed in the main
      class, and its value is the name of the original in the foreign class.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  MyApp::Schema::Track-&gt;belongs_to( cd =&gt; 'MyApp::Schema::CD', 'cd', {
      proxy =&gt; { cd_title =&gt; 'title' },
  });
    </pre>
    <p class="Pp">This will create an accessor named
        <span class="Li">&quot;cd_title&quot;</span> on the
        <span class="Li">$track</span> result object.</p>
  </dd>
</dl>
</div>
<div class="Bd-indent">
<p class="Pp">NOTE: you can pass a nested struct too, for example:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  MyApp::Schema::Track-&gt;belongs_to( cd =&gt; 'MyApp::Schema::CD', 'cd', {
    proxy =&gt; [ 'year', { cd_title =&gt; 'title' } ],
  });
</pre>
</div>
<dl class="Bl-tag">
  <dt>accessor</dt>
  <dd>Specifies the type of accessor that should be created for the
      relationship. Valid values are <span class="Li">&quot;single&quot;</span>
      (for when there is only a single related object),
      <span class="Li">&quot;multi&quot;</span> (when there can be many), and
      <span class="Li">&quot;filter&quot;</span> (for when there is a single
      related object, but you also want the relationship accessor to double as a
      column accessor). For <span class="Li">&quot;multi&quot;</span> accessors,
      an add_to_* method is also created, which calls
      <span class="Li">&quot;create_related&quot;</span> for the
    relationship.</dd>
  <dt>is_foreign_key_constraint</dt>
  <dd>If you are using SQL::Translator to create SQL for you and you find that
      it is creating constraints where it shouldn't, or not creating them where
      it should, set this attribute to a true or false value to override the
      detection of when to create constraints.</dd>
  <dt>cascade_copy</dt>
  <dd>If <span class="Li">&quot;cascade_copy&quot;</span> is true on a
      <span class="Li">&quot;has_many&quot;</span> relationship for an object,
      then when you copy the object all the related objects will be copied too.
      To turn this behaviour off, pass <span class="Li">&quot;cascade_copy =&gt;
      0&quot;</span> in the <span class="Li">$attr</span> hashref.
    <p class="Pp">The behaviour defaults to <span class="Li">&quot;cascade_copy
        =&gt; 1&quot;</span> for <span class="Li">&quot;has_many&quot;</span>
        relationships.</p>
  </dd>
  <dt>cascade_delete</dt>
  <dd>By default, DBIx::Class cascades deletes across
      <span class="Li">&quot;has_many&quot;</span>,
      <span class="Li">&quot;has_one&quot;</span> and
      <span class="Li">&quot;might_have&quot;</span> relationships. You can
      disable this behaviour on a per-relationship basis by supplying
      <span class="Li">&quot;cascade_delete =&gt; 0&quot;</span> in the
      relationship attributes.
    <p class="Pp">The cascaded operations are performed after the requested
        delete, so if your database has a constraint on the relationship, it
        will have deleted/updated the related records or raised an exception
        before DBIx::Class gets to perform the cascaded operation.</p>
  </dd>
  <dt>cascade_update</dt>
  <dd>By default, DBIx::Class cascades updates across
      <span class="Li">&quot;has_one&quot;</span> and
      <span class="Li">&quot;might_have&quot;</span> relationships. You can
      disable this behaviour on a per-relationship basis by supplying
      <span class="Li">&quot;cascade_update =&gt; 0&quot;</span> in the
      relationship attributes.
    <p class="Pp">The <span class="Li">&quot;belongs_to&quot;</span>
        relationship does not update across relationships by default, so if you
        have a 'proxy' attribute on a belongs_to and want to use 'update' on it,
        you must set <span class="Li">&quot;cascade_update =&gt;
      1&quot;</span>.</p>
    <p class="Pp">This is not a RDMS style cascade update - it purely means that
        when an object has update called on it, all the related objects also
        have update called. It will not change foreign keys automatically - you
        must arrange to do this yourself.</p>
  </dd>
  <dt>on_delete / on_update</dt>
  <dd>If you are using SQL::Translator to create SQL for you, you can use these
      attributes to explicitly set the desired <span class="Li">&quot;ON
      DELETE&quot;</span> or <span class="Li">&quot;ON UPDATE&quot;</span>
      constraint type. If not supplied the SQLT parser will attempt to infer the
      constraint type by interrogating the attributes of the <b>opposite</b>
      relationship. For any 'multi' relationship with
      <span class="Li">&quot;cascade_delete =&gt; 1&quot;</span>, the
      corresponding belongs_to relationship will be created with an
      <span class="Li">&quot;ON DELETE CASCADE&quot;</span> constraint. For any
      relationship bearing <span class="Li">&quot;cascade_copy =&gt;
      1&quot;</span> the resulting belongs_to constraint will be
      <span class="Li">&quot;ON UPDATE CASCADE&quot;</span>. If you wish to
      disable this autodetection, and just use the RDBMS' default constraint
      type, pass <span class="Li">&quot;on_delete =&gt; undef&quot;</span> or
      <span class="Li">&quot;on_delete =&gt; ''&quot;</span>, and the same for
      <span class="Li">&quot;on_update&quot;</span> respectively.</dd>
  <dt>is_deferrable</dt>
  <dd>Tells SQL::Translator that the foreign key constraint it creates should be
      deferrable. In other words, the user may request that the constraint be
      ignored until the end of the transaction. Currently, only the PostgreSQL
      producer actually supports this.</dd>
  <dt>add_fk_index</dt>
  <dd>Tells SQL::Translator to add an index for this constraint. Can also be
      specified globally in the args to &quot;deploy&quot; in
      DBIx::Class::Schema or &quot;create_ddl_dir&quot; in DBIx::Class::Schema.
      Default is on, set to 0 to disable.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="register_relationship"><a class="permalink" href="#register_relationship">register_relationship</a></h2>
<dl class="Bl-tag">
  <dt>Arguments: $rel_name, $rel_info</dt>
  <dd></dd>
</dl>
<p class="Pp">Registers a relationship on the class. This is called internally
    by DBIx::Class::ResultSourceProxy to set up Accessors and Proxies.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="related_resultset"><a class="permalink" href="#related_resultset">related_resultset</a></h2>
<dl class="Bl-tag">
  <dt>Arguments: $rel_name</dt>
  <dd></dd>
  <dt>Return Value: $related_resultset</dt>
  <dd></dd>
</dl>
<p class="Pp"><span class="Li"></span></p>
<pre>
  $rs = $cd-&gt;related_resultset('artist');
</pre>
<p class="Pp">Returns a DBIx::Class::ResultSet for the relationship named
    <span class="Li">$rel_name</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="$relationship_accessor"><a class="permalink" href="#$relationship_accessor">$relationship_accessor</a></h2>
<dl class="Bl-tag">
  <dt>Arguments: none</dt>
  <dd></dd>
  <dt>Return Value: $result | $related_resultset | undef</dt>
  <dd></dd>
</dl>
<p class="Pp"><span class="Li"></span></p>
<pre>
  # These pairs do the same thing
  $result = $cd-&gt;related_resultset('artist')-&gt;single;  # has_one relationship
  $result = $cd-&gt;artist;
  $rs = $cd-&gt;related_resultset('tracks');           # has_many relationship
  $rs = $cd-&gt;tracks;
</pre>
<p class="Pp">This is the recommended way to traverse through relationships,
    based on the &quot;accessor&quot; name given in the relationship
  definition.</p>
<p class="Pp">This will return either a Result or a ResultSet, depending on if
    the relationship is <span class="Li">&quot;single&quot;</span> (returns only
    one row) or <span class="Li">&quot;multi&quot;</span> (returns many rows).
    The method may also return <span class="Li">&quot;undef&quot;</span> if the
    relationship doesn't exist for this instance (like in the case of
    <span class="Li">&quot;might_have&quot;</span> relationships).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="search_related"><a class="permalink" href="#search_related">search_related</a></h2>
<dl class="Bl-tag">
  <dt>Arguments: $rel_name, $cond?, \%attrs?</dt>
  <dd></dd>
  <dt>Return Value: $resultset (scalar context) | @result_objs (list
    context)</dt>
  <dd></dd>
</dl>
<p class="Pp">Run a search on a related resultset. The search will be restricted
    to the results represented by the DBIx::Class::ResultSet it was called
  upon.</p>
<p class="Pp">See &quot;search_related&quot; in DBIx::Class::ResultSet for more
    information.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="search_related_rs"><a class="permalink" href="#search_related_rs">search_related_rs</a></h2>
This method works exactly the same as search_related, except that it guarantees
  a resultset, even in list context.
</section>
<section class="Ss">
<h2 class="Ss" id="count_related"><a class="permalink" href="#count_related">count_related</a></h2>
<dl class="Bl-tag">
  <dt>Arguments: $rel_name, $cond?, \%attrs?</dt>
  <dd></dd>
  <dt>Return Value: $count</dt>
  <dd></dd>
</dl>
<p class="Pp">Returns the count of all the rows in the related resultset,
    restricted by the current result or where conditions.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="new_related"><a class="permalink" href="#new_related">new_related</a></h2>
<dl class="Bl-tag">
  <dt>Arguments: $rel_name, \%col_data</dt>
  <dd></dd>
  <dt>Return Value: $result</dt>
  <dd></dd>
</dl>
<p class="Pp">Create a new result object of the related foreign class. It will
    magically set any foreign key columns of the new object to the related
    primary key columns of the source object for you. The newly created result
    will not be saved into your storage until you call &quot;insert&quot; in
    DBIx::Class::Row on it.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="create_related"><a class="permalink" href="#create_related">create_related</a></h2>
<dl class="Bl-tag">
  <dt>Arguments: $rel_name, \%col_data</dt>
  <dd></dd>
  <dt>Return Value: $result</dt>
  <dd></dd>
</dl>
<p class="Pp"><span class="Li"></span></p>
<pre>
  my $result = $obj-&gt;create_related($rel_name, \%col_data);
</pre>
<p class="Pp">Creates a new result object, similarly to new_related, and also
    inserts the result's data into your storage medium. See the distinction
    between <span class="Li">&quot;create&quot;</span> and
    <span class="Li">&quot;new&quot;</span> in DBIx::Class::ResultSet for
    details.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="find_related"><a class="permalink" href="#find_related">find_related</a></h2>
<dl class="Bl-tag">
  <dt>Arguments: $rel_name, \%col_data | @pk_values, { key =&gt;
    $unique_constraint, %attrs }?</dt>
  <dd></dd>
  <dt>Return Value: $result | undef</dt>
  <dd></dd>
</dl>
<p class="Pp"><span class="Li"></span></p>
<pre>
  my $result = $obj-&gt;find_related($rel_name, \%col_data);
</pre>
<p class="Pp">Attempt to find a related object using its primary key or unique
    constraints. See &quot;find&quot; in DBIx::Class::ResultSet for details.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="find_or_new_related"><a class="permalink" href="#find_or_new_related">find_or_new_related</a></h2>
<dl class="Bl-tag">
  <dt>Arguments: $rel_name, \%col_data, { key =&gt; $unique_constraint, %attrs
    }?</dt>
  <dd></dd>
  <dt>Return Value: $result</dt>
  <dd></dd>
</dl>
<p class="Pp">Find a result object of a related class. See
    &quot;find_or_new&quot; in DBIx::Class::ResultSet for details.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="find_or_create_related"><a class="permalink" href="#find_or_create_related">find_or_create_related</a></h2>
<dl class="Bl-tag">
  <dt>Arguments: $rel_name, \%col_data, { key =&gt; $unique_constraint, %attrs
    }?</dt>
  <dd></dd>
  <dt>Return Value: $result</dt>
  <dd></dd>
</dl>
<p class="Pp">Find or create a result object of a related class. See
    &quot;find_or_create&quot; in DBIx::Class::ResultSet for details.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="update_or_create_related"><a class="permalink" href="#update_or_create_related">update_or_create_related</a></h2>
<dl class="Bl-tag">
  <dt>Arguments: $rel_name, \%col_data, { key =&gt; $unique_constraint, %attrs
    }?</dt>
  <dd></dd>
  <dt>Return Value: $result</dt>
  <dd></dd>
</dl>
<p class="Pp">Update or create a result object of a related class. See
    &quot;update_or_create&quot; in DBIx::Class::ResultSet for details.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="set_from_related"><a class="permalink" href="#set_from_related">set_from_related</a></h2>
<dl class="Bl-tag">
  <dt>Arguments: $rel_name, $result</dt>
  <dd></dd>
  <dt>Return Value: not defined</dt>
  <dd></dd>
</dl>
<p class="Pp"><span class="Li"></span></p>
<pre>
  $book-&gt;set_from_related('author', $author_obj);
  $book-&gt;author($author_obj);                      ## same thing
</pre>
<p class="Pp">Set column values on the current object, using related values from
    the given related object. This is used to associate previously separate
    objects, for example, to set the correct author for a book, find the Author
    object, then call set_from_related on the book.</p>
<p class="Pp">This is called internally when you pass existing objects as values
    to &quot;create&quot; in DBIx::Class::ResultSet, or pass an object to a
    belongs_to accessor.</p>
<p class="Pp">The columns are only set in the local copy of the object, call
    update to update them in the storage.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="update_from_related"><a class="permalink" href="#update_from_related">update_from_related</a></h2>
<dl class="Bl-tag">
  <dt>Arguments: $rel_name, $result</dt>
  <dd></dd>
  <dt>Return Value: not defined</dt>
  <dd></dd>
</dl>
<p class="Pp"><span class="Li"></span></p>
<pre>
  $book-&gt;update_from_related('author', $author_obj);
</pre>
<p class="Pp">The same as &quot;set_from_related&quot;, but the changes are
    immediately updated in storage.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="delete_related"><a class="permalink" href="#delete_related">delete_related</a></h2>
<dl class="Bl-tag">
  <dt>Arguments: $rel_name, $cond?, \%attrs?</dt>
  <dd></dd>
  <dt>Return Value: $underlying_storage_rv</dt>
  <dd></dd>
</dl>
<p class="Pp">Delete any related row, subject to the given conditions.
    Internally, this calls:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  $self-&gt;search_related(@_)-&gt;delete
</pre>
<p class="Pp">And returns the result of that.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="add_to_$rel"><a class="permalink" href="#add_to_$rel">add_to_$rel</a></h2>
<b>Currently only available for </b><b>&quot;has_many&quot;</b><b>,
  </b><b>&quot;many_to_many&quot;</b><b> and 'multi' type</b>
  <b>relationships.</b>
<p class="Pp"><i>has_many / multi</i></p>
<dl class="Bl-tag">
  <dt>Arguments: \%col_data</dt>
  <dd></dd>
  <dt>Return Value: $result</dt>
  <dd></dd>
</dl>
<p class="Pp">Creates/inserts a new result object. Internally, this calls:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  $self-&gt;create_related($rel, @_)
</pre>
<p class="Pp">And returns the result of that.</p>
<p class="Pp"><i>many_to_many</i></p>
<dl class="Bl-tag">
  <dt>Arguments: (\%col_data | $result), \%link_col_data?</dt>
  <dd></dd>
  <dt>Return Value: $result</dt>
  <dd></dd>
</dl>
<p class="Pp"><span class="Li"></span></p>
<pre>
  my $role = $schema-&gt;resultset('Role')-&gt;find(1);
  $actor-&gt;add_to_roles($role);
      # creates a My::DBIC::Schema::ActorRoles linking table result object

  $actor-&gt;add_to_roles({ name =&gt; 'lead' }, { salary =&gt; 15_000_000 });
      # creates a new My::DBIC::Schema::Role result object and the linking table
      # object with an extra column in the link
</pre>
<p class="Pp">Adds a linking table object. If the first argument is a hash
    reference, the related object is created first with the column values in the
    hash. If an object reference is given, just the linking table object is
    created. In either case, any additional column values for the linking table
    object can be specified in
    <span class="Li">&quot;\%link_col_data&quot;</span>.</p>
<p class="Pp">See &quot;many_to_many&quot; in DBIx::Class::Relationship for
    additional details.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="set_$rel"><a class="permalink" href="#set_$rel">set_$rel</a></h2>
<b>Currently only available for </b><b>&quot;many_to_many&quot;</b><b>
  relationships.</b>
<dl class="Bl-tag">
  <dt>Arguments: (\@hashrefs_of_col_data | \@result_objs), $link_vals?</dt>
  <dd></dd>
  <dt>Return Value: not defined</dt>
  <dd></dd>
</dl>
<p class="Pp"><span class="Li"></span></p>
<pre>
  my $actor = $schema-&gt;resultset('Actor')-&gt;find(1);
  my @roles = $schema-&gt;resultset('Role')-&gt;search({ role =&gt;
     { '-in' =&gt; ['Fred', 'Barney'] } } );

  $actor-&gt;set_roles(\@roles);
     # Replaces all of $actor's previous roles with the two named

  $actor-&gt;set_roles(\@roles, { salary =&gt; 15_000_000 });
     # Sets a column in the link table for all roles
</pre>
<p class="Pp">Replace all the related objects with the given reference to a list
    of objects. This does a <span class="Li">&quot;delete&quot;</span> <b>on the
    link table resultset</b> to remove the association between the current
    object and all related objects, then calls
    <span class="Li">&quot;add_to_$rel&quot;</span> repeatedly to link all the
    new objects.</p>
<p class="Pp">Note that this means that this method will <b>not</b> delete any
    objects in the table on the right side of the relation, merely that it will
    delete the link between them.</p>
<p class="Pp">Due to a mistake in the original implementation of this method, it
    will also accept a list of objects or hash references. This is
    <b>deprecated</b> and will be removed in a future version.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="remove_from_$rel"><a class="permalink" href="#remove_from_$rel">remove_from_$rel</a></h2>
<b>Currently only available for </b><b>&quot;many_to_many&quot;</b><b>
  relationships.</b>
<dl class="Bl-tag">
  <dt>Arguments: $result</dt>
  <dd></dd>
  <dt>Return Value: not defined</dt>
  <dd></dd>
</dl>
<p class="Pp"><span class="Li"></span></p>
<pre>
  my $role = $schema-&gt;resultset('Role')-&gt;find(1);
  $actor-&gt;remove_from_roles($role);
      # removes $role's My::DBIC::Schema::ActorRoles linking table result object
</pre>
<p class="Pp">Removes the link between the current object and the related
    object. Note that the related object itself won't be deleted unless you call
    -&gt;<b>delete()</b> on it. This method just removes the link between the
    two objects.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="FURTHER_QUESTIONS?"><a class="permalink" href="#FURTHER_QUESTIONS?">FURTHER
  QUESTIONS?</a></h1>
Check the list of additional DBIC resources.
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT_AND_LICENSE"><a class="permalink" href="#COPYRIGHT_AND_LICENSE">COPYRIGHT
  AND LICENSE</a></h1>
This module is free software copyright by the DBIx::Class (DBIC) authors. You
  can redistribute it and/or modify it under the same terms as the DBIx::Class
  library.
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2018-01-29</td>
    <td class="foot-os">perl v5.30.2</td>
  </tr>
</table>
</body>
</html>
