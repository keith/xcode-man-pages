<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.10 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>install::TempContent::Objects::mod_perl-2.0.9::docs::api::APR::Table(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">install::TempContent::Objects::mod_perl-2.0.9::docs::api::APR::Table(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">install::TempContent::Objects::mod_perl-2.0.9::docs::api::APR::Table(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
APR::Table - Perl API for manipulating APR opaque string-content tables
</section>
<section class="Sh">
<h1 class="Sh" id="Synopsis"><a class="permalink" href="#Synopsis">Synopsis</a></h1>
<span class="Li"></span>
<pre>
  use APR::Table ();
  
  $table = APR::Table::make($pool, $nelts);
  $table_copy = $table-&gt;copy($pool);
  
  $table-&gt;clear();
  
  $table-&gt;set($key =&gt; $val);
  $table-&gt;unset($key);
  $table-&gt;add($key, $val);
  
  $val = $table-&gt;get($key);
  @val = $table-&gt;get($key);
  
  $table-&gt;merge($key =&gt; $val);
  
  use APR::Const -compile qw(:table);
  $table_overlay = $table_base-&gt;overlay($table_overlay, $pool);
  $table_overlay-&gt;compress(APR::Const::OVERLAP_TABLES_MERGE);
  
  $table_a-&gt;overlap($table_b, APR::Const::OVERLAP_TABLES_SET);
  
  $table-&gt;do(sub {print &quot;key $_[0], value $_[1]\n&quot;}, @valid_keys);
  
  #Tied Interface
  $value = $table-&gt;{$key};
  $table-&gt;{$key} = $value;
  print &quot;got it&quot; if exists $table-&gt;{$key};
  
  foreach my $key (keys %{$table}) {
      print &quot;$key = $table-&gt;{$key}\n&quot;;
  }
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="Description"><a class="permalink" href="#Description">Description</a></h1>
<span class="Li">&quot;APR::Table&quot;</span> allows its users to manipulate
  opaque string-content tables.
<p class="Pp">On the C level the &quot;opaque string-content&quot; means: you
    can put in '\0'-terminated strings and whatever you put in your get out.</p>
<p class="Pp">On the Perl level that means that we convert scalars into strings
    and store those strings. Any special information that was in the Perl scalar
    is not stored. So for example if a scalar was marked as utf8, tainted or
    tied, that information is not stored. When you get the data back as a Perl
    scalar you get only the string.</p>
<p class="Pp">The table's structure is somewhat similar to the Perl's hash
    structure, but allows multiple values for the same key. An access to the
    records stored in the table always requires a key.</p>
<p class="Pp">The key-value pairs are stored in the order they are added.</p>
<p class="Pp">The keys are case-insensitive.</p>
<p class="Pp">However as of the current implementation if more than value for
    the same key is requested, the whole table is lineary searched, which is
    very inefficient unless the table is very small.</p>
<p class="Pp"><span class="Li">&quot;APR::Table&quot;</span> provides a TIE
    Interface.</p>
<p class="Pp">See <i>apr/include/apr_tables.h</i> in ASF's <i>apr</i> project
    for low level details.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="API"><a class="permalink" href="#API">API</a></h1>
<span class="Li">&quot;APR::Table&quot;</span> provides the following functions
  and/or methods:
<section class="Ss">
<h2 class="Ss" id="_add_"><a class="permalink" href="#_add_">&quot;add&quot;</a></h2>
Add data to a table, regardless of whether there is another element with the
  same key.
<p class="Pp"><span class="Li"></span></p>
<pre>
  $table-&gt;add($key, $val);
</pre>
<dl class="Bl-tag">
  <dt>obj: $table ( &quot;APR::Table object&quot; )</dt>
  <dd>The table to add to.</dd>
  <dt>arg1: $key ( string )</dt>
  <dd>The key to use.</dd>
  <dt>arg2: $val ( string )</dt>
  <dd>The value to add.</dd>
  <dt>ret: no return value</dt>
  <dd></dd>
  <dt>since: 2.0.00</dt>
  <dd></dd>
</dl>
<p class="Pp">When adding data, this function makes a copy of both the key and
    the value.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_clear_"><a class="permalink" href="#_clear_">&quot;clear&quot;</a></h2>
Delete all of the elements from a table.
<p class="Pp"><span class="Li"></span></p>
<pre>
  $table-&gt;clear();
</pre>
<dl class="Bl-tag">
  <dt>obj: $table ( &quot;APR::Table object&quot; )</dt>
  <dd>The table to clear.</dd>
  <dt>ret: no return value</dt>
  <dd></dd>
  <dt>since: 2.0.00</dt>
  <dd></dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="_compress_"><a class="permalink" href="#_compress_">&quot;compress&quot;</a></h2>
Eliminate redundant entries in a table by either overwriting or merging
  duplicates:
<p class="Pp"><span class="Li"></span></p>
<pre>
  $table-&gt;compress($flags);
</pre>
<dl class="Bl-tag">
  <dt>obj: $table ( &quot;APR::Table object&quot; )</dt>
  <dd>The table to compress.</dd>
  <dt>arg1: $flags (&quot;APR::Const constant&quot;)</dt>
  <dd><span class="Li"></span>
    <pre>
  APR::Const::OVERLAP_TABLES_MERGE -- to merge
  APR::Const::OVERLAP_TABLES_SET   -- to overwrite
    </pre>
  </dd>
  <dt>ret: no return value</dt>
  <dd></dd>
  <dt>since: 2.0.00</dt>
  <dd></dd>
</dl>
<p class="Pp">Converts multi-valued keys in <span class="Li">$table</span> into
    single-valued keys. This function takes duplicate table entries and flattens
    them into a single entry. The flattening behavior is controlled by the
    (mandatory) <span class="Li">$flags</span> argument.</p>
<p class="Pp">When <span class="Li">$flags</span> ==
    <span class="Li">&quot;APR::Const::OVERLAP_TABLES_SET&quot;</span>, each key
    will be set to the last value seen for that key. For example, given
    key/value pairs 'foo =&gt; bar' and 'foo =&gt; baz', 'foo' would have a
    final value of 'baz' after compression -- the 'bar' value would be lost.</p>
<p class="Pp">When <span class="Li">$flags</span> ==
    <span class="Li">&quot;APR::Const::OVERLAP_TABLES_MERGE&quot;</span>,
    multiple values for the same key are flattened into a comma-separated list.
    Given key/value pairs 'foo =&gt; bar' and 'foo =&gt; baz', 'foo' would have
    a final value of 'bar, baz' after compression.</p>
<p class="Pp">Access the constants via:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  use APR::Const -compile qw(:table);
</pre>
<p class="Pp">or an explicit:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  use APR::Const -compile qw(OVERLAP_TABLES_SET OVERLAP_TABLES_MERGE);
</pre>
<p class="Pp"><span class="Li">&quot;compress()&quot;</span> combined with
    <span class="Li">&quot;overlay()&quot;</span> does the same thing as
    <span class="Li">&quot;overlap()&quot;</span>.</p>
<p class="Pp">Examples:</p>
<ul class="Bl-bullet">
  <li><span class="Li">&quot;APR::Const::OVERLAP_TABLES_SET&quot;</span>
    <p class="Pp">Start with table <span class="Li">$table</span>:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  foo =&gt; &quot;one&quot;
  foo =&gt; &quot;two&quot;
  foo =&gt; &quot;three&quot;
  bar =&gt; &quot;beer&quot;
    </pre>
    <p class="Pp">which is done by:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  use APR::Const    -compile =&gt; ':table';
  my $table = APR::Table::make($r-&gt;pool, TABLE_SIZE);
  
  $table-&gt;set(bar =&gt; 'beer');
  $table-&gt;set(foo =&gt; 'one');
  $table-&gt;add(foo =&gt; 'two');
  $table-&gt;add(foo =&gt; 'three');
    </pre>
    <p class="Pp">Now compress it using
        <span class="Li">&quot;APR::Const::OVERLAP_TABLES_SET&quot;</span>:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  $table-&gt;compress(APR::Const::OVERLAP_TABLES_SET);
    </pre>
    <p class="Pp">Now table <span class="Li">$table</span> contains:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  foo =&gt; &quot;three&quot;
  bar =&gt; &quot;beer&quot;
    </pre>
    <p class="Pp">The value <i>three</i> for the key <i>foo</i>, that was added
        last, took over the other values.</p>
  </li>
  <li><span class="Li">&quot;APR::Const::OVERLAP_TABLES_MERGE&quot;</span>
    <p class="Pp">Start with table <span class="Li">$table</span>:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  foo =&gt; &quot;one&quot;
  foo =&gt; &quot;two&quot;
  foo =&gt; &quot;three&quot;
  bar =&gt; &quot;beer&quot;
    </pre>
    <p class="Pp">as in the previous example, now compress it using
        <span class="Li">&quot;APR::Const::OVERLAP_TABLES_MERGE&quot;</span>:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  $table-&gt;compress(APR::Const::OVERLAP_TABLES_MERGE);
    </pre>
    <p class="Pp">Now table <span class="Li">$table</span> contains:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  foo =&gt; &quot;one, two, three&quot;
  bar =&gt; &quot;beer&quot;
    </pre>
    <p class="Pp">All the values for the same key were merged into one
      value.</p>
  </li>
</ul>
</section>
<section class="Ss">
<h2 class="Ss" id="_copy_"><a class="permalink" href="#_copy_">&quot;copy&quot;</a></h2>
Create a new table and copy another table into it.
<p class="Pp"><span class="Li"></span></p>
<pre>
  $table_copy = $table-&gt;copy($p);
</pre>
<dl class="Bl-tag">
  <dt>obj: $table ( &quot;APR::Table object&quot; )</dt>
  <dd>The table to copy.</dd>
  <dt>arg1: $p ( &quot;APR::Pool object&quot; )</dt>
  <dd>The pool to allocate the new table out of.</dd>
  <dt>ret: $table_copy ( &quot;APR::Table object&quot; )</dt>
  <dd>A copy of the table passed in.</dd>
  <dt>since: 2.0.00</dt>
  <dd></dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="_do_"><a class="permalink" href="#_do_">&quot;do&quot;</a></h2>
Iterate over all the elements of the table, invoking provided subroutine for
  each element. The subroutine gets passed as argument, a key-value pair.
<p class="Pp"><span class="Li"></span></p>
<pre>
  $table-&gt;do(sub {...}, @filter);
</pre>
<dl class="Bl-tag">
  <dt>obj: $table ( &quot;APR::Table object&quot; )</dt>
  <dd>The table to operate on.</dd>
  <dt>arg1: $sub ( CODE ref/string )</dt>
  <dd>A subroutine reference or name to be called on each item in the table. The
      subroutine can abort the iteration by returning 0 and should always return
      1 otherwise.</dd>
  <dt>opt arg3: @filter ( ARRAY )</dt>
  <dd>If passed, only keys matching one of the entries in
      f<span class="Li">@filter</span> will be processed.</dd>
  <dt>ret: no return value</dt>
  <dd></dd>
  <dt>since: 2.0.00</dt>
  <dd></dd>
</dl>
<p class="Pp">Examples:</p>
<ul class="Bl-bullet">
  <li>This filter simply prints out the key/value pairs and counts how many
      pairs did it see.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  use constant TABLE_SIZE =&gt; 20;
  our $filter_count;
  my $table = APR::Table::make($r-&gt;pool, TABLE_SIZE);
  
  # populate the table with ascii data
  for (1..TABLE_SIZE) {
      $table-&gt;set(chr($_+97), $_);
  }
  
  $filter_count = 0;
  $table-&gt;do(&quot;my_filter&quot;);
  print &quot;Counted $filter_count elements&quot;;
  
  sub my_filter {
      my ($key, $value) = @_;
      warn &quot;$key =&gt; $value\n&quot;;
      $filter_count++;
      return 1;
  }
    </pre>
    <p class="Pp">Notice that <span class="Li">&quot;my_filter&quot;</span>
        always returns 1, ensuring that <span class="Li">&quot;do()&quot;</span>
        will pass all the key/value pairs.</p>
  </li>
  <li>This filter is similar to the one from the previous example, but this time
      it decides to abort the filtering after seeing half of the table, by
      returning 0 when this happens.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  sub my_filter {
      my ($key, $value) = @_;
      $filter_count++;
      return $filter_count == int(TABLE_SIZE)/2 ? 0 : 1;
  }
    </pre>
  </li>
</ul>
</section>
<section class="Ss">
<h2 class="Ss" id="_get_"><a class="permalink" href="#_get_">&quot;get&quot;</a></h2>
Get the value(s) associated with a given key. After this call, the data is still
  in the table.
<p class="Pp"><span class="Li"></span></p>
<pre>
  $val = $table-&gt;get($key);
  @val = $table-&gt;get($key);
</pre>
<dl class="Bl-tag">
  <dt>obj: $table ( &quot;APR::Table object&quot; )</dt>
  <dd>The table to search for the key.</dd>
  <dt>arg1: $key ( string )</dt>
  <dd>The key to search for.</dd>
  <dt>ret: $val or @val</dt>
  <dd>In the scalar context the first matching value returned (the oldest in the
      table, if there is more than one value). If nothing matches
      <span class="Li">&quot;undef&quot;</span> is returned.
    <p class="Pp">In the list context the whole table is traversed and all
        matching values are returned. An empty list is returned if nothing
        matches.</p>
  </dd>
  <dt>since: 2.0.00</dt>
  <dd></dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="_make_"><a class="permalink" href="#_make_">&quot;make&quot;</a></h2>
Make a new table.
<p class="Pp"><span class="Li"></span></p>
<pre>
  $table = APR::Table::make($p, $nelts);
</pre>
<dl class="Bl-tag">
  <dt>obj: $p ( &quot;APR::Pool object&quot; )</dt>
  <dd>The pool to allocate the pool out of.</dd>
  <dt>arg1: $nelts ( integer )</dt>
  <dd>The number of elements in the initial table. At least 1 or more. If 0 is
      passed APR will still allocate 1.</dd>
  <dt>ret: $table ( &quot;APR::Table object&quot; )</dt>
  <dd>The new table.</dd>
  <dt>since: 2.0.00</dt>
  <dd></dd>
</dl>
<p class="Pp">This table can only store text data.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_merge_"><a class="permalink" href="#_merge_">&quot;merge&quot;</a></h2>
Add data to a table by merging the value with data that has already been stored
  using &quot;, &quot; as a separator:
<p class="Pp"><span class="Li"></span></p>
<pre>
  $table-&gt;merge($key, $val);
</pre>
<dl class="Bl-tag">
  <dt>obj: $table ( &quot;APR::Table object&quot; )</dt>
  <dd>The table to search for the data.</dd>
  <dt>arg1: $key ( string )</dt>
  <dd>The key to merge data for.</dd>
  <dt>arg2: $val ( string )</dt>
  <dd>The data to add.</dd>
  <dt>ret: no return value</dt>
  <dd></dd>
  <dt>since: 2.0.00</dt>
  <dd></dd>
</dl>
<p class="Pp">If the key is not found, then this function acts like
    <span class="Li">&quot;add()&quot;</span>.</p>
<p class="Pp">If there is more than one value for the same key, only the first
    (the oldest) value gets merged.</p>
<p class="Pp">Examples:</p>
<ul class="Bl-bullet">
  <li>Start with a pair:
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  merge =&gt; &quot;1&quot;
    </pre>
    <p class="Pp">and merge &quot;a&quot; to the value:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  $table-&gt;set(  merge =&gt; '1');
  $table-&gt;merge(merge =&gt; 'a');
  $val = $table-&gt;get('merge');
    </pre>
    <p class="Pp">Result:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  $val == &quot;1, a&quot;;
    </pre>
  </li>
  <li>Start with a multivalued pair:
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  merge =&gt; &quot;1&quot;
  merge =&gt; &quot;2&quot;
    </pre>
    <p class="Pp">and merge &quot;a&quot; to the first value;</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  $table-&gt;set(  merge =&gt; '1');
  $table-&gt;add(  merge =&gt; '2');
  $table-&gt;merge(merge =&gt; 'a');
  @val = $table-&gt;get('merge');
    </pre>
    <p class="Pp">Result:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  $val[0] == &quot;1, a&quot;;
  $val[1] == &quot;2&quot;;
    </pre>
    <p class="Pp">Only the first value for the same key is affected.</p>
  </li>
  <li>Have no entry and merge &quot;a&quot;;
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  $table-&gt;merge(miss =&gt; 'a');
  $val = $table-&gt;get('miss');
    </pre>
    <p class="Pp">Result:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  $val == &quot;a&quot;;
    </pre>
  </li>
</ul>
</section>
<section class="Ss">
<h2 class="Ss" id="_overlap_"><a class="permalink" href="#_overlap_">&quot;overlap&quot;</a></h2>
For each key/value pair in <span class="Li">$table_b</span>, add the data to
  <span class="Li">$table_a</span>. The definition of
  <span class="Li">$flags</span> explains how <span class="Li">$flags</span>
  define the overlapping method.
<p class="Pp"><span class="Li"></span></p>
<pre>
  $table_a-&gt;overlap($table_b, $flags);
</pre>
<dl class="Bl-tag">
  <dt>obj: $table_a ( &quot;APR::Table object&quot; )</dt>
  <dd>The table to add the data to.</dd>
  <dt>arg1: $table_b ( &quot;APR::Table object&quot; )</dt>
  <dd>The table to iterate over, adding its data to table
      <span class="Li">$table_a</span></dd>
  <dt>arg2: $flags ( integer )</dt>
  <dd>How to add the table to table <span class="Li">$table_a</span>.
    <p class="Pp">When <span class="Li">$flags</span> ==
        <span class="Li">&quot;APR::Const::OVERLAP_TABLES_SET&quot;</span>, if
        another element already exists with the same key, this will over-write
        the old data.</p>
    <p class="Pp">When <span class="Li">$flags</span> ==
        <span class="Li">&quot;APR::Const::OVERLAP_TABLES_MERGE&quot;</span>,
        the key/value pair from <span class="Li">$table_b</span> is added,
        regardless of whether there is another element with the same key in
        <span class="Li">$table_a</span>.</p>
  </dd>
  <dt>ret: no return value</dt>
  <dd></dd>
  <dt>since: 2.0.00</dt>
  <dd></dd>
</dl>
<p class="Pp">Access the constants via:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  use APR::Const -compile qw(:table);
</pre>
<p class="Pp">or an explicit:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  use APR::Const -compile qw(OVERLAP_TABLES_SET OVERLAP_TABLES_MERGE);
</pre>
<p class="Pp">This function is highly optimized, and uses less memory and CPU
    cycles than a function that just loops through table
    <span class="Li">$table_b</span> calling other functions.</p>
<p class="Pp">Conceptually, <span class="Li">&quot;overlap()&quot;</span> does
    this:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  apr_array_header_t *barr = apr_table_elts(b);
  apr_table_entry_t *belt = (apr_table_entry_t *)barr-E&lt;gt&gt;elts;
  int i;
  
  for (i = 0; i &lt; barr-&gt;nelts; ++i) {
      if (flags &amp; APR_OVERLAP_TABLES_MERGE) {
          apr_table_mergen(a, belt[i].key, belt[i].val);
      }
      else {
          apr_table_setn(a, belt[i].key, belt[i].val);
      }
  }
</pre>
<p class="Pp">Except that it is more efficient (less space and cpu-time)
    especially when <span class="Li">$table_b</span> has many elements.</p>
<p class="Pp">Notice the assumptions on the keys and values in
    <span class="Li">$table_b</span> -- they must be in an ancestor of
    <span class="Li">$table_a</span>'s pool. In practice
    <span class="Li">$table_b</span> and <span class="Li">$table_a</span> are
    usually from the same pool.</p>
<p class="Pp">Examples:</p>
<ul class="Bl-bullet">
  <li><span class="Li">&quot;APR::Const::OVERLAP_TABLES_SET&quot;</span>
    <p class="Pp">Start with table <span class="Li">$base</span>:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  foo =&gt; &quot;one&quot;
  foo =&gt; &quot;two&quot;
  bar =&gt; &quot;beer&quot;
    </pre>
    <p class="Pp">and table <span class="Li">$add</span>:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  foo =&gt; &quot;three&quot;
    </pre>
    <p class="Pp">which is done by:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  use APR::Const    -compile =&gt; ':table';
  my $base = APR::Table::make($r-&gt;pool, TABLE_SIZE);
  my $add  = APR::Table::make($r-&gt;pool, TABLE_SIZE);
  
  $base-&gt;set(bar =&gt; 'beer');
  $base-&gt;set(foo =&gt; 'one');
  $base-&gt;add(foo =&gt; 'two');
  
  $add-&gt;set(foo =&gt; 'three');
    </pre>
    <p class="Pp">Now overlap using
        <span class="Li">&quot;APR::Const::OVERLAP_TABLES_SET&quot;</span>:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  $base-&gt;overlap($add, APR::Const::OVERLAP_TABLES_SET);
    </pre>
    <p class="Pp">Now table <span class="Li">$add</span> is unmodified and table
        <span class="Li">$base</span> contains:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  foo =&gt; &quot;three&quot;
  bar =&gt; &quot;beer&quot;
    </pre>
    <p class="Pp">The value from table <span class="Li">&quot;add&quot;</span>
        has overwritten all previous values for the same key both had
        (<i>foo</i>). This is the same as doing
        <span class="Li">&quot;overlay()&quot;</span> followed by
        <span class="Li">&quot;compress()&quot;</span> with
        <span class="Li">&quot;APR::Const::OVERLAP_TABLES_SET&quot;</span>.</p>
  </li>
  <li><span class="Li">&quot;APR::Const::OVERLAP_TABLES_MERGE&quot;</span>
    <p class="Pp">Start with table <span class="Li">$base</span>:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  foo =&gt; &quot;one&quot;
  foo =&gt; &quot;two&quot;
    </pre>
    <p class="Pp">and table <span class="Li">$add</span>:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  foo =&gt; &quot;three&quot;
  bar =&gt; &quot;beer&quot;
    </pre>
    <p class="Pp">which is done by:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  use APR::Const    -compile =&gt; ':table';
  my $base = APR::Table::make($r-&gt;pool, TABLE_SIZE);
  my $add  = APR::Table::make($r-&gt;pool, TABLE_SIZE);
  
  $base-&gt;set(foo =&gt; 'one');
  $base-&gt;add(foo =&gt; 'two');
  
  $add-&gt;set(foo =&gt; 'three');
  $add-&gt;set(bar =&gt; 'beer');
    </pre>
    <p class="Pp">Now overlap using
        <span class="Li">&quot;APR::Const::OVERLAP_TABLES_MERGE&quot;</span>:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  $base-&gt;overlap($add, APR::Const::OVERLAP_TABLES_MERGE);
    </pre>
    <p class="Pp">Now table <span class="Li">$add</span> is unmodified and table
        <span class="Li">$base</span> contains:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  foo =&gt; &quot;one, two, three&quot;
  bar =&gt; &quot;beer&quot;
    </pre>
    <p class="Pp">Values from both tables for the same key were merged into one
        value. This is the same as doing
        <span class="Li">&quot;overlay()&quot;</span> followed by
        <span class="Li">&quot;compress()&quot;</span> with
        <span class="Li">&quot;APR::Const::OVERLAP_TABLES_MERGE&quot;</span>.</p>
  </li>
</ul>
</section>
<section class="Ss">
<h2 class="Ss" id="_overlay_"><a class="permalink" href="#_overlay_">&quot;overlay&quot;</a></h2>
Merge two tables into one new table. The resulting table may have more than one
  value for the same key.
<p class="Pp"><span class="Li"></span></p>
<pre>
  $table = $table_base-&gt;overlay($table_overlay, $p);
</pre>
<dl class="Bl-tag">
  <dt>obj: $table_base ( &quot;APR::Table object&quot; )</dt>
  <dd>The table to add at the end of the new table.</dd>
  <dt>arg1: $table_overlay ( &quot;APR::Table object&quot; )</dt>
  <dd>The first table to put in the new table.</dd>
  <dt>arg2: $p ( &quot;APR::Pool object&quot; )</dt>
  <dd>The pool to use for the new table.</dd>
  <dt>ret: $table ( &quot;APR::Table object&quot; )</dt>
  <dd>A new table containing all of the data from the two passed in.</dd>
  <dt>since: 2.0.00</dt>
  <dd></dd>
</dl>
<p class="Pp">Examples:</p>
<dl class="Bl-tag">
  <dt>&#x2022;</dt>
  <dd>Start with table <span class="Li">$base</span>:
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  foo =&gt; &quot;one&quot;
  foo =&gt; &quot;two&quot;
  bar =&gt; &quot;beer&quot;
    </pre>
    <p class="Pp">and table <span class="Li">$add</span>:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  foo =&gt; &quot;three&quot;
    </pre>
    <p class="Pp">which is done by:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  use APR::Const    -compile =&gt; ':table';
  my $base = APR::Table::make($r-&gt;pool, TABLE_SIZE);
  my $add  = APR::Table::make($r-&gt;pool, TABLE_SIZE);
  
  $base-&gt;set(bar =&gt; 'beer');
  $base-&gt;set(foo =&gt; 'one');
  $base-&gt;add(foo =&gt; 'two');
  
  $add-&gt;set(foo =&gt; 'three');
    </pre>
    <p class="Pp">Now overlay using
        <span class="Li">&quot;APR::Const::OVERLAP_TABLES_SET&quot;</span>:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  my $overlay = $base-&gt;overlay($add, APR::Const::OVERLAP_TABLES_SET);
    </pre>
    <p class="Pp">That resulted in a new table <span class="Li">$overlay</span>
        (tables <span class="Li">&quot;add&quot;</span> and
        <span class="Li">$base</span> are unmodified) which contains:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  foo =&gt; &quot;one&quot;
  foo =&gt; &quot;two&quot;
  foo =&gt; &quot;three&quot;
  bar =&gt; &quot;beer&quot;
    </pre>
  </dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="_set_"><a class="permalink" href="#_set_">&quot;set&quot;</a></h2>
Add a key/value pair to a table, if another element already exists with the same
  key, this will over-write the old data.
<p class="Pp"><span class="Li"></span></p>
<pre>
  $table-&gt;set($key, $val);
</pre>
<dl class="Bl-tag">
  <dt>obj: $table ( &quot;APR::Table object&quot; )</dt>
  <dd>The table to add the data to.</dd>
  <dt>arg1: $key ( string )</dt>
  <dd>The key to use.</dd>
  <dt>arg2: $val ( string )</dt>
  <dd>The value to add.</dd>
  <dt>ret: no return value</dt>
  <dd></dd>
  <dt>since: 2.0.00</dt>
  <dd></dd>
</dl>
<p class="Pp">When adding data, this function makes a copy of both the key and
    the value.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_unset_"><a class="permalink" href="#_unset_">&quot;unset&quot;</a></h2>
Remove data from the table.
<p class="Pp"><span class="Li"></span></p>
<pre>
  $table-&gt;unset($key);
</pre>
<dl class="Bl-tag">
  <dt>obj: $table ( &quot;APR::Table object&quot; )</dt>
  <dd>The table to remove data from.</dd>
  <dt>arg1: $key ( string )</dt>
  <dd>The key of the data being removed.</dd>
  <dt>ret: no return value</dt>
  <dd></dd>
  <dt>since: 2.0.00</dt>
  <dd></dd>
</dl>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="TIE_Interface"><a class="permalink" href="#TIE_Interface">TIE
  Interface</a></h1>
<span class="Li">&quot;APR::Table&quot;</span> also implements a tied interface,
  so you can work with the <span class="Li">$table</span> object as a hash
  reference.
<p class="Pp">The following tied-hash function are supported:
    <span class="Li">&quot;FETCH&quot;</span>,
    <span class="Li">&quot;STORE&quot;</span>,
    <span class="Li">&quot;DELETE&quot;</span>,
    <span class="Li">&quot;CLEAR&quot;</span>,
    <span class="Li">&quot;EXISTS&quot;</span>,
    <span class="Li">&quot;FIRSTKEY&quot;</span>,
    <span class="Li">&quot;NEXTKEY&quot;</span> and
    <span class="Li">&quot;DESTROY&quot;</span>.</p>
<p class="Pp">Note regarding the use of
    <span class="Li">&quot;values()&quot;</span>.
    <span class="Li">&quot;APR::Table&quot;</span> can hold more than one
    key-value pair sharing the same key, so when using a table through the tied
    interface, the first entry found with the right key will be used, completely
    disregarding possible other entries with the same key. With Perl 5.8.0 and
    higher <span class="Li">&quot;values()&quot;</span> will correctly list
    values the corresponding to the list generated by
    <span class="Li">&quot;keys()&quot;</span>. That doesn't work with Perl 5.6.
    Therefore to portably iterate over the key-value pairs, use
    <span class="Li">&quot;each()&quot;</span> (which fully supports multivalued
    keys), or <span class="Li">&quot;APR::Table::do&quot;</span>.</p>
<section class="Ss">
<h2 class="Ss" id="_EXISTS_"><a class="permalink" href="#_EXISTS_">&quot;EXISTS&quot;</a></h2>
<span class="Li"></span>
<pre>
  $ret = $table-&gt;EXISTS($key);
</pre>
<dl class="Bl-tag">
  <dt>obj: $table ( &quot;APR::Table object&quot; )</dt>
  <dd></dd>
  <dt>arg1: $key ( string )</dt>
  <dd></dd>
  <dt>ret: $ret ( integer )</dt>
  <dd>true or false</dd>
  <dt>since: 2.0.00</dt>
  <dd></dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="_CLEAR_"><a class="permalink" href="#_CLEAR_">&quot;CLEAR&quot;</a></h2>
<span class="Li"></span>
<pre>
  $table-&gt;CLEAR();
</pre>
<dl class="Bl-tag">
  <dt>obj: $table ( &quot;APR::Table object&quot; )</dt>
  <dd></dd>
  <dt>ret: no return value</dt>
  <dd></dd>
  <dt>since: 2.0.00</dt>
  <dd></dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="_STORE_"><a class="permalink" href="#_STORE_">&quot;STORE&quot;</a></h2>
<span class="Li"></span>
<pre>
  $table-&gt;STORE($key, $val);
</pre>
<dl class="Bl-tag">
  <dt>obj: $table ( &quot;APR::Table object&quot; )</dt>
  <dd></dd>
  <dt>arg1: $key ( string )</dt>
  <dd></dd>
  <dt>arg2: $val ( string )</dt>
  <dd></dd>
  <dt>ret: no return value</dt>
  <dd></dd>
  <dt>since: 2.0.00</dt>
  <dd></dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="_DELETE_"><a class="permalink" href="#_DELETE_">&quot;DELETE&quot;</a></h2>
<span class="Li"></span>
<pre>
  $table-&gt;DELETE($key);
</pre>
<dl class="Bl-tag">
  <dt>obj: $table ( &quot;APR::Table object&quot; )</dt>
  <dd></dd>
  <dt>arg1: $key ( string )</dt>
  <dd></dd>
  <dt>ret: no return value</dt>
  <dd></dd>
  <dt>since: 2.0.00</dt>
  <dd></dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="_FETCH_"><a class="permalink" href="#_FETCH_">&quot;FETCH&quot;</a></h2>
<span class="Li"></span>
<pre>
  $ret = $table-&gt;FETCH($key);
</pre>
<dl class="Bl-tag">
  <dt>obj: $table ( &quot;APR::Table object&quot; )</dt>
  <dd></dd>
  <dt>arg1: $key ( string )</dt>
  <dd></dd>
  <dt>ret: $ret ( string )</dt>
  <dd></dd>
  <dt>since: 2.0.00</dt>
  <dd></dd>
</dl>
<p class="Pp">When iterating through the table's entries with
    <span class="Li">&quot;each()&quot;</span>,
    <span class="Li">&quot;FETCH&quot;</span> will return the current value of a
    multivalued key. For example:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  $table-&gt;add(&quot;a&quot; =&gt; 1);
  $table-&gt;add(&quot;b&quot; =&gt; 2);
  $table-&gt;add(&quot;a&quot; =&gt; 3);
  
  ($k, $v) = each %$table; # (a, 1)
  print $table-&gt;{a};       # prints 1
  
  ($k, $v) = each %$table; # (b, 2)
  print $table-&gt;{a};       # prints 1
  
  ($k, $v) = each %$table; # (a, 3)
  print $table-&gt;{a};       # prints 3 !!!
  
  ($k, $v) = each %$table; # (undef, undef)
  print $table-&gt;{a};       # prints 1
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="See_Also"><a class="permalink" href="#See_Also">See
  Also</a></h1>
mod_perl 2.0 documentation.
</section>
<section class="Sh">
<h1 class="Sh" id="Copyright"><a class="permalink" href="#Copyright">Copyright</a></h1>
mod_perl 2.0 and its core modules are copyrighted under The Apache Software
  License, Version 2.0.
</section>
<section class="Sh">
<h1 class="Sh" id="Authors"><a class="permalink" href="#Authors">Authors</a></h1>
The mod_perl development team and numerous contributors.
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2015-06-18</td>
    <td class="foot-os">perl v5.28.2</td>
  </tr>
</table>
</body>
</html>
