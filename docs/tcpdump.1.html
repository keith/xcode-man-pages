<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
  	$NetBSD: tcpdump.8,v 1.9 2003/03/31 00:18:17 perry Exp $
  
   Copyright (c) 1987, 1988, 1989, 1990, 1991, 1992, 1994, 1995, 1996, 1997
  	The Regents of the University of California.  All rights reserved.
   All rights reserved.
  
   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that: (1) source code distributions
   retain the above copyright notice and this paragraph in its entirety, (2)
   distributions including binary code include the above copyright notice and
   this paragraph in its entirety in the documentation or other materials
   provided with the distribution, and (3) all advertising materials mentioning
   features or use of this software display the following acknowledgement:
   ``This product includes software developed by the University of California,
   Lawrence Berkeley Laboratory and its contributors.'' Neither the name of
   the University nor the names of its contributors may be used to endorse
   or promote products derived from this software without specific prior
   written permission.
   THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
   WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
   MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
   -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    .Nd, .Bf, .Op { display: inline; }
    .Pa, .Ad { font-style: italic; }
    .Ms { font-weight: bold; }
    .Bl-diag > dt { font-weight: bold; }
    code.Nm, .Fl, .Cm, .Ic, code.In, .Fd, .Fn, .Cd { font-weight: bold;
      font-family: inherit; }
  </style>
  <title>TCPDUMP(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">TCPDUMP(1)</td>
    <td class="head-vol">General Commands Manual</td>
    <td class="head-rtitle">TCPDUMP(1)</td>
  </tr>
</table>
<div class="manual-text">
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">tcpdump - dump traffic on a network</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<p class="Pp"><b>tcpdump</b> [ <b>-AbdDefhHIJKlLnNOpqStuUvxX#</b> ] [ <b>-B</b>
    <i>buffer_size</i> ]
  <br/>
  [ <b>-c</b> <i>count</i> ] [ <b>--count</b> ] [ <b>-C</b> <i>file_size</i> ] [
    <b>-E</b> <i>spi@ipaddr algo:secret,...</i> ] [ <b>-F</b> <i>file</i> ] [
    <b>-G</b> <i>rotate_seconds</i> ] [ <b>-i</b> <i>interface</i> ] [
    <b>--immediate-mode</b> ] [ <b>-j</b> <i>tstamp_type</i> ] [ <b>-k</b>
    <i>(metadata_arg)</i> ]
  <br/>
  [ <b>-m</b> <i>module</i> ] [ <b>-M</b> <i>secret</i> ] [ <b>--number</b> ] [
    <b>--print</b> ] [ <b>-Q</b> <i>packet-metadata-filter</i> ] [ <b>-Q</b>
    <i>in|out|inout</i> ] [ <b>-r</b> <i>file</i> ] [ <b>-s</b> <i>snaplen</i> ]
    [ <b>-T</b> <i>type</i> ] [ <b>--version</b> ] [ <b>-V</b> <i>file</i> ] [
    <b>-w</b> <i>file</i> ] [ <b>-W</b> <i>filecount</i> ] [ <b>-y</b>
    <i>datalinktype</i> ] [ <b>-z</b> <i>postrotate-command</i> ] [ <b>-Z</b>
    <i>user</i> ] [ <b>--time-stamp-precision=</b><i>tstamp_precision</i> ] [
    <b>--micro</b> ] [ <b>--nano</b> ] [ <i>expression</i> ]</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp"><i>Tcpdump</i> prints out a description of the contents of packets
    on a network interface that match the Boolean <i>expression</i>; the
    description is preceded by a time stamp, printed, by default, as hours,
    minutes, seconds, and fractions of a second since midnight. It can also be
    run with the <b>-w</b> flag, which causes it to save the packet data to a
    file for later analysis, and/or with the <b>-r</b> flag, which causes it to
    read from a saved packet file rather than to read packets from a network
    interface. It can also be run with the <b>-V</b> flag, which causes it to
    read a list of saved packet files. In all cases, only packets that match
    <i>expression</i> will be processed by <i>tcpdump</i>.</p>
<p class="Pp"><i>Tcpdump</i> will, if not run with the <b>-c</b> flag, continue
    capturing packets until it is interrupted by a SIGINT signal (generated, for
    example, by typing your interrupt character, typically control-C) or a
    SIGTERM signal (typically generated with the <b>kill</b>(1) command); if run
    with the <b>-c</b> flag, it will capture packets until it is interrupted by
    a SIGINT or SIGTERM signal or the specified number of packets have been
    processed.</p>
<p class="Pp">When <i>tcpdump</i> finishes capturing packets, it will report
    counts of:</p>
<dl class="Bl-tag">
  <dt></dt>
  <dd>packets ``captured'' (this is the number of packets that <i>tcpdump</i>
      has received and processed);</dd>
  <dt></dt>
  <dd>packets ``received by filter'' (the meaning of this depends on the OS on
      which you're running <i>tcpdump</i>, and possibly on the way the OS was
      configured - if a filter was specified on the command line, on some OSes
      it counts packets regardless of whether they were matched by the filter
      expression and, even if they were matched by the filter expression,
      regardless of whether <i>tcpdump</i> has read and processed them yet, on
      other OSes it counts only packets that were matched by the filter
      expression regardless of whether <i>tcpdump</i> has read and processed
      them yet, and on other OSes it counts only packets that were matched by
      the filter expression and were processed by <i>tcpdump</i>);</dd>
  <dt></dt>
  <dd>packets ``dropped by kernel'' (this is the number of packets that were
      dropped, due to a lack of buffer space, by the packet capture mechanism in
      the OS on which <i>tcpdump</i> is running, if the OS reports that
      information to applications; if not, it will be reported as 0).</dd>
</dl>
<p class="Pp">On platforms that support the SIGINFO signal, such as most BSDs
    (including macOS) and Digital/Tru64 UNIX, it will report those counts when
    it receives a SIGINFO signal (generated, for example, by typing your
    ``status'' character, typically control-T, although on some platforms, such
    as macOS, the ``status'' character is not set by default, so you must set it
    with <b>stty</b>(1) in order to use it) and will continue capturing packets.
    On platforms that do not support the SIGINFO signal, the same can be
    achieved by using the SIGUSR1 signal.</p>
<p class="Pp">Using the SIGUSR2 signal along with the <b>-w</b> flag will
    forcibly flush the packet buffer into the output file.</p>
<p class="Pp">Reading packets from a network interface may require that you have
    special privileges; see the <b>pcap</b>(3PCAP) man page for details. Reading
    a saved packet file doesn't require special privileges.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="OPTIONS"><a class="permalink" href="#OPTIONS">OPTIONS</a></h1>
<dl class="Bl-tag">
  <dt id="A"><a class="permalink" href="#A"><b>-A</b></a></dt>
  <dd>Print each packet (minus its link level header) in ASCII. Handy for
      capturing web pages.</dd>
  <dt id="b"><a class="permalink" href="#b"><b>-b</b></a></dt>
  <dd>Print the AS number in BGP packets in ASDOT notation rather than ASPLAIN
      notation.</dd>
  <dt id="B"><a class="permalink" href="#B"><b>-B</b><i>
    buffer_size</i></a></dt>
  <dd></dd>
  <dt id="buffer"><a class="permalink" href="#buffer"><b>--buffer-size=</b><i>buffer_size</i></a></dt>
  <dd>Set the operating system capture buffer size to <i>buffer_size</i>, in
      units of KiB (1024 bytes).</dd>
  <dt id="c"><a class="permalink" href="#c"><b>-c</b><i> count</i></a></dt>
  <dd>Exit after receiving <i>count</i> packets.</dd>
  <dt id="c~2"><a class="permalink" href="#c~2"><b>-c</b><i>
    skip,count</i></a></dt>
  <dd>Exit after receiving or displaying <i>count</i> packets.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>The second form allows to pass the number of initial packets to ignore
      with the <b>skip</b> parameter. The <b>skip</b> parameter is required
      before the comma but the <b>count</b> parameters is optional after the
      comma.</dd>
</dl>
<dl class="Bl-tag">
  <dt id="count"><a class="permalink" href="#count"><b>--count</b></a></dt>
  <dd>Print only on stderr the packet count when reading capture file(s) instead
      of parsing/printing the packets. If a filter is specified on the command
      line, <i>tcpdump</i> counts only packets that were matched by the filter
      expression.</dd>
  <dt id="C"><a class="permalink" href="#C"><b>-C</b><i> file_size</i></a></dt>
  <dd>Before writing a raw packet to a savefile, check whether the file is
      currently larger than <i>file_size</i> and, if so, close the current
      savefile and open a new one. Savefiles after the first savefile will have
      the name specified with the <b>-w</b> flag, with a number after it,
      starting at 1 and continuing upward. The units of <i>file_size</i> are
      millions of bytes (1,000,000 bytes, not 1,048,576 bytes).</dd>
  <dt id="d"><a class="permalink" href="#d"><b>-d</b></a></dt>
  <dd>Dump the compiled packet-matching code in a human readable form to
      standard output and stop.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>Please mind that although code compilation is always DLT-specific,
      typically it is impossible (and unnecessary) to specify which DLT to use
      for the dump because <i>tcpdump</i> uses either the DLT of the input pcap
      file specified with <b>-r</b>, or the default DLT of the network interface
      specified with <b>-i</b>, or the particular DLT of the network interface
      specified with <b>-y</b> and <b>-i</b> respectively. In these cases the
      dump shows the same exact code that would filter the input file or the
      network interface without <b>-d</b>.</dd>
  <dt></dt>
  <dd>However, when neither <b>-r</b> nor <b>-i</b> is specified, specifying
      <b>-d</b> prevents <i>tcpdump</i> from guessing a suitable network
      interface (see <b>-i</b>). In this case the DLT defaults to EN10MB and can
      be set to another valid value manually with <b>-y</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt id="dd"><a class="permalink" href="#dd"><b>-dd</b></a></dt>
  <dd>Dump packet-matching code as a <b>C</b> program fragment.</dd>
  <dt id="ddd"><a class="permalink" href="#ddd"><b>-ddd</b></a></dt>
  <dd>Dump packet-matching code as decimal numbers (preceded with a count).</dd>
  <dt id="D"><a class="permalink" href="#D"><b>-D</b></a></dt>
  <dd></dd>
  <dt id="list"><a class="permalink" href="#list"><b>--list-interfaces</b></a></dt>
  <dd>Print the list of the network interfaces available on the system and on
      which <i>tcpdump</i> can capture packets. For each network interface, a
      number and an interface name, possibly followed by a text description of
      the interface, are printed. The interface name or the number can be
      supplied to the <b>-i</b> flag to specify an interface on which to
      capture.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>This can be useful on systems that don't have a command to list them
      (e.g., Windows systems, or UNIX systems lacking <b>ifconfig -a</b>); the
      number can be useful on Windows 2000 and later systems, where the
      interface name is a somewhat complex string.</dd>
  <dt></dt>
  <dd>The <b>-D</b> flag will not be supported if <i>tcpdump</i> was built with
      an older version of <i>libpcap</i> that lacks the
      <b>pcap_findalldevs(3PCAP)</b> function.</dd>
</dl>
<dl class="Bl-tag">
  <dt id="e"><a class="permalink" href="#e"><b>-e</b></a></dt>
  <dd>Print the link-level header on each dump line. This can be used, for
      example, to print MAC layer addresses for protocols such as Ethernet and
      IEEE 802.11.</dd>
  <dt id="E"><a class="permalink" href="#E"><b>-E</b></a></dt>
  <dd>Use <i>spi@ipaddr algo:secret</i> for decrypting IPsec ESP packets that
      are addressed to <i>addr</i> and contain Security Parameter Index value
      <i>spi</i>. This combination may be repeated with comma or newline
      separation.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>Note that setting the secret for IPv4 ESP packets is supported at this
      time.</dd>
  <dt></dt>
  <dd>Algorithms may be <b>des-cbc</b>, <b>3des-cbc</b>, <b>blowfish-cbc</b>,
      <b>rc3-cbc</b>, <b>cast128-cbc</b>, or <b>none</b>. The default is
      <b>des-cbc</b>. The ability to decrypt packets is only present if
      <i>tcpdump</i> was compiled with cryptography enabled.</dd>
  <dt></dt>
  <dd><i>secret</i> is the ASCII text for ESP secret key. If preceded by 0x,
      then a hex value will be read.</dd>
  <dt></dt>
  <dd>The option assumes RFC2406 ESP, not RFC1827 ESP. The option is only for
      debugging purposes, and the use of this option with a true `secret' key is
      discouraged. By presenting IPsec secret key onto command line you make it
      visible to others, via <i>ps</i>(1) and other occasions.</dd>
  <dt></dt>
  <dd>In addition to the above syntax, the syntax <i>file name</i> may be used
      to have tcpdump read the provided file in. The file is opened upon
      receiving the first ESP packet, so any special permissions that tcpdump
      may have been given should already have been given up.</dd>
</dl>
<dl class="Bl-tag">
  <dt id="f"><a class="permalink" href="#f"><b>-f</b></a></dt>
  <dd>Print `foreign' IPv4 addresses numerically rather than symbolically (this
      option is intended to get around serious brain damage in Sun's NIS server
      &#x2014; usually it hangs forever translating non-local internet
    numbers).</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>The test for `foreign' IPv4 addresses is done using the IPv4 address and
      netmask of the interface on which capture is being done. If that address
      or netmask are not available, available, either because the interface on
      which capture is being done has no address or netmask or because the
      capture is being done on the Linux &quot;any&quot; interface, which can
      capture on more than one interface, this option will not work
    correctly.</dd>
</dl>
<dl class="Bl-tag">
  <dt id="F"><a class="permalink" href="#F"><b>-F</b><i> file</i></a></dt>
  <dd>Use <i>file</i> as input for the filter expression. An additional
      expression given on the command line is ignored.</dd>
  <dt id="g"><a class="permalink" href="#g"><b>-g</b></a></dt>
  <dd></dd>
  <dt id="apple"><a class="permalink" href="#apple"><b>--apple-oneline</b></a></dt>
  <dd>Do not insert line break after IP header in verbose mode for easier
      parsing. This is an Apple addition.</dd>
  <dt id="G"><a class="permalink" href="#G"><b>-G</b><i>
    rotate_seconds</i></a></dt>
  <dd>If specified, rotates the dump file specified with the <b>-w</b> option
      every <i>rotate_seconds</i> seconds. Savefiles will have the name
      specified by <b>-w</b> which should include a time format as defined by
      <b>strftime</b>(3). If no time format is specified, each new file will
      overwrite the previous. Whenever a generated filename is not unique,
      tcpdump will overwrite the pre-existing data; providing a time
      specification that is coarser than the capture period is therefore not
      advised.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>If used in conjunction with the <b>-C</b> option, filenames will take the
      form of `<i>file</i>&lt;count&gt;'.</dd>
</dl>
<dl class="Bl-tag">
  <dt id="h"><a class="permalink" href="#h"><b>-h</b></a></dt>
  <dd></dd>
  <dt id="help"><a class="permalink" href="#help"><b>--help</b></a></dt>
  <dd>Print the tcpdump and libpcap version strings, print a usage message, and
      exit.</dd>
  <dt id="version"><a class="permalink" href="#version"><b>--version</b></a></dt>
  <dd>Print the tcpdump and libpcap version strings and exit.</dd>
  <dt id="H"><a class="permalink" href="#H"><b>-H</b></a></dt>
  <dd>Attempt to detect 802.11s draft mesh headers.</dd>
  <dt id="i"><a class="permalink" href="#i"><b>-i</b><i> interface</i></a></dt>
  <dd></dd>
  <dt id="interface="><a class="permalink" href="#interface="><b>--interface=</b><i>interface</i></a></dt>
  <dd>Listen, report the list of link-layer types, report the list of time stamp
      types, or report the results of compiling a filter expression on
      <i>interface</i>. If unspecified and if the <b>-d</b> flag is not given,
      <i>tcpdump</i> searches the system interface list for the lowest numbered,
      configured up interface (excluding loopback), which may turn out to be,
      for example, ``eth0''.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>On Linux systems with 2.2 or later kernels, an <i>interface</i> argument
      of ``any'' can be used to capture packets from all interfaces. Note that
      captures on the ``any'' device will not be done in promiscuous mode.</dd>
  <dt></dt>
  <dd>On Darwin systems version 13 or later, when the <i>interface</i> is
      unspecified, tcpdump will use a pseudo interface to capture packets on a
      set of interfaces determined by the kernel (excludes by default loopback
      and tunnel interfaces).</dd>
  <dt></dt>
  <dd>Alternatively, to capture on more than one interface at a time, one may
      use &quot;pktap&quot; as the <i>interface</i> parameter followed by an
      optional list of comma separated interface names to include. For example,
      to capture on the loopback and en0 interface:</dd>
</dl>
<div class="Bd-indent">
<div class="Bd-indent">
<pre><b>tcpdump -i pktap,lo0,en0</b></pre>
</div>
</div>
<dl class="Bl-tag">
  <dt></dt>
  <dd>An <i>interface</i> argument of &quot;all&quot; or &quot;pktap,all&quot;
      can be used to capture packets from all interfaces, including loopback and
      tunnel interfaces.</dd>
  <dt></dt>
  <dd>A pktap pseudo interface provides for packet metadata using the default
      PKTAP data link type and files are written in the Pcap-ng file format. The
      RAW data link type must be used to force to use the legacy
      <b>pcap-savefile</b>(5) file format with a ptkap pseudo interface. Note
      that captures on a ptkap pseudo interface will not be done in promiscuous
      mode.</dd>
  <dt></dt>
  <dd>An <i>interface</i> argument of &quot;iptap&quot; can be used to capture
      packets from at the IP layer. This capture packets as they are passed to
      the input and output routines of the IPv4 and IPv6 protocol handlers of
      the networking stack. Note that captures will not be done in promiscuous
      mode.</dd>
  <dt></dt>
  <dd>If the <b>-D</b> flag is supported, an interface number as printed by that
      flag can be used as the <i>interface</i> argument, if no interface on the
      system has that number as a name.</dd>
</dl>
<dl class="Bl-tag">
  <dt id="I"><a class="permalink" href="#I"><b>-I</b></a></dt>
  <dd></dd>
  <dt id="monitor"><a class="permalink" href="#monitor"><b>--monitor-mode</b></a></dt>
  <dd>Put the interface in &quot;monitor mode&quot;; this is supported only on
      IEEE 802.11 Wi-Fi interfaces, and supported only on some operating
      systems.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>Note that in monitor mode the adapter might disassociate from the network
      with which it's associated, so that you will not be able to use any
      wireless networks with that adapter. This could prevent accessing files on
      a network server, or resolving host names or network addresses, if you are
      capturing in monitor mode and are not connected to another network with
      another adapter.</dd>
  <dt></dt>
  <dd>This flag will affect the output of the <b>-L</b> flag. If <b>-I</b> isn't
      specified, only those link-layer types available when not in monitor mode
      will be shown; if <b>-I</b> is specified, only those link-layer types
      available when in monitor mode will be shown.</dd>
</dl>
<dl class="Bl-tag">
  <dt id="immediate"><a class="permalink" href="#immediate"><b>--immediate-mode</b></a></dt>
  <dd>Capture in &quot;immediate mode&quot;. In this mode, packets are delivered
      to tcpdump as soon as they arrive, rather than being buffered for
      efficiency. This is the default when printing packets rather than saving
      packets to a ``savefile'' if the packets are being printed to a terminal
      rather than to a file or pipe.</dd>
  <dt id="j"><a class="permalink" href="#j"><b>-j</b><i>
    tstamp_type</i></a></dt>
  <dd></dd>
  <dt id="time"><a class="permalink" href="#time"><b>--time-stamp-type=</b><i>tstamp_type</i></a></dt>
  <dd>Set the time stamp type for the capture to <i>tstamp_type</i>. The names
      to use for the time stamp types are given in <b>pcap-tstamp</b>(7); not
      all the types listed there will necessarily be valid for any given
      interface.</dd>
  <dt id="J"><a class="permalink" href="#J"><b>-J</b></a></dt>
  <dd></dd>
  <dt id="list~2"><a class="permalink" href="#list~2"><b>--list-time-stamp-types</b></a></dt>
  <dd>List the supported time stamp types for the interface and exit. If the
      time stamp type cannot be set for the interface, no time stamp types are
      listed.</dd>
  <dt id="time~2"><a class="permalink" href="#time~2"><b>--time-stamp-precision=</b><i>tstamp_precision</i></a></dt>
  <dd>When capturing, set the time stamp precision for the capture to
      <i>tstamp_precision</i>. Note that availability of high precision time
      stamps (nanoseconds) and their actual accuracy is platform and hardware
      dependent. Also note that when writing captures made with nanosecond
      accuracy to a savefile, the time stamps are written with nanosecond
      resolution, and the file is written with a different magic number, to
      indicate that the time stamps are in seconds and nanoseconds; not all
      programs that read pcap savefiles will be able to read those
    captures.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>When reading a savefile, convert time stamps to the precision specified by
      <i>timestamp_precision</i>, and display them with that resolution. If the
      precision specified is less than the precision of time stamps in the file,
      the conversion will lose precision.</dd>
  <dt></dt>
  <dd>The supported values for <i>timestamp_precision</i> are <b>micro</b> for
      microsecond resolution and <b>nano</b> for nanosecond resolution. The
      default is microsecond resolution.</dd>
</dl>
<dl class="Bl-tag">
  <dt id="micro"><a class="permalink" href="#micro"><b>--micro</b></a></dt>
  <dd></dd>
  <dt id="nano"><a class="permalink" href="#nano"><b>--nano</b></a></dt>
  <dd>Shorthands for <b>--time-stamp-precision=micro</b> or
      <b>--time-stamp-precision=nano</b>, adjusting the time stamp precision
      accordingly. When reading packets from a savefile, using <b>--micro</b>
      truncates time stamps if the savefile was created with nanosecond
      precision. In contrast, a savefile created with microsecond precision will
      have trailing zeroes added to the time stamp when <b>--nano</b> is
    used.</dd>
  <dt id="k"><a class="permalink" href="#k"><b>-k</b><i>
    metadata_arg</i></a></dt>
  <dd></dd>
  <dt id="apple~2"><a class="permalink" href="#apple~2"><b>--apple-md-print</b><i>
    metadata_arg</i></a></dt>
  <dd>Control the display of packet metadata via an optional <i>metadata_arg</i>
      argument. This is useful when displaying packet saved in the pcap-ng file
      format or with interfaces that support the PKTAP data link type.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>By default, when the <i>metadata_arg</i> optional argument is not
      specified, any available packet metadata information is printed out.</dd>
  <dt></dt>
  <dd>The <i>metadata_arg</i> argument controls the display of specific packet
      metadata information using a flag word, where each character corresponds
      to a type of packet metadata as follows:</dd>
</dl>
<p class="Pp"></p>
<div class="Bd-indent">
<div class="Bd-indent">
<pre><b>I</b>     interface name (or interface ID)
<b>N</b>     process name
<b>P</b>     process ID
<b>S</b>     service class
<b>D</b>     direction
<b>C</b>     comment
<b>F</b>     flags
<b>U</b>     process UUID (not shown by default)
<b>V</b>     verbose printf of pcap-ng blocks (not shown by default)
<b>d</b>     data link type
<b>f</b>     flow identifier
<b>t</b>     trace tag
<b>A</b>     display all types of metadata</pre>
</div>
</div>
<dl class="Bl-tag">
  <dt></dt>
  <dd>This is an Apple modification.</dd>
</dl>
<dl class="Bl-tag">
  <dt id="K"><a class="permalink" href="#K"><b>-K</b></a></dt>
  <dd></dd>
  <dt id="dont"><a class="permalink" href="#dont"><b>--dont-verify-checksums</b></a></dt>
  <dd>Don't attempt to verify IP, TCP, or UDP checksums. This is useful for
      interfaces that perform some or all of those checksum calculation in
      hardware; otherwise, all outgoing TCP checksums will be flagged as
    bad.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>The option also suppresses truncated bytes missing warnings for ip and ip6
      (Apple modification).</dd>
</dl>
<dl class="Bl-tag">
  <dt id="l"><a class="permalink" href="#l"><b>-l</b></a></dt>
  <dd>Make stdout line buffered. Useful if you want to see the data while
      capturing it. E.g.,</dd>
</dl>
<div class="Bd-indent">
<div class="Bd-indent">
<pre><b>tcpdump -l | tee dat</b></pre>
</div>
</div>
<dl class="Bl-tag">
  <dt></dt>
  <dd>or</dd>
</dl>
<div class="Bd-indent">
<div class="Bd-indent">
<pre><b>tcpdump -l &gt; dat &amp; tail -f dat</b></pre>
</div>
</div>
<dl class="Bl-tag">
  <dt></dt>
  <dd>Note that on Windows,``line buffered'' means ``unbuffered'', so that
      WinDump will write each character individually if <b>-l</b> is
    specified.</dd>
  <dt></dt>
  <dd><b>-U</b> is similar to <b>-l</b> in its behavior, but it will cause
      output to be ``packet-buffered'', so that the output is written to stdout
      at the end of each packet rather than at the end of each line; this is
      buffered on all platforms, including Windows.</dd>
</dl>
<dl class="Bl-tag">
  <dt id="L"><a class="permalink" href="#L"><b>-L</b></a></dt>
  <dd></dd>
  <dt id="list~3"><a class="permalink" href="#list~3"><b>--list-data-link-types</b></a></dt>
  <dd>List the known data link types for the interface, in the specified mode,
      and exit. The list of known data link types may be dependent on the
      specified mode; for example, on some platforms, a Wi-Fi interface might
      support one set of data link types when not in monitor mode (for example,
      it might support only fake Ethernet headers, or might support 802.11
      headers but not support 802.11 headers with radio information) and another
      set of data link types when in monitor mode (for example, it might support
      802.11 headers, or 802.11 headers with radio information, only in monitor
      mode).</dd>
  <dt id="m"><a class="permalink" href="#m"><b>-m</b><i> module</i></a></dt>
  <dd>Load SMI MIB module definitions from file <i>module</i>. This option can
      be used several times to load several MIB modules into
    <i>tcpdump</i>.</dd>
  <dt id="M"><a class="permalink" href="#M"><b>-M</b><i> secret</i></a></dt>
  <dd>Use <i>secret</i> as a shared secret for validating the digests found in
      TCP segments with the TCP-MD5 option (RFC 2385), if present.</dd>
  <dt id="n"><a class="permalink" href="#n"><b>-n</b></a></dt>
  <dd>Don't convert addresses (i.e., host addresses, port numbers, etc.) to
      names.</dd>
  <dt id="N"><a class="permalink" href="#N"><b>-N</b></a></dt>
  <dd>Don't print domain name qualification of host names. E.g., if you give
      this flag then <i>tcpdump</i> will print ``nic'' instead of
      ``nic.ddn.mil''.</dd>
  <dt><b>-#</b></dt>
  <dd></dd>
  <dt id="number"><a class="permalink" href="#number"><b>--number</b></a></dt>
  <dd>Print an optional packet number at the beginning of the line.</dd>
  <dt id="O"><a class="permalink" href="#O"><b>-O</b></a></dt>
  <dd></dd>
  <dt id="no"><a class="permalink" href="#no"><b>--no-optimize</b></a></dt>
  <dd>Do not run the packet-matching code optimizer. This is useful only if you
      suspect a bug in the optimizer.</dd>
  <dt id="P"><a class="permalink" href="#P"><b>-P</b></a></dt>
  <dd></dd>
  <dt id="apple~3"><a class="permalink" href="#apple~3"><b>--apple-pcapng</b></a></dt>
  <dd>Use the pcap-ng file format when saving files. This is an Apple
    addition.</dd>
  <dt id="p"><a class="permalink" href="#p"><b>-p</b></a></dt>
  <dd></dd>
  <dt id="no~2"><a class="permalink" href="#no~2"><b>--no-promiscuous-mode</b></a></dt>
  <dd><i>Don't</i> put the interface into promiscuous mode. Note that the
      interface might be in promiscuous mode for some other reason; hence, `-p'
      cannot be used as an abbreviation for `ether host {local-hw-addr} or ether
      broadcast'.</dd>
  <dt id="print"><a class="permalink" href="#print"><b>--print</b></a></dt>
  <dd>Print parsed packet output, even if the raw packets are being saved to a
      file with the <b>-w</b> flag.</dd>
  <dt id="Q"><a class="permalink" href="#Q"><b>-Q</b><i> direction</i></a></dt>
  <dd></dd>
  <dt id="direction="><a class="permalink" href="#direction="><b>--direction=</b><i>direction</i></a></dt>
  <dd>Choose send/receive direction <i>direction</i> for which packets should be
      captured. Possible values are `in', `out' and `inout'. Not available on
      all platforms.</dd>
  <dt id="Q~2"><a class="permalink" href="#Q~2"><b>-Q</b><i>
    meta-data-expression</i></a></dt>
  <dd></dd>
  <dt id="apple~4"><a class="permalink" href="#apple~4"><b>--apple-md-filter</b><i>
    meta-data-expression</i></a></dt>
  <dd>See the PACKET METADATA FILTER section below. This is an Apple
    addition.</dd>
  <dt id="q"><a class="permalink" href="#q"><b>-q</b></a></dt>
  <dd>Quick (quiet?) output. Print less protocol information so output lines are
      shorter.</dd>
  <dt id="r"><a class="permalink" href="#r"><b>-r</b><i> file</i></a></dt>
  <dd>Read packets from <i>file</i> (which was created with the <b>-w</b> option
      or by other tools that write pcap or pcapng files). Standard input is used
      if <i>file</i> is ``-''.</dd>
  <dt id="S"><a class="permalink" href="#S"><b>-S</b></a></dt>
  <dd></dd>
  <dt id="absolute"><a class="permalink" href="#absolute"><b>--absolute-tcp-sequence-numbers</b></a></dt>
  <dd>Print absolute, rather than relative, TCP sequence numbers.</dd>
  <dt id="s"><a class="permalink" href="#s"><b>-s</b><i> snaplen</i></a></dt>
  <dd></dd>
  <dt id="snapshot"><a class="permalink" href="#snapshot"><b>--snapshot-length=</b><i>snaplen</i></a></dt>
  <dd>Snarf <i>snaplen</i> bytes of data from each packet rather than the
      default of 262144 bytes. Packets truncated because of a limited snapshot
      are indicated in the output with ``[|<i>proto</i>]'', where <i>proto</i>
      is the name of the protocol level at which the truncation has
    occurred.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>Note that taking larger snapshots both increases the amount of time it
      takes to process packets and, effectively, decreases the amount of packet
      buffering. This may cause packets to be lost. Note also that taking
      smaller snapshots will discard data from protocols above the transport
      layer, which loses information that may be important. NFS and AFS requests
      and replies, for example, are very large, and much of the detail won't be
      available if a too-short snapshot length is selected.</dd>
  <dt></dt>
  <dd>If you need to reduce the snapshot size below the default, you should
      limit <i>snaplen</i> to the smallest number that will capture the protocol
      information you're interested in. Setting <i>snaplen</i> to 0 sets it to
      the default of 262144, for backwards compatibility with recent older
      versions of <i>tcpdump</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt id="T"><a class="permalink" href="#T"><b>-T</b><i> type</i></a></dt>
  <dd>Force packets selected by &quot;<i>expression</i>&quot; to be interpreted
      the specified <i>type</i>. Currently known types are <b>aodv</b> (Ad-hoc
      On-demand Distance Vector protocol), <b>carp</b> (Common Address
      Redundancy Protocol), <b>cnfp</b> (Cisco NetFlow protocol), <b>domain</b>
      (Domain Name System), <b>lmp</b> (Link Management Protocol), <b>pgm</b>
      (Pragmatic General Multicast), <b>pgm_zmtp1</b> (ZMTP/1.0 inside
      PGM/EPGM), <b>ptp</b> (Precision Time Protocol), <b>radius</b> (RADIUS),
      <b>resp</b> (REdis Serialization Protocol), <b>rpc</b> (Remote Procedure
      Call), <b>rtcp</b> (Real-Time Applications control protocol), <b>rtp</b>
      (Real-Time Applications protocol), <b>snmp</b> (Simple Network Management
      Protocol), <b>someip</b> (SOME/IP), <b>tftp</b> (Trivial File Transfer
      Protocol), <b>vat</b> (Visual Audio Tool), <b>vxlan</b> (Virtual
      eXtensible Local Area Network), <b>wb</b> (distributed White Board) and
      <b>zmtp1</b> (ZeroMQ Message Transport Protocol 1.0).</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>Note that the <b>pgm</b> type above affects UDP interpretation only, the
      native PGM is always recognised as IP protocol 113 regardless.
      UDP-encapsulated PGM is often called &quot;EPGM&quot; or
      &quot;PGM/UDP&quot;.</dd>
  <dt></dt>
  <dd>Note that the <b>pgm_zmtp1</b> type above affects interpretation of both
      native PGM and UDP at once. During the native PGM decoding the application
      data of an ODATA/RDATA packet would be decoded as a ZeroMQ datagram with
      ZMTP/1.0 frames. During the UDP decoding in addition to that any UDP
      packet would be treated as an encapsulated PGM packet.</dd>
  <dt></dt>
  <dd>Additional dissectors for non registered UDP protocols: <b>iperf</b>
      (iperf 2.x), <b>iperf3</b> (iperf 3.x), <b>iperf3-64</b> (iperf 3.x with
      64 bits packet ID), <b>suttp</b> (Simple UDP Throughput Test
    Protocol),</dd>
</dl>
<dl class="Bl-tag">
  <dt id="t"><a class="permalink" href="#t"><b>-t</b></a></dt>
  <dd><i>Don't</i> print a timestamp on each dump line.</dd>
  <dt id="tt"><a class="permalink" href="#tt"><b>-tt</b></a></dt>
  <dd>Print the timestamp, as seconds since January 1, 1970, 00:00:00, UTC, and
      fractions of a second since that time, on each dump line.</dd>
  <dt id="ttt"><a class="permalink" href="#ttt"><b>-ttt</b></a></dt>
  <dd>Print a delta (microsecond or nanosecond resolution depending on the
      <b>--time-stamp-precision</b> option) between current and previous line on
      each dump line. The default is microsecond resolution.</dd>
  <dt id="tttt"><a class="permalink" href="#tttt"><b>-tttt</b></a></dt>
  <dd>Print a timestamp, as hours, minutes, seconds, and fractions of a second
      since midnight, preceded by the date, on each dump line.</dd>
  <dt id="ttttt"><a class="permalink" href="#ttttt"><b>-ttttt</b></a></dt>
  <dd>Print a delta (microsecond or nanosecond resolution depending on the
      <b>--time-stamp-precision</b> option) between current and first line on
      each dump line. The default is microsecond resolution.</dd>
  <dt><b>-t n</b></dt>
  <dd>An alternate form for specifying the kind of timestamp display where
      <b>n</b> is a number between 0 and 5 with the following meaning:</dd>
</dl>
<p class="Pp"></p>
<div class="Bd-indent">
<div class="Bd-indent">
<pre><b>0</b>     time
<b>1</b>     no time
<b>2</b>     unformatted timestamp
<b>3</b>     microseconds since previous line
<b>4</b>     date and time
<b>5</b>     microseconds since first line</pre>
</div>
</div>
<dl class="Bl-tag">
  <dt></dt>
  <dd>This option may be specified more than once to display more than one kind
      of timestamp on each dump line.</dd>
</dl>
<dl class="Bl-tag">
  <dt id="u"><a class="permalink" href="#u"><b>-u</b></a></dt>
  <dd>Print undecoded NFS handles.</dd>
  <dt id="U"><a class="permalink" href="#U"><b>-U</b></a></dt>
  <dd></dd>
  <dt id="packet"><a class="permalink" href="#packet"><b>--packet-buffered</b></a></dt>
  <dd>If the <b>-w</b> option is not specified, or if it is specified but the
      <b>--print</b> flag is also specified, make the printed packet output
      ``packet-buffered''; i.e., as the description of the contents of each
      packet is printed, it will be written to the standard output, rather than,
      when not writing to a terminal, being written only when the output buffer
      fills.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>If the <b>-w</b> option is specified, make the saved raw packet output
      ``packet-buffered''; i.e., as each packet is saved, it will be written to
      the output file, rather than being written only when the output buffer
      fills.</dd>
  <dt></dt>
  <dd>The <b>-U</b> flag will not be supported if <i>tcpdump</i> was built with
      an older version of <i>libpcap</i> that lacks the
      <b>pcap_dump_flush(3PCAP)</b> function.</dd>
</dl>
<dl class="Bl-tag">
  <dt id="v"><a class="permalink" href="#v"><b>-v</b></a></dt>
  <dd>When parsing and printing, produce (slightly more) verbose output. For
      example, the time to live, identification, total length and options in an
      IP packet are printed. Also enables additional packet integrity checks
      such as verifying the IP and ICMP header checksum.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>When writing to a file with the <b>-w</b> option and at the same time not
      reading from a file with the <b>-r</b> option, report to stderr, once per
      second, the number of packets captured. In Solaris, FreeBSD and possibly
      other operating systems this periodic update currently can cause loss of
      captured packets on their way from the kernel to tcpdump.</dd>
  <dt></dt>
  <dd>On Darwin systems when writing to a file with the <b>-w</b> option, the
      number of packets captured is not updated if there as been no new packets
      in the last second.</dd>
</dl>
<dl class="Bl-tag">
  <dt id="vv"><a class="permalink" href="#vv"><b>-vv</b></a></dt>
  <dd>Even more verbose output. For example, additional fields are printed from
      NFS reply packets, and SMB packets are fully decoded.</dd>
  <dt id="vvv"><a class="permalink" href="#vvv"><b>-vvv</b></a></dt>
  <dd>Even more verbose output. For example, telnet <b>SB</b> ... <b>SE</b>
      options are printed in full. With <b>-X</b> Telnet options are printed in
      hex as well.</dd>
  <dt id="V"><a class="permalink" href="#V"><b>-V</b><i> file</i></a></dt>
  <dd>Read a list of filenames from <i>file</i>. Standard input is used if
      <i>file</i> is ``-''.</dd>
  <dt id="w"><a class="permalink" href="#w"><b>-w</b><i> file</i></a></dt>
  <dd>Write the raw packets to <i>file</i> rather than parsing and printing them
      out. They can later be printed with the -r option. Standard output is used
      if <i>file</i> is ``-''.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>This output will be buffered if written to a file or pipe, so a program
      reading from the file or pipe may not see packets for an arbitrary amount
      of time after they are received. Use the <b>-U</b> flag to cause packets
      to be written as soon as they are received.</dd>
  <dt></dt>
  <dd>The MIME type <i>application/vnd.tcpdump.pcap</i> has been registered with
      IANA for <i>pcap</i> files. The filename extension <i>.pcap</i> appears to
      be the most commonly used along with <i>.cap</i> and <i>.dmp</i>.
      <i>Tcpdump</i> itself doesn't check the extension when reading capture
      files and doesn't add an extension when writing them (it uses magic
      numbers in the file header instead). However, many operating systems and
      applications will use the extension if it is present and adding one (e.g.
      .pcap) is recommended.</dd>
  <dt></dt>
  <dd>See <b>pcap-savefile</b>(5) for a description of the file format.</dd>
</dl>
<dl class="Bl-tag">
  <dt id="W"><a class="permalink" href="#W"><b>-W</b><i> filecount</i></a></dt>
  <dd>Used in conjunction with the <b>-C</b> option, this will limit the number
      of files created to the specified number, and begin overwriting files from
      the beginning, thus creating a 'rotating' buffer. In addition, it will
      name the files with enough leading 0s to support the maximum number of
      files, allowing them to sort correctly.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>Used in conjunction with the <b>-G</b> option, this will limit the number
      of rotated dump files that get created, exiting with status 0 when
      reaching the limit.</dd>
  <dt></dt>
  <dd>If used in conjunction with both <b>-C</b> and <b>-G,</b> the <b>-W</b>
      option will currently be ignored, and will only affect the file name.</dd>
</dl>
<dl class="Bl-tag">
  <dt id="x"><a class="permalink" href="#x"><b>-x</b></a></dt>
  <dd>When parsing and printing, in addition to printing the headers of each
      packet, print the data of each packet (minus its link level header) in
      hex. The smaller of the entire packet or <i>snaplen</i> bytes will be
      printed. Note that this is the entire link-layer packet, so for link
      layers that pad (e.g. Ethernet), the padding bytes will also be printed
      when the higher layer packet is shorter than the required padding. In the
      current implementation this flag may have the same effect as <b>-xx</b> if
      the packet is truncated.</dd>
  <dt id="xx"><a class="permalink" href="#xx"><b>-xx</b></a></dt>
  <dd>When parsing and printing, in addition to printing the headers of each
      packet, print the data of each packet, <i>including</i> its link level
      header, in hex.</dd>
  <dt id="X"><a class="permalink" href="#X"><b>-X</b></a></dt>
  <dd>When parsing and printing, in addition to printing the headers of each
      packet, print the data of each packet (minus its link level header) in hex
      and ASCII. This is very handy for analysing new protocols. In the current
      implementation this flag may have the same effect as <b>-XX</b> if the
      packet is truncated.</dd>
  <dt id="XX"><a class="permalink" href="#XX"><b>-XX</b></a></dt>
  <dd>When parsing and printing, in addition to printing the headers of each
      packet, print the data of each packet, <i>including</i> its link level
      header, in hex and ASCII.</dd>
  <dt id="y"><a class="permalink" href="#y"><b>-y</b><i>
    datalinktype</i></a></dt>
  <dd></dd>
  <dt id="linktype="><a class="permalink" href="#linktype="><b>--linktype=</b><i>datalinktype</i></a></dt>
  <dd>Set the data link type to use while capturing packets (see <b>-L</b>) or
      just compiling and dumping packet-matching code (see <b>-d</b>) to
      <i>datalinktype</i>.</dd>
  <dt id="z"><a class="permalink" href="#z"><b>-z</b><i>
    postrotate-command</i></a></dt>
  <dd>Used in conjunction with the <b>-C</b> or <b>-G</b> options, this will
      make <i>tcpdump</i> run &quot; <i>postrotate-command file</i> &quot; where
      <i>file</i> is the savefile being closed after each rotation. For example,
      specifying <b>-z gzip</b> or <b>-z bzip2</b> will compress each savefile
      using gzip or bzip2.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>Note that tcpdump will run the command in parallel to the capture, using
      the lowest priority so that this doesn't disturb the capture process.</dd>
  <dt></dt>
  <dd>And in case you would like to use a command that itself takes flags or
      different arguments, you can always write a shell script that will take
      the savefile name as the only argument, make the flags &amp; arguments
      arrangements and execute the command that you want.</dd>
</dl>
<dl class="Bl-tag">
  <dt id="Z"><a class="permalink" href="#Z"><b>-Z</b><i> user</i></a></dt>
  <dd></dd>
  <dt id="relinquish"><a class="permalink" href="#relinquish"><b>--relinquish-privileges=</b><i>user</i></a></dt>
  <dd>If <i>tcpdump</i> is running as root, after opening the capture device or
      input savefile, but before opening any savefiles for output, change the
      user ID to <i>user</i> and the group ID to the primary group of
      <i>user</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>This behavior can also be enabled by default at compile time.</dd>
  <dt id="expression"><a class="permalink" href="#expression"><i>
    expression</i></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">selects which packets will be dumped. If no
  <i>expression</i> is given, all packets on the net will be dumped. Otherwise,
  only packets for which <i>expression</i> is `true' will be dumped.
<p class="Pp">For the <i>expression</i> syntax, see <b>pcap-filter</b>(7).</p>
<p class="Pp">The <i>expression</i> argument can be passed to <i>tcpdump</i> as
    either a single Shell argument, or as multiple Shell arguments, whichever is
    more convenient. Generally, if the expression contains Shell metacharacters,
    such as backslashes used to escape protocol names, it is easier to pass it
    as a single, quoted argument rather than to escape the Shell metacharacters.
    Multiple arguments are concatenated with spaces before being parsed.</p>
</div>
</section>
<section class="Sh">
<h1 class="Sh" id="EXAMPLES"><a class="permalink" href="#EXAMPLES">EXAMPLES</a></h1>
<p class="Pp">To print all packets arriving at or departing from
  <i>sundown</i>:</p>
<div class="Bd-indent">
<pre><b>tcpdump host sundown</b></pre>
</div>
<p class="Pp">To print traffic between <i>helios</i> and either <i>hot</i> or
    <i>ace</i>:</p>
<div class="Bd-indent">
<pre><b>tcpdump host helios and \( hot or ace \)</b></pre>
</div>
<p class="Pp">To print all IP packets between <i>ace</i> and any host except
    <i>helios</i>:</p>
<div class="Bd-indent">
<pre><b>tcpdump ip host ace and not helios</b></pre>
</div>
<p class="Pp">To print all traffic between local hosts and hosts at
  Berkeley:</p>
<div class="Bd-indent">
<pre><b>
tcpdump net ucb-ether</b></pre>
</div>
<p class="Pp">To print all ftp traffic through internet gateway <i>snup</i>:
    (note that the expression is quoted to prevent the shell from
    (mis-)interpreting the parentheses):</p>
<div class="Bd-indent">
<pre><b>
tcpdump 'gateway snup and (port ftp or ftp-data)'</b></pre>
</div>
<p class="Pp">To print traffic neither sourced from nor destined for local hosts
    (if you gateway to one other net, this stuff should never make it onto your
    local net).</p>
<div class="Bd-indent">
<pre><b>
tcpdump ip and not net <i>localnet</i></b></pre>
</div>
<p class="Pp">To print the start and end packets (the SYN and FIN packets) of
    each TCP conversation that involves a non-local host.</p>
<div class="Bd-indent">
<pre><b>
tcpdump 'tcp[tcpflags] &amp; (tcp-syn|tcp-fin) != 0 and not src and dst net <i>localnet</i>'</b></pre>
</div>
<p class="Pp">To print the TCP packets with flags RST and ACK both set. (i.e.
    select only the RST and ACK flags in the flags field, and if the result is
    &quot;RST and ACK both set&quot;, match)</p>
<div class="Bd-indent">
<pre><b>
tcpdump 'tcp[tcpflags] &amp; (tcp-rst|tcp-ack) == (tcp-rst|tcp-ack)'</b></pre>
</div>
<p class="Pp">To print all IPv4 HTTP packets to and from port 80, i.e. print
    only packets that contain data, not, for example, SYN and FIN packets and
    ACK-only packets. (IPv6 is left as an exercise for the reader.)</p>
<div class="Bd-indent">
<pre><b>
tcpdump 'tcp port 80 and (((ip[2:2] - ((ip[0]&amp;0xf)&lt;&lt;2)) - ((tcp[12]&amp;0xf0)&gt;&gt;2)) != 0)'</b></pre>
</div>
<p class="Pp">To print IP packets longer than 576 bytes sent through gateway
    <i>snup</i>:</p>
<div class="Bd-indent">
<pre><b>
tcpdump 'gateway snup and ip[2:2] &gt; 576'</b></pre>
</div>
<p class="Pp">To print IP broadcast or multicast packets that were <i>not</i>
    sent via Ethernet broadcast or multicast:</p>
<div class="Bd-indent">
<pre><b>
tcpdump 'ether[0] &amp; 1 = 0 and ip[16] &gt;= 224'</b></pre>
</div>
<p class="Pp">To print all ICMP packets that are not echo requests/replies
    (i.e., not ping packets):</p>
<div class="Bd-indent">
<pre><b>
tcpdump 'icmp[icmptype] != icmp-echo and icmp[icmptype] != icmp-echoreply'</b></pre>
</div>
</section>
<section class="Sh">
<h1 class="Sh" id="OUTPUT_FORMAT"><a class="permalink" href="#OUTPUT_FORMAT">OUTPUT
  FORMAT</a></h1>
<p class="Pp">The output of <i>tcpdump</i> is protocol dependent. The following
    gives a brief description and examples of most of the formats.</p>
<p class="Pp"><b>Timestamps</b></p>
<p class="Pp">By default, all output lines are preceded by a timestamp. The
    timestamp is the current clock time in the form</p>
<div class="Bd-indent">
<pre><i>hh:mm:ss.frac</i></pre>
</div>
and is as accurate as the kernel's clock. The timestamp reflects the time the
  kernel applied a time stamp to the packet. No attempt is made to account for
  the time lag between when the network interface finished receiving the packet
  from the network and when the kernel applied a time stamp to the packet; that
  time lag could include a delay between the time when the network interface
  finished receiving a packet from the network and the time when an interrupt
  was delivered to the kernel to get it to read the packet and a delay between
  the time when the kernel serviced the `new packet' interrupt and the time when
  it applied a time stamp to the packet.
<p class="Pp"><b>Link Level Headers</b></p>
<p class="Pp">If the '-e' option is given, the link level header is printed out.
    On Ethernets, the source and destination addresses, protocol, and packet
    length are printed.</p>
<p class="Pp">On FDDI networks, the '-e' option causes <i>tcpdump</i> to print
    the `frame control' field, the source and destination addresses, and the
    packet length. (The `frame control' field governs the interpretation of the
    rest of the packet. Normal packets (such as those containing IP datagrams)
    are `async' packets, with a priority value between 0 and 7; for example,
    `<b>async4</b>'. Such packets are assumed to contain an 802.2 Logical Link
    Control (LLC) packet; the LLC header is printed if it is <i>not</i> an ISO
    datagram or a so-called SNAP packet.</p>
<p class="Pp">On Token Ring networks, the '-e' option causes <i>tcpdump</i> to
    print the `access control' and `frame control' fields, the source and
    destination addresses, and the packet length. As on FDDI networks, packets
    are assumed to contain an LLC packet. Regardless of whether the '-e' option
    is specified or not, the source routing information is printed for
    source-routed packets.</p>
<p class="Pp">On 802.11 networks, the '-e' option causes <i>tcpdump</i> to print
    the `frame control' fields, all of the addresses in the 802.11 header, and
    the packet length. As on FDDI networks, packets are assumed to contain an
    LLC packet.</p>
<p class="Pp"><i>(N.B.: The following description assumes familiarity with</i>
    <i>the SLIP compression algorithm described in RFC-1144.)</i></p>
<p class="Pp">On SLIP links, a direction indicator (``I'' for inbound, ``O'' for
    outbound), packet type, and compression information are printed out. The
    packet type is printed first. The three types are <i>ip</i>, <i>utcp</i>,
    and <i>ctcp</i>. No further link information is printed for <i>ip</i>
    packets. For TCP packets, the connection identifier is printed following the
    type. If the packet is compressed, its encoded header is printed out. The
    special cases are printed out as <b>*S+</b><i>n</i> and <b>*SA+</b><i>n</i>,
    where <i>n</i> is the amount by which the sequence number (or sequence
    number and ack) has changed. If it is not a special case, zero or more
    changes are printed. A change is indicated by U (urgent pointer), W
    (window), A (ack), S (sequence number), and I (packet ID), followed by a
    delta (+n or -n), or a new value (=n). Finally, the amount of data in the
    packet and compressed header length are printed.</p>
<p class="Pp">For example, the following line shows an outbound compressed TCP
    packet, with an implicit connection identifier; the ack has changed by 6,
    the sequence number by 49, and the packet ID by 6; there are 3 bytes of data
    and 6 bytes of compressed header:</p>
<div class="Bd-indent">
<pre><b>O ctcp * A+6 S+49 I+6 3 (6)</b></pre>
</div>
<p class="Pp"><b>ARP/RARP Packets</b></p>
<p class="Pp">ARP/RARP output shows the type of request and its arguments. The
    format is intended to be self explanatory. Here is a short sample taken from
    the start of an `rlogin' from host <i>rtsg</i> to host <i>csam</i>:</p>
<div class="Bd-indent">
<pre>
<span class="Li">arp who-has csam tell rtsg</span>
<span class="Li">arp reply csam is-at CSAM</span>

</pre>
</div>
The first line says that rtsg sent an ARP packet asking for the Ethernet address
  of internet host csam. Csam replies with its Ethernet address (in this
  example, Ethernet addresses are in caps and internet addresses in lower case).
<p class="Pp">This would look less redundant if we had done <i>tcpdump
  -n</i>:</p>
<div class="Bd-indent">
<pre>
<span class="Li">arp who-has 128.3.254.6 tell 128.3.254.68</span>
<span class="Li">arp reply 128.3.254.6 is-at 02:07:01:00:01:c4</span></pre>
</div>
<p class="Pp">If we had done <i>tcpdump -e</i>, the fact that the first packet
    is broadcast and the second is point-to-point would be visible:</p>
<div class="Bd-indent">
<pre>
<span class="Li">RTSG Broadcast 0806  64: arp who-has csam tell rtsg</span>
<span class="Li">CSAM RTSG 0806  64: arp reply csam is-at CSAM</span>

</pre>
</div>
For the first packet this says the Ethernet source address is RTSG, the
  destination is the Ethernet broadcast address, the type field contained hex
  0806 (type ETHER_ARP) and the total length was 64 bytes.
<p class="Pp"><b>IPv4 Packets</b></p>
<p class="Pp">If the link-layer header is not being printed, for IPv4 packets,
    <b>IP</b> is printed after the time stamp.</p>
<p class="Pp">If the <b>-v</b> flag is specified, information from the IPv4
    header is shown in parentheses after the <b>IP</b> or the link-layer header.
    The general format of this information is:</p>
<div class="Bd-indent">
<pre>
tos <i>tos</i>, ttl <i>ttl</i>, id <i>id</i>, offset <i>offset</i>, flags [<i>flags</i>], proto <i>proto</i>, length <i>length</i>, options (<i>options</i>)

</pre>
</div>
<i>tos</i> is the type of service field; if the ECN bits are non-zero, those are
  reported as <b>ECT(1)</b>, <b>ECT(0)</b>, or <b>CE</b>. <i>ttl</i> is the
  time-to-live; it is not reported if it is zero. <i>id</i> is the IP
  identification field. <i>offset</i> is the fragment offset field; it is
  printed whether this is part of a fragmented datagram or not. <i>flags</i> are
  the MF and DF flags; <b>+</b> is reported if MF is set, and <b>DF</b> is
  reported if F is set. If neither are set, <b>.</b> is reported. <i>proto</i>
  is the protocol ID field. <i>length</i> is the total length field.
  <i>options</i> are the IP options, if any.
<p class="Pp">Next, for TCP and UDP packets, the source and destination IP
    addresses and TCP or UDP ports, with a dot between each IP address and its
    corresponding port, will be printed, with a &gt; separating the source and
    destination. For other protocols, the addresses will be printed, with a &gt;
    separating the source and destination. Higher level protocol information, if
    any, will be printed after that.</p>
<p class="Pp">For fragmented IP datagrams, the first fragment contains the
    higher level protocol header; fragments after the first contain no higher
    level protocol header. Fragmentation information will be printed only with
    the <b>-v</b> flag, in the IP header information, as described above.</p>
<p class="Pp"><b>TCP Packets</b></p>
<p class="Pp"><i>(N.B.:The following description assumes familiarity with</i>
    <i>the TCP protocol described in RFC-793.</i> <i>If you are not familiar</i>
    <i>with the protocol, this description will not</i> <i>be of much use to
    you.)</i></p>
<p class="Pp">The general format of a TCP protocol line is:</p>
<div class="Bd-indent">
<pre>
<i>src</i> &gt; <i>dst</i>: Flags [<i>tcpflags</i>], seq <i>data-seqno</i>, ack <i>ackno</i>, win <i>window</i>, urg <i>urgent</i>, options [<i>opts</i>], length <i>len</i>

</pre>
</div>
<i>Src</i> and <i>dst</i> are the source and destination IP addresses and ports.
  <i>Tcpflags</i> are some combination of S (SYN), F (FIN), P (PUSH), R (RST), U
  (URG), W (ECN CWR), E (ECN-Echo) or `.' (ACK), or `none' if no flags are set.
  <i>Data-seqno</i> describes the portion of sequence space covered by the data
  in this packet (see example below). <i>Ackno</i> is sequence number of the
  next data expected the other direction on this connection. <i>Window</i> is
  the number of bytes of receive buffer space available the other direction on
  this connection. <i>Urg</i> indicates there is `urgent' data in the packet.
  <i>Opts</i> are TCP options (e.g., mss 1024). <i>Len</i> is the length of
  payload data.
<p class="Pp"><i>Iptype</i>, <i>Src</i>, <i>dst</i>, and <i>flags</i> are always
    present. The other fields depend on the contents of the packet's TCP
    protocol header and are output only if appropriate.</p>
<p class="Pp">Here is the opening portion of an rlogin from host <i>rtsg</i> to
    host <i>csam</i>.</p>
<div class="Bd-indent">
<pre>
<span class="Li">IP rtsg.1023 &gt; csam.login: Flags [S], seq 768512:768512, win 4096, opts [mss 1024]</span>
<span class="Li">IP csam.login &gt; rtsg.1023: Flags [S.], seq, 947648:947648, ack 768513, win 4096, opts [mss 1024]</span>
<span class="Li">IP rtsg.1023 &gt; csam.login: Flags [.], ack 1, win 4096</span>
<span class="Li">IP rtsg.1023 &gt; csam.login: Flags [P.], seq 1:2, ack 1, win 4096, length 1</span>
<span class="Li">IP csam.login &gt; rtsg.1023: Flags [.], ack 2, win 4096</span>
<span class="Li">IP rtsg.1023 &gt; csam.login: Flags [P.], seq 2:21, ack 1, win 4096, length 19</span>
<span class="Li">IP csam.login &gt; rtsg.1023: Flags [P.], seq 1:2, ack 21, win 4077, length 1</span>
<span class="Li">IP csam.login &gt; rtsg.1023: Flags [P.], seq 2:3, ack 21, win 4077, urg 1, length 1</span>
<span class="Li">IP csam.login &gt; rtsg.1023: Flags [P.], seq 3:4, ack 21, win 4077, urg 1, length 1</span>

</pre>
</div>
The first line says that TCP port 1023 on rtsg sent a packet to port
  <i>login</i> on csam. The <b>S</b> indicates that the <i>SYN</i> flag was set.
  The packet sequence number was 768512 and it contained no data. (The notation
  is `first:last' which means `sequence numbers <i>first</i> up to but not
  including <i>last</i>'.) There was no piggy-backed ACK, the available receive
  window was 4096 bytes and there was a max-segment-size option requesting an
  MSS of 1024 bytes.
<p class="Pp">Csam replies with a similar packet except it includes a
    piggy-backed ACK for rtsg's SYN. Rtsg then ACKs csam's SYN. The `.' means
    the ACK flag was set. The packet contained no data so there is no data
    sequence number or length. Note that the ACK sequence number is a small
    integer (1). The first time <i>tcpdump</i> sees a TCP `conversation', it
    prints the sequence number from the packet. On subsequent packets of the
    conversation, the difference between the current packet's sequence number
    and this initial sequence number is printed. This means that sequence
    numbers after the first can be interpreted as relative byte positions in the
    conversation's data stream (with the first data byte each direction being
    `1'). `-S' will override this feature, causing the original sequence numbers
    to be output.</p>
<p class="Pp">On the 6th line, rtsg sends csam 19 bytes of data (bytes 2 through
    20 in the rtsg &#x2192; csam side of the conversation). The PUSH flag is set
    in the packet. On the 7th line, csam says it's received data sent by rtsg up
    to but not including byte 21. Most of this data is apparently sitting in the
    socket buffer since csam's receive window has gotten 19 bytes smaller. Csam
    also sends one byte of data to rtsg in this packet. On the 8th and 9th
    lines, csam sends two bytes of urgent, pushed data to rtsg.</p>
<p class="Pp">If the snapshot was small enough that <i>tcpdump</i> didn't
    capture the full TCP header, it interprets as much of the header as it can
    and then reports ``[|<i>tcp</i>]'' to indicate the remainder could not be
    interpreted. If the header contains a bogus option (one with a length that's
    either too small or beyond the end of the header), <i>tcpdump</i> reports it
    as ``[<i>bad opt</i>]'' and does not interpret any further options (since
    it's impossible to tell where they start). If the header length indicates
    options are present but the IP datagram length is not long enough for the
    options to actually be there, <i>tcpdump</i> reports it as ``[<i>bad hdr
    length</i>]''.</p>
<p class="Pp"><b><b>Capturing TCP packets with particular flag combinations
    (SYN-ACK, URG-ACK, etc.)</b></b></p>
<p class="Pp">There are 8 bits in the control bits section of the TCP
  header:</p>
<dl class="Bl-tag">
  <dt></dt>
  <dd><i>CWR | ECE | URG | ACK | PSH | RST | SYN | FIN</i></dd>
</dl>
<p class="Pp">Let's assume that we want to watch packets used in establishing a
    TCP connection. Recall that TCP uses a 3-way handshake protocol when it
    initializes a new connection; the connection sequence with regard to the TCP
    control bits is</p>
<p class="Pp"></p>
<div class="Bd-indent">1) Caller sends SYN</div>
<div class="Bd-indent">2) Recipient responds with SYN, ACK</div>
<div class="Bd-indent">3) Caller sends ACK</div>
<p class="Pp">Now we're interested in capturing packets that have only the SYN
    bit set (Step 1). Note that we don't want packets from step 2 (SYN-ACK),
    just a plain initial SYN. What we need is a correct filter expression for
    <i>tcpdump</i>.</p>
<p class="Pp">Recall the structure of a TCP header without options:</p>
<p class="Pp"></p>
<pre>
<br/>
 0                            15                              31
-----------------------------------------------------------------
|          source port          |       destination port        |
-----------------------------------------------------------------
|                        sequence number                        |
-----------------------------------------------------------------
|                     acknowledgment number                     |
-----------------------------------------------------------------
|  HL   | rsvd  |C|E|U|A|P|R|S|F|        window size            |
-----------------------------------------------------------------
|         TCP checksum          |       urgent pointer          |
-----------------------------------------------------------------</pre>
<p class="Pp">A TCP header usually holds 20 octets of data, unless options are
    present. The first line of the graph contains octets 0 - 3, the second line
    shows octets 4 - 7 etc.</p>
<p class="Pp">Starting to count with 0, the relevant TCP control bits are
    contained in octet 13:</p>
<p class="Pp"></p>
<pre>
<br/>
 0             7|             15|             23|             31
----------------|---------------|---------------|----------------
|  HL   | rsvd  |C|E|U|A|P|R|S|F|        window size            |
----------------|---------------|---------------|----------------
|               |  13th octet   |               |               |</pre>
<p class="Pp">Let's have a closer look at octet no. 13:</p>
<p class="Pp"></p>
<pre>
<br/>
                |               |
<br/>
                |---------------|
<br/>
                |C|E|U|A|P|R|S|F|
<br/>
                |---------------|
<br/>
                |7   5   3     0|</pre>
<p class="Pp">These are the TCP control bits we are interested in. We have
    numbered the bits in this octet from 0 to 7, right to left, so the PSH bit
    is bit number 3, while the URG bit is number 5.</p>
<p class="Pp">Recall that we want to capture packets with only SYN set. Let's
    see what happens to octet 13 if a TCP datagram arrives with the SYN bit set
    in its header:</p>
<p class="Pp"></p>
<pre>
<br/>
                |C|E|U|A|P|R|S|F|
<br/>
                |---------------|
<br/>
                |0 0 0 0 0 0 1 0|
<br/>
                |---------------|
<br/>
                |7 6 5 4 3 2 1 0|</pre>
<p class="Pp">Looking at the control bits section we see that only bit number 1
    (SYN) is set.</p>
<p class="Pp">Assuming that octet number 13 is an 8-bit unsigned integer in
    network byte order, the binary value of this octet is</p>
<dl class="Bl-tag">
  <dt></dt>
  <dd>00000010</dd>
</dl>
<p class="Pp">and its decimal representation is</p>
<p class="Pp"></p>
<pre>
<br/>
   7     6     5     4     3     2     1     0
0*2 + 0*2 + 0*2 + 0*2 + 0*2 + 0*2 + 1*2 + 0*2  =  2</pre>
<p class="Pp">We're almost done, because now we know that if only SYN is set,
    the value of the 13th octet in the TCP header, when interpreted as a 8-bit
    unsigned integer in network byte order, must be exactly 2.</p>
<p class="Pp">This relationship can be expressed as</p>
<div class="Bd-indent"><b>tcp[13] == 2</b></div>
<p class="Pp">We can use this expression as the filter for <i>tcpdump</i> in
    order to watch packets which have only SYN set:</p>
<div class="Bd-indent"><b>tcpdump -i xl0 tcp[13] == 2</b></div>
<p class="Pp">The expression says &quot;let the 13th octet of a TCP datagram
    have the decimal value 2&quot;, which is exactly what we want.</p>
<p class="Pp">Now, let's assume that we need to capture SYN packets, but we
    don't care if ACK or any other TCP control bit is set at the same time.
    Let's see what happens to octet 13 when a TCP datagram with SYN-ACK set
    arrives:</p>
<p class="Pp"></p>
<pre>
<br/>
     |C|E|U|A|P|R|S|F|
<br/>
     |---------------|
<br/>
     |0 0 0 1 0 0 1 0|
<br/>
     |---------------|
<br/>
     |7 6 5 4 3 2 1 0|</pre>
<p class="Pp">Now bits 1 and 4 are set in the 13th octet. The binary value of
    octet 13 is</p>
<dl class="Bl-tag">
  <dt></dt>
  <dd>
    <br/>
     00010010</dd>
</dl>
<p class="Pp">which translates to decimal</p>
<p class="Pp"></p>
<pre>
<br/>
   7     6     5     4     3     2     1     0
0*2 + 0*2 + 0*2 + 1*2 + 0*2 + 0*2 + 1*2 + 0*2   = 18</pre>
<p class="Pp">Now we can't just use 'tcp[13] == 18' in the <i>tcpdump</i> filter
    expression, because that would select only those packets that have SYN-ACK
    set, but not those with only SYN set. Remember that we don't care if ACK or
    any other control bit is set as long as SYN is set.</p>
<p class="Pp">In order to achieve our goal, we need to logically AND the binary
    value of octet 13 with some other value to preserve the SYN bit. We know
    that we want SYN to be set in any case, so we'll logically AND the value in
    the 13th octet with the binary value of a SYN:</p>
<p class="Pp"></p>
<pre>
<br/>
          00010010 SYN-ACK              00000010 SYN
<br/>
     AND  00000010 (we want SYN)   AND  00000010 (we want SYN)
<br/>
          --------                      --------
<br/>
     =    00000010                 =    00000010</pre>
<p class="Pp">We see that this AND operation delivers the same result regardless
    whether ACK or another TCP control bit is set. The decimal representation of
    the AND value as well as the result of this operation is 2 (binary
    00000010), so we know that for packets with SYN set the following relation
    must hold true:</p>
<dl class="Bl-tag">
  <dt></dt>
  <dd>( ( value of octet 13 ) AND ( 2 ) ) == ( 2 )</dd>
</dl>
<p class="Pp">This points us to the <i>tcpdump</i> filter expression</p>
<div class="Bd-indent"><b>
<br/>
 tcpdump -i xl0 'tcp[13] &amp; 2 == 2'</b></div>
<p class="Pp">Some offsets and field values may be expressed as names rather
    than as numeric values. For example tcp[13] may be replaced with
    tcp[tcpflags]. The following TCP flag field values are also available:
    tcp-fin, tcp-syn, tcp-rst, tcp-push, tcp-ack, tcp-urg.</p>
<p class="Pp">This can be demonstrated as:</p>
<div class="Bd-indent"><b>
<br/>
 tcpdump -i xl0 'tcp[tcpflags] &amp; tcp-push != 0'</b></div>
<p class="Pp">Note that you should use single quotes or a backslash in the
    expression to hide the AND ('&amp;') special character from the shell.</p>
<p class="Pp"><b><b>UDP Packets</b></b></p>
<p class="Pp">UDP format is illustrated by this rwho packet:</p>
<div class="Bd-indent">
<pre>
<span class="Li">actinide.who &gt; broadcast.who: udp 84</span>

</pre>
</div>
This says that port <i>who</i> on host <i>actinide</i> sent a UDP datagram to
  port <i>who</i> on host <i>broadcast</i>, the Internet broadcast address. The
  packet contained 84 bytes of user data.
<p class="Pp">Some UDP services are recognized (from the source or destination
    port number) and the higher level protocol information printed. In
    particular, Domain Name service requests (RFC-1034/1035) and Sun RPC calls
    (RFC-1050) to NFS.</p>
<p class="Pp"><b>TCP or UDP Name Server Requests</b></p>
<p class="Pp"><i>(N.B.:The following description assumes familiarity with</i>
    <i>the Domain Service protocol described in RFC-1035.</i> <i>If you are not
    familiar</i> <i>with the protocol, the following description will appear to
    be written</i> <i>in Greek.)</i></p>
<p class="Pp">Name server requests are formatted as</p>
<div class="Bd-indent">
<pre>
<i>src &gt; dst: id op? flags qtype qclass name (len)</i>

<span class="Li">h2opolo.1538 &gt; helios.domain: 3+ A? ucbvax.berkeley.edu. (37)</span>

</pre>
</div>
Host <i>h2opolo</i> asked the domain server on <i>helios</i> for an address
  record (qtype=A) associated with the name <i>ucbvax.berkeley.edu.</i> The
  query id was `3'. The `+' indicates the <i>recursion desired</i> flag was set.
  The query length was 37 bytes, excluding the TCP or UDP and IP protocol
  headers. The query operation was the normal one, <i>Query</i>, so the op field
  was omitted. If the op had been anything else, it would have been printed
  between the `3' and the `+'. Similarly, the qclass was the normal one,
  <i>C_IN</i>, and omitted. Any other qclass would have been printed immediately
  after the `A'.
<p class="Pp">A few anomalies are checked and may result in extra fields
    enclosed in square brackets: If a query contains an answer, authority
    records or additional records section, <i>ancount</i>, <i>nscount</i>, or
    <i>arcount</i> are printed as `[<i>n</i>a]', `[<i>n</i>n]' or `[<i>n</i>au]'
    where <i>n</i> is the appropriate count. If any of the response bits are set
    (AA, RA or rcode) or any of the `must be zero' bits are set in bytes two and
    three, `[b2&amp;3=<i>x</i>]' is printed, where <i>x</i> is the hex value of
    header bytes two and three.</p>
<p class="Pp"><b>TCP or UDP Name Server Responses</b></p>
<p class="Pp">Name server responses are formatted as</p>
<div class="Bd-indent">
<pre>
<i>src &gt; dst:  id op rcode flags a/n/au type class data (len)</i>

<span class="Li">helios.domain &gt; h2opolo.1538: 3 3/3/7 A 128.32.137.3 (273)</span>
<span class="Li">helios.domain &gt; h2opolo.1537: 2 NXDomain* 0/1/0 (97)</span>

</pre>
</div>
In the first example, <i>helios</i> responds to query id 3 from <i>h2opolo</i>
  with 3 answer records, 3 name server records and 7 additional records. The
  first answer record is type A (address) and its data is internet address
  128.32.137.3. The total size of the response was 273 bytes, excluding TCP or
  UDP and IP headers. The op (Query) and response code (NoError) were omitted,
  as was the class (C_IN) of the A record.
<p class="Pp">In the second example, <i>helios</i> responds to query 2 with a
    response code of non-existent domain (NXDomain) with no answers, one name
    server and no authority records. The `*' indicates that the <i>authoritative
    answer</i> bit was set. Since there were no answers, no type, class or data
    were printed.</p>
<p class="Pp">Other flag characters that might appear are `-' (recursion
    available, RA, <i>not</i> set) and `|' (truncated message, TC, set). If the
    `question' section doesn't contain exactly one entry, `[<i>n</i>q]' is
    printed.</p>
<p class="Pp"><b>SMB/CIFS decoding</b></p>
<p class="Pp"><i>tcpdump</i> now includes fairly extensive SMB/CIFS/NBT decoding
    for data on UDP/137, UDP/138 and TCP/139. Some primitive decoding of IPX and
    NetBEUI SMB data is also done.</p>
<p class="Pp">By default a fairly minimal decode is done, with a much more
    detailed decode done if -v is used. Be warned that with -v a single SMB
    packet may take up a page or more, so only use -v if you really want all the
    gory details.</p>
<p class="Pp">For information on SMB packet formats and what all the fields mean
    see https://download.samba.org/pub/samba/specs/ and other online resources.
    The SMB patches were written by Andrew Tridgell (tridge@samba.org).</p>
<p class="Pp"><b>NFS Requests and Replies</b></p>
<p class="Pp">Sun NFS (Network File System) requests and replies are printed
  as:</p>
<div class="Bd-indent">
<pre>
<i>src.sport &gt; dst.nfs: NFS request xid xid len op args</i>
<i>src.nfs &gt; dst.dport: NFS reply xid xid reply stat len op results</i>

<span class="Li"></span>
<span class="Li">sushi.1023 &gt; wrl.nfs: NFS request xid 26377</span>
<span class="Li">	112 readlink fh 21,24/10.73165</span>
<span class="Li">wrl.nfs &gt; sushi.1023: NFS reply xid 26377</span>
<span class="Li">	reply ok 40 readlink &quot;../var&quot;</span>
<span class="Li">sushi.1022 &gt; wrl.nfs: NFS request xid 8219</span>
<span class="Li">	144 lookup fh 9,74/4096.6878 &quot;xcolors&quot;</span>
<span class="Li">wrl.nfs &gt; sushi.1022: NFS reply xid 8219</span>
<span class="Li">	reply ok 128 lookup fh 9,74/4134.3150</span>
<span class="Li"></span>

</pre>
</div>
In the first line, host <i>sushi</i> sends a transaction with id <i>26377</i> to
  <i>wrl</i>. The request was 112 bytes, excluding the UDP and IP headers. The
  operation was a <i>readlink</i> (read symbolic link) on file handle
  (<i>fh</i>) 21,24/10.731657119. (If one is lucky, as in this case, the file
  handle can be interpreted as a major,minor device number pair, followed by the
  inode number and generation number.) In the second line, <i>wrl</i> replies
  `ok' with the same transaction id and the contents of the link.
<p class="Pp">In the third line, <i>sushi</i> asks (using a new transaction id)
    <i>wrl</i> to lookup the name `<i>xcolors</i>' in directory file
    9,74/4096.6878. In the fourth line, <i>wrl</i> sends a reply with the
    respective transaction id.</p>
<p class="Pp">Note that the data printed depends on the operation type. The
    format is intended to be self explanatory if read in conjunction with an NFS
    protocol spec. Also note that older versions of tcpdump printed NFS packets
    in a slightly different format: the transaction id (xid) would be printed
    instead of the non-NFS port number of the packet.</p>
<p class="Pp">If the -v (verbose) flag is given, additional information is
    printed. For example:</p>
<div class="Bd-indent">
<pre>
<span class="Li"></span>
<span class="Li">sushi.1023 &gt; wrl.nfs: NFS request xid 79658</span>
<span class="Li">	148 read fh 21,11/12.195 8192 bytes @ 24576</span>
<span class="Li">wrl.nfs &gt; sushi.1023: NFS reply xid 79658</span>
<span class="Li">	reply ok 1472 read REG 100664 ids 417/0 sz 29388</span>
<span class="Li"></span>

</pre>
</div>
(-v also prints the IP header TTL, ID, length, and fragmentation fields, which
  have been omitted from this example.) In the first line, <i>sushi</i> asks
  <i>wrl</i> to read 8192 bytes from file 21,11/12.195, at byte offset 24576.
  <i>Wrl</i> replies `ok'; the packet shown on the second line is the first
  fragment of the reply, and hence is only 1472 bytes long (the other bytes will
  follow in subsequent fragments, but these fragments do not have NFS or even
  UDP headers and so might not be printed, depending on the filter expression
  used). Because the -v flag is given, some of the file attributes (which are
  returned in addition to the file data) are printed: the file type (``REG'',
  for regular file), the file mode (in octal), the UID and GID, and the file
  size.
<p class="Pp">If the -v flag is given more than once, even more details are
    printed.</p>
<p class="Pp">NFS reply packets do not explicitly identify the RPC operation.
    Instead, <i>tcpdump</i> keeps track of ``recent'' requests, and matches them
    to the replies using the transaction ID. If a reply does not closely follow
    the corresponding request, it might not be parsable.</p>
<p class="Pp"><b>AFS Requests and Replies</b></p>
<p class="Pp">Transarc AFS (Andrew File System) requests and replies are printed
    as:</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
<i>src.sport &gt; dst.dport: rx packet-type</i>
<i>src.sport &gt; dst.dport: rx packet-type service call call-name args</i>
<i>src.sport &gt; dst.dport: rx packet-type service reply call-name args</i>

<span class="Li"></span>
<span class="Li">elvis.7001 &gt; pike.afsfs:</span>
<span class="Li">	rx data fs call rename old fid 536876964/1/1 &quot;.newsrc.new&quot;</span>
<span class="Li">	new fid 536876964/1/1 &quot;.newsrc&quot;</span>
<span class="Li">pike.afsfs &gt; elvis.7001: rx data fs reply rename</span>
<span class="Li"></span>

</pre>
</div>
In the first line, host elvis sends a RX packet to pike. This was a RX data
  packet to the fs (fileserver) service, and is the start of an RPC call. The
  RPC call was a rename, with the old directory file id of 536876964/1/1 and an
  old filename of `.newsrc.new', and a new directory file id of 536876964/1/1
  and a new filename of `.newsrc'. The host pike responds with a RPC reply to
  the rename call (which was successful, because it was a data packet and not an
  abort packet).
<p class="Pp">In general, all AFS RPCs are decoded at least by RPC call name.
    Most AFS RPCs have at least some of the arguments decoded (generally only
    the `interesting' arguments, for some definition of interesting).</p>
<p class="Pp">The format is intended to be self-describing, but it will probably
    not be useful to people who are not familiar with the workings of AFS and
    RX.</p>
<p class="Pp">If the -v (verbose) flag is given twice, acknowledgement packets
    and additional header information is printed, such as the RX call ID, call
    number, sequence number, serial number, and the RX packet flags.</p>
<p class="Pp">If the -v flag is given twice, additional information is printed,
    such as the RX call ID, serial number, and the RX packet flags. The MTU
    negotiation information is also printed from RX ack packets.</p>
<p class="Pp">If the -v flag is given three times, the security index and
    service id are printed.</p>
<p class="Pp">Error codes are printed for abort packets, with the exception of
    Ubik beacon packets (because abort packets are used to signify a yes vote
    for the Ubik protocol).</p>
<p class="Pp">AFS reply packets do not explicitly identify the RPC operation.
    Instead, <i>tcpdump</i> keeps track of ``recent'' requests, and matches them
    to the replies using the call number and service ID. If a reply does not
    closely follow the corresponding request, it might not be parsable.</p>
<p class="Pp"></p>
<p class="Pp"><b>KIP AppleTalk (DDP in UDP)</b></p>
<p class="Pp">AppleTalk DDP packets encapsulated in UDP datagrams are
    de-encapsulated and dumped as DDP packets (i.e., all the UDP header
    information is discarded). The file <i>/etc/atalk.names</i> is used to
    translate AppleTalk net and node numbers to names. Lines in this file have
    the form</p>
<div class="Bd-indent">
<pre>
<i>number	name</i>
<span class="Li">1.254		ether</span>
<span class="Li">16.1		icsd-net</span>
<span class="Li">1.254.110	ace</span>

</pre>
</div>
The first two lines give the names of AppleTalk networks. The third line gives
  the name of a particular host (a host is distinguished from a net by the 3rd
  octet in the number - a net number <i>must</i> have two octets and a host
  number <i>must</i> have three octets.) The number and name should be separated
  by whitespace (blanks or tabs). The <i>/etc/atalk.names</i> file may contain
  blank lines or comment lines (lines starting with a `#').
<p class="Pp">AppleTalk addresses are printed in the form</p>
<div class="Bd-indent">
<pre>
<i>net.host.port</i>
<span class="Li">144.1.209.2 &gt; icsd-net.112.220</span>
<span class="Li">office.2 &gt; icsd-net.112.220</span>
<span class="Li">jssmag.149.235 &gt; icsd-net.2</span>

</pre>
</div>
(If the <i>/etc/atalk.names</i> doesn't exist or doesn't contain an entry for
  some AppleTalk host/net number, addresses are printed in numeric form.) In the
  first example, NBP (DDP port 2) on net 144.1 node 209 is sending to whatever
  is listening on port 220 of net icsd node 112. The second line is the same
  except the full name of the source node is known (`office'). The third line is
  a send from port 235 on net jssmag node 149 to broadcast on the icsd-net NBP
  port (note that the broadcast address (255) is indicated by a net name with no
  host number - for this reason it's a good idea to keep node names and net
  names distinct in /etc/atalk.names).
<p class="Pp">NBP (name binding protocol) and ATP (AppleTalk transaction
    protocol) packets have their contents interpreted. Other protocols just dump
    the protocol name (or number if no name is registered for the protocol) and
    packet size.</p>
<p class="Pp"><b>NBP packets</b> are formatted like the following examples:</p>
<div class="Bd-indent">
<pre>
<span class="Li">icsd-net.112.220 &gt; jssmag.2: nbp-lkup 190: &quot;=:LaserWriter@*&quot;</span>
<span class="Li">jssmag.209.2 &gt; icsd-net.112.220: nbp-reply 190: &quot;RM1140:LaserWriter@*&quot; 250</span>
<span class="Li">techpit.2 &gt; icsd-net.112.220: nbp-reply 190: &quot;techpit:LaserWriter@*&quot; 186</span>

</pre>
</div>
The first line is a name lookup request for laserwriters sent by net icsd host
  112 and broadcast on net jssmag. The nbp id for the lookup is 190. The second
  line shows a reply for this request (note that it has the same id) from host
  jssmag.209 saying that it has a laserwriter resource named &quot;RM1140&quot;
  registered on port 250. The third line is another reply to the same request
  saying host techpit has laserwriter &quot;techpit&quot; registered on port
  186.
<p class="Pp"><b>ATP packet</b> formatting is demonstrated by the following
    example:</p>
<div class="Bd-indent">
<pre>
<span class="Li">jssmag.209.165 &gt; helios.132: atp-req  12266&lt;0-7&gt; 0xae030001</span>
<span class="Li">helios.132 &gt; jssmag.209.165: atp-resp 12266:0 (512) 0xae040000</span>
<span class="Li">helios.132 &gt; jssmag.209.165: atp-resp 12266:1 (512) 0xae040000</span>
<span class="Li">helios.132 &gt; jssmag.209.165: atp-resp 12266:2 (512) 0xae040000</span>
<span class="Li">helios.132 &gt; jssmag.209.165: atp-resp 12266:3 (512) 0xae040000</span>
<span class="Li">helios.132 &gt; jssmag.209.165: atp-resp 12266:4 (512) 0xae040000</span>
<span class="Li">helios.132 &gt; jssmag.209.165: atp-resp 12266:5 (512) 0xae040000</span>
<span class="Li">helios.132 &gt; jssmag.209.165: atp-resp 12266:6 (512) 0xae040000</span>
<span class="Li">helios.132 &gt; jssmag.209.165: atp-resp*12266:7 (512) 0xae040000</span>
<span class="Li">jssmag.209.165 &gt; helios.132: atp-req  12266&lt;3,5&gt; 0xae030001</span>
<span class="Li">helios.132 &gt; jssmag.209.165: atp-resp 12266:3 (512) 0xae040000</span>
<span class="Li">helios.132 &gt; jssmag.209.165: atp-resp 12266:5 (512) 0xae040000</span>
<span class="Li">jssmag.209.165 &gt; helios.132: atp-rel  12266&lt;0-7&gt; 0xae030001</span>
<span class="Li">jssmag.209.133 &gt; helios.132: atp-req* 12267&lt;0-7&gt; 0xae030002</span>

</pre>
</div>
Jssmag.209 initiates transaction id 12266 with host helios by requesting up to 8
  packets (the `&lt;0-7&gt;'). The hex number at the end of the line is the
  value of the `userdata' field in the request.
<p class="Pp">Helios responds with 8 512-byte packets. The `:digit' following
    the transaction id gives the packet sequence number in the transaction and
    the number in parens is the amount of data in the packet, excluding the ATP
    header. The `*' on packet 7 indicates that the EOM bit was set.</p>
<p class="Pp">Jssmag.209 then requests that packets 3 &amp; 5 be retransmitted.
    Helios resends them then jssmag.209 releases the transaction. Finally,
    jssmag.209 initiates the next request. The `*' on the request indicates that
    XO (`exactly once') was <i>not</i> set.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="PACKET_METADATA_FILTER"><a class="permalink" href="#PACKET_METADATA_FILTER">PACKET
  METADATA FILTER</a></h1>
<p class="Pp">Use packet metadata filter expression to match packets against
    descriptive information about the packet: interface, process, service type
    or direction.</p>
<p class="Pp">Note this is meaningful only with capture files in the Pcap-ng
    file format or for interfaces supporting the PKTAP data link type.</p>
<p class="Pp">The syntax supports the following operators:</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre><b>or</b>     logical or
<b>and</b>    logical and
<b>not</b>    negation
<b>(...)</b>  to group sub-expressions
<b>=</b>      is equal
<b>!=</b>     is not equal
<b>||</b>     logical or (alternate)
<b>&amp;&amp;</b>     logical and (alternate)
<b>!</b>      negation (alternate)</pre>
</div>
<p class="Pp">The syntax support the following keywords to denote which of
    packet metadata contents is to be compared:</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre><b>if</b>     interface name
<b>proc</b>   process name
<b>pid</b>    process ID
<b>svc</b>    service class
<b>dir</b>    direction
<b>eproc</b>  effective process name
<b>epid</b>   effective process ID
<b>dlt</b>    data link type</pre>
</div>
<p class="Pp">For example to filter packets from interface en0 &quot;sent&quot;
    by the process named &quot;nc&quot; or incoming packet not on interface
  en0:</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre><b>-Q &quot;( if=en0 and proc =nc ) || (if != en0 and dir=in)&quot;</b></pre>
</div>
<p class="Pp">Note that a complex packet metadata filter expression needs to be
    put in quotes as the option <b>-Q</b> takes a single string parameter.</p>
<p class="Pp">Likewise, strings that contain spaces have to be surrounded by
    quotes. For example:</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre><b>-Q &quot;proc = 'Some App'&quot;</b></pre>
</div>
<p class="Pp">Interface names can be filtered by partial string if the unit
    number is ommitted. For example use the following to include interfaces
    whose name begins with &quot;en&quot;:</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre><b>-Q &quot;if = en&quot;</b></pre>
</div>
<p class="Pp">The data link type can be specified by number or by one of the
    following symbolic names:</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>NULL
EN10MB
PPP
RAW
ether (same as EN10MB)</pre>
</div>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp"><b>stty</b>(1), <b>pcap</b>(3PCAP), <b>bpf</b>(4), <b>nit</b>(4P),
    <b>pcap-savefile</b>(5), <b>pcap-filter</b>(7), <b>pcap-tstamp</b>(7)</p>
<p class="Pp"></p>
<div class="Bd-indent"><i>https://www.iana.org/assignments/media-types/application/vnd.tcpdump.pcap</i></div>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHORS"><a class="permalink" href="#AUTHORS">AUTHORS</a></h1>
<p class="Pp">The original authors are:</p>
<p class="Pp">Van Jacobson, Craig Leres and Steven McCanne, all of the Lawrence
    Berkeley National Laboratory, University of California, Berkeley, CA.</p>
<p class="Pp">It is currently being maintained by tcpdump.org.</p>
<p class="Pp">The current version is available via HTTPS:</p>
<p class="Pp"></p>
<div class="Bd-indent"><i>https://www.tcpdump.org/</i></div>
<p class="Pp">The original distribution is available via anonymous ftp:</p>
<p class="Pp"></p>
<div class="Bd-indent"><i>ftp://ftp.ee.lbl.gov/old/tcpdump.tar.Z</i></div>
<p class="Pp">IPv6/IPsec support is added by WIDE/KAME project. This program
    uses OpenSSL/LibreSSL, under specific configurations.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="BUGS"><a class="permalink" href="#BUGS">BUGS</a></h1>
<p class="Pp">To report a security issue please send an e-mail to
    security@tcpdump.org.</p>
<p class="Pp">To report bugs and other problems, contribute patches, request a
    feature, provide generic feedback etc. please see the file
    <i>CONTRIBUTING</i> in the tcpdump source tree root.</p>
<p class="Pp">NIT doesn't let you watch your own outbound traffic, BPF will. We
    recommend that you use the latter.</p>
<p class="Pp">On Linux systems with 2.0[.x] kernels:</p>
<dl class="Bl-tag">
  <dt></dt>
  <dd>packets on the loopback device will be seen twice;</dd>
  <dt></dt>
  <dd>packet filtering cannot be done in the kernel, so that all packets must be
      copied from the kernel in order to be filtered in user mode;</dd>
  <dt></dt>
  <dd>all of a packet, not just the part that's within the snapshot length, will
      be copied from the kernel (the 2.0[.x] packet capture mechanism, if asked
      to copy only part of a packet to userspace, will not report the true
      length of the packet; this would cause most IP packets to get an error
      from <b>tcpdump</b>);</dd>
  <dt></dt>
  <dd>capturing on some PPP devices won't work correctly.</dd>
</dl>
<p class="Pp">We recommend that you upgrade to a 2.2 or later kernel.</p>
<p class="Pp">Some attempt should be made to reassemble IP fragments or, at
    least to compute the right length for the higher level protocol.</p>
<p class="Pp">Name server inverse queries are not dumped correctly: the (empty)
    question section is printed rather than real query in the answer section.
    Some believe that inverse queries are themselves a bug and prefer to fix the
    program generating them rather than <i>tcpdump</i>.</p>
<p class="Pp">A packet trace that crosses a daylight savings time change will
    give skewed time stamps (the time change is ignored).</p>
<p class="Pp">Filter expressions on fields other than those in Token Ring
    headers will not correctly handle source-routed Token Ring packets.</p>
<p class="Pp">Filter expressions on fields other than those in 802.11 headers
    will not correctly handle 802.11 data packets with both To DS and From DS
    set.</p>
<p class="Pp"><b>ip6 proto</b> should chase header chain, but at this moment it
    does not. <b>ip6 protochain</b> is supplied for this behavior.</p>
<p class="Pp">Arithmetic expression against transport layer headers, like
    <b>tcp[0]</b>, does not work against IPv6 packets. It only looks at IPv4
    packets.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2 February 2017</td>
    <td class="foot-os"></td>
  </tr>
</table>
</body>
</html>
