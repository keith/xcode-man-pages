<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    .Nd, .Bf, .Op { display: inline; }
    .Pa, .Ad { font-style: italic; }
    .Ms { font-weight: bold; }
    .Bl-diag > dt { font-weight: bold; }
    code.Nm, .Fl, .Cm, .Ic, code.In, .Fd, .Fn, .Cd { font-weight: bold;
      font-family: inherit; }
  </style>
  <title>Type::Tiny::Manual::Params(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Type::Tiny::Manual::Params(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Type::Tiny::Manual::Params(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Type::Tiny::Manual::Params - advanced information on
  Type::Params</p>
</section>
<section class="Sh">
<h1 class="Sh" id="MANUAL"><a class="permalink" href="#MANUAL">MANUAL</a></h1>
<p class="Pp">To get started with Type::Params, please read
    Type::Tiny::Manual::UsingWithMoo which will cover a lot of the basics, even
    if you're not using Moo.</p>
<section class="Ss">
<h2 class="Ss" id="_validate__and__validate_named_"><a class="permalink" href="#_validate__and__validate_named_">&quot;validate&quot;
  and &quot;validate_named&quot;</a></h2>
<p class="Pp">The generally recommended way of using Type::Params is this:</p>
<p class="Pp"></p>
<pre>  sub mysub {
    state $check = compile( SIGNATURE );
    my @args = $check-&gt;( @_ );
  }
</pre>
<p class="Pp">But it is possible to do it in one call:</p>
<p class="Pp"></p>
<pre>  sub mysub {
    my @args = validate( \@_, SIGNATURE );
  }
</pre>
<p class="Pp">There is also a <span class="Li">&quot;validate_named&quot;</span>
    function which acts as a counterpart for
    <span class="Li">&quot;compile_named&quot;</span>.</p>
<p class="Pp">This will generally be slower and less efficient than using
    <span class="Li">&quot;compile&quot;</span> first because Type::Tiny can do
    a lot of optimizations in that first stage to make the second stage a lot
    faster. (And the results of <span class="Li">&quot;compile&quot;</span> get
    stored in the <span class="Li">&quot;state&quot;</span> variable so that
    only has to happen once.)</p>
<p class="Pp">There is rarely a reason to use
    <span class="Li">&quot;validate&quot;</span> and
    <span class="Li">&quot;validate_named&quot;</span>, but they exist if you
    want them.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_multisig_"><a class="permalink" href="#_multisig_">&quot;multisig&quot;</a></h2>
<p class="Pp">Multisig allows you to allow multiple ways of calling a sub.</p>
<p class="Pp"></p>
<pre> sub repeat_string {
   state $check = multisig(
     compile(
       Int,
       Str,
     ),
     compile_named(
       { named_to_list =&gt; 1 },
       count  =&gt; Int,
       string =&gt; Str,
     ),
   );
   
   my ($count, $string) = $check-&gt;(@_);
   return $string x $count;
 }
 
 repeat_string(            &quot;Hello&quot;,          42  );    # works
 repeat_string(  string =&gt; &quot;Hello&quot;, count =&gt; 42  );    # works
 repeat_string({ string =&gt; &quot;Hello&quot;, count =&gt; 42 });    # works
 repeat_string( qr/hiya/ );                            # dies
</pre>
<p class="Pp">It combines multiple checks and tries each until one works.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_wrap_subs__and__wrap_methods_"><a class="permalink" href="#_wrap_subs__and__wrap_methods_">&quot;wrap_subs&quot;
  and &quot;wrap_methods&quot;</a></h2>
<p class="Pp"><span class="Li">&quot;wrap_subs&quot;</span> turns the
    <span class="Li">&quot;compile&quot;</span> idea inside out.</p>
<p class="Pp">Instead of this:</p>
<p class="Pp"></p>
<pre> sub foobar {
   state $check = compile(Int, Str);
   my ($foo, $bar) = @_;
   ...;
 }
</pre>
<p class="Pp">You do this:</p>
<p class="Pp"></p>
<pre> sub foobar {
   my ($foo, $bar) = @_;
   ...;
 }
 wrap_subs foobar =&gt; [ Int, Str ];
</pre>
<p class="Pp">Or this:</p>
<p class="Pp"></p>
<pre> sub foobar {
   my ($foo, $bar) = @_;
   ...;
 }
 wrap_subs foobar =&gt; compile( Int, Str );
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Mixed_Named_and_Positional_Parameters"><a class="permalink" href="#Mixed_Named_and_Positional_Parameters">Mixed
  Named and Positional Parameters</a></h2>
<p class="Pp">This can be faked using positional parameters and a slurpy
    dictionary.</p>
<p class="Pp"></p>
<pre> state $check = compile(
   Int,
   slurpy Dict[
     foo =&gt; Int,
     bar =&gt; Optional[Int],
     baz =&gt; Optional[Int],
   ],
 );
 
 @_ = (42, foo =&gt; 21);                 # ok
 @_ = (42, foo =&gt; 21, bar  =&gt; 84);     # ok
 @_ = (42, foo =&gt; 21, bar  =&gt; 10.5);   # not ok
 @_ = (42, foo =&gt; 21, quux =&gt; 84);     # not ok
</pre>
<p class="Pp">From Type::Params 1.009_002,
    <span class="Li">&quot;head&quot;</span> and
    <span class="Li">&quot;tail&quot;</span> options are accepted, which provide
    another option for mixed named and positional arguments:</p>
<p class="Pp"></p>
<pre> state $check = compile_named(
   { head =&gt; [ Int ] },
   foo =&gt; Int,
   bar =&gt; Optional[Int],
   baz =&gt; Optional[Int],
   ],
 );
</pre>
<p class="Pp">The <span class="Li">&quot;head&quot;</span> is shifted off
    <span class="Li">@_</span> before <span class="Li">@_</span> is considered
    as a hash. The <span class="Li">&quot;tail&quot;</span> is popped off
    <span class="Li">@_</span> before <span class="Li">@_</span> is considered
    as a hash.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Proper_Signatures"><a class="permalink" href="#Proper_Signatures">Proper
  Signatures</a></h2>
<p class="Pp">Don't you wish your subs could look like this?</p>
<p class="Pp"></p>
<pre>  sub set_name (Object $self, Str $name) {
    $self-&gt;{name} = $name;
  }
</pre>
<p class="Pp">Well; here are a few solutions for sub signatures that work with
    Type::Tiny...</p>
<p class="Pp"><i>Zydeco</i></p>
<p class="Pp">Zydeco is a Perl OO syntax toolkit with Type::Tiny support baked
    in throughout.</p>
<p class="Pp"></p>
<pre>  package MyApp {
    use Zydeco;
    
    class Person {
      has name ( type =&gt; Str );
      
      method rename (Str $new_name) {
        printf(&quot;%s will now be called %s\n&quot;, $self-&gt;name, $new_name);
        $self-&gt;name($new_name);
      }
      
      coerce from Str via {
        $class-&gt;new(name =&gt; $_)
      }
    }
    
    class Company {
      has owner ( type =&gt; 'Person' );
    }
  }
  
  my $acme = MyApp-&gt;new_company(owner =&gt; &quot;Robert&quot;);
  $acme-&gt;owner-&gt;rename(&quot;Bob&quot;);
</pre>
<p class="Pp"><i>Kavorka</i></p>
<p class="Pp">Kavorka is a sub signatures implementation written to natively use
    Type::Utils' <span class="Li">&quot;dwim_type&quot;</span> for type
    constraints, and take advantage of Type::Tiny's features such as inlining,
    and coercions.</p>
<p class="Pp"></p>
<pre>  method set_name (Str $name) {
    $self-&gt;{name} = $name;
  }
</pre>
<p class="Pp">Kavorka's signatures provide a lot more flexibility, and slightly
    more speed than Type::Params. (The speed comes from inlining almost all type
    checks into the body of the sub being declared.)</p>
<p class="Pp">Kavorka also includes support for type checking of the returned
    value.</p>
<p class="Pp">Kavorka can also be used as part of Moops, a larger framework for
    object oriented programming in Perl.</p>
<p class="Pp"><i>Function::Parameters</i></p>
<p class="Pp">Function::Parameters offers support for Type::Tiny and
    MooseX::Types.</p>
<p class="Pp"></p>
<pre>  use Types::Standard qw( Str );
  use Function::Parameters;
  
  method set_name (Str $name) {
      $self-&gt;{name} = $name;
  }
</pre>
<p class="Pp"><i>Attribute::Contract</i></p>
<p class="Pp">Both Kavorka and Function::Parameters require a relatively recent
    version of Perl. Attribute::Contract supports older versions by using a lot
    less magic.</p>
<p class="Pp">You want Attribute::Contract 0.03 or above.</p>
<p class="Pp"></p>
<pre>  use Attribute::Contract -types =&gt; [qw/Object Str/];
  
  sub set_name :ContractRequires(Object, Str) {
      my ($self, $name) = @_;
      $self-&gt;{name} = $name;
  }
</pre>
<p class="Pp">Attribute::Contract also includes support for type checking of the
    returned value.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Type::Params_versus_X"><a class="permalink" href="#Type::Params_versus_X">Type::Params
  versus X</a></h2>
<p class="Pp"><i>Params::Validate</i></p>
<p class="Pp">Type::Params is not really a drop-in replacement for
    Params::Validate; the API differs far too much to claim that. Yet it
    performs a similar task, so it makes sense to compare them.</p>
<ul class="Bl-bullet">
  <li>Type::Params will tend to be faster if you've got a sub which is called
      repeatedly, but may be a little slower than Params::Validate for subs that
      are only called a few times. This is because it does a bunch of work the
      first time your sub is called to make subsequent calls a lot faster.</li>
  <li>Params::Validate doesn't appear to have a particularly natural way of
      validating a mix of positional and named parameters.</li>
  <li>Type::Utils allows you to coerce parameters. For example, if you expect a
      Path::Tiny object, you could coerce it from a string.</li>
  <li>If you are primarily writing object-oriented code, using Moose or similar,
      and you are using Type::Tiny type constraints for your attributes, then
      using Type::Params allows you to use the same constraints for method
      calls.</li>
  <li>Type::Params comes bundled with Types::Standard, which provides a much
      richer vocabulary of types than the type validation constants that come
      with Params::Validate. For example, Types::Standard provides constraints
      like <span class="Li">&quot;ArrayRef[Int]&quot;</span> (an arrayref of
      integers), while the closest from Params::Validate is
      <span class="Li">&quot;ARRAYREF&quot;</span>, which you'd need to
      supplement with additional callbacks if you wanted to check that the
      arrayref contained integers.
    <p class="Pp">Whatsmore, Type::Params doesn't just work with
        Types::Standard, but also any other Type::Tiny type constraints.</p>
  </li>
</ul>
<p class="Pp"><i>Params::ValidationCompiler</i></p>
<p class="Pp">Params::ValidationCompiler does basically the same thing as
    Type::Params.</p>
<ul class="Bl-bullet">
  <li>Params::ValidationCompiler and Type::Params are likely to perform fairly
      similarly. In most cases, recent versions of Type::Params seem to be
      <i>slightly</i> faster, but except in very trivial cases, you're unlikely
      to notice the speed difference. Speed probably shouldn't be a factor when
      choosing between them.</li>
  <li>Type::Params's syntax is more compact:
    <p class="Pp"></p>
    <pre>   state $check = compile(Object, Optional[Int], slurpy ArrayRef);
    </pre>
    <p class="Pp">Versus:</p>
    <p class="Pp"></p>
    <pre>   state $check = validation_for(
      params =&gt; [
         { type =&gt; Object },
         { type =&gt; Int,      optional =&gt; 1 },
         { type =&gt; ArrayRef, slurpy =&gt; 1 },
      ],
   );
    </pre>
  </li>
  <li>Params::ValidationCompiler probably has slightly better exceptions.</li>
</ul>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="NEXT_STEPS"><a class="permalink" href="#NEXT_STEPS">NEXT
  STEPS</a></h1>
<p class="Pp">Here's your next step:</p>
<dl class="Bl-tag">
  <dt>&#x2022;</dt>
  <dd>Type::Tiny::Manual::NonOO
    <p class="Pp">Type::Tiny in non-object-oriented code.</p>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">Toby Inkster &lt;tobyink@cpan.org&gt;.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT_AND_LICENCE"><a class="permalink" href="#COPYRIGHT_AND_LICENCE">COPYRIGHT
  AND LICENCE</a></h1>
<p class="Pp">This software is copyright (c) 2013-2014, 2017-2020 by Toby
    Inkster.</p>
<p class="Pp">This is free software; you can redistribute it and/or modify it
    under the same terms as the Perl 5 programming language system itself.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DISCLAIMER_OF_WARRANTIES"><a class="permalink" href="#DISCLAIMER_OF_WARRANTIES">DISCLAIMER
  OF WARRANTIES</a></h1>
<p class="Pp">THIS PACKAGE IS PROVIDED &quot;AS IS&quot; AND WITHOUT ANY EXPRESS
    OR IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES
    OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2020-10-28</td>
    <td class="foot-os">perl v5.30.2</td>
  </tr>
</table>
</body>
</html>
