<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.10 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>install::TempContent::Objects::mod_perl-2.0.9::docs::api::APR::Socket(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">install::TempContent::Objects::mod_perl-2.0.9::docs::api::APR::Socket(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">install::TempContent::Objects::mod_perl-2.0.9::docs::api::APR::Socket(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
APR::Socket - Perl API for APR sockets
</section>
<section class="Sh">
<h1 class="Sh" id="Synopsis"><a class="permalink" href="#Synopsis">Synopsis</a></h1>
<span class="Li"></span>
<pre>
  use APR::Socket ();
  
  ### set the socket to the blocking mode if it isn't already
  ### and read in the loop and echo it back
  use APR::Const -compile =&gt; qw(SO_NONBLOCK);
  if ($sock-&gt;opt_get(APR::Const::SO_NONBLOCK)) {
      $sock-&gt;opt_set(APR::Const::SO_NONBLOCK =&gt; 0);
  }
  # read from/write to the socket (w/o handling possible failures)
  my $wanted = 1024;
  while ($sock-&gt;recv(my $buff, $wanted)) {
      $sock-&gt;send($buff);
  }

  ### get/set IO timeout and try to read some data
  use APR::Const -compile =&gt; qw(TIMEUP);
  # timeout is in usecs!
  my $timeout = $sock-&gt;timeout_get();
  if ($timeout &lt; 10_000_000) {
      $sock-&gt;timeout_set(20_000_000); # 20 secs
  }
  # now read, while handling timeouts
  my $wanted = 1024;
  my $buff;
  my $rlen = eval { $sock-&gt;recv($buff, $wanted) };
  if ($@ &amp;&amp; ref $@ &amp;&amp; $@ == APR::Const::TIMEUP) {
      # timeout, do something, e.g.
      warn &quot;timed out, will try again later&quot;;
  }
  else {
      warn &quot;asked for $wanted bytes, read $rlen bytes\n&quot;;
      # do something with the data
  }

  # non-blocking io poll
  $sock-&gt;opt_set(APR::Const::SO_NONBLOCK =&gt; 1);
  my $rc = $sock-&gt;poll($c-&gt;pool, 1_000_000, APR::Const::POLLIN);
  if ($rc == APR::Const::SUCCESS) {
      # read the data
  }
  else {
      # handle the condition
  }

  # fetch the operating level socket
  my $fd=$sock-&gt;fileno;
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="Description"><a class="permalink" href="#Description">Description</a></h1>
<span class="Li">&quot;APR::Socket&quot;</span> provides the Perl interface to
  APR sockets.
</section>
<section class="Sh">
<h1 class="Sh" id="API"><a class="permalink" href="#API">API</a></h1>
<span class="Li">&quot;APR::Socket&quot;</span> provides the following methods:
<section class="Ss">
<h2 class="Ss" id="_fileno_"><a class="permalink" href="#_fileno_">&quot;fileno&quot;</a></h2>
Get the operating system socket, the file descriptor on UNIX.
<p class="Pp"><span class="Li"></span></p>
<pre>
  $fd = $sock-&gt;fileno;
</pre>
<dl class="Bl-tag">
  <dt>obj: $sock ( &quot;APR::Socket object&quot; )</dt>
  <dd>The socket</dd>
  <dt>ret: $fd ( integer )</dt>
  <dd>The OS-level file descriptor.</dd>
  <dt>since: 2.0.5 (not implemented on Windows)</dt>
  <dd></dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="_opt_get_"><a class="permalink" href="#_opt_get_">&quot;opt_get&quot;</a></h2>
Query socket options for the specified socket
<p class="Pp"><span class="Li"></span></p>
<pre>
  $val = $sock-&gt;opt_get($opt);
</pre>
<dl class="Bl-tag">
  <dt>obj: $sock ( &quot;APR::Socket object&quot; )</dt>
  <dd>the socket object to query</dd>
  <dt>arg1: $opt ( &quot;APR::Const constant&quot; )</dt>
  <dd>the socket option we would like to configure. Here are the available
      socket options.</dd>
  <dt>ret: $val ( integer )</dt>
  <dd>the currently set value for the socket option you've queried for</dd>
  <dt>excpt: &quot;APR::Error&quot;</dt>
  <dd></dd>
  <dt>since: 2.0.00</dt>
  <dd></dd>
</dl>
<p class="Pp">Examples can be found in the socket options constants section. For
    example setting the IO to the blocking mode.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_opt_set_"><a class="permalink" href="#_opt_set_">&quot;opt_set&quot;</a></h2>
Setup socket options for the specified socket
<p class="Pp"><span class="Li"></span></p>
<pre>
  $sock-&gt;opt_set($opt, $val);
</pre>
<dl class="Bl-tag">
  <dt>obj: $sock ( &quot;APR::Socket object&quot; object )</dt>
  <dd>the socket object to set up.</dd>
  <dt>arg1: $opt ( &quot;APR::Const&quot; constant )</dt>
  <dd>the socket option we would like to configure. Here are the available
      socket options.</dd>
  <dt>arg2: $val ( integer )</dt>
  <dd>value for the option. Refer to the socket options section to learn about
      the expected values.</dd>
  <dt>ret: no return value</dt>
  <dd></dd>
  <dt>excpt: &quot;APR::Error&quot;</dt>
  <dd></dd>
  <dt>since: 2.0.00</dt>
  <dd></dd>
</dl>
<p class="Pp">Examples can be found in the socket options constants section. For
    example setting the IO to the blocking mode.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_poll_"><a class="permalink" href="#_poll_">&quot;poll&quot;</a></h2>
Poll the socket for events:
<p class="Pp"><span class="Li"></span></p>
<pre>
    $rc = $sock-&gt;poll($pool, $timeout, $events);
</pre>
<dl class="Bl-tag">
  <dt>obj: $sock ( &quot;APR::Socket object&quot; )</dt>
  <dd>The socket to poll</dd>
  <dt>arg1: $pool ( &quot;APR::Pool object&quot; )</dt>
  <dd>usually <span class="Li">&quot;$c-&gt;pool&quot;</span>.</dd>
  <dt>arg2: $timeout ( integer )</dt>
  <dd>The amount of time to wait (in milliseconds) for the specified events to
      occur.</dd>
  <dt>arg3: $events ( &quot;APR::Const :poll constants&quot; )</dt>
  <dd>The events for which to wait.
    <p class="Pp">For example use
        <span class="Li">&quot;APR::Const::POLLIN&quot;</span> to wait for
        incoming data to be available,
        <span class="Li">&quot;APR::Const::POLLOUT&quot;</span> to wait until
        it's possible to write data to the socket and
        <span class="Li">&quot;APR::Const::POLLPRI&quot;</span> to wait for
        priority data to become available.</p>
  </dd>
  <dt>ret: $rc ( &quot;APR::Const constant&quot; )</dt>
  <dd>If <span class="Li">&quot;APR::Const::SUCCESS&quot;</span> is received
      than the polling was successful. If not -- the error code is returned,
      which can be converted to the error string with help of
      <span class="Li">&quot;APR::Error::strerror&quot;</span>.</dd>
  <dt>since: 2.0.00</dt>
  <dd></dd>
</dl>
<p class="Pp">For example poll a non-blocking socket up to 1 second when reading
    data from the client:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  use APR::Socket ();
  use APR::Connection ();
  use APR::Error ();
  
  use APR::Const -compile =&gt; qw(SO_NONBLOCK POLLIN SUCCESS TIMEUP);
  
  $sock-&gt;opt_set(APR::Const::SO_NONBLOCK =&gt; 1);
  
  my $rc = $sock-&gt;poll($c-&gt;pool, 1_000_000, APR::Const::POLLIN);
  if ($rc == APR::Const::SUCCESS) {
      # Data is waiting on the socket to be read.
      # $sock-&gt;recv(my $buf, BUFF_LEN)
  }
  elsif ($rc == APR::Const::TIMEUP) {
      # One second elapsed and still there is no data waiting to be
      # read. for example could try again.
  }
  else {
      die &quot;poll error: &quot; . APR::Error::strerror($rc);
  }
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="_recv_"><a class="permalink" href="#_recv_">&quot;recv&quot;</a></h2>
Read incoming data from the socket
<p class="Pp"><span class="Li"></span></p>
<pre>
  $len = $sock-&gt;recv($buffer, $wanted);
</pre>
<dl class="Bl-tag">
  <dt>obj: $sock ( &quot;APR::SockAddr object&quot; object )</dt>
  <dd>The socket to read from</dd>
  <dt>arg1: $buffer ( SCALAR )</dt>
  <dd>The buffer to fill. All previous data will be lost.</dd>
  <dt>arg2: $wanted ( int )</dt>
  <dd>How many bytes to attempt to read.</dd>
  <dt>ret: $len ( number )</dt>
  <dd>How many bytes were actually read.
    <p class="Pp"><span class="Li">$buffer</span> gets populated with the string
        that is read. It will contain an empty string if there was nothing to
        read.</p>
  </dd>
  <dt>excpt: &quot;APR::Error&quot;</dt>
  <dd>If you get the <span class="Li">'(11) Resource temporarily
      unavailable'</span> error (exception
      <span class="Li">&quot;APR::Const::EAGAIN&quot;</span>) (or another
      equivalent, which might be different on non-POSIX systems), then you
      didn't ensure that the socket is in a blocking IO mode before using it.
      Note that you should use
      <span class="Li">&quot;APR::Status::is_EAGAIN&quot;</span> to perform this
      check (since different error codes may be returned for the same event on
      different OSes). For example if the socket is set to the non-blocking mode
      and there is no data right away, you may get this exception thrown. So
      here is how to check for it and retry a few times after short delays:
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  use APR::Status ();
  $sock-&gt;opt_set(APR::Const::SO_NONBLOCK, 1);
  # ....
  my $tries = 0;
  my $buffer;
  RETRY: my $rlen = eval { $socket-&gt;recv($buffer, SIZE) };
  if ($@)
      die $@ unless ref $@ &amp;&amp; APR::Status::is_EAGAIN($@);
      if ($tries++ &lt; 3) {
          # sleep 250msec
          select undef, undef, undef, 0.25;
          goto RETRY;
      }
      else {
          # do something else
      }
  }
  warn &quot;read $rlen bytes\n&quot;
    </pre>
    <p class="Pp">If timeout was set via
        <span class="Li">&quot;timeout_set|/C_timeout_set_&quot;</span>, you may
        need to catch the <span class="Li">&quot;APR::Const::TIMEUP&quot;</span>
        exception. For example:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  use APR::Const -compile =&gt; qw(TIMEUP);
  $sock-&gt;timeout_set(1_000_000); # 1 sec
  my $buffer;
  eval { $sock-&gt;recv($buffer, $wanted) };
  if ($@ &amp;&amp; $@ == APR::Const::TIMEUP) {
      # timeout, do something, e.g.
  }
    </pre>
    <p class="Pp">If not handled -- you may get the error
        <span class="Li">'70007: The timeout</span> <span class="Li">specified
        has expired'</span>.</p>
    <p class="Pp">Another error condition that may occur is the
        <span class="Li">'(104) Connection</span> <span class="Li">reset by
        peer'</span> error, which is up to your application logic to decide
        whether it's an error or not. This error usually happens when the client
        aborts the connection.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  use APR::Const -compile =&gt; qw(ECONNABORTED);
  my $buffer;
  eval { $sock-&gt;recv($buffer, $wanted) };
  if ($@ == APR::Const::ECONNABORTED) {
      # ignore it or deal with it
  }
    </pre>
  </dd>
  <dt>since: 2.0.00</dt>
  <dd></dd>
</dl>
<p class="Pp">Here is the quick prototype example, which doesn't handle any
    errors (mod_perl will do that for you):</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  use APR::Socket ();
  
  # set the socket to the blocking mode if it isn't already
  use APR::Const -compile =&gt; qw(SO_NONBLOCK);
  if ($sock-&gt;opt_get(APR::Const::SO_NONBLOCK)) {
      $sock-&gt;opt_set(APR::Const::SO_NONBLOCK =&gt; 0);
  }
  # read from/write to the socket (w/o handling possible failures)
  my $wanted = 1024;
  while ($sock-&gt;recv(my $buffer, $wanted)) {
      $sock-&gt;send($buffer);
  }
</pre>
<p class="Pp">If you want to handle errors by yourself, the loop may look
  like:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  use APR::Const -compile =&gt; qw(ECONNABORTED);
  # ...
  while (1) {
      my $buf;
      my $len = eval { $sock-&gt;recv($buf, $wanted) };
      if ($@) {
          # handle the error, e.g. to ignore aborted connections but
          # rethrow any other errors:
          if ($@ == APR::Const::ECONNABORTED) {
              # ignore
              last;
          }
          else {
              die $@; # retrow
          }
      }
  
      if ($len) {
          $sock-&gt;send($buffer);
      }
      else {
          last;
      }
  }
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="_send_"><a class="permalink" href="#_send_">&quot;send&quot;</a></h2>
Write data to the socket
<p class="Pp"><span class="Li"></span></p>
<pre>
  $wlen = $sock-&gt;send($buf, $opt_len);
</pre>
<dl class="Bl-tag">
  <dt>obj: $sock ( &quot;APR::Socket object&quot; )</dt>
  <dd>The socket to write to</dd>
  <dt>arg1: $buf ( scalar )</dt>
  <dd>The data to send</dd>
  <dt>opt arg2: $opt_len ( int )</dt>
  <dd>There is no need to pass this argument, unless you want to send less data
      than contained in <span class="Li">$buf</span>.</dd>
  <dt>ret: $wlen ( integer )</dt>
  <dd>How many bytes were sent</dd>
  <dt>since: 2.0.00</dt>
  <dd></dd>
</dl>
<p class="Pp">For examples see the <span class="Li">&quot;recv&quot;</span>
    item.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_timeout_get_"><a class="permalink" href="#_timeout_get_">&quot;timeout_get&quot;</a></h2>
Get socket timeout settings
<p class="Pp"><span class="Li"></span></p>
<pre>
  $usecs = $sock-&gt;timeout_get();
</pre>
<dl class="Bl-tag">
  <dt>obj: $sock ( &quot;APR::Socket object&quot; )</dt>
  <dd>The socket to set up.</dd>
  <dt>ret: $usecs ( number)</dt>
  <dd>Currently set timeout in microseconds (and also the blocking IO behavior).
      See (<span class="Li">&quot;APR::timeout_set&quot;</span>) for possible
      values and their meaning.</dd>
  <dt>excpt: &quot;APR::Error&quot;</dt>
  <dd></dd>
  <dt>since: 2.0.00</dt>
  <dd></dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="_timeout_set_"><a class="permalink" href="#_timeout_set_">&quot;timeout_set&quot;</a></h2>
Setup socket timeout.
<p class="Pp"><span class="Li"></span></p>
<pre>
  $sock-&gt;timeout_set($usecs);
</pre>
<dl class="Bl-tag">
  <dt>obj: $sock ( &quot;APR::Socket object&quot; )</dt>
  <dd>The socket to set up.</dd>
  <dt>arg1: $usecs ( number )</dt>
  <dd>Value for the timeout in microseconds and also the blocking IO behavior.
    <p class="Pp">The possible values are:</p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>t &gt; 0</dt>
  <dd><span class="Li">&quot;send()&quot;</span> and
      <span class="Li">&quot;recv()&quot;</span> throw
      (<span class="Li">&quot;APR::Const::TIMEUP&quot;</span> exception) if
      specified time elapses with no data sent or received.
    <p class="Pp">Notice that the positive value is in micro seconds. So if you
        want to set the timeout for 5 seconds, the value should be:
      5_000_000.</p>
    <p class="Pp">This mode sets the socket into a non-blocking IO mode.</p>
  </dd>
  <dt>t == 0</dt>
  <dd><span class="Li">&quot;send()&quot;</span> and
      <span class="Li">&quot;recv()&quot;</span> calls never block.</dd>
  <dt>t &lt; 0</dt>
  <dd><span class="Li">&quot;send()&quot;</span> and
      <span class="Li">&quot;recv()&quot;</span> calls block.
    <p class="Pp">Usually just -1 is used for this case, but any negative value
        will do.</p>
    <p class="Pp">This mode sets the socket into a blocking IO mode.</p>
  </dd>
  <dt>ret: no return value</dt>
  <dd></dd>
</dl>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>excpt: &quot;APR::Error&quot;</dt>
  <dd></dd>
  <dt>since: 2.0.00</dt>
  <dd></dd>
</dl>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="Unsupported_API"><a class="permalink" href="#Unsupported_API">Unsupported
  API</a></h1>
<span class="Li">&quot;APR::Socket&quot;</span> also provides auto-generated
  Perl interface for a few other methods which aren't tested at the moment and
  therefore their API is a subject to change. These methods will be finalized
  later as a need arises. If you want to rely on any of the following methods
  please contact the the mod_perl development mailing list so we can help each
  other take the steps necessary to shift the method to an officially supported
  API.
<section class="Ss">
<h2 class="Ss" id="_bind_"><a class="permalink" href="#_bind_">&quot;bind&quot;</a></h2>
META: Autogenerated - needs to be reviewed/completed
<p class="Pp">Bind the socket to its associated port</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  $ret = $sock-&gt;bind($sa);
</pre>
<dl class="Bl-tag">
  <dt>obj: $sock ( &quot;APR::Socket object&quot; )</dt>
  <dd>The socket to bind</dd>
  <dt>arg1: $sa ( &quot;APR::SockAddr object&quot; )</dt>
  <dd>The socket address to bind to</dd>
  <dt>ret: $ret ( integer )</dt>
  <dd></dd>
  <dt>since: subject to change</dt>
  <dd></dd>
</dl>
<p class="Pp">This may be where we will find out if there is any other process
    using the selected port.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_close_"><a class="permalink" href="#_close_">&quot;close&quot;</a></h2>
META: Autogenerated - needs to be reviewed/completed
<p class="Pp">Close a socket.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  $ret = $sock-&gt;close();
</pre>
<dl class="Bl-tag">
  <dt>obj: $sock ( &quot;APR::Socket object&quot; )</dt>
  <dd>The socket to close</dd>
  <dt>ret: $ret ( integer )</dt>
  <dd></dd>
  <dt>since: subject to change</dt>
  <dd></dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="_connect_"><a class="permalink" href="#_connect_">&quot;connect&quot;</a></h2>
META: Autogenerated - needs to be reviewed/completed
<p class="Pp">Issue a connection request to a socket either on the same machine
    or a different one.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  $ret = $sock-&gt;connect($sa);
</pre>
<dl class="Bl-tag">
  <dt>obj: $sock ( &quot;APR::Socket object&quot; )</dt>
  <dd>The socket we wish to use for our side of the connection</dd>
  <dt>arg1: $sa ( &quot;APR::SockAddr object&quot; )</dt>
  <dd>The address of the machine we wish to connect to. If NULL, APR assumes
      that the sockaddr_in in the apr_socket is completely filled out.</dd>
  <dt>ret: $ret ( integer )</dt>
  <dd></dd>
  <dt>since: subject to change</dt>
  <dd></dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="_listen_"><a class="permalink" href="#_listen_">&quot;listen&quot;</a></h2>
META: Autogenerated - needs to be reviewed/completed
<p class="Pp">Listen to a bound socket for connections.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  $ret = $sock-&gt;listen($backlog);
</pre>
<dl class="Bl-tag">
  <dt>obj: $sock ( &quot;APR::Socket object&quot; )</dt>
  <dd>The socket to listen on</dd>
  <dt>arg1: $backlog ( integer )</dt>
  <dd>The number of outstanding connections allowed in the sockets listen queue.
      If this value is less than zero, the listen queue size is set to
    zero.</dd>
  <dt>ret: $ret ( integer )</dt>
  <dd></dd>
  <dt>since: subject to change</dt>
  <dd></dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="_recvfrom_"><a class="permalink" href="#_recvfrom_">&quot;recvfrom&quot;</a></h2>
META: Autogenerated - needs to be reviewed/completed
<p class="Pp"><span class="Li"></span></p>
<pre>
  $ret = $from-&gt;recvfrom($sock, $flags, $buf, $len);
</pre>
<dl class="Bl-tag">
  <dt>obj: $from ( &quot;APR::SockAddr object&quot; )</dt>
  <dd>The apr_sockaddr_t to fill in the recipient info</dd>
  <dt>arg1: $sock ( &quot;APR::SockAddr object&quot; )</dt>
  <dd>The socket to use</dd>
  <dt>arg2: $flags ( integer )</dt>
  <dd>The flags to use</dd>
  <dt>arg3: $buf ( integer )</dt>
  <dd>The buffer to use</dd>
  <dt>arg4: $len ( string )</dt>
  <dd>The length of the available buffer</dd>
  <dt>ret: $ret ( integer )</dt>
  <dd></dd>
  <dt>since: subject to change</dt>
  <dd></dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="_sendto_"><a class="permalink" href="#_sendto_">&quot;sendto&quot;</a></h2>
META: Autogenerated - needs to be reviewed/completed
<p class="Pp"><span class="Li"></span></p>
<pre>
  $ret = $sock-&gt;sendto($where, $flags, $buf, $len);
</pre>
<dl class="Bl-tag">
  <dt>obj: $sock ( &quot;APR::Socket object&quot; )</dt>
  <dd>The socket to send from</dd>
  <dt>arg1: $where ( &quot;APR::Socket object&quot; )</dt>
  <dd>The apr_sockaddr_t describing where to send the data</dd>
  <dt>arg2: $flags ( integer )</dt>
  <dd>The flags to use</dd>
  <dt>arg3: $buf ( scalar )</dt>
  <dd>The data to send</dd>
  <dt>arg4: $len ( string )</dt>
  <dd>The length of the data to send</dd>
  <dt>ret: $ret ( integer )</dt>
  <dd></dd>
  <dt>since: subject to change</dt>
  <dd></dd>
</dl>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="See_Also"><a class="permalink" href="#See_Also">See
  Also</a></h1>
mod_perl 2.0 documentation.
</section>
<section class="Sh">
<h1 class="Sh" id="Copyright"><a class="permalink" href="#Copyright">Copyright</a></h1>
mod_perl 2.0 and its core modules are copyrighted under The Apache Software
  License, Version 2.0.
</section>
<section class="Sh">
<h1 class="Sh" id="Authors"><a class="permalink" href="#Authors">Authors</a></h1>
The mod_perl development team and numerous contributors.
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2015-06-18</td>
    <td class="foot-os">perl v5.28.2</td>
  </tr>
</table>
</body>
</html>
