<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>TREEREG(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">TREEREG(1)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">TREEREG(1)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
treereg - Compiler for Tree Regular Expressions
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<span class="Li"></span>
<pre>
  treereg [-m packagename] [[no]syntax] [[no]numbers] [-severity 0|1|2|3] \
          [-p treeprefix] [-o outputfile] [-lib /path/to/library/] -i filename[.trg] 
  treereg [-m packagename] [[no]syntax] [[no]numbers] [-severity 0|1|2|3] \
          [-p treeprefix] [-lib /path/to/library/] [-o outputfile] filename[.trg] 
  treereg -v 
  treereg -h
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="OPTIONS"><a class="permalink" href="#OPTIONS">OPTIONS</a></h1>
Options can be used both with one dash and double dash. It is not necessary to
  write the full name of the option. A disambiguation prefix suffices.
<ul class="Bl-bullet">
  <li><span class="Li">&quot;-i[n] filename&quot;</span>
    <p class="Pp">Input file. Extension <span class="Li">&quot;.trg&quot;</span>
        is assumed if no extension is provided.</p>
  </li>
  <li><span class="Li">&quot;-o[ut] filename&quot;</span>
    <p class="Pp">Output file. By default is the name of the input file
        (concatenated with .pm)</p>
  </li>
  <li><span class="Li">&quot;-m[od] packagename&quot;</span>
    <p class="Pp">Name of the package containing the generated subroutines. By
        default is the longest prefix of the input file name that conforms to
        the classic definition of integer
        <span class="Li">&quot;[a-z_A-Z]\w*&quot;</span>.</p>
  </li>
  <li><span class="Li">&quot;-l[ib] /path/to/library/&quot;</span>
    <p class="Pp">Specifies that
        <span class="Li">&quot;/path/to/library/&quot;</span> will be included
        in <span class="Li">@INC</span>. Useful when the
        <span class="Li">&quot;syntax&quot;</span> option is on. Can be inserted
        as many times as necessary.</p>
  </li>
  <li><span class="Li">&quot;-p[refix] treeprefix&quot;</span>
    <p class="Pp">Tree nodes automatically generated using
        <span class="Li">&quot;Parse::Eyapp&quot;</span> are objects blessed
        into the name of the production. To avoid crashes the programmer may
        prefix the class names with a given prefix when calling the parser; for
        example:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  $self-&gt;YYParse( yylex =&gt; \&amp;_Lexer, yyerror =&gt; \&amp;_Error, yyprefix =&gt; __PACKAGE__.&quot;::&quot;)
    </pre>
    <p class="Pp">The <span class="Li">&quot;-prefix treeprefix&quot;</span>
        option simplifies the process of writing the tree grammar so that
        instead of writing with the full names</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
 CLASS::TIMES(CLASS::NUM, $x) and { $NUM-&gt;{VAL} == 0) =&gt; { $NUM }
    </pre>
    <p class="Pp">it can be written:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
 TIMES(NUM, $x) and { $NUM-&gt;{VAL} == 0) =&gt; { $NUM }
    </pre>
  </li>
  <li><span class="Li">&quot;-n[umbers]&quot;</span>
    <p class="Pp">Produces <span class="Li">&quot;#line&quot;</span>
      directives.</p>
  </li>
  <li><span class="Li">&quot;-non[umbers]&quot;</span>
    <p class="Pp">Disable source file line numbering embedded in your parser</p>
  </li>
  <li><span class="Li">&quot;-sy[ntax]&quot;</span>
    <p class="Pp">Checks that Perl code is syntactically correct.</p>
  </li>
  <li><span class="Li">&quot;-nosy[ntax]&quot;</span>
    <p class="Pp">Does not check the syntax of Perl code</p>
  </li>
  <li><span class="Li">&quot;-se[verity] number&quot;</span></li>
</ul>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>- 0 = Don't check arity (default). Matching does not check the arity. The
    actual node being visited may have more children.</dt>
  <dd></dd>
  <dt>- 1 = Check arity. Matching requires the equality of the number of
    children and the actual node and the pattern.</dt>
  <dd></dd>
  <dt>- 2 = Check arity and give a warning</dt>
  <dd></dd>
  <dt>- 3 = Check arity, give a warning and exit</dt>
  <dd></dd>
</dl>
</div>
<div class="Bd-indent"></div>
<ul class="Bl-bullet">
  <li><span class="Li">&quot;-v[ersion]&quot;</span>
    <p class="Pp">Gives the version</p>
  </li>
  <li><span class="Li">&quot;-u[sage]&quot;</span>
    <p class="Pp">Prints the usage info</p>
  </li>
  <li><span class="Li">&quot;-h[elp]&quot;</span>
    <p class="Pp">Print this help</p>
  </li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<span class="Li">&quot;Treereg&quot;</span> translates a tree grammar
  specification file (default extension <span class="Li">&quot;.trg&quot;</span>
  describing a set of tree patterns and the actions to modify them using
  tree-terms like:
<p class="Pp"><span class="Li"></span></p>
<pre>
  TIMES(NUM, $x) and { $NUM-&gt;{VAL} == 0) =&gt; { $NUM }
</pre>
<p class="Pp">which says that wherever an abstract syntax tree representing the
    product of a numeric expression with value 0 times any other kind of
    expression, the <span class="Li">&quot;TIMES&quot;</span> tree can be
    substituted by its left child.</p>
<p class="Pp">The compiler produces a Perl module containing the subroutines
    implementing those sets of pattern-actions.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="EXAMPLE"><a class="permalink" href="#EXAMPLE">EXAMPLE</a></h1>
Consider the following <span class="Li">&quot;eyapp&quot;</span> grammar (see
  the <span class="Li">&quot;Parse::Eyapp&quot;</span> documentation to know
  more about <span class="Li">&quot;Parse::Eyapp&quot;</span> grammars):
<p class="Pp"><span class="Li"></span></p>
<pre>
  ----------------------------------------------------------
  nereida:~/LEyapp/examples&gt; cat Rule6.yp
  %{
  use Data::Dumper;
  %}
  %right  '='
  %left   '-' '+'
  %left   '*' '/'
  %left   NEG
  %tree

  %%
  line: exp  { $_[1] }
  ;

  exp:      %name NUM
              NUM
          | %name VAR
            VAR
          | %name ASSIGN
            VAR '=' exp
          | %name PLUS
            exp '+' exp
          | %name MINUS
            exp '-' exp
          | %name TIMES
            exp '*' exp
          | %name DIV
            exp '/' exp
          | %name UMINUS
            '-' exp %prec NEG
          |   '(' exp ')'  { $_[2] } /* Let us simplify a bit the tree */
  ;

  %%

  sub _Error {
      die  &quot;Syntax error.\n&quot;;
  }

  sub _Lexer {
      my($parser)=shift;

          $parser-&gt;YYData-&gt;{INPUT}
      or  $parser-&gt;YYData-&gt;{INPUT} = &lt;STDIN&gt;
      or  return('',undef);

      $parser-&gt;YYData-&gt;{INPUT}=~s/^\s+//;

      for ($parser-&gt;YYData-&gt;{INPUT}) {
          s/^([0-9]+(?:\.[0-9]+)?)// and return('NUM',$1);
          s/^([A-Za-z][A-Za-z0-9_]*)// and return('VAR',$1);
          s/^(.)//s and return($1,$1);
      }
  }

  sub Run {
      my($self)=shift;
      $self-&gt;YYParse( yylex =&gt; \&amp;_Lexer, yyerror =&gt; \&amp;_Error );
  }
  ----------------------------------------------------------
</pre>
<p class="Pp">Compile it using <span class="Li">&quot;eyapp&quot;</span>:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  ----------------------------------------------------------
  nereida:~/LEyapp/examples&gt; eyapp Rule6.yp
  nereida:~/LEyapp/examples&gt; ls -ltr | tail -1
  -rw-rw----  1 pl users  4976 2006-09-15 19:56 Rule6.pm
  ----------------------------------------------------------
</pre>
<p class="Pp">Now consider this tree grammar:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  ----------------------------------------------------------
  nereida:~/LEyapp/examples&gt; cat Transform2.trg
  %{
  my %Op = (PLUS=&gt;'+', MINUS =&gt; '-', TIMES=&gt;'*', DIV =&gt; '/');
  %}

  fold: 'TIMES|PLUS|DIV|MINUS':bin(NUM($n), NUM($m))
    =&gt; {
      my $op = $Op{ref($bin)};
      $n-&gt;{attr} = eval  &quot;$n-&gt;{attr} $op $m-&gt;{attr}&quot;;
      $_[0] = $NUM[0];
    }
  zero_times_whatever: TIMES(NUM($x), .) and { $x-&gt;{attr} == 0 } =&gt; { $_[0] = $NUM }
  whatever_times_zero: TIMES(., NUM($x)) and { $x-&gt;{attr} == 0 } =&gt; { $_[0] = $NUM }

  /* rules related with times */
  times_zero = zero_times_whatever whatever_times_zero;
  ----------------------------------------------------------
</pre>
<p class="Pp">Compile it with <span class="Li">&quot;treereg&quot;</span>:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  ----------------------------------------------------------
  nereida:~/LEyapp/examples&gt; treereg Transform2.trg
  nereida:~/LEyapp/examples&gt; ls -ltr | tail -1
  -rw-rw----  1 pl users  1948 2006-09-15 19:57 Transform2.pm
  ----------------------------------------------------------
</pre>
<p class="Pp">The following program makes use of both modules
    <span class="Li">&quot;Rule6.pm&quot;</span> and
    <span class="Li">&quot;Transform2.pm&quot;</span>:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  ----------------------------------------------------------
  nereida:~/LEyapp/examples&gt; cat foldand0rule6_3.pl
  #!/usr/bin/perl -w
  use strict;
  use Rule6;
  use Parse::Eyapp::YATW;
  use Data::Dumper;
  use Transform2;

  $Data::Dumper::Indent = 1;
  my $parser = new Rule6();
  my $t = $parser-&gt;Run;
  print &quot;\n***** Before ******\n&quot;;
  print Dumper($t);
  $t-&gt;s(@Transform2::all);
  print &quot;\n***** After ******\n&quot;;
  print Dumper($t);
  ----------------------------------------------------------
</pre>
<p class="Pp">When the program runs with input
    <span class="Li">&quot;b*(2-2)&quot;</span> produces the following
  output:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  ----------------------------------------------------------
  nereida:~/LEyapp/examples&gt; foldand0rule6_3.pl
  b*(2-2)

  ***** Before ******
  $VAR1 = bless( {
    'children' =&gt; [
      bless( {
        'children' =&gt; [
          bless( { 'children' =&gt; [], 'attr' =&gt; 'b', 'token' =&gt; 'VAR' }, 'TERMINAL' )
        ]
      }, 'VAR' ),
      bless( {
        'children' =&gt; [
          bless( { 'children' =&gt; [
              bless( { 'children' =&gt; [], 'attr' =&gt; '2', 'token' =&gt; 'NUM' }, 'TERMINAL' )
            ]
          }, 'NUM' ),
          bless( {
            'children' =&gt; [
              bless( { 'children' =&gt; [], 'attr' =&gt; '2', 'token' =&gt; 'NUM' }, 'TERMINAL' )
            ]
          }, 'NUM' )
        ]
      }, 'MINUS' )
    ]
  }, 'TIMES' );

  ***** After ******
  $VAR1 = bless( {
    'children' =&gt; [
      bless( { 'children' =&gt; [], 'attr' =&gt; 0, 'token' =&gt; 'NUM' }, 'TERMINAL' )
    ]
  }, 'NUM' );
  ----------------------------------------------------------
</pre>
<p class="Pp">See also the section &quot;Compiling: More Options&quot; in
    Parse::Eyapp for a more contrived example.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<ul class="Bl-bullet">
  <li>Parse::Eyapp,</li>
  <li>eyapptut</li>
  <li>The pdf file in
      &lt;http://nereida.deioc.ull.es/~pl/perlexamples/Eyapp.pdf&gt;</li>
  <li>&lt;http://nereida.deioc.ull.es/~pl/perlexamples/section_eyappts.html&gt;
      (Spanish),</li>
  <li>eyapp,</li>
  <li>treereg,</li>
  <li>Parse::yapp,</li>
  <li><i>yacc</i>(1),</li>
  <li><i>bison</i>(1),</li>
  <li>the classic book &quot;Compilers: Principles, Techniques, and Tools&quot;
      by Alfred V. Aho, Ravi Sethi and</li>
  <li>Jeffrey D. Ullman (Addison-Wesley 1986)</li>
  <li>Parse::RecDescent.</li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
Casiano Rodriguez-Leon
</section>
<section class="Sh">
<h1 class="Sh" id="LICENSE_AND_COPYRIGHT"><a class="permalink" href="#LICENSE_AND_COPYRIGHT">LICENSE
  AND COPYRIGHT</a></h1>
Copyright (C) 2006 by Casiano Rodriguez-Leon
<p class="Pp">This library is free software; you can redistribute it and/or
    modify it under the same terms as Perl itself, either Perl version 5.8.8 or,
    at your option, any later version of Perl 5 you may have available.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2009-11-06</td>
    <td class="foot-os">perl v5.18.2</td>
  </tr>
</table>
</body>
</html>
