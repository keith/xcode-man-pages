<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    .Nd, .Bf, .Op { display: inline; }
    .Pa, .Ad { font-style: italic; }
    .Ms { font-weight: bold; }
    .Bl-diag > dt { font-weight: bold; }
    code.Nm, .Fl, .Cm, .Ic, code.In, .Fd, .Fn, .Cd { font-weight: bold;
      font-family: inherit; }
  </style>
  <title>Types::Standard(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Types::Standard(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Types::Standard(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Types::Standard - bundled set of built-in types for Type::Tiny</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre> use v5.12;
 use strict;
 use warnings;
 
 package Horse {
   use Moo;
   use Types::Standard qw( Str Int Enum ArrayRef Object );
   use Type::Params qw( compile );
   use namespace::autoclean;
   
   has name =&gt; (
     is       =&gt; 'ro',
     isa      =&gt; Str,
     required =&gt; 1,
   );
   has gender =&gt; (
     is       =&gt; 'ro',
     isa      =&gt; Enum[qw( f m )],
   );
   has age =&gt; (
     is       =&gt; 'rw',
     isa      =&gt; Int-&gt;where( '$_ &gt;= 0' ),
   );
   has children =&gt; (
     is       =&gt; 'ro',
     isa      =&gt; ArrayRef[Object],
     default  =&gt; sub { return [] },
   );
   
   sub add_child {
     state $check = compile( Object, Object );  # method signature
     
     my ($self, $child) = $check-&gt;(@_);         # unpack @_
     push @{ $self-&gt;children }, $child;
     
     return $self;
   }
 }
 
 package main;
 
 my $boldruler = Horse-&gt;new(
   name    =&gt; &quot;Bold Ruler&quot;,
   gender  =&gt; 'm',
   age     =&gt; 16,
 );
 
 my $secretariat = Horse-&gt;new(
   name    =&gt; &quot;Secretariat&quot;,
   gender  =&gt; 'm',
   age     =&gt; 0,
 );
 
 $boldruler-&gt;add_child( $secretariat );
 
 use Types::Standard qw( is_Object assert_Object );
 
 # is_Object($thing) returns a boolean
 my $is_it_an_object = is_Object($boldruler);
 
 # assert_Object($thing) returns $thing or dies
 say assert_Object($boldruler)-&gt;name;  # says &quot;Bold Ruler&quot;
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="STATUS"><a class="permalink" href="#STATUS">STATUS</a></h1>
<p class="Pp">This module is covered by the Type-Tiny stability policy.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">This documents the details of the Types::Standard type library.
    Type::Tiny::Manual is a better starting place if you're new.</p>
<p class="Pp">Type::Tiny bundles a few types which seem to be useful.</p>
<section class="Ss">
<h2 class="Ss" id="Moose-like"><a class="permalink" href="#Moose-like">Moose-like</a></h2>
<p class="Pp">The following types are similar to those described in
    Moose::Util::TypeConstraints.</p>
<ul class="Bl-bullet">
  <li><b>Any</b>
    <p class="Pp">Absolutely any value passes this type constraint (even
      undef).</p>
  </li>
  <li><b>Item</b>
    <p class="Pp">Essentially the same as <b>Any</b>. All other type constraints
        in this library inherit directly or indirectly from <b>Item</b>.</p>
  </li>
  <li><b>Bool</b>
    <p class="Pp">Values that are reasonable booleans. Accepts 1, 0, the empty
        string and undef.</p>
  </li>
  <li><b>Maybe[`a]</b>
    <p class="Pp">Given another type constraint, also accepts undef. For
        example, <b>Maybe[Int]</b> accepts all integers plus undef.</p>
  </li>
  <li><b>Undef</b>
    <p class="Pp">Only undef passes this type constraint.</p>
  </li>
  <li><b>Defined</b>
    <p class="Pp">Only undef fails this type constraint.</p>
  </li>
  <li><b>Value</b>
    <p class="Pp">Any defined, non-reference value.</p>
  </li>
  <li><b>Str</b>
    <p class="Pp">Any string.</p>
    <p class="Pp">(The only difference between <b>Value</b> and <b>Str</b> is
        that the former accepts typeglobs and vstrings.)</p>
    <p class="Pp">Other customers also bought: <b>StringLike</b> from
        Types::TypeTiny.</p>
  </li>
  <li><b>Num</b>
    <p class="Pp">See <b>LaxNum</b> and <b>StrictNum</b> below.</p>
  </li>
  <li><b>Int</b>
    <p class="Pp">An integer; that is a string of digits 0 to 9, optionally
        prefixed with a hyphen-minus character.</p>
    <p class="Pp">Expect inconsistent results for dualvars, and numbers too high
        (or negative numbers too low) for Perl to safely represent as an
        integer.</p>
  </li>
  <li><b>ClassName</b>
    <p class="Pp">The name of a loaded package. The package must have
        <span class="Li">@ISA</span> or <span class="Li">$VERSION</span>
        defined, or must define at least one sub to be considered a loaded
        package.</p>
  </li>
  <li><b>RoleName</b>
    <p class="Pp">Like <b>ClassName</b>, but the package must <i>not</i> define
        a method called <span class="Li">&quot;new&quot;</span>. This is subtly
        different from Moose's type constraint of the same name; let me know if
        this causes you any problems. (I can't promise I'll change anything
        though.)</p>
  </li>
  <li><b>Ref[`a]</b>
    <p class="Pp">Any defined reference value, including blessed objects.</p>
    <p class="Pp">Unlike Moose, <b>Ref</b> is a parameterized type, allowing
        Scalar::Util::reftype checks, a la</p>
    <p class="Pp"></p>
    <pre>   Ref[&quot;HASH&quot;]  # hashrefs, including blessed hashrefs
    </pre>
  </li>
  <li><b>ScalarRef[`a]</b>
    <p class="Pp">A value where <span class="Li">&quot;ref($value) eq
        &quot;SCALAR&quot; or ref($value) eq &quot;REF&quot;&quot;</span>.</p>
    <p class="Pp">If parameterized, the referred value must pass the additional
        constraint. For example, <b>ScalarRef[Int]</b> must be a reference to a
        scalar which holds an integer value.</p>
  </li>
  <li><b>ArrayRef[`a]</b>
    <p class="Pp">A value where <span class="Li">&quot;ref($value) eq
        &quot;ARRAY&quot;&quot;</span>.</p>
    <p class="Pp">If parameterized, the elements of the array must pass the
        additional constraint. For example, <b>ArrayRef[Num]</b> must be a
        reference to an array of numbers.</p>
    <p class="Pp">As an extension to Moose's <b>ArrayRef</b> type, a minimum and
        maximum array length can be given:</p>
    <p class="Pp"></p>
    <pre>   ArrayRef[CodeRef, 1]        # ArrayRef of at least one CodeRef
   ArrayRef[FileHandle, 0, 2]  # ArrayRef of up to two FileHandles
   ArrayRef[Any, 0, 100]       # ArrayRef of up to 100 elements
    </pre>
    <p class="Pp">Other customers also bought: <b>ArrayLike</b> from
        Types::TypeTiny.</p>
  </li>
  <li><b>HashRef[`a]</b>
    <p class="Pp">A value where <span class="Li">&quot;ref($value) eq
        &quot;HASH&quot;&quot;</span>.</p>
    <p class="Pp">If parameterized, the values of the hash must pass the
        additional constraint. For example, <b>HashRef[Num]</b> must be a
        reference to an hash where the values are numbers. The hash keys are not
        constrained, but Perl limits them to strings; see <b>Map</b> below if
        you need to further constrain the hash values.</p>
    <p class="Pp">Other customers also bought: <b>HashLike</b> from
        Types::TypeTiny.</p>
  </li>
  <li><b>CodeRef</b>
    <p class="Pp">A value where <span class="Li">&quot;ref($value) eq
        &quot;CODE&quot;&quot;</span>.</p>
    <p class="Pp">Other customers also bought: <b>CodeLike</b> from
        Types::TypeTiny.</p>
  </li>
  <li><b>RegexpRef</b>
    <p class="Pp">A reference where
        <span class="Li">&quot;re::is_regexp($value)&quot;</span> is true, or a
        blessed reference where
        <span class="Li">&quot;$value-&gt;isa(&quot;Regexp&quot;)&quot;</span>
        is true.</p>
  </li>
  <li><b>GlobRef</b>
    <p class="Pp">A value where <span class="Li">&quot;ref($value) eq
        &quot;GLOB&quot;&quot;</span>.</p>
  </li>
  <li><b>FileHandle</b>
    <p class="Pp">A file handle.</p>
  </li>
  <li><b>Object</b>
    <p class="Pp">A blessed object.</p>
    <p class="Pp">(This also accepts regexp refs.)</p>
  </li>
</ul>
</section>
<section class="Ss">
<h2 class="Ss" id="Structured"><a class="permalink" href="#Structured">Structured</a></h2>
<p class="Pp">OK, so I stole some ideas from MooseX::Types::Structured.</p>
<ul class="Bl-bullet">
  <li><b>Map[`k, `v]</b>
    <p class="Pp">Similar to <b>HashRef</b> but parameterized with type
        constraints for both the key and value. The constraint for keys would
        typically be a subtype of <b>Str</b>.</p>
  </li>
  <li><b>Tuple[...]</b>
    <p class="Pp">Subtype of <b>ArrayRef</b>, accepting a list of type
        constraints for each slot in the array.</p>
    <p class="Pp"><b>Tuple[Int, HashRef]</b> would match
        <span class="Li">&quot;[1, {}]&quot;</span> but not
        <span class="Li">&quot;[{}, 1]&quot;</span>.</p>
  </li>
  <li><b>Dict[...]</b>
    <p class="Pp">Subtype of <b>HashRef</b>, accepting a list of type
        constraints for each slot in the hash.</p>
    <p class="Pp">For example <b>Dict[name =&gt; Str, id =&gt; Int]</b> allows
        <span class="Li">&quot;{ name =&gt; &quot;Bob&quot;, id =&gt; 42
        }&quot;</span>.</p>
  </li>
  <li><b>Optional[`a]</b>
    <p class="Pp">Used in conjunction with <b>Dict</b> and <b>Tuple</b> to
        specify slots that are optional and may be omitted (but not necessarily
        set to an explicit undef).</p>
    <p class="Pp"><b>Dict[name =&gt; Str, id =&gt; Optional[Int]]</b> allows
        <span class="Li">&quot;{ name =&gt; &quot;Bob&quot; }&quot;</span> but
        not <span class="Li">&quot;{ name =&gt; &quot;Bob&quot;, id =&gt;
        &quot;BOB&quot; }&quot;</span>.</p>
    <p class="Pp">Note that any use of <b>Optional[`a]</b> outside the context
        of parameterized <b>Dict</b> and <b>Tuple</b> type constraints makes
        little sense, and its behaviour is undefined. (An exception: it is used
        by Type::Params for a similar purpose to how it's used in
      <b>Tuple</b>.)</p>
  </li>
</ul>
<p class="Pp">This module also exports a
    <span class="Li">&quot;slurpy&quot;</span> function, which can be used as
    follows.</p>
<p class="Pp">It can cause additional trailing values in a <b>Tuple</b> to be
    slurped into a structure and validated. For example, slurping into an
    arrayref:</p>
<p class="Pp"></p>
<pre>   my $type = Tuple[Str, slurpy ArrayRef[Int]];
   
   $type-&gt;( [&quot;Hello&quot;] );                # ok
   $type-&gt;( [&quot;Hello&quot;, 1, 2, 3] );       # ok
   $type-&gt;( [&quot;Hello&quot;, [1, 2, 3]] );     # not ok
</pre>
<p class="Pp">Or into a hashref:</p>
<p class="Pp"></p>
<pre>   my $type2 = Tuple[Str, slurpy Map[Int, RegexpRef]];
   
   $type2-&gt;( [&quot;Hello&quot;] );                               # ok
   $type2-&gt;( [&quot;Hello&quot;, 1, qr/one/i, 2, qr/two/] );      # ok
</pre>
<p class="Pp">It can cause additional values in a <b>Dict</b> to be slurped into
    a hashref and validated:</p>
<p class="Pp"></p>
<pre>   my $type3 = Dict[ values =&gt; ArrayRef, slurpy HashRef[Str] ];
   
   $type3-&gt;( { values =&gt; [] } );                        # ok
   $type3-&gt;( { values =&gt; [], name =&gt; &quot;Foo&quot; } );         # ok
   $type3-&gt;( { values =&gt; [], name =&gt; [] } );            # not ok
</pre>
<p class="Pp">In either <b>Tuple</b> or <b>Dict</b>, <b>slurpy Any</b> can be
    used to indicate that additional values are acceptable, but should not be
    constrained in any way.</p>
<p class="Pp"><b>slurpy Any</b> is an optimized code path. Although the
    following are essentially equivalent checks, the former should run a lot
    faster:</p>
<p class="Pp"></p>
<pre>   Tuple[Int, slurpy Any]
   Tuple[Int, slurpy ArrayRef]
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Objects"><a class="permalink" href="#Objects">Objects</a></h2>
<p class="Pp">OK, so I stole some ideas from MooX::Types::MooseLike::Base.</p>
<ul class="Bl-bullet">
  <li><b>InstanceOf[`a]</b>
    <p class="Pp">Shortcut for a union of Type::Tiny::Class constraints.</p>
    <p class="Pp"><b>InstanceOf[&quot;Foo&quot;, &quot;Bar&quot;]</b> allows
        objects blessed into the <span class="Li">&quot;Foo&quot;</span> or
        <span class="Li">&quot;Bar&quot;</span> classes, or subclasses of
      those.</p>
    <p class="Pp">Given no parameters, just equivalent to <b>Object</b>.</p>
  </li>
  <li><b>ConsumerOf[`a]</b>
    <p class="Pp">Shortcut for an intersection of Type::Tiny::Role
      constraints.</p>
    <p class="Pp"><b>ConsumerOf[&quot;Foo&quot;, &quot;Bar&quot;]</b> allows
        objects where
        <span class="Li">&quot;$o-&gt;DOES(&quot;Foo&quot;)&quot;</span> and
        <span class="Li">&quot;$o-&gt;DOES(&quot;Bar&quot;)&quot;</span> both
        return true.</p>
    <p class="Pp">Given no parameters, just equivalent to <b>Object</b>.</p>
  </li>
  <li><b>HasMethods[`a]</b>
    <p class="Pp">Shortcut for a Type::Tiny::Duck constraint.</p>
    <p class="Pp"><b>HasMethods[&quot;foo&quot;, &quot;bar&quot;]</b> allows
        objects where
        <span class="Li">&quot;$o-&gt;can(&quot;foo&quot;)&quot;</span> and
        <span class="Li">&quot;$o-&gt;can(&quot;bar&quot;)&quot;</span> both
        return true.</p>
    <p class="Pp">Given no parameters, just equivalent to <b>Object</b>.</p>
  </li>
</ul>
</section>
<section class="Ss">
<h2 class="Ss" id="More"><a class="permalink" href="#More">More</a></h2>
<p class="Pp">There are a few other types exported by this module:</p>
<ul class="Bl-bullet">
  <li><b>Overload[`a]</b>
    <p class="Pp">With no parameters, checks that the value is an overloaded
        object. Can be given one or more string parameters, which are specific
        operations to check are overloaded. For example, the following checks
        for objects which overload addition and subtraction.</p>
    <p class="Pp"></p>
    <pre>   Overload[&quot;+&quot;, &quot;-&quot;]
    </pre>
  </li>
  <li><b>Tied[`a]</b>
    <p class="Pp">A reference to a tied scalar, array or hash.</p>
    <p class="Pp">Can be parameterized with a type constraint which will be
        applied to the object returned by the
        <span class="Li">&quot;tied()&quot;</span> function. As a convenience,
        can also be parameterized with a string, which will be inflated to a
        Type::Tiny::Class.</p>
    <p class="Pp"></p>
    <pre>   use Types::Standard qw(Tied);
   use Type::Utils qw(class_type);
   
   my $My_Package = class_type { class =&gt; &quot;My::Package&quot; };
   
   tie my %h, &quot;My::Package&quot;;
   \%h ~~ Tied;                   # true
   \%h ~~ Tied[ $My_Package ];    # true
   \%h ~~ Tied[&quot;My::Package&quot;];    # true
   
   tie my $s, &quot;Other::Package&quot;;
   \$s ~~ Tied;                   # true
   $s  ~~ Tied;                   # false !!
    </pre>
    <p class="Pp">If you need to check that something is specifically a
        reference to a tied hash, use an intersection:</p>
    <p class="Pp"></p>
    <pre>   use Types::Standard qw( Tied HashRef );
   
   my $TiedHash = (Tied) &amp; (HashRef);
   
   tie my %h, &quot;My::Package&quot;;
   tie my $s, &quot;Other::Package&quot;;
   
   \%h ~~ $TiedHash;     # true
   \$s ~~ $TiedHash;     # false
    </pre>
  </li>
  <li><b>StrMatch[`a]</b>
    <p class="Pp">A string that matches a regular expression:</p>
    <p class="Pp"></p>
    <pre>   declare &quot;Distance&quot;,
      as StrMatch[ qr{^([0-9]+)\s*(mm|cm|m|km)$} ];
    </pre>
    <p class="Pp">You can optionally provide a type constraint for the array of
        subexpressions:</p>
    <p class="Pp"></p>
    <pre>   declare &quot;Distance&quot;,
      as StrMatch[
         qr{^([0-9]+)\s*(.+)$},
         Tuple[
            Int,
            enum(DistanceUnit =&gt; [qw/ mm cm m km /]),
         ],
      ];
    </pre>
    <p class="Pp">Here's an example using Regexp::Common:</p>
    <p class="Pp"></p>
    <pre>   package Local::Host {
      use Moose;
      use Regexp::Common;
      has ip_address =&gt; (
         is         =&gt; 'ro',
         required   =&gt; 1,
         isa        =&gt; StrMatch[/^$RE{net}{IPv4}$/],
         default    =&gt; '127.0.0.1',
      );
   }
    </pre>
    <p class="Pp">On certain versions of Perl, type constraints of the forms
        <b>StrMatch[qr/../</b> and <b>StrMatch[qr/\A..\z/</b> with any number of
        intervening dots can be optimized to simple length checks.</p>
  </li>
  <li><b>Enum[`a]</b>
    <p class="Pp">As per MooX::Types::MooseLike::Base:</p>
    <p class="Pp"></p>
    <pre>   has size =&gt; (
      is     =&gt; &quot;ro&quot;,
      isa    =&gt; Enum[qw( S M L XL XXL )],
   );
    </pre>
    <p class="Pp">You can enable coercion by passing
        <span class="Li">&quot;\1&quot;</span> before the list of values.</p>
    <p class="Pp"></p>
    <pre>   has size =&gt; (
      is     =&gt; &quot;ro&quot;,
      isa    =&gt; Enum[ \1, qw( S M L XL XXL ) ],
      coerce =&gt; 1,
   );
    </pre>
    <p class="Pp">This will use the
        <span class="Li">&quot;closest_match&quot;</span> method in
        Type::Tiny::Enum to coerce closely matching strings.</p>
  </li>
  <li><b>OptList</b>
    <p class="Pp">An arrayref of arrayrefs in the style of Data::OptList
      output.</p>
  </li>
  <li><b>LaxNum</b>, <b>StrictNum</b>
    <p class="Pp">In Moose 2.09, the <b>Num</b> type constraint implementation
        was changed from being a wrapper around Scalar::Util's
        <span class="Li">&quot;looks_like_number&quot;</span> function to a
        stricter regexp (which disallows things like &quot;-Inf&quot; and
        &quot;Nan&quot;).</p>
    <p class="Pp">Types::Standard provides <i>both</i> implementations.
        <b>LaxNum</b> is measurably faster.</p>
    <p class="Pp">The <b>Num</b> type constraint is currently an alias for
        <b>LaxNum</b> unless you set the
        <span class="Li">&quot;PERL_TYPES_STANDARD_STRICTNUM&quot;</span>
        environment variable to true before loading Types::Standard, in which
        case it becomes an alias for <b>StrictNum</b>. The constant
        <span class="Li">&quot;Types::Standard::STRICTNUM&quot;</span> can be
        used to check if <b>Num</b> is being strict.</p>
    <p class="Pp">Most people should probably use <b>Num</b> or
        <b>StrictNum</b>. Don't explicitly use <b>LaxNum</b> unless you
        specifically need an attribute which will accept things like
        &quot;Inf&quot;.</p>
  </li>
  <li><b>CycleTuple[`a]</b>
    <p class="Pp">Similar to <b>Tuple</b>, but cyclical.</p>
    <p class="Pp"></p>
    <pre>   CycleTuple[Int, HashRef]
    </pre>
    <p class="Pp">will allow <span class="Li">&quot;[1,{}]&quot;</span> and
        <span class="Li">&quot;[1,{},2,{}]&quot;</span> but disallow
        <span class="Li">&quot;[1,{},2]&quot;</span> and
        <span class="Li">&quot;[1,{},2,[]]&quot;</span>.</p>
    <p class="Pp">I think you understand <b>CycleTuple</b> already.</p>
    <p class="Pp">Currently <b>Optional</b> and
        <span class="Li">&quot;slurpy&quot;</span> parameters are forbidden.
        There are fairly limited use cases for them, and it's not exactly clear
        what they should mean.</p>
    <p class="Pp">The following is an efficient way of checking for an
        even-sized arrayref:</p>
    <p class="Pp"></p>
    <pre>   CycleTuple[Any, Any]
    </pre>
    <p class="Pp">The following is an arrayref which would be suitable for
        coercing to a hashref:</p>
    <p class="Pp"></p>
    <pre>   CycleTuple[Str, Any]
    </pre>
    <p class="Pp">All the examples so far have used two parameters, but the
        following is also a possible <b>CycleTuple</b>:</p>
    <p class="Pp"></p>
    <pre>   CycleTuple[Str, Int, HashRef]
    </pre>
    <p class="Pp">This will be an arrayref where the 0th, 3rd, 6th, etc values
        are strings, the 1st, 4th, 7th, etc values are integers, and the 2nd,
        5th, 8th, etc values are hashrefs.</p>
  </li>
</ul>
</section>
<section class="Ss">
<h2 class="Ss" id="Coercions"><a class="permalink" href="#Coercions">Coercions</a></h2>
<p class="Pp">Most of the types in this type library have no coercions by
    default. The exception is <b>Bool</b> as of Types::Standard 1.003_003, which
    coerces from <b>Any</b> via <span class="Li">&quot;!!$_&quot;</span>.</p>
<p class="Pp">Some standalone coercions may be exported. These can be combined
    with type constraints using the
    <span class="Li">&quot;plus_coercions&quot;</span> method.</p>
<ul class="Bl-bullet">
  <li><b>MkOpt</b>
    <p class="Pp">A coercion from <b>ArrayRef</b>, <b>HashRef</b> or
        <b>Undef</b> to <b>OptList</b>. Example usage in a Moose attribute:</p>
    <p class="Pp"></p>
    <pre>   use Types::Standard qw( OptList MkOpt );
   
   has options =&gt; (
      is     =&gt; &quot;ro&quot;,
      isa    =&gt; OptList-&gt;plus_coercions( MkOpt ),
      coerce =&gt; 1,
   );
    </pre>
  </li>
  <li><b>Split[`a]</b>
    <p class="Pp">Split a string on a regexp.</p>
    <p class="Pp"></p>
    <pre>   use Types::Standard qw( ArrayRef Str Split );
   
   has name =&gt; (
      is     =&gt; &quot;ro&quot;,
      isa    =&gt; ArrayRef-&gt;of(Str)-&gt;plus_coercions(Split[qr/\s/]),
      coerce =&gt; 1,
   );
    </pre>
  </li>
  <li><b>Join[`a]</b>
    <p class="Pp">Join an array of strings with a delimiter.</p>
    <p class="Pp"></p>
    <pre>   use Types::Standard qw( Str Join );
   
   my $FileLines = Str-&gt;plus_coercions(Join[&quot;\n&quot;]);
   
   has file_contents =&gt; (
      is     =&gt; &quot;ro&quot;,
      isa    =&gt; $FileLines,
      coerce =&gt; 1,
   );
    </pre>
  </li>
</ul>
</section>
<section class="Ss">
<h2 class="Ss" id="Constants"><a class="permalink" href="#Constants">Constants</a></h2>
<dl class="Bl-tag">
  <dt>&quot;Types::Standard::STRICTNUM&quot;</dt>
  <dd>Indicates whether <b>Num</b> is an alias for <b>StrictNum</b>. (It is
      usually an alias for <b>LaxNum</b>.)</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Environment"><a class="permalink" href="#Environment">Environment</a></h2>
<dl class="Bl-tag">
  <dt>&quot;PERL_TYPES_STANDARD_STRICTNUM&quot;</dt>
  <dd>Switches to more strict regexp-based number checking instead of using
      <span class="Li">&quot;looks_like_number&quot;</span>.</dd>
  <dt>&quot;PERL_TYPE_TINY_XS&quot;</dt>
  <dd>If set to false, can be used to suppress the loading of XS implementions
      of some type constraints.</dd>
  <dt>&quot;PERL_ONLY&quot;</dt>
  <dd>If <span class="Li">&quot;PERL_TYPE_TINY_XS&quot;</span> does not exist,
      can be set to true to suppress XS usage similarly. (Several other CPAN
      distributions also pay attention to this environment variable.)</dd>
</dl>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="BUGS"><a class="permalink" href="#BUGS">BUGS</a></h1>
<p class="Pp">Please report any bugs to
    &lt;http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny&gt;.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp">The Type::Tiny homepage &lt;https://typetiny.toby.ink/&gt;.</p>
<p class="Pp">Type::Tiny::Manual.</p>
<p class="Pp">Type::Tiny, Type::Library, Type::Utils, Type::Coercion.</p>
<p class="Pp">Moose::Util::TypeConstraints, Mouse::Util::TypeConstraints,
    MooseX::Types::Structured.</p>
<p class="Pp">Types::XSD provides some type constraints based on XML Schema's
    data types; this includes constraints for ISO8601-formatted datetimes,
    integer ranges (e.g. <b>PositiveInteger[maxInclusive=&gt;10]</b> and so
  on.</p>
<p class="Pp">Types::Encodings provides <b>Bytes</b> and <b>Chars</b> type
    constraints that were formerly found in Types::Standard.</p>
<p class="Pp">Types::Common::Numeric and Types::Common::String provide
    replacements for MooseX::Types::Common.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">Toby Inkster &lt;tobyink@cpan.org&gt;.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT_AND_LICENCE"><a class="permalink" href="#COPYRIGHT_AND_LICENCE">COPYRIGHT
  AND LICENCE</a></h1>
<p class="Pp">This software is copyright (c) 2013-2014, 2017-2020 by Toby
    Inkster.</p>
<p class="Pp">This is free software; you can redistribute it and/or modify it
    under the same terms as the Perl 5 programming language system itself.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DISCLAIMER_OF_WARRANTIES"><a class="permalink" href="#DISCLAIMER_OF_WARRANTIES">DISCLAIMER
  OF WARRANTIES</a></h1>
<p class="Pp">THIS PACKAGE IS PROVIDED &quot;AS IS&quot; AND WITHOUT ANY EXPRESS
    OR IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES
    OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2020-10-28</td>
    <td class="foot-os">perl v5.34.0</td>
  </tr>
</table>
</body>
</html>
