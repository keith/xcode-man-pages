<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.10 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>Bit::Vector::Overload(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Bit::Vector::Overload(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Bit::Vector::Overload(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
Bit::Vector::Overload - Overloaded operators add-on for Bit::Vector
</section>
<section class="Sh">
<h1 class="Sh" id="USAGE"><a class="permalink" href="#USAGE">USAGE</a></h1>
Note that you do not need to &quot;<span class="Li">&quot;use
  Bit::Vector;&quot;</span>&quot; in addition to this module.
<p class="Pp">Simply &quot;<span class="Li">&quot;use
    Bit::Vector::Overload;&quot;</span>&quot; <b>INSTEAD</b> of
    &quot;<span class="Li">&quot;use Bit::Vector;&quot;</span>&quot;. You can
    still use all the methods from the &quot;Bit::Vector&quot; module in
    addition to the overloaded operators and methods provided here after
  that.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<span class="Li"></span>
<pre>
  Configuration
      $config = Bit::Vector-&gt;Configuration();
      Bit::Vector-&gt;Configuration($config);
      $oldconfig = Bit::Vector-&gt;Configuration($newconfig);

  String Conversion
      $string = &quot;$vector&quot;;             #  depending on configuration
      print &quot;\$vector = '$vector'\n&quot;;

  Emptyness
      if ($vector)  #  if not empty (non-zero)
      if (! $vector)  #  if empty (zero)
      unless ($vector)  #  if empty (zero)

  Complement (one's complement)
      $vector2 = ~$vector1;
      $vector = ~$vector;

  Negation (two's complement)
      $vector2 = -$vector1;
      $vector = -$vector;

  Norm
      $norm = abs($vector);  #  depending on configuration

  Absolute
      $vector2 = abs($vector1);  #  depending on configuration

  Concatenation
      $vector3 = $vector1 . $vector2;
      $vector1 .= $vector2;
      $vector1 = $vector2 . $vector1;
      $vector2 = $vector1 . $scalar;  #  depending on configuration
      $vector2 = $scalar . $vector1;
      $vector .= $scalar;

  Duplication
      $vector2 = $vector1 x $factor;
      $vector x= $factor;

  Shift Left
      $vector2 = $vector1 &lt;&lt; $bits;
      $vector &lt;&lt;= $bits;

  Shift Right
      $vector2 = $vector1 &gt;&gt; $bits;
      $vector &gt;&gt;= $bits;

  Union
      $vector3 = $vector1 | $vector2;
      $vector1 |= $vector2;
      $vector2 = $vector1 | $scalar;
      $vector |= $scalar;

      $vector3 = $vector1 + $vector2;  #  depending on configuration
      $vector1 += $vector2;
      $vector2 = $vector1 + $scalar;
      $vector += $scalar;

  Intersection
      $vector3 = $vector1 &amp; $vector2;
      $vector1 &amp;= $vector2;
      $vector2 = $vector1 &amp; $scalar;
      $vector &amp;= $scalar;

      $vector3 = $vector1 * $vector2;  #  depending on configuration
      $vector1 *= $vector2;
      $vector2 = $vector1 * $scalar;
      $vector *= $scalar;

  ExclusiveOr
      $vector3 = $vector1 ^ $vector2;
      $vector1 ^= $vector2;
      $vector2 = $vector1 ^ $scalar;
      $vector ^= $scalar;

  Set Difference
      $vector3 = $vector1 - $vector2;  #  depending on configuration
      $vector1 -= $vector2;
      $vector1 = $vector2 - $vector1;
      $vector2 = $vector1 - $scalar;
      $vector2 = $scalar - $vector1;
      $vector -= $scalar;

  Addition
      $vector3 = $vector1 + $vector2;  #  depending on configuration
      $vector1 += $vector2;
      $vector2 = $vector1 + $scalar;
      $vector += $scalar;

  Subtraction
      $vector3 = $vector1 - $vector2;  #  depending on configuration
      $vector1 -= $vector2;
      $vector1 = $vector2 - $vector1;
      $vector2 = $vector1 - $scalar;
      $vector2 = $scalar - $vector1;
      $vector -= $scalar;

  Multiplication
      $vector3 = $vector1 * $vector2;  #  depending on configuration
      $vector1 *= $vector2;
      $vector2 = $vector1 * $scalar;
      $vector *= $scalar;

  Division
      $vector3 = $vector1 / $vector2;
      $vector1 /= $vector2;
      $vector1 = $vector2 / $vector1;
      $vector2 = $vector1 / $scalar;
      $vector2 = $scalar / $vector1;
      $vector /= $scalar;

  Modulo
      $vector3 = $vector1 % $vector2;
      $vector1 %= $vector2;
      $vector1 = $vector2 % $vector1;
      $vector2 = $vector1 % $scalar;
      $vector2 = $scalar % $vector1;
      $vector %= $scalar;

  Exponentiation
      $vector3 = $vector1 ** $vector2;
      $vector1 **= $vector2;
      $vector2 = $vector1 ** $scalar;
      $vector2 = $scalar ** $vector1;
      $vector **= $scalar;

  Increment
      ++$vector;
      $vector++;

  Decrement
      --$vector;
      $vector--;

  Lexical Comparison (unsigned)
      $cmp = $vector1 cmp $vector2;
      if ($vector1 lt $vector2)
      if ($vector1 le $vector2)
      if ($vector1 gt $vector2)
      if ($vector1 ge $vector2)

      $cmp = $vector cmp $scalar;
      if ($vector lt $scalar)
      if ($vector le $scalar)
      if ($vector gt $scalar)
      if ($vector ge $scalar)

  Comparison (signed)
      $cmp = $vector1 &lt;=&gt; $vector2;
      if ($vector1 &lt; $vector2)  #  depending on configuration
      if ($vector1 &lt;= $vector2)
      if ($vector1 &gt; $vector2)
      if ($vector1 &gt;= $vector2)

      $cmp = $vector &lt;=&gt; $scalar;
      if ($vector &lt; $scalar)  #  depending on configuration
      if ($vector &lt;= $scalar)
      if ($vector &gt; $scalar)
      if ($vector &gt;= $scalar)

  Equality
      if ($vector1 eq $vector2)
      if ($vector1 ne $vector2)
      if ($vector eq $scalar)
      if ($vector ne $scalar)

      if ($vector1 == $vector2)
      if ($vector1 != $vector2)
      if ($vector == $scalar)
      if ($vector != $scalar)

  Subset Relationship
      if ($vector1 &lt;= $vector2)  #  depending on configuration

  True Subset Relationship
      if ($vector1 &lt; $vector2)  #  depending on configuration

  Superset Relationship
      if ($vector1 &gt;= $vector2)  #  depending on configuration

  True Superset Relationship
      if ($vector1 &gt; $vector2)  #  depending on configuration
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="IMPORTANT_NOTES"><a class="permalink" href="#IMPORTANT_NOTES">IMPORTANT
  NOTES</a></h1>
<ul class="Bl-bullet">
  <li>Boolean values
    <p class="Pp">Boolean values in this module are always a numeric zero
        (&quot;<span class="Li">0</span>&quot;) for &quot;false&quot; and a
        numeric one (&quot;<span class="Li">1</span>&quot;) for
        &quot;true&quot;.</p>
  </li>
  <li>Negative numbers
    <p class="Pp">Numeric factors (as needed for the
        &quot;<span class="Li">&quot;&lt;&lt;&quot;</span>&quot;,
        &quot;<span class="Li">&quot;&gt;&gt;&quot;</span>&quot; and
        &quot;<span class="Li">&quot;x&quot;</span>&quot; operators) and bit
        numbers are always regarded as being <b>UNSIGNED</b>.</p>
    <p class="Pp">As a consequence, whenever you pass a negative number for such
        a factor or bit number, it will be treated as a (usually very large)
        positive number due to its internal two's complement binary
        representation, usually resulting in malfunctions or an &quot;index out
        of range&quot; error message and program abortion.</p>
    <p class="Pp">Note that this does not apply to &quot;big integer&quot;
        decimal numbers, which are (usually) passed as strings, and which may of
        course be negative (see also the section &quot;Big integers&quot; a
        little further below).</p>
  </li>
  <li>Overloaded operators configuration
    <p class="Pp">Note that the behaviour of certain overloaded operators can be
        changed in various ways by means of the
        &quot;<span class="Li">&quot;Configuration()&quot;</span>&quot; method
        (for more details, see the description of this method further
      below).</p>
    <p class="Pp">For instance, scalars (i.e., numbers and strings) provided as
        operands to overloaded operators are automatically converted to bit
        vectors, internally.</p>
    <p class="Pp">These scalars are thereby automatically assumed to be indices
        or to be in hexadecimal, binary, decimal or enumeration format,
        depending on the configuration.</p>
    <p class="Pp">Similarly, when converting bit vectors to strings using double
        quotes (&quot;&quot;), the output format will also depend on the
        previously chosen configuration.</p>
    <p class="Pp">Finally, some overloaded operators may have different
        semantics depending on the proper configuration; for instance, the
        operator &quot;+&quot; can be the &quot;union&quot; operator from set
        theory or the arithmetic &quot;add&quot; operator.</p>
    <p class="Pp">In all cases (input, output and operator semantics), the
        defaults have been chosen in such a way so that the behaviour of the
        module is backward compatible with previous versions.</p>
  </li>
  <li>&quot;Big integers&quot;
    <p class="Pp">As long as &quot;big integers&quot; (for &quot;big
        integer&quot; arithmetic) are small enough so that Perl doesn't need
        scientific notation (exponents) to be able to represent them internally,
        you can provide these &quot;big integer&quot; constants to the
        overloaded operators of this module (or to the method
        &quot;<span class="Li">&quot;from_Dec()&quot;</span>&quot;) in numeric
        form (i.e., either as a numeric constant or expression or as a Perl
        variable containing a numeric value).</p>
    <p class="Pp">Note that you will get an error message (resulting in program
        abortion) if your &quot;big integer&quot; numbers exceed that limit.</p>
    <p class="Pp">Because this limit is machine-dependent and not obvious to
        find out, it is strongly recommended that you enclose <b>ALL</b> your
        &quot;big integer&quot; constants in your programs in (double or single)
        quotes.</p>
    <p class="Pp">Examples:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    $vector /= 10;  #  ok because number is small

    $vector /= -10;  #  ok for same reason

    $vector /= &quot;10&quot;;  #  always correct

    $vector += &quot;1152921504606846976&quot;;  #  quotes probably required here
    </pre>
    <p class="Pp">All examples assume</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    Bit::Vector-&gt;Configuration(&quot;input=decimal&quot;);
    </pre>
    <p class="Pp">having been set beforehand.</p>
    <p class="Pp">Note also that this module does not support scientific
        notation (exponents) for &quot;big integer&quot; decimal numbers because
        you can always make the bit vector large enough for the whole number to
        fit without loss of precision (as it would occur if scientific notation
        were used).</p>
    <p class="Pp">Finally, note that the only characters allowed in &quot;big
        integer&quot; constant strings are the digits
        <span class="Li">0..9</span> and an optional leading sign
        (&quot;<span class="Li">&quot;+&quot;</span>&quot; or
        &quot;<span class="Li">&quot;-&quot;</span>&quot;).</p>
    <p class="Pp">All other characters produce a syntax error.</p>
  </li>
  <li>Valid operands for overloaded operators
    <p class="Pp">All overloaded operators expect at least one bit vector
        operand, in order for the operator to &quot;know&quot; that not the
        usual operation is to be carried out, but rather the overloaded
      variant.</p>
    <p class="Pp">This is especially true for all unary operators:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
                    &quot;$vector&quot;
                    if ($vector)
                    if (!$vector)
                    ~$vector
                    -$vector
                    abs($vector)
                    ++$vector
                    $vector++
                    --$vector
                    $vector--
    </pre>
    <p class="Pp">For obvious reasons the left operand (the &quot;lvalue&quot;)
        of all assignment operators is also required to be a bit vector:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
                        .=
                        x=
                        &lt;&lt;=
                        &gt;&gt;=
                        |=
                        &amp;=
                        ^=
                        +=
                        -=
                        *=
                        /=
                        %=
                       **=
    </pre>
    <p class="Pp">In the case of three special operators, namely
        &quot;<span class="Li">&quot;&lt;&lt;&quot;</span>&quot;,
        &quot;<span class="Li">&quot;&gt;&gt;&quot;</span>&quot; and
        &quot;<span class="Li">&quot;x&quot;</span>&quot;, as well as their
        related assignment variants,
        &quot;<span class="Li">&quot;&lt;&lt;=&quot;</span>&quot;,
        &quot;<span class="Li">&quot;&gt;&gt;=&quot;</span>&quot; and
        &quot;<span class="Li">&quot;x=&quot;</span>&quot;, the left operand is
        <b>ALWAYS</b> a bit vector and the right operand is <b>ALWAYS</b> a
        number (which is the factor indicating how many times the operator is to
        be applied).</p>
    <p class="Pp">In all truly binary operators, i.e.,</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
                        .
                        |
                        &amp;
                        ^
                        +
                        -
                        *
                        /
                        %
                       **
                    &lt;=&gt;   cmp
                     ==    eq
                     !=    ne
                     &lt;     lt
                     &lt;=    le
                     &gt;     gt
                     &gt;=    ge
    </pre>
    <p class="Pp">one of either operands may be replaced by a Perl scalar, i.e.,
        a number or a string, either as a Perl constant, a Perl expression or a
        Perl variable yielding a number or a string.</p>
    <p class="Pp">The same applies to the right side operand (the
        &quot;rvalue&quot;) of the remaining assignment operators, i.e.,</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
                        .=
                        |=
                        &amp;=
                        ^=
                        +=
                        -=
                        *=
                        /=
                        %=
                       **=
    </pre>
    <p class="Pp">Note that this Perl scalar should be of the correct type,
        i.e., numeric or string, for the chosen configuration, because otherwise
        a warning message will occur if your program runs under the
        &quot;<span class="Li">&quot;-w&quot;</span>&quot; switch of Perl.</p>
    <p class="Pp">The acceptable scalar types for each possible configuration
        are the following:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    input = bit indices    (default)  :    numeric
    input = hexadecimal               :    string
    input = binary                    :    string
    input = decimal                   :    string     (in general)
    input = decimal                   :    numeric    (if small enough)
    input = enumeration               :    string
    </pre>
    <p class="Pp">NOTE ALSO THAT THESE SCALAR OPERANDS ARE CONVERTED TO BIT
        VECTORS OF THE SAME SIZE AS THE BIT VECTOR WHICH IS THE OTHER
      OPERAND.</p>
    <p class="Pp">The only exception from this rule is the concatenation
        operator (&quot;<span class="Li">&quot;.&quot;</span>&quot;) and its
        assignment variant
      (&quot;<span class="Li">&quot;.=&quot;</span>&quot;):</p>
    <p class="Pp">If one of the two operands of the concatenation operator
        (&quot;<span class="Li">&quot;.&quot;</span>&quot;) is not a bit vector
        object but a Perl scalar, the contents of the remaining bit vector
        operand are converted into a string (the format of which depends on the
        configuration set with the
        &quot;<span class="Li">&quot;Configuration()&quot;</span>&quot; method),
        which is then concatenated in the proper order (i.e., as indicated by
        the order of the two operands) with the Perl scalar (in other words, a
        string is returned in such a case instead of a bit vector object!).</p>
    <p class="Pp">If the right side operand (the &quot;rvalue&quot;) of the
        assignment variant (&quot;<span class="Li">&quot;.=&quot;</span>&quot;)
        of the concatenation operator is a Perl scalar, it is converted
        internally to a bit vector of the same size as the left side operand
        provided that the configuration states that scalars are to be regarded
        as indices, decimal strings or enumerations.</p>
    <p class="Pp">If the configuration states that scalars are to be regarded as
        hexadecimal or boolean strings, however, these strings are converted to
        bit vectors of a size matching the length of the input string, i.e.,
        four times the length for hexadecimal strings (because each hexadecimal
        digit is worth 4 bits) and once the length for binary strings.</p>
    <p class="Pp">If a decimal number (&quot;big integer&quot;) is too large to
        be stored in a bit vector of the given size, a &quot;numeric overflow
        error&quot; occurs.</p>
    <p class="Pp">If a bit index is out of range for the given bit vector, an
        &quot;index out of range&quot; error occurs.</p>
    <p class="Pp">If a scalar operand cannot be converted successfully due to
        invalid syntax, a fatal &quot;input string syntax error&quot; is
      issued.</p>
    <p class="Pp">If the two operands of the operator
        &quot;<span class="Li">&quot;&lt;&lt;&quot;</span>&quot;,
        &quot;<span class="Li">&quot;&gt;&gt;&quot;</span>&quot; or
        &quot;<span class="Li">&quot;x&quot;</span>&quot; are reversed, a fatal
        &quot;reversed operands error&quot; occurs.</p>
    <p class="Pp">If an operand is neither a bit vector nor a scalar, then a
        fatal &quot;illegal operand type error&quot; occurs.</p>
  </li>
  <li>Bit order
    <p class="Pp">Note that bit vectors are stored least order bit and least
        order word first internally.</p>
    <p class="Pp">I.e., bit #0 of any given bit vector corresponds to bit #0 of
        word #0 in the array of machine words representing the bit vector.</p>
    <p class="Pp">(Where word #0 comes first in memory, i.e., it is stored at
        the least memory address in the allocated block of memory holding the
        given bit vector.)</p>
    <p class="Pp">Note however that machine words can be stored least order byte
        first or last, depending on your system's implementation.</p>
    <p class="Pp">Note further that whenever bit vectors are converted to and
        from (binary or hexadecimal) strings, the <b>RIGHTMOST</b> bit is always
        the <b>LEAST SIGNIFICANT</b> one, and the <b>LEFTMOST</b> bit is always
        the <b>MOST SIGNIFICANT</b> bit.</p>
    <p class="Pp">This is because in our western culture, numbers are always
        represented in this way (least significant to most significant digits go
        from right to left).</p>
    <p class="Pp">Of course this requires an internal reversion of order, which
        the corresponding conversion methods perform automatically (without any
        additional overhead, it's just a matter of starting the internal loop at
        the bottom or the top end).</p>
  </li>
  <li>Matching sizes
    <p class="Pp">In general, for methods involving several bit vectors at the
        same time, all bit vector arguments must have identical sizes (number of
        bits), or a fatal &quot;size mismatch&quot; error will occur.</p>
    <p class="Pp">Exceptions from this rule are the methods
        &quot;<span class="Li">&quot;Concat()&quot;</span>&quot;,
        &quot;<span class="Li">&quot;Concat_List()&quot;</span>&quot;,
        &quot;<span class="Li">&quot;Copy()&quot;</span>&quot;,
        &quot;<span class="Li">&quot;Interval_Copy()&quot;</span>&quot; and
        &quot;<span class="Li">&quot;Interval_Substitute()&quot;</span>&quot;,
        where no conditions at all are imposed on the size of their bit vector
        arguments.</p>
    <p class="Pp">In method
        &quot;<span class="Li">&quot;Multiply()&quot;</span>&quot;, all three
        bit vector arguments must in principle obey the rule of matching sizes,
        but the bit vector in which the result of the multiplication is to be
        stored may be larger than the two bit vector arguments containing the
        factors for the multiplication.</p>
    <p class="Pp">In method
        &quot;<span class="Li">&quot;Power()&quot;</span>&quot;, the bit vector
        for the result must be the same size or greater than the base of the
        exponentiation term. The exponent can be any size.</p>
    <p class="Pp">The same applies to the corresponding overloaded
      operators.</p>
  </li>
  <li>Index ranges
    <p class="Pp">All indices for any given bits must lie between
        &quot;<span class="Li">0</span>&quot; and
        &quot;<span class="Li">&quot;$vector-&gt;Size()-1&quot;</span>&quot;, or
        a fatal &quot;index out of range&quot; error will occur.</p>
  </li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<ul class="Bl-bullet">
  <li><span class="Li">&quot;$config =
      Bit::Vector-&gt;Configuration();&quot;</span></li>
  <li><span class="Li">&quot;Bit::Vector-&gt;Configuration($config);&quot;</span></li>
  <li><span class="Li">&quot;$oldconfig =
      Bit::Vector-&gt;Configuration($newconfig);&quot;</span>
    <p class="Pp">This method serves to alter the semantics (i.e., behaviour) of
        certain overloaded operators (which are all implemented in Perl, by the
        way).</p>
    <p class="Pp">It does not have any effect whatsoever on anything else. In
        particular, it does not affect the methods implemented in C.</p>
    <p class="Pp">The method accepts an (optional) string as input in which
        certain keywords are expected, which influence some or almost all of the
        overloaded operators in several possible ways.</p>
    <p class="Pp">The method always returns a string (which you do not need to
        take care of, i.e., to store, in case you aren't interested in keeping
        it) which is a complete representation of the current configuration
        (i.e., <b>BEFORE</b> any modifications are applied) and which can be fed
        back to this method later in order to restore the previous
        configuration.</p>
    <p class="Pp">There are three aspects of the way certain overloaded
        operators behave which can be controlled with this method:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  +  the way scalar operands (replacing one of the two
     bit vector object operands) are automatically
     converted internally into a bit vector object of
     their own,

  +  the operation certain overloaded operators perform,
     i.e., an operation with sets or an arithmetic
     operation,

  +  the format to which bit vectors are converted
     automatically when they are enclosed in double
     quotes.
    </pre>
    <p class="Pp">The input string may contain any number of assignments, each
        of which controls one of these three aspects.</p>
    <p class="Pp">Each assignment has the form
        &quot;<span class="Li">&quot;&lt;which&gt;=&lt;value&gt;&quot;</span>&quot;.</p>
    <p class="Pp">&quot;<span class="Li">&quot;&lt;which&gt;&quot;</span>&quot;
        and &quot;<span class="Li">&quot;&lt;value&gt;&quot;</span>&quot;
        thereby consist of letters
        (<span class="Li">&quot;[a-zA-Z]&quot;</span>) and white space.</p>
    <p class="Pp">Multiple assignments have to be separated by one or more comma
        (&quot;,&quot;), semi-colon (&quot;;&quot;), colon (&quot;:&quot;),
        vertical bar (&quot;|&quot;), slash (&quot;/&quot;), newline
        (&quot;\n&quot;), ampersand (&quot;&amp;&quot;), plus (&quot;+&quot;) or
        dash (&quot;-&quot;).</p>
    <p class="Pp">Empty lines or statements (only white space) are allowed but
        will be ignored.</p>
    <p class="Pp">&quot;<span class="Li">&quot;&lt;which&gt;&quot;</span>&quot;
        has to contain one or more keywords from one of three groups, each group
        representing one of the three aspects that the
        &quot;<span class="Li">&quot;Configuration()&quot;</span>&quot; method
        controls:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  +  &quot;^scalar&quot;, &quot;^input&quot;, &quot;^in$&quot;

  +  &quot;^operator&quot;, &quot;^semantic&quot;, &quot;^ops$&quot;

  +  &quot;^string&quot;, &quot;^output&quot;, &quot;^out$&quot;
    </pre>
    <p class="Pp">The character &quot;^&quot; thereby denotes the beginning of a
        word, and &quot;$&quot; denotes the end. Case is ignored (!).</p>
    <p class="Pp">Using these keywords, you can build any phrase you like to
        select one of the three aspects (see also examples given below).</p>
    <p class="Pp">The only condition is that no other keyword from any of the
        other two groups may match - otherwise a syntax error will occur (i.e.,
        ambiguities are forbidden). A syntax error also occurs if none of the
        keywords matches.</p>
    <p class="Pp">This same principle applies to
        &quot;<span class="Li">&quot;&lt;value&gt;&quot;</span>&quot;:</p>
    <p class="Pp">Depending on which aspect you specified for
        &quot;<span class="Li">&quot;&lt;which&gt;&quot;</span>&quot;, there are
        different groups of keywords that determine the value the selected
        aspect will be set to:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  +  &quot;&lt;which&gt;&quot; = &quot;^scalar&quot;, &quot;^input&quot;, &quot;^in$&quot;:

       &quot;&lt;value&gt;&quot; =

       *  &quot;^bit$&quot;, &quot;^index&quot;, &quot;^indice&quot;
       *  &quot;^hex&quot;
       *  &quot;^bin&quot;
       *  &quot;^dec&quot;
       *  &quot;^enum&quot;

  +  &quot;&lt;which&gt;&quot; = &quot;^operator&quot;, &quot;^semantic&quot;, &quot;^ops$&quot;:

       &quot;&lt;value&gt;&quot; =

       *  &quot;^set$&quot;
       *  &quot;^arithmetic&quot;

  +  &quot;&lt;which&gt;&quot; = &quot;^string&quot;, &quot;^output&quot;, &quot;^out$&quot;:

       &quot;&lt;value&gt;&quot; =

       *  &quot;^hex&quot;
       *  &quot;^bin&quot;
       *  &quot;^dec&quot;
       *  &quot;^enum&quot;
    </pre>
    <p class="Pp">Examples:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  &quot;Any scalar input I provide should be considered to be = a bit index&quot;

  &quot;I want to have operator semantics suitable for = arithmetics&quot;

  &quot;Any bit vector in double quotes is to be output as = an enumeration&quot;
    </pre>
    <p class="Pp"><b>SCALAR INPUT:</b></p>
    <p class="Pp">In the case of scalar input,
        &quot;<span class="Li">&quot;^bit$&quot;</span>&quot;,
        &quot;<span class="Li">&quot;^index&quot;</span>&quot;, or
        &quot;<span class="Li">&quot;^indice&quot;</span>&quot; all cause scalar
        input to be considered to represent a bit index, i.e.,
        &quot;<span class="Li">&quot;$vector ^= 5;&quot;</span>&quot; will flip
        bit #5 in the given bit vector (this is essentially the same as
        &quot;<span class="Li">&quot;$vector-&gt;bit_flip(5);&quot;</span>&quot;).</p>
    <p class="Pp">Note that &quot;bit indices&quot; is the default setting for
        &quot;scalar input&quot;.</p>
    <p class="Pp">The keyword
        &quot;<span class="Li">&quot;^hex&quot;</span>&quot; will cause scalar
        input to be considered as being in hexadecimal, i.e.,
        &quot;<span class="Li">&quot;$vector ^= 5;&quot;</span>&quot; will flip
        bit #0 and bit #2 (because hexadecimal
        &quot;<span class="Li">5</span>&quot; is binary
        &quot;<span class="Li">0101</span>&quot;).</p>
    <p class="Pp">(Note though that hexadecimal input should always be enclosed
        in quotes, otherwise it will be interpreted as a decimal number by Perl!
        The example relies on the fact that hexadecimal
        <span class="Li">&quot;0-9&quot;</span> and decimal
        <span class="Li">&quot;0-9&quot;</span> are the same.)</p>
    <p class="Pp">The keyword
        &quot;<span class="Li">&quot;^bin&quot;</span>&quot; will cause scalar
        input to be considered as being in binary format. All characters except
        &quot;<span class="Li">0</span>&quot; and
        &quot;<span class="Li">1</span>&quot; are forbidden in this case (i.e.,
        produce a syntax error).</p>
    <p class="Pp">&quot;<span class="Li">&quot;$vector ^=
        '0101';&quot;</span>&quot;, for instance, will flip bit #0 and bit
      #2.</p>
    <p class="Pp">The keyword
        &quot;<span class="Li">&quot;^dec&quot;</span>&quot; causes scalar input
        to be considered as integers in decimal format, i.e.,
        &quot;<span class="Li">&quot;$vector ^= 5;&quot;</span>&quot; will flip
        bit #0 and bit #2 (because decimal &quot;<span class="Li">5</span>&quot;
        is binary &quot;<span class="Li">0101</span>&quot;).</p>
    <p class="Pp">(Note though that all decimal input should be enclosed in
        quotes, because for large numbers, Perl will use scientific notation
        internally for representing them, which produces a syntax error because
        scientific notation is neither supported by this module nor needed.)</p>
    <p class="Pp">Finally, the keyword
        &quot;<span class="Li">&quot;^enum&quot;</span>&quot; causes scalar
        input to be considered as being a list (&quot;enumeration&quot;) of
        indices and ranges of (contiguous) indices, i.e.,
        &quot;<span class="Li">&quot;$vector |=
        '2,3,5,7-13,17-23';&quot;</span>&quot; will cause bits #2, #3, #5, #7
        through #13 and #17 through #23 to be set.</p>
    <p class="Pp"><b>OPERATOR SEMANTICS:</b></p>
    <p class="Pp">Several overloaded operators can have two distinct functions
        depending on this setting.</p>
    <p class="Pp">The affected operators are:
        &quot;<span class="Li">&quot;+&quot;</span>&quot;,
        &quot;<span class="Li">&quot;-&quot;</span>&quot;,
        &quot;<span class="Li">&quot;*&quot;</span>&quot;,
        &quot;<span class="Li">&quot;&lt;&quot;</span>&quot;,
        &quot;<span class="Li">&quot;&lt;=&quot;</span>&quot;,
        &quot;<span class="Li">&quot;&gt;&quot;</span>&quot; and
        &quot;<span class="Li">&quot;&gt;=&quot;</span>&quot;.</p>
    <p class="Pp">With the default setting, &quot;set operations&quot;, these
        operators perform:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  +       set union                           ( set1  u   set2 )
  -       set difference                      ( set1  \   set2 )
  *       set intersection                    ( set1  n   set2 )
  &lt;       true subset relationship            ( set1  &lt;   set2 )
  &lt;=      subset relationship                 ( set1  &lt;=  set2 )
  &gt;       true superset relationship          ( set1  &gt;   set2 )
  &gt;=      superset relationship               ( set1  &gt;=  set2 )
    </pre>
    <p class="Pp">With the alternative setting, &quot;arithmetic
        operations&quot;, these operators perform:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  +       addition                            ( num1  +   num2 )
  -       subtraction                         ( num1  -   num2 )
  *       multiplication                      ( num1  *   num2 )
  &lt;       &quot;less than&quot; comparison              ( num1  &lt;   num2 )
  &lt;=      &quot;less than or equal&quot; comparison     ( num1  &lt;=  num2 )
  &gt;       &quot;greater than&quot; comparison           ( num1  &gt;   num2 )
  &gt;=      &quot;greater than or equal&quot; comparison  ( num1  &gt;=  num2 )
    </pre>
    <p class="Pp">Note that these latter comparison operators
        (&quot;<span class="Li">&quot;&lt;&quot;</span>&quot;,
        &quot;<span class="Li">&quot;&lt;=&quot;</span>&quot;,
        &quot;<span class="Li">&quot;&gt;&quot;</span>&quot; and
        &quot;<span class="Li">&quot;&gt;=&quot;</span>&quot;) regard their
        operands as being <b>SIGNED</b>.</p>
    <p class="Pp">To perform comparisons with <b>UNSIGNED</b> operands, use the
        operators &quot;<span class="Li">&quot;lt&quot;</span>&quot;,
        &quot;<span class="Li">&quot;le&quot;</span>&quot;,
        &quot;<span class="Li">&quot;gt&quot;</span>&quot; and
        &quot;<span class="Li">&quot;ge&quot;</span>&quot; instead (in contrast
        to the operators above, these operators are <b>NOT</b> affected by the
        &quot;operator semantics&quot; setting).</p>
    <p class="Pp"><b>STRING OUTPUT:</b></p>
    <p class="Pp">There are four methods which convert the contents of a given
        bit vector into a string:
        &quot;<span class="Li">&quot;to_Hex()&quot;</span>&quot;,
        &quot;<span class="Li">&quot;to_Bin()&quot;</span>&quot;,
        &quot;<span class="Li">&quot;to_Dec()&quot;</span>&quot; and
        &quot;<span class="Li">&quot;to_Enum()&quot;</span>&quot; (not counting
        &quot;<span class="Li">&quot;Block_Read()&quot;</span>&quot;, since this
        method does not return a human-readable string).</p>
    <p class="Pp">(For conversion to octal, see the description of the method
        &quot;<span class="Li">&quot;Chunk_List_Read()&quot;</span>&quot;.)</p>
    <p class="Pp">Therefore, there are four possible formats into which a bit
        vector can be converted when it is enclosed in double quotes, for
        example:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  print &quot;\$vector = '$vector'\n&quot;;
  $string = &quot;$vector&quot;;
    </pre>
    <p class="Pp">Hence you can set &quot;string output&quot; to four different
        values: To &quot;hex&quot; for hexadecimal format (which is the
        default), to &quot;bin&quot; for binary format, to &quot;dec&quot; for
        conversion to decimal numbers and to &quot;enum&quot; for conversion to
        enumerations (&quot;.newsrc&quot; style sets).</p>
    <p class="Pp"><b>BEWARE</b> that the conversion to decimal numbers is
        inherently slow; it can easily take up several seconds for a single
        large bit vector!</p>
    <p class="Pp">Therefore you should store the decimal strings returned to you
        rather than converting a given bit vector again.</p>
    <p class="Pp"><b>EXAMPLES:</b></p>
    <p class="Pp">The default setting as returned by the method
        &quot;<span class="Li">&quot;Configuration()&quot;</span>&quot; is:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        Scalar Input       = Bit Index
        Operator Semantics = Set Operators
        String Output      = Hexadecimal
    </pre>
    <p class="Pp">Performing a statement such as:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  Bit::Vector-&gt;Configuration(&quot;in=bin,ops=arithmetic,out=bin&quot;);
  print Bit::Vector-&gt;Configuration(), &quot;\n&quot;;
    </pre>
    <p class="Pp">yields the following output:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        Scalar Input       = Binary
        Operator Semantics = Arithmetic Operators
        String Output      = Binary
    </pre>
    <p class="Pp">Note that you can always feed this output back into the
        &quot;<span class="Li">&quot;Configuration()&quot;</span>&quot; method
        to restore that setting later.</p>
    <p class="Pp">This also means that you can enter the same given setting with
        almost any degree of verbosity you like (as long as the required
        keywords appear and no ambiguities arise).</p>
    <p class="Pp">Note further that any aspect you do not specify is not
        changed, i.e., the statement</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  Bit::Vector-&gt;Configuration(&quot;operators = arithmetic&quot;);
    </pre>
    <p class="Pp">leaves all other aspects unchanged.</p>
  </li>
  <li><span class="Li">&quot;$vector&quot;</span>
    <p class="Pp">Remember that variables enclosed in double quotes are always
        interpolated in Perl.</p>
    <p class="Pp">Whenever a Perl variable containing the reference of a
        &quot;Bit::Vector&quot; object is enclosed in double quotes (either
        alone or together with other text and/or variables), the contents of the
        corresponding bit vector are converted into a printable string.</p>
    <p class="Pp">Since there are several conversion methods available in this
        module (see the description of the methods
        &quot;<span class="Li">&quot;to_Hex()&quot;</span>&quot;,
        &quot;<span class="Li">&quot;to_Bin()&quot;</span>&quot;,
        &quot;<span class="Li">&quot;to_Dec()&quot;</span>&quot; and
        &quot;<span class="Li">&quot;to_Enum()&quot;</span>&quot;), it is of
        course desirable to be able to choose which of these methods should be
        applied in this case.</p>
    <p class="Pp">This can actually be done by changing the configuration of
        this module using the method
        &quot;<span class="Li">&quot;Configure()&quot;</span>&quot; (see the
        previous chapter, immediately above).</p>
    <p class="Pp">The default is conversion to hexadecimal.</p>
  </li>
  <li><span class="Li">&quot;if ($vector)&quot;</span>
    <p class="Pp">It is possible to use a Perl variable containing the reference
        of a &quot;Bit::Vector&quot; object as a boolean expression.</p>
    <p class="Pp">The condition above is true if the corresponding bit vector
        contains at least one set bit, and it is false if <b>ALL</b> bits of the
        corresponding bit vector are cleared.</p>
  </li>
  <li><span class="Li">&quot;if (!$vector)&quot;</span>
    <p class="Pp">Since it is possible to use a Perl variable containing the
        reference of a &quot;Bit::Vector&quot; object as a boolean expression,
        you can of course also negate this boolean expression.</p>
    <p class="Pp">The condition above is true if <b>ALL</b> bits of the
        corresponding bit vector are cleared, and it is false if the
        corresponding bit vector contains at least one set bit.</p>
    <p class="Pp">Note that this is <b>NOT</b> the same as using the method
        &quot;<span class="Li">&quot;is_full()&quot;</span>&quot;, which returns
        true if <b>ALL</b> bits of the corresponding bit vector are
      <b>SET</b>.</p>
  </li>
  <li><span class="Li">&quot;~$vector&quot;</span>
    <p class="Pp">This term returns a new bit vector object which is the one's
        complement of the given bit vector.</p>
    <p class="Pp">This is equivalent to inverting all bits.</p>
  </li>
  <li><span class="Li">&quot;-$vector&quot;</span> (unary minus)
    <p class="Pp">This term returns a new bit vector object which is the two's
        complement of the given bit vector.</p>
    <p class="Pp">This is equivalent to inverting all bits and incrementing the
        result by one.</p>
    <p class="Pp">(This is the same as changing the sign of a number in two's
        complement binary representation.)</p>
  </li>
  <li><span class="Li">&quot;abs($vector)&quot;</span>
    <p class="Pp">Depending on the configuration (see the description of the
        method &quot;<span class="Li">&quot;Configuration()&quot;</span>&quot;
        for more details), this term either returns the number of set bits in
        the given bit vector (this is the same as calculating the number of
        elements which are contained in the given set) - which is the default
        behaviour, or it returns a new bit vector object which contains the
        absolute value of the number stored in the given bit vector.</p>
  </li>
  <li><span class="Li">&quot;$vector1 . $vector2&quot;</span>
    <p class="Pp">This term usually returns a new bit vector object which is the
        result of the concatenation of the two bit vector operands.</p>
    <p class="Pp">The left operand becomes the most significant, and the right
        operand becomes the least significant part of the new bit vector
      object.</p>
    <p class="Pp">If one of the two operands is not a bit vector object but a
        Perl scalar, however, the contents of the remaining bit vector operand
        are converted into a string (the format of which depends on the
        configuration set with the
        &quot;<span class="Li">&quot;Configuration()&quot;</span>&quot; method),
        which is then concatenated in the proper order (i.e., as indicated by
        the order of the two operands) with the Perl scalar.</p>
    <p class="Pp">In other words, a string is returned in such a case instead of
        a bit vector object!</p>
  </li>
  <li><span class="Li">&quot;$vector x $factor&quot;</span>
    <p class="Pp">This term returns a new bit vector object which is the
        concatenation of as many copies of the given bit vector operand (the
        left operand) as the factor (the right operand) specifies.</p>
    <p class="Pp">If the factor is zero, a bit vector object with a length of
        zero bits is returned.</p>
    <p class="Pp">If the factor is one, just a new copy of the given bit vector
        is returned.</p>
    <p class="Pp">Note that a fatal &quot;reversed operands error&quot; occurs
        if the two operands are swapped.</p>
  </li>
  <li><span class="Li">&quot;$vector &lt;&lt; $bits&quot;</span>
    <p class="Pp">This term returns a new bit vector object which is a copy of
        the given bit vector (the left operand), which is then shifted left
        (towards the most significant bit) by as many places as the right
        operand, &quot;<span class="Li">$bits</span>&quot;, specifies.</p>
    <p class="Pp">This means that the &quot;<span class="Li">$bits</span>&quot;
        most significant bits are lost, all other bits move up by
        &quot;<span class="Li">$bits</span>&quot; positions, and the
        &quot;<span class="Li">$bits</span>&quot; least significant bits that
        have been left unoccupied by this shift are all set to zero.</p>
    <p class="Pp">If &quot;<span class="Li">$bits</span>&quot; is greater than
        the number of bits of the given bit vector, this term returns an empty
        bit vector (i.e., with all bits cleared) of the same size as the given
        bit vector.</p>
    <p class="Pp">Note that a fatal &quot;reversed operands error&quot; occurs
        if the two operands are swapped.</p>
  </li>
  <li><span class="Li">&quot;$vector &gt;&gt; $bits&quot;</span>
    <p class="Pp">This term returns a new bit vector object which is a copy of
        the given bit vector (the left operand), which is then shifted right
        (towards the least significant bit) by as many places as the right
        operand, &quot;<span class="Li">$bits</span>&quot;, specifies.</p>
    <p class="Pp">This means that the &quot;<span class="Li">$bits</span>&quot;
        least significant bits are lost, all other bits move down by
        &quot;<span class="Li">$bits</span>&quot; positions, and the
        &quot;<span class="Li">$bits</span>&quot; most significant bits that
        have been left unoccupied by this shift are all set to zero.</p>
    <p class="Pp">If &quot;<span class="Li">$bits</span>&quot; is greater than
        the number of bits of the given bit vector, this term returns an empty
        bit vector (i.e., with all bits cleared) of the same size as the given
        bit vector.</p>
    <p class="Pp">Note that a fatal &quot;reversed operands error&quot; occurs
        if the two operands are swapped.</p>
  </li>
  <li><span class="Li">&quot;$vector1 | $vector2&quot;</span>
    <p class="Pp">This term returns a new bit vector object which is the result
        of a bitwise OR operation between the two bit vector operands.</p>
    <p class="Pp">This is the same as calculating the union of two sets.</p>
  </li>
  <li><span class="Li">&quot;$vector1 &amp; $vector2&quot;</span>
    <p class="Pp">This term returns a new bit vector object which is the result
        of a bitwise AND operation between the two bit vector operands.</p>
    <p class="Pp">This is the same as calculating the intersection of two
      sets.</p>
  </li>
  <li><span class="Li">&quot;$vector1 ^ $vector2&quot;</span>
    <p class="Pp">This term returns a new bit vector object which is the result
        of a bitwise XOR (exclusive-or) operation between the two bit vector
        operands.</p>
    <p class="Pp">This is the same as calculating the symmetric difference of
        two sets.</p>
  </li>
  <li><span class="Li">&quot;$vector1 + $vector2&quot;</span>
    <p class="Pp">Depending on the configuration (see the description of the
        method &quot;<span class="Li">&quot;Configuration()&quot;</span>&quot;
        for more details), this term either returns a new bit vector object
        which is the result of a bitwise OR operation between the two bit vector
        operands (this is the same as calculating the union of two sets) - which
        is the default behaviour, or it returns a new bit vector object which
        contains the sum of the two numbers stored in the two bit vector
        operands.</p>
  </li>
  <li><span class="Li">&quot;$vector1 - $vector2&quot;</span>
    <p class="Pp">Depending on the configuration (see the description of the
        method &quot;<span class="Li">&quot;Configuration()&quot;</span>&quot;
        for more details), this term either returns a new bit vector object
        which is the set difference of the two sets represented in the two bit
        vector operands - which is the default behaviour, or it returns a new
        bit vector object which contains the difference of the two numbers
        stored in the two bit vector operands.</p>
  </li>
  <li><span class="Li">&quot;$vector1 * $vector2&quot;</span>
    <p class="Pp">Depending on the configuration (see the description of the
        method &quot;<span class="Li">&quot;Configuration()&quot;</span>&quot;
        for more details), this term either returns a new bit vector object
        which is the result of a bitwise AND operation between the two bit
        vector operands (this is the same as calculating the intersection of two
        sets) - which is the default behaviour, or it returns a new bit vector
        object which contains the product of the two numbers stored in the two
        bit vector operands.</p>
  </li>
  <li><span class="Li">&quot;$vector1 / $vector2&quot;</span>
    <p class="Pp">This term returns a new bit vector object containing the
        result of the division of the two numbers stored in the two bit vector
        operands.</p>
  </li>
  <li><span class="Li">&quot;$vector1 % $vector2&quot;</span>
    <p class="Pp">This term returns a new bit vector object containing the
        remainder of the division of the two numbers stored in the two bit
        vector operands.</p>
  </li>
  <li><span class="Li">&quot;$vector1 ** $vector2&quot;</span>
    <p class="Pp">This term returns a new bit vector object containing the
        result of the exponentiation of the left bit vector elevated to the
        right bit vector's power.</p>
  </li>
  <li><span class="Li">&quot;$vector1 .= $vector2;&quot;</span>
    <p class="Pp">This statement &quot;appends&quot; the right bit vector
        operand (the &quot;rvalue&quot;) to the left one (the
        &quot;lvalue&quot;).</p>
    <p class="Pp">The former contents of the left operand become the most
        significant part of the resulting bit vector, and the right operand
        becomes the least significant part.</p>
    <p class="Pp">Since bit vectors are stored in &quot;least order bit
        first&quot; order, this actually requires the left operand to be shifted
        &quot;up&quot; by the length of the right operand, which is then copied
        to the now freed least significant part of the left operand.</p>
    <p class="Pp">If the right operand is a Perl scalar, it is first converted
        to a bit vector of the same size as the left operand, provided that the
        configuration states that scalars are to be regarded as indices, decimal
        strings or enumerations.</p>
    <p class="Pp">If the configuration states that scalars are to be regarded as
        hexadecimal or boolean strings, however, these strings are converted to
        bit vectors of a size matching the length of the input string, i.e.,
        four times the length for hexadecimal strings (because each hexadecimal
        digit is worth 4 bits) and once the length for binary strings.</p>
  </li>
  <li><span class="Li">&quot;$vector x= $factor;&quot;</span>
    <p class="Pp">This statement replaces the given bit vector by a
        concatenation of as many copies of the original contents of the given
        bit vector as the factor (the right operand) specifies.</p>
    <p class="Pp">If the factor is zero, the given bit vector is resized to a
        length of zero bits.</p>
    <p class="Pp">If the factor is one, the given bit vector is not changed at
        all.</p>
  </li>
  <li><span class="Li">&quot;$vector &lt;&lt;= $bits;&quot;</span>
    <p class="Pp">This statement moves the contents of the given bit vector left
        by &quot;<span class="Li">$bits</span>&quot; positions (towards the most
        significant bit).</p>
    <p class="Pp">This means that the &quot;<span class="Li">$bits</span>&quot;
        most significant bits are lost, all other bits move up by
        &quot;<span class="Li">$bits</span>&quot; positions, and the
        &quot;<span class="Li">$bits</span>&quot; least significant bits that
        have been left unoccupied by this shift are all set to zero.</p>
    <p class="Pp">If &quot;<span class="Li">$bits</span>&quot; is greater than
        the number of bits of the given bit vector, the given bit vector is
        erased completely (i.e., all bits are cleared).</p>
  </li>
  <li><span class="Li">&quot;$vector &gt;&gt;= $bits;&quot;</span>
    <p class="Pp">This statement moves the contents of the given bit vector
        right by &quot;<span class="Li">$bits</span>&quot; positions (towards
        the least significant bit).</p>
    <p class="Pp">This means that the &quot;<span class="Li">$bits</span>&quot;
        least significant bits are lost, all other bits move down by
        &quot;<span class="Li">$bits</span>&quot; positions, and the
        &quot;<span class="Li">$bits</span>&quot; most significant bits that
        have been left unoccupied by this shift are all set to zero.</p>
    <p class="Pp">If &quot;<span class="Li">$bits</span>&quot; is greater than
        the number of bits of the given bit vector, the given bit vector is
        erased completely (i.e., all bits are cleared).</p>
  </li>
  <li><span class="Li">&quot;$vector1 |= $vector2;&quot;</span>
    <p class="Pp">This statement performs a bitwise OR operation between the two
        bit vector operands and stores the result in the left operand.</p>
    <p class="Pp">This is the same as calculating the union of two sets.</p>
  </li>
  <li><span class="Li">&quot;$vector1 &amp;= $vector2;&quot;</span>
    <p class="Pp">This statement performs a bitwise AND operation between the
        two bit vector operands and stores the result in the left operand.</p>
    <p class="Pp">This is the same as calculating the intersection of two
      sets.</p>
  </li>
  <li><span class="Li">&quot;$vector1 ^= $vector2;&quot;</span>
    <p class="Pp">This statement performs a bitwise XOR (exclusive-or) operation
        between the two bit vector operands and stores the result in the left
        operand.</p>
    <p class="Pp">This is the same as calculating the symmetric difference of
        two sets.</p>
  </li>
  <li><span class="Li">&quot;$vector1 += $vector2;&quot;</span>
    <p class="Pp">Depending on the configuration (see the description of the
        method &quot;<span class="Li">&quot;Configuration()&quot;</span>&quot;
        for more details), this statement either performs a bitwise OR operation
        between the two bit vector operands (this is the same as calculating the
        union of two sets) - which is the default behaviour, or it calculates
        the sum of the two numbers stored in the two bit vector operands.</p>
    <p class="Pp">The result of this operation is stored in the left
      operand.</p>
  </li>
  <li><span class="Li">&quot;$vector1 -= $vector2;&quot;</span>
    <p class="Pp">Depending on the configuration (see the description of the
        method &quot;<span class="Li">&quot;Configuration()&quot;</span>&quot;
        for more details), this statement either calculates the set difference
        of the two sets represented in the two bit vector operands - which is
        the default behaviour, or it calculates the difference of the two
        numbers stored in the two bit vector operands.</p>
    <p class="Pp">The result of this operation is stored in the left
      operand.</p>
  </li>
  <li><span class="Li">&quot;$vector1 *= $vector2;&quot;</span>
    <p class="Pp">Depending on the configuration (see the description of the
        method &quot;<span class="Li">&quot;Configuration()&quot;</span>&quot;
        for more details), this statement either performs a bitwise AND
        operation between the two bit vector operands (this is the same as
        calculating the intersection of two sets) - which is the default
        behaviour, or it calculates the product of the two numbers stored in the
        two bit vector operands.</p>
    <p class="Pp">The result of this operation is stored in the left
      operand.</p>
  </li>
  <li><span class="Li">&quot;$vector1 /= $vector2;&quot;</span>
    <p class="Pp">This statement puts the result of the division of the two
        numbers stored in the two bit vector operands into the left operand.</p>
  </li>
  <li><span class="Li">&quot;$vector1 %= $vector2;&quot;</span>
    <p class="Pp">This statement puts the remainder of the division of the two
        numbers stored in the two bit vector operands into the left operand.</p>
  </li>
  <li><span class="Li">&quot;$vector1 **= $vector2;&quot;</span>
    <p class="Pp">This statement puts the result of the exponentiation of the
        left operand elevated to the right operand's power into the left
        operand.</p>
  </li>
  <li><span class="Li">&quot;++$vector&quot;</span>,
      <span class="Li">&quot;$vector++&quot;</span>
    <p class="Pp">This operator performs pre- and post-incrementation of the
        given bit vector.</p>
    <p class="Pp">The value returned by this term is a reference of the given
        bit vector object (after or before the incrementation,
      respectively).</p>
  </li>
  <li><span class="Li">&quot;--$vector&quot;</span>,
      <span class="Li">&quot;$vector--&quot;</span>
    <p class="Pp">This operator performs pre- and post-decrementation of the
        given bit vector.</p>
    <p class="Pp">The value returned by this term is a reference of the given
        bit vector object (after or before the decrementation,
      respectively).</p>
  </li>
  <li><span class="Li">&quot;($vector1 cmp $vector2)&quot;</span>
    <p class="Pp">This term returns
        &quot;<span class="Li">&quot;-1&quot;</span>&quot; if
        &quot;<span class="Li">$vector1</span>&quot; is less than
        &quot;<span class="Li">$vector2</span>&quot;,
        &quot;<span class="Li">0</span>&quot; if
        &quot;<span class="Li">$vector1</span>&quot; and
        &quot;<span class="Li">$vector2</span>&quot; are the same, and
        &quot;<span class="Li">1</span>&quot; if
        &quot;<span class="Li">$vector1</span>&quot; is greater than
        &quot;<span class="Li">$vector2</span>&quot;.</p>
    <p class="Pp">This comparison assumes <b>UNSIGNED</b> bit vectors.</p>
  </li>
  <li><span class="Li">&quot;($vector1 eq $vector2)&quot;</span>
    <p class="Pp">This term returns true (&quot;<span class="Li">1</span>&quot;)
        if the contents of the two bit vector operands are the same and false
        (&quot;<span class="Li">0</span>&quot;) otherwise.</p>
  </li>
  <li><span class="Li">&quot;($vector1 ne $vector2)&quot;</span>
    <p class="Pp">This term returns true (&quot;<span class="Li">1</span>&quot;)
        if the two bit vector operands differ and false
        (&quot;<span class="Li">0</span>&quot;) otherwise.</p>
  </li>
  <li><span class="Li">&quot;($vector1 lt $vector2)&quot;</span>
    <p class="Pp">This term returns true (&quot;<span class="Li">1</span>&quot;)
        if &quot;<span class="Li">$vector1</span>&quot; is less than
        &quot;<span class="Li">$vector2</span>&quot;, and false
        (&quot;<span class="Li">0</span>&quot;) otherwise.</p>
    <p class="Pp">This comparison assumes <b>UNSIGNED</b> bit vectors.</p>
  </li>
  <li><span class="Li">&quot;($vector1 le $vector2)&quot;</span>
    <p class="Pp">This term returns true (&quot;<span class="Li">1</span>&quot;)
        if &quot;<span class="Li">$vector1</span>&quot; is less than or equal to
        &quot;<span class="Li">$vector2</span>&quot;, and false
        (&quot;<span class="Li">0</span>&quot;) otherwise.</p>
    <p class="Pp">This comparison assumes <b>UNSIGNED</b> bit vectors.</p>
  </li>
  <li><span class="Li">&quot;($vector1 gt $vector2)&quot;</span>
    <p class="Pp">This term returns true (&quot;<span class="Li">1</span>&quot;)
        if &quot;<span class="Li">$vector1</span>&quot; is greater than
        &quot;<span class="Li">$vector2</span>&quot;, and false
        (&quot;<span class="Li">0</span>&quot;) otherwise.</p>
    <p class="Pp">This comparison assumes <b>UNSIGNED</b> bit vectors.</p>
  </li>
  <li><span class="Li">&quot;($vector1 ge $vector2)&quot;</span>
    <p class="Pp">This term returns true (&quot;<span class="Li">1</span>&quot;)
        if &quot;<span class="Li">$vector1</span>&quot; is greater than or equal
        to &quot;<span class="Li">$vector2</span>&quot;, and false
        (&quot;<span class="Li">0</span>&quot;) otherwise.</p>
    <p class="Pp">This comparison assumes <b>UNSIGNED</b> bit vectors.</p>
  </li>
  <li><span class="Li">&quot;($vector1 &lt;=&gt; $vector2)&quot;</span>
    <p class="Pp">This term returns
        &quot;<span class="Li">&quot;-1&quot;</span>&quot; if
        &quot;<span class="Li">$vector1</span>&quot; is less than
        &quot;<span class="Li">$vector2</span>&quot;,
        &quot;<span class="Li">0</span>&quot; if
        &quot;<span class="Li">$vector1</span>&quot; and
        &quot;<span class="Li">$vector2</span>&quot; are the same, and
        &quot;<span class="Li">1</span>&quot; if
        &quot;<span class="Li">$vector1</span>&quot; is greater than
        &quot;<span class="Li">$vector2</span>&quot;.</p>
    <p class="Pp">This comparison assumes <b>SIGNED</b> bit vectors.</p>
  </li>
  <li><span class="Li">&quot;($vector1 == $vector2)&quot;</span>
    <p class="Pp">This term returns true (&quot;<span class="Li">1</span>&quot;)
        if the contents of the two bit vector operands are the same and false
        (&quot;<span class="Li">0</span>&quot;) otherwise.</p>
  </li>
  <li><span class="Li">&quot;($vector1 != $vector2)&quot;</span>
    <p class="Pp">This term returns true (&quot;<span class="Li">1</span>&quot;)
        if the two bit vector operands differ and false
        (&quot;<span class="Li">0</span>&quot;) otherwise.</p>
  </li>
  <li><span class="Li">&quot;($vector1 &lt; $vector2)&quot;</span>
    <p class="Pp">Depending on the configuration (see the description of the
        method &quot;<span class="Li">&quot;Configuration()&quot;</span>&quot;
        for more details), this term either returns true
        (&quot;<span class="Li">1</span>&quot;) if
        &quot;<span class="Li">$vector1</span>&quot; is a true subset of
        &quot;<span class="Li">$vector2</span>&quot; (and false
        (&quot;<span class="Li">0</span>&quot;) otherwise) - which is the
        default behaviour, or it returns true
        (&quot;<span class="Li">1</span>&quot;) if
        &quot;<span class="Li">$vector1</span>&quot; is less than
        &quot;<span class="Li">$vector2</span>&quot; (and false
        (&quot;<span class="Li">0</span>&quot;) otherwise).</p>
    <p class="Pp">The latter comparison assumes <b>SIGNED</b> bit vectors.</p>
  </li>
  <li><span class="Li">&quot;($vector1 &lt;= $vector2)&quot;</span>
    <p class="Pp">Depending on the configuration (see the description of the
        method &quot;<span class="Li">&quot;Configuration()&quot;</span>&quot;
        for more details), this term either returns true
        (&quot;<span class="Li">1</span>&quot;) if
        &quot;<span class="Li">$vector1</span>&quot; is a subset of
        &quot;<span class="Li">$vector2</span>&quot; (and false
        (&quot;<span class="Li">0</span>&quot;) otherwise) - which is the
        default behaviour, or it returns true
        (&quot;<span class="Li">1</span>&quot;) if
        &quot;<span class="Li">$vector1</span>&quot; is less than or equal to
        &quot;<span class="Li">$vector2</span>&quot; (and false
        (&quot;<span class="Li">0</span>&quot;) otherwise).</p>
    <p class="Pp">The latter comparison assumes <b>SIGNED</b> bit vectors.</p>
  </li>
  <li><span class="Li">&quot;($vector1 &gt; $vector2)&quot;</span>
    <p class="Pp">Depending on the configuration (see the description of the
        method &quot;<span class="Li">&quot;Configuration()&quot;</span>&quot;
        for more details), this term either returns true
        (&quot;<span class="Li">1</span>&quot;) if
        &quot;<span class="Li">$vector1</span>&quot; is a true superset of
        &quot;<span class="Li">$vector2</span>&quot; (and false
        (&quot;<span class="Li">0</span>&quot;) otherwise) - which is the
        default behaviour, or it returns true
        (&quot;<span class="Li">1</span>&quot;) if
        &quot;<span class="Li">$vector1</span>&quot; is greater than
        &quot;<span class="Li">$vector2</span>&quot; (and false
        (&quot;<span class="Li">0</span>&quot;) otherwise).</p>
    <p class="Pp">The latter comparison assumes <b>SIGNED</b> bit vectors.</p>
  </li>
  <li><span class="Li">&quot;($vector1 &gt;= $vector2)&quot;</span>
    <p class="Pp">Depending on the configuration (see the description of the
        method &quot;<span class="Li">&quot;Configuration()&quot;</span>&quot;
        for more details), this term either returns true
        (&quot;<span class="Li">1</span>&quot;) if
        &quot;<span class="Li">$vector1</span>&quot; is a superset of
        &quot;<span class="Li">$vector2</span>&quot; (and false
        (&quot;<span class="Li">0</span>&quot;) otherwise) - which is the
        default behaviour, or it returns true
        (&quot;<span class="Li">1</span>&quot;) if
        &quot;<span class="Li">$vector1</span>&quot; is greater than or equal to
        &quot;<span class="Li">$vector2</span>&quot; (and false
        (&quot;<span class="Li">0</span>&quot;) otherwise).</p>
    <p class="Pp">The latter comparison assumes <b>SIGNED</b> bit vectors.</p>
  </li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<b>Bit::Vector</b>(3), <b>Bit::Vector::String</b>(3).
</section>
<section class="Sh">
<h1 class="Sh" id="VERSION"><a class="permalink" href="#VERSION">VERSION</a></h1>
This man page documents &quot;Bit::Vector::Overload&quot; version 7.4.
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<span class="Li"></span>
<pre>
  Steffen Beyer
  mailto:STBEY@cpan.org
  http://www.engelschall.com/u/sb/download/
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT"><a class="permalink" href="#COPYRIGHT">COPYRIGHT</a></h1>
Copyright (c) 2000 - 2013 by Steffen Beyer. All rights reserved.
</section>
<section class="Sh">
<h1 class="Sh" id="LICENSE"><a class="permalink" href="#LICENSE">LICENSE</a></h1>
This package is free software; you can redistribute it and/or modify it under
  the same terms as Perl itself, i.e., under the terms of the &quot;Artistic
  License&quot; or the &quot;GNU General Public License&quot;.
<p class="Pp">The C library at the core of this Perl module can additionally be
    redistributed and/or modified under the terms of the &quot;GNU Library
    General Public License&quot;.</p>
<p class="Pp">Please refer to the files &quot;Artistic.txt&quot;,
    &quot;GNU_GPL.txt&quot; and &quot;GNU_LGPL.txt&quot; in this distribution
    for details!</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DISCLAIMER"><a class="permalink" href="#DISCLAIMER">DISCLAIMER</a></h1>
This package is distributed in the hope that it will be useful, but WITHOUT ANY
  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
  A PARTICULAR PURPOSE.
<p class="Pp">See the &quot;GNU General Public License&quot; for more
  details.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2013-09-03</td>
    <td class="foot-os">perl v5.28.2</td>
  </tr>
</table>
</body>
</html>
