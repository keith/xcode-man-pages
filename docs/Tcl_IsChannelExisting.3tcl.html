<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Copyright (c) 1996-1997 Sun Microsystems, Inc.
   Copyright (c) 1997-2000 Ajuba Solutions.
  
   See the file "license.terms" for information on usage and redistribution
   of this file, and for a DISCLAIMER OF ALL WARRANTIES.
  
   RCS: @(#) $Id: CrtChannel.3,v 1.40.2.1 2009/11/27 14:53:54 dkf Exp $
   The -*- nroff -*- definitions below are for supplemental macros used
   in Tcl/Tk manual entries.
  
   .AP type name in/out ?indent?
  	Start paragraph describing an argument to a library procedure.
  	type is type of argument (int, etc.), in/out is either "in", "out",
  	or "in/out" to describe whether procedure reads or modifies arg,
  	and indent is equivalent to second arg of .IP (shouldn't ever be
  	needed;  use .AS below instead)
  
   .AS ?type? ?name?
  	Give maximum sizes of arguments for setting tab stops.  Type and
  	name are examples of largest possible arguments that will be passed
  	to .AP later.  If args are omitted, default tab stops are used.
  
   .BS
  	Start box enclosure.  From here until next .BE, everything will be
  	enclosed in one large box.
  
   .BE
  	End of box enclosure.
  
   .CS
  	Begin code excerpt.
  
   .CE
  	End code excerpt.
  
   .VS ?version? ?br?
  	Begin vertical sidebar, for use in marking newly-changed parts
  	of man pages.  The first argument is ignored and used for recording
  	the version when the .VS was added, so that the sidebars can be
  	found and removed when they reach a certain age.  If another argument
  	is present, then a line break is forced before starting the sidebar.
  
   .VE
  	End of vertical sidebar.
  
   .DS
  	Begin an indented unfilled display.
  
   .DE
  	End of indented unfilled display.
  
   .SO ?manpage?
  	Start of list of standard options for a Tk widget. The manpage
  	argument defines where to look up the standard options; if
  	omitted, defaults to "options". The options follow on successive
  	lines, in three columns separated by tabs.
  
   .SE
  	End of list of standard options for a Tk widget.
  
   .OP cmdName dbName dbClass
  	Start of description of a specific option.  cmdName gives the
  	option's name as specified in the class command, dbName gives
  	the option's name in the option database, and dbClass gives
  	the option's class in the option database.
  
   .UL arg1 arg2
  	Print arg1 underlined, then print arg2 normally.
  
   .QW arg1 ?arg2?
  	Print arg1 in quotes, then arg2 normally (for trailing punctuation).
  
   .PQ arg1 ?arg2?
  	Print an open parenthesis, arg1 in quotes, then arg2 normally
  	(for trailing punctuation) and then a closing parenthesis.
  
   RCS: @(#) $Id: man.macros,v 1.9 2008/01/29 15:32:33 dkf Exp $
  
  	# Set up traps and other miscellaneous stuff for Tcl/Tk man pages.
  	# Start an argument description
  .b
  	# define tabbing values for .AP
  
  	# BS - start boxed text
  	# ^y = starting y location
  	# ^b = 1
  	# BE - end boxed text (draw box now)
  	Draw four-sided box normally, but don't draw top of
  	box if the box started on an earlier page.
  	# VS - start vertical sidebar
  	# ^Y = starting y location
  	# ^v = 1 (for troff;  for nroff this doesn't matter)
  	# VE - end of vertical sidebar
  	# Special macro to handle page bottom:  finish off current
  	# box/sidebar if in box/sidebar mode, then invoked standard
  	# page bottom macro.
  	Draw three-sided box if this is the box's first page,
  	draw two sides but no top otherwise.
  	# DS - begin display
  	# DE - end display
  	# SO - start of list of standard options
  	# SE - end of list of standard options
  	# OP - start of full description for a single option
  	# CS - begin code excerpt
  	# CE - end code excerpt
  	# UL - underline word
  	# QW - apply quotation marks to word
  " fix emacs highlighting
  	# PQ - apply parens and quotation marks to word
  " fix emacs highlighting
  	# QR - quoted range
  " fix emacs highlighting
  	# MT - "empty" string
 -->
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>Tcl_CreateChannel(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Tcl_CreateChannel(3)</td>
    <td class="head-vol">Tcl Library Procedures</td>
    <td class="head-rtitle">Tcl_CreateChannel(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<pre>

</pre>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
Tcl_CreateChannel, Tcl_GetChannelInstanceData, Tcl_GetChannelType,
  Tcl_GetChannelName, Tcl_GetChannelHandle, Tcl_GetChannelMode,
  Tcl_GetChannelBufferSize, Tcl_SetChannelBufferSize, Tcl_NotifyChannel,
  Tcl_BadChannelOption, Tcl_ChannelName, Tcl_ChannelVersion,
  Tcl_ChannelBlockModeProc, Tcl_ChannelCloseProc, Tcl_ChannelClose2Proc,
  Tcl_ChannelInputProc, Tcl_ChannelOutputProc, Tcl_ChannelSeekProc,
  Tcl_ChannelWideSeekProc, Tcl_ChannelTruncateProc, Tcl_ChannelSetOptionProc,
  Tcl_ChannelGetOptionProc, Tcl_ChannelWatchProc, Tcl_ChannelGetHandleProc,
  Tcl_ChannelFlushProc, Tcl_ChannelHandlerProc, Tcl_ChannelThreadActionProc,
  Tcl_IsChannelShared, Tcl_IsChannelRegistered, Tcl_CutChannel,
  Tcl_SpliceChannel, Tcl_IsChannelExisting, Tcl_ClearChannelHandlers,
  Tcl_GetChannelThread, Tcl_ChannelBuffered - procedures for creating and
  manipulating channels
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>
<b>#include &lt;tcl.h&gt;</b>

Tcl_Channel
<b>Tcl_CreateChannel</b>(<i>typePtr, channelName, instanceData, mask</i>)

ClientData
<b>Tcl_GetChannelInstanceData</b>(<i>channel</i>)

Tcl_ChannelType *
<b>Tcl_GetChannelType</b>(<i>channel</i>)

const char *
<b>Tcl_GetChannelName</b>(<i>channel</i>)

int
<b>Tcl_GetChannelHandle</b>(<i>channel, direction, handlePtr</i>)

Tcl_ThreadId
<b>Tcl_GetChannelThread</b>(<i>channel</i>)

int
<b>Tcl_GetChannelMode</b>(<i>channel</i>)

int
<b>Tcl_GetChannelBufferSize</b>(<i>channel</i>)

<b>Tcl_SetChannelBufferSize</b>(<i>channel, size</i>)

<b>Tcl_NotifyChannel</b>(<i>channel, mask</i>)

int
<b>Tcl_BadChannelOption</b>(<i>interp, optionName, optionList</i>)

int
<b>Tcl_IsChannelShared</b>(<i>channel</i>)

int
<b>Tcl_IsChannelRegistered</b>(<i>interp, channel</i>)

int
<b>Tcl_IsChannelExisting</b>(<i>channelName</i>)

void
<b>Tcl_CutChannel</b>(<i>channel</i>)

void
<b>Tcl_SpliceChannel</b>(<i>channel</i>)

void
<b>Tcl_ClearChannelHandlers</b>(<i>channel</i>)

int
<b>Tcl_ChannelBuffered</b>(<i>channel</i>)

const char *
<b>Tcl_ChannelName</b>(<i>typePtr</i>)

Tcl_ChannelTypeVersion
<b>Tcl_ChannelVersion</b>(<i>typePtr</i>)

Tcl_DriverBlockModeProc *
<b>Tcl_ChannelBlockModeProc</b>(<i>typePtr</i>)

Tcl_DriverCloseProc *
<b>Tcl_ChannelCloseProc</b>(<i>typePtr</i>)

Tcl_DriverClose2Proc *
<b>Tcl_ChannelClose2Proc</b>(<i>typePtr</i>)

Tcl_DriverInputProc *
<b>Tcl_ChannelInputProc</b>(<i>typePtr</i>)

Tcl_DriverOutputProc *
<b>Tcl_ChannelOutputProc</b>(<i>typePtr</i>)

Tcl_DriverSeekProc *
<b>Tcl_ChannelSeekProc</b>(<i>typePtr</i>)

Tcl_DriverWideSeekProc *
<b>Tcl_ChannelWideSeekProc</b>(<i>typePtr</i>)

Tcl_DriverThreadActionProc *
<b>Tcl_ChannelThreadActionProc</b>(<i>typePtr</i>)

Tcl_DriverTruncateProc *
<b>Tcl_ChannelTruncateProc</b>(<i>typePtr</i>)

Tcl_DriverSetOptionProc *
<b>Tcl_ChannelSetOptionProc</b>(<i>typePtr</i>)

Tcl_DriverGetOptionProc *
<b>Tcl_ChannelGetOptionProc</b>(<i>typePtr</i>)

Tcl_DriverWatchProc *
<b>Tcl_ChannelWatchProc</b>(<i>typePtr</i>)

Tcl_DriverGetHandleProc *
<b>Tcl_ChannelGetHandleProc</b>(<i>typePtr</i>)

Tcl_DriverFlushProc *
<b>Tcl_ChannelFlushProc</b>(<i>typePtr</i>)

Tcl_DriverHandlerProc *
<b>Tcl_ChannelHandlerProc</b>(<i>typePtr</i>)

</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="ARGUMENTS"><a class="permalink" href="#ARGUMENTS">ARGUMENTS</a></h1>
<dl class="Bl-tag">
  <dt>const Tcl_ChannelType <i>*typePtr</i> (in)</dt>
  <dd>Points to a structure containing the addresses of procedures that can be
      called to perform I/O and other functions on the channel.</dd>
  <dt>const char <i>*channelName</i> (in)</dt>
  <dd>The name of this channel, such as <b>file3</b>; must not be in use by any
      other channel. Can be NULL, in which case the channel is created without a
      name.</dd>
  <dt>ClientData <i>instanceData</i> (in)</dt>
  <dd>Arbitrary one-word value to be associated with this channel. This value is
      passed to procedures in <i>typePtr</i> when they are invoked.</dd>
  <dt>int <i>mask</i> (in)</dt>
  <dd>OR-ed combination of <b>TCL_READABLE</b> and <b>TCL_WRITABLE</b> to
      indicate whether a channel is readable and writable.</dd>
  <dt>Tcl_Channel <i>channel</i> (in)</dt>
  <dd>The channel to operate on.</dd>
  <dt>int <i>direction</i> (in)</dt>
  <dd><b>TCL_READABLE</b> means the input handle is wanted; <b>TCL_WRITABLE</b>
      means the output handle is wanted.</dd>
  <dt>ClientData <i>*handlePtr</i> (out)</dt>
  <dd>Points to the location where the desired OS-specific handle should be
      stored.</dd>
  <dt>int <i>size</i> (in)</dt>
  <dd>The size, in bytes, of buffers to allocate in this channel.</dd>
  <dt>int <i>mask</i> (in)</dt>
  <dd>An OR-ed combination of <b>TCL_READABLE</b>, <b>TCL_WRITABLE</b> and
      <b>TCL_EXCEPTION</b> that indicates events that have occurred on this
      channel.</dd>
  <dt>Tcl_Interp <i>*interp</i> (in)</dt>
  <dd>Current interpreter. (can be NULL)</dd>
  <dt>const char <i>*optionName</i> (in)</dt>
  <dd>Name of the invalid option.</dd>
  <dt>const char <i>*optionList</i> (in)</dt>
  <dd>Specific options list (space separated words, without &#x201C;-&#x201D;)
      to append to the standard generic options list. Can be NULL for generic
      options error message only.
    <p class="Pp"></p>
    <pre>

    </pre>
    <p class="Pp"></p>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
Tcl uses a two-layered channel architecture. It provides a generic upper layer
  to enable C and Tcl programs to perform input and output using the same APIs
  for a variety of files, devices, sockets etc. The generic C APIs are described
  in the manual entry for <b>Tcl_OpenFileChannel</b>.
<p class="Pp">The lower layer provides type-specific channel drivers for each
    type of device supported on each platform. This manual entry describes the C
    APIs used to communicate between the generic layer and the type-specific
    channel drivers. It also explains how new types of channels can be added by
    providing new channel drivers.</p>
<p class="Pp">Channel drivers consist of a number of components: First, each
    channel driver provides a <b>Tcl_ChannelType</b> structure containing
    pointers to functions implementing the various operations used by the
    generic layer to communicate with the channel driver. The
    <b>Tcl_ChannelType</b> structure and the functions referenced by it are
    described in the section <b>TCL_CHANNELTYPE</b>, below.</p>
<p class="Pp">Second, channel drivers usually provide a Tcl command to create
    instances of that type of channel. For example, the Tcl <b>open</b> command
    creates channels that use the file and command channel drivers, and the Tcl
    <b>socket</b> command creates channels that use TCP sockets for network
    communication.</p>
<p class="Pp">Third, a channel driver optionally provides a C function to open
    channel instances of that type. For example, <b>Tcl_OpenFileChannel</b>
    opens a channel that uses the file channel driver, and
    <b>Tcl_OpenTcpClient</b> opens a channel that uses the TCP network protocol.
    These creation functions typically use <b>Tcl_CreateChannel</b> internally
    to open the channel.</p>
<p class="Pp">To add a new type of channel you must implement a C API or a Tcl
    command that opens a channel by invoking <b>Tcl_CreateChannel</b>. When your
    driver calls <b>Tcl_CreateChannel</b> it passes in a <b>Tcl_ChannelType</b>
    structure describing the driver's I/O procedures. The generic layer will
    then invoke the functions referenced in that structure to perform operations
    on the channel.</p>
<p class="Pp"><b>Tcl_CreateChannel</b> opens a new channel and associates the
    supplied <i>typePtr</i> and <i>instanceData</i> with it. The channel is
    opened in the mode indicated by <i>mask</i>. For a discussion of channel
    drivers, their operations and the <b>Tcl_ChannelType</b> structure, see the
    section <b>TCL_CHANNELTYPE</b>, below.</p>
<p class="Pp"><b>Tcl_CreateChannel</b> interacts with the code managing the
    standard channels. Once a standard channel was initialized either through a
    call to <b>Tcl_GetStdChannel</b> or a call to <b>Tcl_SetStdChannel</b>
    closing this standard channel will cause the next call to
    <b>Tcl_CreateChannel</b> to make the new channel the new standard channel
    too. See <b>Tcl_StandardChannels</b> for a general treatise about standard
    channels and the behaviour of the Tcl library with regard to them.</p>
<p class="Pp"><b>Tcl_GetChannelInstanceData</b> returns the instance data
    associated with the channel in <i>channel</i>. This is the same as the
    <i>instanceData</i> argument in the call to <b>Tcl_CreateChannel</b> that
    created this channel.</p>
<p class="Pp"><b>Tcl_GetChannelType</b> returns a pointer to the
    <b>Tcl_ChannelType</b> structure used by the channel in the <i>channel</i>
    argument. This is the same as the <i>typePtr</i> argument in the call to
    <b>Tcl_CreateChannel</b> that created this channel.</p>
<p class="Pp"><b>Tcl_GetChannelName</b> returns a string containing the name
    associated with the channel, or NULL if the <i>channelName</i> argument to
    <b>Tcl_CreateChannel</b> was NULL.</p>
<p class="Pp"><b>Tcl_GetChannelHandle</b> places the OS-specific device handle
    associated with <i>channel</i> for the given <i>direction</i> in the
    location specified by <i>handlePtr</i> and returns <b>TCL_OK</b>. If the
    channel does not have a device handle for the specified direction, then
    <b>TCL_ERROR</b> is returned instead. Different channel drivers will return
    different types of handle. Refer to the manual entries for each driver to
    determine what type of handle is returned.</p>
<p class="Pp"><b>Tcl_GetChannelThread</b> returns the id of the thread currently
    managing the specified <i>channel</i>. This allows channel drivers to send
    their file events to the correct event queue even for a multi-threaded
  core.</p>
<p class="Pp"><b>Tcl_GetChannelMode</b> returns an OR-ed combination of
    <b>TCL_READABLE</b> and <b>TCL_WRITABLE</b>, indicating whether the channel
    is open for input and output.</p>
<p class="Pp"><b>Tcl_GetChannelBufferSize</b> returns the size, in bytes, of
    buffers allocated to store input or output in <i>channel</i>. If the value
    was not set by a previous call to <b>Tcl_SetChannelBufferSize</b>, described
    below, then the default value of 4096 is returned.</p>
<p class="Pp"><b>Tcl_SetChannelBufferSize</b> sets the size, in bytes, of
    buffers that will be allocated in subsequent operations on the channel to
    store input or output. The <i>size</i> argument should be between ten and
    one million, allowing buffers of ten bytes to one million bytes. If
    <i>size</i> is outside this range, <b>Tcl_SetChannelBufferSize</b> sets the
    buffer size to 4096.</p>
<p class="Pp"><b>Tcl_NotifyChannel</b> is called by a channel driver to indicate
    to the generic layer that the events specified by <i>mask</i> have occurred
    on the channel. Channel drivers are responsible for invoking this function
    whenever the channel handlers need to be called for the channel. See
    <b>WATCHPROC</b> below for more details.</p>
<p class="Pp"><b>Tcl_BadChannelOption</b> is called from driver specific
    <i>setOptionProc</i> or <i>getOptionProc</i> to generate a complete error
    message.</p>
<p class="Pp"><b>Tcl_ChannelBuffered</b> returns the number of bytes of input
    currently buffered in the internal buffer (push back area) of the channel
    itself. It does not report about the data in the overall buffers for the
    stack of channels the supplied channel is part of.</p>
<p class="Pp"><b>Tcl_IsChannelShared</b> checks the refcount of the specified
    <i>channel</i> and returns whether the <i>channel</i> was shared among
    multiple interpreters (result == 1) or not (result == 0).</p>
<p class="Pp"><b>Tcl_IsChannelRegistered</b> checks whether the specified
    <i>channel</i> is registered in the given <i>interp</i>reter (result == 1)
    or not (result == 0).</p>
<p class="Pp"><b>Tcl_IsChannelExisting</b> checks whether a channel with the
    specified name is registered in the (thread)-global list of all channels
    (result == 1) or not (result == 0).</p>
<p class="Pp"><b>Tcl_CutChannel</b> removes the specified <i>channel</i> from
    the (thread)global list of all channels (of the current thread). Application
    to a channel still registered in some interpreter is not allowed. Also
    notifies the driver if the <b>Tcl_ChannelType</b> version is
    <b>TCL_CHANNEL_VERSION_4</b> (or higher), and
    <b>Tcl_DriverThreadActionProc</b> is defined for it.</p>
<p class="Pp"><b>Tcl_SpliceChannel</b> adds the specified <i>channel</i> to the
    (thread)global list of all channels (of the current thread). Application to
    a channel registered in some interpreter is not allowed. Also notifies the
    driver if the <b>Tcl_ChannelType</b> version is <b>TCL_CHANNEL_VERSION_4</b>
    (or higher), and <b>Tcl_DriverThreadActionProc</b> is defined for it.</p>
<p class="Pp"><b>Tcl_ClearChannelHandlers</b> removes all channel handlers and
    event scripts associated with the specified <i>channel</i>, thus shutting
    down all event processing for this channel.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="TCL_CHANNELTYPE"><a class="permalink" href="#TCL_CHANNELTYPE">TCL_CHANNELTYPE</a></h1>
A channel driver provides a <b>Tcl_ChannelType</b> structure that contains
  pointers to functions that implement the various operations on a channel;
  these operations are invoked as needed by the generic layer. The structure was
  versioned starting in Tcl 8.3.2/8.4 to correct a problem with stacked channel
  drivers. See the <b>OLD CHANNEL TYPES</b> section below for details about the
  old structure.
<p class="Pp">The <b>Tcl_ChannelType</b> structure contains the following
    fields:</p>
<div class="Bd-indent">
<pre>
typedef struct Tcl_ChannelType {
        char *<i>typeName</i>;
        Tcl_ChannelTypeVersion <i>version</i>;
        Tcl_DriverCloseProc *<i>closeProc</i>;
        Tcl_DriverInputProc *<i>inputProc</i>;
        Tcl_DriverOutputProc *<i>outputProc</i>;
        Tcl_DriverSeekProc *<i>seekProc</i>;
        Tcl_DriverSetOptionProc *<i>setOptionProc</i>;
        Tcl_DriverGetOptionProc *<i>getOptionProc</i>;
        Tcl_DriverWatchProc *<i>watchProc</i>;
        Tcl_DriverGetHandleProc *<i>getHandleProc</i>;
        Tcl_DriverClose2Proc *<i>close2Proc</i>;
        Tcl_DriverBlockModeProc *<i>blockModeProc</i>;
        Tcl_DriverFlushProc *<i>flushProc</i>;
        Tcl_DriverHandlerProc *<i>handlerProc</i>;
        Tcl_DriverWideSeekProc *<i>wideSeekProc</i>;
        Tcl_DriverThreadActionProc *<i>threadActionProc</i>;
        Tcl_DriverTruncateProc *<i>truncateProc</i>;
} Tcl_ChannelType;
</pre>
</div>
<p class="Pp">It is not necessary to provide implementations for all channel
    operations. Those which are not necessary may be set to NULL in the struct:
    <i>blockModeProc</i>, <i>seekProc</i>, <i>setOptionProc</i>,
    <i>getOptionProc</i>, and <i>close2Proc</i>, in addition to
    <i>flushProc</i>, <i>handlerProc</i>, <i>threadActionProc</i>, and
    <i>truncateProc</i>. Other functions that cannot be implemented in a
    meaningful way should return <b>EINVAL</b> when called, to indicate that the
    operations they represent are not available. Also note that
    <i>wideSeekProc</i> can be NULL if <i>seekProc</i> is.</p>
<p class="Pp">The user should only use the above structure for
    <b>Tcl_ChannelType</b> instantiation. When referencing fields in a
    <b>Tcl_ChannelType</b> structure, the following functions should be used to
    obtain the values: <b>Tcl_ChannelName</b>, <b>Tcl_ChannelVersion</b>,
    <b>Tcl_ChannelBlockModeProc</b>, <b>Tcl_ChannelCloseProc</b>,
    <b>Tcl_ChannelClose2Proc</b>, <b>Tcl_ChannelInputProc</b>,
    <b>Tcl_ChannelOutputProc</b>, <b>Tcl_ChannelSeekProc</b>,
    <b>Tcl_ChannelWideSeekProc</b>, <b>Tcl_ChannelThreadActionProc</b>,
    <b>Tcl_ChannelTruncateProc</b>, <b>Tcl_ChannelSetOptionProc</b>,
    <b>Tcl_ChannelGetOptionProc</b>, <b>Tcl_ChannelWatchProc</b>,
    <b>Tcl_ChannelGetHandleProc</b>, <b>Tcl_ChannelFlushProc</b>, or
    <b>Tcl_ChannelHandlerProc</b>.</p>
<p class="Pp">The change to the structures was made in such a way that standard
    channel types are binary compatible. However, channel types that use stacked
    channels (i.e. TLS, Trf) have new versions to correspond to the above change
    since the previous code for stacked channels had problems.</p>
<section class="Ss">
<h2 class="Ss" id="TYPENAME"><a class="permalink" href="#TYPENAME">TYPENAME</a></h2>
The <i>typeName</i> field contains a null-terminated string that identifies the
  type of the device implemented by this driver, e.g. <b>file</b> or
  <b>socket</b>.
<p class="Pp">This value can be retrieved with <b>Tcl_ChannelName</b>, which
    returns a pointer to the string.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="VERSION"><a class="permalink" href="#VERSION">VERSION</a></h2>
The <i>version</i> field should be set to the version of the structure that you
  require. <b>TCL_CHANNEL_VERSION_2</b> is the minimum recommended.
  <b>TCL_CHANNEL_VERSION_3</b> must be set to specify the <i>wideSeekProc</i>
  member. <b>TCL_CHANNEL_VERSION_4</b> must be set to specify the
  <i>threadActionProc</i> member (includes <i>wideSeekProc</i>).
  <b>TCL_CHANNEL_VERSION_5</b> must be set to specify the <i>truncateProc</i>
  members (includes <i>wideSeekProc</i> and <i>threadActionProc</i>). If it is
  not set to any of these, then this <b>Tcl_ChannelType</b> is assumed to have
  the original structure. See <b>OLD CHANNEL TYPES</b> for more details. While
  Tcl will recognize and function with either structures, stacked channels must
  be of at least <b>TCL_CHANNEL_VERSION_2</b> to function correctly.
<p class="Pp">This value can be retrieved with <b>Tcl_ChannelVersion</b>, which
    returns one of <b>TCL_CHANNEL_VERSION_5</b>, <b>TCL_CHANNEL_VERSION_4</b>,
    <b>TCL_CHANNEL_VERSION_3</b>, <b>TCL_CHANNEL_VERSION_2</b> or
    <b>TCL_CHANNEL_VERSION_1</b>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="BLOCKMODEPROC"><a class="permalink" href="#BLOCKMODEPROC">BLOCKMODEPROC</a></h2>
The <i>blockModeProc</i> field contains the address of a function called by the
  generic layer to set blocking and nonblocking mode on the device.
  <i>BlockModeProc</i> should match the following prototype:
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
typedef int Tcl_DriverBlockModeProc(
        ClientData <i>instanceData</i>,
        int <i>mode</i>);
</pre>
</div>
<p class="Pp">The <i>instanceData</i> is the same as the value passed to
    <b>Tcl_CreateChannel</b> when this channel was created. The <i>mode</i>
    argument is either <b>TCL_MODE_BLOCKING</b> or <b>TCL_MODE_NONBLOCKING</b>
    to set the device into blocking or nonblocking mode. The function should
    return zero if the operation was successful, or a nonzero POSIX error code
    if the operation failed.</p>
<p class="Pp">If the operation is successful, the function can modify the
    supplied <i>instanceData</i> to record that the channel entered blocking or
    nonblocking mode and to implement the blocking or nonblocking behavior. For
    some device types, the blocking and nonblocking behavior can be implemented
    by the underlying operating system; for other device types, the behavior
    must be emulated in the channel driver.</p>
<p class="Pp">This value can be retrieved with <b>Tcl_ChannelBlockModeProc</b>,
    which returns a pointer to the function.</p>
<p class="Pp">A channel driver <b>not</b> supplying a <i>blockModeProc</i> has
    to be very, very careful. It has to tell the generic layer exactly which
    blocking mode is acceptable to it, and should this also document for the
    user so that the blocking mode of the channel is not changed to an
    unacceptable value. Any confusion here may lead the interpreter into a
    (spurious and difficult to find) deadlock.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="CLOSEPROC_AND_CLOSE2PROC"><a class="permalink" href="#CLOSEPROC_AND_CLOSE2PROC">CLOSEPROC
  AND CLOSE2PROC</a></h2>
The <i>closeProc</i> field contains the address of a function called by the
  generic layer to clean up driver-related information when the channel is
  closed. <i>CloseProc</i> must match the following prototype:
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
typedef int Tcl_DriverCloseProc(
        ClientData <i>instanceData</i>,
        Tcl_Interp *<i>interp</i>);
</pre>
</div>
<p class="Pp">The <i>instanceData</i> argument is the same as the value provided
    to <b>Tcl_CreateChannel</b> when the channel was created. The function
    should release any storage maintained by the channel driver for this
    channel, and close the input and output devices encapsulated by this
    channel. All queued output will have been flushed to the device before this
    function is called, and no further driver operations will be invoked on this
    instance after calling the <i>closeProc</i>. If the close operation is
    successful, the procedure should return zero; otherwise it should return a
    nonzero POSIX error code. In addition, if an error occurs and <i>interp</i>
    is not NULL, the procedure should store an error message in the
    interpreter's result.</p>
<p class="Pp">Alternatively, channels that support closing the read and write
    sides independently may set <i>closeProc</i> to <b>TCL_CLOSE2PROC</b> and
    set <i>close2Proc</i> to the address of a function that matches the
    following prototype:</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
typedef int Tcl_DriverClose2Proc(
        ClientData <i>instanceData</i>,
        Tcl_Interp *<i>interp</i>,
        int <i>flags</i>);
</pre>
</div>
<p class="Pp">The <i>close2Proc</i> will be called with <i>flags</i> set to an
    OR'ed combination of <b>TCL_CLOSE_READ</b> or <b>TCL_CLOSE_WRITE</b> to
    indicate that the driver should close the read and/or write side of the
    channel. The channel driver may be invoked to perform additional operations
    on the channel after <i>close2Proc</i> is called to close one or both sides
    of the channel. If <i>flags</i> is <b>0</b> (zero), the driver should close
    the channel in the manner described above for <i>closeProc</i>. No further
    operations will be invoked on this instance after <i>close2Proc</i> is
    called with all flags cleared. In all cases, the <i>close2Proc</i> function
    should return zero if the close operation was successful; otherwise it
    should return a nonzero POSIX error code. In addition, if an error occurs
    and <i>interp</i> is not NULL, the procedure should store an error message
    in the interpreter's result.</p>
<p class="Pp">The <i>closeProc</i> and <i>close2Proc</i> values can be retrieved
    with <b>Tcl_ChannelCloseProc</b> or <b>Tcl_ChannelClose2Proc</b>, which
    return a pointer to the respective function.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="INPUTPROC"><a class="permalink" href="#INPUTPROC">INPUTPROC</a></h2>
The <i>inputProc</i> field contains the address of a function called by the
  generic layer to read data from the file or device and store it in an internal
  buffer. <i>InputProc</i> must match the following prototype:
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
typedef int Tcl_DriverInputProc(
        ClientData <i>instanceData</i>,
        char *<i>buf</i>,
        int <i>bufSize</i>,
        int *<i>errorCodePtr</i>);
</pre>
</div>
<p class="Pp"><i>InstanceData</i> is the same as the value passed to
    <b>Tcl_CreateChannel</b> when the channel was created. The <i>buf</i>
    argument points to an array of bytes in which to store input from the
    device, and the <i>bufSize</i> argument indicates how many bytes are
    available at <i>buf</i>.</p>
<p class="Pp">The <i>errorCodePtr</i> argument points to an integer variable
    provided by the generic layer. If an error occurs, the function should set
    the variable to a POSIX error code that identifies the error that
  occurred.</p>
<p class="Pp">The function should read data from the input device encapsulated
    by the channel and store it at <i>buf</i>. On success, the function should
    return a nonnegative integer indicating how many bytes were read from the
    input device and stored at <i>buf</i>. On error, the function should return
    -1. If an error occurs after some data has been read from the device, that
    data is lost.</p>
<p class="Pp">If <i>inputProc</i> can determine that the input device has some
    data available but less than requested by the <i>bufSize</i> argument, the
    function should only attempt to read as much data as is available and return
    without blocking. If the input device has no data available whatsoever and
    the channel is in nonblocking mode, the function should return an
    <b>EAGAIN</b> error. If the input device has no data available whatsoever
    and the channel is in blocking mode, the function should block for the
    shortest possible time until at least one byte of data can be read from the
    device; then, it should return as much data as it can read without
  blocking.</p>
<p class="Pp">This value can be retrieved with <b>Tcl_ChannelInputProc</b>,
    which returns a pointer to the function.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="OUTPUTPROC"><a class="permalink" href="#OUTPUTPROC">OUTPUTPROC</a></h2>
The <i>outputProc</i> field contains the address of a function called by the
  generic layer to transfer data from an internal buffer to the output device.
  <i>OutputProc</i> must match the following prototype:
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
typedef int Tcl_DriverOutputProc(
        ClientData <i>instanceData</i>,
        const char *<i>buf</i>,
        int <i>toWrite</i>,
        int *<i>errorCodePtr</i>);
</pre>
</div>
<p class="Pp"><i>InstanceData</i> is the same as the value passed to
    <b>Tcl_CreateChannel</b> when the channel was created. The <i>buf</i>
    argument contains an array of bytes to be written to the device, and the
    <i>toWrite</i> argument indicates how many bytes are to be written from the
    <i>buf</i> argument.</p>
<p class="Pp">The <i>errorCodePtr</i> argument points to an integer variable
    provided by the generic layer. If an error occurs, the function should set
    this variable to a POSIX error code that identifies the error.</p>
<p class="Pp">The function should write the data at <i>buf</i> to the output
    device encapsulated by the channel. On success, the function should return a
    nonnegative integer indicating how many bytes were written to the output
    device. The return value is normally the same as <i>toWrite</i>, but may be
    less in some cases such as if the output operation is interrupted by a
    signal. If an error occurs the function should return -1. In case of error,
    some data may have been written to the device.</p>
<p class="Pp">If the channel is nonblocking and the output device is unable to
    absorb any data whatsoever, the function should return -1 with an
    <b>EAGAIN</b> error without writing any data.</p>
<p class="Pp">This value can be retrieved with <b>Tcl_ChannelOutputProc</b>,
    which returns a pointer to the function.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="SEEKPROC_AND_WIDESEEKPROC"><a class="permalink" href="#SEEKPROC_AND_WIDESEEKPROC">SEEKPROC
  AND WIDESEEKPROC</a></h2>
The <i>seekProc</i> field contains the address of a function called by the
  generic layer to move the access point at which subsequent input or output
  operations will be applied. <i>SeekProc</i> must match the following
  prototype:
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
typedef int Tcl_DriverSeekProc(
        ClientData <i>instanceData</i>,
        long <i>offset</i>,
        int <i>seekMode</i>,
        int *<i>errorCodePtr</i>);
</pre>
</div>
<p class="Pp">The <i>instanceData</i> argument is the same as the value given to
    <b>Tcl_CreateChannel</b> when this channel was created. <i>Offset</i> and
    <i>seekMode</i> have the same meaning as for the <b>Tcl_Seek</b> procedure
    (described in the manual entry for <b>Tcl_OpenFileChannel</b>).</p>
<p class="Pp">The <i>errorCodePtr</i> argument points to an integer variable
    provided by the generic layer for returning <b>errno</b> values from the
    function. The function should set this variable to a POSIX error code if an
    error occurs. The function should store an <b>EINVAL</b> error code if the
    channel type does not implement seeking.</p>
<p class="Pp">The return value is the new access point or -1 in case of error.
    If an error occurred, the function should not move the access point.</p>
<p class="Pp">If there is a non-NULL <i>seekProc</i> field, the
    <i>wideSeekProc</i> field may contain the address of an alternative function
    to use which handles wide (i.e. larger than 32-bit) offsets, so allowing
    seeks within files larger than 2GB. The <i>wideSeekProc</i> will be called
    in preference to the <i>seekProc</i>, but both must be defined if the
    <i>wideSeekProc</i> is defined. <i>WideSeekProc</i> must match the following
    prototype:</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
typedef Tcl_WideInt Tcl_DriverWideSeekProc(
        ClientData <i>instanceData</i>,
        Tcl_WideInt <i>offset</i>,
        int <i>seekMode</i>,
        int *<i>errorCodePtr</i>);
</pre>
</div>
<p class="Pp">The arguments and return values mean the same thing as with
    <i>seekProc</i> above, except that the type of offsets and the return type
    are different.</p>
<p class="Pp">The <i>seekProc</i> value can be retrieved with
    <b>Tcl_ChannelSeekProc</b>, which returns a pointer to the function, and
    similarly the <i>wideSeekProc</i> can be retrieved with
    <b>Tcl_ChannelWideSeekProc</b>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="SETOPTIONPROC"><a class="permalink" href="#SETOPTIONPROC">SETOPTIONPROC</a></h2>
The <i>setOptionProc</i> field contains the address of a function called by the
  generic layer to set a channel type specific option on a channel.
  <i>setOptionProc</i> must match the following prototype:
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
typedef int Tcl_DriverSetOptionProc(
        ClientData <i>instanceData</i>,
        Tcl_Interp *<i>interp</i>,
        const char *<i>optionName</i>,
        const char *<i>newValue</i>);
</pre>
</div>
<p class="Pp"><i>optionName</i> is the name of an option to set, and
    <i>newValue</i> is the new value for that option, as a string. The
    <i>instanceData</i> is the same as the value given to
    <b>Tcl_CreateChannel</b> when this channel was created. The function should
    do whatever channel type specific action is required to implement the new
    value of the option.</p>
<p class="Pp">Some options are handled by the generic code and this function is
    never called to set them, e.g. <b>-blockmode</b>. Other options are specific
    to each channel type and the <i>setOptionProc</i> procedure of the channel
    driver will get called to implement them. The <i>setOptionProc</i> field can
    be NULL, which indicates that this channel type supports no type specific
    options.</p>
<p class="Pp">If the option value is successfully modified to the new value, the
    function returns <b>TCL_OK</b>. It should call <b>Tcl_BadChannelOption</b>
    which itself returns <b>TCL_ERROR</b> if the <i>optionName</i> is
    unrecognized. If <i>newValue</i> specifies a value for the option that is
    not supported or if a system call error occurs, the function should leave an
    error message in the <i>result</i> field of <i>interp</i> if <i>interp</i>
    is not NULL. The function should also call <b>Tcl_SetErrno</b> to store an
    appropriate POSIX error code.</p>
<p class="Pp">This value can be retrieved with <b>Tcl_ChannelSetOptionProc</b>,
    which returns a pointer to the function.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="GETOPTIONPROC"><a class="permalink" href="#GETOPTIONPROC">GETOPTIONPROC</a></h2>
The <i>getOptionProc</i> field contains the address of a function called by the
  generic layer to get the value of a channel type specific option on a channel.
  <i>getOptionProc</i> must match the following prototype:
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
typedef int Tcl_DriverGetOptionProc(
        ClientData <i>instanceData</i>,
        Tcl_Interp *<i>interp</i>,
        const char *<i>optionName</i>,
        Tcl_DString *<i>optionValue</i>);
</pre>
</div>
<p class="Pp"><i>OptionName</i> is the name of an option supported by this type
    of channel. If the option name is not NULL, the function stores its current
    value, as a string, in the Tcl dynamic string <i>optionValue</i>. If
    <i>optionName</i> is NULL, the function stores in <i>optionValue</i> an
    alternating list of all supported options and their current values. On
    success, the function returns <b>TCL_OK</b>. It should call
    <b>Tcl_BadChannelOption</b> which itself returns <b>TCL_ERROR</b> if the
    <i>optionName</i> is unrecognized. If a system call error occurs, the
    function should leave an error message in the result of <i>interp</i> if
    <i>interp</i> is not NULL. The function should also call <b>Tcl_SetErrno</b>
    to store an appropriate POSIX error code.</p>
<p class="Pp">Some options are handled by the generic code and this function is
    never called to retrieve their value, e.g. <b>-blockmode</b>. Other options
    are specific to each channel type and the <i>getOptionProc</i> procedure of
    the channel driver will get called to implement them. The
    <i>getOptionProc</i> field can be NULL, which indicates that this channel
    type supports no type specific options.</p>
<p class="Pp">This value can be retrieved with <b>Tcl_ChannelGetOptionProc</b>,
    which returns a pointer to the function.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="WATCHPROC"><a class="permalink" href="#WATCHPROC">WATCHPROC</a></h2>
The <i>watchProc</i> field contains the address of a function called by the
  generic layer to initialize the event notification mechanism to notice events
  of interest on this channel. <i>WatchProc</i> should match the following
  prototype:
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
typedef void Tcl_DriverWatchProc(
        ClientData <i>instanceData</i>,
        int <i>mask</i>);
</pre>
</div>
<p class="Pp">The <i>instanceData</i> is the same as the value passed to
    <b>Tcl_CreateChannel</b> when this channel was created. The <i>mask</i>
    argument is an OR-ed combination of <b>TCL_READABLE</b>, <b>TCL_WRITABLE</b>
    and <b>TCL_EXCEPTION</b>; it indicates events the caller is interested in
    noticing on this channel.</p>
<p class="Pp">The function should initialize device type specific mechanisms to
    notice when an event of interest is present on the channel. When one or more
    of the designated events occurs on the channel, the channel driver is
    responsible for calling <b>Tcl_NotifyChannel</b> to inform the generic
    channel module. The driver should take care not to starve other channel
    drivers or sources of callbacks by invoking Tcl_NotifyChannel too
    frequently. Fairness can be insured by using the Tcl event queue to allow
    the channel event to be scheduled in sequence with other events. See the
    description of <b>Tcl_QueueEvent</b> for details on how to queue an
  event.</p>
<p class="Pp">This value can be retrieved with <b>Tcl_ChannelWatchProc</b>,
    which returns a pointer to the function.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="GETHANDLEPROC"><a class="permalink" href="#GETHANDLEPROC">GETHANDLEPROC</a></h2>
The <i>getHandleProc</i> field contains the address of a function called by the
  generic layer to retrieve a device-specific handle from the channel.
  <i>GetHandleProc</i> should match the following prototype:
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
typedef int Tcl_DriverGetHandleProc(
        ClientData <i>instanceData</i>,
        int <i>direction</i>,
        ClientData *<i>handlePtr</i>);
</pre>
</div>
<p class="Pp"><i>InstanceData</i> is the same as the value passed to
    <b>Tcl_CreateChannel</b> when this channel was created. The <i>direction</i>
    argument is either <b>TCL_READABLE</b> to retrieve the handle used for
    input, or <b>TCL_WRITABLE</b> to retrieve the handle used for output.</p>
<p class="Pp">If the channel implementation has device-specific handles, the
    function should retrieve the appropriate handle associated with the channel,
    according the <i>direction</i> argument. The handle should be stored in the
    location referred to by <i>handlePtr</i>, and <b>TCL_OK</b> should be
    returned. If the channel is not open for the specified direction, or if the
    channel implementation does not use device handles, the function should
    return <b>TCL_ERROR</b>.</p>
<p class="Pp">This value can be retrieved with <b>Tcl_ChannelGetHandleProc</b>,
    which returns a pointer to the function.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="FLUSHPROC"><a class="permalink" href="#FLUSHPROC">FLUSHPROC</a></h2>
The <i>flushProc</i> field is currently reserved for future use. It should be
  set to NULL. <i>FlushProc</i> should match the following prototype:
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
typedef int Tcl_DriverFlushProc(
        ClientData <i>instanceData</i>);
</pre>
</div>
<p class="Pp">This value can be retrieved with <b>Tcl_ChannelFlushProc</b>,
    which returns a pointer to the function.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="HANDLERPROC"><a class="permalink" href="#HANDLERPROC">HANDLERPROC</a></h2>
The <i>handlerProc</i> field contains the address of a function called by the
  generic layer to notify the channel that an event occurred. It should be
  defined for stacked channel drivers that wish to be notified of events that
  occur on the underlying (stacked) channel. <i>HandlerProc</i> should match the
  following prototype:
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
typedef int Tcl_DriverHandlerProc(
        ClientData <i>instanceData</i>,
        int <i>interestMask</i>);
</pre>
</div>
<p class="Pp"><i>InstanceData</i> is the same as the value passed to
    <b>Tcl_CreateChannel</b> when this channel was created. The
    <i>interestMask</i> is an OR-ed combination of <b>TCL_READABLE</b> or
    <b>TCL_WRITABLE</b>; it indicates what type of event occurred on this
    channel.</p>
<p class="Pp">This value can be retrieved with <b>Tcl_ChannelHandlerProc</b>,
    which returns a pointer to the function.</p>
<p class="Pp"></p>
</section>
<section class="Ss">
<h2 class="Ss" id="THREADACTIONPROC"><a class="permalink" href="#THREADACTIONPROC">THREADACTIONPROC</a></h2>
The <i>threadActionProc</i> field contains the address of the function called by
  the generic layer when a channel is created, closed, or going to move to a
  different thread, i.e. whenever thread-specific driver state might have to
  initialized or updated. It can be NULL. The action
  <i>TCL_CHANNEL_THREAD_REMOVE</i> is used to notify the driver that it should
  update or remove any thread-specific data it might be maintaining for the
  channel.
<p class="Pp">The action <i>TCL_CHANNEL_THREAD_INSERT</i> is used to notify the
    driver that it should update or initialize any thread-specific data it might
    be maintaining using the calling thread as the associate. See
    <b>Tcl_CutChannel</b> and <b>Tcl_SpliceChannel</b> for more detail.</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
typedef void Tcl_DriverThreadActionProc(
        ClientData <i>instanceData</i>,
        int        <i>action</i>);
</pre>
</div>
<p class="Pp"><i>InstanceData</i> is the same as the value passed to
    <b>Tcl_CreateChannel</b> when this channel was created.</p>
<p class="Pp">These values can be retrieved with
    <b>Tcl_ChannelThreadActionProc</b>, which returns a pointer to the
  function.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="TRUNCATEPROC"><a class="permalink" href="#TRUNCATEPROC">TRUNCATEPROC</a></h2>
The <i>truncateProc</i> field contains the address of the function called by the
  generic layer when a channel is truncated to some length. It can be NULL.
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
typedef int Tcl_DriverTruncateProc(
        ClientData <i>instanceData</i>,
        Tcl_WideInt <i>length</i>);
</pre>
</div>
<p class="Pp"><i>InstanceData</i> is the same as the value passed to
    <b>Tcl_CreateChannel</b> when this channel was created, and <i>length</i> is
    the new length of the underlying file, which should not be negative. The
    result should be 0 on success or an errno code (suitable for use with
    <b>Tcl_SetErrno</b>) on failure.</p>
<p class="Pp">These values can be retrieved with <b>Tcl_ChannelTruncateProc</b>,
    which returns a pointer to the function.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="TCL_BADCHANNELOPTION"><a class="permalink" href="#TCL_BADCHANNELOPTION">TCL_BADCHANNELOPTION</a></h1>
This procedure generates a &#x201C;bad option&#x201D; error message in an
  (optional) interpreter. It is used by channel drivers when an invalid Set/Get
  option is requested. Its purpose is to concatenate the generic options list to
  the specific ones and factorize the generic options error message string.
<p class="Pp">It always returns <b>TCL_ERROR</b></p>
<p class="Pp">An error message is generated in <i>interp</i>'s result object to
    indicate that a command was invoked with a bad option. The message has the
    form</p>
<div class="Bd-indent">
<pre>
    bad option &quot;blah&quot;: should be one of 
    &lt;...generic options...&gt;+&lt;...specific options...&gt;
</pre>
</div>
so you get for instance:
<div class="Bd-indent">
<pre>
    bad option &quot;-blah&quot;: should be one of -blocking,
    -buffering, -buffersize, -eofchar, -translation,
    -peername, or -sockname
</pre>
</div>
when called with <i>optionList</i> equal to &#x201C;peername sockname&#x201D;
<p class="Pp">&#x201C;blah&#x201D; is the <i>optionName</i> argument and
    &#x201C;&lt;specific options&gt;&#x201D; is a space separated list of
    specific option words. The function takes good care of inserting minus signs
    before each option, commas after, and an &#x201C;or&#x201D; before the last
    option.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="OLD_CHANNEL_TYPES"><a class="permalink" href="#OLD_CHANNEL_TYPES">OLD
  CHANNEL TYPES</a></h1>
The original (8.3.1 and below) <b>Tcl_ChannelType</b> structure contains the
  following fields:
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
typedef struct Tcl_ChannelType {
        char *<i>typeName</i>;
        Tcl_DriverBlockModeProc *<i>blockModeProc</i>;
        Tcl_DriverCloseProc *<i>closeProc</i>;
        Tcl_DriverInputProc *<i>inputProc</i>;
        Tcl_DriverOutputProc *<i>outputProc</i>;
        Tcl_DriverSeekProc *<i>seekProc</i>;
        Tcl_DriverSetOptionProc *<i>setOptionProc</i>;
        Tcl_DriverGetOptionProc *<i>getOptionProc</i>;
        Tcl_DriverWatchProc *<i>watchProc</i>;
        Tcl_DriverGetHandleProc *<i>getHandleProc</i>;
        Tcl_DriverClose2Proc *<i>close2Proc</i>;
} Tcl_ChannelType;
</pre>
</div>
<p class="Pp">It is still possible to create channel with the above structure.
    The internal channel code will determine the version. It is imperative to
    use the new <b>Tcl_ChannelType</b> structure if you are creating a stacked
    channel driver, due to problems with the earlier stacked channel
    implementation (in 8.2.0 to 8.3.1).</p>
<p class="Pp">Prior to 8.4.0 (i.e. during the later releases of 8.3 and early
    part of the 8.4 development cycle) the <b>Tcl_ChannelType</b> structure
    contained the following fields:</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
typedef struct Tcl_ChannelType {
        char *<i>typeName</i>;
        Tcl_ChannelTypeVersion <i>version</i>;
        Tcl_DriverCloseProc *<i>closeProc</i>;
        Tcl_DriverInputProc *<i>inputProc</i>;
        Tcl_DriverOutputProc *<i>outputProc</i>;
        Tcl_DriverSeekProc *<i>seekProc</i>;
        Tcl_DriverSetOptionProc *<i>setOptionProc</i>;
        Tcl_DriverGetOptionProc *<i>getOptionProc</i>;
        Tcl_DriverWatchProc *<i>watchProc</i>;
        Tcl_DriverGetHandleProc *<i>getHandleProc</i>;
        Tcl_DriverClose2Proc *<i>close2Proc</i>;
        Tcl_DriverBlockModeProc *<i>blockModeProc</i>;
        Tcl_DriverFlushProc *<i>flushProc</i>;
        Tcl_DriverHandlerProc *<i>handlerProc</i>;
        Tcl_DriverTruncateProc *<i>truncateProc</i>;
} Tcl_ChannelType;
</pre>
</div>
<p class="Pp">When the above structure is registered as a channel type, the
    <i>version</i> field should always be <b>TCL_CHANNEL_VERSION_2</b>.</p>
<p class="Pp"></p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
Tcl_Close(3), Tcl_OpenFileChannel(3), Tcl_SetErrno(3), Tcl_QueueEvent(3),
  Tcl_StackChannel(3), Tcl_GetStdChannel(3)
<p class="Pp"></p>
</section>
<section class="Sh">
<h1 class="Sh" id="KEYWORDS"><a class="permalink" href="#KEYWORDS">KEYWORDS</a></h1>
blocking, channel driver, channel registration, channel type, nonblocking
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">8.4</td>
    <td class="foot-os">Tcl</td>
  </tr>
</table>
</body>
</html>
