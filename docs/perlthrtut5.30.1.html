<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>PERLTHRTUT(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">PERLTHRTUT(1)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">PERLTHRTUT(1)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
perlthrtut - Tutorial on threads in Perl
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
This tutorial describes the use of Perl interpreter threads (sometimes referred
  to as <i>ithreads</i>). In this model, each thread runs in its own Perl
  interpreter, and any data sharing between threads must be explicit. The
  user-level interface for <i>ithreads</i> uses the threads class.
<p class="Pp"><b>NOTE</b>: There was another older Perl threading flavor called
    the 5.005 model that used the threads class. This old model was known to
    have problems, is deprecated, and was removed for release 5.10. You are
    strongly encouraged to migrate any existing 5.005 threads code to the new
    model as soon as possible.</p>
<p class="Pp">You can see which (or neither) threading flavour you have by
    running <span class="Li">&quot;perl -V&quot;</span> and looking at the
    <span class="Li">&quot;Platform&quot;</span> section. If you have
    <span class="Li">&quot;useithreads=define&quot;</span> you have ithreads, if
    you have <span class="Li">&quot;use5005threads=define&quot;</span> you have
    5.005 threads. If you have neither, you don't have any thread support built
    in. If you have both, you are in trouble.</p>
<p class="Pp">The threads and threads::shared modules are included in the core
    Perl distribution. Additionally, they are maintained as a separate modules
    on CPAN, so you can check there for any updates.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="What_Is_A_Thread_Anyway?"><a class="permalink" href="#What_Is_A_Thread_Anyway?">What
  Is A Thread Anyway?</a></h1>
A thread is a flow of control through a program with a single execution point.
<p class="Pp">Sounds an awful lot like a process, doesn't it? Well, it should.
    Threads are one of the pieces of a process. Every process has at least one
    thread and, up until now, every process running Perl had only one thread.
    With 5.8, though, you can create extra threads. We're going to show you how,
    when, and why.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="Threaded_Program_Models"><a class="permalink" href="#Threaded_Program_Models">Threaded
  Program Models</a></h1>
There are three basic ways that you can structure a threaded program. Which
  model you choose depends on what you need your program to do. For many
  non-trivial threaded programs, you'll need to choose different models for
  different pieces of your program.
<section class="Ss">
<h2 class="Ss" id="Boss/Worker"><a class="permalink" href="#Boss/Worker">Boss/Worker</a></h2>
The boss/worker model usually has one <i>boss</i> thread and one or more
  <i>worker</i> threads. The boss thread gathers or generates tasks that need to
  be done, then parcels those tasks out to the appropriate worker thread.
<p class="Pp">This model is common in GUI and server programs, where a main
    thread waits for some event and then passes that event to the appropriate
    worker threads for processing. Once the event has been passed on, the boss
    thread goes back to waiting for another event.</p>
<p class="Pp">The boss thread does relatively little work. While tasks aren't
    necessarily performed faster than with any other method, it tends to have
    the best user-response times.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Work_Crew"><a class="permalink" href="#Work_Crew">Work
  Crew</a></h2>
In the work crew model, several threads are created that do essentially the same
  thing to different pieces of data. It closely mirrors classical parallel
  processing and vector processors, where a large array of processors do the
  exact same thing to many pieces of data.
<p class="Pp">This model is particularly useful if the system running the
    program will distribute multiple threads across different processors. It can
    also be useful in ray tracing or rendering engines, where the individual
    threads can pass on interim results to give the user visual feedback.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Pipeline"><a class="permalink" href="#Pipeline">Pipeline</a></h2>
The pipeline model divides up a task into a series of steps, and passes the
  results of one step on to the thread processing the next. Each thread does one
  thing to each piece of data and passes the results to the next thread in line.
<p class="Pp">This model makes the most sense if you have multiple processors so
    two or more threads will be executing in parallel, though it can often make
    sense in other contexts as well. It tends to keep the individual tasks small
    and simple, as well as allowing some parts of the pipeline to block (on I/O
    or system calls, for example) while other parts keep going. If you're
    running different parts of the pipeline on different processors you may also
    take advantage of the caches on each processor.</p>
<p class="Pp">This model is also handy for a form of recursive programming
    where, rather than having a subroutine call itself, it instead creates
    another thread. Prime and Fibonacci generators both map well to this form of
    the pipeline model. (A version of a prime number generator is presented
    later on.)</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="What_kind_of_threads_are_Perl_threads?"><a class="permalink" href="#What_kind_of_threads_are_Perl_threads?">What
  kind of threads are Perl threads?</a></h1>
If you have experience with other thread implementations, you might find that
  things aren't quite what you expect. It's very important to remember when
  dealing with Perl threads that <i>Perl Threads Are Not X</i> <i>Threads</i>
  for all values of X. They aren't POSIX threads, or DecThreads, or Java's Green
  threads, or Win32 threads. There are similarities, and the broad concepts are
  the same, but if you start looking for implementation details you're going to
  be either disappointed or confused. Possibly both.
<p class="Pp">This is not to say that Perl threads are completely different from
    everything that's ever come before. They're not. Perl's threading model owes
    a lot to other thread models, especially POSIX. Just as Perl is not C,
    though, Perl threads are not POSIX threads. So if you find yourself looking
    for mutexes, or thread priorities, it's time to step back a bit and think
    about what you want to do and how Perl can do it.</p>
<p class="Pp">However, it is important to remember that Perl threads cannot
    magically do things unless your operating system's threads allow it. So if
    your system blocks the entire process on
    <span class="Li">&quot;sleep()&quot;</span>, Perl usually will, as well.</p>
<p class="Pp"><b>Perl Threads Are Different.</b></p>
</section>
<section class="Sh">
<h1 class="Sh" id="Thread-Safe_Modules"><a class="permalink" href="#Thread-Safe_Modules">Thread-Safe
  Modules</a></h1>
The addition of threads has changed Perl's internals substantially. There are
  implications for people who write modules with XS code or external libraries.
  However, since Perl data is not shared among threads by default, Perl modules
  stand a high chance of being thread-safe or can be made thread-safe easily.
  Modules that are not tagged as thread-safe should be tested or code reviewed
  before being used in production code.
<p class="Pp">Not all modules that you might use are thread-safe, and you should
    always assume a module is unsafe unless the documentation says otherwise.
    This includes modules that are distributed as part of the core. Threads are
    a relatively new feature, and even some of the standard modules aren't
    thread-safe.</p>
<p class="Pp">Even if a module is thread-safe, it doesn't mean that the module
    is optimized to work well with threads. A module could possibly be rewritten
    to utilize the new features in threaded Perl to increase performance in a
    threaded environment.</p>
<p class="Pp">If you're using a module that's not thread-safe for some reason,
    you can protect yourself by using it from one, and only one thread at all.
    If you need multiple threads to access such a module, you can use semaphores
    and lots of programming discipline to control access to it. Semaphores are
    covered in &quot;Basic semaphores&quot;.</p>
<p class="Pp">See also &quot;Thread-Safety of System Libraries&quot;.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="Thread_Basics"><a class="permalink" href="#Thread_Basics">Thread
  Basics</a></h1>
The threads module provides the basic functions you need to write threaded
  programs. In the following sections, we'll cover the basics, showing you what
  you need to do to create a threaded program. After that, we'll go over some of
  the features of the threads module that make threaded programming easier.
<section class="Ss">
<h2 class="Ss" id="Basic_Thread_Support"><a class="permalink" href="#Basic_Thread_Support">Basic
  Thread Support</a></h2>
Thread support is a Perl compile-time option. It's something that's turned on or
  off when Perl is built at your site, rather than when your programs are
  compiled. If your Perl wasn't compiled with thread support enabled, then any
  attempt to use threads will fail.
<p class="Pp">Your programs can use the Config module to check whether threads
    are enabled. If your program can't run without them, you can say something
    like:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    use Config;
    $Config{useithreads} or
        die('Recompile Perl with threads to run this program.');
</pre>
<p class="Pp">A possibly-threaded program using a possibly-threaded module might
    have code like this:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    use Config;
    use MyMod;

    BEGIN {
        if ($Config{useithreads}) {
            # We have threads
            require MyMod_threaded;
            import MyMod_threaded;
        } else {
            require MyMod_unthreaded;
            import MyMod_unthreaded;
        }
    }
</pre>
<p class="Pp">Since code that runs both with and without threads is usually
    pretty messy, it's best to isolate the thread-specific code in its own
    module. In our example above, that's what
    <span class="Li">&quot;MyMod_threaded&quot;</span> is, and it's only
    imported if we're running on a threaded Perl.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="A_Note_about_the_Examples"><a class="permalink" href="#A_Note_about_the_Examples">A
  Note about the Examples</a></h2>
In a real situation, care should be taken that all threads are finished
  executing before the program exits. That care has <b>not</b> been taken in
  these examples in the interest of simplicity. Running these examples <i>as
  is</i> will produce error messages, usually caused by the fact that there are
  still threads running when the program exits. You should not be alarmed by
  this.
</section>
<section class="Ss">
<h2 class="Ss" id="Creating_Threads"><a class="permalink" href="#Creating_Threads">Creating
  Threads</a></h2>
The threads module provides the tools you need to create new threads. Like any
  other module, you need to tell Perl that you want to use it;
  <span class="Li">&quot;use threads;&quot;</span> imports all the pieces you
  need to create basic threads.
<p class="Pp">The simplest, most straightforward way to create a thread is with
    <span class="Li">&quot;create()&quot;</span>:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    use threads;

    my $thr = threads-&gt;create(\&amp;sub1);

    sub sub1 {
        print(&quot;In the thread\n&quot;);
    }
</pre>
<p class="Pp">The <span class="Li">&quot;create()&quot;</span> method takes a
    reference to a subroutine and creates a new thread that starts executing in
    the referenced subroutine. Control then passes both to the subroutine and
    the caller.</p>
<p class="Pp">If you need to, your program can pass parameters to the subroutine
    as part of the thread startup. Just include the list of parameters as part
    of the <span class="Li">&quot;threads-&gt;create()&quot;</span> call, like
    this:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    use threads;

    my $Param3 = 'foo';
    my $thr1 = threads-&gt;create(\&amp;sub1, 'Param 1', 'Param 2', $Param3);
    my @ParamList = (42, 'Hello', 3.14);
    my $thr2 = threads-&gt;create(\&amp;sub1, @ParamList);
    my $thr3 = threads-&gt;create(\&amp;sub1, qw(Param1 Param2 Param3));

    sub sub1 {
        my @InboundParameters = @_;
        print(&quot;In the thread\n&quot;);
        print('Got parameters &gt;', join('&lt;&gt;',@InboundParameters), &quot;&lt;\n&quot;);
    }
</pre>
<p class="Pp">The last example illustrates another feature of threads. You can
    spawn off several threads using the same subroutine. Each thread executes
    the same subroutine, but in a separate thread with a separate environment
    and potentially separate arguments.</p>
<p class="Pp"><span class="Li">&quot;new()&quot;</span> is a synonym for
    <span class="Li">&quot;create()&quot;</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Waiting_For_A_Thread_To_Exit"><a class="permalink" href="#Waiting_For_A_Thread_To_Exit">Waiting
  For A Thread To Exit</a></h2>
Since threads are also subroutines, they can return values. To wait for a thread
  to exit and extract any values it might return, you can use the
  <span class="Li">&quot;join()&quot;</span> method:
<p class="Pp"><span class="Li"></span></p>
<pre>
    use threads;

    my ($thr) = threads-&gt;create(\&amp;sub1);

    my @ReturnData = $thr-&gt;join();
    print('Thread returned ', join(', ', @ReturnData), &quot;\n&quot;);

    sub sub1 { return ('Fifty-six', 'foo', 2); }
</pre>
<p class="Pp">In the example above, the
    <span class="Li">&quot;join()&quot;</span> method returns as soon as the
    thread ends. In addition to waiting for a thread to finish and gathering up
    any values that the thread might have returned,
    <span class="Li">&quot;join()&quot;</span> also performs any OS cleanup
    necessary for the thread. That cleanup might be important, especially for
    long-running programs that spawn lots of threads. If you don't want the
    return values and don't want to wait for the thread to finish, you should
    call the <span class="Li">&quot;detach()&quot;</span> method instead, as
    described next.</p>
<p class="Pp">NOTE: In the example above, the thread returns a list, thus
    necessitating that the thread creation call be made in list context (i.e.,
    <span class="Li">&quot;my ($thr)&quot;</span>). See
    &quot;$thr-&gt;<b>join()</b>&quot; in threads and &quot;THREAD CONTEXT&quot;
    in threads for more details on thread context and return values.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Ignoring_A_Thread"><a class="permalink" href="#Ignoring_A_Thread">Ignoring
  A Thread</a></h2>
<span class="Li">&quot;join()&quot;</span> does three things: it waits for a
  thread to exit, cleans up after it, and returns any data the thread may have
  produced. But what if you're not interested in the thread's return values, and
  you don't really care when the thread finishes? All you want is for the thread
  to get cleaned up after when it's done.
<p class="Pp">In this case, you use the
    <span class="Li">&quot;detach()&quot;</span> method. Once a thread is
    detached, it'll run until it's finished; then Perl will clean up after it
    automatically.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    use threads;

    my $thr = threads-&gt;create(\&amp;sub1);   # Spawn the thread

    $thr-&gt;detach();   # Now we officially don't care any more

    sleep(15);        # Let thread run for awhile

    sub sub1 {
        my $count = 0;
        while (1) {
            $count++;
            print(&quot;\$count is $count\n&quot;);
            sleep(1);
        }
    }
</pre>
<p class="Pp">Once a thread is detached, it may not be joined, and any return
    data that it might have produced (if it was done and waiting for a join) is
    lost.</p>
<p class="Pp"><span class="Li">&quot;detach()&quot;</span> can also be called as
    a class method to allow a thread to detach itself:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    use threads;

    my $thr = threads-&gt;create(\&amp;sub1);

    sub sub1 {
        threads-&gt;detach();
        # Do more work
    }
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Process_and_Thread_Termination"><a class="permalink" href="#Process_and_Thread_Termination">Process
  and Thread Termination</a></h2>
With threads one must be careful to make sure they all have a chance to run to
  completion, assuming that is what you want.
<p class="Pp">An action that terminates a process will terminate <i>all</i>
    running threads. <b>die()</b> and <b>exit()</b> have this property, and perl
    does an exit when the main thread exits, perhaps implicitly by falling off
    the end of your code, even if that's not what you want.</p>
<p class="Pp">As an example of this case, this code prints the message
    &quot;Perl exited with active threads: 2 running and unjoined&quot;:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    use threads;
    my $thr1 = threads-&gt;new(\&amp;thrsub, &quot;test1&quot;);
    my $thr2 = threads-&gt;new(\&amp;thrsub, &quot;test2&quot;);
    sub thrsub {
       my ($message) = @_;
       sleep 1;
       print &quot;thread $message\n&quot;;
    }
</pre>
<p class="Pp">But when the following lines are added at the end:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    $thr1-&gt;join();
    $thr2-&gt;join();
</pre>
<p class="Pp">it prints two lines of output, a perhaps more useful outcome.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="Threads_And_Data"><a class="permalink" href="#Threads_And_Data">Threads
  And Data</a></h1>
Now that we've covered the basics of threads, it's time for our next topic:
  Data. Threading introduces a couple of complications to data access that
  non-threaded programs never need to worry about.
<section class="Ss">
<h2 class="Ss" id="Shared_And_Unshared_Data"><a class="permalink" href="#Shared_And_Unshared_Data">Shared
  And Unshared Data</a></h2>
The biggest difference between Perl <i>ithreads</i> and the old 5.005 style
  threading, or for that matter, to most other threading systems out there, is
  that by default, no data is shared. When a new Perl thread is created, all the
  data associated with the current thread is copied to the new thread, and is
  subsequently private to that new thread! This is similar in feel to what
  happens when a Unix process forks, except that in this case, the data is just
  copied to a different part of memory within the same process rather than a
  real fork taking place.
<p class="Pp">To make use of threading, however, one usually wants the threads
    to share at least some data between themselves. This is done with the
    threads::shared module and the <span class="Li">&quot;:shared&quot;</span>
    attribute:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    use threads;
    use threads::shared;

    my $foo :shared = 1;
    my $bar = 1;
    threads-&gt;create(sub { $foo++; $bar++; })-&gt;join();

    print(&quot;$foo\n&quot;);  # Prints 2 since $foo is shared
    print(&quot;$bar\n&quot;);  # Prints 1 since $bar is not shared
</pre>
<p class="Pp">In the case of a shared array, all the array's elements are
    shared, and for a shared hash, all the keys and values are shared. This
    places restrictions on what may be assigned to shared array and hash
    elements: only simple values or references to shared variables are allowed -
    this is so that a private variable can't accidentally become shared. A bad
    assignment will cause the thread to die. For example:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    use threads;
    use threads::shared;

    my $var          = 1;
    my $svar :shared = 2;
    my %hash :shared;

    ... create some threads ...

    $hash{a} = 1;       # All threads see exists($hash{a})
                        # and $hash{a} == 1
    $hash{a} = $var;    # okay - copy-by-value: same effect as previous
    $hash{a} = $svar;   # okay - copy-by-value: same effect as previous
    $hash{a} = \$svar;  # okay - a reference to a shared variable
    $hash{a} = \$var;   # This will die
    delete($hash{a});   # okay - all threads will see !exists($hash{a})
</pre>
<p class="Pp">Note that a shared variable guarantees that if two or more threads
    try to modify it at the same time, the internal state of the variable will
    not become corrupted. However, there are no guarantees beyond this, as
    explained in the next section.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Thread_Pitfalls:_Races"><a class="permalink" href="#Thread_Pitfalls:_Races">Thread
  Pitfalls: Races</a></h2>
While threads bring a new set of useful tools, they also bring a number of
  pitfalls. One pitfall is the race condition:
<p class="Pp"><span class="Li"></span></p>
<pre>
    use threads;
    use threads::shared;

    my $x :shared = 1;
    my $thr1 = threads-&gt;create(\&amp;sub1);
    my $thr2 = threads-&gt;create(\&amp;sub2);

    $thr1-&gt;join();
    $thr2-&gt;join();
    print(&quot;$x\n&quot;);

    sub sub1 { my $foo = $x; $x = $foo + 1; }
    sub sub2 { my $bar = $x; $x = $bar + 1; }
</pre>
<p class="Pp">What do you think <span class="Li">$x</span> will be? The answer,
    unfortunately, is <i>it</i> <i>depends</i>. Both
    <span class="Li">&quot;sub1()&quot;</span> and
    <span class="Li">&quot;sub2()&quot;</span> access the global variable
    <span class="Li">$x</span>, once to read and once to write. Depending on
    factors ranging from your thread implementation's scheduling algorithm to
    the phase of the moon, <span class="Li">$x</span> can be 2 or 3.</p>
<p class="Pp">Race conditions are caused by unsynchronized access to shared
    data. Without explicit synchronization, there's no way to be sure that
    nothing has happened to the shared data between the time you access it and
    the time you update it. Even this simple code fragment has the possibility
    of error:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    use threads;
    my $x :shared = 2;
    my $y :shared;
    my $z :shared;
    my $thr1 = threads-&gt;create(sub { $y = $x; $x = $y + 1; });
    my $thr2 = threads-&gt;create(sub { $z = $x; $x = $z + 1; });
    $thr1-&gt;join();
    $thr2-&gt;join();
</pre>
<p class="Pp">Two threads both access <span class="Li">$x</span>. Each thread
    can potentially be interrupted at any point, or be executed in any order. At
    the end, <span class="Li">$x</span> could be 3 or 4, and both
    <span class="Li">$y</span> and <span class="Li">$z</span> could be 2 or
  3.</p>
<p class="Pp">Even <span class="Li">&quot;$x += 5&quot;</span> or
    <span class="Li">&quot;$x++&quot;</span> are not guaranteed to be
  atomic.</p>
<p class="Pp">Whenever your program accesses data or resources that can be
    accessed by other threads, you must take steps to coordinate access or risk
    data inconsistency and race conditions. Note that Perl will protect its
    internals from your race conditions, but it won't protect you from you.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="Synchronization_and_control"><a class="permalink" href="#Synchronization_and_control">Synchronization
  and control</a></h1>
Perl provides a number of mechanisms to coordinate the interactions between
  themselves and their data, to avoid race conditions and the like. Some of
  these are designed to resemble the common techniques used in thread libraries
  such as <span class="Li">&quot;pthreads&quot;</span>; others are
  Perl-specific. Often, the standard techniques are clumsy and difficult to get
  right (such as condition waits). Where possible, it is usually easier to use
  Perlish techniques such as queues, which remove some of the hard work
  involved.
<section class="Ss">
<h2 class="Ss" id="Controlling_access:__fBlock()_fP"><a class="permalink" href="#Controlling_access:__fBlock()_fP">Controlling
  access: <b>lock()</b></a></h2>
The <span class="Li">&quot;lock()&quot;</span> function takes a shared variable
  and puts a lock on it. No other thread may lock the variable until the
  variable is unlocked by the thread holding the lock. Unlocking happens
  automatically when the locking thread exits the block that contains the call
  to the <span class="Li">&quot;lock()&quot;</span> function. Using
  <span class="Li">&quot;lock()&quot;</span> is straightforward: This example
  has several threads doing some calculations in parallel, and occasionally
  updating a running total:
<p class="Pp"><span class="Li"></span></p>
<pre>
    use threads;
    use threads::shared;

    my $total :shared = 0;

    sub calc {
        while (1) {
            my $result;
            # (... do some calculations and set $result ...)
            {
                lock($total);  # Block until we obtain the lock
                $total += $result;
            } # Lock implicitly released at end of scope
            last if $result == 0;
        }
    }

    my $thr1 = threads-&gt;create(\&amp;calc);
    my $thr2 = threads-&gt;create(\&amp;calc);
    my $thr3 = threads-&gt;create(\&amp;calc);
    $thr1-&gt;join();
    $thr2-&gt;join();
    $thr3-&gt;join();
    print(&quot;total=$total\n&quot;);
</pre>
<p class="Pp"><span class="Li">&quot;lock()&quot;</span> blocks the thread until
    the variable being locked is available. When
    <span class="Li">&quot;lock()&quot;</span> returns, your thread can be sure
    that no other thread can lock that variable until the block containing the
    lock exits.</p>
<p class="Pp">It's important to note that locks don't prevent access to the
    variable in question, only lock attempts. This is in keeping with Perl's
    longstanding tradition of courteous programming, and the advisory file
    locking that <span class="Li">&quot;flock()&quot;</span> gives you.</p>
<p class="Pp">You may lock arrays and hashes as well as scalars. Locking an
    array, though, will not block subsequent locks on array elements, just lock
    attempts on the array itself.</p>
<p class="Pp">Locks are recursive, which means it's okay for a thread to lock a
    variable more than once. The lock will last until the outermost
    <span class="Li">&quot;lock()&quot;</span> on the variable goes out of
    scope. For example:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    my $x :shared;
    doit();

    sub doit {
        {
            {
                lock($x); # Wait for lock
                lock($x); # NOOP - we already have the lock
                {
                    lock($x); # NOOP
                    {
                        lock($x); # NOOP
                        lockit_some_more();
                    }
                }
            } # *** Implicit unlock here ***
        }
    }

    sub lockit_some_more {
        lock($x); # NOOP
    } # Nothing happens here
</pre>
<p class="Pp">Note that there is no <span class="Li">&quot;unlock()&quot;</span>
    function - the only way to unlock a variable is to allow it to go out of
    scope.</p>
<p class="Pp">A lock can either be used to guard the data contained within the
    variable being locked, or it can be used to guard something else, like a
    section of code. In this latter case, the variable in question does not hold
    any useful data, and exists only for the purpose of being locked. In this
    respect, the variable behaves like the mutexes and basic semaphores of
    traditional thread libraries.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="A_Thread_Pitfall:_Deadlocks"><a class="permalink" href="#A_Thread_Pitfall:_Deadlocks">A
  Thread Pitfall: Deadlocks</a></h2>
Locks are a handy tool to synchronize access to data, and using them properly is
  the key to safe shared data. Unfortunately, locks aren't without their
  dangers, especially when multiple locks are involved. Consider the following
  code:
<p class="Pp"><span class="Li"></span></p>
<pre>
    use threads;

    my $x :shared = 4;
    my $y :shared = 'foo';
    my $thr1 = threads-&gt;create(sub {
        lock($x);
        sleep(20);
        lock($y);
    });
    my $thr2 = threads-&gt;create(sub {
        lock($y);
        sleep(20);
        lock($x);
    });
</pre>
<p class="Pp">This program will probably hang until you kill it. The only way it
    won't hang is if one of the two threads acquires both locks first. A
    guaranteed-to-hang version is more complicated, but the principle is the
    same.</p>
<p class="Pp">The first thread will grab a lock on <span class="Li">$x</span>,
    then, after a pause during which the second thread has probably had time to
    do some work, try to grab a lock on <span class="Li">$y</span>. Meanwhile,
    the second thread grabs a lock on <span class="Li">$y</span>, then later
    tries to grab a lock on <span class="Li">$x</span>. The second lock attempt
    for both threads will block, each waiting for the other to release its
  lock.</p>
<p class="Pp">This condition is called a deadlock, and it occurs whenever two or
    more threads are trying to get locks on resources that the others own. Each
    thread will block, waiting for the other to release a lock on a resource.
    That never happens, though, since the thread with the resource is itself
    waiting for a lock to be released.</p>
<p class="Pp">There are a number of ways to handle this sort of problem. The
    best way is to always have all threads acquire locks in the exact same
    order. If, for example, you lock variables <span class="Li">$x</span>,
    <span class="Li">$y</span>, and <span class="Li">$z</span>, always lock
    <span class="Li">$x</span> before <span class="Li">$y</span>, and
    <span class="Li">$y</span> before <span class="Li">$z</span>. It's also best
    to hold on to locks for as short a period of time to minimize the risks of
    deadlock.</p>
<p class="Pp">The other synchronization primitives described below can suffer
    from similar problems.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Queues:_Passing_Data_Around"><a class="permalink" href="#Queues:_Passing_Data_Around">Queues:
  Passing Data Around</a></h2>
A queue is a special thread-safe object that lets you put data in one end and
  take it out the other without having to worry about synchronization issues.
  They're pretty straightforward, and look like this:
<p class="Pp"><span class="Li"></span></p>
<pre>
    use threads;
    use Thread::Queue;

    my $DataQueue = Thread::Queue-&gt;new();
    my $thr = threads-&gt;create(sub {
        while (my $DataElement = $DataQueue-&gt;dequeue()) {
            print(&quot;Popped $DataElement off the queue\n&quot;);
        }
    });

    $DataQueue-&gt;enqueue(12);
    $DataQueue-&gt;enqueue(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;);
    sleep(10);
    $DataQueue-&gt;enqueue(undef);
    $thr-&gt;join();
</pre>
<p class="Pp">You create the queue with
    <span class="Li">&quot;Thread::Queue-&gt;new()&quot;</span>. Then you can
    add lists of scalars onto the end with
    <span class="Li">&quot;enqueue()&quot;</span>, and pop scalars off the front
    of it with <span class="Li">&quot;dequeue()&quot;</span>. A queue has no
    fixed size, and can grow as needed to hold everything pushed on to it.</p>
<p class="Pp">If a queue is empty, <span class="Li">&quot;dequeue()&quot;</span>
    blocks until another thread enqueues something. This makes queues ideal for
    event loops and other communications between threads.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Semaphores:_Synchronizing_Data_Access"><a class="permalink" href="#Semaphores:_Synchronizing_Data_Access">Semaphores:
  Synchronizing Data Access</a></h2>
Semaphores are a kind of generic locking mechanism. In their most basic form,
  they behave very much like lockable scalars, except that they can't hold data,
  and that they must be explicitly unlocked. In their advanced form, they act
  like a kind of counter, and can allow multiple threads to have the <i>lock</i>
  at any one time.
</section>
<section class="Ss">
<h2 class="Ss" id="Basic_semaphores"><a class="permalink" href="#Basic_semaphores">Basic
  semaphores</a></h2>
Semaphores have two methods, <span class="Li">&quot;down()&quot;</span> and
  <span class="Li">&quot;up()&quot;</span>:
  <span class="Li">&quot;down()&quot;</span> decrements the resource count,
  while <span class="Li">&quot;up()&quot;</span> increments it. Calls to
  <span class="Li">&quot;down()&quot;</span> will block if the semaphore's
  current count would decrement below zero. This program gives a quick
  demonstration:
<p class="Pp"><span class="Li"></span></p>
<pre>
    use threads;
    use Thread::Semaphore;

    my $semaphore = Thread::Semaphore-&gt;new();
    my $GlobalVariable :shared = 0;

    $thr1 = threads-&gt;create(\&amp;sample_sub, 1);
    $thr2 = threads-&gt;create(\&amp;sample_sub, 2);
    $thr3 = threads-&gt;create(\&amp;sample_sub, 3);

    sub sample_sub {
        my $SubNumber = shift(@_);
        my $TryCount = 10;
        my $LocalCopy;
        sleep(1);
        while ($TryCount--) {
            $semaphore-&gt;down();
            $LocalCopy = $GlobalVariable;
            print(&quot;$TryCount tries left for sub $SubNumber &quot;
                 .&quot;(\$GlobalVariable is $GlobalVariable)\n&quot;);
            sleep(2);
            $LocalCopy++;
            $GlobalVariable = $LocalCopy;
            $semaphore-&gt;up();
        }
    }

    $thr1-&gt;join();
    $thr2-&gt;join();
    $thr3-&gt;join();
</pre>
<p class="Pp">The three invocations of the subroutine all operate in sync. The
    semaphore, though, makes sure that only one thread is accessing the global
    variable at once.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Advanced_Semaphores"><a class="permalink" href="#Advanced_Semaphores">Advanced
  Semaphores</a></h2>
By default, semaphores behave like locks, letting only one thread
  <span class="Li">&quot;down()&quot;</span> them at a time. However, there are
  other uses for semaphores.
<p class="Pp">Each semaphore has a counter attached to it. By default,
    semaphores are created with the counter set to one,
    <span class="Li">&quot;down()&quot;</span> decrements the counter by one,
    and <span class="Li">&quot;up()&quot;</span> increments by one. However, we
    can override any or all of these defaults simply by passing in different
    values:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    use threads;
    use Thread::Semaphore;

    my $semaphore = Thread::Semaphore-&gt;new(5);
                    # Creates a semaphore with the counter set to five

    my $thr1 = threads-&gt;create(\&amp;sub1);
    my $thr2 = threads-&gt;create(\&amp;sub1);

    sub sub1 {
        $semaphore-&gt;down(5); # Decrements the counter by five
        # Do stuff here
        $semaphore-&gt;up(5); # Increment the counter by five
    }

    $thr1-&gt;detach();
    $thr2-&gt;detach();
</pre>
<p class="Pp">If <span class="Li">&quot;down()&quot;</span> attempts to
    decrement the counter below zero, it blocks until the counter is large
    enough. Note that while a semaphore can be created with a starting count of
    zero, any <span class="Li">&quot;up()&quot;</span> or
    <span class="Li">&quot;down()&quot;</span> always changes the counter by at
    least one, and so <span class="Li">&quot;$semaphore-&gt;down(0)&quot;</span>
    is the same as
  <span class="Li">&quot;$semaphore-&gt;down(1)&quot;</span>.</p>
<p class="Pp">The question, of course, is why would you do something like this?
    Why create a semaphore with a starting count that's not one, or why
    decrement or increment it by more than one? The answer is resource
    availability. Many resources that you want to manage access for can be
    safely used by more than one thread at once.</p>
<p class="Pp">For example, let's take a GUI driven program. It has a semaphore
    that it uses to synchronize access to the display, so only one thread is
    ever drawing at once. Handy, but of course you don't want any thread to
    start drawing until things are properly set up. In this case, you can create
    a semaphore with a counter set to zero, and up it when things are ready for
    drawing.</p>
<p class="Pp">Semaphores with counters greater than one are also useful for
    establishing quotas. Say, for example, that you have a number of threads
    that can do I/O at once. You don't want all the threads reading or writing
    at once though, since that can potentially swamp your I/O channels, or
    deplete your process's quota of filehandles. You can use a semaphore
    initialized to the number of concurrent I/O requests (or open files) that
    you want at any one time, and have your threads quietly block and unblock
    themselves.</p>
<p class="Pp">Larger increments or decrements are handy in those cases where a
    thread needs to check out or return a number of resources at once.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Waiting_for_a_Condition"><a class="permalink" href="#Waiting_for_a_Condition">Waiting
  for a Condition</a></h2>
The functions <span class="Li">&quot;cond_wait()&quot;</span> and
  <span class="Li">&quot;cond_signal()&quot;</span> can be used in conjunction
  with locks to notify co-operating threads that a resource has become
  available. They are very similar in use to the functions found in
  <span class="Li">&quot;pthreads&quot;</span>. However for most purposes,
  queues are simpler to use and more intuitive. See threads::shared for more
  details.
</section>
<section class="Ss">
<h2 class="Ss" id="Giving_up_control"><a class="permalink" href="#Giving_up_control">Giving
  up control</a></h2>
There are times when you may find it useful to have a thread explicitly give up
  the CPU to another thread. You may be doing something processor-intensive and
  want to make sure that the user-interface thread gets called frequently.
  Regardless, there are times that you might want a thread to give up the
  processor.
<p class="Pp">Perl's threading package provides the
    <span class="Li">&quot;yield()&quot;</span> function that does this.
    <span class="Li">&quot;yield()&quot;</span> is pretty straightforward, and
    works like this:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    use threads;

    sub loop {
        my $thread = shift;
        my $foo = 50;
        while($foo--) { print(&quot;In thread $thread\n&quot;); }
        threads-&gt;yield();
        $foo = 50;
        while($foo--) { print(&quot;In thread $thread\n&quot;); }
    }

    my $thr1 = threads-&gt;create(\&amp;loop, 'first');
    my $thr2 = threads-&gt;create(\&amp;loop, 'second');
    my $thr3 = threads-&gt;create(\&amp;loop, 'third');
</pre>
<p class="Pp">It is important to remember that
    <span class="Li">&quot;yield()&quot;</span> is only a hint to give up the
    CPU, it depends on your hardware, OS and threading libraries what actually
    happens. <b>On many operating systems, </b><b>yield()</b><b> is a no-op.</b>
    Therefore it is important to note that one should not build the scheduling
    of the threads around <span class="Li">&quot;yield()&quot;</span> calls. It
    might work on your platform but it won't work on another platform.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="General_Thread_Utility_Routines"><a class="permalink" href="#General_Thread_Utility_Routines">General
  Thread Utility Routines</a></h1>
We've covered the workhorse parts of Perl's threading package, and with these
  tools you should be well on your way to writing threaded code and packages.
  There are a few useful little pieces that didn't really fit in anyplace else.
<section class="Ss">
<h2 class="Ss" id="What_Thread_Am_I_In?"><a class="permalink" href="#What_Thread_Am_I_In?">What
  Thread Am I In?</a></h2>
The <span class="Li">&quot;threads-&gt;self()&quot;</span> class method provides
  your program with a way to get an object representing the thread it's
  currently in. You can use this object in the same way as the ones returned
  from thread creation.
</section>
<section class="Ss">
<h2 class="Ss" id="Thread_IDs"><a class="permalink" href="#Thread_IDs">Thread
  IDs</a></h2>
<span class="Li">&quot;tid()&quot;</span> is a thread object method that returns
  the thread ID of the thread the object represents. Thread IDs are integers,
  with the main thread in a program being 0. Currently Perl assigns a unique TID
  to every thread ever created in your program, assigning the first thread to be
  created a TID of 1, and increasing the TID by 1 for each new thread that's
  created. When used as a class method,
  <span class="Li">&quot;threads-&gt;tid()&quot;</span> can be used by a thread
  to get its own TID.
</section>
<section class="Ss">
<h2 class="Ss" id="Are_These_Threads_The_Same?"><a class="permalink" href="#Are_These_Threads_The_Same?">Are
  These Threads The Same?</a></h2>
The <span class="Li">&quot;equal()&quot;</span> method takes two thread objects
  and returns true if the objects represent the same thread, and false if they
  don't.
<p class="Pp">Thread objects also have an overloaded
    <span class="Li">&quot;==&quot;</span> comparison so that you can do
    comparison on them as you would with normal objects.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="What_Threads_Are_Running?"><a class="permalink" href="#What_Threads_Are_Running?">What
  Threads Are Running?</a></h2>
<span class="Li">&quot;threads-&gt;list()&quot;</span> returns a list of thread
  objects, one for each thread that's currently running and not detached. Handy
  for a number of things, including cleaning up at the end of your program (from
  the main Perl thread, of course):
<p class="Pp"><span class="Li"></span></p>
<pre>
    # Loop through all the threads
    foreach my $thr (threads-&gt;list()) {
        $thr-&gt;join();
    }
</pre>
<p class="Pp">If some threads have not finished running when the main Perl
    thread ends, Perl will warn you about it and die, since it is impossible for
    Perl to clean up itself while other threads are running.</p>
<p class="Pp">NOTE: The main Perl thread (thread 0) is in a <i>detached</i>
    state, and so does not appear in the list returned by
    <span class="Li">&quot;threads-&gt;list()&quot;</span>.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="A_Complete_Example"><a class="permalink" href="#A_Complete_Example">A
  Complete Example</a></h1>
Confused yet? It's time for an example program to show some of the things we've
  covered. This program finds prime numbers using threads.
<p class="Pp"><span class="Li"></span></p>
<pre>
   1 #!/usr/bin/perl
   2 # prime-pthread, courtesy of Tom Christiansen
   3
   4 use strict;
   5 use warnings;
   6
   7 use threads;
   8 use Thread::Queue;
   9
  10 sub check_num {
  11     my ($upstream, $cur_prime) = @_;
  12     my $kid;
  13     my $downstream = Thread::Queue-&gt;new();
  14     while (my $num = $upstream-&gt;dequeue()) {
  15         next unless ($num % $cur_prime);
  16         if ($kid) {
  17             $downstream-&gt;enqueue($num);
  18         } else {
  19             print(&quot;Found prime: $num\n&quot;);
  20             $kid = threads-&gt;create(\&amp;check_num, $downstream, $num);
  21             if (! $kid) {
  22                 warn(&quot;Sorry.  Ran out of threads.\n&quot;);
  23                 last;
  24             }
  25         }
  26     }
  27     if ($kid) {
  28         $downstream-&gt;enqueue(undef);
  29         $kid-&gt;join();
  30     }
  31 }
  32
  33 my $stream = Thread::Queue-&gt;new(3..1000, undef);
  34 check_num($stream, 2);
</pre>
<p class="Pp">This program uses the pipeline model to generate prime numbers.
    Each thread in the pipeline has an input queue that feeds numbers to be
    checked, a prime number that it's responsible for, and an output queue into
    which it funnels numbers that have failed the check. If the thread has a
    number that's failed its check and there's no child thread, then the thread
    must have found a new prime number. In that case, a new child thread is
    created for that prime and stuck on the end of the pipeline.</p>
<p class="Pp">This probably sounds a bit more confusing than it really is, so
    let's go through this program piece by piece and see what it does. (For
    those of you who might be trying to remember exactly what a prime number is,
    it's a number that's only evenly divisible by itself and 1.)</p>
<p class="Pp">The bulk of the work is done by the
    <span class="Li">&quot;check_num()&quot;</span> subroutine, which takes a
    reference to its input queue and a prime number that it's responsible for.
    After pulling in the input queue and the prime that the subroutine is
    checking (line 11), we create a new queue (line 13) and reserve a scalar for
    the thread that we're likely to create later (line 12).</p>
<p class="Pp">The while loop from line 14 to line 26 grabs a scalar off the
    input queue and checks against the prime this thread is responsible for.
    Line 15 checks to see if there's a remainder when we divide the number to be
    checked by our prime. If there is one, the number must not be evenly
    divisible by our prime, so we need to either pass it on to the next thread
    if we've created one (line 17) or create a new thread if we haven't.</p>
<p class="Pp">The new thread creation is line 20. We pass on to it a reference
    to the queue we've created, and the prime number we've found. In lines 21
    through 24, we check to make sure that our new thread got created, and if
    not, we stop checking any remaining numbers in the queue.</p>
<p class="Pp">Finally, once the loop terminates (because we got a 0 or
    <span class="Li">&quot;undef&quot;</span> in the queue, which serves as a
    note to terminate), we pass on the notice to our child, and wait for it to
    exit if we've created a child (lines 27 and 30).</p>
<p class="Pp">Meanwhile, back in the main thread, we first create a queue (line
    33) and queue up all the numbers from 3 to 1000 for checking, plus a
    termination notice. Then all we have to do to get the ball rolling is pass
    the queue and the first prime to the
    <span class="Li">&quot;check_num()&quot;</span> subroutine (line 34).</p>
<p class="Pp">That's how it works. It's pretty simple; as with many Perl
    programs, the explanation is much longer than the program.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="Different_implementations_of_threads"><a class="permalink" href="#Different_implementations_of_threads">Different
  implementations of threads</a></h1>
Some background on thread implementations from the operating system viewpoint.
  There are three basic categories of threads: user-mode threads, kernel
  threads, and multiprocessor kernel threads.
<p class="Pp">User-mode threads are threads that live entirely within a program
    and its libraries. In this model, the OS knows nothing about threads. As far
    as it's concerned, your process is just a process.</p>
<p class="Pp">This is the easiest way to implement threads, and the way most
    OSes start. The big disadvantage is that, since the OS knows nothing about
    threads, if one thread blocks they all do. Typical blocking activities
    include most system calls, most I/O, and things like
    <span class="Li">&quot;sleep()&quot;</span>.</p>
<p class="Pp">Kernel threads are the next step in thread evolution. The OS knows
    about kernel threads, and makes allowances for them. The main difference
    between a kernel thread and a user-mode thread is blocking. With kernel
    threads, things that block a single thread don't block other threads. This
    is not the case with user-mode threads, where the kernel blocks at the
    process level and not the thread level.</p>
<p class="Pp">This is a big step forward, and can give a threaded program quite
    a performance boost over non-threaded programs. Threads that block
    performing I/O, for example, won't block threads that are doing other
    things. Each process still has only one thread running at once, though,
    regardless of how many CPUs a system might have.</p>
<p class="Pp">Since kernel threading can interrupt a thread at any time, they
    will uncover some of the implicit locking assumptions you may make in your
    program. For example, something as simple as <span class="Li">&quot;$x = $x
    + 2&quot;</span> can behave unpredictably with kernel threads if
    <span class="Li">$x</span> is visible to other threads, as another thread
    may have changed <span class="Li">$x</span> between the time it was fetched
    on the right hand side and the time the new value is stored.</p>
<p class="Pp">Multiprocessor kernel threads are the final step in thread
    support. With multiprocessor kernel threads on a machine with multiple CPUs,
    the OS may schedule two or more threads to run simultaneously on different
    CPUs.</p>
<p class="Pp">This can give a serious performance boost to your threaded
    program, since more than one thread will be executing at the same time. As a
    tradeoff, though, any of those nagging synchronization issues that might not
    have shown with basic kernel threads will appear with a vengeance.</p>
<p class="Pp">In addition to the different levels of OS involvement in threads,
    different OSes (and different thread implementations for a particular OS)
    allocate CPU cycles to threads in different ways.</p>
<p class="Pp">Cooperative multitasking systems have running threads give up
    control if one of two things happen. If a thread calls a yield function, it
    gives up control. It also gives up control if the thread does something that
    would cause it to block, such as perform I/O. In a cooperative multitasking
    implementation, one thread can starve all the others for CPU time if it so
    chooses.</p>
<p class="Pp">Preemptive multitasking systems interrupt threads at regular
    intervals while the system decides which thread should run next. In a
    preemptive multitasking system, one thread usually won't monopolize the
  CPU.</p>
<p class="Pp">On some systems, there can be cooperative and preemptive threads
    running simultaneously. (Threads running with realtime priorities often
    behave cooperatively, for example, while threads running at normal
    priorities behave preemptively.)</p>
<p class="Pp">Most modern operating systems support preemptive multitasking
    nowadays.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="Performance_considerations"><a class="permalink" href="#Performance_considerations">Performance
  considerations</a></h1>
The main thing to bear in mind when comparing Perl's <i>ithreads</i> to other
  threading models is the fact that for each new thread created, a complete copy
  of all the variables and data of the parent thread has to be taken. Thus,
  thread creation can be quite expensive, both in terms of memory usage and time
  spent in creation. The ideal way to reduce these costs is to have a relatively
  short number of long-lived threads, all created fairly early on (before the
  base thread has accumulated too much data). Of course, this may not always be
  possible, so compromises have to be made. However, after a thread has been
  created, its performance and extra memory usage should be little different
  than ordinary code.
<p class="Pp">Also note that under the current implementation, shared variables
    use a little more memory and are a little slower than ordinary
  variables.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="Process-scope_Changes"><a class="permalink" href="#Process-scope_Changes">Process-scope
  Changes</a></h1>
Note that while threads themselves are separate execution threads and Perl data
  is thread-private unless explicitly shared, the threads can affect
  process-scope state, affecting all the threads.
<p class="Pp">The most common example of this is changing the current working
    directory using <span class="Li">&quot;chdir()&quot;</span>. One thread
    calls <span class="Li">&quot;chdir()&quot;</span>, and the working directory
    of all the threads changes.</p>
<p class="Pp">Even more drastic example of a process-scope change is
    <span class="Li">&quot;chroot()&quot;</span>: the root directory of all the
    threads changes, and no thread can undo it (as opposed to
    <span class="Li">&quot;chdir()&quot;</span>).</p>
<p class="Pp">Further examples of process-scope changes include
    <span class="Li">&quot;umask()&quot;</span> and changing uids and gids.</p>
<p class="Pp">Thinking of mixing <span class="Li">&quot;fork()&quot;</span> and
    threads? Please lie down and wait until the feeling passes. Be aware that
    the semantics of <span class="Li">&quot;fork()&quot;</span> vary between
    platforms. For example, some Unix systems copy all the current threads into
    the child process, while others only copy the thread that called
    <span class="Li">&quot;fork()&quot;</span>. You have been warned!</p>
<p class="Pp">Similarly, mixing signals and threads may be problematic.
    Implementations are platform-dependent, and even the POSIX semantics may not
    be what you expect (and Perl doesn't even give you the full POSIX API). For
    example, there is no way to guarantee that a signal sent to a multi-threaded
    Perl application will get intercepted by any particular thread. (However, a
    recently added feature does provide the capability to send signals between
    threads. See &quot;THREAD SIGNALLING&quot; in threads for more details.)</p>
</section>
<section class="Sh">
<h1 class="Sh" id="Thread-Safety_of_System_Libraries"><a class="permalink" href="#Thread-Safety_of_System_Libraries">Thread-Safety
  of System Libraries</a></h1>
Whether various library calls are thread-safe is outside the control of Perl.
  Calls often suffering from not being thread-safe include:
  <span class="Li">&quot;localtime()&quot;</span>,
  <span class="Li">&quot;gmtime()&quot;</span>, functions fetching user, group
  and network information (such as
  <span class="Li">&quot;getgrent()&quot;</span>,
  <span class="Li">&quot;gethostent()&quot;</span>,
  <span class="Li">&quot;getnetent()&quot;</span> and so on),
  <span class="Li">&quot;readdir()&quot;</span>,
  <span class="Li">&quot;rand()&quot;</span>, and
  <span class="Li">&quot;srand()&quot;</span>. In general, calls that depend on
  some global external state.
<p class="Pp">If the system Perl is compiled in has thread-safe variants of such
    calls, they will be used. Beyond that, Perl is at the mercy of the
    thread-safety or -unsafety of the calls. Please consult your C library call
    documentation.</p>
<p class="Pp">On some platforms the thread-safe library interfaces may fail if
    the result buffer is too small (for example the user group databases may be
    rather large, and the reentrant interfaces may have to carry around a full
    snapshot of those databases). Perl will start with a small buffer, but keep
    retrying and growing the result buffer until the result fits. If this
    limitless growing sounds bad for security or memory consumption reasons you
    can recompile Perl with
    <span class="Li">&quot;PERL_REENTRANT_MAXSIZE&quot;</span> defined to the
    maximum number of bytes you will allow.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="Conclusion"><a class="permalink" href="#Conclusion">Conclusion</a></h1>
A complete thread tutorial could fill a book (and has, many times), but with
  what we've covered in this introduction, you should be well on your way to
  becoming a threaded Perl expert.
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
Annotated POD for threads:
  &lt;http://annocpan.org/?mode=search&amp;field=Module&amp;name=threads&gt;
<p class="Pp">Latest version of threads on CPAN:
    &lt;https://metacpan.org/pod/threads&gt;</p>
<p class="Pp">Annotated POD for threads::shared:
    &lt;http://annocpan.org/?mode=search&amp;field=Module&amp;name=threads%3A%3Ashared&gt;</p>
<p class="Pp">Latest version of threads::shared on CPAN:
    &lt;https://metacpan.org/pod/threads::shared&gt;</p>
<p class="Pp">Perl threads mailing list:
    &lt;http://lists.perl.org/list/ithreads.html&gt;</p>
</section>
<section class="Sh">
<h1 class="Sh" id="Bibliography"><a class="permalink" href="#Bibliography">Bibliography</a></h1>
Here's a short bibliography courtesy of Juergen Christoffel:
<section class="Ss">
<h2 class="Ss" id="Introductory_Texts"><a class="permalink" href="#Introductory_Texts">Introductory
  Texts</a></h2>
Birrell, Andrew D. An Introduction to Programming with Threads. Digital
  Equipment Corporation, 1989, DEC-SRC Research Report #35 online as
  &lt;ftp://ftp.dec.com/pub/DEC/SRC/research-reports/SRC-035.pdf&gt; (highly
  recommended)
<p class="Pp">Robbins, Kay. A., and Steven Robbins. Practical Unix Programming:
    A Guide to Concurrency, Communication, and Multithreading. Prentice-Hall,
    1996.</p>
<p class="Pp">Lewis, Bill, and Daniel J. Berg. Multithreaded Programming with
    Pthreads. Prentice Hall, 1997, ISBN 0-13-443698-9 (a well-written
    introduction to threads).</p>
<p class="Pp">Nelson, Greg (editor). Systems Programming with Modula-3. Prentice
    Hall, 1991, ISBN 0-13-590464-1.</p>
<p class="Pp">Nichols, Bradford, Dick Buttlar, and Jacqueline Proulx Farrell.
    Pthreads Programming. O'Reilly &amp; Associates, 1996, ISBN 156592-115-1
    (covers POSIX threads).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="OS-Related_References"><a class="permalink" href="#OS-Related_References">OS-Related
  References</a></h2>
Boykin, Joseph, David Kirschen, Alan Langerman, and Susan LoVerso. Programming
  under Mach. Addison-Wesley, 1994, ISBN 0-201-52739-1.
<p class="Pp">Tanenbaum, Andrew S. Distributed Operating Systems. Prentice Hall,
    1995, ISBN 0-13-219908-4 (great textbook).</p>
<p class="Pp">Silberschatz, Abraham, and Peter B. Galvin. Operating System
    Concepts, 4th ed. Addison-Wesley, 1995, ISBN 0-201-59292-4</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Other_References"><a class="permalink" href="#Other_References">Other
  References</a></h2>
Arnold, Ken and James Gosling. The Java Programming Language, 2nd ed.
  Addison-Wesley, 1998, ISBN 0-201-31006-6.
<p class="Pp">comp.programming.threads FAQ,
    &lt;http://www.serpentine.com/~bos/threads-faq/&gt;</p>
<p class="Pp">Le Sergent, T. and B. Berthomieu. &quot;Incremental MultiThreaded
    Garbage Collection on Virtually Shared Memory Architectures&quot; in Memory
    Management: Proc. of the International Workshop IWMM 92, St. Malo, France,
    September 1992, Yves Bekkers and Jacques Cohen, eds. Springer, 1992, ISBN
    3540-55940-X (real-life thread applications).</p>
<p class="Pp">Artur Bergman, &quot;Where Wizards Fear To Tread&quot;, June 11,
    2002, &lt;http://www.perl.com/pub/a/2002/06/11/threads.html&gt;</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="Acknowledgements"><a class="permalink" href="#Acknowledgements">Acknowledgements</a></h1>
Thanks (in no particular order) to Chaim Frenkel, Steve Fink, Gurusamy Sarathy,
  Ilya Zakharevich, Benjamin Sugars, Juergen Christoffel, Joshua Pritikin, and
  Alan Burlison, for their help in reality-checking and polishing this article.
  Big thanks to Tom Christiansen for his rewrite of the prime number generator.
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
Dan Sugalski &lt;dan@sidhe.org&gt;
<p class="Pp">Slightly modified by Arthur Bergman to fit the new thread
    model/module.</p>
<p class="Pp">Reworked slightly by Joerg Walter &lt;jwalt@cpan.org&gt; to be
    more concise about thread-safety of Perl code.</p>
<p class="Pp">Rearranged slightly by Elizabeth Mattijsen &lt;liz@dijkmat.nl&gt;
    to put less emphasis on <b>yield()</b>.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="Copyrights"><a class="permalink" href="#Copyrights">Copyrights</a></h1>
The original version of this article originally appeared in The Perl Journal
  #10, and is copyright 1998 The Perl Journal. It appears courtesy of Jon Orwant
  and The Perl Journal. This document may be distributed under the same terms as
  Perl itself.
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2020-02-29</td>
    <td class="foot-os">perl v5.30.2</td>
  </tr>
</table>
</body>
</html>
