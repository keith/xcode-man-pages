<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   generated by cd2nroff 0.1 from curl_multi_info_read.md
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    .Nd, .Bf, .Op { display: inline; }
    .Pa, .Ad { font-style: italic; }
    .Ms { font-weight: bold; }
    .Bl-diag > dt { font-weight: bold; }
    code.Nm, .Fl, .Cm, .Ic, code.In, .Fd, .Fn, .Cd { font-weight: bold;
      font-family: inherit; }
  </style>
  <title>curl_multi_info_read(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">curl_multi_info_read(3)</td>
    <td class="head-vol">Library Functions Manual</td>
    <td class="head-rtitle">curl_multi_info_read(3)</td>
  </tr>
</table>
<div class="manual-text">
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">curl_multi_info_read - read multi stack information</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>#include &lt;curl/curl.h&gt;
CURLMsg *curl_multi_info_read(CURLM *multi_handle, int *msgs_in_queue);</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">Ask the multi handle if there are any messages from the individual
    transfers. Messages may include information such as an error code from the
    transfer or just the fact that a transfer is completed. More details on
    these should be written down as well.</p>
<p class="Pp">Repeated calls to this function returns a new struct each time,
    until a NULL is returned as a signal that there is no more to get at this
    point. The integer pointed to with <i>msgs_in_queue</i> contains the number
    of remaining messages after this function was called.</p>
<p class="Pp">When you fetch a message using this function, it is removed from
    the internal queue so calling this function again does not return the same
    message again. It instead returns new messages at each new invoke until the
    queue is emptied.</p>
<p class="Pp"><b>WARNING:</b> The data the returned pointer points to does not
    survive calling <i>curl_multi_cleanup(3)</i>,
    <i>curl_multi_remove_handle(3)</i> or <i>curl_easy_cleanup(3)</i>.</p>
<p class="Pp">The <i>CURLMsg</i> struct is simple and only contains basic
    information. If more involved information is wanted, the particular
    &quot;easy handle&quot; is present in that struct and can be used in
    subsequent regular <i>curl_easy_getinfo(3)</i> calls (or similar):</p>
<p class="Pp"></p>
<pre>
<br/>
 struct CURLMsg {
<br/>
   CURLMSG msg;       /* what this message means */
<br/>
   CURL *easy_handle; /* the handle it concerns */
<br/>
   union {
<br/>
     void *whatever;    /* message-specific data */
<br/>
     CURLcode result;   /* return code for transfer */
<br/>
   } data;
<br/>
 };</pre>
<p class="Pp">When <b>msg</b> is <i>CURLMSG_DONE</i>, the message identifies a
    transfer that is done, and then <b>result</b> contains the return code for
    the easy handle that just completed.</p>
<p class="Pp">At this point, there are no other <b>msg</b> types defined.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="EXAMPLE"><a class="permalink" href="#EXAMPLE">EXAMPLE</a></h1>
<pre>int main(void)
{
<br/>
  CURLM *multi = curl_multi_init();
<br/>
  CURL *curl = curl_easy_init();
<br/>
  if(curl) {
<br/>
    struct CURLMsg *m;
<br/>
    /* call curl_multi_perform or curl_multi_socket_action first, then loop
<br/>
       through and check if there are any transfers that have completed */
<br/>
    do {
<br/>
      int msgq = 0;
<br/>
      m = curl_multi_info_read(multi, &amp;msgq);
<br/>
      if(m &amp;&amp; (m-&gt;msg == CURLMSG_DONE)) {
<br/>
        CURL *e = m-&gt;easy_handle;
<br/>
        /* m-&gt;data.result holds the error code for the transfer */
<br/>
        curl_multi_remove_handle(multi, e);
<br/>
        curl_easy_cleanup(e);
<br/>
      }
<br/>
    } while(m);
<br/>
  }
}</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="AVAILABILITY"><a class="permalink" href="#AVAILABILITY">AVAILABILITY</a></h1>
<p class="Pp">Added in 7.9.6</p>
</section>
<section class="Sh">
<h1 class="Sh" id="RETURN_VALUE"><a class="permalink" href="#RETURN_VALUE">RETURN
  VALUE</a></h1>
<p class="Pp">A pointer to a filled-in struct, or NULL if it failed or ran out
    of structs. It also writes the number of messages left in the queue (after
    this read) in the integer the second argument points to.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp"><b>curl_multi_cleanup</b>(3), <b>curl_multi_init</b>(3),
    <b>curl_multi_perform</b>(3)</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">November 4, 2020</td>
    <td class="foot-os">libcurl 7.77.0</td>
  </tr>
</table>
</body>
</html>
