<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   generated by cd2nroff 0.1 from CURLOPT_INTERLEAVEFUNCTION.md
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    .Nd, .Bf, .Op { display: inline; }
    .Pa, .Ad { font-style: italic; }
    .Ms { font-weight: bold; }
    .Bl-diag > dt { font-weight: bold; }
    code.Nm, .Fl, .Cm, .Ic, code.In, .Fd, .Fn, .Cd { font-weight: bold;
      font-family: inherit; }
  </style>
  <title>CURLOPT_INTERLEAVEFUNCTION(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">CURLOPT_INTERLEAVEFUNCTION(3)</td>
    <td class="head-vol">Library Functions Manual</td>
    <td class="head-rtitle">CURLOPT_INTERLEAVEFUNCTION(3)</td>
  </tr>
</table>
<div class="manual-text">
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">CURLOPT_INTERLEAVEFUNCTION - callback for RTSP interleaved
  data</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>#include &lt;curl/curl.h&gt;
size_t interleave_callback(void *ptr, size_t size, size_t nmemb,
<br/>
                           void *userdata);
CURLcode curl_easy_setopt(CURL *handle, CURLOPT_INTERLEAVEFUNCTION,
<br/>
                          interleave_callback);</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">Pass a pointer to your callback function, which should match the
    prototype shown above.</p>
<p class="Pp">This callback function gets called by libcurl as soon as it has
    received interleaved RTP data. This function gets called for each $ block
    and therefore contains exactly one upper-layer protocol unit (e.g. one RTP
    packet). Curl writes the interleaved header as well as the included data for
    each call. The first byte is always an ASCII dollar sign. The dollar sign is
    followed by a one byte channel identifier and then a 2 byte integer length
    in network byte order. See RFC 2326 Section 10.12 for more information on
    how RTP interleaving behaves. If unset or set to NULL, curl uses the default
    write function.</p>
<p class="Pp">Interleaved RTP poses some challenges for the client application.
    Since the stream data is sharing the RTSP control connection, it is critical
    to service the RTP in a timely fashion. If the RTP data is not handled
    quickly, subsequent response processing may become unreasonably delayed and
    the connection may close. The application may use
    <i>CURL_RTSPREQ_RECEIVE</i> to service RTP data when no requests are
    desired. If the application makes a request, (e.g.
    <i>CURL_RTSPREQ_PAUSE</i>) then the response handler processes any pending
    RTP data before marking the request as finished.</p>
<p class="Pp">The <i>CURLOPT_INTERLEAVEDATA(3)</i> is passed in the
    <i>userdata</i> argument in the callback.</p>
<p class="Pp">Your callback should return the number of bytes actually taken
    care of. If that amount differs from the amount passed to your callback
    function, it signals an error condition to the library. This causes the
    transfer to abort and the libcurl function used returns
    <i>CURLE_WRITE_ERROR</i>.</p>
<p class="Pp">You can also abort the transfer by returning CURL_WRITEFUNC_ERROR.
    (7.87.0)</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DEFAULT"><a class="permalink" href="#DEFAULT">DEFAULT</a></h1>
<p class="Pp">NULL, the interleave data is then passed to the regular write
    function: <i>CURLOPT_WRITEFUNCTION(3)</i>.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="PROTOCOLS"><a class="permalink" href="#PROTOCOLS">PROTOCOLS</a></h1>
<p class="Pp">RTSP</p>
</section>
<section class="Sh">
<h1 class="Sh" id="EXAMPLE"><a class="permalink" href="#EXAMPLE">EXAMPLE</a></h1>
<pre>struct local {
<br/>
  void *custom;
};
static size_t rtp_write(void *ptr, size_t size, size_t nmemb, void *userp)
{
<br/>
  struct local *l = userp;
<br/>
  printf(&quot;our ptr: %p\n&quot;, l-&gt;custom);
<br/>
  /* take care of the packet in 'ptr', then return... */
<br/>
  return size * nmemb;
}
int main(void)
{
<br/>
  struct local rtp_data;
<br/>
  CURL *curl = curl_easy_init();
<br/>
  if(curl) {
<br/>
    curl_easy_setopt(curl, CURLOPT_INTERLEAVEFUNCTION, rtp_write);
<br/>
    curl_easy_setopt(curl, CURLOPT_INTERLEAVEDATA, &amp;rtp_data);
<br/>
  }
}</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="AVAILABILITY"><a class="permalink" href="#AVAILABILITY">AVAILABILITY</a></h1>
<p class="Pp">Added in 7.20.0</p>
</section>
<section class="Sh">
<h1 class="Sh" id="RETURN_VALUE"><a class="permalink" href="#RETURN_VALUE">RETURN
  VALUE</a></h1>
<p class="Pp">Returns CURLE_OK if the option is supported, and
    CURLE_UNKNOWN_OPTION if not.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp"><b>CURLOPT_INTERLEAVEDATA</b>(3),
  <b>CURLOPT_RTSP_REQUEST</b>(3)</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">September 26, 2023</td>
    <td class="foot-os">ibcurl 8.4.0</td>
  </tr>
</table>
</body>
</html>
