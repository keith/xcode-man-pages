<!DOCTYPE html>
<html>
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>SLAPD-META(5)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">SLAPD-META(5)</td>
    <td class="head-vol">File Formats Manual</td>
    <td class="head-rtitle">SLAPD-META(5)</td>
  </tr>
</table>
<div class="manual-text">
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
slapd-meta - metadirectory backend to slapd
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
/etc/openldap/slapd.conf
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
The <b>meta</b> backend to <b>slapd</b>(8) performs basic LDAP proxying with
  respect to a set of remote LDAP servers, called &quot;targets&quot;. The
  information contained in these servers can be presented as belonging to a
  single Directory Information Tree (DIT).
<p class="Pp">A basic knowledge of the functionality of the <b>slapd-ldap</b>(5)
    backend is recommended. This backend has been designed as an enhancement of
    the ldap backend. The two backends share many features (actually they also
    share portions of code). While the <b>ldap</b> backend is intended to proxy
    operations directed to a single server, the <b>meta</b> backend is mainly
    intended for proxying of multiple servers and possibly naming context
    masquerading. These features, although useful in many scenarios, may result
    in excessive overhead for some applications, so its use should be carefully
    considered. In the examples section, some typical scenarios will be
    discussed.</p>
<p class="Pp">The proxy instance of <b>slapd</b>(8) must contain schema
    information for the attributes and objectClasses used in filters, request DN
    and request-related data in general. It should also contain schema
    information for the data returned by the proxied server. It is the
    responsibility of the proxy administrator to keep the schema of the proxy
    lined up with that of the proxied server.</p>
<p class="Pp"></p>
<p class="Pp">Note: When looping back to the same instance of <b>slapd</b>(8),
    each connection requires a new thread; as a consequence, <b>slapd</b>(8)
    must be compiled with thread support, and the <b>threads</b> parameter may
    need some tuning; in those cases, unless the multiple target feature is
    required, one may consider using <b>slapd-relay</b>(5) instead, which
    performs the relayed operation internally and thus reuses the same
    connection.</p>
<p class="Pp"></p>
</section>
<section class="Sh">
<h1 class="Sh" id="EXAMPLES"><a class="permalink" href="#EXAMPLES">EXAMPLES</a></h1>
There are examples in various places in this document, as well as in the
  slapd/back-meta/data/ directory in the OpenLDAP source tree.
</section>
<section class="Sh">
<h1 class="Sh" id="CONFIGURATION"><a class="permalink" href="#CONFIGURATION">CONFIGURATION</a></h1>
These <b>slapd.conf</b> options apply to the META backend database. That is,
  they must follow a &quot;database meta&quot; line and come before any
  subsequent &quot;backend&quot; or &quot;database&quot; lines. Other database
  options are described in the <b>slapd.conf</b>(5) manual page.
<p class="Pp">Note: In early versions of back-ldap and back-meta it was
    recommended to always set</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
lastmod  off
</pre>
</div>
<p class="Pp">for <b>ldap</b> and <b>meta</b> databases. This was required
    because operational attributes related to entry creation and modification
    should not be proxied, as they could be mistakenly written to the target
    server(s), generating an error. The current implementation automatically
    sets lastmod to <b>off</b>, so its use is redundant and should be
  omitted.</p>
<p class="Pp"></p>
</section>
<section class="Sh">
<h1 class="Sh" id="SPECIAL_CONFIGURATION_DIRECTIVES"><a class="permalink" href="#SPECIAL_CONFIGURATION_DIRECTIVES">SPECIAL
  CONFIGURATION DIRECTIVES</a></h1>
Target configuration starts with the &quot;uri&quot; directive. All the
  configuration directives that are not specific to targets should be defined
  first for clarity, including those that are common to all backends. They are:
<p class="Pp"></p>
<dl class="Bl-tag">
  <dt><b>conn-ttl &lt;time&gt;</b></dt>
  <dd>This directive causes a cached connection to be dropped an recreated after
      a given ttl, regardless of being idle or not.
    <p class="Pp"></p>
  </dd>
  <dt><b>default-target none</b></dt>
  <dd>This directive forces the backend to reject all those operations that must
      resolve to a single target in case none or multiple targets are selected.
      They include: add, delete, modify, modrdn; compare is not included, as
      well as bind since, as they don't alter entries, in case of multiple
      matches an attempt is made to perform the operation on any candidate
      target, with the constraint that at most one must succeed. This directive
      can also be used when processing targets to mark a specific target as
      default.
    <p class="Pp"></p>
  </dd>
  <dt><b>dncache-ttl {DISABLED|forever|&lt;ttl&gt;}</b></dt>
  <dd>This directive sets the time-to-live of the DN cache. This caches the
      target that holds a given DN to speed up target selection in case multiple
      targets would result from an uncached search; forever means cache never
      expires; disabled means no DN caching; otherwise a valid ( &gt; 0 ) ttl is
      required, in the format illustrated for the <b>idle-timeout</b> directive.
    <p class="Pp"></p>
  </dd>
  <dt><b>onerr {CONTINUE|report|stop}</b></dt>
  <dd>This directive allows to select the behavior in case an error is returned
      by one target during a search. The default, <b>continue</b>, consists in
      continuing the operation, trying to return as much data as possible. If
      the value is set to <b>stop</b>, the search is terminated as soon as an
      error is returned by one target, and the error is immediately propagated
      to the client. If the value is set to <b>report</b>, the search is
      continuated to the end but, in case at least one target returned an error
      code, the first non-success error code is returned.
    <p class="Pp"></p>
  </dd>
  <dt><b>norefs &lt;NO|yes&gt;</b></dt>
  <dd>If <b>yes</b>, do not return search reference responses. By default, they
      are returned unless request is LDAPv2. If set before any target
      specification, it affects all targets, unless overridden by any per-target
      directive.
    <p class="Pp"></p>
  </dd>
  <dt><b>noundeffilter &lt;NO|yes&gt;</b></dt>
  <dd>If <b>yes</b>, return success instead of searching if a filter is
      undefined or contains undefined portions. By default, the search is
      propagated after replacing undefined portions with
      <b>(!(objectClass=*))</b>, which corresponds to the empty result set. If
      set before any target specification, it affects all targets, unless
      overridden by any per-target directive.
    <p class="Pp"></p>
  </dd>
  <dt><b>protocol-version {0,2,3}</b></dt>
  <dd>This directive indicates what protocol version must be used to contact the
      remote server. If set to 0 (the default), the proxy uses the same protocol
      version used by the client, otherwise the requested protocol is used. The
      proxy returns <i>unwillingToPerform</i> if an operation that is
      incompatible with the requested protocol is attempted. If set before any
      target specification, it affects all targets, unless overridden by any
      per-target directive.
    <p class="Pp"></p>
  </dd>
  <dt><b>pseudoroot-bind-defer {YES|no}</b></dt>
  <dd>This directive, when set to <b>yes</b>, causes the authentication to the
      remote servers with the pseudo-root identity (the identity defined in each
      <b>idassert-bind</b> directive) to be deferred until actually needed by
      subsequent operations. Otherwise, all binds as the rootdn are propagated
      to the targets.
    <p class="Pp"></p>
  </dd>
  <dt><b>quarantine
    &lt;interval&gt;,&lt;num&gt;[;&lt;interval&gt;,&lt;num&gt;[...]]</b></dt>
  <dd>Turns on quarantine of URIs that returned <i>LDAP_UNAVAILABLE</i>, so that
      an attempt to reconnect only occurs at given intervals instead of any time
      a client requests an operation. The pattern is: retry only after at least
      <i>interval</i> seconds elapsed since last attempt, for exactly <i>num</i>
      times; then use the next pattern. If <i>num</i> for the last pattern is
      &quot;<b>+</b>&quot;, it retries forever; otherwise, no more retries
      occur. This directive must appear before any target specification; it
      affects all targets with the same pattern.
    <p class="Pp"></p>
  </dd>
  <dt><b>rebind-as-user {NO|yes}</b></dt>
  <dd>If this option is given, the client's bind credentials are remembered for
      rebinds, when trying to re-establish a broken connection, or when chasing
      a referral, if <b>chase-referrals</b> is set to <i>yes</i>.
    <p class="Pp"></p>
  </dd>
  <dt><b>session-tracking-request {NO|yes}</b></dt>
  <dd>Adds session tracking control for all requests. The client's IP and
      hostname, and the identity associated to each request, if known, are sent
      to the remote server for informational purposes. This directive is
      incompatible with setting <i>protocol-version</i> to 2. If set before any
      target specification, it affects all targets, unless overridden by any
      per-target directive.
    <p class="Pp"></p>
  </dd>
  <dt><b>single-conn {NO|yes}</b></dt>
  <dd>Discards current cached connection when the client rebinds.
    <p class="Pp"></p>
  </dd>
  <dt><b>use-temporary-conn {NO|yes}</b></dt>
  <dd>when set to <b>yes</b>, create a temporary connection whenever competing
      with other threads for a shared one; otherwise, wait until the shared
      connection is available.
    <p class="Pp"></p>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="TARGET_SPECIFICATION"><a class="permalink" href="#TARGET_SPECIFICATION">TARGET
  SPECIFICATION</a></h1>
Target specification starts with a &quot;uri&quot; directive:
<p class="Pp"></p>
<dl class="Bl-tag">
  <dt><b>uri &lt;protocol&gt;://[&lt;host&gt;]/&lt;naming context&gt;
    [...]</b></dt>
  <dd>The &lt;protocol&gt; part can be anything <b>ldap_initialize</b>(3)
      accepts ({ldap|ldaps|ldapi} and variants); the &lt;host&gt; may be
      omitted, defaulting to whatever is set in <b>ldap.conf</b>(5). The
      &lt;naming context&gt; part is <i>mandatory</i> for the first URI, but it
      <i>must be omitted</i> for subsequent ones, if any. The naming context
      part must be within the naming context defined for the backend, e.g.:</dd>
</dl>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
suffix &quot;<b>dc=foo,dc=com</b>&quot;
uri    &quot;ldap://x.foo.com/dc=x,<b>dc=foo,dc=com</b>&quot;
</pre>
<p class="Pp"></p>
</div>
<div class="Bd-indent">The &lt;naming context&gt; part doesn't need to be unique
  across the targets; it may also match one of the values of the
  &quot;suffix&quot; directive. Multiple URIs may be defined in a single URI
  statement. The additional URIs must be separate arguments and must not have
  any &lt;naming context&gt; part. This causes the underlying library to contact
  the first server of the list that responds. For example, if <i>l1.foo.com</i>
  and <i>l2.foo.com</i> are shadows of the same server, the directive
<p class="Pp"></p>
<pre>
suffix &quot;<b>dc=foo,dc=com</b>&quot;
uri    &quot;ldap://l1.foo.com/<b>dc=foo,dc=com</b>&quot; &quot;ldap://l2.foo.com/&quot;
</pre>
<p class="Pp"></p>
</div>
<div class="Bd-indent">causes <i>l2.foo.com</i> to be contacted whenever
  <i>l1.foo.com</i> does not respond. In that case, the URI list is internally
  rearranged, by moving unavailable URIs to the end, so that further connection
  attempts occur with respect to the last URI that succeeded.</div>
<p class="Pp"></p>
<dl class="Bl-tag">
  <dt><b>acl-authcDN &lt;administrative DN for access control
    purposes&gt;</b></dt>
  <dd>DN which is used to query the target server for acl checking, as in the
      LDAP backend; it is supposed to have read access on the target server to
      attributes used on the proxy for acl checking. There is no risk of giving
      away such values; they are only used to check permissions. <b>The
      acl-authcDN identity is by no means implicitly used by the proxy</b>
      <b>when the client connects anonymously.</b>
    <p class="Pp"></p>
  </dd>
  <dt><b>acl-passwd &lt;password&gt;</b></dt>
  <dd>Password used with the <b>acl-authcDN</b> above.
    <p class="Pp"></p>
  </dd>
  <dt><b>bind-timeout &lt;microseconds&gt;</b></dt>
  <dd>This directive defines the timeout, in microseconds, used when polling for
      response after an asynchronous bind connection. The initial call to
      ldap_result(3) is performed with a trade-off timeout of 100000 us; if that
      results in a timeout exceeded, subsequent calls use the value provided
      with <b>bind-timeout</b>. The default value is used also for subsequent
      calls if <b>bind-timeout</b> is not specified. If set before any target
      specification, it affects all targets, unless overridden by any per-target
      directive.
    <p class="Pp"></p>
  </dd>
  <dt><b>chase-referrals {YES|no}</b></dt>
  <dd>enable/disable automatic referral chasing, which is delegated to the
      underlying libldap, with rebinding eventually performed if the
      <b>rebind-as-user</b> directive is used. The default is to chase
      referrals. If set before any target specification, it affects all targets,
      unless overridden by any per-target directive.
    <p class="Pp"></p>
  </dd>
  <dt><b>client-pr {accept-unsolicited|DISABLE|&lt;size&gt;}</b></dt>
  <dd>This feature allows to use RFC 2696 Paged Results control when performing
      search operations with a specific target, irrespective of the client's
      request. When set to a numeric value, Paged Results control is always used
      with <i>size</i> as the page size. When set to <i>accept-unsolicited</i>,
      unsolicited Paged Results control responses are accepted and honored for
      compatibility with broken remote DSAs. The client is not exposed to paged
      results handling between <b>slapd-meta</b>(5) and the remote servers. By
      default (disabled), Paged Results control is not used and responses are
      not accepted. If set before any target specification, it affects all
      targets, unless overridden by any per-target directive.
    <p class="Pp"></p>
  </dd>
  <dt><b>default-target [&lt;target&gt;]</b></dt>
  <dd>The &quot;default-target&quot; directive can also be used during target
      specification. With no arguments it marks the current target as the
      default. The optional number marks target &lt;target&gt; as the default
      one, starting from 1. Target &lt;target&gt; must be defined.
    <p class="Pp"></p>
  </dd>
  <dt><b>idassert-authzFrom &lt;authz-regexp&gt;</b></dt>
  <dd>if defined, selects what <i>local</i> identities are authorized to exploit
      the identity assertion feature. The string <b>&lt;authz-regexp&gt;</b>
      follows the rules defined for the <i>authzFrom</i> attribute. See
      <b>slapd.conf</b>(5), section related to <b>authz-policy</b>, for details
      on the syntax of this field.
    <p class="Pp"></p>
  </dd>
</dl>
<p class="Pp HP"><b>idassert-bind</b> <b>bindmethod=none|simple|sasl
    [binddn=&lt;simple DN&gt;] [credentials=&lt;simple password&gt;]</b>
    <b>[saslmech=&lt;SASL mech&gt;] [secprops=&lt;properties&gt;]
    [realm=&lt;realm&gt;]</b> <b>[authcId=&lt;authentication ID&gt;]
    [authzId=&lt;authorization ID&gt;]</b> <b>[authz={native|proxyauthz}]
    [mode=&lt;mode&gt;] [flags=&lt;flags&gt;]</b>
    <b>[starttls=no|yes|critical]</b> <b>[tls_cert=&lt;file&gt;]</b>
    <b>[tls_key=&lt;file&gt;]</b> <b>[tls_cacert=&lt;file&gt;]</b>
    <b>[tls_cacertdir=&lt;path&gt;]</b> <b>[tls_identity=&lt;name&gt;]</b>
    <b>[tls_trusted_certs=&lt;list&gt;]</b>
    <b>[tls_reqcert=never|allow|try|demand]</b>
    <b>[tls_ciphersuite=&lt;ciphers&gt;]</b>
    <b>[tls_protocol_min=&lt;version&gt;]</b>
    <b>[tls_crlcheck=none|peer|all]</b></p>
<div class="Bd-indent">Allows to define the parameters of the authentication
  method that is internally used by the proxy to authorize connections that are
  authenticated by other databases. The identity defined by this directive,
  according to the properties associated to the authentication method, is
  supposed to have auth access on the target server to attributes used on the
  proxy for authentication and authorization, and to be allowed to authorize the
  users. This requires to have <b>proxyAuthz</b> privileges on a wide set of
  DNs, e.g. <b>authzTo=dn.subtree:&quot;&quot;</b>, and the remote server to
  have <b>authz-policy</b> set to <b>to</b> or <b>both</b>. See
  <b>slapd.conf</b>(5) for details on these statements and for remarks and
  drawbacks about their usage. The supported bindmethods are
<p class="Pp"><b>none|simple|sasl</b></p>
<p class="Pp">where <b>none</b> is the default, i.e. no <i>identity
    assertion</i> is performed.</p>
<p class="Pp">The authz parameter is used to instruct the SASL bind to exploit
    <b>native</b> SASL authorization, if available; since connections are
    cached, this should only be used when authorizing with a fixed identity
    (e.g. by means of the <b>authzDN</b> or <b>authzID</b> parameters).
    Otherwise, the default <b>proxyauthz</b> is used, i.e. the proxyAuthz
    control (Proxied Authorization, RFC 4370) is added to all operations.</p>
<p class="Pp">The supported modes are:</p>
<p class="Pp"><b>&lt;mode&gt; := {legacy|anonymous|none|self}</b></p>
<p class="Pp">If <b>&lt;mode&gt;</b> is not present, and <b>authzId</b> is
    given, the proxy always authorizes that identity. <b>&lt;authorization
    ID&gt;</b> can be</p>
<p class="Pp"><b>u:&lt;user&gt;</b></p>
<p class="Pp"><b>[dn:]&lt;DN&gt;</b></p>
<p class="Pp">The former is supposed to be expanded by the remote server
    according to the authz rules; see <b>slapd.conf</b>(5) for details. In the
    latter case, whether or not the <b>dn:</b> prefix is present, the string
    must pass DN validation and normalization.</p>
<p class="Pp">The default mode is <b>legacy</b>, which implies that the proxy
    will either perform a simple bind as the <i>authcDN</i> or a SASL bind as
    the <i>authcID</i> and assert the client's identity when it is not
    anonymous. Direct binds are always proxied. The other modes imply that the
    proxy will always either perform a simple bind as the <i>authcDN</i> or a
    SASL bind as the <i>authcID</i>, unless restricted by
    <b>idassert-authzFrom</b> rules (see below), in which case the operation
    will fail; eventually, it will assert some other identity according to
    <b>&lt;mode&gt;</b>. Other identity assertion modes are <b>anonymous</b> and
    <b>self</b>, which respectively mean that the <i>empty</i> or the
    <i>client</i>'s identity will be asserted; <b>none</b>, which means that no
    proxyAuthz control will be used, so the <i>authcDN</i> or the <i>authcID</i>
    identity will be asserted. For all modes that require the use of the
    <i>proxyAuthz</i> control, on the remote server the proxy identity must have
    appropriate <i>authzTo</i> permissions, or the asserted identities must have
    appropriate <i>authzFrom</i> permissions. Note, however, that the ID
    assertion feature is mostly useful when the asserted identities do not exist
    on the remote server.</p>
<p class="Pp">Flags can be</p>
<p class="Pp"><b>override,[non-]prescriptive,proxy-authz-[non-]critical</b></p>
<p class="Pp">When the <b>override</b> flag is used, identity assertion takes
    place even when the database is authorizing for the identity of the client,
    i.e. after binding with the provided identity, and thus authenticating it,
    the proxy performs the identity assertion using the configured identity and
    authentication method.</p>
<p class="Pp">When the <b>prescriptive</b> flag is used (the default),
    operations fail with <i>inappropriateAuthentication</i> for those identities
    whose assertion is not allowed by the <b>idassert-authzFrom</b> patterns. If
    the <b>non-prescriptive</b> flag is used, operations are performed
    anonymously for those identities whose assertion is not allowed by the
    <b>idassert-authzFrom</b> patterns.</p>
<p class="Pp">When the <b>proxy-authz-non-critical</b> flag is used (the
    default), the proxyAuthz control is not marked as critical, in violation of
    RFC 4370. Use of <b>proxy-authz-critical</b> is recommended.</p>
<p class="Pp">The TLS settings default to the same as the main slapd TLS
    settings, except for <b>tls_reqcert</b> which defaults to
    &quot;demand&quot;.</p>
<p class="Pp">The identity associated to this directive is also used for
    privileged operations whenever <b>idassert-bind</b> is defined and
    <b>acl-bind</b> is not. See <b>acl-bind</b> for details.</p>
</div>
<p class="Pp"></p>
<dl class="Bl-tag">
  <dt><b>idle-timeout &lt;time&gt;</b></dt>
  <dd>This directive causes a cached connection to be dropped an recreated after
      it has been idle for the specified time. The value can be specified as
    <p class="Pp">[&lt;d&gt;d][&lt;h&gt;h][&lt;m&gt;m][&lt;s&gt;[s]]</p>
    <p class="Pp">where &lt;d&gt;, &lt;h&gt;, &lt;m&gt; and &lt;s&gt; are
        respectively treated as days, hours, minutes and seconds. If set before
        any target specification, it affects all targets, unless overridden by
        any per-target directive.</p>
    <p class="Pp"></p>
  </dd>
  <dt><b>map {attribute|objectclass} [&lt;local name&gt;|*] {&lt;foreign
    name&gt;|*}</b></dt>
  <dd>This maps object classes and attributes as in the LDAP backend. See
      <b>slapd-ldap</b>(5).
    <p class="Pp"></p>
  </dd>
  <dt><b>network-timeout &lt;time&gt;</b></dt>
  <dd>Sets the network timeout value after which <b>poll</b>(2)/<b>select</b>(2)
      following a <b>connect</b>(2) returns in case of no activity. The value is
      in seconds, and it can be specified as for <b>idle-timeout</b>. If set
      before any target specification, it affects all targets, unless overridden
      by any per-target directive.
    <p class="Pp"></p>
  </dd>
  <dt><b>nretries {forever|never|&lt;nretries&gt;}</b></dt>
  <dd>This directive defines how many times a bind should be retried in case of
      temporary failure in contacting a target. If defined before any target
      specification, it applies to all targets (by default, <b>3</b> times); the
      global value can be overridden by redefinitions inside each target
      specification.
    <p class="Pp"></p>
  </dd>
  <dt><b>rewrite* ...</b></dt>
  <dd>The rewrite options are described in the &quot;REWRITING&quot; section.
    <p class="Pp"></p>
  </dd>
  <dt><b>subtree-{exclude|include} &lt;rule&gt;</b></dt>
  <dd>This directive allows to indicate what subtrees are actually served by a
      target. The syntax of the supported rules is
    <p class="Pp"><b>&lt;rule&gt;: [dn[.&lt;style&gt;]:]&lt;pattern&gt;</b></p>
    <p class="Pp"><b>&lt;style&gt;: subtree|children|regex</b></p>
    <p class="Pp">When <b>&lt;style&gt;</b> is either <b>subtree</b> or
        <b>children</b> the <b>&lt;pattern&gt;</b> is a DN that must be within
        the naming context served by the target. When <b>&lt;style&gt;</b> is
        <b>regex</b> the <b>&lt;pattern&gt;</b> is a <b>regex</b>(5) pattern. If
        the <b>dn.&lt;style&gt;:</b> prefix is omitted, <b>dn.subtree:</b> is
        implicitly assumed for backward compatibility.</p>
    <p class="Pp">In the <b>subtree-exclude</b> form if the <i>request DN</i>
        matches at least one rule, the target is not considered while fulfilling
        the request; otherwise, the target is considered based on the value of
        the <i>request DN</i>. When the request is a search, also the
        <i>scope</i> is considered.</p>
    <p class="Pp">In the <b>subtree-include</b> form if the <i>request DN</i>
        matches at least one rule, the target is considered while fulfilling the
        request; otherwise the target is ignored.</p>
    <p class="Pp"></p>
  </dd>
</dl>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
    |  match  | exclude |
    +---------+---------+-------------------+
    |    T    |    T    | not candidate     |
    |    F    |    T    | continue checking |
    +---------+---------+-------------------+
    |    T    |    F    | candidate         |
    |    F    |    F    | not candidate     |
    +---------+---------+-------------------+
</pre>
<p class="Pp"></p>
</div>
<div class="Bd-indent">There may be multiple occurrences of the
  <b>subtree-exclude</b> or <b>subtree-include</b> directive for each of the
  targets, but they are mutually exclusive.</div>
<p class="Pp"></p>
<dl class="Bl-tag">
  <dt><b>suffixmassage &lt;virtual naming context&gt; &lt;real naming
    context&gt;</b></dt>
  <dd>All the directives starting with &quot;rewrite&quot; refer to the rewrite
      engine that has been added to slapd. The &quot;suffixmassage&quot;
      directive was introduced in the LDAP backend to allow suffix massaging
      while proxying. It has been obsoleted by the rewriting tools. However,
      both for backward compatibility and for ease of configuration when simple
      suffix massage is required, it has been preserved. It wraps the basic
      rewriting instructions that perform suffix massaging. See the
      &quot;REWRITING&quot; section for a detailed list of the rewrite rules it
      implies.
    <p class="Pp"></p>
  </dd>
  <dt><b>t-f-support {NO|yes|discover}</b></dt>
  <dd>enable if the remote server supports absolute filters (see
      <i>draft-zeilenga-ldap-t-f</i> for details). If set to <b>discover</b>,
      support is detected by reading the remote server's root DSE. If set before
      any target specification, it affects all targets, unless overridden by any
      per-target directive.
    <p class="Pp"></p>
  </dd>
  <dt><b>timeout [&lt;op&gt;=]&lt;val&gt; [...]</b></dt>
  <dd>This directive allows to set per-operation timeouts. Operations can be
    <p class="Pp"><b>&lt;op&gt; ::= bind, add, delete, modrdn, modify, compare,
        search</b></p>
    <p class="Pp">The overall duration of the <b>search</b> operation is
        controlled either by the <b>timelimit</b> parameter or by server-side
        enforced time limits (see <b>timelimit</b> and <b>limits</b> in
        <b>slapd.conf</b>(5) for details). This <b>timeout</b> parameter
        controls how long the target can be irresponsive before the operation is
        aborted. Timeout is meaningless for the remaining operations,
        <b>unbind</b> and <b>abandon</b>, which do not imply any response, while
        it is not yet implemented in currently supported <b>extended</b>
        operations. If no operation is specified, the timeout <b>val</b> affects
        all supported operations. If specified before any target definition, it
        affects all targets unless overridden by per-target directives.</p>
    <p class="Pp">Note: if the timeout is exceeded, the operation is cancelled
        (according to the <b>cancel</b> directive); the protocol does not
        provide any means to rollback operations, so the client will not be
        notified about the result of the operation, which may eventually
        succeeded or not. In case the timeout is exceeded during a bind
        operation, the connection is destroyed, according to RFC4511.</p>
    <p class="Pp"></p>
  </dd>
  <dt><b>tls {[try-]start|[try-]propagate}</b></dt>
  <dd>execute the StartTLS extended operation when the connection is
      initialized; only works if the URI directive protocol scheme is not
      <b>ldaps://</b>. <b>propagate</b> issues the StartTLS operation only if
      the original connection did. The <b>try-</b> prefix instructs the proxy to
      continue operations if the StartTLS operation failed; its use is highly
      deprecated. If set before any target specification, it affects all
      targets, unless overridden by any per-target directive.
    <p class="Pp"></p>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="SCENARIOS"><a class="permalink" href="#SCENARIOS">SCENARIOS</a></h1>
A powerful (and in some sense dangerous) rewrite engine has been added to both
  the LDAP and Meta backends. While the former can gain limited beneficial
  effects from rewriting stuff, the latter can become an amazingly powerful
  tool.
<p class="Pp">Consider a couple of scenarios first.</p>
<p class="Pp">1) Two directory servers share two levels of naming context; say
    &quot;dc=a,dc=foo,dc=com&quot; and &quot;dc=b,dc=foo,dc=com&quot;. Then, an
    unambiguous Meta database can be configured as:</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
database meta
suffix   &quot;<b>dc=foo,dc=com</b>&quot;
uri      &quot;ldap://a.foo.com/dc=a,<b>dc=foo,dc=com</b>&quot;
uri      &quot;ldap://b.foo.com/dc=b,<b>dc=foo,dc=com</b>&quot;
</pre>
</div>
<p class="Pp">Operations directed to a specific target can be easily resolved
    because there are no ambiguities. The only operation that may resolve to
    multiple targets is a search with base &quot;dc=foo,dc=com&quot; and scope
    at least &quot;one&quot;, which results in spawning two searches to the
    targets.</p>
<p class="Pp">2a) Two directory servers don't share any portion of naming
    context, but they'd present as a single DIT [Caveat: uniqueness of
    (massaged) entries among the two servers is assumed; integrity checks risk
    to incur in excessive overhead and have not been implemented]. Say we have
    &quot;dc=bar,dc=org&quot; and &quot;o=Foo,c=US&quot;, and we'd like them to
    appear as branches of &quot;dc=foo,dc=com&quot;, say
    &quot;dc=a,dc=foo,dc=com&quot; and &quot;dc=b,dc=foo,dc=com&quot;. Then we
    need to configure our Meta backend as:</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
database      meta
suffix        &quot;dc=foo,dc=com&quot;
uri           &quot;ldap://a.bar.com/<b>dc=a,dc=foo,dc=com</b>&quot;
suffixmassage &quot;<b>dc=a,dc=foo,dc=com</b>&quot; &quot;dc=bar,dc=org&quot;
uri           &quot;ldap://b.foo.com/<b>dc=b,dc=foo,dc=com</b>&quot;
suffixmassage &quot;<b>dc=b,dc=foo,dc=com</b>&quot; &quot;o=Foo,c=US&quot;
</pre>
</div>
<p class="Pp">Again, operations can be resolved without ambiguity, although some
    rewriting is required. Notice that the virtual naming context of each target
    is a branch of the database's naming context; it is rewritten back and forth
    when operations are performed towards the target servers. What &quot;back
    and forth&quot; means will be clarified later.</p>
<p class="Pp">When a search with base &quot;dc=foo,dc=com&quot; is attempted, if
    the scope is &quot;base&quot; it fails with &quot;no such object&quot;; in
    fact, the common root of the two targets (prior to massaging) does not
    exist. If the scope is &quot;one&quot;, both targets are contacted with the
    base replaced by each target's base; the scope is derated to
    &quot;base&quot;. In general, a scope &quot;one&quot; search is honored, and
    the scope is derated, only when the incoming base is at most one level lower
    of a target's naming context (prior to massaging).</p>
<p class="Pp">Finally, if the scope is &quot;sub&quot; the incoming base is
    replaced by each target's unmassaged naming context, and the scope is not
    altered.</p>
<p class="Pp">2b) Consider the above reported scenario with the two servers
    sharing the same naming context:</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
database      meta
suffix        &quot;<b>dc=foo,dc=com</b>&quot;
uri           &quot;ldap://a.bar.com/<b>dc=foo,dc=com</b>&quot;
suffixmassage &quot;<b>dc=foo,dc=com</b>&quot; &quot;dc=bar,dc=org&quot;
uri           &quot;ldap://b.foo.com/<b>dc=foo,dc=com</b>&quot;
suffixmassage &quot;<b>dc=foo,dc=com</b>&quot; &quot;o=Foo,c=US&quot;
</pre>
</div>
<p class="Pp">All the previous considerations hold, except that now there is no
    way to unambiguously resolve a DN. In this case, all the operations that
    require an unambiguous target selection will fail unless the DN is already
    cached or a default target has been set. Practical configurations may result
    as a combination of all the above scenarios.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="ACLs"><a class="permalink" href="#ACLs">ACLs</a></h1>
Note on ACLs: at present you may add whatever ACL rule you desire to to the Meta
  (and LDAP) backends. However, the meaning of an ACL on a proxy may require
  some considerations. Two philosophies may be considered:
<p class="Pp">a) the remote server dictates the permissions; the proxy simply
    passes back what it gets from the remote server.</p>
<p class="Pp">b) the remote server unveils &quot;everything&quot;; the proxy is
    responsible for protecting data from unauthorized access.</p>
<p class="Pp">Of course the latter sounds unreasonable, but it is not. It is
    possible to imagine scenarios in which a remote host discloses data that can
    be considered &quot;public&quot; inside an intranet, and a proxy that
    connects it to the internet may impose additional constraints. To this
    purpose, the proxy should be able to comply with all the ACL matching
    criteria that the server supports. This has been achieved with regard to all
    the criteria supported by slapd except a special subtle case (please file an
    ITS if you can find other exceptions: &lt;http://www.openldap.org/its/&gt;).
    The rule</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
access to dn=&quot;&lt;dn&gt;&quot; attrs=&lt;attr&gt;
       by dnattr=&lt;dnattr&gt; read
       by * none
</pre>
</div>
<p class="Pp">cannot be matched iff the attribute that is being requested,
    &lt;attr&gt;, is NOT &lt;dnattr&gt;, and the attribute that determines
    membership, &lt;dnattr&gt;, has not been requested (e.g. in a search)</p>
<p class="Pp">In fact this ACL is resolved by slapd using the portion of entry
    it retrieved from the remote server without requiring any further
    intervention of the backend, so, if the &lt;dnattr&gt; attribute has not
    been fetched, the match cannot be assessed because the attribute is not
    present, not because no value matches the requirement!</p>
<p class="Pp">Note on ACLs and attribute mapping: ACLs are applied to the mapped
    attributes; for instance, if the attribute locally known as &quot;foo&quot;
    is mapped to &quot;bar&quot; on a remote server, then local ACLs apply to
    attribute &quot;foo&quot; and are totally unaware of its remote name. The
    remote server will check permissions for &quot;bar&quot;, and the local
    server will possibly enforce additional restrictions to &quot;foo&quot;.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="REWRITING"><a class="permalink" href="#REWRITING">REWRITING</a></h1>
A string is rewritten according to a set of rules, called a `rewrite context'.
  The rules are based on POSIX (''extended'') regular expressions (regex) with
  substring matching; basic variable substitution and map resolution of
  substrings is allowed by specific mechanisms detailed in the following. The
  behavior of pattern matching/substitution can be altered by a set of flags.
<p class="Pp">The underlying concept is to build a lightweight rewrite module
    for the slapd server (initially dedicated to the LDAP backend).</p>
</section>
<section class="Sh">
<h1 class="Sh" id="Passes"><a class="permalink" href="#Passes">Passes</a></h1>
An incoming string is matched against a set of rules. Rules are made of a regex
  match pattern, a substitution pattern and a set of actions, described by a set
  of flags. In case of match a string rewriting is performed according to the
  substitution pattern that allows to refer to substrings matched in the
  incoming string. The actions, if any, are finally performed. The substitution
  pattern allows map resolution of substrings. A map is a generic object that
  maps a substitution pattern to a value. The flags are divided in &quot;Pattern
  matching Flags&quot; and &quot;Action Flags&quot;; the former alter the regex
  match pattern behavior while the latter alter the action that is taken after
  substitution.
</section>
<section class="Sh">
<h1 class="Sh" id="Pattern_Matching_Flags"><a class="permalink" href="#Pattern_Matching_Flags">Pattern
  Matching Flags</a></h1>
<dl class="Bl-tag">
  <dt><b>`C'</b></dt>
  <dd>honors case in matching (default is case insensitive)</dd>
  <dt><b>`R'</b></dt>
  <dd>use POSIX ''basic'' regular expressions (default is ''extended'')</dd>
  <dt><b>`M{n}'</b></dt>
  <dd>allow no more than <b>n</b> recursive passes for a specific rule; does not
      alter the max total count of passes, so it can only enforce a stricter
      limit for a specific rule.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="Action_Flags"><a class="permalink" href="#Action_Flags">Action
  Flags</a></h1>
<dl class="Bl-tag">
  <dt><b>`:'</b></dt>
  <dd>apply the rule once only (default is recursive)</dd>
  <dt><b>`@'</b></dt>
  <dd>stop applying rules in case of match; the current rule is still applied
      recursively; combine with `:' to apply the current rule only once and then
      stop.</dd>
  <dt><b>`#'</b></dt>
  <dd>stop current operation if the rule matches, and issue an `unwilling to
      perform' error.</dd>
  <dt><b>`G{n}'</b></dt>
  <dd>jump <b>n</b> rules back and forth (watch for loops!). Note that `G{1}' is
      implicit in every rule.</dd>
  <dt><b>`I'</b></dt>
  <dd>ignores errors in rule; this means, in case of error, e.g. issued by a
      map, the error is treated as a missed match. The `unwilling to perform' is
      not overridden.</dd>
  <dt><b>`U{n}'</b></dt>
  <dd>uses <b>n</b> as return code if the rule matches; the flag does not alter
      the recursive behavior of the rule, so, to have it performed only once, it
      must be used in combination with `:', e.g. <b>`:U{16}'</b> returns the
      value `16' after exactly one execution of the rule, if the pattern
      matches. As a consequence, its behavior is equivalent to `@', with the
      return code set to <b>n</b>; or, in other words, `@' is equivalent to
      `U{0}'. By convention, the freely available codes are above 16 included;
      the others are reserved.</dd>
</dl>
<p class="Pp">The ordering of the flags can be significant. For instance:
    `IG{2}' means ignore errors and jump two lines ahead both in case of match
    and in case of error, while `G{2}I' means ignore errors, but jump two lines
    ahead only in case of match.</p>
<p class="Pp">More flags (mainly Action Flags) will be added as needed.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="Pattern_matching:"><a class="permalink" href="#Pattern_matching:">Pattern
  matching:</a></h1>
See <b>regex</b>(7) and/or <b>re_format</b>(7).
</section>
<section class="Sh">
<h1 class="Sh" id="Substitution_Pattern_Syntax:"><a class="permalink" href="#Substitution_Pattern_Syntax:">Substitution
  Pattern Syntax:</a></h1>
Everything starting with `%' requires substitution;
<p class="Pp">the only obvious exception is `%%', which is left as is;</p>
<p class="Pp">the basic substitution is `%d', where `d' is a digit; 0 means the
    whole string, while 1-9 is a submatch;</p>
<p class="Pp">a `%' followed by a `{' invokes an advanced substitution. The
    pattern is:</p>
<p class="Pp"></p>
<div class="Bd-indent">`%' `{' [ &lt;op&gt; ] &lt;name&gt; `('
  &lt;substitution&gt; `)' `}'</div>
<p class="Pp">where &lt;name&gt; must be a legal name for the map, i.e.</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
&lt;name&gt; ::= [a-z][a-z0-9]* (case insensitive)
&lt;op&gt; ::= `&gt;' `|' `&amp;' `&amp;&amp;' `*' `**' `$'
</pre>
</div>
<p class="Pp">and &lt;substitution&gt; must be a legal substitution pattern,
    with no limits on the nesting level.</p>
<p class="Pp">The operators are:</p>
<dl class="Bl-tag">
  <dt><b>&gt;</b></dt>
  <dd>sub context invocation; &lt;name&gt; must be a legal, already defined
      rewrite context name</dd>
  <dt><b>|</b></dt>
  <dd>external command invocation; &lt;name&gt; must refer to a legal, already
      defined command name (NOT IMPL.)</dd>
  <dt><b>&amp;</b></dt>
  <dd>variable assignment; &lt;name&gt; defines a variable in the running
      operation structure which can be dereferenced later; operator <b>&amp;</b>
      assigns a variable in the rewrite context scope; operator
      <b>&amp;&amp;</b> assigns a variable that scopes the entire session, e.g.
      its value can be dereferenced later by other rewrite contexts</dd>
  <dt><b>*</b></dt>
  <dd>variable dereferencing; &lt;name&gt; must refer to a variable that is
      defined and assigned for the running operation; operator <b>*</b>
      dereferences a variable scoping the rewrite context; operator <b>**</b>
      dereferences a variable scoping the whole session, e.g. the value is
      passed across rewrite contexts</dd>
  <dt><b>$</b></dt>
  <dd>parameter dereferencing; &lt;name&gt; must refer to an existing parameter;
      the idea is to make some run-time parameters set by the system available
      to the rewrite engine, as the client host name, the bind DN if any,
      constant parameters initialized at config time, and so on; no parameter is
      currently set by either <b>back-ldap</b> or <b>back-meta</b>, but constant
      parameters can be defined in the configuration file by using the
      <b>rewriteParam</b> directive.</dd>
</dl>
<p class="Pp">Substitution escaping has been delegated to the `%' symbol, which
    is used instead of `\' in string substitution patterns because `\' is
    already escaped by slapd's low level parsing routines; as a consequence,
    regex escaping requires two `\' symbols, e.g. `<b>.*\.foo\.bar</b>' must be
    written as `<b>.*\\.foo\\.bar</b>'.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="Rewrite_context:"><a class="permalink" href="#Rewrite_context:">Rewrite
  context:</a></h1>
A rewrite context is a set of rules which are applied in sequence. The basic
  idea is to have an application initialize a rewrite engine (think of Apache's
  mod_rewrite ...) with a set of rewrite contexts; when string rewriting is
  required, one invokes the appropriate rewrite context with the input string
  and obtains the newly rewritten one if no errors occur.
<p class="Pp">Each basic server operation is associated to a rewrite context;
    they are divided in two main groups: client -&gt; server and server -&gt;
    client rewriting.</p>
<p class="Pp">client -&gt; server:</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
(default)            if defined and no specific context 
                     is available
bindDN               bind
searchBase           search
searchFilter         search
searchFilterAttrDN   search
compareDN            compare
compareAttrDN        compare AVA
addDN                add
addAttrDN            add AVA
modifyDN             modify
modifyAttrDN         modify AVA
modrDN               modrdn
newSuperiorDN        modrdn
deleteDN             delete
exopPasswdDN         password modify extended operation DN if proxy
</pre>
</div>
<p class="Pp">server -&gt; client:</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
searchResult         search (only if defined; no default;
                     acts on DN and DN-syntax attributes 
                     of search results)
searchAttrDN         search AVA
matchedDN            all ops (only if applicable)
</pre>
</div>
</section>
<section class="Sh">
<h1 class="Sh" id="Basic_configuration_syntax"><a class="permalink" href="#Basic_configuration_syntax">Basic
  configuration syntax</a></h1>
<dl class="Bl-tag">
  <dt><b>rewriteEngine { on | off }</b></dt>
  <dd>If `on', the requested rewriting is performed; if `off', no rewriting
      takes place (an easy way to stop rewriting without altering too much the
      configuration file).</dd>
  <dt><b>rewriteContext &lt;context name&gt; [ alias &lt;aliased context
    name&gt; ]</b></dt>
  <dd>&lt;Context name&gt; is the name that identifies the context, i.e. the
      name used by the application to refer to the set of rules it contains. It
      is used also to reference sub contexts in string rewriting. A context may
      alias another one. In this case the alias context contains no rule, and
      any reference to it will result in accessing the aliased one.</dd>
  <dt><b>rewriteRule &lt;regex match pattern&gt; &lt;substitution pattern&gt; [
    &lt;flags&gt; ]</b></dt>
  <dd>Determines how a string can be rewritten if a pattern is matched. Examples
      are reported below.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="Additional_configuration_syntax:"><a class="permalink" href="#Additional_configuration_syntax:">Additional
  configuration syntax:</a></h1>
<dl class="Bl-tag">
  <dt><b>rewriteMap &lt;map type&gt; &lt;map name&gt; [ &lt;map attrs&gt;
    ]</b></dt>
  <dd>Allows to define a map that transforms substring rewriting into something
      else. The map is referenced inside the substitution pattern of a
    rule.</dd>
  <dt><b>rewriteParam &lt;param name&gt; &lt;param value&gt;</b></dt>
  <dd>Sets a value with global scope, that can be dereferenced by the command
      `%{$paramName}'.</dd>
  <dt><b>rewriteMaxPasses &lt;number of passes&gt; [&lt;number of passes per
    rule&gt;]</b></dt>
  <dd>Sets the maximum number of total rewriting passes that can be performed in
      a single rewrite operation (to avoid loops). A safe default is set to 100;
      note that reaching this limit is still treated as a success; recursive
      invocation of rules is simply interrupted. The count applies to the
      rewriting operation as a whole, not to any single rule; an optional
      per-rule limit can be set. This limit is overridden by setting specific
      per-rule limits with the `M{n}' flag.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="Configuration_examples:"><a class="permalink" href="#Configuration_examples:">Configuration
  examples:</a></h1>
<pre>
# set to `off' to disable rewriting
rewriteEngine on
# the rules the &quot;suffixmassage&quot; directive implies
rewriteEngine on
# all dataflow from client to server referring to DNs
rewriteContext default
rewriteRule &quot;(.*)&lt;virtualnamingcontext&gt;$&quot; &quot;%1&lt;realnamingcontext&gt;&quot; &quot;:&quot;
# empty filter rule
rewriteContext searchFilter
# all dataflow from server to client
rewriteContext searchResult
rewriteRule &quot;(.*)&lt;realnamingcontext&gt;$&quot; &quot;%1&lt;virtualnamingcontext&gt;&quot; &quot;:&quot;
rewriteContext searchAttrDN alias searchResult
rewriteContext matchedDN alias searchResult
# Everything defined here goes into the `default' context.
# This rule changes the naming context of anything sent
# to `dc=home,dc=net' to `dc=OpenLDAP, dc=org'
rewriteRule &quot;(.*)dc=home,[ ]?dc=net&quot;
            &quot;%1dc=OpenLDAP, dc=org&quot;  &quot;:&quot;
# since a pretty/normalized DN does not include spaces
# after rdn separators, e.g. `,', this rule suffices:
rewriteRule &quot;(.*)dc=home,dc=net&quot;
            &quot;%1dc=OpenLDAP,dc=org&quot;  &quot;:&quot;
# Start a new context (ends input of the previous one).
# This rule adds blanks between DN parts if not present.
rewriteContext  addBlanks
rewriteRule     &quot;(.*),([^ ].*)&quot; &quot;%1, %2&quot;
# This one eats blanks
rewriteContext  eatBlanks
rewriteRule     &quot;(.*),[ ](.*)&quot; &quot;%1,%2&quot;
# Here control goes back to the default rewrite
# context; rules are appended to the existing ones.
# anything that gets here is piped into rule `addBlanks'
rewriteContext  default
rewriteRule     &quot;.*&quot; &quot;%{&gt;addBlanks(%0)}&quot; &quot;:&quot;
# Rewrite the search base according to `default' rules.
rewriteContext  searchBase alias default
# Search results with OpenLDAP DN are rewritten back with
# `dc=home,dc=net' naming context, with spaces eaten.
rewriteContext  searchResult
rewriteRule     &quot;(.*[^ ]?)[ ]?dc=OpenLDAP,[ ]?dc=org&quot;
                &quot;%{&gt;eatBlanks(%1)}dc=home,dc=net&quot;    &quot;:&quot;
# Bind with email instead of full DN: we first need
# an ldap map that turns attributes into a DN (the
# argument used when invoking the map is appended to 
# the URI and acts as the filter portion)
rewriteMap ldap attr2dn &quot;ldap://host/dc=my,dc=org?dn?sub&quot;
# Then we need to detect DN made up of a single email,
# e.g. `mail=someone@example.com'; note that the rule
# in case of match stops rewriting; in case of error,
# it is ignored.  In case we are mapping virtual
# to real naming contexts, we also need to rewrite
# regular DNs, because the definition of a bindDn
# rewrite context overrides the default definition.
rewriteContext bindDN
rewriteRule &quot;^mail=[^,]+@[^,]+$&quot; &quot;%{attr2dn(%0)}&quot; &quot;:@I&quot;
# This is a rather sophisticated example. It massages a
# search filter in case who performs the search has
# administrative privileges.  First we need to keep
# track of the bind DN of the incoming request, which is
# stored in a variable called `binddn' with session scope,
# and left in place to allow regular binding:
rewriteContext  bindDN
rewriteRule     &quot;.+&quot; &quot;%{&amp;&amp;binddn(%0)}%0&quot; &quot;:&quot;
# A search filter containing `uid=' is rewritten only
# if an appropriate DN is bound.
# To do this, in the first rule the bound DN is
# dereferenced, while the filter is decomposed in a
# prefix, in the value of the `uid=&lt;arg&gt;' AVA, and 
# in a suffix. A tag `&lt;&gt;' is appended to the DN. 
# If the DN refers to an entry in the `ou=admin' subtree, 
# the filter is rewritten OR-ing the `uid=&lt;arg&gt;' with
# `cn=&lt;arg&gt;'; otherwise it is left as is. This could be
# useful, for instance, to allow apache's auth_ldap-1.4
# module to authenticate users with both `uid' and
# `cn', but only if the request comes from a possible
# `cn=Web auth,ou=admin,dc=home,dc=net' user.
rewriteContext searchFilter
rewriteRule &quot;(.*\\()uid=([a-z0-9_]+)(\\).*)&quot;
  &quot;%{**binddn}&lt;&gt;%{&amp;prefix(%1)}%{&amp;arg(%2)}%{&amp;suffix(%3)}&quot;
  &quot;:I&quot;
rewriteRule &quot;[^,]+,ou=admin,dc=home,dc=net&quot;
  &quot;%{*prefix}|(uid=%{*arg})(cn=%{*arg})%{*suffix}&quot; &quot;:@I&quot;
rewriteRule &quot;.*&lt;&gt;&quot; &quot;%{*prefix}uid=%{*arg}%{*suffix}&quot; &quot;:&quot;
# This example shows how to strip unwanted DN-valued
# attribute values from a search result; the first rule
# matches DN values below &quot;ou=People,dc=example,dc=com&quot;;
# in case of match the rewriting exits successfully.
# The second rule matches everything else and causes
# the value to be rejected.
rewriteContext searchResult
rewriteRule &quot;.*,ou=People,dc=example,dc=com&quot; &quot;%0&quot; &quot;:@&quot;
rewriteRule &quot;.*&quot; &quot;&quot; &quot;#&quot;
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="LDAP_Proxy_resolution_(a_possible_evolution_of_slapd_-ldap(5)):"><a class="permalink" href="#LDAP_Proxy_resolution_(a_possible_evolution_of_slapd_-ldap(5)):">LDAP
  Proxy resolution (a possible evolution of slapd-ldap(5)):</a></h1>
In case the rewritten DN is an LDAP URI, the operation is initiated towards the
  host[:port] indicated in the uri, if it does not refer to the local server.
  E.g.:
<p class="Pp"></p>
<pre>
  rewriteRule '^cn=root,.*' '%0'                     'G{3}'
  rewriteRule '^cn=[a-l].*' 'ldap://ldap1.my.org/%0' ':@'
  rewriteRule '^cn=[m-z].*' 'ldap://ldap2.my.org/%0' ':@'
  rewriteRule '.*'          'ldap://ldap3.my.org/%0' ':@'
</pre>
<p class="Pp">(Rule 1 is simply there to illustrate the `G{n}' action; it could
    have been written:</p>
<p class="Pp"></p>
<pre>
  rewriteRule '^cn=root,.*' 'ldap://ldap3.my.org/%0' ':@'
</pre>
<p class="Pp">with the advantage of saving one rewrite pass ...)</p>
<p class="Pp"></p>
</section>
<section class="Sh">
<h1 class="Sh" id="ACCESS_CONTROL"><a class="permalink" href="#ACCESS_CONTROL">ACCESS
  CONTROL</a></h1>
The <b>meta</b> backend does not honor all ACL semantics as described in
  <b>slapd.access</b>(5). In general, access checking is delegated to the remote
  server(s). Only <b>read (=r)</b> access to the <b>entry</b> pseudo-attribute
  and to the other attribute values of the entries returned by the <b>search</b>
  operation is honored, which is performed by the frontend.
<p class="Pp"></p>
</section>
<section class="Sh">
<h1 class="Sh" id="PROXY_CACHE_OVERLAY"><a class="permalink" href="#PROXY_CACHE_OVERLAY">PROXY
  CACHE OVERLAY</a></h1>
The proxy cache overlay allows caching of LDAP search requests (queries) in a
  local database. See <b>slapo-pcache</b>(5) for details.
<p class="Pp"></p>
</section>
<section class="Sh">
<h1 class="Sh" id="DEPRECATED_STATEMENTS"><a class="permalink" href="#DEPRECATED_STATEMENTS">DEPRECATED
  STATEMENTS</a></h1>
The following statements have been deprecated and should no longer be used.
<p class="Pp"></p>
<dl class="Bl-tag">
  <dt><b>pseudorootdn &lt;substitute DN in case of rootdn bind&gt;</b></dt>
  <dd>Use <b>idassert-bind</b> instead.
    <p class="Pp"></p>
  </dd>
  <dt><b>pseudorootpw &lt;substitute password in case of rootdn
    bind&gt;</b></dt>
  <dd>Use <b>idassert-bind</b> instead.
    <p class="Pp"></p>
    <p class="Pp"></p>
    <p class="Pp"></p>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="FILES"><a class="permalink" href="#FILES">FILES</a></h1>
<dl class="Bl-tag">
  <dt>/etc/openldap/slapd.conf</dt>
  <dd>default slapd configuration file</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<b>slapd.conf</b>(5), <b>slapd-ldap</b>(5), <b>slapo-pcache</b>(5),
  <b>slapd</b>(8), <b>regex</b>(7), <b>re_format</b>(7).
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
Pierangelo Masarati, based on back-ldap by Howard Chu
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2011/11/24</td>
    <td class="foot-os">OpenLDAP 2.4.28</td>
  </tr>
</table>
</body>
</html>
