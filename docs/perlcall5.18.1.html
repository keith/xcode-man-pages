<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    .Nd, .Bf, .Op { display: inline; }
    .Pa, .Ad { font-style: italic; }
    .Ms { font-weight: bold; }
    .Bl-diag > dt { font-weight: bold; }
    code.Nm, .Fl, .Cm, .Ic, code.In, .Fd, .Fn, .Cd { font-weight: bold;
      font-family: inherit; }
  </style>
  <title>PERLCALL(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">PERLCALL(1)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">PERLCALL(1)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">perlcall - Perl calling conventions from C</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">The purpose of this document is to show you how to call Perl
    subroutines directly from C, i.e., how to write <i>callbacks</i>.</p>
<p class="Pp">Apart from discussing the C interface provided by Perl for writing
    callbacks the document uses a series of examples to show how the interface
    actually works in practice. In addition some techniques for coding callbacks
    are covered.</p>
<p class="Pp">Examples where callbacks are necessary include</p>
<ul class="Bl-bullet">
  <li>An Error Handler
    <p class="Pp">You have created an XSUB interface to an application's C
      API.</p>
    <p class="Pp">A fairly common feature in applications is to allow you to
        define a C function that will be called whenever something nasty occurs.
        What we would like is to be able to specify a Perl subroutine that will
        be called instead.</p>
  </li>
  <li>An Event-Driven Program
    <p class="Pp">The classic example of where callbacks are used is when
        writing an event driven program, such as for an X11 application. In this
        case you register functions to be called whenever specific events occur,
        e.g., a mouse button is pressed, the cursor moves into a window or a
        menu item is selected.</p>
  </li>
</ul>
<p class="Pp">Although the techniques described here are applicable when
    embedding Perl in a C program, this is not the primary goal of this
    document. There are other details that must be considered and are specific
    to embedding Perl. For details on embedding Perl in C refer to
  perlembed.</p>
<p class="Pp">Before you launch yourself head first into the rest of this
    document, it would be a good idea to have read the following two
    documents--perlxs and perlguts.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="THE_CALL__FUNCTIONS"><a class="permalink" href="#THE_CALL__FUNCTIONS">THE
  CALL_ FUNCTIONS</a></h1>
<p class="Pp">Although this stuff is easier to explain using examples, you first
    need be aware of a few important definitions.</p>
<p class="Pp">Perl has a number of C functions that allow you to call Perl
    subroutines. They are</p>
<p class="Pp"></p>
<pre>    I32 call_sv(SV* sv, I32 flags);
    I32 call_pv(char *subname, I32 flags);
    I32 call_method(char *methname, I32 flags);
    I32 call_argv(char *subname, I32 flags, char **argv);
</pre>
<p class="Pp">The key function is <i>call_sv</i>. All the other functions are
    fairly simple wrappers which make it easier to call Perl subroutines in
    special cases. At the end of the day they will all call <i>call_sv</i> to
    invoke the Perl subroutine.</p>
<p class="Pp">All the <i>call_*</i> functions have a
    <span class="Li">&quot;flags&quot;</span> parameter which is used to pass a
    bit mask of options to Perl. This bit mask operates identically for each of
    the functions. The settings available in the bit mask are discussed in
    &quot;FLAG VALUES&quot;.</p>
<p class="Pp">Each of the functions will now be discussed in turn.</p>
<dl class="Bl-tag">
  <dt id="call_sv"><a class="permalink" href="#call_sv">call_sv</a></dt>
  <dd><i>call_sv</i> takes two parameters. The first,
      <span class="Li">&quot;sv&quot;</span>, is an SV*. This allows you to
      specify the Perl subroutine to be called either as a C string (which has
      first been converted to an SV) or a reference to a subroutine. The
      section, <i>Using call_sv</i>, shows how you can make use of
      <i>call_sv</i>.</dd>
  <dt id="call_pv"><a class="permalink" href="#call_pv">call_pv</a></dt>
  <dd>The function, <i>call_pv</i>, is similar to <i>call_sv</i> except it
      expects its first parameter to be a C char* which identifies the Perl
      subroutine you want to call, e.g.,
      <span class="Li">&quot;call_pv(&quot;fred&quot;, 0)&quot;</span>. If the
      subroutine you want to call is in another package, just include the
      package name in the string, e.g.,
      <span class="Li">&quot;pkg::fred&quot;</span>.</dd>
  <dt id="call_method"><a class="permalink" href="#call_method">call_method</a></dt>
  <dd>The function <i>call_method</i> is used to call a method from a Perl
      class. The parameter <span class="Li">&quot;methname&quot;</span>
      corresponds to the name of the method to be called. Note that the class
      that the method belongs to is passed on the Perl stack rather than in the
      parameter list. This class can be either the name of the class (for a
      static method) or a reference to an object (for a virtual method). See
      perlobj for more information on static and virtual methods and &quot;Using
      call_method&quot; for an example of using <i>call_method</i>.</dd>
  <dt id="call_argv"><a class="permalink" href="#call_argv">call_argv</a></dt>
  <dd><i>call_argv</i> calls the Perl subroutine specified by the C string
      stored in the <span class="Li">&quot;subname&quot;</span> parameter. It
      also takes the usual <span class="Li">&quot;flags&quot;</span> parameter.
      The final parameter, <span class="Li">&quot;argv&quot;</span>, consists of
      a NULL-terminated list of C strings to be passed as parameters to the Perl
      subroutine. See <i>Using call_argv</i>.</dd>
</dl>
<p class="Pp">All the functions return an integer. This is a count of the number
    of items returned by the Perl subroutine. The actual items returned by the
    subroutine are stored on the Perl stack.</p>
<p class="Pp">As a general rule you should <i>always</i> check the return value
    from these functions. Even if you are expecting only a particular number of
    values to be returned from the Perl subroutine, there is nothing to stop
    someone from doing something unexpected--don't say you haven't been
  warned.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="FLAG_VALUES"><a class="permalink" href="#FLAG_VALUES">FLAG
  VALUES</a></h1>
<p class="Pp">The <span class="Li">&quot;flags&quot;</span> parameter in all the
    <i>call_*</i> functions is one of G_VOID, G_SCALAR, or G_ARRAY, which
    indicate the call context, OR'ed together with a bit mask of any combination
    of the other G_* symbols defined below.</p>
<section class="Ss">
<h2 class="Ss" id="G_VOID"><a class="permalink" href="#G_VOID">G_VOID</a></h2>
<p class="Pp">Calls the Perl subroutine in a void context.</p>
<p class="Pp">This flag has 2 effects:</p>
<dl class="Bl-tag">
  <dt>1.</dt>
  <dd>It indicates to the subroutine being called that it is executing in a void
      context (if it executes <i>wantarray</i> the result will be the undefined
      value).</dd>
  <dt>2.</dt>
  <dd>It ensures that nothing is actually returned from the subroutine.</dd>
</dl>
<p class="Pp">The value returned by the <i>call_*</i> function indicates how
    many items have been returned by the Perl subroutine--in this case it will
    be 0.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="G_SCALAR"><a class="permalink" href="#G_SCALAR">G_SCALAR</a></h2>
<p class="Pp">Calls the Perl subroutine in a scalar context. This is the default
    context flag setting for all the <i>call_*</i> functions.</p>
<p class="Pp">This flag has 2 effects:</p>
<dl class="Bl-tag">
  <dt>1.</dt>
  <dd>It indicates to the subroutine being called that it is executing in a
      scalar context (if it executes <i>wantarray</i> the result will be
    false).</dd>
  <dt>2.</dt>
  <dd>It ensures that only a scalar is actually returned from the subroutine.
      The subroutine can, of course, ignore the <i>wantarray</i> and return a
      list anyway. If so, then only the last element of the list will be
      returned.</dd>
</dl>
<p class="Pp">The value returned by the <i>call_*</i> function indicates how
    many items have been returned by the Perl subroutine - in this case it will
    be either 0 or 1.</p>
<p class="Pp">If 0, then you have specified the G_DISCARD flag.</p>
<p class="Pp">If 1, then the item actually returned by the Perl subroutine will
    be stored on the Perl stack - the section <i>Returning a Scalar</i> shows
    how to access this value on the stack. Remember that regardless of how many
    items the Perl subroutine returns, only the last one will be accessible from
    the stack - think of the case where only one value is returned as being a
    list with only one element. Any other items that were returned will not
    exist by the time control returns from the <i>call_*</i> function. The
    section <i>Returning a list in a scalar</i> <i>context</i> shows an example
    of this behavior.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="G_ARRAY"><a class="permalink" href="#G_ARRAY">G_ARRAY</a></h2>
<p class="Pp">Calls the Perl subroutine in a list context.</p>
<p class="Pp">As with G_SCALAR, this flag has 2 effects:</p>
<dl class="Bl-tag">
  <dt>1.</dt>
  <dd>It indicates to the subroutine being called that it is executing in a list
      context (if it executes <i>wantarray</i> the result will be true).</dd>
  <dt>2.</dt>
  <dd>It ensures that all items returned from the subroutine will be accessible
      when control returns from the <i>call_*</i> function.</dd>
</dl>
<p class="Pp">The value returned by the <i>call_*</i> function indicates how
    many items have been returned by the Perl subroutine.</p>
<p class="Pp">If 0, then you have specified the G_DISCARD flag.</p>
<p class="Pp">If not 0, then it will be a count of the number of items returned
    by the subroutine. These items will be stored on the Perl stack. The section
    <i>Returning a list of values</i> gives an example of using the G_ARRAY flag
    and the mechanics of accessing the returned items from the Perl stack.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="G_DISCARD"><a class="permalink" href="#G_DISCARD">G_DISCARD</a></h2>
<p class="Pp">By default, the <i>call_*</i> functions place the items returned
    from by the Perl subroutine on the stack. If you are not interested in these
    items, then setting this flag will make Perl get rid of them automatically
    for you. Note that it is still possible to indicate a context to the Perl
    subroutine by using either G_SCALAR or G_ARRAY.</p>
<p class="Pp">If you do not set this flag then it is <i>very</i> important that
    you make sure that any temporaries (i.e., parameters passed to the Perl
    subroutine and values returned from the subroutine) are disposed of
    yourself. The section <i>Returning a Scalar</i> gives details of how to
    dispose of these temporaries explicitly and the section <i>Using Perl to</i>
    <i>dispose of temporaries</i> discusses the specific circumstances where you
    can ignore the problem and let Perl deal with it for you.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="G_NOARGS"><a class="permalink" href="#G_NOARGS">G_NOARGS</a></h2>
<p class="Pp">Whenever a Perl subroutine is called using one of the
    <i>call_*</i> functions, it is assumed by default that parameters are to be
    passed to the subroutine. If you are not passing any parameters to the Perl
    subroutine, you can save a bit of time by setting this flag. It has the
    effect of not creating the <span class="Li">@_</span> array for the Perl
    subroutine.</p>
<p class="Pp">Although the functionality provided by this flag may seem
    straightforward, it should be used only if there is a good reason to do so.
    The reason for being cautious is that, even if you have specified the
    G_NOARGS flag, it is still possible for the Perl subroutine that has been
    called to think that you have passed it parameters.</p>
<p class="Pp">In fact, what can happen is that the Perl subroutine you have
    called can access the <span class="Li">@_</span> array from a previous Perl
    subroutine. This will occur when the code that is executing the
    <i>call_*</i> function has itself been called from another Perl subroutine.
    The code below illustrates this</p>
<p class="Pp"></p>
<pre>    sub fred
      { print &quot;@_\n&quot;  }
    sub joe
      { &amp;fred }
    &amp;joe(1,2,3);
</pre>
<p class="Pp">This will print</p>
<p class="Pp"></p>
<pre>    1 2 3
</pre>
<p class="Pp">What has happened is that <span class="Li">&quot;fred&quot;</span>
    accesses the <span class="Li">@_</span> array which belongs to
    <span class="Li">&quot;joe&quot;</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="G_EVAL"><a class="permalink" href="#G_EVAL">G_EVAL</a></h2>
<p class="Pp">It is possible for the Perl subroutine you are calling to
    terminate abnormally, e.g., by calling <i>die</i> explicitly or by not
    actually existing. By default, when either of these events occurs, the
    process will terminate immediately. If you want to trap this type of event,
    specify the G_EVAL flag. It will put an <i>eval { }</i> around the
    subroutine call.</p>
<p class="Pp">Whenever control returns from the <i>call_*</i> function you need
    to check the <span class="Li">$@</span> variable as you would in a normal
    Perl script.</p>
<p class="Pp">The value returned from the <i>call_*</i> function is dependent on
    what other flags have been specified and whether an error has occurred. Here
    are all the different cases that can occur:</p>
<ul class="Bl-bullet">
  <li>If the <i>call_*</i> function returns normally, then the value returned is
      as specified in the previous sections.</li>
  <li>If G_DISCARD is specified, the return value will always be 0.</li>
  <li>If G_ARRAY is specified <i>and</i> an error has occurred, the return value
      will always be 0.</li>
  <li>If G_SCALAR is specified <i>and</i> an error has occurred, the return
      value will be 1 and the value on the top of the stack will be
      <i>undef</i>. This means that if you have already detected the error by
      checking <span class="Li">$@</span> and you want the program to continue,
      you must remember to pop the <i>undef</i> from the stack.</li>
</ul>
<p class="Pp">See <i>Using G_EVAL</i> for details on using G_EVAL.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="G_KEEPERR"><a class="permalink" href="#G_KEEPERR">G_KEEPERR</a></h2>
<p class="Pp">Using the G_EVAL flag described above will always set
    <span class="Li">$@</span>: clearing it if there was no error, and setting
    it to describe the error if there was an error in the called code. This is
    what you want if your intention is to handle possible errors, but sometimes
    you just want to trap errors and stop them interfering with the rest of the
    program.</p>
<p class="Pp">This scenario will mostly be applicable to code that is meant to
    be called from within destructors, asynchronous callbacks, and signal
    handlers. In such situations, where the code being called has little
    relation to the surrounding dynamic context, the main program needs to be
    insulated from errors in the called code, even if they can't be handled
    intelligently. It may also be useful to do this with code for
    <span class="Li">&quot;__DIE__&quot;</span> or
    <span class="Li">&quot;__WARN__&quot;</span> hooks, and
    <span class="Li">&quot;tie&quot;</span> functions.</p>
<p class="Pp">The G_KEEPERR flag is meant to be used in conjunction with G_EVAL
    in <i>call_*</i> functions that are used to implement such code, or with
    <span class="Li">&quot;eval_sv&quot;</span>. This flag has no effect on the
    <span class="Li">&quot;call_*&quot;</span> functions when G_EVAL is not
    used.</p>
<p class="Pp">When G_KEEPERR is used, any error in the called code will
    terminate the call as usual, and the error will not propagate beyond the
    call (as usual for G_EVAL), but it will not go into
    <span class="Li">$@</span>. Instead the error will be converted into a
    warning, prefixed with the string &quot;\t(in cleanup)&quot;. This can be
    disabled using <span class="Li">&quot;no warnings 'misc'&quot;</span>. If
    there is no error, <span class="Li">$@</span> will not be cleared.</p>
<p class="Pp">Note that the G_KEEPERR flag does not propagate into inner evals;
    these may still set <span class="Li">$@</span>.</p>
<p class="Pp">The G_KEEPERR flag was introduced in Perl version 5.002.</p>
<p class="Pp">See <i>Using G_KEEPERR</i> for an example of a situation that
    warrants the use of this flag.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Determining_the_Context"><a class="permalink" href="#Determining_the_Context">Determining
  the Context</a></h2>
<p class="Pp">As mentioned above, you can determine the context of the currently
    executing subroutine in Perl with <i>wantarray</i>. The equivalent test can
    be made in C by using the <span class="Li">&quot;GIMME_V&quot;</span> macro,
    which returns <span class="Li">&quot;G_ARRAY&quot;</span> if you have been
    called in a list context, <span class="Li">&quot;G_SCALAR&quot;</span> if in
    a scalar context, or <span class="Li">&quot;G_VOID&quot;</span> if in a void
    context (i.e., the return value will not be used). An older version of this
    macro is called <span class="Li">&quot;GIMME&quot;</span>; in a void context
    it returns <span class="Li">&quot;G_SCALAR&quot;</span> instead of
    <span class="Li">&quot;G_VOID&quot;</span>. An example of using the
    <span class="Li">&quot;GIMME_V&quot;</span> macro is shown in section
    <i>Using GIMME_V</i>.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="EXAMPLES"><a class="permalink" href="#EXAMPLES">EXAMPLES</a></h1>
<p class="Pp">Enough of the definition talk! Let's have a few examples.</p>
<p class="Pp">Perl provides many macros to assist in accessing the Perl stack.
    Wherever possible, these macros should always be used when interfacing to
    Perl internals. We hope this should make the code less vulnerable to any
    changes made to Perl in the future.</p>
<p class="Pp">Another point worth noting is that in the first series of examples
    I have made use of only the <i>call_pv</i> function. This has been done to
    keep the code simpler and ease you into the topic. Wherever possible, if the
    choice is between using <i>call_pv</i> and <i>call_sv</i>, you should always
    try to use <i>call_sv</i>. See <i>Using call_sv</i> for details.</p>
<section class="Ss">
<h2 class="Ss" id="No_Parameters,_Nothing_Returned"><a class="permalink" href="#No_Parameters,_Nothing_Returned">No
  Parameters, Nothing Returned</a></h2>
<p class="Pp">This first trivial example will call a Perl subroutine,
    <i>PrintUID</i>, to print out the UID of the process.</p>
<p class="Pp"></p>
<pre>    sub PrintUID
    {
        print &quot;UID is $&lt;\n&quot;;
    }
</pre>
<p class="Pp">and here is a C function to call it</p>
<p class="Pp"></p>
<pre>    static void
    call_PrintUID()
    {
        dSP;
        PUSHMARK(SP);
        call_pv(&quot;PrintUID&quot;, G_DISCARD|G_NOARGS);
    }
</pre>
<p class="Pp">Simple, eh?</p>
<p class="Pp">A few points to note about this example:</p>
<dl class="Bl-tag">
  <dt>1.</dt>
  <dd>Ignore <span class="Li">&quot;dSP&quot;</span> and
      <span class="Li">&quot;PUSHMARK(SP)&quot;</span> for now. They will be
      discussed in the next example.</dd>
  <dt>2.</dt>
  <dd>We aren't passing any parameters to <i>PrintUID</i> so G_NOARGS can be
      specified.</dd>
  <dt>3.</dt>
  <dd>We aren't interested in anything returned from <i>PrintUID</i>, so
      G_DISCARD is specified. Even if <i>PrintUID</i> was changed to return some
      value(s), having specified G_DISCARD will mean that they will be wiped by
      the time control returns from <i>call_pv</i>.</dd>
  <dt>4.</dt>
  <dd>As <i>call_pv</i> is being used, the Perl subroutine is specified as a C
      string. In this case the subroutine name has been 'hard-wired' into the
      code.</dd>
  <dt>5.</dt>
  <dd>Because we specified G_DISCARD, it is not necessary to check the value
      returned from <i>call_pv</i>. It will always be 0.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Passing_Parameters"><a class="permalink" href="#Passing_Parameters">Passing
  Parameters</a></h2>
<p class="Pp">Now let's make a slightly more complex example. This time we want
    to call a Perl subroutine, <span class="Li">&quot;LeftString&quot;</span>,
    which will take 2 parameters--a string ($s) and an integer ($n). The
    subroutine will simply print the first <span class="Li">$n</span> characters
    of the string.</p>
<p class="Pp">So the Perl subroutine would look like this:</p>
<p class="Pp"></p>
<pre>    sub LeftString
    {
        my($s, $n) = @_;
        print substr($s, 0, $n), &quot;\n&quot;;
    }
</pre>
<p class="Pp">The C function required to call <i>LeftString</i> would look like
    this:</p>
<p class="Pp"></p>
<pre>    static void
    call_LeftString(a, b)
    char * a;
    int b;
    {
        dSP;
        ENTER;
        SAVETMPS;
        PUSHMARK(SP);
        XPUSHs(sv_2mortal(newSVpv(a, 0)));
        XPUSHs(sv_2mortal(newSViv(b)));
        PUTBACK;
        call_pv(&quot;LeftString&quot;, G_DISCARD);
        FREETMPS;
        LEAVE;
    }
</pre>
<p class="Pp">Here are a few notes on the C function <i>call_LeftString</i>.</p>
<dl class="Bl-tag">
  <dt>1.</dt>
  <dd>Parameters are passed to the Perl subroutine using the Perl stack. This is
      the purpose of the code beginning with the line
      <span class="Li">&quot;dSP&quot;</span> and ending with the line
      <span class="Li">&quot;PUTBACK&quot;</span>. The
      <span class="Li">&quot;dSP&quot;</span> declares a local copy of the stack
      pointer. This local copy should <b>always</b> be accessed as
      <span class="Li">&quot;SP&quot;</span>.</dd>
  <dt>2.</dt>
  <dd>If you are going to put something onto the Perl stack, you need to know
      where to put it. This is the purpose of the macro
      <span class="Li">&quot;dSP&quot;</span>--it declares and initializes a
      <i>local</i> copy of the Perl stack pointer.
    <p class="Pp">All the other macros which will be used in this example
        require you to have used this macro.</p>
    <p class="Pp">The exception to this rule is if you are calling a Perl
        subroutine directly from an XSUB function. In this case it is not
        necessary to use the <span class="Li">&quot;dSP&quot;</span> macro
        explicitly--it will be declared for you automatically.</p>
  </dd>
  <dt>3.</dt>
  <dd>Any parameters to be pushed onto the stack should be bracketed by the
      <span class="Li">&quot;PUSHMARK&quot;</span> and
      <span class="Li">&quot;PUTBACK&quot;</span> macros. The purpose of these
      two macros, in this context, is to count the number of parameters you are
      pushing automatically. Then whenever Perl is creating the
      <span class="Li">@_</span> array for the subroutine, it knows how big to
      make it.
    <p class="Pp">The <span class="Li">&quot;PUSHMARK&quot;</span> macro tells
        Perl to make a mental note of the current stack pointer. Even if you
        aren't passing any parameters (like the example shown in the section
        <i>No Parameters, Nothing Returned</i>) you must still call the
        <span class="Li">&quot;PUSHMARK&quot;</span> macro before you can call
        any of the <i>call_*</i> functions--Perl still needs to know that there
        are no parameters.</p>
    <p class="Pp">The <span class="Li">&quot;PUTBACK&quot;</span> macro sets the
        global copy of the stack pointer to be the same as our local copy. If we
        didn't do this, <i>call_pv</i> wouldn't know where the two parameters we
        pushed were--remember that up to now all the stack pointer manipulation
        we have done is with our local copy, <i>not</i> the global copy.</p>
  </dd>
  <dt>4.</dt>
  <dd>Next, we come to XPUSHs. This is where the parameters actually get pushed
      onto the stack. In this case we are pushing a string and an integer.
    <p class="Pp">See &quot;XSUBs and the Argument Stack&quot; in perlguts for
        details on how the XPUSH macros work.</p>
  </dd>
  <dt>5.</dt>
  <dd>Because we created temporary values (by means of <i>sv_2mortal()</i>
      calls) we will have to tidy up the Perl stack and dispose of mortal SVs.
    <p class="Pp">This is the purpose of</p>
    <p class="Pp"></p>
    <pre>    ENTER;
    SAVETMPS;
    </pre>
    <p class="Pp">at the start of the function, and</p>
    <p class="Pp"></p>
    <pre>    FREETMPS;
    LEAVE;
    </pre>
    <p class="Pp">at the end. The
        <span class="Li">&quot;ENTER&quot;</span>/<span class="Li">&quot;SAVETMPS&quot;</span>
        pair creates a boundary for any temporaries we create. This means that
        the temporaries we get rid of will be limited to those which were
        created after these calls.</p>
    <p class="Pp">The
        <span class="Li">&quot;FREETMPS&quot;</span>/<span class="Li">&quot;LEAVE&quot;</span>
        pair will get rid of any values returned by the Perl subroutine (see
        next example), plus it will also dump the mortal SVs we have created.
        Having
        <span class="Li">&quot;ENTER&quot;</span>/<span class="Li">&quot;SAVETMPS&quot;</span>
        at the beginning of the code makes sure that no other mortals are
        destroyed.</p>
    <p class="Pp">Think of these macros as working a bit like
        <span class="Li">&quot;{&quot;</span> and
        <span class="Li">&quot;}&quot;</span> in Perl to limit the scope of
        local variables.</p>
    <p class="Pp">See the section <i>Using Perl to Dispose of Temporaries</i>
        for details of an alternative to using these macros.</p>
  </dd>
  <dt>6.</dt>
  <dd>Finally, <i>LeftString</i> can now be called via the <i>call_pv</i>
      function. The only flag specified this time is G_DISCARD. Because we are
      passing 2 parameters to the Perl subroutine this time, we have not
      specified G_NOARGS.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Returning_a_Scalar"><a class="permalink" href="#Returning_a_Scalar">Returning
  a Scalar</a></h2>
<p class="Pp">Now for an example of dealing with the items returned from a Perl
    subroutine.</p>
<p class="Pp">Here is a Perl subroutine, <i>Adder</i>, that takes 2 integer
    parameters and simply returns their sum.</p>
<p class="Pp"></p>
<pre>    sub Adder
    {
        my($a, $b) = @_;
        $a + $b;
    }
</pre>
<p class="Pp">Because we are now concerned with the return value from
    <i>Adder</i>, the C function required to call it is now a bit more
  complex.</p>
<p class="Pp"></p>
<pre>    static void
    call_Adder(a, b)
    int a;
    int b;
    {
        dSP;
        int count;
        ENTER;
        SAVETMPS;
        PUSHMARK(SP);
        XPUSHs(sv_2mortal(newSViv(a)));
        XPUSHs(sv_2mortal(newSViv(b)));
        PUTBACK;
        count = call_pv(&quot;Adder&quot;, G_SCALAR);
        SPAGAIN;
        if (count != 1)
            croak(&quot;Big trouble\n&quot;);
        printf (&quot;The sum of %d and %d is %d\n&quot;, a, b, POPi);
        PUTBACK;
        FREETMPS;
        LEAVE;
    }
</pre>
<p class="Pp">Points to note this time are</p>
<dl class="Bl-tag">
  <dt>1.</dt>
  <dd>The only flag specified this time was G_SCALAR. That means that the
      <span class="Li">@_</span> array will be created and that the value
      returned by <i>Adder</i> will still exist after the call to
      <i>call_pv</i>.</dd>
  <dt>2.</dt>
  <dd>The purpose of the macro <span class="Li">&quot;SPAGAIN&quot;</span> is to
      refresh the local copy of the stack pointer. This is necessary because it
      is possible that the memory allocated to the Perl stack has been
      reallocated during the <i>call_pv</i> call.
    <p class="Pp">If you are making use of the Perl stack pointer in your code
        you must always refresh the local copy using SPAGAIN whenever you make
        use of the <i>call_*</i> functions or any other Perl internal
      function.</p>
  </dd>
  <dt>3.</dt>
  <dd>Although only a single value was expected to be returned from
      <i>Adder</i>, it is still good practice to check the return code from
      <i>call_pv</i> anyway.
    <p class="Pp">Expecting a single value is not quite the same as knowing that
        there will be one. If someone modified <i>Adder</i> to return a list and
        we didn't check for that possibility and take appropriate action the
        Perl stack would end up in an inconsistent state. That is something you
        <i>really</i> don't want to happen ever.</p>
  </dd>
  <dt>4.</dt>
  <dd>The <span class="Li">&quot;POPi&quot;</span> macro is used here to pop the
      return value from the stack. In this case we wanted an integer, so
      <span class="Li">&quot;POPi&quot;</span> was used.
    <p class="Pp">Here is the complete list of POP macros available, along with
        the types they return.</p>
    <p class="Pp"></p>
    <pre>    POPs        SV
    POPp        pointer
    POPn        double
    POPi        integer
    POPl        long
    </pre>
  </dd>
  <dt>5.</dt>
  <dd>The final <span class="Li">&quot;PUTBACK&quot;</span> is used to leave the
      Perl stack in a consistent state before exiting the function. This is
      necessary because when we popped the return value from the stack with
      <span class="Li">&quot;POPi&quot;</span> it updated only our local copy of
      the stack pointer. Remember, <span class="Li">&quot;PUTBACK&quot;</span>
      sets the global stack pointer to be the same as our local copy.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Returning_a_List_of_Values"><a class="permalink" href="#Returning_a_List_of_Values">Returning
  a List of Values</a></h2>
<p class="Pp">Now, let's extend the previous example to return both the sum of
    the parameters and the difference.</p>
<p class="Pp">Here is the Perl subroutine</p>
<p class="Pp"></p>
<pre>    sub AddSubtract
    {
       my($a, $b) = @_;
       ($a+$b, $a-$b);
    }
</pre>
<p class="Pp">and this is the C function</p>
<p class="Pp"></p>
<pre>    static void
    call_AddSubtract(a, b)
    int a;
    int b;
    {
        dSP;
        int count;
        ENTER;
        SAVETMPS;
        PUSHMARK(SP);
        XPUSHs(sv_2mortal(newSViv(a)));
        XPUSHs(sv_2mortal(newSViv(b)));
        PUTBACK;
        count = call_pv(&quot;AddSubtract&quot;, G_ARRAY);
        SPAGAIN;
        if (count != 2)
            croak(&quot;Big trouble\n&quot;);
        printf (&quot;%d - %d = %d\n&quot;, a, b, POPi);
        printf (&quot;%d + %d = %d\n&quot;, a, b, POPi);
        PUTBACK;
        FREETMPS;
        LEAVE;
    }
</pre>
<p class="Pp">If <i>call_AddSubtract</i> is called like this</p>
<p class="Pp"></p>
<pre>    call_AddSubtract(7, 4);
</pre>
<p class="Pp">then here is the output</p>
<p class="Pp"></p>
<pre>    7 - 4 = 3
    7 + 4 = 11
</pre>
<p class="Pp">Notes</p>
<dl class="Bl-tag">
  <dt>1.</dt>
  <dd>We wanted list context, so G_ARRAY was used.</dd>
  <dt>2.</dt>
  <dd>Not surprisingly <span class="Li">&quot;POPi&quot;</span> is used twice
      this time because we were retrieving 2 values from the stack. The
      important thing to note is that when using the
      <span class="Li">&quot;POP*&quot;</span> macros they come off the stack in
      <i>reverse</i> order.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Returning_a_List_in_a_Scalar_Context"><a class="permalink" href="#Returning_a_List_in_a_Scalar_Context">Returning
  a List in a Scalar Context</a></h2>
<p class="Pp">Say the Perl subroutine in the previous section was called in a
    scalar context, like this</p>
<p class="Pp"></p>
<pre>    static void
    call_AddSubScalar(a, b)
    int a;
    int b;
    {
        dSP;
        int count;
        int i;
        ENTER;
        SAVETMPS;
        PUSHMARK(SP);
        XPUSHs(sv_2mortal(newSViv(a)));
        XPUSHs(sv_2mortal(newSViv(b)));
        PUTBACK;
        count = call_pv(&quot;AddSubtract&quot;, G_SCALAR);
        SPAGAIN;
        printf (&quot;Items Returned = %d\n&quot;, count);
        for (i = 1; i &lt;= count; ++i)
            printf (&quot;Value %d = %d\n&quot;, i, POPi);
        PUTBACK;
        FREETMPS;
        LEAVE;
    }
</pre>
<p class="Pp">The other modification made is that <i>call_AddSubScalar</i> will
    print the number of items returned from the Perl subroutine and their value
    (for simplicity it assumes that they are integer). So if
    <i>call_AddSubScalar</i> is called</p>
<p class="Pp"></p>
<pre>    call_AddSubScalar(7, 4);
</pre>
<p class="Pp">then the output will be</p>
<p class="Pp"></p>
<pre>    Items Returned = 1
    Value 1 = 3
</pre>
<p class="Pp">In this case the main point to note is that only the last item in
    the list is returned from the subroutine. <i>AddSubtract</i> actually made
    it back to <i>call_AddSubScalar</i>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Returning_Data_from_Perl_via_the_Parameter_List"><a class="permalink" href="#Returning_Data_from_Perl_via_the_Parameter_List">Returning
  Data from Perl via the Parameter List</a></h2>
<p class="Pp">It is also possible to return values directly via the parameter
    list--whether it is actually desirable to do it is another matter
  entirely.</p>
<p class="Pp">The Perl subroutine, <i>Inc</i>, below takes 2 parameters and
    increments each directly.</p>
<p class="Pp"></p>
<pre>    sub Inc
    {
        ++ $_[0];
        ++ $_[1];
    }
</pre>
<p class="Pp">and here is a C function to call it.</p>
<p class="Pp"></p>
<pre>    static void
    call_Inc(a, b)
    int a;
    int b;
    {
        dSP;
        int count;
        SV * sva;
        SV * svb;
        ENTER;
        SAVETMPS;
        sva = sv_2mortal(newSViv(a));
        svb = sv_2mortal(newSViv(b));
        PUSHMARK(SP);
        XPUSHs(sva);
        XPUSHs(svb);
        PUTBACK;
        count = call_pv(&quot;Inc&quot;, G_DISCARD);
        if (count != 0)
            croak (&quot;call_Inc: expected 0 values from 'Inc', got %d\n&quot;,
                   count);
        printf (&quot;%d + 1 = %d\n&quot;, a, SvIV(sva));
        printf (&quot;%d + 1 = %d\n&quot;, b, SvIV(svb));
        FREETMPS;
        LEAVE;
    }
</pre>
<p class="Pp">To be able to access the two parameters that were pushed onto the
    stack after they return from <i>call_pv</i> it is necessary to make a note
    of their addresses--thus the two variables
    <span class="Li">&quot;sva&quot;</span> and
    <span class="Li">&quot;svb&quot;</span>.</p>
<p class="Pp">The reason this is necessary is that the area of the Perl stack
    which held them will very likely have been overwritten by something else by
    the time control returns from <i>call_pv</i>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Using_G_EVAL"><a class="permalink" href="#Using_G_EVAL">Using
  G_EVAL</a></h2>
<p class="Pp">Now an example using G_EVAL. Below is a Perl subroutine which
    computes the difference of its 2 parameters. If this would result in a
    negative result, the subroutine calls <i>die</i>.</p>
<p class="Pp"></p>
<pre>    sub Subtract
    {
        my ($a, $b) = @_;
        die &quot;death can be fatal\n&quot; if $a &lt; $b;
        $a - $b;
    }
</pre>
<p class="Pp">and some C to call it</p>
<p class="Pp"></p>
<pre>    static void
    call_Subtract(a, b)
    int a;
    int b;
    {
        dSP;
        int count;
        ENTER;
        SAVETMPS;
        PUSHMARK(SP);
        XPUSHs(sv_2mortal(newSViv(a)));
        XPUSHs(sv_2mortal(newSViv(b)));
        PUTBACK;
        count = call_pv(&quot;Subtract&quot;, G_EVAL|G_SCALAR);
        SPAGAIN;
        /* Check the eval first */
        if (SvTRUE(ERRSV))
        {
            printf (&quot;Uh oh - %s\n&quot;, SvPV_nolen(ERRSV));
            POPs;
        }
        else
        {
            if (count != 1)
               croak(&quot;call_Subtract: wanted 1 value from 'Subtract', got %d\n&quot;,
                        count);
            printf (&quot;%d - %d = %d\n&quot;, a, b, POPi);
        }
        PUTBACK;
        FREETMPS;
        LEAVE;
    }
</pre>
<p class="Pp">If <i>call_Subtract</i> is called thus</p>
<p class="Pp"></p>
<pre>    call_Subtract(4, 5)
</pre>
<p class="Pp">the following will be printed</p>
<p class="Pp"></p>
<pre>    Uh oh - death can be fatal
</pre>
<p class="Pp">Notes</p>
<dl class="Bl-tag">
  <dt>1.</dt>
  <dd>We want to be able to catch the <i>die</i> so we have used the G_EVAL
      flag. Not specifying this flag would mean that the program would terminate
      immediately at the <i>die</i> statement in the subroutine
    <i>Subtract</i>.</dd>
  <dt>2.</dt>
  <dd>The code
    <p class="Pp"></p>
    <pre>    if (SvTRUE(ERRSV))
    {
        printf (&quot;Uh oh - %s\n&quot;, SvPV_nolen(ERRSV));
        POPs;
    }
    </pre>
    <p class="Pp">is the direct equivalent of this bit of Perl</p>
    <p class="Pp"></p>
    <pre>    print &quot;Uh oh - $@\n&quot; if $@;
    </pre>
    <p class="Pp"><span class="Li">&quot;PL_errgv&quot;</span> is a perl global
        of type <span class="Li">&quot;GV *&quot;</span> that points to the
        symbol table entry containing the error.
        <span class="Li">&quot;ERRSV&quot;</span> therefore refers to the C
        equivalent of <span class="Li">$@</span>.</p>
  </dd>
  <dt>3.</dt>
  <dd>Note that the stack is popped using
      <span class="Li">&quot;POPs&quot;</span> in the block where
      <span class="Li">&quot;SvTRUE(ERRSV)&quot;</span> is true. This is
      necessary because whenever a <i>call_*</i> function invoked with
      G_EVAL|G_SCALAR returns an error, the top of the stack holds the value
      <i>undef</i>. Because we want the program to continue after detecting this
      error, it is essential that the stack be tidied up by removing the
      <i>undef</i>.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Using_G_KEEPERR"><a class="permalink" href="#Using_G_KEEPERR">Using
  G_KEEPERR</a></h2>
<p class="Pp">Consider this rather facetious example, where we have used an XS
    version of the call_Subtract example above inside a destructor:</p>
<p class="Pp"></p>
<pre>    package Foo;
    sub new { bless {}, $_[0] }
    sub Subtract {
        my($a,$b) = @_;
        die &quot;death can be fatal&quot; if $a &lt; $b;
        $a - $b;
    }
    sub DESTROY { call_Subtract(5, 4); }
    sub foo { die &quot;foo dies&quot;; }
    package main;
    {
        my $foo = Foo-&gt;new;
        eval { $foo-&gt;foo };
    }
    print &quot;Saw: $@&quot; if $@;             # should be, but isn't
</pre>
<p class="Pp">This example will fail to recognize that an error occurred inside
    the <span class="Li">&quot;eval {}&quot;</span>. Here's why: the
    call_Subtract code got executed while perl was cleaning up temporaries when
    exiting the outer braced block, and because call_Subtract is implemented
    with <i>call_pv</i> using the G_EVAL flag, it promptly reset
    <span class="Li">$@</span>. This results in the failure of the outermost
    test for <span class="Li">$@</span>, and thereby the failure of the error
    trap.</p>
<p class="Pp">Appending the G_KEEPERR flag, so that the <i>call_pv</i> call in
    call_Subtract reads:</p>
<p class="Pp"></p>
<pre>        count = call_pv(&quot;Subtract&quot;, G_EVAL|G_SCALAR|G_KEEPERR);
</pre>
<p class="Pp">will preserve the error and restore reliable error handling.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Using_call_sv"><a class="permalink" href="#Using_call_sv">Using
  call_sv</a></h2>
<p class="Pp">In all the previous examples I have 'hard-wired' the name of the
    Perl subroutine to be called from C. Most of the time though, it is more
    convenient to be able to specify the name of the Perl subroutine from within
    the Perl script.</p>
<p class="Pp">Consider the Perl code below</p>
<p class="Pp"></p>
<pre>    sub fred
    {
        print &quot;Hello there\n&quot;;
    }
    CallSubPV(&quot;fred&quot;);
</pre>
<p class="Pp">Here is a snippet of XSUB which defines <i>CallSubPV</i>.</p>
<p class="Pp"></p>
<pre>    void
    CallSubPV(name)
        char *  name
        CODE:
        PUSHMARK(SP);
        call_pv(name, G_DISCARD|G_NOARGS);
</pre>
<p class="Pp">That is fine as far as it goes. The thing is, the Perl subroutine
    can be specified as only a string, however, Perl allows references to
    subroutines and anonymous subroutines. This is where <i>call_sv</i> is
    useful.</p>
<p class="Pp">The code below for <i>CallSubSV</i> is identical to
    <i>CallSubPV</i> except that the <span class="Li">&quot;name&quot;</span>
    parameter is now defined as an SV* and we use <i>call_sv</i> instead of
    <i>call_pv</i>.</p>
<p class="Pp"></p>
<pre>    void
    CallSubSV(name)
        SV *    name
        CODE:
        PUSHMARK(SP);
        call_sv(name, G_DISCARD|G_NOARGS);
</pre>
<p class="Pp">Because we are using an SV to call <i>fred</i> the following can
    all be used:</p>
<p class="Pp"></p>
<pre>    CallSubSV(&quot;fred&quot;);
    CallSubSV(\&amp;fred);
    $ref = \&amp;fred;
    CallSubSV($ref);
    CallSubSV( sub { print &quot;Hello there\n&quot; } );
</pre>
<p class="Pp">As you can see, <i>call_sv</i> gives you much greater flexibility
    in how you can specify the Perl subroutine.</p>
<p class="Pp">You should note that, if it is necessary to store the SV
    (<span class="Li">&quot;name&quot;</span> in the example above) which
    corresponds to the Perl subroutine so that it can be used later in the
    program, it not enough just to store a copy of the pointer to the SV. Say
    the code above had been like this:</p>
<p class="Pp"></p>
<pre>    static SV * rememberSub;
    void
    SaveSub1(name)
        SV *    name
        CODE:
        rememberSub = name;
    void
    CallSavedSub1()
        CODE:
        PUSHMARK(SP);
        call_sv(rememberSub, G_DISCARD|G_NOARGS);
</pre>
<p class="Pp">The reason this is wrong is that, by the time you come to use the
    pointer <span class="Li">&quot;rememberSub&quot;</span> in
    <span class="Li">&quot;CallSavedSub1&quot;</span>, it may or may not still
    refer to the Perl subroutine that was recorded in
    <span class="Li">&quot;SaveSub1&quot;</span>. This is particularly true for
    these cases:</p>
<p class="Pp"></p>
<pre>    SaveSub1(\&amp;fred);
    CallSavedSub1();
    SaveSub1( sub { print &quot;Hello there\n&quot; } );
    CallSavedSub1();
</pre>
<p class="Pp">By the time each of the
    <span class="Li">&quot;SaveSub1&quot;</span> statements above has been
    executed, the SV*s which corresponded to the parameters will no longer
    exist. Expect an error message from Perl of the form</p>
<p class="Pp"></p>
<pre>    Can't use an undefined value as a subroutine reference at ...
</pre>
<p class="Pp">for each of the <span class="Li">&quot;CallSavedSub1&quot;</span>
    lines.</p>
<p class="Pp">Similarly, with this code</p>
<p class="Pp"></p>
<pre>    $ref = \&amp;fred;
    SaveSub1($ref);
    $ref = 47;
    CallSavedSub1();
</pre>
<p class="Pp">you can expect one of these messages (which you actually get is
    dependent on the version of Perl you are using)</p>
<p class="Pp"></p>
<pre>    Not a CODE reference at ...
    Undefined subroutine &amp;main::47 called ...
</pre>
<p class="Pp">The variable <span class="Li">$ref</span> may have referred to the
    subroutine <span class="Li">&quot;fred&quot;</span> whenever the call to
    <span class="Li">&quot;SaveSub1&quot;</span> was made but by the time
    <span class="Li">&quot;CallSavedSub1&quot;</span> gets called it now holds
    the number <span class="Li">47</span>. Because we saved only a pointer to
    the original SV in <span class="Li">&quot;SaveSub1&quot;</span>, any changes
    to <span class="Li">$ref</span> will be tracked by the pointer
    <span class="Li">&quot;rememberSub&quot;</span>. This means that whenever
    <span class="Li">&quot;CallSavedSub1&quot;</span> gets called, it will
    attempt to execute the code which is referenced by the SV*
    <span class="Li">&quot;rememberSub&quot;</span>. In this case though, it now
    refers to the integer <span class="Li">47</span>, so expect Perl to complain
    loudly.</p>
<p class="Pp">A similar but more subtle problem is illustrated with this
  code:</p>
<p class="Pp"></p>
<pre>    $ref = \&amp;fred;
    SaveSub1($ref);
    $ref = \&amp;joe;
    CallSavedSub1();
</pre>
<p class="Pp">This time whenever
    <span class="Li">&quot;CallSavedSub1&quot;</span> gets called it will
    execute the Perl subroutine <span class="Li">&quot;joe&quot;</span>
    (assuming it exists) rather than <span class="Li">&quot;fred&quot;</span> as
    was originally requested in the call to
    <span class="Li">&quot;SaveSub1&quot;</span>.</p>
<p class="Pp">To get around these problems it is necessary to take a full copy
    of the SV. The code below shows <span class="Li">&quot;SaveSub2&quot;</span>
    modified to do that.</p>
<p class="Pp"></p>
<pre>    static SV * keepSub = (SV*)NULL;
    void
    SaveSub2(name)
        SV *    name
        CODE:
        /* Take a copy of the callback */
        if (keepSub == (SV*)NULL)
            /* First time, so create a new SV */
            keepSub = newSVsv(name);
        else
            /* Been here before, so overwrite */
            SvSetSV(keepSub, name);
    void
    CallSavedSub2()
        CODE:
        PUSHMARK(SP);
        call_sv(keepSub, G_DISCARD|G_NOARGS);
</pre>
<p class="Pp">To avoid creating a new SV every time
    <span class="Li">&quot;SaveSub2&quot;</span> is called, the function first
    checks to see if it has been called before. If not, then space for a new SV
    is allocated and the reference to the Perl subroutine
    <span class="Li">&quot;name&quot;</span> is copied to the variable
    <span class="Li">&quot;keepSub&quot;</span> in one operation using
    <span class="Li">&quot;newSVsv&quot;</span>. Thereafter, whenever
    <span class="Li">&quot;SaveSub2&quot;</span> is called, the existing SV,
    <span class="Li">&quot;keepSub&quot;</span>, is overwritten with the new
    value using <span class="Li">&quot;SvSetSV&quot;</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Using_call_argv"><a class="permalink" href="#Using_call_argv">Using
  call_argv</a></h2>
<p class="Pp">Here is a Perl subroutine which prints whatever parameters are
    passed to it.</p>
<p class="Pp"></p>
<pre>    sub PrintList
    {
        my(@list) = @_;
        foreach (@list) { print &quot;$_\n&quot; }
    }
</pre>
<p class="Pp">And here is an example of <i>call_argv</i> which will call
    <i>PrintList</i>.</p>
<p class="Pp"></p>
<pre>    static char * words[] = {&quot;alpha&quot;, &quot;beta&quot;, &quot;gamma&quot;, &quot;delta&quot;, NULL};
    static void
    call_PrintList()
    {
        dSP;
        call_argv(&quot;PrintList&quot;, G_DISCARD, words);
    }
</pre>
<p class="Pp">Note that it is not necessary to call
    <span class="Li">&quot;PUSHMARK&quot;</span> in this instance. This is
    because <i>call_argv</i> will do it for you.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Using_call_method"><a class="permalink" href="#Using_call_method">Using
  call_method</a></h2>
<p class="Pp">Consider the following Perl code:</p>
<p class="Pp"></p>
<pre>    {
        package Mine;
        sub new
        {
            my($type) = shift;
            bless [@_]
        }
        sub Display
        {
            my ($self, $index) = @_;
            print &quot;$index: $$self[$index]\n&quot;;
        }
        sub PrintID
        {
            my($class) = @_;
            print &quot;This is Class $class version 1.0\n&quot;;
        }
    }
</pre>
<p class="Pp">It implements just a very simple class to manage an array. Apart
    from the constructor, <span class="Li">&quot;new&quot;</span>, it declares
    methods, one static and one virtual. The static method,
    <span class="Li">&quot;PrintID&quot;</span>, prints out simply the class
    name and a version number. The virtual method,
    <span class="Li">&quot;Display&quot;</span>, prints out a single element of
    the array. Here is an all-Perl example of using it.</p>
<p class="Pp"></p>
<pre>    $a = Mine-&gt;new('red', 'green', 'blue');
    $a-&gt;Display(1);
    Mine-&gt;PrintID;
</pre>
<p class="Pp">will print</p>
<p class="Pp"></p>
<pre>    1: green
    This is Class Mine version 1.0
</pre>
<p class="Pp">Calling a Perl method from C is fairly straightforward. The
    following things are required:</p>
<ul class="Bl-bullet">
  <li>A reference to the object for a virtual method or the name of the class
      for a static method</li>
  <li>The name of the method</li>
  <li>Any other parameters specific to the method</li>
</ul>
<p class="Pp">Here is a simple XSUB which illustrates the mechanics of calling
    both the <span class="Li">&quot;PrintID&quot;</span> and
    <span class="Li">&quot;Display&quot;</span> methods from C.</p>
<p class="Pp"></p>
<pre>    void
    call_Method(ref, method, index)
        SV *    ref
        char *  method
        int             index
        CODE:
        PUSHMARK(SP);
        XPUSHs(ref);
        XPUSHs(sv_2mortal(newSViv(index)));
        PUTBACK;
        call_method(method, G_DISCARD);
    void
    call_PrintID(class, method)
        char *  class
        char *  method
        CODE:
        PUSHMARK(SP);
        XPUSHs(sv_2mortal(newSVpv(class, 0)));
        PUTBACK;
        call_method(method, G_DISCARD);
</pre>
<p class="Pp">So the methods <span class="Li">&quot;PrintID&quot;</span> and
    <span class="Li">&quot;Display&quot;</span> can be invoked like this:</p>
<p class="Pp"></p>
<pre>    $a = Mine-&gt;new('red', 'green', 'blue');
    call_Method($a, 'Display', 1);
    call_PrintID('Mine', 'PrintID');
</pre>
<p class="Pp">The only thing to note is that, in both the static and virtual
    methods, the method name is not passed via the stack--it is used as the
    first parameter to <i>call_method</i>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Using_"><a class="permalink" href="#Using_">Using
  GIMME_V</a></h2>
<p class="Pp">Here is a trivial XSUB which prints the context in which it is
    currently executing.</p>
<p class="Pp"></p>
<pre>    void
    PrintContext()
        CODE:
        I32 gimme = GIMME_V;
        if (gimme == G_VOID)
            printf (&quot;Context is Void\n&quot;);
        else if (gimme == G_SCALAR)
            printf (&quot;Context is Scalar\n&quot;);
        else
            printf (&quot;Context is Array\n&quot;);
</pre>
<p class="Pp">And here is some Perl to test it.</p>
<p class="Pp"></p>
<pre>    PrintContext;
    $a = PrintContext;
    @a = PrintContext;
</pre>
<p class="Pp">The output from that will be</p>
<p class="Pp"></p>
<pre>    Context is Void
    Context is Scalar
    Context is Array
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Using_Perl_to_Dispose_of_Temporaries"><a class="permalink" href="#Using_Perl_to_Dispose_of_Temporaries">Using
  Perl to Dispose of Temporaries</a></h2>
<p class="Pp">In the examples given to date, any temporaries created in the
    callback (i.e., parameters passed on the stack to the <i>call_*</i> function
    or values returned via the stack) have been freed by one of these
  methods:</p>
<ul class="Bl-bullet">
  <li>Specifying the G_DISCARD flag with <i>call_*</i></li>
  <li>Explicitly using the
      <span class="Li">&quot;ENTER&quot;</span>/<span class="Li">&quot;SAVETMPS&quot;</span>--<span class="Li">&quot;FREETMPS&quot;</span>/<span class="Li">&quot;LEAVE&quot;</span>
      pairing</li>
</ul>
<p class="Pp">There is another method which can be used, namely letting Perl do
    it for you automatically whenever it regains control after the callback has
    terminated. This is done by simply not using the</p>
<p class="Pp"></p>
<pre>    ENTER;
    SAVETMPS;
    ...
    FREETMPS;
    LEAVE;
</pre>
<p class="Pp">sequence in the callback (and not, of course, specifying the
    G_DISCARD flag).</p>
<p class="Pp">If you are going to use this method you have to be aware of a
    possible memory leak which can arise under very specific circumstances. To
    explain these circumstances you need to know a bit about the flow of control
    between Perl and the callback routine.</p>
<p class="Pp">The examples given at the start of the document (an error handler
    and an event driven program) are typical of the two main sorts of flow
    control that you are likely to encounter with callbacks. There is a very
    important distinction between them, so pay attention.</p>
<p class="Pp">In the first example, an error handler, the flow of control could
    be as follows. You have created an interface to an external library. Control
    can reach the external library like this</p>
<p class="Pp"></p>
<pre>    perl --&gt; XSUB --&gt; external library
</pre>
<p class="Pp">Whilst control is in the library, an error condition occurs. You
    have previously set up a Perl callback to handle this situation, so it will
    get executed. Once the callback has finished, control will drop back to Perl
    again. Here is what the flow of control will be like in that situation</p>
<p class="Pp"></p>
<pre>    perl --&gt; XSUB --&gt; external library
                      ...
                      error occurs
                      ...
                      external library --&gt; call_* --&gt; perl
                                                          |
    perl &lt;-- XSUB &lt;-- external library &lt;-- call_* &lt;----+
</pre>
<p class="Pp">After processing of the error using <i>call_*</i> is completed,
    control reverts back to Perl more or less immediately.</p>
<p class="Pp">In the diagram, the further right you go the more deeply nested
    the scope is. It is only when control is back with perl on the extreme left
    of the diagram that you will have dropped back to the enclosing scope and
    any temporaries you have left hanging around will be freed.</p>
<p class="Pp">In the second example, an event driven program, the flow of
    control will be more like this</p>
<p class="Pp"></p>
<pre>    perl --&gt; XSUB --&gt; event handler
                      ...
                      event handler --&gt; call_* --&gt; perl
                                                       |
                      event handler &lt;-- call_* &lt;----+
                      ...
                      event handler --&gt; call_* --&gt; perl
                                                       |
                      event handler &lt;-- call_* &lt;----+
                      ...
                      event handler --&gt; call_* --&gt; perl
                                                       |
                      event handler &lt;-- call_* &lt;----+
</pre>
<p class="Pp">In this case the flow of control can consist of only the repeated
    sequence</p>
<p class="Pp"></p>
<pre>    event handler --&gt; call_* --&gt; perl
</pre>
<p class="Pp">for practically the complete duration of the program. This means
    that control may <i>never</i> drop back to the surrounding scope in Perl at
    the extreme left.</p>
<p class="Pp">So what is the big problem? Well, if you are expecting Perl to
    tidy up those temporaries for you, you might be in for a long wait. For Perl
    to dispose of your temporaries, control must drop back to the enclosing
    scope at some stage. In the event driven scenario that may never happen.
    This means that, as time goes on, your program will create more and more
    temporaries, none of which will ever be freed. As each of these temporaries
    consumes some memory your program will eventually consume all the available
    memory in your system--kapow!</p>
<p class="Pp">So here is the bottom line--if you are sure that control will
    revert back to the enclosing Perl scope fairly quickly after the end of your
    callback, then it isn't absolutely necessary to dispose explicitly of any
    temporaries you may have created. Mind you, if you are at all uncertain
    about what to do, it doesn't do any harm to tidy up anyway.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Strategies_for_Storing_Callback_Context_Information"><a class="permalink" href="#Strategies_for_Storing_Callback_Context_Information">Strategies
  for Storing Callback Context Information</a></h2>
<p class="Pp">Potentially one of the trickiest problems to overcome when
    designing a callback interface can be figuring out how to store the mapping
    between the C callback function and the Perl equivalent.</p>
<p class="Pp">To help understand why this can be a real problem first consider
    how a callback is set up in an all C environment. Typically a C API will
    provide a function to register a callback. This will expect a pointer to a
    function as one of its parameters. Below is a call to a hypothetical
    function <span class="Li">&quot;register_fatal&quot;</span> which registers
    the C function to get called when a fatal error occurs.</p>
<p class="Pp"></p>
<pre>    register_fatal(cb1);
</pre>
<p class="Pp">The single parameter <span class="Li">&quot;cb1&quot;</span> is a
    pointer to a function, so you must have defined
    <span class="Li">&quot;cb1&quot;</span> in your code, say something like
    this</p>
<p class="Pp"></p>
<pre>    static void
    cb1()
    {
        printf (&quot;Fatal Error\n&quot;);
        exit(1);
    }
</pre>
<p class="Pp">Now change that to call a Perl subroutine instead</p>
<p class="Pp"></p>
<pre>    static SV * callback = (SV*)NULL;
    static void
    cb1()
    {
        dSP;
        PUSHMARK(SP);
        /* Call the Perl sub to process the callback */
        call_sv(callback, G_DISCARD);
    }
    void
    register_fatal(fn)
        SV *    fn
        CODE:
        /* Remember the Perl sub */
        if (callback == (SV*)NULL)
            callback = newSVsv(fn);
        else
            SvSetSV(callback, fn);
        /* register the callback with the external library */
        register_fatal(cb1);
</pre>
<p class="Pp">where the Perl equivalent of
    <span class="Li">&quot;register_fatal&quot;</span> and the callback it
    registers, <span class="Li">&quot;pcb1&quot;</span>, might look like
  this</p>
<p class="Pp"></p>
<pre>    # Register the sub pcb1
    register_fatal(\&amp;pcb1);
    sub pcb1
    {
        die &quot;I'm dying...\n&quot;;
    }
</pre>
<p class="Pp">The mapping between the C callback and the Perl equivalent is
    stored in the global variable
  <span class="Li">&quot;callback&quot;</span>.</p>
<p class="Pp">This will be adequate if you ever need to have only one callback
    registered at any time. An example could be an error handler like the code
    sketched out above. Remember though, repeated calls to
    <span class="Li">&quot;register_fatal&quot;</span> will replace the
    previously registered callback function with the new one.</p>
<p class="Pp">Say for example you want to interface to a library which allows
    asynchronous file i/o. In this case you may be able to register a callback
    whenever a read operation has completed. To be of any use we want to be able
    to call separate Perl subroutines for each file that is opened. As it
    stands, the error handler example above would not be adequate as it allows
    only a single callback to be defined at any time. What we require is a means
    of storing the mapping between the opened file and the Perl subroutine we
    want to be called for that file.</p>
<p class="Pp">Say the i/o library has a function
    <span class="Li">&quot;asynch_read&quot;</span> which associates a C
    function <span class="Li">&quot;ProcessRead&quot;</span> with a file handle
    <span class="Li">&quot;fh&quot;</span>--this assumes that it has also
    provided some routine to open the file and so obtain the file handle.</p>
<p class="Pp"></p>
<pre>    asynch_read(fh, ProcessRead)
</pre>
<p class="Pp">This may expect the C <i>ProcessRead</i> function of this form</p>
<p class="Pp"></p>
<pre>    void
    ProcessRead(fh, buffer)
    int fh;
    char *      buffer;
    {
         ...
    }
</pre>
<p class="Pp">To provide a Perl interface to this library we need to be able to
    map between the <span class="Li">&quot;fh&quot;</span> parameter and the
    Perl subroutine we want called. A hash is a convenient mechanism for storing
    this mapping. The code below shows a possible implementation</p>
<p class="Pp"></p>
<pre>    static HV * Mapping = (HV*)NULL;
    void
    asynch_read(fh, callback)
        int     fh
        SV *    callback
        CODE:
        /* If the hash doesn't already exist, create it */
        if (Mapping == (HV*)NULL)
            Mapping = newHV();
        /* Save the fh -&gt; callback mapping */
        hv_store(Mapping, (char*)&amp;fh, sizeof(fh), newSVsv(callback), 0);
        /* Register with the C Library */
        asynch_read(fh, asynch_read_if);
</pre>
<p class="Pp">and <span class="Li">&quot;asynch_read_if&quot;</span> could look
    like this</p>
<p class="Pp"></p>
<pre>    static void
    asynch_read_if(fh, buffer)
    int fh;
    char *      buffer;
    {
        dSP;
        SV ** sv;
        /* Get the callback associated with fh */
        sv =  hv_fetch(Mapping, (char*)&amp;fh , sizeof(fh), FALSE);
        if (sv == (SV**)NULL)
            croak(&quot;Internal error...\n&quot;);
        PUSHMARK(SP);
        XPUSHs(sv_2mortal(newSViv(fh)));
        XPUSHs(sv_2mortal(newSVpv(buffer, 0)));
        PUTBACK;
        /* Call the Perl sub */
        call_sv(*sv, G_DISCARD);
    }
</pre>
<p class="Pp">For completeness, here is
    <span class="Li">&quot;asynch_close&quot;</span>. This shows how to remove
    the entry from the hash <span class="Li">&quot;Mapping&quot;</span>.</p>
<p class="Pp"></p>
<pre>    void
    asynch_close(fh)
        int     fh
        CODE:
        /* Remove the entry from the hash */
        (void) hv_delete(Mapping, (char*)&amp;fh, sizeof(fh), G_DISCARD);
        /* Now call the real asynch_close */
        asynch_close(fh);
</pre>
<p class="Pp">So the Perl interface would look like this</p>
<p class="Pp"></p>
<pre>    sub callback1
    {
        my($handle, $buffer) = @_;
    }
    # Register the Perl callback
    asynch_read($fh, \&amp;callback1);
    asynch_close($fh);
</pre>
<p class="Pp">The mapping between the C callback and Perl is stored in the
    global hash <span class="Li">&quot;Mapping&quot;</span> this time. Using a
    hash has the distinct advantage that it allows an unlimited number of
    callbacks to be registered.</p>
<p class="Pp">What if the interface provided by the C callback doesn't contain a
    parameter which allows the file handle to Perl subroutine mapping? Say in
    the asynchronous i/o package, the callback function gets passed only the
    <span class="Li">&quot;buffer&quot;</span> parameter like this</p>
<p class="Pp"></p>
<pre>    void
    ProcessRead(buffer)
    char *      buffer;
    {
        ...
    }
</pre>
<p class="Pp">Without the file handle there is no straightforward way to map
    from the C callback to the Perl subroutine.</p>
<p class="Pp">In this case a possible way around this problem is to predefine a
    series of C functions to act as the interface to Perl, thus</p>
<p class="Pp"></p>
<pre>    #define MAX_CB              3
    #define NULL_HANDLE -1
    typedef void (*FnMap)();
    struct MapStruct {
        FnMap    Function;
        SV *     PerlSub;
        int      Handle;
      };
    static void  fn1();
    static void  fn2();
    static void  fn3();
    static struct MapStruct Map [MAX_CB] =
        {
            { fn1, NULL, NULL_HANDLE },
            { fn2, NULL, NULL_HANDLE },
            { fn3, NULL, NULL_HANDLE }
        };
    static void
    Pcb(index, buffer)
    int index;
    char * buffer;
    {
        dSP;
        PUSHMARK(SP);
        XPUSHs(sv_2mortal(newSVpv(buffer, 0)));
        PUTBACK;
        /* Call the Perl sub */
        call_sv(Map[index].PerlSub, G_DISCARD);
    }
    static void
    fn1(buffer)
    char * buffer;
    {
        Pcb(0, buffer);
    }
    static void
    fn2(buffer)
    char * buffer;
    {
        Pcb(1, buffer);
    }
    static void
    fn3(buffer)
    char * buffer;
    {
        Pcb(2, buffer);
    }
    void
    array_asynch_read(fh, callback)
        int             fh
        SV *    callback
        CODE:
        int index;
        int null_index = MAX_CB;
        /* Find the same handle or an empty entry */
        for (index = 0; index &lt; MAX_CB; ++index)
        {
            if (Map[index].Handle == fh)
                break;
            if (Map[index].Handle == NULL_HANDLE)
                null_index = index;
        }
        if (index == MAX_CB &amp;&amp; null_index == MAX_CB)
            croak (&quot;Too many callback functions registered\n&quot;);
        if (index == MAX_CB)
            index = null_index;
        /* Save the file handle */
        Map[index].Handle = fh;
        /* Remember the Perl sub */
        if (Map[index].PerlSub == (SV*)NULL)
            Map[index].PerlSub = newSVsv(callback);
        else
            SvSetSV(Map[index].PerlSub, callback);
        asynch_read(fh, Map[index].Function);
    void
    array_asynch_close(fh)
        int     fh
        CODE:
        int index;
        /* Find the file handle */
        for (index = 0; index &lt; MAX_CB; ++ index)
            if (Map[index].Handle == fh)
                break;
        if (index == MAX_CB)
            croak (&quot;could not close fh %d\n&quot;, fh);
        Map[index].Handle = NULL_HANDLE;
        SvREFCNT_dec(Map[index].PerlSub);
        Map[index].PerlSub = (SV*)NULL;
        asynch_close(fh);
</pre>
<p class="Pp">In this case the functions
    <span class="Li">&quot;fn1&quot;</span>,
    <span class="Li">&quot;fn2&quot;</span>, and
    <span class="Li">&quot;fn3&quot;</span> are used to remember the Perl
    subroutine to be called. Each of the functions holds a separate hard-wired
    index which is used in the function <span class="Li">&quot;Pcb&quot;</span>
    to access the <span class="Li">&quot;Map&quot;</span> array and actually
    call the Perl subroutine.</p>
<p class="Pp">There are some obvious disadvantages with this technique.</p>
<p class="Pp">Firstly, the code is considerably more complex than with the
    previous example.</p>
<p class="Pp">Secondly, there is a hard-wired limit (in this case 3) to the
    number of callbacks that can exist simultaneously. The only way to increase
    the limit is by modifying the code to add more functions and then
    recompiling. None the less, as long as the number of functions is chosen
    with some care, it is still a workable solution and in some cases is the
    only one available.</p>
<p class="Pp">To summarize, here are a number of possible methods for you to
    consider for storing the mapping between C and the Perl callback</p>
<dl class="Bl-tag">
  <dt>1. Ignore the problem - Allow only 1 callback</dt>
  <dd>For a lot of situations, like interfacing to an error handler, this may be
      a perfectly adequate solution.</dd>
  <dt>2. Create a sequence of callbacks - hard wired limit</dt>
  <dd>If it is impossible to tell from the parameters passed back from the C
      callback what the context is, then you may need to create a sequence of C
      callback interface functions, and store pointers to each in an array.</dd>
  <dt>3. Use a parameter to map to the Perl callback</dt>
  <dd>A hash is an ideal mechanism to store the mapping between C and Perl.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Alternate_Stack_Manipulation"><a class="permalink" href="#Alternate_Stack_Manipulation">Alternate
  Stack Manipulation</a></h2>
<p class="Pp">Although I have made use of only the
    <span class="Li">&quot;POP*&quot;</span> macros to access values returned
    from Perl subroutines, it is also possible to bypass these macros and read
    the stack using the <span class="Li">&quot;ST&quot;</span> macro (See perlxs
    for a full description of the <span class="Li">&quot;ST&quot;</span>
  macro).</p>
<p class="Pp">Most of the time the <span class="Li">&quot;POP*&quot;</span>
    macros should be adequate; the main problem with them is that they force you
    to process the returned values in sequence. This may not be the most
    suitable way to process the values in some cases. What we want is to be able
    to access the stack in a random order. The
    <span class="Li">&quot;ST&quot;</span> macro as used when coding an XSUB is
    ideal for this purpose.</p>
<p class="Pp">The code below is the example given in the section <i>Returning a
    List</i> <i>of Values</i> recoded to use
    <span class="Li">&quot;ST&quot;</span> instead of
    <span class="Li">&quot;POP*&quot;</span>.</p>
<p class="Pp"></p>
<pre>    static void
    call_AddSubtract2(a, b)
    int a;
    int b;
    {
        dSP;
        I32 ax;
        int count;
        ENTER;
        SAVETMPS;
        PUSHMARK(SP);
        XPUSHs(sv_2mortal(newSViv(a)));
        XPUSHs(sv_2mortal(newSViv(b)));
        PUTBACK;
        count = call_pv(&quot;AddSubtract&quot;, G_ARRAY);
        SPAGAIN;
        SP -= count;
        ax = (SP - PL_stack_base) + 1;
        if (count != 2)
            croak(&quot;Big trouble\n&quot;);
        printf (&quot;%d + %d = %d\n&quot;, a, b, SvIV(ST(0)));
        printf (&quot;%d - %d = %d\n&quot;, a, b, SvIV(ST(1)));
        PUTBACK;
        FREETMPS;
        LEAVE;
    }
</pre>
<p class="Pp">Notes</p>
<dl class="Bl-tag">
  <dt>1.</dt>
  <dd>Notice that it was necessary to define the variable
      <span class="Li">&quot;ax&quot;</span>. This is because the
      <span class="Li">&quot;ST&quot;</span> macro expects it to exist. If we
      were in an XSUB it would not be necessary to define
      <span class="Li">&quot;ax&quot;</span> as it is already defined for
    us.</dd>
  <dt>2.</dt>
  <dd>The code
    <p class="Pp"></p>
    <pre>        SPAGAIN;
        SP -= count;
        ax = (SP - PL_stack_base) + 1;
    </pre>
    <p class="Pp">sets the stack up so that we can use the
        <span class="Li">&quot;ST&quot;</span> macro.</p>
  </dd>
  <dt>3.</dt>
  <dd>Unlike the original coding of this example, the returned values are not
      accessed in reverse order. So <span class="Li">ST(0)</span> refers to the
      first value returned by the Perl subroutine and
      <span class="Li">&quot;ST(count-1)&quot;</span> refers to the last.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Creating_and_Calling_an_Anonymous_Subroutine_in_C"><a class="permalink" href="#Creating_and_Calling_an_Anonymous_Subroutine_in_C">Creating
  and Calling an Anonymous Subroutine in C</a></h2>
<p class="Pp">As we've already shown,
    <span class="Li">&quot;call_sv&quot;</span> can be used to invoke an
    anonymous subroutine. However, our example showed a Perl script invoking an
    XSUB to perform this operation. Let's see how it can be done inside our C
    code:</p>
<p class="Pp"></p>
<pre> ...
 SV *cvrv = eval_pv(&quot;sub { print 'You will not find me cluttering any namespace!' }&quot;, TRUE);
 ...
 call_sv(cvrv, G_VOID|G_NOARGS);
</pre>
<p class="Pp"><span class="Li">&quot;eval_pv&quot;</span> is used to compile the
    anonymous subroutine, which will be the return value as well (read more
    about <span class="Li">&quot;eval_pv&quot;</span> in &quot;eval_pv&quot; in
    perlapi). Once this code reference is in hand, it can be mixed in with all
    the previous examples we've shown.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="LIGHTWEIGHT_CALLBACKS"><a class="permalink" href="#LIGHTWEIGHT_CALLBACKS">LIGHTWEIGHT
  CALLBACKS</a></h1>
<p class="Pp">Sometimes you need to invoke the same subroutine repeatedly. This
    usually happens with a function that acts on a list of values, such as
    Perl's built-in <i>sort()</i>. You can pass a comparison function to
    <i>sort()</i>, which will then be invoked for every pair of values that
    needs to be compared. The <i>first()</i> and <i>reduce()</i> functions from
    List::Util follow a similar pattern.</p>
<p class="Pp">In this case it is possible to speed up the routine (often quite
    substantially) by using the lightweight callback API. The idea is that the
    calling context only needs to be created and destroyed once, and the sub can
    be called arbitrarily many times in between.</p>
<p class="Pp">It is usual to pass parameters using global variables (typically
    <span class="Li">$_</span> for one parameter, or <span class="Li">$a</span>
    and <span class="Li">$b</span> for two parameters) rather than via
    <span class="Li">@_</span>. (It is possible to use the
    <span class="Li">@_</span> mechanism if you know what you're doing, though
    there is as yet no supported API for it. It's also inherently slower.)</p>
<p class="Pp">The pattern of macro calls is like this:</p>
<p class="Pp"></p>
<pre>    dMULTICALL;                 /* Declare local variables */
    I32 gimme = G_SCALAR;       /* context of the call: G_SCALAR,
                                 * G_ARRAY, or G_VOID */
    PUSH_MULTICALL(cv);         /* Set up the context for calling cv,
                                   and set local vars appropriately */
    /* loop */ {
        /* set the value(s) af your parameter variables */
        MULTICALL;              /* Make the actual call */
    } /* end of loop */
    POP_MULTICALL;              /* Tear down the calling context */
</pre>
<p class="Pp">For some concrete examples, see the implementation of the
    <i>first()</i> and <i>reduce()</i> functions of List::Util 1.18. There you
    will also find a header file that emulates the multicall API on older
    versions of perl.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp">perlxs, perlguts, perlembed</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">Paul Marquess</p>
<p class="Pp">Special thanks to the following people who assisted in the
    creation of the document.</p>
<p class="Pp">Jeff Okamoto, Tim Bunce, Nick Gianniotis, Steve Kelem, Gurusamy
    Sarathy and Larry Wall.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DATE"><a class="permalink" href="#DATE">DATE</a></h1>
<p class="Pp">Version 1.3, 14th Apr 1997</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2014-01-31</td>
    <td class="foot-os">perl v5.18.4</td>
  </tr>
</table>
</body>
</html>
