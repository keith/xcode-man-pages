<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    .Nd, .Bf, .Op { display: inline; }
    .Pa, .Ad { font-style: italic; }
    .Ms { font-weight: bold; }
    .Bl-diag > dt { font-weight: bold; }
    code.Nm, .Fl, .Cm, .Ic, code.In, .Fd, .Fn, .Cd { font-weight: bold;
      font-family: inherit; }
  </style>
  <title>DBIx::Class::Manual::Cookbook(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">DBIx::Class::Manual::Cookbook(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">DBIx::Class::Manual::Cookbook(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">DBIx::Class::Manual::Cookbook - Miscellaneous recipes</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEARCHING"><a class="permalink" href="#SEARCHING">SEARCHING</a></h1>
<section class="Ss">
<h2 class="Ss" id="Paged_results"><a class="permalink" href="#Paged_results">Paged
  results</a></h2>
<p class="Pp">When you expect a large number of results, you can ask DBIx::Class
    for a paged resultset, which will fetch only a defined number of records at
    a time:</p>
<p class="Pp"></p>
<pre>  my $rs = $schema-&gt;resultset('Artist')-&gt;search(
    undef,
    {
      page =&gt; 1,  # page to return (defaults to 1)
      rows =&gt; 10, # number of results per page
    },
  );
  return $rs-&gt;all(); # all records for page 1
  return $rs-&gt;page(2); # records for page 2
</pre>
<p class="Pp">You can get a Data::Page object for the resultset (suitable for
    use in e.g. a template) using the <span class="Li">&quot;pager&quot;</span>
    method:</p>
<p class="Pp"></p>
<pre>  return $rs-&gt;pager();
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Complex_"><a class="permalink" href="#Complex_">Complex WHERE
  clauses</a></h2>
<p class="Pp">Sometimes you need to formulate a query using specific
  operators:</p>
<p class="Pp"></p>
<pre>  my @albums = $schema-&gt;resultset('Album')-&gt;search({
    artist =&gt; { 'like', '%Lamb%' },
    title  =&gt; { 'like', '%Fear of Fours%' },
  });
</pre>
<p class="Pp">This results in something like the following
    <span class="Li">&quot;WHERE&quot;</span> clause:</p>
<p class="Pp"></p>
<pre>  WHERE artist LIKE ? AND title LIKE ?
</pre>
<p class="Pp">And the following bind values for the placeholders:
    <span class="Li">'%Lamb%'</span>, <span class="Li">'%Fear of</span>
    <span class="Li">Fours%'</span>.</p>
<p class="Pp">Other queries might require slightly more complex logic:</p>
<p class="Pp"></p>
<pre>  my @albums = $schema-&gt;resultset('Album')-&gt;search({
    -or =&gt; [
      -and =&gt; [
        artist =&gt; { 'like', '%Smashing Pumpkins%' },
        title  =&gt; 'Siamese Dream',
      ],
      artist =&gt; 'Starchildren',
    ],
  });
</pre>
<p class="Pp">This results in the following
    <span class="Li">&quot;WHERE&quot;</span> clause:</p>
<p class="Pp"></p>
<pre>  WHERE ( artist LIKE '%Smashing Pumpkins%' AND title = 'Siamese Dream' )
    OR artist = 'Starchildren'
</pre>
<p class="Pp">For more information on generating complex queries, see
    &quot;WHERE CLAUSES&quot; in SQL::Abstract.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Retrieve_one_and_only_one_row_from_a_resultset"><a class="permalink" href="#Retrieve_one_and_only_one_row_from_a_resultset">Retrieve
  one and only one row from a resultset</a></h2>
<p class="Pp">Sometimes you need only the first &quot;top&quot; row of a
    resultset. While this can be easily done with
    <span class="Li">$rs</span>-&gt;first, it is suboptimal, as a full blown
    cursor for the resultset will be created and then immediately destroyed
    after fetching the first row object. <span class="Li">$rs</span>-&gt;single
    is designed specifically for this case - it will grab the first returned
    result without even instantiating a cursor.</p>
<p class="Pp">Before replacing all your calls to
    <span class="Li">&quot;first()&quot;</span> with
    <span class="Li">&quot;single()&quot;</span> please observe the following
    CAVEATS:</p>
<ul class="Bl-bullet">
  <li>While <i>single()</i> takes a search condition just like <i>search()</i>
      does, it does _not_ accept search attributes. However one can always chain
      a <i>single()</i> to a <i>search()</i>:
    <p class="Pp"></p>
    <pre>  my $top_cd = $cd_rs-&gt;search({}, { order_by =&gt; 'rating' })-&gt;single;
    </pre>
  </li>
  <li>Since <i>single()</i> is the engine behind <i>find()</i>, it is designed
      to fetch a single row per database query. Thus a warning will be issued
      when the underlying SELECT returns more than one row. Sometimes however
      this usage is valid: i.e. we have an arbitrary number of cd's but only one
      of them is at the top of the charts at any given time. If you know what
      you are doing, you can silence the warning by explicitly limiting the
      resultset size:
    <p class="Pp"></p>
    <pre>  my $top_cd = $cd_rs-&gt;search ({}, { order_by =&gt; 'rating', rows =&gt; 1 })-&gt;single;
    </pre>
  </li>
</ul>
</section>
<section class="Ss">
<h2 class="Ss" id="Arbitrary_"><a class="permalink" href="#Arbitrary_">Arbitrary
  SQL through a custom ResultSource</a></h2>
<p class="Pp">Sometimes you have to run arbitrary SQL because your query is too
    complex (e.g. it contains Unions, Sub-Selects, Stored Procedures, etc.) or
    has to be optimized for your database in a special way, but you still want
    to get the results as a DBIx::Class::ResultSet.</p>
<p class="Pp">This is accomplished by defining a ResultSource::View for your
    query, almost like you would define a regular ResultSource.</p>
<p class="Pp"></p>
<pre>  package My::Schema::Result::UserFriendsComplex;
  use strict;
  use warnings;
  use base qw/DBIx::Class::Core/;
  __PACKAGE__-&gt;table_class('DBIx::Class::ResultSource::View');
  # For the time being this is necessary even for virtual views
  __PACKAGE__-&gt;table($view_name);
  #
  # -&gt;add_columns, etc.
  #
  # do not attempt to deploy() this view
  __PACKAGE__-&gt;result_source_instance-&gt;is_virtual(1);
  __PACKAGE__-&gt;result_source_instance-&gt;view_definition(q[
    SELECT u.* FROM user u
    INNER JOIN user_friends f ON u.id = f.user_id
    WHERE f.friend_user_id = ?
    UNION
    SELECT u.* FROM user u
    INNER JOIN user_friends f ON u.id = f.friend_user_id
    WHERE f.user_id = ?
  ]);
</pre>
<p class="Pp">Next, you can execute your complex query using bind parameters
    like this:</p>
<p class="Pp"></p>
<pre>  my $friends = $schema-&gt;resultset( 'UserFriendsComplex' )-&gt;search( {},
    {
      bind  =&gt; [ 12345, 12345 ]
    }
  );
</pre>
<p class="Pp">... and you'll get back a perfect DBIx::Class::ResultSet (except,
    of course, that you cannot modify the rows it contains, e.g. cannot call
    &quot;update&quot;, &quot;delete&quot;, ... on it).</p>
<p class="Pp">Note that you cannot have bind parameters unless is_virtual is set
    to true.</p>
<dl class="Bl-tag">
  <dt>&#x2022;</dt>
  <dd>NOTE
    <p class="Pp">If you're using the old deprecated
        <span class="Li">&quot;$rsrc_instance-&gt;name(\'( SELECT
        ...')&quot;</span> method for custom SQL execution, you are highly
        encouraged to update your code to use a virtual view as above. If you do
        not want to change your code, and just want to suppress the deprecation
        warning when you call &quot;deploy&quot; in DBIx::Class::Schema, add
        this line to your source definition, so that
        <span class="Li">&quot;deploy&quot;</span> will exclude this
        &quot;table&quot;:</p>
    <p class="Pp"></p>
    <pre>  sub sqlt_deploy_hook { $_[1]-&gt;schema-&gt;drop_table ($_[1]) }
    </pre>
  </dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Using_specific_columns"><a class="permalink" href="#Using_specific_columns">Using
  specific columns</a></h2>
<p class="Pp">When you only want specific columns from a table, you can use
    <span class="Li">&quot;columns&quot;</span> to specify which ones you need.
    This is useful to avoid loading columns with large amounts of data that you
    aren't about to use anyway:</p>
<p class="Pp"></p>
<pre>  my $rs = $schema-&gt;resultset('Artist')-&gt;search(
    undef,
    {
      columns =&gt; [qw/ name /]
    }
  );
  # Equivalent SQL:
  # SELECT artist.name FROM artist
</pre>
<p class="Pp">This is a shortcut for <span class="Li">&quot;select&quot;</span>
    and <span class="Li">&quot;as&quot;</span>, see below.
    <span class="Li">&quot;columns&quot;</span> cannot be used together with
    <span class="Li">&quot;select&quot;</span> and
    <span class="Li">&quot;as&quot;</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Using_database_functions_or_stored_procedures"><a class="permalink" href="#Using_database_functions_or_stored_procedures">Using
  database functions or stored procedures</a></h2>
<p class="Pp">The combination of <span class="Li">&quot;select&quot;</span> and
    <span class="Li">&quot;as&quot;</span> can be used to return the result of a
    database function or stored procedure as a column value. You use
    <span class="Li">&quot;select&quot;</span> to specify the source for your
    column value (e.g. a column name, function, or stored procedure name). You
    then use <span class="Li">&quot;as&quot;</span> to set the column name you
    will use to access the returned value:</p>
<p class="Pp"></p>
<pre>  my $rs = $schema-&gt;resultset('Artist')-&gt;search(
    {},
    {
      select =&gt; [ 'name', { LENGTH =&gt; 'name' } ],
      as     =&gt; [qw/ name name_length /],
    }
  );
  # Equivalent SQL:
  # SELECT name name, LENGTH( name )
  # FROM artist
</pre>
<p class="Pp">Note that the <span class="Li">&quot;as&quot;</span> attribute
    <b>has absolutely nothing to do</b> with the SQL syntax
    <span class="Li">&quot; SELECT foo AS bar &quot;</span> (see the
    documentation in &quot;ATTRIBUTES&quot; in DBIx::Class::ResultSet). You can
    control the <span class="Li">&quot;AS&quot;</span> part of the generated SQL
    via the <span class="Li">&quot;-as&quot;</span> field attribute as
  follows:</p>
<p class="Pp"></p>
<pre>  my $rs = $schema-&gt;resultset('Artist')-&gt;search(
    {},
    {
      join =&gt; 'cds',
      distinct =&gt; 1,
      '+select' =&gt; [ { count =&gt; 'cds.cdid', -as =&gt; 'amount_of_cds' } ],
      '+as' =&gt; [qw/num_cds/],
      order_by =&gt; { -desc =&gt; 'amount_of_cds' },
    }
  );
  # Equivalent SQL
  # SELECT me.artistid, me.name, me.rank, me.charfield, COUNT( cds.cdid ) AS amount_of_cds
  #   FROM artist me LEFT JOIN cd cds ON cds.artist = me.artistid
  # GROUP BY me.artistid, me.name, me.rank, me.charfield
  # ORDER BY amount_of_cds DESC
</pre>
<p class="Pp">If your alias exists as a column in your base class (i.e. it was
    added with add_columns), you just access it as normal. Our
    <span class="Li">&quot;Artist&quot;</span> class has a
    <span class="Li">&quot;name&quot;</span> column, so we just use the
    <span class="Li">&quot;name&quot;</span> accessor:</p>
<p class="Pp"></p>
<pre>  my $artist = $rs-&gt;first();
  my $name = $artist-&gt;name();
</pre>
<p class="Pp">If on the other hand the alias does not correspond to an existing
    column, you have to fetch the value using the
    <span class="Li">&quot;get_column&quot;</span> accessor:</p>
<p class="Pp"></p>
<pre>  my $name_length = $artist-&gt;get_column('name_length');
</pre>
<p class="Pp">If you don't like using
    <span class="Li">&quot;get_column&quot;</span>, you can always create an
    accessor for any of your aliases using either of these:</p>
<p class="Pp"></p>
<pre>  # Define accessor manually:
  sub name_length { shift-&gt;get_column('name_length'); }
  # Or use DBIx::Class::AccessorGroup:
  __PACKAGE__-&gt;mk_group_accessors('column' =&gt; 'name_length');
</pre>
<p class="Pp">See also &quot;Using SQL functions on the left hand side of a
    comparison&quot;.</p>
</section>
<section class="Ss">
<h2 class="Ss">SELECT DISTINCT with multiple columns</h2>
<pre>  my $rs = $schema-&gt;resultset('Artist')-&gt;search(
    {},
    {
      columns =&gt; [ qw/artist_id name rank/ ],
      distinct =&gt; 1
    }
  );
  my $rs = $schema-&gt;resultset('Artist')-&gt;search(
    {},
    {
      columns =&gt; [ qw/artist_id name rank/ ],
      group_by =&gt; [ qw/artist_id name rank/ ],
    }
  );
  # Equivalent SQL:
  # SELECT me.artist_id, me.name, me.rank
  # FROM artist me
  # GROUP BY artist_id, name, rank
</pre>
</section>
<section class="Ss">
<h2 class="Ss">SELECT COUNT(DISTINCT colname)</h2>
<pre>  my $rs = $schema-&gt;resultset('Artist')-&gt;search(
    {},
    {
      columns =&gt; [ qw/name/ ],
      distinct =&gt; 1
    }
  );
  my $rs = $schema-&gt;resultset('Artist')-&gt;search(
    {},
    {
      columns =&gt; [ qw/name/ ],
      group_by =&gt; [ qw/name/ ],
    }
  );
  my $count = $rs-&gt;count;
  # Equivalent SQL:
  # SELECT COUNT( * ) FROM (SELECT me.name FROM artist me GROUP BY me.name) me:
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Grouping_results"><a class="permalink" href="#Grouping_results">Grouping
  results</a></h2>
<p class="Pp">DBIx::Class supports <span class="Li">&quot;GROUP BY&quot;</span>
    as follows:</p>
<p class="Pp"></p>
<pre>  my $rs = $schema-&gt;resultset('Artist')-&gt;search(
    {},
    {
      join     =&gt; [qw/ cds /],
      select   =&gt; [ 'name', { count =&gt; 'cds.id' } ],
      as       =&gt; [qw/ name cd_count /],
      group_by =&gt; [qw/ name /]
    }
  );
  # Equivalent SQL:
  # SELECT name, COUNT( cd.id ) FROM artist
  # LEFT JOIN cd ON artist.id = cd.artist
  # GROUP BY name
</pre>
<p class="Pp">Please see &quot;ATTRIBUTES&quot; in DBIx::Class::ResultSet
    documentation if you are in any way unsure about the use of the attributes
    above (<span class="Li">&quot; join</span> <span class="Li">&quot;</span>,
    <span class="Li">&quot; select &quot;</span>, <span class="Li">&quot; as
    &quot;</span> and <span class="Li">&quot; group_by &quot;</span>).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Subqueries"><a class="permalink" href="#Subqueries">Subqueries</a></h2>
<p class="Pp">You can write subqueries relatively easily in DBIC.</p>
<p class="Pp"></p>
<pre>  my $inside_rs = $schema-&gt;resultset('Artist')-&gt;search({
    name =&gt; [ 'Billy Joel', 'Brittany Spears' ],
  });
  my $rs = $schema-&gt;resultset('CD')-&gt;search({
    artist_id =&gt; { -in =&gt; $inside_rs-&gt;get_column('id')-&gt;as_query },
  });
</pre>
<p class="Pp">The usual operators ( '=', '!=', -in, -not_in, etc.) are
    supported.</p>
<p class="Pp"><b>NOTE</b>: You have to explicitly use '=' when doing an equality
    comparison. The following will <b>not</b> work:</p>
<p class="Pp"></p>
<pre>  my $rs = $schema-&gt;resultset('CD')-&gt;search({
    artist_id =&gt; $inside_rs-&gt;get_column('id')-&gt;as_query,  # does NOT work
  });
</pre>
<p class="Pp"><i>Support</i></p>
<p class="Pp">Subqueries are supported in the where clause (first hashref), and
    in the from, select, and +select attributes.</p>
<p class="Pp"><i>Correlated subqueries</i></p>
<p class="Pp"></p>
<pre>  my $cdrs = $schema-&gt;resultset('CD');
  my $rs = $cdrs-&gt;search({
    year =&gt; {
      '=' =&gt; $cdrs-&gt;search(
        { artist_id =&gt; { -ident =&gt; 'me.artist_id' } },
        { alias =&gt; 'sub_query' }
      )-&gt;get_column('year')-&gt;max_rs-&gt;as_query,
    },
  });
</pre>
<p class="Pp">That creates the following SQL:</p>
<p class="Pp"></p>
<pre>  SELECT me.cdid, me.artist, me.title, me.year, me.genreid, me.single_track
    FROM cd me
  WHERE year = (
    SELECT MAX(sub_query.year)
      FROM cd sub_query
    WHERE artist_id = me.artist_id
  )
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Predefined_searches"><a class="permalink" href="#Predefined_searches">Predefined
  searches</a></h2>
<p class="Pp">You can define frequently used searches as methods by subclassing
    DBIx::Class::ResultSet:</p>
<p class="Pp"></p>
<pre>  package My::DBIC::ResultSet::CD;
  use strict;
  use warnings;
  use base 'DBIx::Class::ResultSet';
  sub search_cds_ordered {
      my ($self) = @_;
      return $self-&gt;search(
          {},
          { order_by =&gt; 'name DESC' },
      );
  }
  1;
</pre>
<p class="Pp">If you're using &quot;load_namespaces&quot; in
    DBIx::Class::Schema, simply place the file into the
    <span class="Li">&quot;ResultSet&quot;</span> directory next to your
    <span class="Li">&quot;Result&quot;</span> directory, and it will be
    automatically loaded.</p>
<p class="Pp">If however you are still using &quot;load_classes&quot; in
    DBIx::Class::Schema, first tell DBIx::Class to create an instance of the
    ResultSet class for you, in your My::DBIC::Schema::CD class:</p>
<p class="Pp"></p>
<pre>  # class definition as normal
  use base 'DBIx::Class::Core';
  __PACKAGE__-&gt;table('cd');
  # tell DBIC to use the custom ResultSet class
  __PACKAGE__-&gt;resultset_class('My::DBIC::ResultSet::CD');
</pre>
<p class="Pp">Note that <span class="Li">&quot;resultset_class&quot;</span> must
    be called after <span class="Li">&quot;load_components&quot;</span> and
    <span class="Li">&quot;table&quot;</span>, or you will get errors about
    missing methods.</p>
<p class="Pp">Then call your new method in your code:</p>
<p class="Pp"></p>
<pre>   my $ordered_cds = $schema-&gt;resultset('CD')-&gt;search_cds_ordered();
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Using_"><a class="permalink" href="#Using_">Using SQL
  functions on the left hand side of a comparison</a></h2>
<p class="Pp">Using SQL functions on the left hand side of a comparison is
    generally not a good idea since it requires a scan of the entire table.
    (Unless your RDBMS supports indexes on expressions - including return values
    of functions - and you create an index on the return value of the function
    in question.) However, it can be accomplished with
    <span class="Li">&quot;DBIx::Class&quot;</span> when necessary by resorting
    to literal SQL:</p>
<p class="Pp"></p>
<pre>  $rs-&gt;search(
    \[ 'YEAR(date_of_birth) = ?', 1979 ]
  );
  # Equivalent SQL:
  # SELECT * FROM employee WHERE YEAR(date_of_birth) = ?
</pre>
<p class="Pp">To include the function as part of a larger search, use the '-and'
    keyword to collect the search conditions:</p>
<p class="Pp"></p>
<pre>  $rs-&gt;search({ -and =&gt; [
    name =&gt; 'Bob',
    \[ 'YEAR(date_of_birth) = ?', 1979 ]
  ]});
  # Equivalent SQL:
  # SELECT * FROM employee WHERE name = ? AND YEAR(date_of_birth) = ?
</pre>
<p class="Pp">Note: the syntax for specifying the bind value's datatype and
    value is explained in &quot;DBIC BIND VALUES&quot; in
    DBIx::Class::ResultSet.</p>
<p class="Pp">See also &quot;Literal SQL with placeholders and bind values
    (subqueries)&quot; in SQL::Abstract.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Software_Limits"><a class="permalink" href="#Software_Limits">Software
  Limits</a></h2>
<p class="Pp">When your RDBMS does not have a working SQL limit mechanism (e.g.
    Sybase ASE) and GenericSubQ is either too slow or does not work at all, you
    can try the software_limit DBIx::Class::ResultSet attribute, which skips
    over records to simulate limits in the Perl layer.</p>
<p class="Pp">For example:</p>
<p class="Pp"></p>
<pre>  my $paged_rs = $rs-&gt;search({}, {
    rows =&gt; 25,
    page =&gt; 3,
    order_by =&gt; [ 'me.last_name' ],
    software_limit =&gt; 1,
  });
</pre>
<p class="Pp">You can set it as a default for your schema by placing the
    following in your <span class="Li">&quot;Schema.pm&quot;</span>:</p>
<p class="Pp"></p>
<pre>  __PACKAGE__-&gt;default_resultset_attributes({ software_limit =&gt; 1 });
</pre>
<p class="Pp"><b>WARNING:</b> If you are dealing with large resultsets and your
    DBI or ODBC/ADO driver does not have proper cursor support (i.e. it loads
    the whole resultset into memory) then this feature will be extremely slow
    and use huge amounts of memory at best, and may cause your process to run
    out of memory and cause instability on your server at worst, beware!</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="JOINS_AND_PREFETCHING"><a class="permalink" href="#JOINS_AND_PREFETCHING">JOINS
  AND PREFETCHING</a></h1>
<section class="Ss">
<h2 class="Ss" id="Using_joins_and_prefetch"><a class="permalink" href="#Using_joins_and_prefetch">Using
  joins and prefetch</a></h2>
<p class="Pp">You can use the <span class="Li">&quot;join&quot;</span> attribute
    to allow searching on, or sorting your results by, one or more columns in a
    related table.</p>
<p class="Pp">This requires that you have defined the DBIx::Class::Relationship.
    For example :</p>
<p class="Pp"></p>
<pre>  My::Schema::CD-&gt;has_many( artists =&gt; 'My::Schema::Artist', 'artist_id');
</pre>
<p class="Pp">To return all CDs matching a particular artist name, you specify
    the name of the relationship ('artists'):</p>
<p class="Pp"></p>
<pre>  my $rs = $schema-&gt;resultset('CD')-&gt;search(
    {
      'artists.name' =&gt; 'Bob Marley'
    },
    {
      join =&gt; 'artists', # join the artist table
    }
  );
  # Equivalent SQL:
  # SELECT cd.* FROM cd
  # JOIN artist ON cd.artist = artist.id
  # WHERE artist.name = 'Bob Marley'
</pre>
<p class="Pp">In that example both the join, and the condition use the
    relationship name rather than the table name (see
    DBIx::Class::Manual::Joining for more details on aliasing ).</p>
<p class="Pp">If required, you can now sort on any column in the related tables
    by including it in your <span class="Li">&quot;order_by&quot;</span>
    attribute, (again using the aliased relation name rather than table name)
  :</p>
<p class="Pp"></p>
<pre>  my $rs = $schema-&gt;resultset('CD')-&gt;search(
    {
      'artists.name' =&gt; 'Bob Marley'
    },
    {
      join     =&gt; 'artists',
      order_by =&gt; [qw/ artists.name /]
    }
  );
  # Equivalent SQL:
  # SELECT cd.* FROM cd
  # JOIN artist ON cd.artist = artist.id
  # WHERE artist.name = 'Bob Marley'
  # ORDER BY artist.name
</pre>
<p class="Pp">Note that the <span class="Li">&quot;join&quot;</span> attribute
    should only be used when you need to search or sort using columns in a
    related table. Joining related tables when you only need columns from the
    main table will make performance worse!</p>
<p class="Pp">Now let's say you want to display a list of CDs, each with the
    name of the artist. The following will work fine:</p>
<p class="Pp"></p>
<pre>  while (my $cd = $rs-&gt;next) {
    print &quot;CD: &quot; . $cd-&gt;title . &quot;, Artist: &quot; . $cd-&gt;artist-&gt;name;
  }
</pre>
<p class="Pp">There is a problem however. We have searched both the
    <span class="Li">&quot;cd&quot;</span> and
    <span class="Li">&quot;artist&quot;</span> tables in our main query, but we
    have only returned data from the <span class="Li">&quot;cd&quot;</span>
    table. To get the artist name for any of the CD objects returned,
    DBIx::Class will go back to the database:</p>
<p class="Pp"></p>
<pre>  SELECT artist.* FROM artist WHERE artist.id = ?
</pre>
<p class="Pp">A statement like the one above will run for each and every CD
    returned by our main query. Five CDs, five extra queries. A hundred CDs, one
    hundred extra queries!</p>
<p class="Pp">Thankfully, DBIx::Class has a
    <span class="Li">&quot;prefetch&quot;</span> attribute to solve this
    problem. This allows you to fetch results from related tables in
  advance:</p>
<p class="Pp"></p>
<pre>  my $rs = $schema-&gt;resultset('CD')-&gt;search(
    {
      'artists.name' =&gt; 'Bob Marley'
    },
    {
      join     =&gt; 'artists',
      order_by =&gt; [qw/ artists.name /],
      prefetch =&gt; 'artists' # return artist data too!
    }
  );
  # Equivalent SQL (note SELECT from both &quot;cd&quot; and &quot;artist&quot;):
  # SELECT cd.*, artist.* FROM cd
  # JOIN artist ON cd.artist = artist.id
  # WHERE artist.name = 'Bob Marley'
  # ORDER BY artist.name
</pre>
<p class="Pp">The code to print the CD list remains the same:</p>
<p class="Pp"></p>
<pre>  while (my $cd = $rs-&gt;next) {
    print &quot;CD: &quot; . $cd-&gt;title . &quot;, Artist: &quot; . $cd-&gt;artist-&gt;name;
  }
</pre>
<p class="Pp">DBIx::Class has now prefetched all matching data from the
    <span class="Li">&quot;artist&quot;</span> table, so no additional SQL
    statements are executed. You now have a much more efficient query.</p>
<p class="Pp">Also note that <span class="Li">&quot;prefetch&quot;</span> should
    only be used when you know you will definitely use data from a related
    table. Pre-fetching related tables when you only need columns from the main
    table will make performance worse!</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Multiple_joins"><a class="permalink" href="#Multiple_joins">Multiple
  joins</a></h2>
<p class="Pp">In the examples above, the
    <span class="Li">&quot;join&quot;</span> attribute was a scalar. If you pass
    an array reference instead, you can join to multiple tables. In this
    example, we want to limit the search further, using
    <span class="Li">&quot;LinerNotes&quot;</span>:</p>
<p class="Pp"></p>
<pre>  # Relationships defined elsewhere:
  # CD-&gt;belongs_to('artist' =&gt; 'Artist');
  # CD-&gt;has_one('liner_notes' =&gt; 'LinerNotes', 'cd');
  my $rs = $schema-&gt;resultset('CD')-&gt;search(
    {
      'artist.name' =&gt; 'Bob Marley'
      'liner_notes.notes' =&gt; { 'like', '%some text%' },
    },
    {
      join     =&gt; [qw/ artist liner_notes /],
      order_by =&gt; [qw/ artist.name /],
    }
  );
  # Equivalent SQL:
  # SELECT cd.*, artist.*, liner_notes.* FROM cd
  # JOIN artist ON cd.artist = artist.id
  # JOIN liner_notes ON cd.id = liner_notes.cd
  # WHERE artist.name = 'Bob Marley' AND liner_notes.notes LIKE '%some text%'
  # ORDER BY artist.name
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Multi-step_joins"><a class="permalink" href="#Multi-step_joins">Multi-step
  joins</a></h2>
<p class="Pp">Sometimes you want to join more than one relationship deep. In
    this example, we want to find all <span class="Li">&quot;Artist&quot;</span>
    objects who have <span class="Li">&quot;CD&quot;</span>s whose
    <span class="Li">&quot;LinerNotes&quot;</span> contain a specific
  string:</p>
<p class="Pp"></p>
<pre>  # Relationships defined elsewhere:
  # Artist-&gt;has_many('cds' =&gt; 'CD', 'artist');
  # CD-&gt;has_one('liner_notes' =&gt; 'LinerNotes', 'cd');
  my $rs = $schema-&gt;resultset('Artist')-&gt;search(
    {
      'liner_notes.notes' =&gt; { 'like', '%some text%' },
    },
    {
      join =&gt; {
        'cds' =&gt; 'liner_notes'
      }
    }
  );
  # Equivalent SQL:
  # SELECT artist.* FROM artist
  # LEFT JOIN cd ON artist.id = cd.artist
  # LEFT JOIN liner_notes ON cd.id = liner_notes.cd
  # WHERE liner_notes.notes LIKE '%some text%'
</pre>
<p class="Pp">Joins can be nested to an arbitrary level. So if we decide later
    that we want to reduce the number of Artists returned based on who wrote the
    liner notes:</p>
<p class="Pp"></p>
<pre>  # Relationship defined elsewhere:
  # LinerNotes-&gt;belongs_to('author' =&gt; 'Person');
  my $rs = $schema-&gt;resultset('Artist')-&gt;search(
    {
      'liner_notes.notes' =&gt; { 'like', '%some text%' },
      'author.name' =&gt; 'A. Writer'
    },
    {
      join =&gt; {
        'cds' =&gt; {
          'liner_notes' =&gt; 'author'
        }
      }
    }
  );
  # Equivalent SQL:
  # SELECT artist.* FROM artist
  # LEFT JOIN cd ON artist.id = cd.artist
  # LEFT JOIN liner_notes ON cd.id = liner_notes.cd
  # LEFT JOIN author ON author.id = liner_notes.author
  # WHERE liner_notes.notes LIKE '%some text%'
  # AND author.name = 'A. Writer'
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Multi-step_and_multiple_joins"><a class="permalink" href="#Multi-step_and_multiple_joins">Multi-step
  and multiple joins</a></h2>
<p class="Pp">With various combinations of array and hash references, you can
    join tables in any combination you desire. For example, to join Artist to CD
    and Concert, and join CD to LinerNotes:</p>
<p class="Pp"></p>
<pre>  # Relationships defined elsewhere:
  # Artist-&gt;has_many('concerts' =&gt; 'Concert', 'artist');
  my $rs = $schema-&gt;resultset('Artist')-&gt;search(
    { },
    {
      join =&gt; [
        {
          cds =&gt; 'liner_notes'
        },
        'concerts'
      ],
    }
  );
  # Equivalent SQL:
  # SELECT artist.* FROM artist
  # LEFT JOIN cd ON artist.id = cd.artist
  # LEFT JOIN liner_notes ON cd.id = liner_notes.cd
  # LEFT JOIN concert ON artist.id = concert.artist
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Multi-step_prefetch"><a class="permalink" href="#Multi-step_prefetch">Multi-step
  prefetch</a></h2>
<p class="Pp"><span class="Li">&quot;prefetch&quot;</span> can be nested more
    than one relationship deep using the same syntax as a multi-step join:</p>
<p class="Pp"></p>
<pre>  my $rs = $schema-&gt;resultset('Tag')-&gt;search(
    {},
    {
      prefetch =&gt; {
        cd =&gt; 'artist'
      }
    }
  );
  # Equivalent SQL:
  # SELECT tag.*, cd.*, artist.* FROM tag
  # JOIN cd ON tag.cd = cd.id
  # JOIN artist ON cd.artist = artist.id
</pre>
<p class="Pp">Now accessing our <span class="Li">&quot;cd&quot;</span> and
    <span class="Li">&quot;artist&quot;</span> relationships does not need
    additional SQL statements:</p>
<p class="Pp"></p>
<pre>  my $tag = $rs-&gt;first;
  print $tag-&gt;cd-&gt;artist-&gt;name;
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="ROW-LEVEL_OPERATIONS"><a class="permalink" href="#ROW-LEVEL_OPERATIONS">ROW-LEVEL
  OPERATIONS</a></h1>
<section class="Ss">
<h2 class="Ss" id="Retrieving_a_result_object's_Schema"><a class="permalink" href="#Retrieving_a_result_object's_Schema">Retrieving
  a result object's Schema</a></h2>
<p class="Pp">It is possible to get a Schema object from a result object like
    so:</p>
<p class="Pp"></p>
<pre>  my $schema = $cd-&gt;result_source-&gt;schema;
  # use the schema as normal:
  my $artist_rs = $schema-&gt;resultset('Artist');
</pre>
<p class="Pp">This can be useful when you don't want to pass around a Schema
    object to every method.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Getting_the_value_of_the_primary_key_for_the_last_database_insert"><a class="permalink" href="#Getting_the_value_of_the_primary_key_for_the_last_database_insert">Getting
  the value of the primary key for the last database insert</a></h2>
<p class="Pp">AKA getting last_insert_id</p>
<p class="Pp">Thanks to the core component PK::Auto, this is
  straightforward:</p>
<p class="Pp"></p>
<pre>  my $foo = $rs-&gt;create(\%blah);
  # do more stuff
  my $id = $foo-&gt;id; # foo-&gt;my_primary_key_field will also work.
</pre>
<p class="Pp">If you are not using autoincrementing primary keys, this will
    probably not work, but then you already know the value of the last primary
    key anyway.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Stringification"><a class="permalink" href="#Stringification">Stringification</a></h2>
<p class="Pp">Employ the standard stringification technique by using the
    overload module.</p>
<p class="Pp">To make an object stringify itself as a single column, use
    something like this (replace <span class="Li">&quot;name&quot;</span> with
    the column/method of your choice):</p>
<p class="Pp"></p>
<pre>  use overload '&quot;&quot;' =&gt; sub { shift-&gt;name}, fallback =&gt; 1;
</pre>
<p class="Pp">For more complex stringification, you can use an anonymous
    subroutine:</p>
<p class="Pp"></p>
<pre>  use overload '&quot;&quot;' =&gt; sub { $_[0]-&gt;name . &quot;, &quot; .
                             $_[0]-&gt;address }, fallback =&gt; 1;
</pre>
<p class="Pp"><i>Stringification Example</i></p>
<p class="Pp">Suppose we have two tables:
    <span class="Li">&quot;Product&quot;</span> and
    <span class="Li">&quot;Category&quot;</span>. The table specifications
  are:</p>
<p class="Pp"></p>
<pre>  Product(id, Description, category)
  Category(id, Description)
</pre>
<p class="Pp"><span class="Li">&quot;category&quot;</span> is a foreign key into
    the Category table.</p>
<p class="Pp">If you have a Product object <span class="Li">$obj</span> and
    write something like</p>
<p class="Pp"></p>
<pre>  print $obj-&gt;category
</pre>
<p class="Pp">things will not work as expected.</p>
<p class="Pp">To obtain, for example, the category description, you should add
    this method to the class defining the Category table:</p>
<p class="Pp"></p>
<pre>  use overload &quot;&quot; =&gt; sub {
      my $self = shift;
      return $self-&gt;Description;
  }, fallback =&gt; 1;
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Want_to_know_if_find_or_create_found_or_created_a_row?"><a class="permalink" href="#Want_to_know_if_find_or_create_found_or_created_a_row?">Want
  to know if find_or_create found or created a row?</a></h2>
<p class="Pp">Just use <span class="Li">&quot;find_or_new&quot;</span> instead,
    then check <span class="Li">&quot;in_storage&quot;</span>:</p>
<p class="Pp"></p>
<pre>  my $obj = $rs-&gt;find_or_new({ blah =&gt; 'blarg' });
  unless ($obj-&gt;in_storage) {
    $obj-&gt;insert;
    # do whatever else you wanted if it was a new row
  }
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Static_sub-classing_DBIx::Class_result_classes"><a class="permalink" href="#Static_sub-classing_DBIx::Class_result_classes">Static
  sub-classing DBIx::Class result classes</a></h2>
<p class="Pp">AKA adding additional relationships/methods/etc. to a model for a
    specific usage of the (shared) model.</p>
<p class="Pp"><b>Schema definition</b></p>
<p class="Pp"></p>
<pre>    package My::App::Schema;
    use base 'DBIx::Class::Schema';
    # load subclassed classes from My::App::Schema::Result/ResultSet
    __PACKAGE__-&gt;load_namespaces;
    # load classes from shared model
    load_classes({
        'My::Shared::Model::Result' =&gt; [qw/
            Foo
            Bar
        /]});
    1;
</pre>
<p class="Pp"><b>Result-Subclass definition</b></p>
<p class="Pp"></p>
<pre>    package My::App::Schema::Result::Baz;
    use strict;
    use warnings;
    use base 'My::Shared::Model::Result::Baz';
    # WARNING: Make sure you call table() again in your subclass,
    # otherwise DBIx::Class::ResultSourceProxy::Table will not be called
    # and the class name is not correctly registered as a source
    __PACKAGE__-&gt;table('baz');
    sub additional_method {
        return &quot;I'm an additional method only needed by this app&quot;;
    }
    1;
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Dynamic_Sub-classing_DBIx::Class_proxy_classes"><a class="permalink" href="#Dynamic_Sub-classing_DBIx::Class_proxy_classes">Dynamic
  Sub-classing DBIx::Class proxy classes</a></h2>
<p class="Pp">AKA multi-class object inflation from one table</p>
<p class="Pp">DBIx::Class classes are proxy classes, therefore some different
    techniques need to be employed for more than basic subclassing. In this
    example we have a single user table that carries a boolean bit for admin. We
    would like to give the admin users objects (DBIx::Class::Row) the same
    methods as a regular user but also special admin only methods. It doesn't
    make sense to create two separate proxy-class files for this. We would be
    copying all the user methods into the Admin class. There is a cleaner way to
    accomplish this.</p>
<p class="Pp">Overriding the <span class="Li">&quot;inflate_result&quot;</span>
    method within the User proxy-class gives us the effect we want. This method
    is called by DBIx::Class::ResultSet when inflating a result from storage. So
    we grab the object being returned, inspect the values we are looking for,
    bless it if it's an admin object, and then return it. See the example
  below:</p>
<p class="Pp"><b>Schema Definition</b></p>
<p class="Pp"></p>
<pre>    package My::Schema;
    use base qw/DBIx::Class::Schema/;
    __PACKAGE__-&gt;load_namespaces;
    1;
</pre>
<p class="Pp"><b>Proxy-Class definitions</b></p>
<p class="Pp"></p>
<pre>    package My::Schema::Result::User;
    use strict;
    use warnings;
    use base qw/DBIx::Class::Core/;
    ### Define what our admin class is, for ensure_class_loaded()
    my $admin_class = __PACKAGE__ . '::Admin';
    __PACKAGE__-&gt;table('users');
    __PACKAGE__-&gt;add_columns(qw/user_id   email    password
                                firstname lastname active
                                admin/);
    __PACKAGE__-&gt;set_primary_key('user_id');
    sub inflate_result {
        my $self = shift;
        my $ret = $self-&gt;next::method(@_);
        if( $ret-&gt;admin ) {### If this is an admin, rebless for extra functions
            $self-&gt;ensure_class_loaded( $admin_class );
            bless $ret, $admin_class;
        }
        return $ret;
    }
    sub hello {
        print &quot;I am a regular user.\n&quot;;
        return ;
    }
    1;
    package My::Schema::Result::User::Admin;
    use strict;
    use warnings;
    use base qw/My::Schema::Result::User/;
    # This line is important
    __PACKAGE__-&gt;table('users');
    sub hello
    {
        print &quot;I am an admin.\n&quot;;
        return;
    }
    sub do_admin_stuff
    {
        print &quot;I am doing admin stuff\n&quot;;
        return ;
    }
    1;
</pre>
<p class="Pp"><b>Test File</b> test.pl</p>
<p class="Pp"></p>
<pre>    use warnings;
    use strict;
    use My::Schema;
    my $user_data = { email    =&gt; 'someguy@place.com',
                      password =&gt; 'pass1',
                      admin    =&gt; 0 };
    my $admin_data = { email    =&gt; 'someadmin@adminplace.com',
                       password =&gt; 'pass2',
                       admin    =&gt; 1 };
    my $schema = My::Schema-&gt;connection('dbi:Pg:dbname=test');
    $schema-&gt;resultset('User')-&gt;create( $user_data );
    $schema-&gt;resultset('User')-&gt;create( $admin_data );
    ### Now we search for them
    my $user = $schema-&gt;resultset('User')-&gt;single( $user_data );
    my $admin = $schema-&gt;resultset('User')-&gt;single( $admin_data );
    print ref $user, &quot;\n&quot;;
    print ref $admin, &quot;\n&quot;;
    print $user-&gt;password , &quot;\n&quot;; # pass1
    print $admin-&gt;password , &quot;\n&quot;;# pass2; inherited from User
    print $user-&gt;hello , &quot;\n&quot;;# I am a regular user.
    print $admin-&gt;hello, &quot;\n&quot;;# I am an admin.
    ### The statement below will NOT print
    print &quot;I can do admin stuff\n&quot; if $user-&gt;can('do_admin_stuff');
    ### The statement below will print
    print &quot;I can do admin stuff\n&quot; if $admin-&gt;can('do_admin_stuff');
</pre>
<p class="Pp">Alternatively you can use DBIx::Class::DynamicSubclass that
    implements exactly the above functionality.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Skip_result_object_creation_for_faster_results"><a class="permalink" href="#Skip_result_object_creation_for_faster_results">Skip
  result object creation for faster results</a></h2>
<p class="Pp">DBIx::Class is not built for speed, it's built for convenience and
    ease of use, but sometimes you just need to get the data, and skip the fancy
    objects.</p>
<p class="Pp">To do this simply use
  DBIx::Class::ResultClass::HashRefInflator.</p>
<p class="Pp"></p>
<pre> my $rs = $schema-&gt;resultset('CD');
 $rs-&gt;result_class('DBIx::Class::ResultClass::HashRefInflator');
 my $hash_ref = $rs-&gt;find(1);
</pre>
<p class="Pp">Wasn't that easy?</p>
<p class="Pp">Beware, changing the Result class using &quot;result_class&quot;
    in DBIx::Class::ResultSet will replace any existing class completely
    including any special components loaded using load_components, eg
    DBIx::Class::InflateColumn::DateTime.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Get_raw_data_for_blindingly_fast_results"><a class="permalink" href="#Get_raw_data_for_blindingly_fast_results">Get
  raw data for blindingly fast results</a></h2>
<p class="Pp">If the HashRefInflator solution above is not fast enough for you,
    you can use a DBIx::Class to return values exactly as they come out of the
    database with none of the convenience methods wrapped round them.</p>
<p class="Pp">This is used like so:</p>
<p class="Pp"></p>
<pre>  my $cursor = $rs-&gt;cursor
  while (my @vals = $cursor-&gt;next) {
      # use $val[0..n] here
  }
</pre>
<p class="Pp">You will need to map the array offsets to particular columns (you
    can use the &quot;select&quot; in DBIx::Class::ResultSet attribute of
    &quot;search&quot; in DBIx::Class::ResultSet to force ordering).</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="RESULTSET_OPERATIONS"><a class="permalink" href="#RESULTSET_OPERATIONS">RESULTSET
  OPERATIONS</a></h1>
<section class="Ss">
<h2 class="Ss" id="Getting_Schema_from_a_ResultSet"><a class="permalink" href="#Getting_Schema_from_a_ResultSet">Getting
  Schema from a ResultSet</a></h2>
<p class="Pp">To get the DBIx::Class::Schema object from a ResultSet, do the
    following:</p>
<p class="Pp"></p>
<pre> $rs-&gt;result_source-&gt;schema
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Getting_Columns_Of_Data"><a class="permalink" href="#Getting_Columns_Of_Data">Getting
  Columns Of Data</a></h2>
<p class="Pp">AKA Aggregating Data</p>
<p class="Pp">If you want to find the sum of a particular column there are
    several ways, the obvious one is to use search:</p>
<p class="Pp"></p>
<pre>  my $rs = $schema-&gt;resultset('Items')-&gt;search(
    {},
    {
       select =&gt; [ { sum =&gt; 'Cost' } ],
       as     =&gt; [ 'total_cost' ], # remember this 'as' is for DBIx::Class::ResultSet not SQL
    }
  );
  my $tc = $rs-&gt;first-&gt;get_column('total_cost');
</pre>
<p class="Pp">Or, you can use the DBIx::Class::ResultSetColumn, which gets
    returned when you ask the <span class="Li">&quot;ResultSet&quot;</span> for
    a column using <span class="Li">&quot;get_column&quot;</span>:</p>
<p class="Pp"></p>
<pre>  my $cost = $schema-&gt;resultset('Items')-&gt;get_column('Cost');
  my $tc = $cost-&gt;sum;
</pre>
<p class="Pp">With this you can also do:</p>
<p class="Pp"></p>
<pre>  my $minvalue = $cost-&gt;min;
  my $maxvalue = $cost-&gt;max;
</pre>
<p class="Pp">Or just iterate through the values of this column only:</p>
<p class="Pp"></p>
<pre>  while ( my $c = $cost-&gt;next ) {
    print $c;
  }
  foreach my $c ($cost-&gt;all) {
    print $c;
  }
</pre>
<p class="Pp"><span class="Li">&quot;ResultSetColumn&quot;</span> only has a
    limited number of built-in functions. If you need one that it doesn't have,
    then you can use the <span class="Li">&quot;func&quot;</span> method
    instead:</p>
<p class="Pp"></p>
<pre>  my $avg = $cost-&gt;func('AVERAGE');
</pre>
<p class="Pp">This will cause the following SQL statement to be run:</p>
<p class="Pp"></p>
<pre>  SELECT AVERAGE(Cost) FROM Items me
</pre>
<p class="Pp">Which will of course only work if your database supports this
    function. See DBIx::Class::ResultSetColumn for more documentation.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Creating_a_result_set_from_a_set_of_rows"><a class="permalink" href="#Creating_a_result_set_from_a_set_of_rows">Creating
  a result set from a set of rows</a></h2>
<p class="Pp">Sometimes you have a (set of) result objects that you want to put
    into a resultset without the need to hit the DB again. You can do that by
    using the set_cache method:</p>
<p class="Pp"></p>
<pre> my @uploadable_groups;
 while (my $group = $groups-&gt;next) {
   if ($group-&gt;can_upload($self)) {
     push @uploadable_groups, $group;
   }
 }
 my $new_rs = $self-&gt;result_source-&gt;resultset;
 $new_rs-&gt;set_cache(\@uploadable_groups);
 return $new_rs;
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="USING_RELATIONSHIPS"><a class="permalink" href="#USING_RELATIONSHIPS">USING
  RELATIONSHIPS</a></h1>
<section class="Ss">
<h2 class="Ss" id="Create_a_new_row_in_a_related_table"><a class="permalink" href="#Create_a_new_row_in_a_related_table">Create
  a new row in a related table</a></h2>
<pre>  my $author = $book-&gt;create_related('author', { name =&gt; 'Fred'});
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Search_in_a_related_table"><a class="permalink" href="#Search_in_a_related_table">Search
  in a related table</a></h2>
<p class="Pp">Only searches for books named 'Titanic' by the author in
    <span class="Li">$author</span>.</p>
<p class="Pp"></p>
<pre>  my $books_rs = $author-&gt;search_related('books', { name =&gt; 'Titanic' });
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Delete_data_in_a_related_table"><a class="permalink" href="#Delete_data_in_a_related_table">Delete
  data in a related table</a></h2>
<p class="Pp">Deletes only the book named Titanic by the author in
    <span class="Li">$author</span>.</p>
<p class="Pp"></p>
<pre>  $author-&gt;delete_related('books', { name =&gt; 'Titanic' });
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Ordering_a_relationship_result_set"><a class="permalink" href="#Ordering_a_relationship_result_set">Ordering
  a relationship result set</a></h2>
<p class="Pp">If you always want a relation to be ordered, you can specify this
    when you create the relationship.</p>
<p class="Pp">To order <span class="Li">&quot;$book-&gt;pages&quot;</span> by
    descending page_number, create the relation as follows:</p>
<p class="Pp"></p>
<pre>  __PACKAGE__-&gt;has_many('pages' =&gt; 'Page', 'book', { order_by =&gt; { -desc =&gt; 'page_number'} } );
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Filtering_a_relationship_result_set"><a class="permalink" href="#Filtering_a_relationship_result_set">Filtering
  a relationship result set</a></h2>
<p class="Pp">If you want to get a filtered result set, you can just add to
    <span class="Li">$attr</span> as follows:</p>
<p class="Pp"></p>
<pre> __PACKAGE__-&gt;has_many('pages' =&gt; 'Page', 'book', { where =&gt; { scrap =&gt; 0 } } );
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Many-to-many_relationship_bridges"><a class="permalink" href="#Many-to-many_relationship_bridges">Many-to-many
  relationship bridges</a></h2>
<p class="Pp">This is straightforward using ManyToMany:</p>
<p class="Pp"></p>
<pre>  package My::User;
  use base 'DBIx::Class::Core';
  __PACKAGE__-&gt;table('user');
  __PACKAGE__-&gt;add_columns(qw/id name/);
  __PACKAGE__-&gt;set_primary_key('id');
  __PACKAGE__-&gt;has_many('user_address' =&gt; 'My::UserAddress', 'user');
  __PACKAGE__-&gt;many_to_many('addresses' =&gt; 'user_address', 'address');
  package My::UserAddress;
  use base 'DBIx::Class::Core';
  __PACKAGE__-&gt;table('user_address');
  __PACKAGE__-&gt;add_columns(qw/user address/);
  __PACKAGE__-&gt;set_primary_key(qw/user address/);
  __PACKAGE__-&gt;belongs_to('user' =&gt; 'My::User');
  __PACKAGE__-&gt;belongs_to('address' =&gt; 'My::Address');
  package My::Address;
  use base 'DBIx::Class::Core';
  __PACKAGE__-&gt;table('address');
  __PACKAGE__-&gt;add_columns(qw/id street town area_code country/);
  __PACKAGE__-&gt;set_primary_key('id');
  __PACKAGE__-&gt;has_many('user_address' =&gt; 'My::UserAddress', 'address');
  __PACKAGE__-&gt;many_to_many('users' =&gt; 'user_address', 'user');
  $rs = $user-&gt;addresses(); # get all addresses for a user
  $rs = $address-&gt;users(); # get all users for an address
  my $address = $user-&gt;add_to_addresses(    # returns a My::Address instance,
                                            # NOT a My::UserAddress instance!
    {
      country =&gt; 'United Kingdom',
      area_code =&gt; 'XYZ',
      town =&gt; 'London',
      street =&gt; 'Sesame',
    }
  );
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Relationships_across_"><a class="permalink" href="#Relationships_across_">Relationships
  across DB schemas</a></h2>
<p class="Pp">Mapping relationships across DB schemas is easy as long as the
    schemas themselves are all accessible via the same DBI connection. In most
    cases, this means that they are on the same database host as each other and
    your connecting database user has the proper permissions to them.</p>
<p class="Pp">To accomplish this one only needs to specify the DB schema name in
    the table declaration, like so...</p>
<p class="Pp"></p>
<pre>  package MyApp::Schema::Result::Artist;
  use base qw/DBIx::Class::Core/;
  __PACKAGE__-&gt;table('database1.artist'); # will use &quot;database1.artist&quot; in FROM clause
  __PACKAGE__-&gt;add_columns(qw/ artist_id name /);
  __PACKAGE__-&gt;set_primary_key('artist_id');
  __PACKAGE__-&gt;has_many('cds' =&gt; 'MyApp::Schema::Result::Cd');
  1;
</pre>
<p class="Pp">Whatever string you specify there will be used to build the
    &quot;FROM&quot; clause in SQL queries.</p>
<p class="Pp">The big drawback to this is you now have DB schema names hardcoded
    in your class files. This becomes especially troublesome if you have
    multiple instances of your application to support a change lifecycle (e.g.
    DEV, TEST, PROD) and the DB schemas are named based on the environment (e.g.
    database1_dev).</p>
<p class="Pp">However, one can dynamically &quot;map&quot; to the proper DB
    schema by overriding the connection method in your Schema class and building
    a renaming facility, like so:</p>
<p class="Pp"></p>
<pre>  package MyApp::Schema;
  use Moose;
  extends 'DBIx::Class::Schema';
  around connection =&gt; sub {
    my ( $inner, $self, $dsn, $username, $pass, $attr ) = ( shift, @_ );
    my $postfix = delete $attr-&gt;{schema_name_postfix};
    $inner-&gt;(@_);
    if ( $postfix ) {
        $self-&gt;append_db_name($postfix);
    }
  };
  sub append_db_name {
    my ( $self, $postfix ) = @_;
    my @sources_with_db
        = grep
            { $_-&gt;name =~ /^\w+\./mx }
            map
                { $self-&gt;source($_) }
                $self-&gt;sources;
    foreach my $source (@sources_with_db) {
        my $name = $source-&gt;name;
        $name =~ s{^(\w+)\.}{${1}${postfix}\.}mx;
        $source-&gt;name($name);
    }
  }
  1;
</pre>
<p class="Pp">By overriding the connection method and extracting a custom option
    from the provided \%attr hashref one can then simply iterate over all the
    Schema's ResultSources, renaming them as needed.</p>
<p class="Pp">To use this facility, simply add or modify the \%attr hashref that
    is passed to connection, as follows:</p>
<p class="Pp"></p>
<pre>  my $schema
    = MyApp::Schema-&gt;connect(
      $dsn,
      $user,
      $pass,
      {
        schema_name_postfix =&gt; '_dev'
        # ... Other options as desired ...
      })
</pre>
<p class="Pp">Obviously, one could accomplish even more advanced mapping via a
    hash map or a callback routine.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="TRANSACTIONS"><a class="permalink" href="#TRANSACTIONS">TRANSACTIONS</a></h1>
<section class="Ss">
<h2 class="Ss" id="Transactions_with_txn_do"><a class="permalink" href="#Transactions_with_txn_do">Transactions
  with txn_do</a></h2>
<p class="Pp">As of version 0.04001, there is improved transaction support in
    DBIx::Class::Storage and DBIx::Class::Schema. Here is an example of the
    recommended way to use it:</p>
<p class="Pp"></p>
<pre>  my $genus = $schema-&gt;resultset('Genus')-&gt;find(12);
  my $coderef2 = sub {
    $genus-&gt;extinct(1);
    $genus-&gt;update;
  };
  my $coderef1 = sub {
    $genus-&gt;add_to_species({ name =&gt; 'troglodyte' });
    $genus-&gt;wings(2);
    $genus-&gt;update;
    $schema-&gt;txn_do($coderef2); # Can have a nested transaction. Only the outer will actualy commit
    return $genus-&gt;species;
  };
  use Try::Tiny;
  my $rs;
  try {
    $rs = $schema-&gt;txn_do($coderef1);
  } catch {
    # Transaction failed
    die &quot;the sky is falling!&quot;           #
      if ($_ =~ /Rollback failed/);     # Rollback failed
    deal_with_failed_transaction();
  };
</pre>
<p class="Pp">Note: by default <span class="Li">&quot;txn_do&quot;</span> will
    re-run the coderef one more time if an error occurs due to client
    disconnection (e.g. the server is bounced). You need to make sure that your
    coderef can be invoked multiple times without terrible side effects.</p>
<p class="Pp">Nested transactions will work as expected. That is, only the
    outermost transaction will actually issue a commit to the
    <span class="Li">$dbh</span>, and a rollback at any level of any transaction
    will cause the entire nested transaction to fail.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Nested_transactions_and_auto-savepoints"><a class="permalink" href="#Nested_transactions_and_auto-savepoints">Nested
  transactions and auto-savepoints</a></h2>
<p class="Pp">If savepoints are supported by your RDBMS, it is possible to
    achieve true nested transactions with minimal effort. To enable
    auto-savepoints via nested transactions, supply the
    <span class="Li">&quot;auto_savepoint = 1&quot;</span> connection
  attribute.</p>
<p class="Pp">Here is an example of true nested transactions. In the example, we
    start a big task which will create several rows. Generation of data for each
    row is a fragile operation and might fail. If we fail creating something,
    depending on the type of failure, we want to abort the whole task, or only
    skip the failed row.</p>
<p class="Pp"></p>
<pre>  my $schema = MySchema-&gt;connect(&quot;dbi:Pg:dbname=my_db&quot;);
  # Start a transaction. Every database change from here on will only be
  # committed into the database if the try block succeeds.
  use Try::Tiny;
  my $exception;
  try {
    $schema-&gt;txn_do(sub {
      # SQL: BEGIN WORK;
      my $job = $schema-&gt;resultset('Job')-&gt;create({ name=&gt; 'big job' });
      # SQL: INSERT INTO job ( name) VALUES ( 'big job' );
      for (1..10) {
        # Start a nested transaction, which in fact sets a savepoint.
        try {
          $schema-&gt;txn_do(sub {
            # SQL: SAVEPOINT savepoint_0;
            my $thing = $schema-&gt;resultset('Thing')-&gt;create({ job=&gt;$job-&gt;id });
            # SQL: INSERT INTO thing ( job) VALUES ( 1 );
            if (rand &gt; 0.8) {
              # This will generate an error, thus setting $@
              $thing-&gt;update({force_fail=&gt;'foo'});
              # SQL: UPDATE thing SET force_fail = 'foo'
              #      WHERE ( id = 42 );
            }
          });
        } catch {
          # SQL: ROLLBACK TO SAVEPOINT savepoint_0;
          # There was an error while creating a $thing. Depending on the error
          # we want to abort the whole transaction, or only rollback the
          # changes related to the creation of this $thing
          # Abort the whole job
          if ($_ =~ /horrible_problem/) {
            print &quot;something horrible happend, aborting job!&quot;;
            die $_;                # rethrow error
          }
          # Ignore this $thing, report the error, and continue with the
          # next $thing
          print &quot;Cannot create thing: $_&quot;;
        }
        # There was no error, so save all changes since the last
        # savepoint.
        # SQL: RELEASE SAVEPOINT savepoint_0;
      }
    });
  } catch {
    $exception = $_;
  };
  if ($exception) {
    # There was an error while handling the $job. Rollback all changes
    # since the transaction started, including the already committed
    # ('released') savepoints. There will be neither a new $job nor any
    # $thing entry in the database.
    # SQL: ROLLBACK;
    print &quot;ERROR: $exception\n&quot;;
  }
  else {
    # There was no error while handling the $job. Commit all changes.
    # Only now other connections can see the newly created $job and
    # @things.
    # SQL: COMMIT;
    print &quot;Ok\n&quot;;
  }
</pre>
<p class="Pp">In this example it might be hard to see where the rollbacks,
    releases and commits are happening, but it works just the same as for plain
    &lt;txn_do&gt;: If the <span class="Li">&quot;try&quot;</span>-block around
    <span class="Li">&quot;txn_do&quot;</span> fails, a rollback is issued. If
    the <span class="Li">&quot;try&quot;</span> succeeds, the transaction is
    committed (or the savepoint released).</p>
<p class="Pp">While you can get more fine-grained control using
    <span class="Li">&quot;svp_begin&quot;</span>,
    <span class="Li">&quot;svp_release&quot;</span> and
    <span class="Li">&quot;svp_rollback&quot;</span>, it is strongly recommended
    to use <span class="Li">&quot;txn_do&quot;</span> with coderefs.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Simple_Transactions_with_DBIx::Class::Storage::TxnScopeGuard"><a class="permalink" href="#Simple_Transactions_with_DBIx::Class::Storage::TxnScopeGuard">Simple
  Transactions with DBIx::Class::Storage::TxnScopeGuard</a></h2>
<p class="Pp">An easy way to use transactions is with
    DBIx::Class::Storage::TxnScopeGuard. See &quot;Automatically creating
    related objects&quot; for an example.</p>
<p class="Pp">Note that unlike txn_do, TxnScopeGuard will only make sure the
    connection is alive when issuing the
    <span class="Li">&quot;BEGIN&quot;</span> statement. It will not (and really
    can not) retry if the server goes away mid-operations, unlike
    <span class="Li">&quot;txn_do&quot;</span>.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="SQL"><a class="permalink" href="#SQL">SQL</a></h1>
<section class="Ss">
<h2 class="Ss" id="Creating_Schemas_From_An_Existing_Database"><a class="permalink" href="#Creating_Schemas_From_An_Existing_Database">Creating
  Schemas From An Existing Database</a></h2>
<p class="Pp">DBIx::Class::Schema::Loader will connect to a database and create
    a DBIx::Class::Schema and associated sources by examining the database.</p>
<p class="Pp">The recommend way of achieving this is to use the dbicdump utility
    or the Catalyst helper, as described in Manual::Intro.</p>
<p class="Pp">Alternatively, use the make_schema_at method:</p>
<p class="Pp"></p>
<pre>  perl -MDBIx::Class::Schema::Loader=make_schema_at,dump_to_dir:./lib \
    -e 'make_schema_at(&quot;My::Schema&quot;, \
    { db_schema =&gt; 'myschema', components =&gt; [&quot;InflateColumn::DateTime&quot;] }, \
    [ &quot;dbi:Pg:dbname=foo&quot;, &quot;username&quot;, &quot;password&quot; ])'
</pre>
<p class="Pp">This will create a tree of files rooted at
    <span class="Li">&quot;./lib/My/Schema/&quot;</span> containing source
    definitions for all the tables found in the
    <span class="Li">&quot;myschema&quot;</span> schema in the
    <span class="Li">&quot;foo&quot;</span> database.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Creating_"><a class="permalink" href="#Creating_">Creating
  DDL SQL</a></h2>
<p class="Pp">The following functionality requires you to have SQL::Translator
    (also known as &quot;SQL Fairy&quot;) installed.</p>
<p class="Pp">To create a set of database-specific .sql files for the above
    schema:</p>
<p class="Pp"></p>
<pre> my $schema = My::Schema-&gt;connect($dsn);
 $schema-&gt;create_ddl_dir(['MySQL', 'SQLite', 'PostgreSQL'],
                        '0.1',
                        './dbscriptdir/'
                        );
</pre>
<p class="Pp">By default this will create schema files in the current directory,
    for MySQL, SQLite and PostgreSQL, using the <span class="Li">$VERSION</span>
    from your Schema.pm.</p>
<p class="Pp">To create a new database using the schema:</p>
<p class="Pp"></p>
<pre> my $schema = My::Schema-&gt;connect($dsn);
 $schema-&gt;deploy({ add_drop_table =&gt; 1});
</pre>
<p class="Pp">To import created .sql files using the mysql client:</p>
<p class="Pp"></p>
<pre>  mysql -h &quot;host&quot; -D &quot;database&quot; -u &quot;user&quot; -p &lt; My_Schema_1.0_MySQL.sql
</pre>
<p class="Pp">To create <span class="Li">&quot;ALTER TABLE&quot;</span>
    conversion scripts to update a database to a newer version of your schema at
    a later point, first set a new <span class="Li">$VERSION</span> in your
    Schema file, then:</p>
<p class="Pp"></p>
<pre> my $schema = My::Schema-&gt;connect($dsn);
 $schema-&gt;create_ddl_dir(['MySQL', 'SQLite', 'PostgreSQL'],
                         '0.2',
                         '/dbscriptdir/',
                         '0.1'
                         );
</pre>
<p class="Pp">This will produce new database-specific .sql files for the new
    version of the schema, plus scripts to convert from version 0.1 to 0.2. This
    requires that the files for 0.1 as created above are available in the given
    directory to diff against.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Select_from_dual"><a class="permalink" href="#Select_from_dual">Select
  from dual</a></h2>
<p class="Pp">Dummy tables are needed by some databases to allow calling
    functions or expressions that aren't based on table content, for examples of
    how this applies to various database types, see:
    &lt;http://troels.arvin.dk/db/rdbms/#other-dummy_table&gt;.</p>
<p class="Pp">Note: If you're using Oracles dual table don't <b>ever</b> do
    anything other than a select, if you CRUD on your dual table you *will*
    break your database.</p>
<p class="Pp">Make a table class as you would for any other table</p>
<p class="Pp"></p>
<pre>  package MyAppDB::Dual;
  use strict;
  use warnings;
  use base 'DBIx::Class::Core';
  __PACKAGE__-&gt;table(&quot;Dual&quot;);
  __PACKAGE__-&gt;add_columns(
    &quot;dummy&quot;,
    { data_type =&gt; &quot;VARCHAR2&quot;, is_nullable =&gt; 0, size =&gt; 1 },
  );
</pre>
<p class="Pp">Once you've loaded your table class select from it using
    <span class="Li">&quot;select&quot;</span> and
    <span class="Li">&quot;as&quot;</span> instead of
    <span class="Li">&quot;columns&quot;</span></p>
<p class="Pp"></p>
<pre>  my $rs = $schema-&gt;resultset('Dual')-&gt;search(undef,
    { select =&gt; [ 'sydate' ],
      as     =&gt; [ 'now' ]
    },
  );
</pre>
<p class="Pp">All you have to do now is be careful how you access your
    resultset, the below will not work because there is no column called 'now'
    in the Dual table class</p>
<p class="Pp"></p>
<pre>  while (my $dual = $rs-&gt;next) {
    print $dual-&gt;now.&quot;\n&quot;;
  }
  # Can't locate object method &quot;now&quot; via package &quot;MyAppDB::Dual&quot; at headshot.pl line 23.
</pre>
<p class="Pp">You could of course use 'dummy' in
    <span class="Li">&quot;as&quot;</span> instead of 'now', or
    <span class="Li">&quot;add_columns&quot;</span> to your Dual class for
    whatever you wanted to select from dual, but that's just silly, instead use
    <span class="Li">&quot;get_column&quot;</span></p>
<p class="Pp"></p>
<pre>  while (my $dual = $rs-&gt;next) {
    print $dual-&gt;get_column('now').&quot;\n&quot;;
  }
</pre>
<p class="Pp">Or use <span class="Li">&quot;cursor&quot;</span></p>
<p class="Pp"></p>
<pre>  my $cursor = $rs-&gt;cursor;
  while (my @vals = $cursor-&gt;next) {
    print $vals[0].&quot;\n&quot;;
  }
</pre>
<p class="Pp">In case you're going to use this &quot;trick&quot; together with
    &quot;deploy&quot; in DBIx::Class::Schema or &quot;create_ddl_dir&quot; in
    DBIx::Class::Schema a table called &quot;dual&quot; will be created in your
    current schema. This would overlap &quot;sys.dual&quot; and you could not
    fetch &quot;sysdate&quot; or &quot;sequence.nextval&quot; anymore from dual.
    To avoid this problem, just tell SQL::Translator to not create table
  dual:</p>
<p class="Pp"></p>
<pre>    my $sqlt_args = {
        add_drop_table =&gt; 1,
        parser_args    =&gt; { sources =&gt; [ grep $_ ne 'Dual', schema-&gt;sources ] },
    };
    $schema-&gt;create_ddl_dir( [qw/Oracle/], undef, './sql', undef, $sqlt_args );
</pre>
<p class="Pp">Or use DBIx::Class::ResultClass::HashRefInflator</p>
<p class="Pp"></p>
<pre>  $rs-&gt;result_class('DBIx::Class::ResultClass::HashRefInflator');
  while ( my $dual = $rs-&gt;next ) {
    print $dual-&gt;{now}.&quot;\n&quot;;
  }
</pre>
<p class="Pp">Here are some example <span class="Li">&quot;select&quot;</span>
    conditions to illustrate the different syntax you could use for doing stuff
    like <span class="Li">&quot;oracles.heavily(nested(functions_can('take',
    'lots'), OF), 'args')&quot;</span></p>
<p class="Pp"></p>
<pre>  # get a sequence value
  select =&gt; [ 'A_SEQ.nextval' ],
  # get create table sql
  select =&gt; [ { 'dbms_metadata.get_ddl' =&gt; [ &quot;'TABLE'&quot;, &quot;'ARTIST'&quot; ]} ],
  # get a random num between 0 and 100
  select =&gt; [ { &quot;trunc&quot; =&gt; [ { &quot;dbms_random.value&quot; =&gt; [0,100] } ]} ],
  # what year is it?
  select =&gt; [ { 'extract' =&gt; [ \'year from sysdate' ] } ],
  # do some math
  select =&gt; [ {'round' =&gt; [{'cos' =&gt; [ \'180 * 3.14159265359/180' ]}]}],
  # which day of the week were you born on?
  select =&gt; [{'to_char' =&gt; [{'to_date' =&gt; [ &quot;'25-DEC-1980'&quot;, &quot;'dd-mon-yyyy'&quot; ]}, &quot;'day'&quot;]}],
  # select 16 rows from dual
  select   =&gt; [ &quot;'hello'&quot; ],
  as       =&gt; [ 'world' ],
  group_by =&gt; [ 'cube( 1, 2, 3, 4 )' ],
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Adding_Indexes_And_Functions_To_Your_"><a class="permalink" href="#Adding_Indexes_And_Functions_To_Your_">Adding
  Indexes And Functions To Your SQL</a></h2>
<p class="Pp">Often you will want indexes on columns on your table to speed up
    searching. To do this, create a method called
    <span class="Li">&quot;sqlt_deploy_hook&quot;</span> in the relevant source
    class (refer to the advanced callback system if you wish to share a hook
    between multiple sources):</p>
<p class="Pp"></p>
<pre> package My::Schema::Result::Artist;
 __PACKAGE__-&gt;table('artist');
 __PACKAGE__-&gt;add_columns(id =&gt; { ... }, name =&gt; { ... })
 sub sqlt_deploy_hook {
   my ($self, $sqlt_table) = @_;
   $sqlt_table-&gt;add_index(name =&gt; 'idx_name', fields =&gt; ['name']);
 }
 1;
</pre>
<p class="Pp">Sometimes you might want to change the index depending on the type
    of the database for which SQL is being generated:</p>
<p class="Pp"></p>
<pre>  my ($db_type = $sqlt_table-&gt;schema-&gt;translator-&gt;producer_type)
    =~ s/^SQL::Translator::Producer:://;
</pre>
<p class="Pp">You can also add hooks to the schema level to stop certain tables
    being created:</p>
<p class="Pp"></p>
<pre> package My::Schema;
 ...
 sub sqlt_deploy_hook {
   my ($self, $sqlt_schema) = @_;
   $sqlt_schema-&gt;drop_table('table_name');
 }
</pre>
<p class="Pp">You could also add views, procedures or triggers to the output
    using &quot;add_view&quot; in SQL::Translator::Schema,
    &quot;add_procedure&quot; in SQL::Translator::Schema or
    &quot;add_trigger&quot; in SQL::Translator::Schema.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Schema_versioning"><a class="permalink" href="#Schema_versioning">Schema
  versioning</a></h2>
<p class="Pp">The following example shows simplistically how you might use
    DBIx::Class to deploy versioned schemas to your customers. The basic process
    is as follows:</p>
<dl class="Bl-tag">
  <dt>1.</dt>
  <dd>Create a DBIx::Class schema</dd>
  <dt>2.</dt>
  <dd>Save the schema</dd>
  <dt>3.</dt>
  <dd>Deploy to customers</dd>
  <dt>4.</dt>
  <dd>Modify schema to change functionality</dd>
  <dt>5.</dt>
  <dd>Deploy update to customers</dd>
</dl>
<p class="Pp"><b>Create a DBIx::Class schema</b></p>
<p class="Pp">This can either be done manually, or generated from an existing
    database as described under &quot;Creating Schemas From An Existing
    Database&quot;</p>
<p class="Pp"><b>Save the schema</b></p>
<p class="Pp">Call &quot;create_ddl_dir&quot; in DBIx::Class::Schema as above
    under &quot;Creating DDL SQL&quot;.</p>
<p class="Pp"><b>Deploy to customers</b></p>
<p class="Pp">There are several ways you could deploy your schema. These are
    probably beyond the scope of this recipe, but might include:</p>
<dl class="Bl-tag">
  <dt>1.</dt>
  <dd>Require customer to apply manually using their RDBMS.</dd>
  <dt>2.</dt>
  <dd>Package along with your app, making database dump/schema update/tests all
      part of your install.</dd>
</dl>
<p class="Pp"><b>Modify the schema to change functionality</b></p>
<p class="Pp">As your application evolves, it may be necessary to modify your
    schema to change functionality. Once the changes are made to your schema in
    DBIx::Class, export the modified schema and the conversion scripts as in
    &quot;Creating DDL SQL&quot;.</p>
<p class="Pp"><b>Deploy update to customers</b></p>
<p class="Pp">Add the DBIx::Class::Schema::Versioned schema component to your
    Schema class. This will add a new table to your database called
    <span class="Li">&quot;dbix_class_schema_vesion&quot;</span> which will keep
    track of which version is installed and warn if the user tries to run a
    newer schema version than the database thinks it has.</p>
<p class="Pp">Alternatively, you can send the conversion SQL scripts to your
    customers as above.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Setting_quoting_for_the_generated_"><a class="permalink" href="#Setting_quoting_for_the_generated_">Setting
  quoting for the generated SQL</a></h2>
<p class="Pp">If the database contains column names with spaces and/or reserved
    words, they need to be quoted in the SQL queries. This is done using:</p>
<p class="Pp"></p>
<pre> $schema-&gt;storage-&gt;sql_maker-&gt;quote_char([ qw/[ ]/] );
 $schema-&gt;storage-&gt;sql_maker-&gt;name_sep('.');
</pre>
<p class="Pp">The first sets the quote characters. Either a pair of matching
    brackets, or a <span class="Li">&quot;&quot;&quot;</span> or
    <span class="Li">&quot;'&quot;</span>:</p>
<p class="Pp"></p>
<pre> $schema-&gt;storage-&gt;sql_maker-&gt;quote_char('&quot;');
</pre>
<p class="Pp">Check the documentation of your database for the correct quote
    characters to use. <span class="Li">&quot;name_sep&quot;</span> needs to be
    set to allow the SQL generator to put the quotes the correct place, and
    defaults to <span class="Li">&quot;.&quot;</span> if not supplied.</p>
<p class="Pp">In most cases you should set these as part of the arguments passed
    to &quot;connect&quot; in DBIx::Class::Schema:</p>
<p class="Pp"></p>
<pre> my $schema = My::Schema-&gt;connect(
  'dbi:mysql:my_db',
  'db_user',
  'db_password',
  {
    quote_char =&gt; '&quot;',
    name_sep   =&gt; '.'
  }
 )
</pre>
<p class="Pp">In some cases, quoting will be required for all users of a schema.
    To enforce this, you can also overload the
    <span class="Li">&quot;connection&quot;</span> method for your schema
  class:</p>
<p class="Pp"></p>
<pre> sub connection {
     my $self = shift;
     my $rv = $self-&gt;next::method( @_ );
     $rv-&gt;storage-&gt;sql_maker-&gt;quote_char([ qw/[ ]/ ]);
     $rv-&gt;storage-&gt;sql_maker-&gt;name_sep('.');
     return $rv;
 }
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Working_with_PostgreSQL_array_types"><a class="permalink" href="#Working_with_PostgreSQL_array_types">Working
  with PostgreSQL array types</a></h2>
<p class="Pp">You can also assign values to PostgreSQL array columns by passing
    array references in the <span class="Li">&quot;\%columns&quot;</span>
    (<span class="Li">&quot;\%vals&quot;</span>) hashref of the
    &quot;create&quot; in DBIx::Class::ResultSet and &quot;update&quot; in
    DBIx::Class::Row family of methods:</p>
<p class="Pp"></p>
<pre>  $resultset-&gt;create({
    numbers =&gt; [1, 2, 3]
  });
  $result-&gt;update(
    {
      numbers =&gt; [1, 2, 3]
    },
    {
      day =&gt; '2008-11-24'
    }
  );
</pre>
<p class="Pp">In conditions (e.g. <span class="Li">&quot;\%cond&quot;</span> in
    the &quot;search&quot; in DBIx::Class::ResultSet family of methods) you
    cannot directly use array references (since this is interpreted as a list of
    values to be <span class="Li">&quot;OR&quot;</span>ed), but you can use the
    following syntax to force passing them as bind values:</p>
<p class="Pp"></p>
<pre>  $resultset-&gt;search(
    {
      numbers =&gt; \[ '= ?', [numbers =&gt; [1, 2, 3]] ]
    }
  );
</pre>
<p class="Pp">See &quot;array_datatypes&quot; in SQL::Abstract and &quot;Literal
    SQL with placeholders and bind values (subqueries)&quot; in SQL::Abstract
    for more explanation. Note that DBIx::Class sets &quot;bindtype&quot; in
    SQL::Abstract to <span class="Li">&quot;columns&quot;</span>, so you must
    pass the bind values (the <span class="Li">&quot;[1, 2, 3]&quot;</span>
    arrayref in the above example) wrapped in arrayrefs together with the column
    name, like this: <span class="Li">&quot;[column_name =&gt;
    value]&quot;</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Formatting_DateTime_objects_in_queries"><a class="permalink" href="#Formatting_DateTime_objects_in_queries">Formatting
  DateTime objects in queries</a></h2>
<p class="Pp">To ensure <span class="Li">&quot;WHERE&quot;</span> conditions
    containing DateTime arguments are properly formatted to be understood by
    your RDBMS, you must use the <span class="Li">&quot;DateTime&quot;</span>
    formatter returned by &quot;datetime_parser&quot; in
    DBIx::Class::Storage::DBI to format any DateTime objects you pass to search
    conditions. Any Storage object attached to your Schema provides a correct
    <span class="Li">&quot;DateTime&quot;</span> formatter, so all you have to
    do is:</p>
<p class="Pp"></p>
<pre>  my $dtf = $schema-&gt;storage-&gt;datetime_parser;
  my $rs = $schema-&gt;resultset('users')-&gt;search(
    {
      signup_date =&gt; {
        -between =&gt; [
          $dtf-&gt;format_datetime($dt_start),
          $dtf-&gt;format_datetime($dt_end),
        ],
      }
    },
  );
</pre>
<p class="Pp">Without doing this the query will contain the simple
    stringification of the <span class="Li">&quot;DateTime&quot;</span> object,
    which almost never matches the RDBMS expectations.</p>
<p class="Pp">This kludge is necessary only for conditions passed to
    &quot;search&quot; in DBIx::Class::ResultSet, whereas create, find,
    &quot;update&quot; in DBIx::Class::Row (but not &quot;update&quot; in
    DBIx::Class::ResultSet) are all DBIx::Class::InflateColumn-aware and will do
    the right thing when supplied an inflated
    <span class="Li">&quot;DateTime&quot;</span> object.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Using_Unicode"><a class="permalink" href="#Using_Unicode">Using
  Unicode</a></h2>
<p class="Pp">When using unicode character data there are two alternatives -
    either your database supports unicode characters (including setting the utf8
    flag on the returned string), or you need to encode/decode data
    appropriately each time a string field is inserted into or retrieved from
    the database. It is better to avoid encoding/decoding data and to use your
    database's own unicode capabilities if at all possible.</p>
<p class="Pp">The DBIx::Class::UTF8Columns component handles storing selected
    unicode columns in a database that does not directly support unicode. If
    used with a database that does correctly handle unicode then strange and
    unexpected data corrupt <b>will</b> occur.</p>
<p class="Pp">The Catalyst Wiki Unicode page at
    &lt;http://wiki.catalystframework.org/wiki/tutorialsandhowtos/using_unicode&gt;
    has additional information on the use of Unicode with Catalyst and
    DBIx::Class.</p>
<p class="Pp">The following databases do correctly handle unicode data:-</p>
<p class="Pp"><i>MySQL</i></p>
<p class="Pp">MySQL supports unicode, and will correctly flag utf8 data from the
    database if the <span class="Li">&quot;mysql_enable_utf8&quot;</span> is set
    in the connect options.</p>
<p class="Pp"></p>
<pre>  my $schema = My::Schema-&gt;connection('dbi:mysql:dbname=test',
                                      $user, $pass,
                                      { mysql_enable_utf8 =&gt; 1} );
</pre>
<p class="Pp">When set, a data retrieved from a textual column type (char,
    varchar, etc) will have the UTF-8 flag turned on if necessary. This enables
    character semantics on that string. You will also need to ensure that your
    database / table / column is configured to use UTF8. See Chapter 10 of the
    mysql manual for details.</p>
<p class="Pp">See DBD::mysql for further details.</p>
<p class="Pp"><i>Oracle</i></p>
<p class="Pp">Information about Oracle support for unicode can be found in
    &quot;Unicode&quot; in DBD::Oracle.</p>
<p class="Pp"><i>PostgreSQL</i></p>
<p class="Pp">PostgreSQL supports unicode if the character set is correctly set
    at database creation time. Additionally the
    <span class="Li">&quot;pg_enable_utf8&quot;</span> should be set to ensure
    unicode data is correctly marked.</p>
<p class="Pp"></p>
<pre>  my $schema = My::Schema-&gt;connection('dbi:Pg:dbname=test',
                                      $user, $pass,
                                      { pg_enable_utf8 =&gt; 1} );
</pre>
<p class="Pp">Further information can be found in DBD::Pg.</p>
<p class="Pp"><i>SQLite</i></p>
<p class="Pp">SQLite version 3 and above natively use unicode internally. To
    correctly mark unicode strings taken from the database, the
    <span class="Li">&quot;sqlite_unicode&quot;</span> flag should be set at
    connect time (in versions of DBD::SQLite prior to 1.27 this attribute was
    named <span class="Li">&quot;unicode&quot;</span>).</p>
<p class="Pp"></p>
<pre>  my $schema = My::Schema-&gt;connection('dbi:SQLite:/tmp/test.db',
                                      '', '',
                                      { sqlite_unicode =&gt; 1} );
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="BOOTSTRAPPING/MIGRATING"><a class="permalink" href="#BOOTSTRAPPING/MIGRATING">BOOTSTRAPPING/MIGRATING</a></h1>
<section class="Ss">
<h2 class="Ss" id="Easy_migration_from_class-based_to_schema-based_setup"><a class="permalink" href="#Easy_migration_from_class-based_to_schema-based_setup">Easy
  migration from class-based to schema-based setup</a></h2>
<p class="Pp">You want to start using the schema-based approach to DBIx::Class
    (see &quot;Setting it up manually&quot; in DBIx::Class::Manual::Intro), but
    have an established class-based setup with lots of existing classes that you
    don't want to move by hand. Try this nifty script instead:</p>
<p class="Pp"></p>
<pre>  use MyDB;
  use SQL::Translator;
  my $schema = MyDB-&gt;schema_instance;
  my $translator           =  SQL::Translator-&gt;new(
      debug                =&gt; $debug          ||  0,
      trace                =&gt; $trace          ||  0,
      no_comments          =&gt; $no_comments    ||  0,
      show_warnings        =&gt; $show_warnings  ||  0,
      add_drop_table       =&gt; $add_drop_table ||  0,
      validate             =&gt; $validate       ||  0,
      parser_args          =&gt; {
         'DBIx::Schema'    =&gt; $schema,
                              },
      producer_args   =&gt; {
          'prefix'         =&gt; 'My::Schema',
                         },
  );
  $translator-&gt;parser('SQL::Translator::Parser::DBIx::Class');
  $translator-&gt;producer('SQL::Translator::Producer::DBIx::Class::File');
  my $output = $translator-&gt;translate(@args) or die
          &quot;Error: &quot; . $translator-&gt;error;
  print $output;
</pre>
<p class="Pp">You could use Module::Find to search for all subclasses in the
    MyDB::* namespace, which is currently left as an exercise for the
  reader.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="OVERLOADING_METHODS"><a class="permalink" href="#OVERLOADING_METHODS">OVERLOADING
  METHODS</a></h1>
<p class="Pp">DBIx::Class uses the Class::C3 package, which provides for
    redispatch of method calls, useful for things like default values and
    triggers. You have to use calls to
    <span class="Li">&quot;next::method&quot;</span> to overload methods. More
    information on using Class::C3 with DBIx::Class can be found in
    DBIx::Class::Manual::Component.</p>
<section class="Ss">
<h2 class="Ss" id="Setting_default_values_for_a_row"><a class="permalink" href="#Setting_default_values_for_a_row">Setting
  default values for a row</a></h2>
<p class="Pp">It's as simple as overriding the
    <span class="Li">&quot;new&quot;</span> method. Note the use of
    <span class="Li">&quot;next::method&quot;</span>.</p>
<p class="Pp"></p>
<pre>  sub new {
    my ( $class, $attrs ) = @_;
    $attrs-&gt;{foo} = 'bar' unless defined $attrs-&gt;{foo};
    my $new = $class-&gt;next::method($attrs);
    return $new;
  }
</pre>
<p class="Pp">For more information about
    <span class="Li">&quot;next::method&quot;</span>, look in the Class::C3
    documentation. See also DBIx::Class::Manual::Component for more ways to
    write your own base classes to do this.</p>
<p class="Pp">People looking for ways to do &quot;triggers&quot; with
    DBIx::Class are probably just looking for this.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Changing_one_field_whenever_another_changes"><a class="permalink" href="#Changing_one_field_whenever_another_changes">Changing
  one field whenever another changes</a></h2>
<p class="Pp">For example, say that you have three columns,
    <span class="Li">&quot;id&quot;</span>,
    <span class="Li">&quot;number&quot;</span>, and
    <span class="Li">&quot;squared&quot;</span>. You would like to make changes
    to <span class="Li">&quot;number&quot;</span> and have
    <span class="Li">&quot;squared&quot;</span> be automagically set to the
    value of <span class="Li">&quot;number&quot;</span> squared. You can
    accomplish this by wrapping the <span class="Li">&quot;number&quot;</span>
    accessor with the <span class="Li">&quot;around&quot;</span> method
    modifier, available through either Class::Method::Modifiers, Moose or
    Moose-like modules):</p>
<p class="Pp"></p>
<pre>  around number =&gt; sub {
    my ($orig, $self) = (shift, shift);
    if (@_) {
      my $value = $_[0];
      $self-&gt;squared( $value * $value );
    }
    $self-&gt;$orig(@_);
  };
</pre>
<p class="Pp">Note that the hard work is done by the call to
    <span class="Li">&quot;$self-&gt;$orig&quot;</span>, which redispatches your
    call to store_column in the superclass(es).</p>
<p class="Pp">Generally, if this is a calculation your database can easily do,
    try and avoid storing the calculated value, it is safer to calculate when
    needed, than rely on the data being in sync.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Automatically_creating_related_objects"><a class="permalink" href="#Automatically_creating_related_objects">Automatically
  creating related objects</a></h2>
<p class="Pp">You might have a class <span class="Li">&quot;Artist&quot;</span>
    which has many <span class="Li">&quot;CD&quot;</span>s. Further, you want to
    create a <span class="Li">&quot;CD&quot;</span> object every time you insert
    an <span class="Li">&quot;Artist&quot;</span> object. You can accomplish
    this by overriding <span class="Li">&quot;insert&quot;</span> on your
    objects:</p>
<p class="Pp"></p>
<pre>  sub insert {
    my ( $self, @args ) = @_;
    $self-&gt;next::method(@args);
    $self-&gt;create_related ('cds', \%initial_cd_data );
    return $self;
  }
</pre>
<p class="Pp">If you want to wrap the two inserts in a transaction (for
    consistency, an excellent idea), you can use the awesome
    DBIx::Class::Storage::TxnScopeGuard:</p>
<p class="Pp"></p>
<pre>  sub insert {
    my ( $self, @args ) = @_;
    my $guard = $self-&gt;result_source-&gt;schema-&gt;txn_scope_guard;
    $self-&gt;next::method(@args);
    $self-&gt;create_related ('cds', \%initial_cd_data );
    $guard-&gt;commit;
    return $self
  }
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Wrapping/overloading_a_column_accessor"><a class="permalink" href="#Wrapping/overloading_a_column_accessor">Wrapping/overloading
  a column accessor</a></h2>
<p class="Pp"><b>Problem:</b></p>
<p class="Pp">Say you have a table &quot;Camera&quot; and want to associate a
    description with each camera. For most cameras, you'll be able to generate
    the description from the other columns. However, in a few special cases you
    may want to associate a custom description with a camera.</p>
<p class="Pp"><b>Solution:</b></p>
<p class="Pp">In your database schema, define a description field in the
    &quot;Camera&quot; table that can contain text and null values.</p>
<p class="Pp">In DBIC, we'll overload the column accessor to provide a sane
    default if no custom description is defined. The accessor will either return
    or generate the description, depending on whether the field is null or
  not.</p>
<p class="Pp">First, in your &quot;Camera&quot; schema class, define the
    description field as follows:</p>
<p class="Pp"></p>
<pre>  __PACKAGE__-&gt;add_columns(description =&gt; { accessor =&gt; '_description' });
</pre>
<p class="Pp">Next, we'll define the accessor-wrapper subroutine:</p>
<p class="Pp"></p>
<pre>  sub description {
      my $self = shift;
      # If there is an update to the column, we'll let the original accessor
      # deal with it.
      return $self-&gt;_description(@_) if @_;
      # Fetch the column value.
      my $description = $self-&gt;_description;
      # If there's something in the description field, then just return that.
      return $description if defined $description &amp;&amp; length $descripton;
      # Otherwise, generate a description.
      return $self-&gt;generate_description;
  }
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="DEBUGGING_AND_PROFILING"><a class="permalink" href="#DEBUGGING_AND_PROFILING">DEBUGGING
  AND PROFILING</a></h1>
<section class="Ss">
<h2 class="Ss" id="DBIx::Class_objects_with_Data::Dumper"><a class="permalink" href="#DBIx::Class_objects_with_Data::Dumper">DBIx::Class
  objects with Data::Dumper</a></h2>
<p class="Pp">Data::Dumper can be a very useful tool for debugging, but
    sometimes it can be hard to find the pertinent data in all the data it can
    generate. Specifically, if one naively tries to use it like so,</p>
<p class="Pp"></p>
<pre>  use Data::Dumper;
  my $cd = $schema-&gt;resultset('CD')-&gt;find(1);
  print Dumper($cd);
</pre>
<p class="Pp">several pages worth of data from the CD object's schema and result
    source will be dumped to the screen. Since usually one is only interested in
    a few column values of the object, this is not very helpful.</p>
<p class="Pp">Luckily, it is possible to modify the data before Data::Dumper
    outputs it. Simply define a hook that Data::Dumper will call on the object
    before dumping it. For example,</p>
<p class="Pp"></p>
<pre>  package My::DB::CD;
  sub _dumper_hook {
    $_[0] = bless {
      %{ $_[0] },
      result_source =&gt; undef,
    }, ref($_[0]);
  }
  [...]
  use Data::Dumper;
  local $Data::Dumper::Freezer = '_dumper_hook';
  my $cd = $schema-&gt;resultset('CD')-&gt;find(1);
  print Dumper($cd);
         # dumps $cd without its ResultSource
</pre>
<p class="Pp">If the structure of your schema is such that there is a common
    base class for all your table classes, simply put a method similar to
    <span class="Li">&quot;_dumper_hook&quot;</span> in the base class and set
    <span class="Li">$Data::Dumper::Freezer</span> to its name and Data::Dumper
    will automagically clean up your data before printing it. See
    &quot;EXAMPLES&quot; in Data::Dumper for more information.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Profiling"><a class="permalink" href="#Profiling">Profiling</a></h2>
<p class="Pp">When you enable DBIx::Class::Storage's debugging it prints the SQL
    executed as well as notifications of query completion and transaction
    begin/commit. If you'd like to profile the SQL you can subclass the
    DBIx::Class::Storage::Statistics class and write your own profiling
    mechanism:</p>
<p class="Pp"></p>
<pre>  package My::Profiler;
  use strict;
  use base 'DBIx::Class::Storage::Statistics';
  use Time::HiRes qw(time);
  my $start;
  sub query_start {
    my $self = shift();
    my $sql = shift();
    my @params = @_;
    $self-&gt;print(&quot;Executing $sql: &quot;.join(', ', @params).&quot;\n&quot;);
    $start = time();
  }
  sub query_end {
    my $self = shift();
    my $sql = shift();
    my @params = @_;
    my $elapsed = sprintf(&quot;%0.4f&quot;, time() - $start);
    $self-&gt;print(&quot;Execution took $elapsed seconds.\n&quot;);
    $start = undef;
  }
  1;
</pre>
<p class="Pp">You can then install that class as the debugging object:</p>
<p class="Pp"></p>
<pre>  __PACKAGE__-&gt;storage-&gt;debugobj(new My::Profiler());
  __PACKAGE__-&gt;storage-&gt;debug(1);
</pre>
<p class="Pp">A more complicated example might involve storing each execution of
    SQL in an array:</p>
<p class="Pp"></p>
<pre>  sub query_end {
    my $self = shift();
    my $sql = shift();
    my @params = @_;
    my $elapsed = time() - $start;
    push(@{ $calls{$sql} }, {
        params =&gt; \@params,
        elapsed =&gt; $elapsed
    });
  }
</pre>
<p class="Pp">You could then create average, high and low execution times for an
    SQL statement and dig down to see if certain parameters cause aberrant
    behavior. You might want to check out DBIx::Class::QueryLog as well.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="IMPROVING_PERFORMANCE"><a class="permalink" href="#IMPROVING_PERFORMANCE">IMPROVING
  PERFORMANCE</a></h1>
<ul class="Bl-bullet">
  <li>Install Class::XSAccessor to speed up Class::Accessor::Grouped.</li>
  <li>On Perl 5.8 install Class::C3::XS.</li>
  <li>prefetch relationships, where possible. See &quot;Using joins and
      prefetch&quot;.</li>
  <li>Use populate in void context to insert data when you don't need the
      resulting result objects, if possible, but see the caveats.
    <p class="Pp">When inserting many rows, for best results, populate a large
        number of rows at a time, but not so large that the table is locked for
        an unacceptably long time.</p>
    <p class="Pp">If using create instead, use a transaction and commit every
        <span class="Li">&quot;X&quot;</span> rows; where
        <span class="Li">&quot;X&quot;</span> gives you the best performance
        without locking the table for too long.</p>
  </li>
  <li>When selecting many rows, if you don't need full-blown DBIx::Class::Row
      objects, consider using DBIx::Class::ResultClass::HashRefInflator.</li>
  <li>See also &quot;STARTUP SPEED&quot; and &quot;MEMORY USAGE&quot; in this
      document.</li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="STARTUP_SPEED"><a class="permalink" href="#STARTUP_SPEED">STARTUP
  SPEED</a></h1>
<p class="Pp">DBIx::Class programs can have a significant startup delay as the
    ORM loads all the relevant classes. This section examines techniques for
    reducing the startup delay.</p>
<p class="Pp">These tips are listed in order of decreasing effectiveness - so
    the first tip, if applicable, should have the greatest effect on your
    application.</p>
<section class="Ss">
<h2 class="Ss" id="Statically_Define_Your_Schema"><a class="permalink" href="#Statically_Define_Your_Schema">Statically
  Define Your Schema</a></h2>
<p class="Pp">If you are using DBIx::Class::Schema::Loader to build the classes
    dynamically based on the database schema then there will be a significant
    startup delay.</p>
<p class="Pp">For production use a statically defined schema (which can be
    generated using DBIx::Class::Schema::Loader to dump the database schema once
    - see make_schema_at and dump_directory for more details on creating static
    schemas from a database).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Move_Common_Startup_into_a_Base_Class"><a class="permalink" href="#Move_Common_Startup_into_a_Base_Class">Move
  Common Startup into a Base Class</a></h2>
<p class="Pp">Typically DBIx::Class result classes start off with</p>
<p class="Pp"></p>
<pre>    use base qw/DBIx::Class::Core/;
    __PACKAGE__-&gt;load_components(qw/InflateColumn::DateTime/);
</pre>
<p class="Pp">If this preamble is moved into a common base class:-</p>
<p class="Pp"></p>
<pre>    package MyDBICbase;
    use base qw/DBIx::Class::Core/;
    __PACKAGE__-&gt;load_components(qw/InflateColumn::DateTime/);
    1;
</pre>
<p class="Pp">and each result class then uses this as a base:-</p>
<p class="Pp"></p>
<pre>    use base qw/MyDBICbase/;
</pre>
<p class="Pp">then the load_components is only performed once, which can result
    in a considerable startup speedup for schemas with many classes.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Explicitly_List_Schema_Result_Classes"><a class="permalink" href="#Explicitly_List_Schema_Result_Classes">Explicitly
  List Schema Result Classes</a></h2>
<p class="Pp">The schema class will normally contain</p>
<p class="Pp"></p>
<pre>    __PACKAGE__-&gt;load_classes();
</pre>
<p class="Pp">to load the result classes. This will use Module::Find to find and
    load the appropriate modules. Explicitly defining the classes you wish to
    load will remove the overhead of Module::Find and the related directory
    operations:</p>
<p class="Pp"></p>
<pre>    __PACKAGE__-&gt;load_classes(qw/ CD Artist Track /);
</pre>
<p class="Pp">If you are instead using the load_namespaces syntax to load the
    appropriate classes there is not a direct alternative avoiding
  Module::Find.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="MEMORY_USAGE"><a class="permalink" href="#MEMORY_USAGE">MEMORY
  USAGE</a></h1>
<section class="Ss">
<h2 class="Ss" id="Cached_statements"><a class="permalink" href="#Cached_statements">Cached
  statements</a></h2>
<p class="Pp">DBIx::Class normally caches all statements with
    <i>prepare_cached()</i>. This is normally a good idea, but if too many
    statements are cached, the database may use too much memory and may
    eventually run out and fail entirely. If you suspect this may be the case,
    you may want to examine DBI's CachedKids hash:</p>
<p class="Pp"></p>
<pre>    # print all currently cached prepared statements
    print for keys %{$schema-&gt;storage-&gt;dbh-&gt;{CachedKids}};
    # get a count of currently cached prepared statements
    my $count = scalar keys %{$schema-&gt;storage-&gt;dbh-&gt;{CachedKids}};
</pre>
<p class="Pp">If it's appropriate, you can simply clear these statements,
    automatically deallocating them in the database:</p>
<p class="Pp"></p>
<pre>    my $kids = $schema-&gt;storage-&gt;dbh-&gt;{CachedKids};
    delete @{$kids}{keys %$kids} if scalar keys %$kids &gt; 100;
</pre>
<p class="Pp">But what you probably want is to expire unused statements and not
    those that are used frequently. You can accomplish this with Tie::Cache or
    Tie::Cache::LRU:</p>
<p class="Pp"></p>
<pre>    use Tie::Cache;
    use DB::Main;
    my $schema = DB::Main-&gt;connect($dbi_dsn, $user, $pass, {
        on_connect_do =&gt; sub { tie %{shift-&gt;_dbh-&gt;{CachedKids}}, 'Tie::Cache', 100 },
    });
</pre>
</section>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2014-01-22</td>
    <td class="foot-os">perl v5.18.4</td>
  </tr>
</table>
</body>
</html>
