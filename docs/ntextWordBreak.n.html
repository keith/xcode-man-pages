<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Generated from file '/Library/Caches/com.apple.xbs/Sources/tcl/tcl-128/tcl_ext/tklib/tklib/modules/ntext/ntextWordBreak.man' by tcllib/doctools with format 'nroff'
  
   The definitions below are for supplemental macros used in Tcl/Tk
   manual entries.
  
   .AP type name in/out ?indent?
  	Start paragraph describing an argument to a library procedure.
  	type is type of argument (int, etc.), in/out is either "in", "out",
  	or "in/out" to describe whether procedure reads or modifies arg,
  	and indent is equivalent to second arg of .IP (shouldn't ever be
  	needed;  use .AS below instead)
  
   .AS ?type? ?name?
  	Give maximum sizes of arguments for setting tab stops.  Type and
  	name are examples of largest possible arguments that will be passed
  	to .AP later.  If args are omitted, default tab stops are used.
  
   .BS
  	Start box enclosure.  From here until next .BE, everything will be
  	enclosed in one large box.
  
   .BE
  	End of box enclosure.
  
   .CS
  	Begin code excerpt.
  
   .CE
  	End code excerpt.
  
   .VS ?version? ?br?
  	Begin vertical sidebar, for use in marking newly-changed parts
  	of man pages.  The first argument is ignored and used for recording
  	the version when the .VS was added, so that the sidebars can be
  	found and removed when they reach a certain age.  If another argument
  	is present, then a line break is forced before starting the sidebar.
  
   .VE
  	End of vertical sidebar.
  
   .DS
  	Begin an indented unfilled display.
  
   .DE
  	End of indented unfilled display.
  
   .SO
  	Start of list of standard options for a Tk widget.  The
  	options follow on successive lines, in four columns separated
  	by tabs.
  
   .SE
  	End of list of standard options for a Tk widget.
  
   .OP cmdName dbName dbClass
  	Start of description of a specific option.  cmdName gives the
  	option's name as specified in the class command, dbName gives
  	the option's name in the option database, and dbClass gives
  	the option's class in the option database.
  
   .UL arg1 arg2
  	Print arg1 underlined, then print arg2 normally.
  
   RCS: @(#) $Id: man.macros,v 1.1 2009/01/30 04:56:47 andreas_kupries Exp $
  
  	# Set up traps and other miscellaneous stuff for Tcl/Tk man pages.
  	# Start an argument description
  .b
  	# define tabbing values for .AP
  
  	# BS - start boxed text
  	# ^y = starting y location
  	# ^b = 1
  	# BE - end boxed text (draw box now)
  	Draw four-sided box normally, but don't draw top of
  	box if the box started on an earlier page.
  	# VS - start vertical sidebar
  	# ^Y = starting y location
  	# ^v = 1 (for troff;  for nroff this doesn't matter)
  	# VE - end of vertical sidebar
  	# Special macro to handle page bottom:  finish off current
  	# box/sidebar if in box/sidebar mode, then invoked standard
  	# page bottom macro.
  	Draw three-sided box if this is the box's first page,
  	draw two sides but no top otherwise.
  	# DS - begin display
  	# DE - end display
  	# SO - start of list of standard options
  	# SE - end of list of standard options
  	# OP - start of full description for a single option
  	# CS - begin code excerpt
  	# CE - end code excerpt
 -->
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>ntextWordBreak(n)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">ntextWordBreak(n)</td>
    <td class="head-vol">ntext Word Boundary Detection for the Text Widget</td>
    <td class="head-rtitle">ntextWordBreak(n)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<pre>

</pre>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
ntextWordBreak - ntext Word Boundary Detection for the Text Widget
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
package require <b>Tcl 8.5</b>
<p class="Pp">package require <b>Tk 8.5</b></p>
<p class="Pp">package require <b>ntext ?0.81?</b></p>
<p class="Pp"></p>
<pre>

</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
The <b>ntext</b> package provides a binding tag named <i>Ntext</i> for use by
  text widgets in place of the default <i>Text</i> binding tag.
<p class="Pp">Navigation and selection in a text widget require the detection of
    words and their boundaries. The word boundary detection facilities provided
    by Tcl/Tk through the <i>Text</i> binding tag are limited because they
    define only one class of &quot;word&quot; characters and one class of
    &quot;non-word&quot; characters. The <i>Ntext</i> binding tag uses more
    general rules for word boundary detection, that define <i>two</i> classes of
    &quot;word&quot; characters and one class of &quot;non-word&quot;
    characters.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="CONFIGURATION_OPTIONS"><a class="permalink" href="#CONFIGURATION_OPTIONS">CONFIGURATION
  OPTIONS</a></h1>
The behaviour of <i>Ntext</i> may be configured application-wide by setting the
  values of a number of namespace variables. One of these is relevant to word
  boundary detection:
<p class="Pp"><b>::ntext::classicWordBreak</b></p>
<ul class="Bl-bullet">
  <li><b>0</b> - (default value) selects <i>Ntext</i> behaviour, i.e.
      platform-independent, two classes of word characters and one class of
      non-word characters.</li>
  <li><b>1</b> - selects classic <i>Text</i> behaviour, i.e. platform-dependent,
      one class of word characters and one class of non-word characters</li>
  <li>After changing this value, <i>Ntext</i> 's regexp matching patterns should
      be recalculated. See <b>FUNCTIONS</b> for details and advanced
      configuration options.</li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="ADVANCED_USE"><a class="permalink" href="#ADVANCED_USE">ADVANCED
  USE</a></h1>
</section>
<section class="Sh">
<h1 class="Sh" id="VARIABLES_(ADVANCED_USE)"><a class="permalink" href="#VARIABLES_(ADVANCED_USE)">VARIABLES
  (ADVANCED USE)</a></h1>
<b>::ntext::tcl_match_wordBreakAfter</b>
<p class="Pp"><b>::ntext::tcl_match_wordBreakBefore</b></p>
<p class="Pp"><b>::ntext::tcl_match_endOfWord</b></p>
<p class="Pp"><b>::ntext::tcl_match_startOfNextWord</b></p>
<p class="Pp"><b>::ntext::tcl_match_startOfPreviousWord</b></p>
<p class="Pp">These variables hold the regexp patterns that are used by
    <i>Ntext</i> to search for word boundaries. If they are changed, subsequent
    searches are immediately altered. In many situations, it it unnecessary to
    alter the values of these variables directly: instead call one of the
    functions <b>::ntext::initializeMatchPatterns</b>,
    <b>::ntext::createMatchPatterns</b>.</p>
<p class="Pp">In the <i>Text</i> binding tag one can change the search rules by
    changing the values of the global variables <b>tcl_wordchars</b> and
    <b>tcl_nonwordchars</b>. The equivalent operation in the <i>Ntext</i>
    binding tag is to call <b>::ntext::createMatchPatterns</b> with appropriate
    arguments.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="FUNCTIONS_(ADVANCED_USE)"><a class="permalink" href="#FUNCTIONS_(ADVANCED_USE)">FUNCTIONS
  (ADVANCED USE)</a></h1>
If a simple regexp search should prove insufficient, the following functions
  (analogous to the Tcl/Tk core's <b>tcl_wordBreakAfter</b> etc) may be replaced
  by the developer:
<p class="Pp"><b>ntext::new_wordBreakAfter</b></p>
<p class="Pp"><b>ntext::new_wordBreakBefore</b></p>
<p class="Pp"><b>ntext::new_endOfWord</b></p>
<p class="Pp"><b>ntext::new_startOfNextWord</b></p>
<p class="Pp"><b>ntext::new_startOfPreviousWord</b></p>
</section>
<section class="Sh">
<h1 class="Sh" id="FUNCTIONS"><a class="permalink" href="#FUNCTIONS">FUNCTIONS</a></h1>
Each function calculates the five regexp search patterns that define the word
  boundary searches. These values are stored in the namespace variables listed
  above.
<p class="Pp"><b>::ntext::initializeMatchPatterns</b></p>
<dl class="Bl-tag">
  <dt>&#x2022;</dt>
  <dd>This function is called when <i>Ntext</i> is first used, and needs to be
      called again only if the script changes the value of either
      <b>::ntext::classicWordBreak</b> or <b>::tcl_platform(platform)</b>. The
      function is called with no arguments. It is useful when the desired search
      patterns are the default patterns for either the <i>Ntext</i> or
      <i>Text</i> binding tag, and so are implicitly specified by the values of
      <b>::ntext::classicWordBreak</b> and <b>::tcl_platform(platform)</b>
      alone.</dd>
</dl>
<p class="Pp"><b>::ntext::createMatchPatterns</b> <i>new_nonwordchars</i>
    <i>new_word1chars</i> ?new_word2chars?</p>
<dl class="Bl-tag">
  <dt>&#x2022;</dt>
  <dd>This function is useful in a wider range of situations than
      <b>::ntext::initializeMatchPatterns</b>. It calculates the regexp search
      patterns for any case with one class of &quot;non-word&quot; characters
      and one or two classes of &quot;word&quot; characters.
    <p class="Pp">Each argument should be a regexp expression defining a class
        of characters. An argument will usually be a bracket expression, but
        might alternatively be a class-shorthand escape, or a single character.
        The third argument may be omitted, or supplied as the empty string, in
        which case it is unused.</p>
    <p class="Pp">The first argument is interpreted as the class of non-word
        characters; the second argument (and the third, if present) are classes
        of word characters. The classes should include all possible characters
        and will normally be mutually exclusive: it is often convenient to
        define one class as the negation of the other two.</p>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="WORD_BOUNDARY_MATCHING"><a class="permalink" href="#WORD_BOUNDARY_MATCHING">WORD
  BOUNDARY MATCHING</a></h1>
The problem of word boundary selection is a vexed one, because text is used to
  represent a universe of different types of information, and there are no
  simple rules that are useful for all data types or for all purposes.
<p class="Pp"><i>Ntext</i> attempts to improve on the facilities available in
    classic <i>Text</i> by providing facilities for more complex definitions of
    words (with three classes of characters instead of two).</p>
<p class="Pp"><i>What is a word? Why two classes of word?</i></p>
<p class="Pp">When using the modified cursor keys &lt;Control-Left&gt; and
    &lt;Control-Right&gt; to navigate through a <i>Ntext</i> widget, the cursor
    is placed at the start of a word. A word is defined as a sequence of one or
    more characters from only one of the two defined &quot;word&quot; classes;
    it may be preceded by a character from the other &quot;word&quot; class or
    from the &quot;non-word&quot; class.</p>
<p class="Pp">The double-click of mouse button 1 selects a word of text, where
    in this case a &quot;word&quot; may be as defined above, or alternatively
    may be a sequence of one or more characters from the &quot;non-word&quot;
    class of characters.</p>
<p class="Pp">Traditionally Tcl has defined only one word class and one non-word
    class: on Windows, the non-word class is whitespace, and so alphanumerics
    and punctuation belong to the same class. On other platforms, punctuation is
    bundled with whitespace as &quot;non-word&quot; characters. In either case,
    the navigation and selection of text are unnecessarily coarse-grained, and
    sometimes give unhelpful results.</p>
<p class="Pp">The use of three classes of characters might make selection too
    fine-grained; but in this case, holding down the <i>Shift</i> key and
    double-clicking another word is an excellent way to select a longer range of
    text (a useful binding that Tcl/Tk has long provided but which is missing in
    other systems).</p>
<p class="Pp">As well as its defaults, <i>Ntext</i> permits the developer to
    define their own classes of characters, or to revert to the classic
    <i>Text</i> definitions, or to specify their own regexp matching
  patterns.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="EXAMPLE"><a class="permalink" href="#EXAMPLE">EXAMPLE</a></h1>
To use <i>Ntext</i> with Tcl/Tk's usual word-boundary detection rules:
<pre>
package require ntext
text .t
bindtags .t {.t Ntext . all}
set ::ntext::classicWordBreak 1
::ntext::initializeMatchPatterns
</pre>
See bindtags for more information.
<p class="Pp">To define a different set of word-boundary detection rules:</p>
<pre>
package require ntext
text .t
bindtags .t {.t Ntext . all}
::ntext::createMatchPatterns \
  {[[:space:][:cntrl:]]} {[[:punct:]]} {[^[:punct:][:space:][:cntrl:]]}
</pre>
See regexp, re_syntax for more information.
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
bindtags, ntext, re_syntax, regexp, text
</section>
<section class="Sh">
<h1 class="Sh" id="KEYWORDS"><a class="permalink" href="#KEYWORDS">KEYWORDS</a></h1>
bindtags, re_syntax, regexp, text
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">0.81</td>
    <td class="foot-os">ntext</td>
  </tr>
</table>
</body>
</html>
