<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Copyright (c) 2003-2011 Tim Kientzle
   All rights reserved.
  
   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions
   are met:
   1. Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
   2. Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
  
   THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
   ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
   ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
   FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
   DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
   OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
   HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
   LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
   OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
   SUCH DAMAGE.
  
   $FreeBSD$
   -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>ARCHIVE_WRITE(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">ARCHIVE_WRITE(3)</td>
    <td class="head-vol">Library Functions Manual</td>
    <td class="head-rtitle">ARCHIVE_WRITE(3)</td>
  </tr>
</table>
<div class="manual-text">
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<code class="Nm">archive_write</code> &#x2014;
<div class="Nd">functions for creating archives</div>
</section>
<section class="Sh">
<h1 class="Sh" id="LIBRARY"><a class="permalink" href="#LIBRARY">LIBRARY</a></h1>
Streaming Archive Library (libarchive, -larchive)
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<code class="In">#include &lt;<a class="In">archive.h</a>&gt;</code>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
These functions provide a complete API for creating streaming archive files. The
  general process is to first create the struct archive object, set any desired
  options, initialize the archive, append entries, then close the archive and
  release all resources.
<section class="Ss">
<h2 class="Ss" id="Create_archive_object"><a class="permalink" href="#Create_archive_object">Create
  archive object</a></h2>
See <a class="Xr">archive_write_new(3)</a>.
<p class="Pp">To write an archive, you must first obtain an initialized struct
    archive object from <code class="Fn">archive_write_new</code>().</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Enable_filters_and_formats,_configure_block_size_and_padding"><a class="permalink" href="#Enable_filters_and_formats,_configure_block_size_and_padding">Enable
  filters and formats, configure block size and padding</a></h2>
See <a class="Xr">archive_write_filter(3)</a>,
  <a class="Xr">archive_write_format(3)</a> and
  <a class="Xr">archive_write_blocksize(3)</a>.
<p class="Pp">You can then modify this object for the desired operations with
    the various <code class="Fn">archive_write_set_XXX</code>() functions. In
    particular, you will need to invoke appropriate
    <code class="Fn">archive_write_add_XXX</code>() and
    <code class="Fn">archive_write_set_XXX</code>() functions to enable the
    corresponding compression and format support.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Set_options"><a class="permalink" href="#Set_options">Set
  options</a></h2>
See <a class="Xr">archive_write_set_options(3)</a>.
</section>
<section class="Ss">
<h2 class="Ss" id="Open_archive"><a class="permalink" href="#Open_archive">Open
  archive</a></h2>
See <a class="Xr">archive_write_open(3)</a>.
<p class="Pp">Once you have prepared the struct archive object, you call
    <code class="Fn">archive_write_open</code>() to actually open the archive
    and prepare it for writing. There are several variants of this function; the
    most basic expects you to provide pointers to several functions that can
    provide blocks of bytes from the archive. There are convenience forms that
    allow you to specify a filename, file descriptor, <var class="Ft">FILE
    *</var> object, or a block of memory from which to write the archive
  data.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Produce_archive"><a class="permalink" href="#Produce_archive">Produce
  archive</a></h2>
See <a class="Xr">archive_write_header(3)</a> and
  <a class="Xr">archive_write_data(3)</a>.
<p class="Pp">Individual archive entries are written in a three-step process:
    You first initialize a struct archive_entry structure with information about
    the new entry. At a minimum, you should set the pathname of the entry and
    provide a <var class="Va">struct stat</var> with a valid
    <var class="Va">st_mode</var> field, which specifies the type of object and
    <var class="Va">st_size</var> field, which specifies the size of the data
    portion of the object.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Release_resources"><a class="permalink" href="#Release_resources">Release
  resources</a></h2>
See <a class="Xr">archive_write_free(3)</a>.
<p class="Pp">After all entries have been written, use the
    <code class="Fn">archive_write_free</code>() function to release all
    resources.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="EXAMPLES"><a class="permalink" href="#EXAMPLES">EXAMPLES</a></h1>
The following sketch illustrates basic usage of the library. In this example,
  the callback functions are simply wrappers around the standard
  <a class="Xr">open(2)</a>, <a class="Xr">write(2)</a>, and
  <a class="Xr">close(2)</a> system calls.
<div class="Bd Pp Bd-indent">
<pre>
#ifdef __linux__
#define	_FILE_OFFSET_BITS 64
#endif
#include &lt;sys/stat.h&gt;
#include &lt;archive.h&gt;
#include &lt;archive_entry.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;

struct mydata {
  const char *name;
  int fd;
};

int
myopen(struct archive *a, void *client_data)
{
  struct mydata *mydata = client_data;

  mydata-&gt;fd = open(mydata-&gt;name, O_WRONLY | O_CREAT, 0644);
  if (mydata-&gt;fd &gt;= 0)
    return (ARCHIVE_OK);
  else
    return (ARCHIVE_FATAL);
}

la_ssize_t
mywrite(struct archive *a, void *client_data, const void *buff, size_t n)
{
  struct mydata *mydata = client_data;

  return (write(mydata-&gt;fd, buff, n));
}

int
myclose(struct archive *a, void *client_data)
{
  struct mydata *mydata = client_data;

  if (mydata-&gt;fd &gt; 0)
    close(mydata-&gt;fd);
  return (0);
}

void
write_archive(const char *outname, const char **filename)
{
  struct mydata *mydata = malloc(sizeof(struct mydata));
  struct archive *a;
  struct archive_entry *entry;
  struct stat st;
  char buff[8192];
  int len;
  int fd;

  a = archive_write_new();
  mydata-&gt;name = outname;
  /* Set archive format and filter according to output file extension.
   * If it fails, set default format. Platform depended function.
   * See supported formats in archive_write_set_format_filter_by_ext.c */
  if (archive_write_set_format_filter_by_ext(a, outname) != ARCHIVE_OK)  {
    archive_write_add_filter_gzip(a);
    archive_write_set_format_ustar(a);
  }
  archive_write_open(a, mydata, myopen, mywrite, myclose);
  while (*filename) {
    stat(*filename, &amp;st);
    entry = archive_entry_new();
    archive_entry_copy_stat(entry, &amp;st);
    archive_entry_set_pathname(entry, *filename);
    archive_write_header(a, entry);
    if ((fd = open(*filename, O_RDONLY)) != -1) {
      len = read(fd, buff, sizeof(buff));
      while (len &gt; 0) {
        archive_write_data(a, buff, len);
        len = read(fd, buff, sizeof(buff));
      }
      close(fd);
    }
    archive_entry_free(entry);
    filename++;
  }
  archive_write_free(a);
}

int main(int argc, const char **argv)
{
  const char *outname;
  argv++;
  outname = *argv++;
  write_archive(outname, argv);
  return 0;
}
</pre>
</div>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<a class="Xr">tar(1)</a>, <a class="Xr">archive_write_set_options(3)</a>,
  <a class="Xr">libarchive(3)</a>, <a class="Xr">cpio(5)</a>,
  <a class="Xr">mtree(5)</a>, <a class="Xr">tar(5)</a>
</section>
<section class="Sh">
<h1 class="Sh" id="HISTORY"><a class="permalink" href="#HISTORY">HISTORY</a></h1>
The <code class="Nm">libarchive</code> library first appeared in
  <span class="Ux">FreeBSD 5.3</span>.
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHORS"><a class="permalink" href="#AUTHORS">AUTHORS</a></h1>
The <code class="Nm">libarchive</code> library was written by
  <span class="An">Tim Kientzle</span> &#x27E8;kientzle@acm.org&#x27E9;.
</section>
<section class="Sh">
<h1 class="Sh" id="BUGS"><a class="permalink" href="#BUGS">BUGS</a></h1>
There are many peculiar bugs in historic tar implementations that may cause
  certain programs to reject archives written by this library. For example,
  several historic implementations calculated header checksums incorrectly and
  will thus reject valid archives; GNU tar does not fully support pax
  interchange format; some old tar implementations required specific field
  terminations.
<p class="Pp">The default pax interchange format eliminates most of the historic
    tar limitations and provides a generic key/value attribute facility for
    vendor-defined extensions. One oversight in POSIX is the failure to provide
    a standard attribute for large device numbers. This library uses
    &#x201C;SCHILY.devminor&#x201D; and &#x201C;SCHILY.devmajor&#x201D; for
    device numbers that exceed the range supported by the backwards-compatible
    ustar header. These keys are compatible with Joerg Schilling's
    <code class="Nm">star</code> archiver. Other implementations may not
    recognize these keys and will thus be unable to correctly restore device
    nodes with large device numbers from archives created by this library.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">February 2, 2012</td>
    <td class="foot-os">Mac OS X 11.0</td>
  </tr>
</table>
</body>
</html>
