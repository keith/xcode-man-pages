<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.10 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>PERLUNITUT(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">PERLUNITUT(1)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">PERLUNITUT(1)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
perlunitut - Perl Unicode Tutorial
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
The days of just flinging strings around are over. It's well established that
  modern programs need to be capable of communicating funny accented letters,
  and things like euro symbols. This means that programmers need new habits.
  It's easy to program Unicode capable software, but it does require discipline
  to do it right.
<p class="Pp">There's a lot to know about character sets, and text encodings.
    It's probably best to spend a full day learning all this, but the basics can
    be learned in minutes.</p>
<p class="Pp">These are not the very basics, though. It is assumed that you
    already know the difference between bytes and characters, and realise (and
    accept!) that there are many different character sets and encodings, and
    that your program has to be explicit about them. Recommended reading is
    &quot;The Absolute Minimum Every Software Developer Absolutely, Positively
    Must Know About Unicode and Character Sets (No Excuses!)&quot; by Joel
    Spolsky, at &lt;http://joelonsoftware.com/articles/Unicode.html&gt;.</p>
<p class="Pp">This tutorial speaks in rather absolute terms, and provides only a
    limited view of the wealth of character string related features that Perl
    has to offer. For most projects, this information will probably suffice.</p>
<section class="Ss">
<h2 class="Ss" id="Definitions"><a class="permalink" href="#Definitions">Definitions</a></h2>
It's important to set a few things straight first. This is the most important
  part of this tutorial. This view may conflict with other information that you
  may have found on the web, but that's mostly because many sources are wrong.
<p class="Pp">You may have to re-read this entire section a few times...</p>
<p class="Pp"><i>Unicode</i></p>
<p class="Pp"><b>Unicode</b> is a character set with room for lots of
    characters. The ordinal value of a character is called a <b>code point</b>.
    (But in practice, the distinction between code point and character is
    blurred, so the terms often are used interchangeably.)</p>
<p class="Pp">There are many, many code points, but computers work with bytes,
    and a byte has room for only 256 values. Unicode has many more characters
    than that, so you need a method to make these accessible.</p>
<p class="Pp">Unicode is encoded using several competing encodings, of which
    UTF-8 is the most used. In a Unicode encoding, multiple subsequent bytes can
    be used to store a single code point, or simply: character.</p>
<p class="Pp"><i>UTF-8</i></p>
<p class="Pp"><b>UTF-8</b> is a Unicode encoding. Many people think that Unicode
    and UTF-8 are the same thing, but they're not. There are more Unicode
    encodings, but much of the world has standardized on UTF-8.</p>
<p class="Pp">UTF-8 treats the first 128 codepoints, 0..127, the same as ASCII.
    They take only one byte per character. All other characters are encoded as
    two to four bytes using a complex scheme. Fortunately, Perl handles this for
    us, so we don't have to worry about this.</p>
<p class="Pp"><i>Text strings (character strings)</i></p>
<p class="Pp"><b>Text strings</b>, or <b>character strings</b> are made of
    characters. Bytes are irrelevant here, and so are encodings. Each character
    is just that: the character.</p>
<p class="Pp">On a text string, you would do things like:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    $text =~ s/foo/bar/;
    if ($string =~ /^\d+$/) { ... }
    $text = ucfirst $text;
    my $character_count = length $text;
</pre>
<p class="Pp">The value of a character (<span class="Li">&quot;ord&quot;</span>,
    <span class="Li">&quot;chr&quot;</span>) is the corresponding Unicode code
    point.</p>
<p class="Pp"><i>Binary strings (byte strings)</i></p>
<p class="Pp"><b>Binary strings</b>, or <b>byte strings</b> are made of bytes.
    Here, you don't have characters, just bytes. All communication with the
    outside world (anything outside of your current Perl process) is done in
    binary.</p>
<p class="Pp">On a binary string, you would do things like:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    my (@length_content) = unpack &quot;(V/a)*&quot;, $binary;
    $binary =~ s/\x00\x0F/\xFF\xF0/;  # for the brave :)
    print {$fh} $binary;
    my $byte_count = length $binary;
</pre>
<p class="Pp"><i>Encoding</i></p>
<p class="Pp"><b>Encoding</b> (as a verb) is the conversion from <i>text</i> to
    <i>binary</i>. To encode, you have to supply the target encoding, for
    example <span class="Li">&quot;iso-8859-1&quot;</span> or
    <span class="Li">&quot;UTF-8&quot;</span>. Some encodings, like the
    <span class="Li">&quot;iso-8859&quot;</span> (&quot;latin&quot;) range, do
    not support the full Unicode standard; characters that can't be represented
    are lost in the conversion.</p>
<p class="Pp"><i>Decoding</i></p>
<p class="Pp"><b>Decoding</b> is the conversion from <i>binary</i> to
    <i>text</i>. To decode, you have to know what encoding was used during the
    encoding phase. And most of all, it must be something decodable. It doesn't
    make much sense to decode a PNG image into a text string.</p>
<p class="Pp"><i>Internal format</i></p>
<p class="Pp">Perl has an <b>internal format</b>, an encoding that it uses to
    encode text strings so it can store them in memory. All text strings are in
    this internal format. In fact, text strings are never in any other
  format!</p>
<p class="Pp">You shouldn't worry about what this format is, because conversion
    is automatically done when you decode or encode.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Your_new_toolkit"><a class="permalink" href="#Your_new_toolkit">Your
  new toolkit</a></h2>
Add to your standard heading the following line:
<p class="Pp"><span class="Li"></span></p>
<pre>
    use Encode qw(encode decode);
</pre>
<p class="Pp">Or, if you're lazy, just:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    use Encode;
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="I/O_flow_(the_actual_5_minute_tutorial)"><a class="permalink" href="#I/O_flow_(the_actual_5_minute_tutorial)">I/O
  flow (the actual 5 minute tutorial)</a></h2>
The typical input/output flow of a program is:
<p class="Pp"><span class="Li"></span></p>
<pre>
    1. Receive and decode
    2. Process
    3. Encode and output
</pre>
<p class="Pp">If your input is binary, and is supposed to remain binary, you
    shouldn't decode it to a text string, of course. But in all other cases, you
    should decode it.</p>
<p class="Pp">Decoding can't happen reliably if you don't know how the data was
    encoded. If you get to choose, it's a good idea to standardize on UTF-8.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    my $foo   = decode('UTF-8', get 'http://example.com/');
    my $bar   = decode('ISO-8859-1', readline STDIN);
    my $xyzzy = decode('Windows-1251', $cgi-&gt;param('foo'));
</pre>
<p class="Pp">Processing happens as you knew before. The only difference is that
    you're now using characters instead of bytes. That's very useful if you use
    things like <span class="Li">&quot;substr&quot;</span>, or
    <span class="Li">&quot;length&quot;</span>.</p>
<p class="Pp">It's important to realize that there are no bytes in a text
    string. Of course, Perl has its internal encoding to store the string in
    memory, but ignore that. If you have to do anything with the number of
    bytes, it's probably best to move that part to step 3, just after you've
    encoded the string. Then you know exactly how many bytes it will be in the
    destination string.</p>
<p class="Pp">The syntax for encoding text strings to binary strings is as
    simple as decoding:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    $body = encode('UTF-8', $body);
</pre>
<p class="Pp">If you needed to know the length of the string in bytes, now's the
    perfect time for that. Because <span class="Li">$body</span> is now a byte
    string, <span class="Li">&quot;length&quot;</span> will report the number of
    bytes, instead of the number of characters. The number of characters is no
    longer known, because characters only exist in text strings.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    my $byte_count = length $body;
</pre>
<p class="Pp">And if the protocol you're using supports a way of letting the
    recipient know which character encoding you used, please help the receiving
    end by using that feature! For example, E-mail and HTTP support MIME
    headers, so you can use the <span class="Li">&quot;Content-Type&quot;</span>
    header. They can also have
    <span class="Li">&quot;Content-Length&quot;</span> to indicate the number of
    <i>bytes</i>, which is always a good idea to supply if the number is
  known.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    &quot;Content-Type: text/plain; charset=UTF-8&quot;,
    &quot;Content-Length: $byte_count&quot;
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="SUMMARY"><a class="permalink" href="#SUMMARY">SUMMARY</a></h1>
Decode everything you receive, encode everything you send out. (If it's text
  data.)
</section>
<section class="Sh">
<h1 class="Sh" id="Q_and_A_(or_FAQ)"><a class="permalink" href="#Q_and_A_(or_FAQ)">Q
  and A (or FAQ)</a></h1>
After reading this document, you ought to read perlunifaq too, then
  perluniintro.
</section>
<section class="Sh">
<h1 class="Sh" id="ACKNOWLEDGEMENTS"><a class="permalink" href="#ACKNOWLEDGEMENTS">ACKNOWLEDGEMENTS</a></h1>
Thanks to Johan Vromans from Squirrel Consultancy. His UTF-8 rants during the
  Amsterdam Perl Mongers meetings got me interested and determined to find out
  how to use character encodings in Perl in ways that don't break easily.
<p class="Pp">Thanks to Gerard Goossen from TTY. His presentation &quot;UTF-8 in
    the wild&quot; (Dutch Perl Workshop 2006) inspired me to publish my thoughts
    and write this tutorial.</p>
<p class="Pp">Thanks to the people who asked about this kind of stuff in several
    Perl IRC channels, and have constantly reminded me that a simpler
    explanation was needed.</p>
<p class="Pp">Thanks to the people who reviewed this document for me, before it
    went public. They are: Benjamin Smith, Jan-Pieter Cornet, Johan Vromans,
    Lukas Mai, Nathan Gray.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
Juerd Waalboer &lt;#####@juerd.nl&gt;
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
perlunifaq, perlunicode, perluniintro, Encode
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2018-03-01</td>
    <td class="foot-os">perl v5.28.2</td>
  </tr>
</table>
</body>
</html>
