<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.10 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>Devel::Peek(3pm)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Devel::Peek(3pm)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">Devel::Peek(3pm)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
Devel::Peek - A data debugging tool for the XS programmer
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<span class="Li"></span>
<pre>
        use Devel::Peek;
        Dump( $a );
        Dump( $a, 5 );
        Dump( @a );
        Dump( %h );
        DumpArray( 5, $a, $b, ... );
        mstat &quot;Point 5&quot;;

        use Devel::Peek ':opd=st';
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
Devel::Peek contains functions which allows raw Perl datatypes to be manipulated
  from a Perl script. This is used by those who do XS programming to check that
  the data they are sending from C to Perl looks as they think it should look.
  The trick, then, is to know what the raw datatype is supposed to look like
  when it gets to Perl. This document offers some tips and hints to describe
  good and bad raw data.
<p class="Pp">It is very possible that this document will fall far short of
    being useful to the casual reader. The reader is expected to understand the
    material in the first few sections of perlguts.</p>
<p class="Pp">Devel::Peek supplies a <span class="Li">&quot;Dump()&quot;</span>
    function which can dump a raw Perl datatype, and
    <span class="Li">&quot;mstat(&quot;marker&quot;)&quot;</span> function to
    report on memory usage (if perl is compiled with corresponding option). The
    function <b>DeadCode()</b> provides statistics on the data
    &quot;frozen&quot; into inactive <span class="Li">&quot;CV&quot;</span>.
    Devel::Peek also supplies <span class="Li">&quot;SvREFCNT()&quot;</span>
    which can query reference counts on SVs. This document will take a passive,
    and safe, approach to data debugging and for that it will describe only the
    <span class="Li">&quot;Dump()&quot;</span> function.</p>
<p class="Pp">All output is to STDERR.</p>
<p class="Pp">The <span class="Li">&quot;Dump()&quot;</span> function takes one
    or two arguments: something to dump, and an optional limit for recursion and
    array elements (default is 4). The first argument is evaluted in rvalue
    scalar context, with exceptions for <span class="Li">@array</span> and
    <span class="Li">%hash</span>, which dump the array or hash itself. So
    <span class="Li">&quot;Dump @array&quot;</span> works, as does
    <span class="Li">&quot;Dump $foo&quot;</span>. And
    <span class="Li">&quot;Dump pos&quot;</span> will call
    <span class="Li">&quot;pos&quot;</span> in rvalue context, whereas
    <span class="Li">&quot;Dump ${\pos}&quot;</span> will call it in lvalue
    context.</p>
<p class="Pp">Function <span class="Li">&quot;DumpArray()&quot;</span> allows
    dumping of multiple values (useful when you need to analyze returns of
    functions).</p>
<p class="Pp">The global variable <span class="Li">$Devel::Peek::pv_limit</span>
    can be set to limit the number of character printed in various string
    values. Setting it to 0 means no limit.</p>
<p class="Pp">If <span class="Li">&quot;use Devel::Peek&quot;</span> directive
    has a <span class="Li">&quot;:opd=FLAGS&quot;</span> argument, this switches
    on debugging of opcode dispatch. <span class="Li">&quot;FLAGS&quot;</span>
    should be a combination of <span class="Li">&quot;s&quot;</span>,
    <span class="Li">&quot;t&quot;</span>, and
    <span class="Li">&quot;P&quot;</span> (see <b>-D</b> flags in perlrun).</p>
<p class="Pp"><span class="Li">&quot;:opd&quot;</span> is a shortcut for
    <span class="Li">&quot;:opd=st&quot;</span>.</p>
<section class="Ss">
<h2 class="Ss" id="Runtime_debugging"><a class="permalink" href="#Runtime_debugging">Runtime
  debugging</a></h2>
<span class="Li">&quot;CvGV($cv)&quot;</span> return one of the globs associated
  to a subroutine reference <span class="Li">$cv</span>.
<p class="Pp"><b>debug_flags()</b> returns a string representation of
    <span class="Li">$^D</span> (similar to what is allowed for <b>-D</b> flag).
    When called with a numeric argument, sets $^D to the corresponding value.
    When called with an argument of the form
    <span class="Li">&quot;flags-flags&quot;</span>, set on/off bits of
    <span class="Li">$^D</span> corresponding to letters before/after
    <span class="Li">&quot;-&quot;</span>. (The returned value is for
    <span class="Li">$^D</span> before the modification.)</p>
<p class="Pp"><b>runops_debug()</b> returns true if the current <i>opcode
    dispatcher</i> is the debugging one. When called with an argument, switches
    to debugging or non-debugging dispatcher depending on the argument (active
    for newly-entered subs/etc only). (The returned value is for the dispatcher
    before the modification.)</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Memory_footprint_debugging"><a class="permalink" href="#Memory_footprint_debugging">Memory
  footprint debugging</a></h2>
When perl is compiled with support for memory footprint debugging (default with
  Perl's <b>malloc()</b>), Devel::Peek provides an access to this API.
<p class="Pp">Use <b>mstat()</b> function to emit a memory state statistic to
    the terminal. For more information on the format of output of <b>mstat()</b>
    see &quot;Using <span class="Li">$ENV</span>{PERL_DEBUG_MSTATS}&quot; in
    perldebguts.</p>
<p class="Pp">Three additional functions allow access to this statistic from
    Perl. First, use <span class="Li">&quot;mstats_fillhash(%hash)&quot;</span>
    to get the information contained in the output of <b>mstat()</b> into
    <span class="Li">%hash</span>. The field of this hash are</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  minbucket nbuckets sbrk_good sbrk_slack sbrked_remains sbrks
  start_slack topbucket topbucket_ev topbucket_odd total total_chain
  total_sbrk totfree
</pre>
<p class="Pp">Two additional fields <span class="Li">&quot;free&quot;</span>,
    <span class="Li">&quot;used&quot;</span> contain array references which
    provide per-bucket count of free and used chunks. Two other fields
    <span class="Li">&quot;mem_size&quot;</span>,
    <span class="Li">&quot;available_size&quot;</span> contain array references
    which provide the information about the allocated size and usable size of
    chunks in each bucket. Again, see &quot;Using
    <span class="Li">$ENV</span>{PERL_DEBUG_MSTATS}&quot; in perldebguts for
    details.</p>
<p class="Pp">Keep in mind that only the first several &quot;odd-numbered&quot;
    buckets are used, so the information on size of the &quot;odd-numbered&quot;
    buckets which are not used is probably meaningless.</p>
<p class="Pp">The information in</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
 mem_size available_size minbucket nbuckets
</pre>
<p class="Pp">is the property of a particular build of perl, and does not depend
    on the current process. If you do not provide the optional argument to the
    functions <b>mstats_fillhash()</b>, <b>fill_mstats()</b>,
    <b>mstats2hash()</b>, then the information in fields
    <span class="Li">&quot;mem_size&quot;</span>,
    <span class="Li">&quot;available_size&quot;</span> is not updated.</p>
<p class="Pp"><span class="Li">&quot;fill_mstats($buf)&quot;</span> is a much
    cheaper call (both speedwise and memory-wise) which collects the statistic
    into <span class="Li">$buf</span> in machine-readable form. At a later
    moment you may need to call <span class="Li">&quot;mstats2hash($buf,
    %hash)&quot;</span> to use this information to fill
    <span class="Li">%hash</span>.</p>
<p class="Pp">All three APIs
    <span class="Li">&quot;fill_mstats($buf)&quot;</span>,
    <span class="Li">&quot;mstats_fillhash(%hash)&quot;</span>, and
    <span class="Li">&quot;mstats2hash($buf, %hash)&quot;</span> are designed to
    allocate no memory if used <i>the second time</i> on the same
    <span class="Li">$buf</span> and/or <span class="Li">%hash</span>.</p>
<p class="Pp">So, if you want to collect memory info in a cycle, you may
  call</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  $#buf = 999;
  fill_mstats($_) for @buf;
  mstats_fillhash(%report, 1);          # Static info too

  foreach (@buf) {
    # Do something...
    fill_mstats $_;                     # Collect statistic
  }
  foreach (@buf) {
    mstats2hash($_, %report);           # Preserve static info
    # Do something with %report
  }
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="EXAMPLES"><a class="permalink" href="#EXAMPLES">EXAMPLES</a></h1>
The following examples don't attempt to show everything as that would be a
  monumental task, and, frankly, we don't want this manpage to be an internals
  document for Perl. The examples do demonstrate some basics of the raw Perl
  datatypes, and should suffice to get most determined people on their way.
  There are no guidewires or safety nets, nor blazed trails, so be prepared to
  travel alone from this point and on and, if at all possible, don't fall into
  the quicksand (it's bad for business).
<p class="Pp">Oh, one final bit of advice: take perlguts with you. When you
    return we expect to see it well-thumbed.</p>
<section class="Ss">
<h2 class="Ss" id="A_simple_scalar_string"><a class="permalink" href="#A_simple_scalar_string">A
  simple scalar string</a></h2>
Let's begin by looking a simple scalar which is holding a string.
<p class="Pp"><span class="Li"></span></p>
<pre>
        use Devel::Peek;
        $a = 42; $a = &quot;hello&quot;;
        Dump $a;
</pre>
<p class="Pp">The output:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
        SV = PVIV(0xbc288) at 0xbe9a8
          REFCNT = 1
          FLAGS = (POK,pPOK)
          IV = 42
          PV = 0xb2048 &quot;hello&quot;\0
          CUR = 5
          LEN = 8
</pre>
<p class="Pp">This says <span class="Li">$a</span> is an SV, a scalar. The
    scalar type is a PVIV, which is capable of holding an integer (IV) and/or a
    string (PV) value. The scalar's head is allocated at address 0xbe9a8, while
    the body is at 0xbc288. Its reference count is 1. It has the
    <span class="Li">&quot;POK&quot;</span> flag set, meaning its current PV
    field is valid. Because POK is set we look at the PV item to see what is in
    the scalar. The \0 at the end indicate that this PV is properly
    NUL-terminated. Note that the IV field still contains its old numeric value,
    but because FLAGS doesn't have IOK set, we must ignore the IV item. CUR
    indicates the number of characters in the PV. LEN indicates the number of
    bytes allocated for the PV (at least one more than CUR, because LEN includes
    an extra byte for the end-of-string marker, then usually rounded up to some
    efficient allocation unit).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="A_simple_scalar_number"><a class="permalink" href="#A_simple_scalar_number">A
  simple scalar number</a></h2>
If the scalar contains a number the raw SV will be leaner.
<p class="Pp"><span class="Li"></span></p>
<pre>
        use Devel::Peek;
        $a = 42;
        Dump $a;
</pre>
<p class="Pp">The output:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
        SV = IV(0xbc818) at 0xbe9a8
          REFCNT = 1
          FLAGS = (IOK,pIOK)
          IV = 42
</pre>
<p class="Pp">This says <span class="Li">$a</span> is an SV, a scalar. The
    scalar is an IV, a number. Its reference count is 1. It has the
    <span class="Li">&quot;IOK&quot;</span> flag set, meaning it is currently
    being evaluated as a number. Because IOK is set we look at the IV item to
    see what is in the scalar.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="A_simple_scalar_with_an_extra_reference"><a class="permalink" href="#A_simple_scalar_with_an_extra_reference">A
  simple scalar with an extra reference</a></h2>
If the scalar from the previous example had an extra reference:
<p class="Pp"><span class="Li"></span></p>
<pre>
        use Devel::Peek;
        $a = 42;
        $b = \$a;
        Dump $a;
</pre>
<p class="Pp">The output:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
        SV = IV(0xbe860) at 0xbe9a8
          REFCNT = 2
          FLAGS = (IOK,pIOK)
          IV = 42
</pre>
<p class="Pp">Notice that this example differs from the previous example only in
    its reference count. Compare this to the next example, where we dump
    <span class="Li">$b</span> instead of <span class="Li">$a</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="A_reference_to_a_simple_scalar"><a class="permalink" href="#A_reference_to_a_simple_scalar">A
  reference to a simple scalar</a></h2>
This shows what a reference looks like when it references a simple scalar.
<p class="Pp"><span class="Li"></span></p>
<pre>
        use Devel::Peek;
        $a = 42;
        $b = \$a;
        Dump $b;
</pre>
<p class="Pp">The output:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
        SV = IV(0xf041c) at 0xbe9a0
          REFCNT = 1
          FLAGS = (ROK)
          RV = 0xbab08
          SV = IV(0xbe860) at 0xbe9a8
            REFCNT = 2
            FLAGS = (IOK,pIOK)
            IV = 42
</pre>
<p class="Pp">Starting from the top, this says <span class="Li">$b</span> is an
    SV. The scalar is an IV, which is capable of holding an integer or reference
    value. It has the <span class="Li">&quot;ROK&quot;</span> flag set, meaning
    it is a reference (rather than an integer or string). Notice that Dump
    follows the reference and shows us what <span class="Li">$b</span> was
    referencing. We see the same <span class="Li">$a</span> that we found in the
    previous example.</p>
<p class="Pp">Note that the value of <span class="Li">&quot;RV&quot;</span>
    coincides with the numbers we see when we stringify
    <span class="Li">$b</span>. The addresses inside <b>IV()</b> are addresses
    of <span class="Li">&quot;X***&quot;</span> structures which hold the
    current state of an <span class="Li">&quot;SV&quot;</span>. This address may
    change during lifetime of an SV.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="A_reference_to_an_array"><a class="permalink" href="#A_reference_to_an_array">A
  reference to an array</a></h2>
This shows what a reference to an array looks like.
<p class="Pp"><span class="Li"></span></p>
<pre>
        use Devel::Peek;
        $a = [42];
        Dump $a;
</pre>
<p class="Pp">The output:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
        SV = IV(0xc85998) at 0xc859a8
          REFCNT = 1
          FLAGS = (ROK)
          RV = 0xc70de8
          SV = PVAV(0xc71e10) at 0xc70de8
            REFCNT = 1
            FLAGS = ()
            ARRAY = 0xc7e820
            FILL = 0
            MAX = 0
            FLAGS = (REAL)
            Elt No. 0
            SV = IV(0xc70f88) at 0xc70f98
              REFCNT = 1
              FLAGS = (IOK,pIOK)
              IV = 42
</pre>
<p class="Pp">This says <span class="Li">$a</span> is a reference (ROK), which
    points to another SV which is a PVAV, an array. The array has one element,
    element zero, which is another SV. The field
    <span class="Li">&quot;FILL&quot;</span> above indicates the last element in
    the array, similar to <span class="Li">&quot;$#$a&quot;</span>.</p>
<p class="Pp">If <span class="Li">$a</span> pointed to an array of two elements
    then we would see the following.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
        use Devel::Peek 'Dump';
        $a = [42,24];
        Dump $a;
</pre>
<p class="Pp">The output:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
        SV = IV(0x158c998) at 0x158c9a8
          REFCNT = 1
          FLAGS = (ROK)
          RV = 0x1577de8
          SV = PVAV(0x1578e10) at 0x1577de8
            REFCNT = 1
            FLAGS = ()
            ARRAY = 0x1585820
            FILL = 1
            MAX = 1
            FLAGS = (REAL)
            Elt No. 0
            SV = IV(0x1577f88) at 0x1577f98
              REFCNT = 1
              FLAGS = (IOK,pIOK)
              IV = 42
            Elt No. 1
            SV = IV(0x158be88) at 0x158be98
              REFCNT = 1
              FLAGS = (IOK,pIOK)
              IV = 24
</pre>
<p class="Pp">Note that <span class="Li">&quot;Dump&quot;</span> will not report
    <i>all</i> the elements in the array, only several first (depending on how
    deep it already went into the report tree).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="A_reference_to_a_hash"><a class="permalink" href="#A_reference_to_a_hash">A
  reference to a hash</a></h2>
The following shows the raw form of a reference to a hash.
<p class="Pp"><span class="Li"></span></p>
<pre>
        use Devel::Peek;
        $a = {hello=&gt;42};
        Dump $a;
</pre>
<p class="Pp">The output:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
        SV = IV(0x8177858) at 0x816a618
          REFCNT = 1
          FLAGS = (ROK)
          RV = 0x814fc10
          SV = PVHV(0x8167768) at 0x814fc10
            REFCNT = 1
            FLAGS = (SHAREKEYS)
            ARRAY = 0x816c5b8  (0:7, 1:1)
            hash quality = 100.0%
            KEYS = 1
            FILL = 1
            MAX = 7
            RITER = -1
            EITER = 0x0
            Elt &quot;hello&quot; HASH = 0xc8fd181b
            SV = IV(0x816c030) at 0x814fcf4
              REFCNT = 1
              FLAGS = (IOK,pIOK)
              IV = 42
</pre>
<p class="Pp">This shows <span class="Li">$a</span> is a reference pointing to
    an SV. That SV is a PVHV, a hash. Fields RITER and EITER are used by
    <span class="Li">&quot;&quot;each&quot; in perlfunc&quot;</span>.</p>
<p class="Pp">The &quot;quality&quot; of a hash is defined as the total number
    of comparisons needed to access every element once, relative to the expected
    number needed for a random hash. The value can go over 100%.</p>
<p class="Pp">The total number of comparisons is equal to the sum of the squares
    of the number of entries in each bucket. For a random hash of
    <span class="Li">&quot;&lt;n&quot;</span>&gt; keys into
    <span class="Li">&quot;&lt;k&quot;</span>&gt; buckets, the expected value
    is:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
                n + n(n-1)/2k
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Dumping_a_large_array_or_hash"><a class="permalink" href="#Dumping_a_large_array_or_hash">Dumping
  a large array or hash</a></h2>
The <span class="Li">&quot;Dump()&quot;</span> function, by default, dumps up to
  4 elements from a toplevel array or hash. This number can be increased by
  supplying a second argument to the function.
<p class="Pp"><span class="Li"></span></p>
<pre>
        use Devel::Peek;
        $a = [10,11,12,13,14];
        Dump $a;
</pre>
<p class="Pp">Notice that <span class="Li">&quot;Dump()&quot;</span> prints only
    elements 10 through 13 in the above code. The following code will print all
    of the elements.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
        use Devel::Peek 'Dump';
        $a = [10,11,12,13,14];
        Dump $a, 5;
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="A_reference_to_an__s-1SV_s0_which_holds_a_C_pointer"><a class="permalink" href="#A_reference_to_an__s-1SV_s0_which_holds_a_C_pointer">A
  reference to an SV which holds a C pointer</a></h2>
This is what you really need to know as an XS programmer, of course. When an
  XSUB returns a pointer to a C structure that pointer is stored in an SV and a
  reference to that SV is placed on the XSUB stack. So the output from an XSUB
  which uses something like the T_PTROBJ map might look something like this:
<p class="Pp"><span class="Li"></span></p>
<pre>
        SV = IV(0xf381c) at 0xc859a8
          REFCNT = 1
          FLAGS = (ROK)
          RV = 0xb8ad8
          SV = PVMG(0xbb3c8) at 0xc859a0
            REFCNT = 1
            FLAGS = (OBJECT,IOK,pIOK)
            IV = 729160
            NV = 0
            PV = 0
            STASH = 0xc1d10       &quot;CookBookB::Opaque&quot;
</pre>
<p class="Pp">This shows that we have an SV which is a reference, which points
    at another SV. In this case that second SV is a PVMG, a blessed scalar.
    Because it is blessed it has the <span class="Li">&quot;OBJECT&quot;</span>
    flag set. Note that an SV which holds a C pointer also has the
    <span class="Li">&quot;IOK&quot;</span> flag set. The
    <span class="Li">&quot;STASH&quot;</span> is set to the package name which
    this SV was blessed into.</p>
<p class="Pp">The output from an XSUB which uses something like the T_PTRREF
    map, which doesn't bless the object, might look something like this:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
        SV = IV(0xf381c) at 0xc859a8
          REFCNT = 1
          FLAGS = (ROK)
          RV = 0xb8ad8
          SV = PVMG(0xbb3c8) at 0xc859a0
            REFCNT = 1
            FLAGS = (IOK,pIOK)
            IV = 729160
            NV = 0
            PV = 0
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="A_reference_to_a_subroutine"><a class="permalink" href="#A_reference_to_a_subroutine">A
  reference to a subroutine</a></h2>
Looks like this:
<p class="Pp"><span class="Li"></span></p>
<pre>
        SV = IV(0x24d2dd8) at 0x24d2de8
          REFCNT = 1
          FLAGS = (TEMP,ROK)
          RV = 0x24e79d8
          SV = PVCV(0x24e5798) at 0x24e79d8
            REFCNT = 2
            FLAGS = ()
            COMP_STASH = 0x22c9c50      &quot;main&quot;
            START = 0x22eed60 ===&gt; 0
            ROOT = 0x22ee490
            GVGV::GV = 0x22de9d8        &quot;MY&quot; :: &quot;top_targets&quot;
            FILE = &quot;(eval 5)&quot;
            DEPTH = 0
            FLAGS = 0x0
            OUTSIDE_SEQ = 93
            PADLIST = 0x22e9ed8
            PADNAME = 0x22e9ec0(0x22eed00) PAD = 0x22e9ea8(0x22eecd0)
            OUTSIDE = 0x22c9fb0 (MAIN)
</pre>
<p class="Pp">This shows that</p>
<ul class="Bl-bullet">
  <li>the subroutine is not an XSUB (since
      <span class="Li">&quot;START&quot;</span> and
      <span class="Li">&quot;ROOT&quot;</span> are non-zero, and
      <span class="Li">&quot;XSUB&quot;</span> is not listed, and is thus
    null);</li>
  <li>that it was compiled in the package
      <span class="Li">&quot;main&quot;</span>;</li>
  <li>under the name <span class="Li">&quot;MY::top_targets&quot;</span>;</li>
  <li>inside a 5th eval in the program;</li>
  <li>it is not currently executed (because
      <span class="Li">&quot;DEPTH&quot;</span> is 0);</li>
  <li>it has no prototype (<span class="Li">&quot;PROTOTYPE&quot;</span> field
      is missing).</li>
</ul>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="EXPORTS"><a class="permalink" href="#EXPORTS">EXPORTS</a></h1>
<span class="Li">&quot;Dump&quot;</span>,
  <span class="Li">&quot;mstat&quot;</span>,
  <span class="Li">&quot;DeadCode&quot;</span>,
  <span class="Li">&quot;DumpArray&quot;</span>,
  <span class="Li">&quot;DumpWithOP&quot;</span> and
  <span class="Li">&quot;DumpProg&quot;</span>,
  <span class="Li">&quot;fill_mstats&quot;</span>,
  <span class="Li">&quot;mstats_fillhash&quot;</span>,
  <span class="Li">&quot;mstats2hash&quot;</span> by default. Additionally
  available <span class="Li">&quot;SvREFCNT&quot;</span>,
  <span class="Li">&quot;SvREFCNT_inc&quot;</span> and
  <span class="Li">&quot;SvREFCNT_dec&quot;</span>.
</section>
<section class="Sh">
<h1 class="Sh" id="BUGS"><a class="permalink" href="#BUGS">BUGS</a></h1>
Readers have been known to skip important parts of perlguts, causing much
  frustration for all.
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
Ilya Zakharevich	ilya@math.ohio-state.edu
<p class="Pp">Copyright (c) 1995-98 Ilya Zakharevich. All rights reserved. This
    program is free software; you can redistribute it and/or modify it under the
    same terms as Perl itself.</p>
<p class="Pp">Author of this software makes no claim whatsoever about
    suitability, reliability, edability, editability or usability of this
    product, and should not be kept liable for any damage resulting from the use
    of it. If you can use it, you are in luck, if not, I should not be kept
    responsible. Keep a handy copy of your backup tape at hand.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
perlguts, and perlguts, again.
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2018-11-01</td>
    <td class="foot-os">perl v5.28.2</td>
  </tr>
</table>
</body>
</html>
