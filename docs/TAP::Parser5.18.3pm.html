<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    .Nd, .Bf, .Op { display: inline; }
    .Pa, .Ad { font-style: italic; }
    .Ms { font-weight: bold; }
    .Bl-diag > dt { font-weight: bold; }
    code.Nm, .Fl, .Cm, .Ic, code.In, .Fd, .Fn, .Cd { font-weight: bold;
      font-family: inherit; }
  </style>
  <title>TAP::Parser(3pm)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">TAP::Parser(3pm)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">TAP::Parser(3pm)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">TAP::Parser - Parse TAP output</p>
</section>
<section class="Sh">
<h1 class="Sh" id="VERSION"><a class="permalink" href="#VERSION">VERSION</a></h1>
<p class="Pp">Version 3.26</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>    use TAP::Parser;
    my $parser = TAP::Parser-&gt;new( { source =&gt; $source } );
    while ( my $result = $parser-&gt;next ) {
        print $result-&gt;as_string;
    }
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp"><span class="Li">&quot;TAP::Parser&quot;</span> is designed to
    produce a proper parse of TAP output. For an example of how to run tests
    through this module, see the simple harnesses
    <span class="Li">&quot;examples/&quot;</span>.</p>
<p class="Pp">There's a wiki dedicated to the Test Anything Protocol:</p>
<p class="Pp">&lt;http://testanything.org&gt;</p>
<p class="Pp">It includes the TAP::Parser Cookbook:</p>
<p class="Pp">&lt;http://testanything.org/wiki/index.php/TAP::Parser_Cookbook&gt;</p>
</section>
<section class="Sh">
<h1 class="Sh" id="METHODS"><a class="permalink" href="#METHODS">METHODS</a></h1>
<section class="Ss">
<h2 class="Ss" id="Class_Methods"><a class="permalink" href="#Class_Methods">Class
  Methods</a></h2>
<p class="Pp"><i></i><span class="Li"><i>&quot;new&quot;</i></span><i></i></p>
<p class="Pp"></p>
<pre> my $parser = TAP::Parser-&gt;new(\%args);
</pre>
<p class="Pp">Returns a new <span class="Li">&quot;TAP::Parser&quot;</span>
    object.</p>
<p class="Pp">The arguments should be a hashref with <i>one</i> of the following
    keys:</p>
<ul class="Bl-bullet">
  <li><span class="Li">&quot;source&quot;</span>
    <p class="Pp"><i>CHANGED in 3.18</i></p>
    <p class="Pp">This is the preferred method of passing input to the
        constructor.</p>
    <p class="Pp">The <span class="Li">&quot;source&quot;</span> is used to
        create a TAP::Parser::Source that is passed to the
        &quot;iterator_factory_class&quot; which in turn figures out how to
        handle the source and creates a &lt;TAP::Parser::Iterator&gt; for it.
        The iterator is used by the parser to read in the TAP stream.</p>
    <p class="Pp">To configure the <i>IteratorFactory</i> use the
        <span class="Li">&quot;sources&quot;</span> parameter below.</p>
    <p class="Pp">Note that <span class="Li">&quot;source&quot;</span>,
        <span class="Li">&quot;tap&quot;</span> and
        <span class="Li">&quot;exec&quot;</span> are <i>mutually
      exclusive</i>.</p>
  </li>
  <li><span class="Li">&quot;tap&quot;</span>
    <p class="Pp"><i>CHANGED in 3.18</i></p>
    <p class="Pp">The value should be the complete TAP output.</p>
    <p class="Pp">The <i>tap</i> is used to create a TAP::Parser::Source that is
        passed to the &quot;iterator_factory_class&quot; which in turn figures
        out how to handle the source and creates a &lt;TAP::Parser::Iterator&gt;
        for it. The iterator is used by the parser to read in the TAP
      stream.</p>
    <p class="Pp">To configure the <i>IteratorFactory</i> use the
        <span class="Li">&quot;sources&quot;</span> parameter below.</p>
    <p class="Pp">Note that <span class="Li">&quot;source&quot;</span>,
        <span class="Li">&quot;tap&quot;</span> and
        <span class="Li">&quot;exec&quot;</span> are <i>mutually
      exclusive</i>.</p>
  </li>
  <li><span class="Li">&quot;exec&quot;</span>
    <p class="Pp">Must be passed an array reference.</p>
    <p class="Pp">The <i>exec</i> array ref is used to create a
        TAP::Parser::Source that is passed to the
        &quot;iterator_factory_class&quot; which in turn figures out how to
        handle the source and creates a &lt;TAP::Parser::Iterator&gt; for it.
        The iterator is used by the parser to read in the TAP stream.</p>
    <p class="Pp">By default the TAP::Parser::SourceHandler::Executable class
        will create a TAP::Parser::Iterator::Process object to handle the
        source. This passes the array reference strings as command arguments to
        IPC::Open3::open3:</p>
    <p class="Pp"></p>
    <pre> exec =&gt; [ '/usr/bin/ruby', 't/my_test.rb' ]
    </pre>
    <p class="Pp">If any <span class="Li">&quot;test_args&quot;</span> are given
        they will be appended to the end of the command argument list.</p>
    <p class="Pp">To configure the <i>IteratorFactory</i> use the
        <span class="Li">&quot;sources&quot;</span> parameter below.</p>
    <p class="Pp">Note that <span class="Li">&quot;source&quot;</span>,
        <span class="Li">&quot;tap&quot;</span> and
        <span class="Li">&quot;exec&quot;</span> are <i>mutually
      exclusive</i>.</p>
  </li>
</ul>
<p class="Pp">The following keys are optional.</p>
<ul class="Bl-bullet">
  <li><span class="Li">&quot;sources&quot;</span>
    <p class="Pp"><i>NEW to 3.18</i>.</p>
    <p class="Pp">If set, <span class="Li">&quot;sources&quot;</span> must be a
        hashref containing the names of the TAP::Parser::SourceHandlers to load
        and/or configure. The values are a hash of configuration that will be
        accessible to to the source handlers via &quot;config_for&quot; in
        TAP::Parser::Source.</p>
    <p class="Pp">For example:</p>
    <p class="Pp"></p>
    <pre>  sources =&gt; {
    Perl =&gt; { exec =&gt; '/path/to/custom/perl' },
    File =&gt; { extensions =&gt; [ '.tap', '.txt' ] },
    MyCustom =&gt; { some =&gt; 'config' },
  }
    </pre>
    <p class="Pp">This will cause
        <span class="Li">&quot;TAP::Parser&quot;</span> to pass custom
        configuration to two of the built- in source handlers -
        TAP::Parser::SourceHandler::Perl, TAP::Parser::SourceHandler::File - and
        attempt to load the <span class="Li">&quot;MyCustom&quot;</span> class.
        See &quot;load_handlers&quot; in TAP::Parser::IteratorFactory for more
        detail.</p>
    <p class="Pp">The <span class="Li">&quot;sources&quot;</span> parameter
        affects how <span class="Li">&quot;source&quot;</span>,
        <span class="Li">&quot;tap&quot;</span> and
        <span class="Li">&quot;exec&quot;</span> parameters are handled.</p>
    <p class="Pp">See TAP::Parser::IteratorFactory, TAP::Parser::SourceHandler
        and subclasses for more details.</p>
  </li>
  <li><span class="Li">&quot;callback&quot;</span>
    <p class="Pp">If present, each callback corresponding to a given result type
        will be called with the result as the argument if the
        <span class="Li">&quot;run&quot;</span> method is used:</p>
    <p class="Pp"></p>
    <pre> my %callbacks = (
     test    =&gt; \&amp;test_callback,
     plan    =&gt; \&amp;plan_callback,
     comment =&gt; \&amp;comment_callback,
     bailout =&gt; \&amp;bailout_callback,
     unknown =&gt; \&amp;unknown_callback,
 );
 my $aggregator = TAP::Parser::Aggregator-&gt;new;
 for my $file ( @test_files ) {
     my $parser = TAP::Parser-&gt;new(
         {
             source    =&gt; $file,
             callbacks =&gt; \%callbacks,
         }
     );
     $parser-&gt;run;
     $aggregator-&gt;add( $file, $parser );
 }
    </pre>
  </li>
  <li><span class="Li">&quot;switches&quot;</span>
    <p class="Pp">If using a Perl file as a source, optional switches may be
        passed which will be used when invoking the perl executable.</p>
    <p class="Pp"></p>
    <pre> my $parser = TAP::Parser-&gt;new( {
     source   =&gt; $test_file,
     switches =&gt; [ '-Ilib' ],
 } );
    </pre>
  </li>
  <li><span class="Li">&quot;test_args&quot;</span>
    <p class="Pp">Used in conjunction with the
        <span class="Li">&quot;source&quot;</span> and
        <span class="Li">&quot;exec&quot;</span> option to supply a reference to
        an <span class="Li">@ARGV</span> style array of arguments to pass to the
        test program.</p>
  </li>
  <li><span class="Li">&quot;spool&quot;</span>
    <p class="Pp">If passed a filehandle will write a copy of all parsed TAP to
        that handle.</p>
  </li>
  <li><span class="Li">&quot;merge&quot;</span>
    <p class="Pp">If false, STDERR is not captured (though it is 'relayed' to
        keep it somewhat synchronized with STDOUT.)</p>
    <p class="Pp">If true, STDERR and STDOUT are the same filehandle. This may
        cause breakage if STDERR contains anything resembling TAP format, but
        does allow exact synchronization.</p>
    <p class="Pp">Subtleties of this behavior may be platform-dependent and may
        change in the future.</p>
  </li>
  <li><span class="Li">&quot;grammar_class&quot;</span>
    <p class="Pp">This option was introduced to let you easily customize which
        <i>grammar</i> class the parser should use. It defaults to
        TAP::Parser::Grammar.</p>
    <p class="Pp">See also &quot;make_grammar&quot;.</p>
  </li>
  <li><span class="Li">&quot;result_factory_class&quot;</span>
    <p class="Pp">This option was introduced to let you easily customize which
        <i>result</i> factory class the parser should use. It defaults to
        TAP::Parser::ResultFactory.</p>
    <p class="Pp">See also &quot;make_result&quot;.</p>
  </li>
  <li><span class="Li">&quot;iterator_factory_class&quot;</span>
    <p class="Pp"><i>CHANGED in 3.18</i></p>
    <p class="Pp">This option was introduced to let you easily customize which
        <i>iterator</i> factory class the parser should use. It defaults to
        TAP::Parser::IteratorFactory.</p>
  </li>
</ul>
</section>
<section class="Ss">
<h2 class="Ss" id="Instance_Methods"><a class="permalink" href="#Instance_Methods">Instance
  Methods</a></h2>
<p class="Pp"><i></i><span class="Li"><i>&quot;next&quot;</i></span><i></i></p>
<p class="Pp"></p>
<pre>  my $parser = TAP::Parser-&gt;new( { source =&gt; $file } );
  while ( my $result = $parser-&gt;next ) {
      print $result-&gt;as_string, &quot;\n&quot;;
  }
</pre>
<p class="Pp">This method returns the results of the parsing, one result at a
    time. Note that it is destructive. You can't rewind and examine previous
    results.</p>
<p class="Pp">If callbacks are used, they will be issued before this call
    returns.</p>
<p class="Pp">Each result returned is a subclass of TAP::Parser::Result. See
    that module and related classes for more information on how to use them.</p>
<p class="Pp"><i></i><span class="Li"><i>&quot;run&quot;</i></span><i></i></p>
<p class="Pp"></p>
<pre>  $parser-&gt;run;
</pre>
<p class="Pp">This method merely runs the parser and parses all of the TAP.</p>
<p class="Pp"><i></i><span class="Li"><i>&quot;make_grammar&quot;</i></span><i></i></p>
<p class="Pp">Make a new TAP::Parser::Grammar object and return it. Passes
    through any arguments given.</p>
<p class="Pp">The <span class="Li">&quot;grammar_class&quot;</span> can be
    customized, as described in &quot;new&quot;.</p>
<p class="Pp"><i></i><span class="Li"><i>&quot;make_result&quot;</i></span><i></i></p>
<p class="Pp">Make a new TAP::Parser::Result object using the parser's
    TAP::Parser::ResultFactory, and return it. Passes through any arguments
    given.</p>
<p class="Pp">The <span class="Li">&quot;result_factory_class&quot;</span> can
    be customized, as described in &quot;new&quot;.</p>
<p class="Pp"><i></i><span class="Li"><i>&quot;make_iterator_factory&quot;</i></span><i></i></p>
<p class="Pp"><i>NEW to 3.18</i>.</p>
<p class="Pp">Make a new TAP::Parser::IteratorFactory object and return it.
    Passes through any arguments given.</p>
<p class="Pp"><span class="Li">&quot;iterator_factory_class&quot;</span> can be
    customized, as described in &quot;new&quot;.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="INDIVIDUAL_RESULTS"><a class="permalink" href="#INDIVIDUAL_RESULTS">INDIVIDUAL
  RESULTS</a></h1>
<p class="Pp">If you've read this far in the docs, you've seen this:</p>
<p class="Pp"></p>
<pre>    while ( my $result = $parser-&gt;next ) {
        print $result-&gt;as_string;
    }
</pre>
<p class="Pp">Each result returned is a TAP::Parser::Result subclass, referred
    to as <i>result types</i>.</p>
<section class="Ss">
<h2 class="Ss" id="Result_types"><a class="permalink" href="#Result_types">Result
  types</a></h2>
<p class="Pp">Basically, you fetch individual results from the TAP. The six
    types, with examples of each, are as follows:</p>
<ul class="Bl-bullet">
  <li>Version
    <p class="Pp"></p>
    <pre> TAP version 12
    </pre>
  </li>
  <li>Plan
    <p class="Pp"></p>
    <pre> 1..42
    </pre>
  </li>
  <li>Pragma
    <p class="Pp"></p>
    <pre> pragma +strict
    </pre>
  </li>
  <li>Test
    <p class="Pp"></p>
    <pre> ok 3 - We should start with some foobar!
    </pre>
  </li>
  <li>Comment
    <p class="Pp"></p>
    <pre> # Hope we don't use up the foobar.
    </pre>
  </li>
  <li>Bailout
    <p class="Pp"></p>
    <pre> Bail out!  We ran out of foobar!
    </pre>
  </li>
  <li>Unknown
    <p class="Pp"></p>
    <pre> ... yo, this ain't TAP! ...
    </pre>
  </li>
</ul>
<p class="Pp">Each result fetched is a result object of a different type. There
    are common methods to each result object and different types may have
    methods unique to their type. Sometimes a type method may be overridden in a
    subclass, but its use is guaranteed to be identical.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Common_type_methods"><a class="permalink" href="#Common_type_methods">Common
  type methods</a></h2>
<p class="Pp"><i></i><span class="Li"><i>&quot;type&quot;</i></span><i></i></p>
<p class="Pp">Returns the type of result, such as
    <span class="Li">&quot;comment&quot;</span> or
    <span class="Li">&quot;test&quot;</span>.</p>
<p class="Pp"><i></i><span class="Li"><i>&quot;as_string&quot;</i></span><i></i></p>
<p class="Pp">Prints a string representation of the token. This might not be the
    exact output, however. Tests will have test numbers added if not present,
    TODO and SKIP directives will be capitalized and, in general, things will be
    cleaned up. If you need the original text for the token, see the
    <span class="Li">&quot;raw&quot;</span> method.</p>
<p class="Pp"><i></i><span class="Li"><i>&quot;raw&quot;</i></span><i></i></p>
<p class="Pp">Returns the original line of text which was parsed.</p>
<p class="Pp"><i></i><span class="Li"><i>&quot;is_plan&quot;</i></span><i></i></p>
<p class="Pp">Indicates whether or not this is the test plan line.</p>
<p class="Pp"><i></i><span class="Li"><i>&quot;is_test&quot;</i></span><i></i></p>
<p class="Pp">Indicates whether or not this is a test line.</p>
<p class="Pp"><i></i><span class="Li"><i>&quot;is_comment&quot;</i></span><i></i></p>
<p class="Pp">Indicates whether or not this is a comment. Comments will
    generally only appear in the TAP stream if STDERR is merged to STDOUT. See
    the <span class="Li">&quot;merge&quot;</span> option.</p>
<p class="Pp"><i></i><span class="Li"><i>&quot;is_bailout&quot;</i></span><i></i></p>
<p class="Pp">Indicates whether or not this is bailout line.</p>
<p class="Pp"><i></i><span class="Li"><i>&quot;is_yaml&quot;</i></span><i></i></p>
<p class="Pp">Indicates whether or not the current item is a YAML block.</p>
<p class="Pp"><i></i><span class="Li"><i>&quot;is_unknown&quot;</i></span><i></i></p>
<p class="Pp">Indicates whether or not the current line could be parsed.</p>
<p class="Pp"><i></i><span class="Li"><i>&quot;is_ok&quot;</i></span><i></i></p>
<p class="Pp"></p>
<pre>  if ( $result-&gt;is_ok ) { ... }
</pre>
<p class="Pp">Reports whether or not a given result has passed. Anything which
    is <b>not</b> a test result returns true. This is merely provided as a
    convenient shortcut which allows you to do this:</p>
<p class="Pp"></p>
<pre> my $parser = TAP::Parser-&gt;new( { source =&gt; $source } );
 while ( my $result = $parser-&gt;next ) {
     # only print failing results
     print $result-&gt;as_string unless $result-&gt;is_ok;
 }
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="_plan__methods"><a class="permalink" href="#_plan__methods">&quot;plan&quot;
  methods</a></h2>
<pre> if ( $result-&gt;is_plan ) { ... }
</pre>
<p class="Pp">If the above evaluates as true, the following methods will be
    available on the <span class="Li">$result</span> object.</p>
<p class="Pp"><i></i><span class="Li"><i>&quot;plan&quot;</i></span><i></i></p>
<p class="Pp"></p>
<pre>  if ( $result-&gt;is_plan ) {
     print $result-&gt;plan;
  }
</pre>
<p class="Pp">This is merely a synonym for
    <span class="Li">&quot;as_string&quot;</span>.</p>
<p class="Pp"><i></i><span class="Li"><i>&quot;directive&quot;</i></span><i></i></p>
<p class="Pp"></p>
<pre> my $directive = $result-&gt;directive;
</pre>
<p class="Pp">If a SKIP directive is included with the plan, this method will
    return it.</p>
<p class="Pp"></p>
<pre> 1..0 # SKIP: why bother?
</pre>
<p class="Pp"><i></i><span class="Li"><i>&quot;explanation&quot;</i></span><i></i></p>
<p class="Pp"></p>
<pre> my $explanation = $result-&gt;explanation;
</pre>
<p class="Pp">If a SKIP directive was included with the plan, this method will
    return the explanation, if any.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_pragma__methods"><a class="permalink" href="#_pragma__methods">&quot;pragma&quot;
  methods</a></h2>
<pre> if ( $result-&gt;is_pragma ) { ... }
</pre>
<p class="Pp">If the above evaluates as true, the following methods will be
    available on the <span class="Li">$result</span> object.</p>
<p class="Pp"><i></i><span class="Li"><i>&quot;pragmas&quot;</i></span><i></i></p>
<p class="Pp">Returns a list of pragmas each of which is a + or - followed by
    the pragma name.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_comment__methods"><a class="permalink" href="#_comment__methods">&quot;comment&quot;
  methods</a></h2>
<pre> if ( $result-&gt;is_comment ) { ... }
</pre>
<p class="Pp">If the above evaluates as true, the following methods will be
    available on the <span class="Li">$result</span> object.</p>
<p class="Pp"><i></i><span class="Li"><i>&quot;comment&quot;</i></span><i></i></p>
<p class="Pp"></p>
<pre>  if ( $result-&gt;is_comment ) {
      my $comment = $result-&gt;comment;
      print &quot;I have something to say:  $comment&quot;;
  }
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="_bailout__methods"><a class="permalink" href="#_bailout__methods">&quot;bailout&quot;
  methods</a></h2>
<pre> if ( $result-&gt;is_bailout ) { ... }
</pre>
<p class="Pp">If the above evaluates as true, the following methods will be
    available on the <span class="Li">$result</span> object.</p>
<p class="Pp"><i></i><span class="Li"><i>&quot;explanation&quot;</i></span><i></i></p>
<p class="Pp"></p>
<pre>  if ( $result-&gt;is_bailout ) {
      my $explanation = $result-&gt;explanation;
      print &quot;We bailed out because ($explanation)&quot;;
  }
</pre>
<p class="Pp">If, and only if, a token is a bailout token, you can get an
    &quot;explanation&quot; via this method. The explanation is the text after
    the mystical &quot;Bail out!&quot; words which appear in the tap output.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_unknown__methods"><a class="permalink" href="#_unknown__methods">&quot;unknown&quot;
  methods</a></h2>
<pre> if ( $result-&gt;is_unknown ) { ... }
</pre>
<p class="Pp">There are no unique methods for unknown results.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_test__methods"><a class="permalink" href="#_test__methods">&quot;test&quot;
  methods</a></h2>
<pre> if ( $result-&gt;is_test ) { ... }
</pre>
<p class="Pp">If the above evaluates as true, the following methods will be
    available on the <span class="Li">$result</span> object.</p>
<p class="Pp"><i></i><span class="Li"><i>&quot;ok&quot;</i></span><i></i></p>
<p class="Pp"></p>
<pre>  my $ok = $result-&gt;ok;
</pre>
<p class="Pp">Returns the literal text of the
    <span class="Li">&quot;ok&quot;</span> or <span class="Li">&quot;not
    ok&quot;</span> status.</p>
<p class="Pp"><i></i><span class="Li"><i>&quot;number&quot;</i></span><i></i></p>
<p class="Pp"></p>
<pre>  my $test_number = $result-&gt;number;
</pre>
<p class="Pp">Returns the number of the test, even if the original TAP output
    did not supply that number.</p>
<p class="Pp"><i></i><span class="Li"><i>&quot;description&quot;</i></span><i></i></p>
<p class="Pp"></p>
<pre>  my $description = $result-&gt;description;
</pre>
<p class="Pp">Returns the description of the test, if any. This is the portion
    after the test number but before the directive.</p>
<p class="Pp"><i></i><span class="Li"><i>&quot;directive&quot;</i></span><i></i></p>
<p class="Pp"></p>
<pre>  my $directive = $result-&gt;directive;
</pre>
<p class="Pp">Returns either <span class="Li">&quot;TODO&quot;</span> or
    <span class="Li">&quot;SKIP&quot;</span> if either directive was present for
    a test line.</p>
<p class="Pp"><i></i><span class="Li"><i>&quot;explanation&quot;</i></span><i></i></p>
<p class="Pp"></p>
<pre>  my $explanation = $result-&gt;explanation;
</pre>
<p class="Pp">If a test had either a <span class="Li">&quot;TODO&quot;</span> or
    <span class="Li">&quot;SKIP&quot;</span> directive, this method will return
    the accompanying explanation, if present.</p>
<p class="Pp"></p>
<pre>  not ok 17 - 'Pigs can fly' # TODO not enough acid
</pre>
<p class="Pp">For the above line, the explanation is <i>not enough acid</i>.</p>
<p class="Pp"><i></i><span class="Li"><i>&quot;is_ok&quot;</i></span><i></i></p>
<p class="Pp"></p>
<pre>  if ( $result-&gt;is_ok ) { ... }
</pre>
<p class="Pp">Returns a boolean value indicating whether or not the test passed.
    Remember that for TODO tests, the test always passes.</p>
<p class="Pp"><b>Note:</b> this was formerly
    <span class="Li">&quot;passed&quot;</span>. The latter method is deprecated
    and will issue a warning.</p>
<p class="Pp"><i></i><span class="Li"><i>&quot;is_actual_ok&quot;</i></span><i></i></p>
<p class="Pp"></p>
<pre>  if ( $result-&gt;is_actual_ok ) { ... }
</pre>
<p class="Pp">Returns a boolean value indicating whether or not the test passed,
    regardless of its TODO status.</p>
<p class="Pp"><b>Note:</b> this was formerly
    <span class="Li">&quot;actual_passed&quot;</span>. The latter method is
    deprecated and will issue a warning.</p>
<p class="Pp"><i></i><span class="Li"><i>&quot;is_unplanned&quot;</i></span><i></i></p>
<p class="Pp"></p>
<pre>  if ( $test-&gt;is_unplanned ) { ... }
</pre>
<p class="Pp">If a test number is greater than the number of planned tests, this
    method will return true. Unplanned tests will <i>always</i> return false for
    <span class="Li">&quot;is_ok&quot;</span>, regardless of whether or not the
    test <span class="Li">&quot;has_todo&quot;</span> (see
    TAP::Parser::Result::Test for more information about this).</p>
<p class="Pp"><i></i><span class="Li"><i>&quot;has_skip&quot;</i></span><i></i></p>
<p class="Pp"></p>
<pre>  if ( $result-&gt;has_skip ) { ... }
</pre>
<p class="Pp">Returns a boolean value indicating whether or not this test had a
    SKIP directive.</p>
<p class="Pp"><i></i><span class="Li"><i>&quot;has_todo&quot;</i></span><i></i></p>
<p class="Pp"></p>
<pre>  if ( $result-&gt;has_todo ) { ... }
</pre>
<p class="Pp">Returns a boolean value indicating whether or not this test had a
    TODO directive.</p>
<p class="Pp">Note that TODO tests <i>always</i> pass. If you need to know
    whether or not they really passed, check the
    <span class="Li">&quot;is_actual_ok&quot;</span> method.</p>
<p class="Pp"><i></i><span class="Li"><i>&quot;in_todo&quot;</i></span><i></i></p>
<p class="Pp"></p>
<pre>  if ( $parser-&gt;in_todo ) { ... }
</pre>
<p class="Pp">True while the most recent result was a TODO. Becomes true before
    the TODO result is returned and stays true until just before the next non-
    TODO test is returned.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="TOTAL_RESULTS"><a class="permalink" href="#TOTAL_RESULTS">TOTAL
  RESULTS</a></h1>
<p class="Pp">After parsing the TAP, there are many methods available to let you
    dig through the results and determine what is meaningful to you.</p>
<section class="Ss">
<h2 class="Ss" id="Individual_Results"><a class="permalink" href="#Individual_Results">Individual
  Results</a></h2>
<p class="Pp">These results refer to individual tests which are run.</p>
<p class="Pp"><i></i><span class="Li"><i>&quot;passed&quot;</i></span><i></i></p>
<p class="Pp"></p>
<pre> my @passed = $parser-&gt;passed; # the test numbers which passed
 my $passed = $parser-&gt;passed; # the number of tests which passed
</pre>
<p class="Pp">This method lets you know which (or how many) tests passed. If a
    test failed but had a TODO directive, it will be counted as a passed
  test.</p>
<p class="Pp"><i></i><span class="Li"><i>&quot;failed&quot;</i></span><i></i></p>
<p class="Pp"></p>
<pre> my @failed = $parser-&gt;failed; # the test numbers which failed
 my $failed = $parser-&gt;failed; # the number of tests which failed
</pre>
<p class="Pp">This method lets you know which (or how many) tests failed. If a
    test passed but had a TODO directive, it will <b>NOT</b> be counted as a
    failed test.</p>
<p class="Pp"><i></i><span class="Li"><i>&quot;actual_passed&quot;</i></span><i></i></p>
<p class="Pp"></p>
<pre> # the test numbers which actually passed
 my @actual_passed = $parser-&gt;actual_passed;
 # the number of tests which actually passed
 my $actual_passed = $parser-&gt;actual_passed;
</pre>
<p class="Pp">This method lets you know which (or how many) tests actually
    passed, regardless of whether or not a TODO directive was found.</p>
<p class="Pp"><i></i><span class="Li"><i>&quot;actual_ok&quot;</i></span><i></i></p>
<p class="Pp">This method is a synonym for
    <span class="Li">&quot;actual_passed&quot;</span>.</p>
<p class="Pp"><i></i><span class="Li"><i>&quot;actual_failed&quot;</i></span><i></i></p>
<p class="Pp"></p>
<pre> # the test numbers which actually failed
 my @actual_failed = $parser-&gt;actual_failed;
 # the number of tests which actually failed
 my $actual_failed = $parser-&gt;actual_failed;
</pre>
<p class="Pp">This method lets you know which (or how many) tests actually
    failed, regardless of whether or not a TODO directive was found.</p>
<p class="Pp"><i></i><span class="Li"><i>&quot;todo&quot;</i></span><i></i></p>
<p class="Pp"></p>
<pre> my @todo = $parser-&gt;todo; # the test numbers with todo directives
 my $todo = $parser-&gt;todo; # the number of tests with todo directives
</pre>
<p class="Pp">This method lets you know which (or how many) tests had TODO
    directives.</p>
<p class="Pp"><i></i><span class="Li"><i>&quot;todo_passed&quot;</i></span><i></i></p>
<p class="Pp"></p>
<pre> # the test numbers which unexpectedly succeeded
 my @todo_passed = $parser-&gt;todo_passed;
 # the number of tests which unexpectedly succeeded
 my $todo_passed = $parser-&gt;todo_passed;
</pre>
<p class="Pp">This method lets you know which (or how many) tests actually
    passed but were declared as &quot;TODO&quot; tests.</p>
<p class="Pp"><i></i><span class="Li"><i>&quot;todo_failed&quot;</i></span><i></i></p>
<p class="Pp"></p>
<pre>  # deprecated in favor of 'todo_passed'.  This method was horribly misnamed.
</pre>
<p class="Pp">This was a badly misnamed method. It indicates which TODO tests
    unexpectedly succeeded. Will now issue a warning and call
    <span class="Li">&quot;todo_passed&quot;</span>.</p>
<p class="Pp"><i></i><span class="Li"><i>&quot;skipped&quot;</i></span><i></i></p>
<p class="Pp"></p>
<pre> my @skipped = $parser-&gt;skipped; # the test numbers with SKIP directives
 my $skipped = $parser-&gt;skipped; # the number of tests with SKIP directives
</pre>
<p class="Pp">This method lets you know which (or how many) tests had SKIP
    directives.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Pragmas"><a class="permalink" href="#Pragmas">Pragmas</a></h2>
<p class="Pp"><i></i><span class="Li"><i>&quot;pragma&quot;</i></span><i></i></p>
<p class="Pp">Get or set a pragma. To get the state of a pragma:</p>
<p class="Pp"></p>
<pre>  if ( $p-&gt;pragma('strict') ) {
      # be strict
  }
</pre>
<p class="Pp">To set the state of a pragma:</p>
<p class="Pp"></p>
<pre>  $p-&gt;pragma('strict', 1); # enable strict mode
</pre>
<p class="Pp"><i></i><span class="Li"><i>&quot;pragmas&quot;</i></span><i></i></p>
<p class="Pp">Get a list of all the currently enabled pragmas:</p>
<p class="Pp"></p>
<pre>  my @pragmas_enabled = $p-&gt;pragmas;
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Summary_Results"><a class="permalink" href="#Summary_Results">Summary
  Results</a></h2>
<p class="Pp">These results are &quot;meta&quot; information about the total
    results of an individual test program.</p>
<p class="Pp"><i></i><span class="Li"><i>&quot;plan&quot;</i></span><i></i></p>
<p class="Pp"></p>
<pre> my $plan = $parser-&gt;plan;
</pre>
<p class="Pp">Returns the test plan, if found.</p>
<p class="Pp"><i></i><span class="Li"><i>&quot;good_plan&quot;</i></span><i></i></p>
<p class="Pp">Deprecated. Use <span class="Li">&quot;is_good_plan&quot;</span>
    instead.</p>
<p class="Pp"><i></i><span class="Li"><i>&quot;is_good_plan&quot;</i></span><i></i></p>
<p class="Pp"></p>
<pre>  if ( $parser-&gt;is_good_plan ) { ... }
</pre>
<p class="Pp">Returns a boolean value indicating whether or not the number of
    tests planned matches the number of tests run.</p>
<p class="Pp"><b>Note:</b> this was formerly
    <span class="Li">&quot;good_plan&quot;</span>. The latter method is
    deprecated and will issue a warning.</p>
<p class="Pp">And since we're on that subject ...</p>
<p class="Pp"><i></i><span class="Li"><i>&quot;tests_planned&quot;</i></span><i></i></p>
<p class="Pp"></p>
<pre>  print $parser-&gt;tests_planned;
</pre>
<p class="Pp">Returns the number of tests planned, according to the plan. For
    example, a plan of '1..17' will mean that 17 tests were planned.</p>
<p class="Pp"><i></i><span class="Li"><i>&quot;tests_run&quot;</i></span><i></i></p>
<p class="Pp"></p>
<pre>  print $parser-&gt;tests_run;
</pre>
<p class="Pp">Returns the number of tests which actually were run. Hopefully
    this will match the number of
    <span class="Li">&quot;$parser-&gt;tests_planned&quot;</span>.</p>
<p class="Pp"><i></i><span class="Li"><i>&quot;skip_all&quot;</i></span><i></i></p>
<p class="Pp">Returns a true value (actually the reason for skipping) if all
    tests were skipped.</p>
<p class="Pp"><i></i><span class="Li"><i>&quot;start_time&quot;</i></span><i></i></p>
<p class="Pp">Returns the time when the Parser was created.</p>
<p class="Pp"><i></i><span class="Li"><i>&quot;end_time&quot;</i></span><i></i></p>
<p class="Pp">Returns the time when the end of TAP input was seen.</p>
<p class="Pp"><i></i><span class="Li"><i>&quot;has_problems&quot;</i></span><i></i></p>
<p class="Pp"></p>
<pre>  if ( $parser-&gt;has_problems ) {
      ...
  }
</pre>
<p class="Pp">This is a 'catch-all' method which returns true if any tests have
    currently failed, any TODO tests unexpectedly succeeded, or any parse errors
    occurred.</p>
<p class="Pp"><i></i><span class="Li"><i>&quot;version&quot;</i></span><i></i></p>
<p class="Pp"></p>
<pre>  $parser-&gt;version;
</pre>
<p class="Pp">Once the parser is done, this will return the version number for
    the parsed TAP. Version numbers were introduced with TAP version 13 so if no
    version number is found version 12 is assumed.</p>
<p class="Pp"><i></i><span class="Li"><i>&quot;exit&quot;</i></span><i></i></p>
<p class="Pp"></p>
<pre>  $parser-&gt;exit;
</pre>
<p class="Pp">Once the parser is done, this will return the exit status. If the
    parser ran an executable, it returns the exit status of the executable.</p>
<p class="Pp"><i></i><span class="Li"><i>&quot;wait&quot;</i></span><i></i></p>
<p class="Pp"></p>
<pre>  $parser-&gt;wait;
</pre>
<p class="Pp">Once the parser is done, this will return the wait status. If the
    parser ran an executable, it returns the wait status of the executable.
    Otherwise, this merely returns the <span class="Li">&quot;exit&quot;</span>
    status.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_ignore_exit_"><a class="permalink" href="#_ignore_exit_">&quot;ignore_exit&quot;</a></h2>
<pre>  $parser-&gt;ignore_exit(1);
</pre>
<p class="Pp">Tell the parser to ignore the exit status from the test when
    determining whether the test passed. Normally tests with non-zero exit
    status are considered to have failed even if all individual tests passed. In
    cases where it is not possible to control the exit value of the test script
    use this option to ignore it.</p>
<p class="Pp"><i></i><span class="Li"><i>&quot;parse_errors&quot;</i></span><i></i></p>
<p class="Pp"></p>
<pre> my @errors = $parser-&gt;parse_errors; # the parser errors
 my $errors = $parser-&gt;parse_errors; # the number of parser_errors
</pre>
<p class="Pp">Fortunately, all TAP output is perfect. In the event that it is
    not, this method will return parser errors. Note that a junk line which the
    parser does not recognize is <span class="Li">&quot;not&quot;</span> an
    error. This allows this parser to handle future versions of TAP. The
    following are all TAP errors reported by the parser:</p>
<ul class="Bl-bullet">
  <li>Misplaced plan
    <p class="Pp">The plan (for example, '1..5'), must only come at the
        beginning or end of the TAP output.</p>
  </li>
  <li>No plan
    <p class="Pp">Gotta have a plan!</p>
  </li>
  <li>More than one plan
    <p class="Pp"></p>
    <pre> 1..3
 ok 1 - input file opened
 not ok 2 - first line of the input valid # todo some data
 ok 3 read the rest of the file
 1..3
    </pre>
    <p class="Pp">Right. Very funny. Don't do that.</p>
  </li>
  <li>Test numbers out of sequence
    <p class="Pp"></p>
    <pre> 1..3
 ok 1 - input file opened
 not ok 2 - first line of the input valid # todo some data
 ok 2 read the rest of the file
    </pre>
    <p class="Pp">That last test line above should have the number '3' instead
        of '2'.</p>
    <p class="Pp">Note that it's perfectly acceptable for some lines to have
        test numbers and others to not have them. However, when a test number is
        found, it must be in sequence. The following is also an error:</p>
    <p class="Pp"></p>
    <pre> 1..3
 ok 1 - input file opened
 not ok - first line of the input valid # todo some data
 ok 2 read the rest of the file
    </pre>
    <p class="Pp">But this is not:</p>
    <p class="Pp"></p>
    <pre> 1..3
 ok  - input file opened
 not ok - first line of the input valid # todo some data
 ok 3 read the rest of the file
    </pre>
  </li>
</ul>
<p class="Pp"><i></i><span class="Li"><i>&quot;get_select_handles&quot;</i></span><i></i></p>
<p class="Pp">Get an a list of file handles which can be passed to
    <span class="Li">&quot;select&quot;</span> to determine the readiness of
    this parser.</p>
<p class="Pp"><i></i><span class="Li"><i>&quot;delete_spool&quot;</i></span><i></i></p>
<p class="Pp">Delete and return the spool.</p>
<p class="Pp"></p>
<pre>  my $fh = $parser-&gt;delete_spool;
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="CALLBACKS"><a class="permalink" href="#CALLBACKS">CALLBACKS</a></h1>
<p class="Pp">As mentioned earlier, a &quot;callback&quot; key may be added to
    the <span class="Li">&quot;TAP::Parser&quot;</span> constructor. If present,
    each callback corresponding to a given result type will be called with the
    result as the argument if the <span class="Li">&quot;run&quot;</span> method
    is used. The callback is expected to be a subroutine reference (or anonymous
    subroutine) which is invoked with the parser result as its argument.</p>
<p class="Pp"></p>
<pre> my %callbacks = (
     test    =&gt; \&amp;test_callback,
     plan    =&gt; \&amp;plan_callback,
     comment =&gt; \&amp;comment_callback,
     bailout =&gt; \&amp;bailout_callback,
     unknown =&gt; \&amp;unknown_callback,
 );
 my $aggregator = TAP::Parser::Aggregator-&gt;new;
 for my $file ( @test_files ) {
     my $parser = TAP::Parser-&gt;new(
         {
             source    =&gt; $file,
             callbacks =&gt; \%callbacks,
         }
     );
     $parser-&gt;run;
     $aggregator-&gt;add( $file, $parser );
 }
</pre>
<p class="Pp">Callbacks may also be added like this:</p>
<p class="Pp"></p>
<pre> $parser-&gt;callback( test =&gt; \&amp;test_callback );
 $parser-&gt;callback( plan =&gt; \&amp;plan_callback );
</pre>
<p class="Pp">The following keys allowed for callbacks. These keys are
    case-sensitive.</p>
<ul class="Bl-bullet">
  <li><span class="Li">&quot;test&quot;</span>
    <p class="Pp">Invoked if
        <span class="Li">&quot;$result-&gt;is_test&quot;</span> returns
      true.</p>
  </li>
  <li><span class="Li">&quot;version&quot;</span>
    <p class="Pp">Invoked if
        <span class="Li">&quot;$result-&gt;is_version&quot;</span> returns
      true.</p>
  </li>
  <li><span class="Li">&quot;plan&quot;</span>
    <p class="Pp">Invoked if
        <span class="Li">&quot;$result-&gt;is_plan&quot;</span> returns
      true.</p>
  </li>
  <li><span class="Li">&quot;comment&quot;</span>
    <p class="Pp">Invoked if
        <span class="Li">&quot;$result-&gt;is_comment&quot;</span> returns
      true.</p>
  </li>
  <li><span class="Li">&quot;bailout&quot;</span>
    <p class="Pp">Invoked if
        <span class="Li">&quot;$result-&gt;is_unknown&quot;</span> returns
      true.</p>
  </li>
  <li><span class="Li">&quot;yaml&quot;</span>
    <p class="Pp">Invoked if
        <span class="Li">&quot;$result-&gt;is_yaml&quot;</span> returns
      true.</p>
  </li>
  <li><span class="Li">&quot;unknown&quot;</span>
    <p class="Pp">Invoked if
        <span class="Li">&quot;$result-&gt;is_unknown&quot;</span> returns
      true.</p>
  </li>
  <li><span class="Li">&quot;ELSE&quot;</span>
    <p class="Pp">If a result does not have a callback defined for it, this
        callback will be invoked. Thus, if all of the previous result types are
        specified as callbacks, this callback will <i>never</i> be invoked.</p>
  </li>
  <li><span class="Li">&quot;ALL&quot;</span>
    <p class="Pp">This callback will always be invoked and this will happen for
        each result after one of the above callbacks is invoked. For example, if
        Term::ANSIColor is loaded, you could use the following to color your
        test output:</p>
    <p class="Pp"></p>
    <pre> my %callbacks = (
     test =&gt; sub {
         my $test = shift;
         if ( $test-&gt;is_ok &amp;&amp; not $test-&gt;directive ) {
             # normal passing test
             print color 'green';
         }
         elsif ( !$test-&gt;is_ok ) {    # even if it's TODO
             print color 'white on_red';
         }
         elsif ( $test-&gt;has_skip ) {
             print color 'white on_blue';
         }
         elsif ( $test-&gt;has_todo ) {
             print color 'white';
         }
     },
     ELSE =&gt; sub {
         # plan, comment, and so on (anything which isn't a test line)
         print color 'black on_white';
     },
     ALL =&gt; sub {
         # now print them
         print shift-&gt;as_string;
         print color 'reset';
         print &quot;\n&quot;;
     },
 );
    </pre>
  </li>
  <li><span class="Li">&quot;EOF&quot;</span>
    <p class="Pp">Invoked when there are no more lines to be parsed. Since there
        is no accompanying TAP::Parser::Result object the
        <span class="Li">&quot;TAP::Parser&quot;</span> object is passed
        instead.</p>
  </li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="TAP_GRAMMAR"><a class="permalink" href="#TAP_GRAMMAR">TAP
  GRAMMAR</a></h1>
<p class="Pp">If you're looking for an EBNF grammar, see
  TAP::Parser::Grammar.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="BACKWARDS_COMPATIBILITY"><a class="permalink" href="#BACKWARDS_COMPATIBILITY">BACKWARDS
  COMPATIBILITY</a></h1>
<p class="Pp">The Perl-QA list attempted to ensure backwards compatibility with
    Test::Harness. However, there are some minor differences.</p>
<section class="Ss">
<h2 class="Ss" id="Differences"><a class="permalink" href="#Differences">Differences</a></h2>
<ul class="Bl-bullet">
  <li>TODO plans
    <p class="Pp">A little-known feature of Test::Harness is that it supported
        TODO lists in the plan:</p>
    <p class="Pp"></p>
    <pre> 1..2 todo 2
 ok 1 - We have liftoff
 not ok 2 - Anti-gravity device activated
    </pre>
    <p class="Pp">Under Test::Harness, test number 2 would <i>pass</i> because
        it was listed as a TODO test on the plan line. However, we are not aware
        of anyone actually using this feature and hard-coding test numbers is
        discouraged because it's very easy to add a test and break the test
        number sequence. This makes test suites very fragile. Instead, the
        following should be used:</p>
    <p class="Pp"></p>
    <pre> 1..2
 ok 1 - We have liftoff
 not ok 2 - Anti-gravity device activated # TODO
    </pre>
  </li>
  <li>'Missing' tests
    <p class="Pp">It rarely happens, but sometimes a harness might encounter
        'missing tests:</p>
    <p class="Pp"></p>
    <pre> ok 1
 ok 2
 ok 15
 ok 16
 ok 17
    </pre>
    <p class="Pp">Test::Harness would report tests 3-14 as having failed. For
        the <span class="Li">&quot;TAP::Parser&quot;</span>, these tests are not
        considered failed because they've never run. They're reported as parse
        failures (tests out of sequence).</p>
  </li>
</ul>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="SUBCLASSING"><a class="permalink" href="#SUBCLASSING">SUBCLASSING</a></h1>
<p class="Pp">If you find you need to provide custom functionality (as you would
    have using Test::Harness::Straps), you're in luck:
    <span class="Li">&quot;TAP::Parser&quot;</span> and friends are designed to
    be easily plugged-into and/or subclassed.</p>
<p class="Pp">Before you start, it's important to know a few things:</p>
<dl class="Bl-tag">
  <dt>1.</dt>
  <dd>All <span class="Li">&quot;TAP::*&quot;</span> objects inherit from
      TAP::Object.</dd>
  <dt>2.</dt>
  <dd>Many <span class="Li">&quot;TAP::*&quot;</span> classes have a
      <i>SUBCLASSING</i> section to guide you.</dd>
  <dt>3.</dt>
  <dd>Note that <span class="Li">&quot;TAP::Parser&quot;</span> is designed to
      be the central &quot;maker&quot; - ie: it is responsible for creating most
      new objects in the <span class="Li">&quot;TAP::Parser::*&quot;</span>
      namespace.
    <p class="Pp">This makes it possible for you to have a single point of
        configuring what subclasses should be used, which means that in many
        cases you'll find you only need to sub-class one of the parser's
        components.</p>
    <p class="Pp">The exception to this rule are <i>SourceHandlers</i> &amp;
        <i>Iterators</i>, but those are both created with customizable
        <i>IteratorFactory</i>.</p>
  </dd>
  <dt>4.</dt>
  <dd>By subclassing, you may end up overriding undocumented methods. That's not
      a bad thing per se, but be forewarned that undocumented methods may change
      without warning from one release to the next - we cannot guarantee
      backwards compatibility. If any <i>documented</i> method needs changing,
      it will be deprecated first, and changed in a later release.</dd>
</dl>
<section class="Ss">
<h2 class="Ss" id="Parser_Components"><a class="permalink" href="#Parser_Components">Parser
  Components</a></h2>
<p class="Pp"><i>Sources</i></p>
<p class="Pp">A TAP parser consumes input from a single <i>raw source</i> of
    TAP, which could come from anywhere (a file, an executable, a database, an
    IO handle, a URI, etc..). The source gets bundled up in a
    TAP::Parser::Source object which gathers some meta data about it. The parser
    then uses a TAP::Parser::IteratorFactory to determine which
    TAP::Parser::SourceHandler to use to turn the raw source into a stream of
    TAP by way of &quot;Iterators&quot;.</p>
<p class="Pp">If you simply want <span class="Li">&quot;TAP::Parser&quot;</span>
    to handle a new source of TAP you probably don't need to subclass
    <span class="Li">&quot;TAP::Parser&quot;</span> itself. Rather, you'll need
    to create a new TAP::Parser::SourceHandler class, and just plug it into the
    parser using the <i>sources</i> param to &quot;new&quot;. Before you start
    writing one, read through TAP::Parser::IteratorFactory to get a feel for how
    the system works first.</p>
<p class="Pp">If you find you really need to use your own iterator factory you
    can still do so without sub-classing
    <span class="Li">&quot;TAP::Parser&quot;</span> by setting
    &quot;iterator_factory_class&quot;.</p>
<p class="Pp">If you just need to customize the objects on creation, subclass
    TAP::Parser and override &quot;make_iterator_factory&quot;.</p>
<p class="Pp">Note that &quot;make_source&quot; &amp;
    &quot;make_perl_source&quot; have been <i>DEPRECATED</i> and are now
    removed.</p>
<p class="Pp"><i>Iterators</i></p>
<p class="Pp">A TAP parser uses <i>iterators</i> to loop through the
    <i>stream</i> of TAP read in from the <i>source</i> it was given. There are
    a few types of Iterators available by default, all sub-classes of
    TAP::Parser::Iterator. Choosing which iterator to use is the responsibility
    of the <i>iterator factory</i>, though it simply delegates to the <i>Source
    Handler</i> it uses.</p>
<p class="Pp">If you're writing your own TAP::Parser::SourceHandler, you may
    need to create your own iterators too. If so you'll need to subclass
    TAP::Parser::Iterator.</p>
<p class="Pp">Note that &quot;make_iterator&quot; has been <i>DEPRECATED</i> and
    is now removed.</p>
<p class="Pp"><i>Results</i></p>
<p class="Pp">A TAP parser creates TAP::Parser::Results as it iterates through
    the input <i>stream</i>. There are quite a few result types available;
    choosing which class to use is the responsibility of the <i>result
    factory</i>.</p>
<p class="Pp">To create your own result types you have two options:</p>
<dl class="Bl-tag">
  <dt id="option"><a class="permalink" href="#option">option 1</a></dt>
  <dd>Subclass TAP::Parser::Result and register your new result type/class with
      the default TAP::Parser::ResultFactory.</dd>
  <dt id="option~2"><a class="permalink" href="#option~2">option 2</a></dt>
  <dd>Subclass TAP::Parser::ResultFactory itself and implement your own
      TAP::Parser::Result creation logic. Then you'll need to customize the
      class used by your parser by setting the
      <span class="Li">&quot;result_factory_class&quot;</span> parameter. See
      &quot;new&quot; for more details.</dd>
</dl>
<p class="Pp">If you need to customize the objects on creation, subclass
    TAP::Parser and override &quot;make_result&quot;.</p>
<p class="Pp"><i>Grammar</i></p>
<p class="Pp">TAP::Parser::Grammar is the heart of the parser. It tokenizes the
    TAP input <i>stream</i> and produces results. If you need to customize its
    behaviour you should probably familiarize yourself with the source first.
    Enough lecturing.</p>
<p class="Pp">Subclass TAP::Parser::Grammar and customize your parser by setting
    the <span class="Li">&quot;grammar_class&quot;</span> parameter. See
    &quot;new&quot; for more details.</p>
<p class="Pp">If you need to customize the objects on creation, subclass
    TAP::Parser and override &quot;make_grammar&quot;</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="ACKNOWLEDGMENTS"><a class="permalink" href="#ACKNOWLEDGMENTS">ACKNOWLEDGMENTS</a></h1>
<p class="Pp">All of the following have helped. Bug reports, patches, (im)moral
    support, or just words of encouragement have all been forthcoming.</p>
<ul class="Bl-bullet">
  <li>Michael Schwern</li>
  <li>Andy Lester</li>
  <li>chromatic</li>
  <li>GEOFFR</li>
  <li>Shlomi Fish</li>
  <li>Torsten Schoenfeld</li>
  <li>Jerry Gay</li>
  <li>Aristotle</li>
  <li>Adam Kennedy</li>
  <li>Yves Orton</li>
  <li>Adrian Howard</li>
  <li>Sean &amp; Lil</li>
  <li>Andreas J. Koenig</li>
  <li>Florian Ragwitz</li>
  <li>Corion</li>
  <li>Mark Stosberg</li>
  <li>Matt Kraai</li>
  <li>David Wheeler</li>
  <li>Alex Vandiver</li>
  <li>Cosimo Streppone</li>
  <li>Ville Skyttae</li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHORS"><a class="permalink" href="#AUTHORS">AUTHORS</a></h1>
<p class="Pp">Curtis &quot;Ovid&quot; Poe &lt;ovid@cpan.org&gt;</p>
<p class="Pp">Andy Armstong &lt;andy@hexten.net&gt;</p>
<p class="Pp">Eric Wilhelm @ &lt;ewilhelm at cpan dot org&gt;</p>
<p class="Pp">Michael Peters &lt;mpeters at plusthree dot com&gt;</p>
<p class="Pp">Leif Eriksen &lt;leif dot eriksen at bigpond dot com&gt;</p>
<p class="Pp">Steve Purkis &lt;spurkis@cpan.org&gt;</p>
<p class="Pp">Nicholas Clark &lt;nick@ccl4.org&gt;</p>
<p class="Pp">Lee Johnson &lt;notfadeaway at btinternet dot com&gt;</p>
<p class="Pp">Philippe Bruhat &lt;book@cpan.org&gt;</p>
</section>
<section class="Sh">
<h1 class="Sh" id="BUGS"><a class="permalink" href="#BUGS">BUGS</a></h1>
<p class="Pp">Please report any bugs or feature requests to
    <span class="Li">&quot;bug-test-harness@rt.cpan.org&quot;</span>, or through
    the web interface at
    &lt;http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Test-Harness&gt;. We will
    be notified, and then you'll automatically be notified of progress on your
    bug as we make changes.</p>
<p class="Pp">Obviously, bugs which include patches are best. If you prefer, you
    can patch against bleed by via anonymous checkout of the latest version:</p>
<p class="Pp"></p>
<pre> git clone git://github.com/Perl-Toolchain-Gang/Test-Harness.git
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT_&amp;_LICENSE"><a class="permalink" href="#COPYRIGHT_&amp;_LICENSE">COPYRIGHT
  &amp; LICENSE</a></h1>
<p class="Pp">Copyright 2006-2008 Curtis &quot;Ovid&quot; Poe, all rights
    reserved.</p>
<p class="Pp">This program is free software; you can redistribute it and/or
    modify it under the same terms as Perl itself.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="POD_ERRORS"><a class="permalink" href="#POD_ERRORS">POD
  ERRORS</a></h1>
<p class="Pp">Hey! <b>The above document had some coding errors, which are
    explained below:</b></p>
<dl class="Bl-tag">
  <dt id="Around"><a class="permalink" href="#Around">Around line 1852:</a></dt>
  <dd>Non-ASCII character seen before =encoding in 'Skyttae'. Assuming
    UTF-8</dd>
</dl>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2014-09-30</td>
    <td class="foot-os">perl v5.18.4</td>
  </tr>
</table>
</body>
</html>
