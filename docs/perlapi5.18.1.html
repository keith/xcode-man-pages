<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>PERLAPI(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">PERLAPI(1)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">PERLAPI(1)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
perlapi - autogenerated documentation for the perl public API
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
This file contains the documentation of the perl public API generated by
  <i>embed.pl</i>, specifically a listing of functions, macros, flags, and
  variables that may be used by extension writers. At the end is a list of
  functions which have yet to be documented. The interfaces of those are subject
  to change without notice. Any functions not listed here are not part of the
  public API, and should not be used by extension writers at all. For these
  reasons, blindly using functions listed in proto.h is to be avoided when
  writing extensions.
<p class="Pp">Note that all Perl API global variables must be referenced with
    the <span class="Li">&quot;PL_&quot;</span> prefix. Some macros are provided
    for compatibility with the older, unadorned names, but this support may be
    disabled in a future release.</p>
<p class="Pp">Perl was originally written to handle US-ASCII only (that is
    characters whose ordinal numbers are in the range 0 - 127). And
    documentation and comments may still use the term ASCII, when sometimes in
    fact the entire range from 0 - 255 is meant.</p>
<p class="Pp">Note that Perl can be compiled and run under EBCDIC (See
    perlebcdic) or ASCII. Most of the documentation (and even comments in the
    code) ignore the EBCDIC possibility. For almost all purposes the differences
    are transparent. As an example, under EBCDIC, instead of UTF-8, UTF-EBCDIC
    is used to encode Unicode strings, and so whenever this documentation refers
    to <span class="Li">&quot;utf8&quot;</span> (and variants of that name,
    including in function names), it also (essentially transparently) means
    <span class="Li">&quot;UTF-EBCDIC&quot;</span>. But the ordinals of
    characters differ between ASCII, EBCDIC, and the UTF- encodings, and a
    string encoded in UTF-EBCDIC may occupy more bytes than in UTF-8.</p>
<p class="Pp">The listing below is alphabetical, case insensitive.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="_Gimme__Values"><a class="permalink" href="#_Gimme__Values">&quot;Gimme&quot;
  Values</a></h1>
<dl class="Bl-tag">
  <dt>GIMME </dt>
  <dd>A backward-compatible version of
      <span class="Li">&quot;GIMME_V&quot;</span> which can only return
      <span class="Li">&quot;G_SCALAR&quot;</span> or
      <span class="Li">&quot;G_ARRAY&quot;</span>; in a void context, it returns
      <span class="Li">&quot;G_SCALAR&quot;</span>. Deprecated. Use
      <span class="Li">&quot;GIMME_V&quot;</span> instead.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        U32     GIMME
    </pre>
  </dd>
  <dt>GIMME_V </dt>
  <dd>The XSUB-writer's equivalent to Perl's
      <span class="Li">&quot;wantarray&quot;</span>. Returns
      <span class="Li">&quot;G_VOID&quot;</span>,
      <span class="Li">&quot;G_SCALAR&quot;</span> or
      <span class="Li">&quot;G_ARRAY&quot;</span> for void, scalar or list
      context, respectively. See perlcall for a usage example.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        U32     GIMME_V
    </pre>
  </dd>
  <dt>G_ARRAY</dt>
  <dd>Used to indicate list context. See
      <span class="Li">&quot;GIMME_V&quot;</span>,
      <span class="Li">&quot;GIMME&quot;</span> and perlcall.</dd>
  <dt>G_DISCARD</dt>
  <dd>Indicates that arguments returned from a callback should be discarded. See
      perlcall.</dd>
  <dt>G_EVAL</dt>
  <dd>Used to force a Perl <span class="Li">&quot;eval&quot;</span> wrapper
      around a callback. See perlcall.</dd>
  <dt>G_NOARGS</dt>
  <dd>Indicates that no arguments are being sent to a callback. See
    perlcall.</dd>
  <dt>G_SCALAR</dt>
  <dd>Used to indicate scalar context. See
      <span class="Li">&quot;GIMME_V&quot;</span>,
      <span class="Li">&quot;GIMME&quot;</span>, and perlcall.</dd>
  <dt>G_VOID</dt>
  <dd>Used to indicate void context. See
      <span class="Li">&quot;GIMME_V&quot;</span> and perlcall.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="Array_Manipulation_Functions"><a class="permalink" href="#Array_Manipulation_Functions">Array
  Manipulation Functions</a></h1>
<dl class="Bl-tag">
  <dt>AvFILL</dt>
  <dd>Same as <span class="Li">&quot;av_top_index()&quot;</span>. Deprecated,
      use <span class="Li">&quot;av_top_index()&quot;</span> instead.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        int     AvFILL(AV* av)
    </pre>
  </dd>
  <dt>av_clear</dt>
  <dd>Clears an array, making it empty. Does not free the memory the av uses to
      store its list of scalars. If any destructors are triggered as a result,
      the av itself may be freed when this function returns.
    <p class="Pp">Perl equivalent: <span class="Li">&quot;@myarray =
        ();&quot;</span>.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    av_clear(AV *av)
    </pre>
  </dd>
  <dt>av_create_and_push</dt>
  <dd>Push an SV onto the end of the array, creating the array if necessary. A
      small internal helper function to remove a commonly duplicated idiom.
    <p class="Pp">NOTE: this function is experimental and may change or be
        removed without notice.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    av_create_and_push(AV **const avp,
                                   SV *const val)
    </pre>
  </dd>
  <dt>av_create_and_unshift_one</dt>
  <dd>Unshifts an SV onto the beginning of the array, creating the array if
      necessary. A small internal helper function to remove a commonly
      duplicated idiom.
    <p class="Pp">NOTE: this function is experimental and may change or be
        removed without notice.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV**    av_create_and_unshift_one(AV **const avp,
                                          SV *const val)
    </pre>
  </dd>
  <dt>av_delete</dt>
  <dd>Deletes the element indexed by <span class="Li">&quot;key&quot;</span>
      from the array, makes the element mortal, and returns it. If
      <span class="Li">&quot;flags&quot;</span> equals
      <span class="Li">&quot;G_DISCARD&quot;</span>, the element is freed and
      null is returned. Perl equivalent: <span class="Li">&quot;my $elem =
      delete($myarray[$idx]);&quot;</span> for the
      non-<span class="Li">&quot;G_DISCARD&quot;</span> version and a
      void-context <span class="Li">&quot;delete($myarray[$idx]);&quot;</span>
      for the <span class="Li">&quot;G_DISCARD&quot;</span> version.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV*     av_delete(AV *av, I32 key, I32 flags)
    </pre>
  </dd>
  <dt>av_exists</dt>
  <dd>Returns true if the element indexed by
      <span class="Li">&quot;key&quot;</span> has been initialized.
    <p class="Pp">This relies on the fact that uninitialized array elements are
        set to <span class="Li">&amp;PL_sv_undef</span>.</p>
    <p class="Pp">Perl equivalent:
        <span class="Li">&quot;exists($myarray[$key])&quot;</span>.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    av_exists(AV *av, I32 key)
    </pre>
  </dd>
  <dt>av_extend</dt>
  <dd>Pre-extend an array. The <span class="Li">&quot;key&quot;</span> is the
      index to which the array should be extended.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    av_extend(AV *av, I32 key)
    </pre>
  </dd>
  <dt>av_fetch</dt>
  <dd>Returns the SV at the specified index in the array. The
      <span class="Li">&quot;key&quot;</span> is the index. If lval is true, you
      are guaranteed to get a real SV back (in case it wasn't real before),
      which you can then modify. Check that the return value is non-null before
      dereferencing it to a <span class="Li">&quot;SV*&quot;</span>.
    <p class="Pp">See &quot;Understanding the Magic of Tied Hashes and
        Arrays&quot; in perlguts for more information on how to use this
        function on tied arrays.</p>
    <p class="Pp">The rough perl equivalent is
        <span class="Li">$myarray[$idx]</span>.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV**    av_fetch(AV *av, I32 key, I32 lval)
    </pre>
  </dd>
  <dt>av_fill</dt>
  <dd>Set the highest index in the array to the given number, equivalent to
      Perl's <span class="Li">&quot;$#array = $fill;&quot;</span>.
    <p class="Pp">The number of elements in the an array will be
        <span class="Li">&quot;fill + 1&quot;</span> after <i>av_fill()</i>
        returns. If the array was previously shorter, then the additional
        elements appended are set to
        <span class="Li">&quot;PL_sv_undef&quot;</span>. If the array was
        longer, then the excess elements are freed.
        <span class="Li">&quot;av_fill(av, -1)&quot;</span> is the same as
        <span class="Li">&quot;av_clear(av)&quot;</span>.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    av_fill(AV *av, I32 fill)
    </pre>
  </dd>
  <dt>av_len</dt>
  <dd>Same as &quot;av_top_index&quot;. Returns the highest index in the array.
      Note that the return value is +1 what its name implies it returns; and
      hence differs in meaning from what the similarly named &quot;sv_len&quot;
      returns.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        I32     av_len(AV *av)
    </pre>
  </dd>
  <dt>av_make</dt>
  <dd>Creates a new AV and populates it with a list of SVs. The SVs are copied
      into the array, so they may be freed after the call to av_make. The new AV
      will have a reference count of 1.
    <p class="Pp">Perl equivalent: <span class="Li">&quot;my @new_array =
        ($scalar1, $scalar2, $scalar3...);&quot;</span></p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        AV*     av_make(I32 size, SV **strp)
    </pre>
  </dd>
  <dt>av_pop</dt>
  <dd>Removes one SV from the end of the array, reducing its size by one and
      returning the SV (transferring control of one reference count) to the
      caller. Returns <span class="Li">&amp;PL_sv_undef</span> if the array is
      empty.
    <p class="Pp">Perl equivalent:
        <span class="Li">&quot;pop(@myarray);&quot;</span></p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV*     av_pop(AV *av)
    </pre>
  </dd>
  <dt>av_push</dt>
  <dd>Pushes an SV onto the end of the array. The array will grow automatically
      to accommodate the addition. This takes ownership of one reference count.
    <p class="Pp">Perl equivalent: <span class="Li">&quot;push @myarray,
        $elem;&quot;</span>.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    av_push(AV *av, SV *val)
    </pre>
  </dd>
  <dt>av_shift</dt>
  <dd>Shifts an SV off the beginning of the array. Returns
      <span class="Li">&amp;PL_sv_undef</span> if the array is empty.
    <p class="Pp">Perl equivalent:
        <span class="Li">&quot;shift(@myarray);&quot;</span></p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV*     av_shift(AV *av)
    </pre>
  </dd>
  <dt>av_store</dt>
  <dd>Stores an SV in an array. The array index is specified as
      <span class="Li">&quot;key&quot;</span>. The return value will be NULL if
      the operation failed or if the value did not need to be actually stored
      within the array (as in the case of tied arrays). Otherwise, it can be
      dereferenced to get the <span class="Li">&quot;SV*&quot;</span> that was
      stored there (= <span class="Li">&quot;val&quot;</span>)).
    <p class="Pp">Note that the caller is responsible for suitably incrementing
        the reference count of <span class="Li">&quot;val&quot;</span> before
        the call, and decrementing it if the function returned NULL.</p>
    <p class="Pp">Approximate Perl equivalent:
        <span class="Li">&quot;$myarray[$key] = $val;&quot;</span>.</p>
    <p class="Pp">See &quot;Understanding the Magic of Tied Hashes and
        Arrays&quot; in perlguts for more information on how to use this
        function on tied arrays.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV**    av_store(AV *av, I32 key, SV *val)
    </pre>
  </dd>
  <dt>av_tindex</dt>
  <dd>Same as <span class="Li">&quot;av_top_index()&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        int     av_tindex(AV* av)
    </pre>
  </dd>
  <dt>av_top_index</dt>
  <dd>Returns the highest index in the array. The number of elements in the
      array is <span class="Li">&quot;av_top_index(av) + 1&quot;</span>. Returns
      -1 if the array is empty.
    <p class="Pp">The Perl equivalent for this is
        <span class="Li">$#myarray</span>.</p>
    <p class="Pp">(A slightly shorter form is
        <span class="Li">&quot;av_tindex&quot;</span>.)</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        I32     av_top_index(AV *av)
    </pre>
  </dd>
  <dt>av_undef</dt>
  <dd>Undefines the array. Frees the memory used by the av to store its list of
      scalars. If any destructors are triggered as a result, the av itself may
      be freed.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    av_undef(AV *av)
    </pre>
  </dd>
  <dt>av_unshift</dt>
  <dd>Unshift the given number of <span class="Li">&quot;undef&quot;</span>
      values onto the beginning of the array. The array will grow automatically
      to accommodate the addition. You must then use
      <span class="Li">&quot;av_store&quot;</span> to assign values to these new
      elements.
    <p class="Pp">Perl equivalent: <span class="Li">&quot;unshift @myarray, (
        (undef) x $n );&quot;</span></p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    av_unshift(AV *av, I32 num)
    </pre>
  </dd>
  <dt>get_av</dt>
  <dd>Returns the AV of the specified Perl global or package array with the
      given name (so it won't work on lexical variables).
      <span class="Li">&quot;flags&quot;</span> are passed to
      <span class="Li">&quot;gv_fetchpv&quot;</span>. If
      <span class="Li">&quot;GV_ADD&quot;</span> is set and the Perl variable
      does not exist then it will be created. If
      <span class="Li">&quot;flags&quot;</span> is zero and the variable does
      not exist then NULL is returned.
    <p class="Pp">Perl equivalent:
        <span class="Li">&quot;@{&quot;$name&quot;}&quot;</span>.</p>
    <p class="Pp">NOTE: the perl_ form of this function is deprecated.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        AV*     get_av(const char *name, I32 flags)
    </pre>
  </dd>
  <dt>newAV</dt>
  <dd>Creates a new AV. The reference count is set to 1.
    <p class="Pp">Perl equivalent: <span class="Li">&quot;my
        @array;&quot;</span>.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        AV*     newAV()
    </pre>
  </dd>
  <dt>sortsv</dt>
  <dd>Sort an array. Here is an example:
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    sortsv(AvARRAY(av), av_top_index(av)+1, Perl_sv_cmp_locale);
    </pre>
    <p class="Pp">Currently this always uses mergesort. See sortsv_flags for a
        more flexible routine.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sortsv(SV** array, size_t num_elts,
                       SVCOMPARE_t cmp)
    </pre>
  </dd>
  <dt>sortsv_flags</dt>
  <dd>Sort an array, with various options.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sortsv_flags(SV** array, size_t num_elts,
                             SVCOMPARE_t cmp, U32 flags)
    </pre>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="Callback_Functions"><a class="permalink" href="#Callback_Functions">Callback
  Functions</a></h1>
<dl class="Bl-tag">
  <dt>call_argv</dt>
  <dd>Performs a callback to the specified named and package-scoped Perl
      subroutine with <span class="Li">&quot;argv&quot;</span> (a
      NULL-terminated array of strings) as arguments. See perlcall.
    <p class="Pp">Approximate Perl equivalent:
        <span class="Li">&quot;&amp;{&quot;$sub_name&quot;}(@$argv)&quot;</span>.</p>
    <p class="Pp">NOTE: the perl_ form of this function is deprecated.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        I32     call_argv(const char* sub_name, I32 flags,
                          char** argv)
    </pre>
  </dd>
  <dt>call_method</dt>
  <dd>Performs a callback to the specified Perl method. The blessed object must
      be on the stack. See perlcall.
    <p class="Pp">NOTE: the perl_ form of this function is deprecated.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        I32     call_method(const char* methname, I32 flags)
    </pre>
  </dd>
  <dt>call_pv</dt>
  <dd>Performs a callback to the specified Perl sub. See perlcall.
    <p class="Pp">NOTE: the perl_ form of this function is deprecated.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        I32     call_pv(const char* sub_name, I32 flags)
    </pre>
  </dd>
  <dt>call_sv</dt>
  <dd>Performs a callback to the Perl sub whose name is in the SV. See perlcall.
    <p class="Pp">NOTE: the perl_ form of this function is deprecated.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        I32     call_sv(SV* sv, VOL I32 flags)
    </pre>
  </dd>
  <dt>ENTER </dt>
  <dd>Opening bracket on a callback. See
      <span class="Li">&quot;LEAVE&quot;</span> and perlcall.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
                ENTER;
    </pre>
  </dd>
  <dt>eval_pv</dt>
  <dd>Tells Perl to <span class="Li">&quot;eval&quot;</span> the given string
      and return an SV* result.
    <p class="Pp">NOTE: the perl_ form of this function is deprecated.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV*     eval_pv(const char* p, I32 croak_on_error)
    </pre>
  </dd>
  <dt>eval_sv</dt>
  <dd>Tells Perl to <span class="Li">&quot;eval&quot;</span> the string in the
      SV. It supports the same flags as
      <span class="Li">&quot;call_sv&quot;</span>, with the obvious exception of
      G_EVAL. See perlcall.
    <p class="Pp">NOTE: the perl_ form of this function is deprecated.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        I32     eval_sv(SV* sv, I32 flags)
    </pre>
  </dd>
  <dt>FREETMPS </dt>
  <dd>Closing bracket for temporaries on a callback. See
      <span class="Li">&quot;SAVETMPS&quot;</span> and perlcall.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
                FREETMPS;
    </pre>
  </dd>
  <dt>LEAVE </dt>
  <dd>Closing bracket on a callback. See
      <span class="Li">&quot;ENTER&quot;</span> and perlcall.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
                LEAVE;
    </pre>
  </dd>
  <dt>SAVETMPS </dt>
  <dd>Opening bracket for temporaries on a callback. See
      <span class="Li">&quot;FREETMPS&quot;</span> and perlcall.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
                SAVETMPS;
    </pre>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="Character_case_changing"><a class="permalink" href="#Character_case_changing">Character
  case changing</a></h1>
<dl class="Bl-tag">
  <dt>toLOWER</dt>
  <dd>Converts the specified character to lowercase, if possible; otherwise
      returns the input character itself.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        char    toLOWER(char ch)
    </pre>
  </dd>
  <dt>toUPPER</dt>
  <dd>Converts the specified character to uppercase, if possible; otherwise
      returns the input character itself.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        char    toUPPER(char ch)
    </pre>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="Character_classes"><a class="permalink" href="#Character_classes">Character
  classes</a></h1>
This section is about functions (really macros) that classify characters into
  types, such as punctuation versus alphabetic, etc. Most of these are analogous
  to regular expression character classes. (See &quot;POSIX Character
  Classes&quot; in perlrecharclass.) There are several variants for each class.
  (Not all macros have all variants; each item below lists the ones valid for
  it.) None are affected by <span class="Li">&quot;use bytes&quot;</span>, and
  only the ones with <span class="Li">&quot;LC&quot;</span> in the name are
  affected by the current locale.
<p class="Pp">The base function, e.g.,
    <span class="Li">&quot;isALPHA()&quot;</span>, takes an octet (either a
    <span class="Li">&quot;char&quot;</span> or a
    <span class="Li">&quot;U8&quot;</span>) as input and returns a boolean as to
    whether or not the character represented by that octet is (or on non-ASCII
    platforms, corresponds to) an ASCII character in the named class based on
    platform, Unicode, and Perl rules. If the input is a number that doesn't fit
    in an octet, FALSE is returned.</p>
<p class="Pp">Variant <span class="Li">&quot;isFOO_A&quot;</span> (e.g.,
    <span class="Li">&quot;isALPHA_A()&quot;</span>) is identical to the base
    function with no suffix <span class="Li">&quot;_A&quot;</span>.</p>
<p class="Pp">Variant <span class="Li">&quot;isFOO_L1&quot;</span> imposes the
    Latin-1 (or EBCDIC equivlalent) character set onto the platform. That is,
    the code points that are ASCII are unaffected, since ASCII is a subset of
    Latin-1. But the non-ASCII code points are treated as if they are Latin-1
    characters. For example, <span class="Li">&quot;isWORDCHAR_L1()&quot;</span>
    will return true when called with the code point 0xDF, which is a word
    character in both ASCII and EBCDIC (though it represent different characters
    in each).</p>
<p class="Pp">Variant <span class="Li">&quot;isFOO_uni&quot;</span> is like the
    <span class="Li">&quot;isFOO_L1&quot;</span> variant, but accepts any UV
    code point as input. If the code point is larger than 255, Unicode rules are
    used to determine if it is in the character class. For example,
    <span class="Li">&quot;isWORDCHAR_uni(0x100)&quot;</span> returns TRUE,
    since 0x100 is LATIN CAPITAL LETTER A WITH MACRON in Unicode, and is a word
    character.</p>
<p class="Pp">Variant <span class="Li">&quot;isFOO_utf8&quot;</span> is like
    <span class="Li">&quot;isFOO_uni&quot;</span>, but the input is a pointer to
    a (known to be well-formed) UTF-8 encoded string
    (<span class="Li">&quot;U8*&quot;</span> or
    <span class="Li">&quot;char*&quot;</span>). The classification of just the
    first (possibly multi-byte) character in the string is tested.</p>
<p class="Pp">Variant <span class="Li">&quot;isFOO_LC&quot;</span> is like the
    <span class="Li">&quot;isFOO_A&quot;</span> and
    <span class="Li">&quot;isFOO_L1&quot;</span> variants, but uses the C
    library function that gives the named classification instead of hard-coded
    rules. For example, <span class="Li">&quot;isDIGIT_LC()&quot;</span> returns
    the result of calling <span class="Li">&quot;isdigit()&quot;</span>. This
    means that the result is based on the current locale, which is what
    <span class="Li">&quot;LC&quot;</span> in the name stands for. FALSE is
    always returned if the input won't fit into an octet.</p>
<p class="Pp">Variant <span class="Li">&quot;isFOO_LC_uvchr&quot;</span> is like
    <span class="Li">&quot;isFOO_LC&quot;</span>, but is defined on any UV. It
    returns the same as <span class="Li">&quot;isFOO_LC&quot;</span> for input
    code points less than 256, and returns the hard-coded,
    not-affected-by-locale, Unicode results for larger ones.</p>
<p class="Pp">Variant <span class="Li">&quot;isFOO_LC_utf8&quot;</span> is like
    <span class="Li">&quot;isFOO_LC_uvchr&quot;</span>, but the input is a
    pointer to a (known to be well-formed) UTF-8 encoded string
    (<span class="Li">&quot;U8*&quot;</span> or
    <span class="Li">&quot;char*&quot;</span>). The classification of just the
    first (possibly multi-byte) character in the string is tested.</p>
<dl class="Bl-tag">
  <dt>isALPHA</dt>
  <dd>Returns a boolean indicating whether the specified character is an
      alphabetic character, analogous to
      <span class="Li">&quot;m/[[:alpha:]]/&quot;</span>. See the top of this
      section for an explanation of variants
      <span class="Li">&quot;isALPHA_A&quot;</span>,
      <span class="Li">&quot;isALPHA_L1&quot;</span>,
      <span class="Li">&quot;isALPHA_uni&quot;</span>,
      <span class="Li">&quot;isALPHA_utf8&quot;</span>,
      <span class="Li">&quot;isALPHA_LC&quot;</span>,
      <span class="Li">&quot;isALPHA_LC_uvchr&quot;</span>, and
      <span class="Li">&quot;isALPHA_LC_utf8&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    isALPHA(char ch)
    </pre>
  </dd>
  <dt>isALPHANUMERIC</dt>
  <dd>Returns a boolean indicating whether the specified character is a either
      an alphabetic character or decimal digit, analogous to
      <span class="Li">&quot;m/[[:alnum:]]/&quot;</span>. See the top of this
      section for an explanation of variants
      <span class="Li">&quot;isALPHANUMERIC_A&quot;</span>,
      <span class="Li">&quot;isALPHANUMERIC_L1&quot;</span>,
      <span class="Li">&quot;isALPHANUMERIC_uni&quot;</span>,
      <span class="Li">&quot;isALPHANUMERIC_utf8&quot;</span>,
      <span class="Li">&quot;isALPHANUMERIC_LC&quot;</span>,
      <span class="Li">&quot;isALPHANUMERIC_LC_uvchr&quot;</span>, and
      <span class="Li">&quot;isALPHANUMERIC_LC_utf8&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    isALPHANUMERIC(char ch)
    </pre>
  </dd>
  <dt>isASCII</dt>
  <dd>Returns a boolean indicating whether the specified character is one of the
      128 characters in the ASCII character set, analogous to
      <span class="Li">&quot;m/[[:ascii:]]/&quot;</span>. On non-ASCII
      platforms, it returns TRUE iff this character corresponds to an ASCII
      character. Variants <span class="Li">&quot;isASCII_A()&quot;</span> and
      <span class="Li">&quot;isASCII_L1()&quot;</span> are identical to
      <span class="Li">&quot;isASCII()&quot;</span>. See the top of this section
      for an explanation of variants
      <span class="Li">&quot;isASCII_uni&quot;</span>,
      <span class="Li">&quot;isASCII_utf8&quot;</span>,
      <span class="Li">&quot;isASCII_LC&quot;</span>,
      <span class="Li">&quot;isASCII_LC_uvchr&quot;</span>, and
      <span class="Li">&quot;isASCII_LC_utf8&quot;</span>. Note, however, that
      some platforms do not have the C library routine
      <span class="Li">&quot;isascii()&quot;</span>. In these cases, the
      variants whose names contain <span class="Li">&quot;LC&quot;</span> are
      the same as the corresponding ones without.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    isASCII(char ch)
    </pre>
  </dd>
  <dt>isBLANK</dt>
  <dd>Returns a boolean indicating whether the specified character is a
      character considered to be a blank, analogous to
      <span class="Li">&quot;m/[[:blank:]]/&quot;</span>. See the top of this
      section for an explanation of variants
      <span class="Li">&quot;isBLANK_A&quot;</span>,
      <span class="Li">&quot;isBLANK_L1&quot;</span>,
      <span class="Li">&quot;isBLANK_uni&quot;</span>,
      <span class="Li">&quot;isBLANK_utf8&quot;</span>,
      <span class="Li">&quot;isBLANK_LC&quot;</span>,
      <span class="Li">&quot;isBLANK_LC_uvchr&quot;</span>, and
      <span class="Li">&quot;isBLANK_LC_utf8&quot;</span>. Note, however, that
      some platforms do not have the C library routine
      <span class="Li">&quot;isblank()&quot;</span>. In these cases, the
      variants whose names contain <span class="Li">&quot;LC&quot;</span> are
      the same as the corresponding ones without.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    isBLANK(char ch)
    </pre>
  </dd>
  <dt>isCNTRL</dt>
  <dd>Returns a boolean indicating whether the specified character is a control
      character, analogous to
      <span class="Li">&quot;m/[[:cntrl:]]/&quot;</span>. See the top of this
      section for an explanation of variants
      <span class="Li">&quot;isCNTRL_A&quot;</span>,
      <span class="Li">&quot;isCNTRL_L1&quot;</span>,
      <span class="Li">&quot;isCNTRL_uni&quot;</span>,
      <span class="Li">&quot;isCNTRL_utf8&quot;</span>,
      <span class="Li">&quot;isCNTRL_LC&quot;</span>,
      <span class="Li">&quot;isCNTRL_LC_uvchr&quot;</span>, and
      <span class="Li">&quot;isCNTRL_LC_utf8&quot;</span> On EBCDIC platforms,
      you almost always want to use the
      <span class="Li">&quot;isCNTRL_L1&quot;</span> variant.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    isCNTRL(char ch)
    </pre>
  </dd>
  <dt>isDIGIT</dt>
  <dd>Returns a boolean indicating whether the specified character is a digit,
      analogous to <span class="Li">&quot;m/[[:digit:]]/&quot;</span>. Variants
      <span class="Li">&quot;isDIGIT_A&quot;</span> and
      <span class="Li">&quot;isDIGIT_L1&quot;</span> are identical to
      <span class="Li">&quot;isDIGIT&quot;</span>. See the top of this section
      for an explanation of variants
      <span class="Li">&quot;isDIGIT_uni&quot;</span>,
      <span class="Li">&quot;isDIGIT_utf8&quot;</span>,
      <span class="Li">&quot;isDIGIT_LC&quot;</span>,
      <span class="Li">&quot;isDIGIT_LC_uvchr&quot;</span>, and
      <span class="Li">&quot;isDIGIT_LC_utf8&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    isDIGIT(char ch)
    </pre>
  </dd>
  <dt>isGRAPH</dt>
  <dd>Returns a boolean indicating whether the specified character is a graphic
      character, analogous to
      <span class="Li">&quot;m/[[:graph:]]/&quot;</span>. See the top of this
      section for an explanation of variants
      <span class="Li">&quot;isGRAPH_A&quot;</span>,
      <span class="Li">&quot;isGRAPH_L1&quot;</span>,
      <span class="Li">&quot;isGRAPH_uni&quot;</span>,
      <span class="Li">&quot;isGRAPH_utf8&quot;</span>,
      <span class="Li">&quot;isGRAPH_LC&quot;</span>,
      <span class="Li">&quot;isGRAPH_LC_uvchr&quot;</span>, and
      <span class="Li">&quot;isGRAPH_LC_utf8&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    isGRAPH(char ch)
    </pre>
  </dd>
  <dt>isIDCONT</dt>
  <dd>Returns a boolean indicating whether the specified character can be the
      second or succeeding character of an identifier. This is very close to,
      but not quite the same as the official Unicode property
      <span class="Li">&quot;XID_Continue&quot;</span>. The difference is that
      this returns true only if the input character also matches
      &quot;isWORDCHAR&quot;. See the top of this section for an explanation of
      variants <span class="Li">&quot;isIDCONT_A&quot;</span>,
      <span class="Li">&quot;isIDCONT_L1&quot;</span>,
      <span class="Li">&quot;isIDCONT_uni&quot;</span>,
      <span class="Li">&quot;isIDCONT_utf8&quot;</span>,
      <span class="Li">&quot;isIDCONT_LC&quot;</span>,
      <span class="Li">&quot;isIDCONT_LC_uvchr&quot;</span>, and
      <span class="Li">&quot;isIDCONT_LC_utf8&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    isIDCONT(char ch)
    </pre>
  </dd>
  <dt>isIDFIRST</dt>
  <dd>Returns a boolean indicating whether the specified character can be the
      first character of an identifier. This is very close to, but not quite the
      same as the official Unicode property
      <span class="Li">&quot;XID_Start&quot;</span>. The difference is that this
      returns true only if the input character also matches
      &quot;isWORDCHAR&quot;. See the top of this section for an explanation of
      variants <span class="Li">&quot;isIDFIRST_A&quot;</span>,
      <span class="Li">&quot;isIDFIRST_L1&quot;</span>,
      <span class="Li">&quot;isIDFIRST_uni&quot;</span>,
      <span class="Li">&quot;isIDFIRST_utf8&quot;</span>,
      <span class="Li">&quot;isIDFIRST_LC&quot;</span>,
      <span class="Li">&quot;isIDFIRST_LC_uvchr&quot;</span>, and
      <span class="Li">&quot;isIDFIRST_LC_utf8&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    isIDFIRST(char ch)
    </pre>
  </dd>
  <dt>isLOWER</dt>
  <dd>Returns a boolean indicating whether the specified character is a
      lowercase character, analogous to
      <span class="Li">&quot;m/[[:lower:]]/&quot;</span>. See the top of this
      section for an explanation of variants
      <span class="Li">&quot;isLOWER_A&quot;</span>,
      <span class="Li">&quot;isLOWER_L1&quot;</span>,
      <span class="Li">&quot;isLOWER_uni&quot;</span>,
      <span class="Li">&quot;isLOWER_utf8&quot;</span>,
      <span class="Li">&quot;isLOWER_LC&quot;</span>,
      <span class="Li">&quot;isLOWER_LC_uvchr&quot;</span>, and
      <span class="Li">&quot;isLOWER_LC_utf8&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    isLOWER(char ch)
    </pre>
  </dd>
  <dt>isOCTAL</dt>
  <dd>Returns a boolean indicating whether the specified character is an octal
      digit, [0-7]. The only two variants are
      <span class="Li">&quot;isOCTAL_A&quot;</span> and
      <span class="Li">&quot;isOCTAL_L1&quot;</span>; each is identical to
      <span class="Li">&quot;isOCTAL&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    isOCTAL(char ch)
    </pre>
  </dd>
  <dt>isPRINT</dt>
  <dd>Returns a boolean indicating whether the specified character is a
      printable character, analogous to
      <span class="Li">&quot;m/[[:print:]]/&quot;</span>. See the top of this
      section for an explanation of variants
      <span class="Li">&quot;isPRINT_A&quot;</span>,
      <span class="Li">&quot;isPRINT_L1&quot;</span>,
      <span class="Li">&quot;isPRINT_uni&quot;</span>,
      <span class="Li">&quot;isPRINT_utf8&quot;</span>,
      <span class="Li">&quot;isPRINT_LC&quot;</span>,
      <span class="Li">&quot;isPRINT_LC_uvchr&quot;</span>, and
      <span class="Li">&quot;isPRINT_LC_utf8&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    isPRINT(char ch)
    </pre>
  </dd>
  <dt>isPSXSPC</dt>
  <dd>(short for Posix Space) Starting in 5.18, this is identical
      (experimentally) in all its forms to the corresponding
      <span class="Li">&quot;isSPACE()&quot;</span> macros.
      (&quot;Experimentally&quot; means that this change may be backed out in
      5.20 or 5.22 if field experience indicates that it was unwise.) The locale
      forms of this macro are identical to their corresponding
      <span class="Li">&quot;isSPACE()&quot;</span> forms in all Perl releases.
      In releases prior to 5.18, the non-locale forms differ from their
      <span class="Li">&quot;isSPACE()&quot;</span> forms only in that the
      <span class="Li">&quot;isSPACE()&quot;</span> forms don't match a Vertical
      Tab, and the <span class="Li">&quot;isPSXSPC()&quot;</span> forms do.
      Otherwise they are identical. Thus this macro is analogous to what
      <span class="Li">&quot;m/[[:space:]]/&quot;</span> matches in a regular
      expression. See the top of this section for an explanation of variants
      <span class="Li">&quot;isPSXSPC_A&quot;</span>,
      <span class="Li">&quot;isPSXSPC_L1&quot;</span>,
      <span class="Li">&quot;isPSXSPC_uni&quot;</span>,
      <span class="Li">&quot;isPSXSPC_utf8&quot;</span>,
      <span class="Li">&quot;isPSXSPC_LC&quot;</span>,
      <span class="Li">&quot;isPSXSPC_LC_uvchr&quot;</span>, and
      <span class="Li">&quot;isPSXSPC_LC_utf8&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    isPSXSPC(char ch)
    </pre>
  </dd>
  <dt>isPUNCT</dt>
  <dd>Returns a boolean indicating whether the specified character is a
      punctuation character, analogous to
      <span class="Li">&quot;m/[[:punct:]]/&quot;</span>. Note that the
      definition of what is punctuation isn't as straightforward as one might
      desire. See &quot;POSIX Character Classes&quot; in perlrecharclass for
      details. See the top of this section for an explanation of variants
      <span class="Li">&quot;isPUNCT_A&quot;</span>,
      <span class="Li">&quot;isPUNCT_L1&quot;</span>,
      <span class="Li">&quot;isPUNCT_uni&quot;</span>,
      <span class="Li">&quot;isPUNCT_utf8&quot;</span>,
      <span class="Li">&quot;isPUNCT_LC&quot;</span>,
      <span class="Li">&quot;isPUNCT_LC_uvchr&quot;</span>, and
      <span class="Li">&quot;isPUNCT_LC_utf8&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    isPUNCT(char ch)
    </pre>
  </dd>
  <dt>isSPACE</dt>
  <dd>Returns a boolean indicating whether the specified character is a
      whitespace character. This is analogous to what
      <span class="Li">&quot;m/\s/&quot;</span> matches in a regular expression.
      Starting in Perl 5.18 (experimentally), this also matches what
      <span class="Li">&quot;m/[[:space:]]/&quot;</span> does.
      (&quot;Experimentally&quot; means that this change may be backed out in
      5.20 or 5.22 if field experience indicates that it was unwise.) Prior to
      5.18, only the locale forms of this macro (the ones with
      <span class="Li">&quot;LC&quot;</span> in their names) matched precisely
      what <span class="Li">&quot;m/[[:space:]]/&quot;</span> does. In those
      releases, the only difference, in the non-locale variants, was that
      <span class="Li">&quot;isSPACE()&quot;</span> did not match a vertical
      tab. (See &quot;isPSXSPC&quot; for a macro that matches a vertical tab in
      all releases.) See the top of this section for an explanation of variants
      <span class="Li">&quot;isSPACE_A&quot;</span>,
      <span class="Li">&quot;isSPACE_L1&quot;</span>,
      <span class="Li">&quot;isSPACE_uni&quot;</span>,
      <span class="Li">&quot;isSPACE_utf8&quot;</span>,
      <span class="Li">&quot;isSPACE_LC&quot;</span>,
      <span class="Li">&quot;isSPACE_LC_uvchr&quot;</span>, and
      <span class="Li">&quot;isSPACE_LC_utf8&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    isSPACE(char ch)
    </pre>
  </dd>
  <dt>isUPPER</dt>
  <dd>Returns a boolean indicating whether the specified character is an
      uppercase character, analogous to
      <span class="Li">&quot;m/[[:upper:]]/&quot;</span>. See the top of this
      section for an explanation of variants
      <span class="Li">&quot;isUPPER_A&quot;</span>,
      <span class="Li">&quot;isUPPER_L1&quot;</span>,
      <span class="Li">&quot;isUPPER_uni&quot;</span>,
      <span class="Li">&quot;isUPPER_utf8&quot;</span>,
      <span class="Li">&quot;isUPPER_LC&quot;</span>,
      <span class="Li">&quot;isUPPER_LC_uvchr&quot;</span>, and
      <span class="Li">&quot;isUPPER_LC_utf8&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    isUPPER(char ch)
    </pre>
  </dd>
  <dt>isWORDCHAR</dt>
  <dd>Returns a boolean indicating whether the specified character is a
      character that is a word character, analogous to what
      <span class="Li">&quot;m/\w/&quot;</span> and
      <span class="Li">&quot;m/[[:word:]]/&quot;</span> match in a regular
      expression. A word character is an alphabetic character, a decimal digit,
      a connecting punctuation character (such as an underscore), or a
      &quot;mark&quot; character that attaches to one of those (like some sort
      of accent). <span class="Li">&quot;isALNUM()&quot;</span> is a synonym
      provided for backward compatibility, even though a word character includes
      more than the standard C language meaning of alphanumeric. See the top of
      this section for an explanation of variants
      <span class="Li">&quot;isWORDCHAR_A&quot;</span>,
      <span class="Li">&quot;isWORDCHAR_L1&quot;</span>,
      <span class="Li">&quot;isWORDCHAR_uni&quot;</span>,
      <span class="Li">&quot;isWORDCHAR_utf8&quot;</span>,
      <span class="Li">&quot;isWORDCHAR_LC&quot;</span>,
      <span class="Li">&quot;isWORDCHAR_LC_uvchr&quot;</span>, and
      <span class="Li">&quot;isWORDCHAR_LC_utf8&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    isWORDCHAR(char ch)
    </pre>
  </dd>
  <dt>isXDIGIT</dt>
  <dd>Returns a boolean indicating whether the specified character is a
      hexadecimal digit. In the ASCII range these are
      <span class="Li">&quot;[0-9A-Fa-f]&quot;</span>. Variants
      <span class="Li">&quot;isXDIGIT_A()&quot;</span> and
      <span class="Li">&quot;isXDIGIT_L1()&quot;</span> are identical to
      <span class="Li">&quot;isXDIGIT()&quot;</span>. See the top of this
      section for an explanation of variants
      <span class="Li">&quot;isXDIGIT_uni&quot;</span>,
      <span class="Li">&quot;isXDIGIT_utf8&quot;</span>,
      <span class="Li">&quot;isXDIGIT_LC&quot;</span>,
      <span class="Li">&quot;isXDIGIT_LC_uvchr&quot;</span>, and
      <span class="Li">&quot;isXDIGIT_LC_utf8&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    isXDIGIT(char ch)
    </pre>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="Cloning_an_interpreter"><a class="permalink" href="#Cloning_an_interpreter">Cloning
  an interpreter</a></h1>
<dl class="Bl-tag">
  <dt>perl_clone</dt>
  <dd>Create and return a new interpreter by cloning the current one.
    <p class="Pp">perl_clone takes these flags as parameters:</p>
    <p class="Pp">CLONEf_COPY_STACKS - is used to, well, copy the stacks also,
        without it we only clone the data and zero the stacks, with it we copy
        the stacks and the new perl interpreter is ready to run at the exact
        same point as the previous one. The pseudo-fork code uses COPY_STACKS
        while the threads-&gt;create doesn't.</p>
    <p class="Pp">CLONEf_KEEP_PTR_TABLE - perl_clone keeps a ptr_table with the
        pointer of the old variable as a key and the new variable as a value,
        this allows it to check if something has been cloned and not clone it
        again but rather just use the value and increase the refcount. If
        KEEP_PTR_TABLE is not set then perl_clone will kill the ptr_table using
        the function <span class="Li">&quot;ptr_table_free(PL_ptr_table);
        PL_ptr_table = NULL;&quot;</span>, reason to keep it around is if you
        want to dup some of your own variable who are outside the graph perl
        scans, example of this code is in threads.xs create.</p>
    <p class="Pp">CLONEf_CLONE_HOST - This is a win32 thing, it is ignored on
        unix, it tells perls win32host code (which is c++) to clone itself, this
        is needed on win32 if you want to run two threads at the same time, if
        you just want to do some stuff in a separate perl interpreter and then
        throw it away and return to the original one, you don't need to do
        anything.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        PerlInterpreter* perl_clone(
                             PerlInterpreter *proto_perl,
                             UV flags
                         )
    </pre>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="Compile-time_scope_hooks"><a class="permalink" href="#Compile-time_scope_hooks">Compile-time
  scope hooks</a></h1>
<dl class="Bl-tag">
  <dt>BhkDISABLE</dt>
  <dd>Temporarily disable an entry in this BHK structure, by clearing the
      appropriate flag. <i>which</i> is a preprocessor token indicating which
      entry to disable.
    <p class="Pp">NOTE: this function is experimental and may change or be
        removed without notice.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    BhkDISABLE(BHK *hk, which)
    </pre>
  </dd>
  <dt>BhkENABLE</dt>
  <dd>Re-enable an entry in this BHK structure, by setting the appropriate flag.
      <i>which</i> is a preprocessor token indicating which entry to enable.
      This will assert (under -DDEBUGGING) if the entry doesn't contain a valid
      pointer.
    <p class="Pp">NOTE: this function is experimental and may change or be
        removed without notice.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    BhkENABLE(BHK *hk, which)
    </pre>
  </dd>
  <dt>BhkENTRY_set</dt>
  <dd>Set an entry in the BHK structure, and set the flags to indicate it is
      valid. <i>which</i> is a preprocessing token indicating which entry to
      set. The type of <i>ptr</i> depends on the entry.
    <p class="Pp">NOTE: this function is experimental and may change or be
        removed without notice.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    BhkENTRY_set(BHK *hk, which, void *ptr)
    </pre>
  </dd>
  <dt>blockhook_register</dt>
  <dd>Register a set of hooks to be called when the Perl lexical scope changes
      at compile time. See &quot;Compile-time scope hooks&quot; in perlguts.
    <p class="Pp">NOTE: this function is experimental and may change or be
        removed without notice.</p>
    <p class="Pp">NOTE: this function must be explicitly called as
        Perl_blockhook_register with an aTHX_ parameter.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    Perl_blockhook_register(pTHX_ BHK *hk)
    </pre>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="COP_Hint_Hashes"><a class="permalink" href="#COP_Hint_Hashes">COP
  Hint Hashes</a></h1>
<dl class="Bl-tag">
  <dt>cophh_2hv</dt>
  <dd>Generates and returns a standard Perl hash representing the full set of
      key/value pairs in the cop hints hash <i>cophh</i>. <i>flags</i> is
      currently unused and must be zero.
    <p class="Pp">NOTE: this function is experimental and may change or be
        removed without notice.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        HV *    cophh_2hv(const COPHH *cophh, U32 flags)
    </pre>
  </dd>
  <dt>cophh_copy</dt>
  <dd>Make and return a complete copy of the cop hints hash <i>cophh</i>.
    <p class="Pp">NOTE: this function is experimental and may change or be
        removed without notice.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        COPHH * cophh_copy(COPHH *cophh)
    </pre>
  </dd>
  <dt>cophh_delete_pv</dt>
  <dd>Like &quot;cophh_delete_pvn&quot;, but takes a nul-terminated string
      instead of a string/length pair.
    <p class="Pp">NOTE: this function is experimental and may change or be
        removed without notice.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        COPHH * cophh_delete_pv(const COPHH *cophh,
                                const char *key, U32 hash,
                                U32 flags)
    </pre>
  </dd>
  <dt>cophh_delete_pvn</dt>
  <dd>Delete a key and its associated value from the cop hints hash
      <i>cophh</i>, and returns the modified hash. The returned hash pointer is
      in general not the same as the hash pointer that was passed in. The input
      hash is consumed by the function, and the pointer to it must not be
      subsequently used. Use &quot;cophh_copy&quot; if you need both hashes.
    <p class="Pp">The key is specified by <i>keypv</i> and <i>keylen</i>. If
        <i>flags</i> has the <span class="Li">&quot;COPHH_KEY_UTF8&quot;</span>
        bit set, the key octets are interpreted as UTF-8, otherwise they are
        interpreted as Latin-1. <i>hash</i> is a precomputed hash of the key
        string, or zero if it has not been precomputed.</p>
    <p class="Pp">NOTE: this function is experimental and may change or be
        removed without notice.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        COPHH * cophh_delete_pvn(COPHH *cophh,
                                 const char *keypv,
                                 STRLEN keylen, U32 hash,
                                 U32 flags)
    </pre>
  </dd>
  <dt>cophh_delete_pvs</dt>
  <dd>Like &quot;cophh_delete_pvn&quot;, but takes a literal string instead of a
      string/length pair, and no precomputed hash.
    <p class="Pp">NOTE: this function is experimental and may change or be
        removed without notice.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        COPHH * cophh_delete_pvs(const COPHH *cophh,
                                 const char *key, U32 flags)
    </pre>
  </dd>
  <dt>cophh_delete_sv</dt>
  <dd>Like &quot;cophh_delete_pvn&quot;, but takes a Perl scalar instead of a
      string/length pair.
    <p class="Pp">NOTE: this function is experimental and may change or be
        removed without notice.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        COPHH * cophh_delete_sv(const COPHH *cophh, SV *key,
                                U32 hash, U32 flags)
    </pre>
  </dd>
  <dt>cophh_fetch_pv</dt>
  <dd>Like &quot;cophh_fetch_pvn&quot;, but takes a nul-terminated string
      instead of a string/length pair.
    <p class="Pp">NOTE: this function is experimental and may change or be
        removed without notice.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV *    cophh_fetch_pv(const COPHH *cophh,
                               const char *key, U32 hash,
                               U32 flags)
    </pre>
  </dd>
  <dt>cophh_fetch_pvn</dt>
  <dd>Look up the entry in the cop hints hash <i>cophh</i> with the key
      specified by <i>keypv</i> and <i>keylen</i>. If <i>flags</i> has the
      <span class="Li">&quot;COPHH_KEY_UTF8&quot;</span> bit set, the key octets
      are interpreted as UTF-8, otherwise they are interpreted as Latin-1.
      <i>hash</i> is a precomputed hash of the key string, or zero if it has not
      been precomputed. Returns a mortal scalar copy of the value associated
      with the key, or <span class="Li">&amp;PL_sv_placeholder</span> if there
      is no value associated with the key.
    <p class="Pp">NOTE: this function is experimental and may change or be
        removed without notice.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV *    cophh_fetch_pvn(const COPHH *cophh,
                                const char *keypv,
                                STRLEN keylen, U32 hash,
                                U32 flags)
    </pre>
  </dd>
  <dt>cophh_fetch_pvs</dt>
  <dd>Like &quot;cophh_fetch_pvn&quot;, but takes a literal string instead of a
      string/length pair, and no precomputed hash.
    <p class="Pp">NOTE: this function is experimental and may change or be
        removed without notice.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV *    cophh_fetch_pvs(const COPHH *cophh,
                                const char *key, U32 flags)
    </pre>
  </dd>
  <dt>cophh_fetch_sv</dt>
  <dd>Like &quot;cophh_fetch_pvn&quot;, but takes a Perl scalar instead of a
      string/length pair.
    <p class="Pp">NOTE: this function is experimental and may change or be
        removed without notice.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV *    cophh_fetch_sv(const COPHH *cophh, SV *key,
                               U32 hash, U32 flags)
    </pre>
  </dd>
  <dt>cophh_free</dt>
  <dd>Discard the cop hints hash <i>cophh</i>, freeing all resources associated
      with it.
    <p class="Pp">NOTE: this function is experimental and may change or be
        removed without notice.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    cophh_free(COPHH *cophh)
    </pre>
  </dd>
  <dt>cophh_new_empty</dt>
  <dd>Generate and return a fresh cop hints hash containing no entries.
    <p class="Pp">NOTE: this function is experimental and may change or be
        removed without notice.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        COPHH * cophh_new_empty()
    </pre>
  </dd>
  <dt>cophh_store_pv</dt>
  <dd>Like &quot;cophh_store_pvn&quot;, but takes a nul-terminated string
      instead of a string/length pair.
    <p class="Pp">NOTE: this function is experimental and may change or be
        removed without notice.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        COPHH * cophh_store_pv(const COPHH *cophh,
                               const char *key, U32 hash,
                               SV *value, U32 flags)
    </pre>
  </dd>
  <dt>cophh_store_pvn</dt>
  <dd>Stores a value, associated with a key, in the cop hints hash <i>cophh</i>,
      and returns the modified hash. The returned hash pointer is in general not
      the same as the hash pointer that was passed in. The input hash is
      consumed by the function, and the pointer to it must not be subsequently
      used. Use &quot;cophh_copy&quot; if you need both hashes.
    <p class="Pp">The key is specified by <i>keypv</i> and <i>keylen</i>. If
        <i>flags</i> has the <span class="Li">&quot;COPHH_KEY_UTF8&quot;</span>
        bit set, the key octets are interpreted as UTF-8, otherwise they are
        interpreted as Latin-1. <i>hash</i> is a precomputed hash of the key
        string, or zero if it has not been precomputed.</p>
    <p class="Pp"><i>value</i> is the scalar value to store for this key.
        <i>value</i> is copied by this function, which thus does not take
        ownership of any reference to it, and later changes to the scalar will
        not be reflected in the value visible in the cop hints hash. Complex
        types of scalar will not be stored with referential integrity, but will
        be coerced to strings.</p>
    <p class="Pp">NOTE: this function is experimental and may change or be
        removed without notice.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        COPHH * cophh_store_pvn(COPHH *cophh, const char *keypv,
                                STRLEN keylen, U32 hash,
                                SV *value, U32 flags)
    </pre>
  </dd>
  <dt>cophh_store_pvs</dt>
  <dd>Like &quot;cophh_store_pvn&quot;, but takes a literal string instead of a
      string/length pair, and no precomputed hash.
    <p class="Pp">NOTE: this function is experimental and may change or be
        removed without notice.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        COPHH * cophh_store_pvs(const COPHH *cophh,
                                const char *key, SV *value,
                                U32 flags)
    </pre>
  </dd>
  <dt>cophh_store_sv</dt>
  <dd>Like &quot;cophh_store_pvn&quot;, but takes a Perl scalar instead of a
      string/length pair.
    <p class="Pp">NOTE: this function is experimental and may change or be
        removed without notice.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        COPHH * cophh_store_sv(const COPHH *cophh, SV *key,
                               U32 hash, SV *value, U32 flags)
    </pre>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="COP_Hint_Reading"><a class="permalink" href="#COP_Hint_Reading">COP
  Hint Reading</a></h1>
<dl class="Bl-tag">
  <dt>cop_hints_2hv</dt>
  <dd>Generates and returns a standard Perl hash representing the full set of
      hint entries in the cop <i>cop</i>. <i>flags</i> is currently unused and
      must be zero.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        HV *    cop_hints_2hv(const COP *cop, U32 flags)
    </pre>
  </dd>
  <dt>cop_hints_fetch_pv</dt>
  <dd>Like &quot;cop_hints_fetch_pvn&quot;, but takes a nul-terminated string
      instead of a string/length pair.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV *    cop_hints_fetch_pv(const COP *cop,
                                   const char *key, U32 hash,
                                   U32 flags)
    </pre>
  </dd>
  <dt>cop_hints_fetch_pvn</dt>
  <dd>Look up the hint entry in the cop <i>cop</i> with the key specified by
      <i>keypv</i> and <i>keylen</i>. If <i>flags</i> has the
      <span class="Li">&quot;COPHH_KEY_UTF8&quot;</span> bit set, the key octets
      are interpreted as UTF-8, otherwise they are interpreted as Latin-1.
      <i>hash</i> is a precomputed hash of the key string, or zero if it has not
      been precomputed. Returns a mortal scalar copy of the value associated
      with the key, or <span class="Li">&amp;PL_sv_placeholder</span> if there
      is no value associated with the key.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV *    cop_hints_fetch_pvn(const COP *cop,
                                    const char *keypv,
                                    STRLEN keylen, U32 hash,
                                    U32 flags)
    </pre>
  </dd>
  <dt>cop_hints_fetch_pvs</dt>
  <dd>Like &quot;cop_hints_fetch_pvn&quot;, but takes a literal string instead
      of a string/length pair, and no precomputed hash.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV *    cop_hints_fetch_pvs(const COP *cop,
                                    const char *key, U32 flags)
    </pre>
  </dd>
  <dt>cop_hints_fetch_sv</dt>
  <dd>Like &quot;cop_hints_fetch_pvn&quot;, but takes a Perl scalar instead of a
      string/length pair.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV *    cop_hints_fetch_sv(const COP *cop, SV *key,
                                   U32 hash, U32 flags)
    </pre>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="Custom_Operators"><a class="permalink" href="#Custom_Operators">Custom
  Operators</a></h1>
<dl class="Bl-tag">
  <dt>custom_op_register</dt>
  <dd>Register a custom op. See &quot;Custom Operators&quot; in perlguts.
    <p class="Pp">NOTE: this function must be explicitly called as
        Perl_custom_op_register with an aTHX_ parameter.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    Perl_custom_op_register(pTHX_ 
                                        Perl_ppaddr_t ppaddr,
                                        const XOP *xop)
    </pre>
  </dd>
  <dt>custom_op_xop</dt>
  <dd>Return the XOP structure for a given custom op. This function should be
      considered internal to OP_NAME and the other access macros: use them
      instead.
    <p class="Pp">NOTE: this function must be explicitly called as
        Perl_custom_op_xop with an aTHX_ parameter.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        const XOP * Perl_custom_op_xop(pTHX_ const OP *o)
    </pre>
  </dd>
  <dt>XopDISABLE</dt>
  <dd>Temporarily disable a member of the XOP, by clearing the appropriate flag.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    XopDISABLE(XOP *xop, which)
    </pre>
  </dd>
  <dt>XopENABLE</dt>
  <dd>Reenable a member of the XOP which has been disabled.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    XopENABLE(XOP *xop, which)
    </pre>
  </dd>
  <dt>XopENTRY</dt>
  <dd>Return a member of the XOP structure. <i>which</i> is a cpp token
      indicating which entry to return. If the member is not set this will
      return a default value. The return type depends on <i>which</i>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
                XopENTRY(XOP *xop, which)
    </pre>
  </dd>
  <dt>XopENTRY_set</dt>
  <dd>Set a member of the XOP structure. <i>which</i> is a cpp token indicating
      which entry to set. See &quot;Custom Operators&quot; in perlguts for
      details about the available members and how they are used.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    XopENTRY_set(XOP *xop, which, value)
    </pre>
  </dd>
  <dt>XopFLAGS</dt>
  <dd>Return the XOP's flags.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        U32     XopFLAGS(XOP *xop)
    </pre>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="CV_Manipulation_Functions"><a class="permalink" href="#CV_Manipulation_Functions">CV
  Manipulation Functions</a></h1>
<dl class="Bl-tag">
  <dt>CvSTASH</dt>
  <dd>Returns the stash of the CV. A stash is the symbol table hash, containing
      the package-scoped variables in the package where the subroutine was
      defined. For more information, see perlguts.
    <p class="Pp">This also has a special use with XS AUTOLOAD subs. See
        &quot;Autoloading with XSUBs&quot; in perlguts.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        HV*     CvSTASH(CV* cv)
    </pre>
  </dd>
  <dt>get_cv</dt>
  <dd>Uses <span class="Li">&quot;strlen&quot;</span> to get the length of
      <span class="Li">&quot;name&quot;</span>, then calls
      <span class="Li">&quot;get_cvn_flags&quot;</span>.
    <p class="Pp">NOTE: the perl_ form of this function is deprecated.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        CV*     get_cv(const char* name, I32 flags)
    </pre>
  </dd>
  <dt>get_cvn_flags</dt>
  <dd>Returns the CV of the specified Perl subroutine.
      <span class="Li">&quot;flags&quot;</span> are passed to
      <span class="Li">&quot;gv_fetchpvn_flags&quot;</span>. If
      <span class="Li">&quot;GV_ADD&quot;</span> is set and the Perl subroutine
      does not exist then it will be declared (which has the same effect as
      saying <span class="Li">&quot;sub name;&quot;</span>). If
      <span class="Li">&quot;GV_ADD&quot;</span> is not set and the subroutine
      does not exist then NULL is returned.
    <p class="Pp">NOTE: the perl_ form of this function is deprecated.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        CV*     get_cvn_flags(const char* name, STRLEN len,
                              I32 flags)
    </pre>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="Embedding_Functions"><a class="permalink" href="#Embedding_Functions">Embedding
  Functions</a></h1>
<dl class="Bl-tag">
  <dt>cv_clone</dt>
  <dd>Clone a CV, making a lexical closure. <i>proto</i> supplies the prototype
      of the function: its code, pad structure, and other attributes. The
      prototype is combined with a capture of outer lexicals to which the code
      refers, which are taken from the currently-executing instance of the
      immediately surrounding code.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        CV *    cv_clone(CV *proto)
    </pre>
  </dd>
  <dt>cv_undef</dt>
  <dd>Clear out all the active components of a CV. This can happen either by an
      explicit <span class="Li">&quot;undef &amp;foo&quot;</span>, or by the
      reference count going to zero. In the former case, we keep the CvOUTSIDE
      pointer, so that any anonymous children can still follow the full lexical
      scope chain.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    cv_undef(CV* cv)
    </pre>
  </dd>
  <dt>find_rundefsv</dt>
  <dd>Find and return the variable that is named <span class="Li">$_</span> in
      the lexical scope of the currently-executing function. This may be a
      lexical <span class="Li">$_</span>, or will otherwise be the global one.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV *    find_rundefsv()
    </pre>
  </dd>
  <dt>find_rundefsvoffset</dt>
  <dd>Find the position of the lexical <span class="Li">$_</span> in the pad of
      the currently-executing function. Returns the offset in the current pad,
      or <span class="Li">&quot;NOT_IN_PAD&quot;</span> if there is no lexical
      <span class="Li">$_</span> in scope (in which case the global one should
      be used instead). &quot;find_rundefsv&quot; is likely to be more
      convenient.
    <p class="Pp">NOTE: the perl_ form of this function is deprecated.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        PADOFFSET find_rundefsvoffset()
    </pre>
  </dd>
  <dt>load_module</dt>
  <dd>Loads the module whose name is pointed to by the string part of name. Note
      that the actual module name, not its filename, should be given. Eg,
      &quot;Foo::Bar&quot; instead of &quot;Foo/Bar.pm&quot;. flags can be any
      of PERL_LOADMOD_DENY, PERL_LOADMOD_NOIMPORT, or PERL_LOADMOD_IMPORT_OPS
      (or 0 for no flags). ver, if specified and not NULL, provides version
      semantics similar to <span class="Li">&quot;use Foo::Bar
      VERSION&quot;</span>. The optional trailing SV* arguments can be used to
      specify arguments to the module's <i>import()</i> method, similar to
      <span class="Li">&quot;use Foo::Bar VERSION LIST&quot;</span>. They must
      be terminated with a final NULL pointer. Note that this list can only be
      omitted when the PERL_LOADMOD_NOIMPORT flag has been used. Otherwise at
      least a single NULL pointer to designate the default import list is
      required.
    <p class="Pp">The reference count for each specified
        <span class="Li">&quot;SV*&quot;</span> parameter is decremented.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    load_module(U32 flags, SV* name, SV* ver, ...)
    </pre>
  </dd>
  <dt>nothreadhook</dt>
  <dd>Stub that provides thread hook for perl_destruct when there are no
      threads.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        int     nothreadhook()
    </pre>
  </dd>
  <dt>pad_add_anon</dt>
  <dd>Allocates a place in the currently-compiling pad (via
      &quot;pad_alloc&quot;) for an anonymous function that is lexically scoped
      inside the currently-compiling function. The function <i>func</i> is
      linked into the pad, and its <span class="Li">&quot;CvOUTSIDE&quot;</span>
      link to the outer scope is weakened to avoid a reference loop.
    <p class="Pp">One reference count is stolen, so you may need to do
        <span class="Li">&quot;SvREFCNT_inc(func)&quot;</span>.</p>
    <p class="Pp"><i>optype</i> should be an opcode indicating the type of
        operation that the pad entry is to support. This doesn't affect
        operational semantics, but is used for debugging.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        PADOFFSET pad_add_anon(CV *func, I32 optype)
    </pre>
  </dd>
  <dt>pad_add_name_pv</dt>
  <dd>Exactly like &quot;pad_add_name_pvn&quot;, but takes a nul-terminated
      string instead of a string/length pair.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        PADOFFSET pad_add_name_pv(const char *name, U32 flags,
                                  HV *typestash, HV *ourstash)
    </pre>
  </dd>
  <dt>pad_add_name_pvn</dt>
  <dd>Allocates a place in the currently-compiling pad for a named lexical
      variable. Stores the name and other metadata in the name part of the pad,
      and makes preparations to manage the variable's lexical scoping. Returns
      the offset of the allocated pad slot.
    <p class="Pp"><i>namepv</i>/<i>namelen</i> specify the variable's name,
        including leading sigil. If <i>typestash</i> is non-null, the name is
        for a typed lexical, and this identifies the type. If <i>ourstash</i> is
        non-null, it's a lexical reference to a package variable, and this
        identifies the package. The following flags can be OR'ed together:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    padadd_OUR          redundantly specifies if it's a package var
    padadd_STATE        variable will retain value persistently
    padadd_NO_DUP_CHECK skip check for lexical shadowing

        PADOFFSET pad_add_name_pvn(const char *namepv,
                                   STRLEN namelen, U32 flags,
                                   HV *typestash, HV *ourstash)
    </pre>
  </dd>
  <dt>pad_add_name_sv</dt>
  <dd>Exactly like &quot;pad_add_name_pvn&quot;, but takes the name string in
      the form of an SV instead of a string/length pair.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        PADOFFSET pad_add_name_sv(SV *name, U32 flags,
                                  HV *typestash, HV *ourstash)
    </pre>
  </dd>
  <dt>pad_alloc</dt>
  <dd>Allocates a place in the currently-compiling pad, returning the offset of
      the allocated pad slot. No name is initially attached to the pad slot.
      <i>tmptype</i> is a set of flags indicating the kind of pad entry
      required, which will be set in the value SV for the allocated pad entry:
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    SVs_PADMY    named lexical variable (&quot;my&quot;, &quot;our&quot;, &quot;state&quot;)
    SVs_PADTMP   unnamed temporary store
    </pre>
    <p class="Pp"><i>optype</i> should be an opcode indicating the type of
        operation that the pad entry is to support. This doesn't affect
        operational semantics, but is used for debugging.</p>
    <p class="Pp">NOTE: this function is experimental and may change or be
        removed without notice.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        PADOFFSET pad_alloc(I32 optype, U32 tmptype)
    </pre>
  </dd>
  <dt>pad_compname_type</dt>
  <dd>Looks up the type of the lexical variable at position <i>po</i> in the
      currently-compiling pad. If the variable is typed, the stash of the class
      to which it is typed is returned. If not,
      <span class="Li">&quot;NULL&quot;</span> is returned.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        HV *    pad_compname_type(PADOFFSET po)
    </pre>
  </dd>
  <dt>pad_findmy_pv</dt>
  <dd>Exactly like &quot;pad_findmy_pvn&quot;, but takes a nul-terminated string
      instead of a string/length pair.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        PADOFFSET pad_findmy_pv(const char *name, U32 flags)
    </pre>
  </dd>
  <dt>pad_findmy_pvn</dt>
  <dd>Given the name of a lexical variable, find its position in the
      currently-compiling pad. <i>namepv</i>/<i>namelen</i> specify the
      variable's name, including leading sigil. <i>flags</i> is reserved and
      must be zero. If it is not in the current pad but appears in the pad of
      any lexically enclosing scope, then a pseudo-entry for it is added in the
      current pad. Returns the offset in the current pad, or
      <span class="Li">&quot;NOT_IN_PAD&quot;</span> if no such lexical is in
      scope.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        PADOFFSET pad_findmy_pvn(const char *namepv,
                                 STRLEN namelen, U32 flags)
    </pre>
  </dd>
  <dt>pad_findmy_sv</dt>
  <dd>Exactly like &quot;pad_findmy_pvn&quot;, but takes the name string in the
      form of an SV instead of a string/length pair.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        PADOFFSET pad_findmy_sv(SV *name, U32 flags)
    </pre>
  </dd>
  <dt>pad_setsv</dt>
  <dd>Set the value at offset <i>po</i> in the current (compiling or executing)
      pad. Use the macro <i>PAD_SETSV()</i> rather than calling this function
      directly.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    pad_setsv(PADOFFSET po, SV *sv)
    </pre>
  </dd>
  <dt>pad_sv</dt>
  <dd>Get the value at offset <i>po</i> in the current (compiling or executing)
      pad. Use macro PAD_SV instead of calling this function directly.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV *    pad_sv(PADOFFSET po)
    </pre>
  </dd>
  <dt>pad_tidy</dt>
  <dd>Tidy up a pad at the end of compilation of the code to which it belongs.
      Jobs performed here are: remove most stuff from the pads of anonsub
      prototypes; give it a <span class="Li">@_</span>; mark temporaries as
      such. <i>type</i> indicates the kind of subroutine:
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    padtidy_SUB        ordinary subroutine
    padtidy_SUBCLONE   prototype for lexical closure
    padtidy_FORMAT     format
    </pre>
    <p class="Pp">NOTE: this function is experimental and may change or be
        removed without notice.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    pad_tidy(padtidy_type type)
    </pre>
  </dd>
  <dt>perl_alloc</dt>
  <dd>Allocates a new Perl interpreter. See perlembed.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        PerlInterpreter* perl_alloc()
    </pre>
  </dd>
  <dt>perl_construct</dt>
  <dd>Initializes a new Perl interpreter. See perlembed.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    perl_construct(PerlInterpreter *my_perl)
    </pre>
  </dd>
  <dt>perl_destruct</dt>
  <dd>Shuts down a Perl interpreter. See perlembed.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        int     perl_destruct(PerlInterpreter *my_perl)
    </pre>
  </dd>
  <dt>perl_free</dt>
  <dd>Releases a Perl interpreter. See perlembed.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    perl_free(PerlInterpreter *my_perl)
    </pre>
  </dd>
  <dt>perl_parse</dt>
  <dd>Tells a Perl interpreter to parse a Perl script. See perlembed.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        int     perl_parse(PerlInterpreter *my_perl,
                           XSINIT_t xsinit, int argc,
                           char** argv, char** env)
    </pre>
  </dd>
  <dt>perl_run</dt>
  <dd>Tells a Perl interpreter to run. See perlembed.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        int     perl_run(PerlInterpreter *my_perl)
    </pre>
  </dd>
  <dt>require_pv</dt>
  <dd>Tells Perl to <span class="Li">&quot;require&quot;</span> the file named
      by the string argument. It is analogous to the Perl code
      <span class="Li">&quot;eval &quot;require '$file'&quot;&quot;</span>. It's
      even implemented that way; consider using load_module instead.
    <p class="Pp">NOTE: the perl_ form of this function is deprecated.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    require_pv(const char* pv)
    </pre>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="Functions_in_file_dump.c"><a class="permalink" href="#Functions_in_file_dump.c">Functions
  in file dump.c</a></h1>
<dl class="Bl-tag">
  <dt>pv_display</dt>
  <dd>Similar to
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  pv_escape(dsv,pv,cur,pvlim,PERL_PV_ESCAPE_QUOTE);
    </pre>
    <p class="Pp">except that an additional &quot;\0&quot; will be appended to
        the string when len &gt; cur and pv[cur] is &quot;\0&quot;.</p>
    <p class="Pp">Note that the final string may be up to 7 chars longer than
        pvlim.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        char*   pv_display(SV *dsv, const char *pv, STRLEN cur,
                           STRLEN len, STRLEN pvlim)
    </pre>
  </dd>
  <dt>pv_escape</dt>
  <dd>Escapes at most the first &quot;count&quot; chars of pv and puts the
      results into dsv such that the size of the escaped string will not exceed
      &quot;max&quot; chars and will not contain any incomplete escape
      sequences.
    <p class="Pp">If flags contains PERL_PV_ESCAPE_QUOTE then any double quotes
        in the string will also be escaped.</p>
    <p class="Pp">Normally the SV will be cleared before the escaped string is
        prepared, but when PERL_PV_ESCAPE_NOCLEAR is set this will not
      occur.</p>
    <p class="Pp">If PERL_PV_ESCAPE_UNI is set then the input string is treated
        as Unicode, if PERL_PV_ESCAPE_UNI_DETECT is set then the input string is
        scanned using <span class="Li">&quot;is_utf8_string()&quot;</span> to
        determine if it is Unicode.</p>
    <p class="Pp">If PERL_PV_ESCAPE_ALL is set then all input chars will be
        output using <span class="Li">&quot;\x01F1&quot;</span> style escapes,
        otherwise if PERL_PV_ESCAPE_NONASCII is set, only chars above 127 will
        be escaped using this style; otherwise, only chars above 255 will be so
        escaped; other non printable chars will use octal or common escaped
        patterns like <span class="Li">&quot;\n&quot;</span>. Otherwise, if
        PERL_PV_ESCAPE_NOBACKSLASH then all chars below 255 will be treated as
        printable and will be output as literals.</p>
    <p class="Pp">If PERL_PV_ESCAPE_FIRSTCHAR is set then only the first char of
        the string will be escaped, regardless of max. If the output is to be in
        hex, then it will be returned as a plain hex sequence. Thus the output
        will either be a single char, an octal escape sequence, a special escape
        like <span class="Li">&quot;\n&quot;</span> or a hex value.</p>
    <p class="Pp">If PERL_PV_ESCAPE_RE is set then the escape char used will be
        a '%' and not a '\\'. This is because regexes very often contain
        backslashed sequences, whereas '%' is not a particularly common
        character in patterns.</p>
    <p class="Pp">Returns a pointer to the escaped text as held by dsv.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        char*   pv_escape(SV *dsv, char const * const str,
                          const STRLEN count, const STRLEN max,
                          STRLEN * const escaped,
                          const U32 flags)
    </pre>
  </dd>
  <dt>pv_pretty</dt>
  <dd>Converts a string into something presentable, handling escaping via
      <i>pv_escape()</i> and supporting quoting and ellipses.
    <p class="Pp">If the PERL_PV_PRETTY_QUOTE flag is set then the result will
        be double quoted with any double quotes in the string escaped. Otherwise
        if the PERL_PV_PRETTY_LTGT flag is set then the result be wrapped in
        angle brackets.</p>
    <p class="Pp">If the PERL_PV_PRETTY_ELLIPSES flag is set and not all
        characters in string were output then an ellipsis
        <span class="Li">&quot;...&quot;</span> will be appended to the string.
        Note that this happens AFTER it has been quoted.</p>
    <p class="Pp">If start_color is non-null then it will be inserted after the
        opening quote (if there is one) but before the escaped text. If
        end_color is non-null then it will be inserted after the escaped text
        but before any quotes or ellipses.</p>
    <p class="Pp">Returns a pointer to the prettified text as held by dsv.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        char*   pv_pretty(SV *dsv, char const * const str,
                          const STRLEN count, const STRLEN max,
                          char const * const start_color,
                          char const * const end_color,
                          const U32 flags)
    </pre>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="Functions_in_file_mathoms.c"><a class="permalink" href="#Functions_in_file_mathoms.c">Functions
  in file mathoms.c</a></h1>
<dl class="Bl-tag">
  <dt>custom_op_desc</dt>
  <dd>Return the description of a given custom op. This was once used by the
      OP_DESC macro, but is no longer: it has only been kept for compatibility,
      and should not be used.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        const char * custom_op_desc(const OP *o)
    </pre>
  </dd>
  <dt>custom_op_name</dt>
  <dd>Return the name for a given custom op. This was once used by the OP_NAME
      macro, but is no longer: it has only been kept for compatibility, and
      should not be used.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        const char * custom_op_name(const OP *o)
    </pre>
  </dd>
  <dt>gv_fetchmethod</dt>
  <dd>See &quot;gv_fetchmethod_autoload&quot;.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        GV*     gv_fetchmethod(HV* stash, const char* name)
    </pre>
  </dd>
  <dt>pack_cat</dt>
  <dd>The engine implementing <i>pack()</i> Perl function. Note: parameters
      next_in_list and flags are not used. This call should not be used; use
      packlist instead.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    pack_cat(SV *cat, const char *pat,
                         const char *patend, SV **beglist,
                         SV **endlist, SV ***next_in_list,
                         U32 flags)
    </pre>
  </dd>
  <dt>sv_2pvbyte_nolen</dt>
  <dd>Return a pointer to the byte-encoded representation of the SV. May cause
      the SV to be downgraded from UTF-8 as a side-effect.
    <p class="Pp">Usually accessed via the
        <span class="Li">&quot;SvPVbyte_nolen&quot;</span> macro.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        char*   sv_2pvbyte_nolen(SV* sv)
    </pre>
  </dd>
  <dt>sv_2pvutf8_nolen</dt>
  <dd>Return a pointer to the UTF-8-encoded representation of the SV. May cause
      the SV to be upgraded to UTF-8 as a side-effect.
    <p class="Pp">Usually accessed via the
        <span class="Li">&quot;SvPVutf8_nolen&quot;</span> macro.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        char*   sv_2pvutf8_nolen(SV* sv)
    </pre>
  </dd>
  <dt>sv_2pv_nolen</dt>
  <dd>Like <span class="Li">&quot;sv_2pv()&quot;</span>, but doesn't return the
      length too. You should usually use the macro wrapper
      <span class="Li">&quot;SvPV_nolen(sv)&quot;</span> instead.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        char*   sv_2pv_nolen(SV* sv)
    </pre>
  </dd>
  <dt>sv_catpvn_mg</dt>
  <dd>Like <span class="Li">&quot;sv_catpvn&quot;</span>, but also handles 'set'
      magic.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_catpvn_mg(SV *sv, const char *ptr,
                             STRLEN len)
    </pre>
  </dd>
  <dt>sv_catsv_mg</dt>
  <dd>Like <span class="Li">&quot;sv_catsv&quot;</span>, but also handles 'set'
      magic.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_catsv_mg(SV *dsv, SV *ssv)
    </pre>
  </dd>
  <dt>sv_force_normal</dt>
  <dd>Undo various types of fakery on an SV: if the PV is a shared string, make
      a private copy; if we're a ref, stop refing; if we're a glob, downgrade to
      an xpvmg. See also
      <span class="Li">&quot;sv_force_normal_flags&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_force_normal(SV *sv)
    </pre>
  </dd>
  <dt>sv_iv</dt>
  <dd>A private implementation of the <span class="Li">&quot;SvIVx&quot;</span>
      macro for compilers which can't cope with complex macro expressions.
      Always use the macro instead.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        IV      sv_iv(SV* sv)
    </pre>
  </dd>
  <dt>sv_nolocking</dt>
  <dd>Dummy routine which &quot;locks&quot; an SV when there is no locking
      module present. Exists to avoid test for a NULL function pointer and
      because it could potentially warn under some level of strict-ness.
    <p class="Pp">&quot;Superseded&quot; by <i>sv_nosharing()</i>.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_nolocking(SV *sv)
    </pre>
  </dd>
  <dt>sv_nounlocking</dt>
  <dd>Dummy routine which &quot;unlocks&quot; an SV when there is no locking
      module present. Exists to avoid test for a NULL function pointer and
      because it could potentially warn under some level of strict-ness.
    <p class="Pp">&quot;Superseded&quot; by <i>sv_nosharing()</i>.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_nounlocking(SV *sv)
    </pre>
  </dd>
  <dt>sv_nv</dt>
  <dd>A private implementation of the <span class="Li">&quot;SvNVx&quot;</span>
      macro for compilers which can't cope with complex macro expressions.
      Always use the macro instead.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        NV      sv_nv(SV* sv)
    </pre>
  </dd>
  <dt>sv_pv</dt>
  <dd>Use the <span class="Li">&quot;SvPV_nolen&quot;</span> macro instead
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        char*   sv_pv(SV *sv)
    </pre>
  </dd>
  <dt>sv_pvbyte</dt>
  <dd>Use <span class="Li">&quot;SvPVbyte_nolen&quot;</span> instead.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        char*   sv_pvbyte(SV *sv)
    </pre>
  </dd>
  <dt>sv_pvbyten</dt>
  <dd>A private implementation of the
      <span class="Li">&quot;SvPVbyte&quot;</span> macro for compilers which
      can't cope with complex macro expressions. Always use the macro instead.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        char*   sv_pvbyten(SV *sv, STRLEN *lp)
    </pre>
  </dd>
  <dt>sv_pvn</dt>
  <dd>A private implementation of the <span class="Li">&quot;SvPV&quot;</span>
      macro for compilers which can't cope with complex macro expressions.
      Always use the macro instead.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        char*   sv_pvn(SV *sv, STRLEN *lp)
    </pre>
  </dd>
  <dt>sv_pvutf8</dt>
  <dd>Use the <span class="Li">&quot;SvPVutf8_nolen&quot;</span> macro instead
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        char*   sv_pvutf8(SV *sv)
    </pre>
  </dd>
  <dt>sv_pvutf8n</dt>
  <dd>A private implementation of the
      <span class="Li">&quot;SvPVutf8&quot;</span> macro for compilers which
      can't cope with complex macro expressions. Always use the macro instead.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        char*   sv_pvutf8n(SV *sv, STRLEN *lp)
    </pre>
  </dd>
  <dt>sv_taint</dt>
  <dd>Taint an SV. Use <span class="Li">&quot;SvTAINTED_on&quot;</span> instead.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_taint(SV* sv)
    </pre>
  </dd>
  <dt>sv_unref</dt>
  <dd>Unsets the RV status of the SV, and decrements the reference count of
      whatever was being referenced by the RV. This can almost be thought of as
      a reversal of <span class="Li">&quot;newSVrv&quot;</span>. This is
      <span class="Li">&quot;sv_unref_flags&quot;</span> with the
      <span class="Li">&quot;flag&quot;</span> being zero. See
      <span class="Li">&quot;SvROK_off&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_unref(SV* sv)
    </pre>
  </dd>
  <dt>sv_usepvn</dt>
  <dd>Tells an SV to use <span class="Li">&quot;ptr&quot;</span> to find its
      string value. Implemented by calling
      <span class="Li">&quot;sv_usepvn_flags&quot;</span> with
      <span class="Li">&quot;flags&quot;</span> of 0, hence does not handle
      'set' magic. See <span class="Li">&quot;sv_usepvn_flags&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_usepvn(SV* sv, char* ptr, STRLEN len)
    </pre>
  </dd>
  <dt>sv_usepvn_mg</dt>
  <dd>Like <span class="Li">&quot;sv_usepvn&quot;</span>, but also handles 'set'
      magic.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_usepvn_mg(SV *sv, char *ptr, STRLEN len)
    </pre>
  </dd>
  <dt>sv_uv</dt>
  <dd>A private implementation of the <span class="Li">&quot;SvUVx&quot;</span>
      macro for compilers which can't cope with complex macro expressions.
      Always use the macro instead.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        UV      sv_uv(SV* sv)
    </pre>
  </dd>
  <dt>unpack_str</dt>
  <dd>The engine implementing <i>unpack()</i> Perl function. Note: parameters
      strbeg, new_s and ocnt are not used. This call should not be used, use
      unpackstring instead.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        I32     unpack_str(const char *pat, const char *patend,
                           const char *s, const char *strbeg,
                           const char *strend, char **new_s,
                           I32 ocnt, U32 flags)
    </pre>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="Functions_in_file_op.c"><a class="permalink" href="#Functions_in_file_op.c">Functions
  in file op.c</a></h1>
<dl class="Bl-tag">
  <dt>alloccopstash</dt>
  <dd>Available only under threaded builds, this function allocates an entry in
      <span class="Li">&quot;PL_stashpad&quot;</span> for the stash passed to
      it.
    <p class="Pp">NOTE: this function is experimental and may change or be
        removed without notice.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        PADOFFSET alloccopstash(HV *hv)
    </pre>
  </dd>
  <dt>op_contextualize</dt>
  <dd>Applies a syntactic context to an op tree representing an expression.
      <i>o</i> is the op tree, and <i>context</i> must be
      <span class="Li">&quot;G_SCALAR&quot;</span>,
      <span class="Li">&quot;G_ARRAY&quot;</span>, or
      <span class="Li">&quot;G_VOID&quot;</span> to specify the context to
      apply. The modified op tree is returned.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        OP *    op_contextualize(OP *o, I32 context)
    </pre>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="Functions_in_file_perl.h"><a class="permalink" href="#Functions_in_file_perl.h">Functions
  in file perl.h</a></h1>
<dl class="Bl-tag">
  <dt>PERL_SYS_INIT </dt>
  <dd>Provides system-specific tune up of the C runtime environment necessary to
      run Perl interpreters. This should be called only once, before creating
      any Perl interpreters.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    PERL_SYS_INIT(int *argc, char*** argv)
    </pre>
  </dd>
  <dt>PERL_SYS_INIT3 </dt>
  <dd>Provides system-specific tune up of the C runtime environment necessary to
      run Perl interpreters. This should be called only once, before creating
      any Perl interpreters.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    PERL_SYS_INIT3(int *argc, char*** argv,
                               char*** env)
    </pre>
  </dd>
  <dt>PERL_SYS_TERM </dt>
  <dd>Provides system-specific clean up of the C runtime environment after
      running Perl interpreters. This should be called only once, after freeing
      any remaining Perl interpreters.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    PERL_SYS_TERM()
    </pre>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="Functions_in_file_pp_ctl.c"><a class="permalink" href="#Functions_in_file_pp_ctl.c">Functions
  in file pp_ctl.c</a></h1>
<dl class="Bl-tag">
  <dt>caller_cx</dt>
  <dd>The XSUB-writer's equivalent of <i>caller()</i>. The returned
      <span class="Li">&quot;PERL_CONTEXT&quot;</span> structure can be
      interrogated to find all the information returned to Perl by
      <span class="Li">&quot;caller&quot;</span>. Note that XSUBs don't get a
      stack frame, so <span class="Li">&quot;caller_cx(0, NULL)&quot;</span>
      will return information for the immediately-surrounding Perl code.
    <p class="Pp">This function skips over the automatic calls to
        <span class="Li">&amp;DB::sub</span> made on the behalf of the debugger.
        If the stack frame requested was a sub called by
        <span class="Li">&quot;DB::sub&quot;</span>, the return value will be
        the frame for the call to <span class="Li">&quot;DB::sub&quot;</span>,
        since that has the correct line number/etc. for the call site. If
        <i>dbcxp</i> is non-<span class="Li">&quot;NULL&quot;</span>, it will be
        set to a pointer to the frame for the sub call itself.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        const PERL_CONTEXT * caller_cx(
                                 I32 level,
                                 const PERL_CONTEXT **dbcxp
                             )
    </pre>
  </dd>
  <dt>find_runcv</dt>
  <dd>Locate the CV corresponding to the currently executing sub or eval. If
      db_seqp is non_null, skip CVs that are in the DB package and populate
      *db_seqp with the cop sequence number at the point that the DB:: code was
      entered. (allows debuggers to eval in the scope of the breakpoint rather
      than in the scope of the debugger itself).
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        CV*     find_runcv(U32 *db_seqp)
    </pre>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="Functions_in_file_pp_pack.c"><a class="permalink" href="#Functions_in_file_pp_pack.c">Functions
  in file pp_pack.c</a></h1>
<dl class="Bl-tag">
  <dt>packlist</dt>
  <dd>The engine implementing <i>pack()</i> Perl function.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    packlist(SV *cat, const char *pat,
                         const char *patend, SV **beglist,
                         SV **endlist)
    </pre>
  </dd>
  <dt>unpackstring</dt>
  <dd>The engine implementing the <i>unpack()</i> Perl function.
    <p class="Pp">Using the template pat..patend, this function unpacks the
        string s..strend into a number of mortal SVs, which it pushes onto the
        perl argument (@_) stack (so you will need to issue a
        <span class="Li">&quot;PUTBACK&quot;</span> before and
        <span class="Li">&quot;SPAGAIN&quot;</span> after the call to this
        function). It returns the number of pushed elements.</p>
    <p class="Pp">The strend and patend pointers should point to the byte
        following the last character of each string.</p>
    <p class="Pp">Although this function returns its values on the perl argument
        stack, it doesn't take any parameters from that stack (and thus in
        particular there's no need to do a PUSHMARK before calling it, unlike
        &quot;call_pv&quot; for example).</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        I32     unpackstring(const char *pat,
                             const char *patend, const char *s,
                             const char *strend, U32 flags)
    </pre>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="Functions_in_file_pp_sys.c"><a class="permalink" href="#Functions_in_file_pp_sys.c">Functions
  in file pp_sys.c</a></h1>
<dl class="Bl-tag">
  <dt>setdefout</dt>
  <dd>Sets PL_defoutgv, the default file handle for output, to the passed in
      typeglob. As PL_defoutgv &quot;owns&quot; a reference on its typeglob, the
      reference count of the passed in typeglob is increased by one, and the
      reference count of the typeglob that PL_defoutgv points to is decreased by
      one.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    setdefout(GV* gv)
    </pre>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="Functions_in_file_utf8.h"><a class="permalink" href="#Functions_in_file_utf8.h">Functions
  in file utf8.h</a></h1>
<dl class="Bl-tag">
  <dt>ibcmp_utf8</dt>
  <dd>This is a synonym for (! <i>foldEQ_utf8()</i>)
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        I32     ibcmp_utf8(const char *s1, char **pe1, UV l1,
                           bool u1, const char *s2, char **pe2,
                           UV l2, bool u2)
    </pre>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="Functions_in_file_util.h"><a class="permalink" href="#Functions_in_file_util.h">Functions
  in file util.h</a></h1>
<dl class="Bl-tag">
  <dt>ibcmp</dt>
  <dd>This is a synonym for (! <i>foldEQ()</i>)
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        I32     ibcmp(const char* a, const char* b, I32 len)
    </pre>
  </dd>
  <dt>ibcmp_locale</dt>
  <dd>This is a synonym for (! <i>foldEQ_locale()</i>)
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        I32     ibcmp_locale(const char* a, const char* b,
                             I32 len)
    </pre>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="Global_Variables"><a class="permalink" href="#Global_Variables">Global
  Variables</a></h1>
<dl class="Bl-tag">
  <dt>PL_check</dt>
  <dd>Array, indexed by opcode, of functions that will be called for the
      &quot;check&quot; phase of optree building during compilation of Perl
      code. For most (but not all) types of op, once the op has been initially
      built and populated with child ops it will be filtered through the check
      function referenced by the appropriate element of this array. The new op
      is passed in as the sole argument to the check function, and the check
      function returns the completed op. The check function may (as the name
      suggests) check the op for validity and signal errors. It may also
      initialise or modify parts of the ops, or perform more radical surgery
      such as adding or removing child ops, or even throw the op away and return
      a different op in its place.
    <p class="Pp">This array of function pointers is a convenient place to hook
        into the compilation process. An XS module can put its own custom check
        function in place of any of the standard ones, to influence the
        compilation of a particular type of op. However, a custom check function
        must never fully replace a standard check function (or even a custom
        check function from another module). A module modifying checking must
        instead <b>wrap</b> the preexisting check function. A custom check
        function must be selective about when to apply its custom behaviour. In
        the usual case where it decides not to do anything special with an op,
        it must chain the preexisting op function. Check functions are thus
        linked in a chain, with the core's base checker at the end.</p>
    <p class="Pp">For thread safety, modules should not write directly to this
        array. Instead, use the function &quot;wrap_op_checker&quot;.</p>
  </dd>
  <dt>PL_keyword_plugin</dt>
  <dd>Function pointer, pointing at a function used to handle extended keywords.
      The function should be declared as
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        int keyword_plugin_function(pTHX_
                char *keyword_ptr, STRLEN keyword_len,
                OP **op_ptr)
    </pre>
    <p class="Pp">The function is called from the tokeniser, whenever a possible
        keyword is seen. <span class="Li">&quot;keyword_ptr&quot;</span> points
        at the word in the parser's input buffer, and
        <span class="Li">&quot;keyword_len&quot;</span> gives its length; it is
        not null-terminated. The function is expected to examine the word, and
        possibly other state such as %^H, to decide whether it wants to handle
        it as an extended keyword. If it does not, the function should return
        <span class="Li">&quot;KEYWORD_PLUGIN_DECLINE&quot;</span>, and the
        normal parser process will continue.</p>
    <p class="Pp">If the function wants to handle the keyword, it first must
        parse anything following the keyword that is part of the syntax
        introduced by the keyword. See &quot;Lexer interface&quot; for
      details.</p>
    <p class="Pp">When a keyword is being handled, the plugin function must
        build a tree of <span class="Li">&quot;OP&quot;</span> structures,
        representing the code that was parsed. The root of the tree must be
        stored in <span class="Li">*op_ptr</span>. The function then returns a
        constant indicating the syntactic role of the construct that it has
        parsed: <span class="Li">&quot;KEYWORD_PLUGIN_STMT&quot;</span> if it is
        a complete statement, or
        <span class="Li">&quot;KEYWORD_PLUGIN_EXPR&quot;</span> if it is an
        expression. Note that a statement construct cannot be used inside an
        expression (except via <span class="Li">&quot;do BLOCK&quot;</span> and
        similar), and an expression is not a complete statement (it requires at
        least a terminating semicolon).</p>
    <p class="Pp">When a keyword is handled, the plugin function may also have
        (compile-time) side effects. It may modify
        <span class="Li">&quot;%^H&quot;</span>, define functions, and so on.
        Typically, if side effects are the main purpose of a handler, it does
        not wish to generate any ops to be included in the normal compilation.
        In this case it is still required to supply an op tree, but it suffices
        to generate a single null op.</p>
    <p class="Pp">That's how the <span class="Li">*PL_keyword_plugin</span>
        function needs to behave overall. Conventionally, however, one does not
        completely replace the existing handler function. Instead, take a copy
        of <span class="Li">&quot;PL_keyword_plugin&quot;</span> before
        assigning your own function pointer to it. Your handler function should
        look for keywords that it is interested in and handle those. Where it is
        not interested, it should call the saved plugin function, passing on the
        arguments it received. Thus
        <span class="Li">&quot;PL_keyword_plugin&quot;</span> actually points at
        a chain of handler functions, all of which have an opportunity to handle
        keywords, and only the last function in the chain (built into the Perl
        core) will normally return
        <span class="Li">&quot;KEYWORD_PLUGIN_DECLINE&quot;</span>.</p>
    <p class="Pp">NOTE: this function is experimental and may change or be
        removed without notice.</p>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="GV_Functions"><a class="permalink" href="#GV_Functions">GV
  Functions</a></h1>
<dl class="Bl-tag">
  <dt>GvAV</dt>
  <dd>Return the AV from the GV.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        AV*     GvAV(GV* gv)
    </pre>
  </dd>
  <dt>GvCV</dt>
  <dd>Return the CV from the GV.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        CV*     GvCV(GV* gv)
    </pre>
  </dd>
  <dt>GvHV</dt>
  <dd>Return the HV from the GV.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        HV*     GvHV(GV* gv)
    </pre>
  </dd>
  <dt>GvSV</dt>
  <dd>Return the SV from the GV.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV*     GvSV(GV* gv)
    </pre>
  </dd>
  <dt>gv_const_sv</dt>
  <dd>If <span class="Li">&quot;gv&quot;</span> is a typeglob whose subroutine
      entry is a constant sub eligible for inlining, or
      <span class="Li">&quot;gv&quot;</span> is a placeholder reference that
      would be promoted to such a typeglob, then returns the value returned by
      the sub. Otherwise, returns NULL.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV*     gv_const_sv(GV* gv)
    </pre>
  </dd>
  <dt>gv_fetchmeth</dt>
  <dd>Like &quot;gv_fetchmeth_pvn&quot;, but lacks a flags parameter.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        GV*     gv_fetchmeth(HV* stash, const char* name,
                             STRLEN len, I32 level)
    </pre>
  </dd>
  <dt>gv_fetchmethod_autoload</dt>
  <dd>Returns the glob which contains the subroutine to call to invoke the
      method on the <span class="Li">&quot;stash&quot;</span>. In fact in the
      presence of autoloading this may be the glob for &quot;AUTOLOAD&quot;. In
      this case the corresponding variable <span class="Li">$AUTOLOAD</span> is
      already setup.
    <p class="Pp">The third parameter of
        <span class="Li">&quot;gv_fetchmethod_autoload&quot;</span> determines
        whether AUTOLOAD lookup is performed if the given method is not present:
        non-zero means yes, look for AUTOLOAD; zero means no, don't look for
        AUTOLOAD. Calling <span class="Li">&quot;gv_fetchmethod&quot;</span> is
        equivalent to calling
        <span class="Li">&quot;gv_fetchmethod_autoload&quot;</span> with a
        non-zero <span class="Li">&quot;autoload&quot;</span> parameter.</p>
    <p class="Pp">These functions grant
        <span class="Li">&quot;SUPER&quot;</span> token as a prefix of the
        method name. Note that if you want to keep the returned glob for a long
        time, you need to check for it being &quot;AUTOLOAD&quot;, since at the
        later time the call may load a different subroutine due to
        <span class="Li">$AUTOLOAD</span> changing its value. Use the glob
        created via a side effect to do this.</p>
    <p class="Pp">These functions have the same side-effects and as
        <span class="Li">&quot;gv_fetchmeth&quot;</span> with
        <span class="Li">&quot;level==0&quot;</span>.
        <span class="Li">&quot;name&quot;</span> should be writable if contains
        <span class="Li">':'</span> or <span class="Li">'</span>
        <span class="Li">''</span>. The warning against passing the GV returned
        by <span class="Li">&quot;gv_fetchmeth&quot;</span> to
        <span class="Li">&quot;call_sv&quot;</span> apply equally to these
        functions.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        GV*     gv_fetchmethod_autoload(HV* stash,
                                        const char* name,
                                        I32 autoload)
    </pre>
  </dd>
  <dt>gv_fetchmeth_autoload</dt>
  <dd>This is the old form of &quot;gv_fetchmeth_pvn_autoload&quot;, which has
      no flags parameter.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        GV*     gv_fetchmeth_autoload(HV* stash,
                                      const char* name,
                                      STRLEN len, I32 level)
    </pre>
  </dd>
  <dt>gv_fetchmeth_pv</dt>
  <dd>Exactly like &quot;gv_fetchmeth_pvn&quot;, but takes a nul-terminated
      string instead of a string/length pair.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        GV*     gv_fetchmeth_pv(HV* stash, const char* name,
                                I32 level, U32 flags)
    </pre>
  </dd>
  <dt>gv_fetchmeth_pvn</dt>
  <dd>Returns the glob with the given <span class="Li">&quot;name&quot;</span>
      and a defined subroutine or <span class="Li">&quot;NULL&quot;</span>. The
      glob lives in the given <span class="Li">&quot;stash&quot;</span>, or in
      the stashes accessible via <span class="Li">@ISA</span> and UNIVERSAL::.
    <p class="Pp">The argument <span class="Li">&quot;level&quot;</span> should
        be either 0 or -1. If <span class="Li">&quot;level==0&quot;</span>, as a
        side-effect creates a glob with the given
        <span class="Li">&quot;name&quot;</span> in the given
        <span class="Li">&quot;stash&quot;</span> which in the case of success
        contains an alias for the subroutine, and sets up caching info for this
        glob.</p>
    <p class="Pp">The only significant values for
        <span class="Li">&quot;flags&quot;</span> are GV_SUPER and SVf_UTF8.</p>
    <p class="Pp">GV_SUPER indicates that we want to look up the method in the
        superclasses of the <span class="Li">&quot;stash&quot;</span>.</p>
    <p class="Pp">The GV returned from
        <span class="Li">&quot;gv_fetchmeth&quot;</span> may be a method cache
        entry, which is not visible to Perl code. So when calling
        <span class="Li">&quot;call_sv&quot;</span>, you should not use the GV
        directly; instead, you should use the method's CV, which can be obtained
        from the GV with the <span class="Li">&quot;GvCV&quot;</span> macro.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        GV*     gv_fetchmeth_pvn(HV* stash, const char* name,
                                 STRLEN len, I32 level,
                                 U32 flags)
    </pre>
  </dd>
  <dt>gv_fetchmeth_pvn_autoload</dt>
  <dd>Same as <i>gv_fetchmeth_pvn()</i>, but looks for autoloaded subroutines
      too. Returns a glob for the subroutine.
    <p class="Pp">For an autoloaded subroutine without a GV, will create a GV
        even if <span class="Li">&quot;level &lt; 0&quot;</span>. For an
        autoloaded subroutine without a stub, <i>GvCV()</i> of the result may be
        zero.</p>
    <p class="Pp">Currently, the only significant value for
        <span class="Li">&quot;flags&quot;</span> is SVf_UTF8.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        GV*     gv_fetchmeth_pvn_autoload(HV* stash,
                                          const char* name,
                                          STRLEN len, I32 level,
                                          U32 flags)
    </pre>
  </dd>
  <dt>gv_fetchmeth_pv_autoload</dt>
  <dd>Exactly like &quot;gv_fetchmeth_pvn_autoload&quot;, but takes a
      nul-terminated string instead of a string/length pair.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        GV*     gv_fetchmeth_pv_autoload(HV* stash,
                                         const char* name,
                                         I32 level, U32 flags)
    </pre>
  </dd>
  <dt>gv_fetchmeth_sv</dt>
  <dd>Exactly like &quot;gv_fetchmeth_pvn&quot;, but takes the name string in
      the form of an SV instead of a string/length pair.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        GV*     gv_fetchmeth_sv(HV* stash, SV* namesv,
                                I32 level, U32 flags)
    </pre>
  </dd>
  <dt>gv_fetchmeth_sv_autoload</dt>
  <dd>Exactly like &quot;gv_fetchmeth_pvn_autoload&quot;, but takes the name
      string in the form of an SV instead of a string/length pair.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        GV*     gv_fetchmeth_sv_autoload(HV* stash, SV* namesv,
                                         I32 level, U32 flags)
    </pre>
  </dd>
  <dt>gv_init</dt>
  <dd>The old form of <i>gv_init_pvn()</i>. It does not work with UTF8 strings,
      as it has no flags parameter. If the
      <span class="Li">&quot;multi&quot;</span> parameter is set, the
      GV_ADDMULTI flag will be passed to <i>gv_init_pvn()</i>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    gv_init(GV* gv, HV* stash, const char* name,
                        STRLEN len, int multi)
    </pre>
  </dd>
  <dt>gv_init_pv</dt>
  <dd>Same as <i>gv_init_pvn()</i>, but takes a nul-terminated string for the
      name instead of separate char * and length parameters.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    gv_init_pv(GV* gv, HV* stash, const char* name,
                           U32 flags)
    </pre>
  </dd>
  <dt>gv_init_pvn</dt>
  <dd>Converts a scalar into a typeglob. This is an incoercible typeglob;
      assigning a reference to it will assign to one of its slots, instead of
      overwriting it as happens with typeglobs created by SvSetSV. Converting
      any scalar that is <i>SvOK()</i> may produce unpredictable results and is
      reserved for perl's internal use.
    <p class="Pp"><span class="Li">&quot;gv&quot;</span> is the scalar to be
        converted.</p>
    <p class="Pp"><span class="Li">&quot;stash&quot;</span> is the parent
        stash/package, if any.</p>
    <p class="Pp"><span class="Li">&quot;name&quot;</span> and
        <span class="Li">&quot;len&quot;</span> give the name. The name must be
        unqualified; that is, it must not include the package name. If
        <span class="Li">&quot;gv&quot;</span> is a stash element, it is the
        caller's responsibility to ensure that the name passed to this function
        matches the name of the element. If it does not match, perl's internal
        bookkeeping will get out of sync.</p>
    <p class="Pp"><span class="Li">&quot;flags&quot;</span> can be set to
        SVf_UTF8 if <span class="Li">&quot;name&quot;</span> is a UTF8 string,
        or the return value of SvUTF8(sv). It can also take the GV_ADDMULTI
        flag, which means to pretend that the GV has been seen before (i.e.,
        suppress &quot;Used once&quot; warnings).</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    gv_init_pvn(GV* gv, HV* stash, const char* name,
                            STRLEN len, U32 flags)
    </pre>
  </dd>
  <dt>gv_init_sv</dt>
  <dd>Same as <i>gv_init_pvn()</i>, but takes an SV * for the name instead of
      separate char * and length parameters.
      <span class="Li">&quot;flags&quot;</span> is currently unused.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    gv_init_sv(GV* gv, HV* stash, SV* namesv,
                           U32 flags)
    </pre>
  </dd>
  <dt>gv_stashpv</dt>
  <dd>Returns a pointer to the stash for a specified package. Uses
      <span class="Li">&quot;strlen&quot;</span> to determine the length of
      <span class="Li">&quot;name&quot;</span>, then calls
      <span class="Li">&quot;gv_stashpvn()&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        HV*     gv_stashpv(const char* name, I32 flags)
    </pre>
  </dd>
  <dt>gv_stashpvn</dt>
  <dd>Returns a pointer to the stash for a specified package. The
      <span class="Li">&quot;namelen&quot;</span> parameter indicates the length
      of the <span class="Li">&quot;name&quot;</span>, in bytes.
      <span class="Li">&quot;flags&quot;</span> is passed to
      <span class="Li">&quot;gv_fetchpvn_flags()&quot;</span>, so if set to
      <span class="Li">&quot;GV_ADD&quot;</span> then the package will be
      created if it does not already exist. If the package does not exist and
      <span class="Li">&quot;flags&quot;</span> is 0 (or any other setting that
      does not create packages) then NULL is returned.
    <p class="Pp">Flags may be one of:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    GV_ADD
    SVf_UTF8
    GV_NOADD_NOINIT
    GV_NOINIT
    GV_NOEXPAND
    GV_ADDMG
    </pre>
    <p class="Pp">The most important of which are probably GV_ADD and
      SVf_UTF8.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        HV*     gv_stashpvn(const char* name, U32 namelen,
                            I32 flags)
    </pre>
  </dd>
  <dt>gv_stashpvs</dt>
  <dd>Like <span class="Li">&quot;gv_stashpvn&quot;</span>, but takes a literal
      string instead of a string/length pair.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        HV*     gv_stashpvs(const char* name, I32 create)
    </pre>
  </dd>
  <dt>gv_stashsv</dt>
  <dd>Returns a pointer to the stash for a specified package. See
      <span class="Li">&quot;gv_stashpvn&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        HV*     gv_stashsv(SV* sv, I32 flags)
    </pre>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="Handy_Values"><a class="permalink" href="#Handy_Values">Handy
  Values</a></h1>
<dl class="Bl-tag">
  <dt>Nullav</dt>
  <dd>Null AV pointer.
    <p class="Pp">(deprecated - use <span class="Li">&quot;(AV
        *)NULL&quot;</span> instead)</p>
  </dd>
  <dt>Nullch</dt>
  <dd>Null character pointer. (No longer available when
      <span class="Li">&quot;PERL_CORE&quot;</span> is defined.)</dd>
  <dt>Nullcv</dt>
  <dd>Null CV pointer.
    <p class="Pp">(deprecated - use <span class="Li">&quot;(CV
        *)NULL&quot;</span> instead)</p>
  </dd>
  <dt>Nullhv</dt>
  <dd>Null HV pointer.
    <p class="Pp">(deprecated - use <span class="Li">&quot;(HV
        *)NULL&quot;</span> instead)</p>
  </dd>
  <dt>Nullsv</dt>
  <dd>Null SV pointer. (No longer available when
      <span class="Li">&quot;PERL_CORE&quot;</span> is defined.)</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="Hash_Manipulation_Functions"><a class="permalink" href="#Hash_Manipulation_Functions">Hash
  Manipulation Functions</a></h1>
<dl class="Bl-tag">
  <dt>cop_fetch_label</dt>
  <dd>Returns the label attached to a cop. The flags pointer may be set to
      <span class="Li">&quot;SVf_UTF8&quot;</span> or 0.
    <p class="Pp">NOTE: this function is experimental and may change or be
        removed without notice.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        const char * cop_fetch_label(COP *const cop,
                                     STRLEN *len, U32 *flags)
    </pre>
  </dd>
  <dt>cop_store_label</dt>
  <dd>Save a label into a <span class="Li">&quot;cop_hints_hash&quot;</span>.
      You need to set flags to <span class="Li">&quot;SVf_UTF8&quot;</span> for
      a utf-8 label.
    <p class="Pp">NOTE: this function is experimental and may change or be
        removed without notice.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    cop_store_label(COP *const cop,
                                const char *label, STRLEN len,
                                U32 flags)
    </pre>
  </dd>
  <dt>get_hv</dt>
  <dd>Returns the HV of the specified Perl hash.
      <span class="Li">&quot;flags&quot;</span> are passed to
      <span class="Li">&quot;gv_fetchpv&quot;</span>. If
      <span class="Li">&quot;GV_ADD&quot;</span> is set and the Perl variable
      does not exist then it will be created. If
      <span class="Li">&quot;flags&quot;</span> is zero and the variable does
      not exist then NULL is returned.
    <p class="Pp">NOTE: the perl_ form of this function is deprecated.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        HV*     get_hv(const char *name, I32 flags)
    </pre>
  </dd>
  <dt>HEf_SVKEY</dt>
  <dd>This flag, used in the length slot of hash entries and magic structures,
      specifies the structure contains an
      <span class="Li">&quot;SV*&quot;</span> pointer where a
      <span class="Li">&quot;char*&quot;</span> pointer is to be expected. (For
      information only--not to be used).</dd>
  <dt>HeHASH</dt>
  <dd>Returns the computed hash stored in the hash entry.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        U32     HeHASH(HE* he)
    </pre>
  </dd>
  <dt>HeKEY</dt>
  <dd>Returns the actual pointer stored in the key slot of the hash entry. The
      pointer may be either <span class="Li">&quot;char*&quot;</span> or
      <span class="Li">&quot;SV*&quot;</span>, depending on the value of
      <span class="Li">&quot;HeKLEN()&quot;</span>. Can be assigned to. The
      <span class="Li">&quot;HePV()&quot;</span> or
      <span class="Li">&quot;HeSVKEY()&quot;</span> macros are usually
      preferable for finding the value of a key.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void*   HeKEY(HE* he)
    </pre>
  </dd>
  <dt>HeKLEN</dt>
  <dd>If this is negative, and amounts to
      <span class="Li">&quot;HEf_SVKEY&quot;</span>, it indicates the entry
      holds an <span class="Li">&quot;SV*&quot;</span> key. Otherwise, holds the
      actual length of the key. Can be assigned to. The
      <span class="Li">&quot;HePV()&quot;</span> macro is usually preferable for
      finding key lengths.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        STRLEN  HeKLEN(HE* he)
    </pre>
  </dd>
  <dt>HePV</dt>
  <dd>Returns the key slot of the hash entry as a
      <span class="Li">&quot;char*&quot;</span> value, doing any necessary
      dereferencing of possibly <span class="Li">&quot;SV*&quot;</span> keys.
      The length of the string is placed in
      <span class="Li">&quot;len&quot;</span> (this is a macro, so do <i>not</i>
      use <span class="Li">&amp;len</span>). If you do not care about what the
      length of the key is, you may use the global variable
      <span class="Li">&quot;PL_na&quot;</span>, though this is rather less
      efficient than using a local variable. Remember though, that hash keys in
      perl are free to contain embedded nulls, so using
      <span class="Li">&quot;strlen()&quot;</span> or similar is not a good way
      to find the length of hash keys. This is very similar to the
      <span class="Li">&quot;SvPV()&quot;</span> macro described elsewhere in
      this document. See also <span class="Li">&quot;HeUTF8&quot;</span>.
    <p class="Pp">If you are using <span class="Li">&quot;HePV&quot;</span> to
        get values to pass to <span class="Li">&quot;newSVpvn()&quot;</span> to
        create a new SV, you should consider using
        <span class="Li">&quot;newSVhek(HeKEY_hek(he))&quot;</span> as it is
        more efficient.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        char*   HePV(HE* he, STRLEN len)
    </pre>
  </dd>
  <dt>HeSVKEY</dt>
  <dd>Returns the key as an <span class="Li">&quot;SV*&quot;</span>, or
      <span class="Li">&quot;NULL&quot;</span> if the hash entry does not
      contain an <span class="Li">&quot;SV*&quot;</span> key.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV*     HeSVKEY(HE* he)
    </pre>
  </dd>
  <dt>HeSVKEY_force</dt>
  <dd>Returns the key as an <span class="Li">&quot;SV*&quot;</span>. Will create
      and return a temporary mortal <span class="Li">&quot;SV*&quot;</span> if
      the hash entry contains only a <span class="Li">&quot;char*&quot;</span>
      key.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV*     HeSVKEY_force(HE* he)
    </pre>
  </dd>
  <dt>HeSVKEY_set</dt>
  <dd>Sets the key to a given <span class="Li">&quot;SV*&quot;</span>, taking
      care to set the appropriate flags to indicate the presence of an
      <span class="Li">&quot;SV*&quot;</span> key, and returns the same
      <span class="Li">&quot;SV*&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV*     HeSVKEY_set(HE* he, SV* sv)
    </pre>
  </dd>
  <dt>HeUTF8</dt>
  <dd>Returns whether the <span class="Li">&quot;char *&quot;</span> value
      returned by <span class="Li">&quot;HePV&quot;</span> is encoded in UTF-8,
      doing any necessary dereferencing of possibly
      <span class="Li">&quot;SV*&quot;</span> keys. The value returned will be 0
      or non-0, not necessarily 1 (or even a value with any low bits set), so
      <b>do not</b> blindly assign this to a
      <span class="Li">&quot;bool&quot;</span> variable, as
      <span class="Li">&quot;bool&quot;</span> may be a typedef for
      <span class="Li">&quot;char&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        char*   HeUTF8(HE* he)
    </pre>
  </dd>
  <dt>HeVAL</dt>
  <dd>Returns the value slot (type <span class="Li">&quot;SV*&quot;</span>)
      stored in the hash entry. Can be assigned to.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  SV *foo= HeVAL(hv);
  HeVAL(hv)= sv;


        SV*     HeVAL(HE* he)
    </pre>
  </dd>
  <dt>HvENAME</dt>
  <dd>Returns the effective name of a stash, or NULL if there is none. The
      effective name represents a location in the symbol table where this stash
      resides. It is updated automatically when packages are aliased or deleted.
      A stash that is no longer in the symbol table has no effective name. This
      name is preferable to <span class="Li">&quot;HvNAME&quot;</span> for use
      in MRO linearisations and isa caches.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        char*   HvENAME(HV* stash)
    </pre>
  </dd>
  <dt>HvENAMELEN</dt>
  <dd>Returns the length of the stash's effective name.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        STRLEN  HvENAMELEN(HV *stash)
    </pre>
  </dd>
  <dt>HvENAMEUTF8</dt>
  <dd>Returns true if the effective name is in UTF8 encoding.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        unsigned char HvENAMEUTF8(HV *stash)
    </pre>
  </dd>
  <dt>HvNAME</dt>
  <dd>Returns the package name of a stash, or NULL if
      <span class="Li">&quot;stash&quot;</span> isn't a stash. See
      <span class="Li">&quot;SvSTASH&quot;</span>,
      <span class="Li">&quot;CvSTASH&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        char*   HvNAME(HV* stash)
    </pre>
  </dd>
  <dt>HvNAMELEN</dt>
  <dd>Returns the length of the stash's name.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        STRLEN  HvNAMELEN(HV *stash)
    </pre>
  </dd>
  <dt>HvNAMEUTF8</dt>
  <dd>Returns true if the name is in UTF8 encoding.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        unsigned char HvNAMEUTF8(HV *stash)
    </pre>
  </dd>
  <dt>hv_assert</dt>
  <dd>Check that a hash is in an internally consistent state.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    hv_assert(HV *hv)
    </pre>
  </dd>
  <dt>hv_clear</dt>
  <dd>Frees the all the elements of a hash, leaving it empty. The XS equivalent
      of <span class="Li">&quot;%hash = ()&quot;</span>. See also
      &quot;hv_undef&quot;.
    <p class="Pp">If any destructors are triggered as a result, the hv itself
        may be freed.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    hv_clear(HV *hv)
    </pre>
  </dd>
  <dt>hv_clear_placeholders</dt>
  <dd>Clears any placeholders from a hash. If a restricted hash has any of its
      keys marked as readonly and the key is subsequently deleted, the key is
      not actually deleted but is marked by assigning it a value of
      &amp;PL_sv_placeholder. This tags it so it will be ignored by future
      operations such as iterating over the hash, but will still allow the hash
      to have a value reassigned to the key at some future point. This function
      clears any such placeholder keys from the hash. See
      <i>Hash::Util::lock_keys()</i> for an example of its use.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    hv_clear_placeholders(HV *hv)
    </pre>
  </dd>
  <dt>hv_copy_hints_hv</dt>
  <dd>A specialised version of &quot;newHVhv&quot; for copying
      <span class="Li">&quot;%^H&quot;</span>. <i>ohv</i> must be a pointer to a
      hash (which may have <span class="Li">&quot;%^H&quot;</span> magic, but
      should be generally non-magical), or
      <span class="Li">&quot;NULL&quot;</span> (interpreted as an empty hash).
      The content of <i>ohv</i> is copied to a new hash, which has the
      <span class="Li">&quot;%^H&quot;</span>-specific magic added to it. A
      pointer to the new hash is returned.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        HV *    hv_copy_hints_hv(HV *ohv)
    </pre>
  </dd>
  <dt>hv_delete</dt>
  <dd>Deletes a key/value pair in the hash. The value's SV is removed from the
      hash, made mortal, and returned to the caller. The absolute value of
      <span class="Li">&quot;klen&quot;</span> is the length of the key. If
      <span class="Li">&quot;klen&quot;</span> is negative the key is assumed to
      be in UTF-8-encoded Unicode. The <span class="Li">&quot;flags&quot;</span>
      value will normally be zero; if set to G_DISCARD then NULL will be
      returned. NULL will also be returned if the key is not found.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV*     hv_delete(HV *hv, const char *key, I32 klen,
                          I32 flags)
    </pre>
  </dd>
  <dt>hv_delete_ent</dt>
  <dd>Deletes a key/value pair in the hash. The value SV is removed from the
      hash, made mortal, and returned to the caller. The
      <span class="Li">&quot;flags&quot;</span> value will normally be zero; if
      set to G_DISCARD then NULL will be returned. NULL will also be returned if
      the key is not found. <span class="Li">&quot;hash&quot;</span> can be a
      valid precomputed hash value, or 0 to ask for it to be computed.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV*     hv_delete_ent(HV *hv, SV *keysv, I32 flags,
                              U32 hash)
    </pre>
  </dd>
  <dt>hv_exists</dt>
  <dd>Returns a boolean indicating whether the specified hash key exists. The
      absolute value of <span class="Li">&quot;klen&quot;</span> is the length
      of the key. If <span class="Li">&quot;klen&quot;</span> is negative the
      key is assumed to be in UTF-8-encoded Unicode.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    hv_exists(HV *hv, const char *key, I32 klen)
    </pre>
  </dd>
  <dt>hv_exists_ent</dt>
  <dd>Returns a boolean indicating whether the specified hash key exists.
      <span class="Li">&quot;hash&quot;</span> can be a valid precomputed hash
      value, or 0 to ask for it to be computed.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    hv_exists_ent(HV *hv, SV *keysv, U32 hash)
    </pre>
  </dd>
  <dt>hv_fetch</dt>
  <dd>Returns the SV which corresponds to the specified key in the hash. The
      absolute value of <span class="Li">&quot;klen&quot;</span> is the length
      of the key. If <span class="Li">&quot;klen&quot;</span> is negative the
      key is assumed to be in UTF-8-encoded Unicode. If
      <span class="Li">&quot;lval&quot;</span> is set then the fetch will be
      part of a store. This means that if there is no value in the hash
      associated with the given key, then one is created and a pointer to it is
      returned. The <span class="Li">&quot;SV*&quot;</span> it points to can be
      assigned to. But always check that the return value is non-null before
      dereferencing it to an <span class="Li">&quot;SV*&quot;</span>.
    <p class="Pp">See &quot;Understanding the Magic of Tied Hashes and
        Arrays&quot; in perlguts for more information on how to use this
        function on tied hashes.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV**    hv_fetch(HV *hv, const char *key, I32 klen,
                         I32 lval)
    </pre>
  </dd>
  <dt>hv_fetchs</dt>
  <dd>Like <span class="Li">&quot;hv_fetch&quot;</span>, but takes a literal
      string instead of a string/length pair.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV**    hv_fetchs(HV* tb, const char* key, I32 lval)
    </pre>
  </dd>
  <dt>hv_fetch_ent</dt>
  <dd>Returns the hash entry which corresponds to the specified key in the hash.
      <span class="Li">&quot;hash&quot;</span> must be a valid precomputed hash
      number for the given <span class="Li">&quot;key&quot;</span>, or 0 if you
      want the function to compute it. IF
      <span class="Li">&quot;lval&quot;</span> is set then the fetch will be
      part of a store. Make sure the return value is non-null before accessing
      it. The return value when <span class="Li">&quot;hv&quot;</span> is a tied
      hash is a pointer to a static location, so be sure to make a copy of the
      structure if you need to store it somewhere.
    <p class="Pp">See &quot;Understanding the Magic of Tied Hashes and
        Arrays&quot; in perlguts for more information on how to use this
        function on tied hashes.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        HE*     hv_fetch_ent(HV *hv, SV *keysv, I32 lval,
                             U32 hash)
    </pre>
  </dd>
  <dt>hv_fill</dt>
  <dd>Returns the number of hash buckets that happen to be in use. This function
      is wrapped by the macro <span class="Li">&quot;HvFILL&quot;</span>.
    <p class="Pp">Previously this value was stored in the HV structure, rather
        than being calculated on demand.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        STRLEN  hv_fill(HV const *const hv)
    </pre>
  </dd>
  <dt>hv_iterinit</dt>
  <dd>Prepares a starting point to traverse a hash table. Returns the number of
      keys in the hash (i.e. the same as
      <span class="Li">&quot;HvUSEDKEYS(hv)&quot;</span>). The return value is
      currently only meaningful for hashes without tie magic.
    <p class="Pp">NOTE: Before version 5.004_65,
        <span class="Li">&quot;hv_iterinit&quot;</span> used to return the
        number of hash buckets that happen to be in use. If you still need that
        esoteric value, you can get it through the macro
        <span class="Li">&quot;HvFILL(hv)&quot;</span>.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        I32     hv_iterinit(HV *hv)
    </pre>
  </dd>
  <dt>hv_iterkey</dt>
  <dd>Returns the key from the current position of the hash iterator. See
      <span class="Li">&quot;hv_iterinit&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        char*   hv_iterkey(HE* entry, I32* retlen)
    </pre>
  </dd>
  <dt>hv_iterkeysv</dt>
  <dd>Returns the key as an <span class="Li">&quot;SV*&quot;</span> from the
      current position of the hash iterator. The return value will always be a
      mortal copy of the key. Also see
      <span class="Li">&quot;hv_iterinit&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV*     hv_iterkeysv(HE* entry)
    </pre>
  </dd>
  <dt>hv_iternext</dt>
  <dd>Returns entries from a hash iterator. See
      <span class="Li">&quot;hv_iterinit&quot;</span>.
    <p class="Pp">You may call <span class="Li">&quot;hv_delete&quot;</span> or
        <span class="Li">&quot;hv_delete_ent&quot;</span> on the hash entry that
        the iterator currently points to, without losing your place or
        invalidating your iterator. Note that in this case the current entry is
        deleted from the hash with your iterator holding the last reference to
        it. Your iterator is flagged to free the entry on the next call to
        <span class="Li">&quot;hv_iternext&quot;</span>, so you must not discard
        your iterator immediately else the entry will leak - call
        <span class="Li">&quot;hv_iternext&quot;</span> to trigger the resource
        deallocation.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        HE*     hv_iternext(HV *hv)
    </pre>
  </dd>
  <dt>hv_iternextsv</dt>
  <dd>Performs an <span class="Li">&quot;hv_iternext&quot;</span>,
      <span class="Li">&quot;hv_iterkey&quot;</span>, and
      <span class="Li">&quot;hv_iterval&quot;</span> in one operation.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV*     hv_iternextsv(HV *hv, char **key, I32 *retlen)
    </pre>
  </dd>
  <dt>hv_iternext_flags</dt>
  <dd>Returns entries from a hash iterator. See
      <span class="Li">&quot;hv_iterinit&quot;</span> and
      <span class="Li">&quot;hv_iternext&quot;</span>. The
      <span class="Li">&quot;flags&quot;</span> value will normally be zero; if
      HV_ITERNEXT_WANTPLACEHOLDERS is set the placeholders keys (for restricted
      hashes) will be returned in addition to normal keys. By default
      placeholders are automatically skipped over. Currently a placeholder is
      implemented with a value that is
      <span class="Li">&amp;PL_sv_placeholder</span>. Note that the
      implementation of placeholders and restricted hashes may change, and the
      implementation currently is insufficiently abstracted for any change to be
      tidy.
    <p class="Pp">NOTE: this function is experimental and may change or be
        removed without notice.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        HE*     hv_iternext_flags(HV *hv, I32 flags)
    </pre>
  </dd>
  <dt>hv_iterval</dt>
  <dd>Returns the value from the current position of the hash iterator. See
      <span class="Li">&quot;hv_iterkey&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV*     hv_iterval(HV *hv, HE *entry)
    </pre>
  </dd>
  <dt>hv_magic</dt>
  <dd>Adds magic to a hash. See <span class="Li">&quot;sv_magic&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    hv_magic(HV *hv, GV *gv, int how)
    </pre>
  </dd>
  <dt>hv_scalar</dt>
  <dd>Evaluates the hash in scalar context and returns the result. Handles magic
      when the hash is tied.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV*     hv_scalar(HV *hv)
    </pre>
  </dd>
  <dt>hv_store</dt>
  <dd>Stores an SV in a hash. The hash key is specified as
      <span class="Li">&quot;key&quot;</span> and the absolute value of
      <span class="Li">&quot;klen&quot;</span> is the length of the key. If
      <span class="Li">&quot;klen&quot;</span> is negative the key is assumed to
      be in UTF-8-encoded Unicode. The <span class="Li">&quot;hash&quot;</span>
      parameter is the precomputed hash value; if it is zero then Perl will
      compute it.
    <p class="Pp">The return value will be NULL if the operation failed or if
        the value did not need to be actually stored within the hash (as in the
        case of tied hashes). Otherwise it can be dereferenced to get the
        original <span class="Li">&quot;SV*&quot;</span>. Note that the caller
        is responsible for suitably incrementing the reference count of
        <span class="Li">&quot;val&quot;</span> before the call, and
        decrementing it if the function returned NULL. Effectively a successful
        hv_store takes ownership of one reference to
        <span class="Li">&quot;val&quot;</span>. This is usually what you want;
        a newly created SV has a reference count of one, so if all your code
        does is create SVs then store them in a hash, hv_store will own the only
        reference to the new SV, and your code doesn't need to do anything
        further to tidy up. hv_store is not implemented as a call to
        hv_store_ent, and does not create a temporary SV for the key, so if your
        key data is not already in SV form then use hv_store in preference to
        hv_store_ent.</p>
    <p class="Pp">See &quot;Understanding the Magic of Tied Hashes and
        Arrays&quot; in perlguts for more information on how to use this
        function on tied hashes.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV**    hv_store(HV *hv, const char *key, I32 klen,
                         SV *val, U32 hash)
    </pre>
  </dd>
  <dt>hv_stores</dt>
  <dd>Like <span class="Li">&quot;hv_store&quot;</span>, but takes a literal
      string instead of a string/length pair and omits the hash parameter.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV**    hv_stores(HV* tb, const char* key,
                          NULLOK SV* val)
    </pre>
  </dd>
  <dt>hv_store_ent</dt>
  <dd>Stores <span class="Li">&quot;val&quot;</span> in a hash. The hash key is
      specified as <span class="Li">&quot;key&quot;</span>. The
      <span class="Li">&quot;hash&quot;</span> parameter is the precomputed hash
      value; if it is zero then Perl will compute it. The return value is the
      new hash entry so created. It will be NULL if the operation failed or if
      the value did not need to be actually stored within the hash (as in the
      case of tied hashes). Otherwise the contents of the return value can be
      accessed using the <span class="Li">&quot;He?&quot;</span> macros
      described here. Note that the caller is responsible for suitably
      incrementing the reference count of
      <span class="Li">&quot;val&quot;</span> before the call, and decrementing
      it if the function returned NULL. Effectively a successful hv_store_ent
      takes ownership of one reference to
      <span class="Li">&quot;val&quot;</span>. This is usually what you want; a
      newly created SV has a reference count of one, so if all your code does is
      create SVs then store them in a hash, hv_store will own the only reference
      to the new SV, and your code doesn't need to do anything further to tidy
      up. Note that hv_store_ent only reads the
      <span class="Li">&quot;key&quot;</span>; unlike
      <span class="Li">&quot;val&quot;</span> it does not take ownership of it,
      so maintaining the correct reference count on
      <span class="Li">&quot;key&quot;</span> is entirely the caller's
      responsibility. hv_store is not implemented as a call to hv_store_ent, and
      does not create a temporary SV for the key, so if your key data is not
      already in SV form then use hv_store in preference to hv_store_ent.
    <p class="Pp">See &quot;Understanding the Magic of Tied Hashes and
        Arrays&quot; in perlguts for more information on how to use this
        function on tied hashes.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        HE*     hv_store_ent(HV *hv, SV *key, SV *val, U32 hash)
    </pre>
  </dd>
  <dt>hv_undef</dt>
  <dd>Undefines the hash. The XS equivalent of
      <span class="Li">&quot;undef(%hash)&quot;</span>.
    <p class="Pp">As well as freeing all the elements of the hash (like
        <i>hv_clear()</i>), this also frees any auxiliary data and storage
        associated with the hash.</p>
    <p class="Pp">If any destructors are triggered as a result, the hv itself
        may be freed.</p>
    <p class="Pp">See also &quot;hv_clear&quot;.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    hv_undef(HV *hv)
    </pre>
  </dd>
  <dt>newHV</dt>
  <dd>Creates a new HV. The reference count is set to 1.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        HV*     newHV()
    </pre>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="Hook_manipulation"><a class="permalink" href="#Hook_manipulation">Hook
  manipulation</a></h1>
<dl class="Bl-tag">
  <dt>wrap_op_checker</dt>
  <dd>Puts a C function into the chain of check functions for a specified op
      type. This is the preferred way to manipulate the &quot;PL_check&quot;
      array. <i>opcode</i> specifies which type of op is to be affected.
      <i>new_checker</i> is a pointer to the C function that is to be added to
      that opcode's check chain, and <i>old_checker_p</i> points to the storage
      location where a pointer to the next function in the chain will be stored.
      The value of <i>new_pointer</i> is written into the &quot;PL_check&quot;
      array, while the value previously stored there is written to
      <i>*old_checker_p</i>.
    <p class="Pp">&quot;PL_check&quot; is global to an entire process, and a
        module wishing to hook op checking may find itself invoked more than
        once per process, typically in different threads. To handle that
        situation, this function is idempotent. The location
        <i>*old_checker_p</i> must initially (once per process) contain a null
        pointer. A C variable of static duration (declared at file scope,
        typically also marked <span class="Li">&quot;static&quot;</span> to give
        it internal linkage) will be implicitly initialised appropriately, if it
        does not have an explicit initialiser. This function will only actually
        modify the check chain if it finds <i>*old_checker_p</i> to be null.
        This function is also thread safe on the small scale. It uses
        appropriate locking to avoid race conditions in accessing
        &quot;PL_check&quot;.</p>
    <p class="Pp">When this function is called, the function referenced by
        <i>new_checker</i> must be ready to be called, except for
        <i>*old_checker_p</i> being unfilled. In a threading situation,
        <i>new_checker</i> may be called immediately, even before this function
        has returned. <i>*old_checker_p</i> will always be appropriately set
        before <i>new_checker</i> is called. If <i>new_checker</i> decides not
        to do anything special with an op that it is given (which is the usual
        case for most uses of op check hooking), it must chain the check
        function referenced by <i>*old_checker_p</i>.</p>
    <p class="Pp">If you want to influence compilation of calls to a specific
        subroutine, then use &quot;cv_set_call_checker&quot; rather than hooking
        checking of all <span class="Li">&quot;entersub&quot;</span> ops.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    wrap_op_checker(Optype opcode,
                                Perl_check_t new_checker,
                                Perl_check_t *old_checker_p)
    </pre>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="Lexer_interface"><a class="permalink" href="#Lexer_interface">Lexer
  interface</a></h1>
<dl class="Bl-tag">
  <dt>lex_bufutf8</dt>
  <dd>Indicates whether the octets in the lexer buffer
      (&quot;PL_parser-&gt;linestr&quot;) should be interpreted as the UTF-8
      encoding of Unicode characters. If not, they should be interpreted as
      Latin-1 characters. This is analogous to the
      <span class="Li">&quot;SvUTF8&quot;</span> flag for scalars.
    <p class="Pp">In UTF-8 mode, it is not guaranteed that the lexer buffer
        actually contains valid UTF-8. Lexing code must be robust in the face of
        invalid encoding.</p>
    <p class="Pp">The actual <span class="Li">&quot;SvUTF8&quot;</span> flag of
        the &quot;PL_parser-&gt;linestr&quot; scalar is significant, but not the
        whole story regarding the input character encoding. Normally, when a
        file is being read, the scalar contains octets and its
        <span class="Li">&quot;SvUTF8&quot;</span> flag is off, but the octets
        should be interpreted as UTF-8 if the <span class="Li">&quot;use
        utf8&quot;</span> pragma is in effect. During a string eval, however,
        the scalar may have the <span class="Li">&quot;SvUTF8&quot;</span> flag
        on, and in this case its octets should be interpreted as UTF-8 unless
        the <span class="Li">&quot;use bytes&quot;</span> pragma is in effect.
        This logic may change in the future; use this function instead of
        implementing the logic yourself.</p>
    <p class="Pp">NOTE: this function is experimental and may change or be
        removed without notice.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    lex_bufutf8()
    </pre>
  </dd>
  <dt>lex_discard_to</dt>
  <dd>Discards the first part of the &quot;PL_parser-&gt;linestr&quot; buffer,
      up to <i>ptr</i>. The remaining content of the buffer will be moved, and
      all pointers into the buffer updated appropriately. <i>ptr</i> must not be
      later in the buffer than the position of &quot;PL_parser-&gt;bufptr&quot;:
      it is not permitted to discard text that has yet to be lexed.
    <p class="Pp">Normally it is not necessarily to do this directly, because it
        suffices to use the implicit discarding behaviour of
        &quot;lex_next_chunk&quot; and things based on it. However, if a token
        stretches across multiple lines, and the lexing code has kept multiple
        lines of text in the buffer for that purpose, then after completion of
        the token it would be wise to explicitly discard the now-unneeded
        earlier lines, to avoid future multi-line tokens growing the buffer
        without bound.</p>
    <p class="Pp">NOTE: this function is experimental and may change or be
        removed without notice.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    lex_discard_to(char *ptr)
    </pre>
  </dd>
  <dt>lex_grow_linestr</dt>
  <dd>Reallocates the lexer buffer (&quot;PL_parser-&gt;linestr&quot;) to
      accommodate at least <i>len</i> octets (including terminating NUL).
      Returns a pointer to the reallocated buffer. This is necessary before
      making any direct modification of the buffer that would increase its
      length. &quot;lex_stuff_pvn&quot; provides a more convenient way to insert
      text into the buffer.
    <p class="Pp">Do not use <span class="Li">&quot;SvGROW&quot;</span> or
        <span class="Li">&quot;sv_grow&quot;</span> directly on
        <span class="Li">&quot;PL_parser-&gt;linestr&quot;</span>; this function
        updates all of the lexer's variables that point directly into the
        buffer.</p>
    <p class="Pp">NOTE: this function is experimental and may change or be
        removed without notice.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        char *  lex_grow_linestr(STRLEN len)
    </pre>
  </dd>
  <dt>lex_next_chunk</dt>
  <dd>Reads in the next chunk of text to be lexed, appending it to
      &quot;PL_parser-&gt;linestr&quot;. This should be called when lexing code
      has looked to the end of the current chunk and wants to know more. It is
      usual, but not necessary, for lexing to have consumed the entirety of the
      current chunk at this time.
    <p class="Pp">If &quot;PL_parser-&gt;bufptr&quot; is pointing to the very
        end of the current chunk (i.e., the current chunk has been entirely
        consumed), normally the current chunk will be discarded at the same time
        that the new chunk is read in. If <i>flags</i> includes
        <span class="Li">&quot;LEX_KEEP_PREVIOUS&quot;</span>, the current chunk
        will not be discarded. If the current chunk has not been entirely
        consumed, then it will not be discarded regardless of the flag.</p>
    <p class="Pp">Returns true if some new text was added to the buffer, or
        false if the buffer has reached the end of the input text.</p>
    <p class="Pp">NOTE: this function is experimental and may change or be
        removed without notice.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    lex_next_chunk(U32 flags)
    </pre>
  </dd>
  <dt>lex_peek_unichar</dt>
  <dd>Looks ahead one (Unicode) character in the text currently being lexed.
      Returns the codepoint (unsigned integer value) of the next character, or
      -1 if lexing has reached the end of the input text. To consume the peeked
      character, use &quot;lex_read_unichar&quot;.
    <p class="Pp">If the next character is in (or extends into) the next chunk
        of input text, the next chunk will be read in. Normally the current
        chunk will be discarded at the same time, but if <i>flags</i> includes
        <span class="Li">&quot;LEX_KEEP_PREVIOUS&quot;</span> then the current
        chunk will not be discarded.</p>
    <p class="Pp">If the input is being interpreted as UTF-8 and a UTF-8
        encoding error is encountered, an exception is generated.</p>
    <p class="Pp">NOTE: this function is experimental and may change or be
        removed without notice.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        I32     lex_peek_unichar(U32 flags)
    </pre>
  </dd>
  <dt>lex_read_space</dt>
  <dd>Reads optional spaces, in Perl style, in the text currently being lexed.
      The spaces may include ordinary whitespace characters and Perl-style
      comments. <span class="Li">&quot;#line&quot;</span> directives are
      processed if encountered. &quot;PL_parser-&gt;bufptr&quot; is moved past
      the spaces, so that it points at a non-space character (or the end of the
      input text).
    <p class="Pp">If spaces extend into the next chunk of input text, the next
        chunk will be read in. Normally the current chunk will be discarded at
        the same time, but if <i>flags</i> includes
        <span class="Li">&quot;LEX_KEEP_PREVIOUS&quot;</span> then the current
        chunk will not be discarded.</p>
    <p class="Pp">NOTE: this function is experimental and may change or be
        removed without notice.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    lex_read_space(U32 flags)
    </pre>
  </dd>
  <dt>lex_read_to</dt>
  <dd>Consume text in the lexer buffer, from &quot;PL_parser-&gt;bufptr&quot; up
      to <i>ptr</i>. This advances &quot;PL_parser-&gt;bufptr&quot; to match
      <i>ptr</i>, performing the correct bookkeeping whenever a newline
      character is passed. This is the normal way to consume lexed text.
    <p class="Pp">Interpretation of the buffer's octets can be abstracted out by
        using the slightly higher-level functions &quot;lex_peek_unichar&quot;
        and &quot;lex_read_unichar&quot;.</p>
    <p class="Pp">NOTE: this function is experimental and may change or be
        removed without notice.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    lex_read_to(char *ptr)
    </pre>
  </dd>
  <dt>lex_read_unichar</dt>
  <dd>Reads the next (Unicode) character in the text currently being lexed.
      Returns the codepoint (unsigned integer value) of the character read, and
      moves &quot;PL_parser-&gt;bufptr&quot; past the character, or returns -1
      if lexing has reached the end of the input text. To non-destructively
      examine the next character, use &quot;lex_peek_unichar&quot; instead.
    <p class="Pp">If the next character is in (or extends into) the next chunk
        of input text, the next chunk will be read in. Normally the current
        chunk will be discarded at the same time, but if <i>flags</i> includes
        <span class="Li">&quot;LEX_KEEP_PREVIOUS&quot;</span> then the current
        chunk will not be discarded.</p>
    <p class="Pp">If the input is being interpreted as UTF-8 and a UTF-8
        encoding error is encountered, an exception is generated.</p>
    <p class="Pp">NOTE: this function is experimental and may change or be
        removed without notice.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        I32     lex_read_unichar(U32 flags)
    </pre>
  </dd>
  <dt>lex_start</dt>
  <dd>Creates and initialises a new lexer/parser state object, supplying a
      context in which to lex and parse from a new source of Perl code. A
      pointer to the new state object is placed in &quot;PL_parser&quot;. An
      entry is made on the save stack so that upon unwinding the new state
      object will be destroyed and the former value of &quot;PL_parser&quot;
      will be restored. Nothing else need be done to clean up the parsing
      context.
    <p class="Pp">The code to be parsed comes from <i>line</i> and <i>rsfp</i>.
        <i>line</i>, if non-null, provides a string (in SV form) containing code
        to be parsed. A copy of the string is made, so subsequent modification
        of <i>line</i> does not affect parsing. <i>rsfp</i>, if non-null,
        provides an input stream from which code will be read to be parsed. If
        both are non-null, the code in <i>line</i> comes first and must consist
        of complete lines of input, and <i>rsfp</i> supplies the remainder of
        the source.</p>
    <p class="Pp">The <i>flags</i> parameter is reserved for future use.
        Currently it is only used by perl internally, so extensions should
        always pass zero.</p>
    <p class="Pp">NOTE: this function is experimental and may change or be
        removed without notice.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    lex_start(SV *line, PerlIO *rsfp, U32 flags)
    </pre>
  </dd>
  <dt>lex_stuff_pv</dt>
  <dd>Insert characters into the lexer buffer
      (&quot;PL_parser-&gt;linestr&quot;), immediately after the current lexing
      point (&quot;PL_parser-&gt;bufptr&quot;), reallocating the buffer if
      necessary. This means that lexing code that runs later will see the
      characters as if they had appeared in the input. It is not recommended to
      do this as part of normal parsing, and most uses of this facility run the
      risk of the inserted characters being interpreted in an unintended manner.
    <p class="Pp">The string to be inserted is represented by octets starting at
        <i>pv</i> and continuing to the first nul. These octets are interpreted
        as either UTF-8 or Latin-1, according to whether the
        <span class="Li">&quot;LEX_STUFF_UTF8&quot;</span> flag is set in
        <i>flags</i>. The characters are recoded for the lexer buffer, according
        to how the buffer is currently being interpreted
        (&quot;lex_bufutf8&quot;). If it is not convenient to nul-terminate a
        string to be inserted, the &quot;lex_stuff_pvn&quot; function is more
        appropriate.</p>
    <p class="Pp">NOTE: this function is experimental and may change or be
        removed without notice.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    lex_stuff_pv(const char *pv, U32 flags)
    </pre>
  </dd>
  <dt>lex_stuff_pvn</dt>
  <dd>Insert characters into the lexer buffer
      (&quot;PL_parser-&gt;linestr&quot;), immediately after the current lexing
      point (&quot;PL_parser-&gt;bufptr&quot;), reallocating the buffer if
      necessary. This means that lexing code that runs later will see the
      characters as if they had appeared in the input. It is not recommended to
      do this as part of normal parsing, and most uses of this facility run the
      risk of the inserted characters being interpreted in an unintended manner.
    <p class="Pp">The string to be inserted is represented by <i>len</i> octets
        starting at <i>pv</i>. These octets are interpreted as either UTF-8 or
        Latin-1, according to whether the
        <span class="Li">&quot;LEX_STUFF_UTF8&quot;</span> flag is set in
        <i>flags</i>. The characters are recoded for the lexer buffer, according
        to how the buffer is currently being interpreted
        (&quot;lex_bufutf8&quot;). If a string to be inserted is available as a
        Perl scalar, the &quot;lex_stuff_sv&quot; function is more
      convenient.</p>
    <p class="Pp">NOTE: this function is experimental and may change or be
        removed without notice.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    lex_stuff_pvn(const char *pv, STRLEN len,
                              U32 flags)
    </pre>
  </dd>
  <dt>lex_stuff_pvs</dt>
  <dd>Like &quot;lex_stuff_pvn&quot;, but takes a literal string instead of a
      string/length pair.
    <p class="Pp">NOTE: this function is experimental and may change or be
        removed without notice.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    lex_stuff_pvs(const char *pv, U32 flags)
    </pre>
  </dd>
  <dt>lex_stuff_sv</dt>
  <dd>Insert characters into the lexer buffer
      (&quot;PL_parser-&gt;linestr&quot;), immediately after the current lexing
      point (&quot;PL_parser-&gt;bufptr&quot;), reallocating the buffer if
      necessary. This means that lexing code that runs later will see the
      characters as if they had appeared in the input. It is not recommended to
      do this as part of normal parsing, and most uses of this facility run the
      risk of the inserted characters being interpreted in an unintended manner.
    <p class="Pp">The string to be inserted is the string value of <i>sv</i>.
        The characters are recoded for the lexer buffer, according to how the
        buffer is currently being interpreted (&quot;lex_bufutf8&quot;). If a
        string to be inserted is not already a Perl scalar, the
        &quot;lex_stuff_pvn&quot; function avoids the need to construct a
        scalar.</p>
    <p class="Pp">NOTE: this function is experimental and may change or be
        removed without notice.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    lex_stuff_sv(SV *sv, U32 flags)
    </pre>
  </dd>
  <dt>lex_unstuff</dt>
  <dd>Discards text about to be lexed, from &quot;PL_parser-&gt;bufptr&quot; up
      to <i>ptr</i>. Text following <i>ptr</i> will be moved, and the buffer
      shortened. This hides the discarded text from any lexing code that runs
      later, as if the text had never appeared.
    <p class="Pp">This is not the normal way to consume lexed text. For that,
        use &quot;lex_read_to&quot;.</p>
    <p class="Pp">NOTE: this function is experimental and may change or be
        removed without notice.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    lex_unstuff(char *ptr)
    </pre>
  </dd>
  <dt>parse_arithexpr</dt>
  <dd>Parse a Perl arithmetic expression. This may contain operators of
      precedence down to the bit shift operators. The expression must be
      followed (and thus terminated) either by a comparison or lower-precedence
      operator or by something that would normally terminate an expression such
      as semicolon. If <i>flags</i> includes
      <span class="Li">&quot;PARSE_OPTIONAL&quot;</span> then the expression is
      optional, otherwise it is mandatory. It is up to the caller to ensure that
      the dynamic parser state (&quot;PL_parser&quot; et al) is correctly set to
      reflect the source of the code to be parsed and the lexical context for
      the expression.
    <p class="Pp">The op tree representing the expression is returned. If an
        optional expression is absent, a null pointer is returned, otherwise the
        pointer will be non-null.</p>
    <p class="Pp">If an error occurs in parsing or compilation, in most cases a
        valid op tree is returned anyway. The error is reflected in the parser
        state, normally resulting in a single exception at the top level of
        parsing which covers all the compilation errors that occurred. Some
        compilation errors, however, will throw an exception immediately.</p>
    <p class="Pp">NOTE: this function is experimental and may change or be
        removed without notice.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        OP *    parse_arithexpr(U32 flags)
    </pre>
  </dd>
  <dt>parse_barestmt</dt>
  <dd>Parse a single unadorned Perl statement. This may be a normal imperative
      statement or a declaration that has compile-time effect. It does not
      include any label or other affixture. It is up to the caller to ensure
      that the dynamic parser state (&quot;PL_parser&quot; et al) is correctly
      set to reflect the source of the code to be parsed and the lexical context
      for the statement.
    <p class="Pp">The op tree representing the statement is returned. This may
        be a null pointer if the statement is null, for example if it was
        actually a subroutine definition (which has compile-time side effects).
        If not null, it will be ops directly implementing the statement,
        suitable to pass to &quot;newSTATEOP&quot;. It will not normally include
        a <span class="Li">&quot;nextstate&quot;</span> or equivalent op (except
        for those embedded in a scope contained entirely within the
      statement).</p>
    <p class="Pp">If an error occurs in parsing or compilation, in most cases a
        valid op tree (most likely null) is returned anyway. The error is
        reflected in the parser state, normally resulting in a single exception
        at the top level of parsing which covers all the compilation errors that
        occurred. Some compilation errors, however, will throw an exception
        immediately.</p>
    <p class="Pp">The <i>flags</i> parameter is reserved for future use, and
        must always be zero.</p>
    <p class="Pp">NOTE: this function is experimental and may change or be
        removed without notice.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        OP *    parse_barestmt(U32 flags)
    </pre>
  </dd>
  <dt>parse_block</dt>
  <dd>Parse a single complete Perl code block. This consists of an opening
      brace, a sequence of statements, and a closing brace. The block
      constitutes a lexical scope, so <span class="Li">&quot;my&quot;</span>
      variables and various compile-time effects can be contained within it. It
      is up to the caller to ensure that the dynamic parser state
      (&quot;PL_parser&quot; et al) is correctly set to reflect the source of
      the code to be parsed and the lexical context for the statement.
    <p class="Pp">The op tree representing the code block is returned. This is
        always a real op, never a null pointer. It will normally be a
        <span class="Li">&quot;lineseq&quot;</span> list, including
        <span class="Li">&quot;nextstate&quot;</span> or equivalent ops. No ops
        to construct any kind of runtime scope are included by virtue of it
        being a block.</p>
    <p class="Pp">If an error occurs in parsing or compilation, in most cases a
        valid op tree (most likely null) is returned anyway. The error is
        reflected in the parser state, normally resulting in a single exception
        at the top level of parsing which covers all the compilation errors that
        occurred. Some compilation errors, however, will throw an exception
        immediately.</p>
    <p class="Pp">The <i>flags</i> parameter is reserved for future use, and
        must always be zero.</p>
    <p class="Pp">NOTE: this function is experimental and may change or be
        removed without notice.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        OP *    parse_block(U32 flags)
    </pre>
  </dd>
  <dt>parse_fullexpr</dt>
  <dd>Parse a single complete Perl expression. This allows the full expression
      grammar, including the lowest-precedence operators such as
      <span class="Li">&quot;or&quot;</span>. The expression must be followed
      (and thus terminated) by a token that an expression would normally be
      terminated by: end-of-file, closing bracketing punctuation, semicolon, or
      one of the keywords that signals a postfix expression-statement modifier.
      If <i>flags</i> includes
      <span class="Li">&quot;PARSE_OPTIONAL&quot;</span> then the expression is
      optional, otherwise it is mandatory. It is up to the caller to ensure that
      the dynamic parser state (&quot;PL_parser&quot; et al) is correctly set to
      reflect the source of the code to be parsed and the lexical context for
      the expression.
    <p class="Pp">The op tree representing the expression is returned. If an
        optional expression is absent, a null pointer is returned, otherwise the
        pointer will be non-null.</p>
    <p class="Pp">If an error occurs in parsing or compilation, in most cases a
        valid op tree is returned anyway. The error is reflected in the parser
        state, normally resulting in a single exception at the top level of
        parsing which covers all the compilation errors that occurred. Some
        compilation errors, however, will throw an exception immediately.</p>
    <p class="Pp">NOTE: this function is experimental and may change or be
        removed without notice.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        OP *    parse_fullexpr(U32 flags)
    </pre>
  </dd>
  <dt>parse_fullstmt</dt>
  <dd>Parse a single complete Perl statement. This may be a normal imperative
      statement or a declaration that has compile-time effect, and may include
      optional labels. It is up to the caller to ensure that the dynamic parser
      state (&quot;PL_parser&quot; et al) is correctly set to reflect the source
      of the code to be parsed and the lexical context for the statement.
    <p class="Pp">The op tree representing the statement is returned. This may
        be a null pointer if the statement is null, for example if it was
        actually a subroutine definition (which has compile-time side effects).
        If not null, it will be the result of a &quot;newSTATEOP&quot; call,
        normally including a <span class="Li">&quot;nextstate&quot;</span> or
        equivalent op.</p>
    <p class="Pp">If an error occurs in parsing or compilation, in most cases a
        valid op tree (most likely null) is returned anyway. The error is
        reflected in the parser state, normally resulting in a single exception
        at the top level of parsing which covers all the compilation errors that
        occurred. Some compilation errors, however, will throw an exception
        immediately.</p>
    <p class="Pp">The <i>flags</i> parameter is reserved for future use, and
        must always be zero.</p>
    <p class="Pp">NOTE: this function is experimental and may change or be
        removed without notice.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        OP *    parse_fullstmt(U32 flags)
    </pre>
  </dd>
  <dt>parse_label</dt>
  <dd>Parse a single label, possibly optional, of the type that may prefix a
      Perl statement. It is up to the caller to ensure that the dynamic parser
      state (&quot;PL_parser&quot; et al) is correctly set to reflect the source
      of the code to be parsed. If <i>flags</i> includes
      <span class="Li">&quot;PARSE_OPTIONAL&quot;</span> then the label is
      optional, otherwise it is mandatory.
    <p class="Pp">The name of the label is returned in the form of a fresh
        scalar. If an optional label is absent, a null pointer is returned.</p>
    <p class="Pp">If an error occurs in parsing, which can only occur if the
        label is mandatory, a valid label is returned anyway. The error is
        reflected in the parser state, normally resulting in a single exception
        at the top level of parsing which covers all the compilation errors that
        occurred.</p>
    <p class="Pp">NOTE: this function is experimental and may change or be
        removed without notice.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV *    parse_label(U32 flags)
    </pre>
  </dd>
  <dt>parse_listexpr</dt>
  <dd>Parse a Perl list expression. This may contain operators of precedence
      down to the comma operator. The expression must be followed (and thus
      terminated) either by a low-precedence logic operator such as
      <span class="Li">&quot;or&quot;</span> or by something that would normally
      terminate an expression such as semicolon. If <i>flags</i> includes
      <span class="Li">&quot;PARSE_OPTIONAL&quot;</span> then the expression is
      optional, otherwise it is mandatory. It is up to the caller to ensure that
      the dynamic parser state (&quot;PL_parser&quot; et al) is correctly set to
      reflect the source of the code to be parsed and the lexical context for
      the expression.
    <p class="Pp">The op tree representing the expression is returned. If an
        optional expression is absent, a null pointer is returned, otherwise the
        pointer will be non-null.</p>
    <p class="Pp">If an error occurs in parsing or compilation, in most cases a
        valid op tree is returned anyway. The error is reflected in the parser
        state, normally resulting in a single exception at the top level of
        parsing which covers all the compilation errors that occurred. Some
        compilation errors, however, will throw an exception immediately.</p>
    <p class="Pp">NOTE: this function is experimental and may change or be
        removed without notice.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        OP *    parse_listexpr(U32 flags)
    </pre>
  </dd>
  <dt>parse_stmtseq</dt>
  <dd>Parse a sequence of zero or more Perl statements. These may be normal
      imperative statements, including optional labels, or declarations that
      have compile-time effect, or any mixture thereof. The statement sequence
      ends when a closing brace or end-of-file is encountered in a place where a
      new statement could have validly started. It is up to the caller to ensure
      that the dynamic parser state (&quot;PL_parser&quot; et al) is correctly
      set to reflect the source of the code to be parsed and the lexical context
      for the statements.
    <p class="Pp">The op tree representing the statement sequence is returned.
        This may be a null pointer if the statements were all null, for example
        if there were no statements or if there were only subroutine definitions
        (which have compile-time side effects). If not null, it will be a
        <span class="Li">&quot;lineseq&quot;</span> list, normally including
        <span class="Li">&quot;nextstate&quot;</span> or equivalent ops.</p>
    <p class="Pp">If an error occurs in parsing or compilation, in most cases a
        valid op tree is returned anyway. The error is reflected in the parser
        state, normally resulting in a single exception at the top level of
        parsing which covers all the compilation errors that occurred. Some
        compilation errors, however, will throw an exception immediately.</p>
    <p class="Pp">The <i>flags</i> parameter is reserved for future use, and
        must always be zero.</p>
    <p class="Pp">NOTE: this function is experimental and may change or be
        removed without notice.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        OP *    parse_stmtseq(U32 flags)
    </pre>
  </dd>
  <dt>parse_termexpr</dt>
  <dd>Parse a Perl term expression. This may contain operators of precedence
      down to the assignment operators. The expression must be followed (and
      thus terminated) either by a comma or lower-precedence operator or by
      something that would normally terminate an expression such as semicolon.
      If <i>flags</i> includes
      <span class="Li">&quot;PARSE_OPTIONAL&quot;</span> then the expression is
      optional, otherwise it is mandatory. It is up to the caller to ensure that
      the dynamic parser state (&quot;PL_parser&quot; et al) is correctly set to
      reflect the source of the code to be parsed and the lexical context for
      the expression.
    <p class="Pp">The op tree representing the expression is returned. If an
        optional expression is absent, a null pointer is returned, otherwise the
        pointer will be non-null.</p>
    <p class="Pp">If an error occurs in parsing or compilation, in most cases a
        valid op tree is returned anyway. The error is reflected in the parser
        state, normally resulting in a single exception at the top level of
        parsing which covers all the compilation errors that occurred. Some
        compilation errors, however, will throw an exception immediately.</p>
    <p class="Pp">NOTE: this function is experimental and may change or be
        removed without notice.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        OP *    parse_termexpr(U32 flags)
    </pre>
  </dd>
  <dt>PL_parser</dt>
  <dd>Pointer to a structure encapsulating the state of the parsing operation
      currently in progress. The pointer can be locally changed to perform a
      nested parse without interfering with the state of an outer parse.
      Individual members of <span class="Li">&quot;PL_parser&quot;</span> have
      their own documentation.</dd>
  <dt>PL_parser-&gt;bufend</dt>
  <dd>Direct pointer to the end of the chunk of text currently being lexed, the
      end of the lexer buffer. This is equal to
      <span class="Li">&quot;SvPVX(PL_parser-&gt;linestr)</span>
      <span class="Li">+ SvCUR(PL_parser-&gt;linestr)&quot;</span>. A NUL
      character (zero octet) is always located at the end of the buffer, and
      does not count as part of the buffer's contents.
    <p class="Pp">NOTE: this function is experimental and may change or be
        removed without notice.</p>
  </dd>
  <dt>PL_parser-&gt;bufptr</dt>
  <dd>Points to the current position of lexing inside the lexer buffer.
      Characters around this point may be freely examined, within the range
      delimited by
      <span class="Li">&quot;SvPVX(&quot;PL_parser-&gt;linestr&quot;)&quot;</span>
      and &quot;PL_parser-&gt;bufend&quot;. The octets of the buffer may be
      intended to be interpreted as either UTF-8 or Latin-1, as indicated by
      &quot;lex_bufutf8&quot;.
    <p class="Pp">Lexing code (whether in the Perl core or not) moves this
        pointer past the characters that it consumes. It is also expected to
        perform some bookkeeping whenever a newline character is consumed. This
        movement can be more conveniently performed by the function
        &quot;lex_read_to&quot;, which handles newlines appropriately.</p>
    <p class="Pp">Interpretation of the buffer's octets can be abstracted out by
        using the slightly higher-level functions &quot;lex_peek_unichar&quot;
        and &quot;lex_read_unichar&quot;.</p>
    <p class="Pp">NOTE: this function is experimental and may change or be
        removed without notice.</p>
  </dd>
  <dt>PL_parser-&gt;linestart</dt>
  <dd>Points to the start of the current line inside the lexer buffer. This is
      useful for indicating at which column an error occurred, and not much
      else. This must be updated by any lexing code that consumes a newline; the
      function &quot;lex_read_to&quot; handles this detail.
    <p class="Pp">NOTE: this function is experimental and may change or be
        removed without notice.</p>
  </dd>
  <dt>PL_parser-&gt;linestr</dt>
  <dd>Buffer scalar containing the chunk currently under consideration of the
      text currently being lexed. This is always a plain string scalar (for
      which <span class="Li">&quot;SvPOK&quot;</span> is true). It is not
      intended to be used as a scalar by normal scalar means; instead refer to
      the buffer directly by the pointer variables described below.
    <p class="Pp">The lexer maintains various
        <span class="Li">&quot;char*&quot;</span> pointers to things in the
        <span class="Li">&quot;PL_parser-&gt;linestr&quot;</span> buffer. If
        <span class="Li">&quot;PL_parser-&gt;linestr&quot;</span> is ever
        reallocated, all of these pointers must be updated. Don't attempt to do
        this manually, but rather use &quot;lex_grow_linestr&quot; if you need
        to reallocate the buffer.</p>
    <p class="Pp">The content of the text chunk in the buffer is commonly
        exactly one complete line of input, up to and including a newline
        terminator, but there are situations where it is otherwise. The octets
        of the buffer may be intended to be interpreted as either UTF-8 or
        Latin-1. The function &quot;lex_bufutf8&quot; tells you which. Do not
        use the <span class="Li">&quot;SvUTF8&quot;</span> flag on this scalar,
        which may disagree with it.</p>
    <p class="Pp">For direct examination of the buffer, the variable
        &quot;PL_parser-&gt;bufend&quot; points to the end of the buffer. The
        current lexing position is pointed to by
        &quot;PL_parser-&gt;bufptr&quot;. Direct use of these pointers is
        usually preferable to examination of the scalar through normal scalar
        means.</p>
    <p class="Pp">NOTE: this function is experimental and may change or be
        removed without notice.</p>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="Magical_Functions"><a class="permalink" href="#Magical_Functions">Magical
  Functions</a></h1>
<dl class="Bl-tag">
  <dt>mg_clear</dt>
  <dd>Clear something magical that the SV represents. See
      <span class="Li">&quot;sv_magic&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        int     mg_clear(SV* sv)
    </pre>
  </dd>
  <dt>mg_copy</dt>
  <dd>Copies the magic from one SV to another. See
      <span class="Li">&quot;sv_magic&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        int     mg_copy(SV *sv, SV *nsv, const char *key,
                        I32 klen)
    </pre>
  </dd>
  <dt>mg_find</dt>
  <dd>Finds the magic pointer for type matching the SV. See
      <span class="Li">&quot;sv_magic&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        MAGIC*  mg_find(const SV* sv, int type)
    </pre>
  </dd>
  <dt>mg_findext</dt>
  <dd>Finds the magic pointer of <span class="Li">&quot;type&quot;</span> with
      the given <span class="Li">&quot;vtbl&quot;</span> for the
      <span class="Li">&quot;SV&quot;</span>. See
      <span class="Li">&quot;sv_magicext&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        MAGIC*  mg_findext(const SV* sv, int type,
                           const MGVTBL *vtbl)
    </pre>
  </dd>
  <dt>mg_free</dt>
  <dd>Free any magic storage used by the SV. See
      <span class="Li">&quot;sv_magic&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        int     mg_free(SV* sv)
    </pre>
  </dd>
  <dt>mg_free_type</dt>
  <dd>Remove any magic of type <i>how</i> from the SV <i>sv</i>. See
      &quot;sv_magic&quot;.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    mg_free_type(SV *sv, int how)
    </pre>
  </dd>
  <dt>mg_get</dt>
  <dd>Do magic before a value is retrieved from the SV. The type of SV must be
      &gt;= SVt_PVMG. See <span class="Li">&quot;sv_magic&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        int     mg_get(SV* sv)
    </pre>
  </dd>
  <dt>mg_length</dt>
  <dd>This function is deprecated.
    <p class="Pp">It reports on the SV's length in bytes, calling length magic
        if available, but does not set the UTF8 flag on the sv. It will fall
        back to 'get' magic if there is no 'length' magic, but with no
        indication as to whether it called 'get' magic. It assumes the sv is a
        PVMG or higher. Use <i>sv_len()</i> instead.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        U32     mg_length(SV* sv)
    </pre>
  </dd>
  <dt>mg_magical</dt>
  <dd>Turns on the magical status of an SV. See
      <span class="Li">&quot;sv_magic&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    mg_magical(SV* sv)
    </pre>
  </dd>
  <dt>mg_set</dt>
  <dd>Do magic after a value is assigned to the SV. See
      <span class="Li">&quot;sv_magic&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        int     mg_set(SV* sv)
    </pre>
  </dd>
  <dt>SvGETMAGIC</dt>
  <dd>Invokes <span class="Li">&quot;mg_get&quot;</span> on an SV if it has
      'get' magic. For example, this will call
      <span class="Li">&quot;FETCH&quot;</span> on a tied variable. This macro
      evaluates its argument more than once.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    SvGETMAGIC(SV* sv)
    </pre>
  </dd>
  <dt>SvLOCK</dt>
  <dd>Arranges for a mutual exclusion lock to be obtained on sv if a suitable
      module has been loaded.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    SvLOCK(SV* sv)
    </pre>
  </dd>
  <dt>SvSETMAGIC</dt>
  <dd>Invokes <span class="Li">&quot;mg_set&quot;</span> on an SV if it has
      'set' magic. This is necessary after modifying a scalar, in case it is a
      magical variable like <span class="Li">$|</span> or a tied variable (it
      calls <span class="Li">&quot;STORE&quot;</span>). This macro evaluates its
      argument more than once.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    SvSETMAGIC(SV* sv)
    </pre>
  </dd>
  <dt>SvSetMagicSV</dt>
  <dd>Like <span class="Li">&quot;SvSetSV&quot;</span>, but does any set magic
      required afterwards.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    SvSetMagicSV(SV* dsb, SV* ssv)
    </pre>
  </dd>
  <dt>SvSetMagicSV_nosteal</dt>
  <dd>Like <span class="Li">&quot;SvSetSV_nosteal&quot;</span>, but does any set
      magic required afterwards.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    SvSetMagicSV_nosteal(SV* dsv, SV* ssv)
    </pre>
  </dd>
  <dt>SvSetSV</dt>
  <dd>Calls <span class="Li">&quot;sv_setsv&quot;</span> if dsv is not the same
      as ssv. May evaluate arguments more than once.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    SvSetSV(SV* dsb, SV* ssv)
    </pre>
  </dd>
  <dt>SvSetSV_nosteal</dt>
  <dd>Calls a non-destructive version of
      <span class="Li">&quot;sv_setsv&quot;</span> if dsv is not the same as
      ssv. May evaluate arguments more than once.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    SvSetSV_nosteal(SV* dsv, SV* ssv)
    </pre>
  </dd>
  <dt>SvSHARE</dt>
  <dd>Arranges for sv to be shared between threads if a suitable module has been
      loaded.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    SvSHARE(SV* sv)
    </pre>
  </dd>
  <dt>SvUNLOCK</dt>
  <dd>Releases a mutual exclusion lock on sv if a suitable module has been
      loaded.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    SvUNLOCK(SV* sv)
    </pre>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="Memory_Management"><a class="permalink" href="#Memory_Management">Memory
  Management</a></h1>
<dl class="Bl-tag">
  <dt>Copy</dt>
  <dd>The XSUB-writer's interface to the C
      <span class="Li">&quot;memcpy&quot;</span> function. The
      <span class="Li">&quot;src&quot;</span> is the source,
      <span class="Li">&quot;dest&quot;</span> is the destination,
      <span class="Li">&quot;nitems&quot;</span> is the number of items, and
      <span class="Li">&quot;type&quot;</span> is the type. May fail on
      overlapping copies. See also <span class="Li">&quot;Move&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    Copy(void* src, void* dest, int nitems, type)
    </pre>
  </dd>
  <dt>CopyD</dt>
  <dd>Like <span class="Li">&quot;Copy&quot;</span> but returns dest. Useful for
      encouraging compilers to tail-call optimise.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void *  CopyD(void* src, void* dest, int nitems, type)
    </pre>
  </dd>
  <dt>Move</dt>
  <dd>The XSUB-writer's interface to the C
      <span class="Li">&quot;memmove&quot;</span> function. The
      <span class="Li">&quot;src&quot;</span> is the source,
      <span class="Li">&quot;dest&quot;</span> is the destination,
      <span class="Li">&quot;nitems&quot;</span> is the number of items, and
      <span class="Li">&quot;type&quot;</span> is the type. Can do overlapping
      moves. See also <span class="Li">&quot;Copy&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    Move(void* src, void* dest, int nitems, type)
    </pre>
  </dd>
  <dt>MoveD</dt>
  <dd>Like <span class="Li">&quot;Move&quot;</span> but returns dest. Useful for
      encouraging compilers to tail-call optimise.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void *  MoveD(void* src, void* dest, int nitems, type)
    </pre>
  </dd>
  <dt>Newx</dt>
  <dd>The XSUB-writer's interface to the C
      <span class="Li">&quot;malloc&quot;</span> function.
    <p class="Pp">In 5.9.3, <i>Newx()</i> and friends replace the older
        <i>New()</i> API, and drops the first parameter, <i>x</i>, a debug aid
        which allowed callers to identify themselves. This aid has been
        superseded by a new build option, PERL_MEM_LOG (see
        &quot;PERL_MEM_LOG&quot; in perlhacktips). The older API is still there
        for use in XS modules supporting older perls.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    Newx(void* ptr, int nitems, type)
    </pre>
  </dd>
  <dt>Newxc</dt>
  <dd>The XSUB-writer's interface to the C
      <span class="Li">&quot;malloc&quot;</span> function, with cast. See also
      <span class="Li">&quot;Newx&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    Newxc(void* ptr, int nitems, type, cast)
    </pre>
  </dd>
  <dt>Newxz</dt>
  <dd>The XSUB-writer's interface to the C
      <span class="Li">&quot;malloc&quot;</span> function. The allocated memory
      is zeroed with <span class="Li">&quot;memzero&quot;</span>. See also
      <span class="Li">&quot;Newx&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    Newxz(void* ptr, int nitems, type)
    </pre>
  </dd>
  <dt>Poison</dt>
  <dd>PoisonWith(0xEF) for catching access to freed memory.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    Poison(void* dest, int nitems, type)
    </pre>
  </dd>
  <dt>PoisonFree</dt>
  <dd>PoisonWith(0xEF) for catching access to freed memory.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    PoisonFree(void* dest, int nitems, type)
    </pre>
  </dd>
  <dt>PoisonNew</dt>
  <dd>PoisonWith(0xAB) for catching access to allocated but uninitialized
      memory.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    PoisonNew(void* dest, int nitems, type)
    </pre>
  </dd>
  <dt>PoisonWith</dt>
  <dd>Fill up memory with a byte pattern (a byte repeated over and over again)
      that hopefully catches attempts to access uninitialized memory.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    PoisonWith(void* dest, int nitems, type,
                           U8 byte)
    </pre>
  </dd>
  <dt>Renew</dt>
  <dd>The XSUB-writer's interface to the C
      <span class="Li">&quot;realloc&quot;</span> function.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    Renew(void* ptr, int nitems, type)
    </pre>
  </dd>
  <dt>Renewc</dt>
  <dd>The XSUB-writer's interface to the C
      <span class="Li">&quot;realloc&quot;</span> function, with cast.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    Renewc(void* ptr, int nitems, type, cast)
    </pre>
  </dd>
  <dt>Safefree</dt>
  <dd>The XSUB-writer's interface to the C
      <span class="Li">&quot;free&quot;</span> function.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    Safefree(void* ptr)
    </pre>
  </dd>
  <dt>savepv</dt>
  <dd>Perl's version of <span class="Li">&quot;strdup()&quot;</span>. Returns a
      pointer to a newly allocated string which is a duplicate of
      <span class="Li">&quot;pv&quot;</span>. The size of the string is
      determined by <span class="Li">&quot;strlen()&quot;</span>. The memory
      allocated for the new string can be freed with the
      <span class="Li">&quot;Safefree()&quot;</span> function.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        char*   savepv(const char* pv)
    </pre>
  </dd>
  <dt>savepvn</dt>
  <dd>Perl's version of what <span class="Li">&quot;strndup()&quot;</span> would
      be if it existed. Returns a pointer to a newly allocated string which is a
      duplicate of the first <span class="Li">&quot;len&quot;</span> bytes from
      <span class="Li">&quot;pv&quot;</span>, plus a trailing NUL byte. The
      memory allocated for the new string can be freed with the
      <span class="Li">&quot;Safefree()&quot;</span> function.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        char*   savepvn(const char* pv, I32 len)
    </pre>
  </dd>
  <dt>savepvs</dt>
  <dd>Like <span class="Li">&quot;savepvn&quot;</span>, but takes a literal
      string instead of a string/length pair.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        char*   savepvs(const char* s)
    </pre>
  </dd>
  <dt>savesharedpv</dt>
  <dd>A version of <span class="Li">&quot;savepv()&quot;</span> which allocates
      the duplicate string in memory which is shared between threads.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        char*   savesharedpv(const char* pv)
    </pre>
  </dd>
  <dt>savesharedpvn</dt>
  <dd>A version of <span class="Li">&quot;savepvn()&quot;</span> which allocates
      the duplicate string in memory which is shared between threads. (With the
      specific difference that a NULL pointer is not acceptable)
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        char*   savesharedpvn(const char *const pv,
                              const STRLEN len)
    </pre>
  </dd>
  <dt>savesharedpvs</dt>
  <dd>A version of <span class="Li">&quot;savepvs()&quot;</span> which allocates
      the duplicate string in memory which is shared between threads.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        char*   savesharedpvs(const char* s)
    </pre>
  </dd>
  <dt>savesharedsvpv</dt>
  <dd>A version of <span class="Li">&quot;savesharedpv()&quot;</span> which
      allocates the duplicate string in memory which is shared between threads.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        char*   savesharedsvpv(SV *sv)
    </pre>
  </dd>
  <dt>savesvpv</dt>
  <dd>A version of
      <span class="Li">&quot;savepv()&quot;</span>/<span class="Li">&quot;savepvn()&quot;</span>
      which gets the string to duplicate from the passed in SV using
      <span class="Li">&quot;SvPV()&quot;</span>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        char*   savesvpv(SV* sv)
    </pre>
  </dd>
  <dt>StructCopy</dt>
  <dd>This is an architecture-independent macro to copy one structure to
      another.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    StructCopy(type *src, type *dest, type)
    </pre>
  </dd>
  <dt>Zero</dt>
  <dd>The XSUB-writer's interface to the C
      <span class="Li">&quot;memzero&quot;</span> function. The
      <span class="Li">&quot;dest&quot;</span> is the destination,
      <span class="Li">&quot;nitems&quot;</span> is the number of items, and
      <span class="Li">&quot;type&quot;</span> is the type.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    Zero(void* dest, int nitems, type)
    </pre>
  </dd>
  <dt>ZeroD</dt>
  <dd>Like <span class="Li">&quot;Zero&quot;</span> but returns dest. Useful for
      encouraging compilers to tail-call optimise.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void *  ZeroD(void* dest, int nitems, type)
    </pre>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="Miscellaneous_Functions"><a class="permalink" href="#Miscellaneous_Functions">Miscellaneous
  Functions</a></h1>
<dl class="Bl-tag">
  <dt>fbm_compile</dt>
  <dd>Analyses the string in order to make fast searches on it using
      <i>fbm_instr()</i> -- the Boyer-Moore algorithm.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    fbm_compile(SV* sv, U32 flags)
    </pre>
  </dd>
  <dt>fbm_instr</dt>
  <dd>Returns the location of the SV in the string delimited by
      <span class="Li">&quot;big&quot;</span> and
      <span class="Li">&quot;bigend&quot;</span>. It returns
      <span class="Li">&quot;NULL&quot;</span> if the string can't be found. The
      <span class="Li">&quot;sv&quot;</span> does not have to be fbm_compiled,
      but the search will not be as fast then.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        char*   fbm_instr(unsigned char* big,
                          unsigned char* bigend, SV* littlestr,
                          U32 flags)
    </pre>
  </dd>
  <dt>foldEQ</dt>
  <dd>Returns true if the leading len bytes of the strings s1 and s2 are the
      same case-insensitively; false otherwise. Uppercase and lowercase ASCII
      range bytes match themselves and their opposite case counterparts.
      Non-cased and non-ASCII range bytes match only themselves.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        I32     foldEQ(const char* a, const char* b, I32 len)
    </pre>
  </dd>
  <dt>foldEQ_locale</dt>
  <dd>Returns true if the leading len bytes of the strings s1 and s2 are the
      same case-insensitively in the current locale; false otherwise.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        I32     foldEQ_locale(const char* a, const char* b,
                              I32 len)
    </pre>
  </dd>
  <dt>form</dt>
  <dd>Takes a sprintf-style format pattern and conventional (non-SV) arguments
      and returns the formatted string.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    (char *) Perl_form(pTHX_ const char* pat, ...)
    </pre>
    <p class="Pp">can be used any place a string (char *) is required:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    char * s = Perl_form(&quot;%d.%d&quot;,major,minor);
    </pre>
    <p class="Pp">Uses a single private buffer so if you want to format several
        strings you must explicitly copy the earlier strings away (and free the
        copies when you are done).</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        char*   form(const char* pat, ...)
    </pre>
  </dd>
  <dt>getcwd_sv</dt>
  <dd>Fill the sv with current working directory
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        int     getcwd_sv(SV* sv)
    </pre>
  </dd>
  <dt>mess</dt>
  <dd>Take a sprintf-style format pattern and argument list. These are used to
      generate a string message. If the message does not end with a newline,
      then it will be extended with some indication of the current location in
      the code, as described for &quot;mess_sv&quot;.
    <p class="Pp">Normally, the resulting message is returned in a new mortal
        SV. During global destruction a single SV may be shared between uses of
        this function.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV *    mess(const char *pat, ...)
    </pre>
  </dd>
  <dt>mess_sv</dt>
  <dd>Expands a message, intended for the user, to include an indication of the
      current location in the code, if the message does not already appear to be
      complete.
    <p class="Pp"><span class="Li">&quot;basemsg&quot;</span> is the initial
        message or object. If it is a reference, it will be used as-is and will
        be the result of this function. Otherwise it is used as a string, and if
        it already ends with a newline, it is taken to be complete, and the
        result of this function will be the same string. If the message does not
        end with a newline, then a segment such as
        <span class="Li">&quot;at</span> <span class="Li">foo.pl line
        37&quot;</span> will be appended, and possibly other clauses indicating
        the current state of execution. The resulting message will end with a
        dot and a newline.</p>
    <p class="Pp">Normally, the resulting message is returned in a new mortal
        SV. During global destruction a single SV may be shared between uses of
        this function. If <span class="Li">&quot;consume&quot;</span> is true,
        then the function is permitted (but not required) to modify and return
        <span class="Li">&quot;basemsg&quot;</span> instead of allocating a new
        SV.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV *    mess_sv(SV *basemsg, bool consume)
    </pre>
  </dd>
  <dt>my_snprintf</dt>
  <dd>The C library <span class="Li">&quot;snprintf&quot;</span> functionality,
      if available and standards-compliant (uses
      <span class="Li">&quot;vsnprintf&quot;</span>, actually). However, if the
      <span class="Li">&quot;vsnprintf&quot;</span> is not available, will
      unfortunately use the unsafe <span class="Li">&quot;vsprintf&quot;</span>
      which can overrun the buffer (there is an overrun check, but that may be
      too late). Consider using <span class="Li">&quot;sv_vcatpvf&quot;</span>
      instead, or getting <span class="Li">&quot;vsnprintf&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        int     my_snprintf(char *buffer, const Size_t len,
                            const char *format, ...)
    </pre>
  </dd>
  <dt>my_sprintf</dt>
  <dd>The C library <span class="Li">&quot;sprintf&quot;</span>, wrapped if
      necessary, to ensure that it will return the length of the string written
      to the buffer. Only rare pre-ANSI systems need the wrapper function -
      usually this is a direct call to
      <span class="Li">&quot;sprintf&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        int     my_sprintf(char *buffer, const char *pat, ...)
    </pre>
  </dd>
  <dt>my_vsnprintf</dt>
  <dd>The C library <span class="Li">&quot;vsnprintf&quot;</span> if available
      and standards-compliant. However, if if the
      <span class="Li">&quot;vsnprintf&quot;</span> is not available, will
      unfortunately use the unsafe <span class="Li">&quot;vsprintf&quot;</span>
      which can overrun the buffer (there is an overrun check, but that may be
      too late). Consider using <span class="Li">&quot;sv_vcatpvf&quot;</span>
      instead, or getting <span class="Li">&quot;vsnprintf&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        int     my_vsnprintf(char *buffer, const Size_t len,
                             const char *format, va_list ap)
    </pre>
  </dd>
  <dt>new_version</dt>
  <dd>Returns a new version object based on the passed in SV:
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    SV *sv = new_version(SV *ver);
    </pre>
    <p class="Pp">Does not alter the passed in ver SV. See
        &quot;upg_version&quot; if you want to upgrade the SV.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV*     new_version(SV *ver)
    </pre>
  </dd>
  <dt>prescan_version</dt>
  <dd>Validate that a given string can be parsed as a version object, but
      doesn't actually perform the parsing. Can use either strict or lax
      validation rules. Can optionally set a number of hint variables to save
      the parsing code some time when tokenizing.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        const char* prescan_version(const char *s, bool strict,
                                    const char** errstr,
                                    bool *sqv,
                                    int *ssaw_decimal,
                                    int *swidth, bool *salpha)
    </pre>
  </dd>
  <dt>READ_XDIGIT </dt>
  <dd>Returns the value of an ASCII-range hex digit and advances the string
      pointer. Behaviour is only well defined when isXDIGIT(*str) is true.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        U8      READ_XDIGIT(char str*)
    </pre>
  </dd>
  <dt>scan_version</dt>
  <dd>Returns a pointer to the next character after the parsed version string,
      as well as upgrading the passed in SV to an RV.
    <p class="Pp">Function must be called with an already existing SV like</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    sv = newSV(0);
    s = scan_version(s, SV *sv, bool qv);
    </pre>
    <p class="Pp">Performs some preprocessing to the string to ensure that it
        has the correct characteristics of a version. Flags the object if it
        contains an underscore (which denotes this is an alpha version). The
        boolean qv denotes that the version should be interpreted as if it had
        multiple decimals, even if it doesn't.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        const char* scan_version(const char *s, SV *rv, bool qv)
    </pre>
  </dd>
  <dt>strEQ</dt>
  <dd>Test two strings to see if they are equal. Returns true or false.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    strEQ(char* s1, char* s2)
    </pre>
  </dd>
  <dt>strGE</dt>
  <dd>Test two strings to see if the first,
      <span class="Li">&quot;s1&quot;</span>, is greater than or equal to the
      second, <span class="Li">&quot;s2&quot;</span>. Returns true or false.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    strGE(char* s1, char* s2)
    </pre>
  </dd>
  <dt>strGT</dt>
  <dd>Test two strings to see if the first,
      <span class="Li">&quot;s1&quot;</span>, is greater than the second,
      <span class="Li">&quot;s2&quot;</span>. Returns true or false.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    strGT(char* s1, char* s2)
    </pre>
  </dd>
  <dt>strLE</dt>
  <dd>Test two strings to see if the first,
      <span class="Li">&quot;s1&quot;</span>, is less than or equal to the
      second, <span class="Li">&quot;s2&quot;</span>. Returns true or false.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    strLE(char* s1, char* s2)
    </pre>
  </dd>
  <dt>strLT</dt>
  <dd>Test two strings to see if the first,
      <span class="Li">&quot;s1&quot;</span>, is less than the second,
      <span class="Li">&quot;s2&quot;</span>. Returns true or false.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    strLT(char* s1, char* s2)
    </pre>
  </dd>
  <dt>strNE</dt>
  <dd>Test two strings to see if they are different. Returns true or false.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    strNE(char* s1, char* s2)
    </pre>
  </dd>
  <dt>strnEQ</dt>
  <dd>Test two strings to see if they are equal. The
      <span class="Li">&quot;len&quot;</span> parameter indicates the number of
      bytes to compare. Returns true or false. (A wrapper for
      <span class="Li">&quot;strncmp&quot;</span>).
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    strnEQ(char* s1, char* s2, STRLEN len)
    </pre>
  </dd>
  <dt>strnNE</dt>
  <dd>Test two strings to see if they are different. The
      <span class="Li">&quot;len&quot;</span> parameter indicates the number of
      bytes to compare. Returns true or false. (A wrapper for
      <span class="Li">&quot;strncmp&quot;</span>).
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    strnNE(char* s1, char* s2, STRLEN len)
    </pre>
  </dd>
  <dt>sv_destroyable</dt>
  <dd>Dummy routine which reports that object can be destroyed when there is no
      sharing module present. It ignores its single SV argument, and returns
      'true'. Exists to avoid test for a NULL function pointer and because it
      could potentially warn under some level of strict-ness.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    sv_destroyable(SV *sv)
    </pre>
  </dd>
  <dt>sv_nosharing</dt>
  <dd>Dummy routine which &quot;shares&quot; an SV when there is no sharing
      module present. Or &quot;locks&quot; it. Or &quot;unlocks&quot; it. In
      other words, ignores its single SV argument. Exists to avoid test for a
      NULL function pointer and because it could potentially warn under some
      level of strict-ness.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_nosharing(SV *sv)
    </pre>
  </dd>
  <dt>upg_version</dt>
  <dd>In-place upgrade of the supplied SV to a version object.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    SV *sv = upg_version(SV *sv, bool qv);
    </pre>
    <p class="Pp">Returns a pointer to the upgraded SV. Set the boolean qv if
        you want to force this SV to be interpreted as an &quot;extended&quot;
        version.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV*     upg_version(SV *ver, bool qv)
    </pre>
  </dd>
  <dt>vcmp</dt>
  <dd>Version object aware cmp. Both operands must already have been converted
      into version objects.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        int     vcmp(SV *lhv, SV *rhv)
    </pre>
  </dd>
  <dt>vmess</dt>
  <dd><span class="Li">&quot;pat&quot;</span> and
      <span class="Li">&quot;args&quot;</span> are a sprintf-style format
      pattern and encapsulated argument list. These are used to generate a
      string message. If the message does not end with a newline, then it will
      be extended with some indication of the current location in the code, as
      described for &quot;mess_sv&quot;.
    <p class="Pp">Normally, the resulting message is returned in a new mortal
        SV. During global destruction a single SV may be shared between uses of
        this function.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV *    vmess(const char *pat, va_list *args)
    </pre>
  </dd>
  <dt>vnormal</dt>
  <dd>Accepts a version object and returns the normalized string representation.
      Call like:
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    sv = vnormal(rv);
    </pre>
    <p class="Pp">NOTE: you can pass either the object directly or the SV
        contained within the RV.</p>
    <p class="Pp">The SV returned has a refcount of 1.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV*     vnormal(SV *vs)
    </pre>
  </dd>
  <dt>vnumify</dt>
  <dd>Accepts a version object and returns the normalized floating point
      representation. Call like:
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    sv = vnumify(rv);
    </pre>
    <p class="Pp">NOTE: you can pass either the object directly or the SV
        contained within the RV.</p>
    <p class="Pp">The SV returned has a refcount of 1.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV*     vnumify(SV *vs)
    </pre>
  </dd>
  <dt>vstringify</dt>
  <dd>In order to maintain maximum compatibility with earlier versions of Perl,
      this function will return either the floating point notation or the
      multiple dotted notation, depending on whether the original version
      contained 1 or more dots, respectively.
    <p class="Pp">The SV returned has a refcount of 1.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV*     vstringify(SV *vs)
    </pre>
  </dd>
  <dt>vverify</dt>
  <dd>Validates that the SV contains valid internal structure for a version
      object. It may be passed either the version object (RV) or the hash itself
      (HV). If the structure is valid, it returns the HV. If the structure is
      invalid, it returns NULL.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    SV *hv = vverify(sv);
    </pre>
    <p class="Pp">Note that it only confirms the bare minimum structure (so as
        not to get confused by derived classes which may contain additional hash
        entries):</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV*     vverify(SV *vs)
    </pre>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="MRO_Functions"><a class="permalink" href="#MRO_Functions">MRO
  Functions</a></h1>
<dl class="Bl-tag">
  <dt>mro_get_linear_isa</dt>
  <dd>Returns the mro linearisation for the given stash. By default, this will
      be whatever <span class="Li">&quot;mro_get_linear_isa_dfs&quot;</span>
      returns unless some other MRO is in effect for the stash. The return value
      is a read-only AV*.
    <p class="Pp">You are responsible for
        <span class="Li">&quot;SvREFCNT_inc()&quot;</span> on the return value
        if you plan to store it anywhere semi-permanently (otherwise it might be
        deleted out from under you the next time the cache is invalidated).</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        AV*     mro_get_linear_isa(HV* stash)
    </pre>
  </dd>
  <dt>mro_method_changed_in</dt>
  <dd>Invalidates method caching on any child classes of the given stash, so
      that they might notice the changes in this one.
    <p class="Pp">Ideally, all instances of
        <span class="Li">&quot;PL_sub_generation++&quot;</span> in perl source
        outside of <i>mro.c</i> should be replaced by calls to this.</p>
    <p class="Pp">Perl automatically handles most of the common ways a method
        might be redefined. However, there are a few ways you could change a
        method in a stash without the cache code noticing, in which case you
        need to call this method afterwards:</p>
    <p class="Pp">1) Directly manipulating the stash HV entries from XS
      code.</p>
    <p class="Pp">2) Assigning a reference to a readonly scalar constant into a
        stash entry in order to create a constant subroutine (like constant.pm
        does).</p>
    <p class="Pp">This same method is available from pure perl via,
        <span class="Li">&quot;mro::method_changed_in(classname)&quot;</span>.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    mro_method_changed_in(HV* stash)
    </pre>
  </dd>
  <dt>mro_register</dt>
  <dd>Registers a custom mro plugin. See perlmroapi for details.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    mro_register(const struct mro_alg *mro)
    </pre>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="Multicall_Functions"><a class="permalink" href="#Multicall_Functions">Multicall
  Functions</a></h1>
<dl class="Bl-tag">
  <dt>dMULTICALL</dt>
  <dd>Declare local variables for a multicall. See &quot;LIGHTWEIGHT
      CALLBACKS&quot; in perlcall.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
                dMULTICALL;
    </pre>
  </dd>
  <dt>MULTICALL </dt>
  <dd>Make a lightweight callback. See &quot;LIGHTWEIGHT CALLBACKS&quot; in
      perlcall.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
                MULTICALL;
    </pre>
  </dd>
  <dt>POP_MULTICALL </dt>
  <dd>Closing bracket for a lightweight callback. See &quot;LIGHTWEIGHT
      CALLBACKS&quot; in perlcall.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
                POP_MULTICALL;
    </pre>
  </dd>
  <dt>PUSH_MULTICALL </dt>
  <dd>Opening bracket for a lightweight callback. See &quot;LIGHTWEIGHT
      CALLBACKS&quot; in perlcall.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
                PUSH_MULTICALL;
    </pre>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="Numeric_functions"><a class="permalink" href="#Numeric_functions">Numeric
  functions</a></h1>
<dl class="Bl-tag">
  <dt>grok_bin</dt>
  <dd>converts a string representing a binary number to numeric form.
    <p class="Pp">On entry <i>start</i> and <i>*len</i> give the string to scan,
        <i>*flags</i> gives conversion flags, and <i>result</i> should be NULL
        or a pointer to an NV. The scan stops at the end of the string, or the
        first invalid character. Unless
        <span class="Li">&quot;PERL_SCAN_SILENT_ILLDIGIT&quot;</span> is set in
        <i>*flags</i>, encountering an invalid character will also trigger a
        warning. On return <i>*len</i> is set to the length of the scanned
        string, and <i>*flags</i> gives output flags.</p>
    <p class="Pp">If the value is &lt;=
        <span class="Li">&quot;UV_MAX&quot;</span> it is returned as a UV, the
        output flags are clear, and nothing is written to <i>*result</i>. If the
        value is &gt; UV_MAX <span class="Li">&quot;grok_bin&quot;</span>
        returns UV_MAX, sets
        <span class="Li">&quot;PERL_SCAN_GREATER_THAN_UV_MAX&quot;</span> in the
        output flags, and writes the value to <i>*result</i> (or the value is
        discarded if <i>result</i> is NULL).</p>
    <p class="Pp">The binary number may optionally be prefixed with
        &quot;0b&quot; or &quot;b&quot; unless
        <span class="Li">&quot;PERL_SCAN_DISALLOW_PREFIX&quot;</span> is set in
        <i>*flags</i> on entry. If
        <span class="Li">&quot;PERL_SCAN_ALLOW_UNDERSCORES&quot;</span> is set
        in <i>*flags</i> then the binary number may use '_' characters to
        separate digits.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        UV      grok_bin(const char* start, STRLEN* len_p,
                         I32* flags, NV *result)
    </pre>
  </dd>
  <dt>grok_hex</dt>
  <dd>converts a string representing a hex number to numeric form.
    <p class="Pp">On entry <i>start</i> and <i>*len</i> give the string to scan,
        <i>*flags</i> gives conversion flags, and <i>result</i> should be NULL
        or a pointer to an NV. The scan stops at the end of the string, or the
        first invalid character. Unless
        <span class="Li">&quot;PERL_SCAN_SILENT_ILLDIGIT&quot;</span> is set in
        <i>*flags</i>, encountering an invalid character will also trigger a
        warning. On return <i>*len</i> is set to the length of the scanned
        string, and <i>*flags</i> gives output flags.</p>
    <p class="Pp">If the value is &lt;= UV_MAX it is returned as a UV, the
        output flags are clear, and nothing is written to <i>*result</i>. If the
        value is &gt; UV_MAX <span class="Li">&quot;grok_hex&quot;</span>
        returns UV_MAX, sets
        <span class="Li">&quot;PERL_SCAN_GREATER_THAN_UV_MAX&quot;</span> in the
        output flags, and writes the value to <i>*result</i> (or the value is
        discarded if <i>result</i> is NULL).</p>
    <p class="Pp">The hex number may optionally be prefixed with &quot;0x&quot;
        or &quot;x&quot; unless
        <span class="Li">&quot;PERL_SCAN_DISALLOW_PREFIX&quot;</span> is set in
        <i>*flags</i> on entry. If
        <span class="Li">&quot;PERL_SCAN_ALLOW_UNDERSCORES&quot;</span> is set
        in <i>*flags</i> then the hex number may use '_' characters to separate
        digits.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        UV      grok_hex(const char* start, STRLEN* len_p,
                         I32* flags, NV *result)
    </pre>
  </dd>
  <dt>grok_number</dt>
  <dd>Recognise (or not) a number. The type of the number is returned (0 if
      unrecognised), otherwise it is a bit-ORed combination of IS_NUMBER_IN_UV,
      IS_NUMBER_GREATER_THAN_UV_MAX, IS_NUMBER_NOT_INT, IS_NUMBER_NEG,
      IS_NUMBER_INFINITY, IS_NUMBER_NAN (defined in perl.h).
    <p class="Pp">If the value of the number can fit an in UV, it is returned in
        the *valuep IS_NUMBER_IN_UV will be set to indicate that *valuep is
        valid, IS_NUMBER_IN_UV will never be set unless *valuep is valid, but
        *valuep may have been assigned to during processing even though
        IS_NUMBER_IN_UV is not set on return. If valuep is NULL, IS_NUMBER_IN_UV
        will be set for the same cases as when valuep is non-NULL, but no actual
        assignment (or SEGV) will occur.</p>
    <p class="Pp">IS_NUMBER_NOT_INT will be set with IS_NUMBER_IN_UV if trailing
        decimals were seen (in which case *valuep gives the true value truncated
        to an integer), and IS_NUMBER_NEG if the number is negative (in which
        case *valuep holds the absolute value). IS_NUMBER_IN_UV is not set if e
        notation was used or the number is larger than a UV.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        int     grok_number(const char *pv, STRLEN len,
                            UV *valuep)
    </pre>
  </dd>
  <dt>grok_numeric_radix</dt>
  <dd>Scan and skip for a numeric decimal separator (radix).
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    grok_numeric_radix(const char **sp,
                                   const char *send)
    </pre>
  </dd>
  <dt>grok_oct</dt>
  <dd>converts a string representing an octal number to numeric form.
    <p class="Pp">On entry <i>start</i> and <i>*len</i> give the string to scan,
        <i>*flags</i> gives conversion flags, and <i>result</i> should be NULL
        or a pointer to an NV. The scan stops at the end of the string, or the
        first invalid character. Unless
        <span class="Li">&quot;PERL_SCAN_SILENT_ILLDIGIT&quot;</span> is set in
        <i>*flags</i>, encountering an 8 or 9 will also trigger a warning. On
        return <i>*len</i> is set to the length of the scanned string, and
        <i>*flags</i> gives output flags.</p>
    <p class="Pp">If the value is &lt;= UV_MAX it is returned as a UV, the
        output flags are clear, and nothing is written to <i>*result</i>. If the
        value is &gt; UV_MAX <span class="Li">&quot;grok_oct&quot;</span>
        returns UV_MAX, sets
        <span class="Li">&quot;PERL_SCAN_GREATER_THAN_UV_MAX&quot;</span> in the
        output flags, and writes the value to <i>*result</i> (or the value is
        discarded if <i>result</i> is NULL).</p>
    <p class="Pp">If
        <span class="Li">&quot;PERL_SCAN_ALLOW_UNDERSCORES&quot;</span> is set
        in <i>*flags</i> then the octal number may use '_' characters to
        separate digits.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        UV      grok_oct(const char* start, STRLEN* len_p,
                         I32* flags, NV *result)
    </pre>
  </dd>
  <dt>Perl_signbit</dt>
  <dd>Return a non-zero integer if the sign bit on an NV is set, and 0 if it is
      not.
    <p class="Pp">If Configure detects this system has a <i>signbit()</i> that
        will work with our NVs, then we just use it via the #define in perl.h.
        Otherwise, fall back on this implementation. As a first pass, this gets
        everything right except -0.0. Alas, catching -0.0 is the main use for
        this function, so this is not too helpful yet. Still, at least we have
        the scaffolding in place to support other systems, should that prove
        useful.</p>
    <p class="Pp">Configure notes: This function is called 'Perl_signbit'
        instead of a plain 'signbit' because it is easy to imagine a system
        having a <i>signbit()</i> function or macro that doesn't happen to work
        with our particular choice of NVs. We shouldn't just re-#define signbit
        as Perl_signbit and expect the standard system headers to be happy.
        Also, this is a no-context function (no pTHX_) because
        <i>Perl_signbit()</i> is usually re-#defined in perl.h as a simple macro
        call to the system's <i>signbit()</i>. Users should just always call
        <i>Perl_signbit()</i>.</p>
    <p class="Pp">NOTE: this function is experimental and may change or be
        removed without notice.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        int     Perl_signbit(NV f)
    </pre>
  </dd>
  <dt>scan_bin</dt>
  <dd>For backwards compatibility. Use
      <span class="Li">&quot;grok_bin&quot;</span> instead.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        NV      scan_bin(const char* start, STRLEN len,
                         STRLEN* retlen)
    </pre>
  </dd>
  <dt>scan_hex</dt>
  <dd>For backwards compatibility. Use
      <span class="Li">&quot;grok_hex&quot;</span> instead.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        NV      scan_hex(const char* start, STRLEN len,
                         STRLEN* retlen)
    </pre>
  </dd>
  <dt>scan_oct</dt>
  <dd>For backwards compatibility. Use
      <span class="Li">&quot;grok_oct&quot;</span> instead.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        NV      scan_oct(const char* start, STRLEN len,
                         STRLEN* retlen)
    </pre>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="Optree_construction"><a class="permalink" href="#Optree_construction">Optree
  construction</a></h1>
<dl class="Bl-tag">
  <dt>newASSIGNOP</dt>
  <dd>Constructs, checks, and returns an assignment op. <i>left</i> and
      <i>right</i> supply the parameters of the assignment; they are consumed by
      this function and become part of the constructed op tree.
    <p class="Pp">If <i>optype</i> is
        <span class="Li">&quot;OP_ANDASSIGN&quot;</span>,
        <span class="Li">&quot;OP_ORASSIGN&quot;</span>, or
        <span class="Li">&quot;OP_DORASSIGN&quot;</span>, then a suitable
        conditional optree is constructed. If <i>optype</i> is the opcode of a
        binary operator, such as <span class="Li">&quot;OP_BIT_OR&quot;</span>,
        then an op is constructed that performs the binary operation and assigns
        the result to the left argument. Either way, if <i>optype</i> is
        non-zero then <i>flags</i> has no effect.</p>
    <p class="Pp">If <i>optype</i> is zero, then a plain scalar or list
        assignment is constructed. Which type of assignment it is is
        automatically determined. <i>flags</i> gives the eight bits of
        <span class="Li">&quot;op_flags&quot;</span>, except that
        <span class="Li">&quot;OPf_KIDS&quot;</span> will be set automatically,
        and, shifted up eight bits, the eight bits of
        <span class="Li">&quot;op_private&quot;</span>, except that the bit with
        value 1 or 2 is automatically set as required.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        OP *    newASSIGNOP(I32 flags, OP *left, I32 optype,
                            OP *right)
    </pre>
  </dd>
  <dt>newBINOP</dt>
  <dd>Constructs, checks, and returns an op of any binary type. <i>type</i> is
      the opcode. <i>flags</i> gives the eight bits of
      <span class="Li">&quot;op_flags&quot;</span>, except that
      <span class="Li">&quot;OPf_KIDS&quot;</span> will be set automatically,
      and, shifted up eight bits, the eight bits of
      <span class="Li">&quot;op_private&quot;</span>, except that the bit with
      value 1 or 2 is automatically set as required. <i>first</i> and
      <i>last</i> supply up to two ops to be the direct children of the binary
      op; they are consumed by this function and become part of the constructed
      op tree.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        OP *    newBINOP(I32 type, I32 flags, OP *first,
                         OP *last)
    </pre>
  </dd>
  <dt>newCONDOP</dt>
  <dd>Constructs, checks, and returns a conditional-expression
      (<span class="Li">&quot;cond_expr&quot;</span>) op. <i>flags</i> gives the
      eight bits of <span class="Li">&quot;op_flags&quot;</span>, except that
      <span class="Li">&quot;OPf_KIDS&quot;</span> will be set automatically,
      and, shifted up eight bits, the eight bits of
      <span class="Li">&quot;op_private&quot;</span>, except that the bit with
      value 1 is automatically set. <i>first</i> supplies the expression
      selecting between the two branches, and <i>trueop</i> and <i>falseop</i>
      supply the branches; they are consumed by this function and become part of
      the constructed op tree.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        OP *    newCONDOP(I32 flags, OP *first, OP *trueop,
                          OP *falseop)
    </pre>
  </dd>
  <dt>newFOROP</dt>
  <dd>Constructs, checks, and returns an op tree expressing a
      <span class="Li">&quot;foreach&quot;</span> loop (iteration through a list
      of values). This is a heavyweight loop, with structure that allows exiting
      the loop by <span class="Li">&quot;last&quot;</span> and suchlike.
    <p class="Pp"><i>sv</i> optionally supplies the variable that will be
        aliased to each item in turn; if null, it defaults to
        <span class="Li">$_</span> (either lexical or global). <i>expr</i>
        supplies the list of values to iterate over. <i>block</i> supplies the
        main body of the loop, and <i>cont</i> optionally supplies a
        <span class="Li">&quot;continue&quot;</span> block that operates as a
        second half of the body. All of these optree inputs are consumed by this
        function and become part of the constructed op tree.</p>
    <p class="Pp"><i>flags</i> gives the eight bits of
        <span class="Li">&quot;op_flags&quot;</span> for the
        <span class="Li">&quot;leaveloop&quot;</span> op and, shifted up eight
        bits, the eight bits of <span class="Li">&quot;op_private&quot;</span>
        for the <span class="Li">&quot;leaveloop&quot;</span> op, except that
        (in both cases) some bits will be set automatically.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        OP *    newFOROP(I32 flags, OP *sv, OP *expr, OP *block,
                         OP *cont)
    </pre>
  </dd>
  <dt>newGIVENOP</dt>
  <dd>Constructs, checks, and returns an op tree expressing a
      <span class="Li">&quot;given&quot;</span> block. <i>cond</i> supplies the
      expression that will be locally assigned to a lexical variable, and
      <i>block</i> supplies the body of the
      <span class="Li">&quot;given&quot;</span> construct; they are consumed by
      this function and become part of the constructed op tree. <i>defsv_off</i>
      is the pad offset of the scalar lexical variable that will be affected. If
      it is 0, the global <span class="Li">$_</span> will be used.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        OP *    newGIVENOP(OP *cond, OP *block,
                           PADOFFSET defsv_off)
    </pre>
  </dd>
  <dt>newGVOP</dt>
  <dd>Constructs, checks, and returns an op of any type that involves an
      embedded reference to a GV. <i>type</i> is the opcode. <i>flags</i> gives
      the eight bits of <span class="Li">&quot;op_flags&quot;</span>. <i>gv</i>
      identifies the GV that the op should reference; calling this function does
      not transfer ownership of any reference to it.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        OP *    newGVOP(I32 type, I32 flags, GV *gv)
    </pre>
  </dd>
  <dt>newLISTOP</dt>
  <dd>Constructs, checks, and returns an op of any list type. <i>type</i> is the
      opcode. <i>flags</i> gives the eight bits of
      <span class="Li">&quot;op_flags&quot;</span>, except that
      <span class="Li">&quot;OPf_KIDS&quot;</span> will be set automatically if
      required. <i>first</i> and <i>last</i> supply up to two ops to be direct
      children of the list op; they are consumed by this function and become
      part of the constructed op tree.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        OP *    newLISTOP(I32 type, I32 flags, OP *first,
                          OP *last)
    </pre>
  </dd>
  <dt>newLOGOP</dt>
  <dd>Constructs, checks, and returns a logical (flow control) op. <i>type</i>
      is the opcode. <i>flags</i> gives the eight bits of
      <span class="Li">&quot;op_flags&quot;</span>, except that
      <span class="Li">&quot;OPf_KIDS&quot;</span> will be set automatically,
      and, shifted up eight bits, the eight bits of
      <span class="Li">&quot;op_private&quot;</span>, except that the bit with
      value 1 is automatically set. <i>first</i> supplies the expression
      controlling the flow, and <i>other</i> supplies the side (alternate) chain
      of ops; they are consumed by this function and become part of the
      constructed op tree.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        OP *    newLOGOP(I32 type, I32 flags, OP *first,
                         OP *other)
    </pre>
  </dd>
  <dt>newLOOPEX</dt>
  <dd>Constructs, checks, and returns a loop-exiting op (such as
      <span class="Li">&quot;goto&quot;</span> or
      <span class="Li">&quot;last&quot;</span>). <i>type</i> is the opcode.
      <i>label</i> supplies the parameter determining the target of the op; it
      is consumed by this function and becomes part of the constructed op tree.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        OP *    newLOOPEX(I32 type, OP *label)
    </pre>
  </dd>
  <dt>newLOOPOP</dt>
  <dd>Constructs, checks, and returns an op tree expressing a loop. This is only
      a loop in the control flow through the op tree; it does not have the
      heavyweight loop structure that allows exiting the loop by
      <span class="Li">&quot;last&quot;</span> and suchlike. <i>flags</i> gives
      the eight bits of <span class="Li">&quot;op_flags&quot;</span> for the
      top-level op, except that some bits will be set automatically as required.
      <i>expr</i> supplies the expression controlling loop iteration, and
      <i>block</i> supplies the body of the loop; they are consumed by this
      function and become part of the constructed op tree. <i>debuggable</i> is
      currently unused and should always be 1.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        OP *    newLOOPOP(I32 flags, I32 debuggable, OP *expr,
                          OP *block)
    </pre>
  </dd>
  <dt>newNULLLIST</dt>
  <dd>Constructs, checks, and returns a new
      <span class="Li">&quot;stub&quot;</span> op, which represents an empty
      list expression.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        OP *    newNULLLIST()
    </pre>
  </dd>
  <dt>newOP</dt>
  <dd>Constructs, checks, and returns an op of any base type (any type that has
      no extra fields). <i>type</i> is the opcode. <i>flags</i> gives the eight
      bits of <span class="Li">&quot;op_flags&quot;</span>, and, shifted up
      eight bits, the eight bits of
      <span class="Li">&quot;op_private&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        OP *    newOP(I32 type, I32 flags)
    </pre>
  </dd>
  <dt>newPADOP</dt>
  <dd>Constructs, checks, and returns an op of any type that involves a
      reference to a pad element. <i>type</i> is the opcode. <i>flags</i> gives
      the eight bits of <span class="Li">&quot;op_flags&quot;</span>. A pad slot
      is automatically allocated, and is populated with <i>sv</i>; this function
      takes ownership of one reference to it.
    <p class="Pp">This function only exists if Perl has been compiled to use
        ithreads.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        OP *    newPADOP(I32 type, I32 flags, SV *sv)
    </pre>
  </dd>
  <dt>newPMOP</dt>
  <dd>Constructs, checks, and returns an op of any pattern matching type.
      <i>type</i> is the opcode. <i>flags</i> gives the eight bits of
      <span class="Li">&quot;op_flags&quot;</span> and, shifted up eight bits,
      the eight bits of <span class="Li">&quot;op_private&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        OP *    newPMOP(I32 type, I32 flags)
    </pre>
  </dd>
  <dt>newPVOP</dt>
  <dd>Constructs, checks, and returns an op of any type that involves an
      embedded C-level pointer (PV). <i>type</i> is the opcode. <i>flags</i>
      gives the eight bits of <span class="Li">&quot;op_flags&quot;</span>.
      <i>pv</i> supplies the C-level pointer, which must have been allocated
      using &quot;PerlMemShared_malloc&quot;; the memory will be freed when the
      op is destroyed.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        OP *    newPVOP(I32 type, I32 flags, char *pv)
    </pre>
  </dd>
  <dt>newRANGE</dt>
  <dd>Constructs and returns a <span class="Li">&quot;range&quot;</span> op,
      with subordinate <span class="Li">&quot;flip&quot;</span> and
      <span class="Li">&quot;flop&quot;</span> ops. <i>flags</i> gives the eight
      bits of <span class="Li">&quot;op_flags&quot;</span> for the
      <span class="Li">&quot;flip&quot;</span> op and, shifted up eight bits,
      the eight bits of <span class="Li">&quot;op_private&quot;</span> for both
      the <span class="Li">&quot;flip&quot;</span> and
      <span class="Li">&quot;range&quot;</span> ops, except that the bit with
      value 1 is automatically set. <i>left</i> and <i>right</i> supply the
      expressions controlling the endpoints of the range; they are consumed by
      this function and become part of the constructed op tree.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        OP *    newRANGE(I32 flags, OP *left, OP *right)
    </pre>
  </dd>
  <dt>newSLICEOP</dt>
  <dd>Constructs, checks, and returns an
      <span class="Li">&quot;lslice&quot;</span> (list slice) op. <i>flags</i>
      gives the eight bits of <span class="Li">&quot;op_flags&quot;</span>,
      except that <span class="Li">&quot;OPf_KIDS&quot;</span> will be set
      automatically, and, shifted up eight bits, the eight bits of
      <span class="Li">&quot;op_private&quot;</span>, except that the bit with
      value 1 or 2 is automatically set as required. <i>listval</i> and
      <i>subscript</i> supply the parameters of the slice; they are consumed by
      this function and become part of the constructed op tree.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        OP *    newSLICEOP(I32 flags, OP *subscript,
                           OP *listval)
    </pre>
  </dd>
  <dt>newSTATEOP</dt>
  <dd>Constructs a state op (COP). The state op is normally a
      <span class="Li">&quot;nextstate&quot;</span> op, but will be a
      <span class="Li">&quot;dbstate&quot;</span> op if debugging is enabled for
      currently-compiled code. The state op is populated from
      &quot;PL_curcop&quot; (or &quot;PL_compiling&quot;). If <i>label</i> is
      non-null, it supplies the name of a label to attach to the state op; this
      function takes ownership of the memory pointed at by <i>label</i>, and
      will free it. <i>flags</i> gives the eight bits of
      <span class="Li">&quot;op_flags&quot;</span> for the state op.
    <p class="Pp">If <i>o</i> is null, the state op is returned. Otherwise the
        state op is combined with <i>o</i> into a
        <span class="Li">&quot;lineseq&quot;</span> list op, which is returned.
        <i>o</i> is consumed by this function and becomes part of the returned
        op tree.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        OP *    newSTATEOP(I32 flags, char *label, OP *o)
    </pre>
  </dd>
  <dt>newSVOP</dt>
  <dd>Constructs, checks, and returns an op of any type that involves an
      embedded SV. <i>type</i> is the opcode. <i>flags</i> gives the eight bits
      of <span class="Li">&quot;op_flags&quot;</span>. <i>sv</i> gives the SV to
      embed in the op; this function takes ownership of one reference to it.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        OP *    newSVOP(I32 type, I32 flags, SV *sv)
    </pre>
  </dd>
  <dt>newUNOP</dt>
  <dd>Constructs, checks, and returns an op of any unary type. <i>type</i> is
      the opcode. <i>flags</i> gives the eight bits of
      <span class="Li">&quot;op_flags&quot;</span>, except that
      <span class="Li">&quot;OPf_KIDS&quot;</span> will be set automatically if
      required, and, shifted up eight bits, the eight bits of
      <span class="Li">&quot;op_private&quot;</span>, except that the bit with
      value 1 is automatically set. <i>first</i> supplies an optional op to be
      the direct child of the unary op; it is consumed by this function and
      become part of the constructed op tree.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        OP *    newUNOP(I32 type, I32 flags, OP *first)
    </pre>
  </dd>
  <dt>newWHENOP</dt>
  <dd>Constructs, checks, and returns an op tree expressing a
      <span class="Li">&quot;when&quot;</span> block. <i>cond</i> supplies the
      test expression, and <i>block</i> supplies the block that will be executed
      if the test evaluates to true; they are consumed by this function and
      become part of the constructed op tree. <i>cond</i> will be interpreted
      DWIMically, often as a comparison against <span class="Li">$_</span>, and
      may be null to generate a <span class="Li">&quot;default&quot;</span>
      block.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        OP *    newWHENOP(OP *cond, OP *block)
    </pre>
  </dd>
  <dt>newWHILEOP</dt>
  <dd>Constructs, checks, and returns an op tree expressing a
      <span class="Li">&quot;while&quot;</span> loop. This is a heavyweight
      loop, with structure that allows exiting the loop by
      <span class="Li">&quot;last&quot;</span> and suchlike.
    <p class="Pp"><i>loop</i> is an optional preconstructed
        <span class="Li">&quot;enterloop&quot;</span> op to use in the loop; if
        it is null then a suitable op will be constructed automatically.
        <i>expr</i> supplies the loop's controlling expression. <i>block</i>
        supplies the main body of the loop, and <i>cont</i> optionally supplies
        a <span class="Li">&quot;continue&quot;</span> block that operates as a
        second half of the body. All of these optree inputs are consumed by this
        function and become part of the constructed op tree.</p>
    <p class="Pp"><i>flags</i> gives the eight bits of
        <span class="Li">&quot;op_flags&quot;</span> for the
        <span class="Li">&quot;leaveloop&quot;</span> op and, shifted up eight
        bits, the eight bits of <span class="Li">&quot;op_private&quot;</span>
        for the <span class="Li">&quot;leaveloop&quot;</span> op, except that
        (in both cases) some bits will be set automatically. <i>debuggable</i>
        is currently unused and should always be 1. <i>has_my</i> can be
        supplied as true to force the loop body to be enclosed in its own
      scope.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        OP *    newWHILEOP(I32 flags, I32 debuggable,
                           LOOP *loop, OP *expr, OP *block,
                           OP *cont, I32 has_my)
    </pre>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="Optree_Manipulation_Functions"><a class="permalink" href="#Optree_Manipulation_Functions">Optree
  Manipulation Functions</a></h1>
<dl class="Bl-tag">
  <dt>ck_entersub_args_list</dt>
  <dd>Performs the default fixup of the arguments part of an
      <span class="Li">&quot;entersub&quot;</span> op tree. This consists of
      applying list context to each of the argument ops. This is the standard
      treatment used on a call marked with
      <span class="Li">&quot;&amp;&quot;</span>, or a method call, or a call
      through a subroutine reference, or any other call where the callee can't
      be identified at compile time, or a call where the callee has no
      prototype.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        OP *    ck_entersub_args_list(OP *entersubop)
    </pre>
  </dd>
  <dt>ck_entersub_args_proto</dt>
  <dd>Performs the fixup of the arguments part of an
      <span class="Li">&quot;entersub&quot;</span> op tree based on a subroutine
      prototype. This makes various modifications to the argument ops, from
      applying context up to inserting
      <span class="Li">&quot;refgen&quot;</span> ops, and checking the number
      and syntactic types of arguments, as directed by the prototype. This is
      the standard treatment used on a subroutine call, not marked with
      <span class="Li">&quot;&amp;&quot;</span>, where the callee can be
      identified at compile time and has a prototype.
    <p class="Pp"><i>protosv</i> supplies the subroutine prototype to be applied
        to the call. It may be a normal defined scalar, of which the string
        value will be used. Alternatively, for convenience, it may be a
        subroutine object (a <span class="Li">&quot;CV*&quot;</span> that has
        been cast to <span class="Li">&quot;SV*&quot;</span>) which has a
        prototype. The prototype supplied, in whichever form, does not need to
        match the actual callee referenced by the op tree.</p>
    <p class="Pp">If the argument ops disagree with the prototype, for example
        by having an unacceptable number of arguments, a valid op tree is
        returned anyway. The error is reflected in the parser state, normally
        resulting in a single exception at the top level of parsing which covers
        all the compilation errors that occurred. In the error message, the
        callee is referred to by the name defined by the <i>namegv</i>
        parameter.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        OP *    ck_entersub_args_proto(OP *entersubop,
                                       GV *namegv, SV *protosv)
    </pre>
  </dd>
  <dt>ck_entersub_args_proto_or_list</dt>
  <dd>Performs the fixup of the arguments part of an
      <span class="Li">&quot;entersub&quot;</span> op tree either based on a
      subroutine prototype or using default list-context processing. This is the
      standard treatment used on a subroutine call, not marked with
      <span class="Li">&quot;&amp;&quot;</span>, where the callee can be
      identified at compile time.
    <p class="Pp"><i>protosv</i> supplies the subroutine prototype to be applied
        to the call, or indicates that there is no prototype. It may be a normal
        scalar, in which case if it is defined then the string value will be
        used as a prototype, and if it is undefined then there is no prototype.
        Alternatively, for convenience, it may be a subroutine object (a
        <span class="Li">&quot;CV*&quot;</span> that has been cast to
        <span class="Li">&quot;SV*&quot;</span>), of which the prototype will be
        used if it has one. The prototype (or lack thereof) supplied, in
        whichever form, does not need to match the actual callee referenced by
        the op tree.</p>
    <p class="Pp">If the argument ops disagree with the prototype, for example
        by having an unacceptable number of arguments, a valid op tree is
        returned anyway. The error is reflected in the parser state, normally
        resulting in a single exception at the top level of parsing which covers
        all the compilation errors that occurred. In the error message, the
        callee is referred to by the name defined by the <i>namegv</i>
        parameter.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        OP *    ck_entersub_args_proto_or_list(OP *entersubop,
                                               GV *namegv,
                                               SV *protosv)
    </pre>
  </dd>
  <dt>cv_const_sv</dt>
  <dd>If <span class="Li">&quot;cv&quot;</span> is a constant sub eligible for
      inlining. returns the constant value returned by the sub. Otherwise,
      returns NULL.
    <p class="Pp">Constant subs can be created with
        <span class="Li">&quot;newCONSTSUB&quot;</span> or as described in
        &quot;Constant Functions&quot; in perlsub.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV*     cv_const_sv(const CV *const cv)
    </pre>
  </dd>
  <dt>cv_get_call_checker</dt>
  <dd>Retrieves the function that will be used to fix up a call to <i>cv</i>.
      Specifically, the function is applied to an
      <span class="Li">&quot;entersub&quot;</span> op tree for a subroutine
      call, not marked with <span class="Li">&quot;&amp;&quot;</span>, where the
      callee can be identified at compile time as <i>cv</i>.
    <p class="Pp">The C-level function pointer is returned in <i>*ckfun_p</i>,
        and an SV argument for it is returned in <i>*ckobj_p</i>. The function
        is intended to be called in this manner:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    entersubop = (*ckfun_p)(aTHX_ entersubop, namegv, (*ckobj_p));
    </pre>
    <p class="Pp">In this call, <i>entersubop</i> is a pointer to the
        <span class="Li">&quot;entersub&quot;</span> op, which may be replaced
        by the check function, and <i>namegv</i> is a GV supplying the name that
        should be used by the check function to refer to the callee of the
        <span class="Li">&quot;entersub&quot;</span> op if it needs to emit any
        diagnostics. It is permitted to apply the check function in non-standard
        situations, such as to a call to a different subroutine or to a method
        call.</p>
    <p class="Pp">By default, the function is
        Perl_ck_entersub_args_proto_or_list, and the SV parameter is <i>cv</i>
        itself. This implements standard prototype processing. It can be
        changed, for a particular subroutine, by
        &quot;cv_set_call_checker&quot;.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    cv_get_call_checker(CV *cv,
                                    Perl_call_checker *ckfun_p,
                                    SV **ckobj_p)
    </pre>
  </dd>
  <dt>cv_set_call_checker</dt>
  <dd>Sets the function that will be used to fix up a call to <i>cv</i>.
      Specifically, the function is applied to an
      <span class="Li">&quot;entersub&quot;</span> op tree for a subroutine
      call, not marked with <span class="Li">&quot;&amp;&quot;</span>, where the
      callee can be identified at compile time as <i>cv</i>.
    <p class="Pp">The C-level function pointer is supplied in <i>ckfun</i>, and
        an SV argument for it is supplied in <i>ckobj</i>. The function is
        intended to be called in this manner:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    entersubop = ckfun(aTHX_ entersubop, namegv, ckobj);
    </pre>
    <p class="Pp">In this call, <i>entersubop</i> is a pointer to the
        <span class="Li">&quot;entersub&quot;</span> op, which may be replaced
        by the check function, and <i>namegv</i> is a GV supplying the name that
        should be used by the check function to refer to the callee of the
        <span class="Li">&quot;entersub&quot;</span> op if it needs to emit any
        diagnostics. It is permitted to apply the check function in non-standard
        situations, such as to a call to a different subroutine or to a method
        call.</p>
    <p class="Pp">The current setting for a particular CV can be retrieved by
        &quot;cv_get_call_checker&quot;.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    cv_set_call_checker(CV *cv,
                                    Perl_call_checker ckfun,
                                    SV *ckobj)
    </pre>
  </dd>
  <dt>LINKLIST </dt>
  <dd>Given the root of an optree, link the tree in execution order using the
      <span class="Li">&quot;op_next&quot;</span> pointers and return the first
      op executed. If this has already been done, it will not be redone, and
      <span class="Li">&quot;o-&gt;op_next&quot;</span> will be returned. If
      <span class="Li">&quot;o-&gt;op_next&quot;</span> is not already set,
      <i>o</i> should be at least an <span class="Li">&quot;UNOP&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        OP*     LINKLIST(OP *o)
    </pre>
  </dd>
  <dt>newCONSTSUB</dt>
  <dd>See &quot;newCONSTSUB_flags&quot;.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        CV*     newCONSTSUB(HV* stash, const char* name, SV* sv)
    </pre>
  </dd>
  <dt>newCONSTSUB_flags</dt>
  <dd>Creates a constant sub equivalent to Perl <span class="Li">&quot;sub FOO
      () { 123 }&quot;</span> which is eligible for inlining at compile-time.
    <p class="Pp">Currently, the only useful value for
        <span class="Li">&quot;flags&quot;</span> is SVf_UTF8.</p>
    <p class="Pp">The newly created subroutine takes ownership of a reference to
        the passed in SV.</p>
    <p class="Pp">Passing NULL for SV creates a constant sub equivalent to
        <span class="Li">&quot;sub BAR () {}&quot;</span>, which won't be called
        if used as a destructor, but will suppress the overhead of a call to
        <span class="Li">&quot;AUTOLOAD&quot;</span>. (This form, however, isn't
        eligible for inlining at compile time.)</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        CV*     newCONSTSUB_flags(HV* stash, const char* name,
                                  STRLEN len, U32 flags, SV* sv)
    </pre>
  </dd>
  <dt>newXS</dt>
  <dd>Used by <span class="Li">&quot;xsubpp&quot;</span> to hook up XSUBs as
      Perl subs. <i>filename</i> needs to be static storage, as it is used
      directly as <i>CvFILE()</i>, without a copy being made.</dd>
  <dt>op_append_elem</dt>
  <dd>Append an item to the list of ops contained directly within a list-type
      op, returning the lengthened list. <i>first</i> is the list-type op, and
      <i>last</i> is the op to append to the list. <i>optype</i> specifies the
      intended opcode for the list. If <i>first</i> is not already a list of the
      right type, it will be upgraded into one. If either <i>first</i> or
      <i>last</i> is null, the other is returned unchanged.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        OP *    op_append_elem(I32 optype, OP *first, OP *last)
    </pre>
  </dd>
  <dt>op_append_list</dt>
  <dd>Concatenate the lists of ops contained directly within two list-type ops,
      returning the combined list. <i>first</i> and <i>last</i> are the
      list-type ops to concatenate. <i>optype</i> specifies the intended opcode
      for the list. If either <i>first</i> or <i>last</i> is not already a list
      of the right type, it will be upgraded into one. If either <i>first</i> or
      <i>last</i> is null, the other is returned unchanged.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        OP *    op_append_list(I32 optype, OP *first, OP *last)
    </pre>
  </dd>
  <dt>OP_CLASS </dt>
  <dd>Return the class of the provided OP: that is, which of the *OP structures
      it uses. For core ops this currently gets the information out of
      PL_opargs, which does not always accurately reflect the type used. For
      custom ops the type is returned from the registration, and it is up to the
      registree to ensure it is accurate. The value returned will be one of the
      OA_* constants from op.h.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        U32     OP_CLASS(OP *o)
    </pre>
  </dd>
  <dt>OP_DESC </dt>
  <dd>Return a short description of the provided OP.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        const char * OP_DESC(OP *o)
    </pre>
  </dd>
  <dt>op_linklist</dt>
  <dd>This function is the implementation of the &quot;LINKLIST&quot; macro. It
      should not be called directly.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        OP*     op_linklist(OP *o)
    </pre>
  </dd>
  <dt>op_lvalue</dt>
  <dd>Propagate lvalue (&quot;modifiable&quot;) context to an op and its
      children. <i>type</i> represents the context type, roughly based on the
      type of op that would do the modifying, although
      <span class="Li">&quot;local()&quot;</span> is represented by OP_NULL,
      because it has no op type of its own (it is signalled by a flag on the
      lvalue op).
    <p class="Pp">This function detects things that can't be modified, such as
        <span class="Li">&quot;$x+1&quot;</span>, and generates errors for them.
        For example, <span class="Li">&quot;$x+1 = 2&quot;</span> would cause it
        to be called with an op of type OP_ADD and a
        <span class="Li">&quot;type&quot;</span> argument of OP_SASSIGN.</p>
    <p class="Pp">It also flags things that need to behave specially in an
        lvalue context, such as <span class="Li">&quot;$$x = 5&quot;</span>
        which might have to vivify a reference in
      <span class="Li">$x</span>.</p>
    <p class="Pp">NOTE: this function is experimental and may change or be
        removed without notice.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        OP *    op_lvalue(OP *o, I32 type)
    </pre>
  </dd>
  <dt>OP_NAME </dt>
  <dd>Return the name of the provided OP. For core ops this looks up the name
      from the op_type; for custom ops from the op_ppaddr.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        const char * OP_NAME(OP *o)
    </pre>
  </dd>
  <dt>op_prepend_elem</dt>
  <dd>Prepend an item to the list of ops contained directly within a list-type
      op, returning the lengthened list. <i>first</i> is the op to prepend to
      the list, and <i>last</i> is the list-type op. <i>optype</i> specifies the
      intended opcode for the list. If <i>last</i> is not already a list of the
      right type, it will be upgraded into one. If either <i>first</i> or
      <i>last</i> is null, the other is returned unchanged.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        OP *    op_prepend_elem(I32 optype, OP *first, OP *last)
    </pre>
  </dd>
  <dt>op_scope</dt>
  <dd>Wraps up an op tree with some additional ops so that at runtime a dynamic
      scope will be created. The original ops run in the new dynamic scope, and
      then, provided that they exit normally, the scope will be unwound. The
      additional ops used to create and unwind the dynamic scope will normally
      be an
      <span class="Li">&quot;enter&quot;</span>/<span class="Li">&quot;leave&quot;</span>
      pair, but a <span class="Li">&quot;scope&quot;</span> op may be used
      instead if the ops are simple enough to not need the full dynamic scope
      structure.
    <p class="Pp">NOTE: this function is experimental and may change or be
        removed without notice.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        OP *    op_scope(OP *o)
    </pre>
  </dd>
  <dt>rv2cv_op_cv</dt>
  <dd>Examines an op, which is expected to identify a subroutine at runtime, and
      attempts to determine at compile time which subroutine it identifies. This
      is normally used during Perl compilation to determine whether a prototype
      can be applied to a function call. <i>cvop</i> is the op being considered,
      normally an <span class="Li">&quot;rv2cv&quot;</span> op. A pointer to the
      identified subroutine is returned, if it could be determined statically,
      and a null pointer is returned if it was not possible to determine
      statically.
    <p class="Pp">Currently, the subroutine can be identified statically if the
        RV that the <span class="Li">&quot;rv2cv&quot;</span> is to operate on
        is provided by a suitable <span class="Li">&quot;gv&quot;</span> or
        <span class="Li">&quot;const&quot;</span> op. A
        <span class="Li">&quot;gv&quot;</span> op is suitable if the GV's CV
        slot is populated. A <span class="Li">&quot;const&quot;</span> op is
        suitable if the constant value must be an RV pointing to a CV. Details
        of this process may change in future versions of Perl. If the
        <span class="Li">&quot;rv2cv&quot;</span> op has the
        <span class="Li">&quot;OPpENTERSUB_AMPER&quot;</span> flag set then no
        attempt is made to identify the subroutine statically: this flag is used
        to suppress compile-time magic on a subroutine call, forcing it to use
        default runtime behaviour.</p>
    <p class="Pp">If <i>flags</i> has the bit
        <span class="Li">&quot;RV2CVOPCV_MARK_EARLY&quot;</span> set, then the
        handling of a GV reference is modified. If a GV was examined and its CV
        slot was found to be empty, then the
        <span class="Li">&quot;gv&quot;</span> op has the
        <span class="Li">&quot;OPpEARLY_CV&quot;</span> flag set. If the op is
        not optimised away, and the CV slot is later populated with a subroutine
        having a prototype, that flag eventually triggers the warning
        &quot;called too early to check prototype&quot;.</p>
    <p class="Pp">If <i>flags</i> has the bit
        <span class="Li">&quot;RV2CVOPCV_RETURN_NAME_GV&quot;</span> set, then
        instead of returning a pointer to the subroutine it returns a pointer to
        the GV giving the most appropriate name for the subroutine in this
        context. Normally this is just the
        <span class="Li">&quot;CvGV&quot;</span> of the subroutine, but for an
        anonymous (<span class="Li">&quot;CvANON&quot;</span>) subroutine that
        is referenced through a GV it will be the referencing GV. The resulting
        <span class="Li">&quot;GV*&quot;</span> is cast to
        <span class="Li">&quot;CV*&quot;</span> to be returned. A null pointer
        is returned as usual if there is no statically-determinable
      subroutine.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        CV *    rv2cv_op_cv(OP *cvop, U32 flags)
    </pre>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="Pad_Data_Structures"><a class="permalink" href="#Pad_Data_Structures">Pad
  Data Structures</a></h1>
<dl class="Bl-tag">
  <dt>CvPADLIST</dt>
  <dd>CV's can have CvPADLIST(cv) set to point to a PADLIST. This is the CV's
      scratchpad, which stores lexical variables and opcode temporary and
      per-thread values.
    <p class="Pp">For these purposes &quot;formats&quot; are a kind-of CV;
        eval&quot;&quot;s are too (except they're not callable at will and are
        always thrown away after the eval&quot;&quot; is done executing).
        Require'd files are simply evals without any outer lexical scope.</p>
    <p class="Pp">XSUBs don't have CvPADLIST set - dXSTARG fetches values from
        PL_curpad, but that is really the callers pad (a slot of which is
        allocated by every entersub).</p>
    <p class="Pp">The PADLIST has a C array where pads are stored.</p>
    <p class="Pp">The 0th entry of the PADLIST is a PADNAMELIST (which is
        actually just an AV, but that may change) which represents the
        &quot;names&quot; or rather the &quot;static type information&quot; for
        lexicals. The individual elements of a PADNAMELIST are PADNAMEs (just
        SVs; but, again, that may change). Future refactorings might stop the
        PADNAMELIST from being stored in the PADLIST's array, so don't rely on
        it. See &quot;PadlistNAMES&quot;.</p>
    <p class="Pp">The CvDEPTH'th entry of a PADLIST is a PAD (an AV) which is
        the stack frame at that depth of recursion into the CV. The 0th slot of
        a frame AV is an AV which is <span class="Li">@_</span>. Other entries
        are storage for variables and op targets.</p>
    <p class="Pp">Iterating over the PADNAMELIST iterates over all possible pad
        items. Pad slots that are SVs_PADTMP (targets/GVs/constants) end up
        having &amp;PL_sv_undef &quot;names&quot; (see <i>pad_alloc()</i>).</p>
    <p class="Pp">Only my/our variable (SvPADMY/PADNAME_isOUR) slots get valid
        names. The rest are op targets/GVs/constants which are statically
        allocated or resolved at compile time. These don't have names by which
        they can be looked up from Perl code at run time through
        eval&quot;&quot; the way my/our variables can be. Since they can't be
        looked up by &quot;name&quot; but only by their index allocated at
        compile time (which is usually in PL_op-&gt;op_targ), wasting a name SV
        for them doesn't make sense.</p>
    <p class="Pp">The SVs in the names AV have their PV being the name of the
        variable. xlow+1..xhigh inclusive in the NV union is a range of cop_seq
        numbers for which the name is valid (accessed through the macros
        COP_SEQ_RANGE_LOW and _HIGH). During compilation, these fields may hold
        the special value PERL_PADSEQ_INTRO to indicate various stages:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
   COP_SEQ_RANGE_LOW        _HIGH
   -----------------        -----
   PERL_PADSEQ_INTRO            0   variable not yet introduced:   { my ($x
   valid-seq#   PERL_PADSEQ_INTRO   variable in scope:             { my ($x)
   valid-seq#          valid-seq#   compilation of scope complete: { my ($x) }
    </pre>
    <p class="Pp">For typed lexicals name SV is SVt_PVMG and SvSTASH points at
        the type. For <span class="Li">&quot;our&quot;</span> lexicals, the type
        is also SVt_PVMG, with the SvOURSTASH slot pointing at the stash of the
        associated global (so that duplicate
        <span class="Li">&quot;our&quot;</span> declarations in the same package
        can be detected). SvUVX is sometimes hijacked to store the generation
        number during compilation.</p>
    <p class="Pp">If PADNAME_OUTER (SvFAKE) is set on the name SV, then that
        slot in the frame AV is a REFCNT'ed reference to a lexical from
        &quot;outside&quot;. In this case, the name SV does not use xlow and
        xhigh to store a cop_seq range, since it is in scope throughout. Instead
        xhigh stores some flags containing info about the real lexical (is it
        declared in an anon, and is it capable of being instantiated multiple
        times?), and for fake ANONs, xlow contains the index within the parent's
        pad where the lexical's value is stored, to make cloning quicker.</p>
    <p class="Pp">If the 'name' is '&amp;' the corresponding entry in the PAD is
        a CV representing a possible closure. (PADNAME_OUTER and name of '&amp;'
        is not a meaningful combination currently but could become so if
        <span class="Li">&quot;my sub foo {}&quot;</span> is implemented.)</p>
    <p class="Pp">Note that formats are treated as anon subs, and are cloned
        each time write is called (if necessary).</p>
    <p class="Pp">The flag SVs_PADSTALE is cleared on lexicals each time the
        <i>my()</i> is executed, and set on scope exit. This allows the
        'Variable <span class="Li">$x</span> is not available' warning to be
        generated in evals, such as</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    { my $x = 1; sub f { eval '$x'} } f();
    </pre>
    <p class="Pp">For state vars, SVs_PADSTALE is overloaded to mean 'not yet
        initialised'.</p>
    <p class="Pp">NOTE: this function is experimental and may change or be
        removed without notice.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        PADLIST * CvPADLIST(CV *cv)
    </pre>
  </dd>
  <dt>PadARRAY</dt>
  <dd>The C array of pad entries.
    <p class="Pp">NOTE: this function is experimental and may change or be
        removed without notice.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV **   PadARRAY(PAD pad)
    </pre>
  </dd>
  <dt>PadlistARRAY</dt>
  <dd>The C array of a padlist, containing the pads. Only subscript it with
      numbers &gt;= 1, as the 0th entry is not guaranteed to remain usable.
    <p class="Pp">NOTE: this function is experimental and may change or be
        removed without notice.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        PAD **  PadlistARRAY(PADLIST padlist)
    </pre>
  </dd>
  <dt>PadlistMAX</dt>
  <dd>The index of the last pad in the padlist.
    <p class="Pp">NOTE: this function is experimental and may change or be
        removed without notice.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SSize_t PadlistMAX(PADLIST padlist)
    </pre>
  </dd>
  <dt>PadlistNAMES</dt>
  <dd>The names associated with pad entries.
    <p class="Pp">NOTE: this function is experimental and may change or be
        removed without notice.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        PADNAMELIST * PadlistNAMES(PADLIST padlist)
    </pre>
  </dd>
  <dt>PadlistNAMESARRAY</dt>
  <dd>The C array of pad names.
    <p class="Pp">NOTE: this function is experimental and may change or be
        removed without notice.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        PADNAME ** PadlistNAMESARRAY(PADLIST padlist)
    </pre>
  </dd>
  <dt>PadlistNAMESMAX</dt>
  <dd>The index of the last pad name.
    <p class="Pp">NOTE: this function is experimental and may change or be
        removed without notice.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SSize_t PadlistNAMESMAX(PADLIST padlist)
    </pre>
  </dd>
  <dt>PadlistREFCNT</dt>
  <dd>The reference count of the padlist. Currently this is always 1.
    <p class="Pp">NOTE: this function is experimental and may change or be
        removed without notice.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        U32     PadlistREFCNT(PADLIST padlist)
    </pre>
  </dd>
  <dt>PadMAX</dt>
  <dd>The index of the last pad entry.
    <p class="Pp">NOTE: this function is experimental and may change or be
        removed without notice.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SSize_t PadMAX(PAD pad)
    </pre>
  </dd>
  <dt>PadnameLEN</dt>
  <dd>The length of the name.
    <p class="Pp">NOTE: this function is experimental and may change or be
        removed without notice.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        STRLEN  PadnameLEN(PADNAME pn)
    </pre>
  </dd>
  <dt>PadnamelistARRAY</dt>
  <dd>The C array of pad names.
    <p class="Pp">NOTE: this function is experimental and may change or be
        removed without notice.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        PADNAME ** PadnamelistARRAY(PADNAMELIST pnl)
    </pre>
  </dd>
  <dt>PadnamelistMAX</dt>
  <dd>The index of the last pad name.
    <p class="Pp">NOTE: this function is experimental and may change or be
        removed without notice.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SSize_t PadnamelistMAX(PADNAMELIST pnl)
    </pre>
  </dd>
  <dt>PadnamePV</dt>
  <dd>The name stored in the pad name struct. This returns NULL for a target or
      GV slot.
    <p class="Pp">NOTE: this function is experimental and may change or be
        removed without notice.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        char *  PadnamePV(PADNAME pn)
    </pre>
  </dd>
  <dt>PadnameSV</dt>
  <dd>Returns the pad name as an SV. This is currently just
      <span class="Li">&quot;pn&quot;</span>. It will begin returning a new
      mortal SV if pad names ever stop being SVs.
    <p class="Pp">NOTE: this function is experimental and may change or be
        removed without notice.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV *    PadnameSV(PADNAME pn)
    </pre>
  </dd>
  <dt>PadnameUTF8</dt>
  <dd>Whether PadnamePV is in UTF8.
    <p class="Pp">NOTE: this function is experimental and may change or be
        removed without notice.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    PadnameUTF8(PADNAME pn)
    </pre>
  </dd>
  <dt>pad_add_name_pvs</dt>
  <dd>Exactly like &quot;pad_add_name_pvn&quot;, but takes a literal string
      instead of a string/length pair.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        PADOFFSET pad_add_name_pvs(const char *name, U32 flags,
                                   HV *typestash, HV *ourstash)
    </pre>
  </dd>
  <dt>pad_findmy_pvs</dt>
  <dd>Exactly like &quot;pad_findmy_pvn&quot;, but takes a literal string
      instead of a string/length pair.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        PADOFFSET pad_findmy_pvs(const char *name, U32 flags)
    </pre>
  </dd>
  <dt>pad_new</dt>
  <dd>Create a new padlist, updating the global variables for the
      currently-compiling padlist to point to the new padlist. The following
      flags can be OR'ed together:
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    padnew_CLONE        this pad is for a cloned CV
    padnew_SAVE         save old globals on the save stack
    padnew_SAVESUB      also save extra stuff for start of sub

        PADLIST * pad_new(int flags)
    </pre>
  </dd>
  <dt>PL_comppad</dt>
  <dd>During compilation, this points to the array containing the values part of
      the pad for the currently-compiling code. (At runtime a CV may have many
      such value arrays; at compile time just one is constructed.) At runtime,
      this points to the array containing the currently-relevant values for the
      pad for the currently-executing code.
    <p class="Pp">NOTE: this function is experimental and may change or be
        removed without notice.</p>
  </dd>
  <dt>PL_comppad_name</dt>
  <dd>During compilation, this points to the array containing the names part of
      the pad for the currently-compiling code.
    <p class="Pp">NOTE: this function is experimental and may change or be
        removed without notice.</p>
  </dd>
  <dt>PL_curpad</dt>
  <dd>Points directly to the body of the &quot;PL_comppad&quot; array. (I.e.,
      this is <span class="Li">&quot;PAD_ARRAY(PL_comppad)&quot;</span>.)
    <p class="Pp">NOTE: this function is experimental and may change or be
        removed without notice.</p>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="Per-Interpreter_Variables"><a class="permalink" href="#Per-Interpreter_Variables">Per-Interpreter
  Variables</a></h1>
<dl class="Bl-tag">
  <dt>PL_modglobal</dt>
  <dd><span class="Li">&quot;PL_modglobal&quot;</span> is a general purpose,
      interpreter global HV for use by extensions that need to keep information
      on a per-interpreter basis. In a pinch, it can also be used as a symbol
      table for extensions to share data among each other. It is a good idea to
      use keys prefixed by the package name of the extension that owns the data.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        HV*     PL_modglobal
    </pre>
  </dd>
  <dt>PL_na</dt>
  <dd>A convenience variable which is typically used with
      <span class="Li">&quot;SvPV&quot;</span> when one doesn't care about the
      length of the string. It is usually more efficient to either declare a
      local variable and use that instead or to use the
      <span class="Li">&quot;SvPV_nolen&quot;</span> macro.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        STRLEN  PL_na
    </pre>
  </dd>
  <dt>PL_opfreehook</dt>
  <dd>When non-<span class="Li">&quot;NULL&quot;</span>, the function pointed by
      this variable will be called each time an OP is freed with the
      corresponding OP as the argument. This allows extensions to free any extra
      attribute they have locally attached to an OP. It is also assured to first
      fire for the parent OP and then for its kids.
    <p class="Pp">When you replace this variable, it is considered a good
        practice to store the possibly previously installed hook and that you
        recall it inside your own.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        Perl_ophook_t   PL_opfreehook
    </pre>
  </dd>
  <dt>PL_peepp</dt>
  <dd>Pointer to the per-subroutine peephole optimiser. This is a function that
      gets called at the end of compilation of a Perl subroutine (or
      equivalently independent piece of Perl code) to perform fixups of some ops
      and to perform small-scale optimisations. The function is called once for
      each subroutine that is compiled, and is passed, as sole parameter, a
      pointer to the op that is the entry point to the subroutine. It modifies
      the op tree in place.
    <p class="Pp">The peephole optimiser should never be completely replaced.
        Rather, add code to it by wrapping the existing optimiser. The basic way
        to do this can be seen in &quot;Compile pass 3: peephole
        optimization&quot; in perlguts. If the new code wishes to operate on ops
        throughout the subroutine's structure, rather than just at the top
        level, it is likely to be more convenient to wrap the
        &quot;PL_rpeepp&quot; hook.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        peep_t  PL_peepp
    </pre>
  </dd>
  <dt>PL_rpeepp</dt>
  <dd>Pointer to the recursive peephole optimiser. This is a function that gets
      called at the end of compilation of a Perl subroutine (or equivalently
      independent piece of Perl code) to perform fixups of some ops and to
      perform small-scale optimisations. The function is called once for each
      chain of ops linked through their
      <span class="Li">&quot;op_next&quot;</span> fields; it is recursively
      called to handle each side chain. It is passed, as sole parameter, a
      pointer to the op that is at the head of the chain. It modifies the op
      tree in place.
    <p class="Pp">The peephole optimiser should never be completely replaced.
        Rather, add code to it by wrapping the existing optimiser. The basic way
        to do this can be seen in &quot;Compile pass 3: peephole
        optimization&quot; in perlguts. If the new code wishes to operate only
        on ops at a subroutine's top level, rather than throughout the
        structure, it is likely to be more convenient to wrap the
        &quot;PL_peepp&quot; hook.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        peep_t  PL_rpeepp
    </pre>
  </dd>
  <dt>PL_sv_no</dt>
  <dd>This is the <span class="Li">&quot;false&quot;</span> SV. See
      <span class="Li">&quot;PL_sv_yes&quot;</span>. Always refer to this as
      <span class="Li">&amp;PL_sv_no</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV      PL_sv_no
    </pre>
  </dd>
  <dt>PL_sv_undef</dt>
  <dd>This is the <span class="Li">&quot;undef&quot;</span> SV. Always refer to
      this as <span class="Li">&amp;PL_sv_undef</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV      PL_sv_undef
    </pre>
  </dd>
  <dt>PL_sv_yes</dt>
  <dd>This is the <span class="Li">&quot;true&quot;</span> SV. See
      <span class="Li">&quot;PL_sv_no&quot;</span>. Always refer to this as
      <span class="Li">&amp;PL_sv_yes</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV      PL_sv_yes
    </pre>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="REGEXP_Functions"><a class="permalink" href="#REGEXP_Functions">REGEXP
  Functions</a></h1>
<dl class="Bl-tag">
  <dt>SvRX</dt>
  <dd>Convenience macro to get the REGEXP from a SV. This is approximately
      equivalent to the following snippet:
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    if (SvMAGICAL(sv))
        mg_get(sv);
    if (SvROK(sv))
        sv = MUTABLE_SV(SvRV(sv));
    if (SvTYPE(sv) == SVt_REGEXP)
        return (REGEXP*) sv;
    </pre>
    <p class="Pp">NULL will be returned if a REGEXP* is not found.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        REGEXP * SvRX(SV *sv)
    </pre>
  </dd>
  <dt>SvRXOK</dt>
  <dd>Returns a boolean indicating whether the SV (or the one it references) is
      a REGEXP.
    <p class="Pp">If you want to do something with the REGEXP* later use SvRX
        instead and check for NULL.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    SvRXOK(SV* sv)
    </pre>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="Simple_Exception_Handling_Macros"><a class="permalink" href="#Simple_Exception_Handling_Macros">Simple
  Exception Handling Macros</a></h1>
<dl class="Bl-tag">
  <dt>dXCPT</dt>
  <dd>Set up necessary local variables for exception handling. See
      &quot;Exception Handling&quot; in perlguts.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
                dXCPT;
    </pre>
  </dd>
  <dt>XCPT_CATCH </dt>
  <dd>Introduces a catch block. See &quot;Exception Handling&quot; in
    perlguts.</dd>
  <dt>XCPT_RETHROW </dt>
  <dd>Rethrows a previously caught exception. See &quot;Exception Handling&quot;
      in perlguts.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
                XCPT_RETHROW;
    </pre>
  </dd>
  <dt>XCPT_TRY_END </dt>
  <dd>Ends a try block. See &quot;Exception Handling&quot; in perlguts.</dd>
  <dt>XCPT_TRY_START </dt>
  <dd>Starts a try block. See &quot;Exception Handling&quot; in perlguts.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="Stack_Manipulation_Macros"><a class="permalink" href="#Stack_Manipulation_Macros">Stack
  Manipulation Macros</a></h1>
<dl class="Bl-tag">
  <dt>dMARK</dt>
  <dd>Declare a stack marker variable, <span class="Li">&quot;mark&quot;</span>,
      for the XSUB. See <span class="Li">&quot;MARK&quot;</span> and
      <span class="Li">&quot;dORIGMARK&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
                dMARK;
    </pre>
  </dd>
  <dt>dORIGMARK</dt>
  <dd>Saves the original stack mark for the XSUB. See
      <span class="Li">&quot;ORIGMARK&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
                dORIGMARK;
    </pre>
  </dd>
  <dt>dSP</dt>
  <dd>Declares a local copy of perl's stack pointer for the XSUB, available via
      the <span class="Li">&quot;SP&quot;</span> macro. See
      <span class="Li">&quot;SP&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
                dSP;
    </pre>
  </dd>
  <dt>EXTEND </dt>
  <dd>Used to extend the argument stack for an XSUB's return values. Once used,
      guarantees that there is room for at least
      <span class="Li">&quot;nitems&quot;</span> to be pushed onto the stack.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    EXTEND(SP, int nitems)
    </pre>
  </dd>
  <dt>MARK </dt>
  <dd>Stack marker variable for the XSUB. See
      <span class="Li">&quot;dMARK&quot;</span>.</dd>
  <dt>mPUSHi</dt>
  <dd>Push an integer onto the stack. The stack must have room for this element.
      Does not use <span class="Li">&quot;TARG&quot;</span>. See also
      <span class="Li">&quot;PUSHi&quot;</span>,
      <span class="Li">&quot;mXPUSHi&quot;</span> and
      <span class="Li">&quot;XPUSHi&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    mPUSHi(IV iv)
    </pre>
  </dd>
  <dt>mPUSHn</dt>
  <dd>Push a double onto the stack. The stack must have room for this element.
      Does not use <span class="Li">&quot;TARG&quot;</span>. See also
      <span class="Li">&quot;PUSHn&quot;</span>,
      <span class="Li">&quot;mXPUSHn&quot;</span> and
      <span class="Li">&quot;XPUSHn&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    mPUSHn(NV nv)
    </pre>
  </dd>
  <dt>mPUSHp</dt>
  <dd>Push a string onto the stack. The stack must have room for this element.
      The <span class="Li">&quot;len&quot;</span> indicates the length of the
      string. Does not use <span class="Li">&quot;TARG&quot;</span>. See also
      <span class="Li">&quot;PUSHp&quot;</span>,
      <span class="Li">&quot;mXPUSHp&quot;</span> and
      <span class="Li">&quot;XPUSHp&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    mPUSHp(char* str, STRLEN len)
    </pre>
  </dd>
  <dt>mPUSHs</dt>
  <dd>Push an SV onto the stack and mortalizes the SV. The stack must have room
      for this element. Does not use <span class="Li">&quot;TARG&quot;</span>.
      See also <span class="Li">&quot;PUSHs&quot;</span> and
      <span class="Li">&quot;mXPUSHs&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    mPUSHs(SV* sv)
    </pre>
  </dd>
  <dt>mPUSHu</dt>
  <dd>Push an unsigned integer onto the stack. The stack must have room for this
      element. Does not use <span class="Li">&quot;TARG&quot;</span>. See also
      <span class="Li">&quot;PUSHu&quot;</span>,
      <span class="Li">&quot;mXPUSHu&quot;</span> and
      <span class="Li">&quot;XPUSHu&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    mPUSHu(UV uv)
    </pre>
  </dd>
  <dt>mXPUSHi</dt>
  <dd>Push an integer onto the stack, extending the stack if necessary. Does not
      use <span class="Li">&quot;TARG&quot;</span>. See also
      <span class="Li">&quot;XPUSHi&quot;</span>,
      <span class="Li">&quot;mPUSHi&quot;</span> and
      <span class="Li">&quot;PUSHi&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    mXPUSHi(IV iv)
    </pre>
  </dd>
  <dt>mXPUSHn</dt>
  <dd>Push a double onto the stack, extending the stack if necessary. Does not
      use <span class="Li">&quot;TARG&quot;</span>. See also
      <span class="Li">&quot;XPUSHn&quot;</span>,
      <span class="Li">&quot;mPUSHn&quot;</span> and
      <span class="Li">&quot;PUSHn&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    mXPUSHn(NV nv)
    </pre>
  </dd>
  <dt>mXPUSHp</dt>
  <dd>Push a string onto the stack, extending the stack if necessary. The
      <span class="Li">&quot;len&quot;</span> indicates the length of the
      string. Does not use <span class="Li">&quot;TARG&quot;</span>. See also
      <span class="Li">&quot;XPUSHp&quot;</span>,
      <span class="Li">&quot;mPUSHp&quot;</span> and
      <span class="Li">&quot;PUSHp&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    mXPUSHp(char* str, STRLEN len)
    </pre>
  </dd>
  <dt>mXPUSHs</dt>
  <dd>Push an SV onto the stack, extending the stack if necessary and mortalizes
      the SV. Does not use <span class="Li">&quot;TARG&quot;</span>. See also
      <span class="Li">&quot;XPUSHs&quot;</span> and
      <span class="Li">&quot;mPUSHs&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    mXPUSHs(SV* sv)
    </pre>
  </dd>
  <dt>mXPUSHu</dt>
  <dd>Push an unsigned integer onto the stack, extending the stack if necessary.
      Does not use <span class="Li">&quot;TARG&quot;</span>. See also
      <span class="Li">&quot;XPUSHu&quot;</span>,
      <span class="Li">&quot;mPUSHu&quot;</span> and
      <span class="Li">&quot;PUSHu&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    mXPUSHu(UV uv)
    </pre>
  </dd>
  <dt>ORIGMARK </dt>
  <dd>The original stack mark for the XSUB. See
      <span class="Li">&quot;dORIGMARK&quot;</span>.</dd>
  <dt>POPi</dt>
  <dd>Pops an integer off the stack.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        IV      POPi
    </pre>
  </dd>
  <dt>POPl</dt>
  <dd>Pops a long off the stack.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        long    POPl
    </pre>
  </dd>
  <dt>POPn</dt>
  <dd>Pops a double off the stack.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        NV      POPn
    </pre>
  </dd>
  <dt>POPp</dt>
  <dd>Pops a string off the stack.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        char*   POPp
    </pre>
  </dd>
  <dt>POPpbytex</dt>
  <dd>Pops a string off the stack which must consist of bytes i.e. characters
      &lt; 256.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        char*   POPpbytex
    </pre>
  </dd>
  <dt>POPpx</dt>
  <dd>Pops a string off the stack. Identical to POPp. There are two names for
      historical reasons.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        char*   POPpx
    </pre>
  </dd>
  <dt>POPs</dt>
  <dd>Pops an SV off the stack.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV*     POPs
    </pre>
  </dd>
  <dt>PUSHi</dt>
  <dd>Push an integer onto the stack. The stack must have room for this element.
      Handles 'set' magic. Uses <span class="Li">&quot;TARG&quot;</span>, so
      <span class="Li">&quot;dTARGET&quot;</span> or
      <span class="Li">&quot;dXSTARG&quot;</span> should be called to declare
      it. Do not call multiple <span class="Li">&quot;TARG&quot;</span>-oriented
      macros to return lists from XSUB's - see
      <span class="Li">&quot;mPUSHi&quot;</span> instead. See also
      <span class="Li">&quot;XPUSHi&quot;</span> and
      <span class="Li">&quot;mXPUSHi&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    PUSHi(IV iv)
    </pre>
  </dd>
  <dt>PUSHMARK </dt>
  <dd>Opening bracket for arguments on a callback. See
      <span class="Li">&quot;PUTBACK&quot;</span> and perlcall.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    PUSHMARK(SP)
    </pre>
  </dd>
  <dt>PUSHmortal</dt>
  <dd>Push a new mortal SV onto the stack. The stack must have room for this
      element. Does not use <span class="Li">&quot;TARG&quot;</span>. See also
      <span class="Li">&quot;PUSHs&quot;</span>,
      <span class="Li">&quot;XPUSHmortal&quot;</span> and
      <span class="Li">&quot;XPUSHs&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    PUSHmortal()
    </pre>
  </dd>
  <dt>PUSHn</dt>
  <dd>Push a double onto the stack. The stack must have room for this element.
      Handles 'set' magic. Uses <span class="Li">&quot;TARG&quot;</span>, so
      <span class="Li">&quot;dTARGET&quot;</span> or
      <span class="Li">&quot;dXSTARG&quot;</span> should be called to declare
      it. Do not call multiple <span class="Li">&quot;TARG&quot;</span>-oriented
      macros to return lists from XSUB's - see
      <span class="Li">&quot;mPUSHn&quot;</span> instead. See also
      <span class="Li">&quot;XPUSHn&quot;</span> and
      <span class="Li">&quot;mXPUSHn&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    PUSHn(NV nv)
    </pre>
  </dd>
  <dt>PUSHp</dt>
  <dd>Push a string onto the stack. The stack must have room for this element.
      The <span class="Li">&quot;len&quot;</span> indicates the length of the
      string. Handles 'set' magic. Uses
      <span class="Li">&quot;TARG&quot;</span>, so
      <span class="Li">&quot;dTARGET&quot;</span> or
      <span class="Li">&quot;dXSTARG&quot;</span> should be called to declare
      it. Do not call multiple <span class="Li">&quot;TARG&quot;</span>-oriented
      macros to return lists from XSUB's - see
      <span class="Li">&quot;mPUSHp&quot;</span> instead. See also
      <span class="Li">&quot;XPUSHp&quot;</span> and
      <span class="Li">&quot;mXPUSHp&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    PUSHp(char* str, STRLEN len)
    </pre>
  </dd>
  <dt>PUSHs</dt>
  <dd>Push an SV onto the stack. The stack must have room for this element. Does
      not handle 'set' magic. Does not use
      <span class="Li">&quot;TARG&quot;</span>. See also
      <span class="Li">&quot;PUSHmortal&quot;</span>,
      <span class="Li">&quot;XPUSHs&quot;</span> and
      <span class="Li">&quot;XPUSHmortal&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    PUSHs(SV* sv)
    </pre>
  </dd>
  <dt>PUSHu</dt>
  <dd>Push an unsigned integer onto the stack. The stack must have room for this
      element. Handles 'set' magic. Uses
      <span class="Li">&quot;TARG&quot;</span>, so
      <span class="Li">&quot;dTARGET&quot;</span> or
      <span class="Li">&quot;dXSTARG&quot;</span> should be called to declare
      it. Do not call multiple <span class="Li">&quot;TARG&quot;</span>-oriented
      macros to return lists from XSUB's - see
      <span class="Li">&quot;mPUSHu&quot;</span> instead. See also
      <span class="Li">&quot;XPUSHu&quot;</span> and
      <span class="Li">&quot;mXPUSHu&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    PUSHu(UV uv)
    </pre>
  </dd>
  <dt>PUTBACK </dt>
  <dd>Closing bracket for XSUB arguments. This is usually handled by
      <span class="Li">&quot;xsubpp&quot;</span>. See
      <span class="Li">&quot;PUSHMARK&quot;</span> and perlcall for other uses.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
                PUTBACK;
    </pre>
  </dd>
  <dt>SP </dt>
  <dd>Stack pointer. This is usually handled by
      <span class="Li">&quot;xsubpp&quot;</span>. See
      <span class="Li">&quot;dSP&quot;</span> and
      <span class="Li">&quot;SPAGAIN&quot;</span>.</dd>
  <dt>SPAGAIN </dt>
  <dd>Refetch the stack pointer. Used after a callback. See perlcall.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
                SPAGAIN;
    </pre>
  </dd>
  <dt>XPUSHi</dt>
  <dd>Push an integer onto the stack, extending the stack if necessary. Handles
      'set' magic. Uses <span class="Li">&quot;TARG&quot;</span>, so
      <span class="Li">&quot;dTARGET&quot;</span> or
      <span class="Li">&quot;dXSTARG&quot;</span> should be called to declare
      it. Do not call multiple <span class="Li">&quot;TARG&quot;</span>-oriented
      macros to return lists from XSUB's - see
      <span class="Li">&quot;mXPUSHi&quot;</span> instead. See also
      <span class="Li">&quot;PUSHi&quot;</span> and
      <span class="Li">&quot;mPUSHi&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    XPUSHi(IV iv)
    </pre>
  </dd>
  <dt>XPUSHmortal</dt>
  <dd>Push a new mortal SV onto the stack, extending the stack if necessary.
      Does not use <span class="Li">&quot;TARG&quot;</span>. See also
      <span class="Li">&quot;XPUSHs&quot;</span>,
      <span class="Li">&quot;PUSHmortal&quot;</span> and
      <span class="Li">&quot;PUSHs&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    XPUSHmortal()
    </pre>
  </dd>
  <dt>XPUSHn</dt>
  <dd>Push a double onto the stack, extending the stack if necessary. Handles
      'set' magic. Uses <span class="Li">&quot;TARG&quot;</span>, so
      <span class="Li">&quot;dTARGET&quot;</span> or
      <span class="Li">&quot;dXSTARG&quot;</span> should be called to declare
      it. Do not call multiple <span class="Li">&quot;TARG&quot;</span>-oriented
      macros to return lists from XSUB's - see
      <span class="Li">&quot;mXPUSHn&quot;</span> instead. See also
      <span class="Li">&quot;PUSHn&quot;</span> and
      <span class="Li">&quot;mPUSHn&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    XPUSHn(NV nv)
    </pre>
  </dd>
  <dt>XPUSHp</dt>
  <dd>Push a string onto the stack, extending the stack if necessary. The
      <span class="Li">&quot;len&quot;</span> indicates the length of the
      string. Handles 'set' magic. Uses
      <span class="Li">&quot;TARG&quot;</span>, so
      <span class="Li">&quot;dTARGET&quot;</span> or
      <span class="Li">&quot;dXSTARG&quot;</span> should be called to declare
      it. Do not call multiple <span class="Li">&quot;TARG&quot;</span>-oriented
      macros to return lists from XSUB's - see
      <span class="Li">&quot;mXPUSHp&quot;</span> instead. See also
      <span class="Li">&quot;PUSHp&quot;</span> and
      <span class="Li">&quot;mPUSHp&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    XPUSHp(char* str, STRLEN len)
    </pre>
  </dd>
  <dt>XPUSHs</dt>
  <dd>Push an SV onto the stack, extending the stack if necessary. Does not
      handle 'set' magic. Does not use <span class="Li">&quot;TARG&quot;</span>.
      See also <span class="Li">&quot;XPUSHmortal&quot;</span>,
      <span class="Li">&quot;PUSHs&quot;</span> and
      <span class="Li">&quot;PUSHmortal&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    XPUSHs(SV* sv)
    </pre>
  </dd>
  <dt>XPUSHu</dt>
  <dd>Push an unsigned integer onto the stack, extending the stack if necessary.
      Handles 'set' magic. Uses <span class="Li">&quot;TARG&quot;</span>, so
      <span class="Li">&quot;dTARGET&quot;</span> or
      <span class="Li">&quot;dXSTARG&quot;</span> should be called to declare
      it. Do not call multiple <span class="Li">&quot;TARG&quot;</span>-oriented
      macros to return lists from XSUB's - see
      <span class="Li">&quot;mXPUSHu&quot;</span> instead. See also
      <span class="Li">&quot;PUSHu&quot;</span> and
      <span class="Li">&quot;mPUSHu&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    XPUSHu(UV uv)
    </pre>
  </dd>
  <dt>XSRETURN </dt>
  <dd>Return from XSUB, indicating number of items on the stack. This is usually
      handled by <span class="Li">&quot;xsubpp&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    XSRETURN(int nitems)
    </pre>
  </dd>
  <dt>XSRETURN_EMPTY </dt>
  <dd>Return an empty list from an XSUB immediately.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
                XSRETURN_EMPTY;
    </pre>
  </dd>
  <dt>XSRETURN_IV </dt>
  <dd>Return an integer from an XSUB immediately. Uses
      <span class="Li">&quot;XST_mIV&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    XSRETURN_IV(IV iv)
    </pre>
  </dd>
  <dt>XSRETURN_NO </dt>
  <dd>Return <span class="Li">&amp;PL_sv_no</span> from an XSUB immediately.
      Uses <span class="Li">&quot;XST_mNO&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
                XSRETURN_NO;
    </pre>
  </dd>
  <dt>XSRETURN_NV </dt>
  <dd>Return a double from an XSUB immediately. Uses
      <span class="Li">&quot;XST_mNV&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    XSRETURN_NV(NV nv)
    </pre>
  </dd>
  <dt>XSRETURN_PV </dt>
  <dd>Return a copy of a string from an XSUB immediately. Uses
      <span class="Li">&quot;XST_mPV&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    XSRETURN_PV(char* str)
    </pre>
  </dd>
  <dt>XSRETURN_UNDEF </dt>
  <dd>Return <span class="Li">&amp;PL_sv_undef</span> from an XSUB immediately.
      Uses <span class="Li">&quot;XST_mUNDEF&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
                XSRETURN_UNDEF;
    </pre>
  </dd>
  <dt>XSRETURN_UV </dt>
  <dd>Return an integer from an XSUB immediately. Uses
      <span class="Li">&quot;XST_mUV&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    XSRETURN_UV(IV uv)
    </pre>
  </dd>
  <dt>XSRETURN_YES </dt>
  <dd>Return <span class="Li">&amp;PL_sv_yes</span> from an XSUB immediately.
      Uses <span class="Li">&quot;XST_mYES&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
                XSRETURN_YES;
    </pre>
  </dd>
  <dt>XST_mIV</dt>
  <dd>Place an integer into the specified position
      <span class="Li">&quot;pos&quot;</span> on the stack. The value is stored
      in a new mortal SV.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    XST_mIV(int pos, IV iv)
    </pre>
  </dd>
  <dt>XST_mNO</dt>
  <dd>Place <span class="Li">&amp;PL_sv_no</span> into the specified position
      <span class="Li">&quot;pos&quot;</span> on the stack.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    XST_mNO(int pos)
    </pre>
  </dd>
  <dt>XST_mNV</dt>
  <dd>Place a double into the specified position
      <span class="Li">&quot;pos&quot;</span> on the stack. The value is stored
      in a new mortal SV.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    XST_mNV(int pos, NV nv)
    </pre>
  </dd>
  <dt>XST_mPV</dt>
  <dd>Place a copy of a string into the specified position
      <span class="Li">&quot;pos&quot;</span> on the stack. The value is stored
      in a new mortal SV.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    XST_mPV(int pos, char* str)
    </pre>
  </dd>
  <dt>XST_mUNDEF</dt>
  <dd>Place <span class="Li">&amp;PL_sv_undef</span> into the specified position
      <span class="Li">&quot;pos&quot;</span> on the stack.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    XST_mUNDEF(int pos)
    </pre>
  </dd>
  <dt>XST_mYES</dt>
  <dd>Place <span class="Li">&amp;PL_sv_yes</span> into the specified position
      <span class="Li">&quot;pos&quot;</span> on the stack.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    XST_mYES(int pos)
    </pre>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="SV_Flags"><a class="permalink" href="#SV_Flags">SV
  Flags</a></h1>
<dl class="Bl-tag">
  <dt>svtype</dt>
  <dd>An enum of flags for Perl types. These are found in the file <b>sv.h</b>
      in the <span class="Li">&quot;svtype&quot;</span> enum. Test these flags
      with the <span class="Li">&quot;SvTYPE&quot;</span> macro.
    <p class="Pp">The types are:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    SVt_NULL
    SVt_BIND (unused)
    SVt_IV
    SVt_NV
    SVt_RV
    SVt_PV
    SVt_PVIV
    SVt_PVNV
    SVt_PVMG
    SVt_REGEXP
    SVt_PVGV
    SVt_PVLV
    SVt_PVAV
    SVt_PVHV
    SVt_PVCV
    SVt_PVFM
    SVt_PVIO
    </pre>
    <p class="Pp">These are most easily explained from the bottom up.</p>
    <p class="Pp">SVt_PVIO is for I/O objects, SVt_PVFM for formats, SVt_PVCV
        for subroutines, SVt_PVHV for hashes and SVt_PVAV for arrays.</p>
    <p class="Pp">All the others are scalar types, that is, things that can be
        bound to a <span class="Li">&quot;$&quot;</span> variable. For these,
        the internal types are mostly orthogonal to types in the Perl
      language.</p>
    <p class="Pp">Hence, checking <span class="Li">&quot;SvTYPE(sv) &lt;
        SVt_PVAV&quot;</span> is the best way to see whether something is a
        scalar.</p>
    <p class="Pp">SVt_PVGV represents a typeglob. If !SvFAKE(sv), then it is a
        real, incoercible typeglob. If SvFAKE(sv), then it is a scalar to which
        a typeglob has been assigned. Assigning to it again will stop it from
        being a typeglob. SVt_PVLV represents a scalar that delegates to another
        scalar behind the scenes. It is used, e.g., for the return value of
        <span class="Li">&quot;substr&quot;</span> and for tied hash and array
        elements. It can hold any scalar value, including a typeglob. SVt_REGEXP
        is for regular expressions.</p>
    <p class="Pp">SVt_PVMG represents a &quot;normal&quot; scalar (not a
        typeglob, regular expression, or delegate). Since most scalars do not
        need all the internal fields of a PVMG, we save memory by allocating
        smaller structs when possible. All the other types are just simpler
        forms of SVt_PVMG, with fewer internal fields.
       SVt_NULL can only hold undef. SVt_IV can hold undef, an integer, or a
        reference. (SVt_RV is an alias for SVt_IV, which exists for backward
        compatibility.) SVt_NV can hold any of those or a double. SVt_PV can
        only hold undef or a string. SVt_PVIV is a superset of SVt_PV and
        SVt_IV. SVt_PVNV is similar. SVt_PVMG can hold anything SVt_PVNV can
        hold, but it can, but does not have to, be blessed or magical.</p>
  </dd>
  <dt>SVt_IV</dt>
  <dd>Type flag for scalars. See &quot;svtype&quot;.</dd>
  <dt>SVt_NULL</dt>
  <dd>Type flag for scalars. See &quot;svtype&quot;.</dd>
  <dt>SVt_NV</dt>
  <dd>Type flag for scalars. See &quot;svtype&quot;.</dd>
  <dt>SVt_PV</dt>
  <dd>Type flag for scalars. See &quot;svtype&quot;.</dd>
  <dt>SVt_PVAV</dt>
  <dd>Type flag for arrays. See &quot;svtype&quot;.</dd>
  <dt>SVt_PVCV</dt>
  <dd>Type flag for subroutines. See &quot;svtype&quot;.</dd>
  <dt>SVt_PVFM</dt>
  <dd>Type flag for formats. See &quot;svtype&quot;.</dd>
  <dt>SVt_PVGV</dt>
  <dd>Type flag for typeglobs. See &quot;svtype&quot;.</dd>
  <dt>SVt_PVHV</dt>
  <dd>Type flag for hashes. See &quot;svtype&quot;.</dd>
  <dt>SVt_PVIO</dt>
  <dd>Type flag for I/O objects. See &quot;svtype&quot;.</dd>
  <dt>SVt_PVIV</dt>
  <dd>Type flag for scalars. See &quot;svtype&quot;.</dd>
  <dt>SVt_PVLV</dt>
  <dd>Type flag for scalars. See &quot;svtype&quot;.</dd>
  <dt>SVt_PVMG</dt>
  <dd>Type flag for scalars. See &quot;svtype&quot;.</dd>
  <dt>SVt_PVNV</dt>
  <dd>Type flag for scalars. See &quot;svtype&quot;.</dd>
  <dt>SVt_REGEXP</dt>
  <dd>Type flag for regular expressions. See &quot;svtype&quot;.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="SV_Manipulation_Functions"><a class="permalink" href="#SV_Manipulation_Functions">SV
  Manipulation Functions</a></h1>
<dl class="Bl-tag">
  <dt>boolSV</dt>
  <dd>Returns a true SV if <span class="Li">&quot;b&quot;</span> is a true
      value, or a false SV if <span class="Li">&quot;b&quot;</span> is 0.
    <p class="Pp">See also <span class="Li">&quot;PL_sv_yes&quot;</span> and
        <span class="Li">&quot;PL_sv_no&quot;</span>.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV *    boolSV(bool b)
    </pre>
  </dd>
  <dt>croak_xs_usage</dt>
  <dd>A specialised variant of <span class="Li">&quot;croak()&quot;</span> for
      emitting the usage message for xsubs
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    croak_xs_usage(cv, &quot;eee_yow&quot;);
    </pre>
    <p class="Pp">works out the package name and subroutine name from
        <span class="Li">&quot;cv&quot;</span>, and then calls
        <span class="Li">&quot;croak()&quot;</span>. Hence if
        <span class="Li">&quot;cv&quot;</span> is
        <span class="Li">&amp;ouch::awk</span>, it would call
        <span class="Li">&quot;croak&quot;</span> as:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    Perl_croak(aTHX_ &quot;Usage: %&quot;SVf&quot;::%&quot;SVf&quot;(%s)&quot;, &quot;ouch&quot; &quot;awk&quot;, &quot;eee_yow&quot;);

        void    croak_xs_usage(const CV *const cv,
                               const char *const params)
    </pre>
  </dd>
  <dt>get_sv</dt>
  <dd>Returns the SV of the specified Perl scalar.
      <span class="Li">&quot;flags&quot;</span> are passed to
      <span class="Li">&quot;gv_fetchpv&quot;</span>. If
      <span class="Li">&quot;GV_ADD&quot;</span> is set and the Perl variable
      does not exist then it will be created. If
      <span class="Li">&quot;flags&quot;</span> is zero and the variable does
      not exist then NULL is returned.
    <p class="Pp">NOTE: the perl_ form of this function is deprecated.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV*     get_sv(const char *name, I32 flags)
    </pre>
  </dd>
  <dt>newRV_inc</dt>
  <dd>Creates an RV wrapper for an SV. The reference count for the original SV
      is incremented.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV*     newRV_inc(SV* sv)
    </pre>
  </dd>
  <dt>newSVpadname</dt>
  <dd>Creates a new SV containing the pad name. This is currently identical to
      <span class="Li">&quot;newSVsv&quot;</span>, but pad names may cease being
      SVs at some point, so <span class="Li">&quot;newSVpadname&quot;</span> is
      preferable.
    <p class="Pp">NOTE: this function is experimental and may change or be
        removed without notice.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV*     newSVpadname(PADNAME *pn)
    </pre>
  </dd>
  <dt>newSVpvn_utf8</dt>
  <dd>Creates a new SV and copies a string into it. If utf8 is true, calls
      <span class="Li">&quot;SvUTF8_on&quot;</span> on the new SV. Implemented
      as a wrapper around <span class="Li">&quot;newSVpvn_flags&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV*     newSVpvn_utf8(NULLOK const char* s, STRLEN len,
                              U32 utf8)
    </pre>
  </dd>
  <dt>SvCUR</dt>
  <dd>Returns the length of the string which is in the SV. See
      <span class="Li">&quot;SvLEN&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        STRLEN  SvCUR(SV* sv)
    </pre>
  </dd>
  <dt>SvCUR_set</dt>
  <dd>Set the current length of the string which is in the SV. See
      <span class="Li">&quot;SvCUR&quot;</span> and
      <span class="Li">&quot;SvIV_set&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    SvCUR_set(SV* sv, STRLEN len)
    </pre>
  </dd>
  <dt>SvEND</dt>
  <dd>Returns a pointer to the spot just after the last character in the string
      which is in the SV, where there is usually a trailing null (even though
      Perl scalars do not strictly require it). See
      <span class="Li">&quot;SvCUR&quot;</span>. Access the character as
      *(SvEND(sv)).
    <p class="Pp">Warning: If <span class="Li">&quot;SvCUR&quot;</span> is equal
        to <span class="Li">&quot;SvLEN&quot;</span>, then
        <span class="Li">&quot;SvEND&quot;</span> points to unallocated
      memory.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        char*   SvEND(SV* sv)
    </pre>
  </dd>
  <dt>SvGAMAGIC</dt>
  <dd>Returns true if the SV has get magic or overloading. If either is true
      then the scalar is active data, and has the potential to return a new
      value every time it is accessed. Hence you must be careful to only read it
      once per user logical operation and work with that returned value. If
      neither is true then the scalar's value cannot change unless written to.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        U32     SvGAMAGIC(SV* sv)
    </pre>
  </dd>
  <dt>SvGROW</dt>
  <dd>Expands the character buffer in the SV so that it has room for the
      indicated number of bytes (remember to reserve space for an extra trailing
      NUL character). Calls <span class="Li">&quot;sv_grow&quot;</span> to
      perform the expansion if necessary. Returns a pointer to the character
      buffer. SV must be of type &gt;= SVt_PV. One alternative is to call
      <span class="Li">&quot;sv_grow&quot;</span> if you are not sure of the
      type of SV.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        char *  SvGROW(SV* sv, STRLEN len)
    </pre>
  </dd>
  <dt>SvIOK</dt>
  <dd>Returns a U32 value indicating whether the SV contains an integer.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        U32     SvIOK(SV* sv)
    </pre>
  </dd>
  <dt>SvIOKp</dt>
  <dd>Returns a U32 value indicating whether the SV contains an integer. Checks
      the <b>private</b> setting. Use <span class="Li">&quot;SvIOK&quot;</span>
      instead.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        U32     SvIOKp(SV* sv)
    </pre>
  </dd>
  <dt>SvIOK_notUV</dt>
  <dd>Returns a boolean indicating whether the SV contains a signed integer.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    SvIOK_notUV(SV* sv)
    </pre>
  </dd>
  <dt>SvIOK_off</dt>
  <dd>Unsets the IV status of an SV.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    SvIOK_off(SV* sv)
    </pre>
  </dd>
  <dt>SvIOK_on</dt>
  <dd>Tells an SV that it is an integer.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    SvIOK_on(SV* sv)
    </pre>
  </dd>
  <dt>SvIOK_only</dt>
  <dd>Tells an SV that it is an integer and disables all other OK bits.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    SvIOK_only(SV* sv)
    </pre>
  </dd>
  <dt>SvIOK_only_UV</dt>
  <dd>Tells an SV that it is an unsigned integer and disables all other OK bits.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    SvIOK_only_UV(SV* sv)
    </pre>
  </dd>
  <dt>SvIOK_UV</dt>
  <dd>Returns a boolean indicating whether the SV contains an integer that must
      be interpreted as unsigned. A non-negative integer whose value is within
      the range of both an IV and a UV may be be flagged as either SvUOK or
      SVIOK.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    SvIOK_UV(SV* sv)
    </pre>
  </dd>
  <dt>SvIsCOW</dt>
  <dd>Returns a boolean indicating whether the SV is Copy-On-Write (either
      shared hash key scalars, or full Copy On Write scalars if 5.9.0 is
      configured for COW).
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    SvIsCOW(SV* sv)
    </pre>
  </dd>
  <dt>SvIsCOW_shared_hash</dt>
  <dd>Returns a boolean indicating whether the SV is Copy-On-Write shared hash
      key scalar.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    SvIsCOW_shared_hash(SV* sv)
    </pre>
  </dd>
  <dt>SvIV</dt>
  <dd>Coerces the given SV to an integer and returns it. See
      <span class="Li">&quot;SvIVx&quot;</span> for a version which guarantees
      to evaluate sv only once.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        IV      SvIV(SV* sv)
    </pre>
  </dd>
  <dt>SvIVX</dt>
  <dd>Returns the raw value in the SV's IV slot, without checks or conversions.
      Only use when you are sure SvIOK is true. See also
      <span class="Li">&quot;SvIV()&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        IV      SvIVX(SV* sv)
    </pre>
  </dd>
  <dt>SvIVx</dt>
  <dd>Coerces the given SV to an integer and returns it. Guarantees to evaluate
      <span class="Li">&quot;sv&quot;</span> only once. Only use this if
      <span class="Li">&quot;sv&quot;</span> is an expression with side effects,
      otherwise use the more efficient <span class="Li">&quot;SvIV&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        IV      SvIVx(SV* sv)
    </pre>
  </dd>
  <dt>SvIV_nomg</dt>
  <dd>Like <span class="Li">&quot;SvIV&quot;</span> but doesn't process magic.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        IV      SvIV_nomg(SV* sv)
    </pre>
  </dd>
  <dt>SvIV_set</dt>
  <dd>Set the value of the IV pointer in sv to val. It is possible to perform
      the same function of this macro with an lvalue assignment to
      <span class="Li">&quot;SvIVX&quot;</span>. With future Perls, however, it
      will be more efficient to use <span class="Li">&quot;SvIV_set&quot;</span>
      instead of the lvalue assignment to
      <span class="Li">&quot;SvIVX&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    SvIV_set(SV* sv, IV val)
    </pre>
  </dd>
  <dt>SvLEN</dt>
  <dd>Returns the size of the string buffer in the SV, not including any part
      attributable to <span class="Li">&quot;SvOOK&quot;</span>. See
      <span class="Li">&quot;SvCUR&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        STRLEN  SvLEN(SV* sv)
    </pre>
  </dd>
  <dt>SvLEN_set</dt>
  <dd>Set the actual length of the string which is in the SV. See
      <span class="Li">&quot;SvIV_set&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    SvLEN_set(SV* sv, STRLEN len)
    </pre>
  </dd>
  <dt>SvMAGIC_set</dt>
  <dd>Set the value of the MAGIC pointer in sv to val. See
      <span class="Li">&quot;SvIV_set&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    SvMAGIC_set(SV* sv, MAGIC* val)
    </pre>
  </dd>
  <dt>SvNIOK</dt>
  <dd>Returns a U32 value indicating whether the SV contains a number, integer
      or double.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        U32     SvNIOK(SV* sv)
    </pre>
  </dd>
  <dt>SvNIOKp</dt>
  <dd>Returns a U32 value indicating whether the SV contains a number, integer
      or double. Checks the <b>private</b> setting. Use
      <span class="Li">&quot;SvNIOK&quot;</span> instead.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        U32     SvNIOKp(SV* sv)
    </pre>
  </dd>
  <dt>SvNIOK_off</dt>
  <dd>Unsets the NV/IV status of an SV.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    SvNIOK_off(SV* sv)
    </pre>
  </dd>
  <dt>SvNOK</dt>
  <dd>Returns a U32 value indicating whether the SV contains a double.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        U32     SvNOK(SV* sv)
    </pre>
  </dd>
  <dt>SvNOKp</dt>
  <dd>Returns a U32 value indicating whether the SV contains a double. Checks
      the <b>private</b> setting. Use <span class="Li">&quot;SvNOK&quot;</span>
      instead.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        U32     SvNOKp(SV* sv)
    </pre>
  </dd>
  <dt>SvNOK_off</dt>
  <dd>Unsets the NV status of an SV.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    SvNOK_off(SV* sv)
    </pre>
  </dd>
  <dt>SvNOK_on</dt>
  <dd>Tells an SV that it is a double.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    SvNOK_on(SV* sv)
    </pre>
  </dd>
  <dt>SvNOK_only</dt>
  <dd>Tells an SV that it is a double and disables all other OK bits.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    SvNOK_only(SV* sv)
    </pre>
  </dd>
  <dt>SvNV</dt>
  <dd>Coerce the given SV to a double and return it. See
      <span class="Li">&quot;SvNVx&quot;</span> for a version which guarantees
      to evaluate sv only once.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        NV      SvNV(SV* sv)
    </pre>
  </dd>
  <dt>SvNVX</dt>
  <dd>Returns the raw value in the SV's NV slot, without checks or conversions.
      Only use when you are sure SvNOK is true. See also
      <span class="Li">&quot;SvNV()&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        NV      SvNVX(SV* sv)
    </pre>
  </dd>
  <dt>SvNVx</dt>
  <dd>Coerces the given SV to a double and returns it. Guarantees to evaluate
      <span class="Li">&quot;sv&quot;</span> only once. Only use this if
      <span class="Li">&quot;sv&quot;</span> is an expression with side effects,
      otherwise use the more efficient <span class="Li">&quot;SvNV&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        NV      SvNVx(SV* sv)
    </pre>
  </dd>
  <dt>SvNV_nomg</dt>
  <dd>Like <span class="Li">&quot;SvNV&quot;</span> but doesn't process magic.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        NV      SvNV_nomg(SV* sv)
    </pre>
  </dd>
  <dt>SvNV_set</dt>
  <dd>Set the value of the NV pointer in sv to val. See
      <span class="Li">&quot;SvIV_set&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    SvNV_set(SV* sv, NV val)
    </pre>
  </dd>
  <dt>SvOK</dt>
  <dd>Returns a U32 value indicating whether the value is defined. This is only
      meaningful for scalars.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        U32     SvOK(SV* sv)
    </pre>
  </dd>
  <dt>SvOOK</dt>
  <dd>Returns a U32 indicating whether the pointer to the string buffer is
      offset. This hack is used internally to speed up removal of characters
      from the beginning of a SvPV. When SvOOK is true, then the start of the
      allocated string buffer is actually
      <span class="Li">&quot;SvOOK_offset()&quot;</span> bytes before SvPVX.
      This offset used to be stored in SvIVX, but is now stored within the spare
      part of the buffer.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        U32     SvOOK(SV* sv)
    </pre>
  </dd>
  <dt>SvOOK_offset</dt>
  <dd>Reads into <i>len</i> the offset from SvPVX back to the true start of the
      allocated buffer, which will be non-zero if
      <span class="Li">&quot;sv_chop&quot;</span> has been used to efficiently
      remove characters from start of the buffer. Implemented as a macro, which
      takes the address of <i>len</i>, which must be of type
      <span class="Li">&quot;STRLEN&quot;</span>. Evaluates <i>sv</i> more than
      once. Sets <i>len</i> to 0 if
      <span class="Li">&quot;SvOOK(sv)&quot;</span> is false.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    SvOOK_offset(NN SV*sv, STRLEN len)
    </pre>
  </dd>
  <dt>SvPOK</dt>
  <dd>Returns a U32 value indicating whether the SV contains a character string.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        U32     SvPOK(SV* sv)
    </pre>
  </dd>
  <dt>SvPOKp</dt>
  <dd>Returns a U32 value indicating whether the SV contains a character string.
      Checks the <b>private</b> setting. Use
      <span class="Li">&quot;SvPOK&quot;</span> instead.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        U32     SvPOKp(SV* sv)
    </pre>
  </dd>
  <dt>SvPOK_off</dt>
  <dd>Unsets the PV status of an SV.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    SvPOK_off(SV* sv)
    </pre>
  </dd>
  <dt>SvPOK_on</dt>
  <dd>Tells an SV that it is a string.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    SvPOK_on(SV* sv)
    </pre>
  </dd>
  <dt>SvPOK_only</dt>
  <dd>Tells an SV that it is a string and disables all other OK bits. Will also
      turn off the UTF-8 status.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    SvPOK_only(SV* sv)
    </pre>
  </dd>
  <dt>SvPOK_only_UTF8</dt>
  <dd>Tells an SV that it is a string and disables all other OK bits, and leaves
      the UTF-8 status as it was.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    SvPOK_only_UTF8(SV* sv)
    </pre>
  </dd>
  <dt>SvPV</dt>
  <dd>Returns a pointer to the string in the SV, or a stringified form of the SV
      if the SV does not contain a string. The SV may cache the stringified
      version becoming <span class="Li">&quot;SvPOK&quot;</span>. Handles 'get'
      magic. See also <span class="Li">&quot;SvPVx&quot;</span> for a version
      which guarantees to evaluate sv only once.
    <p class="Pp">Note that there is no guarantee that the return value of
        <span class="Li">&quot;SvPV()&quot;</span> is equal to
        <span class="Li">&quot;SvPVX(sv)&quot;</span>, or that
        <span class="Li">&quot;SvPVX(sv)&quot;</span> contains valid data, or
        that successive calls to <span class="Li">&quot;SvPV(sv)) will return
        the same pointer value each</span> <span class="Li">time. This is due to
        the way that things like overloading and</span>
        <span class="Li">Copy-On-Write are handled. In these cases, the return
        value may point to</span> <span class="Li">a temporary buffer or
        similar. If you absolutely need the SvPVX field to</span>
        <span class="Li">be valid (for example, if you intend to write to it),
        then see</span>
      <span class="Li">&quot;SvPV_force&quot;.&quot;</span></p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        char*   SvPV(SV* sv, STRLEN len)
    </pre>
  </dd>
  <dt>SvPVbyte</dt>
  <dd>Like <span class="Li">&quot;SvPV&quot;</span>, but converts sv to byte
      representation first if necessary.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        char*   SvPVbyte(SV* sv, STRLEN len)
    </pre>
  </dd>
  <dt>SvPVbytex</dt>
  <dd>Like <span class="Li">&quot;SvPV&quot;</span>, but converts sv to byte
      representation first if necessary. Guarantees to evaluate sv only once;
      use the more efficient <span class="Li">&quot;SvPVbyte&quot;</span>
      otherwise.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        char*   SvPVbytex(SV* sv, STRLEN len)
    </pre>
  </dd>
  <dt>SvPVbytex_force</dt>
  <dd>Like <span class="Li">&quot;SvPV_force&quot;</span>, but converts sv to
      byte representation first if necessary. Guarantees to evaluate sv only
      once; use the more efficient
      <span class="Li">&quot;SvPVbyte_force&quot;</span> otherwise.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        char*   SvPVbytex_force(SV* sv, STRLEN len)
    </pre>
  </dd>
  <dt>SvPVbyte_force</dt>
  <dd>Like <span class="Li">&quot;SvPV_force&quot;</span>, but converts sv to
      byte representation first if necessary.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        char*   SvPVbyte_force(SV* sv, STRLEN len)
    </pre>
  </dd>
  <dt>SvPVbyte_nolen</dt>
  <dd>Like <span class="Li">&quot;SvPV_nolen&quot;</span>, but converts sv to
      byte representation first if necessary.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        char*   SvPVbyte_nolen(SV* sv)
    </pre>
  </dd>
  <dt>SvPVutf8</dt>
  <dd>Like <span class="Li">&quot;SvPV&quot;</span>, but converts sv to utf8
      first if necessary.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        char*   SvPVutf8(SV* sv, STRLEN len)
    </pre>
  </dd>
  <dt>SvPVutf8x</dt>
  <dd>Like <span class="Li">&quot;SvPV&quot;</span>, but converts sv to utf8
      first if necessary. Guarantees to evaluate sv only once; use the more
      efficient <span class="Li">&quot;SvPVutf8&quot;</span> otherwise.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        char*   SvPVutf8x(SV* sv, STRLEN len)
    </pre>
  </dd>
  <dt>SvPVutf8x_force</dt>
  <dd>Like <span class="Li">&quot;SvPV_force&quot;</span>, but converts sv to
      utf8 first if necessary. Guarantees to evaluate sv only once; use the more
      efficient <span class="Li">&quot;SvPVutf8_force&quot;</span> otherwise.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        char*   SvPVutf8x_force(SV* sv, STRLEN len)
    </pre>
  </dd>
  <dt>SvPVutf8_force</dt>
  <dd>Like <span class="Li">&quot;SvPV_force&quot;</span>, but converts sv to
      utf8 first if necessary.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        char*   SvPVutf8_force(SV* sv, STRLEN len)
    </pre>
  </dd>
  <dt>SvPVutf8_nolen</dt>
  <dd>Like <span class="Li">&quot;SvPV_nolen&quot;</span>, but converts sv to
      utf8 first if necessary.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        char*   SvPVutf8_nolen(SV* sv)
    </pre>
  </dd>
  <dt>SvPVX</dt>
  <dd>Returns a pointer to the physical string in the SV. The SV must contain a
      string. Prior to 5.9.3 it is not safe to execute this macro unless the
      SV's type &gt;= SVt_PV.
    <p class="Pp">This is also used to store the name of an autoloaded
        subroutine in an XS AUTOLOAD routine. See &quot;Autoloading with
        XSUBs&quot; in perlguts.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        char*   SvPVX(SV* sv)
    </pre>
  </dd>
  <dt>SvPVx</dt>
  <dd>A version of <span class="Li">&quot;SvPV&quot;</span> which guarantees to
      evaluate <span class="Li">&quot;sv&quot;</span> only once. Only use this
      if <span class="Li">&quot;sv&quot;</span> is an expression with side
      effects, otherwise use the more efficient
      <span class="Li">&quot;SvPV&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        char*   SvPVx(SV* sv, STRLEN len)
    </pre>
  </dd>
  <dt>SvPV_force</dt>
  <dd>Like <span class="Li">&quot;SvPV&quot;</span> but will force the SV into
      containing a string (<span class="Li">&quot;SvPOK&quot;</span>), and only
      a string (<span class="Li">&quot;SvPOK_only&quot;</span>), by hook or by
      crook. You need force if you are going to update the
      <span class="Li">&quot;SvPVX&quot;</span> directly. Processes get magic.
    <p class="Pp">Note that coercing an arbitrary scalar into a plain PV will
        potentially strip useful data from it. For example if the SV was
        <span class="Li">&quot;SvROK&quot;</span>, then the referent will have
        its reference count decremented, and the SV itself may be converted to
        an <span class="Li">&quot;SvPOK&quot;</span> scalar with a string buffer
        containing a value such as
        <span class="Li">&quot;ARRAY(0x1234)&quot;</span>.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        char*   SvPV_force(SV* sv, STRLEN len)
    </pre>
  </dd>
  <dt>SvPV_force_nomg</dt>
  <dd>Like <span class="Li">&quot;SvPV_force&quot;</span>, but doesn't process
      get magic.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        char*   SvPV_force_nomg(SV* sv, STRLEN len)
    </pre>
  </dd>
  <dt>SvPV_nolen</dt>
  <dd>Like <span class="Li">&quot;SvPV&quot;</span> but doesn't set a length
      variable.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        char*   SvPV_nolen(SV* sv)
    </pre>
  </dd>
  <dt>SvPV_nomg</dt>
  <dd>Like <span class="Li">&quot;SvPV&quot;</span> but doesn't process magic.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        char*   SvPV_nomg(SV* sv, STRLEN len)
    </pre>
  </dd>
  <dt>SvPV_nomg_nolen</dt>
  <dd>Like <span class="Li">&quot;SvPV_nolen&quot;</span> but doesn't process
      magic.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        char*   SvPV_nomg_nolen(SV* sv)
    </pre>
  </dd>
  <dt>SvPV_set</dt>
  <dd>Set the value of the PV pointer in sv to val. See also
      <span class="Li">&quot;SvIV_set&quot;</span>.
    <p class="Pp">Beware that the existing pointer may be involved in
        copy-on-write or other mischief, so do
        <span class="Li">&quot;SvOOK_off(sv)&quot;</span> and use
        <span class="Li">&quot;sv_force_normal&quot;</span> or
        <span class="Li">&quot;SvPV_force&quot;</span> (or check the SvIsCOW
        flag) first to make sure this modification is safe.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    SvPV_set(SV* sv, char* val)
    </pre>
  </dd>
  <dt>SvREFCNT</dt>
  <dd>Returns the value of the object's reference count.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        U32     SvREFCNT(SV* sv)
    </pre>
  </dd>
  <dt>SvREFCNT_dec</dt>
  <dd>Decrements the reference count of the given SV. <i>sv</i> may be NULL.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    SvREFCNT_dec(SV* sv)
    </pre>
  </dd>
  <dt>SvREFCNT_dec_NN</dt>
  <dd>Same as SvREFCNT_dec, but can only be used if you know <i>sv</i> is not
      NULL. Since we don't have to check the NULLness, it's faster and smaller.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    SvREFCNT_dec_NN(SV* sv)
    </pre>
  </dd>
  <dt>SvREFCNT_inc</dt>
  <dd>Increments the reference count of the given SV, returning the SV.
    <p class="Pp">All of the following SvREFCNT_inc* macros are optimized
        versions of SvREFCNT_inc, and can be replaced with SvREFCNT_inc.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV*     SvREFCNT_inc(SV* sv)
    </pre>
  </dd>
  <dt>SvREFCNT_inc_NN</dt>
  <dd>Same as SvREFCNT_inc, but can only be used if you know <i>sv</i> is not
      NULL. Since we don't have to check the NULLness, it's faster and smaller.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV*     SvREFCNT_inc_NN(SV* sv)
    </pre>
  </dd>
  <dt>SvREFCNT_inc_simple</dt>
  <dd>Same as SvREFCNT_inc, but can only be used with expressions without side
      effects. Since we don't have to store a temporary value, it's faster.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV*     SvREFCNT_inc_simple(SV* sv)
    </pre>
  </dd>
  <dt>SvREFCNT_inc_simple_NN</dt>
  <dd>Same as SvREFCNT_inc_simple, but can only be used if you know <i>sv</i> is
      not NULL. Since we don't have to check the NULLness, it's faster and
      smaller.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV*     SvREFCNT_inc_simple_NN(SV* sv)
    </pre>
  </dd>
  <dt>SvREFCNT_inc_simple_void</dt>
  <dd>Same as SvREFCNT_inc_simple, but can only be used if you don't need the
      return value. The macro doesn't need to return a meaningful value.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    SvREFCNT_inc_simple_void(SV* sv)
    </pre>
  </dd>
  <dt>SvREFCNT_inc_simple_void_NN</dt>
  <dd>Same as SvREFCNT_inc, but can only be used if you don't need the return
      value, and you know that <i>sv</i> is not NULL. The macro doesn't need to
      return a meaningful value, or check for NULLness, so it's smaller and
      faster.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    SvREFCNT_inc_simple_void_NN(SV* sv)
    </pre>
  </dd>
  <dt>SvREFCNT_inc_void</dt>
  <dd>Same as SvREFCNT_inc, but can only be used if you don't need the return
      value. The macro doesn't need to return a meaningful value.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    SvREFCNT_inc_void(SV* sv)
    </pre>
  </dd>
  <dt>SvREFCNT_inc_void_NN</dt>
  <dd>Same as SvREFCNT_inc, but can only be used if you don't need the return
      value, and you know that <i>sv</i> is not NULL. The macro doesn't need to
      return a meaningful value, or check for NULLness, so it's smaller and
      faster.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    SvREFCNT_inc_void_NN(SV* sv)
    </pre>
  </dd>
  <dt>SvROK</dt>
  <dd>Tests if the SV is an RV.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        U32     SvROK(SV* sv)
    </pre>
  </dd>
  <dt>SvROK_off</dt>
  <dd>Unsets the RV status of an SV.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    SvROK_off(SV* sv)
    </pre>
  </dd>
  <dt>SvROK_on</dt>
  <dd>Tells an SV that it is an RV.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    SvROK_on(SV* sv)
    </pre>
  </dd>
  <dt>SvRV</dt>
  <dd>Dereferences an RV to return the SV.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV*     SvRV(SV* sv)
    </pre>
  </dd>
  <dt>SvRV_set</dt>
  <dd>Set the value of the RV pointer in sv to val. See
      <span class="Li">&quot;SvIV_set&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    SvRV_set(SV* sv, SV* val)
    </pre>
  </dd>
  <dt>SvSTASH</dt>
  <dd>Returns the stash of the SV.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        HV*     SvSTASH(SV* sv)
    </pre>
  </dd>
  <dt>SvSTASH_set</dt>
  <dd>Set the value of the STASH pointer in sv to val. See
      <span class="Li">&quot;SvIV_set&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    SvSTASH_set(SV* sv, HV* val)
    </pre>
  </dd>
  <dt>SvTAINT</dt>
  <dd>Taints an SV if tainting is enabled, and if some input to the current
      expression is tainted--usually a variable, but possibly also implicit
      inputs such as locale settings.
      <span class="Li">&quot;SvTAINT&quot;</span> propagates that taintedness to
      the outputs of an expression in a pessimistic fashion; i.e., without
      paying attention to precisely which outputs are influenced by which
      inputs.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    SvTAINT(SV* sv)
    </pre>
  </dd>
  <dt>SvTAINTED</dt>
  <dd>Checks to see if an SV is tainted. Returns TRUE if it is, FALSE if not.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    SvTAINTED(SV* sv)
    </pre>
  </dd>
  <dt>SvTAINTED_off</dt>
  <dd>Untaints an SV. Be <i>very</i> careful with this routine, as it
      short-circuits some of Perl's fundamental security features. XS module
      authors should not use this function unless they fully understand all the
      implications of unconditionally untainting the value. Untainting should be
      done in the standard perl fashion, via a carefully crafted regexp, rather
      than directly untainting variables.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    SvTAINTED_off(SV* sv)
    </pre>
  </dd>
  <dt>SvTAINTED_on</dt>
  <dd>Marks an SV as tainted if tainting is enabled.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    SvTAINTED_on(SV* sv)
    </pre>
  </dd>
  <dt>SvTRUE</dt>
  <dd>Returns a boolean indicating whether Perl would evaluate the SV as true or
      false. See <i>SvOK()</i> for a defined/undefined test. Handles 'get' magic
      unless the scalar is already SvPOK, SvIOK or SvNOK (the public, not the
      private flags).
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    SvTRUE(SV* sv)
    </pre>
  </dd>
  <dt>SvTRUE_nomg</dt>
  <dd>Returns a boolean indicating whether Perl would evaluate the SV as true or
      false. See <i>SvOK()</i> for a defined/undefined test. Does not handle
      'get' magic.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    SvTRUE_nomg(SV* sv)
    </pre>
  </dd>
  <dt>SvTYPE</dt>
  <dd>Returns the type of the SV. See
      <span class="Li">&quot;svtype&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        svtype  SvTYPE(SV* sv)
    </pre>
  </dd>
  <dt>SvUOK</dt>
  <dd>Returns a boolean indicating whether the SV contains an integer that must
      be interpreted as unsigned. A non-negative integer whose value is within
      the range of both an IV and a UV may be be flagged as either SvUOK or
      SVIOK.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    SvUOK(SV* sv)
    </pre>
  </dd>
  <dt>SvUPGRADE</dt>
  <dd>Used to upgrade an SV to a more complex form. Uses
      <span class="Li">&quot;sv_upgrade&quot;</span> to perform the upgrade if
      necessary. See <span class="Li">&quot;svtype&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    SvUPGRADE(SV* sv, svtype type)
    </pre>
  </dd>
  <dt>SvUTF8</dt>
  <dd>Returns a U32 value indicating the UTF-8 status of an SV. If things are
      set-up properly, this indicates whether or not the SV contains UTF-8
      encoded data. You should use this <i>after</i> a call to <i>SvPV()</i> or
      one of its variants, in case any call to string overloading updates the
      internal flag.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        U32     SvUTF8(SV* sv)
    </pre>
  </dd>
  <dt>SvUTF8_off</dt>
  <dd>Unsets the UTF-8 status of an SV (the data is not changed, just the flag).
      Do not use frivolously.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    SvUTF8_off(SV *sv)
    </pre>
  </dd>
  <dt>SvUTF8_on</dt>
  <dd>Turn on the UTF-8 status of an SV (the data is not changed, just the
      flag). Do not use frivolously.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    SvUTF8_on(SV *sv)
    </pre>
  </dd>
  <dt>SvUV</dt>
  <dd>Coerces the given SV to an unsigned integer and returns it. See
      <span class="Li">&quot;SvUVx&quot;</span> for a version which guarantees
      to evaluate sv only once.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        UV      SvUV(SV* sv)
    </pre>
  </dd>
  <dt>SvUVX</dt>
  <dd>Returns the raw value in the SV's UV slot, without checks or conversions.
      Only use when you are sure SvIOK is true. See also
      <span class="Li">&quot;SvUV()&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        UV      SvUVX(SV* sv)
    </pre>
  </dd>
  <dt>SvUVx</dt>
  <dd>Coerces the given SV to an unsigned integer and returns it. Guarantees to
      evaluate <span class="Li">&quot;sv&quot;</span> only once. Only use this
      if <span class="Li">&quot;sv&quot;</span> is an expression with side
      effects, otherwise use the more efficient
      <span class="Li">&quot;SvUV&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        UV      SvUVx(SV* sv)
    </pre>
  </dd>
  <dt>SvUV_nomg</dt>
  <dd>Like <span class="Li">&quot;SvUV&quot;</span> but doesn't process magic.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        UV      SvUV_nomg(SV* sv)
    </pre>
  </dd>
  <dt>SvUV_set</dt>
  <dd>Set the value of the UV pointer in sv to val. See
      <span class="Li">&quot;SvIV_set&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    SvUV_set(SV* sv, UV val)
    </pre>
  </dd>
  <dt>SvVOK</dt>
  <dd>Returns a boolean indicating whether the SV contains a v-string.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    SvVOK(SV* sv)
    </pre>
  </dd>
  <dt>sv_catpvn_nomg</dt>
  <dd>Like <span class="Li">&quot;sv_catpvn&quot;</span> but doesn't process
      magic.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_catpvn_nomg(SV* sv, const char* ptr,
                               STRLEN len)
    </pre>
  </dd>
  <dt>sv_catpv_nomg</dt>
  <dd>Like <span class="Li">&quot;sv_catpv&quot;</span> but doesn't process
      magic.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_catpv_nomg(SV* sv, const char* ptr)
    </pre>
  </dd>
  <dt>sv_catsv_nomg</dt>
  <dd>Like <span class="Li">&quot;sv_catsv&quot;</span> but doesn't process
      magic.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_catsv_nomg(SV* dsv, SV* ssv)
    </pre>
  </dd>
  <dt>sv_derived_from</dt>
  <dd>Exactly like &quot;sv_derived_from_pv&quot;, but doesn't take a
      <span class="Li">&quot;flags&quot;</span> parameter.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    sv_derived_from(SV* sv, const char *const name)
    </pre>
  </dd>
  <dt>sv_derived_from_pv</dt>
  <dd>Exactly like &quot;sv_derived_from_pvn&quot;, but takes a nul-terminated
      string instead of a string/length pair.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    sv_derived_from_pv(SV* sv,
                                   const char *const name,
                                   U32 flags)
    </pre>
  </dd>
  <dt>sv_derived_from_pvn</dt>
  <dd>Returns a boolean indicating whether the SV is derived from the specified
      class <i>at the C level</i>. To check derivation at the Perl level, call
      <span class="Li">&quot;isa()&quot;</span> as a normal Perl method.
    <p class="Pp">Currently, the only significant value for
        <span class="Li">&quot;flags&quot;</span> is SVf_UTF8.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    sv_derived_from_pvn(SV* sv,
                                    const char *const name,
                                    const STRLEN len, U32 flags)
    </pre>
  </dd>
  <dt>sv_derived_from_sv</dt>
  <dd>Exactly like &quot;sv_derived_from_pvn&quot;, but takes the name string in
      the form of an SV instead of a string/length pair.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    sv_derived_from_sv(SV* sv, SV *namesv,
                                   U32 flags)
    </pre>
  </dd>
  <dt>sv_does</dt>
  <dd>Like &quot;sv_does_pv&quot;, but doesn't take a
      <span class="Li">&quot;flags&quot;</span> parameter.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    sv_does(SV* sv, const char *const name)
    </pre>
  </dd>
  <dt>sv_does_pv</dt>
  <dd>Like &quot;sv_does_sv&quot;, but takes a nul-terminated string instead of
      an SV.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    sv_does_pv(SV* sv, const char *const name,
                           U32 flags)
    </pre>
  </dd>
  <dt>sv_does_pvn</dt>
  <dd>Like &quot;sv_does_sv&quot;, but takes a string/length pair instead of an
      SV.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    sv_does_pvn(SV* sv, const char *const name,
                            const STRLEN len, U32 flags)
    </pre>
  </dd>
  <dt>sv_does_sv</dt>
  <dd>Returns a boolean indicating whether the SV performs a specific, named
      role. The SV can be a Perl object or the name of a Perl class.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    sv_does_sv(SV* sv, SV* namesv, U32 flags)
    </pre>
  </dd>
  <dt>sv_report_used</dt>
  <dd>Dump the contents of all SVs not yet freed (debugging aid).
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_report_used()
    </pre>
  </dd>
  <dt>sv_setsv_nomg</dt>
  <dd>Like <span class="Li">&quot;sv_setsv&quot;</span> but doesn't process
      magic.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_setsv_nomg(SV* dsv, SV* ssv)
    </pre>
  </dd>
  <dt>sv_utf8_upgrade_nomg</dt>
  <dd>Like sv_utf8_upgrade, but doesn't do magic on
      <span class="Li">&quot;sv&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        STRLEN  sv_utf8_upgrade_nomg(NN SV *sv)
    </pre>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="SV-Body_Allocation"><a class="permalink" href="#SV-Body_Allocation">SV-Body
  Allocation</a></h1>
<dl class="Bl-tag">
  <dt>looks_like_number</dt>
  <dd>Test if the content of an SV looks like a number (or is a number).
      <span class="Li">&quot;Inf&quot;</span> and
      <span class="Li">&quot;Infinity&quot;</span> are treated as numbers (so
      will not issue a non-numeric warning), even if your <i>atof()</i> doesn't
      grok them. Get-magic is ignored.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        I32     looks_like_number(SV *const sv)
    </pre>
  </dd>
  <dt>newRV_noinc</dt>
  <dd>Creates an RV wrapper for an SV. The reference count for the original SV
      is <b>not</b> incremented.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV*     newRV_noinc(SV *const sv)
    </pre>
  </dd>
  <dt>newSV</dt>
  <dd>Creates a new SV. A non-zero <span class="Li">&quot;len&quot;</span>
      parameter indicates the number of bytes of preallocated string space the
      SV should have. An extra byte for a trailing NUL is also reserved. (SvPOK
      is not set for the SV even if string space is allocated.) The reference
      count for the new SV is set to 1.
    <p class="Pp">In 5.9.3, <i>newSV()</i> replaces the older <i>NEWSV()</i>
        API, and drops the first parameter, <i>x</i>, a debug aid which allowed
        callers to identify themselves. This aid has been superseded by a new
        build option, PERL_MEM_LOG (see &quot;PERL_MEM_LOG&quot; in
        perlhacktips). The older API is still there for use in XS modules
        supporting older perls.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV*     newSV(const STRLEN len)
    </pre>
  </dd>
  <dt>newSVhek</dt>
  <dd>Creates a new SV from the hash key structure. It will generate scalars
      that point to the shared string table where possible. Returns a new
      (undefined) SV if the hek is NULL.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV*     newSVhek(const HEK *const hek)
    </pre>
  </dd>
  <dt>newSViv</dt>
  <dd>Creates a new SV and copies an integer into it. The reference count for
      the SV is set to 1.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV*     newSViv(const IV i)
    </pre>
  </dd>
  <dt>newSVnv</dt>
  <dd>Creates a new SV and copies a floating point value into it. The reference
      count for the SV is set to 1.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV*     newSVnv(const NV n)
    </pre>
  </dd>
  <dt>newSVpv</dt>
  <dd>Creates a new SV and copies a string into it. The reference count for the
      SV is set to 1. If <span class="Li">&quot;len&quot;</span> is zero, Perl
      will compute the length using <i>strlen()</i>. For efficiency, consider
      using <span class="Li">&quot;newSVpvn&quot;</span> instead.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV*     newSVpv(const char *const s, const STRLEN len)
    </pre>
  </dd>
  <dt>newSVpvf</dt>
  <dd>Creates a new SV and initializes it with the string formatted like
      <span class="Li">&quot;sprintf&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV*     newSVpvf(const char *const pat, ...)
    </pre>
  </dd>
  <dt>newSVpvn</dt>
  <dd>Creates a new SV and copies a buffer into it, which may contain NUL
      characters (<span class="Li">&quot;\0&quot;</span>) and other binary data.
      The reference count for the SV is set to 1. Note that if
      <span class="Li">&quot;len&quot;</span> is zero, Perl will create a zero
      length (Perl) string. You are responsible for ensuring that the source
      buffer is at least <span class="Li">&quot;len&quot;</span> bytes long. If
      the <span class="Li">&quot;buffer&quot;</span> argument is NULL the new SV
      will be undefined.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV*     newSVpvn(const char *const s, const STRLEN len)
    </pre>
  </dd>
  <dt>newSVpvn_flags</dt>
  <dd>Creates a new SV and copies a string into it. The reference count for the
      SV is set to 1. Note that if <span class="Li">&quot;len&quot;</span> is
      zero, Perl will create a zero length string. You are responsible for
      ensuring that the source string is at least
      <span class="Li">&quot;len&quot;</span> bytes long. If the
      <span class="Li">&quot;s&quot;</span> argument is NULL the new SV will be
      undefined. Currently the only flag bits accepted are
      <span class="Li">&quot;SVf_UTF8&quot;</span> and
      <span class="Li">&quot;SVs_TEMP&quot;</span>. If
      <span class="Li">&quot;SVs_TEMP&quot;</span> is set, then
      <span class="Li">&quot;sv_2mortal()&quot;</span> is called on the result
      before returning. If <span class="Li">&quot;SVf_UTF8&quot;</span> is set,
      <span class="Li">&quot;s&quot;</span> is considered to be in UTF-8 and the
      <span class="Li">&quot;SVf_UTF8&quot;</span> flag will be set on the new
      SV. <span class="Li">&quot;newSVpvn_utf8()&quot;</span> is a convenience
      wrapper for this function, defined as
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    #define newSVpvn_utf8(s, len, u)                    \
        newSVpvn_flags((s), (len), (u) ? SVf_UTF8 : 0)

        SV*     newSVpvn_flags(const char *const s,
                               const STRLEN len,
                               const U32 flags)
    </pre>
  </dd>
  <dt>newSVpvn_share</dt>
  <dd>Creates a new SV with its SvPVX_const pointing to a shared string in the
      string table. If the string does not already exist in the table, it is
      created first. Turns on the SvIsCOW flag (or READONLY and FAKE in 5.16 and
      earlier). If the <span class="Li">&quot;hash&quot;</span> parameter is
      non-zero, that value is used; otherwise the hash is computed. The string's
      hash can later be retrieved from the SV with the
      <span class="Li">&quot;SvSHARED_HASH()&quot;</span> macro. The idea here
      is that as the string table is used for shared hash keys these strings
      will have SvPVX_const == HeKEY and hash lookup will avoid string compare.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV*     newSVpvn_share(const char* s, I32 len, U32 hash)
    </pre>
  </dd>
  <dt>newSVpvs</dt>
  <dd>Like <span class="Li">&quot;newSVpvn&quot;</span>, but takes a literal
      string instead of a string/length pair.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV*     newSVpvs(const char* s)
    </pre>
  </dd>
  <dt>newSVpvs_flags</dt>
  <dd>Like <span class="Li">&quot;newSVpvn_flags&quot;</span>, but takes a
      literal string instead of a string/length pair.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV*     newSVpvs_flags(const char* s, U32 flags)
    </pre>
  </dd>
  <dt>newSVpvs_share</dt>
  <dd>Like <span class="Li">&quot;newSVpvn_share&quot;</span>, but takes a
      literal string instead of a string/length pair and omits the hash
      parameter.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV*     newSVpvs_share(const char* s)
    </pre>
  </dd>
  <dt>newSVpv_share</dt>
  <dd>Like <span class="Li">&quot;newSVpvn_share&quot;</span>, but takes a
      nul-terminated string instead of a string/length pair.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV*     newSVpv_share(const char* s, U32 hash)
    </pre>
  </dd>
  <dt>newSVrv</dt>
  <dd>Creates a new SV for the existing RV,
      <span class="Li">&quot;rv&quot;</span>, to point to. If
      <span class="Li">&quot;rv&quot;</span> is not an RV then it will be
      upgraded to one. If <span class="Li">&quot;classname&quot;</span> is
      non-null then the new SV will be blessed in the specified package. The new
      SV is returned and its reference count is 1. The reference count 1 is
      owned by <span class="Li">&quot;rv&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV*     newSVrv(SV *const rv,
                        const char *const classname)
    </pre>
  </dd>
  <dt>newSVsv</dt>
  <dd>Creates a new SV which is an exact duplicate of the original SV. (Uses
      <span class="Li">&quot;sv_setsv&quot;</span>.)
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV*     newSVsv(SV *const old)
    </pre>
  </dd>
  <dt>newSVuv</dt>
  <dd>Creates a new SV and copies an unsigned integer into it. The reference
      count for the SV is set to 1.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV*     newSVuv(const UV u)
    </pre>
  </dd>
  <dt>newSV_type</dt>
  <dd>Creates a new SV, of the type specified. The reference count for the new
      SV is set to 1.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV*     newSV_type(const svtype type)
    </pre>
  </dd>
  <dt>sv_2bool</dt>
  <dd>This macro is only used by <i>sv_true()</i> or its macro equivalent, and
      only if the latter's argument is neither SvPOK, SvIOK nor SvNOK. It calls
      sv_2bool_flags with the SV_GMAGIC flag.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    sv_2bool(SV *const sv)
    </pre>
  </dd>
  <dt>sv_2bool_flags</dt>
  <dd>This function is only used by <i>sv_true()</i> and friends, and only if
      the latter's argument is neither SvPOK, SvIOK nor SvNOK. If the flags
      contain SV_GMAGIC, then it does an <i>mg_get()</i> first.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    sv_2bool_flags(SV *const sv, const I32 flags)
    </pre>
  </dd>
  <dt>sv_2cv</dt>
  <dd>Using various gambits, try to get a CV from an SV; in addition, try if
      possible to set <span class="Li">*st</span> and
      <span class="Li">*gvp</span> to the stash and GV associated with it. The
      flags in <span class="Li">&quot;lref&quot;</span> are passed to
      gv_fetchsv.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        CV*     sv_2cv(SV* sv, HV **const st, GV **const gvp,
                       const I32 lref)
    </pre>
  </dd>
  <dt>sv_2io</dt>
  <dd>Using various gambits, try to get an IO from an SV: the IO slot if its a
      GV; or the recursive result if we're an RV; or the IO slot of the symbol
      named after the PV if we're a string.
    <p class="Pp">'Get' magic is ignored on the sv passed in, but will be called
        on <span class="Li">&quot;SvRV(sv)&quot;</span> if sv is an RV.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        IO*     sv_2io(SV *const sv)
    </pre>
  </dd>
  <dt>sv_2iv_flags</dt>
  <dd>Return the integer value of an SV, doing any necessary string conversion.
      If flags includes SV_GMAGIC, does an <i>mg_get()</i> first. Normally used
      via the <span class="Li">&quot;SvIV(sv)&quot;</span> and
      <span class="Li">&quot;SvIVx(sv)&quot;</span> macros.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        IV      sv_2iv_flags(SV *const sv, const I32 flags)
    </pre>
  </dd>
  <dt>sv_2mortal</dt>
  <dd>Marks an existing SV as mortal. The SV will be destroyed &quot;soon&quot;,
      either by an explicit call to FREETMPS, or by an implicit call at places
      such as statement boundaries. <i>SvTEMP()</i> is turned on which means
      that the SV's string buffer can be &quot;stolen&quot; if this SV is
      copied. See also <span class="Li">&quot;sv_newmortal&quot;</span> and
      <span class="Li">&quot;sv_mortalcopy&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV*     sv_2mortal(SV *const sv)
    </pre>
  </dd>
  <dt>sv_2nv_flags</dt>
  <dd>Return the num value of an SV, doing any necessary string or integer
      conversion. If flags includes SV_GMAGIC, does an <i>mg_get()</i> first.
      Normally used via the <span class="Li">&quot;SvNV(sv)&quot;</span> and
      <span class="Li">&quot;SvNVx(sv)&quot;</span> macros.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        NV      sv_2nv_flags(SV *const sv, const I32 flags)
    </pre>
  </dd>
  <dt>sv_2pvbyte</dt>
  <dd>Return a pointer to the byte-encoded representation of the SV, and set *lp
      to its length. May cause the SV to be downgraded from UTF-8 as a
      side-effect.
    <p class="Pp">Usually accessed via the
        <span class="Li">&quot;SvPVbyte&quot;</span> macro.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        char*   sv_2pvbyte(SV *sv, STRLEN *const lp)
    </pre>
  </dd>
  <dt>sv_2pvutf8</dt>
  <dd>Return a pointer to the UTF-8-encoded representation of the SV, and set
      *lp to its length. May cause the SV to be upgraded to UTF-8 as a
      side-effect.
    <p class="Pp">Usually accessed via the
        <span class="Li">&quot;SvPVutf8&quot;</span> macro.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        char*   sv_2pvutf8(SV *sv, STRLEN *const lp)
    </pre>
  </dd>
  <dt>sv_2pv_flags</dt>
  <dd>Returns a pointer to the string value of an SV, and sets *lp to its
      length. If flags includes SV_GMAGIC, does an <i>mg_get()</i> first.
      Coerces sv to a string if necessary. Normally invoked via the
      <span class="Li">&quot;SvPV_flags&quot;</span> macro.
      <span class="Li">&quot;sv_2pv()&quot;</span> and
      <span class="Li">&quot;sv_2pv_nomg&quot;</span> usually end up here too.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        char*   sv_2pv_flags(SV *const sv, STRLEN *const lp,
                             const I32 flags)
    </pre>
  </dd>
  <dt>sv_2uv_flags</dt>
  <dd>Return the unsigned integer value of an SV, doing any necessary string
      conversion. If flags includes SV_GMAGIC, does an <i>mg_get()</i> first.
      Normally used via the <span class="Li">&quot;SvUV(sv)&quot;</span> and
      <span class="Li">&quot;SvUVx(sv)&quot;</span> macros.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        UV      sv_2uv_flags(SV *const sv, const I32 flags)
    </pre>
  </dd>
  <dt>sv_backoff</dt>
  <dd>Remove any string offset. You should normally use the
      <span class="Li">&quot;SvOOK_off&quot;</span> macro wrapper instead.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        int     sv_backoff(SV *const sv)
    </pre>
  </dd>
  <dt>sv_bless</dt>
  <dd>Blesses an SV into a specified package. The SV must be an RV. The package
      must be designated by its stash (see
      <span class="Li">&quot;gv_stashpv()&quot;</span>). The reference count of
      the SV is unaffected.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV*     sv_bless(SV *const sv, HV *const stash)
    </pre>
  </dd>
  <dt>sv_catpv</dt>
  <dd>Concatenates the string onto the end of the string which is in the SV. If
      the SV has the UTF-8 status set, then the bytes appended should be valid
      UTF-8. Handles 'get' magic, but not 'set' magic. See
      <span class="Li">&quot;sv_catpv_mg&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_catpv(SV *const sv, const char* ptr)
    </pre>
  </dd>
  <dt>sv_catpvf</dt>
  <dd>Processes its arguments like <span class="Li">&quot;sprintf&quot;</span>
      and appends the formatted output to an SV. If the appended data contains
      &quot;wide&quot; characters (including, but not limited to, SVs with a
      UTF-8 PV formatted with <span class="Li">%s</span>, and characters &gt;255
      formatted with <span class="Li">%c</span>), the original SV might get
      upgraded to UTF-8. Handles 'get' magic, but not 'set' magic. See
      <span class="Li">&quot;sv_catpvf_mg&quot;</span>. If the original SV was
      UTF-8, the pattern should be valid UTF-8; if the original SV was bytes,
      the pattern should be too.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_catpvf(SV *const sv, const char *const pat,
                          ...)
    </pre>
  </dd>
  <dt>sv_catpvf_mg</dt>
  <dd>Like <span class="Li">&quot;sv_catpvf&quot;</span>, but also handles 'set'
      magic.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_catpvf_mg(SV *const sv,
                             const char *const pat, ...)
    </pre>
  </dd>
  <dt>sv_catpvn</dt>
  <dd>Concatenates the string onto the end of the string which is in the SV. The
      <span class="Li">&quot;len&quot;</span> indicates number of bytes to copy.
      If the SV has the UTF-8 status set, then the bytes appended should be
      valid UTF-8. Handles 'get' magic, but not 'set' magic. See
      <span class="Li">&quot;sv_catpvn_mg&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_catpvn(SV *dsv, const char *sstr, STRLEN len)
    </pre>
  </dd>
  <dt>sv_catpvn_flags</dt>
  <dd>Concatenates the string onto the end of the string which is in the SV. The
      <span class="Li">&quot;len&quot;</span> indicates number of bytes to copy.
      If the SV has the UTF-8 status set, then the bytes appended should be
      valid UTF-8. If <span class="Li">&quot;flags&quot;</span> has the
      <span class="Li">&quot;SV_SMAGIC&quot;</span> bit set, will
      <span class="Li">&quot;mg_set&quot;</span> on
      <span class="Li">&quot;dsv&quot;</span> afterwards if appropriate.
      <span class="Li">&quot;sv_catpvn&quot;</span> and
      <span class="Li">&quot;sv_catpvn_nomg&quot;</span> are implemented in
      terms of this function.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_catpvn_flags(SV *const dstr,
                                const char *sstr,
                                const STRLEN len,
                                const I32 flags)
    </pre>
  </dd>
  <dt>sv_catpvs</dt>
  <dd>Like <span class="Li">&quot;sv_catpvn&quot;</span>, but takes a literal
      string instead of a string/length pair.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_catpvs(SV* sv, const char* s)
    </pre>
  </dd>
  <dt>sv_catpvs_flags</dt>
  <dd>Like <span class="Li">&quot;sv_catpvn_flags&quot;</span>, but takes a
      literal string instead of a string/length pair.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_catpvs_flags(SV* sv, const char* s,
                                I32 flags)
    </pre>
  </dd>
  <dt>sv_catpvs_mg</dt>
  <dd>Like <span class="Li">&quot;sv_catpvn_mg&quot;</span>, but takes a literal
      string instead of a string/length pair.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_catpvs_mg(SV* sv, const char* s)
    </pre>
  </dd>
  <dt>sv_catpvs_nomg</dt>
  <dd>Like <span class="Li">&quot;sv_catpvn_nomg&quot;</span>, but takes a
      literal string instead of a string/length pair.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_catpvs_nomg(SV* sv, const char* s)
    </pre>
  </dd>
  <dt>sv_catpv_flags</dt>
  <dd>Concatenates the string onto the end of the string which is in the SV. If
      the SV has the UTF-8 status set, then the bytes appended should be valid
      UTF-8. If <span class="Li">&quot;flags&quot;</span> has the
      <span class="Li">&quot;SV_SMAGIC&quot;</span> bit set, will
      <span class="Li">&quot;mg_set&quot;</span> on the modified SV if
      appropriate.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_catpv_flags(SV *dstr, const char *sstr,
                               const I32 flags)
    </pre>
  </dd>
  <dt>sv_catpv_mg</dt>
  <dd>Like <span class="Li">&quot;sv_catpv&quot;</span>, but also handles 'set'
      magic.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_catpv_mg(SV *const sv, const char *const ptr)
    </pre>
  </dd>
  <dt>sv_catsv</dt>
  <dd>Concatenates the string from SV <span class="Li">&quot;ssv&quot;</span>
      onto the end of the string in SV <span class="Li">&quot;dsv&quot;</span>.
      If <span class="Li">&quot;ssv&quot;</span> is null, does nothing;
      otherwise modifies only <span class="Li">&quot;dsv&quot;</span>. Handles
      'get' magic on both SVs, but no 'set' magic. See
      <span class="Li">&quot;sv_catsv_mg&quot;</span> and
      <span class="Li">&quot;sv_catsv_nomg&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_catsv(SV *dstr, SV *sstr)
    </pre>
  </dd>
  <dt>sv_catsv_flags</dt>
  <dd>Concatenates the string from SV <span class="Li">&quot;ssv&quot;</span>
      onto the end of the string in SV <span class="Li">&quot;dsv&quot;</span>.
      If <span class="Li">&quot;ssv&quot;</span> is null, does nothing;
      otherwise modifies only <span class="Li">&quot;dsv&quot;</span>. If
      <span class="Li">&quot;flags&quot;</span> include
      <span class="Li">&quot;SV_GMAGIC&quot;</span> bit set, will call
      <span class="Li">&quot;mg_get&quot;</span> on both SVs if appropriate. If
      <span class="Li">&quot;flags&quot;</span> include
      <span class="Li">&quot;SV_SMAGIC&quot;</span>,
      <span class="Li">&quot;mg_set&quot;</span> will be called on the modified
      SV afterward, if appropriate.
      <span class="Li">&quot;sv_catsv&quot;</span>,
      <span class="Li">&quot;sv_catsv_nomg&quot;</span>, and
      <span class="Li">&quot;sv_catsv_mg&quot;</span> are implemented in terms
      of this function.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_catsv_flags(SV *const dsv, SV *const ssv,
                               const I32 flags)
    </pre>
  </dd>
  <dt>sv_chop</dt>
  <dd>Efficient removal of characters from the beginning of the string buffer.
      SvPOK(sv), or at least SvPOKp(sv), must be true and the
      <span class="Li">&quot;ptr&quot;</span> must be a pointer to somewhere
      inside the string buffer. The <span class="Li">&quot;ptr&quot;</span>
      becomes the first character of the adjusted string. Uses the &quot;OOK
      hack&quot;. On return, only SvPOK(sv) and SvPOKp(sv) among the OK flags
      will be true.
    <p class="Pp">Beware: after this function returns,
        <span class="Li">&quot;ptr&quot;</span> and SvPVX_const(sv) may no
        longer refer to the same chunk of data.</p>
    <p class="Pp">The unfortunate similarity of this function's name to that of
        Perl's <span class="Li">&quot;chop&quot;</span> operator is strictly
        coincidental. This function works from the left;
        <span class="Li">&quot;chop&quot;</span> works from the right.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_chop(SV *const sv, const char *const ptr)
    </pre>
  </dd>
  <dt>sv_clear</dt>
  <dd>Clear an SV: call any destructors, free up any memory used by the body,
      and free the body itself. The SV's head is <i>not</i> freed, although its
      type is set to all 1's so that it won't inadvertently be assumed to be
      live during global destruction etc. This function should only be called
      when REFCNT is zero. Most of the time you'll want to call
      <span class="Li">&quot;sv_free()&quot;</span> (or its macro wrapper
      <span class="Li">&quot;SvREFCNT_dec&quot;</span>) instead.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_clear(SV *const orig_sv)
    </pre>
  </dd>
  <dt>sv_cmp</dt>
  <dd>Compares the strings in two SVs. Returns -1, 0, or 1 indicating whether
      the string in <span class="Li">&quot;sv1&quot;</span> is less than, equal
      to, or greater than the string in <span class="Li">&quot;sv2&quot;</span>.
      Is UTF-8 and 'use bytes' aware, handles get magic, and will coerce its
      args to strings if necessary. See also
      <span class="Li">&quot;sv_cmp_locale&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        I32     sv_cmp(SV *const sv1, SV *const sv2)
    </pre>
  </dd>
  <dt>sv_cmp_flags</dt>
  <dd>Compares the strings in two SVs. Returns -1, 0, or 1 indicating whether
      the string in <span class="Li">&quot;sv1&quot;</span> is less than, equal
      to, or greater than the string in <span class="Li">&quot;sv2&quot;</span>.
      Is UTF-8 and 'use bytes' aware and will coerce its args to strings if
      necessary. If the flags include SV_GMAGIC, it handles get magic. See also
      <span class="Li">&quot;sv_cmp_locale_flags&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        I32     sv_cmp_flags(SV *const sv1, SV *const sv2,
                             const U32 flags)
    </pre>
  </dd>
  <dt>sv_cmp_locale</dt>
  <dd>Compares the strings in two SVs in a locale-aware manner. Is UTF-8 and
      'use bytes' aware, handles get magic, and will coerce its args to strings
      if necessary. See also <span class="Li">&quot;sv_cmp&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        I32     sv_cmp_locale(SV *const sv1, SV *const sv2)
    </pre>
  </dd>
  <dt>sv_cmp_locale_flags</dt>
  <dd>Compares the strings in two SVs in a locale-aware manner. Is UTF-8 and
      'use bytes' aware and will coerce its args to strings if necessary. If the
      flags contain SV_GMAGIC, it handles get magic. See also
      <span class="Li">&quot;sv_cmp_flags&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        I32     sv_cmp_locale_flags(SV *const sv1,
                                    SV *const sv2,
                                    const U32 flags)
    </pre>
  </dd>
  <dt>sv_collxfrm</dt>
  <dd>This calls <span class="Li">&quot;sv_collxfrm_flags&quot;</span> with the
      SV_GMAGIC flag. See <span class="Li">&quot;sv_collxfrm_flags&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        char*   sv_collxfrm(SV *const sv, STRLEN *const nxp)
    </pre>
  </dd>
  <dt>sv_collxfrm_flags</dt>
  <dd>Add Collate Transform magic to an SV if it doesn't already have it. If the
      flags contain SV_GMAGIC, it handles get-magic.
    <p class="Pp">Any scalar variable may carry PERL_MAGIC_collxfrm magic that
        contains the scalar data of the variable, but transformed to such a
        format that a normal memory comparison can be used to compare the data
        according to the locale settings.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        char*   sv_collxfrm_flags(SV *const sv,
                                  STRLEN *const nxp,
                                  I32 const flags)
    </pre>
  </dd>
  <dt>sv_copypv_flags</dt>
  <dd>Implementation of sv_copypv and sv_copypv_nomg. Calls get magic iff flags
      include SV_GMAGIC.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_copypv_flags(SV *const dsv, SV *const ssv,
                                const I32 flags)
    </pre>
  </dd>
  <dt>sv_copypv_nomg</dt>
  <dd>Like sv_copypv, but doesn't invoke get magic first.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_copypv_nomg(SV *const dsv, SV *const ssv)
    </pre>
  </dd>
  <dt>sv_dec</dt>
  <dd>Auto-decrement of the value in the SV, doing string to numeric conversion
      if necessary. Handles 'get' magic and operator overloading.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_dec(SV *const sv)
    </pre>
  </dd>
  <dt>sv_dec_nomg</dt>
  <dd>Auto-decrement of the value in the SV, doing string to numeric conversion
      if necessary. Handles operator overloading. Skips handling 'get' magic.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_dec_nomg(SV *const sv)
    </pre>
  </dd>
  <dt>sv_eq</dt>
  <dd>Returns a boolean indicating whether the strings in the two SVs are
      identical. Is UTF-8 and 'use bytes' aware, handles get magic, and will
      coerce its args to strings if necessary.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        I32     sv_eq(SV* sv1, SV* sv2)
    </pre>
  </dd>
  <dt>sv_eq_flags</dt>
  <dd>Returns a boolean indicating whether the strings in the two SVs are
      identical. Is UTF-8 and 'use bytes' aware and coerces its args to strings
      if necessary. If the flags include SV_GMAGIC, it handles get-magic, too.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        I32     sv_eq_flags(SV* sv1, SV* sv2, const U32 flags)
    </pre>
  </dd>
  <dt>sv_force_normal_flags</dt>
  <dd>Undo various types of fakery on an SV, where fakery means &quot;more
      than&quot; a string: if the PV is a shared string, make a private copy; if
      we're a ref, stop refing; if we're a glob, downgrade to an xpvmg; if we're
      a copy-on-write scalar, this is the on-write time when we do the copy, and
      is also used locally; if this is a vstring, drop the vstring magic. If
      <span class="Li">&quot;SV_COW_DROP_PV&quot;</span> is set then a
      copy-on-write scalar drops its PV buffer (if any) and becomes SvPOK_off
      rather than making a copy. (Used where this scalar is about to be set to
      some other value.) In addition, the
      <span class="Li">&quot;flags&quot;</span> parameter gets passed to
      <span class="Li">&quot;sv_unref_flags()&quot;</span> when unreffing.
      <span class="Li">&quot;sv_force_normal&quot;</span> calls this function
      with flags set to 0.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_force_normal_flags(SV *const sv,
                                      const U32 flags)
    </pre>
  </dd>
  <dt>sv_free</dt>
  <dd>Decrement an SV's reference count, and if it drops to zero, call
      <span class="Li">&quot;sv_clear&quot;</span> to invoke destructors and
      free up any memory used by the body; finally, deallocate the SV's head
      itself. Normally called via a wrapper macro
      <span class="Li">&quot;SvREFCNT_dec&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_free(SV *const sv)
    </pre>
  </dd>
  <dt>sv_gets</dt>
  <dd>Get a line from the filehandle and store it into the SV, optionally
      appending to the currently-stored string. If
      <span class="Li">&quot;append&quot;</span> is not 0, the line is appended
      to the SV instead of overwriting it.
      <span class="Li">&quot;append&quot;</span> should be set to the byte
      offset that the appended string should start at in the SV (typically,
      <span class="Li">&quot;SvCUR(sv)&quot;</span> is a suitable choice).
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        char*   sv_gets(SV *const sv, PerlIO *const fp,
                        I32 append)
    </pre>
  </dd>
  <dt>sv_grow</dt>
  <dd>Expands the character buffer in the SV. If necessary, uses
      <span class="Li">&quot;sv_unref&quot;</span> and upgrades the SV to
      <span class="Li">&quot;SVt_PV&quot;</span>. Returns a pointer to the
      character buffer. Use the <span class="Li">&quot;SvGROW&quot;</span>
      wrapper instead.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        char*   sv_grow(SV *const sv, STRLEN newlen)
    </pre>
  </dd>
  <dt>sv_inc</dt>
  <dd>Auto-increment of the value in the SV, doing string to numeric conversion
      if necessary. Handles 'get' magic and operator overloading.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_inc(SV *const sv)
    </pre>
  </dd>
  <dt>sv_inc_nomg</dt>
  <dd>Auto-increment of the value in the SV, doing string to numeric conversion
      if necessary. Handles operator overloading. Skips handling 'get' magic.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_inc_nomg(SV *const sv)
    </pre>
  </dd>
  <dt>sv_insert</dt>
  <dd>Inserts a string at the specified offset/length within the SV. Similar to
      the Perl <i>substr()</i> function. Handles get magic.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_insert(SV *const bigstr, const STRLEN offset,
                          const STRLEN len,
                          const char *const little,
                          const STRLEN littlelen)
    </pre>
  </dd>
  <dt>sv_insert_flags</dt>
  <dd>Same as <span class="Li">&quot;sv_insert&quot;</span>, but the extra
      <span class="Li">&quot;flags&quot;</span> are passed to the
      <span class="Li">&quot;SvPV_force_flags&quot;</span> that applies to
      <span class="Li">&quot;bigstr&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_insert_flags(SV *const bigstr,
                                const STRLEN offset,
                                const STRLEN len,
                                const char *const little,
                                const STRLEN littlelen,
                                const U32 flags)
    </pre>
  </dd>
  <dt>sv_isa</dt>
  <dd>Returns a boolean indicating whether the SV is blessed into the specified
      class. This does not check for subtypes; use
      <span class="Li">&quot;sv_derived_from&quot;</span> to verify an
      inheritance relationship.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        int     sv_isa(SV* sv, const char *const name)
    </pre>
  </dd>
  <dt>sv_isobject</dt>
  <dd>Returns a boolean indicating whether the SV is an RV pointing to a blessed
      object. If the SV is not an RV, or if the object is not blessed, then this
      will return false.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        int     sv_isobject(SV* sv)
    </pre>
  </dd>
  <dt>sv_len</dt>
  <dd>Returns the length of the string in the SV. Handles magic and type
      coercion and sets the UTF8 flag appropriately. See also
      <span class="Li">&quot;SvCUR&quot;</span>, which gives raw access to the
      xpv_cur slot.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        STRLEN  sv_len(SV *const sv)
    </pre>
  </dd>
  <dt>sv_len_utf8</dt>
  <dd>Returns the number of characters in the string in an SV, counting wide
      UTF-8 bytes as a single character. Handles magic and type coercion.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        STRLEN  sv_len_utf8(SV *const sv)
    </pre>
  </dd>
  <dt>sv_magic</dt>
  <dd>Adds magic to an SV. First upgrades <span class="Li">&quot;sv&quot;</span>
      to type <span class="Li">&quot;SVt_PVMG&quot;</span> if necessary, then
      adds a new magic item of type <span class="Li">&quot;how&quot;</span> to
      the head of the magic list.
    <p class="Pp">See <span class="Li">&quot;sv_magicext&quot;</span> (which
        <span class="Li">&quot;sv_magic&quot;</span> now calls) for a
        description of the handling of the
        <span class="Li">&quot;name&quot;</span> and
        <span class="Li">&quot;namlen&quot;</span> arguments.</p>
    <p class="Pp">You need to use
        <span class="Li">&quot;sv_magicext&quot;</span> to add magic to
        SvREADONLY SVs and also to add more than one instance of the same
      'how'.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_magic(SV *const sv, SV *const obj,
                         const int how, const char *const name,
                         const I32 namlen)
    </pre>
  </dd>
  <dt>sv_magicext</dt>
  <dd>Adds magic to an SV, upgrading it if necessary. Applies the supplied
      vtable and returns a pointer to the magic added.
    <p class="Pp">Note that <span class="Li">&quot;sv_magicext&quot;</span> will
        allow things that <span class="Li">&quot;sv_magic&quot;</span> will not.
        In particular, you can add magic to SvREADONLY SVs, and add more than
        one instance of the same 'how'.</p>
    <p class="Pp">If <span class="Li">&quot;namlen&quot;</span> is greater than
        zero then a <span class="Li">&quot;savepvn&quot;</span> <i>copy</i> of
        <span class="Li">&quot;name&quot;</span> is stored, if
        <span class="Li">&quot;namlen&quot;</span> is zero then
        <span class="Li">&quot;name&quot;</span> is stored as-is and - as
        another special case - if <span class="Li">&quot;(name &amp;&amp; namlen
        == HEf_SVKEY)&quot;</span> then <span class="Li">&quot;name&quot;</span>
        is assumed to contain an <span class="Li">&quot;SV*&quot;</span> and is
        stored as-is with its REFCNT incremented.</p>
    <p class="Pp">(This is now used as a subroutine by
        <span class="Li">&quot;sv_magic&quot;</span>.)</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        MAGIC * sv_magicext(SV *const sv, SV *const obj,
                            const int how,
                            const MGVTBL *const vtbl,
                            const char *const name,
                            const I32 namlen)
    </pre>
  </dd>
  <dt>sv_mortalcopy</dt>
  <dd>Creates a new SV which is a copy of the original SV (using
      <span class="Li">&quot;sv_setsv&quot;</span>). The new SV is marked as
      mortal. It will be destroyed &quot;soon&quot;, either by an explicit call
      to FREETMPS, or by an implicit call at places such as statement
      boundaries. See also <span class="Li">&quot;sv_newmortal&quot;</span> and
      <span class="Li">&quot;sv_2mortal&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV*     sv_mortalcopy(SV *const oldsv)
    </pre>
  </dd>
  <dt>sv_newmortal</dt>
  <dd>Creates a new null SV which is mortal. The reference count of the SV is
      set to 1. It will be destroyed &quot;soon&quot;, either by an explicit
      call to FREETMPS, or by an implicit call at places such as statement
      boundaries. See also <span class="Li">&quot;sv_mortalcopy&quot;</span> and
      <span class="Li">&quot;sv_2mortal&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV*     sv_newmortal()
    </pre>
  </dd>
  <dt>sv_newref</dt>
  <dd>Increment an SV's reference count. Use the
      <span class="Li">&quot;SvREFCNT_inc()&quot;</span> wrapper instead.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV*     sv_newref(SV *const sv)
    </pre>
  </dd>
  <dt>sv_pos_b2u</dt>
  <dd>Converts the value pointed to by offsetp from a count of bytes from the
      start of the string, to a count of the equivalent number of UTF-8 chars.
      Handles magic and type coercion.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_pos_b2u(SV *const sv, I32 *const offsetp)
    </pre>
  </dd>
  <dt>sv_pos_u2b</dt>
  <dd>Converts the value pointed to by offsetp from a count of UTF-8 chars from
      the start of the string, to a count of the equivalent number of bytes; if
      lenp is non-zero, it does the same to lenp, but this time starting from
      the offset, rather than from the start of the string. Handles magic and
      type coercion.
    <p class="Pp">Use <span class="Li">&quot;sv_pos_u2b_flags&quot;</span> in
        preference, which correctly handles strings longer than 2Gb.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_pos_u2b(SV *const sv, I32 *const offsetp,
                           I32 *const lenp)
    </pre>
  </dd>
  <dt>sv_pos_u2b_flags</dt>
  <dd>Converts the value pointed to by offsetp from a count of UTF-8 chars from
      the start of the string, to a count of the equivalent number of bytes; if
      lenp is non-zero, it does the same to lenp, but this time starting from
      the offset, rather than from the start of the string. Handles type
      coercion. <i>flags</i> is passed to
      <span class="Li">&quot;SvPV_flags&quot;</span>, and usually should be
      <span class="Li">&quot;SV_GMAGIC|SV_CONST_RETURN&quot;</span> to handle
      magic.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        STRLEN  sv_pos_u2b_flags(SV *const sv, STRLEN uoffset,
                                 STRLEN *const lenp, U32 flags)
    </pre>
  </dd>
  <dt>sv_pvbyten_force</dt>
  <dd>The backend for the <span class="Li">&quot;SvPVbytex_force&quot;</span>
      macro. Always use the macro instead.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        char*   sv_pvbyten_force(SV *const sv, STRLEN *const lp)
    </pre>
  </dd>
  <dt>sv_pvn_force</dt>
  <dd>Get a sensible string out of the SV somehow. A private implementation of
      the <span class="Li">&quot;SvPV_force&quot;</span> macro for compilers
      which can't cope with complex macro expressions. Always use the macro
      instead.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        char*   sv_pvn_force(SV* sv, STRLEN* lp)
    </pre>
  </dd>
  <dt>sv_pvn_force_flags</dt>
  <dd>Get a sensible string out of the SV somehow. If
      <span class="Li">&quot;flags&quot;</span> has
      <span class="Li">&quot;SV_GMAGIC&quot;</span> bit set, will
      <span class="Li">&quot;mg_get&quot;</span> on
      <span class="Li">&quot;sv&quot;</span> if appropriate, else not.
      <span class="Li">&quot;sv_pvn_force&quot;</span> and
      <span class="Li">&quot;sv_pvn_force_nomg&quot;</span> are implemented in
      terms of this function. You normally want to use the various wrapper
      macros instead: see <span class="Li">&quot;SvPV_force&quot;</span> and
      <span class="Li">&quot;SvPV_force_nomg&quot;</span>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        char*   sv_pvn_force_flags(SV *const sv,
                                   STRLEN *const lp,
                                   const I32 flags)
    </pre>
  </dd>
  <dt>sv_pvutf8n_force</dt>
  <dd>The backend for the <span class="Li">&quot;SvPVutf8x_force&quot;</span>
      macro. Always use the macro instead.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        char*   sv_pvutf8n_force(SV *const sv, STRLEN *const lp)
    </pre>
  </dd>
  <dt>sv_reftype</dt>
  <dd>Returns a string describing what the SV is a reference to.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        const char* sv_reftype(const SV *const sv, const int ob)
    </pre>
  </dd>
  <dt>sv_replace</dt>
  <dd>Make the first argument a copy of the second, then delete the original.
      The target SV physically takes over ownership of the body of the source SV
      and inherits its flags; however, the target keeps any magic it owns, and
      any magic in the source is discarded. Note that this is a rather
      specialist SV copying operation; most of the time you'll want to use
      <span class="Li">&quot;sv_setsv&quot;</span> or one of its many macro
      front-ends.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_replace(SV *const sv, SV *const nsv)
    </pre>
  </dd>
  <dt>sv_reset</dt>
  <dd>Underlying implementation for the
      <span class="Li">&quot;reset&quot;</span> Perl function. Note that the
      perl-level function is vaguely deprecated.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_reset(const char* s, HV *const stash)
    </pre>
  </dd>
  <dt>sv_rvweaken</dt>
  <dd>Weaken a reference: set the <span class="Li">&quot;SvWEAKREF&quot;</span>
      flag on this RV; give the referred-to SV
      <span class="Li">&quot;PERL_MAGIC_backref&quot;</span> magic if it hasn't
      already; and push a back-reference to this RV onto the array of
      backreferences associated with that magic. If the RV is magical, set magic
      will be called after the RV is cleared.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV*     sv_rvweaken(SV *const sv)
    </pre>
  </dd>
  <dt>sv_setiv</dt>
  <dd>Copies an integer into the given SV, upgrading first if necessary. Does
      not handle 'set' magic. See also
      <span class="Li">&quot;sv_setiv_mg&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_setiv(SV *const sv, const IV num)
    </pre>
  </dd>
  <dt>sv_setiv_mg</dt>
  <dd>Like <span class="Li">&quot;sv_setiv&quot;</span>, but also handles 'set'
      magic.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_setiv_mg(SV *const sv, const IV i)
    </pre>
  </dd>
  <dt>sv_setnv</dt>
  <dd>Copies a double into the given SV, upgrading first if necessary. Does not
      handle 'set' magic. See also
      <span class="Li">&quot;sv_setnv_mg&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_setnv(SV *const sv, const NV num)
    </pre>
  </dd>
  <dt>sv_setnv_mg</dt>
  <dd>Like <span class="Li">&quot;sv_setnv&quot;</span>, but also handles 'set'
      magic.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_setnv_mg(SV *const sv, const NV num)
    </pre>
  </dd>
  <dt>sv_setpv</dt>
  <dd>Copies a string into an SV. The string must be null-terminated. Does not
      handle 'set' magic. See <span class="Li">&quot;sv_setpv_mg&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_setpv(SV *const sv, const char *const ptr)
    </pre>
  </dd>
  <dt>sv_setpvf</dt>
  <dd>Works like <span class="Li">&quot;sv_catpvf&quot;</span> but copies the
      text into the SV instead of appending it. Does not handle 'set' magic. See
      <span class="Li">&quot;sv_setpvf_mg&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_setpvf(SV *const sv, const char *const pat,
                          ...)
    </pre>
  </dd>
  <dt>sv_setpvf_mg</dt>
  <dd>Like <span class="Li">&quot;sv_setpvf&quot;</span>, but also handles 'set'
      magic.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_setpvf_mg(SV *const sv,
                             const char *const pat, ...)
    </pre>
  </dd>
  <dt>sv_setpviv</dt>
  <dd>Copies an integer into the given SV, also updating its string value. Does
      not handle 'set' magic. See
      <span class="Li">&quot;sv_setpviv_mg&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_setpviv(SV *const sv, const IV num)
    </pre>
  </dd>
  <dt>sv_setpviv_mg</dt>
  <dd>Like <span class="Li">&quot;sv_setpviv&quot;</span>, but also handles
      'set' magic.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_setpviv_mg(SV *const sv, const IV iv)
    </pre>
  </dd>
  <dt>sv_setpvn</dt>
  <dd>Copies a string into an SV. The <span class="Li">&quot;len&quot;</span>
      parameter indicates the number of bytes to be copied. If the
      <span class="Li">&quot;ptr&quot;</span> argument is NULL the SV will
      become undefined. Does not handle 'set' magic. See
      <span class="Li">&quot;sv_setpvn_mg&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_setpvn(SV *const sv, const char *const ptr,
                          const STRLEN len)
    </pre>
  </dd>
  <dt>sv_setpvn_mg</dt>
  <dd>Like <span class="Li">&quot;sv_setpvn&quot;</span>, but also handles 'set'
      magic.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_setpvn_mg(SV *const sv,
                             const char *const ptr,
                             const STRLEN len)
    </pre>
  </dd>
  <dt>sv_setpvs</dt>
  <dd>Like <span class="Li">&quot;sv_setpvn&quot;</span>, but takes a literal
      string instead of a string/length pair.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_setpvs(SV* sv, const char* s)
    </pre>
  </dd>
  <dt>sv_setpvs_mg</dt>
  <dd>Like <span class="Li">&quot;sv_setpvn_mg&quot;</span>, but takes a literal
      string instead of a string/length pair.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_setpvs_mg(SV* sv, const char* s)
    </pre>
  </dd>
  <dt>sv_setpv_mg</dt>
  <dd>Like <span class="Li">&quot;sv_setpv&quot;</span>, but also handles 'set'
      magic.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_setpv_mg(SV *const sv, const char *const ptr)
    </pre>
  </dd>
  <dt>sv_setref_iv</dt>
  <dd>Copies an integer into a new SV, optionally blessing the SV. The
      <span class="Li">&quot;rv&quot;</span> argument will be upgraded to an RV.
      That RV will be modified to point to the new SV. The
      <span class="Li">&quot;classname&quot;</span> argument indicates the
      package for the blessing. Set
      <span class="Li">&quot;classname&quot;</span> to
      <span class="Li">&quot;NULL&quot;</span> to avoid the blessing. The new SV
      will have a reference count of 1, and the RV will be returned.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV*     sv_setref_iv(SV *const rv,
                             const char *const classname,
                             const IV iv)
    </pre>
  </dd>
  <dt>sv_setref_nv</dt>
  <dd>Copies a double into a new SV, optionally blessing the SV. The
      <span class="Li">&quot;rv&quot;</span> argument will be upgraded to an RV.
      That RV will be modified to point to the new SV. The
      <span class="Li">&quot;classname&quot;</span> argument indicates the
      package for the blessing. Set
      <span class="Li">&quot;classname&quot;</span> to
      <span class="Li">&quot;NULL&quot;</span> to avoid the blessing. The new SV
      will have a reference count of 1, and the RV will be returned.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV*     sv_setref_nv(SV *const rv,
                             const char *const classname,
                             const NV nv)
    </pre>
  </dd>
  <dt>sv_setref_pv</dt>
  <dd>Copies a pointer into a new SV, optionally blessing the SV. The
      <span class="Li">&quot;rv&quot;</span> argument will be upgraded to an RV.
      That RV will be modified to point to the new SV. If the
      <span class="Li">&quot;pv&quot;</span> argument is NULL then
      <span class="Li">&quot;PL_sv_undef&quot;</span> will be placed into the
      SV. The <span class="Li">&quot;classname&quot;</span> argument indicates
      the package for the blessing. Set
      <span class="Li">&quot;classname&quot;</span> to
      <span class="Li">&quot;NULL&quot;</span> to avoid the blessing. The new SV
      will have a reference count of 1, and the RV will be returned.
    <p class="Pp">Do not use with other Perl types such as HV, AV, SV, CV,
        because those objects will become corrupted by the pointer copy
      process.</p>
    <p class="Pp">Note that <span class="Li">&quot;sv_setref_pvn&quot;</span>
        copies the string while this copies the pointer.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV*     sv_setref_pv(SV *const rv,
                             const char *const classname,
                             void *const pv)
    </pre>
  </dd>
  <dt>sv_setref_pvn</dt>
  <dd>Copies a string into a new SV, optionally blessing the SV. The length of
      the string must be specified with <span class="Li">&quot;n&quot;</span>.
      The <span class="Li">&quot;rv&quot;</span> argument will be upgraded to an
      RV. That RV will be modified to point to the new SV. The
      <span class="Li">&quot;classname&quot;</span> argument indicates the
      package for the blessing. Set
      <span class="Li">&quot;classname&quot;</span> to
      <span class="Li">&quot;NULL&quot;</span> to avoid the blessing. The new SV
      will have a reference count of 1, and the RV will be returned.
    <p class="Pp">Note that <span class="Li">&quot;sv_setref_pv&quot;</span>
        copies the pointer while this copies the string.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV*     sv_setref_pvn(SV *const rv,
                              const char *const classname,
                              const char *const pv,
                              const STRLEN n)
    </pre>
  </dd>
  <dt>sv_setref_pvs</dt>
  <dd>Like <span class="Li">&quot;sv_setref_pvn&quot;</span>, but takes a
      literal string instead of a string/length pair.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV *    sv_setref_pvs(const char* s)
    </pre>
  </dd>
  <dt>sv_setref_uv</dt>
  <dd>Copies an unsigned integer into a new SV, optionally blessing the SV. The
      <span class="Li">&quot;rv&quot;</span> argument will be upgraded to an RV.
      That RV will be modified to point to the new SV. The
      <span class="Li">&quot;classname&quot;</span> argument indicates the
      package for the blessing. Set
      <span class="Li">&quot;classname&quot;</span> to
      <span class="Li">&quot;NULL&quot;</span> to avoid the blessing. The new SV
      will have a reference count of 1, and the RV will be returned.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV*     sv_setref_uv(SV *const rv,
                             const char *const classname,
                             const UV uv)
    </pre>
  </dd>
  <dt>sv_setsv</dt>
  <dd>Copies the contents of the source SV
      <span class="Li">&quot;ssv&quot;</span> into the destination SV
      <span class="Li">&quot;dsv&quot;</span>. The source SV may be destroyed if
      it is mortal, so don't use this function if the source SV needs to be
      reused. Does not handle 'set' magic. Loosely speaking, it performs a
      copy-by-value, obliterating any previous content of the destination.
    <p class="Pp">You probably want to use one of the assortment of wrappers,
        such as <span class="Li">&quot;SvSetSV&quot;</span>,
        <span class="Li">&quot;SvSetSV_nosteal&quot;</span>,
        <span class="Li">&quot;SvSetMagicSV&quot;</span> and
        <span class="Li">&quot;SvSetMagicSV_nosteal&quot;</span>.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_setsv(SV *dstr, SV *sstr)
    </pre>
  </dd>
  <dt>sv_setsv_flags</dt>
  <dd>Copies the contents of the source SV
      <span class="Li">&quot;ssv&quot;</span> into the destination SV
      <span class="Li">&quot;dsv&quot;</span>. The source SV may be destroyed if
      it is mortal, so don't use this function if the source SV needs to be
      reused. Does not handle 'set' magic. Loosely speaking, it performs a
      copy-by-value, obliterating any previous content of the destination. If
      the <span class="Li">&quot;flags&quot;</span> parameter has the
      <span class="Li">&quot;SV_GMAGIC&quot;</span> bit set, will
      <span class="Li">&quot;mg_get&quot;</span> on
      <span class="Li">&quot;ssv&quot;</span> if appropriate, else not. If the
      <span class="Li">&quot;flags&quot;</span> parameter has the
      <span class="Li">&quot;NOSTEAL&quot;</span> bit set then the buffers of
      temps will not be stolen. &lt;sv_setsv&gt; and
      <span class="Li">&quot;sv_setsv_nomg&quot;</span> are implemented in terms
      of this function.
    <p class="Pp">You probably want to use one of the assortment of wrappers,
        such as <span class="Li">&quot;SvSetSV&quot;</span>,
        <span class="Li">&quot;SvSetSV_nosteal&quot;</span>,
        <span class="Li">&quot;SvSetMagicSV&quot;</span> and
        <span class="Li">&quot;SvSetMagicSV_nosteal&quot;</span>.</p>
    <p class="Pp">This is the primary function for copying scalars, and most
        other copy-ish functions and macros use this underneath.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_setsv_flags(SV *dstr, SV *sstr,
                               const I32 flags)
    </pre>
  </dd>
  <dt>sv_setsv_mg</dt>
  <dd>Like <span class="Li">&quot;sv_setsv&quot;</span>, but also handles 'set'
      magic.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_setsv_mg(SV *const dstr, SV *const sstr)
    </pre>
  </dd>
  <dt>sv_setuv</dt>
  <dd>Copies an unsigned integer into the given SV, upgrading first if
      necessary. Does not handle 'set' magic. See also
      <span class="Li">&quot;sv_setuv_mg&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_setuv(SV *const sv, const UV num)
    </pre>
  </dd>
  <dt>sv_setuv_mg</dt>
  <dd>Like <span class="Li">&quot;sv_setuv&quot;</span>, but also handles 'set'
      magic.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_setuv_mg(SV *const sv, const UV u)
    </pre>
  </dd>
  <dt>sv_tainted</dt>
  <dd>Test an SV for taintedness. Use
      <span class="Li">&quot;SvTAINTED&quot;</span> instead.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    sv_tainted(SV *const sv)
    </pre>
  </dd>
  <dt>sv_true</dt>
  <dd>Returns true if the SV has a true value by Perl's rules. Use the
      <span class="Li">&quot;SvTRUE&quot;</span> macro instead, which may call
      <span class="Li">&quot;sv_true()&quot;</span> or may instead use an
      in-line version.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        I32     sv_true(SV *const sv)
    </pre>
  </dd>
  <dt>sv_unmagic</dt>
  <dd>Removes all magic of type <span class="Li">&quot;type&quot;</span> from an
      SV.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        int     sv_unmagic(SV *const sv, const int type)
    </pre>
  </dd>
  <dt>sv_unmagicext</dt>
  <dd>Removes all magic of type <span class="Li">&quot;type&quot;</span> with
      the specified <span class="Li">&quot;vtbl&quot;</span> from an SV.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        int     sv_unmagicext(SV *const sv, const int type,
                              MGVTBL *vtbl)
    </pre>
  </dd>
  <dt>sv_unref_flags</dt>
  <dd>Unsets the RV status of the SV, and decrements the reference count of
      whatever was being referenced by the RV. This can almost be thought of as
      a reversal of <span class="Li">&quot;newSVrv&quot;</span>. The
      <span class="Li">&quot;cflags&quot;</span> argument can contain
      <span class="Li">&quot;SV_IMMEDIATE_UNREF&quot;</span> to force the
      reference count to be decremented (otherwise the decrementing is
      conditional on the reference count being different from one or the
      reference being a readonly SV). See
      <span class="Li">&quot;SvROK_off&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_unref_flags(SV *const ref, const U32 flags)
    </pre>
  </dd>
  <dt>sv_untaint</dt>
  <dd>Untaint an SV. Use <span class="Li">&quot;SvTAINTED_off&quot;</span>
      instead.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_untaint(SV *const sv)
    </pre>
  </dd>
  <dt>sv_upgrade</dt>
  <dd>Upgrade an SV to a more complex form. Generally adds a new body type to
      the SV, then copies across as much information as possible from the old
      body. It croaks if the SV is already in a more complex form than
      requested. You generally want to use the
      <span class="Li">&quot;SvUPGRADE&quot;</span> macro wrapper, which checks
      the type before calling <span class="Li">&quot;sv_upgrade&quot;</span>,
      and hence does not croak. See also
      <span class="Li">&quot;svtype&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_upgrade(SV *const sv, svtype new_type)
    </pre>
  </dd>
  <dt>sv_usepvn_flags</dt>
  <dd>Tells an SV to use <span class="Li">&quot;ptr&quot;</span> to find its
      string value. Normally the string is stored inside the SV but sv_usepvn
      allows the SV to use an outside string. The
      <span class="Li">&quot;ptr&quot;</span> should point to memory that was
      allocated by <span class="Li">&quot;malloc&quot;</span>. It must be the
      start of a mallocked block of memory, and not a pointer to the middle of
      it. The string length, <span class="Li">&quot;len&quot;</span>, must be
      supplied. By default this function will realloc (i.e. move) the memory
      pointed to by <span class="Li">&quot;ptr&quot;</span>, so that pointer
      should not be freed or used by the programmer after giving it to
      sv_usepvn, and neither should any pointers from &quot;behind&quot; that
      pointer (e.g. ptr + 1) be used.
    <p class="Pp">If <span class="Li">&quot;flags&quot;</span> &amp; SV_SMAGIC
        is true, will call SvSETMAGIC. If
        <span class="Li">&quot;flags&quot;</span> &amp; SV_HAS_TRAILING_NUL is
        true, then <span class="Li">&quot;ptr[len]&quot;</span> must be NUL, and
        the realloc will be skipped (i.e. the buffer is actually at least 1 byte
        longer than <span class="Li">&quot;len&quot;</span>, and already meets
        the requirements for storing in
        <span class="Li">&quot;SvPVX&quot;</span>).</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_usepvn_flags(SV *const sv, char* ptr,
                                const STRLEN len,
                                const U32 flags)
    </pre>
  </dd>
  <dt>sv_utf8_decode</dt>
  <dd>If the PV of the SV is an octet sequence in UTF-8 and contains a
      multiple-byte character, the <span class="Li">&quot;SvUTF8&quot;</span>
      flag is turned on so that it looks like a character. If the PV contains
      only single-byte characters, the
      <span class="Li">&quot;SvUTF8&quot;</span> flag stays off. Scans PV for
      validity and returns false if the PV is invalid UTF-8.
    <p class="Pp">NOTE: this function is experimental and may change or be
        removed without notice.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    sv_utf8_decode(SV *const sv)
    </pre>
  </dd>
  <dt>sv_utf8_downgrade</dt>
  <dd>Attempts to convert the PV of an SV from characters to bytes. If the PV
      contains a character that cannot fit in a byte, this conversion will fail;
      in this case, either returns false or, if
      <span class="Li">&quot;fail_ok&quot;</span> is not true, croaks.
    <p class="Pp">This is not a general purpose Unicode to byte encoding
        interface: use the Encode extension for that.</p>
    <p class="Pp">NOTE: this function is experimental and may change or be
        removed without notice.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    sv_utf8_downgrade(SV *const sv,
                                  const bool fail_ok)
    </pre>
  </dd>
  <dt>sv_utf8_encode</dt>
  <dd>Converts the PV of an SV to UTF-8, but then turns the
      <span class="Li">&quot;SvUTF8&quot;</span> flag off so that it looks like
      octets again.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_utf8_encode(SV *const sv)
    </pre>
  </dd>
  <dt>sv_utf8_upgrade</dt>
  <dd>Converts the PV of an SV to its UTF-8-encoded form. Forces the SV to
      string form if it is not already. Will
      <span class="Li">&quot;mg_get&quot;</span> on
      <span class="Li">&quot;sv&quot;</span> if appropriate. Always sets the
      SvUTF8 flag to avoid future validity checks even if the whole string is
      the same in UTF-8 as not. Returns the number of bytes in the converted
      string
    <p class="Pp">This is not a general purpose byte encoding to Unicode
        interface: use the Encode extension for that.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        STRLEN  sv_utf8_upgrade(SV *sv)
    </pre>
  </dd>
  <dt>sv_utf8_upgrade_flags</dt>
  <dd>Converts the PV of an SV to its UTF-8-encoded form. Forces the SV to
      string form if it is not already. Always sets the SvUTF8 flag to avoid
      future validity checks even if all the bytes are invariant in UTF-8. If
      <span class="Li">&quot;flags&quot;</span> has
      <span class="Li">&quot;SV_GMAGIC&quot;</span> bit set, will
      <span class="Li">&quot;mg_get&quot;</span> on
      <span class="Li">&quot;sv&quot;</span> if appropriate, else not. Returns
      the number of bytes in the converted string
      <span class="Li">&quot;sv_utf8_upgrade&quot;</span> and
      <span class="Li">&quot;sv_utf8_upgrade_nomg&quot;</span> are implemented
      in terms of this function.
    <p class="Pp">This is not a general purpose byte encoding to Unicode
        interface: use the Encode extension for that.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        STRLEN  sv_utf8_upgrade_flags(SV *const sv,
                                      const I32 flags)
    </pre>
  </dd>
  <dt>sv_utf8_upgrade_nomg</dt>
  <dd>Like sv_utf8_upgrade, but doesn't do magic on
      <span class="Li">&quot;sv&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        STRLEN  sv_utf8_upgrade_nomg(SV *sv)
    </pre>
  </dd>
  <dt>sv_vcatpvf</dt>
  <dd>Processes its arguments like <span class="Li">&quot;vsprintf&quot;</span>
      and appends the formatted output to an SV. Does not handle 'set' magic.
      See <span class="Li">&quot;sv_vcatpvf_mg&quot;</span>.
    <p class="Pp">Usually used via its frontend
        <span class="Li">&quot;sv_catpvf&quot;</span>.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_vcatpvf(SV *const sv, const char *const pat,
                           va_list *const args)
    </pre>
  </dd>
  <dt>sv_vcatpvfn</dt>
  <dd><span class="Li"></span>
    <pre>
        void    sv_vcatpvfn(SV *const sv, const char *const pat,
                            const STRLEN patlen,
                            va_list *const args,
                            SV **const svargs, const I32 svmax,
                            bool *const maybe_tainted)
    </pre>
  </dd>
  <dt>sv_vcatpvfn_flags</dt>
  <dd>Processes its arguments like <span class="Li">&quot;vsprintf&quot;</span>
      and appends the formatted output to an SV. Uses an array of SVs if the C
      style variable argument list is missing (NULL). When running with taint
      checks enabled, indicates via
      <span class="Li">&quot;maybe_tainted&quot;</span> if results are
      untrustworthy (often due to the use of locales).
    <p class="Pp">If called as <span class="Li">&quot;sv_vcatpvfn&quot;</span>
        or flags include <span class="Li">&quot;SV_GMAGIC&quot;</span>, calls
        get magic.</p>
    <p class="Pp">Usually used via one of its frontends
        <span class="Li">&quot;sv_vcatpvf&quot;</span> and
        <span class="Li">&quot;sv_vcatpvf_mg&quot;</span>.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_vcatpvfn_flags(SV *const sv,
                                  const char *const pat,
                                  const STRLEN patlen,
                                  va_list *const args,
                                  SV **const svargs,
                                  const I32 svmax,
                                  bool *const maybe_tainted,
                                  const U32 flags)
    </pre>
  </dd>
  <dt>sv_vcatpvf_mg</dt>
  <dd>Like <span class="Li">&quot;sv_vcatpvf&quot;</span>, but also handles
      'set' magic.
    <p class="Pp">Usually used via its frontend
        <span class="Li">&quot;sv_catpvf_mg&quot;</span>.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_vcatpvf_mg(SV *const sv,
                              const char *const pat,
                              va_list *const args)
    </pre>
  </dd>
  <dt>sv_vsetpvf</dt>
  <dd>Works like <span class="Li">&quot;sv_vcatpvf&quot;</span> but copies the
      text into the SV instead of appending it. Does not handle 'set' magic. See
      <span class="Li">&quot;sv_vsetpvf_mg&quot;</span>.
    <p class="Pp">Usually used via its frontend
        <span class="Li">&quot;sv_setpvf&quot;</span>.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_vsetpvf(SV *const sv, const char *const pat,
                           va_list *const args)
    </pre>
  </dd>
  <dt>sv_vsetpvfn</dt>
  <dd>Works like <span class="Li">&quot;sv_vcatpvfn&quot;</span> but copies the
      text into the SV instead of appending it.
    <p class="Pp">Usually used via one of its frontends
        <span class="Li">&quot;sv_vsetpvf&quot;</span> and
        <span class="Li">&quot;sv_vsetpvf_mg&quot;</span>.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_vsetpvfn(SV *const sv, const char *const pat,
                            const STRLEN patlen,
                            va_list *const args,
                            SV **const svargs, const I32 svmax,
                            bool *const maybe_tainted)
    </pre>
  </dd>
  <dt>sv_vsetpvf_mg</dt>
  <dd>Like <span class="Li">&quot;sv_vsetpvf&quot;</span>, but also handles
      'set' magic.
    <p class="Pp">Usually used via its frontend
        <span class="Li">&quot;sv_setpvf_mg&quot;</span>.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_vsetpvf_mg(SV *const sv,
                              const char *const pat,
                              va_list *const args)
    </pre>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="Unicode_Support"><a class="permalink" href="#Unicode_Support">Unicode
  Support</a></h1>
<dl class="Bl-tag">
  <dt>bytes_cmp_utf8</dt>
  <dd>Compares the sequence of characters (stored as octets) in
      <span class="Li">&quot;b&quot;</span>,
      <span class="Li">&quot;blen&quot;</span> with the sequence of characters
      (stored as UTF-8) in <span class="Li">&quot;u&quot;</span>,
      <span class="Li">&quot;ulen&quot;</span>. Returns 0 if they are equal, -1
      or -2 if the first string is less than the second string, +1 or +2 if the
      first string is greater than the second string.
    <p class="Pp">-1 or +1 is returned if the shorter string was identical to
        the start of the longer string. -2 or +2 is returned if the was a
        difference between characters within the strings.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        int     bytes_cmp_utf8(const U8 *b, STRLEN blen,
                               const U8 *u, STRLEN ulen)
    </pre>
  </dd>
  <dt>bytes_from_utf8</dt>
  <dd>Converts a string <span class="Li">&quot;s&quot;</span> of length
      <span class="Li">&quot;len&quot;</span> from UTF-8 into native byte
      encoding. Unlike &quot;utf8_to_bytes&quot; but like
      &quot;bytes_to_utf8&quot;, returns a pointer to the newly-created string,
      and updates <span class="Li">&quot;len&quot;</span> to contain the new
      length. Returns the original string if no conversion occurs,
      <span class="Li">&quot;len&quot;</span> is unchanged. Do nothing if
      <span class="Li">&quot;is_utf8&quot;</span> points to 0. Sets
      <span class="Li">&quot;is_utf8&quot;</span> to 0 if
      <span class="Li">&quot;s&quot;</span> is converted or consisted entirely
      of characters that are invariant in utf8 (i.e., US-ASCII on non-EBCDIC
      machines).
    <p class="Pp">NOTE: this function is experimental and may change or be
        removed without notice.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        U8*     bytes_from_utf8(const U8 *s, STRLEN *len,
                                bool *is_utf8)
    </pre>
  </dd>
  <dt>bytes_to_utf8</dt>
  <dd>Converts a string <span class="Li">&quot;s&quot;</span> of length
      <span class="Li">&quot;len&quot;</span> bytes from the native encoding
      into UTF-8. Returns a pointer to the newly-created string, and sets
      <span class="Li">&quot;len&quot;</span> to reflect the new length in
      bytes.
    <p class="Pp">A NUL character will be written after the end of the
      string.</p>
    <p class="Pp">If you want to convert to UTF-8 from encodings other than the
        native (Latin1 or EBCDIC), see &quot;sv_recode_to_utf8&quot;().</p>
    <p class="Pp">NOTE: this function is experimental and may change or be
        removed without notice.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        U8*     bytes_to_utf8(const U8 *s, STRLEN *len)
    </pre>
  </dd>
  <dt>foldEQ_utf8</dt>
  <dd>Returns true if the leading portions of the strings
      <span class="Li">&quot;s1&quot;</span> and
      <span class="Li">&quot;s2&quot;</span> (either or both of which may be in
      UTF-8) are the same case-insensitively; false otherwise. How far into the
      strings to compare is determined by other input parameters.
    <p class="Pp">If <span class="Li">&quot;u1&quot;</span> is true, the string
        <span class="Li">&quot;s1&quot;</span> is assumed to be in UTF-8-encoded
        Unicode; otherwise it is assumed to be in native 8-bit encoding.
        Correspondingly for <span class="Li">&quot;u2&quot;</span> with respect
        to <span class="Li">&quot;s2&quot;</span>.</p>
    <p class="Pp">If the byte length <span class="Li">&quot;l1&quot;</span> is
        non-zero, it says how far into <span class="Li">&quot;s1&quot;</span> to
        check for fold equality. In other words,
        <span class="Li">&quot;s1&quot;</span>+<span class="Li">&quot;l1&quot;</span>
        will be used as a goal to reach. The scan will not be considered to be a
        match unless the goal is reached, and scanning won't continue past that
        goal. Correspondingly for <span class="Li">&quot;l2&quot;</span> with
        respect to <span class="Li">&quot;s2&quot;</span>.</p>
    <p class="Pp">If <span class="Li">&quot;pe1&quot;</span> is non-NULL and the
        pointer it points to is not NULL, that pointer is considered an end
        pointer to the position 1 byte past the maximum point in
        <span class="Li">&quot;s1&quot;</span> beyond which scanning will not
        continue under any circumstances. (This routine assumes that UTF-8
        encoded input strings are not malformed; malformed input can cause it to
        read past <span class="Li">&quot;pe1&quot;</span>). This means that if
        both <span class="Li">&quot;l1&quot;</span> and
        <span class="Li">&quot;pe1&quot;</span> are specified, and
        <span class="Li">&quot;pe1&quot;</span> is less than
        <span class="Li">&quot;s1&quot;</span>+<span class="Li">&quot;l1&quot;</span>,
        the match will never be successful because it can never get as far as
        its goal (and in fact is asserted against). Correspondingly for
        <span class="Li">&quot;pe2&quot;</span> with respect to
        <span class="Li">&quot;s2&quot;</span>.</p>
    <p class="Pp">At least one of <span class="Li">&quot;s1&quot;</span> and
        <span class="Li">&quot;s2&quot;</span> must have a goal (at least one of
        <span class="Li">&quot;l1&quot;</span> and
        <span class="Li">&quot;l2&quot;</span> must be non-zero), and if both
        do, both have to be reached for a successful match. Also, if the fold of
        a character is multiple characters, all of them must be matched (see
        tr21 reference below for 'folding').</p>
    <p class="Pp">Upon a successful match, if
        <span class="Li">&quot;pe1&quot;</span> is non-NULL, it will be set to
        point to the beginning of the <i>next</i> character of
        <span class="Li">&quot;s1&quot;</span> beyond what was matched.
        Correspondingly for <span class="Li">&quot;pe2&quot;</span> and
        <span class="Li">&quot;s2&quot;</span>.</p>
    <p class="Pp">For case-insensitiveness, the &quot;casefolding&quot; of
        Unicode is used instead of upper/lowercasing both the characters, see
        &lt;http://www.unicode.org/unicode/reports/tr21/&gt; (Case
      Mappings).</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        I32     foldEQ_utf8(const char *s1, char **pe1, UV l1,
                            bool u1, const char *s2, char **pe2,
                            UV l2, bool u2)
    </pre>
  </dd>
  <dt>is_ascii_string</dt>
  <dd>Returns true if the first <span class="Li">&quot;len&quot;</span> bytes of
      the string <span class="Li">&quot;s&quot;</span> are the same whether or
      not the string is encoded in UTF-8 (or UTF-EBCDIC on EBCDIC machines).
      That is, if they are invariant. On ASCII-ish machines, only ASCII
      characters fit this definition, hence the function's name.
    <p class="Pp">If <span class="Li">&quot;len&quot;</span> is 0, it will be
        calculated using <span class="Li">strlen(s)</span>.</p>
    <p class="Pp">See also &quot;is_utf8_string&quot;(),
        &quot;is_utf8_string_loclen&quot;(), and
        &quot;is_utf8_string_loc&quot;().</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    is_ascii_string(const U8 *s, STRLEN len)
    </pre>
  </dd>
  <dt>is_utf8_char</dt>
  <dd>DEPRECATED!
    <p class="Pp">Tests if some arbitrary number of bytes begins in a valid
        UTF-8 character. Note that an INVARIANT (i.e. ASCII on non-EBCDIC
        machines) character is a valid UTF-8 character. The actual number of
        bytes in the UTF-8 character will be returned if it is valid, otherwise
        0.</p>
    <p class="Pp">This function is deprecated due to the possibility that
        malformed input could cause reading beyond the end of the input buffer.
        Use &quot;is_utf8_char_buf&quot; instead.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        STRLEN  is_utf8_char(const U8 *s)
    </pre>
  </dd>
  <dt>is_utf8_char_buf</dt>
  <dd>Returns the number of bytes that comprise the first UTF-8 encoded
      character in buffer <span class="Li">&quot;buf&quot;</span>.
      <span class="Li">&quot;buf_end&quot;</span> should point to one position
      beyond the end of the buffer. 0 is returned if
      <span class="Li">&quot;buf&quot;</span> does not point to a complete,
      valid UTF-8 encoded character.
    <p class="Pp">Note that an INVARIANT character (i.e. ASCII on non-EBCDIC
        machines) is a valid UTF-8 character.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        STRLEN  is_utf8_char_buf(const U8 *buf,
                                 const U8 *buf_end)
    </pre>
  </dd>
  <dt>is_utf8_string</dt>
  <dd>Returns true if the first <span class="Li">&quot;len&quot;</span> bytes of
      string <span class="Li">&quot;s&quot;</span> form a valid UTF-8 string,
      false otherwise. If <span class="Li">&quot;len&quot;</span> is 0, it will
      be calculated using <span class="Li">strlen(s)</span> (which means if you
      use this option, that <span class="Li">&quot;s&quot;</span> has to have a
      terminating NUL byte). Note that all characters being ASCII constitute 'a
      valid UTF-8 string'.
    <p class="Pp">See also &quot;is_ascii_string&quot;(),
        &quot;is_utf8_string_loclen&quot;(), and
        &quot;is_utf8_string_loc&quot;().</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    is_utf8_string(const U8 *s, STRLEN len)
    </pre>
  </dd>
  <dt>is_utf8_string_loc</dt>
  <dd>Like &quot;is_utf8_string&quot; but stores the location of the failure (in
      the case of &quot;utf8ness failure&quot;) or the location
      <span class="Li">&quot;s&quot;</span>+<span class="Li">&quot;len&quot;</span>
      (in the case of &quot;utf8ness success&quot;) in the
      <span class="Li">&quot;ep&quot;</span>.
    <p class="Pp">See also &quot;is_utf8_string_loclen&quot;() and
        &quot;is_utf8_string&quot;().</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    is_utf8_string_loc(const U8 *s, STRLEN len,
                                   const U8 **ep)
    </pre>
  </dd>
  <dt>is_utf8_string_loclen</dt>
  <dd>Like &quot;is_utf8_string&quot;() but stores the location of the failure
      (in the case of &quot;utf8ness failure&quot;) or the location
      <span class="Li">&quot;s&quot;</span>+<span class="Li">&quot;len&quot;</span>
      (in the case of &quot;utf8ness success&quot;) in the
      <span class="Li">&quot;ep&quot;</span>, and the number of UTF-8 encoded
      characters in the <span class="Li">&quot;el&quot;</span>.
    <p class="Pp">See also &quot;is_utf8_string_loc&quot;() and
        &quot;is_utf8_string&quot;().</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    is_utf8_string_loclen(const U8 *s, STRLEN len,
                                      const U8 **ep, STRLEN *el)
    </pre>
  </dd>
  <dt>pv_uni_display</dt>
  <dd>Build to the scalar <span class="Li">&quot;dsv&quot;</span> a displayable
      version of the string <span class="Li">&quot;spv&quot;</span>, length
      <span class="Li">&quot;len&quot;</span>, the displayable version being at
      most <span class="Li">&quot;pvlim&quot;</span> bytes long (if longer, the
      rest is truncated and &quot;...&quot; will be appended).
    <p class="Pp">The <span class="Li">&quot;flags&quot;</span> argument can
        have UNI_DISPLAY_ISPRINT set to display <i>isPRINT()</i>able characters
        as themselves, UNI_DISPLAY_BACKSLASH to display the \\[nrfta\\] as the
        backslashed versions (like '\n') (UNI_DISPLAY_BACKSLASH is preferred
        over UNI_DISPLAY_ISPRINT for \\). UNI_DISPLAY_QQ (and its alias
        UNI_DISPLAY_REGEX) have both UNI_DISPLAY_BACKSLASH and
        UNI_DISPLAY_ISPRINT turned on.</p>
    <p class="Pp">The pointer to the PV of the
        <span class="Li">&quot;dsv&quot;</span> is returned.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        char*   pv_uni_display(SV *dsv, const U8 *spv,
                               STRLEN len, STRLEN pvlim,
                               UV flags)
    </pre>
  </dd>
  <dt>sv_cat_decode</dt>
  <dd>The encoding is assumed to be an Encode object, the PV of the ssv is
      assumed to be octets in that encoding and decoding the input starts from
      the position which (PV + *offset) pointed to. The dsv will be concatenated
      the decoded UTF-8 string from ssv. Decoding will terminate when the string
      tstr appears in decoding output or the input ends on the PV of the ssv.
      The value which the offset points will be modified to the last input
      position on the ssv.
    <p class="Pp">Returns TRUE if the terminator was found, else returns
      FALSE.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    sv_cat_decode(SV* dsv, SV *encoding, SV *ssv,
                              int *offset, char* tstr, int tlen)
    </pre>
  </dd>
  <dt>sv_recode_to_utf8</dt>
  <dd>The encoding is assumed to be an Encode object, on entry the PV of the sv
      is assumed to be octets in that encoding, and the sv will be converted
      into Unicode (and UTF-8).
    <p class="Pp">If the sv already is UTF-8 (or if it is not POK), or if the
        encoding is not a reference, nothing is done to the sv. If the encoding
        is not an <span class="Li">&quot;Encode::XS&quot;</span> Encoding
        object, bad things will happen. (See <i>lib/encoding.pm</i> and
      Encode.)</p>
    <p class="Pp">The PV of the sv is returned.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        char*   sv_recode_to_utf8(SV* sv, SV *encoding)
    </pre>
  </dd>
  <dt>sv_uni_display</dt>
  <dd>Build to the scalar <span class="Li">&quot;dsv&quot;</span> a displayable
      version of the scalar <span class="Li">&quot;sv&quot;</span>, the
      displayable version being at most
      <span class="Li">&quot;pvlim&quot;</span> bytes long (if longer, the rest
      is truncated and &quot;...&quot; will be appended).
    <p class="Pp">The <span class="Li">&quot;flags&quot;</span> argument is as
        in &quot;pv_uni_display&quot;().</p>
    <p class="Pp">The pointer to the PV of the
        <span class="Li">&quot;dsv&quot;</span> is returned.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        char*   sv_uni_display(SV *dsv, SV *ssv, STRLEN pvlim,
                               UV flags)
    </pre>
  </dd>
  <dt>to_utf8_case</dt>
  <dd>The <span class="Li">&quot;p&quot;</span> contains the pointer to the
      UTF-8 string encoding the character that is being converted. This routine
      assumes that the character at <span class="Li">&quot;p&quot;</span> is
      well-formed.
    <p class="Pp">The <span class="Li">&quot;ustrp&quot;</span> is a pointer to
        the character buffer to put the conversion result to. The
        <span class="Li">&quot;lenp&quot;</span> is a pointer to the length of
        the result.</p>
    <p class="Pp">The <span class="Li">&quot;swashp&quot;</span> is a pointer to
        the swash to use.</p>
    <p class="Pp">Both the special and normal mappings are stored in
        <i>lib/unicore/To/Foo.pl</i>, and loaded by SWASHNEW, using
        <i>lib/utf8_heavy.pl</i>. The
        <span class="Li">&quot;special&quot;</span> (usually, but not always, a
        multicharacter mapping), is tried first.</p>
    <p class="Pp">The <span class="Li">&quot;special&quot;</span> is a string
        like &quot;utf8::ToSpecLower&quot;, which means the hash
        <span class="Li">%utf8::ToSpecLower</span>. The access to the hash is
        through <i>Perl_to_utf8_case()</i>.</p>
    <p class="Pp">The <span class="Li">&quot;normal&quot;</span> is a string
        like &quot;ToLower&quot; which means the swash
        <span class="Li">%utf8::ToLower</span>.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        UV      to_utf8_case(const U8 *p, U8* ustrp,
                             STRLEN *lenp, SV **swashp,
                             const char *normal,
                             const char *special)
    </pre>
  </dd>
  <dt>to_utf8_fold</dt>
  <dd>Convert the UTF-8 encoded character at
      <span class="Li">&quot;p&quot;</span> to its foldcase version and store
      that in UTF-8 in <span class="Li">&quot;ustrp&quot;</span> and its length
      in bytes in <span class="Li">&quot;lenp&quot;</span>. Note that the
      <span class="Li">&quot;ustrp&quot;</span> needs to be at least
      UTF8_MAXBYTES_CASE+1 bytes since the foldcase version may be longer than
      the original character (up to three characters).
    <p class="Pp">The first character of the foldcased version is returned (but
        note, as explained above, that there may be more.)</p>
    <p class="Pp">The character at <span class="Li">&quot;p&quot;</span> is
        assumed by this routine to be well-formed.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        UV      to_utf8_fold(const U8 *p, U8* ustrp,
                             STRLEN *lenp)
    </pre>
  </dd>
  <dt>to_utf8_lower</dt>
  <dd>Convert the UTF-8 encoded character at
      <span class="Li">&quot;p&quot;</span> to its lowercase version and store
      that in UTF-8 in ustrp and its length in bytes in
      <span class="Li">&quot;lenp&quot;</span>. Note that the
      <span class="Li">&quot;ustrp&quot;</span> needs to be at least
      UTF8_MAXBYTES_CASE+1 bytes since the lowercase version may be longer than
      the original character.
    <p class="Pp">The first character of the lowercased version is returned (but
        note, as explained above, that there may be more.)</p>
    <p class="Pp">The character at <span class="Li">&quot;p&quot;</span> is
        assumed by this routine to be well-formed.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        UV      to_utf8_lower(const U8 *p, U8* ustrp,
                              STRLEN *lenp)
    </pre>
  </dd>
  <dt>to_utf8_title</dt>
  <dd>Convert the UTF-8 encoded character at
      <span class="Li">&quot;p&quot;</span> to its titlecase version and store
      that in UTF-8 in <span class="Li">&quot;ustrp&quot;</span> and its length
      in bytes in <span class="Li">&quot;lenp&quot;</span>. Note that the
      <span class="Li">&quot;ustrp&quot;</span> needs to be at least
      UTF8_MAXBYTES_CASE+1 bytes since the titlecase version may be longer than
      the original character.
    <p class="Pp">The first character of the titlecased version is returned (but
        note, as explained above, that there may be more.)</p>
    <p class="Pp">The character at <span class="Li">&quot;p&quot;</span> is
        assumed by this routine to be well-formed.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        UV      to_utf8_title(const U8 *p, U8* ustrp,
                              STRLEN *lenp)
    </pre>
  </dd>
  <dt>to_utf8_upper</dt>
  <dd>Convert the UTF-8 encoded character at
      <span class="Li">&quot;p&quot;</span> to its uppercase version and store
      that in UTF-8 in <span class="Li">&quot;ustrp&quot;</span> and its length
      in bytes in <span class="Li">&quot;lenp&quot;</span>. Note that the ustrp
      needs to be at least UTF8_MAXBYTES_CASE+1 bytes since the uppercase
      version may be longer than the original character.
    <p class="Pp">The first character of the uppercased version is returned (but
        note, as explained above, that there may be more.)</p>
    <p class="Pp">The character at <span class="Li">&quot;p&quot;</span> is
        assumed by this routine to be well-formed.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        UV      to_utf8_upper(const U8 *p, U8* ustrp,
                              STRLEN *lenp)
    </pre>
  </dd>
  <dt>utf8n_to_uvchr</dt>
  <dd>Returns the native character value of the first character in the string
      <span class="Li">&quot;s&quot;</span> which is assumed to be in UTF-8
      encoding; <span class="Li">&quot;retlen&quot;</span> will be set to the
      length, in bytes, of that character.
    <p class="Pp"><span class="Li">&quot;length&quot;</span> and
        <span class="Li">&quot;flags&quot;</span> are the same as
        &quot;utf8n_to_uvuni&quot;().</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        UV      utf8n_to_uvchr(const U8 *s, STRLEN curlen,
                               STRLEN *retlen, U32 flags)
    </pre>
  </dd>
  <dt>utf8n_to_uvuni</dt>
  <dd>Bottom level UTF-8 decode routine. Returns the code point value of the
      first character in the string <span class="Li">&quot;s&quot;</span>, which
      is assumed to be in UTF-8 (or UTF-EBCDIC) encoding, and no longer than
      <span class="Li">&quot;curlen&quot;</span> bytes;
      <span class="Li">*retlen</span> (if
      <span class="Li">&quot;retlen&quot;</span> isn't NULL) will be set to the
      length, in bytes, of that character.
    <p class="Pp">The value of <span class="Li">&quot;flags&quot;</span>
        determines the behavior when <span class="Li">&quot;s&quot;</span> does
        not point to a well-formed UTF-8 character. If
        <span class="Li">&quot;flags&quot;</span> is 0, when a malformation is
        found, zero is returned and <span class="Li">*retlen</span> is set so
        that
        (<span class="Li">&quot;s&quot;</span>&#x00A0;+&#x00A0;<span class="Li">*retlen</span>)
        is the next possible position in <span class="Li">&quot;s&quot;</span>
        that could begin a non-malformed character. Also, if UTF-8 warnings
        haven't been lexically disabled, a warning is raised.</p>
    <p class="Pp">Various ALLOW flags can be set in
        <span class="Li">&quot;flags&quot;</span> to allow (and not warn on)
        individual types of malformations, such as the sequence being overlong
        (that is, when there is a shorter sequence that can express the same
        code point; overlong sequences are expressly forbidden in the UTF-8
        standard due to potential security issues). Another malformation example
        is the first byte of a character not being a legal first byte. See
        <i>utf8.h</i> for the list of such flags. For allowed 0 length strings,
        this function returns 0; for allowed overlong sequences, the computed
        code point is returned; for all other allowed malformations, the Unicode
        REPLACEMENT CHARACTER is returned, as these have no determinable
        reasonable value.</p>
    <p class="Pp">The UTF8_CHECK_ONLY flag overrides the behavior when a
        non-allowed (by other flags) malformation is found. If this flag is set,
        the routine assumes that the caller will raise a warning, and this
        function will silently just set
        <span class="Li">&quot;retlen&quot;</span> to
        <span class="Li">&quot;-1&quot;</span> (cast to
        <span class="Li">&quot;STRLEN&quot;</span>) and return zero.</p>
    <p class="Pp">Note that this API requires disambiguation between successful
        decoding a NUL character, and an error return (unless the
        UTF8_CHECK_ONLY flag is set), as in both cases, 0 is returned. To
        disambiguate, upon a zero return, see if the first byte of
        <span class="Li">&quot;s&quot;</span> is 0 as well. If so, the input was
        a NUL; if not, the input had an error.</p>
    <p class="Pp">Certain code points are considered problematic. These are
        Unicode surrogates, Unicode non-characters, and code points above the
        Unicode maximum of 0x10FFFF. By default these are considered regular
        code points, but certain situations warrant special handling for them.
        If <span class="Li">&quot;flags&quot;</span> contains
        UTF8_DISALLOW_ILLEGAL_INTERCHANGE, all three classes are treated as
        malformations and handled as such. The flags UTF8_DISALLOW_SURROGATE,
        UTF8_DISALLOW_NONCHAR, and UTF8_DISALLOW_SUPER (meaning above the legal
        Unicode maximum) can be set to disallow these categories
      individually.</p>
    <p class="Pp">The flags UTF8_WARN_ILLEGAL_INTERCHANGE, UTF8_WARN_SURROGATE,
        UTF8_WARN_NONCHAR, and UTF8_WARN_SUPER will cause warning messages to be
        raised for their respective categories, but otherwise the code points
        are considered valid (not malformations). To get a category to both be
        treated as a malformation and raise a warning, specify both the WARN and
        DISALLOW flags. (But note that warnings are not raised if lexically
        disabled nor if UTF8_CHECK_ONLY is also specified.)</p>
    <p class="Pp">Very large code points (above 0x7FFF_FFFF) are considered more
        problematic than the others that are above the Unicode legal maximum.
        There are several reasons: they requre at least 32 bits to represent
        them on ASCII platforms, are not representable at all on EBCDIC
        platforms, and the original UTF-8 specification never went above this
        number (the current 0x10FFFF limit was imposed later). (The smaller
        ones, those that fit into 32 bits, are representable by a UV on ASCII
        platforms, but not by an IV, which means that the number of operations
        that can be performed on them is quite restricted.) The UTF-8 encoding
        on ASCII platforms for these large code points begins with a byte
        containing 0xFE or 0xFF. The UTF8_DISALLOW_FE_FF flag will cause them to
        be treated as malformations, while allowing smaller above-Unicode code
        points. (Of course UTF8_DISALLOW_SUPER will treat all above-Unicode code
        points, including these, as malformations.) Similarly, UTF8_WARN_FE_FF
        acts just like the other WARN flags, but applies just to these code
        points.</p>
    <p class="Pp">All other code points corresponding to Unicode characters,
        including private use and those yet to be assigned, are never considered
        malformed and never warn.</p>
    <p class="Pp">Most code should use &quot;utf8_to_uvchr_buf&quot;() rather
        than call this directly.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        UV      utf8n_to_uvuni(const U8 *s, STRLEN curlen,
                               STRLEN *retlen, U32 flags)
    </pre>
  </dd>
  <dt>utf8_distance</dt>
  <dd>Returns the number of UTF-8 characters between the UTF-8 pointers
      <span class="Li">&quot;a&quot;</span> and
      <span class="Li">&quot;b&quot;</span>.
    <p class="Pp">WARNING: use only if you *know* that the pointers point inside
        the same UTF-8 buffer.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        IV      utf8_distance(const U8 *a, const U8 *b)
    </pre>
  </dd>
  <dt>utf8_hop</dt>
  <dd>Return the UTF-8 pointer <span class="Li">&quot;s&quot;</span> displaced
      by <span class="Li">&quot;off&quot;</span> characters, either forward or
      backward.
    <p class="Pp">WARNING: do not use the following unless you *know*
        <span class="Li">&quot;off&quot;</span> is within the UTF-8 data pointed
        to by <span class="Li">&quot;s&quot;</span> *and* that on entry
        <span class="Li">&quot;s&quot;</span> is aligned on the first byte of
        character or just after the last byte of a character.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        U8*     utf8_hop(const U8 *s, I32 off)
    </pre>
  </dd>
  <dt>utf8_length</dt>
  <dd>Return the length of the UTF-8 char encoded string
      <span class="Li">&quot;s&quot;</span> in characters. Stops at
      <span class="Li">&quot;e&quot;</span> (inclusive). If
      <span class="Li">&quot;e &lt; s&quot;</span> or if the scan would end up
      past <span class="Li">&quot;e&quot;</span>, croaks.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        STRLEN  utf8_length(const U8* s, const U8 *e)
    </pre>
  </dd>
  <dt>utf8_to_bytes</dt>
  <dd>Converts a string <span class="Li">&quot;s&quot;</span> of length
      <span class="Li">&quot;len&quot;</span> from UTF-8 into native byte
      encoding. Unlike &quot;bytes_to_utf8&quot;, this over-writes the original
      string, and updates <span class="Li">&quot;len&quot;</span> to contain the
      new length. Returns zero on failure, setting
      <span class="Li">&quot;len&quot;</span> to -1.
    <p class="Pp">If you need a copy of the string, see
        &quot;bytes_from_utf8&quot;.</p>
    <p class="Pp">NOTE: this function is experimental and may change or be
        removed without notice.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        U8*     utf8_to_bytes(U8 *s, STRLEN *len)
    </pre>
  </dd>
  <dt>utf8_to_uvchr</dt>
  <dd>DEPRECATED!
    <p class="Pp">Returns the native code point of the first character in the
        string <span class="Li">&quot;s&quot;</span> which is assumed to be in
        UTF-8 encoding; <span class="Li">&quot;retlen&quot;</span> will be set
        to the length, in bytes, of that character.</p>
    <p class="Pp">Some, but not all, UTF-8 malformations are detected, and in
        fact, some malformed input could cause reading beyond the end of the
        input buffer, which is why this function is deprecated. Use
        &quot;utf8_to_uvchr_buf&quot; instead.</p>
    <p class="Pp">If <span class="Li">&quot;s&quot;</span> points to one of the
        detected malformations, and UTF8 warnings are enabled, zero is returned
        and <span class="Li">*retlen</span> is set (if
        <span class="Li">&quot;retlen&quot;</span> isn't NULL) to -1. If those
        warnings are off, the computed value if well-defined (or the Unicode
        REPLACEMENT CHARACTER, if not) is silently returned, and
        <span class="Li">*retlen</span> is set (if
        <span class="Li">&quot;retlen&quot;</span> isn't NULL) so that
        (<span class="Li">&quot;s&quot;</span>&#x00A0;+&#x00A0;<span class="Li">*retlen</span>)
        is the next possible position in <span class="Li">&quot;s&quot;</span>
        that could begin a non-malformed character. See
        &quot;utf8n_to_uvuni&quot; for details on when the REPLACEMENT CHARACTER
        is returned.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        UV      utf8_to_uvchr(const U8 *s, STRLEN *retlen)
    </pre>
  </dd>
  <dt>utf8_to_uvchr_buf</dt>
  <dd>Returns the native code point of the first character in the string
      <span class="Li">&quot;s&quot;</span> which is assumed to be in UTF-8
      encoding; <span class="Li">&quot;send&quot;</span> points to 1 beyond the
      end of <span class="Li">&quot;s&quot;</span>.
      <span class="Li">*retlen</span> will be set to the length, in bytes, of
      that character.
    <p class="Pp">If <span class="Li">&quot;s&quot;</span> does not point to a
        well-formed UTF-8 character and UTF8 warnings are enabled, zero is
        returned and <span class="Li">*retlen</span> is set (if
        <span class="Li">&quot;retlen&quot;</span> isn't NULL) to -1. If those
        warnings are off, the computed value, if well-defined (or the Unicode
        REPLACEMENT CHARACTER if not), is silently returned, and
        <span class="Li">*retlen</span> is set (if
        <span class="Li">&quot;retlen&quot;</span> isn't NULL) so that
        (<span class="Li">&quot;s&quot;</span>&#x00A0;+&#x00A0;<span class="Li">*retlen</span>)
        is the next possible position in <span class="Li">&quot;s&quot;</span>
        that could begin a non-malformed character. See
        &quot;utf8n_to_uvuni&quot; for details on when the REPLACEMENT CHARACTER
        is returned.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        UV      utf8_to_uvchr_buf(const U8 *s, const U8 *send,
                                  STRLEN *retlen)
    </pre>
  </dd>
  <dt>utf8_to_uvuni</dt>
  <dd>DEPRECATED!
    <p class="Pp">Returns the Unicode code point of the first character in the
        string <span class="Li">&quot;s&quot;</span> which is assumed to be in
        UTF-8 encoding; <span class="Li">&quot;retlen&quot;</span> will be set
        to the length, in bytes, of that character.</p>
    <p class="Pp">This function should only be used when the returned UV is
        considered an index into the Unicode semantic tables (e.g. swashes).</p>
    <p class="Pp">Some, but not all, UTF-8 malformations are detected, and in
        fact, some malformed input could cause reading beyond the end of the
        input buffer, which is why this function is deprecated. Use
        &quot;utf8_to_uvuni_buf&quot; instead.</p>
    <p class="Pp">If <span class="Li">&quot;s&quot;</span> points to one of the
        detected malformations, and UTF8 warnings are enabled, zero is returned
        and <span class="Li">*retlen</span> is set (if
        <span class="Li">&quot;retlen&quot;</span> doesn't point to NULL) to -1.
        If those warnings are off, the computed value if well-defined (or the
        Unicode REPLACEMENT CHARACTER, if not) is silently returned, and
        <span class="Li">*retlen</span> is set (if
        <span class="Li">&quot;retlen&quot;</span> isn't NULL) so that
        (<span class="Li">&quot;s&quot;</span>&#x00A0;+&#x00A0;<span class="Li">*retlen</span>)
        is the next possible position in <span class="Li">&quot;s&quot;</span>
        that could begin a non-malformed character. See
        &quot;utf8n_to_uvuni&quot; for details on when the REPLACEMENT CHARACTER
        is returned.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        UV      utf8_to_uvuni(const U8 *s, STRLEN *retlen)
    </pre>
  </dd>
  <dt>utf8_to_uvuni_buf</dt>
  <dd>Returns the Unicode code point of the first character in the string
      <span class="Li">&quot;s&quot;</span> which is assumed to be in UTF-8
      encoding; <span class="Li">&quot;send&quot;</span> points to 1 beyond the
      end of <span class="Li">&quot;s&quot;</span>.
      <span class="Li">&quot;retlen&quot;</span> will be set to the length, in
      bytes, of that character.
    <p class="Pp">This function should only be used when the returned UV is
        considered an index into the Unicode semantic tables (e.g. swashes).</p>
    <p class="Pp">If <span class="Li">&quot;s&quot;</span> does not point to a
        well-formed UTF-8 character and UTF8 warnings are enabled, zero is
        returned and <span class="Li">*retlen</span> is set (if
        <span class="Li">&quot;retlen&quot;</span> isn't NULL) to -1. If those
        warnings are off, the computed value if well-defined (or the Unicode
        REPLACEMENT CHARACTER, if not) is silently returned, and
        <span class="Li">*retlen</span> is set (if
        <span class="Li">&quot;retlen&quot;</span> isn't NULL) so that
        (<span class="Li">&quot;s&quot;</span>&#x00A0;+&#x00A0;<span class="Li">*retlen</span>)
        is the next possible position in <span class="Li">&quot;s&quot;</span>
        that could begin a non-malformed character. See
        &quot;utf8n_to_uvuni&quot; for details on when the REPLACEMENT CHARACTER
        is returned.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        UV      utf8_to_uvuni_buf(const U8 *s, const U8 *send,
                                  STRLEN *retlen)
    </pre>
  </dd>
  <dt>uvchr_to_utf8</dt>
  <dd>Adds the UTF-8 representation of the Native code point
      <span class="Li">&quot;uv&quot;</span> to the end of the string
      <span class="Li">&quot;d&quot;</span>;
      <span class="Li">&quot;d&quot;</span> should have at least
      <span class="Li">&quot;UTF8_MAXBYTES+1&quot;</span> free bytes available.
      The return value is the pointer to the byte after the end of the new
      character. In other words,
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    d = uvchr_to_utf8(d, uv);
    </pre>
    <p class="Pp">is the recommended wide native character-aware way of
      saying</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    *(d++) = uv;

        U8*     uvchr_to_utf8(U8 *d, UV uv)
    </pre>
  </dd>
  <dt>uvuni_to_utf8_flags</dt>
  <dd>Adds the UTF-8 representation of the Unicode code point
      <span class="Li">&quot;uv&quot;</span> to the end of the string
      <span class="Li">&quot;d&quot;</span>;
      <span class="Li">&quot;d&quot;</span> should have at least
      <span class="Li">&quot;UTF8_MAXBYTES+1&quot;</span> free bytes available.
      The return value is the pointer to the byte after the end of the new
      character. In other words,
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    d = uvuni_to_utf8_flags(d, uv, flags);
    </pre>
    <p class="Pp">or, in most cases,</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    d = uvuni_to_utf8(d, uv);
    </pre>
    <p class="Pp">(which is equivalent to)</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    d = uvuni_to_utf8_flags(d, uv, 0);
    </pre>
    <p class="Pp">This is the recommended Unicode-aware way of saying</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    *(d++) = uv;
    </pre>
    <p class="Pp">where uv is a code point expressed in Latin-1 or above, not
        the platform's native character set. <b>Almost all code should instead
        use &quot;uvchr_to_utf8&quot;</b> <b>or
        &quot;uvchr_to_utf8_flags&quot;</b>.</p>
    <p class="Pp">This function will convert to UTF-8 (and not warn) even code
        points that aren't legal Unicode or are problematic, unless
        <span class="Li">&quot;flags&quot;</span> contains one or more of the
        following flags:</p>
    <p class="Pp">If <span class="Li">&quot;uv&quot;</span> is a Unicode
        surrogate code point and UNICODE_WARN_SURROGATE is set, the function
        will raise a warning, provided UTF8 warnings are enabled. If instead
        UNICODE_DISALLOW_SURROGATE is set, the function will fail and return
        NULL. If both flags are set, the function will both warn and return
        NULL.</p>
    <p class="Pp">The UNICODE_WARN_NONCHAR and UNICODE_DISALLOW_NONCHAR flags
        correspondingly affect how the function handles a Unicode non-character.
        And likewise, the UNICODE_WARN_SUPER and UNICODE_DISALLOW_SUPER flags,
        affect the handling of code points that are above the Unicode maximum of
        0x10FFFF. Code points above 0x7FFF_FFFF (which are even less portable)
        can be warned and/or disallowed even if other above-Unicode code points
        are accepted by the UNICODE_WARN_FE_FF and UNICODE_DISALLOW_FE_FF
      flags.</p>
    <p class="Pp">And finally, the flag UNICODE_WARN_ILLEGAL_INTERCHANGE selects
        all four of the above WARN flags; and
        UNICODE_DISALLOW_ILLEGAL_INTERCHANGE selects all four DISALLOW
      flags.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        U8*     uvuni_to_utf8_flags(U8 *d, UV uv, UV flags)
    </pre>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="Variables_created_by__xsubpp__and__xsubpp__internal_functions"><a class="permalink" href="#Variables_created_by__xsubpp__and__xsubpp__internal_functions">Variables
  created by &quot;xsubpp&quot; and &quot;xsubpp&quot; internal
  functions</a></h1>
<dl class="Bl-tag">
  <dt>ax</dt>
  <dd>Variable which is setup by <span class="Li">&quot;xsubpp&quot;</span> to
      indicate the stack base offset, used by the
      <span class="Li">&quot;ST&quot;</span>,
      <span class="Li">&quot;XSprePUSH&quot;</span> and
      <span class="Li">&quot;XSRETURN&quot;</span> macros. The
      <span class="Li">&quot;dMARK&quot;</span> macro must be called prior to
      setup the <span class="Li">&quot;MARK&quot;</span> variable.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        I32     ax
    </pre>
  </dd>
  <dt>CLASS </dt>
  <dd>Variable which is setup by <span class="Li">&quot;xsubpp&quot;</span> to
      indicate the class name for a C++ XS constructor. This is always a
      <span class="Li">&quot;char*&quot;</span>. See
      <span class="Li">&quot;THIS&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        char*   CLASS
    </pre>
  </dd>
  <dt>dAX</dt>
  <dd>Sets up the <span class="Li">&quot;ax&quot;</span> variable. This is
      usually handled automatically by
      <span class="Li">&quot;xsubpp&quot;</span> by calling
      <span class="Li">&quot;dXSARGS&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
                dAX;
    </pre>
  </dd>
  <dt>dAXMARK</dt>
  <dd>Sets up the <span class="Li">&quot;ax&quot;</span> variable and stack
      marker variable <span class="Li">&quot;mark&quot;</span>. This is usually
      handled automatically by <span class="Li">&quot;xsubpp&quot;</span> by
      calling <span class="Li">&quot;dXSARGS&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
                dAXMARK;
    </pre>
  </dd>
  <dt>dITEMS</dt>
  <dd>Sets up the <span class="Li">&quot;items&quot;</span> variable. This is
      usually handled automatically by
      <span class="Li">&quot;xsubpp&quot;</span> by calling
      <span class="Li">&quot;dXSARGS&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
                dITEMS;
    </pre>
  </dd>
  <dt>dUNDERBAR</dt>
  <dd>Sets up any variable needed by the
      <span class="Li">&quot;UNDERBAR&quot;</span> macro. It used to define
      <span class="Li">&quot;padoff_du&quot;</span>, but it is currently a noop.
      However, it is strongly advised to still use it for ensuring past and
      future compatibility.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
                dUNDERBAR;
    </pre>
  </dd>
  <dt>dXSARGS</dt>
  <dd>Sets up stack and mark pointers for an XSUB, calling dSP and dMARK. Sets
      up the <span class="Li">&quot;ax&quot;</span> and
      <span class="Li">&quot;items&quot;</span> variables by calling
      <span class="Li">&quot;dAX&quot;</span> and
      <span class="Li">&quot;dITEMS&quot;</span>. This is usually handled
      automatically by <span class="Li">&quot;xsubpp&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
                dXSARGS;
    </pre>
  </dd>
  <dt>dXSI32</dt>
  <dd>Sets up the <span class="Li">&quot;ix&quot;</span> variable for an XSUB
      which has aliases. This is usually handled automatically by
      <span class="Li">&quot;xsubpp&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
                dXSI32;
    </pre>
  </dd>
  <dt>items</dt>
  <dd>Variable which is setup by <span class="Li">&quot;xsubpp&quot;</span> to
      indicate the number of items on the stack. See &quot;Variable-length
      Parameter Lists&quot; in perlxs.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        I32     items
    </pre>
  </dd>
  <dt>ix</dt>
  <dd>Variable which is setup by <span class="Li">&quot;xsubpp&quot;</span> to
      indicate which of an XSUB's aliases was used to invoke it. See &quot;The
      ALIAS: Keyword&quot; in perlxs.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        I32     ix
    </pre>
  </dd>
  <dt>newXSproto</dt>
  <dd>Used by <span class="Li">&quot;xsubpp&quot;</span> to hook up XSUBs as
      Perl subs. Adds Perl prototypes to the subs.</dd>
  <dt>RETVAL </dt>
  <dd>Variable which is setup by <span class="Li">&quot;xsubpp&quot;</span> to
      hold the return value for an XSUB. This is always the proper type for the
      XSUB. See &quot;The RETVAL Variable&quot; in perlxs.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        (whatever)      RETVAL
    </pre>
  </dd>
  <dt>ST </dt>
  <dd>Used to access elements on the XSUB's stack.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV*     ST(int ix)
    </pre>
  </dd>
  <dt>THIS </dt>
  <dd>Variable which is setup by <span class="Li">&quot;xsubpp&quot;</span> to
      designate the object in a C++ XSUB. This is always the proper type for the
      C++ object. See <span class="Li">&quot;CLASS&quot;</span> and &quot;Using
      XS With C++&quot; in perlxs.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        (whatever)      THIS
    </pre>
  </dd>
  <dt>UNDERBAR </dt>
  <dd>The SV* corresponding to the <span class="Li">$_</span> variable. Works
      even if there is a lexical <span class="Li">$_</span> in scope.</dd>
  <dt>XS </dt>
  <dd>Macro to declare an XSUB and its C parameter list. This is handled by
      <span class="Li">&quot;xsubpp&quot;</span>. It is the same as using the
      more explicit XS_EXTERNAL macro.</dd>
  <dt>XS_APIVERSION_BOOTCHECK </dt>
  <dd>Macro to verify that the perl api version an XS module has been compiled
      against matches the api version of the perl interpreter it's being loaded
      into.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
                XS_APIVERSION_BOOTCHECK;
    </pre>
  </dd>
  <dt>XS_EXTERNAL </dt>
  <dd>Macro to declare an XSUB and its C parameter list explicitly exporting the
      symbols.</dd>
  <dt>XS_INTERNAL </dt>
  <dd>Macro to declare an XSUB and its C parameter list without exporting the
      symbols. This is handled by <span class="Li">&quot;xsubpp&quot;</span> and
      generally preferable over exporting the XSUB symbols unnecessarily.</dd>
  <dt>XS_VERSION </dt>
  <dd>The version identifier for an XS module. This is usually handled
      automatically by <span class="Li">&quot;ExtUtils::MakeMaker&quot;</span>.
      See <span class="Li">&quot;XS_VERSION_BOOTCHECK&quot;</span>.</dd>
  <dt>XS_VERSION_BOOTCHECK </dt>
  <dd>Macro to verify that a PM module's <span class="Li">$VERSION</span>
      variable matches the XS module's
      <span class="Li">&quot;XS_VERSION&quot;</span> variable. This is usually
      handled automatically by <span class="Li">&quot;xsubpp&quot;</span>. See
      &quot;The VERSIONCHECK: Keyword&quot; in perlxs.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
                XS_VERSION_BOOTCHECK;
    </pre>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="Warning_and_Dieing"><a class="permalink" href="#Warning_and_Dieing">Warning
  and Dieing</a></h1>
<dl class="Bl-tag">
  <dt>croak</dt>
  <dd>This is an XS interface to Perl's <span class="Li">&quot;die&quot;</span>
      function.
    <p class="Pp">Take a sprintf-style format pattern and argument list. These
        are used to generate a string message. If the message does not end with
        a newline, then it will be extended with some indication of the current
        location in the code, as described for &quot;mess_sv&quot;.</p>
    <p class="Pp">The error message will be used as an exception, by default
        returning control to the nearest enclosing
        <span class="Li">&quot;eval&quot;</span>, but subject to modification by
        a <span class="Li">$SIG{__DIE__}</span> handler. In any case, the
        <span class="Li">&quot;croak&quot;</span> function never returns
        normally.</p>
    <p class="Pp">For historical reasons, if
        <span class="Li">&quot;pat&quot;</span> is null then the contents of
        <span class="Li">&quot;ERRSV&quot;</span> (<span class="Li">$@</span>)
        will be used as an error message or object instead of building an error
        message from arguments. If you want to throw a non-string object, or
        build an error message in an SV yourself, it is preferable to use the
        &quot;croak_sv&quot; function, which does not involve clobbering
        <span class="Li">&quot;ERRSV&quot;</span>.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    croak(const char *pat, ...)
    </pre>
  </dd>
  <dt>croak_no_modify</dt>
  <dd>Exactly equivalent to <span class="Li">&quot;Perl_croak(aTHX_
      &quot;%s&quot;, PL_no_modify)&quot;</span>, but generates terser object
      code than using <span class="Li">&quot;Perl_croak&quot;</span>. Less code
      used on exception code paths reduces CPU cache pressure.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    croak_no_modify()
    </pre>
  </dd>
  <dt>croak_sv</dt>
  <dd>This is an XS interface to Perl's <span class="Li">&quot;die&quot;</span>
      function.
    <p class="Pp"><span class="Li">&quot;baseex&quot;</span> is the error
        message or object. If it is a reference, it will be used as-is.
        Otherwise it is used as a string, and if it does not end with a newline
        then it will be extended with some indication of the current location in
        the code, as described for &quot;mess_sv&quot;.</p>
    <p class="Pp">The error message or object will be used as an exception, by
        default returning control to the nearest enclosing
        <span class="Li">&quot;eval&quot;</span>, but subject to modification by
        a <span class="Li">$SIG{__DIE__}</span> handler. In any case, the
        <span class="Li">&quot;croak_sv&quot;</span> function never returns
        normally.</p>
    <p class="Pp">To die with a simple string message, the &quot;croak&quot;
        function may be more convenient.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    croak_sv(SV *baseex)
    </pre>
  </dd>
  <dt>die</dt>
  <dd>Behaves the same as &quot;croak&quot;, except for the return type. It
      should be used only where the <span class="Li">&quot;OP *&quot;</span>
      return type is required. The function never actually returns.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        OP *    die(const char *pat, ...)
    </pre>
  </dd>
  <dt>die_sv</dt>
  <dd>Behaves the same as &quot;croak_sv&quot;, except for the return type. It
      should be used only where the <span class="Li">&quot;OP *&quot;</span>
      return type is required. The function never actually returns.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        OP *    die_sv(SV *baseex)
    </pre>
  </dd>
  <dt>vcroak</dt>
  <dd>This is an XS interface to Perl's <span class="Li">&quot;die&quot;</span>
      function.
    <p class="Pp"><span class="Li">&quot;pat&quot;</span> and
        <span class="Li">&quot;args&quot;</span> are a sprintf-style format
        pattern and encapsulated argument list. These are used to generate a
        string message. If the message does not end with a newline, then it will
        be extended with some indication of the current location in the code, as
        described for &quot;mess_sv&quot;.</p>
    <p class="Pp">The error message will be used as an exception, by default
        returning control to the nearest enclosing
        <span class="Li">&quot;eval&quot;</span>, but subject to modification by
        a <span class="Li">$SIG{__DIE__}</span> handler. In any case, the
        <span class="Li">&quot;croak&quot;</span> function never returns
        normally.</p>
    <p class="Pp">For historical reasons, if
        <span class="Li">&quot;pat&quot;</span> is null then the contents of
        <span class="Li">&quot;ERRSV&quot;</span> (<span class="Li">$@</span>)
        will be used as an error message or object instead of building an error
        message from arguments. If you want to throw a non-string object, or
        build an error message in an SV yourself, it is preferable to use the
        &quot;croak_sv&quot; function, which does not involve clobbering
        <span class="Li">&quot;ERRSV&quot;</span>.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    vcroak(const char *pat, va_list *args)
    </pre>
  </dd>
  <dt>vwarn</dt>
  <dd>This is an XS interface to Perl's <span class="Li">&quot;warn&quot;</span>
      function.
    <p class="Pp"><span class="Li">&quot;pat&quot;</span> and
        <span class="Li">&quot;args&quot;</span> are a sprintf-style format
        pattern and encapsulated argument list. These are used to generate a
        string message. If the message does not end with a newline, then it will
        be extended with some indication of the current location in the code, as
        described for &quot;mess_sv&quot;.</p>
    <p class="Pp">The error message or object will by default be written to
        standard error, but this is subject to modification by a
        <span class="Li">$SIG{__WARN__}</span> handler.</p>
    <p class="Pp">Unlike with &quot;vcroak&quot;,
        <span class="Li">&quot;pat&quot;</span> is not permitted to be null.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    vwarn(const char *pat, va_list *args)
    </pre>
  </dd>
  <dt>warn</dt>
  <dd>This is an XS interface to Perl's <span class="Li">&quot;warn&quot;</span>
      function.
    <p class="Pp">Take a sprintf-style format pattern and argument list. These
        are used to generate a string message. If the message does not end with
        a newline, then it will be extended with some indication of the current
        location in the code, as described for &quot;mess_sv&quot;.</p>
    <p class="Pp">The error message or object will by default be written to
        standard error, but this is subject to modification by a
        <span class="Li">$SIG{__WARN__}</span> handler.</p>
    <p class="Pp">Unlike with &quot;croak&quot;,
        <span class="Li">&quot;pat&quot;</span> is not permitted to be null.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    warn(const char *pat, ...)
    </pre>
  </dd>
  <dt>warn_sv</dt>
  <dd>This is an XS interface to Perl's <span class="Li">&quot;warn&quot;</span>
      function.
    <p class="Pp"><span class="Li">&quot;baseex&quot;</span> is the error
        message or object. If it is a reference, it will be used as-is.
        Otherwise it is used as a string, and if it does not end with a newline
        then it will be extended with some indication of the current location in
        the code, as described for &quot;mess_sv&quot;.</p>
    <p class="Pp">The error message or object will by default be written to
        standard error, but this is subject to modification by a
        <span class="Li">$SIG{__WARN__}</span> handler.</p>
    <p class="Pp">To warn with a simple string message, the &quot;warn&quot;
        function may be more convenient.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    warn_sv(SV *baseex)
    </pre>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="Undocumented_functions"><a class="permalink" href="#Undocumented_functions">Undocumented
  functions</a></h1>
The following functions have been flagged as part of the public API, but are
  currently undocumented. Use them at your own risk, as the interfaces are
  subject to change. Functions that are not listed in this document are not
  intended for public use, and should NOT be used under any circumstances.
<p class="Pp">If you use one of the undocumented functions below, you may wish
    to consider creating and submitting documentation for it. If your patch is
    accepted, this will indicate that the interface is stable (unless it is
    explicitly marked otherwise).</p>
<dl class="Bl-tag">
  <dt>GetVars</dt>
  <dd></dd>
  <dt>Gv_AMupdate</dt>
  <dd></dd>
  <dt>PerlIO_clearerr</dt>
  <dd></dd>
  <dt>PerlIO_close</dt>
  <dd></dd>
  <dt>PerlIO_context_layers</dt>
  <dd></dd>
  <dt>PerlIO_eof</dt>
  <dd></dd>
  <dt>PerlIO_error</dt>
  <dd></dd>
  <dt>PerlIO_fileno</dt>
  <dd></dd>
  <dt>PerlIO_fill</dt>
  <dd></dd>
  <dt>PerlIO_flush</dt>
  <dd></dd>
  <dt>PerlIO_get_base</dt>
  <dd></dd>
  <dt>PerlIO_get_bufsiz</dt>
  <dd></dd>
  <dt>PerlIO_get_cnt</dt>
  <dd></dd>
  <dt>PerlIO_get_ptr</dt>
  <dd></dd>
  <dt>PerlIO_read</dt>
  <dd></dd>
  <dt>PerlIO_seek</dt>
  <dd></dd>
  <dt>PerlIO_set_cnt</dt>
  <dd></dd>
  <dt>PerlIO_set_ptrcnt</dt>
  <dd></dd>
  <dt>PerlIO_setlinebuf</dt>
  <dd></dd>
  <dt>PerlIO_stderr</dt>
  <dd></dd>
  <dt>PerlIO_stdin</dt>
  <dd></dd>
  <dt>PerlIO_stdout</dt>
  <dd></dd>
  <dt>PerlIO_tell</dt>
  <dd></dd>
  <dt>PerlIO_unread</dt>
  <dd></dd>
  <dt>PerlIO_write</dt>
  <dd></dd>
  <dt>amagic_call</dt>
  <dd></dd>
  <dt>amagic_deref_call</dt>
  <dd></dd>
  <dt>any_dup</dt>
  <dd></dd>
  <dt>atfork_lock</dt>
  <dd></dd>
  <dt>atfork_unlock</dt>
  <dd></dd>
  <dt>av_arylen_p</dt>
  <dd></dd>
  <dt>av_iter_p</dt>
  <dd></dd>
  <dt>block_gimme</dt>
  <dd></dd>
  <dt>call_atexit</dt>
  <dd></dd>
  <dt>call_list</dt>
  <dd></dd>
  <dt>calloc</dt>
  <dd></dd>
  <dt>cast_i32</dt>
  <dd></dd>
  <dt>cast_iv</dt>
  <dd></dd>
  <dt>cast_ulong</dt>
  <dd></dd>
  <dt>cast_uv</dt>
  <dd></dd>
  <dt>ck_warner</dt>
  <dd></dd>
  <dt>ck_warner_d</dt>
  <dd></dd>
  <dt>ckwarn</dt>
  <dd></dd>
  <dt>ckwarn_d</dt>
  <dd></dd>
  <dt>clone_params_del</dt>
  <dd></dd>
  <dt>clone_params_new</dt>
  <dd></dd>
  <dt>croak_nocontext</dt>
  <dd></dd>
  <dt>csighandler</dt>
  <dd></dd>
  <dt>cx_dump</dt>
  <dd></dd>
  <dt>cx_dup</dt>
  <dd></dd>
  <dt>cxinc</dt>
  <dd></dd>
  <dt>deb</dt>
  <dd></dd>
  <dt>deb_nocontext</dt>
  <dd></dd>
  <dt>debop</dt>
  <dd></dd>
  <dt>debprofdump</dt>
  <dd></dd>
  <dt>debstack</dt>
  <dd></dd>
  <dt>debstackptrs</dt>
  <dd></dd>
  <dt>delimcpy</dt>
  <dd></dd>
  <dt>despatch_signals</dt>
  <dd></dd>
  <dt>die_nocontext</dt>
  <dd></dd>
  <dt>dirp_dup</dt>
  <dd></dd>
  <dt>do_aspawn</dt>
  <dd></dd>
  <dt>do_binmode</dt>
  <dd></dd>
  <dt>do_close</dt>
  <dd></dd>
  <dt>do_gv_dump</dt>
  <dd></dd>
  <dt>do_gvgv_dump</dt>
  <dd></dd>
  <dt>do_hv_dump</dt>
  <dd></dd>
  <dt>do_join</dt>
  <dd></dd>
  <dt>do_magic_dump</dt>
  <dd></dd>
  <dt>do_op_dump</dt>
  <dd></dd>
  <dt>do_open</dt>
  <dd></dd>
  <dt>do_open9</dt>
  <dd></dd>
  <dt>do_openn</dt>
  <dd></dd>
  <dt>do_pmop_dump</dt>
  <dd></dd>
  <dt>do_spawn</dt>
  <dd></dd>
  <dt>do_spawn_nowait</dt>
  <dd></dd>
  <dt>do_sprintf</dt>
  <dd></dd>
  <dt>do_sv_dump</dt>
  <dd></dd>
  <dt>doing_taint</dt>
  <dd></dd>
  <dt>doref</dt>
  <dd></dd>
  <dt>dounwind</dt>
  <dd></dd>
  <dt>dowantarray</dt>
  <dd></dd>
  <dt>dump_all</dt>
  <dd></dd>
  <dt>dump_eval</dt>
  <dd></dd>
  <dt>dump_fds</dt>
  <dd></dd>
  <dt>dump_form</dt>
  <dd></dd>
  <dt>dump_indent</dt>
  <dd></dd>
  <dt>dump_mstats</dt>
  <dd></dd>
  <dt>dump_packsubs</dt>
  <dd></dd>
  <dt>dump_sub</dt>
  <dd></dd>
  <dt>dump_vindent</dt>
  <dd></dd>
  <dt>filter_add</dt>
  <dd></dd>
  <dt>filter_del</dt>
  <dd></dd>
  <dt>filter_read</dt>
  <dd></dd>
  <dt>foldEQ_latin1</dt>
  <dd></dd>
  <dt>form_nocontext</dt>
  <dd></dd>
  <dt>fp_dup</dt>
  <dd></dd>
  <dt>fprintf_nocontext</dt>
  <dd></dd>
  <dt>free_global_struct</dt>
  <dd></dd>
  <dt>free_tmps</dt>
  <dd></dd>
  <dt>get_context</dt>
  <dd></dd>
  <dt>get_mstats</dt>
  <dd></dd>
  <dt>get_op_descs</dt>
  <dd></dd>
  <dt>get_op_names</dt>
  <dd></dd>
  <dt>get_ppaddr</dt>
  <dd></dd>
  <dt>get_vtbl</dt>
  <dd></dd>
  <dt>gp_dup</dt>
  <dd></dd>
  <dt>gp_free</dt>
  <dd></dd>
  <dt>gp_ref</dt>
  <dd></dd>
  <dt>gv_AVadd</dt>
  <dd></dd>
  <dt>gv_HVadd</dt>
  <dd></dd>
  <dt>gv_IOadd</dt>
  <dd></dd>
  <dt>gv_SVadd</dt>
  <dd></dd>
  <dt>gv_add_by_type</dt>
  <dd></dd>
  <dt>gv_autoload4</dt>
  <dd></dd>
  <dt>gv_autoload_pv</dt>
  <dd></dd>
  <dt>gv_autoload_pvn</dt>
  <dd></dd>
  <dt>gv_autoload_sv</dt>
  <dd></dd>
  <dt>gv_check</dt>
  <dd></dd>
  <dt>gv_dump</dt>
  <dd></dd>
  <dt>gv_efullname</dt>
  <dd></dd>
  <dt>gv_efullname3</dt>
  <dd></dd>
  <dt>gv_efullname4</dt>
  <dd></dd>
  <dt>gv_fetchfile</dt>
  <dd></dd>
  <dt>gv_fetchfile_flags</dt>
  <dd></dd>
  <dt>gv_fetchpv</dt>
  <dd></dd>
  <dt>gv_fetchpvn_flags</dt>
  <dd></dd>
  <dt>gv_fetchsv</dt>
  <dd></dd>
  <dt>gv_fullname</dt>
  <dd></dd>
  <dt>gv_fullname3</dt>
  <dd></dd>
  <dt>gv_fullname4</dt>
  <dd></dd>
  <dt>gv_handler</dt>
  <dd></dd>
  <dt>gv_name_set</dt>
  <dd></dd>
  <dt>he_dup</dt>
  <dd></dd>
  <dt>hek_dup</dt>
  <dd></dd>
  <dt>hv_common</dt>
  <dd></dd>
  <dt>hv_common_key_len</dt>
  <dd></dd>
  <dt>hv_delayfree_ent</dt>
  <dd></dd>
  <dt>hv_eiter_p</dt>
  <dd></dd>
  <dt>hv_eiter_set</dt>
  <dd></dd>
  <dt>hv_free_ent</dt>
  <dd></dd>
  <dt>hv_ksplit</dt>
  <dd></dd>
  <dt>hv_name_set</dt>
  <dd></dd>
  <dt>hv_placeholders_get</dt>
  <dd></dd>
  <dt>hv_placeholders_p</dt>
  <dd></dd>
  <dt>hv_placeholders_set</dt>
  <dd></dd>
  <dt>hv_rand_set</dt>
  <dd></dd>
  <dt>hv_riter_p</dt>
  <dd></dd>
  <dt>hv_riter_set</dt>
  <dd></dd>
  <dt>init_global_struct</dt>
  <dd></dd>
  <dt>init_i18nl10n</dt>
  <dd></dd>
  <dt>init_i18nl14n</dt>
  <dd></dd>
  <dt>init_stacks</dt>
  <dd></dd>
  <dt>init_tm</dt>
  <dd></dd>
  <dt>instr</dt>
  <dd></dd>
  <dt>is_lvalue_sub</dt>
  <dd></dd>
  <dt>leave_scope</dt>
  <dd></dd>
  <dt>load_module_nocontext</dt>
  <dd></dd>
  <dt>magic_dump</dt>
  <dd></dd>
  <dt>malloc</dt>
  <dd></dd>
  <dt>markstack_grow</dt>
  <dd></dd>
  <dt>mess_nocontext</dt>
  <dd></dd>
  <dt>mfree</dt>
  <dd></dd>
  <dt>mg_dup</dt>
  <dd></dd>
  <dt>mg_size</dt>
  <dd></dd>
  <dt>mini_mktime</dt>
  <dd></dd>
  <dt>moreswitches</dt>
  <dd></dd>
  <dt>mro_get_from_name</dt>
  <dd></dd>
  <dt>mro_get_private_data</dt>
  <dd></dd>
  <dt>mro_set_mro</dt>
  <dd></dd>
  <dt>mro_set_private_data</dt>
  <dd></dd>
  <dt>my_atof</dt>
  <dd></dd>
  <dt>my_atof2</dt>
  <dd></dd>
  <dt>my_bcopy</dt>
  <dd></dd>
  <dt>my_bzero</dt>
  <dd></dd>
  <dt>my_chsize</dt>
  <dd></dd>
  <dt>my_cxt_index</dt>
  <dd></dd>
  <dt>my_cxt_init</dt>
  <dd></dd>
  <dt>my_dirfd</dt>
  <dd></dd>
  <dt>my_exit</dt>
  <dd></dd>
  <dt>my_failure_exit</dt>
  <dd></dd>
  <dt>my_fflush_all</dt>
  <dd></dd>
  <dt>my_fork</dt>
  <dd></dd>
  <dt>my_htonl</dt>
  <dd></dd>
  <dt>my_lstat</dt>
  <dd></dd>
  <dt>my_memcmp</dt>
  <dd></dd>
  <dt>my_memset</dt>
  <dd></dd>
  <dt>my_ntohl</dt>
  <dd></dd>
  <dt>my_pclose</dt>
  <dd></dd>
  <dt>my_popen</dt>
  <dd></dd>
  <dt>my_popen_list</dt>
  <dd></dd>
  <dt>my_setenv</dt>
  <dd></dd>
  <dt>my_socketpair</dt>
  <dd></dd>
  <dt>my_stat</dt>
  <dd></dd>
  <dt>my_strftime</dt>
  <dd></dd>
  <dt>my_strlcat</dt>
  <dd></dd>
  <dt>my_strlcpy</dt>
  <dd></dd>
  <dt>my_swap</dt>
  <dd></dd>
  <dt>newANONATTRSUB</dt>
  <dd></dd>
  <dt>newANONHASH</dt>
  <dd></dd>
  <dt>newANONLIST</dt>
  <dd></dd>
  <dt>newANONSUB</dt>
  <dd></dd>
  <dt>newATTRSUB</dt>
  <dd></dd>
  <dt>newAVREF</dt>
  <dd></dd>
  <dt>newCVREF</dt>
  <dd></dd>
  <dt>newFORM</dt>
  <dd></dd>
  <dt>newGVREF</dt>
  <dd></dd>
  <dt>newGVgen</dt>
  <dd></dd>
  <dt>newGVgen_flags</dt>
  <dd></dd>
  <dt>newHVREF</dt>
  <dd></dd>
  <dt>newHVhv</dt>
  <dd></dd>
  <dt>newIO</dt>
  <dd></dd>
  <dt>newMYSUB</dt>
  <dd></dd>
  <dt>newPROG</dt>
  <dd></dd>
  <dt>newRV</dt>
  <dd></dd>
  <dt>newSUB</dt>
  <dd></dd>
  <dt>newSVREF</dt>
  <dd></dd>
  <dt>newSVpvf_nocontext</dt>
  <dd></dd>
  <dt>new_collate</dt>
  <dd></dd>
  <dt>new_ctype</dt>
  <dd></dd>
  <dt>new_numeric</dt>
  <dd></dd>
  <dt>new_stackinfo</dt>
  <dd></dd>
  <dt>ninstr</dt>
  <dd></dd>
  <dt>op_dump</dt>
  <dd></dd>
  <dt>op_free</dt>
  <dd></dd>
  <dt>op_null</dt>
  <dd></dd>
  <dt>op_refcnt_lock</dt>
  <dd></dd>
  <dt>op_refcnt_unlock</dt>
  <dd></dd>
  <dt>parser_dup</dt>
  <dd></dd>
  <dt>perl_alloc_using</dt>
  <dd></dd>
  <dt>perl_clone_using</dt>
  <dd></dd>
  <dt>pmop_dump</dt>
  <dd></dd>
  <dt>pop_scope</dt>
  <dd></dd>
  <dt>pregcomp</dt>
  <dd></dd>
  <dt>pregexec</dt>
  <dd></dd>
  <dt>pregfree</dt>
  <dd></dd>
  <dt>pregfree2</dt>
  <dd></dd>
  <dt>printf_nocontext</dt>
  <dd></dd>
  <dt>ptr_table_clear</dt>
  <dd></dd>
  <dt>ptr_table_fetch</dt>
  <dd></dd>
  <dt>ptr_table_free</dt>
  <dd></dd>
  <dt>ptr_table_new</dt>
  <dd></dd>
  <dt>ptr_table_split</dt>
  <dd></dd>
  <dt>ptr_table_store</dt>
  <dd></dd>
  <dt>push_scope</dt>
  <dd></dd>
  <dt>re_compile</dt>
  <dd></dd>
  <dt>re_dup_guts</dt>
  <dd></dd>
  <dt>re_intuit_start</dt>
  <dd></dd>
  <dt>re_intuit_string</dt>
  <dd></dd>
  <dt>realloc</dt>
  <dd></dd>
  <dt>reentrant_free</dt>
  <dd></dd>
  <dt>reentrant_init</dt>
  <dd></dd>
  <dt>reentrant_retry</dt>
  <dd></dd>
  <dt>reentrant_size</dt>
  <dd></dd>
  <dt>ref</dt>
  <dd></dd>
  <dt>reg_named_buff_all</dt>
  <dd></dd>
  <dt>reg_named_buff_exists</dt>
  <dd></dd>
  <dt>reg_named_buff_fetch</dt>
  <dd></dd>
  <dt>reg_named_buff_firstkey</dt>
  <dd></dd>
  <dt>reg_named_buff_nextkey</dt>
  <dd></dd>
  <dt>reg_named_buff_scalar</dt>
  <dd></dd>
  <dt>regclass_swash</dt>
  <dd></dd>
  <dt>regdump</dt>
  <dd></dd>
  <dt>regdupe_internal</dt>
  <dd></dd>
  <dt>regexec_flags</dt>
  <dd></dd>
  <dt>regfree_internal</dt>
  <dd></dd>
  <dt>reginitcolors</dt>
  <dd></dd>
  <dt>regnext</dt>
  <dd></dd>
  <dt>repeatcpy</dt>
  <dd></dd>
  <dt>rninstr</dt>
  <dd></dd>
  <dt>rsignal</dt>
  <dd></dd>
  <dt>rsignal_state</dt>
  <dd></dd>
  <dt>runops_debug</dt>
  <dd></dd>
  <dt>runops_standard</dt>
  <dd></dd>
  <dt>rvpv_dup</dt>
  <dd></dd>
  <dt>safesyscalloc</dt>
  <dd></dd>
  <dt>safesysfree</dt>
  <dd></dd>
  <dt>safesysmalloc</dt>
  <dd></dd>
  <dt>safesysrealloc</dt>
  <dd></dd>
  <dt>save_I16</dt>
  <dd></dd>
  <dt>save_I32</dt>
  <dd></dd>
  <dt>save_I8</dt>
  <dd></dd>
  <dt>save_adelete</dt>
  <dd></dd>
  <dt>save_aelem</dt>
  <dd></dd>
  <dt>save_aelem_flags</dt>
  <dd></dd>
  <dt>save_alloc</dt>
  <dd></dd>
  <dt>save_aptr</dt>
  <dd></dd>
  <dt>save_ary</dt>
  <dd></dd>
  <dt>save_bool</dt>
  <dd></dd>
  <dt>save_clearsv</dt>
  <dd></dd>
  <dt>save_delete</dt>
  <dd></dd>
  <dt>save_destructor</dt>
  <dd></dd>
  <dt>save_destructor_x</dt>
  <dd></dd>
  <dt>save_freeop</dt>
  <dd></dd>
  <dt>save_freepv</dt>
  <dd></dd>
  <dt>save_freesv</dt>
  <dd></dd>
  <dt>save_generic_pvref</dt>
  <dd></dd>
  <dt>save_generic_svref</dt>
  <dd></dd>
  <dt>save_gp</dt>
  <dd></dd>
  <dt>save_hash</dt>
  <dd></dd>
  <dt>save_hdelete</dt>
  <dd></dd>
  <dt>save_helem</dt>
  <dd></dd>
  <dt>save_helem_flags</dt>
  <dd></dd>
  <dt>save_hints</dt>
  <dd></dd>
  <dt>save_hptr</dt>
  <dd></dd>
  <dt>save_int</dt>
  <dd></dd>
  <dt>save_item</dt>
  <dd></dd>
  <dt>save_iv</dt>
  <dd></dd>
  <dt>save_list</dt>
  <dd></dd>
  <dt>save_long</dt>
  <dd></dd>
  <dt>save_mortalizesv</dt>
  <dd></dd>
  <dt>save_nogv</dt>
  <dd></dd>
  <dt>save_op</dt>
  <dd></dd>
  <dt>save_padsv_and_mortalize</dt>
  <dd></dd>
  <dt>save_pptr</dt>
  <dd></dd>
  <dt>save_pushi32ptr</dt>
  <dd></dd>
  <dt>save_pushptr</dt>
  <dd></dd>
  <dt>save_pushptrptr</dt>
  <dd></dd>
  <dt>save_re_context</dt>
  <dd></dd>
  <dt>save_scalar</dt>
  <dd></dd>
  <dt>save_set_svflags</dt>
  <dd></dd>
  <dt>save_shared_pvref</dt>
  <dd></dd>
  <dt>save_sptr</dt>
  <dd></dd>
  <dt>save_svref</dt>
  <dd></dd>
  <dt>save_vptr</dt>
  <dd></dd>
  <dt>savestack_grow</dt>
  <dd></dd>
  <dt>savestack_grow_cnt</dt>
  <dd></dd>
  <dt>scan_num</dt>
  <dd></dd>
  <dt>scan_vstring</dt>
  <dd></dd>
  <dt>screaminstr</dt>
  <dd></dd>
  <dt>seed</dt>
  <dd></dd>
  <dt>set_context</dt>
  <dd></dd>
  <dt>set_numeric_local</dt>
  <dd></dd>
  <dt>set_numeric_radix</dt>
  <dd></dd>
  <dt>set_numeric_standard</dt>
  <dd></dd>
  <dt>share_hek</dt>
  <dd></dd>
  <dt>si_dup</dt>
  <dd></dd>
  <dt>ss_dup</dt>
  <dd></dd>
  <dt>stack_grow</dt>
  <dd></dd>
  <dt>start_subparse</dt>
  <dd></dd>
  <dt>str_to_version</dt>
  <dd></dd>
  <dt>sv_2iv</dt>
  <dd></dd>
  <dt>sv_2pv</dt>
  <dd></dd>
  <dt>sv_2uv</dt>
  <dd></dd>
  <dt>sv_catpvf_mg_nocontext</dt>
  <dd></dd>
  <dt>sv_catpvf_nocontext</dt>
  <dd></dd>
  <dt>sv_dump</dt>
  <dd></dd>
  <dt>sv_dup</dt>
  <dd></dd>
  <dt>sv_dup_inc</dt>
  <dd></dd>
  <dt>sv_peek</dt>
  <dd></dd>
  <dt>sv_pvn_nomg</dt>
  <dd></dd>
  <dt>sv_setpvf_mg_nocontext</dt>
  <dd></dd>
  <dt>sv_setpvf_nocontext</dt>
  <dd></dd>
  <dt>sv_utf8_upgrade_flags_grow</dt>
  <dd></dd>
  <dt>swash_fetch</dt>
  <dd></dd>
  <dt>swash_init</dt>
  <dd></dd>
  <dt>sys_init</dt>
  <dd></dd>
  <dt>sys_init3</dt>
  <dd></dd>
  <dt>sys_intern_clear</dt>
  <dd></dd>
  <dt>sys_intern_dup</dt>
  <dd></dd>
  <dt>sys_intern_init</dt>
  <dd></dd>
  <dt>sys_term</dt>
  <dd></dd>
  <dt>taint_env</dt>
  <dd></dd>
  <dt>taint_proper</dt>
  <dd></dd>
  <dt>tmps_grow</dt>
  <dd></dd>
  <dt>unlnk</dt>
  <dd></dd>
  <dt>unsharepvn</dt>
  <dd></dd>
  <dt>utf16_to_utf8</dt>
  <dd></dd>
  <dt>utf16_to_utf8_reversed</dt>
  <dd></dd>
  <dt>uvchr_to_utf8_flags</dt>
  <dd></dd>
  <dt>uvuni_to_utf8</dt>
  <dd></dd>
  <dt>vdeb</dt>
  <dd></dd>
  <dt>vform</dt>
  <dd></dd>
  <dt>vload_module</dt>
  <dd></dd>
  <dt>vnewSVpvf</dt>
  <dd></dd>
  <dt>vwarner</dt>
  <dd></dd>
  <dt>warn_nocontext</dt>
  <dd></dd>
  <dt>warner</dt>
  <dd></dd>
  <dt>warner_nocontext</dt>
  <dd></dd>
  <dt>whichsig</dt>
  <dd></dd>
  <dt>whichsig_pv</dt>
  <dd></dd>
  <dt>whichsig_pvn</dt>
  <dd></dd>
  <dt>whichsig_sv</dt>
  <dd></dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHORS"><a class="permalink" href="#AUTHORS">AUTHORS</a></h1>
Until May 1997, this document was maintained by Jeff Okamoto
  &lt;okamoto@corp.hp.com&gt;. It is now maintained as part of Perl itself.
<p class="Pp">With lots of help and suggestions from Dean Roehrich, Malcolm
    Beattie, Andreas Koenig, Paul Hudson, Ilya Zakharevich, Paul Marquess, Neil
    Bowers, Matthew Green, Tim Bunce, Spider Boardman, Ulrich Pfeifer, Stephen
    McCamant, and Gurusamy Sarathy.</p>
<p class="Pp">API Listing originally by Dean Roehrich
  &lt;roehrich@cray.com&gt;.</p>
<p class="Pp">Updated to be autogenerated from comments in the source by
    Benjamin Stuhl.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
perlguts, perlxs, perlxstut, perlintern
</section>
<section class="Sh">
<h1 class="Sh" id="POD_ERRORS"><a class="permalink" href="#POD_ERRORS">POD
  ERRORS</a></h1>
Hey! <b>The above document had some coding errors, which are explained
  below:</b>
<dl class="Bl-tag">
  <dt>Around line 8556:</dt>
  <dd>Unterminated C&lt;...&gt; sequence</dd>
</dl>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2020-06-06</td>
    <td class="foot-os">perl v5.18.4</td>
  </tr>
</table>
</body>
</html>
