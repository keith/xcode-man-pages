<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>Pod::Parser(3pm)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Pod::Parser(3pm)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">Pod::Parser(3pm)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
Pod::Parser - base class for creating POD filters and translators
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<span class="Li"></span>
<pre>
    use Pod::Parser;

    package MyParser;
    @ISA = qw(Pod::Parser);

    sub command { 
        my ($parser, $command, $paragraph, $line_num) = @_;
        ## Interpret the command and its text; sample actions might be:
        if ($command eq 'head1') { ... }
        elsif ($command eq 'head2') { ... }
        ## ... other commands and their actions
        my $out_fh = $parser-&gt;output_handle();
        my $expansion = $parser-&gt;interpolate($paragraph, $line_num);
        print $out_fh $expansion;
    }

    sub verbatim { 
        my ($parser, $paragraph, $line_num) = @_;
        ## Format verbatim paragraph; sample actions might be:
        my $out_fh = $parser-&gt;output_handle();
        print $out_fh $paragraph;
    }

    sub textblock { 
        my ($parser, $paragraph, $line_num) = @_;
        ## Translate/Format this block of text; sample actions might be:
        my $out_fh = $parser-&gt;output_handle();
        my $expansion = $parser-&gt;interpolate($paragraph, $line_num);
        print $out_fh $expansion;
    }

    sub interior_sequence { 
        my ($parser, $seq_command, $seq_argument) = @_;
        ## Expand an interior sequence; sample actions might be:
        return &quot;*$seq_argument*&quot;     if ($seq_command eq 'B');
        return &quot;`$seq_argument'&quot;     if ($seq_command eq 'C');
        return &quot;_${seq_argument}_'&quot;  if ($seq_command eq 'I');
        ## ... other sequence commands and their resulting text
    }

    package main;

    ## Create a parser object and have it parse file whose name was
    ## given on the command-line (use STDIN if no files were given).
    $parser = new MyParser();
    $parser-&gt;parse_from_filehandle(\*STDIN)  if (@ARGV == 0);
    for (@ARGV) { $parser-&gt;parse_from_file($_); }
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="REQUIRES"><a class="permalink" href="#REQUIRES">REQUIRES</a></h1>
perl5.005, Pod::InputObjects, Exporter, Symbol, Carp
</section>
<section class="Sh">
<h1 class="Sh" id="EXPORTS"><a class="permalink" href="#EXPORTS">EXPORTS</a></h1>
Nothing.
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<b>Pod::Parser</b> is a base class for creating POD filters and translators. It
  handles most of the effort involved with parsing the POD sections from an
  input stream, leaving subclasses free to be concerned only with performing the
  actual translation of text.
<p class="Pp"><b>Pod::Parser</b> parses PODs, and makes method calls to handle
    the various components of the POD. Subclasses of <b>Pod::Parser</b> override
    these methods to translate the POD into whatever output format they
  desire.</p>
<p class="Pp">Note: This module is considered as legacy; modern Perl releases
    (5.18 and higher) are going to remove Pod::Parser from core and use
    Pod::Simple for all things POD.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="QUICK_OVERVIEW"><a class="permalink" href="#QUICK_OVERVIEW">QUICK
  OVERVIEW</a></h1>
To create a POD filter for translating POD documentation into some other format,
  you create a subclass of <b>Pod::Parser</b> which typically overrides just the
  base class implementation for the following methods:
<ul class="Bl-bullet">
  <li><b></b><b><i>command()</i></b><b></b></li>
  <li><b></b><b><i>verbatim()</i></b><b></b></li>
  <li><b></b><b><i>textblock()</i></b><b></b></li>
  <li><b></b><b><i>interior_sequence()</i></b><b></b></li>
</ul>
<p class="Pp">You may also want to override the
    <b></b><b><i>begin_input()</i></b> <b></b> and
    <b></b><b><i>end_input()</i></b> <b></b> methods for your subclass (to
    perform any needed per-file and/or per-document initialization or
  cleanup).</p>
<p class="Pp">If you need to perform any preprocessing of input before it is
    parsed you may want to override one or more of
    <b></b><b><i>preprocess_line()</i></b><b></b> and/or
    <b></b><b><i>preprocess_paragraph()</i></b><b></b>.</p>
<p class="Pp">Sometimes it may be necessary to make more than one pass over the
    input files. If this is the case you have several options. You can make the
    first pass using <b>Pod::Parser</b> and override your methods to store the
    intermediate results in memory somewhere for the
    <b></b><b><i>end_pod()</i></b> <b></b> method to process. You could use
    <b>Pod::Parser</b> for several passes with an appropriate state variable to
    control the operation for each pass. If your input source can't be reset to
    start at the beginning, you can store it in some other structure as a string
    or an array and have that structure implement a
    <b></b><b><i>getline()</i></b> <b></b> method (which is all that
    <b></b><b><i>parse_from_filehandle()</i></b><b></b> uses to read input).</p>
<p class="Pp">Feel free to add any member data fields you need to keep track of
    things like current font, indentation, horizontal or vertical position, or
    whatever else you like. Be sure to read &quot;PRIVATE METHODS AND DATA&quot;
    to avoid name collisions.</p>
<p class="Pp">For the most part, the <b>Pod::Parser</b> base class should be
    able to do most of the input parsing for you and leave you free to worry
    about how to interpret the commands and translate the result.</p>
<p class="Pp">Note that all we have described here in this quick overview is the
    simplest most straightforward use of <b>Pod::Parser</b> to do stream-based
    parsing. It is also possible to use the <b>Pod::Parser::parse_text</b>
    function to do more sophisticated tree-based parsing. See &quot;TREE-BASED
    PARSING&quot;.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="PARSING_OPTIONS"><a class="permalink" href="#PARSING_OPTIONS">PARSING
  OPTIONS</a></h1>
A <i>parse-option</i> is simply a named option of <b>Pod::Parser</b> with a
  value that corresponds to a certain specified behavior. These various
  behaviors of <b>Pod::Parser</b> may be enabled/disabled by setting or
  unsetting one or more <i>parse-options</i> using the
  <b></b><b><i>parseopts()</i></b> <b></b> method. The set of currently accepted
  parse-options is as follows:
<dl class="Bl-tag">
  <dt><b>-want_nonPODs</b> (default: unset)</dt>
  <dd>Normally (by default) <b>Pod::Parser</b> will only provide access to the
      POD sections of the input. Input paragraphs that are not part of the
      POD-format documentation are not made available to the caller (not even
      using <b></b><b><i>preprocess_paragraph()</i></b><b></b>). Setting this
      option to a non-empty, non-zero value will allow
      <b></b><b><i>preprocess_paragraph()</i></b><b></b> to see non-POD sections
      of the input as well as POD sections. The
      <b></b><b><i>cutting()</i></b><b></b> method can be used to determine if
      the corresponding paragraph is a POD paragraph, or some other input
      paragraph.</dd>
  <dt><b>-process_cut_cmd</b> (default: unset)</dt>
  <dd>Normally (by default) <b>Pod::Parser</b> handles the
      <span class="Li">&quot;=cut&quot;</span> POD directive by itself and does
      not pass it on to the caller for processing. Setting this option to a
      non-empty, non-zero value will cause <b>Pod::Parser</b> to pass the
      <span class="Li">&quot;=cut&quot;</span> directive to the caller just like
      any other POD command (and hence it may be processed by the
      <b></b><b><i>command()</i></b><b></b> method).
    <p class="Pp"><b>Pod::Parser</b> will still interpret the
        <span class="Li">&quot;=cut&quot;</span> directive to mean that
        &quot;cutting mode&quot; has been (re)entered, but the caller will get a
        chance to capture the actual <span class="Li">&quot;=cut&quot;</span>
        paragraph itself for whatever purpose it desires.</p>
  </dd>
  <dt><b>-warnings</b> (default: unset)</dt>
  <dd>Normally (by default) <b>Pod::Parser</b> recognizes a bare minimum of pod
      syntax errors and warnings and issues diagnostic messages for errors, but
      not for warnings. (Use <b>Pod::Checker</b> to do more thorough checking of
      POD syntax.) Setting this option to a non-empty, non-zero value will cause
      <b>Pod::Parser</b> to issue diagnostics for the few warnings it recognizes
      as well as the errors.</dd>
</dl>
<p class="Pp">Please see &quot;<i>parseopts()</i>&quot; for a complete
    description of the interface for the setting and unsetting of
  parse-options.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="RECOMMENDED_SUBROUTINE/METHOD_OVERRIDES"><a class="permalink" href="#RECOMMENDED_SUBROUTINE/METHOD_OVERRIDES">RECOMMENDED
  SUBROUTINE/METHOD OVERRIDES</a></h1>
<b>Pod::Parser</b> provides several methods which most subclasses will probably
  want to override. These methods are as follows:
</section>
<section class="Sh">
<h1 class="Sh" id="_fB_fP_f(BIcommand()_fP_fB_fP"><a class="permalink" href="#_fB_fP_f(BIcommand()_fP_fB_fP"><b></b><b><i>command()</i></b><b></b></a></h1>
<span class="Li"></span>
<pre>
            $parser-&gt;command($cmd,$text,$line_num,$pod_para);
</pre>
<p class="Pp">This method should be overridden by subclasses to take the
    appropriate action when a POD command paragraph (denoted by a line beginning
    with &quot;=&quot;) is encountered. When such a POD directive is seen in the
    input, this method is called and is passed:</p>
<dl class="Bl-tag">
  <dt>$cmd</dt>
  <dd>the name of the command for this POD paragraph</dd>
  <dt>$text</dt>
  <dd>the paragraph text for the given POD paragraph command.</dd>
  <dt>$line_num</dt>
  <dd>the line-number of the beginning of the paragraph</dd>
  <dt>$pod_para</dt>
  <dd>a reference to a <span class="Li">&quot;Pod::Paragraph&quot;</span> object
      which contains further information about the paragraph command (see
      Pod::InputObjects for details).</dd>
</dl>
<p class="Pp"><b>Note</b> that this method <i>is</i> called for
    <span class="Li">&quot;=pod&quot;</span> paragraphs.</p>
<p class="Pp">The base class implementation of this method simply treats the raw
    POD command as normal block of paragraph text (invoking the
    <b></b><b><i>textblock()</i></b><b></b> method with the command
  paragraph).</p>
</section>
<section class="Sh">
<h1 class="Sh" id="_fB_fP_f(BIverbatim()_fP_fB_fP"><a class="permalink" href="#_fB_fP_f(BIverbatim()_fP_fB_fP"><b></b><b><i>verbatim()</i></b><b></b></a></h1>
<span class="Li"></span>
<pre>
            $parser-&gt;verbatim($text,$line_num,$pod_para);
</pre>
<p class="Pp">This method may be overridden by subclasses to take the
    appropriate action when a block of verbatim text is encountered. It is
    passed the following parameters:</p>
<dl class="Bl-tag">
  <dt>$text</dt>
  <dd>the block of text for the verbatim paragraph</dd>
  <dt>$line_num</dt>
  <dd>the line-number of the beginning of the paragraph</dd>
  <dt>$pod_para</dt>
  <dd>a reference to a <span class="Li">&quot;Pod::Paragraph&quot;</span> object
      which contains further information about the paragraph (see
      Pod::InputObjects for details).</dd>
</dl>
<p class="Pp">The base class implementation of this method simply prints the
    textblock (unmodified) to the output filehandle.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="_fB_fP_f(BItextblock()_fP_fB_fP"><a class="permalink" href="#_fB_fP_f(BItextblock()_fP_fB_fP"><b></b><b><i>textblock()</i></b><b></b></a></h1>
<span class="Li"></span>
<pre>
            $parser-&gt;textblock($text,$line_num,$pod_para);
</pre>
<p class="Pp">This method may be overridden by subclasses to take the
    appropriate action when a normal block of POD text is encountered (although
    the base class method will usually do what you want). It is passed the
    following parameters:</p>
<dl class="Bl-tag">
  <dt>$text</dt>
  <dd>the block of text for the a POD paragraph</dd>
  <dt>$line_num</dt>
  <dd>the line-number of the beginning of the paragraph</dd>
  <dt>$pod_para</dt>
  <dd>a reference to a <span class="Li">&quot;Pod::Paragraph&quot;</span> object
      which contains further information about the paragraph (see
      Pod::InputObjects for details).</dd>
</dl>
<p class="Pp">In order to process interior sequences, subclasses implementations
    of this method will probably want to invoke either
    <b></b><b><i>interpolate()</i></b><b></b> or
    <b></b><b><i>parse_text()</i></b> <b></b>, passing it the text block
    <span class="Li">$text</span>, and the corresponding line number in
    <span class="Li">$line_num</span>, and then perform any desired processing
    upon the returned result.</p>
<p class="Pp">The base class implementation of this method simply prints the
    text block as it occurred in the input stream).</p>
</section>
<section class="Sh">
<h1 class="Sh" id="_fB_fP_f(BIinterior_sequence()_fP_fB_fP"><a class="permalink" href="#_fB_fP_f(BIinterior_sequence()_fP_fB_fP"><b></b><b><i>interior_sequence()</i></b><b></b></a></h1>
<span class="Li"></span>
<pre>
            $parser-&gt;interior_sequence($seq_cmd,$seq_arg,$pod_seq);
</pre>
<p class="Pp">This method should be overridden by subclasses to take the
    appropriate action when an interior sequence is encountered. An interior
    sequence is an embedded command within a block of text which appears as a
    command name (usually a single uppercase character) followed immediately by
    a string of text which is enclosed in angle brackets. This method is passed
    the sequence command <span class="Li">$seq_cmd</span> and the corresponding
    text <span class="Li">$seq_arg</span>. It is invoked by the
    <b></b><b><i>interpolate()</i></b><b></b> method for each interior sequence
    that occurs in the string that it is passed. It should return the desired
    text string to be used in place of the interior sequence. The
    <span class="Li">$pod_seq</span> argument is a reference to a
    <span class="Li">&quot;Pod::InteriorSequence&quot;</span> object which
    contains further information about the interior sequence. Please see
    Pod::InputObjects for details if you need to access this additional
    information.</p>
<p class="Pp">Subclass implementations of this method may wish to invoke the
    <b></b> <b><i>nested()</i></b><b></b> method of
    <span class="Li">$pod_seq</span> to see if it is nested inside some other
    interior-sequence (and if so, which kind).</p>
<p class="Pp">The base class implementation of the
    <b></b><b><i>interior_sequence()</i></b><b></b> method simply returns the
    raw text of the interior sequence (as it occurred in the input) to the
    caller.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="OPTIONAL_SUBROUTINE/METHOD_OVERRIDES"><a class="permalink" href="#OPTIONAL_SUBROUTINE/METHOD_OVERRIDES">OPTIONAL
  SUBROUTINE/METHOD OVERRIDES</a></h1>
<b>Pod::Parser</b> provides several methods which subclasses may want to
  override to perform any special pre/post-processing. These methods do
  <i>not</i> have to be overridden, but it may be useful for subclasses to take
  advantage of them.
</section>
<section class="Sh">
<h1 class="Sh" id="_fB_fP_f(BInew()_fP_fB_fP"><a class="permalink" href="#_fB_fP_f(BInew()_fP_fB_fP"><b></b><b><i>new()</i></b><b></b></a></h1>
<span class="Li"></span>
<pre>
            my $parser = Pod::Parser-&gt;new();
</pre>
<p class="Pp">This is the constructor for <b>Pod::Parser</b> and its subclasses.
    You <i>do not</i> need to override this method! It is capable of
    constructing subclass objects as well as base class objects, provided you
    use any of the following constructor invocation styles:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    my $parser1 = MyParser-&gt;new();
    my $parser2 = new MyParser();
    my $parser3 = $parser2-&gt;new();
</pre>
<p class="Pp">where <span class="Li">&quot;MyParser&quot;</span> is some
    subclass of <b>Pod::Parser</b>.</p>
<p class="Pp">Using the syntax
    <span class="Li">&quot;MyParser::new()&quot;</span> to invoke the
    constructor is <i>not</i> recommended, but if you insist on being able to do
    this, then the subclass <i>will</i> need to override the
    <b></b><b><i>new()</i></b> <b></b> constructor method. If you do override
    the constructor, you <i>must</i> be sure to invoke the
    <b></b><b><i>initialize()</i></b><b></b> method of the newly blessed
  object.</p>
<p class="Pp">Using any of the above invocations, the first argument to the
    constructor is always the corresponding package name (or object reference).
    No other arguments are required, but if desired, an associative array (or
    hash-table) my be passed to the <b></b><b><i>new()</i></b><b></b>
    constructor, as in:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    my $parser1 = MyParser-&gt;new( MYDATA =&gt; $value1, MOREDATA =&gt; $value2 );
    my $parser2 = new MyParser( -myflag =&gt; 1 );
</pre>
<p class="Pp">All arguments passed to the <b></b><b><i>new()</i></b><b></b>
    constructor will be treated as key/value pairs in a hash-table. The newly
    constructed object will be initialized by copying the contents of the given
    hash-table (which may have been empty). The
    <b></b><b><i>new()</i></b><b></b> constructor for this class and all of its
    subclasses returns a blessed reference to the initialized object
    (hash-table).</p>
</section>
<section class="Sh">
<h1 class="Sh" id="_fB_fP_f(BIinitialize()_fP_fB_fP"><a class="permalink" href="#_fB_fP_f(BIinitialize()_fP_fB_fP"><b></b><b><i>initialize()</i></b><b></b></a></h1>
<span class="Li"></span>
<pre>
            $parser-&gt;initialize();
</pre>
<p class="Pp">This method performs any necessary object initialization. It takes
    no arguments (other than the object instance of course, which is typically
    copied to a local variable named <span class="Li">$self</span>). If
    subclasses override this method then they <i>must</i> be sure to invoke
    <span class="Li">&quot;$self-&gt;SUPER::initialize()&quot;</span>.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="_fB_fP_f(BIbegin_pod()_fP_fB_fP"><a class="permalink" href="#_fB_fP_f(BIbegin_pod()_fP_fB_fP"><b></b><b><i>begin_pod()</i></b><b></b></a></h1>
<span class="Li"></span>
<pre>
            $parser-&gt;begin_pod();
</pre>
<p class="Pp">This method is invoked at the beginning of processing for each POD
    document that is encountered in the input. Subclasses should override this
    method to perform any per-document initialization.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="_fB_fP_f(BIbegin_input()_fP_fB_fP"><a class="permalink" href="#_fB_fP_f(BIbegin_input()_fP_fB_fP"><b></b><b><i>begin_input()</i></b><b></b></a></h1>
<span class="Li"></span>
<pre>
            $parser-&gt;begin_input();
</pre>
<p class="Pp">This method is invoked by
    <b></b><b><i>parse_from_filehandle()</i></b> <b></b> immediately
    <i>before</i> processing input from a filehandle. The base class
    implementation does nothing, however, subclasses may override it to perform
    any per-file initializations.</p>
<p class="Pp">Note that if multiple files are parsed for a single POD document
    (perhaps the result of some future
    <span class="Li">&quot;=include&quot;</span> directive) this method is
    invoked for every file that is parsed. If you wish to perform certain
    initializations once per document, then you should use
    <b></b><b><i>begin_pod()</i></b><b></b>.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="_fB_fP_f(BIend_input()_fP_fB_fP"><a class="permalink" href="#_fB_fP_f(BIend_input()_fP_fB_fP"><b></b><b><i>end_input()</i></b><b></b></a></h1>
<span class="Li"></span>
<pre>
            $parser-&gt;end_input();
</pre>
<p class="Pp">This method is invoked by
    <b></b><b><i>parse_from_filehandle()</i></b> <b></b> immediately
    <i>after</i> processing input from a filehandle. The base class
    implementation does nothing, however, subclasses may override it to perform
    any per-file cleanup actions.</p>
<p class="Pp">Please note that if multiple files are parsed for a single POD
    document (perhaps the result of some kind of
    <span class="Li">&quot;=include&quot;</span> directive) this method is
    invoked for every file that is parsed. If you wish to perform certain
    cleanup actions once per document, then you should use
    <b></b><b><i>end_pod()</i></b><b></b>.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="_fB_fP_f(BIend_pod()_fP_fB_fP"><a class="permalink" href="#_fB_fP_f(BIend_pod()_fP_fB_fP"><b></b><b><i>end_pod()</i></b><b></b></a></h1>
<span class="Li"></span>
<pre>
            $parser-&gt;end_pod();
</pre>
<p class="Pp">This method is invoked at the end of processing for each POD
    document that is encountered in the input. Subclasses should override this
    method to perform any per-document finalization.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="_fB_fP_f(BIpreprocess_line()_fP_fB_fP"><a class="permalink" href="#_fB_fP_f(BIpreprocess_line()_fP_fB_fP"><b></b><b><i>preprocess_line()</i></b><b></b></a></h1>
<span class="Li"></span>
<pre>
          $textline = $parser-&gt;preprocess_line($text, $line_num);
</pre>
<p class="Pp">This method should be overridden by subclasses that wish to
    perform any kind of preprocessing for each <i>line</i> of input
    (<i>before</i> it has been determined whether or not it is part of a POD
    paragraph). The parameter <span class="Li">$text</span> is the input line;
    and the parameter <span class="Li">$line_num</span> is the line number of
    the corresponding text line.</p>
<p class="Pp">The value returned should correspond to the new text to use in its
    place. If the empty string or an undefined value is returned then no further
    processing will be performed for this line.</p>
<p class="Pp">Please note that the <b></b><b><i>preprocess_line()</i></b><b></b>
    method is invoked <i>before</i> the
    <b></b><b><i>preprocess_paragraph()</i></b> <b></b> method. After all
    (possibly preprocessed) lines in a paragraph have been assembled together
    and it has been determined that the paragraph is part of the POD
    documentation from one of the selected sections, then
    <b></b><b><i>preprocess_paragraph()</i></b><b></b> is invoked.</p>
<p class="Pp">The base class implementation of this method returns the given
    text.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="_fB_fP_f(BIpreprocess_paragraph()_fP_fB_fP"><a class="permalink" href="#_fB_fP_f(BIpreprocess_paragraph()_fP_fB_fP"><b></b><b><i>preprocess_paragraph()</i></b><b></b></a></h1>
<span class="Li"></span>
<pre>
            $textblock = $parser-&gt;preprocess_paragraph($text, $line_num);
</pre>
<p class="Pp">This method should be overridden by subclasses that wish to
    perform any kind of preprocessing for each block (paragraph) of POD
    documentation that appears in the input stream. The parameter
    <span class="Li">$text</span> is the POD paragraph from the input file; and
    the parameter <span class="Li">$line_num</span> is the line number for the
    beginning of the corresponding paragraph.</p>
<p class="Pp">The value returned should correspond to the new text to use in its
    place If the empty string is returned or an undefined value is returned,
    then the given <span class="Li">$text</span> is ignored (not processed).</p>
<p class="Pp">This method is invoked after gathering up all the lines in a
    paragraph and after determining the cutting state of the paragraph, but
    before trying to further parse or interpret them. After
    <b></b><b><i>preprocess_paragraph()</i></b><b></b> returns, the current
    cutting state (which is returned by
    <span class="Li">&quot;$self-&gt;cutting()&quot;</span>) is examined. If it
    evaluates to true then input text (including the given
    <span class="Li">$text</span>) is cut (not processed) until the next POD
    directive is encountered.</p>
<p class="Pp">Please note that the <b></b><b><i>preprocess_line()</i></b><b></b>
    method is invoked <i>before</i> the
    <b></b><b><i>preprocess_paragraph()</i></b> <b></b> method. After all
    (possibly preprocessed) lines in a paragraph have been assembled together
    and either it has been determined that the paragraph is part of the POD
    documentation from one of the selected sections or the
    <span class="Li">&quot;-want_nonPODs&quot;</span> option is true, then
    <b></b> <b><i>preprocess_paragraph()</i></b><b></b> is invoked.</p>
<p class="Pp">The base class implementation of this method returns the given
    text.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="METHODS_FOR_PARSING_AND_PROCESSING"><a class="permalink" href="#METHODS_FOR_PARSING_AND_PROCESSING">METHODS
  FOR PARSING AND PROCESSING</a></h1>
<b>Pod::Parser</b> provides several methods to process input text. These methods
  typically won't need to be overridden (and in some cases they can't be
  overridden), but subclasses may want to invoke them to exploit their
  functionality.
</section>
<section class="Sh">
<h1 class="Sh" id="_fB_fP_f(BIparse_text()_fP_fB_fP"><a class="permalink" href="#_fB_fP_f(BIparse_text()_fP_fB_fP"><b></b><b><i>parse_text()</i></b><b></b></a></h1>
<span class="Li"></span>
<pre>
            $ptree1 = $parser-&gt;parse_text($text, $line_num);
            $ptree2 = $parser-&gt;parse_text({%opts}, $text, $line_num);
            $ptree3 = $parser-&gt;parse_text(\%opts, $text, $line_num);
</pre>
<p class="Pp">This method is useful if you need to perform your own
    interpolation of interior sequences and can't rely upon <b>interpolate</b>
    to expand them in simple bottom-up order.</p>
<p class="Pp">The parameter <span class="Li">$text</span> is a string or block
    of text to be parsed for interior sequences; and the parameter
    <span class="Li">$line_num</span> is the line number corresponding to the
    beginning of <span class="Li">$text</span>.</p>
<p class="Pp"><b></b><b><i>parse_text()</i></b><b></b> will parse the given text
    into a parse-tree of &quot;nodes.&quot; and interior-sequences. Each
    &quot;node&quot; in the parse tree is either a text-string, or a
    <b>Pod::InteriorSequence</b>. The result returned is a parse-tree of type
    <b>Pod::ParseTree</b>. Please see Pod::InputObjects for more information
    about <b>Pod::InteriorSequence</b> and <b>Pod::ParseTree</b>.</p>
<p class="Pp">If desired, an optional hash-ref may be specified as the first
    argument to customize certain aspects of the parse-tree that is created and
    returned. The set of recognized option keywords are:</p>
<dl class="Bl-tag">
  <dt><b>-expand_seq</b> =&gt; <i>code-ref</i>|<i>method-name</i></dt>
  <dd>Normally, the parse-tree returned by
      <b></b><b><i>parse_text()</i></b><b></b> will contain an unexpanded
      <span class="Li">&quot;Pod::InteriorSequence&quot;</span> object for each
      interior-sequence encountered. Specifying <b>-expand_seq</b> tells
      <b></b><b><i>parse_text()</i></b><b></b> to &quot;expand&quot; every
      interior-sequence it sees by invoking the referenced function (or named
      method of the parser object) and using the return value as the expanded
      result.
    <p class="Pp">If a subroutine reference was given, it is invoked as:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  &amp;$code_ref( $parser, $sequence )
    </pre>
    <p class="Pp">and if a method-name was given, it is invoked as:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  $parser-&gt;method_name( $sequence )
    </pre>
    <p class="Pp">where <span class="Li">$parser</span> is a reference to the
        parser object, and <span class="Li">$sequence</span> is a reference to
        the interior-sequence object. [<i>NOTE</i>: If the
        <b></b><b><i>interior_sequence()</i></b><b></b> method is specified,
        then it is invoked according to the interface specified in
        &quot;<i>interior_sequence()</i>&quot;].</p>
  </dd>
  <dt><b>-expand_text</b> =&gt; <i>code-ref</i>|<i>method-name</i></dt>
  <dd>Normally, the parse-tree returned by
      <b></b><b><i>parse_text()</i></b><b></b> will contain a text-string for
      each contiguous sequence of characters outside of an interior-sequence.
      Specifying <b>-expand_text</b> tells
      <b></b><b><i>parse_text()</i></b><b></b> to &quot;preprocess&quot; every
      such text-string it sees by invoking the referenced function (or named
      method of the parser object) and using the return value as the
      preprocessed (or &quot;expanded&quot;) result. [Note that if the result is
      an interior-sequence, then it will <i>not</i> be expanded as specified by
      the <b>-expand_seq</b> option; Any such recursive expansion needs to be
      handled by the specified callback routine.]
    <p class="Pp">If a subroutine reference was given, it is invoked as:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  &amp;$code_ref( $parser, $text, $ptree_node )
    </pre>
    <p class="Pp">and if a method-name was given, it is invoked as:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  $parser-&gt;method_name( $text, $ptree_node )
    </pre>
    <p class="Pp">where <span class="Li">$parser</span> is a reference to the
        parser object, <span class="Li">$text</span> is the text-string
        encountered, and <span class="Li">$ptree_node</span> is a reference to
        the current node in the parse-tree (usually an interior-sequence object
        or else the top-level node of the parse-tree).</p>
  </dd>
  <dt><b>-expand_ptree</b> =&gt; <i>code-ref</i>|<i>method-name</i></dt>
  <dd>Rather than returning a
      <span class="Li">&quot;Pod::ParseTree&quot;</span>, pass the parse-tree as
      an argument to the referenced subroutine (or named method of the parser
      object) and return the result instead of the parse-tree object.
    <p class="Pp">If a subroutine reference was given, it is invoked as:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  &amp;$code_ref( $parser, $ptree )
    </pre>
    <p class="Pp">and if a method-name was given, it is invoked as:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  $parser-&gt;method_name( $ptree )
    </pre>
    <p class="Pp">where <span class="Li">$parser</span> is a reference to the
        parser object, and <span class="Li">$ptree</span> is a reference to the
        parse-tree object.</p>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="_fB_fP_f(BIinterpolate()_fP_fB_fP"><a class="permalink" href="#_fB_fP_f(BIinterpolate()_fP_fB_fP"><b></b><b><i>interpolate()</i></b><b></b></a></h1>
<span class="Li"></span>
<pre>
            $textblock = $parser-&gt;interpolate($text, $line_num);
</pre>
<p class="Pp">This method translates all text (including any embedded interior
    sequences) in the given text string <span class="Li">$text</span> and
    returns the interpolated result. The parameter
    <span class="Li">$line_num</span> is the line number corresponding to the
    beginning of <span class="Li">$text</span>.</p>
<p class="Pp"><b></b><b><i>interpolate()</i></b><b></b> merely invokes a private
    method to recursively expand nested interior sequences in bottom-up order
    (innermost sequences are expanded first). If there is a need to expand
    nested sequences in some alternate order, use <b>parse_text</b> instead.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="_fB_fP_f(BIparse_from_filehandle()_fP_fB_fP"><a class="permalink" href="#_fB_fP_f(BIparse_from_filehandle()_fP_fB_fP"><b></b><b><i>parse_from_filehandle()</i></b><b></b></a></h1>
<span class="Li"></span>
<pre>
            $parser-&gt;parse_from_filehandle($in_fh,$out_fh);
</pre>
<p class="Pp">This method takes an input filehandle (which is assumed to already
    be opened for reading) and reads the entire input stream looking for blocks
    (paragraphs) of POD documentation to be processed. If no first argument is
    given the default input filehandle <span class="Li">&quot;STDIN&quot;</span>
    is used.</p>
<p class="Pp">The <span class="Li">$in_fh</span> parameter may be any object
    that provides a <b></b><b><i>getline()</i></b><b></b> method to retrieve a
    single line of input text (hence, an appropriate wrapper object could be
    used to parse PODs from a single string or an array of strings).</p>
<p class="Pp">Using <span class="Li">&quot;$in_fh-&gt;getline()&quot;</span>,
    input is read line-by-line and assembled into paragraphs or
    &quot;blocks&quot; (which are separated by lines containing nothing but
    whitespace). For each block of POD documentation encountered it will invoke
    a method to parse the given paragraph.</p>
<p class="Pp">If a second argument is given then it should correspond to a
    filehandle where output should be sent (otherwise the default output
    filehandle is <span class="Li">&quot;STDOUT&quot;</span> if no output
    filehandle is currently in use).</p>
<p class="Pp"><b>NOTE:</b> For performance reasons, this method caches the input
    stream at the top of the stack in a local variable. Any attempts by clients
    to change the stack contents during processing when in the midst executing
    of this method <i>will not affect</i> the input stream used by the current
    invocation of this method.</p>
<p class="Pp">This method does <i>not</i> usually need to be overridden by
    subclasses.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="_fB_fP_f(BIparse_from_file()_fP_fB_fP"><a class="permalink" href="#_fB_fP_f(BIparse_from_file()_fP_fB_fP"><b></b><b><i>parse_from_file()</i></b><b></b></a></h1>
<span class="Li"></span>
<pre>
            $parser-&gt;parse_from_file($filename,$outfile);
</pre>
<p class="Pp">This method takes a filename and does the following:</p>
<ul class="Bl-bullet">
  <li>opens the input and output files for reading (creating the appropriate
      filehandles)</li>
  <li>invokes the <b></b><b><i>parse_from_filehandle()</i></b><b></b> method
      passing it the corresponding input and output filehandles.</li>
  <li>closes the input and output files.</li>
</ul>
<p class="Pp">If the special input filename &quot;-&quot; or
    &quot;&lt;&amp;STDIN&quot; is given then the STDIN filehandle is used for
    input (and no open or close is performed). If no input filename is specified
    then &quot;-&quot; is implied. Filehandle references, or objects that
    support the regular IO operations (like
    <span class="Li">&quot;&lt;$fh&gt;&quot;</span> or
    <span class="Li">&quot;$fh-&lt;Egt&quot;</span>getline&gt;) are also
    accepted; the handles must already be opened.</p>
<p class="Pp">If a second argument is given then it should be the name of the
    desired output file. If the special output filename &quot;-&quot; or
    &quot;&gt;&amp;STDOUT&quot; is given then the STDOUT filehandle is used for
    output (and no open or close is performed). If the special output filename
    &quot;&gt;&amp;STDERR&quot; is given then the STDERR filehandle is used for
    output (and no open or close is performed). If no output filehandle is
    currently in use and no output filename is specified, then &quot;-&quot; is
    implied. Alternatively, filehandle references or objects that support the
    regular IO operations (like <span class="Li">&quot;print&quot;</span>, e.g.
    IO::String) are also accepted; the object must already be opened.</p>
<p class="Pp">This method does <i>not</i> usually need to be overridden by
    subclasses.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="ACCESSOR_METHODS"><a class="permalink" href="#ACCESSOR_METHODS">ACCESSOR
  METHODS</a></h1>
Clients of <b>Pod::Parser</b> should use the following methods to access
  instance data fields:
</section>
<section class="Sh">
<h1 class="Sh" id="_fB_fP_f(BIerrorsub()_fP_fB_fP"><a class="permalink" href="#_fB_fP_f(BIerrorsub()_fP_fB_fP"><b></b><b><i>errorsub()</i></b><b></b></a></h1>
<span class="Li"></span>
<pre>
            $parser-&gt;errorsub(&quot;method_name&quot;);
            $parser-&gt;errorsub(\&amp;warn_user);
            $parser-&gt;errorsub(sub { print STDERR, @_ });
</pre>
<p class="Pp">Specifies the method or subroutine to use when printing error
    messages about POD syntax. The supplied method/subroutine <i>must</i> return
    TRUE upon successful printing of the message. If
    <span class="Li">&quot;undef&quot;</span> is given, then the <b>carp</b>
    builtin is used to issue error messages (this is the default behavior).</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
            my $errorsub = $parser-&gt;errorsub()
            my $errmsg = &quot;This is an error message!\n&quot;
            (ref $errorsub) and &amp;{$errorsub}($errmsg)
                or (defined $errorsub) and $parser-&gt;$errorsub($errmsg)
                    or  carp($errmsg);
</pre>
<p class="Pp">Returns a method name, or else a reference to the user-supplied
    subroutine used to print error messages. Returns
    <span class="Li">&quot;undef&quot;</span> if the <b>carp</b> builtin is used
    to issue error messages (this is the default behavior).</p>
</section>
<section class="Sh">
<h1 class="Sh" id="_fB_fP_f(BIcutting()_fP_fB_fP"><a class="permalink" href="#_fB_fP_f(BIcutting()_fP_fB_fP"><b></b><b><i>cutting()</i></b><b></b></a></h1>
<span class="Li"></span>
<pre>
            $boolean = $parser-&gt;cutting();
</pre>
<p class="Pp">Returns the current <span class="Li">&quot;cutting&quot;</span>
    state: a boolean-valued scalar which evaluates to true if text from the
    input file is currently being &quot;cut&quot; (meaning it is <i>not</i>
    considered part of the POD document).</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
            $parser-&gt;cutting($boolean);
</pre>
<p class="Pp">Sets the current <span class="Li">&quot;cutting&quot;</span> state
    to the given value and returns the result.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="_fB_fP_f(BIparseopts()_fP_fB_fP"><a class="permalink" href="#_fB_fP_f(BIparseopts()_fP_fB_fP"><b></b><b><i>parseopts()</i></b><b></b></a></h1>
When invoked with no additional arguments, <b>parseopts</b> returns a hashtable
  of all the current parsing options.
<p class="Pp"><span class="Li"></span></p>
<pre>
            ## See if we are parsing non-POD sections as well as POD ones
            my %opts = $parser-&gt;parseopts();
            $opts{'-want_nonPODs}' and print &quot;-want_nonPODs\n&quot;;
</pre>
<p class="Pp">When invoked using a single string, <b>parseopts</b> treats the
    string as the name of a parse-option and returns its corresponding value if
    it exists (returns <span class="Li">&quot;undef&quot;</span> if it
  doesn't).</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
            ## Did we ask to see '=cut' paragraphs?
            my $want_cut = $parser-&gt;parseopts('-process_cut_cmd');
            $want_cut and print &quot;-process_cut_cmd\n&quot;;
</pre>
<p class="Pp">When invoked with multiple arguments, <b>parseopts</b> treats them
    as key/value pairs and the specified parse-option names are set to the given
    values. Any unspecified parse-options are unaffected.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
            ## Set them back to the default
            $parser-&gt;parseopts(-warnings =&gt; 0);
</pre>
<p class="Pp">When passed a single hash-ref, <b>parseopts</b> uses that hash to
    completely reset the existing parse-options, all previous parse-option
    values are lost.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
            ## Reset all options to default 
            $parser-&gt;parseopts( { } );
</pre>
<p class="Pp">See &quot;PARSING OPTIONS&quot; for more information on the name
    and meaning of each parse-option currently recognized.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="_fB_fP_f(BIoutput_file()_fP_fB_fP"><a class="permalink" href="#_fB_fP_f(BIoutput_file()_fP_fB_fP"><b></b><b><i>output_file()</i></b><b></b></a></h1>
<span class="Li"></span>
<pre>
            $fname = $parser-&gt;output_file();
</pre>
<p class="Pp">Returns the name of the output file being written.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="_fB_fP_f(BIoutput_handle()_fP_fB_fP"><a class="permalink" href="#_fB_fP_f(BIoutput_handle()_fP_fB_fP"><b></b><b><i>output_handle()</i></b><b></b></a></h1>
<span class="Li"></span>
<pre>
            $fhandle = $parser-&gt;output_handle();
</pre>
<p class="Pp">Returns the output filehandle object.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="_fB_fP_f(BIinput_file()_fP_fB_fP"><a class="permalink" href="#_fB_fP_f(BIinput_file()_fP_fB_fP"><b></b><b><i>input_file()</i></b><b></b></a></h1>
<span class="Li"></span>
<pre>
            $fname = $parser-&gt;input_file();
</pre>
<p class="Pp">Returns the name of the input file being read.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="_fB_fP_f(BIinput_handle()_fP_fB_fP"><a class="permalink" href="#_fB_fP_f(BIinput_handle()_fP_fB_fP"><b></b><b><i>input_handle()</i></b><b></b></a></h1>
<span class="Li"></span>
<pre>
            $fhandle = $parser-&gt;input_handle();
</pre>
<p class="Pp">Returns the current input filehandle object.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="PRIVATE_METHODS_AND_DATA"><a class="permalink" href="#PRIVATE_METHODS_AND_DATA">PRIVATE
  METHODS AND DATA</a></h1>
<b>Pod::Parser</b> makes use of several internal methods and data fields which
  clients should not need to see or use. For the sake of avoiding name
  collisions for client data and methods, these methods and fields are briefly
  discussed here. Determined hackers may obtain further information about them
  by reading the <b>Pod::Parser</b> source code.
<p class="Pp">Private data fields are stored in the hash-object whose reference
    is returned by the <b></b><b><i>new()</i></b><b></b> constructor for this
    class. The names of all private methods and data-fields used by
    <b>Pod::Parser</b> begin with a prefix of &quot;_&quot; and match the
    regular expression <span class="Li">&quot;/^_\w+$/&quot;</span>.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="TREE-BASED_PARSING"><a class="permalink" href="#TREE-BASED_PARSING">TREE-BASED
  PARSING</a></h1>
If straightforward stream-based parsing wont meet your needs (as is likely the
  case for tasks such as translating PODs into structured markup languages like
  HTML and XML) then you may need to take the tree-based approach. Rather than
  doing everything in one pass and calling the
  <b></b><b><i>interpolate()</i></b> <b></b> method to expand sequences into
  text, it may be desirable to instead create a parse-tree using the
  <b></b><b><i>parse_text()</i></b><b></b> method to return a tree-like
  structure which may contain an ordered list of children (each of which may be
  a text-string, or a similar tree-like structure).
<p class="Pp">Pay special attention to &quot;METHODS FOR PARSING AND
    PROCESSING&quot; and to the objects described in Pod::InputObjects. The
    former describes the gory details and parameters for how to customize and
    extend the parsing behavior of <b>Pod::Parser</b>. <b>Pod::InputObjects</b>
    provides several objects that may all be used interchangeably as
    parse-trees. The most obvious one is the <b>Pod::ParseTree</b> object. It
    defines the basic interface and functionality that all things trying to be a
    POD parse-tree should do. A <b>Pod::ParseTree</b> is defined such that each
    &quot;node&quot; may be a text-string, or a reference to another parse-tree.
    Each <b>Pod::Paragraph</b> object and each <b>Pod::InteriorSequence</b>
    object also supports the basic parse-tree interface.</p>
<p class="Pp">The <b></b><b><i>parse_text()</i></b><b></b> method takes a given
    paragraph of text, and returns a parse-tree that contains one or more
    children, each of which may be a text-string, or an InteriorSequence object.
    There are also callback-options that may be passed to
    <b></b><b><i>parse_text()</i></b><b></b> to customize the way it expands or
    transforms interior-sequences, as well as the returned result. These
    callbacks can be used to create a parse-tree with custom-made objects (which
    may or may not support the parse-tree interface, depending on how you choose
    to do it).</p>
<p class="Pp">If you wish to turn an entire POD document into a parse-tree, that
    process is fairly straightforward. The
    <b></b><b><i>parse_text()</i></b><b></b> method is the key to doing this
    successfully. Every paragraph-callback (i.e. the polymorphic methods for
    <b></b> <b><i>command()</i></b><b></b>,
    <b></b><b><i>verbatim()</i></b><b></b>, and
    <b></b><b><i>textblock()</i></b><b></b> paragraphs) takes a
    <b>Pod::Paragraph</b> object as an argument. Each paragraph object has a
    <b></b> <b><i>parse_tree()</i></b><b></b> method that can be used to get or
    set a corresponding parse-tree. So for each of those paragraph-callback
    methods, simply call <b></b><b><i>parse_text()</i></b><b></b> with the
    options you desire, and then use the returned parse-tree to assign to the
    given paragraph object.</p>
<p class="Pp">That gives you a parse-tree for each paragraph - so now all you
    need is an ordered list of paragraphs. You can maintain that yourself as a
    data element in the object/hash. The most straightforward way would be
    simply to use an array-ref, with the desired set of custom
    &quot;options&quot; for each invocation of <b>parse_text</b>. Let's assume
    the desired option-set is given by the hash
    <span class="Li">%options</span>. Then we might do something like the
    following:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    package MyPodParserTree;

    @ISA = qw( Pod::Parser );

    ...

    sub begin_pod {
        my $self = shift;
        $self-&gt;{'-paragraphs'} = [];  ## initialize paragraph list
    }

    sub command { 
        my ($parser, $command, $paragraph, $line_num, $pod_para) = @_;
        my $ptree = $parser-&gt;parse_text({%options}, $paragraph, ...);
        $pod_para-&gt;parse_tree( $ptree );
        push @{ $self-&gt;{'-paragraphs'} }, $pod_para;
    }

    sub verbatim { 
        my ($parser, $paragraph, $line_num, $pod_para) = @_;
        push @{ $self-&gt;{'-paragraphs'} }, $pod_para;
    }

    sub textblock { 
        my ($parser, $paragraph, $line_num, $pod_para) = @_;
        my $ptree = $parser-&gt;parse_text({%options}, $paragraph, ...);
        $pod_para-&gt;parse_tree( $ptree );
        push @{ $self-&gt;{'-paragraphs'} }, $pod_para;
    }

    ...

    package main;
    ...
    my $parser = new MyPodParserTree(...);
    $parser-&gt;parse_from_file(...);
    my $paragraphs_ref = $parser-&gt;{'-paragraphs'};
</pre>
<p class="Pp">Of course, in this module-author's humble opinion, I'd be more
    inclined to use the existing <b>Pod::ParseTree</b> object than a simple
    array. That way everything in it, paragraphs and sequences, all respond to
    the same core interface for all parse-tree nodes. The result would look
    something like:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    package MyPodParserTree2;

    ...

    sub begin_pod {
        my $self = shift;
        $self-&gt;{'-ptree'} = new Pod::ParseTree;  ## initialize parse-tree
    }

    sub parse_tree {
        ## convenience method to get/set the parse-tree for the entire POD
        (@_ &gt; 1)  and  $_[0]-&gt;{'-ptree'} = $_[1];
        return $_[0]-&gt;{'-ptree'};
    }

    sub command { 
        my ($parser, $command, $paragraph, $line_num, $pod_para) = @_;
        my $ptree = $parser-&gt;parse_text({&lt;&lt;options&gt;&gt;}, $paragraph, ...);
        $pod_para-&gt;parse_tree( $ptree );
        $parser-&gt;parse_tree()-&gt;append( $pod_para );
    }

    sub verbatim { 
        my ($parser, $paragraph, $line_num, $pod_para) = @_;
        $parser-&gt;parse_tree()-&gt;append( $pod_para );
    }

    sub textblock { 
        my ($parser, $paragraph, $line_num, $pod_para) = @_;
        my $ptree = $parser-&gt;parse_text({&lt;&lt;options&gt;&gt;}, $paragraph, ...);
        $pod_para-&gt;parse_tree( $ptree );
        $parser-&gt;parse_tree()-&gt;append( $pod_para );
    }

    ...

    package main;
    ...
    my $parser = new MyPodParserTree2(...);
    $parser-&gt;parse_from_file(...);
    my $ptree = $parser-&gt;parse_tree;
    ...
</pre>
<p class="Pp">Now you have the entire POD document as one great big parse-tree.
    You can even use the <b>-expand_seq</b> option to <b>parse_text</b> to
    insert whole different kinds of objects. Just don't expect
    <b>Pod::Parser</b> to know what to do with them after that. That will need
    to be in your code. Or, alternatively, you can insert any object you like so
    long as it conforms to the <b>Pod::ParseTree</b> interface.</p>
<p class="Pp">One could use this to create subclasses of <b>Pod::Paragraphs</b>
    and <b>Pod::InteriorSequences</b> for specific commands (or to create your
    own custom node-types in the parse-tree) and add some kind of
    <b></b><b><i>emit()</i></b><b></b> method to each custom node/subclass
    object in the tree. Then all you'd need to do is recursively walk the tree
    in the desired order, processing the children (most likely from left to
    right) by formatting them if they are text-strings, or by calling their
    <b></b> <b><i>emit()</i></b><b></b> method if they are
  objects/references.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="CAVEATS"><a class="permalink" href="#CAVEATS">CAVEATS</a></h1>
Please note that POD has the notion of &quot;paragraphs&quot;: this is something
  starting <i>after</i> a blank (read: empty) line, with the single exception of
  the file start, which is also starting a paragraph. That means that especially
  a command (e.g. <span class="Li">&quot;=head1&quot;</span>) <i>must</i> be
  preceded with a blank line; <span class="Li">&quot;__END__&quot;</span> is
  <i>not</i> a blank line.
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
Pod::InputObjects, Pod::Select
<p class="Pp"><b>Pod::InputObjects</b> defines POD input objects corresponding
    to command paragraphs, parse-trees, and interior-sequences.</p>
<p class="Pp"><b>Pod::Select</b> is a subclass of <b>Pod::Parser</b> which
    provides the ability to selectively include and/or exclude sections of a POD
    document from being translated based upon the current heading, subheading,
    subsubheading, etc.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
Please report bugs using &lt;http://rt.cpan.org&gt;.
<p class="Pp">Brad Appleton &lt;bradapp@enteract.com&gt;</p>
<p class="Pp">Based on code for <b>Pod::Text</b> written by Tom Christiansen
    &lt;tchrist@mox.perl.com&gt;</p>
</section>
<section class="Sh">
<h1 class="Sh" id="LICENSE"><a class="permalink" href="#LICENSE">LICENSE</a></h1>
Pod-Parser is free software; you can redistribute it and/or modify it under the
  terms of the Artistic License distributed with Perl version 5.000 or (at your
  option) any later version. Please refer to the Artistic License that came with
  your Perl distribution for more details. If your version of Perl was not
  distributed under the terms of the Artistic License, than you may distribute
  PodParser under the same terms as Perl itself.
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2014-09-30</td>
    <td class="foot-os">perl v5.18.4</td>
  </tr>
</table>
</body>
</html>
