<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>charnames(3pm)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">charnames(3pm)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">charnames(3pm)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
charnames - access to Unicode character names and named character sequences;
  also define character names
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<span class="Li"></span>
<pre>
 use charnames ':full';
 print &quot;\N{GREEK SMALL LETTER SIGMA} is called sigma.\n&quot;;
 print &quot;\N{LATIN CAPITAL LETTER E WITH VERTICAL LINE BELOW}&quot;,
       &quot; is an officially named sequence of two Unicode characters\n&quot;;

 use charnames ':loose';
 print &quot;\N{Greek small-letter  sigma}&quot;,
        &quot;can be used to ignore case, underscores, most blanks,&quot;
        &quot;and when you aren't sure if the official name has hyphens\n&quot;;

 use charnames ':short';
 print &quot;\N{greek:Sigma} is an upper-case sigma.\n&quot;;

 use charnames qw(cyrillic greek);
 print &quot;\N{sigma} is Greek sigma, and \N{be} is Cyrillic b.\n&quot;;

 use utf8;
 use charnames &quot;:full&quot;, &quot;:alias&quot; =&gt; {
   e_ACUTE =&gt; &quot;LATIN SMALL LETTER E WITH ACUTE&quot;,
   mychar =&gt; 0xE8000,  # Private use area
   &quot;XXXXXXX&quot; =&gt; &quot;BICYCLIST&quot;
 };
 print &quot;\N{e_ACUTE} is a small letter e with an acute.\n&quot;;
 print &quot;\N{mychar} allows me to name private use characters.\n&quot;;
 print &quot;And I can create synonyms in other languages,&quot;,
       &quot; such as \N{XXXXXXX} for &quot;BICYCLIST (U+1F6B4)\n&quot;;

 use charnames ();
 print charnames::viacode(0x1234); # prints &quot;ETHIOPIC SYLLABLE SEE&quot;
 printf &quot;%04X&quot;, charnames::vianame(&quot;GOTHIC LETTER AHSA&quot;); # prints
                                                          # &quot;10330&quot;
 print charnames::vianame(&quot;LATIN CAPITAL LETTER A&quot;); # prints 65 on
                                                     # ASCII platforms;
                                                     # 193 on EBCDIC
 print charnames::string_vianame(&quot;LATIN CAPITAL LETTER A&quot;); # prints &quot;A&quot;
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
Pragma <span class="Li">&quot;use charnames&quot;</span> is used to gain access
  to the names of the Unicode characters and named character sequences, and to
  allow you to define your own character and character sequence names.
<p class="Pp">All forms of the pragma enable use of the following 3
  functions:</p>
<ul class="Bl-bullet">
  <li>&quot;charnames::string_vianame(<i>name</i>)&quot; for run-time lookup of
      a either a character name or a named character sequence, returning its
      string representation</li>
  <li>&quot;charnames::vianame(<i>name</i>)&quot; for run-time lookup of a
      character name (but not a named character sequence) to get its ordinal
      value (code point)</li>
  <li>&quot;charnames::viacode(<i>code</i>)&quot; for run-time lookup of a code
      point to get its Unicode name.</li>
</ul>
<p class="Pp">Starting in Perl v5.16, any occurrence of
    <span class="Li">&quot;\N{</span><i>CHARNAME</i><span class="Li">}&quot;</span>
    sequences in a double-quotish string automatically loads this module with
    arguments <span class="Li">&quot;:full&quot;</span> and
    <span class="Li">&quot;:short&quot;</span> (described below) if it hasn't
    already been loaded with different arguments, in order to compile the named
    Unicode character into position in the string. Prior to v5.16, an explicit
    <span class="Li">&quot;use&#x00A0;charnames&quot;</span> was required to
    enable this usage. (However, prior to v5.16, the form
    <span class="Li">&quot;use&#x00A0;charnames&#x00A0;();&quot;</span> did not
    enable
    <span class="Li">&quot;\N{</span><i>CHARNAME</i><span class="Li">}&quot;</span>.)</p>
<p class="Pp">Note that
    <span class="Li">&quot;\N{U+</span><i>...</i><span class="Li">}&quot;</span>,
    where the <i>...</i> is a hexadecimal number, also inserts a character into
    a string. The character it inserts is the one whose code point (ordinal
    value) is equal to the number. For example,
    <span class="Li">&quot;\N{U+263a}&quot;</span> is the Unicode (white
    background, black foreground) smiley face equivalent to
    <span class="Li">&quot;\N{WHITE SMILING FACE}&quot;</span>. Also note,
    <span class="Li">&quot;\N{</span><i>...</i><span class="Li">}&quot;</span>
    can mean a regex quantifier instead of a character name, when the <i>...</i>
    is a number (or comma separated pair of numbers (see &quot;QUANTIFIERS&quot;
    in perlreref), and is not related to this pragma.</p>
<p class="Pp">The <span class="Li">&quot;charnames&quot;</span> pragma supports
    arguments <span class="Li">&quot;:full&quot;</span>,
    <span class="Li">&quot;:loose&quot;</span>,
    <span class="Li">&quot;:short&quot;</span>, script names and customized
    aliases.</p>
<p class="Pp">If <span class="Li">&quot;:full&quot;</span> is present, for
    expansion of
    <span class="Li">&quot;\N{</span><i>CHARNAME</i><span class="Li">}&quot;</span>,
    the string <i>CHARNAME</i> is first looked up in the list of standard
    Unicode character names.</p>
<p class="Pp"><span class="Li">&quot;:loose&quot;</span> is a variant of
    <span class="Li">&quot;:full&quot;</span> which allows <i>CHARNAME</i> to be
    less precisely specified. Details are in &quot;LOOSE MATCHES&quot;.</p>
<p class="Pp">If <span class="Li">&quot;:short&quot;</span> is present, and
    <i>CHARNAME</i> has the form
    <span class="Li">&quot;</span><i>SCRIPT</i><span class="Li">:</span><i>CNAME</i><span class="Li">&quot;</span>,
    then <i>CNAME</i> is looked up as a letter in script <i>SCRIPT</i>, as
    described in the next paragraph. Or, if <span class="Li">&quot;use
    charnames&quot;</span> is used with script name arguments, then for
    <span class="Li">&quot;\N{</span><i>CHARNAME</i><span class="Li">}&quot;</span>
    the name <i>CHARNAME</i> is looked up as a letter in the given scripts (in
    the specified order). Customized aliases can override these, and are
    explained in &quot;CUSTOM ALIASES&quot;.</p>
<p class="Pp">For lookup of <i>CHARNAME</i> inside a given script
    <i>SCRIPTNAME</i>, this pragma looks in the table of standard Unicode names
    for the names</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  SCRIPTNAME CAPITAL LETTER CHARNAME
  SCRIPTNAME SMALL LETTER CHARNAME
  SCRIPTNAME LETTER CHARNAME
</pre>
<p class="Pp">If <i>CHARNAME</i> is all lowercase, then the
    <span class="Li">&quot;CAPITAL&quot;</span> variant is ignored, otherwise
    the <span class="Li">&quot;SMALL&quot;</span> variant is ignored, and both
    <i>CHARNAME</i> and <i>SCRIPTNAME</i> are converted to all uppercase for
    look-up. Other than that, both of them follow loose rules if
    <span class="Li">&quot;:loose&quot;</span> is also specified; strict
    otherwise.</p>
<p class="Pp">Note that <span class="Li">&quot;\N{...}&quot;</span> is
    compile-time; it's a special form of string constant used inside
    double-quotish strings; this means that you cannot use variables inside the
    <span class="Li">&quot;\N{...}&quot;</span>. If you want similar run-time
    functionality, use <i>charnames::string_vianame()</i>.</p>
<p class="Pp">Note, starting in Perl 5.18, the name
    <span class="Li">&quot;BELL&quot;</span> refers to the Unicode character
    U+1F514, instead of the traditional U+0007. For the latter, use
    <span class="Li">&quot;ALERT&quot;</span> or
    <span class="Li">&quot;BEL&quot;</span>.</p>
<p class="Pp">It is a syntax error to use
    <span class="Li">&quot;\N{NAME}&quot;</span> where
    <span class="Li">&quot;NAME&quot;</span> is unknown.</p>
<p class="Pp">For <span class="Li">&quot;\N{NAME}&quot;</span>, it is a fatal
    error if <span class="Li">&quot;use bytes&quot;</span> is in effect and the
    input name is that of a character that won't fit into a byte (i.e., whose
    ordinal is above 255).</p>
<p class="Pp">Otherwise, any string that includes a
    <span class="Li">&quot;\N{</span>
    <i>charname</i><span class="Li">}&quot;</span> or
    <span class="Li">&quot;\N{U+</span><i>code&#x00A0;point</i><span class="Li">}&quot;</span>
    will automatically have Unicode semantics (see &quot;Byte and Character
    Semantics&quot; in perlunicode).</p>
</section>
<section class="Sh">
<h1 class="Sh" id="LOOSE_MATCHES"><a class="permalink" href="#LOOSE_MATCHES">LOOSE
  MATCHES</a></h1>
By specifying <span class="Li">&quot;:loose&quot;</span>, Unicode's loose
  character name matching
  &lt;http://www.unicode.org/reports/tr44#Matching_Rules&gt; rules are selected
  instead of the strict exact match used otherwise. That means that
  <i>CHARNAME</i> doesn't have to be so precisely specified. Upper/lower case
  doesn't matter (except with scripts as mentioned above), nor do any
  underscores, and the only hyphens that matter are those at the beginning or
  end of a word in the name (with one exception: the hyphen in U+1180
  <span class="Li">&quot;HANGUL JUNGSEONG O-E&quot;</span> does matter). Also,
  blanks not adjacent to hyphens don't matter. The official Unicode names are
  quite variable as to where they use hyphens versus spaces to separate
  word-like units, and this option allows you to not have to care as much. The
  reason non-medial hyphens matter is because of cases like U+0F60
  <span class="Li">&quot;TIBETAN LETTER -A&quot;</span> versus U+0F68
  <span class="Li">&quot;TIBETAN LETTER A&quot;</span>. The hyphen here is
  significant, as is the space before it, and so both must be included.
<p class="Pp"><span class="Li">&quot;:loose&quot;</span> slows down look-ups by
    a factor of 2 to 3 versus <span class="Li">&quot;:full&quot;</span>, but the
    trade-off may be worth it to you. Each individual look-up takes very little
    time, and the results are cached, so the speed difference would become a
    factor only in programs that do look-ups of many different spellings, and
    probably only when those look-ups are through
    <span class="Li">&quot;vianame()&quot;</span> and
    <span class="Li">&quot;string_vianame()&quot;</span>, since
    <span class="Li">&quot;\N{...}&quot;</span> look-ups are done at compile
    time.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="ALIASES"><a class="permalink" href="#ALIASES">ALIASES</a></h1>
Starting in Unicode 6.1 and Perl v5.16, Unicode defines many abbreviations and
  names that were formerly Perl extensions, and some additional ones that Perl
  did not previously accept. The list is getting too long to reproduce here, but
  you can get the complete list from the Unicode web site:
  &lt;http://www.unicode.org/Public/UNIDATA/NameAliases.txt&gt;.
<p class="Pp">Earlier versions of Perl accepted almost all the 6.1 names. These
    were most extensively documented in the v5.14 version of this pod:
    &lt;http://perldoc.perl.org/5.14.0/charnames.html#ALIASES&gt;.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="CUSTOM_ALIASES"><a class="permalink" href="#CUSTOM_ALIASES">CUSTOM
  ALIASES</a></h1>
You can add customized aliases to standard
  (<span class="Li">&quot;:full&quot;</span>) Unicode naming conventions. The
  aliases override any standard definitions, so, if you're twisted enough, you
  can change <span class="Li">&quot;\N{LATIN CAPITAL LETTER A}&quot;</span> to
  mean <span class="Li">&quot;B&quot;</span>, etc.
<p class="Pp">Aliases must begin with a character that is alphabetic. After
    that, each may contain any combination of word
    (<span class="Li">&quot;\w&quot;</span>) characters, SPACE (U+0020),
    HYPHEN-MINUS (U+002D), LEFT PARENTHESIS (U+0028), RIGHT PARENTHESIS
    (U+0029), and NO-BREAK SPACE (U+00A0). These last three should never have
    been allowed in names, and are retained for backwards compatibility only;
    they may be deprecated and removed in future releases of Perl, so don't use
    them for new names. (More precisely, the first character of a name you
    specify must be something that matches all of
    <span class="Li">&quot;\p{ID_Start}&quot;</span>,
    <span class="Li">&quot;\p{Alphabetic}&quot;</span>, and
    <span class="Li">&quot;\p{Gc=Letter}&quot;</span>. This makes sure it is
    what any reasonable person would view as an alphabetic character. And, the
    continuation characters that match <span class="Li">&quot;\w&quot;</span>
    must also match <span class="Li">&quot;\p{ID_Continue}&quot;</span>.)
    Starting with Perl v5.18, any Unicode characters meeting the above criteria
    may be used; prior to that only Latin1-range characters were acceptable.</p>
<p class="Pp">An alias can map to either an official Unicode character name (not
    a loose matched name) or to a numeric code point (ordinal). The latter is
    useful for assigning names to code points in Unicode private use areas such
    as U+E800 through U+F8FF. A numeric code point must be a non-negative
    integer or a string beginning with <span class="Li">&quot;U+&quot;</span> or
    <span class="Li">&quot;0x&quot;</span> with the remainder considered to be a
    hexadecimal integer. A literal numeric constant must be unsigned; it will be
    interpreted as hex if it has a leading zero or contains non-decimal hex
    digits; otherwise it will be interpreted as decimal.</p>
<p class="Pp">Aliases are added either by the use of anonymous hashes:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    use charnames &quot;:alias&quot; =&gt; {
        e_ACUTE =&gt; &quot;LATIN SMALL LETTER E WITH ACUTE&quot;,
        mychar1 =&gt; 0xE8000,
        };
    my $str = &quot;\N{e_ACUTE}&quot;;
</pre>
<p class="Pp">or by using a file containing aliases:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    use charnames &quot;:alias&quot; =&gt; &quot;pro&quot;;
</pre>
<p class="Pp">This will try to read
    <span class="Li">&quot;unicore/pro_alias.pl&quot;</span> from the
    <span class="Li">@INC</span> path. This file should return a list in plain
    perl:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    (
    A_GRAVE         =&gt; &quot;LATIN CAPITAL LETTER A WITH GRAVE&quot;,
    A_CIRCUM        =&gt; &quot;LATIN CAPITAL LETTER A WITH CIRCUMFLEX&quot;,
    A_DIAERES       =&gt; &quot;LATIN CAPITAL LETTER A WITH DIAERESIS&quot;,
    A_TILDE         =&gt; &quot;LATIN CAPITAL LETTER A WITH TILDE&quot;,
    A_BREVE         =&gt; &quot;LATIN CAPITAL LETTER A WITH BREVE&quot;,
    A_RING          =&gt; &quot;LATIN CAPITAL LETTER A WITH RING ABOVE&quot;,
    A_MACRON        =&gt; &quot;LATIN CAPITAL LETTER A WITH MACRON&quot;,
    mychar2         =&gt; &quot;U+E8001&quot;,
    );
</pre>
<p class="Pp">Both these methods insert
    <span class="Li">&quot;:full&quot;</span> automatically as the first
    argument (if no other argument is given), and you can give the
    <span class="Li">&quot;:full&quot;</span> explicitly as well, like</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    use charnames &quot;:full&quot;, &quot;:alias&quot; =&gt; &quot;pro&quot;;
</pre>
<p class="Pp"><span class="Li">&quot;:loose&quot;</span> has no effect with
    these. Input names must match exactly, using
    <span class="Li">&quot;:full&quot;</span> rules.</p>
<p class="Pp">Also, both these methods currently allow only single characters to
    be named. To name a sequence of characters, use a custom translator
    (described below).</p>
</section>
<section class="Sh">
<h1 class="Sh" id="charnames::string_vianame(_fIname_fP)"><a class="permalink" href="#charnames::string_vianame(_fIname_fP)">charnames::string_vianame(<i>name</i>)</a></h1>
This is a runtime equivalent to <span class="Li">&quot;\N{...}&quot;</span>.
  <i>name</i> can be any expression that evaluates to a name accepted by
  <span class="Li">&quot;\N{...}&quot;</span> under the
  <span class="Li">&quot;:full&quot;</span> option to
  <span class="Li">&quot;charnames&quot;</span>. In addition, any other options
  for the controlling <span class="Li">&quot;use charnames&quot;</span> in the
  same scope apply, like <span class="Li">&quot;:loose&quot;</span> or any
  script list, <span class="Li">&quot;:short&quot;</span> option, or custom
  aliases you may have defined.
<p class="Pp">The only differences are due to the fact that
    <span class="Li">&quot;string_vianame&quot;</span> is run-time and
    <span class="Li">&quot;\N{}&quot;</span> is compile time. You can't
    interpolate inside a <span class="Li">&quot;\N{}&quot;</span>, (so
    <span class="Li">&quot;\N{$variable}&quot;</span> doesn't work); and if the
    input name is unknown, <span class="Li">&quot;string_vianame&quot;</span>
    returns <span class="Li">&quot;undef&quot;</span> instead of it being a
    syntax error.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="charnames::vianame(_fIname_fP)"><a class="permalink" href="#charnames::vianame(_fIname_fP)">charnames::vianame(<i>name</i>)</a></h1>
This is similar to <span class="Li">&quot;string_vianame&quot;</span>. The main
  difference is that under most circumstances,
  <span class="Li">&quot;vianame&quot;</span> returns an ordinal code point,
  whereas <span class="Li">&quot;string_vianame&quot;</span> returns a string.
  For example,
<p class="Pp"><span class="Li"></span></p>
<pre>
   printf &quot;U+%04X&quot;, charnames::vianame(&quot;FOUR TEARDROP-SPOKED ASTERISK&quot;);
</pre>
<p class="Pp">prints &quot;U+2722&quot;.</p>
<p class="Pp">This leads to the other two differences. Since a single code point
    is returned, the function can't handle named character sequences, as these
    are composed of multiple characters (it returns
    <span class="Li">&quot;undef&quot;</span> for these. And, the code point can
    be that of any character, even ones that aren't legal under the
    <span class="Li">&quot;use&#x00A0;bytes&quot;</span> pragma,</p>
<p class="Pp">See &quot;BUGS&quot; for the circumstances in which the behavior
    differs from that described above.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="charnames::viacode(_fIcode_fP)"><a class="permalink" href="#charnames::viacode(_fIcode_fP)">charnames::viacode(<i>code</i>)</a></h1>
Returns the full name of the character indicated by the numeric code. For
  example,
<p class="Pp"><span class="Li"></span></p>
<pre>
    print charnames::viacode(0x2722);
</pre>
<p class="Pp">prints &quot;FOUR TEARDROP-SPOKED ASTERISK&quot;.</p>
<p class="Pp">The name returned is the &quot;best&quot; (defined below) official
    name or alias for the code point, if available; otherwise your custom alias
    for it, if defined; otherwise <span class="Li">&quot;undef&quot;</span>.
    This means that your alias will only be returned for code points that don't
    have an official Unicode name (nor alias) such as private use code
  points.</p>
<p class="Pp">If you define more than one name for the code point, it is
    indeterminate which one will be returned.</p>
<p class="Pp">As mentioned, the function returns
    <span class="Li">&quot;undef&quot;</span> if no name is known for the code
    point. In Unicode the proper name for these is the empty string, which
    <span class="Li">&quot;undef&quot;</span> stringifies to. (If you ask for a
    code point past the legal Unicode maximum of U+10FFFF that you haven't
    assigned an alias to, you get <span class="Li">&quot;undef&quot;</span> plus
    a warning.)</p>
<p class="Pp">The input number must be a non-negative integer, or a string
    beginning with <span class="Li">&quot;U+&quot;</span> or
    <span class="Li">&quot;0x&quot;</span> with the remainder considered to be a
    hexadecimal integer. A literal numeric constant must be unsigned; it will be
    interpreted as hex if it has a leading zero or contains non-decimal hex
    digits; otherwise it will be interpreted as decimal.</p>
<p class="Pp">As mentioned above under &quot;ALIASES&quot;, Unicode 6.1 defines
    extra names (synonyms or aliases) for some code points, most of which were
    already available as Perl extensions. All these are accepted by
    <span class="Li">&quot;\N{...}&quot;</span> and the other functions in this
    module, but <span class="Li">&quot;viacode&quot;</span> has to choose which
    one name to return for a given input code point, so it returns the
    &quot;best&quot; name. To understand how this works, it is helpful to know
    more about the Unicode name properties. All code points actually have only a
    single name, which (starting in Unicode 2.0) can never change once a
    character has been assigned to the code point. But mistakes have been made
    in assigning names, for example sometimes a clerical error was made during
    the publishing of the Standard which caused words to be misspelled, and
    there was no way to correct those. The Name_Alias property was eventually
    created to handle these situations. If a name was wrong, a corrected synonym
    would be published for it, using Name_Alias.
    <span class="Li">&quot;viacode&quot;</span> will return that corrected
    synonym as the &quot;best&quot; name for a code point. (It is even possible,
    though it hasn't happened yet, that the correction itself will need to be
    corrected, and so another Name_Alias can be created for that code point;
    <span class="Li">&quot;viacode&quot;</span> will return the most recent
    correction.)</p>
<p class="Pp">The Unicode name for each of the control characters (such as LINE
    FEED) is the empty string. However almost all had names assigned by other
    standards, such as the ASCII Standard, or were in common use.
    <span class="Li">&quot;viacode&quot;</span> returns these names as the
    &quot;best&quot; ones available. Unicode 6.1 has created Name_Aliases for
    each of them, including alternate names, like NEW LINE.
    <span class="Li">&quot;viacode&quot;</span> uses the original name,
    &quot;LINE FEED&quot; in preference to the alternate. Similarly the name
    returned for U+FEFF is &quot;ZERO WIDTH NO-BREAK SPACE&quot;, not &quot;BYTE
    ORDER MARK&quot;.</p>
<p class="Pp">Until Unicode 6.1, the 4 control characters U+0080, U+0081,
    U+0084, and U+0099 did not have names nor aliases. To preserve backwards
    compatibility, any alias you define for these code points will be returned
    by this function, in preference to the official name.</p>
<p class="Pp">Some code points also have abbreviated names, such as
    &quot;LF&quot; or &quot;NL&quot;.
    <span class="Li">&quot;viacode&quot;</span> never returns these.</p>
<p class="Pp">Because a name correction may be added in future Unicode releases,
    the name that <span class="Li">&quot;viacode&quot;</span> returns may change
    as a result. This is a rare event, but it does happen.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="CUSTOM_TRANSLATORS"><a class="permalink" href="#CUSTOM_TRANSLATORS">CUSTOM
  TRANSLATORS</a></h1>
The mechanism of translation of <span class="Li">&quot;\N{...}&quot;</span>
  escapes is general and not hardwired into <i>charnames.pm</i>. A module can
  install custom translations (inside the scope which
  <span class="Li">&quot;use&quot;</span>s the module) with the following magic
  incantation:
<p class="Pp"><span class="Li"></span></p>
<pre>
    sub import {
        shift;
        $^H{charnames} = \&amp;translator;
    }
</pre>
<p class="Pp">Here <i>translator()</i> is a subroutine which takes
    <i>CHARNAME</i> as an argument, and returns text to insert into the string
    instead of the
    <span class="Li">&quot;\N{</span><i>CHARNAME</i><span class="Li">}&quot;</span>
    escape.</p>
<p class="Pp">This is the only way you can create a custom named sequence of
    code points.</p>
<p class="Pp">Since the text to insert should be different in
    <span class="Li">&quot;bytes&quot;</span> mode and out of it, the function
    should check the current state of
    <span class="Li">&quot;bytes&quot;</span>-flag as in:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    use bytes ();                      # for $bytes::hint_bits
    sub translator {
        if ($^H &amp; $bytes::hint_bits) {
            return bytes_translator(@_);
        }
        else {
            return utf8_translator(@_);
        }
    }
</pre>
<p class="Pp">See &quot;CUSTOM ALIASES&quot; above for restrictions on
    <i>CHARNAME</i>.</p>
<p class="Pp">Of course, <span class="Li">&quot;vianame&quot;</span>,
    <span class="Li">&quot;viacode&quot;</span>, and
    <span class="Li">&quot;string_vianame&quot;</span> would need to be
    overridden as well.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="BUGS"><a class="permalink" href="#BUGS">BUGS</a></h1>
<i>vianame()</i> normally returns an ordinal code point, but when the input name
  is of the form <span class="Li">&quot;U+...&quot;</span>, it returns a chr
  instead. In this case, if <span class="Li">&quot;use bytes&quot;</span> is in
  effect and the character won't fit into a byte, it returns
  <span class="Li">&quot;undef&quot;</span> and raises a warning.
<p class="Pp">Since evaluation of the translation function (see &quot;CUSTOM
    TRANSLATORS&quot;) happens in the middle of compilation (of a string
    literal), the translation function should not do any
    <span class="Li">&quot;eval&quot;</span>s or
    <span class="Li">&quot;require&quot;</span>s. This restriction should be
    lifted (but is low priority) in a future version of Perl.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2014-09-30</td>
    <td class="foot-os">perl v5.18.4</td>
  </tr>
</table>
</body>
</html>
