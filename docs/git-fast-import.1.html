<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   t
       Title: git-fast-import
      Author: [FIXME: author] [see http://www.docbook.org/tdg5/en/html/author]
   Generator: DocBook XSL Stylesheets vsnapshot <http://docbook.sf.net/>
        Date: 06/06/2021
      Manual: Git Manual
      Source: Git 2.32.0
    Language: English
   -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    .Nd, .Bf, .Op { display: inline; }
    .Pa, .Ad { font-style: italic; }
    .Ms { font-weight: bold; }
    .Bl-diag > dt { font-weight: bold; }
    code.Nm, .Fl, .Cm, .Ic, code.In, .Fd, .Fn, .Cd { font-weight: bold;
      font-family: inherit; }
  </style>
  <title>GIT-FAST-IMPORT(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">GIT-FAST-IMPORT(1)</td>
    <td class="head-vol">Git Manual</td>
    <td class="head-rtitle">GIT-FAST-IMPORT(1)</td>
  </tr>
</table>
<div class="manual-text">
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">git-fast-import - Backend for fast Git data importers</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>frontend | <i>git fast-import</i> [&lt;options&gt;]</pre>
<p class="Pp"></p>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">This program is usually not what the end user wants to run
    directly. Most end users want to use one of the existing frontend programs,
    which parses a specific type of foreign source and feeds the contents stored
    there to <i>git fast-import</i>.</p>
<p class="Pp">fast-import reads a mixed command/data stream from standard input
    and writes one or more packfiles directly into the current repository. When
    EOF is received on standard input, fast import writes out updated branch and
    tag refs, fully updating the current repository with the newly imported
    data.</p>
<p class="Pp">The fast-import backend itself can import into an empty repository
    (one that has already been initialized by <i>git init</i>) or incrementally
    update an existing populated repository. Whether or not incremental imports
    are supported from a particular foreign source depends on the frontend
    program in use.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="OPTIONS"><a class="permalink" href="#OPTIONS">OPTIONS</a></h1>
<p class="Pp">--force</p>
<div class="Bd-indent">Force updating modified existing branches, even if doing
  so would cause commits to be lost (as the new commit does not contain the old
  commit).</div>
<p class="Pp">--quiet</p>
<div class="Bd-indent">Disable the output shown by --stats, making fast-import
  usually be silent when it is successful. However, if the import stream has
  directives intended to show user output (e.g. <b>progress</b> directives), the
  corresponding messages will still be shown.</div>
<p class="Pp">--stats</p>
<div class="Bd-indent">Display some basic statistics about the objects
  fast-import has created, the packfiles they were stored into, and the memory
  used by fast-import during this run. Showing this output is currently the
  default, but can be disabled with --quiet.</div>
<p class="Pp">--allow-unsafe-features</p>
<div class="Bd-indent">Many command-line options can be provided as part of the
  fast-import stream itself by using the <b>feature</b> or <b>option</b>
  commands. However, some of these options are unsafe (e.g., allowing
  fast-import to access the filesystem outside of the repository). These options
  are disabled by default, but can be allowed by providing this option on the
  command line. This currently impacts only the <b>export-marks</b>,
  <b>import-marks</b>, and <b>import-marks-if-exists</b> feature commands.
<p class="Pp"></p>
<div class="Bd-indent">
<pre>Only enable this option if you trust the program generating the
fast-import stream! This option is enabled automatically for
remote-helpers that use the `import` capability, as they are
already trusted to run their own code.</pre>
</div>
</div>
<section class="Ss">
<h2 class="Ss" id="Options_for_Frontends"><a class="permalink" href="#Options_for_Frontends">Options
  for Frontends</a></h2>
<p class="Pp">--cat-blob-fd=&lt;fd&gt;</p>
<div class="Bd-indent">Write responses to <b>get-mark</b>, <b>cat-blob</b>, and
  <b>ls</b> queries to the file descriptor &lt;fd&gt; instead of <b>stdout</b>.
  Allows <b>progress</b> output intended for the end-user to be separated from
  other output.</div>
<p class="Pp">--date-format=&lt;fmt&gt;</p>
<div class="Bd-indent">Specify the type of dates the frontend will supply to
  fast-import within <b>author</b>, <b>committer</b> and <b>tagger</b> commands.
  See &#x201C;Date Formats&#x201D; below for details about which formats are
  supported, and their syntax.</div>
<p class="Pp">--done</p>
<div class="Bd-indent">Terminate with error if there is no <b>done</b> command
  at the end of the stream. This option might be useful for detecting errors
  that cause the frontend to terminate before it has started to write a
  stream.</div>
</section>
<section class="Ss">
<h2 class="Ss" id="Locations_of_Marks_Files"><a class="permalink" href="#Locations_of_Marks_Files">Locations
  of Marks Files</a></h2>
<p class="Pp">--export-marks=&lt;file&gt;</p>
<div class="Bd-indent">Dumps the internal marks table to &lt;file&gt; when
  complete. Marks are written one per line as <b>:markid SHA-1</b>. Frontends
  can use this file to validate imports after they have been completed, or to
  save the marks table across incremental runs. As &lt;file&gt; is only opened
  and truncated at checkpoint (or completion) the same path can also be safely
  given to --import-marks.</div>
<p class="Pp">--import-marks=&lt;file&gt;</p>
<div class="Bd-indent">Before processing any input, load the marks specified in
  &lt;file&gt;. The input file must exist, must be readable, and must use the
  same format as produced by --export-marks. Multiple options may be supplied to
  import more than one set of marks. If a mark is defined to different values,
  the last file wins.</div>
<p class="Pp">--import-marks-if-exists=&lt;file&gt;</p>
<div class="Bd-indent">Like --import-marks but instead of erroring out, silently
  skips the file if it does not exist.</div>
<p class="Pp">--[no-]relative-marks</p>
<div class="Bd-indent">After specifying --relative-marks the paths specified
  with --import-marks= and --export-marks= are relative to an internal directory
  in the current repository. In git-fast-import this means that the paths are
  relative to the .git/info/fast-import directory. However, other importers may
  use a different location.
<p class="Pp">Relative and non-relative marks may be combined by interweaving
    --(no-)-relative-marks with the --(import|export)-marks= options.</p>
</div>
</section>
<section class="Ss">
<h2 class="Ss" id="Submodule_Rewriting"><a class="permalink" href="#Submodule_Rewriting">Submodule
  Rewriting</a></h2>
<p class="Pp">--rewrite-submodules-from=&lt;name&gt;:&lt;file&gt;,
    --rewrite-submodules-to=&lt;name&gt;:&lt;file&gt;</p>
<div class="Bd-indent">Rewrite the object IDs for the submodule specified by
  &lt;name&gt; from the values used in the from &lt;file&gt; to those used in
  the to &lt;file&gt;. The from marks should have been created by <b>git
  fast-export</b>, and the to marks should have been created by <b>git
  fast-import</b> when importing that same submodule.
<p class="Pp">&lt;name&gt; may be any arbitrary string not containing a colon
    character, but the same value must be used with both options when specifying
    corresponding marks. Multiple submodules may be specified with different
    values for &lt;name&gt;. It is an error not to use these options in
    corresponding pairs.</p>
<p class="Pp">These options are primarily useful when converting a repository
    from one hash algorithm to another; without them, fast-import will fail if
    it encounters a submodule because it has no way of writing the object ID
    into the new hash algorithm.</p>
</div>
</section>
<section class="Ss">
<h2 class="Ss" id="Performance_and_Compression_Tuning"><a class="permalink" href="#Performance_and_Compression_Tuning">Performance
  and Compression Tuning</a></h2>
<p class="Pp">--active-branches=&lt;n&gt;</p>
<div class="Bd-indent">Maximum number of branches to maintain active at once.
  See &#x201C;Memory Utilization&#x201D; below for details. Default is 5.</div>
<p class="Pp">--big-file-threshold=&lt;n&gt;</p>
<div class="Bd-indent">Maximum size of a blob that fast-import will attempt to
  create a delta for, expressed in bytes. The default is 512m (512 MiB). Some
  importers may wish to lower this on systems with constrained memory.</div>
<p class="Pp">--depth=&lt;n&gt;</p>
<div class="Bd-indent">Maximum delta depth, for blob and tree deltification.
  Default is 50.</div>
<p class="Pp">--export-pack-edges=&lt;file&gt;</p>
<div class="Bd-indent">After creating a packfile, print a line of data to
  &lt;file&gt; listing the filename of the packfile and the last commit on each
  branch that was written to that packfile. This information may be useful after
  importing projects whose total object set exceeds the 4 GiB packfile limit, as
  these commits can be used as edge points during calls to <i>git
  pack-objects</i>.</div>
<p class="Pp">--max-pack-size=&lt;n&gt;</p>
<div class="Bd-indent">Maximum size of each output packfile. The default is
  unlimited.</div>
<p class="Pp">fastimport.unpackLimit</p>
<div class="Bd-indent">See <b>git-config</b>(1)</div>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="PERFORMANCE"><a class="permalink" href="#PERFORMANCE">PERFORMANCE</a></h1>
<p class="Pp">The design of fast-import allows it to import large projects in a
    minimum amount of memory usage and processing time. Assuming the frontend is
    able to keep up with fast-import and feed it a constant stream of data,
    import times for projects holding 10+ years of history and containing
    100,000+ individual commits are generally completed in just 1-2 hours on
    quite modest (~$2,000 USD) hardware.</p>
<p class="Pp">Most bottlenecks appear to be in foreign source data access (the
    source just cannot extract revisions fast enough) or disk IO (fast-import
    writes as fast as the disk will take the data). Imports will run faster if
    the source data is stored on a different drive than the destination Git
    repository (due to less IO contention).</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DEVELOPMENT_COST"><a class="permalink" href="#DEVELOPMENT_COST">DEVELOPMENT
  COST</a></h1>
<p class="Pp">A typical frontend for fast-import tends to weigh in at
    approximately 200 lines of Perl/Python/Ruby code. Most developers have been
    able to create working importers in just a couple of hours, even though it
    is their first exposure to fast-import, and sometimes even to Git. This is
    an ideal situation, given that most conversion tools are throw-away (use
    once, and never look back).</p>
</section>
<section class="Sh">
<h1 class="Sh" id="PARALLEL_OPERATION"><a class="permalink" href="#PARALLEL_OPERATION">PARALLEL
  OPERATION</a></h1>
<p class="Pp">Like <i>git push</i> or <i>git fetch</i>, imports handled by
    fast-import are safe to run alongside parallel <b>git repack -a -d</b> or
    <b>git gc</b> invocations, or any other Git operation (including <i>git
    prune</i>, as loose objects are never used by fast-import).</p>
<p class="Pp">fast-import does not lock the branch or tag refs it is actively
    importing. After the import, during its ref update phase, fast-import tests
    each existing branch ref to verify the update will be a fast-forward update
    (the commit stored in the ref is contained in the new history of the commit
    to be written). If the update is not a fast-forward update, fast-import will
    skip updating that ref and instead prints a warning message. fast-import
    will always attempt to update all branch refs, and does not stop on the
    first failure.</p>
<p class="Pp">Branch updates can be forced with --force, but it&#x2019;s
    recommended that this only be used on an otherwise quiet repository. Using
    --force is not necessary for an initial import into an empty repository.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="TECHNICAL_DISCUSSION"><a class="permalink" href="#TECHNICAL_DISCUSSION">TECHNICAL
  DISCUSSION</a></h1>
<p class="Pp">fast-import tracks a set of branches in memory. Any branch can be
    created or modified at any point during the import process by sending a
    <b>commit</b> command on the input stream. This design allows a frontend
    program to process an unlimited number of branches simultaneously,
    generating commits in the order they are available from the source data. It
    also simplifies the frontend programs considerably.</p>
<p class="Pp">fast-import does not use or alter the current working directory,
    or any file within it. (It does however update the current Git repository,
    as referenced by <b>GIT_DIR</b>.) Therefore an import frontend may use the
    working directory for its own purposes, such as extracting file revisions
    from the foreign source. This ignorance of the working directory also allows
    fast-import to run very quickly, as it does not need to perform any costly
    file update operations when switching between branches.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="INPUT_FORMAT"><a class="permalink" href="#INPUT_FORMAT">INPUT
  FORMAT</a></h1>
<p class="Pp">With the exception of raw file data (which Git does not interpret)
    the fast-import input format is text (ASCII) based. This text based format
    simplifies development and debugging of frontend programs, especially when a
    higher level language such as Perl, Python or Ruby is being used.</p>
<p class="Pp">fast-import is very strict about its input. Where we say SP below
    we mean <b>exactly</b> one space. Likewise LF means one (and only one)
    linefeed and HT one (and only one) horizontal tab. Supplying additional
    whitespace characters will cause unexpected results, such as branch names or
    file names with leading or trailing spaces in their name, or early
    termination of fast-import when it encounters unexpected input.</p>
<section class="Ss">
<h2 class="Ss" id="Stream_Comments"><a class="permalink" href="#Stream_Comments">Stream
  Comments</a></h2>
<p class="Pp">To aid in debugging frontends fast-import ignores any line that
    begins with <b>#</b> (ASCII pound/hash) up to and including the line ending
    <b>LF</b>. A comment line may contain any sequence of bytes that does not
    contain an LF and therefore may be used to include any detailed debugging
    information that might be specific to the frontend and useful when
    inspecting a fast-import data stream.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Date_Formats"><a class="permalink" href="#Date_Formats">Date
  Formats</a></h2>
<p class="Pp">The following date formats are supported. A frontend should select
    the format it will use for this import by passing the format name in the
    --date-format=&lt;fmt&gt; command-line option.</p>
<p class="Pp"><b>raw</b></p>
<div class="Bd-indent">This is the Git native format and is <b>&lt;time&gt; SP
  &lt;offutc&gt;</b>. It is also fast-import&#x2019;s default format, if
  --date-format was not specified.
<p class="Pp">The time of the event is specified by <b>&lt;time&gt;</b> as the
    number of seconds since the UNIX epoch (midnight, Jan 1, 1970, UTC) and is
    written as an ASCII decimal integer.</p>
<p class="Pp">The local offset is specified by <b>&lt;offutc&gt;</b> as a
    positive or negative offset from UTC. For example EST (which is 5 hours
    behind UTC) would be expressed in <b>&lt;tz&gt;</b> by &#x201C;-0500&#x201D;
    while UTC is &#x201C;+0000&#x201D;. The local offset does not affect
    <b>&lt;time&gt;</b>; it is used only as an advisement to help formatting
    routines display the timestamp.</p>
<p class="Pp">If the local offset is not available in the source material, use
    &#x201C;+0000&#x201D;, or the most common local offset. For example many
    organizations have a CVS repository which has only ever been accessed by
    users who are located in the same location and time zone. In this case a
    reasonable offset from UTC could be assumed.</p>
<p class="Pp">Unlike the <b>rfc2822</b> format, this format is very strict. Any
    variation in formatting will cause fast-import to reject the value, and some
    sanity checks on the numeric values may also be performed.</p>
</div>
<p class="Pp"><b>raw-permissive</b></p>
<div class="Bd-indent">This is the same as <b>raw</b> except that no sanity
  checks on the numeric epoch and local offset are performed. This can be useful
  when trying to filter or import an existing history with e.g. bogus timezone
  values.</div>
<p class="Pp"><b>rfc2822</b></p>
<div class="Bd-indent">This is the standard email format as described by RFC
  2822.
<p class="Pp">An example value is &#x201C;Tue Feb 6 11:22:18 2007 -0500&#x201D;.
    The Git parser is accurate, but a little on the lenient side. It is the same
    parser used by <i>git am</i> when applying patches received from email.</p>
<p class="Pp">Some malformed strings may be accepted as valid dates. In some of
    these cases Git will still be able to obtain the correct date from the
    malformed string. There are also some types of malformed strings which Git
    will parse wrong, and yet consider valid. Seriously malformed strings will
    be rejected.</p>
<p class="Pp">Unlike the <b>raw</b> format above, the time zone/UTC offset
    information contained in an RFC 2822 date string is used to adjust the date
    value to UTC prior to storage. Therefore it is important that this
    information be as accurate as possible.</p>
<p class="Pp">If the source material uses RFC 2822 style dates, the frontend
    should let fast-import handle the parsing and conversion (rather than
    attempting to do it itself) as the Git parser has been well tested in the
    wild.</p>
<p class="Pp">Frontends should prefer the <b>raw</b> format if the source
    material already uses UNIX-epoch format, can be coaxed to give dates in that
    format, or its format is easily convertible to it, as there is no ambiguity
    in parsing.</p>
</div>
<p class="Pp"><b>now</b></p>
<div class="Bd-indent">Always use the current time and time zone. The literal
  <b>now</b> must always be supplied for <b>&lt;when&gt;</b>.
<p class="Pp">This is a toy format. The current time and time zone of this
    system is always copied into the identity string at the time it is being
    created by fast-import. There is no way to specify a different time or time
    zone.</p>
<p class="Pp">This particular format is supplied as it&#x2019;s short to
    implement and may be useful to a process that wants to create a new commit
    right now, without needing to use a working directory or <i>git
    update-index</i>.</p>
<p class="Pp">If separate <b>author</b> and <b>committer</b> commands are used
    in a <b>commit</b> the timestamps may not match, as the system clock will be
    polled twice (once for each command). The only way to ensure that both
    author and committer identity information has the same timestamp is to omit
    <b>author</b> (thus copying from <b>committer</b>) or to use a date format
    other than <b>now</b>.</p>
</div>
</section>
<section class="Ss">
<h2 class="Ss" id="Commands"><a class="permalink" href="#Commands">Commands</a></h2>
<p class="Pp">fast-import accepts several commands to update the current
    repository and control the current import process. More detailed discussion
    (with examples) of each command follows later.</p>
<p class="Pp"><b>commit</b></p>
<div class="Bd-indent">Creates a new branch or updates an existing branch by
  creating a new commit and updating the branch to point at the newly created
  commit.</div>
<p class="Pp"><b>tag</b></p>
<div class="Bd-indent">Creates an annotated tag object from an existing commit
  or branch. Lightweight tags are not supported by this command, as they are not
  recommended for recording meaningful points in time.</div>
<p class="Pp"><b>reset</b></p>
<div class="Bd-indent">Reset an existing branch (or a new branch) to a specific
  revision. This command must be used to change a branch to a specific revision
  without making a commit on it.</div>
<p class="Pp"><b>blob</b></p>
<div class="Bd-indent">Convert raw file data into a blob, for future use in a
  <b>commit</b> command. This command is optional and is not needed to perform
  an import.</div>
<p class="Pp"><b>alias</b></p>
<div class="Bd-indent">Record that a mark refers to a given object without first
  creating any new object. Using --import-marks and referring to missing marks
  will cause fast-import to fail, so aliases can provide a way to set otherwise
  pruned commits to a valid value (e.g. the nearest non-pruned ancestor).</div>
<p class="Pp"><b>checkpoint</b></p>
<div class="Bd-indent">Forces fast-import to close the current packfile,
  generate its unique SHA-1 checksum and index, and start a new packfile. This
  command is optional and is not needed to perform an import.</div>
<p class="Pp"><b>progress</b></p>
<div class="Bd-indent">Causes fast-import to echo the entire line to its own
  standard output. This command is optional and is not needed to perform an
  import.</div>
<p class="Pp"><b>done</b></p>
<div class="Bd-indent">Marks the end of the stream. This command is optional
  unless the <b>done</b> feature was requested using the <b>--done</b>
  command-line option or <b>feature done</b> command.</div>
<p class="Pp"><b>get-mark</b></p>
<div class="Bd-indent">Causes fast-import to print the SHA-1 corresponding to a
  mark to the file descriptor set with <b>--cat-blob-fd</b>, or <b>stdout</b> if
  unspecified.</div>
<p class="Pp"><b>cat-blob</b></p>
<div class="Bd-indent">Causes fast-import to print a blob in <i>cat-file
  --batch</i> format to the file descriptor set with <b>--cat-blob-fd</b> or
  <b>stdout</b> if unspecified.</div>
<p class="Pp"><b>ls</b></p>
<div class="Bd-indent">Causes fast-import to print a line describing a directory
  entry in <i>ls-tree</i> format to the file descriptor set with
  <b>--cat-blob-fd</b> or <b>stdout</b> if unspecified.</div>
<p class="Pp"><b>feature</b></p>
<div class="Bd-indent">Enable the specified feature. This requires that
  fast-import supports the specified feature, and aborts if it does not.</div>
<p class="Pp"><b>option</b></p>
<div class="Bd-indent">Specify any of the options listed under OPTIONS that do
  not change stream semantic to suit the frontend&#x2019;s needs. This command
  is optional and is not needed to perform an import.</div>
</section>
<section class="Ss">
<h2 class="Ss"><b>commit</b></h2>
<p class="Pp">Create or update a branch with a new commit, recording one logical
    change to the project.</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
<br/>
        'commit' SP &lt;ref&gt; LF
<br/>
        mark?
<br/>
        original-oid?
<br/>
        ('author' (SP &lt;name&gt;)? SP LT &lt;email&gt; GT SP &lt;when&gt; LF)?
<br/>
        'committer' (SP &lt;name&gt;)? SP LT &lt;email&gt; GT SP &lt;when&gt; LF
<br/>
        ('encoding' SP &lt;encoding&gt;)?
<br/>
        data
<br/>
        ('from' SP &lt;commit-ish&gt; LF)?
<br/>
        ('merge' SP &lt;commit-ish&gt; LF)*
<br/>
        (filemodify | filedelete | filecopy | filerename | filedeleteall | notemodify)*
<br/>
        LF?</pre>
</div>
<p class="Pp">where <b>&lt;ref&gt;</b> is the name of the branch to make the
    commit on. Typically branch names are prefixed with <b>refs/heads/</b> in
    Git, so importing the CVS branch symbol <b>RELENG-1_0</b> would use
    <b>refs/heads/RELENG-1_0</b> for the value of <b>&lt;ref&gt;</b>. The value
    of <b>&lt;ref&gt;</b> must be a valid refname in Git. As <b>LF</b> is not
    valid in a Git refname, no quoting or escaping syntax is supported here.</p>
<p class="Pp">A <b>mark</b> command may optionally appear, requesting
    fast-import to save a reference to the newly created commit for future use
    by the frontend (see below for format). It is very common for frontends to
    mark every commit they create, thereby allowing future branch creation from
    any imported commit.</p>
<p class="Pp">The <b>data</b> command following <b>committer</b> must supply the
    commit message (see below for <b>data</b> command syntax). To import an
    empty commit message use a 0 length data. Commit messages are free-form and
    are not interpreted by Git. Currently they must be encoded in UTF-8, as
    fast-import does not permit other encodings to be specified.</p>
<p class="Pp">Zero or more <b>filemodify</b>, <b>filedelete</b>,
    <b>filecopy</b>, <b>filerename</b>, <b>filedeleteall</b> and
    <b>notemodify</b> commands may be included to update the contents of the
    branch prior to creating the commit. These commands may be supplied in any
    order. However it is recommended that a <b>filedeleteall</b> command precede
    all <b>filemodify</b>, <b>filecopy</b>, <b>filerename</b> and
    <b>notemodify</b> commands in the same commit, as <b>filedeleteall</b> wipes
    the branch clean (see below).</p>
<p class="Pp">The <b>LF</b> after the command is optional (it used to be
    required). Note that for reasons of backward compatibility, if the commit
    ends with a <b>data</b> command (i.e. it has no <b>from</b>, <b>merge</b>,
    <b>filemodify</b>, <b>filedelete</b>, <b>filecopy</b>, <b>filerename</b>,
    <b>filedeleteall</b> or <b>notemodify</b> commands) then two <b>LF</b>
    commands may appear at the end of the command instead of just one.</p>
<p class="Pp"><b>author</b>
  <br/>
</p>
<div class="Bd-indent">
<p class="Pp">An <b>author</b> command may optionally appear, if the author
    information might differ from the committer information. If <b>author</b> is
    omitted then fast-import will automatically use the committer&#x2019;s
    information for the author portion of the commit. See below for a
    description of the fields in <b>author</b>, as they are identical to
    <b>committer</b>.</p>
</div>
<p class="Pp"><b>committer</b>
  <br/>
</p>
<div class="Bd-indent">
<p class="Pp">The <b>committer</b> command indicates who made this commit, and
    when they made it.</p>
<p class="Pp">Here <b>&lt;name&gt;</b> is the person&#x2019;s display name (for
    example &#x201C;Com M Itter&#x201D;) and <b>&lt;email&gt;</b> is the
    person&#x2019;s email address (&#x201C;cm@example.com&#x201D;). <b>LT</b>
    and <b>GT</b> are the literal less-than (\x3c) and greater-than (\x3e)
    symbols. These are required to delimit the email address from the other
    fields in the line. Note that <b>&lt;name&gt;</b> and <b>&lt;email&gt;</b>
    are free-form and may contain any sequence of bytes, except <b>LT</b>,
    <b>GT</b> and <b>LF</b>. <b>&lt;name&gt;</b> is typically UTF-8 encoded.</p>
<p class="Pp">The time of the change is specified by <b>&lt;when&gt;</b> using
    the date format that was selected by the --date-format=&lt;fmt&gt;
    command-line option. See &#x201C;Date Formats&#x201D; above for the set of
    supported formats, and their syntax.</p>
</div>
<p class="Pp"><b>encoding</b>
  <br/>
</p>
<div class="Bd-indent">
<p class="Pp">The optional <b>encoding</b> command indicates the encoding of the
    commit message. Most commits are UTF-8 and the encoding is omitted, but this
    allows importing commit messages into git without first reencoding them.</p>
</div>
<p class="Pp"><b>from</b>
  <br/>
</p>
<div class="Bd-indent">
<p class="Pp">The <b>from</b> command is used to specify the commit to
    initialize this branch from. This revision will be the first ancestor of the
    new commit. The state of the tree built at this commit will begin with the
    state at the <b>from</b> commit, and be altered by the content modifications
    in this commit.</p>
<p class="Pp">Omitting the <b>from</b> command in the first commit of a new
    branch will cause fast-import to create that commit with no ancestor. This
    tends to be desired only for the initial commit of a project. If the
    frontend creates all files from scratch when making a new branch, a
    <b>merge</b> command may be used instead of <b>from</b> to start the commit
    with an empty tree. Omitting the <b>from</b> command on existing branches is
    usually desired, as the current commit on that branch is automatically
    assumed to be the first ancestor of the new commit.</p>
<p class="Pp">As <b>LF</b> is not valid in a Git refname or SHA-1 expression, no
    quoting or escaping syntax is supported within
  <b>&lt;commit-ish&gt;</b>.</p>
<p class="Pp">Here <b>&lt;commit-ish&gt;</b> is any of the following:</p>
<p class="Pp"></p>
<div class="Bd-indent">&#x2022;The name of an existing branch already in
  fast-import&#x2019;s internal branch table. If fast-import doesn&#x2019;t know
  the name, it&#x2019;s treated as a SHA-1 expression.</div>
<p class="Pp"></p>
<div class="Bd-indent">&#x2022;A mark reference, <b>:&lt;idnum&gt;</b>, where
  <b>&lt;idnum&gt;</b> is the mark number.
<p class="Pp">The reason fast-import uses <b>:</b> to denote a mark reference is
    this character is not legal in a Git branch name. The leading <b>:</b> makes
    it easy to distinguish between the mark 42 (<b>:42</b>) and the branch 42
    (<b>42</b> or <b>refs/heads/42</b>), or an abbreviated SHA-1 which happened
    to consist only of base-10 digits.</p>
<p class="Pp">Marks must be declared (via <b>mark</b>) before they can be
  used.</p>
</div>
<p class="Pp"></p>
<div class="Bd-indent">&#x2022;A complete 40 byte or abbreviated commit SHA-1 in
  hex.</div>
<p class="Pp"></p>
<div class="Bd-indent">&#x2022;Any valid Git SHA-1 expression that resolves to a
  commit. See &#x201C;SPECIFYING REVISIONS&#x201D; in <b>gitrevisions</b>(7) for
  details.</div>
<p class="Pp"></p>
<div class="Bd-indent">&#x2022;The special null SHA-1 (40 zeros) specifies that
  the branch is to be removed.</div>
<p class="Pp">The special case of restarting an incremental import from the
    current branch value should be written as:</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
<br/>
        from refs/heads/branch^0</pre>
</div>
<p class="Pp"></p>
<p class="Pp">The <b>^0</b> suffix is necessary as fast-import does not permit a
    branch to start from itself, and the branch is created in memory before the
    <b>from</b> command is even read from the input. Adding <b>^0</b> will force
    fast-import to resolve the commit through Git&#x2019;s revision parsing
    library, rather than its internal branch table, thereby loading in the
    existing value of the branch.</p>
</div>
<p class="Pp"><b>merge</b>
  <br/>
</p>
<div class="Bd-indent">
<p class="Pp">Includes one additional ancestor commit. The additional ancestry
    link does not change the way the tree state is built at this commit. If the
    <b>from</b> command is omitted when creating a new branch, the first
    <b>merge</b> commit will be the first ancestor of the current commit, and
    the branch will start out with no files. An unlimited number of <b>merge</b>
    commands per commit are permitted by fast-import, thereby establishing an
    n-way merge.</p>
<p class="Pp">Here <b>&lt;commit-ish&gt;</b> is any of the commit specification
    expressions also accepted by <b>from</b> (see above).</p>
</div>
<p class="Pp"><b>filemodify</b>
  <br/>
</p>
<div class="Bd-indent">
<p class="Pp">Included in a <b>commit</b> command to add a new file or change
    the content of an existing file. This command has two different means of
    specifying the content of the file.</p>
<p class="Pp">External data format</p>
<div class="Bd-indent">The data content for the file was already supplied by a
  prior <b>blob</b> command. The frontend just needs to connect it.
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
<br/>
        'M' SP &lt;mode&gt; SP &lt;dataref&gt; SP &lt;path&gt; LF</pre>
</div>
<p class="Pp">Here usually <b>&lt;dataref&gt;</b> must be either a mark
    reference (<b>:&lt;idnum&gt;</b>) set by a prior <b>blob</b> command, or a
    full 40-byte SHA-1 of an existing Git blob object. If <b>&lt;mode&gt;</b> is
    <b>040000`</b> then <b>&lt;dataref&gt;</b> must be the full 40-byte SHA-1 of
    an existing Git tree object or a mark reference set with
    <b>--import-marks</b>.</p>
</div>
<p class="Pp">Inline data format</p>
<div class="Bd-indent">The data content for the file has not been supplied yet.
  The frontend wants to supply it as part of this modify command.
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
<br/>
        'M' SP &lt;mode&gt; SP 'inline' SP &lt;path&gt; LF
<br/>
        data</pre>
</div>
<p class="Pp">See below for a detailed description of the <b>data</b>
  command.</p>
</div>
<p class="Pp">In both formats <b>&lt;mode&gt;</b> is the type of file entry,
    specified in octal. Git only supports the following modes:</p>
<p class="Pp"></p>
<div class="Bd-indent">&#x2022;<b>100644</b> or <b>644</b>: A normal
  (not-executable) file. The majority of files in most projects use this mode.
  If in doubt, this is what you want.</div>
<p class="Pp"></p>
<div class="Bd-indent">&#x2022;<b>100755</b> or <b>755</b>: A normal, but
  executable, file.</div>
<p class="Pp"></p>
<div class="Bd-indent">&#x2022;<b>120000</b>: A symlink, the content of the file
  will be the link target.</div>
<p class="Pp"></p>
<div class="Bd-indent">&#x2022;<b>160000</b>: A gitlink, SHA-1 of the object
  refers to a commit in another repository. Git links can only be specified by
  SHA or through a commit mark. They are used to implement submodules.</div>
<p class="Pp"></p>
<div class="Bd-indent">&#x2022;<b>040000</b>: A subdirectory. Subdirectories can
  only be specified by SHA or through a tree mark set with
  <b>--import-marks</b>.</div>
<p class="Pp">In both formats <b>&lt;path&gt;</b> is the complete path of the
    file to be added (if not already existing) or modified (if already
    existing).</p>
<p class="Pp">A <b>&lt;path&gt;</b> string must use UNIX-style directory
    separators (forward slash <b>/</b>), may contain any byte other than
    <b>LF</b>, and must not start with double quote (<b>&quot;</b>).</p>
<p class="Pp">A path can use C-style string quoting; this is accepted in all
    cases and mandatory if the filename starts with double quote or contains
    <b>LF</b>. In C-style quoting, the complete name should be surrounded with
    double quotes, and any <b>LF</b>, backslash, or double quote characters must
    be escaped by preceding them with a backslash (e.g., <b>&quot;path/with\n,
    \\ and \&quot; in it&quot;</b>).</p>
<p class="Pp">The value of <b>&lt;path&gt;</b> must be in canonical form. That
    is it must not:</p>
<p class="Pp"></p>
<div class="Bd-indent">&#x2022;contain an empty directory component (e.g.
  <b>foo//bar</b> is invalid),</div>
<p class="Pp"></p>
<div class="Bd-indent">&#x2022;end with a directory separator (e.g. <b>foo/</b>
  is invalid),</div>
<p class="Pp"></p>
<div class="Bd-indent">&#x2022;start with a directory separator (e.g.
  <b>/foo</b> is invalid),</div>
<p class="Pp"></p>
<div class="Bd-indent">&#x2022;contain the special component <b>.</b> or
  <b>..</b> (e.g. <b>foo/./bar</b> and <b>foo/../bar</b> are invalid).</div>
<p class="Pp">The root of the tree can be represented by an empty string as
    <b>&lt;path&gt;</b>.</p>
<p class="Pp">It is recommended that <b>&lt;path&gt;</b> always be encoded using
    UTF-8.</p>
</div>
<p class="Pp"><b>filedelete</b>
  <br/>
</p>
<div class="Bd-indent">
<p class="Pp">Included in a <b>commit</b> command to remove a file or
    recursively delete an entire directory from the branch. If the file or
    directory removal makes its parent directory empty, the parent directory
    will be automatically removed too. This cascades up the tree until the first
    non-empty directory or the root is reached.</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
<br/>
        'D' SP &lt;path&gt; LF</pre>
</div>
<p class="Pp">here <b>&lt;path&gt;</b> is the complete path of the file or
    subdirectory to be removed from the branch. See <b>filemodify</b> above for
    a detailed description of <b>&lt;path&gt;</b>.</p>
</div>
<p class="Pp"><b>filecopy</b>
  <br/>
</p>
<div class="Bd-indent">
<p class="Pp">Recursively copies an existing file or subdirectory to a different
    location within the branch. The existing file or directory must exist. If
    the destination exists it will be completely replaced by the content copied
    from the source.</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
<br/>
        'C' SP &lt;path&gt; SP &lt;path&gt; LF</pre>
</div>
<p class="Pp">here the first <b>&lt;path&gt;</b> is the source location and the
    second <b>&lt;path&gt;</b> is the destination. See <b>filemodify</b> above
    for a detailed description of what <b>&lt;path&gt;</b> may look like. To use
    a source path that contains SP the path must be quoted.</p>
<p class="Pp">A <b>filecopy</b> command takes effect immediately. Once the
    source location has been copied to the destination any future commands
    applied to the source location will not impact the destination of the
  copy.</p>
</div>
<p class="Pp"><b>filerename</b>
  <br/>
</p>
<div class="Bd-indent">
<p class="Pp">Renames an existing file or subdirectory to a different location
    within the branch. The existing file or directory must exist. If the
    destination exists it will be replaced by the source directory.</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
<br/>
        'R' SP &lt;path&gt; SP &lt;path&gt; LF</pre>
</div>
<p class="Pp">here the first <b>&lt;path&gt;</b> is the source location and the
    second <b>&lt;path&gt;</b> is the destination. See <b>filemodify</b> above
    for a detailed description of what <b>&lt;path&gt;</b> may look like. To use
    a source path that contains SP the path must be quoted.</p>
<p class="Pp">A <b>filerename</b> command takes effect immediately. Once the
    source location has been renamed to the destination any future commands
    applied to the source location will create new files there and not impact
    the destination of the rename.</p>
<p class="Pp">Note that a <b>filerename</b> is the same as a <b>filecopy</b>
    followed by a <b>filedelete</b> of the source location. There is a slight
    performance advantage to using <b>filerename</b>, but the advantage is so
    small that it is never worth trying to convert a delete/add pair in source
    material into a rename for fast-import. This <b>filerename</b> command is
    provided just to simplify frontends that already have rename information and
    don&#x2019;t want bother with decomposing it into a <b>filecopy</b> followed
    by a <b>filedelete</b>.</p>
</div>
<p class="Pp"><b>filedeleteall</b>
  <br/>
</p>
<div class="Bd-indent">
<p class="Pp">Included in a <b>commit</b> command to remove all files (and also
    all directories) from the branch. This command resets the internal branch
    structure to have no files in it, allowing the frontend to subsequently add
    all interesting files from scratch.</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
<br/>
        'deleteall' LF</pre>
</div>
<p class="Pp">This command is extremely useful if the frontend does not know (or
    does not care to know) what files are currently on the branch, and therefore
    cannot generate the proper <b>filedelete</b> commands to update the
  content.</p>
<p class="Pp">Issuing a <b>filedeleteall</b> followed by the needed
    <b>filemodify</b> commands to set the correct content will produce the same
    results as sending only the needed <b>filemodify</b> and <b>filedelete</b>
    commands. The <b>filedeleteall</b> approach may however require fast-import
    to use slightly more memory per active branch (less than 1 MiB for even most
    large projects); so frontends that can easily obtain only the affected paths
    for a commit are encouraged to do so.</p>
</div>
<p class="Pp"><b>notemodify</b>
  <br/>
</p>
<div class="Bd-indent">
<p class="Pp">Included in a <b>commit</b> <b>&lt;notes_ref&gt;</b> command to
    add a new note annotating a <b>&lt;commit-ish&gt;</b> or change this
    annotation contents. Internally it is similar to filemodify 100644 on
    <b>&lt;commit-ish&gt;</b> path (maybe split into subdirectories).
    It&#x2019;s not advised to use any other commands to write to the
    <b>&lt;notes_ref&gt;</b> tree except <b>filedeleteall</b> to delete all
    existing notes in this tree. This command has two different means of
    specifying the content of the note.</p>
<p class="Pp">External data format</p>
<div class="Bd-indent">The data content for the note was already supplied by a
  prior <b>blob</b> command. The frontend just needs to connect it to the commit
  that is to be annotated.
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
<br/>
        'N' SP &lt;dataref&gt; SP &lt;commit-ish&gt; LF</pre>
</div>
<p class="Pp">Here <b>&lt;dataref&gt;</b> can be either a mark reference
    (<b>:&lt;idnum&gt;</b>) set by a prior <b>blob</b> command, or a full
    40-byte SHA-1 of an existing Git blob object.</p>
</div>
<p class="Pp">Inline data format</p>
<div class="Bd-indent">The data content for the note has not been supplied yet.
  The frontend wants to supply it as part of this modify command.
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
<br/>
        'N' SP 'inline' SP &lt;commit-ish&gt; LF
<br/>
        data</pre>
</div>
<p class="Pp">See below for a detailed description of the <b>data</b>
  command.</p>
</div>
<p class="Pp">In both formats <b>&lt;commit-ish&gt;</b> is any of the commit
    specification expressions also accepted by <b>from</b> (see above).</p>
</div>
</section>
<section class="Ss">
<h2 class="Ss"><b>mark</b></h2>
<p class="Pp">Arranges for fast-import to save a reference to the current
    object, allowing the frontend to recall this object at a future point in
    time, without knowing its SHA-1. Here the current object is the object
    creation command the <b>mark</b> command appears within. This can be
    <b>commit</b>, <b>tag</b>, and <b>blob</b>, but <b>commit</b> is the most
    common usage.</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
<br/>
        'mark' SP ':' &lt;idnum&gt; LF</pre>
</div>
<p class="Pp">where <b>&lt;idnum&gt;</b> is the number assigned by the frontend
    to this mark. The value of <b>&lt;idnum&gt;</b> is expressed as an ASCII
    decimal integer. The value 0 is reserved and cannot be used as a mark. Only
    values greater than or equal to 1 may be used as marks.</p>
<p class="Pp">New marks are created automatically. Existing marks can be moved
    to another object simply by reusing the same <b>&lt;idnum&gt;</b> in another
    <b>mark</b> command.</p>
</section>
<section class="Ss">
<h2 class="Ss"><b>original-oid</b></h2>
<p class="Pp">Provides the name of the object in the original source control
    system. fast-import will simply ignore this directive, but filter processes
    which operate on and modify the stream before feeding to fast-import may
    have uses for this information</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
<br/>
        'original-oid' SP &lt;object-identifier&gt; LF</pre>
</div>
<p class="Pp">where <b>&lt;object-identifier&gt;</b> is any string not
    containing LF.</p>
</section>
<section class="Ss">
<h2 class="Ss"><b>tag</b></h2>
<p class="Pp">Creates an annotated tag referring to a specific commit. To create
    lightweight (non-annotated) tags see the <b>reset</b> command below.</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
<br/>
        'tag' SP &lt;name&gt; LF
<br/>
        mark?
<br/>
        'from' SP &lt;commit-ish&gt; LF
<br/>
        original-oid?
<br/>
        'tagger' (SP &lt;name&gt;)? SP LT &lt;email&gt; GT SP &lt;when&gt; LF
<br/>
        data</pre>
</div>
<p class="Pp">where <b>&lt;name&gt;</b> is the name of the tag to create.</p>
<p class="Pp">Tag names are automatically prefixed with <b>refs/tags/</b> when
    stored in Git, so importing the CVS branch symbol <b>RELENG-1_0-FINAL</b>
    would use just <b>RELENG-1_0-FINAL</b> for <b>&lt;name&gt;</b>, and
    fast-import will write the corresponding ref as
    <b>refs/tags/RELENG-1_0-FINAL</b>.</p>
<p class="Pp">The value of <b>&lt;name&gt;</b> must be a valid refname in Git
    and therefore may contain forward slashes. As <b>LF</b> is not valid in a
    Git refname, no quoting or escaping syntax is supported here.</p>
<p class="Pp">The <b>from</b> command is the same as in the <b>commit</b>
    command; see above for details.</p>
<p class="Pp">The <b>tagger</b> command uses the same format as <b>committer</b>
    within <b>commit</b>; again see above for details.</p>
<p class="Pp">The <b>data</b> command following <b>tagger</b> must supply the
    annotated tag message (see below for <b>data</b> command syntax). To import
    an empty tag message use a 0 length data. Tag messages are free-form and are
    not interpreted by Git. Currently they must be encoded in UTF-8, as
    fast-import does not permit other encodings to be specified.</p>
<p class="Pp">Signing annotated tags during import from within fast-import is
    not supported. Trying to include your own PGP/GPG signature is not
    recommended, as the frontend does not (easily) have access to the complete
    set of bytes which normally goes into such a signature. If signing is
    required, create lightweight tags from within fast-import with <b>reset</b>,
    then create the annotated versions of those tags offline with the standard
    <i>git tag</i> process.</p>
</section>
<section class="Ss">
<h2 class="Ss"><b>reset</b></h2>
<p class="Pp">Creates (or recreates) the named branch, optionally starting from
    a specific revision. The reset command allows a frontend to issue a new
    <b>from</b> command for an existing branch, or to create a new branch from
    an existing commit without creating a new commit.</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
<br/>
        'reset' SP &lt;ref&gt; LF
<br/>
        ('from' SP &lt;commit-ish&gt; LF)?
<br/>
        LF?</pre>
</div>
<p class="Pp">For a detailed description of <b>&lt;ref&gt;</b> and
    <b>&lt;commit-ish&gt;</b> see above under <b>commit</b> and <b>from</b>.</p>
<p class="Pp">The <b>LF</b> after the command is optional (it used to be
    required).</p>
<p class="Pp">The <b>reset</b> command can also be used to create lightweight
    (non-annotated) tags. For example:</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>reset refs/tags/938
from :938</pre>
</div>
<p class="Pp">would create the lightweight tag <b>refs/tags/938</b> referring to
    whatever commit mark <b>:938</b> references.</p>
</section>
<section class="Ss">
<h2 class="Ss"><b>blob</b></h2>
<p class="Pp">Requests writing one file revision to the packfile. The revision
    is not connected to any commit; this connection must be formed in a
    subsequent <b>commit</b> command by referencing the blob through an assigned
    mark.</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
<br/>
        'blob' LF
<br/>
        mark?
<br/>
        original-oid?
<br/>
        data</pre>
</div>
<p class="Pp">The mark command is optional here as some frontends have chosen to
    generate the Git SHA-1 for the blob on their own, and feed that directly to
    <b>commit</b>. This is typically more work than it&#x2019;s worth however,
    as marks are inexpensive to store and easy to use.</p>
</section>
<section class="Ss">
<h2 class="Ss"><b>data</b></h2>
<p class="Pp">Supplies raw data (for use as blob/file content, commit messages,
    or annotated tag messages) to fast-import. Data can be supplied using an
    exact byte count or delimited with a terminating line. Real frontends
    intended for production-quality conversions should always use the exact byte
    count format, as it is more robust and performs better. The delimited format
    is intended primarily for testing fast-import.</p>
<p class="Pp">Comment lines appearing within the <b>&lt;raw&gt;</b> part of
    <b>data</b> commands are always taken to be part of the body of the data and
    are therefore never ignored by fast-import. This makes it safe to import any
    file/message content whose lines might start with <b>#</b>.</p>
<p class="Pp">Exact byte count format</p>
<div class="Bd-indent">The frontend must specify the number of bytes of data.
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
<br/>
        'data' SP &lt;count&gt; LF
<br/>
        &lt;raw&gt; LF?</pre>
</div>
<p class="Pp">where <b>&lt;count&gt;</b> is the exact number of bytes appearing
    within <b>&lt;raw&gt;</b>. The value of <b>&lt;count&gt;</b> is expressed as
    an ASCII decimal integer. The <b>LF</b> on either side of <b>&lt;raw&gt;</b>
    is not included in <b>&lt;count&gt;</b> and will not be included in the
    imported data.</p>
<p class="Pp">The <b>LF</b> after <b>&lt;raw&gt;</b> is optional (it used to be
    required) but recommended. Always including it makes debugging a fast-import
    stream easier as the next command always starts in column 0 of the next
    line, even if <b>&lt;raw&gt;</b> did not end with an <b>LF</b>.</p>
</div>
<p class="Pp">Delimited format</p>
<div class="Bd-indent">A delimiter string is used to mark the end of the data.
  fast-import will compute the length by searching for the delimiter. This
  format is primarily useful for testing and is not recommended for real data.
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
<br/>
        'data' SP '&lt;&lt;' &lt;delim&gt; LF
<br/>
        &lt;raw&gt; LF
<br/>
        &lt;delim&gt; LF
<br/>
        LF?</pre>
</div>
<p class="Pp">where <b>&lt;delim&gt;</b> is the chosen delimiter string. The
    string <b>&lt;delim&gt;</b> must not appear on a line by itself within
    <b>&lt;raw&gt;</b>, as otherwise fast-import will think the data ends
    earlier than it really does. The <b>LF</b> immediately trailing
    <b>&lt;raw&gt;</b> is part of <b>&lt;raw&gt;</b>. This is one of the
    limitations of the delimited format, it is impossible to supply a data chunk
    which does not have an LF as its last byte.</p>
<p class="Pp">The <b>LF</b> after <b>&lt;delim&gt; LF</b> is optional (it used
    to be required).</p>
</div>
</section>
<section class="Ss">
<h2 class="Ss"><b>alias</b></h2>
<p class="Pp">Record that a mark refers to a given object without first creating
    any new object.</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
<br/>
        'alias' LF
<br/>
        mark
<br/>
        'to' SP &lt;commit-ish&gt; LF
<br/>
        LF?</pre>
</div>
<p class="Pp">For a detailed description of <b>&lt;commit-ish&gt;</b> see above
    under <b>from</b>.</p>
</section>
<section class="Ss">
<h2 class="Ss"><b>checkpoint</b></h2>
<p class="Pp">Forces fast-import to close the current packfile, start a new one,
    and to save out all current branch refs, tags and marks.</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
<br/>
        'checkpoint' LF
<br/>
        LF?</pre>
</div>
<p class="Pp">Note that fast-import automatically switches packfiles when the
    current packfile reaches --max-pack-size, or 4 GiB, whichever limit is
    smaller. During an automatic packfile switch fast-import does not update the
    branch refs, tags or marks.</p>
<p class="Pp">As a <b>checkpoint</b> can require a significant amount of CPU
    time and disk IO (to compute the overall pack SHA-1 checksum, generate the
    corresponding index file, and update the refs) it can easily take several
    minutes for a single <b>checkpoint</b> command to complete.</p>
<p class="Pp">Frontends may choose to issue checkpoints during extremely large
    and long running imports, or when they need to allow another Git process
    access to a branch. However given that a 30 GiB Subversion repository can be
    loaded into Git through fast-import in about 3 hours, explicit checkpointing
    may not be necessary.</p>
<p class="Pp">The <b>LF</b> after the command is optional (it used to be
    required).</p>
</section>
<section class="Ss">
<h2 class="Ss"><b>progress</b></h2>
<p class="Pp">Causes fast-import to print the entire <b>progress</b> line
    unmodified to its standard output channel (file descriptor 1) when the
    command is processed from the input stream. The command otherwise has no
    impact on the current import, or on any of fast-import&#x2019;s internal
    state.</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
<br/>
        'progress' SP &lt;any&gt; LF
<br/>
        LF?</pre>
</div>
<p class="Pp">The <b>&lt;any&gt;</b> part of the command may contain any
    sequence of bytes that does not contain <b>LF</b>. The <b>LF</b> after the
    command is optional. Callers may wish to process the output through a tool
    such as sed to remove the leading part of the line, for example:</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>frontend | git fast-import | sed 's/^progress //'</pre>
</div>
<p class="Pp">Placing a <b>progress</b> command immediately after a
    <b>checkpoint</b> will inform the reader when the <b>checkpoint</b> has been
    completed and it can safely access the refs that fast-import updated.</p>
</section>
<section class="Ss">
<h2 class="Ss"><b>get-mark</b></h2>
<p class="Pp">Causes fast-import to print the SHA-1 corresponding to a mark to
    stdout or to the file descriptor previously arranged with the
    <b>--cat-blob-fd</b> argument. The command otherwise has no impact on the
    current import; its purpose is to retrieve SHA-1s that later commits might
    want to refer to in their commit messages.</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
<br/>
        'get-mark' SP ':' &lt;idnum&gt; LF</pre>
</div>
<p class="Pp">See &#x201C;Responses To Commands&#x201D; below for details about
    how to read this output safely.</p>
</section>
<section class="Ss">
<h2 class="Ss"><b>cat-blob</b></h2>
<p class="Pp">Causes fast-import to print a blob to a file descriptor previously
    arranged with the <b>--cat-blob-fd</b> argument. The command otherwise has
    no impact on the current import; its main purpose is to retrieve blobs that
    may be in fast-import&#x2019;s memory but not accessible from the target
    repository.</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
<br/>
        'cat-blob' SP &lt;dataref&gt; LF</pre>
</div>
<p class="Pp">The <b>&lt;dataref&gt;</b> can be either a mark reference
    (<b>:&lt;idnum&gt;</b>) set previously or a full 40-byte SHA-1 of a Git
    blob, preexisting or ready to be written.</p>
<p class="Pp">Output uses the same format as <b>git cat-file --batch</b>:</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>&lt;sha1&gt; SP 'blob' SP &lt;size&gt; LF
&lt;contents&gt; LF</pre>
</div>
<p class="Pp">This command can be used where a <b>filemodify</b> directive can
    appear, allowing it to be used in the middle of a commit. For a
    <b>filemodify</b> using an inline directive, it can also appear right before
    the <b>data</b> directive.</p>
<p class="Pp">See &#x201C;Responses To Commands&#x201D; below for details about
    how to read this output safely.</p>
</section>
<section class="Ss">
<h2 class="Ss"><b>ls</b></h2>
<p class="Pp">Prints information about the object at a path to a file descriptor
    previously arranged with the <b>--cat-blob-fd</b> argument. This allows
    printing a blob from the active commit (with <b>cat-blob</b>) or copying a
    blob or tree from a previous commit for use in the current one (with
    <b>filemodify</b>).</p>
<p class="Pp">The <b>ls</b> command can also be used where a <b>filemodify</b>
    directive can appear, allowing it to be used in the middle of a commit.</p>
<p class="Pp">Reading from the active commit</p>
<div class="Bd-indent">This form can only be used in the middle of a
  <b>commit</b>. The path names a directory entry within fast-import&#x2019;s
  active commit. The path must be quoted in this case.
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
<br/>
        'ls' SP &lt;path&gt; LF</pre>
</div>
</div>
<p class="Pp">Reading from a named tree</p>
<div class="Bd-indent">The <b>&lt;dataref&gt;</b> can be a mark reference
  (<b>:&lt;idnum&gt;</b>) or the full 40-byte SHA-1 of a Git tag, commit, or
  tree object, preexisting or waiting to be written. The path is relative to the
  top level of the tree named by <b>&lt;dataref&gt;</b>.
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
<br/>
        'ls' SP &lt;dataref&gt; SP &lt;path&gt; LF</pre>
</div>
</div>
<p class="Pp">See <b>filemodify</b> above for a detailed description of
    <b>&lt;path&gt;</b>.</p>
<p class="Pp">Output uses the same format as <b>git ls-tree &lt;tree&gt; --
    &lt;path&gt;</b>:</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>&lt;mode&gt; SP ('blob' | 'tree' | 'commit') SP &lt;dataref&gt; HT &lt;path&gt; LF</pre>
</div>
<p class="Pp">The &lt;dataref&gt; represents the blob, tree, or commit object at
    &lt;path&gt; and can be used in later <i>get-mark</i>, <i>cat-blob</i>,
    <i>filemodify</i>, or <i>ls</i> commands.</p>
<p class="Pp">If there is no file or subtree at that path, <i>git
    fast-import</i> will instead report</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>missing SP &lt;path&gt; LF</pre>
</div>
<p class="Pp">See &#x201C;Responses To Commands&#x201D; below for details about
    how to read this output safely.</p>
</section>
<section class="Ss">
<h2 class="Ss"><b>feature</b></h2>
<p class="Pp">Require that fast-import supports the specified feature, or abort
    if it does not.</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
<br/>
        'feature' SP &lt;feature&gt; ('=' &lt;argument&gt;)? LF</pre>
</div>
<p class="Pp">The &lt;feature&gt; part of the command may be any one of the
    following:</p>
<p class="Pp">date-format, export-marks, relative-marks, no-relative-marks,
    force</p>
<div class="Bd-indent">Act as though the corresponding command-line option with
  a leading <b>--</b> was passed on the command line (see OPTIONS, above).</div>
<p class="Pp">import-marks, import-marks-if-exists</p>
<div class="Bd-indent">Like --import-marks except in two respects: first, only
  one &quot;feature import-marks&quot; or &quot;feature
  import-marks-if-exists&quot; command is allowed per stream; second, an
  --import-marks= or --import-marks-if-exists command-line option overrides any
  of these &quot;feature&quot; commands in the stream; third, &quot;feature
  import-marks-if-exists&quot; like a corresponding command-line option silently
  skips a nonexistent file.</div>
<p class="Pp">get-mark, cat-blob, ls</p>
<div class="Bd-indent">Require that the backend support the <i>get-mark</i>,
  <i>cat-blob</i>, or <i>ls</i> command respectively. Versions of fast-import
  not supporting the specified command will exit with a message indicating so.
  This lets the import error out early with a clear message, rather than wasting
  time on the early part of an import before the unsupported command is
  detected.</div>
<p class="Pp">notes</p>
<div class="Bd-indent">Require that the backend support the <i>notemodify</i>
  (N) subcommand to the <i>commit</i> command. Versions of fast-import not
  supporting notes will exit with a message indicating so.</div>
<p class="Pp">done</p>
<div class="Bd-indent">Error out if the stream ends without a <i>done</i>
  command. Without this feature, errors causing the frontend to end abruptly at
  a convenient point in the stream can go undetected. This may occur, for
  example, if an import front end dies in mid-operation without emitting SIGTERM
  or SIGKILL at its subordinate git fast-import instance.</div>
</section>
<section class="Ss">
<h2 class="Ss"><b>option</b></h2>
<p class="Pp">Processes the specified option so that git fast-import behaves in
    a way that suits the frontend&#x2019;s needs. Note that options specified by
    the frontend are overridden by any options the user may specify to git
    fast-import itself.</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
<br/>
    'option' SP &lt;option&gt; LF</pre>
</div>
<p class="Pp">The <b>&lt;option&gt;</b> part of the command may contain any of
    the options listed in the OPTIONS section that do not change import
    semantics, without the leading <b>--</b> and is treated in the same way.</p>
<p class="Pp">Option commands must be the first commands on the input (not
    counting feature commands), to give an option command after any non-option
    command is an error.</p>
<p class="Pp">The following command-line options change import semantics and may
    therefore not be passed as option:</p>
<p class="Pp"></p>
<div class="Bd-indent">&#x2022;date-format</div>
<p class="Pp"></p>
<div class="Bd-indent">&#x2022;import-marks</div>
<p class="Pp"></p>
<div class="Bd-indent">&#x2022;export-marks</div>
<p class="Pp"></p>
<div class="Bd-indent">&#x2022;cat-blob-fd</div>
<p class="Pp"></p>
<div class="Bd-indent">&#x2022;force</div>
</section>
<section class="Ss">
<h2 class="Ss"><b>done</b></h2>
<p class="Pp">If the <b>done</b> feature is not in use, treated as if EOF was
    read. This can be used to tell fast-import to finish early.</p>
<p class="Pp">If the <b>--done</b> command-line option or <b>feature done</b>
    command is in use, the <b>done</b> command is mandatory and marks the end of
    the stream.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="RESPONSES_TO_COMMANDS"><a class="permalink" href="#RESPONSES_TO_COMMANDS">RESPONSES
  TO COMMANDS</a></h1>
<p class="Pp">New objects written by fast-import are not available immediately.
    Most fast-import commands have no visible effect until the next checkpoint
    (or completion). The frontend can send commands to fill fast-import&#x2019;s
    input pipe without worrying about how quickly they will take effect, which
    improves performance by simplifying scheduling.</p>
<p class="Pp">For some frontends, though, it is useful to be able to read back
    data from the current repository as it is being updated (for example when
    the source material describes objects in terms of patches to be applied to
    previously imported objects). This can be accomplished by connecting the
    frontend and fast-import via bidirectional pipes:</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>mkfifo fast-import-output
frontend &lt;fast-import-output |
git fast-import &gt;fast-import-output</pre>
</div>
<p class="Pp">A frontend set up this way can use <b>progress</b>,
    <b>get-mark</b>, <b>ls</b>, and <b>cat-blob</b> commands to read information
    from the import in progress.</p>
<p class="Pp">To avoid deadlock, such frontends must completely consume any
    pending output from <b>progress</b>, <b>ls</b>, <b>get-mark</b>, and
    <b>cat-blob</b> before performing writes to fast-import that might
  block.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="CRASH_REPORTS"><a class="permalink" href="#CRASH_REPORTS">CRASH
  REPORTS</a></h1>
<p class="Pp">If fast-import is supplied invalid input it will terminate with a
    non-zero exit status and create a crash report in the top level of the Git
    repository it was importing into. Crash reports contain a snapshot of the
    internal fast-import state as well as the most recent commands that lead up
    to the crash.</p>
<p class="Pp">All recent commands (including stream comments, file changes and
    progress commands) are shown in the command history within the crash report,
    but raw file data and commit messages are excluded from the crash report.
    This exclusion saves space within the report file and reduces the amount of
    buffering that fast-import must perform during execution.</p>
<p class="Pp">After writing a crash report fast-import will close the current
    packfile and export the marks table. This allows the frontend developer to
    inspect the repository state and resume the import from the point where it
    crashed. The modified branches and tags are not updated during a crash, as
    the import did not complete successfully. Branch and tag information can be
    found in the crash report and must be applied manually if the update is
    needed.</p>
<p class="Pp">An example crash:</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>$ cat &gt;in &lt;&lt;END_OF_INPUT
# my very first test commit
commit refs/heads/master
committer Shawn O. Pearce &lt;spearce&gt; 19283 -0400
# who is that guy anyway?
data &lt;&lt;EOF
this is my commit
EOF
M 644 inline .gitignore
data &lt;&lt;EOF
.gitignore
EOF
M 777 inline bob
END_OF_INPUT</pre>
</div>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>$ git fast-import &lt;in
fatal: Corrupt mode: M 777 inline bob
fast-import: dumping crash report to .git/fast_import_crash_8434</pre>
</div>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>$ cat .git/fast_import_crash_8434
fast-import crash report:
<br/>
    fast-import process: 8434
<br/>
    parent process     : 1391
<br/>
    at Sat Sep 1 00:58:12 2007</pre>
</div>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>fatal: Corrupt mode: M 777 inline bob</pre>
</div>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>Most Recent Commands Before Crash
---------------------------------
<br/>
  # my very first test commit
<br/>
  commit refs/heads/master
<br/>
  committer Shawn O. Pearce &lt;spearce&gt; 19283 -0400
<br/>
  # who is that guy anyway?
<br/>
  data &lt;&lt;EOF
<br/>
  M 644 inline .gitignore
<br/>
  data &lt;&lt;EOF
* M 777 inline bob</pre>
</div>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>Active Branch LRU
-----------------
<br/>
    active_branches = 1 cur, 5 max</pre>
</div>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>pos  clock name
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<br/>
 1)      0 refs/heads/master</pre>
</div>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>Inactive Branches
-----------------
refs/heads/master:
<br/>
  status      : active loaded dirty
<br/>
  tip commit  : 0000000000000000000000000000000000000000
<br/>
  old tree    : 0000000000000000000000000000000000000000
<br/>
  cur tree    : 0000000000000000000000000000000000000000
<br/>
  commit clock: 0
<br/>
  last pack   :</pre>
</div>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>-------------------
END OF CRASH REPORT</pre>
</div>
</section>
<section class="Sh">
<h1 class="Sh" id="TIPS_AND_TRICKS"><a class="permalink" href="#TIPS_AND_TRICKS">TIPS
  AND TRICKS</a></h1>
<p class="Pp">The following tips and tricks have been collected from various
    users of fast-import, and are offered here as suggestions.</p>
<section class="Ss">
<h2 class="Ss" id="Use_One_Mark_Per_Commit"><a class="permalink" href="#Use_One_Mark_Per_Commit">Use
  One Mark Per Commit</a></h2>
<p class="Pp">When doing a repository conversion, use a unique mark per commit
    (<b>mark :&lt;n&gt;</b>) and supply the --export-marks option on the command
    line. fast-import will dump a file which lists every mark and the Git object
    SHA-1 that corresponds to it. If the frontend can tie the marks back to the
    source repository, it is easy to verify the accuracy and completeness of the
    import by comparing each Git commit to the corresponding source
  revision.</p>
<p class="Pp">Coming from a system such as Perforce or Subversion this should be
    quite simple, as the fast-import mark can also be the Perforce changeset
    number or the Subversion revision number.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Freely_Skip_Around_Branches"><a class="permalink" href="#Freely_Skip_Around_Branches">Freely
  Skip Around Branches</a></h2>
<p class="Pp">Don&#x2019;t bother trying to optimize the frontend to stick to
    one branch at a time during an import. Although doing so might be slightly
    faster for fast-import, it tends to increase the complexity of the frontend
    code considerably.</p>
<p class="Pp">The branch LRU builtin to fast-import tends to behave very well,
    and the cost of activating an inactive branch is so low that bouncing around
    between branches has virtually no impact on import performance.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Handling_Renames"><a class="permalink" href="#Handling_Renames">Handling
  Renames</a></h2>
<p class="Pp">When importing a renamed file or directory, simply delete the old
    name(s) and modify the new name(s) during the corresponding commit. Git
    performs rename detection after-the-fact, rather than explicitly during a
    commit.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Use_Tag_Fixup_Branches"><a class="permalink" href="#Use_Tag_Fixup_Branches">Use
  Tag Fixup Branches</a></h2>
<p class="Pp">Some other SCM systems let the user create a tag from multiple
    files which are not from the same commit/changeset. Or to create tags which
    are a subset of the files available in the repository.</p>
<p class="Pp">Importing these tags as-is in Git is impossible without making at
    least one commit which &#x201C;fixes up&#x201D; the files to match the
    content of the tag. Use fast-import&#x2019;s <b>reset</b> command to reset a
    dummy branch outside of your normal branch space to the base commit for the
    tag, then commit one or more file fixup commits, and finally tag the dummy
    branch.</p>
<p class="Pp">For example since all normal branches are stored under
    <b>refs/heads/</b> name the tag fixup branch <b>TAG_FIXUP</b>. This way it
    is impossible for the fixup branch used by the importer to have namespace
    conflicts with real branches imported from the source (the name
    <b>TAG_FIXUP</b> is not <b>refs/heads/TAG_FIXUP</b>).</p>
<p class="Pp">When committing fixups, consider using <b>merge</b> to connect the
    commit(s) which are supplying file revisions to the fixup branch. Doing so
    will allow tools such as <i>git blame</i> to track through the real commit
    history and properly annotate the source files.</p>
<p class="Pp">After fast-import terminates the frontend will need to do <b>rm
    .git/TAG_FIXUP</b> to remove the dummy branch.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Import_Now,_Repack_Later"><a class="permalink" href="#Import_Now,_Repack_Later">Import
  Now, Repack Later</a></h2>
<p class="Pp">As soon as fast-import completes the Git repository is completely
    valid and ready for use. Typically this takes only a very short time, even
    for considerably large projects (100,000+ commits).</p>
<p class="Pp">However repacking the repository is necessary to improve data
    locality and access performance. It can also take hours on extremely large
    projects (especially if -f and a large --window parameter is used). Since
    repacking is safe to run alongside readers and writers, run the repack in
    the background and let it finish when it finishes. There is no reason to
    wait to explore your new Git project!</p>
<p class="Pp">If you choose to wait for the repack, don&#x2019;t try to run
    benchmarks or performance tests until repacking is completed. fast-import
    outputs suboptimal packfiles that are simply never seen in real use
    situations.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Repacking_Historical_Data"><a class="permalink" href="#Repacking_Historical_Data">Repacking
  Historical Data</a></h2>
<p class="Pp">If you are repacking very old imported data (e.g. older than the
    last year), consider expending some extra CPU time and supplying --window=50
    (or higher) when you run <i>git repack</i>. This will take longer, but will
    also produce a smaller packfile. You only need to expend the effort once,
    and everyone using your project will benefit from the smaller
  repository.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Include_Some_Progress_Messages"><a class="permalink" href="#Include_Some_Progress_Messages">Include
  Some Progress Messages</a></h2>
<p class="Pp">Every once in a while have your frontend emit a <b>progress</b>
    message to fast-import. The contents of the messages are entirely free-form,
    so one suggestion would be to output the current month and year each time
    the current commit date moves into the next month. Your users will feel
    better knowing how much of the data stream has been processed.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="PACKFILE_OPTIMIZATION"><a class="permalink" href="#PACKFILE_OPTIMIZATION">PACKFILE
  OPTIMIZATION</a></h1>
<p class="Pp">When packing a blob fast-import always attempts to deltify against
    the last blob written. Unless specifically arranged for by the frontend,
    this will probably not be a prior version of the same file, so the generated
    delta will not be the smallest possible. The resulting packfile will be
    compressed, but will not be optimal.</p>
<p class="Pp">Frontends which have efficient access to all revisions of a single
    file (for example reading an RCS/CVS ,v file) can choose to supply all
    revisions of that file as a sequence of consecutive <b>blob</b> commands.
    This allows fast-import to deltify the different file revisions against each
    other, saving space in the final packfile. Marks can be used to later
    identify individual file revisions during a sequence of <b>commit</b>
    commands.</p>
<p class="Pp">The packfile(s) created by fast-import do not encourage good disk
    access patterns. This is caused by fast-import writing the data in the order
    it is received on standard input, while Git typically organizes data within
    packfiles to make the most recent (current tip) data appear before
    historical data. Git also clusters commits together, speeding up revision
    traversal through better cache locality.</p>
<p class="Pp">For this reason it is strongly recommended that users repack the
    repository with <b>git repack -a -d</b> after fast-import completes,
    allowing Git to reorganize the packfiles for faster data access. If blob
    deltas are suboptimal (see above) then also adding the <b>-f</b> option to
    force recomputation of all deltas can significantly reduce the final
    packfile size (30-50% smaller can be quite typical).</p>
<p class="Pp">Instead of running <b>git repack</b> you can also run <b>git gc
    --aggressive</b>, which will also optimize other things after an import
    (e.g. pack loose refs). As noted in the &quot;AGGRESSIVE&quot; section in
    <b>git-gc</b>(1) the <b>--aggressive</b> option will find new deltas with
    the <b>-f</b> option to <b>git-repack</b>(1). For the reasons elaborated on
    above using <b>--aggressive</b> after a fast-import is one of the few cases
    where it&#x2019;s known to be worthwhile.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="MEMORY_UTILIZATION"><a class="permalink" href="#MEMORY_UTILIZATION">MEMORY
  UTILIZATION</a></h1>
<p class="Pp">There are a number of factors which affect how much memory
    fast-import requires to perform an import. Like critical sections of core
    Git, fast-import uses its own memory allocators to amortize any overheads
    associated with malloc. In practice fast-import tends to amortize any malloc
    overheads to 0, due to its use of large block allocations.</p>
<section class="Ss">
<h2 class="Ss" id="per_object"><a class="permalink" href="#per_object">per
  object</a></h2>
<p class="Pp">fast-import maintains an in-memory structure for every object
    written in this execution. On a 32 bit system the structure is 32 bytes, on
    a 64 bit system the structure is 40 bytes (due to the larger pointer sizes).
    Objects in the table are not deallocated until fast-import terminates.
    Importing 2 million objects on a 32 bit system will require approximately 64
    MiB of memory.</p>
<p class="Pp">The object table is actually a hashtable keyed on the object name
    (the unique SHA-1). This storage configuration allows fast-import to reuse
    an existing or already written object and avoid writing duplicates to the
    output packfile. Duplicate blobs are surprisingly common in an import,
    typically due to branch merges in the source.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="per_mark"><a class="permalink" href="#per_mark">per
  mark</a></h2>
<p class="Pp">Marks are stored in a sparse array, using 1 pointer (4 bytes or 8
    bytes, depending on pointer size) per mark. Although the array is sparse,
    frontends are still strongly encouraged to use marks between 1 and n, where
    n is the total number of marks required for this import.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="per_branch"><a class="permalink" href="#per_branch">per
  branch</a></h2>
<p class="Pp">Branches are classified as active and inactive. The memory usage
    of the two classes is significantly different.</p>
<p class="Pp">Inactive branches are stored in a structure which uses 96 or 120
    bytes (32 bit or 64 bit systems, respectively), plus the length of the
    branch name (typically under 200 bytes), per branch. fast-import will easily
    handle as many as 10,000 inactive branches in under 2 MiB of memory.</p>
<p class="Pp">Active branches have the same overhead as inactive branches, but
    also contain copies of every tree that has been recently modified on that
    branch. If subtree <b>include</b> has not been modified since the branch
    became active, its contents will not be loaded into memory, but if subtree
    <b>src</b> has been modified by a commit since the branch became active,
    then its contents will be loaded in memory.</p>
<p class="Pp">As active branches store metadata about the files contained on
    that branch, their in-memory storage size can grow to a considerable size
    (see below).</p>
<p class="Pp">fast-import automatically moves active branches to inactive status
    based on a simple least-recently-used algorithm. The LRU chain is updated on
    each <b>commit</b> command. The maximum number of active branches can be
    increased or decreased on the command line with --active-branches=.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="per_active_tree"><a class="permalink" href="#per_active_tree">per
  active tree</a></h2>
<p class="Pp">Trees (aka directories) use just 12 bytes of memory on top of the
    memory required for their entries (see &#x201C;per active file&#x201D;
    below). The cost of a tree is virtually 0, as its overhead amortizes out
    over the individual file entries.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="per_active_file_entry"><a class="permalink" href="#per_active_file_entry">per
  active file entry</a></h2>
<p class="Pp">Files (and pointers to subtrees) within active trees require 52 or
    64 bytes (32/64 bit platforms) per entry. To conserve space, file and tree
    names are pooled in a common string table, allowing the filename
    &#x201C;Makefile&#x201D; to use just 16 bytes (after including the string
    header overhead) no matter how many times it occurs within the project.</p>
<p class="Pp">The active branch LRU, when coupled with the filename string pool
    and lazy loading of subtrees, allows fast-import to efficiently import
    projects with 2,000+ branches and 45,114+ files in a very limited memory
    footprint (less than 2.7 MiB per active branch).</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="SIGNALS"><a class="permalink" href="#SIGNALS">SIGNALS</a></h1>
<p class="Pp">Sending <b>SIGUSR1</b> to the <i>git fast-import</i> process ends
    the current packfile early, simulating a <b>checkpoint</b> command. The
    impatient operator can use this facility to peek at the objects and refs
    from an import in progress, at the cost of some added running time and worse
    compression.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="CONFIGURATION"><a class="permalink" href="#CONFIGURATION">CONFIGURATION</a></h1>
<p class="Pp">Everything below this line in this section is selectively included
    from the <b>git-config</b>(1) documentation. The content is the same as
    what&#x2019;s found there:</p>
<p class="Pp">fastimport.unpackLimit</p>
<div class="Bd-indent">If the number of objects imported by
  <b>git-fast-import</b>(1) is below this limit, then the objects will be
  unpacked into loose object files. However if the number of imported objects
  equals or exceeds this limit then the pack will be stored as a pack. Storing
  the pack from a fast-import can make the import operation complete faster,
  especially on slow filesystems. If not set, the value of
  <b>transfer.unpackLimit</b> is used instead.</div>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp"><b>git-fast-export</b>(1)</p>
</section>
<section class="Sh">
<h1 class="Sh" id="GIT"><a class="permalink" href="#GIT">GIT</a></h1>
<p class="Pp">Part of the <b>git</b>(1) suite</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">06/06/2021</td>
    <td class="foot-os">Git 2.32.0</td>
  </tr>
</table>
</body>
</html>
