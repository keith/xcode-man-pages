<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    .Nd, .Bf, .Op { display: inline; }
    .Pa, .Ad { font-style: italic; }
    .Ms { font-weight: bold; }
    .Bl-diag > dt { font-weight: bold; }
    code.Nm, .Fl, .Cm, .Ic, code.In, .Fd, .Fn, .Cd { font-weight: bold;
      font-family: inherit; }
  </style>
  <title>Net::SMTP(3pm)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Net::SMTP(3pm)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">Net::SMTP(3pm)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Net::SMTP - Simple Mail Transfer Protocol Client</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>    use Net::SMTP;
    # Constructors
    $smtp = Net::SMTP-&gt;new('mailhost');
    $smtp = Net::SMTP-&gt;new('mailhost', Timeout =&gt; 60);
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">This module implements a client interface to the SMTP and ESMTP
    protocol, enabling a perl5 application to talk to SMTP servers. This
    documentation assumes that you are familiar with the concepts of the SMTP
    protocol described in RFC2821. With IO::Socket::SSL installed it also
    provides support for implicit and explicit TLS encryption, i.e. SMTPS or
    SMTP+STARTTLS.</p>
<p class="Pp">The Net::SMTP class is a subclass of Net::Cmd and (depending on
    avaibility) of IO::Socket::IP, IO::Socket::INET6 or IO::Socket::INET.</p>
<section class="Ss">
<h2 class="Ss" id="Class_Methods"><a class="permalink" href="#Class_Methods">Class
  Methods</a></h2>
<dl class="Bl-tag">
  <dt>&quot;new([$host][, %options])&quot;</dt>
  <dd>This is the constructor for a new Net::SMTP object.
      <span class="Li">$host</span> is the name of the remote host to which an
      SMTP connection is required.
    <p class="Pp">On failure <span class="Li">&quot;undef&quot;</span> will be
        returned and <span class="Li">$@</span> will contain the reason for the
        failure.</p>
    <p class="Pp"><span class="Li">$host</span> is optional. If
        <span class="Li">$host</span> is not given then it may instead be passed
        as the <span class="Li">&quot;Host&quot;</span> option described below.
        If neither is given then the
        <span class="Li">&quot;SMTP_Hosts&quot;</span> specified in
        <span class="Li">&quot;Net::Config&quot;</span> will be used.</p>
    <p class="Pp"><span class="Li">%options</span> are passed in a hash like
        fashion, using key and value pairs. Possible options are:</p>
    <p class="Pp"><b>Hello</b> - SMTP requires that you identify yourself. This
        option specifies a string to pass as your mail domain. If not given
        localhost.localdomain will be used.</p>
    <p class="Pp"><b>SendHello</b> - If false then the EHLO (or HELO) command
        that is normally sent when constructing the object will not be sent. In
        that case the command will have to be sent manually by calling
        <span class="Li">&quot;hello()&quot;</span> instead.</p>
    <p class="Pp"><b>Host</b> - SMTP host to connect to. It may be a single
        scalar (hostname[:port]), as defined for the
        <span class="Li">&quot;PeerAddr&quot;</span> option in IO::Socket::INET,
        or a reference to an array with hosts to try in turn. The
        &quot;host&quot; method will return the value which was used to connect
        to the host. Format - <span class="Li">&quot;PeerHost&quot;</span> from
        IO::Socket::INET new method.</p>
    <p class="Pp"><b>Port</b> - port to connect to. Default - 25 for plain SMTP
        and 465 for immediate SSL.</p>
    <p class="Pp"><b>SSL</b> - If the connection should be done from start with
        SSL, contrary to later upgrade with
        <span class="Li">&quot;starttls&quot;</span>. You can use SSL arguments
        as documented in IO::Socket::SSL, but it will usually use the right
        arguments already.</p>
    <p class="Pp"><b>LocalAddr</b> and <b>LocalPort</b> - These parameters are
        passed directly to IO::Socket to allow binding the socket to a specific
        local address and port.</p>
    <p class="Pp"><b>Domain</b> - This parameter is passed directly to
        IO::Socket and makes it possible to enforce IPv4 connections even if
        IO::Socket::IP is used as super class. Alternatively <b>Family</b> can
        be used.</p>
    <p class="Pp"><b>Timeout</b> - Maximum time, in seconds, to wait for a
        response from the SMTP server (default: 120)</p>
    <p class="Pp"><b>ExactAddresses</b> - If true then all
        <span class="Li">$address</span> arguments must be as defined by
        <span class="Li">&quot;addr-spec&quot;</span> in RFC2822. If not given,
        or false, then Net::SMTP will attempt to extract the address from the
        value passed.</p>
    <p class="Pp"><b>Debug</b> - Enable debugging information</p>
    <p class="Pp">Example:</p>
    <p class="Pp"></p>
    <pre>    $smtp = Net::SMTP-&gt;new('mailhost',
                           Hello =&gt; 'my.mail.domain',
                           Timeout =&gt; 30,
                           Debug   =&gt; 1,
                          );
    # the same
    $smtp = Net::SMTP-&gt;new(
                           Host =&gt; 'mailhost',
                           Hello =&gt; 'my.mail.domain',
                           Timeout =&gt; 30,
                           Debug   =&gt; 1,
                          );
    # the same with direct SSL
    $smtp = Net::SMTP-&gt;new('mailhost',
                           Hello =&gt; 'my.mail.domain',
                           Timeout =&gt; 30,
                           Debug   =&gt; 1,
                           SSL     =&gt; 1,
                          );
    # Connect to the default server from Net::config
    $smtp = Net::SMTP-&gt;new(
                           Hello =&gt; 'my.mail.domain',
                           Timeout =&gt; 30,
                          );
    </pre>
  </dd>
</dl>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="Object_Methods"><a class="permalink" href="#Object_Methods">Object
  Methods</a></h1>
<p class="Pp">Unless otherwise stated all methods return either a <i>true</i> or
    <i>false</i> value, with <i>true</i> meaning that the operation was a
    success. When a method states that it returns a value, failure will be
    returned as <i>undef</i> or an empty list.</p>
<p class="Pp"><span class="Li">&quot;Net::SMTP&quot;</span> inherits from
    <span class="Li">&quot;Net::Cmd&quot;</span> so methods defined in
    <span class="Li">&quot;Net::Cmd&quot;</span> may be used to send commands to
    the remote SMTP server in addition to the methods documented here.</p>
<dl class="Bl-tag">
  <dt>&quot;banner()&quot;</dt>
  <dd>Returns the banner message which the server replied with when the initial
      connection was made.</dd>
  <dt>&quot;domain()&quot;</dt>
  <dd>Returns the domain that the remote SMTP server identified itself as during
      connection.</dd>
  <dt>&quot;hello($domain)&quot;</dt>
  <dd>Tell the remote server the mail domain which you are in using the EHLO
      command (or HELO if EHLO fails). Since this method is invoked
      automatically when the Net::SMTP object is constructed the user should
      normally not have to call it manually.</dd>
  <dt>&quot;host()&quot;</dt>
  <dd>Returns the value used by the constructor, and passed to IO::Socket::INET,
      to connect to the host.</dd>
  <dt>&quot;etrn($domain)&quot;</dt>
  <dd>Request a queue run for the <span class="Li">$domain</span> given.</dd>
  <dt>&quot;starttls(%sslargs)&quot;</dt>
  <dd>Upgrade existing plain connection to SSL. You can use SSL arguments as
      documented in IO::Socket::SSL, but it will usually use the right arguments
      already.</dd>
  <dt>&quot;auth($username, $password)&quot;</dt>
  <dd></dd>
  <dt>&quot;auth($sasl)&quot;</dt>
  <dd>Attempt SASL authentication. Requires Authen::SASL module. The first form
      constructs a new Authen::SASL object using the given username and
      password; the second form uses the given Authen::SASL object.</dd>
  <dt>&quot;mail($address[, %options])&quot;</dt>
  <dd></dd>
  <dt>&quot;send($address)&quot;</dt>
  <dd></dd>
  <dt>&quot;send_or_mail($address)&quot;</dt>
  <dd></dd>
  <dt>&quot;send_and_mail($address)&quot;</dt>
  <dd>Send the appropriate command to the server MAIL, SEND, SOML or SAML.
      <span class="Li">$address</span> is the address of the sender. This
      initiates the sending of a message. The method
      <span class="Li">&quot;recipient&quot;</span> should be called for each
      address that the message is to be sent to.
    <p class="Pp">The <span class="Li">&quot;mail&quot;</span> method can take
        some additional ESMTP <span class="Li">%options</span> which is passed
        in hash like fashion, using key and value pairs. Possible options
      are:</p>
    <p class="Pp"></p>
    <pre> Size        =&gt; &lt;bytes&gt;
 Return      =&gt; &quot;FULL&quot; | &quot;HDRS&quot;
 Bits        =&gt; &quot;7&quot; | &quot;8&quot; | &quot;binary&quot;
 Transaction =&gt; &lt;ADDRESS&gt;
 Envelope    =&gt; &lt;ENVID&gt;     # xtext-encodes its argument
 ENVID       =&gt; &lt;ENVID&gt;     # similar to Envelope, but expects argument encoded
 XVERP       =&gt; 1
 AUTH        =&gt; &lt;submitter&gt; # encoded address according to RFC 2554
    </pre>
    <p class="Pp">The <span class="Li">&quot;Return&quot;</span> and
        <span class="Li">&quot;Envelope&quot;</span> parameters are used for DSN
        (Delivery Status Notification).</p>
    <p class="Pp">The submitter address in
        <span class="Li">&quot;AUTH&quot;</span> option is expected to be in a
        format as required by RFC 2554, in an RFC2821-quoted form and
        xtext-encoded, or &lt;&gt; .</p>
  </dd>
  <dt>&quot;reset()&quot;</dt>
  <dd>Reset the status of the server. This may be called after a message has
      been initiated, but before any data has been sent, to cancel the sending
      of the message.</dd>
  <dt>&quot;recipient($address[, $address[, ...]][, %options])&quot;</dt>
  <dd>Notify the server that the current message should be sent to all of the
      addresses given. Each address is sent as a separate command to the server.
      Should the sending of any address result in a failure then the process is
      aborted and a <i>false</i> value is returned. It is up to the user to call
      <span class="Li">&quot;reset&quot;</span> if they so desire.
    <p class="Pp">The <span class="Li">&quot;recipient&quot;</span> method can
        also pass additional case-sensitive <span class="Li">%options</span> as
        an anonymous hash using key and value pairs. Possible options are:</p>
    <p class="Pp"></p>
    <pre>  Notify  =&gt; ['NEVER'] or ['SUCCESS','FAILURE','DELAY']  (see below)
  ORcpt   =&gt; &lt;ORCPT&gt;
  SkipBad =&gt; 1        (to ignore bad addresses)
    </pre>
    <p class="Pp">If <span class="Li">&quot;SkipBad&quot;</span> is true the
        <span class="Li">&quot;recipient&quot;</span> will not return an error
        when a bad address is encountered and it will return an array of
        addresses that did succeed.</p>
    <p class="Pp"></p>
    <pre>  $smtp-&gt;recipient($recipient1,$recipient2);  # Good
  $smtp-&gt;recipient($recipient1,$recipient2, { SkipBad =&gt; 1 });  # Good
  $smtp-&gt;recipient($recipient1,$recipient2, { Notify =&gt; ['FAILURE','DELAY'], SkipBad =&gt; 1 });  # Good
  @goodrecips=$smtp-&gt;recipient(@recipients, { Notify =&gt; ['FAILURE'], SkipBad =&gt; 1 });  # Good
  $smtp-&gt;recipient(&quot;$recipient,$recipient2&quot;); # BAD
    </pre>
    <p class="Pp">Notify is used to request Delivery Status Notifications
        (DSNs), but your SMTP/ESMTP service may not respect this request
        depending upon its version and your site's SMTP configuration.</p>
    <p class="Pp">Leaving out the Notify option usually defaults an SMTP service
        to its default behavior equivalent to ['FAILURE'] notifications only,
        but again this may be dependent upon your site's SMTP configuration.</p>
    <p class="Pp">The NEVER keyword must appear by itself if used within the
        Notify option and &quot;requests that a DSN not be returned to the
        sender under any conditions.&quot;</p>
    <p class="Pp"></p>
    <pre>  {Notify =&gt; ['NEVER']}
  $smtp-&gt;recipient(@recipients, { Notify =&gt; ['NEVER'], SkipBad =&gt; 1 });  # Good
    </pre>
    <p class="Pp">You may use any combination of these three values
        'SUCCESS','FAILURE','DELAY' in the anonymous array reference as defined
        by RFC3461 (see &lt;https://www.ietf.org/rfc/rfc3461.txt&gt; for more
        information. Note: quotations in this topic from same.).</p>
    <p class="Pp">A Notify parameter of 'SUCCESS' or 'FAILURE' &quot;requests
        that a DSN be issued on successful delivery or delivery failure,
        respectively.&quot;</p>
    <p class="Pp">A Notify parameter of 'DELAY' &quot;indicates the sender's
        willingness to receive delayed DSNs. Delayed DSNs may be issued if
        delivery of a message has been delayed for an unusual amount of time (as
        determined by the Message Transfer Agent (MTA) at which the message is
        delayed), but the final delivery status (whether successful or failure)
        cannot be determined. The absence of the DELAY keyword in a NOTIFY
        parameter requests that a &quot;delayed&quot; DSN NOT be issued under
        any conditions.&quot;</p>
    <p class="Pp"></p>
    <pre>  {Notify =&gt; ['SUCCESS','FAILURE','DELAY']}
  $smtp-&gt;recipient(@recipients, { Notify =&gt; ['FAILURE','DELAY'], SkipBad =&gt; 1 });  # Good
    </pre>
    <p class="Pp">ORcpt is also part of the SMTP DSN extension according to
        RFC3461. It is used to pass along the original recipient that the mail
        was first sent to. The machine that generates a DSN will use this
        address to inform the sender, because he can't know if recipients get
        rewritten by mail servers. It is expected to be in a format as required
        by RFC3461, xtext-encoded.</p>
  </dd>
  <dt>&quot;to($address[, $address[, ...]])&quot;</dt>
  <dd></dd>
  <dt>&quot;cc($address[, $address[, ...]])&quot;</dt>
  <dd></dd>
  <dt>&quot;bcc($address[, $address[, ...]])&quot;</dt>
  <dd>Synonyms for <span class="Li">&quot;recipient&quot;</span>.</dd>
  <dt>&quot;data([$data])&quot;</dt>
  <dd>Initiate the sending of the data from the current message.
    <p class="Pp"><span class="Li">$data</span> may be a reference to a list or
        a list and must be encoded by the caller to octets of whatever encoding
        is required, e.g. by using the Encode module's
        <span class="Li">&quot;encode()&quot;</span> function.</p>
    <p class="Pp">If specified the contents of <span class="Li">$data</span> and
        a termination string <span class="Li">&quot;.\r\n&quot;</span> is sent
        to the server. The result will be true if the data was accepted.</p>
    <p class="Pp">If <span class="Li">$data</span> is not specified then the
        result will indicate that the server wishes the data to be sent. The
        data must then be sent using the
        <span class="Li">&quot;datasend&quot;</span> and
        <span class="Li">&quot;dataend&quot;</span> methods described in
        Net::Cmd.</p>
  </dd>
  <dt>&quot;bdat($data)&quot;</dt>
  <dd></dd>
  <dt>&quot;bdatlast($data)&quot;</dt>
  <dd>Use the alternate <span class="Li">$data</span> command &quot;BDAT&quot;
      of the data chunking service extension defined in RFC1830 for efficiently
      sending large MIME messages.</dd>
  <dt>&quot;expand($address)&quot;</dt>
  <dd>Request the server to expand the given address Returns an array which
      contains the text read from the server.</dd>
  <dt>&quot;verify($address)&quot;</dt>
  <dd>Verify that <span class="Li">$address</span> is a legitimate mailing
      address.
    <p class="Pp">Most sites usually disable this feature in their SMTP service
        configuration. Use &quot;Debug =&gt; 1&quot; option under <b>new()</b>
        to see if disabled.</p>
  </dd>
  <dt>&quot;help([$subject])&quot;</dt>
  <dd>Request help text from the server. Returns the text or undef upon
    failure</dd>
  <dt>&quot;quit()&quot;</dt>
  <dd>Send the QUIT command to the remote SMTP server and close the socket
      connection.</dd>
  <dt>&quot;can_inet6()&quot;</dt>
  <dd>Returns whether we can use IPv6.</dd>
  <dt>&quot;can_ssl()&quot;</dt>
  <dd>Returns whether we can use SSL.</dd>
</dl>
<section class="Ss">
<h2 class="Ss" id="Addresses"><a class="permalink" href="#Addresses">Addresses</a></h2>
<p class="Pp">Net::SMTP attempts to DWIM with addresses that are passed. For
    example an application might extract The From: line from an email and pass
    that to <b>mail()</b>. While this may work, it is not recommended. The
    application should really use a module like Mail::Address to extract the
    mail address and pass that.</p>
<p class="Pp">If <span class="Li">&quot;ExactAddresses&quot;</span> is passed to
    the constructor, then addresses should be a valid rfc2821-quoted address,
    although Net::SMTP will accept the address surrounded by angle brackets.</p>
<p class="Pp"></p>
<pre> funny user@domain      WRONG
 &quot;funny user&quot;@domain    RIGHT, recommended
 &lt;&quot;funny user&quot;@domain&gt;  OK
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="EXAMPLES"><a class="permalink" href="#EXAMPLES">EXAMPLES</a></h1>
<p class="Pp">This example prints the mail domain name of the SMTP server known
    as mailhost:</p>
<p class="Pp"></p>
<pre>    #!/usr/local/bin/perl -w
    use Net::SMTP;
    $smtp = Net::SMTP-&gt;new('mailhost');
    print $smtp-&gt;domain,&quot;\n&quot;;
    $smtp-&gt;quit;
</pre>
<p class="Pp">This example sends a small message to the postmaster at the SMTP
    server known as mailhost:</p>
<p class="Pp"></p>
<pre>    #!/usr/local/bin/perl -w
    use Net::SMTP;
    my $smtp = Net::SMTP-&gt;new('mailhost');
    $smtp-&gt;mail($ENV{USER});
    if ($smtp-&gt;to('postmaster')) {
     $smtp-&gt;data();
     $smtp-&gt;datasend(&quot;To: postmaster\n&quot;);
     $smtp-&gt;datasend(&quot;\n&quot;);
     $smtp-&gt;datasend(&quot;A simple test message\n&quot;);
     $smtp-&gt;dataend();
    } else {
     print &quot;Error: &quot;, $smtp-&gt;message();
    }
    $smtp-&gt;quit;
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="EXPORTS"><a class="permalink" href="#EXPORTS">EXPORTS</a></h1>
<p class="Pp"><i>None</i>.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="KNOWN_BUGS"><a class="permalink" href="#KNOWN_BUGS">KNOWN
  BUGS</a></h1>
<p class="Pp">See
    &lt;https://rt.cpan.org/Dist/Display.html?Status=Active&amp;Queue=libnet&gt;.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp">Net::Cmd, IO::Socket::SSL.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">Graham Barr &lt;gbarr@pobox.com
    &lt;mailto:gbarr@pobox.com&gt;&gt;.</p>
<p class="Pp">Steve Hay &lt;shay@cpan.org &lt;mailto:shay@cpan.org&gt;&gt; is
    now maintaining libnet as of version 1.22_02.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT"><a class="permalink" href="#COPYRIGHT">COPYRIGHT</a></h1>
<p class="Pp">Copyright (C) 1995-2004 Graham Barr. All rights reserved.</p>
<p class="Pp">Copyright (C) 2013-2016, 2020 Steve Hay. All rights reserved.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="LICENCE"><a class="permalink" href="#LICENCE">LICENCE</a></h1>
<p class="Pp">This module is free software; you can redistribute it and/or
    modify it under the same terms as Perl itself, i.e. under the terms of
    either the GNU General Public License or the Artistic License, as specified
    in the <i>LICENCE</i> file.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="VERSION"><a class="permalink" href="#VERSION">VERSION</a></h1>
<p class="Pp">Version 3.13</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DATE"><a class="permalink" href="#DATE">DATE</a></h1>
<p class="Pp">23 Dec 2020</p>
</section>
<section class="Sh">
<h1 class="Sh" id="HISTORY"><a class="permalink" href="#HISTORY">HISTORY</a></h1>
<p class="Pp">See the <i>Changes</i> file.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2022-02-19</td>
    <td class="foot-os">perl v5.34.1</td>
  </tr>
</table>
</body>
</html>
