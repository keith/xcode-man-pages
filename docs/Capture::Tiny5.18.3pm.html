<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>Capture::Tiny(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Capture::Tiny(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Capture::Tiny(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
Capture::Tiny - Capture STDOUT and STDERR from Perl, XS or external programs
</section>
<section class="Sh">
<h1 class="Sh" id="VERSION"><a class="permalink" href="#VERSION">VERSION</a></h1>
version 0.23
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<span class="Li"></span>
<pre>
   use Capture::Tiny ':all';
 
   # capture from external command
 
   ($stdout, $stderr, $exit) = capture {
     system( $cmd, @args );
   };
 
   # capture from arbitrary code (Perl or external)
 
   ($stdout, $stderr, @result) = capture {
     # your code here
   };
 
   # capture partial or merged output
 
   $stdout = capture_stdout { ... };
   $stderr = capture_stderr { ... };
   $merged = capture_merged { ... };
 
   # tee output
 
   ($stdout, $stderr) = tee {
     # your code here
   };
 
   $stdout = tee_stdout { ... };
   $stderr = tee_stderr { ... };
   $merged = tee_merged { ... };
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
Capture::Tiny provides a simple, portable way to capture almost anything sent to
  STDOUT or STDERR, regardless of whether it comes from Perl, from XS code or
  from an external program. Optionally, output can be teed so that it is
  captured while being passed through to the original filehandles. Yes, it even
  works on Windows (usually). Stop guessing which of a dozen capturing modules
  to use in any particular situation and just use this one.
</section>
<section class="Sh">
<h1 class="Sh" id="USAGE"><a class="permalink" href="#USAGE">USAGE</a></h1>
The following functions are available. None are exported by default.
<section class="Ss">
<h2 class="Ss" id="capture"><a class="permalink" href="#capture">capture</a></h2>
<span class="Li"></span>
<pre>
   ($stdout, $stderr, @result) = capture \&amp;code;
   $stdout = capture \&amp;code;
</pre>
<p class="Pp">The <span class="Li">&quot;capture&quot;</span> function takes a
    code reference and returns what is sent to STDOUT and STDERR as well as any
    return values from the code reference. In scalar context, it returns only
    STDOUT. If no output was received for a filehandle, it returns an empty
    string for that filehandle. Regardless of calling context, all output is
    captured -- nothing is passed to the existing filehandles.</p>
<p class="Pp">It is prototyped to take a subroutine reference as an argument.
    Thus, it can be called in block form:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
   ($stdout, $stderr) = capture {
     # your code here ...
   };
</pre>
<p class="Pp">Note that the coderef is evaluated in list context. If you wish to
    force scalar context on the return value, you must use the
    <span class="Li">&quot;scalar&quot;</span> keyword.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
   ($stdout, $stderr, $count) = capture {
     my @list = qw/one two three/;
     return scalar @list; # $count will be 3
   };
</pre>
<p class="Pp">Also note that within the coderef, the <span class="Li">@_</span>
    variable will be empty. So don't use arguments from a surrounding subroutine
    without copying them to an array first:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
   sub wont_work {
     my ($stdout, $stderr) = capture { do_stuff( @_ ) };    # WRONG
     ...
   }
 
   sub will_work {
     my @args = @_;
     my ($stdout, $stderr) = capture { do_stuff( @args ) }; # RIGHT
     ...
   }
</pre>
<p class="Pp">Captures are normally done to an anonymous temporary filehandle.
    To capture via a named file (e.g. to externally monitor a long-running
    capture), provide custom filehandles as a trailing list of option pairs:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
   my $out_fh = IO::File-&gt;new(&quot;out.txt&quot;, &quot;w+&quot;);
   my $err_fh = IO::File-&gt;new(&quot;out.txt&quot;, &quot;w+&quot;);
   capture { ... } stdout =&gt; $out_fh, stderr =&gt; $err_fh;
</pre>
<p class="Pp">The filehandles must be read/write and seekable. Modifying the
    files or filehandles during a capture operation will give unpredictable
    results. Existing IO layers on them may be changed by the capture.</p>
<p class="Pp">When called in void context,
    <span class="Li">&quot;capture&quot;</span> saves memory and time by not
    reading back from the capture handles.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="capture_stdout"><a class="permalink" href="#capture_stdout">capture_stdout</a></h2>
<span class="Li"></span>
<pre>
   ($stdout, @result) = capture_stdout \&amp;code;
   $stdout = capture_stdout \&amp;code;
</pre>
<p class="Pp">The <span class="Li">&quot;capture_stdout&quot;</span> function
    works just like <span class="Li">&quot;capture&quot;</span> except only
    STDOUT is captured. STDERR is not captured.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="capture_stderr"><a class="permalink" href="#capture_stderr">capture_stderr</a></h2>
<span class="Li"></span>
<pre>
   ($stderr, @result) = capture_stderr \&amp;code;
   $stderr = capture_stderr \&amp;code;
</pre>
<p class="Pp">The <span class="Li">&quot;capture_stderr&quot;</span> function
    works just like <span class="Li">&quot;capture&quot;</span> except only
    STDERR is captured. STDOUT is not captured.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="capture_merged"><a class="permalink" href="#capture_merged">capture_merged</a></h2>
<span class="Li"></span>
<pre>
   ($merged, @result) = capture_merged \&amp;code;
   $merged = capture_merged \&amp;code;
</pre>
<p class="Pp">The <span class="Li">&quot;capture_merged&quot;</span> function
    works just like <span class="Li">&quot;capture&quot;</span> except STDOUT
    and STDERR are merged. (Technically, STDERR is redirected to the same
    capturing handle as STDOUT before executing the function.)</p>
<p class="Pp">Caution: STDOUT and STDERR output in the merged result are not
    guaranteed to be properly ordered due to buffering.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="tee"><a class="permalink" href="#tee">tee</a></h2>
<span class="Li"></span>
<pre>
   ($stdout, $stderr, @result) = tee \&amp;code;
   $stdout = tee \&amp;code;
</pre>
<p class="Pp">The <span class="Li">&quot;tee&quot;</span> function works just
    like <span class="Li">&quot;capture&quot;</span>, except that output is
    captured as well as passed on to the original STDOUT and STDERR.</p>
<p class="Pp">When called in void context,
    <span class="Li">&quot;tee&quot;</span> saves memory and time by not reading
    back from the capture handles, except when the original STDOUT OR STDERR
    were tied or opened to a scalar handle.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="tee_stdout"><a class="permalink" href="#tee_stdout">tee_stdout</a></h2>
<span class="Li"></span>
<pre>
   ($stdout, @result) = tee_stdout \&amp;code;
   $stdout = tee_stdout \&amp;code;
</pre>
<p class="Pp">The <span class="Li">&quot;tee_stdout&quot;</span> function works
    just like <span class="Li">&quot;tee&quot;</span> except only STDOUT is
    teed. STDERR is not teed (output goes to STDERR as usual).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="tee_stderr"><a class="permalink" href="#tee_stderr">tee_stderr</a></h2>
<span class="Li"></span>
<pre>
   ($stderr, @result) = tee_stderr \&amp;code;
   $stderr = tee_stderr \&amp;code;
</pre>
<p class="Pp">The <span class="Li">&quot;tee_stderr&quot;</span> function works
    just like <span class="Li">&quot;tee&quot;</span> except only STDERR is
    teed. STDOUT is not teed (output goes to STDOUT as usual).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="tee_merged"><a class="permalink" href="#tee_merged">tee_merged</a></h2>
<span class="Li"></span>
<pre>
   ($merged, @result) = tee_merged \&amp;code;
   $merged = tee_merged \&amp;code;
</pre>
<p class="Pp">The <span class="Li">&quot;tee_merged&quot;</span> function works
    just like <span class="Li">&quot;capture_merged&quot;</span> except that
    output is captured as well as passed on to STDOUT.</p>
<p class="Pp">Caution: STDOUT and STDERR output in the merged result are not
    guaranteed to be properly ordered due to buffering.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="LIMITATIONS"><a class="permalink" href="#LIMITATIONS">LIMITATIONS</a></h1>
<section class="Ss">
<h2 class="Ss" id="Portability"><a class="permalink" href="#Portability">Portability</a></h2>
Portability is a goal, not a guarantee. <span class="Li">&quot;tee&quot;</span>
  requires fork, except on Windows where <span class="Li">&quot;system(1,
  @cmd)&quot;</span> is used instead. Not tested on any particularly esoteric
  platforms yet. See the CPAN Testers Matrix
  &lt;http://matrix.cpantesters.org/?dist=Capture-Tiny&gt; for test result by
  platform.
</section>
<section class="Ss">
<h2 class="Ss" id="PerlIO_layers"><a class="permalink" href="#PerlIO_layers">PerlIO
  layers</a></h2>
Capture::Tiny does it's best to preserve PerlIO layers such as ':utf8' or
  ':crlf' when capturing (only for Perl 5.8.1+) . Layers should be applied to
  STDOUT or STDERR <i>before</i> the call to
  <span class="Li">&quot;capture&quot;</span> or
  <span class="Li">&quot;tee&quot;</span>. This may not work for tied
  filehandles (see below).
</section>
<section class="Ss">
<h2 class="Ss" id="Modifying_filehandles_before_capturing"><a class="permalink" href="#Modifying_filehandles_before_capturing">Modifying
  filehandles before capturing</a></h2>
Generally speaking, you should do little or no manipulation of the standard IO
  filehandles prior to using Capture::Tiny. In particular, closing, reopening,
  localizing or tying standard filehandles prior to capture may cause a variety
  of unexpected, undesirable and/or unreliable behaviors, as described below.
  Capture::Tiny does its best to compensate for these situations, but the
  results may not be what you desire.
<p class="Pp"><b>Closed filehandles</b></p>
<p class="Pp">Capture::Tiny will work even if STDIN, STDOUT or STDERR have been
    previously closed. However, since they will be reopened to capture or tee
    output, any code within the captured block that depends on finding them
    closed will, of course, not find them to be closed. If they started closed,
    Capture::Tiny will close them again when the capture block finishes.</p>
<p class="Pp">Note that this reopening will happen even for STDIN or a
    filehandle not being captured to ensure that the filehandle used for capture
    is not opened to file descriptor 0, as this causes problems on various
    platforms.</p>
<p class="Pp">Prior to Perl 5.12, closed STDIN combined with PERL_UNICODE=D
    leaks filehandles and also breaks <i>tee()</i> for undiagnosed reasons. So
    don't do that.</p>
<p class="Pp"><b>Localized filehandles</b></p>
<p class="Pp">If code localizes any of Perl's standard filehandles before
    capturing, the capture will affect the localized filehandles and not the
    original ones. External system calls are not affected by localizing a
    filehandle in Perl and will continue to send output to the original
    filehandles (which will thus not be captured).</p>
<p class="Pp"><b>Scalar filehandles</b></p>
<p class="Pp">If STDOUT or STDERR are reopened to scalar filehandles prior to
    the call to <span class="Li">&quot;capture&quot;</span> or
    <span class="Li">&quot;tee&quot;</span>, then Capture::Tiny will override
    the output filehandle for the duration of the
    <span class="Li">&quot;capture&quot;</span> or
    <span class="Li">&quot;tee&quot;</span> call and then, for
    <span class="Li">&quot;tee&quot;</span>, send captured output to the output
    filehandle after the capture is complete. (Requires Perl 5.8)</p>
<p class="Pp">Capture::Tiny attempts to preserve the semantics of STDIN opened
    to a scalar reference, but note that external processes will not be able to
    read from such a handle. Capture::Tiny tries to ensure that external
    processes will read from the null device instead, but this is not
    guaranteed.</p>
<p class="Pp"><b>Tied output filehandles</b></p>
<p class="Pp">If STDOUT or STDERR are tied prior to the call to
    <span class="Li">&quot;capture&quot;</span> or
    <span class="Li">&quot;tee&quot;</span>, then Capture::Tiny will attempt to
    override the tie for the duration of the
    <span class="Li">&quot;capture&quot;</span> or
    <span class="Li">&quot;tee&quot;</span> call and then send captured output
    to the tied filehandle after the capture is complete. (Requires Perl
  5.8)</p>
<p class="Pp">Capture::Tiny may not succeed resending UTF-8 encoded data to a
    tied STDOUT or STDERR filehandle. Characters may appear as bytes. If the
    tied filehandle is based on Tie::StdHandle, then Capture::Tiny will attempt
    to determine appropriate layers like
    <span class="Li">&quot;:utf8&quot;</span> from the underlying filehandle and
    do the right thing.</p>
<p class="Pp"><b>Tied input filehandle</b></p>
<p class="Pp">Capture::Tiny attempts to preserve the semantics of tied STDIN,
    but this requires Perl 5.8 and is not entirely predictable. External
    processes will not be able to read from such a handle.</p>
<p class="Pp">Unless having STDIN tied is crucial, it may be safest to localize
    STDIN when capturing:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
   my ($out, $err) = do { local *STDIN; capture { ... } };
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Modifying_filehandles_during_a_capture"><a class="permalink" href="#Modifying_filehandles_during_a_capture">Modifying
  filehandles during a capture</a></h2>
Attempting to modify STDIN, STDOUT or STDERR <i>during</i>
  <span class="Li">&quot;capture&quot;</span> or
  <span class="Li">&quot;tee&quot;</span> is almost certainly going to cause
  problems. Don't do that.
</section>
<section class="Ss">
<h2 class="Ss" id="No_support_for_Perl_5.8.0"><a class="permalink" href="#No_support_for_Perl_5.8.0">No
  support for Perl 5.8.0</a></h2>
It's just too buggy when it comes to layers and UTF-8. Perl 5.8.1 or later is
  recommended.
</section>
<section class="Ss">
<h2 class="Ss" id="Limited_support_for_Perl_5.6"><a class="permalink" href="#Limited_support_for_Perl_5.6">Limited
  support for Perl 5.6</a></h2>
Perl 5.6 predates PerlIO. UTF-8 data may not be captured correctly.
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="ENVIRONMENT"><a class="permalink" href="#ENVIRONMENT">ENVIRONMENT</a></h1>
<section class="Ss">
<h2 class="Ss" id="_s-1PERL_CAPTURE_TINY_TIMEOUT_s0"><a class="permalink" href="#_s-1PERL_CAPTURE_TINY_TIMEOUT_s0">PERL_CAPTURE_TINY_TIMEOUT</a></h2>
Capture::Tiny uses subprocesses for <span class="Li">&quot;tee&quot;</span>. By
  default, Capture::Tiny will timeout with an error if the subprocesses are not
  ready to receive data within 30 seconds (or whatever is the value of
  <span class="Li">$Capture::Tiny::TIMEOUT</span>). An alternate timeout may be
  specified by setting the
  <span class="Li">&quot;PERL_CAPTURE_TINY_TIMEOUT&quot;</span> environment
  variable. Setting it to zero will disable timeouts.
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
This module was, inspired by IO::CaptureOutput, which provides similar
  functionality without the ability to tee output and with more complicated code
  and API. IO::CaptureOutput does not handle layers or most of the unusual cases
  described in the &quot;Limitations&quot; section and I no longer recommend it.
<p class="Pp">There are many other CPAN modules that provide some sort of output
    capture, albeit with various limitations that make them appropriate only in
    particular circumstances. I'm probably missing some. The long list is
    provided to show why I felt Capture::Tiny was necessary.</p>
<ul class="Bl-bullet">
  <li>IO::Capture</li>
  <li>IO::Capture::Extended</li>
  <li>IO::CaptureOutput</li>
  <li>IPC::Capture</li>
  <li>IPC::Cmd</li>
  <li>IPC::Open2</li>
  <li>IPC::Open3</li>
  <li>IPC::Open3::Simple</li>
  <li>IPC::Open3::Utils</li>
  <li>IPC::Run</li>
  <li>IPC::Run::SafeHandles</li>
  <li>IPC::Run::Simple</li>
  <li>IPC::Run3</li>
  <li>IPC::System::Simple</li>
  <li>Tee</li>
  <li>IO::Tee</li>
  <li>File::Tee</li>
  <li>Filter::Handle</li>
  <li>Tie::STDERR</li>
  <li>Tie::STDOUT</li>
  <li>Test::Output</li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="SUPPORT"><a class="permalink" href="#SUPPORT">SUPPORT</a></h1>
<section class="Ss">
<h2 class="Ss" id="Bugs_/_Feature_Requests"><a class="permalink" href="#Bugs_/_Feature_Requests">Bugs
  / Feature Requests</a></h2>
Please report any bugs or feature requests through the issue tracker at
  &lt;https://github.com/dagolden/Capture-Tiny/issues&gt;. You will be notified
  automatically of any progress on your issue.
</section>
<section class="Ss">
<h2 class="Ss" id="Source_Code"><a class="permalink" href="#Source_Code">Source
  Code</a></h2>
This is open source software. The code repository is available for public review
  and contribution under the terms of the license.
<p class="Pp">&lt;https://github.com/dagolden/Capture-Tiny&gt;</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  git clone https://github.com/dagolden/Capture-Tiny.git
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
David Golden &lt;dagolden@cpan.org&gt;
</section>
<section class="Sh">
<h1 class="Sh" id="CONTRIBUTOR"><a class="permalink" href="#CONTRIBUTOR">CONTRIBUTOR</a></h1>
Dagfinn Ilmari Mannsaaker &lt;ilmari@ilmari.org&gt;
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT_AND_LICENSE"><a class="permalink" href="#COPYRIGHT_AND_LICENSE">COPYRIGHT
  AND LICENSE</a></h1>
This software is Copyright (c) 2009 by David Golden.
<p class="Pp">This is free software, licensed under:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  The Apache License, Version 2.0, January 2004
</pre>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2013-10-20</td>
    <td class="foot-os">perl v5.18.4</td>
  </tr>
</table>
</body>
</html>
