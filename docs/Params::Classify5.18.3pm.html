<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    .Nd, .Bf, .Op { display: inline; }
    .Pa, .Ad { font-style: italic; }
    .Ms { font-weight: bold; }
    .Bl-diag > dt { font-weight: bold; }
    code.Nm, .Fl, .Cm, .Ic, code.In, .Fd, .Fn, .Cd { font-weight: bold;
      font-family: inherit; }
  </style>
  <title>Params::Classify(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Params::Classify(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Params::Classify(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Params::Classify - argument type classification</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>    use Params::Classify qw(
        scalar_class
        is_undef check_undef
        is_string check_string
        is_number check_number
        is_glob check_glob
        is_regexp check_regexp
        is_ref check_ref ref_type
        is_blessed check_blessed blessed_class
        is_strictly_blessed check_strictly_blessed
        is_able check_able);
    $c = scalar_class($arg);
    if(is_undef($arg)) {
    check_undef($arg);
    if(is_string($arg)) {
    check_string($arg);
    if(is_number($arg)) {
    check_number($arg);
    if(is_glob($arg)) {
    check_glob($arg);
    if(is_regexp($arg)) {
    check_regexp($arg);
    if(is_ref($arg)) {
    check_ref($arg);
    $t = ref_type($arg);
    if(is_ref($arg, &quot;HASH&quot;)) {
    check_ref($arg, &quot;HASH&quot;);
    if(is_blessed($arg)) {
    check_blessed($arg);
    if(is_blessed($arg, &quot;IO::Handle&quot;)) {
    check_blessed($arg, &quot;IO::Handle&quot;);
    $c = blessed_class($arg);
    if(is_strictly_blessed($arg, &quot;IO::Pipe::End&quot;)) {
    check_strictly_blessed($arg, &quot;IO::Pipe::End&quot;);
    if(is_able($arg, [&quot;print&quot;, &quot;flush&quot;])) {
    check_able($arg, [&quot;print&quot;, &quot;flush&quot;]);
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">This module provides various type-testing functions. These are
    intended for functions that, unlike most Perl code, care what type of data
    they are operating on. For example, some functions wish to behave
    differently depending on the type of their arguments (like overloaded
    functions in C++).</p>
<p class="Pp">There are two flavours of function in this module. Functions of
    the first flavour only provide type classification, to allow code to
    discriminate between argument types. Functions of the second flavour package
    up the most common type of type discrimination: checking that an argument is
    of an expected type. The functions come in matched pairs, of the two
    flavours, and so the type enforcement functions handle only the simplest
    requirements for arguments of the types handled by the classification
    functions. Enforcement of more complex types may, of course, be built using
    the classification functions, or it may be more convenient to use a module
    designed for the more complex job, such as Params::Validate.</p>
<p class="Pp">This module is implemented in XS, with a pure Perl backup version
    for systems that can't handle XS.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="TYPE_CLASSIFICATION"><a class="permalink" href="#TYPE_CLASSIFICATION">TYPE
  CLASSIFICATION</a></h1>
<p class="Pp">This module divides up scalar values into the following
  classes:</p>
<ul class="Bl-bullet">
  <li>undef</li>
  <li>string (defined ordinary scalar)</li>
  <li>typeglob (yes, typeglobs fit into scalar variables)</li>
  <li>regexp (first-class regular expression objects in Perl 5.11 onwards)</li>
  <li>reference to unblessed object (further classified by physical data type of
      the referenced object)</li>
  <li>reference to blessed object (further classified by class blessed
    into)</li>
</ul>
<p class="Pp">These classes are mutually exclusive and should be exhaustive.
    This classification has been chosen as the most useful when one wishes to
    discriminate between types of scalar. Other classifications are possible.
    (For example, the two reference classes are distinguished by a feature of
    the referenced object; Perl does not internally treat this as a feature of
    the reference.)</p>
</section>
<section class="Sh">
<h1 class="Sh" id="FUNCTIONS"><a class="permalink" href="#FUNCTIONS">FUNCTIONS</a></h1>
<p class="Pp">Each of these functions takes one scalar argument (<i>ARG</i>) to
    be tested, possibly with other arguments specifying details of the test. Any
    scalar value is acceptable for the argument to be tested. Each
    <span class="Li">&quot;is_&quot;</span> function returns a simple truth
    value result, which is true iff <i>ARG</i> is of the type being checked for.
    Each <span class="Li">&quot;check_&quot;</span> function will return
    normally if the argument is of the type being checked for, or will
    <span class="Li">&quot;die&quot;</span> if it is not.</p>
<section class="Ss">
<h2 class="Ss" id="Classification"><a class="permalink" href="#Classification">Classification</a></h2>
<dl class="Bl-tag">
  <dt id="scalar_class("><a class="permalink" href="#scalar_class(">scalar_class(ARG)</a></dt>
  <dd>Determines which of the five classes described above <i>ARG</i> falls
      into. Returns &quot;<b>UNDEF</b>&quot;, &quot;<b>STRING</b>&quot;,
      &quot;<b>GLOB</b>&quot;, &quot;<b>REGEXP</b>&quot;,
      &quot;<b>REF</b>&quot;, or &quot;<b>BLESSED</b>&quot; accordingly.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="The_Undefined_Value"><a class="permalink" href="#The_Undefined_Value">The
  Undefined Value</a></h2>
<dl class="Bl-tag">
  <dt id="is_undef("><a class="permalink" href="#is_undef(">is_undef(ARG)</a></dt>
  <dd></dd>
  <dt id="check_undef("><a class="permalink" href="#check_undef(">check_undef(ARG)</a></dt>
  <dd>Check whether <i>ARG</i> is <span class="Li">&quot;undef&quot;</span>.
      <span class="Li">&quot;is_undef(ARG)&quot;</span> is precisely equivalent
      to <span class="Li">&quot;!defined(ARG)&quot;</span>, and is included for
      completeness.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Strings"><a class="permalink" href="#Strings">Strings</a></h2>
<dl class="Bl-tag">
  <dt id="is_string("><a class="permalink" href="#is_string(">is_string(ARG)</a></dt>
  <dd></dd>
  <dt id="check_string("><a class="permalink" href="#check_string(">check_string(ARG)</a></dt>
  <dd>Check whether <i>ARG</i> is defined and is an ordinary scalar value (not a
      reference, typeglob, or regexp). This is what one usually thinks of as a
      string in Perl. In fact, any scalar (including
      <span class="Li">&quot;undef&quot;</span> and references) can be coerced
      to a string, but if you're trying to classify a scalar then you don't want
      to do that.</dd>
  <dt id="is_number("><a class="permalink" href="#is_number(">is_number(ARG)</a></dt>
  <dd></dd>
  <dt id="check_number("><a class="permalink" href="#check_number(">check_number(ARG)</a></dt>
  <dd>Check whether <i>ARG</i> is defined and an ordinary scalar (i.e.,
      satisfies &quot;is_string&quot; above) and is an acceptable number to
      Perl. This is what one usually thinks of as a number.
    <p class="Pp">Note that simple (&quot;is_string&quot;-satisfying) scalars
        may have independent numeric and string values, despite the usual
        pretence that they have only one value. Such a scalar is deemed to be a
        number if <i>either</i> it already has a numeric value (e.g., was
        generated by a numeric literal or an arithmetic computation) <i>or</i>
        its string value has acceptable syntax for a number (so it can be
        converted). Where a scalar has separate numeric and string values (see
        &quot;dualvar&quot; in Scalar::Util), it is possible for it to have an
        acceptable numeric value while its string value does <i>not</i> have
        acceptable numeric syntax. Be careful to use such a value only in a
        numeric context, if you are using it as a number.
        &quot;scalar_num_part&quot; in Scalar::Number extracts the numeric part
        of a scalar as an ordinary number.
        (<span class="Li">&quot;0+ARG&quot;</span> suffices for that unless you
        need to preserve floating point signed zeroes.)</p>
    <p class="Pp">A number may be either a native integer or a native floating
        point value, and there are several subtypes of floating point value. For
        classification, and other handling of numbers in scalars, see
        Scalar::Number. For details of the two numeric data types, see
        Data::Integer and Data::Float.</p>
    <p class="Pp">This function differs from
        <span class="Li">&quot;looks_like_number&quot;</span> (see
        &quot;looks_like_number&quot; in Scalar::Util; also
        &quot;looks_like_number&quot; in perlapi for a lower-level description)
        in excluding <span class="Li">&quot;undef&quot;</span>, typeglobs, and
        references. Why <span class="Li">&quot;looks_like_number&quot;</span>
        returns true for <span class="Li">&quot;undef&quot;</span> or typeglobs
        is anybody's guess. References, if treated as numbers, evaluate to the
        address in memory that they reference; this is useful for comparing
        references for equality, but it is not otherwise useful to treat
        references as numbers. Blessed references may have overloaded numeric
        operators, but if so then they don't necessarily behave like ordinary
        numbers. <span class="Li">&quot;looks_like_number&quot;</span> is also
        confused by dualvars: it looks at the string portion of the scalar.</p>
  </dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Typeglobs"><a class="permalink" href="#Typeglobs">Typeglobs</a></h2>
<dl class="Bl-tag">
  <dt id="is_glob("><a class="permalink" href="#is_glob(">is_glob(ARG)</a></dt>
  <dd></dd>
  <dt id="check_glob("><a class="permalink" href="#check_glob(">check_glob(ARG)</a></dt>
  <dd>Check whether <i>ARG</i> is a typeglob.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Regexps"><a class="permalink" href="#Regexps">Regexps</a></h2>
<dl class="Bl-tag">
  <dt id="is_regexp("><a class="permalink" href="#is_regexp(">is_regexp(ARG)</a></dt>
  <dd></dd>
  <dt id="check_regexp("><a class="permalink" href="#check_regexp(">check_regexp(ARG)</a></dt>
  <dd>Check whether <i>ARG</i> is a regexp object.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="References_to_Unblessed_Objects"><a class="permalink" href="#References_to_Unblessed_Objects">References
  to Unblessed Objects</a></h2>
<dl class="Bl-tag">
  <dt id="is_ref("><a class="permalink" href="#is_ref(">is_ref(ARG)</a></dt>
  <dd></dd>
  <dt id="check_ref("><a class="permalink" href="#check_ref(">check_ref(ARG)</a></dt>
  <dd>Check whether <i>ARG</i> is a reference to an unblessed object. If it is,
      then the referenced data type can be determined using
      <span class="Li">&quot;ref_type&quot;</span> (see below), which will
      return a string such as &quot;HASH&quot; or &quot;SCALAR&quot;.</dd>
  <dt id="ref_type("><a class="permalink" href="#ref_type(">ref_type(ARG)</a></dt>
  <dd>Returns <span class="Li">&quot;undef&quot;</span> if <i>ARG</i> is not a
      reference to an unblessed object. Otherwise, determines what type of
      object is referenced. Returns &quot;<b>SCALAR</b>&quot;,
      &quot;<b>ARRAY</b>&quot;, &quot;<b>HASH</b>&quot;,
      &quot;<b>CODE</b>&quot;, &quot;<b>FORMAT</b>&quot;, or
      &quot;<b>IO</b>&quot; accordingly.
    <p class="Pp">Note that, unlike <span class="Li">&quot;ref&quot;</span>,
        this does not distinguish between different types of referenced scalar.
        A reference to a string and a reference to a reference will both return
        &quot;<b>SCALAR</b>&quot;. Consequently, what
        <span class="Li">&quot;ref_type&quot;</span> returns for a particular
        reference will not change due to changes in the value of the referent,
        except for the referent being blessed.</p>
  </dd>
  <dt id="is_ref(~2"><a class="permalink" href="#is_ref(~2">is_ref(ARG,
    TYPE)</a></dt>
  <dd></dd>
  <dt id="check_ref(~2"><a class="permalink" href="#check_ref(~2">check_ref(ARG,
    TYPE)</a></dt>
  <dd>Check whether <i>ARG</i> is a reference to an unblessed object of type
      <i>TYPE</i>, as determined by &quot;ref_type&quot;. <i>TYPE</i> must be a
      string. Possible <i>TYPE</i>s are &quot;<b>SCALAR</b>&quot;,
      &quot;<b>ARRAY</b>&quot;, &quot;<b>HASH</b>&quot;,
      &quot;<b>CODE</b>&quot;, &quot;<b>FORMAT</b>&quot;, and
      &quot;<b>IO</b>&quot;.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="References_to_Blessed_Objects"><a class="permalink" href="#References_to_Blessed_Objects">References
  to Blessed Objects</a></h2>
<dl class="Bl-tag">
  <dt id="is_blessed("><a class="permalink" href="#is_blessed(">is_blessed(ARG)</a></dt>
  <dd></dd>
  <dt id="check_blessed("><a class="permalink" href="#check_blessed(">check_blessed(ARG)</a></dt>
  <dd>Check whether <i>ARG</i> is a reference to a blessed object. If it is,
      then the class into which the object was blessed can be determined using
      &quot;blessed_class&quot;.</dd>
  <dt id="is_blessed(~2"><a class="permalink" href="#is_blessed(~2">is_blessed(ARG,
    CLASS)</a></dt>
  <dd></dd>
  <dt id="check_blessed(~2"><a class="permalink" href="#check_blessed(~2">check_blessed(ARG,
    CLASS)</a></dt>
  <dd>Check whether <i>ARG</i> is a reference to a blessed object that claims to
      be an instance of <i>CLASS</i> (via its
      <span class="Li">&quot;isa&quot;</span> method; see &quot;isa&quot; in
      perlobj). <i>CLASS</i> must be a string, naming a Perl class.</dd>
  <dt id="blessed_class("><a class="permalink" href="#blessed_class(">blessed_class(ARG)</a></dt>
  <dd>Returns <span class="Li">&quot;undef&quot;</span> if <i>ARG</i> is not a
      reference to a blessed object. Otherwise, returns the class into which the
      object is blessed.
    <p class="Pp"><span class="Li">&quot;ref&quot;</span> (see &quot;ref&quot;
        in perlfunc) gives the same result on references to blessed objects, but
        different results on other types of value.
        <span class="Li">&quot;blessed_class&quot;</span> is actually identical
        to &quot;blessed&quot; in Scalar::Util.</p>
  </dd>
  <dt id="is_strictly_blessed("><a class="permalink" href="#is_strictly_blessed(">is_strictly_blessed(ARG)</a></dt>
  <dd></dd>
  <dt id="check_strictly_blessed("><a class="permalink" href="#check_strictly_blessed(">check_strictly_blessed(ARG)</a></dt>
  <dd>Check whether <i>ARG</i> is a reference to a blessed object, identically
      to &quot;is_blessed&quot;. This exists only for symmetry; the useful form
      of <span class="Li">&quot;is_strictly_blessed&quot;</span> appears
    below.</dd>
  <dt id="is_strictly_blessed(~2"><a class="permalink" href="#is_strictly_blessed(~2">is_strictly_blessed(ARG,
    CLASS)</a></dt>
  <dd></dd>
  <dt id="check_strictly_blessed(~2"><a class="permalink" href="#check_strictly_blessed(~2">check_strictly_blessed(ARG,
    CLASS)</a></dt>
  <dd>Check whether <i>ARG</i> is a reference to an object blessed into
      <i>CLASS</i> exactly. <i>CLASS</i> must be a string, naming a Perl class.
      Because this excludes subclasses, this is rarely what one wants, but there
      are some specialised occasions where it is useful.</dd>
  <dt id="is_able("><a class="permalink" href="#is_able(">is_able(ARG)</a></dt>
  <dd></dd>
  <dt id="check_able("><a class="permalink" href="#check_able(">check_able(ARG)</a></dt>
  <dd>Check whether <i>ARG</i> is a reference to a blessed object, identically
      to &quot;is_blessed&quot;. This exists only for symmetry; the useful form
      of <span class="Li">&quot;is_able&quot;</span> appears below.</dd>
  <dt id="is_able(~2"><a class="permalink" href="#is_able(~2">is_able(ARG,
    METHODS)</a></dt>
  <dd></dd>
  <dt id="check_able(~2"><a class="permalink" href="#check_able(~2">check_able(ARG,
    METHODS)</a></dt>
  <dd>Check whether <i>ARG</i> is a reference to a blessed object that claims to
      implement the methods specified by <i>METHODS</i> (via its
      <span class="Li">&quot;can&quot;</span> method; see &quot;can&quot; in
      perlobj). <i>METHODS</i> must be either a single method name or a
      reference to an array of method names. Each method name is a string. This
      interface check is often more appropriate than a direct ancestry check
      (such as &quot;is_blessed&quot; performs).</dd>
</dl>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="BUGS"><a class="permalink" href="#BUGS">BUGS</a></h1>
<p class="Pp">Probably ought to handle something like Params::Validate's scalar
    type specification system, which makes much the same distinctions.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp">Data::Float, Data::Integer, Params::Validate, Scalar::Number,
    Scalar::Util</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">Andrew Main (Zefram) &lt;zefram@fysh.org&gt;</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT"><a class="permalink" href="#COPYRIGHT">COPYRIGHT</a></h1>
<p class="Pp">Copyright (C) 2004, 2006, 2007, 2009, 2010, 2017 Andrew Main
    (Zefram) &lt;zefram@fysh.org&gt;</p>
<p class="Pp">Copyright (C) 2009, 2010 PhotoBox Ltd</p>
</section>
<section class="Sh">
<h1 class="Sh" id="LICENSE"><a class="permalink" href="#LICENSE">LICENSE</a></h1>
<p class="Pp">This module is free software; you can redistribute it and/or
    modify it under the same terms as Perl itself.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2022-02-12</td>
    <td class="foot-os">perl v5.18.4</td>
  </tr>
</table>
</body>
</html>
