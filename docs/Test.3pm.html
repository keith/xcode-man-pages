<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>Test(3pm)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Test(3pm)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">Test(3pm)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
Test - provides a simple framework for writing test scripts
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<span class="Li"></span>
<pre>
  use strict;
  use Test;

  # use a BEGIN block so we print our plan before MyModule is loaded
  BEGIN { plan tests =&gt; 14, todo =&gt; [3,4] }

  # load your module...
  use MyModule;

  # Helpful notes.  All note-lines must start with a &quot;#&quot;.
  print &quot;# I'm testing MyModule version $MyModule::VERSION\n&quot;;

  ok(0); # failure
  ok(1); # success

  ok(0); # ok, expected failure (see todo list, above)
  ok(1); # surprise success!

  ok(0,1);             # failure: '0' ne '1'
  ok('broke','fixed'); # failure: 'broke' ne 'fixed'
  ok('fixed','fixed'); # success: 'fixed' eq 'fixed'
  ok('fixed',qr/x/);   # success: 'fixed' =~ qr/x/

  ok(sub { 1+1 }, 2);  # success: '2' eq '2'
  ok(sub { 1+1 }, 3);  # failure: '2' ne '3'

  my @list = (0,0);
  ok @list, 3, &quot;\@list=&quot;.join(',',@list);      #extra notes
  ok 'segmentation fault', '/(?i)success/';    #regex match

  skip(
    $^O =~ m/MSWin/ ? &quot;Skip if MSWin&quot; : 0,  # whether to skip
    $foo, $bar  # arguments just like for ok(...)
  );
  skip(
    $^O =~ m/MSWin/ ? 0 : &quot;Skip unless MSWin&quot;,  # whether to skip
    $foo, $bar  # arguments just like for ok(...)
  );
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
This module simplifies the task of writing test files for Perl modules, such
  that their output is in the format that Test::Harness expects to see.
</section>
<section class="Sh">
<h1 class="Sh" id="QUICK_START_GUIDE"><a class="permalink" href="#QUICK_START_GUIDE">QUICK
  START GUIDE</a></h1>
To write a test for your new (and probably not even done) module, create a new
  file called <i>t/test.t</i> (in a new <i>t</i> directory). If you have
  multiple test files, to test the &quot;foo&quot;, &quot;bar&quot;, and
  &quot;baz&quot; feature sets, then feel free to call your files
  <i>t/foo.t</i>, <i>t/bar.t</i>, and <i>t/baz.t</i>
<section class="Ss">
<h2 class="Ss" id="Functions"><a class="permalink" href="#Functions">Functions</a></h2>
This module defines three public functions,
  <span class="Li">&quot;plan(...)&quot;</span>,
  <span class="Li">&quot;ok(...)&quot;</span>, and
  <span class="Li">&quot;skip(...)&quot;</span>. By default, all three are
  exported by the <span class="Li">&quot;use Test;&quot;</span> statement.
<dl class="Bl-tag">
  <dt>&quot;plan(...)&quot;</dt>
  <dd><span class="Li"></span>
    <pre>
     BEGIN { plan %theplan; }
    </pre>
    <p class="Pp">This should be the first thing you call in your test script.
        It declares your testing plan, how many there will be, if any of them
        should be allowed to fail, and so on.</p>
    <p class="Pp">Typical usage is just:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
     use Test;
     BEGIN { plan tests =&gt; 23 }
    </pre>
    <p class="Pp">These are the things that you can put in the parameters to
        plan:</p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>&quot;tests =&gt; <i>number</i><span class="Li">&quot;</span></dt>
  <dd>The number of tests in your script. This means all <i>ok()</i> and
      <i>skip()</i> calls.</dd>
  <dt>&quot;todo =&gt; [<i>1,5,14</i><span class="Li">]&quot;</span></dt>
  <dd>A reference to a list of tests which are allowed to fail. See &quot;TODO
      TESTS&quot;.</dd>
  <dt>&quot;onfail =&gt; sub { ... }&quot;</dt>
  <dd></dd>
  <dt>&quot;onfail =&gt; \&amp;some_sub&quot;</dt>
  <dd>A subroutine reference to be run at the end of the test script, if any of
      the tests fail. See &quot;ONFAIL&quot;.</dd>
</dl>
</div>
<div class="Bd-indent">
<p class="Pp">You must call <span class="Li">&quot;plan(...)&quot;</span> once
    and only once. You should call it in a <span class="Li">&quot;BEGIN
    {...}&quot;</span> block, like so:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
     BEGIN { plan tests =&gt; 23 }
</pre>
</div>
<dl class="Bl-tag">
  <dt>&quot;ok(...)&quot;</dt>
  <dd><span class="Li"></span>
    <pre>
  ok(1 + 1 == 2);
  ok($have, $expect);
  ok($have, $expect, $diagnostics);
    </pre>
    <p class="Pp">This function is the reason for
        <span class="Li">&quot;Test&quot;</span>'s existence. It's the basic
        function that handles printing
        &quot;<span class="Li">&quot;ok&quot;</span>&quot; or
        &quot;<span class="Li">&quot;not ok&quot;</span>&quot;, along with the
        current test number. (That's what
        <span class="Li">&quot;Test::Harness&quot;</span> wants to see.)</p>
    <p class="Pp">In its most basic usage,
        <span class="Li">&quot;ok(...)&quot;</span> simply takes a single scalar
        expression. If its value is true, the test passes; if false, the test
        fails. Examples:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    # Examples of ok(scalar)

    ok( 1 + 1 == 2 );           # ok if 1 + 1 == 2
    ok( $foo =~ /bar/ );        # ok if $foo contains 'bar'
    ok( baz($x + $y) eq 'Armondo' );    # ok if baz($x + $y) returns
                                        # 'Armondo'
    ok( @a == @b );             # ok if @a and @b are the same length
    </pre>
    <p class="Pp">The expression is evaluated in scalar context. So the
        following will work:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    ok( @stuff );                       # ok if @stuff has any elements
    ok( !grep !defined $_, @stuff );    # ok if everything in @stuff is
                                        # defined.
    </pre>
    <p class="Pp">A special case is if the expression is a subroutine reference
        (in either <span class="Li">&quot;sub {...}&quot;</span> syntax or
        <span class="Li">&quot;\&amp;foo&quot;</span> syntax). In that case, it
        is executed and its value (true or false) determines if the test passes
        or fails. For example,</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    ok( sub {   # See whether sleep works at least passably
      my $start_time = time;
      sleep 5;
      time() - $start_time  &gt;= 4
    });
    </pre>
    <p class="Pp">In its two-argument form,
        <span class="Li">&quot;ok(</span><i>arg1</i><span class="Li">,
        </span><i>arg2</i><span class="Li">)&quot;</span> compares the two
        scalar values to see if they match. They match if both are undefined, or
        if <i>arg2</i> is a regex that matches <i>arg1</i>, or if they compare
        equal with <span class="Li">&quot;eq&quot;</span>.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    # Example of ok(scalar, scalar)

    ok( &quot;this&quot;, &quot;that&quot; );               # not ok, 'this' ne 'that'
    ok( &quot;&quot;, undef );                    # not ok, &quot;&quot; is defined
    </pre>
    <p class="Pp">The second argument is considered a regex if it is either a
        regex object or a string that looks like a regex. Regex objects are
        constructed with the qr// operator in recent versions of perl. A string
        is considered to look like a regex if its first and last characters are
        &quot;/&quot;, or if the first character is &quot;m&quot; and its second
        and last characters are both the same non-alphanumeric non-whitespace
        character. These regexp</p>
    <p class="Pp">Regex examples:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    ok( 'JaffO', '/Jaff/' );    # ok, 'JaffO' =~ /Jaff/
    ok( 'JaffO', 'm|Jaff|' );   # ok, 'JaffO' =~ m|Jaff|
    ok( 'JaffO', qr/Jaff/ );    # ok, 'JaffO' =~ qr/Jaff/;
    ok( 'JaffO', '/(?i)jaff/ ); # ok, 'JaffO' =~ /jaff/i;
    </pre>
    <p class="Pp">If either (or both!) is a subroutine reference, it is run and
        used as the value for comparing. For example:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    ok sub {
        open(OUT, &quot;&gt;x.dat&quot;) || die $!;
        print OUT &quot;\x{e000}&quot;;
        close OUT;
        my $bytecount = -s 'x.dat';
        unlink 'x.dat' or warn &quot;Can't unlink : $!&quot;;
        return $bytecount;
      },
      4
    ;
    </pre>
    <p class="Pp">The above test passes two values to
        <span class="Li">&quot;ok(arg1, arg2)&quot;</span> -- the first a
        coderef, and the second is the number 4. Before
        <span class="Li">&quot;ok&quot;</span> compares them, it calls the
        coderef, and uses its return value as the real value of this parameter.
        Assuming that <span class="Li">$bytecount</span> returns 4,
        <span class="Li">&quot;ok&quot;</span> ends up testing
        <span class="Li">&quot;4 eq 4&quot;</span>. Since that's true, this test
        passes.</p>
    <p class="Pp">Finally, you can append an optional third argument, in
        <span class="Li">&quot;ok(</span><i>arg1</i><span class="Li">,</span><i>arg2</i><span class="Li">,
        </span> <i>note</i><span class="Li">)&quot;</span>, where <i>note</i> is
        a string value that will be printed if the test fails. This should be
        some useful information about the test, pertaining to why it failed,
        and/or a description of the test. For example:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    ok( grep($_ eq 'something unique', @stuff), 1,
        &quot;Something that should be unique isn't!\n&quot;.
        '@stuff = '.join ', ', @stuff
      );
    </pre>
    <p class="Pp">Unfortunately, a note cannot be used with the single argument
        style of <span class="Li">&quot;ok()&quot;</span>. That is, if you try
        <span class="Li">&quot;ok(</span><i>arg1</i><span class="Li">,
        </span><i>note</i><span class="Li">)&quot;</span>, then
        <span class="Li">&quot;Test&quot;</span> will interpret this as
        <span class="Li">&quot;ok(</span><i>arg1</i><span class="Li">,
        </span><i>arg2</i><span class="Li">)&quot;</span>, and probably end up
        testing <span class="Li">&quot;</span><i>arg1</i><span class="Li"> eq
        </span> <i>arg2</i><span class="Li">&quot;</span> -- and that's not what
        you want!</p>
    <p class="Pp">All of the above special cases can occasionally cause some
        problems. See &quot;BUGS and CAVEATS&quot;.</p>
  </dd>
  <dt>&quot;skip(<i>skip_if_true</i><span class="Li">,
    </span><i>args...</i><span class="Li">)&quot;</span></dt>
  <dd>This is used for tests that under some conditions can be skipped. It's
      basically equivalent to:
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  if( $skip_if_true ) {
    ok(1);
  } else {
    ok( args... );
  }
    </pre>
    <p class="Pp">...except that the <span class="Li">ok(1)</span> emits not
        just &quot;<span class="Li">&quot;ok
        </span><i>testnum</i><span class="Li">&quot;</span>&quot; but actually
        &quot;<span class="Li">&quot;ok </span><i>testnum</i><span class="Li"> #
        </span>
      <i>skip_if_true_value</i><span class="Li">&quot;</span>&quot;.</p>
    <p class="Pp">The arguments after the <i>skip_if_true</i> are what is fed to
        <span class="Li">&quot;ok(...)&quot;</span> if this test isn't
      skipped.</p>
    <p class="Pp">Example usage:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  my $if_MSWin =
    $^O =~ m/MSWin/ ? 'Skip if under MSWin' : '';

  # A test to be skipped if under MSWin (i.e., run except under MSWin)
  skip($if_MSWin, thing($foo), thing($bar) );
    </pre>
    <p class="Pp">Or, going the other way:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  my $unless_MSWin =
    $^O =~ m/MSWin/ ? '' : 'Skip unless under MSWin';

  # A test to be skipped unless under MSWin (i.e., run only under MSWin)
  skip($unless_MSWin, thing($foo), thing($bar) );
    </pre>
    <p class="Pp">The tricky thing to remember is that the first parameter is
        true if you want to <i>skip</i> the test, not <i>run</i> it; and it also
        doubles as a note about why it's being skipped. So in the first
        codeblock above, read the code as &quot;skip if MSWin -- (otherwise)
        test whether <span class="Li">&quot;thing($foo)&quot;</span> is
        <span class="Li">&quot;thing($bar)&quot;</span>&quot; or for the second
        case, &quot;skip unless MSWin...&quot;.</p>
    <p class="Pp">Also, when your <i>skip_if_reason</i> string is true, it
        really should (for backwards compatibility with older Test.pm versions)
        start with the string &quot;Skip&quot;, as shown in the above
      examples.</p>
    <p class="Pp">Note that in the above cases,
        <span class="Li">&quot;thing($foo)&quot;</span> and
        <span class="Li">&quot;thing($bar)&quot;</span> <i>are</i> evaluated --
        but as long as the <span class="Li">&quot;skip_if_true&quot;</span> is
        true, then we <span class="Li">&quot;skip(...)&quot;</span> just tosses
        out their value (i.e., not bothering to treat them like values to
        <span class="Li">&quot;ok(...)&quot;</span>. But if you need to
        <i>not</i> eval the arguments when skipping the test, use this
      format:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  skip( $unless_MSWin,
    sub {
      # This code returns true if the test passes.
      # (But it doesn't even get called if the test is skipped.)
      thing($foo) eq thing($bar)
    }
  );
    </pre>
    <p class="Pp">or even this, which is basically equivalent:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  skip( $unless_MSWin,
    sub { thing($foo) }, sub { thing($bar) }
  );
    </pre>
    <p class="Pp">That is, both are like this:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  if( $unless_MSWin ) {
    ok(1);  # but it actually appends &quot;# $unless_MSWin&quot;
            #  so that Test::Harness can tell it's a skip
  } else {
    # Not skipping, so actually call and evaluate...
    ok( sub { thing($foo) }, sub { thing($bar) } );
  }
    </pre>
  </dd>
</dl>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="TEST_TYPES"><a class="permalink" href="#TEST_TYPES">TEST
  TYPES</a></h1>
<ul class="Bl-bullet">
  <li>NORMAL TESTS
    <p class="Pp">These tests are expected to succeed. Usually, most or all of
        your tests are in this category. If a normal test doesn't succeed, then
        that means that something is <i>wrong</i>.</p>
  </li>
  <li>SKIPPED TESTS
    <p class="Pp">The <span class="Li">&quot;skip(...)&quot;</span> function is
        for tests that might or might not be possible to run, depending on the
        availability of platform-specific features. The first argument should
        evaluate to true (think &quot;yes, please skip&quot;) if the required
        feature is <i>not</i> available. After the first argument,
        <span class="Li">&quot;skip(...)&quot;</span> works exactly the same way
        as <span class="Li">&quot;ok(...)&quot;</span> does.</p>
  </li>
  <li>TODO TESTS
    <p class="Pp">TODO tests are designed for maintaining an <b>executable TODO
        list</b>. These tests are <i>expected to fail.</i> If a TODO test does
        succeed, then the feature in question shouldn't be on the TODO list, now
        should it?</p>
    <p class="Pp">Packages should NOT be released with succeeding TODO tests. As
        soon as a TODO test starts working, it should be promoted to a normal
        test, and the newly working feature should be documented in the release
        notes or in the change log.</p>
  </li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="ONFAIL"><a class="permalink" href="#ONFAIL">ONFAIL</a></h1>
<span class="Li"></span>
<pre>
  BEGIN { plan test =&gt; 4, onfail =&gt; sub { warn &quot;CALL 911!&quot; } }
</pre>
<p class="Pp">Although test failures should be enough, extra diagnostics can be
    triggered at the end of a test run.
    <span class="Li">&quot;onfail&quot;</span> is passed an array ref of hash
    refs that describe each test failure. Each hash will contain at least the
    following fields: <span class="Li">&quot;package&quot;</span>,
    <span class="Li">&quot;repetition&quot;</span>, and
    <span class="Li">&quot;result&quot;</span>. (You shouldn't rely on any other
    fields being present.) If the test had an expected value or a diagnostic (or
    &quot;note&quot;) string, these will also be included.</p>
<p class="Pp">The <i>optional</i> <span class="Li">&quot;onfail&quot;</span>
    hook might be used simply to print out the version of your package and/or
    how to report problems. It might also be used to generate extremely
    sophisticated diagnostics for a particularly bizarre test failure. However
    it's not a panacea. Core dumps or other unrecoverable errors prevent the
    <span class="Li">&quot;onfail&quot;</span> hook from running. (It is run
    inside an <span class="Li">&quot;END&quot;</span> block.) Besides,
    <span class="Li">&quot;onfail&quot;</span> is probably over-kill in most
    cases. (Your test code should be simpler than the code it is testing,
  yes?)</p>
</section>
<section class="Sh">
<h1 class="Sh" id="BUGS_and_CAVEATS"><a class="permalink" href="#BUGS_and_CAVEATS">BUGS
  and CAVEATS</a></h1>
<ul class="Bl-bullet">
  <li><span class="Li">&quot;ok(...)&quot;</span>'s special handing of strings
      which look like they might be regexes can also cause unexpected behavior.
      An innocent:
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    ok( $fileglob, '/path/to/some/*stuff/' );
    </pre>
    <p class="Pp">will fail, since Test.pm considers the second argument to be a
        regex! The best bet is to use the one-argument form:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    ok( $fileglob eq '/path/to/some/*stuff/' );
    </pre>
  </li>
  <li><span class="Li">&quot;ok(...)&quot;</span>'s use of string
      <span class="Li">&quot;eq&quot;</span> can sometimes cause odd problems
      when comparing numbers, especially if you're casting a string to a number:
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    $foo = &quot;1.0&quot;;
    ok( $foo, 1 );      # not ok, &quot;1.0&quot; ne 1
    </pre>
    <p class="Pp">Your best bet is to use the single argument form:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    ok( $foo == 1 );    # ok &quot;1.0&quot; == 1
    </pre>
  </li>
  <li>As you may have inferred from the above documentation and examples,
      <span class="Li">&quot;ok&quot;</span>'s prototype is
      <span class="Li">&quot;($;$$)&quot;</span> (and, incidentally,
      <span class="Li">&quot;skip&quot;</span>'s is
      <span class="Li">&quot;($;$$$)&quot;</span>). This means, for example,
      that you can do <span class="Li">&quot;ok @foo, @bar&quot;</span> to
      compare the <i>size</i> of the two arrays. But don't be fooled into
      thinking that <span class="Li">&quot;ok @foo, @bar&quot;</span> means a
      comparison of the contents of two arrays -- you're comparing <i>just</i>
      the number of elements of each. It's so easy to make that mistake in
      reading <span class="Li">&quot;ok @foo, @bar&quot;</span> that you might
      want to be very explicit about it, and instead write
      <span class="Li">&quot;ok scalar(@foo),</span>
      <span class="Li">scalar(@bar)&quot;</span>.</li>
  <li>This almost definitely doesn't do what you expect:
    <p class="Pp"><span class="Li"></span></p>
    <pre>
     ok $thingy-&gt;can('some_method');
    </pre>
    <p class="Pp">Why? Because <span class="Li">&quot;can&quot;</span> returns a
        coderef to mean &quot;yes it can (and the method is this...)&quot;, and
        then <span class="Li">&quot;ok&quot;</span> sees a coderef and thinks
        you're passing a function that you want it to call and consider the
        truth of the result of! I.e., just like:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
     ok $thingy-&gt;can('some_method')-&gt;();
    </pre>
    <p class="Pp">What you probably want instead is this:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
     ok $thingy-&gt;can('some_method') &amp;&amp; 1;
    </pre>
    <p class="Pp">If the <span class="Li">&quot;can&quot;</span> returns false,
        then that is passed to <span class="Li">&quot;ok&quot;</span>. If it
        returns true, then the larger expression
        <span class="Li">&quot;$thingy-&gt;can('some_method')&#x00A0;&amp;&amp;&#x00A0;1&quot;</span>
        returns 1, which <span class="Li">&quot;ok&quot;</span> sees as a simple
        signal of success, as you would expect.</p>
  </li>
  <li>The syntax for <span class="Li">&quot;skip&quot;</span> is about the only
      way it can be, but it's still quite confusing. Just start with the above
      examples and you'll be okay.
    <p class="Pp">Moreover, users may expect this:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  skip $unless_mswin, foo($bar), baz($quux);
    </pre>
    <p class="Pp">to not evaluate <span class="Li">&quot;foo($bar)&quot;</span>
        and <span class="Li">&quot;baz($quux)&quot;</span> when the test is
        being skipped. But in reality, they <i>are</i> evaluated, but
        <span class="Li">&quot;skip&quot;</span> just won't bother comparing
        them if <span class="Li">$unless_mswin</span> is true.</p>
    <p class="Pp">You could do this:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  skip $unless_mswin, sub{foo($bar)}, sub{baz($quux)};
    </pre>
    <p class="Pp">But that's not terribly pretty. You may find it simpler or
        clearer in the long run to just do things like this:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  if( $^O =~ m/MSWin/ ) {
    print &quot;# Yay, we're under $^O\n&quot;;
    ok foo($bar), baz($quux);
    ok thing($whatever), baz($stuff);
    ok blorp($quux, $whatever);
    ok foo($barzbarz), thang($quux);
  } else {
    print &quot;# Feh, we're under $^O.  Watch me skip some tests...\n&quot;;
    for(1 .. 4) { skip &quot;Skip unless under MSWin&quot; }
  }
    </pre>
    <p class="Pp">But be quite sure that <span class="Li">&quot;ok&quot;</span>
        is called exactly as many times in the first block as
        <span class="Li">&quot;skip&quot;</span> is called in the second
      block.</p>
  </li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="ENVIRONMENT"><a class="permalink" href="#ENVIRONMENT">ENVIRONMENT</a></h1>
If <span class="Li">&quot;PERL_TEST_DIFF&quot;</span> environment variable is
  set, it will be used as a command for comparing unexpected multiline results.
  If you have GNU diff installed, you might want to set
  <span class="Li">&quot;PERL_TEST_DIFF&quot;</span> to
  <span class="Li">&quot;diff -u&quot;</span>. If you don't have a suitable
  program, you might install the <span class="Li">&quot;Text::Diff&quot;</span>
  module and then set <span class="Li">&quot;PERL_TEST_DIFF&quot;</span> to be
  <span class="Li">&quot;perl</span> <span class="Li">-MText::Diff -e 'print
  diff(@ARGV)'&quot;</span>. If
  <span class="Li">&quot;PERL_TEST_DIFF&quot;</span> isn't set but the
  <span class="Li">&quot;Algorithm::Diff&quot;</span> module is available, then
  it will be used to show the differences in multiline results.
</section>
<section class="Sh">
<h1 class="Sh" id="NOTE"><a class="permalink" href="#NOTE">NOTE</a></h1>
A past developer of this module once said that it was no longer being actively
  developed. However, rumors of its demise were greatly exaggerated. Feedback
  and suggestions are quite welcome.
<p class="Pp">Be aware that the main value of this module is its simplicity.
    Note that there are already more ambitious modules out there, such as
    Test::More and Test::Unit.</p>
<p class="Pp">Some earlier versions of this module had docs with some confusing
    typos in the description of
  <span class="Li">&quot;skip(...)&quot;</span>.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
Test::Harness
<p class="Pp">Test::Simple, Test::More, Devel::Cover</p>
<p class="Pp">Test::Builder for building your own testing library.</p>
<p class="Pp">Test::Unit is an interesting XUnit-style testing library.</p>
<p class="Pp">Test::Inline and SelfTest let you embed tests in code.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
Copyright (c) 1998-2000 Joshua Nathaniel Pritikin.
<p class="Pp">Copyright (c) 2001-2002 Michael G. Schwern.</p>
<p class="Pp">Copyright (c) 2002-2004 Sean M. Burke.</p>
<p class="Pp">Current maintainer: Jesse Vincent.
  &lt;jesse@bestpractical.com&gt;</p>
<p class="Pp">This package is free software and is provided &quot;as is&quot;
    without express or implied warranty. It may be used, redistributed and/or
    modified under the same terms as Perl itself.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2014-01-31</td>
    <td class="foot-os">perl v5.18.4</td>
  </tr>
</table>
</body>
</html>
