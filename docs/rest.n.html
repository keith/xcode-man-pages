<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   The definitions below are for supplemental macros used in Tcl/Tk
   manual entries.
  
   .AP type name in/out ?indent?
  	Start paragraph describing an argument to a library procedure.
  	type is type of argument (int, etc.), in/out is either "in", "out",
  	or "in/out" to describe whether procedure reads or modifies arg,
  	and indent is equivalent to second arg of .IP (shouldn't ever be
  	needed;  use .AS below instead)
  
   .AS ?type? ?name?
  	Give maximum sizes of arguments for setting tab stops.  Type and
  	name are examples of largest possible arguments that will be passed
  	to .AP later.  If args are omitted, default tab stops are used.
  
   .BS
  	Start box enclosure.  From here until next .BE, everything will be
  	enclosed in one large box.
  
   .BE
  	End of box enclosure.
  
   .CS
  	Begin code excerpt.
  
   .CE
  	End code excerpt.
  
   .VS ?version? ?br?
  	Begin vertical sidebar, for use in marking newly-changed parts
  	of man pages.  The first argument is ignored and used for recording
  	the version when the .VS was added, so that the sidebars can be
  	found and removed when they reach a certain age.  If another argument
  	is present, then a line break is forced before starting the sidebar.
  
   .VE
  	End of vertical sidebar.
  
   .DS
  	Begin an indented unfilled display.
  
   .DE
  	End of indented unfilled display.
  
   .SO
  	Start of list of standard options for a Tk widget.  The
  	options follow on successive lines, in four columns separated
  	by tabs.
  
   .SE
  	End of list of standard options for a Tk widget.
  
   .OP cmdName dbName dbClass
  	Start of description of a specific option.  cmdName gives the
  	option's name as specified in the class command, dbName gives
  	the option's name in the option database, and dbClass gives
  	the option's class in the option database.
  
   .UL arg1 arg2
  	Print arg1 underlined, then print arg2 normally.
  
   RCS: @(#) $Id: man.macros,v 1.1 2009/01/30 04:56:47 andreas_kupries Exp $
  
  	# Set up traps and other miscellaneous stuff for Tcl/Tk man pages.
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    .Nd, .Bf, .Op { display: inline; }
    .Pa, .Ad { font-style: italic; }
    .Ms { font-weight: bold; }
    .Bl-diag > dt { font-weight: bold; }
    code.Nm, .Fl, .Cm, .Ic, code.In, .Fd, .Fn, .Cd { font-weight: bold;
      font-family: inherit; }
  </style>
  <title>rest(n)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">rest(n)</td>
    <td class="head-vol">A framework for RESTful web services</td>
    <td class="head-rtitle">rest(n)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<pre>
</pre>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">rest - define REST web APIs and call them inline or
  asychronously</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<p class="Pp">package require <b>Tcl 8.5</b></p>
<p class="Pp">package require <b>rest ?1.0?</b></p>
<p class="Pp"><b>::rest::simple</b> <i>url</i> <i>query</i> ?config? ?body?</p>
<p class="Pp"><b>::rest::get</b> <i>url</i> <i>query</i> ?config? ?body?</p>
<p class="Pp"><b>::rest::post</b> <i>url</i> <i>query</i> ?config? ?body?</p>
<p class="Pp"><b>::rest::head</b> <i>url</i> <i>query</i> ?config? ?body?</p>
<p class="Pp"><b>::rest::put</b> <i>url</i> <i>query</i> ?config? ?body?</p>
<p class="Pp"><b>::rest::delete</b> <i>url</i> <i>query</i> ?config? ?body?</p>
<p class="Pp"><b>::rest::save</b> <i>name</i> <i>file</i></p>
<p class="Pp"><b>::rest::describe</b> <i>name</i></p>
<p class="Pp"><b>::rest::parameters</b> <i>url</i> ?args?</p>
<p class="Pp"><b>::rest::parse_opts</b> <i>static</i> <i>required</i>
    <i>optional</i> <i>string</i></p>
<p class="Pp"><b>::rest::substitute</b> <i>string</i> ?var?</p>
<p class="Pp"><b>::rest::create_interface</b> <i>name</i></p>
<p class="Pp">describe</p>
<p class="Pp">uplevel token token</p>
<p class="Pp">upvar body body</p>
<p class="Pp">uplevel token token</p>
<p class="Pp">uplevel token token</p>
<p class="Pp"></p>
<pre>
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">There are 2 types of usage this package supports: simple calls,
    and complete interfaces. In an interface you specify a set of rules and then
    the package builds commands which correspond to the REST methods. These
    commands can have many options such as input and output transformations and
    data type specific formatting. This results in a cleaner and simpler script.
    On the other hand, a simple call is easier and quicker to implement but less
    featureful. It takes the url and a few options on the command and returns
    the result directly. Any formatting or checking is up to rest of the script.
    Simple usage In simple usage you make calls using http method procedures and
    then check or process the returned data yourself</p>
<dl class="Bl-tag">
  <dt><b>::rest::simple</b> <i>url</i> <i>query</i> ?config? ?body?</dt>
  <dd></dd>
  <dt><b>::rest::get</b> <i>url</i> <i>query</i> ?config? ?body?</dt>
  <dd></dd>
  <dt><b>::rest::post</b> <i>url</i> <i>query</i> ?config? ?body?</dt>
  <dd></dd>
  <dt><b>::rest::head</b> <i>url</i> <i>query</i> ?config? ?body?</dt>
  <dd></dd>
  <dt><b>::rest::put</b> <i>url</i> <i>query</i> ?config? ?body?</dt>
  <dd></dd>
  <dt><b>::rest::delete</b> <i>url</i> <i>query</i> ?config? ?body?</dt>
  <dd></dd>
</dl>
<p class="Pp">The above commands are all equivalent except for the http method
    used. If you use <b>simple</b> then the method should be specified as an
    option in the ?config? dict, otherwise it defaults to <b>get</b>. If a body
    is needed then the config dict must be present, however it may be empty.</p>
<pre>
<br/>
    set appid APPID
<br/>
    set search tcl
<br/>
    set res [rest::get http://boss.yahooapis.com/ysearch/web/v1/$search [list appid $appid]]
<br/>
    set res [rest::format_json $res]
</pre>
<pre>
<br/>
    set res [rest::simple http://twitter.com/statuses/update.json  [list status $text]  {
<br/>
          method post
<br/>
          auth {basic user password}
<br/>
          format json
<br/>
        }
<br/>
    ]
</pre>
the options supported in the config dict are as follows headers cookie auth
  format method content-type Interface usage An interface to a REST API consists
  of a series of definitions of REST calls contained in an array. The array name
  becomes a namespace containing the defined commands. Each array element
  defines the name of the call and takes the form of a dict, aka key/value
  pairs. These keys are the defined configuration options below. After creating
  the definitions simply call rest::create_interface on the array to create the
  commands.
<pre>
package require rest
set yweather(forecast) {
<br/>
   url http://weather.yahooapis.com/forecastrss
<br/>
   req_args { p: }
<br/>
   opt_args { u: }
}
rest::create_interface yweather
puts [yweather::forecast -p 94089]
</pre>
::${name}::basic_auth <i>u</i> <i>p</i> ::${name}::set_static_args ?args?]
<dl class="Bl-tag">
  <dt><b>::rest::save</b> <i>name</i> <i>file</i></dt>
  <dd>saves a copy of the dynamically created procs to a file for later
    loading</dd>
  <dt><b>::rest::describe</b> <i>name</i></dt>
  <dd>print a description of defined api calls</dd>
  <dt><b>::rest::parameters</b> <i>url</i> ?args?</dt>
  <dd>parse a url query string into a dict</dd>
  <dt><b>::rest::parse_opts</b> <i>static</i> <i>required</i> <i>optional</i>
    <i>string</i></dt>
  <dd></dd>
  <dt><b>::rest::substitute</b> <i>string</i> ?var?</dt>
  <dd>take a string and substitute real values for any option identifiers</dd>
  <dt><b>::rest::create_interface</b> <i>name</i></dt>
  <dd>TOKENS the value is substituted into the url at call time. tokens in the
      form of %name:default_value% will be an optional argument with a default
      value. url the target of the http request description a string which
      describes the call. used only for</dd>
  <dt id="describe"><a class="permalink" href="#describe">describe</a></dt>
  <dd>body indicates if arguments are required for the request body or not.
      should be one of none, optional, required, argument or mime_multipart.
      default is optional. if <b>argument</b> is used then the option is parsed
      as a list where the second value is the name of a option. the body will
      then be used as the value for that option. if the value is
      <b>mime_multipart</b> then the body is required and interpreted as each
      argument representing one part of a mime multipart document. each argument
      should be a 2 item list with the first being a list of header keys and
      values, and the second being the mime part body.
    <pre>
set ygeo(parse) {
<br/>
    url http://wherein.yahooapis.com/v1/document
<br/>
    method post
<br/>
    body { arg documentContent }
}
ygeo::parse &quot;san jose ca&quot;
# &quot;san jose ca&quot; will be interpreted as if it were specified as the -documentContent option
    </pre>
    <pre>
set gdocs(upload) {
<br/>
    url http://docs.google.com/feeds/default/private/full
<br/>
    body mime_multipart
}
gdocs::upload [list {Content-Type application/atom+xml} $xml] [list {Content-Type image/jpeg} $filedata]
    </pre>
    method The HTTP method to call on the url. The default is GET. copy this
      copies the definition of a previously defined call. after copying you can
      override selected options by defining them again. unset removes the named
      option. useful when using copy of another definition. headers the value
      must be another dict containing header fields and their values. The
      default is to not add any additional headers. content-type Specifies the
      content type for the request data. req_args a list of the required
      arguments. names ending in a colon will require a value. opt_args
      arguments that may be present but are not required. static_args arguments
      that are always the same. no sense in troubling the user with these. A
      leading - is allowed but not required to maintain consistancy with the
      command line. auth should be one of basic or sign. if basic is used you
      can configure basic auth with the proc auth_basic which takes 2 arguments,
      the username and password. if sign is specified then the value must be a
      list with the second element being the name of a proc which will be called
      to perform the request signing.
    <pre>
set delicious(updated) {
<br/>
    url https://api.del.icio.us/v1/posts/update
<br/>
    auth basic
}
rest::create_interface flickr
flickr::basic_auth username password
    </pre>
    <pre>
set flickr(auth.getToken) {
<br/>
   url http://api.flickr.com/services/rest/
<br/>
   req_args { api_key: secret: }
<br/>
   auth { sign do_signature }
}
rest::create_interface flickr
proc ::flickr::do_signature {query} {
<br/>
    # perform some operations on the query here
<br/>
    return $query
}
    </pre>
    callback If this option is present then the method will be created as an
      async call. An async call will return immediately with the value of the
      http token. The event loop must be active to use this option. The value of
      this option is the name of a proc which is invoked when the HTTP call is
      complete. The proc receives three arguments, the name of the calling
      procedure, the status of the result (one of OK or ERROR), and the data
      associated with the result. the http request header is available via</dd>
  <dt id="uplevel"><a class="permalink" href="#uplevel">uplevel token
    token</a></dt>
  <dd>cookie a list of cookies to be passed in the http header. this is just a
      shortcut to the headers option input_transform commands which take the
      variable $query and transform it in some manner before returning a new
      value. return value must be a dict which will be passed to
      http::formatQuery the request body is accessible via</dd>
  <dt id="upvar"><a class="permalink" href="#upvar">upvar body body</a></dt>
  <dd>format or result defines the format of the returned data. should be one of
      discard, raw, json, xml, or tdom. the default is auto which should auto
      detect between xml and json. rss is formated as a special case of xml.
      pre_transform this value takes the form of a proc which should perform
      some action on $result and return a value. it is run on the result before
      the output (xml/json/etc) transformation is done. the http request header
      is available via</dd>
  <dt id="uplevel~2"><a class="permalink" href="#uplevel~2">uplevel token
    token</a></dt>
  <dd>result may have the value xml, json, tdom, raw, or auto. the default is
      auto and should auto detect json or xml results and transform them into a
      tcl list. this is here if you want to specify it explicitly.
      post_transform this value takes the form of a proc which should perform
      some action on $result and return a value. it is run on the result after
      the output transformation but before returning the value to the calling
      procedure. the http request header is available via</dd>
  <dt id="uplevel~3"><a class="permalink" href="#uplevel~3">uplevel token
    token</a></dt>
  <dd>check_result this value should be a list of 2 expressions either of which
      may be empty. the first expression is checks the OK condition, it must
      return true when the result is satisfactory. the second expression is the
      error condition, it must return false unless there is an error.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="INCLUDED"><a class="permalink" href="#INCLUDED">INCLUDED</a></h1>
<p class="Pp">functional but incomplete implementations are included for the
    following services: flickr twitter yahoo boss yahoo weather google calendar
    facebook del.icio.us read the file or source it and use <b>describe</b> for
    more information. also see the developers documentation on the respective
    sites.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">1.0</td>
    <td class="foot-os">rest</td>
  </tr>
</table>
</body>
</html>
