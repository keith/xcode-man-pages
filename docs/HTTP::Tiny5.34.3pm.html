<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    .Nd, .Bf, .Op { display: inline; }
    .Pa, .Ad { font-style: italic; }
    .Ms { font-weight: bold; }
    .Bl-diag > dt { font-weight: bold; }
    code.Nm, .Fl, .Cm, .Ic, code.In, .Fd, .Fn, .Cd { font-weight: bold;
      font-family: inherit; }
  </style>
  <title>HTTP::Tiny(3pm)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">HTTP::Tiny(3pm)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">HTTP::Tiny(3pm)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">HTTP::Tiny - A small, simple, correct HTTP/1.1 client</p>
</section>
<section class="Sh">
<h1 class="Sh" id="VERSION"><a class="permalink" href="#VERSION">VERSION</a></h1>
<p class="Pp">version 0.076</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>    use HTTP::Tiny;
    my $response = HTTP::Tiny-&gt;new-&gt;get('http://example.com/');
    die &quot;Failed!\n&quot; unless $response-&gt;{success};
    print &quot;$response-&gt;{status} $response-&gt;{reason}\n&quot;;
    while (my ($k, $v) = each %{$response-&gt;{headers}}) {
        for (ref $v eq 'ARRAY' ? @$v : $v) {
            print &quot;$k: $_\n&quot;;
        }
    }
    print $response-&gt;{content} if length $response-&gt;{content};
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">This is a very simple HTTP/1.1 client, designed for doing simple
    requests without the overhead of a large framework like LWP::UserAgent.</p>
<p class="Pp">It is more correct and more complete than HTTP::Lite. It supports
    proxies and redirection. It also correctly resumes after EINTR.</p>
<p class="Pp">If IO::Socket::IP 0.25 or later is installed, HTTP::Tiny will use
    it instead of IO::Socket::INET for transparent support for both IPv4 and
    IPv6.</p>
<p class="Pp">Cookie support requires HTTP::CookieJar or an equivalent
  class.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="METHODS"><a class="permalink" href="#METHODS">METHODS</a></h1>
<section class="Ss">
<h2 class="Ss" id="new"><a class="permalink" href="#new">new</a></h2>
<pre>    $http = HTTP::Tiny-&gt;new( %attributes );
</pre>
<p class="Pp">This constructor returns a new HTTP::Tiny object. Valid attributes
    include:</p>
<ul class="Bl-bullet">
  <li><span class="Li">&quot;agent&quot;</span> X A user-agent string (defaults
      to 'HTTP-Tiny/$VERSION'). If <span class="Li">&quot;agent&quot;</span> X
      ends in a space character, the default user-agent string is appended.</li>
  <li><span class="Li">&quot;cookie_jar&quot;</span> X An instance of
      HTTP::CookieJar X or equivalent class that supports the
      <span class="Li">&quot;add&quot;</span> and
      <span class="Li">&quot;cookie_header&quot;</span> methods</li>
  <li><span class="Li">&quot;default_headers&quot;</span> X A hashref of default
      headers to apply to requests</li>
  <li><span class="Li">&quot;local_address&quot;</span> X The local IP address
      to bind to</li>
  <li><span class="Li">&quot;keep_alive&quot;</span> X Whether to reuse the last
      connection (if for the same scheme, host and port) (defaults to 1)</li>
  <li><span class="Li">&quot;max_redirect&quot;</span> X Maximum number of
      redirects allowed (defaults to 5)</li>
  <li><span class="Li">&quot;max_size&quot;</span> X Maximum response size in
      bytes (only when not using a data callback). If defined, responses larger
      than this will return an exception.</li>
  <li><span class="Li">&quot;http_proxy&quot;</span> X URL of a proxy server to
      use for HTTP connections (default is
      <span class="Li">$ENV{http_proxy}</span> X if set)</li>
  <li><span class="Li">&quot;https_proxy&quot;</span> X URL of a proxy server to
      use for HTTPS connections (default is
      <span class="Li">$ENV{https_proxy}</span> X if set)</li>
  <li><span class="Li">&quot;proxy&quot;</span> X URL of a generic proxy server
      for both HTTP and HTTPS connections (default is
      <span class="Li">$ENV{all_proxy}</span> X if set)</li>
  <li><span class="Li">&quot;no_proxy&quot;</span> X List of domain suffixes
      that should not be proxied. Must be a comma-separated string or an array
      reference. (default is <span class="Li">$ENV{no_proxy}</span> X)</li>
  <li><span class="Li">&quot;timeout&quot;</span> X Request timeout in seconds
      (default is 60) If a socket open, read or write takes longer than the
      timeout, an exception is thrown.</li>
  <li><span class="Li">&quot;verify_SSL&quot;</span> X A boolean that indicates
      whether to validate the SSL certificate of an
      <span class="Li">&quot;https&quot;</span> X connection (default is
    false)</li>
  <li><span class="Li">&quot;SSL_options&quot;</span> X A hashref of
      <span class="Li">&quot;SSL_*&quot;</span> X options to pass through to
      IO::Socket::SSL</li>
</ul>
<p class="Pp">Passing an explicit <span class="Li">&quot;undef&quot;</span> for
    <span class="Li">&quot;proxy&quot;</span>,
    <span class="Li">&quot;http_proxy&quot;</span> or
    <span class="Li">&quot;https_proxy&quot;</span> will prevent getting the
    corresponding proxies from the environment.</p>
<p class="Pp">Exceptions from <span class="Li">&quot;max_size&quot;</span>,
    <span class="Li">&quot;timeout&quot;</span> or other errors will result in a
    pseudo-HTTP status code of 599 and a reason of &quot;Internal
    Exception&quot;. The content field in the response will contain the text of
    the exception.</p>
<p class="Pp">The <span class="Li">&quot;keep_alive&quot;</span> parameter
    enables a persistent connection, but only to a single destination scheme,
    host and port. Also, if any connection-relevant attributes are modified, or
    if the process ID or thread ID change, the persistent connection will be
    dropped. If you want persistent connections across multiple destinations,
    use multiple HTTP::Tiny objects.</p>
<p class="Pp">See &quot;SSL SUPPORT&quot; for more on the
    <span class="Li">&quot;verify_SSL&quot;</span> and
    <span class="Li">&quot;SSL_options&quot;</span> attributes.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="get_head_put_post_delete"><a class="permalink" href="#get_head_put_post_delete">get|head|put|post|delete</a></h2>
<pre>    $response = $http-&gt;get($url);
    $response = $http-&gt;get($url, \%options);
    $response = $http-&gt;head($url);
</pre>
<p class="Pp">These methods are shorthand for calling
    <span class="Li">&quot;request()&quot;</span> for the given method. The URL
    must have unsafe characters escaped and international domain names encoded.
    See <span class="Li">&quot;request()&quot;</span> for valid options and a
    description of the response.</p>
<p class="Pp">The <span class="Li">&quot;success&quot;</span> field of the
    response will be true if the status code is 2XX.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="post_form"><a class="permalink" href="#post_form">post_form</a></h2>
<pre>    $response = $http-&gt;post_form($url, $form_data);
    $response = $http-&gt;post_form($url, $form_data, \%options);
</pre>
<p class="Pp">This method executes a <span class="Li">&quot;POST&quot;</span>
    request and sends the key/value pairs from a form data hash or array
    reference to the given URL with a
    <span class="Li">&quot;content-type&quot;</span> of
    <span class="Li">&quot;application/x-www-form-urlencoded&quot;</span>. If
    data is provided as an array reference, the order is preserved; if provided
    as a hash reference, the terms are sorted on key and value for consistency.
    See documentation for the
    <span class="Li">&quot;www_form_urlencode&quot;</span> method for details on
    the encoding.</p>
<p class="Pp">The URL must have unsafe characters escaped and international
    domain names encoded. See <span class="Li">&quot;request()&quot;</span> for
    valid options and a description of the response. Any
    <span class="Li">&quot;content-type&quot;</span> header or content in the
    options hashref will be ignored.</p>
<p class="Pp">The <span class="Li">&quot;success&quot;</span> field of the
    response will be true if the status code is 2XX.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="mirror"><a class="permalink" href="#mirror">mirror</a></h2>
<pre>    $response = $http-&gt;mirror($url, $file, \%options)
    if ( $response-&gt;{success} ) {
        print &quot;$file is up to date\n&quot;;
    }
</pre>
<p class="Pp">Executes a <span class="Li">&quot;GET&quot;</span> request for the
    URL and saves the response body to the file name provided. The URL must have
    unsafe characters escaped and international domain names encoded. If the
    file already exists, the request will include an
    <span class="Li">&quot;If-Modified-Since&quot;</span> header with the
    modification timestamp of the file. You may specify a different
    <span class="Li">&quot;If-Modified-Since&quot;</span> header yourself in the
    <span class="Li">&quot;$options-&gt;{headers}&quot;</span> hash.</p>
<p class="Pp">The <span class="Li">&quot;success&quot;</span> field of the
    response will be true if the status code is 2XX or if the status code is 304
    (unmodified).</p>
<p class="Pp">If the file was modified and the server response includes a
    properly formatted <span class="Li">&quot;Last-Modified&quot;</span> header,
    the file modification time will be updated accordingly.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="request"><a class="permalink" href="#request">request</a></h2>
<pre>    $response = $http-&gt;request($method, $url);
    $response = $http-&gt;request($method, $url, \%options);
</pre>
<p class="Pp">Executes an HTTP request of the given method type ('GET', 'HEAD',
    'POST', 'PUT', etc.) on the given URL. The URL must have unsafe characters
    escaped and international domain names encoded.</p>
<p class="Pp"><b>NOTE</b>: Method names are <b>case-sensitive</b> per the
    HTTP/1.1 specification. Don't use <span class="Li">&quot;get&quot;</span>
    when you really want <span class="Li">&quot;GET&quot;</span>. See
    LIMITATIONS for how this applies to redirection.</p>
<p class="Pp">If the URL includes a &quot;user:password&quot; stanza, they will
    be used for Basic-style authorization headers. (Authorization headers will
    not be included in a redirected request.) For example:</p>
<p class="Pp"></p>
<pre>    $http-&gt;request('GET', 'http://Aladdin:open sesame@example.com/');
</pre>
<p class="Pp">If the &quot;user:password&quot; stanza contains reserved
    characters, they must be percent-escaped:</p>
<p class="Pp"></p>
<pre>    $http-&gt;request('GET', 'http://john%40example.com:password@example.com/');
</pre>
<p class="Pp">A hashref of options may be appended to modify the request.</p>
<p class="Pp">Valid options are:</p>
<ul class="Bl-bullet">
  <li><span class="Li">&quot;headers&quot;</span> X A hashref containing headers
      to include with the request. If the value for a header is an array
      reference, the header will be output multiple times with each value in the
      array. These headers over-write any default headers.</li>
  <li><span class="Li">&quot;content&quot;</span> X A scalar to include as the
      body of the request OR a code reference that will be called iteratively to
      produce the body of the request</li>
  <li><span class="Li">&quot;trailer_callback&quot;</span> X A code reference
      that will be called if it exists to provide a hashref of trailing headers
      (only used with chunked transfer-encoding)</li>
  <li><span class="Li">&quot;data_callback&quot;</span> X A code reference that
      will be called for each chunks of the response body received.</li>
  <li><span class="Li">&quot;peer&quot;</span> X Override host resolution and
      force all connections to go only to a specific peer address, regardless of
      the URL of the request. This will include any redirections! This options
      should be used with extreme caution (e.g. debugging or very special
      circumstances). It can be given as either a scalar or a code reference
      that will receive the hostname and whose response will be taken as the
      address.</li>
</ul>
<p class="Pp">The <span class="Li">&quot;Host&quot;</span> header is generated
    from the URL in accordance with RFC 2616. It is a fatal error to specify
    <span class="Li">&quot;Host&quot;</span> in the
    <span class="Li">&quot;headers&quot;</span> option. Other headers may be
    ignored or overwritten if necessary for transport compliance.</p>
<p class="Pp">If the <span class="Li">&quot;content&quot;</span> option is a
    code reference, it will be called iteratively to provide the content body of
    the request. It should return the empty string or undef when the iterator is
    exhausted.</p>
<p class="Pp">If the <span class="Li">&quot;content&quot;</span> option is the
    empty string, no <span class="Li">&quot;content-type&quot;</span> or
    <span class="Li">&quot;content-length&quot;</span> headers will be
    generated.</p>
<p class="Pp">If the <span class="Li">&quot;data_callback&quot;</span> option is
    provided, it will be called iteratively until the entire response body is
    received. The first argument will be a string containing a chunk of the
    response body, the second argument will be the in-progress response hash
    reference, as described below. (This allows customizing the action of the
    callback based on the <span class="Li">&quot;status&quot;</span> or
    <span class="Li">&quot;headers&quot;</span> received prior to the content
    body.)</p>
<p class="Pp">The <span class="Li">&quot;request&quot;</span> method returns a
    hashref containing the response. The hashref will have the following
  keys:</p>
<ul class="Bl-bullet">
  <li><span class="Li">&quot;success&quot;</span> X Boolean indicating whether
      the operation returned a 2XX status code</li>
  <li><span class="Li">&quot;url&quot;</span> X URL that provided the response.
      This is the URL of the request unless there were redirections, in which
      case it is the last URL queried in a redirection chain</li>
  <li><span class="Li">&quot;status&quot;</span> X The HTTP status code of the
      response</li>
  <li><span class="Li">&quot;reason&quot;</span> X The response phrase returned
      by the server</li>
  <li><span class="Li">&quot;content&quot;</span> X The body of the response. If
      the response does not have any content or if a data callback is provided
      to consume the response body, this will be the empty string</li>
  <li><span class="Li">&quot;headers&quot;</span> X A hashref of header fields.
      All header field names will be normalized to be lower case. If a header is
      repeated, the value will be an arrayref; it will otherwise be a scalar
      string containing the value</li>
  <li><span class="Li">&quot;protocol&quot;</span> - If this field exists, it is
      the protocol of the response such as HTTP/1.0 or HTTP/1.1</li>
  <li><span class="Li">&quot;redirects&quot;</span> If this field exists, it is
      an arrayref of response hash references from redirects in the same order
      that redirections occurred. If it does not exist, then no redirections
      occurred.</li>
</ul>
<p class="Pp">On an exception during the execution of the request, the
    <span class="Li">&quot;status&quot;</span> field will contain 599, and the
    <span class="Li">&quot;content&quot;</span> field will contain the text of
    the exception.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="www_form_urlencode"><a class="permalink" href="#www_form_urlencode">www_form_urlencode</a></h2>
<pre>    $params = $http-&gt;www_form_urlencode( $data );
    $response = $http-&gt;get(&quot;http://example.com/query?$params&quot;);
</pre>
<p class="Pp">This method converts the key/value pairs from a data hash or array
    reference into a <span class="Li">&quot;x-www-form-urlencoded&quot;</span>
    string. The keys and values from the data reference will be UTF-8 encoded
    and escaped per RFC 3986. If a value is an array reference, the key will be
    repeated with each of the values of the array reference. If data is provided
    as a hash reference, the key/value pairs in the resulting string will be
    sorted by key and value for consistent ordering.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="can_ssl"><a class="permalink" href="#can_ssl">can_ssl</a></h2>
<pre>    $ok         = HTTP::Tiny-&gt;can_ssl;
    ($ok, $why) = HTTP::Tiny-&gt;can_ssl;
    ($ok, $why) = $http-&gt;can_ssl;
</pre>
<p class="Pp">Indicates if SSL support is available. When called as a class
    object, it checks for the correct version of Net::SSLeay and
    IO::Socket::SSL. When called as an object methods, if
    <span class="Li">&quot;SSL_verify&quot;</span> is true or if
    <span class="Li">&quot;SSL_verify_mode&quot;</span> is set in
    <span class="Li">&quot;SSL_options&quot;</span>, it checks that a CA file is
    available.</p>
<p class="Pp">In scalar context, returns a boolean indicating if SSL is
    available. In list context, returns the boolean and a (possibly multi-line)
    string of errors indicating why SSL isn't available.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="connected"><a class="permalink" href="#connected">connected</a></h2>
<pre>    $host = $http-&gt;connected;
    ($host, $port) = $http-&gt;connected;
</pre>
<p class="Pp">Indicates if a connection to a peer is being kept alive, per the
    <span class="Li">&quot;keep_alive&quot;</span> option.</p>
<p class="Pp">In scalar context, returns the peer host and port, joined with a
    colon, or <span class="Li">&quot;undef&quot;</span> (if no peer is
    connected). In list context, returns the peer host and port or an empty list
    (if no peer is connected).</p>
<p class="Pp"><b>Note</b>: This method cannot reliably be used to discover
    whether the remote host has closed its end of the socket.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="SSL_SUPPORT"><a class="permalink" href="#SSL_SUPPORT">SSL
  SUPPORT</a></h1>
<p class="Pp">Direct <span class="Li">&quot;https&quot;</span> connections are
    supported only if IO::Socket::SSL 1.56 or greater and Net::SSLeay 1.49 or
    greater are installed. An exception will be thrown if new enough versions of
    these modules are not installed or if the SSL encryption fails. You can also
    use <span class="Li">&quot;HTTP::Tiny::can_ssl()&quot;</span> utility
    function that returns boolean to see if the required modules are
  installed.</p>
<p class="Pp">An <span class="Li">&quot;https&quot;</span> connection may be
    made via an <span class="Li">&quot;http&quot;</span> proxy that supports the
    CONNECT command (i.e. RFC 2817). You may not proxy
    <span class="Li">&quot;https&quot;</span> via a proxy that itself requires
    <span class="Li">&quot;https&quot;</span> to communicate.</p>
<p class="Pp">SSL provides two distinct capabilities:</p>
<ul class="Bl-bullet">
  <li>Encrypted communication channel</li>
  <li>Verification of server identity</li>
</ul>
<p class="Pp"><b>By default, HTTP::Tiny does not verify server identity</b>.</p>
<p class="Pp">Server identity verification is controversial and potentially
    tricky because it depends on a (usually paid) third-party Certificate
    Authority (CA) trust model to validate a certificate as legitimate. This
    discriminates against servers with self-signed certificates or certificates
    signed by free, community-driven CA's such as CAcert.org
    &lt;http://cacert.org&gt;.</p>
<p class="Pp">By default, HTTP::Tiny does not make any assumptions about your
    trust model, threat level or risk tolerance. It just aims to give you an
    encrypted channel when you need one.</p>
<p class="Pp">Setting the <span class="Li">&quot;verify_SSL&quot;</span>
    attribute to a true value will make HTTP::Tiny verify that an SSL connection
    has a valid SSL certificate corresponding to the host name of the connection
    and that the SSL certificate has been verified by a CA. Assuming you trust
    the CA, this will protect against a man-in-the-middle attack
    &lt;http://en.wikipedia.org/wiki/Man-in-the-middle_attack&gt;. If you are
    concerned about security, you should enable this option.</p>
<p class="Pp">Certificate verification requires a file containing trusted CA
    certificates.</p>
<p class="Pp">If the environment variable
    <span class="Li">&quot;SSL_CERT_FILE&quot;</span> is present, HTTP::Tiny
    will try to find a CA certificate file in that location.</p>
<p class="Pp">If the Mozilla::CA module is installed, HTTP::Tiny will use the CA
    file included with it as a source of trusted CA's. (This means you trust
    Mozilla, the author of Mozilla::CA, the CPAN mirror where you got
    Mozilla::CA, the toolchain used to install it, and your operating system
    security, right?)</p>
<p class="Pp">If that module is not available, then HTTP::Tiny will search
    several system-specific default locations for a CA certificate file:</p>
<ul class="Bl-bullet">
  <li>/etc/ssl/certs/ca-certificates.crt</li>
  <li>/etc/pki/tls/certs/ca-bundle.crt</li>
  <li>/etc/ssl/ca-bundle.pem</li>
</ul>
<p class="Pp">An exception will be raised if
    <span class="Li">&quot;verify_SSL&quot;</span> is true and no CA certificate
    file is available.</p>
<p class="Pp">If you desire complete control over SSL connections, the
    <span class="Li">&quot;SSL_options&quot;</span> attribute lets you provide a
    hash reference that will be passed through to
    <span class="Li">&quot;IO::Socket::SSL::start_SSL()&quot;</span>, overriding
    any options set by HTTP::Tiny. For example, to provide your own trusted CA
    file:</p>
<p class="Pp"></p>
<pre>    SSL_options =&gt; {
        SSL_ca_file =&gt; $file_path,
    }
</pre>
<p class="Pp">The <span class="Li">&quot;SSL_options&quot;</span> attribute
    could also be used for such things as providing a client certificate for
    authentication to a server or controlling the choice of cipher used for the
    SSL connection. See IO::Socket::SSL documentation for details.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="PROXY_SUPPORT"><a class="permalink" href="#PROXY_SUPPORT">PROXY
  SUPPORT</a></h1>
<p class="Pp">HTTP::Tiny can proxy both <span class="Li">&quot;http&quot;</span>
    and <span class="Li">&quot;https&quot;</span> requests. Only Basic proxy
    authorization is supported and it must be provided as part of the proxy URL:
    <span class="Li">&quot;http://user:pass@proxy.example.com/&quot;</span>.</p>
<p class="Pp">HTTP::Tiny supports the following proxy environment variables:</p>
<ul class="Bl-bullet">
  <li>http_proxy or HTTP_PROXY</li>
  <li>https_proxy or HTTPS_PROXY</li>
  <li>all_proxy or ALL_PROXY</li>
</ul>
<p class="Pp">If the <span class="Li">&quot;REQUEST_METHOD&quot;</span>
    environment variable is set, then this might be a CGI process and
    <span class="Li">&quot;HTTP_PROXY&quot;</span> would be set from the
    <span class="Li">&quot;Proxy:&quot;</span> header, which is a security risk.
    If <span class="Li">&quot;REQUEST_METHOD&quot;</span> is set,
    <span class="Li">&quot;HTTP_PROXY&quot;</span> (the upper case variant only)
    is ignored.</p>
<p class="Pp">Tunnelling <span class="Li">&quot;https&quot;</span> over an
    <span class="Li">&quot;http&quot;</span> proxy using the CONNECT method is
    supported. If your proxy uses <span class="Li">&quot;https&quot;</span>
    itself, you can not tunnel <span class="Li">&quot;https&quot;</span> over
    it.</p>
<p class="Pp">Be warned that proxying an
    <span class="Li">&quot;https&quot;</span> connection opens you to the risk
    of a man-in-the-middle attack by the proxy server.</p>
<p class="Pp">The <span class="Li">&quot;no_proxy&quot;</span> environment
    variable is supported in the format of a comma-separated list of domain
    extensions proxy should not be used for.</p>
<p class="Pp">Proxy arguments passed to <span class="Li">&quot;new&quot;</span>
    will override their corresponding environment variables.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="LIMITATIONS"><a class="permalink" href="#LIMITATIONS">LIMITATIONS</a></h1>
<p class="Pp">HTTP::Tiny is <i>conditionally compliant</i> with the HTTP/1.1
    specifications &lt;http://www.w3.org/Protocols/&gt;:</p>
<ul class="Bl-bullet">
  <li>&quot;Message Syntax and Routing&quot; [RFC7230]</li>
  <li>&quot;Semantics and Content&quot; [RFC7231]</li>
  <li>&quot;Conditional Requests&quot; [RFC7232]</li>
  <li>&quot;Range Requests&quot; [RFC7233]</li>
  <li>&quot;Caching&quot; [RFC7234]</li>
  <li>&quot;Authentication&quot; [RFC7235]</li>
</ul>
<p class="Pp">It attempts to meet all &quot;MUST&quot; requirements of the
    specification, but does not implement all &quot;SHOULD&quot; requirements.
    (Note: it was developed against the earlier RFC 2616 specification and may
    not yet meet the revised RFC 7230-7235 spec.)</p>
<p class="Pp">Some particular limitations of note include:</p>
<ul class="Bl-bullet">
  <li>HTTP::Tiny focuses on correct transport. Users are responsible for
      ensuring that user-defined headers and content are compliant with the
      HTTP/1.1 specification.</li>
  <li>Users must ensure that URLs are properly escaped for unsafe characters and
      that international domain names are properly encoded to ASCII. See
      URI::Escape, URI::_punycode and Net::IDN::Encode.</li>
  <li>Redirection is very strict against the specification. Redirection is only
      automatic for response codes 301, 302, 307 and 308 if the request method
      is 'GET' or 'HEAD'. Response code 303 is always converted into a 'GET'
      redirection, as mandated by the specification. There is no automatic
      support for status 305 (&quot;Use proxy&quot;) redirections.</li>
  <li>There is no provision for delaying a request body using an
      <span class="Li">&quot;Expect&quot;</span> header. Unexpected
      <span class="Li">&quot;1XX&quot;</span> responses are silently ignored as
      per the specification.</li>
  <li>Only 'chunked' <span class="Li">&quot;Transfer-Encoding&quot;</span> is
      supported.</li>
  <li>There is no support for a Request-URI of '*' for the 'OPTIONS'
    request.</li>
  <li>Headers mentioned in the RFCs and some other, well-known headers are
      generated with their canonical case. Other headers are sent in the case
      provided by the user. Except for control headers (which are sent first),
      headers are sent in arbitrary order.</li>
</ul>
<p class="Pp">Despite the limitations listed above, HTTP::Tiny is considered
    feature-complete. New feature requests should be directed to
  HTTP::Tiny::UA.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<ul class="Bl-bullet">
  <li>HTTP::Tiny::UA - Higher level UA features for HTTP::Tiny</li>
  <li>HTTP::Thin - HTTP::Tiny wrapper with HTTP::Request/HTTP::Response
      compatibility</li>
  <li>HTTP::Tiny::Mech - Wrap WWW::Mechanize instance in HTTP::Tiny compatible
      interface</li>
  <li>IO::Socket::IP - Required for IPv6 support</li>
  <li>IO::Socket::SSL - Required for SSL support</li>
  <li>LWP::UserAgent - If HTTP::Tiny isn't enough for you, this is the
      &quot;standard&quot; way to do things</li>
  <li>Mozilla::CA - Required if you want to validate SSL certificates</li>
  <li>Net::SSLeay - Required for SSL support</li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="SUPPORT"><a class="permalink" href="#SUPPORT">SUPPORT</a></h1>
<section class="Ss">
<h2 class="Ss" id="Bugs_/_Feature_Requests"><a class="permalink" href="#Bugs_/_Feature_Requests">Bugs
  / Feature Requests</a></h2>
<p class="Pp">Please report any bugs or feature requests through the issue
    tracker at &lt;https://github.com/chansen/p5-http-tiny/issues&gt;. You will
    be notified automatically of any progress on your issue.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Source_Code"><a class="permalink" href="#Source_Code">Source
  Code</a></h2>
<p class="Pp">This is open source software. The code repository is available for
    public review and contribution under the terms of the license.</p>
<p class="Pp">&lt;https://github.com/chansen/p5-http-tiny&gt;</p>
<p class="Pp"></p>
<pre>  git clone https://github.com/chansen/p5-http-tiny.git
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHORS"><a class="permalink" href="#AUTHORS">AUTHORS</a></h1>
<ul class="Bl-bullet">
  <li>Christian Hansen &lt;chansen@cpan.org&gt;</li>
  <li>David Golden &lt;dagolden@cpan.org&gt;</li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="CONTRIBUTORS"><a class="permalink" href="#CONTRIBUTORS">CONTRIBUTORS</a></h1>
<ul class="Bl-bullet">
  <li>Alan Gardner &lt;gardner@pythian.com&gt;</li>
  <li>Alessandro Ghedini &lt;al3xbio@gmail.com&gt;</li>
  <li>A. Sinan Unur &lt;nanis@cpan.org&gt;</li>
  <li>Brad Gilbert &lt;bgills@cpan.org&gt;</li>
  <li>brian m. carlson &lt;sandals@crustytoothpaste.net&gt;</li>
  <li>Chris Nehren &lt;apeiron@cpan.org&gt;</li>
  <li>Chris Weyl &lt;cweyl@alumni.drew.edu&gt;</li>
  <li>Claes Jakobsson &lt;claes@surfar.nu&gt;</li>
  <li>Clinton Gormley &lt;clint@traveljury.com&gt;</li>
  <li>Craig A. Berry &lt;craigberry@mac.com&gt;</li>
  <li>Craig Berry &lt;cberry@cpan.org&gt;</li>
  <li>David Golden &lt;xdg@xdg.me&gt;</li>
  <li>David Mitchell &lt;davem@iabyn.com&gt;</li>
  <li>Dean Pearce &lt;pearce@pythian.com&gt;</li>
  <li>Edward Zborowski &lt;ed@rubensteintech.com&gt;</li>
  <li>Felipe Gasper &lt;felipe@felipegasper.com&gt;</li>
  <li>James Raspass &lt;jraspass@gmail.com&gt;</li>
  <li>Jeremy Mates &lt;jmates@cpan.org&gt;</li>
  <li>Jess Robinson &lt;castaway@desert-island.me.uk&gt;</li>
  <li>Karen Etheridge &lt;ether@cpan.org&gt;</li>
  <li>Lukas Eklund &lt;leklund@gmail.com&gt;</li>
  <li>Martin J. Evans &lt;mjegh@ntlworld.com&gt;</li>
  <li>Martin-Louis Bright &lt;mlbright@gmail.com&gt;</li>
  <li>Mike Doherty &lt;doherty@cpan.org&gt;</li>
  <li>Nicolas Rochelemagne &lt;rochelemagne@cpanel.net&gt;</li>
  <li>Olaf Alders &lt;olaf@wundersolutions.com&gt;</li>
  <li>Olivier Mengue &lt;dolmen@cpan.org&gt;</li>
  <li>Petr PisaX &lt;ppisar@redhat.com&gt;</li>
  <li>Serguei Trouchelle &lt;stro@cpan.org&gt;</li>
  <li>Shoichi Kaji &lt;skaji@cpan.org&gt;</li>
  <li>SkyMarshal &lt;skymarshal1729@gmail.com&gt;</li>
  <li>Soeren Kornetzki &lt;soeren.kornetzki@delti.com&gt;</li>
  <li>Steve Grazzini &lt;steve.grazzini@grantstreet.com&gt;</li>
  <li>Syohei YOSHIDA &lt;syohex@gmail.com&gt;</li>
  <li>Tatsuhiko Miyagawa &lt;miyagawa@bulknews.net&gt;</li>
  <li>Tom Hukins &lt;tom@eborcom.com&gt;</li>
  <li>Tony Cook &lt;tony@develop-help.com&gt;</li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT_AND_LICENSE"><a class="permalink" href="#COPYRIGHT_AND_LICENSE">COPYRIGHT
  AND LICENSE</a></h1>
<p class="Pp">This software is copyright (c) 2018 by Christian Hansen.</p>
<p class="Pp">This is free software; you can redistribute it and/or modify it
    under the same terms as the Perl 5 programming language system itself.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2022-02-19</td>
    <td class="foot-os">perl v5.34.1</td>
  </tr>
</table>
</body>
</html>
