<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.10 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>ExtUtils::Constant::Base(3pm)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">ExtUtils::Constant::Base(3pm)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">ExtUtils::Constant::Base(3pm)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
ExtUtils::Constant::Base - base class for ExtUtils::Constant objects
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<span class="Li"></span>
<pre>
    require ExtUtils::Constant::Base;
    @ISA = 'ExtUtils::Constant::Base';
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
ExtUtils::Constant::Base provides a base implementation of methods to generate C
  code to give fast constant value lookup by named string. Currently it's mostly
  used ExtUtils::Constant::XS, which generates the lookup code for the
  <b>constant()</b> subroutine found in many XS modules.
</section>
<section class="Sh">
<h1 class="Sh" id="USAGE"><a class="permalink" href="#USAGE">USAGE</a></h1>
ExtUtils::Constant::Base exports no subroutines. The following methods are
  available
<dl class="Bl-tag">
  <dt>header</dt>
  <dd>A method returning a scalar containing definitions needed, typically for a
      C header file.</dd>
  <dt>memEQ_clause args_hashref</dt>
  <dd>A method to return a suitable C <span class="Li">&quot;if&quot;</span>
      statement to check whether <i>name</i> is equal to the C variable
      <span class="Li">&quot;name&quot;</span>. If <i>checked_at</i> is defined,
      then it is used to avoid <span class="Li">&quot;memEQ&quot;</span> for
      short names, or to generate a comment to highlight the position of the
      character in the <span class="Li">&quot;switch&quot;</span> statement.
    <p class="Pp">If i&lt;checked_at&gt; is a reference to a scalar, then
        instead it gives the characters pre-checked at the beginning, (and the
        number of chars by which the C variable name has been advanced. These
        need to be chopped from the front of <i>name</i>).</p>
  </dd>
  <dt>dump_names arg_hashref, ITEM...</dt>
  <dd>An internal function to generate the embedded perl code that will
      regenerate the constant subroutines. <i>default_type</i>, <i>types</i> and
      <i>ITEM</i>s are the same as for C_constant. <i>indent</i> is treated as
      number of spaces to indent by. If
      <span class="Li">&quot;declare_types&quot;</span> is true a
      <span class="Li">$types</span> is always declared in the perl code
      generated, if defined and false never declared, and if undefined
      <span class="Li">$types</span> is only declared if the values in
      <i>types</i> as passed in cannot be inferred from <i>default_types</i> and
      the <i>ITEM</i>s.</dd>
  <dt>assign arg_hashref, VALUE...</dt>
  <dd>A method to return a suitable assignment clause. If <i>type</i> is
      aggregate (eg <i>PVN</i> expects both pointer and length) then there
      should be multiple <i>VALUE</i>s for the components. <i>pre</i> and
      <i>post</i> if defined give snippets of C code to proceed and follow the
      assignment. <i>pre</i> will be at the start of a block, so variables may
      be defined in it.</dd>
  <dt>return_clause arg_hashref, ITEM</dt>
  <dd>A method to return a suitable <span class="Li">&quot;#ifdef&quot;</span>
      clause. <i>ITEM</i> is a hashref (as passed to
      <span class="Li">&quot;C_constant&quot;</span> and
      <span class="Li">&quot;match_clause&quot;</span>. <i>indent</i> is the
      number of spaces to indent, defaulting to 6.</dd>
  <dt>switch_clause arg_hashref, NAMELEN, ITEMHASH, ITEM...</dt>
  <dd>An internal method to generate a suitable
      <span class="Li">&quot;switch&quot;</span> clause, called by
      <span class="Li">&quot;C_constant&quot;</span> <i>ITEM</i>s are in the
      hash ref format as given in the description of
      <span class="Li">&quot;C_constant&quot;</span>, and must all have the
      names of the same length, given by <i>NAMELEN</i>. <i>ITEMHASH</i> is a
      reference to a hash, keyed by name, values being the hashrefs in the
      <i>ITEM</i> list. (No parameters are modified, and there can be keys in
      the <i>ITEMHASH</i> that are not in the list of <i>ITEM</i>s without
      causing problems - the hash is passed in to save generating it afresh for
      each call).</dd>
  <dt>params WHAT</dt>
  <dd>An &quot;internal&quot; method, subject to change, currently called to
      allow an overriding class to cache information that will then be passed
      into all the <span class="Li">&quot;*param*&quot;</span> calls. (Yes,
      having to read the source to make sense of this is considered a known
      bug). <i>WHAT</i> is be a hashref of types the constant function will
      return. In ExtUtils::Constant::XS this method is used to returns a hashref
      keyed IV NV PV SV to show which combination of pointers will be needed in
      the C argument list generated by C_constant_other_params_definition and
      C_constant_other_params</dd>
  <dt>dogfood arg_hashref, ITEM...</dt>
  <dd>An internal function to generate the embedded perl code that will
      regenerate the constant subroutines. Parameters are the same as for
      C_constant.
    <p class="Pp">Currently the base class does nothing and returns an empty
        string.</p>
  </dd>
  <dt>normalise_items args, default_type, seen_types, seen_items, ITEM...</dt>
  <dd>Convert the items to a normalised form. For 8 bit and Unicode values
      converts the item to an array of 1 or 2 items, both 8 bit and UTF-8
      encoded.</dd>
  <dt>C_constant arg_hashref, ITEM...</dt>
  <dd>A function that returns a <b>list</b> of C subroutine definitions that
      return the value and type of constants when passed the name by the XS
      wrapper. <i>ITEM...</i> gives a list of constant names. Each can either be
      a string, which is taken as a C macro name, or a reference to a hash with
      the following keys</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>name</dt>
  <dd>The name of the constant, as seen by the perl code.</dd>
  <dt>type</dt>
  <dd>The type of the constant (<i>IV</i>, <i>NV</i> etc)</dd>
  <dt>value</dt>
  <dd>A C expression for the value of the constant, or a list of C expressions
      if the type is aggregate. This defaults to the <i>name</i> if not
    given.</dd>
  <dt>macro</dt>
  <dd>The C pre-processor macro to use in the
      <span class="Li">&quot;#ifdef&quot;</span>. This defaults to the
      <i>name</i>, and is mainly used if <i>value</i> is an
      <span class="Li">&quot;enum&quot;</span>. If a reference an array is
      passed then the first element is used in place of the
      <span class="Li">&quot;#ifdef&quot;</span> line, and the second element in
      place of the <span class="Li">&quot;#endif&quot;</span>. This allows
      pre-processor constructions such as
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    #if defined (foo)
    #if !defined (bar)
    ...
    #endif
    #endif
    </pre>
    <p class="Pp">to be used to determine if a constant is to be defined.</p>
    <p class="Pp">A &quot;macro&quot; 1 signals that the constant is always
        defined, so the
        <span class="Li">&quot;#if&quot;</span>/<span class="Li">&quot;#endif&quot;</span>
        test is omitted.</p>
  </dd>
  <dt>default</dt>
  <dd>Default value to use (instead of
      <span class="Li">&quot;croak&quot;</span>ing with &quot;your vendor has
      not defined...&quot;) to return if the macro isn't defined. Specify a
      reference to an array with type followed by value(s).</dd>
  <dt>pre</dt>
  <dd>C code to use before the assignment of the value of the constant. This
      allows you to use temporary variables to extract a value from part of a
      <span class="Li">&quot;struct&quot;</span> and return this as
      <i>value</i>. This C code is places at the start of a block, so you can
      declare variables in it.</dd>
  <dt>post</dt>
  <dd>C code to place between the assignment of value (to a temporary) and the
      return from the function. This allows you to clear up anything in
      <i>pre</i>. Rarely needed.</dd>
  <dt>def_pre</dt>
  <dd></dd>
  <dt>def_post</dt>
  <dd>Equivalents of <i>pre</i> and <i>post</i> for the default value.</dd>
  <dt>utf8</dt>
  <dd>Generated internally. Is zero or undefined if name is 7 bit ASCII,
      &quot;no&quot; if the name is 8 bit (and so should only match if
      <b>SvUTF8()</b> is false), &quot;yes&quot; if the name is utf8 encoded.
    <p class="Pp">The internals automatically clone any name with characters
        128-255 but none 256+ (ie one that could be either in bytes or utf8)
        into a second entry which is utf8 encoded.</p>
  </dd>
  <dt>weight</dt>
  <dd>Optional sorting weight for names, to determine the order of linear
      testing when multiple names fall in the same case of a switch clause.
      Higher comes earlier, undefined defaults to zero.</dd>
</dl>
</div>
<div class="Bd-indent">
<p class="Pp">In the argument hashref, <i>package</i> is the name of the
    package, and is only used in comments inside the generated C code.
    <i>subname</i> defaults to <span class="Li">&quot;constant&quot;</span> if
    undefined.</p>
<p class="Pp"><i>default_type</i> is the type returned by
    <span class="Li">&quot;ITEM&quot;</span>s that don't specify their type. It
    defaults to the value of <span class="Li">&quot;default_type()&quot;</span>.
    <i>types</i> should be given either as a comma separated list of types that
    the C subroutine <i>subname</i> will generate or as a reference to a hash.
    <i>default_type</i> will be added to the list if not present, as will any
    types given in the list of <i>ITEM</i>s. The resultant list should be the
    same list of types that <span class="Li">&quot;XS_constant&quot;</span> is
    given. [Otherwise <span class="Li">&quot;XS_constant&quot;</span> and
    <span class="Li">&quot;C_constant&quot;</span> may differ in the number of
    parameters to the constant function. <i>indent</i> is currently unused and
    ignored. In future it may be used to pass in information used to change the
    C indentation style used.] The best way to maintain consistency is to pass
    in a hash reference and let this function update it.</p>
<p class="Pp"><i>breakout</i> governs when child functions of <i>subname</i> are
    generated. If there are <i>breakout</i> or more <i>ITEM</i>s with the same
    length of name, then the code to switch between them is placed into a
    function named <i>subname</i>_<i>len</i>, for example
    <span class="Li">&quot;constant_5&quot;</span> for names 5 characters long.
    The default <i>breakout</i> is 3. A single
    <span class="Li">&quot;ITEM&quot;</span> is always inlined.</p>
</div>
</section>
<section class="Sh">
<h1 class="Sh" id="BUGS"><a class="permalink" href="#BUGS">BUGS</a></h1>
Not everything is documented yet.
<p class="Pp">Probably others.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
Nicholas Clark &lt;nick@ccl4.org&gt; based on the code in
  <span class="Li">&quot;h2xs&quot;</span> by Larry Wall and others
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2018-11-01</td>
    <td class="foot-os">perl v5.28.2</td>
  </tr>
</table>
</body>
</html>
